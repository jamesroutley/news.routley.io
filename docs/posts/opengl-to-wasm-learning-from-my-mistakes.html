<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://uds5501.github.io/mindpalace/2025/03/01/opengl-webgl-porting.html">Original</a>
    <h1>OpenGL to WASM, learning from my mistakes</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
    <div>
      <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    

<p>The last few weeks, OpenGL has caught my eye (frankly, it was a hiring challenge that nerd sniped me). I had 0
experience with OpenGL whatsover and thought that this might be a good time to give graphics a shot! If nothing I‚Äôll at
least revise the
graphics concepts that I‚Äôve long forgotten after my 6th Semester.</p>

<p>However, I should mention that this post is not intended to be a learning guide for OpenGL or WASM, I have attached
resources in the end for the same.
This is supposed to be my journal of sorts regarding all the mistakes I did over the last 10 days.</p>

<h2 id="challenge-specifications">Challenge specifications</h2>

<ul>
  <li>Render 1 Million Spheres.</li>
  <li>Maintain dynamic lighting in the scene.</li>
  <li>Highlighting for each sphere.</li>
  <li>Maintaining 60 FPS.</li>
</ul>

<h2 id="my-approach">My approach</h2>

<p>The specs at which my poor M1 managed to render the spheres was this -</p>

<ol>
  <li>Rendered 10k spheres with instances method.</li>
  <li>Single light source to emulate phong lighting with proper attenuation techniques.</li>
  <li>4 unique texture support (you can add as many as you want).</li>
</ol>

<p>The stress test on this project showed that close to 100k spheres could be rendered locally before it starts cracking. (
Oh, to be GPU poor :(( )
You can check out the source code implementation here (note, it‚Äôs still poorly documented but the building instructions
are there) -</p>



<p>It yielded the following mini demo
<a href="https://www.youtube.com/shorts/R5YZGdQ08io"><img src="https://uds5501.github.io/mindpalace/assets/images/posts/2025-03-01-opengl-webgl-porting/demo-img.png" alt="CPP implementation"/></a></p>

<h2 id="wasm-and-opengl">WASM and OpenGL</h2>

<p>A funny thing happened while I was trying to demo this. The poor laptop decided to malfunction and load half backed
scene with one quarter of the scene gone!
It was at that moment realization hits, maybe it‚Äôs time to port this to the web and not my machine be a blocker for the
demo.</p>

<p><strong>The solution?</strong></p>

<p>Port the entire project to WASM and WebGL. The project was already in C++ and OpenGL, so it was just a matter of finding
the right libraries and tools to port it to the web.
Thankfully, LLM is your friend in conversions while <a href="https://emscripten.org/docs/">emscripten</a> is the tool for this job.</p>

<p>The Iframe below is the demo of the project build specifically for web. (<strong>Note, give it sometime, it will take a few seconds to move away from a brown screen to the actual scene</strong>).</p>

<h2 id="-camera-controls">üéÆ Camera Controls</h2>

<p>To play around with the demo, use these keys -</p>

<table>
  <thead>
    <tr>
      <th>Action</th>
      <th>Key</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Move Forward</strong></td>
      <td><code>W</code></td>
    </tr>
    <tr>
      <td><strong>Move Backward</strong></td>
      <td><code>S</code></td>
    </tr>
    <tr>
      <td><strong>Move Left</strong></td>
      <td><code>A</code></td>
    </tr>
    <tr>
      <td><strong>Move Right</strong></td>
      <td><code>D</code></td>
    </tr>
    <tr>
      <td><strong>Move Up</strong></td>
      <td><code>Space</code></td>
    </tr>
    <tr>
      <td><strong>Move Down</strong></td>
      <td><code>Z</code></td>
    </tr>
    <tr>
      <td><strong>Sprint (Faster Movement)</strong></td>
      <td><code>Left Shift (Hold)</code></td>
    </tr>
    <tr>
      <td><strong>Stop Sprinting</strong></td>
      <td><code>Left Shift (Release)</code></td>
    </tr>
    <tr>
      <td><strong>Look Around</strong></td>
      <td><code>Mouse Left Click + Move Mouse</code></td>
    </tr>
    <tr>
      <td><strong>Unlock Cursor</strong></td>
      <td><code>Mouse Left Click (Release)</code></td>
    </tr>
    <tr>
      <td><strong>Cycle the texture for a sphere</strong></td>
      <td><code>Click on sphere</code></td>
    </tr>
  </tbody>
</table>



<h2 id="mistakes-through-the-process-">Mistakes through the process ü§¶üèæ</h2>

<p>I believe anyone can learn this tech with the presence of resource and LLMs, however, It‚Äôs worth to mention the mistakes
that your
cursor IDE might not be able to figure out after a while of composition to and fro.</p>

<h3 id="mistake-1-weird-flattened-sphere-instead-of-a-round-sphere">Mistake 1: Weird flattened sphere instead of a round sphere.</h3>

<p>VBO and VAO are the bread and butter of OpenGL however they may not always be well documented in the LLMs or the
tutorials.
I was incrementally adding colours, transformations and then textures to
my <a href="https://learnopengl.com/Advanced-OpenGL/Instancing">instanced spheres</a>.
For some reason, the textures were being flattened out like shown in the image.</p>

<p><img src="https://uds5501.github.io/mindpalace/assets/images/posts/2025-03-01-opengl-webgl-porting/flattened-textures.png" alt="flattened-textures.png"/></p>

<p>Before I talk about the culprit, let me explain what goes into rendering an object. There‚Äôs a <strong>VAO (Vertex Array
Object)</strong> that
stores the mapping of the <strong>VBO (Vertex Buffer Object)</strong> to the shader attributes. The VBO stores the vertices, indices
and the texture coordinates. The shader then uses these attributes to render the object.</p>

<p>Your shader (written in <code>glsl</code>) will expect inputs supplied by the VAO. My vertex shader (the one that‚Äôs responsible for
transforming the vertices) looked like this -</p>

<div><div><pre><code><span>#version 330 core
</span><span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>0</span><span>)</span> <span>in</span> <span>vec3</span> <span>aPos</span><span>;</span>
<span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>1</span><span>)</span> <span>in</span> <span>vec3</span> <span>aNormal</span><span>;</span>
<span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>2</span><span>)</span> <span>in</span> <span>vec2</span> <span>aTexCoords</span><span>;</span>
<span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>3</span><span>)</span> <span>in</span> <span>mat4</span> <span>instanceMatrix</span><span>;</span>
<span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>7</span><span>)</span> <span>in</span> <span>vec4</span> <span>instanceColor</span><span>;</span>
<span>layout</span> <span>(</span><span>location</span> <span>=</span> <span>8</span><span>)</span> <span>in</span> <span>int</span> <span>textureIndex</span><span>;</span>

<span>out</span> <span>vec3</span> <span>Normal</span><span>;</span>
<span>out</span> <span>vec3</span> <span>currentPosition</span><span>;</span>
<span>out</span> <span>vec4</span> <span>color</span><span>;</span>
<span>out</span> <span>vec2</span> <span>textCoords</span><span>;</span>
<span>flat</span> <span>out</span> <span>int</span> <span>TexIndex</span><span>;</span> 

<span>uniform</span> <span>mat4</span> <span>camMatrix</span><span>;</span>
<span>uniform</span> <span>mat4</span> <span>model</span><span>;</span>

<span>void</span> <span>main</span><span>()</span>
<span>{</span>
    <span>currentPosition</span> <span>=</span> <span>vec3</span><span>(</span><span>instanceMatrix</span> <span>*</span> <span>vec4</span><span>(</span><span>aPos</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>f</span><span>));</span>
    <span>gl_Position</span> <span>=</span> <span>camMatrix</span> <span>*</span> <span>vec4</span><span>(</span><span>currentPosition</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>);</span>
    <span>Normal</span> <span>=</span> <span>normalize</span><span>(</span><span>aNormal</span><span>);</span>
    <span>color</span> <span>=</span> <span>instanceColor</span><span>;</span>
    <span>TexIndex</span> <span>=</span> <span>textureIndex</span><span>;</span>
    <span>textCoords</span> <span>=</span> <span>aTexCoords</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>It took the following elements as input -</p>

<ol>
  <li>At position 0, the vertex positions.</li>
  <li>At position 1, the normals.</li>
  <li>At position 2, the texture coordinates.</li>
  <li>At position 3, the transformation matrix for the instance of the sphere.</li>
  <li>At position 7, the color of the instance. (why 7? the transformation matrix is <strong>4x4</strong> in size).</li>
  <li>At position 8, the texture index, i.e., which texture needs to be rendered here.</li>
</ol>

<p>Sounds good, now how do i map it? Take a look at the code below.</p>

<div><div><pre><code><span>// src/InstancedSphere.cpp</span>
    <span>shapeVAO</span><span>.</span><span>LinkAttrib</span><span>(</span><span>shapeVBO</span><span>,</span> <span>0</span><span>,</span> <span>3</span><span>,</span> <span>GL_FLOAT</span><span>,</span> <span>8</span> <span>*</span> <span>sizeof</span><span>(</span><span>float</span><span>),</span> <span>(</span><span>void</span> <span>*</span><span>)</span><span>0</span><span>);</span>                   <span>// saved the basic mesh points.</span>
    <span>shapeVAO</span><span>.</span><span>LinkAttrib</span><span>(</span><span>shapeVBO</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>,</span> <span>GL_FLOAT</span><span>,</span> <span>8</span> <span>*</span> <span>sizeof</span><span>(</span><span>float</span><span>),</span> <span>(</span><span>void</span> <span>*</span><span>)(</span><span>3</span> <span>*</span> <span>sizeof</span><span>(</span><span>float</span><span>)));</span> <span>// save the indices from the same shape buffer</span>
    <span>shapeVAO</span><span>.</span><span>LinkAttrib</span><span>(</span><span>shapeVBO</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>GL_FLOAT</span><span>,</span> <span>8</span> <span>*</span> <span>sizeof</span><span>(</span><span>float</span><span>),</span> <span>(</span><span>void</span> <span>*</span><span>)(</span><span>6</span> <span>*</span> <span>sizeof</span><span>(</span><span>float</span><span>)));</span> <span>// save texture coords</span>

    <span>instanceVBO</span> <span>=</span> <span>VBO</span><span>(</span><span>mat4s</span><span>);</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>4</span><span>;</span> <span>i</span><span>++</span><span>)</span>
    <span>{</span>
        <span>shapeVAO</span><span>.</span><span>LinkAttrib</span><span>(</span><span>instanceVBO</span><span>,</span> <span>2</span> <span>+</span> <span>i</span><span>,</span> <span>4</span><span>,</span> <span>GL_FLOAT</span><span>,</span> <span>sizeof</span><span>(</span><span>glm</span><span>::</span><span>mat4</span><span>),</span> <span>(</span><span>void</span> <span>*</span><span>)(</span><span>i</span> <span>*</span> <span>sizeof</span><span>(</span><span>glm</span><span>::</span><span>vec4</span><span>)));</span>
        <span>glVertexAttribDivisor</span><span>(</span><span>2</span> <span>+</span> <span>i</span><span>,</span> <span>1</span><span>);</span> <span>// This tells OpenGL this is per-instance</span>
    <span>}</span>
    <span>colorVBO</span> <span>=</span> <span>VBO</span><span>(</span><span>instanceColors</span><span>);</span>                                              <span>// this should be dynamic</span>
    <span>shapeVAO</span><span>.</span><span>LinkAttrib</span><span>(</span><span>colorVBO</span><span>,</span> <span>6</span><span>,</span> <span>4</span><span>,</span> <span>GL_FLOAT</span><span>,</span> <span>4</span> <span>*</span> <span>sizeof</span><span>(</span><span>float</span><span>),</span> <span>(</span><span>void</span> <span>*</span><span>)</span><span>0</span><span>);</span> <span>// link the indices from the color buffer.</span>
    <span>glVertexAttribDivisor</span><span>(</span><span>6</span><span>,</span> <span>1</span><span>);</span>

    <span>textureVBO</span> <span>=</span> <span>VBO</span><span>(</span><span>instanceTextures</span><span>);</span>
    <span>textureVBO</span><span>.</span><span>Bind</span><span>();</span>
    <span>shapeVAO</span><span>.</span><span>LinkAttrib</span><span>(</span><span>textureVBO</span><span>,</span> <span>7</span><span>,</span> <span>1</span><span>,</span> <span>GL_INT</span><span>,</span> <span>sizeof</span><span>(</span><span>int</span><span>),</span> <span>(</span><span>void</span> <span>*</span><span>)</span><span>0</span><span>);</span> <span>// link texture ids</span>
</code></pre></div></div>

<p>Here I am linking the following:</p>

<ol>
  <li>At position 0, map shape buffer‚Äôs first 3 elements to the shader to act as vertex locations.</li>
  <li>At position 1, map shape buffer‚Äôs next 3 elements to the shader to act as normals.</li>
  <li>At position 2, map shape buffer‚Äôs next 2 elements to the shader to act as texture coordinates.</li>
  <li>At position 2 + i, map the instance buffer‚Äôs <code>i</code>th element to the shader to act as one row of the transformation
matrix, $(i \in [0,3])$.</li>
  <li>At position 6, map the color buffer‚Äôs 4 elements to the shader to act as the color of the instance.</li>
  <li>At position 7, map the texture buffer‚Äôs 1 element to the shader to act as the texture index.</li>
</ol>

<p><strong>Spotted the error?</strong></p>

<p>I overrode the texture coordinate with the row of transformation matrix :) the correct mapping should‚Äôve been -</p>

<div><div><pre><code>    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>4</span><span>;</span> <span>i</span><span>++</span><span>)</span>
    <span>{</span>
        <span>shapeVAO</span><span>.</span><span>LinkAttrib</span><span>(</span><span>instanceVBO</span><span>,</span> <span>3</span> <span>+</span> <span>i</span><span>,</span> <span>4</span><span>,</span> <span>GL_FLOAT</span><span>,</span> <span>sizeof</span><span>(</span><span>glm</span><span>::</span><span>mat4</span><span>),</span> <span>(</span><span>void</span> <span>*</span><span>)(</span><span>i</span> <span>*</span> <span>sizeof</span><span>(</span><span>glm</span><span>::</span><span>vec4</span><span>)));</span>
        <span>glVertexAttribDivisor</span><span>(</span><span>3</span> <span>+</span> <span>i</span><span>,</span> <span>1</span><span>);</span> <span>// This tells OpenGL this is per-instance</span>
    <span>}</span>
    <span>colorVBO</span> <span>=</span> <span>VBO</span><span>(</span><span>instanceColors</span><span>);</span>                                              <span>// this should be dynamic</span>
    <span>shapeVAO</span><span>.</span><span>LinkAttrib</span><span>(</span><span>colorVBO</span><span>,</span> <span>7</span><span>,</span> <span>4</span><span>,</span> <span>GL_FLOAT</span><span>,</span> <span>4</span> <span>*</span> <span>sizeof</span><span>(</span><span>float</span><span>),</span> <span>(</span><span>void</span> <span>*</span><span>)</span><span>0</span><span>);</span> <span>// link the indices from the color buffer.</span>
    <span>glVertexAttribDivisor</span><span>(</span><span>7</span><span>,</span> <span>1</span><span>);</span>

    <span>textureVBO</span> <span>=</span> <span>VBO</span><span>(</span><span>instanceTextures</span><span>);</span>
    <span>textureVBO</span><span>.</span><span>Bind</span><span>();</span>
    <span>shapeVAO</span><span>.</span><span>LinkAttrib</span><span>(</span><span>textureVBO</span><span>,</span> <span>8</span><span>,</span> <span>1</span><span>,</span> <span>GL_INT</span><span>,</span> <span>sizeof</span><span>(</span><span>int</span><span>),</span> <span>(</span><span>void</span> <span>*</span><span>)</span><span>0</span><span>);</span> <span>// link texture ids</span>
</code></pre></div></div>

<h3 id="mistake-2-vaos-being-reused-between-spheres-and-light-source">Mistake 2: VAO‚Äôs being reused between spheres and light source.</h3>

<p>There‚Äôs a reason why I am using pointers to individual meshes for spheres and light object. Earlier when I was using
individual objects to
draw multiple spheres (see <code>src/Spheres.cpp</code>), I was noticing that the spheres are suddenly being rendered as cubes with
some hemispherical lightings on top of it, like this:</p>

<p><img src="https://uds5501.github.io/mindpalace/assets/images/posts/2025-03-01-opengl-webgl-porting/weird-cube.png" alt="weird-cube.png"/></p>

<p>Why was this happening? Let‚Äôs take a look at how it was being initialized:</p>

<div><div><pre><code>        <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>Sphere</span><span>&gt;</span> <span>spheres</span> <span>=</span> <span>{</span>
		<span>new</span> <span>Sphere</span><span>(</span><span>0.3</span><span>f</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>glm</span><span>::</span><span>vec3</span><span>(</span><span>-</span><span>1.0</span><span>f</span><span>,</span> <span>0.0</span><span>f</span><span>,</span> <span>-</span><span>2.0</span><span>f</span><span>)),</span>
		<span>new</span> <span>Sphere</span><span>(</span><span>0.3</span><span>f</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>glm</span><span>::</span><span>vec3</span><span>(</span><span>1.0</span><span>f</span><span>,</span> <span>0.0</span><span>f</span><span>,</span> <span>-</span><span>2.0</span><span>f</span><span>)),</span>
		<span>new</span> <span>Sphere</span><span>(</span><span>0.3</span><span>f</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>glm</span><span>::</span><span>vec3</span><span>(</span><span>0.0</span><span>f</span><span>,</span> <span>1.0</span><span>f</span><span>,</span> <span>-</span><span>3.0</span><span>f</span><span>)),</span>
		<span>new</span> <span>Sphere</span><span>(</span><span>0.3</span><span>f</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>glm</span><span>::</span><span>vec3</span><span>(</span><span>0.0</span><span>f</span><span>,</span> <span>-</span><span>1.0</span><span>f</span><span>,</span> <span>-</span><span>3.0</span><span>f</span><span>)),</span>
		<span>new</span> <span>Sphere</span><span>(</span><span>0.3</span><span>f</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>glm</span><span>::</span><span>vec3</span><span>(</span><span>-</span><span>1.5</span><span>f</span><span>,</span> <span>1.5</span><span>f</span><span>,</span> <span>-</span><span>4.0</span><span>f</span><span>)),</span>
		<span>new</span> <span>Sphere</span><span>(</span><span>0.3</span><span>f</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>glm</span><span>::</span><span>vec3</span><span>(</span><span>1.5</span><span>f</span><span>,</span> <span>1.5</span><span>f</span><span>,</span> <span>-</span><span>4.0</span><span>f</span><span>)),</span>
		<span>new</span> <span>Sphere</span><span>(</span><span>0.3</span><span>f</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>glm</span><span>::</span><span>vec3</span><span>(</span><span>-</span><span>1.5</span><span>f</span><span>,</span> <span>-</span><span>1.5</span><span>f</span><span>,</span> <span>-</span><span>4.0</span><span>f</span><span>)),</span>
		<span>new</span> <span>Sphere</span><span>(</span><span>0.3</span><span>f</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>glm</span><span>::</span><span>vec3</span><span>(</span><span>1.5</span><span>f</span><span>,</span> <span>-</span><span>1.5</span><span>f</span><span>,</span> <span>-</span><span>4.0</span><span>f</span><span>))};</span>
		
		<span>// some code</span>
		
		<span>VAO</span> <span>lightVAO</span><span>;</span>
		<span>lightVAO</span><span>.</span><span>Bind</span><span>();</span>
</code></pre></div></div>

<ul>
  <li>You initialize the spheres with their own VAO and VBOs internally. IDs from 1-8 are registered in each sphere.</li>
  <li>The moment these sphere objects are created and pushed in vector, they were deconstructed and the IDs earlier being
bound for Spheres (1-8) were set free.</li>
  <li>Now, you bind the lightVAO and the ID 1 is being used for the light object, hence messing the vertex rendering of all
the spheres!</li>
</ul>

<p>Solution? You‚Äôll laugh at this.</p>

<div><div><pre><code>   <span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>Sphere</span><span>*&gt;</span> <span>spheres</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>I had fun. Honestly it was fun to do something aimless and just for the sake of learning. I‚Äôll be reading up the
compilers next (currently a big black box for me in terms of implementation, kinda excited for this!)</p>

<p>See you in the next one? :D</p>

<h2 id="resources">Resources</h2>

<ol>
  <li><a href="https://learnopengl.com/">OpenGL Resources</a></li>
  <li><a href="https://webglfundamentals.org/">WebGL Resource</a></li>
  <li><a href="https://www.youtube.com/watch?v=XpBGwZNyUh0&amp;list=PLPaoO-vpZnumdcb4tZc4x5Q-v7CkrQ6M-">Tutorial series</a></li>
</ol>

  </div>
</article>

    </div>
  </div></div>
  </body>
</html>
