<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dolthub.com/blog/2022-12-19-maphash/">Original</a>
    <h1>Hacking Go&#39;s runtime with generics</h1>
    
    <div id="readability-page-1" class="page"><div data-cy="blog-post-text"><p>Today&#39;s blog is about <a href="https://github.com/dolthub/maphash">maphash</a>, a new open-source package for hashing arbitrary
(comparable) Golang types. We&#39;ll do a deep-dive on how its implemented as well as some interesting tid-bits on the
Golang runtime.</p>
<p>Here at Dolthub, we love Golang! We&#39;ve been pretty happy with Golang as our primary development language. It has a
strong open-source community, an excellent tool chain, and the simplicity of the language itself facilitates a
productive developer experience. We&#39;re using it to build Dolt, a MySQL-compatible version-controlled
<a href="https://www.dolthub.com/blog/2022-08-04-database-versioning/">database</a>. This blog is the latest in our technical
<a href="https://www.dolthub.com/blog/?q=golang">Golang series</a>, check them out if you&#39;re looking for more fun Golang content.</p>
<h2 id="hashing-all-the-things"><a href="#hashing-all-the-things" aria-label="hashing all the things permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hashing All the Things</h2>
<p><code>maphash</code> is a minimal package meant for one purpose: put the power of Golang&#39;s builtin hash into developers hands.
Any <code>comparable</code> Golang type can be hashed using a <code>maphash.Hasher</code>. The entire public API can be
summarized as follows:</p>
<div data-language="go"><pre><code><span>type</span> Hasher<span>[</span>K comparable<span>]</span> <span>struct</span> <span>{</span>
    <span>...</span>
<span>}</span>

<span>func</span> NewHasher<span>[</span>K comparable<span>]</span><span>(</span><span>)</span> Hasher<span>[</span>K<span>]</span> <span>{</span>
    <span>...</span>
<span>}</span>

<span>func</span> <span>(</span>h Hasher<span>[</span>K<span>]</span><span>)</span> <span>Hash</span><span>(</span>key K<span>)</span> <span>uint64</span> <span>{</span>
    <span>...</span>
<span>}</span></code></pre></div>
<p>In Golang the <a href="https://github.com/golang/go/blob/master/src/builtin/builtin.go#L97">comparable</a> type constraint is the union of
all types that implement the operators <code>==</code> and <code>!=</code>. This includes all scalar types, channels, interfaces, arrays, and
structs of other <code>comparable</code> types. Essentially anything you can use as the key of <code>map</code> you can hash with <code>maphash</code></p>
<p>So what&#39;s the point? The motivation for this package came while implementing a concurrent, <a href="https://dzone.com/articles/fine-grained-concurrency-guava">stripe-locked</a>
cache for Dolt. The design looked something like this:</p>
<div data-language="go"><pre><code><span>type</span> Cache<span>[</span>K comparable<span>,</span> V any<span>]</span> <span>struct</span> <span>{</span>
    stripes <span>[</span><span>64</span><span>]</span><span>map</span><span>[</span>K<span>]</span>V
    locks   <span>[</span><span>64</span><span>]</span>sync<span>.</span>RWLock
<span>}</span></code></pre></div>
<p>Using generics, we can create a flexible container class backed by a builtin <code>map</code>. However, as we try to implement the
accessor methods for this class, we get stuck writing a generic function to choose which stripe each key belongs to:</p>
<div data-language="go"><pre><code>
<span>func</span> <span>(</span>c Cache<span>[</span>K<span>,</span> V<span>]</span><span>)</span> <span>getStripe</span><span>(</span>key K<span>)</span> <span>int8</span> <span>{</span>
    ???
<span>}</span></code></pre></div>
<p>What we need here is a hash function for a generic, <code>comparable</code> type <code>K</code>.</p>
<h2 id="background"><a href="#background" aria-label="background permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Background</h2>
<p>The concept of exposing a generic hash function is not new to Golang. This idea first appeared in the core Golang repo
in a 2017 <a href="https://github.com/golang/go/issues/21195">issue</a> submitted by Byran Mills of Google&#39;s Golang team. It
suggests adding a builtin function for hashing <code>comparable</code> types as a building block for custom containers and data
structures. The proposal argues that Golang developers are forced to work around language when writing hash-based data
structures like <a href="https://en.wikipedia.org/wiki/Trie#">Tries</a> or <a href="https://pkg.go.dev/github.com/orcaman/concurrent-map#ConcurrentMap.Set">concurrent hash maps</a>.
Developers who want an efficient hash-based data structure have only the builtin <code>map</code> to choose from.</p>
<p>When this issue was originally created in 2017, Golang didn&#39;t have generics, so the proposed interfaced lacked a concrete type:</p>
<div data-language="go"><pre><code><span>func</span> <span>Local</span><span>(</span><span>interface</span><span>{</span><span>}</span><span>)</span> <span>uintptr</span></code></pre></div>
<p>This API seems reasonable at first, but it leaves the compiler without the type information it needs to implement this
function efficiently. The secret sauce of what makes Go&#39;s builtin map so fast is that the compiler generates
<a href="https://dave.cheney.net/tag/maps">custom hash functions</a> for each map type declared in the source code. These generated
functions know how to traverse a specific data type and use <a href="https://en.wikipedia.org/wiki/AES_instruction_set">AES instructions</a>
to hash them with special hardware support. Unfortunately, all this magic is hidden inside the <a href="https://pkg.go.dev/runtime">runtime</a>,
and it depends on the compiler knowing a static type at build-time.</p>
<p>In <code>go 1.19</code>, the standard library added a new <a href="https://pkg.go.dev/hash/maphash">maphash</a> package that exposed
utilities for hashing <code>string</code>s and <code>[]byte</code> slices using the AES-based runtime implementations. These are certainly
welcome additions to the language, but they still lack the flexibility needed to write generic container types like
Tries. Earlier this year, a <a href="https://github.com/golang/go/issues/54670">new issue</a> proposed expanding this package to
hash any <code>comparable</code> type. But unless this proposal gets accepted, we&#39;re left with only one option: hacking.</p>
<h2 id="hacking-the-runtime"><a href="#hacking-the-runtime" aria-label="hacking the runtime permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hacking the Runtime</h2>
<p>As a pretext, we know the compiler is capable of generating the exact hash functions we want. And further, we know that
using a <code>map[T]V</code> will trigger the compiler to generate a function that will hash a <code>comparable</code> type <code>T</code>. Within the
runtime, these custom hash functions are accessed through a <a href="https://github.com/golang/go/blob/master/src/runtime/type.go#L356">maptype</a>:</p>
<div data-language="go"><pre><code><span>type</span> maptype <span>struct</span> <span>{</span>
    typ    _type
    key    <span>*</span>_type
    elem   <span>*</span>_type
    bucket <span>*</span>_type 
    
    hasher     <span>func</span><span>(</span>unsafe<span>.</span>Pointer<span>,</span> <span>uintptr</span><span>)</span> <span>uintptr</span>
    keysize    <span>uint8</span>  
    elemsize   <span>uint8</span>  
    bucketsize <span>uint16</span> 
    flags      <span>uint32</span>
<span>}</span></code></pre></div>
<p>Each usage of a <code>map</code> takes a <code>*maptype</code> and an instance of a <code>map</code> (<code>*hmap</code>):</p>
<div data-language="go"><pre><code>
<span>func</span> <span>mapaccess1</span><span>(</span>t <span>*</span>maptype<span>,</span> h <span>*</span>hmap<span>,</span> key unsafe<span>.</span>Pointer<span>)</span> unsafe<span>.</span>Pointer <span>{</span>
    <span>...</span>
<span>}</span>


<span>func</span> <span>mapaccess2</span><span>(</span>t <span>*</span>maptype<span>,</span> h <span>*</span>hmap<span>,</span> key unsafe<span>.</span>Pointer<span>)</span> <span>(</span>unsafe<span>.</span>Pointer<span>,</span> <span>bool</span><span>)</span> <span>{</span>
    <span>...</span>
<span>}</span>


<span>func</span> <span>mapdelete</span><span>(</span>t <span>*</span>maptype<span>,</span> h <span>*</span>hmap<span>,</span> key unsafe<span>.</span>Pointer<span>)</span> <span>{</span>
    <span>...</span>
<span>}</span></code></pre></div>
<p>So how can we get access to this? Using Golang&#39;s <a href="https://pkg.go.dev/unsafe">unsafe</a> package, we can work around the type
system and get access to the private fields within these runtime types. This is what it looks like in our new <code>maphash</code>
package:</p>
<div data-language="go"><pre><code><span>func</span> getRuntimeHasher<span>[</span>K comparable<span>]</span><span>(</span><span>)</span> <span>(</span>h hashfn<span>,</span> seed <span>uintptr</span><span>)</span> <span>{</span>
    a <span>:=</span> <span>any</span><span>(</span><span>make</span><span>(</span><span>map</span><span>[</span>K<span>]</span><span>struct</span><span>{</span><span>}</span><span>)</span><span>)</span>
    i <span>:=</span> <span>(</span><span>*</span>mapiface<span>)</span><span>(</span>unsafe<span>.</span><span>Pointer</span><span>(</span><span>&amp;</span>a<span>)</span><span>)</span>
    h<span>,</span> seed <span>=</span> i<span>.</span>typ<span>.</span>hasher<span>,</span> <span>uintptr</span><span>(</span>i<span>.</span>val<span>.</span>hash0<span>)</span>
    <span>return</span>
<span>}</span>

<span>type</span> hashfn <span>func</span><span>(</span>unsafe<span>.</span>Pointer<span>,</span> <span>uintptr</span><span>)</span> <span>uintptr</span>

<span>type</span> mapiface <span>struct</span> <span>{</span>
    typ <span>*</span>maptype
    val <span>*</span>hmap
<span>}</span>


<span>type</span> maptype <span>struct</span> <span>{</span>
    typ    _type
    key    <span>*</span>_type
    elem   <span>*</span>_type
    bucket <span>*</span>_type
    
    hasher     <span>func</span><span>(</span>unsafe<span>.</span>Pointer<span>,</span> <span>uintptr</span><span>)</span> <span>uintptr</span>
    keysize    <span>uint8</span>
    elemsize   <span>uint8</span>
    bucketsize <span>uint16</span>
    flags      <span>uint32</span>
<span>}</span></code></pre></div>
<p>In <code>getRuntimeHasher[K comparable]()</code>, start by declaring a <code>map[K]struct{}</code>. This declaration makes the compiler create
the hash function we want. Next we cast our <code>map</code> to type <code>any</code>, forcing the compiler to add additional metadata do
describe the dynamic type of the variable <code>a</code>. For <code>map</code>s, this metadata is a pointer to a <code>maptype</code> object, which is
just what we need to access the hash function! Using an <code>unsafe.Pointer</code> we can cast <code>a</code> to <code>mapiface</code> (a runtime type),
get our <code>hasher</code>, and construct a <code>maphash.Hasher</code>:</p>
<div data-language="go"><pre><code><span>type</span> Hasher<span>[</span>K comparable<span>]</span> <span>struct</span> <span>{</span>
    hash hashfn
    seed <span>uintptr</span>
<span>}</span>

<span>func</span> NewHasher<span>[</span>K comparable<span>]</span><span>(</span><span>)</span> Hasher<span>[</span>K<span>]</span> <span>{</span>
    h<span>,</span> s <span>:=</span> getRuntimeHasher<span>[</span>K<span>]</span><span>(</span><span>)</span>
    <span>return</span> Hasher<span>[</span>K<span>]</span><span>{</span>hash<span>:</span> h<span>,</span> seed<span>:</span> s<span>}</span>
<span>}</span></code></pre></div>
<p>Using a <code>maphash.Hasher</code> we can create hash-based datastructures keyed by <code>UUID</code>s, <code>time.Time</code>, or any other <code>comparable</code>
type. And thanks to the compiler, <code>Hasher</code> is able to take advantage of optimized AES instructions. Hashing a <code>string</code>
with <code>maphash</code> is <a href="https://github.com/dolthub/maphash/blob/main/hasher_bench_test.go#L35">just as fast</a> as the standard
library version!</p>
<div data-language="go"><pre><code>goos<span>:</span> darwin
goarch<span>:</span> amd64
pkg<span>:</span> github<span>.</span>com<span>/</span>dolthub<span>/</span>maphash
cpu<span>:</span> <span>Intel</span><span>(</span>R<span>)</span> <span>Core</span><span>(</span>TM<span>)</span> i7<span>-</span>9750H CPU @ <span>2</span><span>.</span>60GHz
BenchmarkCompareStringHasher
BenchmarkCompareStringHasher<span>/</span>string_hasher
BenchmarkCompareStringHasher<span>/</span>string_hasher<span>-</span><span>12</span>         	<span>237970230</span>	         <span>5.341</span> ns<span>/</span>op	       <span>0</span> B<span>/</span>op	       <span>0</span> allocs<span>/</span>op
BenchmarkCompareStringHasher<span>/</span>std_string_hasher
BenchmarkCompareStringHasher<span>/</span>std_string_hasher<span>-</span><span>12</span>     	<span>207972664</span>	         <span>5.759</span> ns<span>/</span>op	       <span>0</span> B<span>/</span>op	       <span>0</span> allocs<span>/</span>op
PASS</code></pre></div>
<h2 id="a-humble-request"><a href="#a-humble-request" aria-label="a humble request permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A Humble Request</h2>
<p>If you&#39;re thinking that this code is an abuse of Golang, I agree with you. The <code>maphash</code> package, like <code>map</code> itself, is
tightly coupled to the current <code>runtime</code> implementation. Golang&#39;s <code>map</code> implementation has been fairly stable over the
last several major releases, but any changes would need to be ported to <code>maphash</code>. Pretty fragile! Currently, <code>maphash</code>
uses <a href="https://www.digitalocean.com/community/tutorials/customizing-go-binaries-with-build-tags">build tags</a> to restrict
its supported versions to <code>go 1.18</code> and <code>go 1.19</code>. We&#39;ll expand this support with future major version releases.</p>
<p>If you&#39;re thinking there&#39;s a better way to do this, I agree with you again! If I could make a request, I would ask you
to comment and upvote the <a href="https://github.com/golang/go/issues/54670">open issue</a> to expand the standard library version
of <code>maphash</code> to include the following:</p>
<div data-language="go"><pre><code>


<span>func</span> Comparable<span>[</span>T comparable<span>]</span><span>(</span>seed Seed<span>,</span> v T<span>)</span> <span>uint64</span></code></pre></div>
<h2 id="wrapping-up"><a href="#wrapping-up" aria-label="wrapping up permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wrapping Up</h2>
<p>Thanks for reading! I hope you learned something about Golang internals and I hope you give
<a href="https://github.com/dolthub/maphash">maphash</a> a try. I&#39;d like to give a shout-out here to Dave Cheney and his
excellent blogs about Golang and its runtime. In particular his <a href="https://dave.cheney.net/tag/maps">blog on maps</a> was
incredibly helpful background for this work. I also hope you get a chance to checkout <a href="https://github.com/dolthub/dolt">Dolt</a>
a Git-like SQL database built using Golang. If you&#39;re interested in learning more about Golang or Dolt, join us on our
<a href="https://discord.com/invite/RFwfYpu">Discord</a>!</p></div></div>
  </body>
</html>
