<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://effectivetypescript.com/2024/08/30/keyof-puzzle/">Original</a>
    <h1>A keyof puzzle</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><em>Effective TypeScript</em> is nearly 400 pages long, but I&#39;ve received the most feedback by far on just one passage. It comes in <a target="_blank" rel="noopener" href="https://github.com/danvk/effective-typescript/blob/main/samples/ch-types/types-as-sets.md" onclick="return trackOutboundLink(&#39;a keyof puzzle&#39;, &#39;https://github.com/danvk/effective-typescript/blob/main/samples/ch-types/types-as-sets.md&#39;, event);">Item 7: Think of Types as Sets of Values</a>:</p>
<blockquote>
<figure><div><pre><code>keyof (A&amp;B) = (keyof A) | (keyof B)</code></pre></div></figure>

<p>If you can build an intuition for why these equations hold, you&#39;ll have come a long way toward understanding TypeScript&#39;s type system!</p>
</blockquote>
<p>I&#39;ll explain these equations in a moment. But before I do, head over to the <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play/?#code/JYOwLgpgTgZghgYwgAgHJwLYQCYAUD2oYyA3gFDLIiYQBcyAzmFKAOYDcFyAHvSAK4YARtE6UAnn0EionAL5ki0eEmQEiAZgAipLryrTRXSQeFHKALylnZZBWQT4QTKjWwANAJoAtZAF5dSmosegByVAgAd2RPfCgAa1CAGj16AFoAdg0UiXoAFgAGHOQrZCK7TkdnYhBxBFR6dCw8QnB-V2avb3ZkAHpe5Hx4gEIHJxdahG96dXBtduCcLp7+wZGyMjBxAAcUAGlUdpI5ZAAyZHiIcXwYNDdZsE5VygA9AH5Nnf2NI5Pzy+utwe2ieA1eH0+u2QewAku0ATdkAAKJo4B5nNStMDaACUoMoyHekP2AFV2kiEbdUS0iDjkAAfZGUzGaLQ4sjPQkfIA" onclick="return trackOutboundLink(&#39;a keyof puzzle&#39;, &#39;https://www.typescriptlang.org/play/?#code/JYOwLgpgTgZghgYwgAgHJwLYQCYAUD2oYyA3gFDLIiYQBcyAzmFKAOYDcFyAHvSAK4YARtE6UAnn0EionAL5ki0eEmQEiAZgAipLryrTRXSQeFHKALylnZZBWQT4QTKjWwANAJoAtZAF5dSmosegByVAgAd2RPfCgAa1CAGj16AFoAdg0UiXoAFgAGHOQrZCK7TkdnYhBxBFR6dCw8QnB-V2avb3ZkAHpe5Hx4gEIHJxdahG96dXBtduCcLp7+wZGyMjBxAAcUAGlUdpI5ZAAyZHiIcXwYNDdZsE5VygA9AH5Nnf2NI5Pzy+utwe2ieA1eH0+u2QewAku0ATdkAAKJo4B5nNStMDaACUoMoyHekP2AFV2kiEbdUS0iDjkAAfZGUzGaLQ4sjPQkfIA&#39;, event);">TypeScript Playground</a> and test them out with a few types. See if you can build that intuition for why they hold.</p>
<p>I first saw these equations in Anders Hejlsberg&#39;s <a target="_blank" rel="noopener" href="https://youtu.be/wpgKd-rwnMw?si=szTbEWSFGCF8xp2x&amp;t=1576" onclick="return trackOutboundLink(&#39;a keyof puzzle&#39;, &#39;https://youtu.be/wpgKd-rwnMw?si=szTbEWSFGCF8xp2x&amp;t=1576&#39;, event);">keynote at TSConf 2018</a> (&#34;Higher order type equivalences&#34; at 26m15s):</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wpgKd-rwnMw?si=G6bKilX_4QC-Z7Xw&amp;start=1576" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

<p>Anders&#39; explanation at the talk was helpful, but I still had to stare at them for a long time before they clicked. But when they did, I felt like I&#39;d had a real insight about how TypeScript types work.</p>
<p>The feedback on these equations in the book is typically that I need to explain them more. Some readers have even claimed they&#39;re wrong. (They&#39;re not!) By presenting them a bit cryptically, I wanted to give readers a chance to think through them and have an insight of their own.</p>
<p>With that out of the way, let&#39;s dig into why these equations hold, and why they&#39;re interesting.</p>
<p>We can start by plugging in concrete types for <code>A</code> and <code>B</code>:</p>
<figure><div><pre><code><span>interface</span> NamedPoint {</code></pre></div></figure>

<p>What&#39;s <code>NamedPoint &amp; Point3D</code>, the intersection of these two types? It&#39;s easy to think that it&#39;s an <code>interface</code> with just the common fields:</p>
<figure><div><pre><code></code></pre></div></figure>

<p>That&#39;s not what it is, though. To understand the intersection of these types, we need to think a little more about what values are assignable to each type. A <code>NamedPoint</code> is an object with three properties, <code>name</code>, <code>x</code>, and <code>y</code>, with the expected types:</p>
<figure><div><pre><code><span>const</span> nyc: NamedPoint = {</code></pre></div></figure>

<p>But a <code>NamedPoint</code> could have other properties, too. In particular it could have a <code>z</code> property:</p>
<figure><div><pre><code><span>const</span> namedXYZ = {</code></pre></div></figure>

<p>(We have to go through an intermediate object to avoid <a target="_blank" rel="noopener" href="https://observablehq.com/@koop/excess-property-checking-in-typescript" onclick="return trackOutboundLink(&#39;a keyof puzzle&#39;, &#39;https://observablehq.com/@koop/excess-property-checking-in-typescript&#39;, event);">excess property checking</a> errors here. If you have a copy of <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" onclick="return trackOutboundLink(&#39;a keyof puzzle&#39;, &#39;https://amzn.to/3UjPrsK&#39;, event);"><em>Effective TypeScript</em></a>, check out <a target="_blank" rel="noopener" href="https://github.com/danvk/effective-typescript/blob/main/samples/ch-types/excess-property-checking.md" onclick="return trackOutboundLink(&#39;a keyof puzzle&#39;, &#39;https://github.com/danvk/effective-typescript/blob/main/samples/ch-types/excess-property-checking.md&#39;, event);">Item 11: Distinguish Excess Property Checking from Type Checking</a>.)</p>
<p>There&#39;s nothing special about <code>z</code>. It could have other properties, too, and still be assignable to <code>NamedPoint</code>. For this reason, we sometimes say that TypeScript types are &#34;open.&#34;</p>
<p>Of course, <code>Point3D</code> is open, too. It could also have other fields, including a <code>name</code> field:</p>
<figure><div><pre><code><span>const</span> nycZ: Point3D = namedXYZ; <br/></code></pre></div></figure>

<p>So <code>namedXYZ</code> is assignable to both <code>NamedPoint</code> and <code>Point3D</code>. And that is the very definition of an intersection. Sure enough, <code>namedXYZ</code> is assignable to the intersection of these types, too:</p>
<figure><div><pre><code><span>const</span> nycZ: Point3D &amp; NamedPoint = namedXYZ; <br/></code></pre></div></figure>

<p>This gives us a hint about what the intersection looks like:</p>
<figure><div><pre><code><span>interface</span> NamedPoint3D {</code></pre></div></figure>

<p>This type is <em>also</em> &#34;open:&#34; a <code>NamedPoint3D</code> might have more than these four fields. But it has to have at least these four.</p>
<p>To <em>intersect</em> these two types, we <em>unioned</em> their properties. We can see this in code using <code>keyof</code>:</p>
<figure><div><pre><code><span>type</span> KN = {} &amp; keyof NamedPoint;</code></pre></div></figure>

<p>So <code>keyof (A&amp;B) = (keyof A) | (keyof B)</code>!</p>
<p>(The weird <code>{} &amp;</code> forces TypeScript to print out the results of <code>keyof</code>. I <a target="_blank" rel="noopener" href="https://www.effectivetypescript.com/2022/02/25/gentips-4-display/#Exclude-lt-keyof-T-never-gt" onclick="return trackOutboundLink(&#39;a keyof puzzle&#39;, &#39;https://www.effectivetypescript.com/2022/02/25/gentips-4-display/#Exclude-lt-keyof-T-never-gt&#39;, event);">wish</a> this weren&#39;t necessary.)</p>
<p>What about the other relationship, <code>keyof (A|B)</code>? <code>keyof T</code> will only include a property if TypeScript can be sure that it will be present on values assignable to <code>T</code> (with a caveat, see below).</p>
<p>Again, let&#39;s make this more concrete with some examples:</p>
<figure><div><pre><code><span>const</span> nyc: NamedPoint = {</code></pre></div></figure>

<p>To be assignable to <code>A|B</code>, a value must be assignable to either <code>A</code> or <code>B</code> (or both!). So these values are both assignable to <code>NamedPoint | Point3D</code>:</p>
<figure><div><pre><code><span>const</span> u1: NamedPoint | Point3D = nyc; </code></pre></div></figure>

<p>Thinking about <code>keyof</code>, which properties belong to both those objects? It&#39;s just <code>&#34;x&#34;</code> and <code>&#34;y&#34;</code>. And that&#39;s <code>keyof</code> for the union type:</p>
<figure><div><pre><code><span>type</span> KU = keyof (NamedPoint | Point3D)</code></pre></div></figure>

<p>So <code>keyof (A|B) = (keyof A) &amp; (keyof B)</code> and the equation holds.</p>
<p>Hopefully working through these examples with some concrete types makes the equations clearer. I really like them because they&#39;re concise but still manage to say a lot about how types work in TypeScript.</p>
<p>I mentioned one caveat, and it has to do with optional fields:</p>
<figure><div><pre><code><span>interface</span> PartialPoint {</code></pre></div></figure>

<p><code>justX</code> is assignable to <code>PartialPoint</code>, but it doesn&#39;t have a <code>y</code> property, which you&#39;d expect given the <code>keyof</code>.</p>
<p>Optional fields are a little strange when you think about types in a set-theoretic way. On the one hand, it&#39;s surprising that <code>keyof PartialPoint</code> includes <code>&#34;y&#34;</code> because values needn&#39;t have that property. On the other hand, it would be incredibly annoying if it didn&#39;t because <code>keyof</code> is so often used with <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html" onclick="return trackOutboundLink(&#39;a keyof puzzle&#39;, &#39;https://www.typescriptlang.org/docs/handbook/2/mapped-types.html&#39;, event);">mapped types</a>, and you&#39;d really like to map over all the fields, not just the required ones.</p>
<p>At the end of the day, what&#39;s the difference between these two types?</p>
<figure><div><pre><code><span>interface</span> JustX {</code></pre></div></figure>

<p>I&#39;ll cryptically say &#34;not much!&#34; and leave it at that!</p>

          </div></div>
  </body>
</html>
