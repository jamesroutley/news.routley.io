<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nickdrozd.github.io/2022/02/11/latest-beeping-busy-beaver-results.html">Original</a>
    <h1>Latest Beeping Busy Beaver Results</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>The <a href="https://scottaaronson.blog/?p=4916"><strong>Busy Beaver</strong></a> question asks: what is the longest that a Turing machine program of <em>n</em> states and <em>k</em> colors can run when started on the blank tape before halting? The function that maps from <em>(n, k)</em> to the longest run length is <strong>uncomputable</strong> and grows faster than any computable function.</p>

<p>Variations of the Busy Beaver function (BB) can be obtained by changing the <a href="https://nickdrozd.github.io/2021/02/14/blanking-beavers.html"><strong>termination condition</strong></a>: what is the longest that a Turing machine of <em>n</em> states and <em>k</em> colors can run before doing such-and-such? The <strong>Blanking Beaver</strong> function (BLB) arises from running programs until the Turing machine tape becomes blank, and the <strong>Beeping Busy Beaver</strong> (BBB) function arises from running programs until they reach a condition known as <a href="https://nickdrozd.github.io/2021/01/14/halt-quasihalt-recur.html"><strong><em>quasihalting</em></strong></a>.</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Termination</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BB</td>
      <td>Halt</td>
    </tr>
    <tr>
      <td>BLB</td>
      <td>Blank tape</td>
    </tr>
    <tr>
      <td>BBB</td>
      <td>Quasihalt</td>
    </tr>
  </tbody>
</table>

<p>Here are the <strong>latest and greatest lower bounds</strong> that have been discovered for early values of these functions:</p>

<table>
  <thead>
    <tr>
      <th>States</th>
      <th>Colors</th>
      <th>BB</th>
      <th>BLB</th>
      <th>BBB</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
      <td>2</td>
      <td>6</td>
      <td>6</td>
      <td>8</td>
    </tr>
    <tr>
      <td>3</td>
      <td>2</td>
      <td>21</td>
      <td>34</td>
      <td>55</td>
    </tr>
    <tr>
      <td>2</td>
      <td>3</td>
      <td>38</td>
      <td>77</td>
      <td>59</td>
    </tr>
    <tr>
      <td>4</td>
      <td>2</td>
      <td>107</td>
      <td>32,779,477</td>
      <td>32,779,478</td>
    </tr>
    <tr>
      <td>2</td>
      <td>4</td>
      <td>3,932,964</td>
      <td>1,367,361,263,049</td>
      <td>205,770,076,433,044,242,247,859</td>
    </tr>
    <tr>
      <td>5</td>
      <td>2</td>
      <td>47,176,870</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>(I claim that <strong>all the small values are the true values</strong>, but that’s for a separate post.)</p>

<p>These numbers suggest several <strong>plausible hypotheses</strong>:</p>

<ol>
  <li><strong>BLB grows faster than BB.</strong></li>
  <li><strong>BBB grows faster than BB.</strong></li>
  <li><strong>BBB grows faster than BLB.</strong></li>
</ol>

<p>(2) and (3) are both known from <strong>computability theory</strong> to be true. This has to do with the termination conditions. At any given step it’s possible to determine whether or not the machine is <em>currently</em> halted and whether or not the tape is <em>currently</em> blank. In other words, they are <strong>decidable predicates</strong>. Determining whether a machine will <em>eventually</em> halt or whether the tape will <em>eventually</em> become blank requires an unbounded search for a decidable predicate, and that search is <strong>semidecidable</strong>: if the condition eventually holds, it will turn up, but otherwise it won’t.</p>

<p>In contrast, checking whether a machine is currently quasihalted or not is already semidecidable, and solving this in general is equivalent to the <strong>halting problem</strong>. Checking whether a machine will <em>eventually</em> quasihalt thus requires an unbounded search for an uncomputable predicate, and this means that BBB is a <strong>super-uncomputable function</strong>. Just as BB grows faster than any computable function, BBB grows faster than any function that is <strong>“just” regular-uncomputable</strong>.</p>

<p>Computability theory is a <strong>theory</strong>, and that theory makes <strong>predictions</strong>, and one of those predictions is that BBB, as a super-uncomputable function, should grow really, really fast. Thus these <strong>empirical results</strong> about Turing machine program behavior serve to <strong>confirm the theory’s predictions</strong>.</p>

<p>What about BB and BLB? These functions are <strong>equicomputable</strong>, and one can be solved given an <strong>oracle</strong> for the other. Computability theory doesn’t make a prediction about which one grows faster. All known empirical results suggest that BB &lt; BLB, but as <a href="https://scottaaronson.blog/?p=5661#comment-1900309">Bruce Smith</a> pointed out, <strong>we can’t even prove that BLB ≤ BB</strong>!</p>

<p><strong>Provability</strong> is important from a mathematical point of view. But the Busy Beaver problem was originally posed as a <strong>competition</strong> to see who could come up with the longest-running program. Searching for long-running Turing machines is like <strong>prospecting for gold</strong>, and it requires making predictions about where the winning programs might be found, even if these predictions cannot be backed up wth proofs. <strong>I made a few predictions myself, and they turned out to be correct.</strong></p>

<p>Here are the best values that had been discovered through <strong>the end of 2021</strong>:</p>

<table>
  <thead>
    <tr>
      <th>States</th>
      <th>Colors</th>
      <th>BB</th>
      <th>BLB</th>
      <th>BBB</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4</td>
      <td>2</td>
      <td>107</td>
      <td>32,779,477</td>
      <td>32,779,478</td>
    </tr>
    <tr>
      <td>2</td>
      <td>4</td>
      <td>3,932,964</td>
      <td>190,524</td>
      <td>2,501,552</td>
    </tr>
    <tr>
      <td>5</td>
      <td>2</td>
      <td>47,176,870</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>This is the situation with which I, as a searcher, was faced. I had searched for 2-state 4-color blank-tape and quasihalting programs up through several hundred million steps, and that was the best I had found. <strong>Were these the true values?</strong> It seemed unlikely to me that BBB(2, 4) &lt; BB(2, 4). Again, computability theory tells us that <strong>the super-uncomputable function should grow uncomputably faster than the regular-uncomputable function</strong>. There’s no good reason why it shouldn’t start early, so I figured it probably did.</p>

<p>Things were not so clear with BLB. Again, there’s no proof even that BLB ≤ BB, so maybe BLB(2, 4) &lt; BB(2, 4). But my <a href="https://nickdrozd.github.io/2021/07/11/self-cleaning-turing-machine.html">previous discovery of the <strong>BLB(4, 2) champion</strong> </a> gave me an <strong>unshakeable hunch</strong> that there was still more to find.</p>

<p>It’s not always easy to discern <strong>justifiable faith</strong> from <strong>blind fanaticism</strong>. I certainly didn’t want to waste a bunch of time searching for something that never existed in the first place, so I set a <strong>limit</strong> beyond which I would not bother searching. I reasoned as follows: The ratio BLB(4, 2) / BB(4, 2) works out to about 306,350. If BLB(2, 4) / BB(2, 4) holds the same ratio, then we should have something like BLB(2, 4) ≈ 1,204,863,521,400, or 1.2 trillion. Rounding up, that means searching within 2 trillion steps or so.</p>

<p>This was really a <strong>grasping-at-straws</strong> kind of estimate, totally made up, with no good reason to believe that it would hold. So imagine my surprise when <a href="https://nickdrozd.github.io/2022/01/10/another-self-cleaning-turing-machine.html"><strong>the estimate turned out to be accurate!</strong></a> A new BLB champion turned up to prove that BLB(2, 4) ≥ 1,367,361,263,049. That same program quasihalts too, but earlier, establishing that BBB(2, 4) ≥ 1,367,354,345,128.</p>

<p>Here is the updated results table through <strong>mid-January 2022</strong>:</p>

<table>
  <thead>
    <tr>
      <th>States</th>
      <th>Colors</th>
      <th>BB</th>
      <th>BLB</th>
      <th>BBB</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4</td>
      <td>2</td>
      <td>107</td>
      <td>32,779,477</td>
      <td>32,779,478</td>
    </tr>
    <tr>
      <td>2</td>
      <td>4</td>
      <td>3,932,964</td>
      <td>1,367,361,263,049</td>
      <td>1,367,354,345,128</td>
    </tr>
    <tr>
      <td>5</td>
      <td>2</td>
      <td>47,176,870</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>According to this table, BLB(2, 4) &gt; BBB(2, 4). This wouldn’t too different from the 4-state 2-color case, where as far as we know BLB(4, 2) + 1 = BBB(4, 2). It’s just that <strong>a single program is the champion for multiple classes</strong>, and the various termination conditions are hit at different steps.</p>

<p>We know that BB and BLB are equicomputable, and so, I figured, maybe they maintain some kind of relationship in their growth. But BBB is <strong>uncomputable even with respect to these uncomputable functions</strong>. BBB grows faster than BLB, and historically Busy Beaver searchers have always understimated how fast BB grows. Putting these facts together, I decided that it the true value of BBB(2, 4) must be even further out.</p>

<p>To find the BLB(2, 4) champion, I used <a href="https://github.com/nickdrozd/busy-beaver-stuff/tree/main/idris">a simulator written in <strong>Idris</strong></a>. It’s pretty fast, but I felt I had reached the limits of what it could do. And so I turned to <a href="https://github.com/sligocki/busy-beaver">a simulator written by <strong>Shawn and Terry Ligocki</strong></a>. That simulator, which was used to discover many <a href="https://webusers.imj-prg.fr/~pascal.michel/ha.html">historical BB candidates</a>, does some sophisticated runtime analysis and is able to provide a <strong>massive speed-up</strong> in certain cases. If those kinds of programs existed in the 2-state 4-color space, this simulator would find them.</p>

<p>And it did! On 24 January 2022, I found a program that quasihalts in 67,093,892,759,901,295 steps (about 67 quadrillion). <strong>This was more like how I had expected things to look based on what I knew from theory.</strong></p>

<p>I reported this value to <a href="https://www.sligocki.com/"><strong>Shawn Ligocki</strong></a> along with the search parameters used. He then pushed his simulator even further, and on 7 February 2022 he reported a 2-state 4-color program that quasihalts in 205,770,076,433,044,242,247,859 steps (about 205 sextillion). <strong>That is where the record stands today.</strong></p>



<table>
  <thead>
    <tr>
      <th>Program</th>
      <th>Steps</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>1RB 2RA 1RA 2RB ; 2LB 3LA 0RB 0RA</code></td>
      <td>1,367,361,263,049</td>
      <td>Current BLB(2, 4) champion</td>
    </tr>
    <tr>
      <td><code>1RB 2RA 1LA 2LB ; 2LB 3RB 0RB 1RA</code></td>
      <td>67,093,892,759,901,295</td>
      <td>Former BBB(2, 4) champion</td>
    </tr>
    <tr>
      <td><code>1RB 2LA 1RA 1LB ; 0LB 2RB 3RB 1LA</code></td>
      <td>205,770,076,433,044,242,247,859</td>
      <td>Current BBB(2, 4) champion</td>
    </tr>
  </tbody>
</table>



<ol>
  <li>Why should the BLB / BB ratio hold?</li>
  <li>How likely is it that BLB(5, 2) &gt; 47,176,870?</li>
  <li>How likely is it that BBB(4, 2) = 32,779,478?</li>
  <li>Why would a simulator only be able to provide speed-up in “certain cases”? Which cases?</li>
</ol>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
