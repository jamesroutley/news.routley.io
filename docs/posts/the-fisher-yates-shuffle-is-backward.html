<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://possiblywrong.wordpress.com/2020/12/10/the-fisher-yates-shuffle-is-backward/">Original</a>
    <h1>The Fisher-Yates shuffle is backward</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Given a list of <img src="https://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="n"/> elements, such as cards in a deck, what is the right way to shuffle the list? That is, what is the appropriate algorithm to (pseudo)randomly permute the elements in the list, so that each of the <img src="https://s0.wp.com/latex.php?latex=n%21&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=n%21&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=n%21&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="n!"/> possible permutations is equally likely?</p>



<p>This is an interesting problem, in part because it is easy to get <a href="https://possiblywrong.wordpress.com/2014/12/01/card-shuffling-algorithms-good-and-bad/">wrong</a>. The standard, all-the-cool-kids-know-it response is the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a>, consisting of a sequence of <img src="https://s0.wp.com/latex.php?latex=n-1&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=n-1&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=n-1&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="n-1"/> carefully specified random transpositions, with the following basic implementation in Python:</p>


<div><pre title="">def fisher_yates_shuffle(a):
    &#34;&#34;&#34;Shuffle list a[0..n-1] of n elements.&#34;&#34;&#34;
    for i in range(len(a) - 1, 0, -1): # i from n-1 downto 1
        j = random.randint(0, i) # inclusive
        a[i], a[j] = a[j], a[i]
</pre></div>


<p>Note that the loop index <code>i</code> <em>decreases</em> from <img src="https://s0.wp.com/latex.php?latex=n-1&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=n-1&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=n-1&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="n-1"/> down to 1. Everywhere I have looked, this is how the algorithm is always presented. The motivation for this post is to wonder aloud why the following variant– which seems simpler, at least to me– is not the “standard” approach, with the only difference being that the loop runs “forward” instead of backward:</p>


<div><pre title="">def forward_shuffle(a):
    &#34;Shuffle list a[0..n-1] of n elements.&#34;&#34;&#34;
    for i in range(1, len(a)): # i from 1 to n-1
        j = random.randint(0, i) # inclusive
        a[i], a[j] = a[j], a[i]
</pre></div>


<p>It’s worth emphasizing that this is different from what seems to be the usual “forward” version of the algorithm (e.g., <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm">this</a> “equivalent version”), that seems to consistently insist on also “mirroring” the ranges of the random draws, so that <em>they </em>are decreasing with each loop iteration instead of the loop index:</p>


<div><pre title="">def mirror_shuffle(a):
    &#34;Shuffle list a[0..n-1] of n elements.&#34;&#34;&#34;
    for i in range(0, len(a) - 1): # i from 0 to n-2
        j = random.randint(i, len(a) - 1) # inclusive
        a[i], a[j] = a[j], a[i]
</pre></div>


<p>There are a couple of ways to see and/or prove that <code>forward_shuffle</code> does indeed yield a uniform distribution on all possible permutations. One is by induction– the rather nice loop invariant is that, after each iteration <code>i</code>, the sublist <code>a[0..i]</code> is a uniformly random permutation of the original sublist <code>a[0..i]</code>. (Contrast this with the normal Fisher-Yates shuffle, where after each iteration indexed by <code>i</code>, the “suffix” sublist <code>a[i..n-1]</code> is essentially a uniformly permuted <a href="https://en.wikipedia.org/wiki/Reservoir_sampling">reservoir-sampled</a> subset of the entire original list.)</p>



<p>Another way to see that <code>forward_shuffle</code> works as desired is to relate its behavior to that of the original <code>fisher_yates_shuffle</code>, which has already been proved correct. Consider the set of independent discrete random variables <img src="https://s0.wp.com/latex.php?latex=%5C%7BX_1%2C+X_2%2C+%5Cldots%2C+X_%7Bn-1%7D%5C%7D&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5C%7BX_1%2C+X_2%2C+%5Cldots%2C+X_%7Bn-1%7D%5C%7D&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5C%7BX_1%2C+X_2%2C+%5Cldots%2C+X_%7Bn-1%7D%5C%7D&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\{X_1, X_2, \ldots, X_{n-1}\}"/>, with each <img src="https://s0.wp.com/latex.php?latex=X_i&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=X_i&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=X_i&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="X_i"/> distributed uniformly between 0 and <img src="https://s0.wp.com/latex.php?latex=i&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=i&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=i&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="i"/>, inclusive. These <img src="https://s0.wp.com/latex.php?latex=X_i&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=X_i&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=X_i&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="X_i"/> are the random draws returned from <code>random.randint(0, i)</code>.</p>



<p>Imagine generating the entire set of those <img src="https://s0.wp.com/latex.php?latex=n-1&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=n-1&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=n-1&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="n-1"/> independent random draws up front, <em>then </em>applying the sequence of corresponding transpositions <img src="https://s0.wp.com/latex.php?latex=%28i%2C+X_i%29&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%28i%2C+X_i%29&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%28i%2C+X_i%29&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="(i, X_i)"/>. The original Fisher-Yates shuffle applies those transpositions in order of <em>decreasing </em><img src="https://s0.wp.com/latex.php?latex=i&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=i&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=i&amp;bg=ffffff&amp;fg=333333&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="i"/>, while <code>forward_shuffle</code> applies the <em>same </em>set of random transpositions, but in reverse order. Thus, the permutations resulting from <code>fisher_yates_shuffle</code> and <code>forward_shuffle</code> are inverses of each other… and if a random permutation is uniformly distributed, then so is its inverse.</p>



<p>There is nothing special here– indeed, this <code>forward_shuffle</code> is really just a less dressed-up implementation of what is usually referred to as the “<a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_%22inside-out%22_algorithm">inside-out</a>” version of Fisher-Yates, that for some reason seems to be presented as only appropriate when shuffling a list generated from an external source (possibly of unknown length):</p>


<div><pre title="">def forward_shuffle(source):
    &#34;Return shuffled list from external source.&#34;&#34;&#34;
    a = []
    for i, x in enumerate(source):
        a.append(x)
        j = random.randint(0, i) # inclusive
        a[i], a[j] = a[j], a[i]
    return a
</pre></div>


<p>I say “less dressed-up” because I’ve skipped what seems to be the usual special case <code>j==i</code> comparison that would eliminate the swapping. The above seems simpler to me, and I would be curious to know if these (branchless) swaps are really less efficient in practice.</p>
			</div></div>
  </body>
</html>
