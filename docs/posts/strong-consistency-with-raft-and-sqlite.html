<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sqlitecloud.io/strong-consistency-with-raft-and-sqlite">Original</a>
    <h1>Strong Consistency with Raft and SQLite</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-parent"><div id="post-content-wrapper"><p>In the recent past, a typical client/server environment consisted of multiple clients connected to a central database server. A central database architecture is a system where all data is stored in a single centralized location.</p>
<p>When client A from Singapore commits a piece of information into the central database, client B from New York can access the same up-to-date information without any issue because it reads from the same central database.</p>
<p>The central database architecture is consistent and up-to-date by default, as there is only one source of truth. So why don&#39;t use a central database architecture for everything?</p>
<p>A central database architecture represents a single point of failure: If the central database fails, the entire system may be affected, leading to downtime and data loss and as the amount of data grows, a central database may become overwhelmed, leading to performance issues and slower response times.</p>
<p>Modern architectures involve a distributed database system where data is stored across multiple decentralized locations. This approach leads to numerous advantages:</p>
<ol>
<li><p>Scalability: Distributed databases can be scaled horizontally by adding more nodes to the network, making handling larger amounts of data and higher volumes of requests easier.</p>
</li>
<li><p>High availability: Because data is stored across multiple locations, if one node fails, the data is still available on other nodes.</p>
</li>
<li><p>Localized access: With a distributed database, data can be stored closer to the users who need it, which can improve response times and reduce network latency.</p>
</li>
<li><p>Lower cost: Distributed databases can be built using commodity hardware, which is less expensive than specialized hardware required for a central database.</p>
</li>
</ol>
<p>A distributed database system is the right solution for modern requirements, but maintaining data consistency across multiple nodes can be challenging, especially when dealing with updates and modifications.</p>
<p>In the example above, we need to guarantee that if client A from Singapore commits a piece of information in the node located in Asia, then client B connected to the node located in New York can access that up-to-date information transparently and with the minimum amount of latency.</p>
<p>Consistency means a lot of things, and in database terminology, there are several shades of consistency. The eventual consistency model is easy to achieve, where data read from client B can be the most up-to-date information. There is no guarantee about it. This compromise can be good enough for some instances like the number of reads in a blog post or likes in a Facebook article. At one point (we don&#39;t know when), the change in the Singapore database will be propagated to all the nodes, and the information will be consistent across all the nodes in the cluster.</p>
<p>The above model would be unacceptable for other cases, especially the ones that need to use transactions. Think about a bank account balance, a flight reservation system, or a CMS or a real-time app. For these cases, a strong consistency model must be used. Strong consistency guarantees that the data must be strongly consistent at all times. All the server nodes across the world should contain the same value as an entity at any point in time.</p>
<p>SQLite Cloud guarantees strong consistency and uses the Raft consensus algorithm under the hood.</p>
<p>The <a target="_blank" href="https://raft.github.io">Raft consensus algorithm</a> is a distributed consensus algorithm designed to help manage replicated logs (database changes in our case) in a distributed system. The algorithm was introduced in 2014 by <a target="_blank" href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf">Diego Ongaro and John Ousterhout</a> as an alternative to other, more complex, consensus algorithms. Raft works by ensuring that all nodes in a distributed system agree on the same log of commands or events. In doing so, it helps achieve strong consistency across the system.</p>
<p><strong>How Does Raft Work?</strong></p>
<p>The <a target="_blank" href="http://thesecretlivesofdata.com/raft/">Raft consensus algorithm</a> works by electing a leader node that manages the replicated log. The leader node receives commands from clients and replicates them across all nodes in the distributed system. Raft ensures that all nodes have the same log of commands by using a series of communication messages called &#34;log entries.&#34; Each log entry contains a command or event that is appended to the log of each node.</p>
<p>Raft divides time into terms, where each term begins with a leader election. During each term, a single leader is elected, and that leader is responsible for managing the replicated log. If the leader fails or becomes unreachable, a new leader is elected, and the process starts over.</p>
<p>To ensure that all nodes have the same log of commands, Raft uses a mechanism called &#34;log replication.&#34; During log replication, the leader sends log entries to all other nodes in the distributed system. Once a majority of nodes in the system have received and committed the log entry, it is considered committed and can be executed. This process ensures that all nodes in the system have the same log of commands and can maintain strong consistency.</p>
<p><strong>How To Achieve Strong Consistency with Raft?</strong></p>
<p>Raft achieves strong consistency by ensuring that all nodes in the distributed system have the same log of commands. To achieve this, Raft uses several mechanisms, including leader election, log replication, and commit mechanisms.</p>
<p>During leader election, Raft ensures that a single node is responsible for managing the replicated log. This ensures that all nodes in the system are working with the same log of commands.</p>
<p>During log replication, Raft ensures that all nodes in the system receive the same log of commands by using a majority vote. This ensures that any updates made to the log are replicated to a majority of nodes in the system, maintaining strong consistency (SQLite Cloud guarantees to prevent <a target="_blank" href="https://en.wiktionary.org/wiki/stale_read">stale reads</a> in any node).</p>
<p>Finally, Raft uses a commit mechanism to ensure that log entries are executed in the same order on all nodes in the system. This helps maintain strong consistency by ensuring that all nodes execute the same commands in the same order.</p>
<p><strong>What to distribute with SQLite?</strong></p>
<p>Thanks to Raft, we have a way to distribute a database change across all the cluster nodes. But what is the real information to distribute?</p>
<p>Some database vendors choose to distribute the raw SQL statement, so, if client A connected to Singapore performs the following statement:</p>
<pre><code><span>INSERT</span> <span>INTO</span> foo (col1, col2, col3) <span>VALUES</span> (<span>1</span>, <span>2</span>, <span>3</span>);
</code></pre>
<p>Then this same SQL statement as-is will be replicated across all the cluster nodes. This simple statement will work fine because it contains <em>deterministic</em> values like 1, 2, and 3 that cannot change during the execution on different nodes.</p>
<p>But what about if the executed SQL statement is something like:</p>
<pre><code><span>INSERT</span> <span>INTO</span> foo (col1, col2, col3) <span>VALUES</span> (RANDOM(), <span>TIME</span>(), <span>DATE</span>());
</code></pre>
<p>This SQL statement will produce different outputs on different nodes, breaking the consistency we need to guarantee. This problem is due to <em>non-deterministic</em> SQL functions like TIME, DATE, and RANDOM. If the time used by the information to travel from Singapore to New York is 100ms, then the TIME function will be 100ms higher when written to the New York node, which can have catastrophic consequences for the logic of our solution.</p>
<p>Some database engines warn users not to use <em>non-deterministic</em> SQL functions, introducing severe limitations in database usage. Other database engines implemented complex SQL parsers that replace <em>non-deterministic</em> SQL functions with <em>deterministic</em>  values. This solution introduces a runtime delay because each SQL statement must be parsed and analyzed. More importantly, it increases the difficulty of staying up-to-date with the new versions of the underline SQL engine (SQLite in this specific case) because the custom parser must be updated each time a new SQL function/feature is introduced.</p>
<p><strong>How to safely distribute a non-deterministic SQL statement?</strong></p>
<p>With <a target="_blank" href="https://sqlitecloud.io/">SQLite Cloud</a>, we never distribute an SQL statement as-is, we only distribute the changeset derived from executing the SQL statement in one node.</p>
<p>In other words, instead of distributing this raw SQL statement:</p>
<pre><code><span>INSERT</span> <span>INTO</span> foo (col1, col2, col3) <span>VALUES</span> (RANDOM(), <span>TIME</span>(), <span>DATE</span>());
</code></pre>
<p>We distribute the result of the statement (plus some other metadata):</p>
<pre><code>{
    <span>&#34;table&#34;</span>: foo,
    <span>&#34;data&#34;</span>: {
        <span>&#34;col1&#34;</span>: <span>8875612685081594789</span>,
        <span>&#34;col2&#34;</span>: <span>&#34;10:57:34&#34;</span>,
        <span>&#34;col3&#34;</span>: <span>&#34;2023-03-21&#34;</span>
    }
}
</code></pre>
<p>By distributing a changeset we are immune to the side effects of <em>non-deterministic</em> SQL statements.</p>
<p>SQLite Cloud is now in beta and we understand that users feedback is critical to our success. As such, I would like to personally invite you to <a target="_blank" href="https://sqlitecloud.io/register">join our beta program</a> and share any comments, observations, or feature requests that you may have with us.</p>
<p>As a beta tester, you have a unique opportunity to help shape the future of <a target="_blank" href="https://sqlitecloud.io/">SQLite Cloud</a>. Your feedback will help us to identify areas for improvement and to develop new features that meet your needs. We are committed to providing you with a high-quality cloud database service, and we believe that your input will be invaluable in achieving this goal.</p>
</div></div></div>
  </body>
</html>
