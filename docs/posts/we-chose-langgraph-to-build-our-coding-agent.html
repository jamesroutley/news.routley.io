<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.qodo.ai/blog/why-we-chose-langgraph-to-build-our-coding-agent/">Original</a>
    <h1>We chose LangGraph to build our coding agent</h1>
    
    <div id="readability-page-1" class="page"><div data-post-content="">
									<figure>
						<img width="900" height="604" src="https://www.qodo.ai/wp-content/uploads/2025/03/Why-We-Chose-LangGraph-for-Building-Our-Coding-Agent.png" alt=""/>					</figure>
					<p>We’ve been building AI coding assistants at Qodo since the GPT-3 days. Our initial approach was highly structured with predefined flows for different coding tasks like test generation, code reviews, and improvements. This approach worked well with earlier generations of LLMs and with structured flows we were able to get real-world value from older models, despite all of their limitations.</p>
<p>Since Claude Sonnet 3.5 was released 9 months ago, LLMs have become significantly more capable at general-purpose coding tasks. The new models opened up the possibility to build something more dynamic and flexible while still maintaining our standards for code quality. We wanted to move away from rigid workflows to an agent that could adapt to any kind of user request, while still reflecting our opinionated views on how AI can be best used for coding.</p>
<p>Initially, we needed a framework that would let us quickly validate our ideas and from the few options that were available about 4 months ago, we settled on LangGraph for our initial proof of concept. We were pleasantly surprised to see that the framework has proven flexible and mature enough to carry us all the way to production.</p>
<p>In this post, I’ll explain why LangGraph was the right choice for us, and how it enabled us to build a coding assistant that balances flexibility with our opinionated approach to coding best practices.</p>
<h2 id="flexibility-to-be-opinionated">Flexibility to be opinionated</h2>
<p>Our key consideration was the ability to create opinionated workflows while maintaining adaptability. LangGraph takes a graph-based approach that gives you flexibility to build agents that land anywhere on the spectrum from completely open-ended — where you just give an LLM all available tools and let it run in a loop — to fully structured deterministic flows (like the ones we started with).</p>
<p>At its core, LangGraph lets you define a state machine for your agent. You create nodes that represent discrete steps in your workflow and edges that define the possible transitions between them. Each node can perform specific functions—gathering context, planning, generating code, or validating—while the graph structure determines how these functions connect.</p>
<p>The density of connections in the graph corresponds to how structured or flexible your agent is. A sparse graph with few connections corresponds with a more rigid, predictable flow where each step leads to exactly one next step. A dense graph with many interconnections gives the agent more freedom to choose its path.</p>
<p>Future, more capable models might work best with fully open-ended approaches. But even with the best current LLMs, you still get better results when you guide them through the problem. If you use LLMs directly for coding, you’ve probably already developed your own workflow — like breaking problems down, providing context strategically, guiding the model through complex reasoning, and backtracking or iterating when needed.</p>
<p>The nice thing about LangGraph’s flexibility is that we can easily recalibrate how structured our flows are when new, more powerful models are released.</p>
<p>Our main flow follows a pattern that you might recognize: first, a context collection node gathers relevant information from the codebase (and external resources <a href="https://www.qodo.ai/blog/building-agentic-flows-with-langgraph-model-context-protocol/">via MCP integration</a>); next, a planning node breaks down the task into manageable steps; then an execution node generates the actual code; finally, a validation node checks the output against best practices and requirements. When validation fails, the agent loops back to execution with specific feedback rather than starting from scratch.</p>
<p><img loading="lazy" src="https://www.qodo.ai/wp-content/uploads/2025/03/main-workflow-1.png" alt="" width="900" height="1162" srcset="https://www.qodo.ai/wp-content/uploads/2025/03/main-workflow-1.png 900w, https://www.qodo.ai/wp-content/uploads/2025/03/main-workflow-1-232x300.png 232w, https://www.qodo.ai/wp-content/uploads/2025/03/main-workflow-1-793x1024.png 793w, https://www.qodo.ai/wp-content/uploads/2025/03/main-workflow-1-768x992.png 768w, https://www.qodo.ai/wp-content/uploads/2025/03/main-workflow-1-25x32.png 25w, https://www.qodo.ai/wp-content/uploads/2025/03/main-workflow-1-58x75.png 58w, https://www.qodo.ai/wp-content/uploads/2025/03/main-workflow-1-37x48.png 37w" sizes="auto, (max-width: 900px) 100vw, 900px"/></p>
<h2 id="coherent-interface">Coherent interface</h2>
<p>When you’re building a complex system, a framework should simplify rather than complicate your work. LangGraph’s API does exactly that.</p>
<p>Here’s how a simplified version of our main workflow looks when implemented with LangGraph:</p>
<pre data-enlighter-language="python">from langgraph.graph import StateGraph, END

workflow = StateGraph(name=&#34;coding_assistant&#34;)
workflow.add_node(&#34;context_collector&#34;, collect_relevant_context)
workflow.add_node(&#34;task_planner&#34;, create_execution_plan)
workflow.add_node(&#34;task_executor&#34;, execute_plan)
workflow.add_node(&#34;validator&#34;, validate_output)

# Define flow between nodes
workflow.add_edge(&#34;context_collector&#34;, &#34;task_planner&#34;)
workflow.add_edge(&#34;task_planner&#34;, &#34;task_executor&#34;)
workflow.add_edge(&#34;task_executor&#34;, &#34;validator&#34;)

# Conditional routing based on validation results
workflow.add_conditional_edges(
    &#34;validator&#34;,
    should_revise,
    {
        True: &#34;task_executor&#34;,  # Loop back if revision needed
        False: END               # Complete if validation passes
    }
)

graph = workflow.compile()
graph.invoke({&#34;user_input&#34;: &#34;build me a game like levelsio&#34;})
</pre>
<p>This declarative approach makes the code almost self-documenting. The workflow definition directly mirrors our conceptual diagram, which makes it easy to reason about and modify.</p>
<p>Each node function receives the current state and returns updates to that state. There’s no magic happening behind the scenes, just straightforward state transitions.</p>
<p>LangChain gets a lot of flack for its overly complicated abstraction, but the team really cooked with the LangGraph interface. It adds just enough structure without getting in your way or forcing you to adopt a complicated mental model and puts your agent logic on full display rather than obscuring it behind abstractions.</p>
<h2 id="reusable-components-across-workflows">Reusable components across workflows</h2>
<p>Reusability is what separates valuable frameworks from disposable ones. The node-based architecture that LangGraph uses is great here.</p>
<p>Our context collection node is a good example. It handles gathering relevant information from the codebase and it’s used in pretty much every flow. The same goes for our validation node, which checks code quality and runs tests. These components can slot into different graphs with minimal configuration.</p>
<p>As we build out more flows, the velocity payout is huge. We’re building specialized flows like TDD that have different structures but reuse many of the same nodes, just connected in a different configuration with a few specialized components added in.</p>
<p><img loading="lazy" src="https://www.qodo.ai/wp-content/uploads/2025/03/tdd-workflow-1.png" alt="" width="900" height="1162" srcset="https://www.qodo.ai/wp-content/uploads/2025/03/tdd-workflow-1.png 900w, https://www.qodo.ai/wp-content/uploads/2025/03/tdd-workflow-1-232x300.png 232w, https://www.qodo.ai/wp-content/uploads/2025/03/tdd-workflow-1-793x1024.png 793w, https://www.qodo.ai/wp-content/uploads/2025/03/tdd-workflow-1-768x992.png 768w, https://www.qodo.ai/wp-content/uploads/2025/03/tdd-workflow-1-25x32.png 25w, https://www.qodo.ai/wp-content/uploads/2025/03/tdd-workflow-1-58x75.png 58w, https://www.qodo.ai/wp-content/uploads/2025/03/tdd-workflow-1-37x48.png 37w" sizes="auto, (max-width: 900px) 100vw, 900px"/></p>
<h2 id="state-management">State management</h2>
<p>The most satisfying part of adopting the right framework is when you get useful functionality out of the box. LangGraph’s built-in state management is a perfect example.</p>
<p>Adding persistence to our agent took just a few lines of code:</p>
<pre data-enlighter-language="python">from langgraph.graph import StateGraph, END
from langgraph.checkpoint.postgres import PostgresSaver

workflow = StateGraph(name=&#34;coding_assistant&#34;)
...
...

checkpointer = PostgresSaver.from_conn_string(
    &#34;postgresql://user:password@localhost:5432/db&#34;
)
checkpointer.setup()

graph = workflow.compile(checkpointer=checkpointer)
</pre>
<p>That’s it. With this simple addition, our entire workflow state—including context collected, plans made, and code generated—persists to our postgres database without us building any custom infrastructure. There are also SQLite and in memory checkpointers that can be added just as easily.</p>
<p>What’s really neat is that this doesn’t just enable basic persistence across sessions. It supports checkpoints and branch points so you can undo and replay changes.</p>
<h2 id="areas-for-growth">Areas for growth</h2>
<p>While LangGraph has been a great foundation for our agentic flows, it’s not without challenges. One pain point has been documentation. The framework is developing very quickly and the docs are sometimes incomplete or out of date. The maintainers are great and were super responsive on Slack (thanks Harrison and Nuno for all the help :)). Be prepared to potentially need to communicate directly with the project maintainers if you’re using the newer and more niche capabilities.</p>
<p>Testing and mocking is a huge challenge when developing LLM driven systems that aren’t deterministic. Even relatively simple flows are extremely hard to reproduce. Our agent interacts extensively with the IDE, which is difficult to simulate in automated tests. We built a mock repository that simulates basic IDE operations, but it doesn’t perfectly replicate the real environment. This creates a gap between what we can test automatically and what happens in production.</p>
<p>For example, operations like “find all usages of this function” that depend on the IDE’s language server are particularly hard to mock. This forced us to rely more on manual testing than we’d prefer, which slowed down the iteration cycle.</p>
<p>Mature frameworks tend to provide robust infrastructure for mocking and testing. I’m hopeful that LangGraph will develop in these areas over time.</p>

				<div data-post-modal="">
					<figure data-modal-figure="">
						<img src="" alt="" data-modal-img=""/>
					</figure>
				</div>
			</div></div>
  </body>
</html>
