<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interrupt.memfault.com/blog/zero-to-main-1">Original</a>
    <h1>From Zero to main(): Bare metal C</h1>
    
    <div id="readability-page-1" class="page"><div>

        <p>Working on embedded software, one quickly develops a quasi-religious respect for
the axioms of embedded C programming:</p>

<ol>
  <li>The entry point of thy program shall be named “main”.</li>
  <li>Thou shalt initialize thy static variables, else The Machine shall set them
to zero.</li>
  <li>Thou shalt implement The Interrupts. HardFault_Handler chief among them, but
also SysTick_Handler.</li>
</ol>

<p>Ask an engineer where those rules come from, and they’ll wave towards cryptic startup files implemented in assembly. Often times those files are copy-pasted
from project to project. Seldom are they ever read, let alone modified.</p>

<!-- excerpt start -->
<p>Throughout the <a href="https://riskmusings.substack.com/tag/zero-to-main">Zero to main() series</a> of posts,
we demystify what happens between when power is applied
and your main function is called. In the process, we’ll learn how to bootstrap a
C environment, implement a bootloader, relocate code, and more!
<!-- excerpt end --></p>

<h2 id="setting-the-stage">Setting the stage</h2>

<p>While most of the concepts and code presented in this series should work for all
Cortex-M series MCUs, our examples target the SAMD21G18 processor by Atmel. This
is a Cortex-M0+ chip found on several affordable development boards.</p>

<p>Specifically, we are using:</p>

<ul>
  <li>Adafruit’s <a href="https://www.adafruit.com/product/3505" target="_blank">Metro M0 Express</a> as our
development board,</li>
  <li>a simple <a href="https://www.adafruit.com/product/2764" target="_blank">CMSIS-DAP Adapter</a>
</li>
  <li>OpenOCD (the <a href="https://github.com/arduino/OpenOCD" target="_blank">Arduino fork</a>) for programming</li>
</ul>

<p>In each case, we’ll implement a simple blinking LED application. It is not
particularly interesting in itself, but for the sake of completeness you can
find the code reproduced below.</p>

<div><div><pre><code><span>#include &lt;samd21g18a.h&gt;
</span>
<span>#include &lt;port.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
</span>
<span>#define LED_0_PIN PIN_PA17
</span>
<span>static</span> <span>void</span> <span>set_output</span><span>(</span><span>const</span> <span>uint8_t</span> <span>pin</span><span>)</span> <span>{</span>
  <span>struct</span> <span>port_config</span> <span>config_port_pin</span><span>;</span>
  <span>port_get_config_defaults</span><span>(</span><span>&amp;</span><span>config_port_pin</span><span>);</span>
  <span>config_port_pin</span><span>.</span><span>direction</span> <span>=</span> <span>PORT_PIN_DIR_OUTPUT</span><span>;</span>
  <span>port_pin_set_config</span><span>(</span><span>pin</span><span>,</span> <span>&amp;</span><span>config_port_pin</span><span>);</span>
  <span>port_pin_set_output_level</span><span>(</span><span>pin</span><span>,</span> <span>false</span><span>);</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>set_output</span><span>(</span><span>LED_0_PIN</span><span>);</span>
  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>port_pin_toggle_output_level</span><span>(</span><span>LED_0_PIN</span><span>);</span>
    <span>for</span> <span>(</span><span>volatile</span> <span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>100000</span><span>;</span> <span>++</span><span>i</span><span>)</span> <span>{}</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<h2 id="power-on">Power on!</h2>

<p>So how did we get to main? All we can tell from observation is that we applied
power to the board and our code started executing. There must be behavior
intrinsic to the chip that defines how code is executed.</p>

<p>And indeed, there is! Digging into the <a href="https://static.docs.arm.com/ddi0419/d/DDI0419D_armv6m_arm.pdf" target="_blank">ARMv6-M Technical Reference
Manual</a>, which is
the underlying architecture manual for the Cortex-M0+, we can
find some pseudo-code that describes reset behavior:</p>

<div><div><pre><code><span>// B1.5.5 TakeReset()</span>
<span>// ============</span>
<span>TakeReset</span><span>()</span>
    <span>VTOR</span> <span>=</span> <span>Zeros</span><span>(</span><span>32</span><span>);</span>
    <span>for</span> <span>i</span> <span>=</span> <span>0</span> <span>to</span> <span>12</span>
        <span>R</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>bits</span><span>(</span><span>32</span><span>)</span> <span>UNKNOWN</span><span>;</span>
    <span>bits</span><span>(</span><span>32</span><span>)</span> <span>vectortable</span> <span>=</span> <span>VTOR</span><span>;</span>
    <span>CurrentMode</span> <span>=</span> <span>Mode_Thread</span><span>;</span>
    <span>LR</span> <span>=</span> <span>bits</span><span>(</span><span>32</span><span>)</span> <span>UNKNOWN</span><span>;</span> <span>// Value must be initialised by software</span>
    <span>APSR</span> <span>=</span> <span>bits</span><span>(</span><span>32</span><span>)</span> <span>UNKNOWN</span><span>;</span> <span>// Flags UNPREDICTABLE from reset</span>
    <span>IPSR</span><span>&lt;</span><span>5</span><span>:</span><span>0</span><span>&gt;</span> <span>=</span> <span>Zeros</span><span>(</span><span>6</span><span>);</span> <span>// Exception number cleared at reset</span>
    <span>PRIMASK</span><span>.</span><span>PM</span> <span>=</span> <span>&#39;0&#39;</span><span>;</span> <span>// Priority mask cleared at reset</span>
    <span>CONTROL</span><span>.</span><span>SPSEL</span> <span>=</span> <span>&#39;0&#39;</span><span>;</span> <span>// Current stack is Main</span>
    <span>CONTROL</span><span>.</span><span>nPRIV</span> <span>=</span> <span>&#39;0&#39;</span><span>;</span> <span>// Thread is privileged</span>
    <span>ResetSCSRegs</span><span>();</span> <span>// Catch-all function for System Control Space reset</span>
    <span>for</span> <span>i</span> <span>=</span> <span>0</span> <span>to</span> <span>511</span> <span>// All exceptions Inactive</span>
        <span>ExceptionActive</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>&#39;0&#39;</span><span>;</span>
    <span>ClearEventRegister</span><span>();</span> <span>// See WFE instruction for more information</span>
    <span>SP_main</span> <span>=</span> <span>MemA</span><span>[</span><span>vectortable</span><span>,</span><span>4</span><span>]</span> <span>AND</span> <span>0xFFFFFFFC</span><span>&lt;</span><span>31</span><span>:</span><span>0</span><span>&gt;</span><span>;</span>
    <span>SP_process</span> <span>=</span> <span>((</span><span>bits</span><span>(</span><span>30</span><span>)</span> <span>UNKNOWN</span><span>)</span><span>:</span><span>&#39;</span><span>00</span><span>&#39;</span><span>);</span>
    <span>start</span> <span>=</span> <span>MemA</span><span>[</span><span>vectortable</span><span>+</span><span>4</span><span>,</span><span>4</span><span>];</span> <span>// Load address of reset routine</span>
    <span>BLXWritePC</span><span>(</span><span>start</span><span>);</span> <span>// Start execution of reset routine</span>
</code></pre></div></div>

<p>In short, the chip does the following:</p>

<ul>
  <li>Reset the vector table address to <code>0x00000000</code>
</li>
  <li>Disable all interrupts</li>
  <li>Load the SP from address <code>0x00000000</code>
</li>
  <li>Load the PC from address <code>0x00000004</code>
</li>
</ul>

<p>“Mystery solved!”, you’ll say. Our <code>main</code> function must be at address
<code>0x00000004</code>!</p>

<p>Let us check.</p>

<p>First, we dump our <code>bin</code> file to see what address <code>0x0000000</code> and <code>0x00000004</code> contain:</p>

<div><div><pre><code><span>francois-mba:zero-to-main francois$</span><span> </span>xxd build/minimal/minimal.bin  | <span>head</span>
<span>00000000: 0020 0020 c100 0000 b500 0000 bb00 0000  . . ............
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span></code></pre></div></div>

<p>If I’m reading this correctly, our inital SP is <code>0x20002000</code>, and our start
address pointer is <code>0x000000c1</code>.</p>

<p>Let’s dump our symbols to see which one is at <code>0x000000c1</code>.</p>

<div><div><pre><code><span>francois-mba:minimal francois$</span><span> </span>arm-none-eabi-objdump <span>-t</span> build/minimal.elf | <span>sort</span>
<span>...
</span><span>000000b4 g     F .text  00000006 NMI_Handler
000000ba g     F .text  00000006 HardFault_Handler
000000c0 g     F .text  00000088 Reset_Handler
00000148 l     F .text  0000005c system_pinmux_get_group_from_gpio_pin
000001a4 l     F .text  00000020 port_get_group_from_gpio_pin
000001c4 l     F .text  00000022 port_get_config_defaults
000001e6 l     F .text  0000004e port_pin_set_output_level
00000234 l     F .text  00000038 port_pin_toggle_output_level
0000026c l     F .text  00000040 set_output
000002ac g     F .text  0000002c main
</span><span>...
</span></code></pre></div></div>

<p>That’s odd! Our main function is found at <code>0x000002ac</code>. No symbol at <code>0x000000c1</code>, but a
<code>Reset_Handler</code> symbol at <code>0x000000c0</code>.</p>

<p>It turns out that the lowest bit of the PC is used to indicate thumb2
instructions, which is one of the two instruction sets supported by ARM
processors, so <code>Reset_Handler</code> is what we’re looking for (for more details check
out section A4.1.1 in the ARMv6-M manual).</p>

<h2 id="writing-a-reset_handler">Writing a Reset_Handler</h2>

<p>Unfortunately, the Reset_Handler is often an inscrutable mess of Assembly code.
See the <a href="https://github.com/NordicSemiconductor/nrfx/blob/293f553ed9551c1fdfd05eac48e75bbdeb4e7290/mdk/gcc_startup_nrf52.S#L217" target="_blank">nRF52 SDK
startup</a>
file for example.</p>

<p>Instead of going through this file line-by-line, let’s see if we can write a
minimal Reset_Handler from first principles.</p>

<p>Here again, ARM’s Technical Reference Manuals are useful. <a href="https://developer.arm.com/docs/ddi0337/e/exceptions/resets/intended-boot-up-sequence" target="_blank">Section 5.9.2 of the
Cortex-M3
TRM</a>
contains the following table:</p>

<table summary="Reset boot-up behavior">
<caption>Reset boot-up behavior</caption>
    <thead xmlns="http://www.w3.org/1999/xhtml">
        <tr>
<th>Action</th>
<th>Description</th>
</tr>
    </thead>
    <tbody xmlns="http://www.w3.org/1999/xhtml">
        <tr>
            <td>Initialize variables</td>
            <td>Any global/static variables must be setup. This includes
initializing the BSS variable to 0, and copying initial values from ROM to RAM
for non-constant variables.</td>
        </tr>
        <tr>
            <td>[Setup stacks]</td>
            <td>If more than one stack is be used, the other banked SPs must be
initialized. The current SP can also be changed to Process from Main.</td>
        </tr>
        <tr>
            <td>[Initialize any runtime]</td>
            <td>Optionally make calls to C/C++ runtime init code to enable use
of heap, floating point, or other features. This is normally done by <code>__main</code> from the C/C++ library.</td>
        </tr>
    </tbody>
</table>


<blockquote>
  <p>All objects with static storage duration shall be initialized (set to their
initial values) before program startup. The manner and timing of such
initialization are otherwise unspecified.</p>
</blockquote>

<p>(Section 5.1.2, Execution environment)</p>

<p>In practice this means that given the following snippet:</p>

<div><div><pre><code><span>static</span> <span>uint32_t</span> <span>foo</span><span>;</span>
<span>static</span> <span>uint32_t</span> <span>bar</span> <span>=</span> <span>2</span><span>;</span>
</code></pre></div></div>

<p>Our <code>Reset_Handler</code> needs to make sure that the memory at <code>&amp;foo</code> is 0x00000000, and the
memory at <code>&amp;bar</code> is 0x00000002.</p>

<p>We cannot just go and initialize each variable one by one. Instead, we rely on
the compiler (technically, the linker) to put all those variables in the same
place so we can initialize them in one fell swoop.</p>

<p>For static variables that must be zeroed, the linker gives us <code>_sbss</code> and
<code>_ebss</code> as start and end addresses. We can therefore do:</p>

<div><div><pre><code><span>/* Clear the zero segment */</span>
<span>for</span> <span>(</span><span>uint32_t</span> <span>*</span><span>bss_ptr</span> <span>=</span> <span>&amp;</span><span>_sbss</span><span>;</span> <span>bss_ptr</span> <span>&lt;</span> <span>&amp;</span><span>_ebss</span><span>;)</span> <span>{</span>
    <span>*</span><span>bss_ptr</span><span>++</span> <span>=</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>For static variables with an init value, the linker gives us:</p>
<ul>
  <li>
<code>_etext</code> as the address the init values are stored at</li>
  <li>
<code>_sdata</code> as the address the static variables live at</li>
  <li>
<code>_edata</code> as the end of the static variables memory</li>
</ul>

<p>We then can do:</p>
<div><div><pre><code><span>uint32_t</span> <span>*</span><span>init_values_ptr</span> <span>=</span> <span>&amp;</span><span>_etext</span><span>;</span>
<span>uint32_t</span> <span>*</span><span>data_ptr</span> <span>=</span> <span>&amp;</span><span>_sdata</span><span>;</span>
<span>if</span> <span>(</span><span>init_values_ptr</span> <span>!=</span> <span>data_ptr</span><span>)</span> <span>{</span>
    <span>for</span> <span>(;</span> <span>data_ptr</span> <span>&lt;</span> <span>&amp;</span><span>_edata</span><span>;)</span> <span>{</span>
        <span>*</span><span>data_ptr</span><span>++</span> <span>=</span> <span>*</span><span>init_values_ptr</span><span>++</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Putting it together, we can write our <code>Reset_Handler</code></p>

<div><div><pre><code><span>void</span> <span>Reset_Handler</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>/* Copy init values from text to data */</span>
    <span>uint32_t</span> <span>*</span><span>init_values_ptr</span> <span>=</span> <span>&amp;</span><span>_etext</span><span>;</span>
    <span>uint32_t</span> <span>*</span><span>data_ptr</span> <span>=</span> <span>&amp;</span><span>_sdata</span><span>;</span>

    <span>if</span> <span>(</span><span>init_values_ptr</span> <span>!=</span> <span>data_ptr</span><span>)</span> <span>{</span>
        <span>for</span> <span>(;</span> <span>data_ptr</span> <span>&lt;</span> <span>&amp;</span><span>_edata</span><span>;)</span> <span>{</span>
            <span>*</span><span>data_ptr</span><span>++</span> <span>=</span> <span>*</span><span>init_values_ptr</span><span>++</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/* Clear the zero segment */</span>
    <span>for</span> <span>(</span><span>uint32_t</span> <span>*</span><span>bss_ptr</span> <span>=</span> <span>&amp;</span><span>_sbss</span><span>;</span> <span>bss_ptr</span> <span>&lt;</span> <span>&amp;</span><span>_ebss</span><span>;)</span> <span>{</span>
        <span>*</span><span>bss_ptr</span><span>++</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>We still need to start our program! That’s achieved with a simple call to
<code>main()</code>.</p>

<div><div><pre><code><span>void</span> <span>Reset_Handler</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>/* Copy init values from text to data */</span>
    <span>uint32_t</span> <span>*</span><span>init_values_ptr</span> <span>=</span> <span>&amp;</span><span>_etext</span><span>;</span>
    <span>uint32_t</span> <span>*</span><span>data_ptr</span> <span>=</span> <span>&amp;</span><span>_sdata</span><span>;</span>

    <span>if</span> <span>(</span><span>init_values_ptr</span> <span>!=</span> <span>data_ptr</span><span>)</span> <span>{</span>
        <span>for</span> <span>(;</span> <span>data_ptr</span> <span>&lt;</span> <span>&amp;</span><span>_edata</span><span>;)</span> <span>{</span>
            <span>*</span><span>data_ptr</span><span>++</span> <span>=</span> <span>*</span><span>init_values_ptr</span><span>++</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/* Clear the zero segment */</span>
    <span>for</span> <span>(</span><span>uint32_t</span> <span>*</span><span>bss_ptr</span> <span>=</span> <span>&amp;</span><span>_sbss</span><span>;</span> <span>bss_ptr</span> <span>&lt;</span> <span>&amp;</span><span>_ebss</span><span>;)</span> <span>{</span>
        <span>*</span><span>bss_ptr</span><span>++</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */</span>
    <span>NVMCTRL</span><span>-&gt;</span><span>CTRLB</span><span>.</span><span>bit</span><span>.</span><span>MANW</span> <span>=</span> <span>1</span><span>;</span>

    <span>/* Branch to main function */</span>
    <span>main</span><span>();</span>

    <span>/* Infinite loop */</span>
    <span>while</span> <span>(</span><span>1</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>You will note that we added two things:</p>
<ol>
  <li>An infinite loop after <code>main()</code>, so we do not run off into the weeds if the
main function returns</li>
  <li>Workaround for chip bugs which are best taken care of before our program
starts. Sometimes these are wrapped in a <code>SystemInit</code> function called by the
<code>Reset_Handler</code> before <code>main</code>. This is the approach <a href="https://github.com/NordicSemiconductor/nrfx/blob/6f54f689e9555ea18f9aca87caf44a3419e5dd7a/mdk/system_nrf52811.c#L60" target="_blank">taken by
Nordic</a>.</li>
</ol>

<h2 id="closing">Closing</h2>

<p>All the code used in this blog post is available on
<a href="https://github.com/memfault/zero-to-main/tree/master/minimal" target="_blank">Github</a>.</p>

<p>See anything you&#39;d like to change? Submit a pull request or open an issue at <a href="https://github.com/memfault/interrupt" target="_blank">GitHub</a></p>

<p>More complex programs often require a more complicated <code>Reset_Handler</code>. For
example:</p>
<ol>
  <li>Relocatable code must be copied over</li>
  <li>If our program relies on libc, we must initialize it</li>
  <li>More complex memory layouts can add a few copy / zero loops</li>
</ol>

<p>We’ll cover all of them in future posts. But before that,
we’ll talk about how the magical memory region variables come about,
how our <code>Reset_Handler</code>’s address ends up at <code>0x00000004</code>, and how to write a
linker script in our next post!</p>

<p><em>EDIT: Post written!</em> - <a href="https://riskmusings.substack.com/blog/how-to-write-linker-scripts-for-firmware">From Zero to main(): Demystifying Firmware Linker Scripts</a></p>


    </div><p><img src="https://riskmusings.substack.com/img/author/francois.jpg"/>
            
            <span>
                <a href="https://riskmusings.substack.com/authors/francois">François Baldassari</a> has worked on the embedded software teams at Sun, Pebble, and Oculus. He is currently the CEO of <a href="https://memfault.com" target="_blank">Memfault</a>.</span>

        </p></div>
  </body>
</html>
