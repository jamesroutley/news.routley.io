<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pinecone.io/learn/autoencoders/">Original</a>
    <h1>Introduction to Autoencoders</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>Our minds extract and compress knowledge from the world, which we reuse to face other similar situations. One of the critical aspects of that process is that we don’t store all the details of the actual event: just the essential information that allows us to recreate it.</p><p>What if you could use Machine Learning to do the same thing? Could boil down knowledge into a reduced data space to be used later? That is what Autoencoders do.</p><p>An autoencoder is an Artificial Neural Network algorithm capable of discovering structure within data to develop a compressed representation of some input. It does this, in simple terms, by learning to copy its input to its output.</p><p>Autoencoders were designed to encode a data input into a compressed and meaningful representation and then decode it back such that the reconstructed output is as similar as possible to the original input. An autoencoder aims to learn a lower-dimensional representation of higher-dimensional data while maintaining the most crucial information from the initial input.</p><h2 id="the-anatomy-of-autoencoders">The Anatomy of Autoencoders</h2><p>Autoencoders consist of <a href="https://www.v7labs.com/blog/autoencoders-guide">three components</a>:</p><ol><li><strong>Encoder</strong>: A module that compresses the train-validate-test set input data into an encoded representation that is typically several orders of magnitude smaller than the input data.</li><li><strong>Bottleneck</strong> or <strong>Latent Representation</strong>: A module that contains the compressed knowledge representations and is, therefore, the most important part of the network.</li><li><strong>Decoder</strong>: A module that helps the network “decompress” the knowledge representations and reconstruct the data from its encoded form. The output is then compared with the ground truth.</li></ol><p>The anatomy of an autoencoder looks like this:</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/05601d7884b83ed92c0e159f50c943574420060e/3db32/images/autoencoders-1.png" alt="Latent representation" width="100%"/>
<small>Autoencoders output a reconstruction of the input. The autoencoder consists of two smaller networks: an encoder and a decoder. During training, the encoder learns a set of features, known as a latent representation, from the data input. At the same time, the decoder is trained to reconstruct the data based on these features. The autoencoder can then be applied to predict inputs not previously seen. Source: <a href="https://www.mathworks.com/discovery/autoencoder.html">MathWorks</a></small></p><p>This way, the encoder generates a reduced feature representation of an initial data input (e.g., an image), and the decoder is used to reconstruct that initial input from the encoder’s output. During this process, the dimensionality of the data input is reduced (you can see that the middle layers have fewer units compared to the input and output layers). These middle layers hold the compressed representation of the input, and the output is reconstructed from this reduced representation.</p><p>Autoencoders are trained by minimizing a reconstruction loss function, which measures how well the autoencoder can reconstruct the input data from the hidden representation.</p><p>In practical terms, autoencoders are used for:</p><ul><li><p><strong>Data denoising</strong>: Since they can be trained to <a href="https://www.tensorflow.org/tutorials/generative/autoencoder#third_example_anomaly_detection">remove noise from different data types, like images</a>: you train an autoencoder using the noisy image as input, and the original image as the target.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/99a452c5a196ad74117a2bb78417302ea522fb86/7a35e/images/autoencoders-2.png" alt="Denoising images" width="100%"/>
<small>Denoising images using the Fashion MNIST dataset. Source: <a href="https://www.tensorflow.org/tutorials/generative/autoencoder#second_example_image_denoising">TensorFlow</a></small></p></li><li><p><strong>Anomaly detection</strong>: Through encoding and decoding, you’ll know how well you can generally reconstruct your data. If an autoencoder is presented with unusual data that shows something the model has never seen before, the <a href="https://rapidminer.com/blog/autoencoders/">error when reconstructing the input after the bottleneck will be much higher</a>.</p></li><li><p><strong><a href="https://www.pinecone.io/learn/dimensionality-reduction/">Dimensionality reduction</a></strong>: after training, the decoder can be discarded, and the output from the encoder can be used directly as the <a href="https://machinelearningmastery.com/dimensionality-reduction-for-machine-learning/">reduced dimensionality of the input</a>. This output serves as a type of projection, and like other projection methods, there is no direct relationship between the bottleneck and the original input variables, making them challenging to interpret.</p></li><li><p><strong>Data generation</strong>: Autoencoders can be used to <a href="https://blog.roboflow.com/what-is-an-autoencoder-computer-vision/">generate both image and time series data</a>. The parameterized distribution in the code of the autoencoder can be randomly sampled to generate discrete values for latent vectors, which can then be forwarded to the decoder, leading to the generation of new data.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/14e57aa7e8338e2fdf6e42668348b69aac533db2/0ba57/images/autoencoders-3.jpg" alt="Creation of a deepfake" width="100%"/>
<small>Creation of a deepfake using an autoencoder and decoder. The same encoder-decoder pair is used to learn the latent features of the faces during training, while during generation, Decoders are swapped, such that latent face A is subjected to decoder B to generate face A with the features of face B. Source: <a href="https://www.researchgate.net/figure/Creation-of-a-Deepfake-using-an-auto-encoder-and-decoder-The-same-encoder-decoder-pair_fig2_349703826">ResearchGate</a></small></p></li><li><p><strong>Recommendation tasks</strong>: the input and output vectors are typically a representation of the user. For example, in the case of <a href="https://ojs.aaai.org/index.php/aimagazine/article/view/18140">video recommendation</a>, each element of the vector refers to a video, and its value could be 1 if the user has played the video, and 0 otherwise. Besides binary vectors, continuous-valued ones may also be used, for example, to capture the time duration a user watched a video.</p></li></ul><p>Autoencoders must deal with an <a href="https://www.analyticsvidhya.com/blog/2022/09/all-you-need-to-know-about-autoencoders-in-2022/">intrinsic trade-off</a>: they should reconstruct the input well enough (reducing the reconstruction error) while generalizing the low representation to something meaningful (so that the model doesn’t simply memorize or overfit the training data). Let’s see next how this is done.</p><h2 id="types-of-autoencoders">Types of Autoencoders</h2><p>Some popular architectures are undercomplete, sparse, denoising, and variational autoencoders.</p><h3 id="undercomplete-autoencoders">Undercomplete Autoencoders</h3><p>The simplest architecture for constructing an autoencoder is to <a href="https://www.jeremyjordan.me/autoencoders/">constrain the number of nodes</a> present in the hidden layer(s) of the network, limiting the amount of information that can flow through it.</p><p>Undercomplete autoencoders have a smaller dimension for the middle layers compared to the input layer, which helps to obtain essential features from the data. By penalizing the network according to the reconstruction error, the model can learn the most important attributes of the input data and how to best reconstruct the original input from an “encoded” state.</p><p>Undercomplete autoencoders work by <a href="https://neptune.ai/blog/autoencoders-case-study-guide">limiting the capacity of the model</a> as much as possible, minimizing the amount of information that flows through the network. Consequently, they are not versatile and tend to overfit since they are a simple model with limited capacity and reduced flexibility.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/a49745b808a51658bd61d73cff2bde53ce5080c9/c182e/images/autoencoders-4.png" alt="Undercomplete autoencoder" width="auto"/>
<small>The architecture of an undercomplete autoencoder with a single encoding layer and a single decoding layer. Source: <a href="https://www.researchgate.net/figure/Architecture-of-an-undercomplete-autoencoder-with-a-single-encoding-layer-and-a-single_fig1_340711214">ResearchGate</a></small></p><h3 id="sparse-autoencoders">Sparse Autoencoders</h3><p>Sparse autoencoders represent an alternative method for introducing bottlenecks. Instead of constraining the number of nodes, it forces sparsity on the hidden layers. A sparse autoencoder has small numbers of simultaneously active neural nodes.</p><p>This type of autoencoder penalizes the use of hidden node connections, regularizing the model and keeping it from overfitting the data: only a reduced number of hidden units are allowed to be active simultaneously.</p><p>This way, even when the number of hidden units is large (perhaps even greater than the number of input units), we can <a href="https://web.stanford.edu/class/cs294a/sparseAutoencoder.pdf">still discover interesting structures</a> by imposing sparsity constraints on them.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/be3e015582da7519f80998b6cf790d88d79fc364/17fb7/images/autoencoders-5.png" alt="Sparse autoencoder" width="auto"/>
<small>Simple schema of a single-layer sparse autoencoder. The hidden nodes in bright yellow are activated, while the light yellow ones are inactive. The activation depends on the input. Source: <a href="https://www.wikiwand.com/en/Autoencoder">Wikiwand</a></small></p><p>On the downside, neuron activation depends on the input data, which means that even slight data variations will result in the activations of different nodes through the network.</p><h3 id="denoising-autoencoders">Denoising Autoencoders</h3><p>Approaches like undercomplete or sparse autoencoders rely on penalizing the network for being different from the original input. But another way to design an autoencoder is to <a href="https://www.analyticsvidhya.com/blog/2022/09/all-you-need-to-know-about-autoencoders-in-2022/">perturb the input data</a> but keep the pure data as the target output. With this approach, the model cannot simply create a mapping from input data to output data because they are no longer similar.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/3ee018e5f889cc879c4abb559cb73a6312b18704/d643f/images/autoencoders-6.png" alt="Sparse autoencoder" width="100%"/>
<small>Denoising autoencoders take a partially corrupted input while training to recover the original undistorted input. The model learns a vector field for mapping the input data towards a lower dimensional manifold which describes the natural data to cancel out the added noise. Source: <a href="https://iq.opengenus.org/types-of-autoencoder/">OpenGenusIQ</a></small></p><p>The goal of a denoising autoencoder is to remove those noises and yield a noise-free output. In doing so, the output of the autoencoder is meant to be de-noised and, therefore, different than the input. Noise removal is performed by mapping the input data into a lower-dimensional manifold (like in an undercomplete autoencoder), where this <a href="https://www.v7labs.com/blog/autoencoders-guide#h4">noise filtering becomes easier</a>.</p><p>Denoising autoencoders are great at <a href="https://neptune.ai/blog/autoencoders-case-study-guide">learning the latent representation in corrupted data</a> while creating a robust representation, allowing the model to recover true features.</p><p>Unlike previously seen models, denoising autoencoders can’t create a mapping from input to output data because they are no longer similar.</p><h3 id="variational-autoencoders">Variational Autoencoders</h3><p>Variational autoencoders (VAE) provide a <a href="https://www.jeremyjordan.me/variational-autoencoders/">probabilistic</a> way of describing latent space observations. Rather than an encoder that outputs a single value to describe each latent state attribute, a VAE describes a probability distribution for each latent attribute.</p><p>Look at the example below. While the image attributes (smile, skin tone, etc.) obtained after training a standard autoencoder can be used to reconstruct it from the compressed latent space, they are not continuous and, in effect, might not be easy to interpolate.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/36336904087d136cb6dc8d8f0a4b0bd1e9c15c99/8dc24/images/autoencoders-7.png" alt="variational autoencoder" width="100%"/>
<small>While these attributes explain the image and can be used in reconstructing the image from the compressed latent space, they do not allow the latent attributes to be expressed in a probabilistic fashion. Source: <a href="https://www.v7labs.com/blog/autoencoders-guide#h4">V7 Labs</a></small></p><p>VAEs deal with this topic by expressing each latent attribute as a probability distribution, forming a continuous latent space that can be easily sampled and interpolated. When decoding from the latent space, VAEs will randomly sample from each latent state distribution to feed the decoder.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/5a0e1002d26919210bea0fce4c98f0dc1e3f0e9b/434fe/images/autoencoders-8.png" alt="variational autoencoder" width="100%"/>
<small>In a VAE, the latent attributes are sampled from the latent distribution and fed to the decoder, reconstructing the input. Source: <a href="https://www.v7labs.com/blog/autoencoders-guide#h4">V7 Labs</a></small></p><p>VAEs enforce a continuous, <a href="https://www.jeremyjordan.me/variational-autoencoders/">smooth latent space</a> representation. For any sampling of the latent distributions, we expect the decoder model to reconstruct the input accurately. This way, values that are nearby to one another in the latent space should correspond with very similar reconstructions.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/85a0b1734b490b64cf104f7b68d652ef82dfdbef/fcae8/images/autoencoders-9.png" alt="variational autoencoder" width="100%"/>
<small>VAEs continuous latent space representation and sampling: Source: <a href="https://www.jeremyjordan.me/variational-autoencoders/">Jeremy Jordan</a></small></p><p>By sampling from the latent space, VAEs can be used as generative models capable of creating new data similar to what was observed during training.</p><h2 id="in-summary">In summary</h2><p>Whether to create <a href="https://www.pinecone.io/learn/vector-embeddings/">embeddings</a>, <a href="https://www.pinecone.io/learn/dimensionality-reduction/">reduce data dimensionality</a>, or detect anomalies, Autoencoders can serve multiple purposes. They are not only powerful tools for data compression and analysis but also for <a href="https://tech.preferred.jp/en/blog/i21_drug-design-and-weighted-retraining/">data generation</a>.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/3c7f20e4f0a04f5d061c396c1661a78c7127df92/269b3/images/autoencoders-10.png" alt="Types of autoencoders" width="auto"/>
<small>Different types of autoencoders. Source: <a href="https://www.theaidream.com/post/an-introduction-to-autoencoder-and-variational-autoencoder-vae">The A! Dream</a></small></p><p>Besides this versatility, you should always <a href="https://blog.keras.io/building-autoencoders-in-keras.html">note that</a>:</p><ol><li><p>Autoencoders are data-specific, meaning they will only be able to compress data similar to what they have been trained on. An autoencoder trained on pictures of faces would do a poor job compressing pictures of trees because the features it would learn would be face-specific.</p></li><li><p>Autoencoders are lossy, which means the decompressed outputs will be degraded compared to the original inputs (similar to MP3 or JPEG compression). This differs from lossless arithmetic compression.</p></li><li><p>Autoencoders are learned automatically from data examples, which is a valuable property: it is easy to train specialized algorithm instances that will perform well on a specific type of input. It doesn’t require any new engineering, just appropriate training data.</p></li></ol><p>Finally, remember that the ultimate goal of working with autoencoders is getting the model to learn a meaningful latent space representation.</p></div></div></div></div>
  </body>
</html>
