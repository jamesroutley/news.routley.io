<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://unixmagic.net/">Original</a>
    <h1>Annotated Unix Magic Poster</h1>
    
    <div id="readability-page-1" class="page"><p>Get ready for some Unix magic... ü™Ñ</p><div id="poster-info"><div><p>This is the <strong>UNIX Magic Poster</strong>, originally created by <strong>Gary Overacre</strong> in
the mid-1980s and published by UniTech Software.
It was later seen on display at a <a href="https://www.usenix.org/" target="_blank">USENIX
Conference</a>, reflecting its lasting influence in UNIX culture.
Head over to the <a href="https://github.com/drio/unixmagic" target="_blank">repo</a> if you‚Äôd like to
contribute!</p><p>UNIX has been a major influence on my career
from the very beginning. My first exposure to UNIX was during my college years,
when I had to write most of my first-year programming assignments on terminals
connected to an <a href="https://en.wikipedia.org/wiki/HP-UX">HP-UX</a> main server.
I was immediately captivated by the simplicity
and power UNIX offered‚Äîespecially compared to the operating systems I had used
before, like DOS and Windows.</p><p>That experience changed the way I thought about computers. From that point on,
I never looked back‚ÄîUNIX has been my constant companion in my computing journey
ever since.
This project is my humble rendition‚Äîa celebration of UNIX and its lasting impact
on me.</p></div></div><div><div id="annotation-01-shell"><div><p>The prominent position of the shell in the UNIX Magic poster reflects its
central role in UNIX systems. The shell was (and still is) the primary
interface for interacting with the kernel, serving as the workbench of the UNIX
user. It is an incredibly powerful tool, allowing users to launch and
coordinate processes, perform complex computations, and interface directly with
the operating system.</p><p>The shell is not just an interface; it is also a full programming language.
Users can write scripts to automate tasks, control processes, and build
pipelines to process data efficiently. This makes the shell both interactive
and programmable‚Äîsomething remarkably different from other operating systems of
its time.</p><p>While many shells exist today, the original was the Bourne shell (sh), which
laid the foundation for everything that followed.</p><p>Finally, I want to emphasize that the shell is the gateway to UNIX power. It is
the first point of contact when learning UNIX, and mastering it unlocks the
system‚Äôs full potential. I believe the poster captures this perfectly‚Äîthe shell
is at the heart of the wizard‚Äôs magic because it is the gateway to controlling
the system.</p></div></div><div id="annotation-02-man"><div><p>The <a href="https://man7.org/linux/man-pages/man1/man.1.html">man(1)</a>
command (short for manual) is used to display online reference manuals (man
pages) for commands, system calls, configuration files, and other aspects of
the system. man provides detailed documentation on how to use a command,
including its options, usage examples, related files, and other pertinent
details.</p><p>There‚Äôs some ambiguity as to what the interpretation of the man in the window
could represent.
The man is holding a scythe, which could represent <a href="https://en.wikipedia.org/wiki/Zombie_process">reaping a process</a>.
Under Unix like systems, process reaping is when a parent process reads
the exit status of a spawned child process, allowing the child process
to be removed from the process table.</p><p>Others have suggested that the man could represent a <a href="https://en.wikipedia.org/wiki/Hacker">hacker</a>,
a term used to mean a skilled or clever programmer.</p></div></div><div id="annotation-03-pipes"><p><a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">Pipes</a> are a
foundational feature in Unix that enable you to combine simple utilities into
more powerful workflows. By passing data from one command‚Äôs output to another
command‚Äôs input, pipes allow you to quickly create flexible, efficient, and
maintainable solutions directly at the command line. They are denoted in the
shell by the vertical bar character (|).</p></div><div id="annotation-04-leak"><p>A memory leak occurs when a computer program improperly manages memory
allocation, failing to release memory that‚Äôs no longer needed. Over time, these
un-freed allocations accumulate, reducing the amount of available memory for
other processes and potentially leading to slowdowns or crashes.</p></div><div id="annotation-05-kandr"><div><p>In the context of Unix history these three sets of initials refer to legendary
figures in the creation and development of Unix:</p><p>dmr: Dennis M. Ritchie, co-creator of Unix and creator of the C programming
language.</p><p>kt: Ken Thompson (often just ‚Äúken‚Äù in historical Unix references), co-creator
of Unix alongside Ritchie.</p><p>bwk: Brian W. Kernighan, co-author of several influential Unix programs and
books (including ‚ÄúThe C Programming Language‚Äù and ‚ÄúThe UNIX Programming
Environment‚Äù).</p></div></div><div id="annotation-06-c"><p>C is deeply intertwined with the history and development of the Unix operating
system. Created by Dennis M. Ritchie at Bell Labs in the early 1970s, C was
used to rewrite Unix from low-level assembly into a higher-level language. This
shift made Unix significantly more portable across different hardware
platforms, fueling its rapid adoption in academia and industry. Over time, C
evolved into one of the most influential and widely used programming languages
in history.</p></div><div id="annotation-07-backpressure"><div><p>When two processes communicate over a pipe, the process sending data is the
producer, and the process receiving data is the consumer. The OS maintains a
buffer to temporarily store data if the producer sends data faster than the
consumer can process it. However, if the buffer becomes full, the OS will block
the producer until space is available.</p><p>Was that the intention of the artist? You decide‚Äîis the valve handle in the
pipes a clever reference to UNIX back pressure, or is that a stretch?</p></div></div><div id="annotation-08-daemons"><div><p><a href="https://en.wikipedia.org/wiki/Daemon_(computing)">Daemons</a> are programs that run in the background
and are often started at system boot time. They respond to network requests, hardware activity,
or other programs by performing some task. Daemons such as cron may also perform
defined tasks at scheduled times.</p><p>The term was coined by the programmers at MIT‚Äôs Project MAC. It is inspired by Maxwell‚Äôs demon and
greek mythology, acting as a metaphor for a supernatural being working in the background.</p></div></div><div id="annotation-09-su"><p>The <a href="https://www.man7.org/linux/man-pages/man1/su.1.html">su</a> command (short for ‚Äúsubstitute user‚Äù or
‚Äúswitch user‚Äù) is used to start a shell under a different user account.
Typically, one of the most common uses of su is switching to the superuser
(root) account to gain administrative privileges.</p></div><div id="annotation-10-null"><p>The <a href="https://en.wikipedia.org/wiki/Null_device">Null device</a> is a device file that discards all data written
to it but reports that the write operation succeeded.
This device is called /dev/null on Unix and Unix-like systems.
The null device is typically used for disposing of unwanted output streams of a process, or as a convenient empty file for input streams.</p></div><div id="annotation-11-oregano"><div><p>From <a href="https://groups.google.com/g/comp.unix.wizards/c/qkiqSJWgEPE/m/E5BwZYMvXwAJ">Sarah Groves Hobart</a>:</p><blockquote><p>The oregano is reputedly referring to an incident in which one of the
original folks involved with BSD was hassled for coming across the
Canadian/U.S. border with a bag of what was assumed to be an illegal
substance, and turned out to be oregano.</p></blockquote></div></div><div id="annotation-12-tar"><div><p><a href="https://en.wikipedia.org/wiki/Tar_(computing)">Tar</a> is a software tool for collecting multiple
files into a single archive file, often called a tarball.
The name is derived from ‚Äútape archive‚Äù, as it was originally developed to write
data to sequential I/O devices with no file system of their own, such as devices that use magnetic tape.</p><p>The command-line utility was first introduced in the Version 7 Unix in January 1979, replacing the <code>tp</code> program (which in turn replaced <code>tap</code>).</p></div></div><div id="annotation-13-fork"><div><p>In multitasking operating systems, processes need a way to create new processes.
<a href="https://en.wikipedia.org/wiki/Fork_(system_call)">Forking</a> a process is typically the
only way of doing so in Unix-like systems.</p><p>One of the earliest references to a fork concept appeared in A Multiprocessor System Design by Melvin Conway, published in 1962.</p></div></div><div id="annotation-14-shell-script"><p>A <a href="https://en.wikipedia.org/wiki/Shell_script">shell script</a> is a computer program designed to be run by a Unix shell.
The term is also used more generally to mean the automated mode of running an operating system shell.</p></div><div id="annotation-15-awk"><div><p><a href="https://en.wikipedia.org/wiki/AWK">AWK</a> is a domain specific language designed for text
processing, either run directly on files or used as part of a pipeline.</p><p>AWK was created at Bell Labs in the 1970s, and its name is
derived from the surnames of its authors: Alfred Aho, Peter Weinberger and Brian Kernighan.</p></div></div><div id="annotation-16-usr"><div><p>The ‚Äúuser file system‚Äù (<a href="https://en.wikipedia.org/wiki/Unix_filesystem#Conventional_directory_layout"><code>/usr</code></a> ),
is a directory holding user home directories, including executables, libraries and shared resources.</p><p>The spool of threads may be also a reference to <strong>Unix threads</strong>, which are lightweight processes.</p><ul><li><strong>Parallelism:</strong> Different parts of a program can run at the same time.</li><li><strong>Efficiency:</strong> Threads are faster to create and use fewer system resources compared to processes.</li><li><strong>Easy Data Sharing:</strong> Threads can easily access and modify shared data since they operate within the same memory space.</li></ul><p>This makes threads a powerful tool for <strong>concurrent programming</strong> in Unix systems.</p></div></div><div id="annotation-17-troff"><div><p><a href="https://en.wikipedia.org/wiki/Troff">Troff</a> is the major component of a document processing system developed by Bell Labs for the Unix operating system.
Troff stands for ‚Äútypesetter roff‚Äù, where <code>roff</code> is a typesetting markup language.
A typical distribution of troff includes macros for many document styles, including ones for the Unix <code>man</code> pages.</p><p>Troff was developed by Bell Labs in th 1970s, where Joseph Ossanna created <code>troff</code> by modifying <code>nroff</code> to support multiple fonts and proportional spacing.</p></div></div><div id="annotation-18-B"><div><p><a href="https://en.wikipedia.org/wiki/B_(programming_language)">B</a> is a programming language
designed for recursive, non-numeric, machine-independent applications.
B was derived from BCPL, and its name may possibly be a contraction of BCPL.
B is an almost extinct programming language, superseded by the more modern C language.</p><p>B was developed at Bell Labs circa 1969 by Ken Thompson and Dennis Ritchie.</p></div></div><div id="annotation-19-cat"><div><p><a href="https://en.wikipedia.org/wiki/Cat_(Unix)"><code>cat</code></a> derives its name from its function of
(con)<em>cat</em>enating files together.</p><p>The original version of <code>cat</code> was part of version 1 of Unix, and written by Ken Thompson and Dennis Ritchie.</p></div></div><div id="annotation-20-uucp"><div><p><a href="https://en.wikipedia.org/wiki/UUCP"><code>uucp</code></a> is one of the programs in the suite of Unix-to-Unix Copy programs.</p><p>UUCP was originally written at AT&amp;T Bell Laboratories by Mike Lesk.</p></div></div><div id="annotation-21-boot"><div><p>I have to admit, this object looks more like a boot than a sock, but I find it
hard to believe that the author would leave out a reference to sockets,
considering how important they are‚Äînot only in UNIX but in the history of
operating systems.</p><p>For that reason, I see two possibilities:</p><ul><li><p>If it is a boot, it may represent the booting process of the UNIX operating
system, a fundamental part of bringing the system to life.</p></li><li><p>Alternatively, if it is a sock (granted, a thick and oversized one! üòÑ), it
is likely a playful reference to UNIX network sockets. Network sockets were an
abstraction pioneered by UNIX in BSD UNIX (4.2BSD, 1983). Sockets provided a
unified interface for interprocess communication (IPC), enabling processes to
communicate both locally (on the same machine) via UNIX domain sockets, and
over a network using TCP/IP. This innovation became foundational to modern
networking, and the socket API was later adopted by all major operating
systems, shaping how network programming is done today.</p></li></ul><p>For more on the history of BSD sockets, see <a href="https://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley Sockets ‚Äì
Wikipedia</a>, or read the
official Linux man page for
<a href="https://man7.org/linux/man-pages/man2/socket.2.html"><code>socket()</code></a>.</p></div></div><div id="annotation-22-make"><div><p><a href="https://en.wikipedia.org/wiki/Make_(software)">Make</a> is a command line interface
that reads in a configuration <code>Makefile</code> that is often used in code executable
compilation and automation.
Before Make, building on Unix mostly consisted of shell scripts written for each program‚Äôs codebase.
Make‚Äôs dependency ordering and out-of-date checking makes the build process more robust and more efficient.</p><p>Stuart Feldman was the original author of Make, completing an early version in April 1976 at
Bell Labs.</p></div></div><div id="annotation-23-spawn"><div><p>Spawning is the process of loading and executing a new child process.
Closely related is the idea of <code>fork</code> and <code>exec</code> that can be used
to simulate spawning, by forking a process, having the parent terminate
and <code>exec</code>ing the child into the desired spawn process.</p><p>POSIX allow for the concept of spawning by itself that can be made
to be more efficient than <code>fork</code> and <code>exec</code>.</p><p>The spawn metaphor had its early use in the VMS operating system from 1977.</p></div></div><div id="annotation-24-jfo-nroff"><div><p><a href="https://en.wikipedia.org/wiki/Nroff"><code>nroff</code></a>, short for ‚Äúnew roff‚Äù
is a text-formatting program produces output suitable for simple fixed-width
printers and terminal windows.
It is an integral part of the Unix help system, being used to format man pages for display.</p><p>The letters <em>Jfo</em> stand for Joseph Frank Ossanna
who created the original version of <code>nroff</code> for Version 2 Unix.</p></div></div><div id="annotation-25-root"><p>The root user is the name often given to the administrator or superuser account
on UNIX systems.
In Unix-like systems, root is the conventional name of the user who has all rights or
permissions to all files and programs in all modes (e.g. single- or multi-user).
The root user can do many things an ordinary user cannot, such as changing the
ownership of files and binding to network ports numbered below 1024.</p></div><div id="annotation-26-dates"><div><p><a href="https://man7.org/linux/man-pages/man1/date.1.html"><code>date</code></a> is a command to display and set a UNIX system date.</p><p>Unix time is currently defined as the number of non-leap seconds which have passed since 00:00:00 UTC on Thursday, 1 January 1970,
which is referred to as the Unix epoch.</p><p>The earliest versions of Unix time had a 32-bit integer incrementing at a rate of 60 Hz, which was the rate of the system clock
on the hardware of the early Unix systems.
Timestamps stored this way could only represent a range of a little over two and a quarter years.</p><p>The current epoch of 1 January 1970 00:00:00 UTC was selected arbitrarily by Unix engineers because it was considered a
convenient date to work with.</p></div></div><div id="annotation-27-whoami"><div><p>Users on UNIX systems may want to
switch to other accounts, allowing for switching roles, escalation or deescalation of
privileges or might be logging into multiple machines across networks.
The <a href="https://en.wikipedia.org/wiki/Whoami"><code>whoami</code></a> is a command to tell the invoker
what user they are logged in as.</p><p>The earliest versions were created in 2.9 BSD.</p></div></div><div id="annotation-28-pwd"><p><a href="https://man7.org/linux/man-pages/man1/pwd.1.html"><code>pwd</code></a> is a simple command
that shows your current location in the filesystem. Is it a coincidence that
<code>pwd</code> is visually presented in a box? Maybe. But perhaps it‚Äôs a visual clue,
suggesting that <code>pwd</code> is a small, self-contained tool‚Äîlike many classic UNIX
commands.</p></div><div id="annotation-29-mbox"><p><code>mbox</code> is a reference to the mail format from the early days of UNIX. UNIX was
one of the first operating systems to come with built-in email capabilities,
and it did so while staying true to its mantra: ‚Äúeverything is a file.‚Äù In the
<code>mbox</code> format, all email messages are stored in a single file, with new
messages simply appended to the end. By default, users‚Äô mail was stored in
<code>/usr/mail/&lt;username&gt;</code>. This design naturally enabled the integration of
system logs and notifications to be sent via email‚Äîfurther embedding email as
a core part of the UNIX experience.</p></div><div id="annotation-30-login"><div><p><code>login</code> is the gateway into the system. It authenticates the user, initializes
the environment by changing to the user‚Äôs home directory, and spawns a process
running as the user (with their <code>uid</code> and <code>gid</code>), using their shell of choice.</p><p>Additionally, the standard input and output need to be attached to a terminal:
this could be a <strong>pseudo-terminal</strong> (if you are in a graphical interface or
using <code>ssh</code>), or a <strong>physical terminal</strong> (as was common at the time).</p></div></div><div id="annotation-31-spells"><div><p><a href="https://en.wikipedia.org/wiki/Spell_(Unix)"><code>spell</code></a> is the standard English
language spell checker for Unix and other Unix-like operating systems.</p><p>The original version was written by Stephen C. Johnson for Version 6 UNIX while at Bell Labs in 1976.</p></div></div><div id="annotation-32-curses"><div><p>The <a href="https://en.wikipedia.org/wiki/Curses_(programming_library)"><code>curses</code></a> programming
library provides a layer of abstraction over sending graphical and positioning
data directly to allow for graphical elements and cursor positioning in Unix terminals.
The name is a pun on the term ‚Äúcursor optimization‚Äù.</p><p>The first curses library was written by Ken Arnold and originally released with BSD UNIX.</p></div></div><div id="annotation-33-diff"><div><p><a href="https://en.wikipedia.org/wiki/Diff"><code>diff</code></a> is a data comparison tool that computes
and displays the differences in the contents of files.
<code>diff</code> is line oriented and is often used to determine changes between two versions
of the same file.
For example, <code>diff</code> can be used to find which lines have changed in a source file,
allowing for only transmission of the changes, rather than the whole file.</p><p><code>diff</code> as developed in the early 1970s at Bell Labs.</p></div></div><div id="annotation-34-traps"><p>Traps, or <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">signals</a>, are sent
from the kernel to a process, notifying the process of an event.
Common signals are interrupt, terminate or kill, with some signal
handling useful for inter-process communication and coordination.</p></div><div id="annotation-35-shell-symbols"><div><h3 id="shell-symbols-on-the-wizards-cloak">Shell Symbols on the Wizard‚Äôs Cloak</h3><p>The wizard‚Äôs cloak is decorated with symbols that represent some of the most
important special characters used in the UNIX shell. These symbols are the
‚Äúrunes‚Äù of UNIX power, allowing users to combine commands, redirect input and
output, and control processes with precision. Mastery of these symbols is part
of what transforms a regular user into a ‚ÄúUNIX wizard.‚Äù</p><h4 id="--job-control"><code>%</code> ‚Äì Job Control</h4><p>Used to <strong>refer to background jobs in the shell</strong>.</p><ul><li><code>jobs</code> ‚Üí List background jobs.</li><li><code>fg %1</code> ‚Üí Bring <strong>job 1 to the foreground</strong>.</li><li><code>bg %2</code> ‚Üí Resume <strong>job 2 in the background</strong>.</li></ul><h4 id="--variable-expansion--shell-prompt"><code>$</code> ‚Äì Variable Expansion &amp; Shell Prompt</h4><p>Represents <strong>variables and parameter substitution</strong>.</p><ul><li><code>$HOME</code> ‚Üí Expands to <strong>the value of the <code>HOME</code> environment variable</strong>.</li><li><code>$?</code> ‚Üí Shows <strong>the exit status of the last command</strong>.</li></ul><p>Also often <strong>appears as the shell prompt</strong> for <strong>a regular user</strong>.</p><h4 id="--output-redirection"><code>&gt;</code> ‚Äì Output Redirection</h4><p>Redirects <strong>standard output to a file</strong>.</p><ul><li><code>ls &gt; files.txt</code> ‚Üí Writes the <strong>output of <code>ls</code> into <code>files.txt</code></strong> (overwriting it).</li></ul><h4 id="--input-redirection"><code>&lt;</code> ‚Äì Input Redirection</h4><p>Redirects <strong>standard input from a file</strong>.</p><ul><li><code>sort &lt; input.txt</code> ‚Üí Reads <strong>input from <code>input.txt</code> instead of the keyboard</strong>.</li></ul><h4 id="--wildcard-glob"><code>*</code> ‚Äì Wildcard (Glob)</h4><p><strong>Matches any number of characters</strong> in filenames.</p><ul><li><code>ls *.txt</code> ‚Üí Lists <strong>all files ending in <code>.txt</code></strong>.</li><li><code>rm *</code> ‚Üí <strong>Deletes all files in the current directory</strong> (Dangerous!).</li></ul><h4 id="--history-expansion"><code>!</code> ‚Äì History Expansion</h4><p><strong>Expands to previously executed commands</strong>.</p><ul><li><code>!!</code> ‚Üí Repeats <strong>the last command</strong>.</li><li><code>!ls</code> ‚Üí Repeats <strong>the last command starting with <code>ls</code></strong>.</li><li><code>!$</code> ‚Üí Expands <strong>to the last argument of the previous command</strong>.</li></ul><h4 id="---test--conditional-expressions"><code>[</code> <code>]</code> ‚Äì Test / Conditional Expressions</h4><p>Used <strong>in shell conditionals</strong> and <strong><code>if</code> statements</strong>.</p><ul><li><code>[ -f file.txt ]</code> ‚Üí <strong>Tests if <code>file.txt</code> is a regular file</strong>.</li><li>Common <strong>in shell scripting</strong>:<div><pre tabindex="0"><code data-lang="bash"><span><span><span>if</span> <span>[</span> -f file.txt <span>]</span>; <span>then</span>
</span></span><span><span>    echo <span>&#34;File exists!&#34;</span>
</span></span><span><span><span>fi</span>
</span></span></code></pre></div></li></ul></div></div><div id="annotation-36-overflows"><div><p>This may be a bit of a stretch, but considering how prevalent buffer overflows
have been in the history of UNIX, the imagery might be intentional. The
overflowing liquid from the shell could be a visual reference to a buffer overflow.</p><p>A buffer overflow occurs when a program writes more data into a buffer (a fixed
block of memory) than it can hold. The excess data ‚Äúspills over‚Äù into adjacent
memory, often overwriting critical information like return addresses, which can
cause crashes or open security vulnerabilities. Buffer overflows were (and still
are) a classic type of exploit in C programming on UNIX systems.</p><p>For more information, see
<a href="https://en.wikipedia.org/wiki/Buffer_overflow">Buffer overflow ‚Äì Wikipedia</a>.</p></div></div><div id="annotation-37-tee"><p>The T shape of the pipes may also reference the
<a href="https://man7.org/linux/man-pages/man1/tee.1.html"><code>tee</code></a> command, a classic
utility in UNIX. The <code>tee</code> command is used to split the output of a command,
sending it to both a file and the next command in a pipeline.</p></div><div id="annotation-38-tree-graph"><div><p>The tree-like shape of the liquid the wizard is manipulating may be a reference to
the UNIX filesystem hierarchy. UNIX organizes files and directories in a tree
structure, starting from the root (<code>/</code>) and branching into subdirectories.</p><p>Navigating this structure is a fundamental part of working with UNIX, typically done
through the shell using commands like <code>cd</code>, <code>ls</code>, and <code>pwd</code>. The tree shape could
symbolize this concept, visually representing how users move through directories,
access files, and execute commands.</p><p>Alternatively, the branching form could represent recursive operations or the
parent-child relationships in process trees, both key concepts in UNIX systems.</p><p>Some modern readers might associate the tree shape with version control systems like
Git, where branching is a common visual metaphor. However, this is likely not the
intended reference, as branching version control workflows were not as prevalent in
the UNIX world at the time the poster was created. Tools like SCCS (1972) and RCS
(1982) were available, but they focused more on linear versioning and file locking
than the branching models popular today.</p></div></div><div id="annotation-39-skull"><div><p>The skull connected to the shell may symbolize <code>/dev/null</code>, the special UNIX
device that discards all data written to it.
In UNIX, redirecting output to
<code>/dev/null</code> effectively sends it into a ‚Äúblack hole,‚Äù where it is lost
forever.
Output redirection is part of a broader
<a href="https://en.wikipedia.org/wiki/Standard_streams">standard stream</a> UNIX concept that
allows outputs of one process to be redirected to the input of another.</p><p>Another interpretation is that the spigot is reminiscent of a gargoyle, perhaps
referencing a UNIX <a href="https://en.wikipedia.org/wiki/Daemon_(computing)">daemon</a>
process.</p><p>See the (<a href="#annotation-10-null">/dev/null</a>) mark.</p></div></div></div></div>
  </body>
</html>
