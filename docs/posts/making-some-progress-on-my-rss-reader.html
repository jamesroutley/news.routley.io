<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sawyer.dev/posts/rss-reader-progress/">Original</a>
    <h1>Making Some Progress on My RSS Reader</h1>
    
    <div id="readability-page-1" class="page"><div>
      



<section id="post">

  <nav>
    &gt; <a href="https://sawyer.dev/">home</a>
    &gt; <a href="https://sawyer.dev/posts">blog posts</a>
  </nav>

  <container>
    <h2 id="post-title"> Making Some Progress on My RSS Reader </h2>

    <article>
      <p>I&#39;ve started numerous RSS reader attempts over the years. I revisited my tradition of starting an RSS reader a few weeks ago, but this time I may have broken the cycle. It&#39;s possible that soon I&#39;ll want to use this day-to-day. To celebrate the occasion, I wanted to write down what&#39;s appealing to me about a project like this.</p>
<p>My goals with this project are: have a usable RSS reader; have a project that can act as a vehicle for experimentation; and continue writing and maintaining software that I use every day.</p>
<h2>a usable RSS reader</h2>
<p>This is the minimum functionality that counts as &#34;usable&#34; to me: I can subscribe to new RSS feeds, have them refresh automatically, see posts in chronological order, and click on a post&#39;s title to open the page in my browser. The overall flow is: the landing page is a list of feeds I&#39;ve subscribed to and a two-part form to add a new feed. The first part is a single text input field that accepts a feed URL. The second part acts as a kind of validation step: it displays the details of the feed (or an error message) and has a &#34;save feed&#34; button. Feed items can be seen by clicking on the feed title.</p>
<p>I&#39;ve decided to avoid features like showing the number of unread posts or grouping feeds into different folders or supporting podcasts. I imagine they&#39;d be fun to handle later, but I don&#39;t think they&#39;re necessary right now and I&#39;d like to use this reader for a bit so I have some &#34;user feedback&#34; for myself.</p>
<h3>a brief overview of the pieces involved</h3>
<p>I picked <a href="https://tauri.app/">Tauri</a> as the overall application framework because I wanted the application to be primarily local. I know there are ways to do this entirely within the browser, but Tauri seemed to mimic the kind of front-end/back-end web development structure that I&#39;m already familiar with. I&#39;m using an existing <a href="https://github.com/rust-syndication/rss">RSS parsing library</a> to actually read RSS feeds and I&#39;m using SQLite to store data. All HTTP requests and SQLite interactions happen within Rust, with Tauri providing the bridge between Rust and TypeScript.
Within the Rust back-end, I&#39;m using <a href="https://github.com/mvniekerk/tokio-cron-scheduler/">tokio-cron-scheduler</a> to schedule refresh jobs for all my subscribed feeds. I developed a small headache trying to wrap my head around async closures, but otherwise it wasn&#39;t too bad to set up.</p>
<p>I&#39;m using TypeScript and <a href="https://lit.dev/">Lit</a> for UI development. I was originally planning to do this without any kind of frontend framework, but when I went to reach for web components I decided to try Lit, since it uses web components under the hood while providing some modern nicities. One day I might replace it with vanilla web components, but Lit&#39;s been easy and enjoyable to work with. The hardest part so far has been figuring out the TypeScript config.</p>
<h2>a vehicle for experimentation</h2>
<p>Another motivation for this project is that I&#39;d like to have some kind of non-trivial program that provides even a remote excuse to try out certain things. Some such things are local-first software, UI development, and Rust&#39;s type system.</p>
<p>I don&#39;t think this really counts as local-first software since there&#39;s so little that&#39;s actually saved to my device, but I think this provides an opportunity. I could try to save web pages locally to read later, or I could try syncing state across devices. One example I think about often was when I used <a href="https://joplinapp.org/">Joplin</a> for taking notes. I set up a Dropbox folder to sync data between desktop and mobile and pretty much never thought about it after that initial set up. I&#39;d like to try something similar here, since Tauri apparently supports building mobile targets (I have no idea how big or small of a task that is, though).</p>
<p>I&#39;d also like to develop my UI design and implementation skills. The majority of my frontend programming occurred during the days of Angular 1. I didn&#39;t know what Flexbox was; I was <code>float</code>ing left and right. I currently fumble my way through any UI I need to create, and my minimalist web aesthetic is as much driven by a lack of skill as it is personal preference. Using Tauri allows me to think about design while figuring out what frontend development is like in 2024, not 2014.</p>
<p>Regarding Rust&#39;s type system, I&#39;m trying to learn more about how Rust models low-level system abstractions through the type system. To me, this includes things like lifetimes and ownership. In general, my experience with Rust is that it doesn&#39;t try to hide complexity but rather that it aims to give programmers a realistic toolkit for managing it. This has never been clearer to me than in the async realm, where one must deal with what it means for data to be available across threads or how code should suspend execution to let some other code run. I still don&#39;t have a comfortable grasp of async Rust, but this project has given me an opportunity to jump in and try.</p>
<p>Aside from async Rust, I&#39;ve also tried to take advantage of a type system that lets me be more specific about program state. A few months ago I came across this post on <a href="https://boinkor.net/2024/04/some-useful-types-for-database-using-rust-web-apps/">Rust types for database-related code</a> and wanted to try it out. With these, I can specify something like &#34;this RSS feed might not exist in the database yet&#34;, which is tremendously freeing. These types do feel a bit clunky from time to time, but I really like that the type system handles these guarantees for me.</p>
<p>As far as other tech goes, I also decided to use Codeberg instead of Gits Hub or Lab, but I haven&#39;t used it for anything other than <code>git push</code> so I can&#39;t say what it&#39;s really like. Seems fine so far.</p>
<h2>writing and maintaining the software I use every day</h2>
<p>Last year, I wrote a <a href="https://sawyer.dev/posts/dropbox-cli-python">cli for Dropbox</a>. At the time, I thought it would be another project that sat in a git repo and accumulated dust. Instead, I use it all the time! It feels freeing to use something I made, to feel like I&#39;ve acutally made a tool instead of a toy. If I use this reader as much as I use that little command-line client, I&#39;d consider this project a huge success.</p>
<p>Another benefit to writing and maintaining my own software is that I can go at my own pace. I can be as rigorous or relaxed as I&#39;d like. I am the target audience for both the application and the codebase. for instance, if I don&#39;t think I need to see a specific error, I&#39;ll just catch it, do nothing, and move on with my life! At the same time, if I want to go wild and look into whether it&#39;s feasible to extend Litestream to write to Dropbox, who&#39;s gonna stop me?</p>
<p>And lastly, building these things on my own helps me build up my product management intuition, as I continue to think critically about the software I use and how I could improve it.</p>
<hr/>
<p>The code for this project can be found here: <a href="https://codeberg.org/rors/r2s2/">https://codeberg.org/rors/r2s2/</a></p>

    </article>

  </container>


</section>

    </div></div>
  </body>
</html>
