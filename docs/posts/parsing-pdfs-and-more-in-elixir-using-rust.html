<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.chriis.dev/opinion/parsing-pdfs-in-elixir-using-rust">Original</a>
    <h1>Parsing PDFs (and more) in Elixir using Rust</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>Here&#39;s the thing about PDFs - they&#39;re complex beasts that require quite a bit of thinking to properly parse - they come in all shapes and sizes, and they can contain a lot of different types of data and formatting. 90% of the time, we just want to extract the text from the file, but that&#39;s not always easy - for the remaining 10%, well we won&#39;t be covering that in this blog post.</p>
<p>If you&#39;ve been in the Elixir world for long enough, you&#39;ll probably have tried to parse a PDF file and realised that it&#39;s not as easy as it seems. A quick look on the <a href="https://elixirforum.com/t/parsing-pdf-file/23287">Elixir Forum</a> will quickly show you that there is no simple way to do it.</p>
<p>Most people will tell you to upload the file to S3 and use a Lambda to handle the contents. Offloading to AWS Lambda might seem elegant at first (&#34;Look, Ma, no dependencies!&#34;), but it comes with its own baggage:</p>
<ul>
<li><span><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="5" x2="19" y1="12" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span>You&#39;re adding network latency to what should be a simple operation</li>
<li><span><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="5" x2="19" y1="12" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span>AWS costs can spiral if you&#39;re processing lots of PDFs</li>
<li><span><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="5" x2="19" y1="12" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span>You&#39;re now dependent on external services for core functionality</li>
<li><span><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="5" x2="19" y1="12" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span>Debugging becomes a distributed systems problem</li>
</ul>
<p>These aren&#39;t ideal solutions - and software engineering is already made more complicated than it needs to be at times - we don&#39;t need to add more complexity to the mix.</p>
<p>We need a robust, native solution that plays nicely with the BEAM. So how do we do that?</p>
<h2>Enter the crabs!</h2>
<p>Elixir is my favourite language, but it can&#39;t do everything - web services, background jobs, and more are easy but sometimes we need a little help from our friends closer to the hardware for some of the tasks Elixir doesn&#39;t have a native solution for. That&#39;s where Rust and NIFs come in!</p>
<p>Rust is a systems programming language that is fast, safe, and easy to use. It&#39;s a great language for writing code that needs to be performant and reliable.</p>
<p>But Rust isn&#39;t just fast - it&#39;s &#34;zero-cost abstractions&#34; fast. What does that mean? You get high-level, ergonomic code that compiles down to something as efficient as hand-written C. For PDF parsing, where you&#39;re dealing with complex file formats and potentially large documents, this performance is a game-changer.</p>
<blockquote>
<p>What is a NIF?
A NIF (Native Implemented Function) is a way to call Rust code from Elixir - it&#39;s the BEAMs method of allowing processes to directly call native functions. It allows you to write code in Rust that can be called directly from Elixir, giving you the performance benefits of Rust without sacrificing the ease of use of Elixir.</p>
</blockquote>
<p>For this blog post, we&#39;re going to be using the <a href="https://github.com/yobix-ai/extractous">Extractous library</a> which provides fast and efficient unstructured data extraction in Rust. This combined with the NIFs in Elixir gives us a powerful combination for parsing PDFs.</p>
<h2>The Setup</h2>
<p>First things first, ensure you have Elixir and Rust installed on your machine.</p>
<p>Let&#39;s begin by creating a new LiveView Elixir application that will allow users to upload a PDF file and see a breakdown of the contents. We won&#39;t be needing any database functionality for this so we can use the <code>--no-ecto</code> flag to skip the database setup.</p>
<pre><code>mix phx<span>.</span>new elixir_pdf <span>--</span>no<span>-</span>ecto
</code></pre>
<p>We&#39;ll also need to add the <code>rustler</code> dependency to our <code>mix.exs</code> file so we can call Rust code from Elixir.</p>
<pre><code><span>defp</span> deps <span>do</span>
  <span>[</span>
    <span>{</span><span>:rustler</span><span>,</span> <span>&#34;~&gt; 0.27.0&#34;</span><span>}</span>
  <span>]</span>
<span>end</span>
</code></pre>
<p>Once we pull down our dependencies using <code>mix deps.get</code>, we can use <code>mix rustler.new</code> to generate our new Rust project in our code.</p>
<p>If you head to <code>lib/elixir_pdf/&lt;name_of_your_rust_project&gt;.ex</code>, you&#39;ll see that it&#39;s already generated a basic NIF for us. A default NIF implementation is provided for us, but we&#39;ll be implementing our own in the next step. I&#39;ve named my Rust project <code>rustreader</code> for this example.</p>
<pre><code><span>defmodule</span> <span>RustReader</span> <span>do</span>
  <span>use</span> <span>Rustler</span><span>,</span> <span>otp_app:</span> <span>:elixir_pdf</span><span>,</span> <span>crate:</span> <span>&#34;rustreader&#34;</span>

  
  <span>def</span> <span>extract_pdf</span><span>(</span>_path<span>)</span><span>,</span> <span>do:</span> <span>:erlang</span><span>.</span><span>nif_error</span><span>(</span><span>:nif_not_loaded</span><span>)</span>
<span>end</span>

</code></pre>
<p>Now, let&#39;s grab the <code>extractous</code> library and add it to our <code>native/rustreader/Cargo.toml</code> file - this will allow us to use the <code>extractous</code> library in our Rust code.</p>
<pre><code><span>[</span>dependencies<span>]</span>
rustler <span>=</span> <span>&#34;0.36.0&#34;</span>
extractous <span>=</span> <span>&#34;0.2.0&#34;</span>
</code></pre>
<p>With this in place, we can run <code>cargo build</code> to build our Rust code - this will also pull down the <code>extractous</code> library and any other dependencies.</p>
<h2>The fun part - writing some code</h2>
<p>Next we need to actually write some Rust code to implement the <code>extract_pdf</code> function in our <code>native/rustreader/src/lib.rs</code> file.</p>
<pre><code><span>use</span> <span>extractous<span>::</span></span><span>Extractor</span><span>;</span>
<span>use</span> <span>rustler<span>::</span></span><span>{</span><span>Encoder</span><span>,</span> <span>Env</span><span>,</span> <span>NifResult</span><span>,</span> <span>Term</span><span>}</span><span>;</span>

<span>#[rustler::nif(schedule = <span>&#34;DirtyCpu&#34;</span>)]</span>
<span>fn</span> <span>extract_pdf</span><span>(</span>path<span>:</span> <span>String</span><span>)</span> <span>-&gt;</span> <span>NifResult</span><span>&lt;</span><span>(</span><span>String</span><span>,</span> <span>String</span><span>)</span><span>&gt;</span> <span>{</span>
    <span>let</span> extractor <span>=</span> <span>Extractor</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>

    <span>match</span> extractor<span>.</span><span>extract_file_to_string</span><span>(</span><span>&amp;</span>path<span>)</span> <span>{</span>
        <span>Ok</span><span>(</span><span>(</span>content<span>,</span> metadata<span>)</span><span>)</span> <span>=&gt;</span> <span>Ok</span><span>(</span><span>(</span>content<span>,</span> <span>format!</span><span>(</span><span>&#34;{:?}&#34;</span><span>,</span> metadata<span>)</span><span>)</span><span>)</span><span>,</span>
        <span>Err</span><span>(</span>e<span>)</span> <span>=&gt;</span> <span>Err</span><span>(</span><span>rustler<span>::</span></span><span>Error</span><span>::</span><span>Term</span><span>(</span><span>Box</span><span>::</span><span>new</span><span>(</span><span>format!</span><span>(</span><span>&#34;Extraction failed: {}&#34;</span><span>,</span> e<span>)</span><span>)</span><span>)</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>rustler<span>::</span></span><span>init!</span><span>(</span><span>&#34;Elixir.RustReader&#34;</span><span>,</span> <span>[</span>extract_pdf<span>]</span><span>)</span><span>;</span>
</code></pre>
<p>This code will define a new instance of the <code>Extractor</code> struct and use it to extract the contents of the PDF file. We&#39;ll then return the contents and the metadata as a tuple.</p>
<p>The magic of the <code>rustler::init!</code> macro is that it will automatically generate the necessary code to call the Rust function from Elixir.</p>
<p>Astute observers will note our use of the <code>DirtyCpu</code> schedule. This ingenious feature instructs Rustler and the BEAM to automatically schedule our task in a manner that prevents global blocking during execution. This functionality, known as a DirtyNif, significantly simplifies our work compared to the complexities of manual implementation in C.</p>

<p>Now we need to write a some simple LiveView Elixir code to allow users to upload a PDF file and then call our Rust function from the server.</p>
<pre><code><span>defmodule</span> <span>ElixirPdfWeb</span><span>.</span><span>HomeLive</span> <span>do</span>
  <span>use</span> <span>ElixirPdfWeb</span><span>,</span> <span>:live_view</span>

  <span>@impl</span> <span>true</span>
  <span>def</span> <span>mount</span><span>(</span>_params<span>,</span> _session<span>,</span> socket<span>)</span> <span>do</span>
    <span>{</span><span>:ok</span><span>,</span>
     socket
     <span>|&gt;</span> <span>assign</span><span>(</span><span>:uploaded_files</span><span>,</span> <span>[</span><span>]</span><span>)</span>
     <span>|&gt;</span> <span>allow_upload</span><span>(</span><span>:pdf</span><span>,</span>
       <span>accept:</span> <span>~w(.pdf)</span><span>,</span>
       <span>max_entries:</span> <span>1</span><span>,</span>
       
       <span>max_file_size:</span> <span>10_000_000</span><span>,</span>
       <span>chunk_size:</span> <span>64_000</span>
     <span>)</span><span>}</span>
  <span>end</span>

  <span>@impl</span> <span>true</span>
  <span>def</span> <span>handle_event</span><span>(</span><span>&#34;validate&#34;</span><span>,</span> _params<span>,</span> socket<span>)</span> <span>do</span>
    <span>{</span><span>:noreply</span><span>,</span> socket<span>}</span>
  <span>end</span>

  <span>@impl</span> <span>true</span>
  <span>def</span> <span>handle_event</span><span>(</span><span>&#34;save&#34;</span><span>,</span> _params<span>,</span> socket<span>)</span> <span>do</span>
    uploaded_files <span>=</span>
      <span>consume_uploaded_entries</span><span>(</span>socket<span>,</span> <span>:pdf</span><span>,</span> <span>fn</span> <span>%</span><span>{</span><span>path:</span> path<span>}</span><span>,</span> _entry <span>-&gt;</span>
        dest <span>=</span> <span>Path</span><span>.</span><span>join</span><span>(</span><span>[</span><span>&#34;priv&#34;</span><span>,</span> <span>&#34;static&#34;</span><span>,</span> <span>&#34;uploads&#34;</span><span>,</span> <span>Path</span><span>.</span><span>basename</span><span>(</span>path<span>)</span><span>]</span><span>)</span>
        <span>File</span><span>.</span><span>cp!</span><span>(</span>path<span>,</span> dest<span>)</span>
        <span>{</span><span>:ok</span><span>,</span> dest<span>}</span>
      <span>end</span><span>)</span>

    pdf_document <span>=</span>
      uploaded_files
      <span>|&gt;</span> <span>hd</span><span>(</span><span>)</span>

    <span>{</span><span>:noreply</span><span>,</span>
     socket
     <span>|&gt;</span> <span>assign</span><span>(</span><span>:pdf_document</span><span>,</span> pdf_document<span>)</span>
     <span>|&gt;</span> <span>update</span><span>(</span><span>:uploaded_files</span><span>,</span> <span>&amp;</span><span>(</span><span>&amp;1</span> <span>++</span> uploaded_files<span>)</span><span>)</span><span>}</span>
  <span>end</span>
<span>end</span>
</code></pre>
<p>Alongside this we need to add a little bit of code to our <code>router.ex</code> file to allow us to upload files.</p>
<pre><code>scope <span>&#34;/&#34;</span><span>,</span> <span>ElixirPdfWeb</span> <span>do</span>
  pipe_through <span>:browser</span>

  live <span>&#34;/&#34;</span><span>,</span> <span>HomeLive</span>
<span>end</span>
</code></pre>
<p>We also need a simple LiveView template to allow users to upload a PDF file and see the results.</p>
<pre><code>&lt;div class<span>=</span><span>&#34;mx-auto max-w-2xl py-8&#34;</span>&gt;
  <span>&lt;</span>div class<span>=</span><span>&#34;flex flex-col items-center justify-center&#34;</span>&gt;
    <span>&lt;</span>h1 class<span>=</span><span>&#34;text-2xl font-bold mb-8&#34;</span>&gt;<span>Upload</span> <span>PDF</span>&lt;<span>/</span>h1<span>&gt;</span>

    <span>&lt;</span>form phx<span>-</span>submit<span>=</span><span>&#34;save&#34;</span> phx<span>-</span>change<span>=</span><span>&#34;validate&#34;</span> class<span>=</span><span>&#34;w-full&#34;</span>&gt;
      <span>&lt;</span>div class<span>=</span><span>&#34;flex flex-col items-center space-y-4 w-full&#34;</span> phx<span>-</span>drop<span>-</span>target<span>=</span><span>{</span><span>@uploads</span><span>.</span>pdf<span>.</span>ref<span>}</span><span>&gt;</span>
        <span>&lt;</span>div class<span>=</span><span>&#34;w-full border-2 border-dashed border-gray-300 rounded-lg p-12 text-center hover:border-gray-400 transition-colors&#34;</span>&gt;
          <span>&lt;</span>div class<span>=</span><span>&#34;space-y-2&#34;</span>&gt;
            <span>&lt;</span>div class<span>=</span><span>&#34;text-gray-600&#34;</span>&gt;
              <span>Drag</span> <span>and</span> drop your <span>PDF</span> here <span>or</span>
              <span>&lt;</span>label class<span>=</span><span>&#34;cursor-pointer text-blue-500 hover:text-blue-600&#34;</span>&gt;
                browse <span>&lt;</span><span>.</span>live_file_input upload<span>=</span><span>{</span><span>@uploads</span><span>.</span>pdf<span>}</span> class<span>=</span><span>&#34;hidden&#34;</span> <span>/</span>&gt;
              <span>&lt;</span><span>/</span>label<span>&gt;</span>
            <span>&lt;</span><span>/</span>div<span>&gt;</span>
            <span>&lt;</span>p class<span>=</span><span>&#34;text-xs text-gray-500&#34;</span>&gt;<span>PDF</span> files only<span>,</span> up to 10MB<span>&lt;</span><span>/</span>p<span>&gt;</span>
          <span>&lt;</span><span>/</span>div<span>&gt;</span>
        <span>&lt;</span><span>/</span>div<span>&gt;</span>

        <span>&lt;</span><span>%</span><span>=</span> <span>for</span> entry <span>&lt;-</span> <span>@uploads</span><span>.</span>pdf<span>.</span>entries <span>do</span> <span>%</span><span>&gt;</span>
          <span>&lt;</span>div class<span>=</span><span>&#34;w-full&#34;</span>&gt;
            <span>&lt;</span>div class<span>=</span><span>&#34;flex items-center justify-between p-4 bg-gray-50 rounded&#34;</span>&gt;
              <span>&lt;</span>div class<span>=</span><span>&#34;flex items-center space-x-2&#34;</span>&gt;
                <span>&lt;</span>span class<span>=</span><span>&#34;font-medium&#34;</span>&gt;<span>{</span>entry<span>.</span>client_name<span>}</span><span>&lt;</span><span>/</span>span<span>&gt;</span>
                <span>&lt;</span>span class<span>=</span><span>&#34;text-sm text-gray-500&#34;</span>&gt;
                  <span>(</span><span>{</span>entry<span>.</span>client_size<span>}</span><span>B</span><span>)</span>
                <span>&lt;</span><span>/</span>span<span>&gt;</span>
              <span>&lt;</span><span>/</span>div<span>&gt;</span>

              <span>&lt;</span>button
                type<span>=</span><span>&#34;button&#34;</span>
                class<span>=</span><span>&#34;text-red-500 hover:text-red-700&#34;</span>
                phx<span>-</span>click<span>=</span><span>&#34;cancel-upload&#34;</span>
                phx<span>-</span>value<span>-</span>ref<span>=</span><span>{</span>entry<span>.</span>ref<span>}</span>
              <span>&gt;</span>
                <span>&amp;</span>times;
              <span>&lt;</span><span>/</span>button<span>&gt;</span>
            <span>&lt;</span><span>/</span>div<span>&gt;</span>

            <span>&lt;</span><span>%</span><span>=</span> <span>for</span> err <span>&lt;-</span> <span>upload_errors</span><span>(</span><span>@uploads</span><span>.</span>pdf<span>,</span> entry<span>)</span> <span>do</span> <span>%</span><span>&gt;</span>
              <span>&lt;</span>div class<span>=</span><span>&#34;text-red-500 text-sm&#34;</span>&gt;
                <span>{</span>err<span>}</span>
              <span>&lt;</span><span>/</span>div<span>&gt;</span>
            <span>&lt;</span><span>%</span> <span>end</span> <span>%</span><span>&gt;</span>
          <span>&lt;</span><span>/</span>div<span>&gt;</span>
        <span>&lt;</span><span>%</span> <span>end</span> <span>%</span><span>&gt;</span>

        <span>&lt;</span><span>%</span><span>=</span> <span>if</span> <span>length</span><span>(</span><span>@uploads</span><span>.</span>pdf<span>.</span>entries<span>)</span> <span>&gt;</span> <span>0</span> <span>do</span> <span>%</span><span>&gt;</span>
          <span>&lt;</span>button
            type<span>=</span><span>&#34;submit&#34;</span>
            class<span>=</span><span>&#34;px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors&#34;</span>
          <span>&gt;</span>
            <span>Upload</span>
          <span>&lt;</span><span>/</span>button<span>&gt;</span>
        <span>&lt;</span><span>%</span> <span>end</span> <span>%</span><span>&gt;</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>&lt;</span><span>/</span>form<span>&gt;</span>
  <span>&lt;</span><span>/</span>div<span>&gt;</span>
<span>&lt;</span><span>/</span>div<span>&gt;</span>
</code></pre>
<h2>Putting it all together</h2>
<p>So we can upload a PDF file - but let&#39;s call our Rust function and see what it returns.</p>
<p>In our handle_event function, we can call our Rust function as simply as this:</p>
<pre><code>  <span>@impl</span> <span>true</span>
  <span>def</span> <span>handle_event</span><span>(</span><span>&#34;save&#34;</span><span>,</span> _params<span>,</span> socket<span>)</span> <span>do</span>
    uploaded_files <span>=</span>
      <span>consume_uploaded_entries</span><span>(</span>socket<span>,</span> <span>:pdf</span><span>,</span> <span>fn</span> <span>%</span><span>{</span><span>path:</span> path<span>}</span><span>,</span> _entry <span>-&gt;</span>
        dest <span>=</span> <span>Path</span><span>.</span><span>join</span><span>(</span><span>[</span><span>&#34;priv&#34;</span><span>,</span> <span>&#34;static&#34;</span><span>,</span> <span>&#34;uploads&#34;</span><span>,</span> <span>Path</span><span>.</span><span>basename</span><span>(</span>path<span>)</span><span>]</span><span>)</span>
        <span>File</span><span>.</span><span>cp!</span><span>(</span>path<span>,</span> dest<span>)</span>
        <span>{</span><span>:ok</span><span>,</span> dest<span>}</span>
      <span>end</span><span>)</span>

    pdf_document <span>=</span>
      uploaded_files
      <span>|&gt;</span> <span>hd</span><span>(</span><span>)</span>
      <span>|&gt;</span> <span>RustReader</span><span>.</span><span>extract_pdf</span><span>(</span><span>)</span> 

    <span>{</span><span>:noreply</span><span>,</span>
     socket
     <span>|&gt;</span> <span>assign</span><span>(</span><span>:pdf_document</span><span>,</span> pdf_document<span>)</span>
     <span>|&gt;</span> <span>update</span><span>(</span><span>:uploaded_files</span><span>,</span> <span>&amp;</span><span>(</span><span>&amp;1</span> <span>++</span> uploaded_files<span>)</span><span>)</span><span>}</span>
  <span>end</span>
</code></pre>
<p>We&#39;re grabbing the first uploaded file and calling our Rust function. The result is a tuple containing the contents of the PDF and the metadata.</p>
<p>Let&#39;s try it out with the <a href="https://liveviewcookbook.com/">LiveView Cookbook PDF</a>.</p>
<p><img src="https://i.imgur.com/dpyzduq.png" alt="Unstructured"/></p>
<p>Success! We&#39;ve now got a PDF parser that&#39;s fast, efficient, and written in Rust.</p>
<p>But that&#39;s quite hard to read so we&#39;re not done yet, let&#39;s make this a little nicer to work with.</p>
<p>Let&#39;s create a new module to handle the Jason encoding of the metadata.</p>
<pre><code><span>defmodule</span> <span>ElixirPdf</span><span>.</span><span>PdfDocument</span> <span>do</span>
  <span>@derive</span> <span>{</span><span>Jason</span><span>.</span><span>Encoder</span><span>,</span> <span>only:</span> <span>[</span><span>:content</span><span>,</span> <span>:metadata</span><span>]</span><span>}</span>
  <span>defstruct</span> <span>[</span><span>:content</span><span>,</span> <span>:metadata</span><span>]</span>

  <span>def</span> <span>from_rustler</span><span>(</span><span>{</span>content<span>,</span> metadata_json<span>}</span><span>)</span> <span>do</span>
    with <span>{</span><span>:ok</span><span>,</span> metadata<span>}</span> <span>&lt;-</span> <span>Jason</span><span>.</span><span>decode</span><span>(</span>metadata_json<span>)</span> <span>do</span>
      <span>%</span>__MODULE__<span>{</span>
        <span>content:</span> <span>String</span><span>.</span><span>trim</span><span>(</span>content<span>)</span><span>,</span>
        <span>metadata:</span> metadata
      <span>}</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre>
<p>This will allow us to encode the metadata to JSON and decode it back to a struct in Elixir to make it easier to work with.</p>
<p>All we have to do is pipe the result of our Rust function through this module and we&#39;re done!</p>
<pre><code><span>...</span>
<span>RustReader</span><span>.</span><span>extract_pdf</span><span>(</span><span>@pdf_document</span><span>)</span>
<span>|&gt;</span> <span>ElixirPdf</span><span>.</span><span>PdfDocument</span><span>.</span><span>from_rustler</span><span>(</span><span>)</span>
<span>...</span>
</code></pre>
<p>Now when we upload a PDF file, we&#39;ll see the metadata results in a much more readable format.</p>
<p><img src="https://i.imgur.com/QvG2QUV.png" alt="Structured"/></p>
<p>Much better!</p>
<p>This approach is simple and effective - it&#39;s fast, efficient, and leverages the strengths of both Elixir and Rust to provide a robust solution for PDF parsing.</p>
<p>We&#39;re only talking about PDF files here but extractous supports a <a href="https://github.com/yobix-ai/extractous?tab=readme-ov-file#-supported-file-formats">wide range of file types</a> - so keep that in mind if you need to extract data from other file types.</p>
<h2>What about deployment?</h2>
<p>Keep in mind that this is a native extension and so you&#39;ll need to build the Rust code before deploying your application. This can be done in a CI/CD pipeline or manually.</p>
<p>If you&#39;re using Docker, you can update the <code>Dockerfile</code> to build the Rust code as part of the build process and update <code>config/prod.exs</code> to tell Rustler to skip compilation and load the compiled NIF from where it was built in the Docker image.</p>
<p>Check out the <a href="https://fly.io/phoenix-files/elixir-and-rust-is-a-good-mix/">Fly.io blog post</a> for more information on how to deploy an Elixir application with Rust NIFs.</p>
<h2>Shoutouts</h2>
<p>Some shoutouts are in order - firstly this blog post from <a href="https://fly.io/phoenix-files/elixir-and-rust-is-a-good-mix/">Fly.io&#39;s Phoenix Files</a> outlining how to use Rust with NIFs in Elixir. It was a key inspiration for this approach and gave me the idea to use Rust in the first place. Also check out Fly in general for some great Elixir hosting options - I use them for all my Elixir applications.</p>
<p>Also a shoutout for the excellent <a href="https://github.com/yobix-ai/extractous">Extractous library</a> which provides fast and efficient unstructured data extraction in Rust - it&#39;s also 25x faster than the very popular unstructured-io library.</p>
<p>Finally, a shoutout to the <a href="https://github.com/rusterlium/rustler">Rustler</a> library for providing a simple way to call Rust code from Elixir!</p>

<p>All the code for this blog post can be <a href="https://github.com/chrisgreg/elixir_pdf_tutorial">found here on my Github</a> if anyone wants to clone it and run it yourselves!</p>
<p>I hope you found this post useful, subscribe to my Substack below for similar content and  <a href="https://www.twitter.com/codestirring">follow me on Twitter</a> and <a href="https://bsky.app/profile/codestirring.bsky.social">Bluesky</a> for more Elixir (and general programming) tips.</p>
<p>If you&#39;re building a Phoenix project, I&#39;d also encourage you to take a look at my open-source component library <a href="https://bloom-ui.fly.dev">Bloom</a> to help you out even further or check out my <a href="https://mmbl.io">new voice to notes application to automatically tag and sync your voice to your calendar</a>.</p><div><p><img src="https://www.liveviewcookbook.com/liveview-cook-book2.png"/></p></div><div><p>fin</p><p><h3>Sign up to my substack to be emailed about new posts</h3></p></div></div></div></div></div>
  </body>
</html>
