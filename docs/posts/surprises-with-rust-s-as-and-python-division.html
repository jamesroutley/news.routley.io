<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://annahope.me/blog/rust-as/">Original</a>
    <h1>Surprises with Rust&#39;s `as` (and Python division)</h1>
    
    <div id="readability-page-1" class="page"><article>
      

      <span> 15 min read <span></span> July 08, 2024 <span></span> #<a href="https://annahope.me/tags/rust/">rust</a>  #<a href="https://annahope.me/tags/python/">python</a>  #<a href="https://annahope.me/tags/programming/">programming</a> </span>

    


<p><small>I&#39;m not the first
to talk about this, and if you have experience with Rust or systems programming,
I doubt you&#39;ll find anything in this post surprising. 
I would welcome your feedback, though!</small></p>
<p>Coming to Rust mostly from higher-level languages,
I&#39;ve experienced surprising behavior when using <code>as</code> for type casting, and started to avoid it
where I could. </p>
<p>In this post, I give quite a bit of background information, which I hope explains 
<a href="https://annahope.me/blog/rust-as/#using-as-to-cast-types">why</a> someone might want to use <code>as</code> 
in the first place, <a href="https://annahope.me/blog/rust-as/#except-maybe-also-confusing-and-risky-1">why</a> 
I recommend for newcomers to Rust not to use <code>as</code>, and what I prefer
to use to convert between types instead. If you want to skip that background and go 
straight to the point, press <a href="https://annahope.me/blog/rust-as/#so-what-s-the-alternative-to-as">here.</a></p>
<span id="continue-reading"></span><h2 id="some-background">Some background</h2>
<p>Over the first week of my <a href="https://annahope.me/blog/starting-rc/">RC batch,</a> I met a lot of people who want to learn Rust. 
A fair number of people coming to Rust (at RC and beyond) have backgrounds primarily
in higher-level languages like Python or JavaScript. That&#39;s how I came to Rust as well — though I had 
written C in college, and Java before, I promptly moved on to Python because it was just plain more convenient
for everything I wanted to do. </p>
<p>I <em>really</em> enjoy coding in Rust now,
but it took a while for me to get there, and I abandoned learning it multiple times. 
Picking up Rust can be particularly frustrating for higher-language programmers. 
On top of the things that everyone has to grok, like
<a rel="noopener" target="_blank" href="https://doc.rust-lang.org/rust-by-example/scope/move.html">ownership</a> or 
<a rel="noopener" target="_blank" href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#the-rules-of-references">aliasing,</a>
non-systems-y people like me also immediately get hit with things like Rust having 
<a rel="noopener" target="_blank" href="https://doc.rust-lang.org/reference/types/numeric.html">14 built-in types to represent numbers</a> — 
meanwhile, Python has <a rel="noopener" target="_blank" href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex">three</a> 
(and most of us probably only ever deal with two — sorry, <code>complex</code>!), and JS has <del>one</del>
<a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#number_type">two.</a> </p>
<p>This kind of lower-level complexity is why I really appreciate people like <a rel="noopener" target="_blank" href="https://ntietz.com/">Nicole</a> 
creating resources like <a rel="noopener" target="_blank" href="https://yarr.fyi/introduction">YARR!</a> It targets specifically people who know how to 
program in high-level but maybe not lower-level languages, and who want to get started with Rust without immediately
getting overwhelmed. And one thing that can cause newcomers to Rust extra overwhelm 
is the number of resources telling them what <em>not</em> to do, just as they&#39;re figuring out what they can do in 
the first place. </p>
<p>I know that advice is probably coming from a good place, and has merit 
— we don&#39;t want newcomers to learn unidiomatic constructs and form bad habits that could hurt them
in the long term. 
But often, the &#34;don&#39;t do &lt;x&gt;&#34; advice doesn&#39;t give clear direction on what to do instead,
which can make newcomers feel more confused and stuck, or, at worst, make them give up altogether.</p>
<p>So I want to be cautious with this post, and first explain where I&#39;m coming from with my own
&#34;don&#39;t do &lt;x&gt;&#34; advice about type casting with <code>as</code>.</p>
<h2 id="gotchas-with-types-more-background">Gotchas with types (more background)</h2>
<p>Not only does Rust have all those numeric types, Rust is also much stricter about types
than other languages people might be used to.</p>
<h3 id="being-flexible-with-types-is-convenient">Being flexible with types is convenient!</h3>
<p>Take this Python function:</p>
<pre data-lang="python"><code data-lang="python"><span><span><span><span>def</span></span> <span><span>get_half</span></span></span><span><span>(</span></span><span><span>number</span><span>)</span></span><span><span>:</span></span>
</span><span>    <span>return</span> <span><span>number</span></span> <span>/</span> <span>2</span>
</span></code></pre>
<p>We can give it a <code>float</code> or an <code>int</code>, and it does what most people would intuitively
expect it to do:</p>
<pre data-lang="python"><code data-lang="python"><span><span>&gt;</span><span>&gt;</span><span>&gt;</span> <span><span><span><span>get_half</span></span></span></span><span><span>(</span><span>2</span><span>)</span></span>
</span><span><span>1<span>.</span>0</span>
</span></code></pre>
<pre data-lang="python"><code data-lang="python"><span><span>&gt;</span><span>&gt;</span><span>&gt;</span> <span><span><span><span>get_half</span></span></span></span><span><span>(</span><span>1<span>.</span>5</span><span>)</span></span>
</span><span><span>0<span>.</span>75</span>
</span></code></pre>
<p>No matter whether we give <code>get_half</code> an <code>int</code> or a <code>float</code>, it can work with either,
and always gives us back a <code>float</code>. Makes sense. Great.</p>
<p>Now, let&#39;s say we want to get half of something that can only ever be an integer. 
For example, we might want
to distribute some computationally expensive workload among multiple CPU cores, but we
don&#39;t want to use more than half of our CPU cores to save the rest for something else. 
Our input is always a whole number, our output should always be a whole number,
we never want to get more than ½ of the output, so we choose to use 
<a rel="noopener" target="_blank" href="https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations">floor division,</a>
and write this function instead:</p>
<pre data-lang="python"><code data-lang="python"><span><span><span><span>def</span></span> <span><span>get_half_floor</span></span></span><span><span>(</span></span><span><span>number</span><span>)</span></span><span><span>:</span></span>
</span><span>    <span>return</span> <span><span>number</span></span> <span>/</span><span>/</span> <span>2</span>
</span></code></pre>
<p>We can give it an <code>int</code>, and it does what we think it should.</p>
<pre data-lang="python"><code data-lang="python"><span><span>&gt;</span><span>&gt;</span><span>&gt;</span> <span><span><span><span>get_half_floor</span></span></span></span><span><span>(</span><span>6</span><span>)</span></span>
</span><span><span>3</span>
</span><span><span>&gt;</span><span>&gt;</span><span>&gt;</span> <span><span><span><span>get_half_floor</span></span></span></span><span><span>(</span><span>7</span><span>)</span></span>
</span><span><span>3</span>
</span></code></pre>
<p>We get back an <code>int</code>, as we should, and we never get more than half, which is how floor division by 2 should 
work. Great.</p>
<h3 id="except-maybe-also-confusing-and-risky">...except maybe also confusing and risky</h3>
<p>Someone somehow introduces a bug in the code we use to get the number of CPU cores,
and it starts giving us a <code>float</code> instead. What would <code>get_half_floor</code> do?</p>
<pre data-lang="python"><code data-lang="python"><span><span>&gt;</span><span>&gt;</span><span>&gt;</span> <span><span><span><span>get_half_floor</span></span></span></span><span><span>(</span><span>6<span>.</span>0</span><span>)</span></span>
</span><span><span>3<span>.</span>0</span>
</span></code></pre>
<p>No matter whether we give <code>get_half_floor</code> an <code>int</code> or a <code>float</code>, it can work with either, 
and gives us an <code>int</code> if we passed it an <code>int</code>, and a <code>float</code> if we passed a <code>float</code>. Makes sense. Great.</p>
<p><em>Wait.</em></p>
<pre data-lang="python"><code data-lang="python"><span><span>&gt;</span><span>&gt;</span><span>&gt;</span> <span><span><span><span>get_half</span></span></span></span><span><span>(</span><span>2</span><span>)</span></span>
</span><span><span>1<span>.</span>0</span>
</span><span><span>&gt;</span><span>&gt;</span><span>&gt;</span> <span><span><span><span>get_half</span></span></span></span><span><span>(</span><span>1<span>.</span>5</span><span>)</span></span>
</span><span><span>0<span>.</span>75</span>
</span><span><span>&gt;</span><span>&gt;</span><span>&gt;</span> <span><span><span><span>get_half_floor</span></span></span></span><span><span>(</span><span>6</span><span>)</span></span>
</span><span><span>3</span>
</span><span><span>&gt;</span><span>&gt;</span><span>&gt;</span> <span><span><span><span>get_half_floor</span></span></span></span><span><span>(</span><span>6<span>.</span>0</span><span>)</span></span>
</span><span><span>3<span>.</span>0</span>
</span></code></pre>
<p><code>get_half</code>, which uses &#34;regular&#34; division, can take an <code>int</code> or a <code>float</code>, and always returns a <code>float</code>. 
<code>get_half_floor</code>, which uses floor division, can take an <code>int</code> or a <code>float</code>, and always returns the same
numeric type that we gave it. Huh.</p>
<p>While both behaviors might make sense individually, this inconsistency between the two
<a rel="noopener" target="_blank" href="https://stackoverflow.com/questions/49282799/python-3-int-division-operator-is-returning-a-float">has</a>
<a rel="noopener" target="_blank" href="https://stackoverflow.com/questions/1282945/why-does-integer-division-yield-a-float-instead-of-another-integer">confused</a> 
<a rel="noopener" target="_blank" href="https://stackoverflow.com/questions/63283423/why-does-floor-division-return-a-float-instead-of-an-int">some</a>
<a rel="noopener" target="_blank" href="https://stackoverflow.com/questions/63218521/why-does-python-floor-division-return-a-float-when-the-divisor-and-or-dividend-i">people.</a></p>
<p>Worse, if getting a <code>float</code> for the number of CPUs (or whatever else) is indeed a bug, 
and our <code>get_half_floor</code> function happily takes and returns both ints and floats, 
we might not realize something is wrong until much later, if at all.
So, while the flexibility that comes with
<a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Type_conversion">type coercion</a> is often convenient, and many common
programming languages offer it, it can also cause subtle bugs or unexpected behavior in real-world code, 
which can be difficult to track down in a complex codebase.</p>
<p>Which is likely why Rust does not implicitly coerce types at all.</p>
<h2 id="the-challenge-with-rust-s-strict-type-system">The challenge with Rust&#39;s strict type system</h2>
<p><small>Note: If you want a refresher on Rust&#39;s types I will be using in this section,
please check the <a rel="noopener" target="_blank" href="https://doc.rust-lang.org/book/ch03-02-data-types.html#scalar-types">Data Types section</a>
of The Rust Programming Language (a.k.a. The Book).</small></p>
<p>Let&#39;s say we want to port the above <code>get_half</code> function to Rust.</p>
<p>First, we have to pick which of those many numeric types we want our function to take as an argument. 
Maybe we choose <code>f64</code>, because that&#39;s the equivalent of Python&#39;s <code>float</code>, and is Rust&#39;s default
floating-point type, and write the following function:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>get_half</span></span><span><span><span>(</span><span>number</span><span>:</span> <span>f64</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>f64</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    number <span>/</span> <span>2.</span><span>0</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>and then use it with another floating-point input: </p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> number <span>=</span> <span>2.</span><span>0</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> result <span>=</span> <span>get_half</span><span><span>(</span>number</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>dbg!</span><span><span>(</span>result</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>We compile and run that code and get:</p>
<pre><code><span>[src/main.rs:8:5] result = 1.0
</span></code></pre>
<p>Great.</p>
<p>But what if we change <code>number</code> to be an integer?</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> number <span>=</span> <span>2</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> result <span>=</span> <span>get_half</span><span><span>(</span>number</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>dbg!</span><span><span>(</span>result</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Rust doesn&#39;t allow that.</p>
<pre><code><span>error[E0308]: mismatched types
</span><span> --&gt; src/main.rs:7:27
</span><span>  |
</span><span>7 |     let result = get_half(number);
</span><span>  |                  -------- ^^^^^^ expected `f64`, found integer
</span><span>  |                  |
</span><span>  |                  arguments to this function are incorrect
</span><span>  |
</span><span>note: function defined here
</span><span> --&gt; src/main.rs:1:4
</span><span>  |
</span><span>1 | fn get_half(number: f64) -&gt; f64 {
</span><span>  |    ^^^^^^^^ -----------
</span><span>
</span><span>For more information about this error, try `rustc --explain E0308`.
</span></code></pre>
<p>Rust doesn&#39;t even allow us to use <code>f32</code> as-is, either:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> number<span>:</span> <span>f32</span> <span>=</span> <span>2.</span><span>0</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> result <span>=</span> <span>get_half</span><span><span>(</span>number</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>dbg!</span><span><span>(</span>result</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<pre><code><span> --&gt; src/main.rs:7:27
</span><span>  |
</span><span>7 |     let result = get_half(number);
</span><span>  |                  -------- ^^^^^^ expected `f64`, found `f32`
</span><span>  |                  |
</span><span>  |                  arguments to this function are incorrect
</span><span>  |
</span><span>note: function defined here
</span><span> --&gt; src/main.rs:1:4
</span><span>  |
</span><span>1 | fn get_half(number: f64) -&gt; f64 {
</span><span>  |    ^^^^^^^^ -----------
</span><span>help: you can convert an `f32` to an `f64`
</span><span>  |
</span><span>7 |     let result = get_half(number.into());
</span><span>  |                                 +++++++
</span><span>
</span><span>For more information about this error, try `rustc --explain E0308`.
</span></code></pre>
<p>(When we try to call <code>get_half</code> with an <code>f32</code>, Rust does at least suggest we can use 
<a rel="noopener" target="_blank" href="https://doc.rust-lang.org/1.79.0/std/convert/trait.Into.html"><code>into</code>,</a> which is helpful and makes this code work.)</p>
<p>Our Rust function takes an <code>f64</code>, so we can only give it an <code>f64</code>, and nothing else will compile.
This could save us from the kind of subtle bugs and inconsistencies
we saw in our Python code.</p>
<p>But what do we do if our input has one of the other numeric types?</p>
<h2 id="using-as-to-cast-types">Using <code>as</code> to cast types</h2>
<h3 id="it-s-convenient">It&#39;s convenient!</h3>
<p>As YARR! <a rel="noopener" target="_blank" href="https://yarr.fyi/variables#casting-between-types">points out</a>, we can use <code>as</code> to cast
our number to <code>f64</code>, whatever its type.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> number <span>=</span> <span>2</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> result <span>=</span> <span>get_half</span><span><span>(</span>number <span>as</span> <span>f64</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>dbg!</span><span><span>(</span>result</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>It compiles, and runs, and we get what we want:</p>
<pre><code><span>[src/main.rs:8:5] result = 1.0
</span></code></pre>
<p>All is well. We just learned a convenient way to work around Rust&#39;s strictness with types by using <code>as</code>.</p>
<h3 id="except-maybe-also-confusing-and-risky-1">...except maybe also confusing and risky</h3>
<p>YARR! also says this:</p>
<blockquote>
<p>You do have to be careful to ensure that if you cast to a smaller size value, that you won&#39;t overflow anything. 
The behavior you get is well-defined but may be unexpected.</p>
</blockquote>
<p>What&#39;s this unexpected behavior?</p>
<p>Well, remember the <code>get_half_floor</code> function for getting no more than half of available CPU cores?</p>
<p>We port that to Rust, too:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>get_half_floor</span></span><span><span><span>(</span><span>number</span><span>:</span> <span>u8</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>u8</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    number <span>/</span> <span>2</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> number <span>=</span> <span>6</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> result <span>=</span> <span>get_half_floor</span><span><span>(</span>number</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>dbg!</span><span><span>(</span>result</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    <span>let</span> another_result <span>=</span> <span>get_half_floor</span><span><span>(</span><span>7</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>dbg!</span><span><span>(</span>another_result</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>We use <code>u8</code> for <code>get_half_floor</code>&#39;s input type, which 
<a rel="noopener" target="_blank" href="https://doc.rust-lang.org/book/ch03-02-data-types.html#scalar-types">maxes out at 255,</a> and 255 CPU cores 
<a rel="noopener" target="_blank" href="https://quoteinvestigator.com/2011/09/08/640k-enough/">ought to be enough for anybody.</a>
We compile and run our code.</p>
<pre><code><span>[src/main.rs:8:5] result = 3
</span><span>[src/main.rs:11:5] another_result = 3
</span></code></pre>
<p>Great.</p>
<p>But now someone gives us a machine with a <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Sierra_Forest">Sierra Forest</a> 
CPU, which has 288 cores. Our <code>get_half_floor</code> function still takes a <code>u8</code> though, so I guess
we&#39;ll be limited to half of 255 until we can update our code. That should do for now, though.</p>
<p>We run our code:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> number <span>=</span> <span>288</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> result <span>=</span> <span>get_half_floor</span><span><span>(</span>number <span>as</span> <span>u8</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>dbg!</span><span><span>(</span>result</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<pre><code><span>[src/main.rs:8:5] result = 16
</span></code></pre>
<p>Wait. We didn&#39;t get half of 288, which we knew we wouldn&#39;t, but we didn&#39;t even get half of 255. That&#39;s odd.
Why?</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> number <span>=</span> <span>288</span><span>;</span>
</span></span></span><span><span><span>    <span>dbg!</span><span><span>(</span>number <span>as</span> <span>u8</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<pre><code><span>[src/main.rs:7:5] number as u8 = 32
</span></code></pre>
<p>That&#39;s what that whole &#34;be careful not to overflow&#34; thing with &#34;unexpected behavior&#34; was about.
Rust By Example gives some helpful, uh, 
<a rel="noopener" target="_blank" href="https://doc.rust-lang.org/rust-by-example/types/cast.html">examples,</a> and explains that
when we use <code>as</code> to cast a number to a <code>u8</code>, and our number can&#39;t fit into a <code>u8</code></p>
<blockquote>
<p>the first 8 least significant bits (LSB) are kept,
while the rest towards the most significant bit (MSB) get truncated.</p>
</blockquote>
<p>This makes sense if we look at the binary representation:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> number <span>=</span> <span>288</span><span>;</span>
</span></span></span><span><span><span>    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>288 in binary is <span>{number:b}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>288 as u8 in binary is <span>{:b}</span><span>&#34;</span></span></span><span><span>,</span> number <span>as</span> <span>u8</span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<pre><code><span>288 in binary is 100100000
</span><span>288 as u8 in binary is 100000
</span></code></pre>
<p>288 doesn&#39;t fit into <code>u8</code>, so when we cast it to <code>u8</code> with <code>as</code>, 
Rust indeed took only the 8 least significant bits (going from right to left), 
and discarded the rest. This gave us 100000 in binary, which is 32 in decimal,
and explains why <code>get_half_floor</code> gave us 16 when we called it with <code>288 as u8</code>.</p>
<p>So, similarly to our earlier Python functions surprising us by giving us <code>float</code>s when we might&#39;ve 
expected an <code>int</code>, using <code>as</code> could lead to subtle bugs and confusing behavior that we might not notice 
or find hard to track down in a larger codebase. Systems-y people know about this,
but programmers coming from higher-level languages might find it surprising.</p>
<h2 id="so-what-s-the-alternative-to-as">So what&#39;s the alternative to <code>as</code>?</h2>
<p>I have gotten in the habit of using <a rel="noopener" target="_blank" href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html#examples"><code>TryFrom</code></a>
when I need to convert between types and avoid surprising (to me) results. As its docs say:</p>
<blockquote>
<p>the TryFrom trait informs the programmer when a type conversion could go bad and lets them decide how to handle it.</p>
</blockquote>
<p>With that, we could now change our code to</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>get_half_floor</span></span><span><span><span>(</span><span>number</span><span>:</span> <span>u8</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>u8</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    number <span>/</span> <span>2</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> number<span>:</span> <span>u16</span> <span>=</span> <span>32</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> result <span>=</span> <span>match</span> <span>u8</span><span><span>::</span></span>try_from<span><span>(</span>number</span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>Ok</span><span><span>(</span>number</span><span><span>)</span></span> <span>=&gt;</span> <span>get_half_floor</span><span><span>(</span>number</span><span><span>)</span></span><span>,</span>
</span></span></span></span><span><span><span><span>        <span>Err</span><span><span>(</span>error</span><span><span>)</span></span> <span>=&gt;</span> <span>panic!</span><span><span>(</span><span><span>&#34;</span>{error}<span>&#34;</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span><span>;</span>
</span></span></span><span><span><span>    <span>dbg!</span><span><span>(</span>result</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>and get</p>
<pre><code><span>[src/main.rs:11:5] result = 16
</span></code></pre>
<p>And if we try a value that doesn&#39;t fit, like here:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> number <span>=</span> <span>288</span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>dbg!</span><span><span>(</span>result</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>we get </p>
<pre><code><span>thread &#39;main&#39; panicked at src/main.rs:9:23:
</span><span>Couldn&#39;t convert 288 to u8: out of range integral type conversion attempted
</span></code></pre>
<p>which tells us something went wrong (and what), instead of surprising us. </p>
<p>In real code, we might want to handle the error some other way
instead of just panicking, like </p>
<ul>
<li>Logging a warning  that our value is out of range of <code>u8</code> 
(perhaps with <a rel="noopener" target="_blank" href="https://github.com/tokio-rs/tracing">tracing)</a></li>
<li>And/or passing <code>get_half_floor</code> a
<a rel="noopener" target="_blank" href="https://doc.rust-lang.org/std/primitive.u8.html#associatedconstant.MAX"><code>u8::MAX</code></a> instead, if we got something
larger than that</li>
<li>And/or ignoring the input as invalid </li>
<li>And/or using <code>as</code> anyway, but at least with a log message that would make it clearer to us (or someone else) 
that something unexpected happened, and where to look </li>
</ul>
<p>Or maybe something else! Our strategy for handling the error would depend on what we&#39;re ultimately trying to do, and 
what would be appropriate for our library/application and the user. But we would know 
something unexpected happened, and we&#39;d explicitly decide how to deal with it.</p>
<p>Using <code>TryFrom</code> is definitely more verbose, and requires more boilerplate, which makes it less convenient 
than <code>as</code>. But like others have pointed out, it&#39;s one of a few relatively uncommon cases where going against Rust&#39;s 
&#34;default&#34; way of doing something may actually be a better pattern. </p>
<p><small>Thanks to <a rel="noopener" target="_blank" href="https://www.davidglivar.com/">David Glivar</a> for giving me feedback 
about a draft of this post!</small></p>
<hr/>








    <p><small><i>If you have feedback, I would love to hear from you! Please use one of the links below to get in touch.</i></small>
    </p>
      <nav>
        
        
      </nav>
    </article></div>
  </body>
</html>
