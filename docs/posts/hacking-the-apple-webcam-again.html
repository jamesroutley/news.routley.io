<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ryanpickren.com/safari-uxss">Original</a>
    <h1>Hacking the Apple Webcam (Again)</h1>
    
    <div id="readability-page-1" class="page"><div data-mesh-id="comp-ks8xfd0zinlineContent" data-testid="inline-content"><div data-mesh-id="comp-ks8xfd0zinlineContent-gridContainer" data-testid="mesh-container-content"><p id="comp-ku4h2tmw" data-testid="richTextElement"><h2><span><span><span>Hacking the Apple Webcam (again)</span></span></span></h2></p><p><span>Gaining unauthorized camera access via Safari UXSS: the story of how a shared iCloud document can hack every website you&#39;ve ever visited.</span></p><div id="comp-kvgpl2jq" title=""><div data-testid="linkElement"><wix-image id="img_comp-kvgpl2jq" data-image-info="{&#34;containerId&#34;:&#34;comp-kvgpl2jq&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:2880,&#34;height&#34;:1800,&#34;uri&#34;:&#34;149864_9ee474cf32a541a6b34c80ea501d9e7b~mv2.jpeg&#34;,&#34;name&#34;:&#34;Screen Shot 2021-11-01 at 9.34.38 AM.jpeg&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_9ee474cf32a541a6b34c80ea501d9e7b~mv2.jpeg/v1/fill/w_635,h_397,al_c,q_80,usm_0.66_1.00_0.01/Screen%20Shot%202021-11-01%20at%209_34_38%20AM.jpeg" alt="Ryan Pickren"/></wix-image></div></div><p id="comp-ksat5ote" data-testid="richTextElement"><h2><span><span><span>Summary</span></span></span></h2></p><div id="comp-ksat5tod" data-testid="richTextElement"><p><span><span>It&#39;s been over a year since my <span><a href="https://www.ryanpickren.com/webcam-hacking" target="_blank">last Apple camera hacking project</a></span>, so I decided to give it another go.</span></span></p>



<p><span><span>My hack successfully gained unauthorized camera access by exploiting a series of issues with iCloud Sharing and Safari 15. While this bug does require the victim to click &#34;open&#34; on a popup from my website, it results in more than just multimedia permission hijacking. This time, the bug gives the attacker full access to every website ever visited by the victim. That means in addition to turning on your camera, my bug can also hack your iCloud, PayPal, Facebook, Gmail, etc. accounts too.</span></span></p>

<p><span><span>​</span></span></p>

<p><span><span>This research resulted in 4 0day bugs (CVE-2021-30861, CVE-2021-30975, and two without CVEs), 2 of which were used in the camera hack. I reported this chain to Apple and was awarded $100,500 as a bounty.</span></span></p></div><div id="comp-kshwj1ah" title=""><div data-testid="linkElement"><wix-image id="img_comp-kshwj1ah" data-image-info="{&#34;containerId&#34;:&#34;comp-kshwj1ah&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:3460,&#34;height&#34;:1912,&#34;uri&#34;:&#34;149864_39c68683560a40619317cdc414031092~mv2.png&#34;,&#34;name&#34;:&#34;hack-banner2.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_39c68683560a40619317cdc414031092~mv2.png/v1/fill/w_809,h_447,al_c,usm_0.66_1.00_0.01/hack-banner2.png" alt="Safari UXSS"/></wix-image></div></div><p id="comp-ks8xh4qs" data-testid="richTextElement"><h2><span><span><span>Background</span></span></span></h2></p><div id="comp-ks8xhhjq" data-testid="richTextElement"><p>Apple fixed my last 0day chain (CVE-2020-3852 + CVE-2020-3864 + CVE-2020-3865) by making camera access drastically more difficult. Now multimedia access is only allowed when the protocol is &#34;https:&#34; and the domain matches your saved settings. This means that cleverly malformed URIs won&#39;t cut it anymore. Now we need to genuinely inject our evil code into the target origin. <span>In other words, we need to find a <span>Universal Cross-Site Scripting (UXSS)</span> bug.</span></p>



<p><span>But what exactly is UXSS? Google Project Zero has a nice summary in their paper, &#34;<span><a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/f5a8289d4f69e9e34b38a1e7c05ef4818b22cd5b.pdf" target="_blank" rel="noreferrer noopener">Analysis of UXSS exploits and mitigations in Chromium</a></span>&#34; - </span></p>

<p><span><span>​</span></span></p>

<p><span><span>&#34;UXSS attacks exploit vulnerabilities in the browser itself [...] to achieve an XSS condition. As a result, the attacker does not just get access to user session on a single website, but may get access to any [website].&#34;</span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span>The authors of this paper go on to call UXSS &#34;<span>among the most significant threats for users of any browser</span>&#34; and &#34;<span>almost as valuable as a ​Remote Code Execution​ (RCE) exploit with the sandbox escape</span>.&#34; Sounds pretty great, right? Imagine building a website that can jump into <a data-auto-recognition="true" href="https://zoom.com" target="_blank">https://zoom.com</a> to turn on the camera, hop into <a data-auto-recognition="true" href="https://paypal.com" target="_blank">https://paypal.com</a> to transfer money, and hijack <a data-auto-recognition="true" href="https://gmail.com" target="_blank">https://gmail.com</a> to steal emails. </span></p>

<p><span><span>​</span></span></p>

<p><span>Before we go any further, I should clarify how exactly this bug differs from my last <span><a href="https://www.ryanpickren.com/webcam-hacking" target="_blank" rel="noreferrer noopener">Safari Camera Hacking project</a></span>. That bug specifically targeted stored multimedia permissions. It did not give me the ability to execute code on arbitrary origins. Check out my <span><a href="https://static.wixstatic.com/media/149864_ec31bf9c57244f2c9c45113067800963~mv2_d_1954_1420_s_2.png/v1/fill/w_1510,h_1096,al_c,usm_0.66_1.00_0.01/finaldiagram.png" target="_blank" rel="noreferrer noopener">attack diagram</a></span> to see which origins were being used. In other words, that hack let me leverage Skype&#39;s camera permission but did not let me steal Skype&#39;s cookies. </span></p>

<p><span><span>​</span></span></p>

<p><span>Let&#39;s try to find a UXSS bug in the latest version of Safari (<span>Safari v15 beta</span> at time of writing). As always, the first step is to do <span>a lot</span> of research into prior work. After all, the best security research comes from <span><a href="https://en.wikipedia.org/wiki/Standing_on_the_shoulders_of_giants" target="_blank" rel="noreferrer noopener">standing on the shoulders of giants</a></span>.</span></p></div><p id="comp-ks8xigw7" data-testid="richTextElement"><h2><span><span><span>The Attack Plan</span></span></span></h2></p><p><span>After reading numerous write-ups about patched Safari UXSS bugs, I decided to focus my research on <span><a href="https://en.wikipedia.org/wiki/Webarchive" target="_blank">webarchive</a></span> files. These files are created by Safari as an alternative to HTML when a user saves a website locally.</span></p><div id="comp-ks917u2c" title=""><div data-testid="linkElement"><wix-image id="img_comp-ks917u2c" data-image-info="{&#34;containerId&#34;:&#34;comp-ks917u2c&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:660,&#34;height&#34;:490,&#34;uri&#34;:&#34;149864_c843308e16bc4ecfbc5025b163c8a422~mv2.png&#34;,&#34;name&#34;:&#34;Screen Shot 2021-08-12 at 10.43.16 AM.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_c843308e16bc4ecfbc5025b163c8a422~mv2.png/v1/fill/w_336,h_249,al_c,usm_0.66_1.00_0.01/Screen%20Shot%202021-08-12%20at%2010_43_16%20AM.png" alt="Screen Shot 2021-08-12 at 10.43.16 AM.png"/></wix-image></div></div><p><span>Safari saving a website as a Webarchive file</span></p><p><span>A startling </span><span>feature</span><span> of these files is that they specify the web origin that the content should be rendered in. </span></p><div id="comp-ksj51imt" title=""><div data-testid="linkElement"><wix-image id="img_comp-ksj51imt" data-image-info="{&#34;containerId&#34;:&#34;comp-ksj51imt&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:1876,&#34;height&#34;:900,&#34;uri&#34;:&#34;149864_a0910f9a434f40a98558d5d034c50814~mv2.png&#34;,&#34;name&#34;:&#34;Screen Shot 2021-08-19 at 12.24.03 PM.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_a0910f9a434f40a98558d5d034c50814~mv2.png/v1/fill/w_700,h_336,al_c,usm_0.66_1.00_0.01/Screen%20Shot%202021-08-19%20at%2012_24_03%20PM.png" alt="Apple Webarchive File Format"/></wix-image></div></div><p><span>Webarchive File Format</span></p><div id="comp-ks91adf8" data-testid="richTextElement"><p><span><span>This is an awesome trick to let Safari rebuild the context of the saved website, but as the Metasploit authors </span><span><a href="https://www.rapid7.com/blog/post/2013/04/25/abusing-safaris-webarchive-file-format/" target="_blank" rel="noreferrer noopener">pointed out</a></span><span> back in 2013, if an attacker can somehow modify this file, they could effectively achieve UXSS by-design.</span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span><span><a href="https://www.rapid7.com/blog/post/2013/04/25/abusing-safaris-webarchive-file-format/" target="_blank" rel="noreferrer noopener">According to Metasploit</a></span>, Apple did not view this attack scenario as very realistic because &#34;<span>the webarchives must be downloaded and manually opened by the client</span>.&#34; Granted this decision was made nearly a decade ago, when the browser </span><span>security model wasn&#39;t nearly as mature as it is today.</span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>Apple&#39;s decision to support this ultra-powerful filetype gave way to an era of hackers trying to forcefully open them on victims&#39; machines. Fundamentally, this attack can be broken into two steps:</span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>1) Forcefully download an evil webarchive file</span></span></p>

<p><span><span>2) Forcefully open it</span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>Until recently, there were no protections to prevent step #1. Prior to Safari 13, no warnings were even displayed to the user before a website downloaded arbitrary files. So planting the webarchive file was easy. (</span><span><a href="https://www.cultofmac.com/675928/how-to-stop-safari-asking-permission-to-download-everything/" target="_blank" rel="noreferrer noopener">Now with Safari 13+</a></span><span>, users are prompted before each download)</span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>Opening the webarchive file was trickier, but still manageable by somehow navigating to the file:// URI scheme. Back when Safari&#39;s error pages lived on the file:// scheme, hackers figured out how to purposely invoke an error page to just alter its pathname, a hack delightfully dubbed &#34;<span>Errorjacking</span>.&#34; See <span><a href="http://vttynotes.blogspot.com/2011/03/safari-errorjacking-cve-2011-0167.html" target="_blank" rel="noreferrer noopener">here</a></span> and <span><a href="http://joevennix.com/2015/06/24/Adventures-in-Browser-Exploitation-Part-II-Safari-8-UXSS.html" target="_blank" rel="noreferrer noopener">here</a></span> for two variations. <span><a href="http://vttynotes.blogspot.com/2011/10/cve-2011-3230-launch-any-file-path-from.html" target="_blank" rel="noreferrer noopener">Another approach</a></span> that worked back in the day was to simply set the &lt;base&gt; tag to file://.</span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>Fast forward to 2022 and things get a lot harder. Not only are auto-downloads prevented by default, but webarchive files are considered malicious applications by </span><span><a href="https://en.wikipedia.org/wiki/Gatekeeper_(macOS)" target="_blank" rel="noreferrer noopener">macOS Gatekeeper</a></span><span>. This means that users can&#39;t even manually open foreign webarchives themselves anymore. Apple seems to have changed their 2013 stance about how dangerous these files can be.</span></span></p></div><div id="comp-ks96qb3o" title=""><div data-testid="linkElement"><wix-image id="img_comp-ks96qb3o" data-image-info="{&#34;containerId&#34;:&#34;comp-ks96qb3o&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:910,&#34;height&#34;:322,&#34;uri&#34;:&#34;149864_9423c1acab4f42f2b9acb968c71815d1~mv2.png&#34;,&#34;name&#34;:&#34;Screen Shot 2021-08-12 at 1.17.50 PM.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_9423c1acab4f42f2b9acb968c71815d1~mv2.png/v1/fill/w_511,h_181,al_c,usm_0.66_1.00_0.01/Screen%20Shot%202021-08-12%20at%201_17_50%20PM.png" alt="Screen Shot 2021-08-12 at 1.17.50 PM.png"/></wix-image></div></div><p><span>Download prompt in Safari 13+</span></p><div id="comp-ks96sl0l" title=""><div data-testid="linkElement"><wix-image id="img_comp-ks96sl0l" data-image-info="{&#34;containerId&#34;:&#34;comp-ks96sl0l&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:550,&#34;height&#34;:616,&#34;uri&#34;:&#34;149864_8208d8b8b5334544b92f5db939257238~mv2.png&#34;,&#34;name&#34;:&#34;Screen Shot 2021-08-12 at 1.19.38 PM.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_8208d8b8b5334544b92f5db939257238~mv2.png/v1/fill/w_307,h_344,al_c,usm_0.66_1.00_0.01/Screen%20Shot%202021-08-12%20at%201_19_38%20PM.png" alt="Gatekeeper Webarchive Prompt"/></wix-image></div></div><p><span>Gatekeeper Launch Prevention</span></p><p><span>Still, webarchive files just seem too juicy to give up on. Let&#39;s explore how this old-school hack can still occur on the latest Safari and macOS builds.</span></p><p id="comp-ks8xtmqc" data-testid="richTextElement"><h2><span><span><span>Exploration of custom URI Schemes</span></span></span></h2></p><div id="comp-ks8xtmqh" data-testid="richTextElement"><p><span>I found success with my last </span><span><a href="https://www.ryanpickren.com/webcam-hacking" target="_blank" rel="noreferrer noopener">Safari Camera Hacking project</a></span><span> by conducting a deep dive into </span><span><a href="https://en.wikipedia.org/wiki/List_of_URI_schemes#Official_IANA-registered_schemes" target="_blank" rel="noreferrer noopener">official IANA-registered URI schemes</a></span><span>. This project was heavily guided by RFCs and public documentation. But there is an entire world of <span><a href="https://developer.apple.com/documentation/xcode/defining-a-custom-url-scheme-for-your-app" target="_blank" rel="noreferrer noopener">custom URL schemes</a></span> that I neglected to talk about. These </span><span>unofficial and (mostly) undocumented </span><span>schemes are usually used by third party iOS/macOS apps as a form of deep linking. There is actually an entire community built around <span><a href="https://github.com/phynet/iOS-URL-Schemes" target="_blank" rel="noreferrer noopener">discovering</a></span> and using these schemes cross-app for both <span><a href="https://ios.gadgethacks.com/how-to/use-google-maps-waze-with-siri-instead-apple-maps-0192301/" target="_blank" rel="noreferrer noopener">fun</a></span> and <span><a href="https://grepharder.github.io/blog/0x03_learning_about_universal_links_and_fuzzing_url_schemes_on_ios_with_frida.html" target="_blank" rel="noreferrer noopener">hacking</a></span> projects.</span></p>

<p><span><span>​</span></span></p>

<p><span>An interesting note is that several first-party system apps such as Apple Help Viewer (help://), FaceTime (facetime-audio://), and Apple Feedback (applefeedback://) also support custom URI schemes. Abusing these schemes from a website in Safari is not a novel technique. Indeed, hackers have been finding ways to use custom schemes to launch (and exploit bugs in) system applications for a while now. Hacks range from </span><span><a href="https://www.cvedetails.com/cve/CVE-2013-6835/" target="_blank" rel="noreferrer noopener">annoyingly placing calls</a></span><span>, </span><span><a href="https://www.bitcoininsider.org/article/29392/i-give-you-working-exploit-stable-chrome-mac" target="_blank" rel="noreferrer noopener"><span>aiding in social engineering</span></a></span><span>, to </span><span><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1040" target="_blank" rel="noreferrer noopener">arbitrary file execution</a></span><span>. Seriously, there is some </span><span><a href="https://conference.hitb.org/hitbsecconf2017ams/materials/D2T2%20-%20Yu%20Hong%20-%20Attack%20Surface%20Extended%20by%20URL%20Schemes.pdf" target="_blank" rel="noreferrer noopener">awesome research</a></span><span> in this space.</span></p>

<p><span>​</span></p>

<p><span>To help combat these attacks, modern versions of Safari warn the user before blindly launching secondary applications. That is, unless they are one of the hardcoded exceptions identified in this great <span><a href="https://i.blackhat.com/eu-20/Thursday/eu-20-Zhou-Cross-Site-Escape-Pwning-MacOS-Safari-Sandbox-The-Unusual-Way.pdf" target="_blank" rel="noreferrer noopener">Blackhat presentation</a></span>. </span></p></div><div id="comp-ks99lzxk" title=""><div data-testid="linkElement"><wix-image id="img_comp-ks99lzxk" data-image-info="{&#34;containerId&#34;:&#34;comp-ks99lzxk&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:1428,&#34;height&#34;:630,&#34;uri&#34;:&#34;149864_44bd070e80b6438582966fb78c3dc726~mv2.png&#34;,&#34;name&#34;:&#34;Screen Shot 2021-08-12 at 2.33.07 PM.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_44bd070e80b6438582966fb78c3dc726~mv2.png/v1/fill/w_600,h_265,al_c,usm_0.66_1.00_0.01/Screen%20Shot%202021-08-12%20at%202_33_07%20PM.png" alt="Screen Shot 2021-08-12 at 2.33.07 PM.png"/></wix-image></div></div><p><span>Custom URI Schemes that Safari will launch without Prompt</span></p><div id="comp-ks99jp5e" data-testid="richTextElement"><p><span>All of these schemes are registered with </span><span><span><a href="https://developer.apple.com/documentation/coreservices/launch_services" target="_blank">Launch Services</a></span></span><span>, so you can list them (and others) via this command:</span></p>

<p><span>​</span></p></div><p>/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -dump | grep -B6 bindings:.*: | grep -B6 apple-internal</p><p><span>After digging through internal Apple schemes and cross-referencing them with the ones trusted by Safari, I found one that caught my eye- &#34;icloud-sharing:&#34;. This scheme appears to be </span><span>registered by an iCloud Sharing Application called &#34;ShareBear.&#34;</span></p><div id="comp-ks99lhvz" title=""><div data-testid="linkElement"><wix-image id="img_comp-ks99lhvz" data-image-info="{&#34;containerId&#34;:&#34;comp-ks99lhvz&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:1464,&#34;height&#34;:366,&#34;uri&#34;:&#34;149864_d60f099e6bad4a798dbb801d19ead7d0~mv2.png&#34;,&#34;name&#34;:&#34;Screen Shot 2021-08-12 at 2.38.00 PM.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_d60f099e6bad4a798dbb801d19ead7d0~mv2.png/v1/fill/w_600,h_150,al_c,usm_0.66_1.00_0.01/Screen%20Shot%202021-08-12%20at%202_38_00%20PM.png" alt="Screen Shot 2021-08-12 at 2.38.00 PM.png"/></wix-image></div></div><p><span>LaunchServices data about the icloud-sharing: scheme</span></p><p><span>ShareBear was interesting to me because sharing iCloud documents seemed like a plausible path towards downloading &amp; launching webarchive files. I couldn&#39;t find any publicly available documentation or research about this scheme so I just started poking at it myself.</span></p><p id="comp-ks8xy1e6" data-testid="richTextElement"><h2><span><span><span>ShareBear Application</span></span></span></h2></p><div id="comp-ks8xy1ec" data-testid="richTextElement"><p><span>At this point ​we have identified an application that can be automatically launched by Safari, however we do not know how to correctly open it yet. Luckily, it was pretty straight forward.</span></p>

<p><span><span>​</span></span></p>

<p><span>Some quick research shows that <span><a href="https://support.apple.com/guide/mac-help/share-files-with-icloud-file-sharing-mchl91854a7a/mac" target="_blank">iCloud File Sharing</a></span> can generate a public Share Link.</span></p>

<p><span>​</span></p></div><div id="comp-ks9a8uob" title=""><div data-testid="linkElement"><wix-image id="img_comp-ks9a8uob" data-image-info="{&#34;containerId&#34;:&#34;comp-ks9a8uob&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:700,&#34;height&#34;:543,&#34;uri&#34;:&#34;149864_51551058a85a4968a55461db5ba2c515~mv2.png&#34;,&#34;name&#34;:&#34;d69b081b8b7300b9da7fe35cb6fdaad1.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_51551058a85a4968a55461db5ba2c515~mv2.png/v1/fill/w_462,h_358,al_c,usm_0.66_1.00_0.01/d69b081b8b7300b9da7fe35cb6fdaad1.png" alt="d69b081b8b7300b9da7fe35cb6fdaad1.png"/></wix-image></div></div><p><span>Creating a public iCloud Share Link</span></p><p><span>evil.html</span></p><p><span>Great, so what does ShareBear do now? Some quick testing showed this behavior:</span></p><div id="comp-ks9dlucm" title=""><div data-testid="linkElement"><wix-image id="img_comp-ks9dlucm" data-image-info="{&#34;containerId&#34;:&#34;comp-ks9dlucm&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:1978,&#34;height&#34;:1452,&#34;uri&#34;:&#34;149864_a1380bc45a8f403f940925ffe1b1ecd6~mv2.png&#34;,&#34;name&#34;:&#34;sharebear.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_a1380bc45a8f403f940925ffe1b1ecd6~mv2.png/v1/fill/w_493,h_362,al_c,usm_0.66_1.00_0.01/sharebear.png" alt="sharebear.png"/></wix-image></div></div><p><span>ShareBear Behavior Flowchart</span></p><p><span>There is a subtle, but wildly impactful, design flaw with this behavior. Let&#39;s dig into what happens if the user has not opened this file before. The user will be shown a prompt, similar to the one below.</span></p><div id="comp-ks9e9dsd" title=""><div data-testid="linkElement"><wix-image id="img_comp-ks9e9dsd" data-image-info="{&#34;containerId&#34;:&#34;comp-ks9e9dsd&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:1324,&#34;height&#34;:1300,&#34;uri&#34;:&#34;149864_6c53897f72fc41d2a0183f1110a1a407~mv2.png&#34;,&#34;name&#34;:&#34;propt.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_6c53897f72fc41d2a0183f1110a1a407~mv2.png/v1/fill/w_328,h_322,al_c,usm_0.66_1.00_0.01/propt.png" alt="propt.png"/></wix-image></div></div><p><span>ShareBear Open Prompt</span></p><div id="comp-ks9e9vpb" data-testid="richTextElement"><p><span><span>This innocuous little prompt, with the default value of &#34;Open,&#34; seems pretty straightforward. A user should expect to have the image, </span><span>example.png</span><span>, opened if they agree. But in actuality, they are agreeing to much more than that. </span></span></p>



<p><span><span>Once the user clicks Open, the file is downloaded onto the victim&#39;s machine at the location <span>/Users/&lt;user&gt;/</span></span><span>Library/Mobile Documents/com~apple~CloudDocs </span><span>then automatically opened via Launch Services. Then the user will <span>never</span> see this prompt again. From that point forward, ShareBear (and thus <span>any</span> website in Safari) will have the ability to automatically launch this file. The truly problematic part of this agreement is that the file can be changed by anybody with write access to it. For example, the owner of the file could change the entire byte content and file extension after you agree to open it. ShareBear will then download and update the file on the victim&#39;s machine without any user interaction or notification.</span></span></p>



<p><span><span>In essence, the victim has given the attacker permission to plant a <span><a href="https://en.wikipedia.org/wiki/Polymorphic_code#Malicious_code" target="_blank" rel="noreferrer noopener">polymorphic file</a></span> onto their machine <span>and</span> the permission to remotely launch it at any moment. Yikes.</span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>Agreed to view my PNG file yesterday? Well today it&#39;s an executable binary that will be automatically launched whenever I want.</span></span></p>



<p><span><span>Apple fixed this behavior in <span><a href="https://support.apple.com/en-us/HT212869" target="_blank" rel="noreferrer noopener">macOS Monterey 12.0.1</a></span> as a result of my report without issuing a CVE because it is more of a design flaw than a bug per-se.</span></span></p></div><p id="comp-ks8xzp4b" data-testid="richTextElement"><h2><span><span><span>Bonus Bug: Iframe Sandbox Escape</span></span></span></h2></p><p><span>While fuzzing the </span><span>icloud-sharing://</span><span> scheme, I stumbled upon a fun bug unrelated to the UXSS hunt. ShareBear appears to check the path of the URL for &#34;<span>/iclouddrive/*</span>&#34; before performing the behavior outlined above. If the path happens to be &#34;<span>/photos/*</span>&#34; then ShareBear makes a pretty silly mistake. It will tell Safari to open a new tab pointing to the iCloud web app... but it does not verify that the domain name is actually the iCloud web app.</span></p><div id="comp-ksacs4i0" data-testid="richTextElement"><p><span>In normal operation, the user is simply presented with the website, &#34;<a data-auto-recognition="true" href="https://photos.icloud.com" target="_blank">https://photos.icloud.com</a>.&#34; However because this domain name is never validated, we can trick ShareBear into instructing Safari into opening a new tab to any website. </span></p>



<p><span>The implications of this behavior may not be obvious. This doesn&#39;t seem all that different than just calling<span> window.open(&#39;<a data-auto-recognition="true" href="https://example.com" target="_blank">https://example.com</a>&#39;)</span> normally. However there are situations in the web where websites aren&#39;t allowed to do that. One example is if popup blocker is enabled. Another, more devious, example is when your website is inside of a <span><a href="https://html.spec.whatwg.org/multipage/iframe-embed-object.html#attr-iframe-sandbox" target="_blank">sandboxed iframe</a></span>.</span></p>

<p><span><span>​</span></span></p>

<p><span>The </span><span>sandbox</span><span> iframe attribute is typically used when you want to embed untrusted 3rd party content on your website. For example, you may want to display an ad banner on your blog but you don&#39;t want this ad to be able to run JavaScript (who knows, maybe the ad author has a browser 0day).</span></p></div><div id="comp-ksacraca" title=""><div data-testid="linkElement"><wix-image id="img_comp-ksacraca" data-image-info="{&#34;containerId&#34;:&#34;comp-ksacraca&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:1254,&#34;height&#34;:1942,&#34;uri&#34;:&#34;149864_ffad609afc49487ab430f1297d00ae5b~mv2.png&#34;,&#34;name&#34;:&#34;iframe-sandbox.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_ffad609afc49487ab430f1297d00ae5b~mv2.png/v1/fill/w_353,h_547,al_c,usm_0.66_1.00_0.01/iframe-sandbox.png" alt="iframe-sandbox.png"/></wix-image></div></div><div id="comp-ksacegio" data-testid="richTextElement"><p><span>An important rule for sandboxed iframes is that new windows opened from that iframe should inherit the same restrictions as the iframe itself. Otherwise escaping the sandbox would be as trivial as opening a popup.</span></p>

<p><span><span>​</span></span></p>

<p><span>Well this bug tricks Safari into opening a &#39;fresh&#39; new tab without any sandbox restrictions!</span></p></div><div id="comp-ksadskm1"><div data-mesh-id="comp-ksadskm1inlineContent" data-testid="inline-content"><div data-mesh-id="comp-ksadskm1inlineContent-gridContainer" data-testid="mesh-container-content"><div id="comp-ksadsknl" data-testid="richTextElement"><p>&lt;html&gt;    </p>

<p>  &lt;head&gt;      </p>

<p>    &lt;meta http-equiv=&#34;refresh&#34; content=&#34;0;URL=&#39;icloud-sharing://example.com/photos/foo&#39;&#34; /&gt;    </p>

<p>  &lt;/head&gt;     </p>

<p>&lt;/html&gt;</p></div></div></div></div><p><span>Website trapped in a Sandboxed Iframe</span></p><div id="comp-ksadv5p4" data-testid="richTextElement"><p><span><span>So ShareBear neglecting to verify the domain gives us an easy popup-blocker bypass and an iframe sandbox escape. Nice! (fixed in Safari 15.2 without being assigned a CVE) Live demo on BugPoC - <span><a href="https://bugpoc.com/poc#bp-S4HH6YcO" target="_blank" rel="noreferrer noopener"><span>https://bugpoc.com/poc#bp-S4HH6YcO</span></a></span> PoC ID: <span>bp-S4HH6YcO</span>, Password: <span>loVEDsquId01</span>. Note this demo will only work with Safari &lt;15.2 pre macOS Monterey 12.1.</span></span></p>



<p><span><span>Now back to the Camera/UXSS hunt.</span></span></p></div><p id="comp-ks8y5n2x" data-testid="richTextElement"><h2><span><span>Quarantine</span><span> and Gatekeeper</span></span></h2></p><div id="comp-ks8y5n33" data-testid="richTextElement"><p><span>Quick reminder of where we are -</span></p>

<p><span><span>​</span></span></p>

<p><span>Our website can prompt the user to open a shared PNG file. If the user agrees, we can automatically launch this file at any point in the future, even after we alter the file content and extension.</span></p></div><div id="comp-ksaf2lt7" title=""><div data-testid="linkElement"><wix-image id="img_comp-ksaf2lt7" data-image-info="{&#34;containerId&#34;:&#34;comp-ksaf2lt7&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:3836,&#34;height&#34;:972,&#34;uri&#34;:&#34;149864_081d3e5798ca4b7b869b8600c29765a5~mv2.png&#34;,&#34;name&#34;:&#34;staging.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_081d3e5798ca4b7b869b8600c29765a5~mv2.png/v1/fill/w_845,h_214,al_c,usm_0.66_1.00_0.01/staging.png" alt="staging.png"/></wix-image></div></div><p><span><span>The attacker can then </span><span>modify the file on his own machine and ShareBear will take care of updating it on the victim&#39;s machine.</span></span></p><p><span>Attacker&#39;s Machine</span></p><p><span>Victim&#39;s Machine</span></p><p><span>Mutating the Polymorphic File</span></p><p><span>The attacker&#39;s website can then automatically launch this newly-updated file using the same </span><span>icloud-sharing://</span><span> URL that he used to display the original prompt.</span></p><div id="comp-ksaf3l04" title=""><div data-testid="linkElement"><wix-image id="img_comp-ksaf3l04" data-image-info="{&#34;containerId&#34;:&#34;comp-ksaf3l04&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:2470,&#34;height&#34;:970,&#34;uri&#34;:&#34;149864_82abb8f54cb8470f84190f447fc51e6c~mv2.png&#34;,&#34;name&#34;:&#34;launching.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_82abb8f54cb8470f84190f447fc51e6c~mv2.png/v1/fill/w_578,h_227,al_c,usm_0.66_1.00_0.01/launching.png" alt="launching.png"/></wix-image></div></div><p><span>This seems very close to our goal of forcefully downloading &amp; opening an evil webarchive file. We can just swap out the content of puppy.png for a webarchive file and rename it &#34;evil.webarchive&#34;, right? Unfortunately for us, pesky </span><span><a href="https://support.apple.com/en-us/HT202491" target="_blank">macOS Gatekeeper</a></span><span> won&#39;t allow that.</span></p><div id="comp-ksafdtf9" title=""><div data-testid="linkElement"><wix-image id="img_comp-ksafdtf9" data-image-info="{&#34;containerId&#34;:&#34;comp-ksafdtf9&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:550,&#34;height&#34;:616,&#34;uri&#34;:&#34;149864_8208d8b8b5334544b92f5db939257238~mv2.png&#34;,&#34;name&#34;:&#34;Screen Shot 2021-08-12 at 1.19.38 PM.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_8208d8b8b5334544b92f5db939257238~mv2.png/v1/fill/w_307,h_344,al_c,usm_0.66_1.00_0.01/Screen%20Shot%202021-08-12%20at%201_19_38%20PM.png" alt="Screen Shot 2021-08-12 at 1.19.38 PM.png"/></wix-image></div></div><p><span>Gatekeeper Launch Prevention</span></p><div id="comp-ksaf9372" data-testid="richTextElement"><p><span><span>It appears that ShareBear correctly gives downloaded files the &#39;</span><span><a href="https://en.wikipedia.org/wiki/Gatekeeper_(macOS)#Quarantine" target="_blank" rel="noreferrer noopener"><span>com.apple.quarantine</span></a></span><span>&#39; attribute and according to <span><a href="https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/EnablingAppSandbox.html#//apple_ref/doc/uid/TP40011195-CH4-SW5" target="_blank" rel="noreferrer noopener">Apple</a></span>, &#34;<span>Gatekeeper prevents quarantined executable files and other similar files (shell scripts, <span>web archives</span>, and so on) from opening or executing</span>.&#34; For a deep dive into how macOS treats this attribute, as well as how Gatekeeper performs code signing, check out <span><a href="https://objective-see.com/blog/blog_0x64.html" target="_blank" rel="noreferrer noopener">this</a></span> great write-up.</span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>For our purposes, there are two big limitations introduced by this OS protection -</span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>1) We can&#39;t run our own apps  </span></span></p>

<p><span><span>2) We can&#39;t directly open webarchive files</span></span></p></div><p><span><span>Side Bar - while we can&#39;t run our own apps, launching existing, approved, apps is trivial. Just use a fileloc to point to a local app (this technique is quite </span><span><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1029375" target="_blank" rel="noreferrer noopener">common</a></span><span>). This attack is sometimes referred to as &#34;<span><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1040" target="_blank" rel="noreferrer noopener">Arbitrary File Execution</a></span>&#34; and is often <span><a href="https://9to5mac.com/2021/09/22/mac-shortcut-bug/" target="_blank" rel="noreferrer noopener">misunderstood</a></span> because it looks so scary.</span></span></p><div id="comp-ksah995l"><div data-mesh-id="comp-ksah995linlineContent" data-testid="inline-content"><div data-mesh-id="comp-ksah995linlineContent-gridContainer" data-testid="mesh-container-content"><div id="comp-ksah9970" data-testid="richTextElement"><p>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</p>

<p>&lt;!DOCTYPE plist PUBLIC &#34;-//Apple//DTD PLIST 1.0//EN&#34; &#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&#34;&gt;</p>

<p>&lt;plist version=&#34;1.0&#34;&gt;</p>

<p>&lt;dict&gt;</p>

<p>    &lt;key&gt;URL&lt;/key&gt;</p>

<p>    &lt;string&gt;file:///System/Applications/Calculator.app&lt;/string&gt;</p>

<p>&lt;/dict&gt;</p>

<p>&lt;/plist&gt;</p></div></div></div></div><p><span>fileloc pointing to macOS Calculator</span></p><p><span>Using the icloud-sharing:// scheme to launch the fileloc</span></p><p><span>While this attack might look scary, launching an already-approved app doesn&#39;t have much impact. Let&#39;s focus on opening webarchives.</span></p><p id="comp-ks8y8dqv" data-testid="richTextElement"><h2><span><span><span>Shortcuts</span></span></span></h2></p><div id="comp-ks8y8dr2" data-testid="richTextElement"><p><span>The above technique to open local apps is reminiscent of an old-school </span><span><a href="https://capec.mitre.org/data/definitions/132.html" target="_blank">symlink attack</a></span><span>. It basically just uses a &#34;<span><a href="https://en.wikipedia.org/wiki/Shortcut_(computing)" target="_blank">shortcut</a></span>&#34; to trick software into opening something it doesn&#39;t expect.</span></p>

<p><span><span>​</span></span></p>

<p><span>Lots of different operating systems and applications have reinvented the wheel over the years when it comes to shortcuts. Nowadays, the term &#34;shortcut&#34; could be referring to a Unix symlink, a macOS alias, a Window&#39;s linkfile, a Safari webloc, an Edge bookmark, etc. </span></p>

<p><span><span>​</span></span></p>

<p><span>I was hopeful that I could use this technique to bypass Gatekeeper and open a webarchive file. This idea seemed promising to me because the actual application I want to open is Safari (an existing, approved, application). Gatekeeper doesn&#39;t have a problem with me launching Safari, it just gets upset when I attempt to open any file ending in &#34;</span><span>.webarchive</span><span>&#34;.</span></p>

<p><span><span>​</span></span></p>

<p><span>So I needed to find a shortcut filetype that launches Safari, then tells Safari to open a different file. After some trial and error, I found just that - the ancient <span><a href="http://www.lyberty.com/encyc/articles/tech/dot_url_format_-_an_unofficial_guide.html" target="_blank">Windows URL File</a></span>!</span></p></div><div id="comp-ksaib69s"><div data-mesh-id="comp-ksaib69sinlineContent" data-testid="inline-content"><div data-mesh-id="comp-ksaib69sinlineContent-gridContainer" data-testid="mesh-container-content"><div id="comp-ksaib6b2" data-testid="richTextElement"><p>[{000214A0-0000-0000-C000-000000000046}]</p>

<p>Prop3=19,2</p>

<p>[InternetShortcut]</p>

<p>URL=file:///path/to/webarchive</p>

<p>IDList=</p></div></div></div></div><p><span>evil.url file pointing to a local webarchive</span></p><div id="comp-ksaidmxe" data-testid="richTextElement"><p><span>Launching <span>evil.url</span> successfully opens Safari and instructs it to load the webarchive file without asking Gatekeeper for permission! (CVE-2021-30861) There was only one small hiccup - I need to know the full path to the webarchive file. Assuming the webarchive gets downloaded via ShareBear, it will live in </span><span>/Users/&lt;user&gt;/</span><span>Library/Mobile Documents/com~apple~CloudDocs</span>, <span>which includes the victim&#39;s username (not a very scalable attack).</span></p>

<p><span><span>​</span></span></p>

<p><span>Luckily, there is a neat trick to circumvent this requirement - we can mount the webarchive file into the known <span>/Volumes/</span> directory using a DMG file.</span></p></div><p><span>Using the icloud-sharing:// scheme to mount the dmg</span></p><p><span>Now we know exactly where the webarchive file resides. Which means the below <span>evil.url</span> file will work every time.</span></p><div id="comp-ksaizdie"><div data-mesh-id="comp-ksaizdieinlineContent" data-testid="inline-content"><div data-mesh-id="comp-ksaizdieinlineContent-gridContainer" data-testid="mesh-container-content"><div id="comp-ksaizdkf" data-testid="richTextElement"><p>[{000214A0-0000-0000-C000-000000000046}]</p>

<p>Prop3=19,2</p>

<p>[InternetShortcut]</p>

<p>URL=file:///Volumes/folder/evil.webarchive</p>

<p>IDList=</p></div></div></div></div><p><span>evil.url file pointing to a known-location local webarchive</span></p><p><span>Using the icloud-sharing:// scheme to launch <span>evil.url</span> to open <span>evil.webarchive</span></span></p><div id="comp-ksaj5v7t" data-testid="richTextElement"><p><span>And just like that, we are executing JavaScript code anywhere we want. The above screen recording injects &#39;<span>alert(origin)</span>&#39; in <span><a data-auto-recognition="true" href="https://google.com" target="_blank">https://google.com</a></span>.</span></p>

<p><span><span>​</span></span></p>

<p><span>Let&#39;s tie this together into one final attack.</span></p></div><p id="comp-ks8yc4rf" data-testid="richTextElement"><h2><span><span><span>Full Chain</span></span></span></h2></p><p><span>Using ShareBear to download and open a webarchive file for us can be broken down into 3 steps:</span></p><p><span>1) Trick the victim into giving us permission to plant the polymorphic file</span></p><div id="comp-ksajji2q" title=""><div data-testid="linkElement"><wix-image id="img_comp-ksajji2q" data-image-info="{&#34;containerId&#34;:&#34;comp-ksajji2q&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:3836,&#34;height&#34;:972,&#34;uri&#34;:&#34;149864_081d3e5798ca4b7b869b8600c29765a5~mv2.png&#34;,&#34;name&#34;:&#34;staging.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_081d3e5798ca4b7b869b8600c29765a5~mv2.png/v1/fill/w_770,h_195,al_c,usm_0.66_1.00_0.01/staging.png" alt="staging.png"/></wix-image></div></div><p><span>2) Turn <span>puppies.png</span> into <span>evil.dmg</span> and launch it</span></p><div id="comp-ksajkp1n" title=""><div data-testid="linkElement"><wix-image id="img_comp-ksajkp1n" data-image-info="{&#34;containerId&#34;:&#34;comp-ksajkp1n&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:2470,&#34;height&#34;:970,&#34;uri&#34;:&#34;149864_e86de3de8a3d49a1986c2ab804f02b0c~mv2.png&#34;,&#34;name&#34;:&#34;mount.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_e86de3de8a3d49a1986c2ab804f02b0c~mv2.png/v1/fill/w_516,h_203,al_c,usm_0.66_1.00_0.01/mount.png" alt="mount.png"/></wix-image></div></div><p><span>3) Turn <span>evil.dmg</span> into <span>evil.url</span> and launch it</span></p><div id="comp-ksajqibz" title=""><div data-testid="linkElement"><wix-image id="img_comp-ksajqibz" data-image-info="{&#34;containerId&#34;:&#34;comp-ksajqibz&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:2498,&#34;height&#34;:972,&#34;uri&#34;:&#34;149864_e86715d433614587b1a42c8352c18735~mv2.png&#34;,&#34;name&#34;:&#34;urlfile.png&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_e86715d433614587b1a42c8352c18735~mv2.png/v1/fill/w_521,h_203,al_c,usm_0.66_1.00_0.01/urlfile.png" alt="urlfile.png"/></wix-image></div></div><p><span>Of course turning &#34;File A&#34; into three different payloads will require some server-side coordination. Another (less fun) way to pull-off this attack is to have the victim agree to open a shared </span><span>folder </span><span>that already has all the files ready-to-go.</span></p><p><span>Screen Recording of UXSS via viewing an iCloud Shared Folder</span></p><div id="comp-ksaoo15s" data-testid="richTextElement"><p><span><span>In the above screen recording, the victim agrees to view a folder that contains some PNG images. This folder also has two hidden files - <span>.evil.dmg</span> &amp; <span>.evil.url.</span></span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>The website uses the </span><span>icloud-sharing://</span><span> URL Scheme to automatically launch both of the hidden files to successfully bypass Gatekeeper and open a webarchive file. Note that no additional prompts are displayed to the victim after he agrees to view the shared folder. The example webarchive file above injects code into <span><a data-auto-recognition="true" href="https://www.icloud.com" target="_blank">https://www.icloud.com</a></span> to exfiltrate the victim&#39;s iOS camera roll. </span></span></p>



<p><span><span>Of course this is just an example, this UXSS attack allows the attacker to inject <span>arbitrary</span> code into <span>arbitrary</span> origins. It would be just as easy to inject JavaScript code to turn on the webcam when hijacking a trusted video chat website like <span><a data-auto-recognition="true" href="https://zoom.us" target="_blank">https://zoom.us</a></span> or <span><a data-auto-recognition="true" href="https://facetime.apple.com" target="_blank">https://facetime.apple.com</a></span>. Mission accomplished. </span></span></p></div><div id="comp-kvh340a6" title=""><div data-testid="linkElement"><wix-image id="img_comp-kvh340a6" data-image-info="{&#34;containerId&#34;:&#34;comp-kvh340a6&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;imageData&#34;:{&#34;width&#34;:2880,&#34;height&#34;:1800,&#34;uri&#34;:&#34;149864_9ee474cf32a541a6b34c80ea501d9e7b~mv2.jpeg&#34;,&#34;name&#34;:&#34;Screen Shot 2021-11-01 at 9.34.38 AM.jpeg&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-bg-effect-name="" data-is-svg="false" data-is-svg-mask="false" data-image-zoomed="" data-has-ssr-src="true"><img src="https://static.wixstatic.com/media/149864_9ee474cf32a541a6b34c80ea501d9e7b~mv2.jpeg/v1/fill/w_715,h_447,al_c,q_80,usm_0.66_1.00_0.01/Screen%20Shot%202021-11-01%20at%209_34_38%20AM.jpeg" alt="Ryan Pickren hacked Apple Webcam"/></wix-image></div></div><p><span>Screenshot of UXSS hijacking Zoom Website to turn on webcam</span></p><p id="comp-ksalyh3v" data-testid="richTextElement"><h2><span><span><span>Remediation</span></span></span></h2></p><div id="comp-ksalyh49" data-testid="richTextElement"><p><span><span>So how did Apple fix these issues?</span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>The first fix was to have ShareBear just <span>reveal</span> files instead of <span>launch</span> them (fixed in <span><a href="https://support.apple.com/en-us/HT212869" target="_blank" rel="noreferrer noopener">macOS Monterey 12.0.1</a></span> without being assigned a CVE). </span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>The second fix was to prevent WebKit from opening any quarantined files (fixed in <span><a href="https://support.apple.com/en-us/HT212816" target="_blank" rel="noreferrer noopener">Safari 15</a></span> as CVE-2021-30861; see fix implementation <span><a href="https://trac.webkit.org/changeset/281056/webkit" target="_blank" rel="noreferrer noopener">here</a></span>).</span></span></p></div><p id="comp-ksiz157j" data-testid="richTextElement"><h2><span><span><span>Bonus Material (#1)</span></span></span></h2></p><div id="comp-ksiz157z" data-testid="richTextElement"><p><span>Before I discovered the <span>evil.url</span> trick, I actually found a different way to trick Launch Services into (indirectly) opening a webarchive file. I found this bug on the latest public release of Safari (v14.1.1). A few days after reporting this bug to Apple, they informed me that the beta Safari v15 was not vulnerable. It appeared that an unrelated code refactor made v15 impervious. For completeness sake, I will quickly go over that bug anyway- </span></p>

<p><span><span>​</span></span></p>

<p><span>The obvious way to open Safari via Launch Services is with a local html file. Once opened, this page will have the file:// URI scheme. From there, JavaScript is allowed to navigate to other file:// URIs.</span></p></div><div id="comp-ksiz9kys"><div data-mesh-id="comp-ksiz9kysinlineContent" data-testid="inline-content"><div data-mesh-id="comp-ksiz9kysinlineContent-gridContainer" data-testid="mesh-container-content"><div id="comp-ksiz9l0g" data-testid="richTextElement"><p>&lt;script&gt;</p>

<p>location.href = &#39;file:///path/to/another/local/file&#39;; // ok if location.protocol == &#39;file://&#39;</p>

<p>&lt;/script&gt;</p></div></div></div></div><p><span>local HTML file navigating to another local file</span></p><p><span>So what happens if the file we are navigating to is a webarchive? Well, Safari just hangs.</span></p><p><span>Screen Recording of Safari refusing to render a webarchive</span></p><div id="comp-ksizlqkh" data-testid="richTextElement"><p><span>This annoying hang occurred for every type of page navigation I could think of (anchor href, iframe src, meta redirect, etc.) when the destination file was a webarchive. </span></p>

<p><span><span>​</span></span></p>

<p><span>Then I found this bug:</span></p></div><div id="comp-ksiznpaw"><div data-mesh-id="comp-ksiznpawinlineContent" data-testid="inline-content"><div data-mesh-id="comp-ksiznpawinlineContent-gridContainer" data-testid="mesh-container-content"><div id="comp-ksiznpd0" data-testid="richTextElement"><p>&lt;script&gt;</p>

<p>location.href = &#39;file://fake.com/path/to/evil.webarchive&#39;; </p>

<p>&lt;/script&gt;</p></div></div></div></div><p><span>local HTML file navigating to a local webarchive file</span></p><div id="comp-ksizqczu" data-testid="richTextElement"><p><span><span>Safari forgets to perform the webarchive check when there is a host value in a file:// URL! Funny enough, this bug appears to have been introduced when Apple fixed my old file:// bug (CVE-2020-3885)</span><span>.</span></span></p>



<p><span><span>When Apple informed me that Safari Beta v15 wasn&#39;t vulnerable, I went back to the drawing board and found the <span>evil.url</span> hack.</span></span></p></div><p id="comp-ksizz3zv" data-testid="richTextElement"><h2><span><span><span>Bonus Material (#2)</span></span></span></h2></p><div id="comp-ksizz40c" data-testid="richTextElement"><p><span><span>There was still one thing that bugged me after I finished the UXSS chain.... it can&#39;t be used to steal local files. Sure, UXSS can be used to indirectly steal files by injecting code into <a data-auto-recognition="true" href="https://dropbox.com" target="_blank">https://dropbox.com</a> or <a data-auto-recognition="true" href="https://drive.google.com" target="_blank">https://drive.google.com</a>, but files exclusively on the victim&#39;s hard drive are out of reach. </span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>The excellent </span><span><a href="https://i.blackhat.com/eu-20/Thursday/eu-20-Zhou-Cross-Site-Escape-Pwning-MacOS-Safari-Sandbox-The-Unusual-Way.pdf" target="_blank" rel="noreferrer noopener">Blackhat Presentation</a></span><span> I referenced earlier inspired me to look for other System applications that could run my JavaScript in a more privileged context than Safari. After digging around for a while, I stumbled upon an obscure filetype recognized my <span><a href="https://en.wikipedia.org/wiki/AppleScript_Editor" target="_blank" rel="noreferrer noopener">macOS Script Editor</a></span> called &#34;<span><a href="https://www.oreilly.com/library/view/applescript-the-definitive/0596102119/ch03s08.html" target="_blank" rel="noreferrer noopener">Scripting Additions</a></span>&#34; (.osax). These files (or rather &#39;<span><a href="https://en.wikipedia.org/wiki/Bundle_(macOS)" target="_blank" rel="noreferrer noopener">bundles</a></span>&#39;) contained a nested xml-based file called a &#34;Dictionary Document&#34; (.sdef). This dictionary document was used to display human-readable, developer-defined, terms used by an AppleScript application. Phew.</span></span></p>

<p><span><span><span>​</span></span></span></p>

<p><span><span>The important discovery was that these xml-based files are allowed to contain HTML. As it turns out, the HTML renderer also has a JavaScript engine and this engine does not enforce SOP! (fixed in macOS Big Sur 11.6.2 as <span><a href="https://support.apple.com/en-us/HT212979" target="_blank" rel="noreferrer noopener">CVE-2021-30975</a></span></span></span><span><span>) Which means stealing /etc/passwd is easy-</span></span></p></div><div id="comp-ksj1brrf"><div data-mesh-id="comp-ksj1brrfinlineContent" data-testid="inline-content"><div data-mesh-id="comp-ksj1brrfinlineContent-gridContainer" data-testid="mesh-container-content"><div id="comp-ksj1brtf" data-testid="richTextElement"><p>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</p>

<p>&lt;!DOCTYPE dictionary SYSTEM &#34;&#34;&gt;</p>

<p>&lt;dictionary&gt;</p>

<p>    &lt;suite name=&#34;&#34; code=&#34;&#34;&gt;</p>

<p>        &lt;command name=&#34;&#34; code=&#34;&#34; description=&#34;&#34;&gt;</p>

<p>        &lt;/command&gt;</p>

<p>            &lt;documentation&gt;</p>

<p>            &lt;html&gt;</p>

<p>                &lt;![CDATA[</p>

<p>                    &lt;script&gt;</p>



<p>                        fetch(&#39;file:///etc/passwd&#39;).then(x=&gt;{x.text().then(y=&gt;{document.write(y);})})</p>



<p>                    &lt;/script&gt;</p>

<p>                ]]&gt;</p>

<p>            &lt;/html&gt;</p>

<p>            &lt;/documentation&gt;</p>

<p>    &lt;/suite&gt;</p>

<p>&lt;/dictionary&gt;</p></div></div></div></div><p><span>evil.sdef displaying the content of /etc/passwd</span></p><p><span>Luckily for us, Gatekeeper does not mind us opening Scripting Addition files. So we just take </span><span>evil.sdef</span><span>, package it in </span><span>evil.osax</span><span>, and send it to the victim via ShareBear. Then our <span>icloud-sharing://</span> URI can automatically launch it in Script Editor.</span></p><p><span>Screen Recording of ShareBear opening evil.osax to steal /etc/passwd</span></p><p><span><span>Nice, so now in addition to UXSS, this hack can also circumvent sandbox restrictions and steal local files!</span></span></p><p id="comp-ks8yfmbb" data-testid="richTextElement"><h2><span><span><span>Conclusion</span></span></span></h2></p><div id="comp-ks8yfmbj" data-testid="richTextElement"><p><span>This project was an interesting exploration of how a design flaw in one application can enable a variety of other, unrelated, bugs to become more dangerous. It was also great example of how even with macOS Gatekeeper enabled, an attacker can still achieve a lot of mischief by tricking approved apps into doing malicious things.  </span></p>

<p><span><span>​</span></span></p>

<p><span><span>I submitted these bugs to Apple in mid July 2021. They patched all issues in early 2022 and rewarded me </span></span><span><span>$100,500</span></span><span><span> as a bounty.</span></span></p></div></div></div></div>
  </body>
</html>
