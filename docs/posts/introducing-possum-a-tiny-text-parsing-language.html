<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mulias.github.io/blog/possum-intro/">Original</a>
    <h1>Introducing Possum, a Tiny Text Parsing Language</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p><a href="https://github.com/mulias/possum_parser_language">Possum</a> is a domain-specific language designed for parsing text, inspired by classic Unix utilities like <a href="https://en.wikipedia.org/wiki/AWK">AWK</a> and <a href="https://en.wikipedia.org/wiki/Sed">sed</a>. You can use Possum for tasks ranging from single-line scripts for data extraction to quickly prototyping a new programming language syntax. The language aims to make parsing friendly and fun, and uses a minimal feature set to write declarative programs that are both compact and readable.</p>
<p>This guide teaches the core features of Possum using interactive examples, and should give you enough context to handle a wide range of parsing situations. If you&#39;re checking out Possum for the first time and want to learn more about the language at a higher level, I&#39;m planning on writing separate articles covering the design philosophy behind Possum and examples of larger Possum programs.</p>
<h4 id="warning-work-in-progress-warning">‚ö†Ô∏è  Work In Progress ‚ö†Ô∏è</h4>
<p>Possum is still in development. Most of the core functionality is in place, but there are a number of rough edges. The one you&#39;ll likely notice is that error messages are mostly placeholders, and will be pretty unhelpful. Rest assured we&#39;ve got a team of marsupials working around the clock to correct this issue.</p>
<h2 id="the-basics">The Basics</h2>
<p>A Possum program is made up of parsers, functions that define both what text inputs are valid and how to transform valid inputs into structured data. The Possum runtime takes a program and an input string and either successfully parses the input into a JSON encoded value, or fails if the input was malformed.</p>
<p>This section covers parsers that match against specific strings or numbers in the input text, and then returns the matched value unchanged. Later on we&#39;ll introduce ways to compose these basic parsers together to make compound parsers that can validate more complex inputs and produce any JSON value as output.</p>
<h3 id="literal-parsers">Literal Parsers</h3>
<p>String literals are parsers which match the exact text of the string and return the string value on success.</p>
<p>Here&#39;s our first interactive example! Typically Possum is run from the command line, but in the browser the <code>Input</code> field is the text we&#39;re going to parse, while the <code>Parser</code> field is the Possum program. Try running the program once to see it succeed, and then change either the input or parser to experiment with the string matching behavior.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>String literals can use double or single quotes. JSON strings are encoded with double quotes, so the program output will always use double quotes.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Number literals are parsers which match the exact digits of a number and return the number value on success. Possum supports the same number format as JSON, which includes positive and negative numbers, integers, and numbers with fraction and/or exponent parts.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<h3 id="range-parsers">Range Parsers</h3>
<p>Character ranges are parsers that match a single Unicode code point that falls within an inclusive range.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Code points are, broadly speaking, how Unicode defines units of text. This means we can use character range parsers for more than just ASCII characters. The emoji &#34;üòÑ&#34; is code point <code>U+1F604</code> and &#34;ü§†&#34; is <code>U+1F920</code>, so &#34;üòÖ&#34; (<code>U+1F605</code>) is in the range. It&#39;s worth noting that some units of text are made up of multiple code points stuck together, so character ranges won&#39;t work for absolutely everything that looks like a single character. This limitation shouldn&#39;t be an issue in the majority of parsing use cases.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Integer ranges use the same <code>..</code> syntax, but match all integers that fall within an inclusive range.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<h3 id="greed-and-failure">Greed and Failure</h3>
<p>Parsers always start matching from the beginning of the input, do not skip over any input, and return the longest possible match.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>After parsing, any extra input is thrown out. This means that the empty string <code>&#34;&#34;</code> is a parser that always succeeds, no matter the input.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>If the parser fails to find a match, Possum returns an error.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<h2 id="the-standard-library">The Standard Library</h2>
<p>Possum has a standard library with parsers covering many common parsing situations. We&#39;ll be using parsers from the standard library in our examples, so here&#39;s a quick overview.</p>
<h3 id="parsing-strings">Parsing Strings</h3>
<p>Use <code>char</code> to parse exactly one character, returning the value as a string.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Parse and return an upper- or lower-case letter from the English alphabet with <code>alpha</code>. To parse multiple letters try changing <code>alpha</code> to <code>alphas</code>.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Parse and return one or more alphanumeric characters with <code>word</code>. This parser also accepts <code>_</code> and <code>-</code>.
</p><form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>

<p>Parse and return one or more non-whitespace characters with <code>token</code>.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Some parsers are parametrized by other parsers. The parser <code>many(p)</code> tries to run the parser <code>p</code> repeatedly until it no longer succeeds, and returns the concatenation of all of the parsed values.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<h3 id="parsing-whitespace">Parsing Whitespace</h3>
<p>The <code>space</code> parser matches a single blank non-line-breaking character. This usually means an ASCII space or tab. By convention <code>spaces</code> will instead parse multiple blank characters at once.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>The <code>newline</code> parser matches and returns a single line-breaking character. To parse multiple line breaks use <code>newlines</code>. These parsers are aliased to the abbreviations <code>nl</code> and <code>nls</code>, respectively.</p>
<form action="">
  <label>
    <span>Input</span>
    
  </label>

  <label>
    <span>Parser</span>
    
    
  </label>

  <label></label>
</form>
<p>To parse all contiguous whitespace use <code>whitespace</code> or <code>ws</code>.</p>
<form action="">
  <label>
    <span>Input</span>
    
  </label>

  <label>
    <span>Parser</span>
    
    
  </label>

  <label></label>
</form>
<h3 id="parsing-numbers">Parsing Numbers</h3>
<p>The <code>digit</code> parser matches a single Arabic numeral between <code>0</code> and <code>9</code>, and returns the numeral as an integer.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Parse any valid JSON integer with <code>integer</code>, or the alias <code>int</code>.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Parse any valid JSON number with <code>number</code> or <code>num</code>. This includes numbers with fraction and/or exponent parts.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<h3 id="parsing-constants">Parsing Constants</h3>
<p>The parsers <code>true(t)</code>, <code>false(f)</code>, <code>bool(t, f)</code>, and <code>null(n)</code> return the appropriate constant values when the provided parser matches.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<h3 id="parsing-collections">Parsing Collections</h3>
<p>Finally, <code>array(elem)</code> and <code>object(key, value)</code> return ordered list collections (arrays) and key/value pair collections (objects).</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Collections frequently use separator characters between elements. You can use <code>array_sep(elem, sep)</code> and <code>object_sep(key, pair_sep, value, sep)</code> to handle these cases, parsing the separators but excluding them from the result.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <label>
    <span>Input</span>
    
  </label>

  <label>
    <span>Parser</span>
    
    
  </label>

  <label></label>
</form>
<h2 id="composing-parsers">Composing Parsers</h2>
<p>We&#39;ve now covered both basic parsers for strings and numbers, and some of the high-level parser functions from Possum&#39;s standard library. The last big feature we need is the ability to stick parsers together in order to create larger parsers for more complex inputs. In Possum we do this with <em>infix operators</em>, symbols that go between two parsers to change how and when the parsers get ran on the input.</p>
<h3 id="or">Or</h3>
<p>The &#34;or&#34; operator <code>p1 | p2</code> tries to match the parser <code>p1</code> and then if that fails tries to match <code>p2</code> instead.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>If both parsers fail then the compound parser fails.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<h3 id="take-right">Take Right</h3>
<p>The &#34;take right&#34; operator <code>p1 &gt; p2</code> matches <code>p1</code> and then matches and returns <code>p2</code>.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>If either parser fails then the compound parser fails.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<h3 id="take-left">Take Left</h3>
<p>Similarly the &#34;take left&#34; operator <code>p1 &lt; p2</code> matches <code>p1</code>, keeps the result, then matches <code>p2</code>. If both succeed then the value parsed by <code>p1</code> is returned.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>If either parser fails then the compound parser fails.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<h3 id="merge">Merge</h3>
<p>The &#34;merge&#34; operator <code>p1 + p2</code> matches <code>p1</code> and then <code>p2</code> and combines the two values.</p>
<p>Merging will concatenate strings:</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Concatenate arrays:</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Combine objects, adding fields from the right-side object to the left-side object, possibly replacing existing values:</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Sum numbers:</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>And apply logical &#34;or&#34; to booleans:</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>If the two parsed values have different types then the operation will throw a runtime error.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>The one exception to this rule is the value <code>null</code>, which can be merged with any other value, acting as the identity value for that data type:</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<h3 id="return">Return</h3>
<p>The &#34;return&#34; operator <code>p $ V</code> matches <code>p</code>, and then on success returns the value <code>V</code>.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>The value on the right-side of <code>$</code> can be any valid JSON data, including arrays, objects, true, false, and null.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<h3 id="destructure">Destructure</h3>
<p>The &#34;destructure&#34; operator <code>p -&gt; P</code> matches <code>p</code>, and then compares the result to the pattern <code>P</code>. If the parsed value has the same structure as the pattern then the parser matches and the whole value is returned. The pattern can be any value, including arrays and objects.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>If the parsed value does not match the pattern then the parser fails.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Patterns can also contain <code>UpperCamelCase</code> variables, which match any value and assign the value to the variable. Variables can be used later in the same parser.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<h3 id="sequence">Sequence</h3>
<p>The &#34;sequence&#34; operator <code>p1 &amp; p2</code> matches <code>p1</code> and then matches and returns <code>p2</code>. This behavior is similar to <code>&gt;</code>, but <code>&amp;</code> has a more general precedence, grouping parts of a parser together in a similar way to parentheses. Because of this <code>&gt;</code> is best suited for parsing and then ignoring a value within a parsing step, while <code>&amp;</code> is more useful in stringing together a list of steps. Instead of grouping like this:</p>
<form action="">
  <label>
    <span>Input</span>
    
  </label>

  <label>
    <span>Parser</span>
    
    
  </label>

  <label></label>
</form>
<p>A sequence of parsers can be written like this:</p>
<form action="">
  <label>
    <span>Input</span>
    
  </label>

  <label>
    <span>Parser</span>
    
    
  </label>

  <label></label>
</form>
<h3 id="putting-it-all-together">Putting it all together</h3>
<p>Using the return, destructure, and sequence operators together we can implement a very common pattern in Possum ‚Äî matching a sequence of parsers, destructuring to assign values to variables, and then building a return value using the variables.</p>
<form action="">
  <label>
    <span>Input</span>
    
  </label>

  <label>
    <span>Parser</span>
    
    
  </label>

  <label></label>
</form>
<h2 id="defining-parsers">Defining Parsers</h2>
<p>A Possum program must have one <em>main parser</em>, and can optionally declare any number of <em>named parsers</em>. Parsers must be separated either by newlines or semicolons. Named parsers are declared with the syntax <code>name = parser</code>. At runtime Possum executes the main parser, which can reference named parsers declared in the program in the same way we reference named parsers from the standard library.</p>
<form action="">
  <label>
    <span>Input</span>
    
  </label>

  <label>
    <span>Parser</span>
    
    
  </label>

  <label></label>
</form>
<p>Named Parsers can be parameterized with both parsers and values. Note that parser params are always <code>snake_case</code> while value params are always <code>UpperCamelCase</code>.</p>
<form action="">
  <label>
    <span>Input</span>
    
  </label>

  <label>
    <span>Parser</span>
    
    
  </label>

  <label></label>
</form>
<p>Named parsers can be recursive and referenced before they are declared. The main parser can come before, after, or in between named parser declarations.</p>
<form action="">
  <label>
    <span>Input</span>
    
  </label>

  <label>
    <span>Parser</span>
    
    
  </label>

  <label></label>
</form>
<h2 id="a-few-more-standard-library-parsers">A Few More Standard Library Parsers</h2>
<p>At this point you should be well equipped to <a href="https://github.com/mulias/possum_parser_language/blob/main/docs/stdlib.md">browse the standard library</a>, but here are a few more parsers that you might find particularly useful.</p>
<p>The parser <code>maybe(p)</code> runs <code>p</code> and either returns the parsed value if <code>p</code> succeeds, or returns <code>null</code> if <code>p</code> fails. This means <code>maybe(p)</code> will never fail, and can be merged with any other value in a concatenated output.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Similarly, <code>skip(p)</code> runs <code>p</code>, but on success always returns <code>null</code>. Since <code>null</code> can merge with any value this allows parts of the input to be ignored in a concatenated output.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Once you&#39;re happy with a parser, you may want to ensure that it always parses the whole input by using <code>end_of_input</code> or <code>end</code> to specify that the end of the input has been reached.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>If <code>end</code> finds unparsed input then it fails.
</p><form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>

<p>Alternatively, <code>input(p)</code> wraps a parser to both strip surrounding whitespace and make sure the whole input is parsed.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Use <code>scan(p)</code> to skip characters until the provided parser matches.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Similar to how <code>array_sep(elem, sep)</code> handles one-dimensional data with separators, <code>table_sep(array, sep, row_sep)</code> handles two dimensional data with both column and row separators.</p>
<form action="">
  <label>
    <span>Input</span>
    
  </label>

  <label>
    <span>Parser</span>
    
    
  </label>

  <label></label>
</form>
<h2 id="conclusion">~~~(##)&#39;&gt; Conclusion</h2>
<p>We&#39;ve made it ‚Äî that&#39;s just about everything you need to know to be productive with Possum. In the very first example we matched and returned a string input exactly, but with just a few changes we can extend that parser to handle any number of variations or requirements.</p>
<form action="">
  <p><label>
      <span>Input</span>
      
    </label>

    <label>
      <span>Parser</span>
      
      
    </label>
  </p>

  <label></label>
</form>
<p>Possum aims to make parsing friendly and fun by making it easy to compose complex parsers out of simple component parts. These kinds of parsers are frequently called <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinators</a>. Many modern languages have parser combinator libraries, but they&#39;re all implemented slightly differently from one another. Part of what Possum offers is a single set of powerful parsing utilities that can effectivly be integrated with any other programming language via JSON. On top of that, Possum avoids much of the complexity that comes from trying to integrate parser combinators into an existing language by focusing solely on parsing.</p>
<p>To install Possum check out the <a href="https://github.com/mulias/possum_parser_language/">Github repo</a>. To learn more about using Possum read through the <a href="https://github.com/mulias/possum_parser_language/blob/main/docs/stdlib.md">standard library</a> or some <a href="https://github.com/mulias/possum_parser_language/tree/main/examples">larger examples</a>. Good luck and happy parsing!</p>

  </div></div>
  </body>
</html>
