<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/a-foolish-consistency/">Original</a>
    <h1>A Foolish Consistency: Consul at Fly.io</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="http://harihareswara.net/public/images/thomas.jpg" alt="Thomas Ptacek" srcset=""/> <dl> <dt>Name</dt> <dd> Thomas Ptacek </dd> <dt>Twitter</dt> <dd> <a href="https://twitter.com/tqbf" target="_blank"> @tqbf </a> </dd> </dl> </dd> </dl> <section> <img src="http://harihareswara.net/blog/2022-03-29/default-books.jpg" alt=""/> <p> <a href="http://Fly.io">Fly.io</a> runs applications by transmogrifying Docker containers into Firecracker micro-VMs running on our hardware around the world, connected with WireGuard to a global Anycast network. Yours could be one of them! <a href="https://fly.io/docs/speedrun/">Check us out</a>: from a working container, your app can be running worldwide in minutes.</p><p>We set the scene, as usual, with sandwiches. Dig if you will the picture: a global Sandwich Bracket application, ascertaining once and for all the <a href="https://jpgraziano.com/">greatest sandwich on the planet</a>.</p> <p><a href="http://Fly.io">Fly.io</a> wants our app, <code>sandwich-bracket</code>, deployed close to users around the world. Chicago users vote for <a href="https://www.tripadvisor.com/Restaurant_Review-g35956-d502500-Reviews-Johnnie_s_Beef-Elmwood_Park_Illinois.html">Italian beefs</a> on an instance of <code>sandwich-bracket</code> in Chicago; people who love bánh mì are probably voting on a Sydney instance, egg salad on white bread, Tokyo.</p> <p>To run a platform that makes this kind of thing work, we need a way to route incoming traffic to instances. The way we do that is with service discovery: a distributed catalog of all services running at Fly.io. The Fly.io service catalog lives in <a href="https://www.consul.io/">Consul</a>. The catalog expands consciousness. The catalog is vital to space travel.</p> <p>The catalog occupies more of our mental energy than just about anything at Fly.io. We&#39;ve sunk a huge amount of energy into keeping São Paulo, Sydney, Singapore, and points between consistent in their view of what&#39;s running on Fly.io, scaling a single global Consul cluster. What we think we&#39;ve learned is that keeping São Paulo and Sydney on exactly the same page about what&#39;s running in Mumbai is a mug&#39;s game, and we shouldn&#39;t be playing it.</p> <p>And so, to begin, it is my privilege to inflict Consul on you.</p> <h3 id="what-the-hell-is-consul"><a href="#what-the-hell-is-consul" aria-label="Anchor"></a>What the Hell Is Consul?</h3><p>Consul is a distributed database that attempts to be a source of truth for which services are currently running. It’s <a href="https://aphyr.com/posts/316-jepsen-etcd-and-consul">one of several</a> “service coordination” or “service discovery” databases; the other popular ones are <a href="https://etcd.io/">Etcd</a>, which once powered Kubernetes, and <a href="https://zookeeper.apache.org/">Zookeeper</a>, the original service coordinator, important in the Java/Hadoop ecosystem.</p> <p>The challenge of these databases, the reason they’re not just trivial MySQL instances, is that you can’t just have one of them. Once you start relying on service discovery, it can&#39;t go down, or your applications all break. So you end up with a cluster of databases, which have to agree with each other, even as services come and go. These systems all expend a lot of effort, and make a lot of compromises, in order to cough up consistent answers on flappy networks with fallible servers where individual components can fail.</p> <p>How Consul works is that you have a cluster of “Consul Servers” — maybe 3, 5, or 7 — and then all the rest of your machines run a “Consul Agent” that talks to the Servers. The Servers execute the <a href="https://raft.github.io/">Raft consensus protocol</a>, maintaining a log of updates that form the basis for the database. Agents, in turn, inform the servers about events, such as an instance of a service terminating. An Agent can talk to any Server, but the Servers elect a leader, and updates are routed to the leader, which coordinates the Raft update to the log.</p> <p>With me so far? Neither am I. But the specifics don’t matter much, as long as you understand that every machine in our fleet runs a lightweight Consul Agent that relays events to Consul Servers, which we only have a few of, locked in an unending and arcane ritual of consensus-tracking, producing: a map of every service running on <a href="http://Fly.io">Fly.io</a>, and exactly where it’s running. <a href="#other-consul-uses">Plus some other stuff</a>.</p> <p>Let&#39;s see it in action.</p> <h3 id="consul-at-fly-io"><a href="#consul-at-fly-io" aria-label="Anchor"></a>Consul at Fly.io</h3><p>A Consul &#34;service&#34; at Fly.io, in the main, is an exposed port on an app a user deployed here. An &#34;instance&#34; of a service is a VM exposing that port. A &#34;node&#34; is one of Fly.io&#39;s own servers.</p> <p>We run a couple different kinds of servers, among them lightweight “edges” handling Internet traffic, and chonky “workers” running customer VMs. Both run <a href="https://fly.io/blog/the-tokio-1-x-upgrade/"><code>fly-proxy</code>, our Rust+Tokio+Hyper proxy server</a>.</p> <p>Every app running on <a href="http://Fly.io">Fly.io</a> gets a <a href="https://fly.io/blog/32-bit-real-estate/">unique, routable IPv4 address</a>.</p> <p>That’s how our CDN works: we advertise these addresses, the same addresses, from dozens of data centers around the world, with BGP4 (this is “Anycast”). Backbone routing takes you to the closest one. Say <code>sandwich-bracket</code> is currently deployed in Frankfurt and Sydney. Anycast means the votes for doner land on a <a href="http://Fly.io">Fly.io</a> edge in Frankfurt, right next to a worker running <code>sandwich-bracket</code>; A bánh mì vote lands on a Sydney edge, and is routed to a Sydney worker. We&#39;re not deployed in Tokyo, so a vote for egg salad hits a Tokyo edge, and gets routed… out of Japan.</p> <p>The problem facing <code>fly-proxy</code> is, “where do I send this egg salad vote”. “The garbage” being, unfortunately, not a valid answer, <code>fly-proxy</code> needs to know which workers your <code>sandwich-bracket</code> app is running on, and then it needs to pick one to route to.</p> <p>Here&#39;s the data we&#39;re working with:</p> <div id="pricing-1"> <div><table><thead><tr> <th>data</th> <th>stability</th> <th>what</th> </tr> </thead><tbody><tr> <td>nodes</td> <td>very stable</td> <td>network locations of workers and edges</td> </tr> <tr> <td>app IPs</td> <td>stable</td> <td>match incoming traffic to apps</td> </tr> <tr> <td>services</td> <td>changing</td> <td>pinpoint instances to route to</td> </tr> <tr> <td>health</td> <td>flappy</td> <td>pinpoint instances to avoid routing to</td> </tr> <tr> <td>load</td> <td>untenably flappy</td> <td>enable load balancing</td> </tr> </tbody></table></div></div><p>Enter Consul. When you first created <code>sandwich-bracket</code> with our API, we:</p> <ol> <li>allocated an IPv4 address for it  </li><li>wrote it to Consul’s KV store </li><li>deployed it to, say, a worker node in Frankfurt </li><li>when that instance came up, our orchestration code registered the service instance with Consul.  </li></ol> <p>The simplest way to integrate all that information, and what we did until a couple months ago, is: we’d run <code>consul-templaterb</code> and ask it to track every service in Consul and sync a JSON file with the data; when the file is updated, <code>fly-proxy</code> gets a signal and re-reads it into memory.</p> <p>Theoretically, Consul can tell us how “close” each of those services are <a href="https://fly.io/blog/building-clusters-with-serf/">– Consul puts a bunch of work into network telemetry</a> — but we do that bit ourselves, and so there’s another JSON file that <code>fly-proxy</code> watches to track network distance to every server in our fleet.</p> <p>Consul doesn&#39;t give us the load (in concurrent requests) on all the services. For a long time, we abused Consul for this, too: we tracked load in Consul KV. Never do this! Today, we use a messaging system to gossip load across our fleet.</p> <div><p> Specifically, we use <a href="https://nats.io/">NATS</a>, a simple &#34;brokered&#34; asynchronous messaging system, the pretentious way to say &#34;almost exactly like IRC, but for programs instead of people&#34;.</p> <p>Unlike Consul, NATS is neither consistent nor reliable. That&#39;s what we like about it. We can get our heads around it. That&#39;s a big deal: it&#39;s easy to get billed for a lot of complexity by systems that solve problems 90% similar to yours. It seems like a win, but that 10% is murder. So our service discovery will likely never involve an event-streaming platform like Kafka.</p></div><p>Putting it all together, you have a sense of how our control plane works. Say the World Sandwich Authority declares doner is no longer a sandwich, and Japanese biochemists invent an even fluffier white bread. Traffic plummets in Frankfurt and skyrockets in Tokyo. We move our Frankfurt instance to Tokyo (<code>flyctl regions set syd nrt</code>). This kills the Frankfurt instance, and Frankfurt&#39;s Consul Agent deregisters it. JSON files update across the fleet. The Tokyo instance comes up and gets registered; more JSON churn.</p> <p><a name="other-consul-uses">We use Consul for other stuff!</a></p><a name="other-consul-uses"> </a><ul><a name="other-consul-uses"> </a><li><a name="other-consul-uses">Apps on </a><a href="http://Fly.io">Fly.io</a> belong to “organizations”, and apps within an organization, all over the world, <a href="https://fly.io/blog/incoming-6pn-private-networks/">can talk to each other on 6PN private networks</a>. The DNS records for those 6PN addresses are derived (mostly) from Consul. </li><li>One of Consul’s big features is “health checks” — it’ll report the health of a service based on configurable checks, so we don’t route traffic to instances that are having problems. </li><li>Consul used to be <a href="https://fly.io/blog/our-user-mode-wireguard-year/">how we propagated WireGuard information for our users</a>, which is how <code>flyctl</code> works.  </li><li>Consul is also the source of truth for the WireGuard mesh network that links every machine in our fleet. </li></ul> <h3 id="it-burns"><a href="#it-burns" aria-label="Anchor"></a>It Burns</h3><p>It looks like textbook Consul. But it&#39;s not, really.</p> <p>Consul is designed to make it easy to manage a single engineering team&#39;s applications. We&#39;re managing deployments for thousands of teams. It&#39;s led us to a somewhat dysfunctional relationship.</p> <p>To start with, we have a single Consul namespace, and a single global Consul cluster. This seems nuts. You can federate Consul. But every Fly.io data center needs details for every app running on the planet! Federating costs us the global KV store. We can engineer around that, but then we might as well not use Consul at all.</p> <p>Consul&#39;s API was also not designed with our needs in mind (nor should it have been). It&#39;s got a reasonable API for tracking some things, but not quite the things we need. So, for instance, there’s an HTTP endpoint we can long-poll to <a href="https://www.consul.io/api-docs/catalog">track the catalog of services</a>. But:</p> <ol> <li>For any endpoint in the Consul HTTP API, if something changes, we get a refresh of all the data for that endpoint, which means incremental changes, which happen every few seconds, are expensive. </li><li>What’s worse (and not Consul’s fault), tooling like <code>consul-templaterb</code> means we’re constantly rewriting and rereading large JSON files to register those small changes. </li><li>The “<a href="https://www.consul.io/api-docs/catalog#list-services">catalog of services</a>” endpoint returns information about the services (the <code>sandwich-brackets</code> app), but not the metadata for individual instances of those services (the instances of <code>sandwich-brackets</code> in <code>nrt</code> and <code>syd</code>). </li></ol> <p>That second problem is kind of a nightmare. We have tens of thousands of distinct services. We need per-instance metadata for every instance of those services.</p> <p>Consul can give us that metadata in two ways: by asking it about individual services, one-by-one, or by asking for service catalogs from each of our servers. We can&#39;t long poll tens of thousands of endpoints. So, the way we get instance metadata from Consul is to ask it about servers, not services. We long-poll <a href="https://www.consul.io/api-docs/catalog#retrieve-map-of-services-for-a-node">an API endpoint for each individual server</a>. There’s no one endpoint that we can long-poll for all the nodes.</p> <div><p> You might at this point ask why we’re storing this kind of stuff in instance metadata at all. That’s a good question with a complicated answer. Some of it has to do with <a href="https://www.nomadproject.io/">Nomad</a>, the orchestration service we use (and are gradually moving away from) to actually run VM jobs. Information about, say, what ports an app listens on percolates from a Nomad task description into its Consul service registration; that’s <a href="https://www.nomadproject.io/docs/integrations/consul-integration">just how Nomad works.</a></p> <p>You also can’t just factor the information out into, say, a Consul KV tree, because apps have versions, and different versions of apps listen on different ports, and <code>fly-proxy</code> needs to track them.</p> <p>This stuff is all solvable! But, like, are you going to solve it by using Consul more carefully, or are you going to solve it by using Consul less?</p></div><p>Which is how it came to be that we found ourselves driving over 10 (t-e-n) gb/sec of Consul traffic across our fleet. Meanwhile, and I haven’t done the math, but it’s possible that the underlying data, carefully formatted and compressed, might fit on a dialup modem.</p> <p>This, it turns out, was Not Entirely Our Fault. Long-suffering SRE Will Jordan, his brain shattered by ten gigabits of sustained Consul traffic, dove into the Consul codebase and <a href="https://github.com/hashicorp/consul/issues/12398">discovered a bug</a>: updates anywhere in Consul un-blocked every long-polling query. We had tens of thousands, N^2 (don’t email me!) in the number of nodes, all of which return a full refresh of the data they’re tracking when they unblock. Anyways, <a href="https://github.com/hashicorp/consul/pull/12399">Will wrote a couple dozen lines of Go,</a> and:</p> <p><img src="http://harihareswara.net/blog/2022-03-29/hashi-graph.png?&amp;centered" alt="A gruesome bandwidth graph"/></p> <h2 id="extricating-ourselves"><a href="#extricating-ourselves" aria-label="Anchor"></a>Extricating Ourselves</h2><p>So, <code>consul-templaterb</code>is easy, but rough at the scale we work at. It runs Ruby code to to track updates that happen multiple times per second, each time writing giant JSON blobs to disk.</p> <p>We felt this acutely with private DNS. Consul propagates the data that our DNS servers use (it&#39;s similar to the data that <code>fly-proxy</code> uses). <a href="https://fly.io/blog/free-postgres/">Fly.io Postgres</a> depends on these DNS records, so it needs to work.</p> <p>Our DNS server was originally written in Rust, and used <code>consul-templaterb</code> the way <code>fly-proxy</code> did, but wrote its updates to a sqlite database. At certain times, for certain workers, we’d experience double-digit second delays after instances came up — or worse, after they terminated. This is a big deal: it&#39;s a window of many seconds during which internal requests get routed to nonexistent hosts; worse, the requests aren&#39;t being handled by our smart proxy, but by people&#39;s random app networking code.</p> <p>We blamed Consul and <code>consul-templaterb</code>.</p> <p>To fix this, we rewrote the DNS server (in Go), so that it tracked Consul directly, using Consul’s Go API, rather than relying on <code>consul-templaterb</code>. We also had it take “hints” directly from our orchestration code, via NATS messages, for instances starting and stopping.</p> <p> Rewriting a Rust program in Go is sacrilege, we know, but Go had the Consul libraries we needed, and, long term, that Go server is going to end up baked into our orchestration code, which is already in Go.</p><p>It turns out that what we really want (if not our dream Consul API) is a local sqlite cache of all of Consul’s state. That way our proxy, WireGuard code, DNS servers, and everything else can track updates across our fleet without a lot of complicated SRE work to make sure we’re interfacing with Consul properly.</p> <p>By rewriting our DNS server, we&#39;d inadvertently built most of that. So we extracted its Consul-tracking code and gave it an identity of its own, <code>attache</code>. <code>attache</code> runs on all our hosts and tracks most of Consul in sqlite. In theory, infra services at <a href="http://Fly.io">Fly.io</a> don’t need to know anything about Consul anymore, just the schema for that database.</p> <p>New architectural possibilities are becoming apparent.</p> <p>Take that horrible N^2 polling problem. Since we&#39;ve abstracted Consul out, we really don&#39;t need a better Consul API; we just need an <code>attache</code> API, so a &#34;follower&#34; <code>attache</code> can sync from a &#34;leader&#34;. Then we could run a small number of leaders around the world — maybe just alongside Consul Servers, so that almost all our Consul read traffic would be from machines local to the Consul Servers. We&#39;d chain lots of followers from them, and possibly scale Consul indefinitely.</p> <p>We can get clever about things, too. What we&#39;d really be doing with &#34;leader&#34; and &#34;follower&#34; <code>attache</code> is replicating a sqlite database. That&#39;s already a solved problem! There&#39;s an amazing project called <a href="https://litestream.io/">Litestream</a> that <a href="https://litestream.io/how-it-works/">hooks</a> sqlite&#39;s <a href="https://sqlite.org/wal.html">WAL checkpointing</a> process and <a href="https://litestream.io/how-it-works/">ships WAL frames to storage services</a>. Instead of building a new <code>attache</code> event streaming system, we could just set up &#34;followers&#34; to use Litestream to replicate the &#34;leader&#34; database.</p> <figure> <figcaption> <p> It&#39;s just a couple commands to get an app deployed on Fly.io; no service discovery required.</p><p><a href="https://fly.io/docs/speedrun/"> Try Fly for free  <span>→</span> </a></p> </figcaption><p><img src="http://harihareswara.net/public/images/cta-cat.jpg" srcset="/public/images/cta-cat@2x.jpg 2x" alt=""/></p></figure><h3 id="we-don-t-want-raft"><a href="#we-don-t-want-raft" aria-label="Anchor"></a>We Don&#39;t Want Raft</h3><p>We&#39;re probably not going to do any of that, though, because we&#39;re increasingly convinced that&#39;s sinking engineering work into the wrong problem.</p> <p>First, if you haven&#39;t read the Google Research paper &#34;<a href="https://research.google/pubs/pub40801/">The Tail At Scale</a>&#34;, drop everything and remedy that. It&#39;s amazing, an easy read, and influential at Fly.io.</p> <p>Then: the problem we&#39;re solving with <code>attache</code> is &#34;creating a globally consistent map of all the apps running across our fleet&#34;. But that&#39;s not our real problem. Our real problem is &#34;generate fast valid responses from incoming requests&#34;. Solving the former problem is hard. It&#39;s one answer to the real problem, but not necessarily the optimal one.</p> <p>No matter how we synchronize service catalogs, we&#39;re still beclowned by the speed of light. Our routing code always races our synchronization code. Routing in Tokyo is impacted by events happening in São Paolo (sandwich: mortadella on a roll), and events in São Paolo have a 260ms head start.</p> <p>A different strategy for our real problem is request routing that&#39;s resilient to variability. That means a distributing enough information to make smart first decisions, and smart routing to handle the stale data. We&#39;ve already had to build some of that. For instance, if we route a request from an edge to a worker whose instances have died, <code>fly-proxy</code> replays it elsewhere.</p> <p>You can finesse this stuff. &#34;The Tail At Scale&#34; discusses &#34;hedged&#34; requests, which are sometimes forwarded to multiple servers (after cleverly waiting for the 95th percentile latency); you take the first response. Google also uses &#34;tied&#34; requests, which fan out to multiple servers that can each call dibs, canceling the other handlers.</p> <p>We&#39;d do all of this stuff if we could. Google works on harder problems than we do, but they have an advantage: they own their applications. So, for instance, they can engineer their protocols to break large, highly-variable requests into smaller units of work, allowing them to interleave heavyweight tasks with latency-sensitive interactive ones to eliminate head-of-line blocking. We haven&#39;t figured out how to do that with your Django POST and GET requests. But we&#39;re working on it!</p> <p>A lot of our problems are also just simpler than Raft makes them out to be. We used to use Consul to synchronize load information. But that&#39;s kind of silly: Consul is slower than the feed of load events, and with events sourced globally, we never could have had a picture that was both fresh and accurate. What we needed were hints, not databases, and that&#39;s what we have now: we use NATS (which isn&#39;t necessarily even reliably delivered, let alone consensus-based) to gossip load.</p> <p>Same goes for health checks. We already have to be resilient to stale health check information (it can and does change during request routing). Consul keeps a picture of health status, and we do still use it to restart ailing instances of apps and report status to our users. But <code>fly-proxy</code> doesn&#39;t use it anymore, and shouldn&#39;t: it does a fine job generating and gossiping health hints on its own.</p> <h3 id="but-as-always-dns"><a href="#but-as-always-dns" aria-label="Anchor"></a>But, as Always: DNS</h3><p>We can make our routing resilient to stale health and load information, and push orchestration decisions closer to workers to be less reliant on distributed health events. We have a lot of flexibility with our own infrastructure.</p> <p>That flexibility stops at the doors of the VM running your Django app. We don&#39;t own your app; we don&#39;t really even know what it does. We&#39;re <a href="https://christoph.luppri.ch/fixing-dns-resolution-for-ruby-on-alpine-linux">at the mercy of your socket code.</a></p> <p>So one place we&#39;re kind of stuck with Consul-style strongly consistent service maps is DNS. Normal apps simply aren&#39;t built to assume that DNS can be a moving target. If your app looks up <code>sandwich-postgres.internal</code>, it needs to get a valid address; if it gets nothing, or, worse, the address of a VM that terminated 750ms ago, it&#39;ll probably break, and break in hyper-annoying ways that we don&#39;t yet have clever ways to detect.</p> <p>We&#39;ve spent the better part of 9 months improving the performance of our <code>.internal</code> DNS, which is a lot for a feature that was an afterthought when I threw it together. We&#39;re in a sane place right now, but we can&#39;t stay here forever.</p> <p>What we&#39;re going to do instead – you&#39;ll see it soon on our platform – is play the ultimate CS trump card, and <code>add another layer of indirection</code>. Apps on Fly.io are getting, in addition to the DNS names they have today, &#34;internal Anycast&#34;: a stable address that routes over <code>fly-proxy</code>, so we can use the same routing smarts we&#39;re using for Internet traffic for Postgres and Redis.</p> <p>You&#39;ll still get to be fussy about connectivity between your internal apps! Internal Anycast is optional. But it&#39;s where our heads are at with making internal connectivity resilient and efficient.</p> <h2 id="and-so"><a href="#and-so" aria-label="Anchor"></a>And So</h2><p>We mostly like Consul and would use it again in new designs. It’s easy to stand up. It’s incredibly useful to deploy infrastructure configurations. For example: we write blog posts like this and people invariably comment about how cool it is that we have a WireGuard mesh network between all of our machines. But, not to diminish Steve’s work on flywire, that system falls straight out of us using Consul. It’s great!</p> <p>But we probably wouldn’t use Consul as the backing store for a global app platform again, in part because a global app platform might not even want a single globally consistent backing store. Our trajectory is away from it.</p>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="http://harihareswara.net/blog/intro-to-accessibility/"> Accessibility for real-time web apps </a> </dd> </dl> </article></div>
  </body>
</html>
