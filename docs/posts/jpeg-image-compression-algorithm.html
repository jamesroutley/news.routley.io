<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://pi.math.cornell.edu/~web6140/TopTenAlgorithms/JPEG.html">Original</a>
    <h1>JPEG: Image Compression Algorithm</h1>
    
    <div id="readability-page-1" class="page"><div><!--introduction--><p>Alex Townsend, March 2017</p><!--/introduction--><h2>Contents</h2><h2>What is JPEG?<a name="1"></a></h2><p>JPEG stands for Joint Photographic Experts Group, which was a group of image processing experts that devised a standard for compressing images (ISO).</p><p>So, JPEG (or JPG) is not really a file format but rather an image compression standard. The JPEG standard is complicated with many different options and color space regulations. It was not widely adopted. A much simpler standard version was advocated at the same time, called JFIF. This is the image compression algorithm that most people mean when they say JPEG compression, and the one that we will be describing in this class. Note that the file extensions .jpeg and .jpg have stuck, even though the underneath algorithm is (strictly speaking) JFIF compression.</p><h2>The underlying assumptions of the JPEG algorithm<a name="3"></a></h2><p>The JPEG algorithm is designed specifically for the human eye. It exploits the following biological properties of human sight:</p><p>(1) We are more sensitive to the illuminocity of color, rather than the chromatric value of an image, and</p><p>(2) We are not particularly sensitive to high-frequency content in images.</p><p>The algorithm can be neatly broken up into several stages: There is an input image I, which goes through the following process:</p><p>1) A colour transform, 2) A 2D discrete cosine transform on 8x8 blocks, 3) A quantization (filtering) stage, 4) Huffman encoding.</p><p>Finally, a compressed image is returned in the .jpg file format. This format contains the compressed image as well as information that is needed to uncompressed, with other information to allow for reexpanding the image.</p><h2>An uncompressed image of mixed peppers<a name="4"></a></h2><p>MATLAB has various images uploaded into MATLAB. Here, is one of some peppers:</p><pre>I = imread(<span>&#39;peppers.png&#39;</span>);
imshow(I)
</pre><p><img src="http://pi.math.cornell.edu/~web6140/TopTenAlgorithms/JPEG_01.png" alt=""/></p><p>It currently requires about the following number of bits to store:</p><pre>ImageSize = 8*prod(size(I))
</pre><pre>ImageSize =
     4718592
</pre><h2>Color transform: Convert RGB to YCbCr<a name="6"></a></h2><p>Right now, the image is stored in RGB format. While this colorspace is convenient for projecting the image on the computer screen, it does not isolate the illuminance and color of an image. The intensity of color is intermixed in the colorspace. The YCbCr is a more convenitent colorspace for image compression because it separates the illuminance and the chromatic strength of an image.</p><pre>Y = I;
A = [.229 .587 .114 ; -.168736 -.331264 .5 ; .5 -.418688 -.081312];
Y(:,:,1) = A(1,1)*I(:,:,1) + A(1,2)*I(:,:,2) + A(1,3)*I(:,:,3);
Y(:,:,2) = A(2,1)*I(:,:,1) + A(2,2)*I(:,:,2) + A(2,3)*I(:,:,3) + 128;
Y(:,:,3) = A(3,1)*I(:,:,1) + A(3,2)*I(:,:,2) + A(3,3)*I(:,:,3) + 128;


Y = rgb2ycbcr(I);
</pre><h2>Plot Y&#39;CbCr colorspace<a name="7"></a></h2><p>Let&#39;s see what that colorspace looks like.</p><pre>lb = {<span>&#39;Y&#39;</span>, <span>&#39;Cb&#39;</span>, <span>&#39;Cr&#39;</span>};

<span>for</span> channel = 1:3
    subplot(1,3,channel)
    Y_C = Y;
    Y_C(:,:,setdiff(1:3,channel)) = intmax(class(Y_C))/2;
    imshow(ycbcr2rgb(Y_C))
    title([lb{channel} <span>&#39; component&#39;</span>],<span>&#39;fontsize&#39;</span>,16)
<span>end</span>
</pre><p><img src="http://pi.math.cornell.edu/~web6140/TopTenAlgorithms/JPEG_02.png" alt=""/></p><h2>Our eyes are senstitive to illuminance, but not color<a name="8"></a></h2><p>Since our eyes are not particularly sensitive to chrominance, we can &#34;downsample&#34; that stuff. Here, we remove x100 amount of &#34;color&#34; from the image and see that it has barely changed:</p><pre>subplot(1,2,1)
imshow( I )
title(<span>&#39;Original&#39;</span>)
subplot(1,2,2)
Y_d = Y;
Y_d(:,:,2) = 10*round(Y_d(:,:,2)/10);
Y_d(:,:,3) = 10*round(Y_d(:,:,3)/10);
imshow(ycbcr2rgb(Y_d))
title(<span>&#39;Downsampled image&#39;</span>)
</pre><p><img src="http://pi.math.cornell.edu/~web6140/TopTenAlgorithms/JPEG_03.png" alt=""/></p><h2>Eyes are senstitive to intensity<a name="9"></a></h2><p>However, if we downsample the illuminance by x10, then there is a noticeable difference. (You&#39;ll have to zoom in to see it.)</p><pre>subplot(1,2,1)
imshow( I )
title(<span>&#39;original&#39;</span>)
subplot(1,2,2)
Y_d = Y;
Y_d(:,:,1) = 10*round(Y_d(:,:,1)/10);
imshow(ycbcr2rgb(Y_d))
title(<span>&#39;Downsample illuminance&#39;</span>)
</pre><p><img src="http://pi.math.cornell.edu/~web6140/TopTenAlgorithms/JPEG_04.png" alt=""/></p><h2>JPEG downsampling<a name="10"></a></h2><p>Here, we will be a little conservative and downsample the chrominance by only a factor of 2.</p><pre>Y_d = Y;
Y_d(:,:,2) = 2*round(Y_d(:,:,2)/2);
Y_d(:,:,3) = 2*round(Y_d(:,:,3)/2);
</pre><h2>The 2D discrete cosine transform<a name="11"></a></h2><p>Once the image is in YCrCb color space and downsampled, it is partitioned into 8x8 blocks. Each block is transformed by the two-dimensional discrete cosine transform (DCT). Let&#39;s extract one 8x8 block of pixels for demonstration, shown here in white:</p><p>We apply the DCT to that box:</p><pre>clf
box = Y_d;
II = box(200:207,200:207,1);
Y = chebfun.dct(chebfun.dct(II).&#39;).&#39;;
surf(log10(abs(Y))), title(<span>&#39;DCT coefficients&#39;</span>)
set(gca,<span>&#39;fontsize&#39;</span>,16)
</pre><p><img src="http://pi.math.cornell.edu/~web6140/TopTenAlgorithms/JPEG_05.png" alt=""/></p><h2>Quantization table<a name="13"></a></h2><p>Next we apply a quantization table to Y, which filters out the high frequency DCT coefficients:</p><pre>Q = [16 11 10 16 24 40 51 61 ;
     12 12 14 19 26 28 60 55 ;
     14 13 16 24 40 57 69 56 ;
     14 17 22 29 51 87 80 62 ;
     18 22 37 56 68 109 103 77 ;
     24 35 55 64 81 104 113 92 ;
     49 64 78 87 103 121 120 101;
     72 92 95 98 112 100 103 99];
before = nnz(Y);
Y = Q.*round(Y./Q);
after = nnz(Y);
</pre><p>The number of nonzero DCT coefficients after quantization is:</p><pre>before, after
</pre><pre>before =
    64
after =
     6
</pre><p>We now apply this compression to every 8x8 block. We obtain:</p><pre>I = imread(<span>&#39;peppers.png&#39;</span>);
Y_d = rgb2ycbcr( I );

Y_d(:,:,2) = 2*round(Y_d(:,:,2)/2);
Y_d(:,:,3) = 2*round(Y_d(:,:,3)/2);

A = zeros(size(Y_d));
B = A;
<span>for</span> channel = 1:3
    <span>for</span> j = 1:8:size(Y_d,1)-7
        <span>for</span> k = 1:8:size(Y_d,2)
            II = Y_d(j:j+7,k:k+7,channel);
            freq = chebfun.dct(chebfun.dct(II).&#39;).&#39;;
            freq = Q.*round(freq./Q);
            A(j:j+7,k:k+7,channel) = freq;
            B(j:j+7,k:k+7,channel) = chebfun.idct(chebfun.idct(freq).&#39;).&#39;;
        <span>end</span>
    <span>end</span>
<span>end</span>

subplot(1,2,1)
imshow(ycbcr2rgb(Y_d))
title(<span>&#39;Original&#39;</span>)
subplot(1,2,2)
imshow(ycbcr2rgb(uint8(B)));
title(<span>&#39;Compressed&#39;</span>)
shg
</pre><p><img src="http://pi.math.cornell.edu/~web6140/TopTenAlgorithms/JPEG_06.png" alt=""/></p><h2>Compression so far<a name="16"></a></h2><p>The quantization step has successfully compressed the image by about a factor of 7.</p><pre>CompressedImageSize = 8*nnz(A(:,:,1)) + 7*nnz(A(:,:,2)) + 7*nnz(A(:,:,3))
CompressedImageSize/ImageSize
</pre><pre>CompressedImageSize =
      701189
ans =
   0.148601320054796
</pre><p>The formula above is obtained by noting that we downsampled in Cr and Cb are downsampled.</p><h2>Huffman encoding<a name="18"></a></h2><p>We now encode the DCT blocks using Huffman encoding:</p><pre>b = A(:);
b = b(:);
b(b==0)=[];  
b = floor(255*(b-min(b))/(max(b)-min(b)));
symbols = unique(b);
prob = histcounts(b,length(symbols))/length(b);
dict = huffmandict(symbols, prob);
enco = huffmanenco(b, dict);
FinalCompressedImage = length(enco)
</pre><pre>FinalCompressedImage =
      695755
</pre><h2>Final compression<a name="19"></a></h2><p>We have successfully reduced the pepper image by about x7, while being extremely conservative:</p><pre>length(enco)/ImageSize   
</pre><pre>ans =
   0.147449705335829
</pre><h2>A different image<a name="20"></a></h2><p>The images of peppers is not ideal for JPEG. Here is an image for which JPEG gets a better compression rate (of about x30).</p><pre>I = imread(<span>&#39;saturn.png&#39;</span>);
ImageSize = 8*prod(size(I));
Y_d = rgb2ycbcr( I );

Y_d(:,:,2) = 2*round(Y_d(:,:,2)/2);
Y_d(:,:,3) = 2*round(Y_d(:,:,3)/2);

A = zeros(size(Y_d));
B = A;
<span>for</span> channel = 1:3
    <span>for</span> j = 1:8:size(Y_d,1)-7
        <span>for</span> k = 1:8:size(Y_d,2)-7
            II = Y_d(j:j+7,k:k+7,channel);
            freq = chebfun.dct(chebfun.dct(II).&#39;).&#39;;
            freq = Q.*round(freq./Q);
            A(j:j+7,k:k+7,channel) = freq;
            
            B(j:j+7,k:k+7,channel) = chebfun.idct(chebfun.idct(freq).&#39;).&#39;;
        <span>end</span>
    <span>end</span>
<span>end</span>
b = A(:);
b = b(:);
b(b==0)=[];  
b = floor(255*(b-min(b))/(max(b)-min(b)));
symbols = unique(b);
prob = histcounts(b,length(symbols))/length(b);
dict = huffmandict(symbols, prob);
enco = huffmanenco(b, dict);
FinalCompressedImage = length(enco);

FinalCompressedImage/ImageSize
</pre><pre>ans =
   0.031958287037037
</pre><p>Here&#39;s what the images look like:</p><pre>subplot(1,2,1)
imshow(I)
title(<span>&#39;Original&#39;</span>)
subplot(1,2,2)
imshow(ycbcr2rgb(uint8(B)));
title(<span>&#39;Compressed&#39;</span>)
</pre><p><img src="http://pi.math.cornell.edu/~web6140/TopTenAlgorithms/JPEG_07.png" alt=""/></p></div></div>
  </body>
</html>
