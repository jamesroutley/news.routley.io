<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hivekit.io/blog/how-weve-saved-5000-percent-in-cloud-costs-by-writing-our-own-database/">Original</a>
    <h1>Saving cloud costs by writing our own database</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
        
<p><img src="https://hivekit.io/blog/how-weve-saved-5000-percent-in-cloud-costs-by-writing-our-own-database/title.png" alt="Two Mechanics working on a database"/></p>
<p>What is the first rule of programming? Maybe something like “do not repeat yourself” or “if it works, don’t touch it”? Or, how about “do not write your own database!”… That’s a good one.</p>
<p>Databases are a nightmare to write, from Atomicity, Consistency, Isolation, and Durability (ACID) requirements to sharding to fault recovery to administration - everything is hard beyond belief.</p>
<p>Fortunately, there are amazing databases out there that have been polished over decades and don’t cost a cent. So why on earth would we be foolish enough to write one from scratch?</p>
<h2 id="well-heres-the-thing">Well, here’s the thing…</h2>
<p>We are running a cloud platform that tracks tens of thousands of people and vehicles simultaneously. Every location update is stored and can be retrieved via a history API.</p>
<p>The amount of simultaneously connected vehicles and the frequency of their location updates varies widely over time, but having around 13.000 simultaneous connections, each sending around one update a second, is fairly normal.</p>
<p>Our customers use this data in very different ways. Some use cases are very coarse, e.g. when a car rental company wants to show an outline of the route a customer took that day. This sort of requirement could be handled with 30-100 location points for a one hour trip and would allow us to heavily aggregate and compress the location data before storing it.</p>
<p>But there are many other use cases where that’s not an option. Delivery companies that want to be able to replay the exact seconds leading up to an accident. Mines with very precise, on-site location trackers that want to generate reports of which worker stepped into which restricted zone - by as little as half a meter.</p>
<p>So - given that we don’t know upfront what level of granularity each customer will need, we store every single location update. At 13k vehicles that’s 3.5 billion updates per month - and that will only grow from here. So far, we’ve been using AWS Aurora with the PostGIS extension for geospatial data storage. But Aurora costs us upwards of $10k a month already, just for the database alone - and that will only become more expensive in the future.</p>
<p>But it’s not just about Aurora pricing. While Aurora holds up quite well under load, many of our customers are using our on-premise version. And there, they have to run their own database clusters which are easily overwhelmed by this volume of updates.</p>
<h2 id="why-arent-we-just-using-a-database-purpose-built-for-geospatial-data">Why aren’t we just using a database, purpose built for geospatial data?</h2>
<p>Unfortunately, there is no such thing. (If there is and we somehow overlooked it in our research, <a href="mailto:wolfram@hivekit.io">please let me know</a>). Many databases, from Mongo and H2 to Redis support spatial data types like points and areas. And there are “Spatial Databases” - but they are exclusively extensions that sit on top of existing DBs. <a href="https://postgis.net/">PostGIS</a>, built on top of PostgreSQL is probably the most famous one, but there are others like <a href="https://www.geomesa.org/">Geomesa</a> that offer great geospatial querying capabilities on top of other storage engines.</p>
<p>Unfortunately, that’s not what we need.</p>
<p>Here’s what our requirement profile looks like:</p>
<ul>
<li><strong>Extremely high write performance</strong> </li>
<li><strong>Unlimited parallelism</strong> </li>
<li><strong>Small size on disk</strong> </li>
</ul>
<p>This means, we’ll have to accept some trade-offs. Here’s what we are ok with:</p>
<ul>
<li>
<p><strong>Moderate performance for reads from disk</strong> </p>
</li>
<li>
<p><strong>Low consistency guarantees</strong> </p>
</li>
</ul>
<h2 id="what-sort-of-data-do-we-need-to-store">What sort of data do we need to store?</h2>
<p>The main type of entity that we need to persist is an “object” - basically any vehicle, person, sensor or machine. Objects have an id label, location and arbitrary key/value data, e.g. for fuel levels or current rider id. Locations consist of longitude, latitude accuracy, speed, heading, altitude and altitude accuracy - though each update can only change a subset of these fields.</p>
<p>In addition we also need to store areas, tasks (something an “object” has to do), and instructions (tiny bits of spatial logic the hivekit server executes based on the incoming data).</p>
<h2 id="what-weve-built">What we’ve built</h2>
<p>We’ve created a purpose built, in process storage engine that’s part of the same executable as our core server. It writes a minimal, delta based binary format. A single entry looks like this:</p>
<p><img src="https://hivekit.io/blog/how-weve-saved-5000-percent-in-cloud-costs-by-writing-our-own-database/byte-diagram.png" alt="Byte Diagram"/></p></div></div>
  </body>
</html>
