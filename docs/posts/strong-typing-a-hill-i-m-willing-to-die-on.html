<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.svix.com/blog/strong-typing-hill-to-die-on/">Original</a>
    <h1>Strong typing, a hill I&#39;m willing to die on</h1>
    
    <div id="readability-page-1" class="page"><div><div><p><img alt="Cover image" src="https://www.svix.com/blog/static/images/generated/strong-typing-hill-to-die-on/cover-IT6ATRYD.png"/></p>
<p>Svix is the enterprise ready webhooks sending service. With Svix, you can build a secure,
reliable, and scalable webhook platform in minutes. Looking to send webhooks?<!-- --> <!-- -->
<a href="https://www.svix.com">Give it a try!</a></p>
<p><strong>Edit:</strong> previous version of this post didn&#39;t have &#34;static&#34; in the title to keep it short (but the body did). Added it in the title for clarification.</p>
<p>I&#39;ve been writing software for over 20 years, and with every day that goes by I grow more certain that strong static typing is not just a good idea, but also almost always the right choice.</p>
<p>There are definitely uses for untyped languages (or language variants), for example they are much nicer when using a REPL, or for throwaway scripts in environments that are already hopelessly untyped (e.g. the shell). In almost every other case, however, strong typing is strongly preferred.</p>
<p>There are advantages to not using types, such as a faster development speed, but they pale in comparison to all of the advantages. To that I say:</p>
<blockquote>
<p>Writing software without types lets you go at full speed. Full speed towards the cliff.</p>
</blockquote>
<p>The question around strong static typing is simple: would you rather work a bit more and get invariants checked at compile-time (or type-checking time for non-compiled languages), or work a bit less and have them be enforced at runtime, or even worse not enforced even at runtime (JavaScript, I&#39;m looking at you... <code>1 + &#34;2&#34; == 12</code>).</p>
<p>Getting errors at runtime is a terrible idea. First, it means that you won&#39;t always catch them during development. Second, when you do catch them, it will happen in a customer facing manner. Yes, tests help, but writing tests for every possible mistyped function parameter is impossible given the endless possibilities. Even if you could, having types is much easier than testing for wrong types.</p>
<h2 id="types-lead-to-less-bugs"><a href="#types-lead-to-less-bugs" aria-hidden="true" tabindex="-1"><span></span></a>Types lead to less bugs</h2>
<p>Types also offer annotations to code that benefit both humans and machines. Having types is a way to more strictly define the contract between different pieces of code.</p>
<p>Consider the following four examples. They all do exactly the same thing just with varying level of contract definition.</p>
<div><pre><code><span>
</span><span><span>function</span> <span>birthdayGreeting1</span><span>(</span><span><span>...</span>params</span><span>)</span> <span>{</span>
</span><span>    <span>return</span> <span><span>`</span><span><span>${</span>params<span>[</span><span>0</span><span>]</span><span>}</span></span><span> is </span><span><span>${</span>params<span>[</span><span>1</span><span>]</span><span>}</span></span><span>!</span><span>`</span></span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span>
</span><span><span>function</span> <span>birthdayGreeting2</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
</span><span>    <span>return</span> <span><span>`</span><span><span>${</span>name<span>}</span></span><span> is </span><span><span>${</span>age<span>}</span></span><span>!</span><span>`</span></span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>function</span> <span>birthdayGreeting3</span><span>(</span><span>name<span>:</span> string<span>,</span> age<span>:</span> number</span><span>)</span><span>:</span> string <span>{</span>
</span><span>    <span>return</span> <span><span>`</span><span><span>${</span>name<span>}</span></span><span> is </span><span><span>${</span>age<span>}</span></span><span>!</span><span>`</span></span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div>
<p>The first one doesn&#39;t even define the number of parameters, so it&#39;s hard to know what it does without reading the docs. I believe most people will agree the first one is an abomination and wouldn&#39;t write code like that. Though it&#39;s a very similar idea to typing, it&#39;s about defining the contract between the caller and the callee.</p>
<p>As for the second and the third, because of the typing, the third will need less documentation. The code is simpler, but admittedly, the advantages are fairly limited. Well, until you actually change this function...</p>
<p>In both the second and the third functions, the author assumes the age is a number. So it is absolutely fine to change the code as below:</p>
<div><pre><code><span>
</span><span><span>function</span> <span>birthdayGreeting2</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
</span><span>    <span>return</span> <span><span>`</span><span><span>${</span>name<span>}</span></span><span> will turn </span><span><span>${</span>age <span>+</span> <span>1</span><span>}</span></span><span> next year!</span><span>`</span></span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>function</span> <span>birthdayGreeting3</span><span>(</span><span>name<span>:</span> string<span>,</span> age<span>:</span> number</span><span>)</span><span>:</span> string <span>{</span>
</span><span>    <span>return</span> <span><span>`</span><span><span>${</span>name<span>}</span></span><span> will turn </span><span><span>${</span>age <span>+</span> <span>1</span><span>}</span></span><span> next year!</span><span>`</span></span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div>
<p>The problem is that some of the places that use this code accept user input which was collected from an HTML input (so always a string). Which will result in:</p>
<div><pre><code><span><span>&gt;</span> <span>birthdayGreeting2</span><span>(</span><span>&#34;John&#34;</span><span>,</span> <span>&#34;20&#34;</span><span>)</span>
</span><span><span>&#34;John will turn 201 next year!&#34;</span>
</span></code></pre></div>
<p>While the typed version will correctly fail to compile because this function excepts age to be a number, not a string.</p>
<p>Having the contract between a caller and callee is important for a codebase, so that callers can know when callees change. This is especially important for an open source library, where the callers and the callees are not written by the same group of people. With this contract it&#39;s impossible to know how things change when they do.</p>
<h2 id="types-lead-to-a-better-development-experience"><a href="#types-lead-to-a-better-development-experience" aria-hidden="true" tabindex="-1"><span></span></a>Types lead to a better development experience</h2>
<p>Typing can also be used by IDEs and other development tools to vastly improve the development experience. You get notified as you code if any of your expectations are wrong. This significantly reduces cognitive load. You no longer need to remember the types of all the variables and the function in the context. The compiler will be there with you and tell you when something is wrong.</p>
<p>This also leads to a very nice additional benefit: easier refactoring. You can trust the compiler to let you know whether a change you make (e.g. the change in our example above) will break assumptions made elsewhere in the code or not.</p>
<p>Types also make it much easier to onboard new engineers to a codebase or library:</p>
<ol>
<li>They can follow the type definitions to understand where things are used.</li>
<li>It&#39;s much easier to tinker with things as changes will trigger a compile error.</li>
</ol>
<p>Let&#39;s consider the following changes to our above code:</p>
<div><pre><code><span><span>class</span> <span>Person</span> <span>{</span>
</span><span>  name<span>:</span> <span>string</span><span>;</span>
</span><span>  age<span>:</span> <span>number</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>function</span> <span>birthdayGreeting2</span><span>(</span>person<span>)</span> <span>{</span>
</span><span>    <span>return</span> <span><span>`</span><span><span>${</span>person<span>.</span>name<span>}</span></span><span> will turn </span><span><span>${</span>person<span>.</span>age <span>+</span> <span>1</span><span>}</span></span><span> next year!</span><span>`</span></span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>function</span> <span>birthdayGreeting3</span><span>(</span>person<span>:</span> Person<span>)</span><span>:</span> <span>string</span> <span>{</span>
</span><span>    <span>return</span> <span><span>`</span><span><span>${</span>person<span>.</span>name<span>}</span></span><span> will turn </span><span><span>${</span>person<span>.</span>age <span>+</span> <span>1</span><span>}</span></span><span> next year!</span><span>`</span></span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>function</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
</span><span>  <span>const</span> person<span>:</span> Person <span>=</span> <span>{</span> name<span>:</span> <span>&#34;Hello&#34;</span><span>,</span> age<span>:</span> <span>12</span> <span>}</span><span>;</span>
</span><span>
</span><span>  <span>birthdayGreeting2</span><span>(</span>person<span>)</span><span>;</span>
</span><span>
</span><span>  <span>birthdayGreeting3</span><span>(</span>person<span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div>
<p>It&#39;s very easy to see (or use your IDE to find) all the places where <code>Person</code> is used. You can see it&#39;s initiated in <code>main</code> and you can see it&#39;s used by birthdayGreeting3<code>. However, in order to know it&#39;s used in </code>birthdayGreeting2`, you&#39;d need to read the entire codebase.</p>
<p>The flip side of this is also that when looking at <code>birthdayGreeting2</code>, it&#39;s hard to know that it expects a <code>Person</code> as a parameter. Some of these things can be solved by exhaustive documentation, but: (1) why bother if you can achieve more with types? (2) documentation goes stale, here the code is the documentation.</p>
<p>It&#39;s very similar to how you wouldn&#39;t write code like:</p>
<div><pre><code><span>
</span><span><span>function</span> <span>birthdayGreeting2</span><span>(</span><span>a</span><span>)</span> <span>{</span>
</span><span>    b <span>=</span> person<span>.</span><span>name</span><span>;</span>
</span><span>    c <span>=</span> person<span>.</span><span>age</span><span>;</span>
</span><span>    <span>return</span> <span><span>`</span><span><span>${</span>b<span>}</span></span><span> will turn </span><span><span>${</span>c <span>+</span> <span>1</span><span>}</span></span><span> next year!</span><span>`</span></span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div>
<p>You would want to use useful variable names. Typing is the same, it&#39;s just variable names on steriods.</p>
<h2 id="we-encode-everything-in-the-type-system"><a href="#we-encode-everything-in-the-type-system" aria-hidden="true" tabindex="-1"><span></span></a>We encode everything in the type system</h2>
<p>At Svix we love types. In fact, we try to encode as much information as we possibly can in the type system, so that all of the errors that can be caught at compile time will be caught at compile time; and also to squeeze that extra mileage of developer experience improvements.</p>
<p>For example, Redis is a string based protocol with no inherent typing. We use Redis for caching (among other things). The problem is that all of our nice typing benefits will be lost at the Redis layer, and bugs can happen.</p>
<p>Consider the following piece of code:</p>
<div><pre><code><span><span>pub</span> <span>struct</span> <span>Person</span> <span>{</span>
</span><span>    <span>pub</span> id<span>:</span> <span>String</span><span>,</span>
</span><span>    <span>pub</span> name<span>:</span> <span>String</span><span>,</span>
</span><span>    <span>pub</span> age<span>:</span> <span>u16</span><span>,</span>
</span><span><span>}</span>
</span><span>
</span><span><span>pub</span> <span>struct</span> <span>Pet</span> <span>{</span>
</span><span>    <span>pub</span> id<span>:</span> <span>String</span><span>,</span>
</span><span>    <span>pub</span> owner<span>:</span> <span>String</span><span>,</span>
</span><span><span>}</span>
</span><span>
</span><span>
</span><span><span>let</span> id <span>=</span> <span>&#34;p123&#34;</span><span>;</span>
</span><span><span>let</span> person <span>=</span> <span>Person</span><span>::</span><span>new</span><span>(</span><span>&#34;John&#34;</span><span>,</span> <span>20</span><span>)</span><span>;</span>
</span><span>cache<span>.</span><span>set</span><span>(</span><span>format!</span><span>(</span><span>&#34;person-{id}&#34;</span><span>)</span><span>,</span> person<span>)</span><span>;</span>
</span><span>
</span><span><span>let</span> pet<span>:</span> <span>Pet</span> <span>=</span> cache<span>.</span><span>get</span><span>(</span><span>format!</span><span>(</span><span>&#34;preson-{id}&#34;</span><span>)</span><span>)</span><span>;</span>
</span></code></pre></div>
<p>There are a couple of bugs in the snippet:</p>
<ol>
<li>There&#39;s a typo in the second key name.</li>
<li>We are trying to load a person into a pet type.</li>
</ol>
<p>To avoid such issues we do two things at Svix. The first is that we require the key to be of a certain type (not a generic string), and to create this type you need to call a specific fuction. The second thing we do, is force pairing a key to a value.</p>
<p>So the above example would look something like:</p>
<div><pre><code><span><span>pub</span> <span>struct</span> <span>PersonCacheKey</span><span>(</span><span>String</span><span>)</span><span>;</span>
</span><span>
</span><span><span>impl</span> <span>PersonCacheKey</span> <span>{</span>
</span><span>    <span>fn</span> <span>new</span><span>(</span>id<span>:</span> <span>&amp;</span><span>str</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span> <span>...</span> <span>}</span>
</span><span><span>}</span>
</span><span>
</span><span><span>pub</span> <span>struct</span> <span>Person</span> <span>{</span>
</span><span>    <span>pub</span> id<span>:</span> <span>String</span><span>,</span>
</span><span>        <span>pub</span> name<span>:</span> <span>String</span><span>,</span>
</span><span>        <span>pub</span> age<span>:</span> <span>u16</span><span>,</span>
</span><span><span>}</span>
</span><span>
</span><span><span>pub</span> <span>struct</span> <span>PetCacheKey</span><span>;</span>
</span><span>
</span><span><span>pub</span> <span>struct</span> <span>Pet</span> <span>{</span>
</span><span>    <span>pub</span> id<span>:</span> <span>String</span><span>,</span>
</span><span>        <span>pub</span> owner<span>:</span> <span>String</span><span>,</span>
</span><span><span>}</span>
</span><span>
</span><span>
</span><span><span>let</span> id <span>=</span> <span>&#34;p123&#34;</span><span>;</span>
</span><span><span>let</span> person <span>=</span> <span>Person</span><span>::</span><span>new</span><span>(</span>id<span>,</span> <span>&#34;John&#34;</span><span>,</span> <span>20</span><span>)</span><span>;</span>
</span><span>cache<span>.</span><span>set</span><span>(</span><span>PersonCacheKey</span><span>::</span><span>new</span><span>(</span>id<span>)</span><span>,</span> person<span>)</span><span>;</span>
</span><span>
</span><span>
</span><span><span>let</span> pet<span>:</span> <span>Pet</span> <span>=</span> cache<span>.</span><span>get</span><span>(</span><span>PersonCacheKey</span><span>::</span><span>new</span><span>(</span>id<span>)</span><span>)</span><span>;</span>
</span></code></pre></div>
<p>This is already much better, and makes it impossible to get either of the previously mentioned bugs. Though we can do even better!</p>
<p>Consider the following function:</p>
<div><pre><code><span><span>pub</span> <span>fn</span> <span>do_something</span><span>(</span>id<span>:</span> <span>String</span><span>)</span> <span>{</span>
</span><span>    <span>let</span> person<span>:</span> <span>Person</span> <span>=</span> cache<span>.</span><span>get</span><span>(</span><span>PersonCacheKey</span><span>::</span><span>new</span><span>(</span>id<span>)</span><span>)</span><span>;</span>
</span><span>    
</span><span><span>}</span>
</span></code></pre></div>
<p>There are a couple of problems with it. The first is that it&#39;s not very clear which <code>id</code> it should be for. Is it a person? A pet? It&#39;s very easy to accidentally call it with the wrong one, like in the following example:</p>
<div><pre><code><span><span>let</span> pet <span>=</span> <span>...</span><span>;</span>
</span><span><span>do_something</span><span>(</span>pet<span>.</span>id<span>)</span><span>;</span> 
</span></code></pre></div>
<p>The second is that we are losing the discoverability. It&#39;s a bit hard to know that a Pet has a relationship to a Person.</p>
<p>So at Svix, we have a special type for each <code>id</code> to ensure that there are no mistakes. The adjusted code looks something like:</p>
<div><pre><code><span><span>pub</span> <span>struct</span> <span>PersonId</span><span>(</span><span>String</span><span>)</span><span>;</span>
</span><span><span>pub</span> <span>struct</span> <span>PetId</span><span>(</span><span>String</span><span>)</span><span>;</span>
</span><span>
</span><span><span>pub</span> <span>struct</span> <span>Person</span> <span>{</span>
</span><span>    <span>pub</span> id<span>:</span> <span>PersonId</span><span>,</span>
</span><span>    <span>pub</span> name<span>:</span> <span>String</span><span>,</span>
</span><span>    <span>pub</span> age<span>:</span> <span>u16</span><span>,</span>
</span><span><span>}</span>
</span><span>
</span><span><span>pub</span> <span>struct</span> <span>Pet</span> <span>{</span>
</span><span>    <span>pub</span> id<span>:</span> <span>PetId</span><span>,</span>
</span><span>    <span>pub</span> owner<span>:</span> <span>PersonId</span><span>,</span>
</span><span><span>}</span>
</span></code></pre></div>
<p>This is indeed much better than our previous example.</p>
<p>There is still one issue. If we accept the <code>id</code>s from the API, how do we know that they are valid? All of the pet <code>id</code>s in Svix, for example, are prefixed with <code>pet_</code> and are then followed by a Ksuid like so: <code>pet_25SVqQSCVpGZh5SmuV0A7X0E3rw</code>.</p>
<p>We want to be able to tell our customers that they pass the wrong <code>id</code> in the API, e.g. they pass a person <code>id</code> when a pet one is expected. One simple solution for this is to validate this (duh...) but it can be easy to forget to validate it everywhere that it&#39;s used.</p>
<p>So we enforce that a <code>PetId</code> can never be created without first being validated. This way we know that all of the code paths that create a <code>PetId</code> first make sure it&#39;s valid. This means that when we return a <code>404 Not Found</code> to a customer because a pet isn&#39;t found in the database, we can be sure it was actually a valid <code>id</code> that wasn&#39;t found in the database. If it wasn&#39;t a valid <code>id</code>, we would have already returned a <code>422</code> or <code>400</code> when it was passed to the API handlers.</p>
<h2 id="so-why-doesnt-everyone-like-types"><a href="#so-why-doesnt-everyone-like-types" aria-hidden="true" tabindex="-1"><span></span></a>So why doesn&#39;t everyone like types?</h2>
<p>The main topic of argument against types are:</p>
<ol>
<li>Development speed</li>
<li>Learning curve and types complexity</li>
<li>The amount of effort and boilerplate required</li>
</ol>
<p>First of all, I&#39;d argue that even if all of the above were true, the advantages mentioned above are well worth the trouble. Though I also don&#39;t agree with all of the above.</p>
<p>The first one is development speed. Prototyping without types is definitely much faster. You can comment out pieces of the code and won&#39;t have a compiler complain to you. You can set the wrong values for some of the fields until you&#39;re ready to figure out the right ones, etc.</p>
<p>Though like I said above: &#34;Writing software without types lets you go at full speed. Full speed towards the cliff.&#34; The problem is that this is just aggressive and unnecessary technical debt. You&#39;ll pay it mulitple times over when you need to debug why your code doesn&#39;t work (either locally, in the test suite, or in production).</p>
<p>As for the learning curve: Yes, learning more things takes time. Though I&#39;d say that most people don&#39;t need to be typing experts. They can just get by with very simple type expressions, and ask if they ever hit a wall. However, if you keep things simple, you&#39;ll probably rarely if ever hit one.</p>
<p>Additionally, people are already required to learn how to code, learn frameworks (React, Axum, etc.), and so many other things. I don&#39;t think the learning burden is as significant as it&#39;s made out to be.</p>
<p>Last, but not least, regarding the learning curve: I strongly believe that the benefits of a lessened learning curve by not having to know types, are much less than the benefits of using the type script to onboard on a specific codebase. Especially since learning types is a one time cost.</p>
<p>The last point is about the amount of effort and boilerplate required to use types in your codebase. I strongly believe that the amount of effort is actually less than the amount of effort required by not writing types.</p>
<p>Not using types requires significant documentation and testing in order to reach even a basic level of sanity. Documentation can go stale, and so can testing; and either way they require more effort than just adding the right types. Reading code with types is also easier, because you get the types inline instead of in the function documentation where it&#39;s in an inconsistent format with a lot of added noise.</p>
<p>Yes, typing can be a pain in languages that don&#39;t support inference, e.g Java can be tedious:</p>
<div><pre><code><span><span>Person</span> person1 <span>=</span> <span>newPerson</span><span>(</span><span>)</span><span>;</span>
</span><span><span>Person</span> person2 <span>=</span> <span>newPerson</span><span>(</span><span>)</span><span>;</span>
</span><span><span>Person</span> child <span>=</span> <span>makeChild</span><span>(</span>person1<span>,</span> person2<span>)</span><span>;</span>
</span></code></pre></div>
<p>while mother languages that have inference (like Rust), are much nicer:</p>
<div><pre><code><span><span>let</span> person1 <span>=</span> <span>new_person</span><span>(</span><span>)</span><span>;</span>
</span><span><span>let</span> person2 <span>=</span> <span>new_person</span><span>(</span><span>)</span><span>;</span>
</span><span><span>let</span> child <span>=</span> <span>make_child</span><span>(</span>person1<span>,</span> person2<span>)</span><span>;</span>
</span></code></pre></div>
<p>So having the right tools definitely helps.</p>
<p>Speaking of tools, in order to reap the benefits of your typing, you probably need to use a code editor (or IDE) that supports modern code completion that is language aware.</p>
<h2 id="closing-words"><a href="#closing-words" aria-hidden="true" tabindex="-1"><span></span></a>Closing words</h2>
<p>I can see both side of the arguments on many topics, such as <code>vim</code> vs. <code>emacs</code>, tabs vs. spaces, and even much more controversial ones. Though in this case, the costs are so low compared to the benefits that I just don&#39;t understand why anyone would ever choose not to use types.</p>
<p>I&#39;d love to know what I&#39;m missing, but until then: Strong typing is a hill I&#39;m willing to die on.</p>
<hr/>
<p>For more content like this, make sure to follow us on <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/SvixHQ">Twitter</a>, <a target="_blank" rel="noopener noreferrer" href="https://github.com/svix">Github</a> or <a target="_blank" rel="noopener noreferrer" href="https://www.svix.com/blog/rss/">RSS</a> for the latest updates for the <a target="_blank" rel="noopener noreferrer" href="https://www.svix.com">Svix webhook service</a>, or join the discussion on <a target="_blank" rel="noopener noreferrer" href="https://www.svix.com/slack/">our community Slack</a>.</p></div></div></div>
  </body>
</html>
