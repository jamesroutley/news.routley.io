<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://microsoftedge.github.io/edgevr/posts/Escaping-the-sandbox-A-bug-that-speaks-for-itself/">Original</a>
    <h1>Escaping the Edge sandbox: A bug that speaks for itself</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="introduction">Introduction</h2><p>In this blog post, we will share the story about how we discovered a critical stack corruption bug that has existed in Windows for more than 20 years (<a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-36719">CVE-2023-36719</a>). The bug was found in a core Windows OS library which is used by countless software products but is most notably reachable from within the sandbox of all Chromium-based browsers, exposing a sandbox escape which is reachable from the web via JavaScript.</p><p>We will walk through the process on how we chose the target and the method that led us to discover this vulnerability, as well as some thoughts on how this could lead to browser and full system compromise.</p><p>In line with our goal to make Microsoft Edge the most secure browser for Windows, we decided to target a platform-specific feature in the Web Speech API, which offers speech synthesis functionality to aid user experience and accessibility and ends up using the internal Microsoft Speech API.</p><h2 id="the-web-speech-api">The Web Speech API</h2><p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API">Web Speech API</a> is defined in the JavaScript standard. It is a set of APIs which allow web developers to use speech synthesis and recognition features in their web applications.</p><p>As an example, consider the following JavaScript code snippet:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>let</span> <span>text</span> <span>=</span> <span>&#34;</span><span>Hello World!</span><span>&#34;</span><span>;</span>

<span>speechSynthesis</span><span>.</span><span>speak</span><span>(</span><span>new</span> <span>SpeechSynthesisUtterance</span><span>(</span><span>text</span><span>));</span>
</pre></td></tr></tbody></table></code></p></div><p>The <a href="https://wicg.github.io/speech-api/#dom-speechsynthesis-speak">speak method</a> interacts with the platform-specific Text-To-Speech (TTS) service, and the audio will be played on the device.</p><h3 id="chromium-multi-process-architecture">Chromium Multi-Process Architecture</h3><p>We will briefly cover the sandboxing architecture of Chromium-based browsers. Readers who are already familiar with this can skip to the next section,</p><p>As you may be aware, Chromium-based browsers (and most widespread modern browsers) use a multi-process architecture. All the content of a site, including untrusted JavaScript code, is parsed and executed within a separate process with no access to the file system, network or many other system resources. Generically, we refer to these as “sandbox” processes and there are several different types, in this case we are referring specifically to the Renderer Process.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/speech_synthesis/image1.png" alt="A diagram showing Chromium multi-process architecture."/></p><p><em>Diagram showing Chromium multi-process architecture. <a href="https://www.chromium.org/developers/design-documents/multi-process-architecture/">Reference</a></em></p><p>Following the principle of least privilege, many of the higher trust responsibilities and functionalities are managed by the more privileged Browser Process. It has the permission to initiate many kinds of actions, including (but not limited to) accessing the filesystem, the device’s camera, geolocation data, and more.</p><p>Every time that the Renderer Process wants to perform a privileged action, it sends a request to the Browser Process over an IPC (Inter-Process Communication) channel.</p><p>The IPC functionality is implemented by Mojo, a collection of runtime libraries integrated into Chromium, that provides a platform-agnostic abstraction of common primitives, such as message passing, shared memory and platform handles.</p><p>The internal details of Mojo are not relevant for this blog post and are not necessary to follow the rest of the analysis. For more information, please refer to the <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/mojo/README.md">official documentation</a>.</p><h3 id="crossing-the-boundary">Crossing the Boundary</h3><p>In this case, the JavaScript call initiated by the web page will result in an IPC call from the renderer process to the SpeechSynthesis Mojo Interface, which is implemented by the browser process: <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/public/mojom/speech/speech_synthesis.mojom;l=1?q=speech_synthesis.mojom&amp;sq=&amp;ss=chromium%2Fchromium%2Fsrc">speech_synthesis.mojom - Chromium Code Search</a></p><p>Effectively, calling the speak JavaScript API crosses a privilege boundary, and any bug that we trigger in the browser code may allow an attacker to gain code execution outside of the context of the sandbox.</p><p>Chromium does not have a custom TTS engine, as such the SpeechSynthesis interface is just a wrapper around the platform-specific service.</p><p>In the case of Windows, the “speak” method will call into the <code>ISpVoice</code> COM interface, as can be seen here: <a href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/speech/tts_win.cc;l=302;drc=d708cc843536cc344f0f7679a978634cc14d6153;bpv=1;bpt=1">tts_win.cc - Chromium Code Search</a></p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>Microsoft</span><span>::</span><span>WRL</span><span>::</span><span>ComPtr</span><span>&lt;</span><span>ISpVoice</span><span>&gt;</span> <span>speech_synthesizer_</span><span>;</span>

<span>HRESULT</span> <span>result</span> <span>=</span> <span>speech_synthesizer_</span><span>-&gt;</span><span>Speak</span><span>(</span><span>merged_utterance</span><span>.</span><span>c_str</span><span>(),</span>
                                                <span>SPF_ASYNC</span><span>,</span> <span>&amp;</span><span>stream_number_</span><span>);</span>
</pre></td></tr></tbody></table></code></p></div><p>The (untrusted) data that is passed as an argument to the JavaScript call is forwarded as-is* to the browser process and used as argument for <code>ISpVoice::Speak</code> call.</p><p>* <em>Actually, it goes through some conversion process, from string to wide string, and some more characters are prepended to it, but it doesn’t really matter for the sake of this analysis.</em></p><h3 id="the-ispvoice-com-interface">The ISpVoice COM interface</h3><p>Windows offers a framework, called COM (Component Object Model), which allows different software components to communicate and interoperate with each other, regardless of their programming language.</p><p>Without getting too much into details, whenever an instance of ISpVoice object is used, like this:</p><div><p><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>speech_synthesizer_</span><span>-&gt;</span><span>Speak</span><span>(...);</span>
</pre></td></tr></tbody></table></code></p></div><p>the COM system framework (<code>combase.dll</code>) finds the path of the library which implements such interface and takes care of routing the call to the correct function.</p><p>In case of ISpVoice interface, the library which implements it resides in <code>C:\Windows\System32\Speech\Common\sapi.dll</code>.</p><p>This library will be dynamically loaded within the Browser Process memory <em>(for the readers who are familiar with COM: this is because the ISpVoice service is an in-process service).</em></p><p>The ISpVoice interface implements the Windows Speech API (SAPI) and is very well documented here <a href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ms720570(v=vs.85)">ISpVoice (SAPI 5.3) | Microsoft Learn</a></p><p>From the documentation we quickly learn that TTS engines are complex machines and not only support simple text but support a specific markup language based on XML that can be used to produce more accurate audio, specifying pitch, pronunciation, speaking rate, volume, and more. Such language is called SSML (<a href="https://www.w3.org/TR/speech-synthesis11/">Speech Synthesis Markup Language</a>) and it’s a standard for Text-to-Speech engines. Microsoft also extends this standard by offering an additional grammar, called SAPI XML grammar (<a href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ms717077(v=vs.85)">XML TTS Tutorial (SAPI 5.3) | Microsoft Learn</a>).</p><p>For example, one could use SAPI grammar like this:</p><div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>speechSynthesis</span><span>.</span><span>speak</span><span>(</span><span>new</span> <span>SpeechSynthesisUtterance</span><span>(</span><span>`&lt;volume level=&#34;50&#34;&gt;
This text should be spoken at volume level fifty.&lt;/volume&gt;`</span><span>);</span>
</pre></td></tr></tbody></table></code></p></div><p>The XML string passed as an argument ends up being parsed by the native library <code>sapi.dll</code>, which makes this a perfect target for vulnerability research.</p><p>This breaks the Chromium project <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/security/rule-of-2.md">Rule of 2</a> (indirectly using sapi.dll) because the OS library code is written in C++, it parses untrusted inputs, and it runs unsandboxed within the Browser process.</p><p>As emphasized before, a bug in this code might lead to a potential browser sandbox escape exploit. Moreover, being reachable directly from JavaScript, this would be one of those rare cases in which a sandbox escape could be achieved without compromising the Renderer process.</p><h2 id="fuzzing">Fuzzing</h2><p>Now that we have our target, we wanted to begin hunting for exploitable bugs. For our first approach, we decided to go for <a href="https://en.wikipedia.org/wiki/Fuzzing#Aware_of_program_structure">black box fuzzing</a> to get something running as quickly as possible and get feedback on how to iterate later.</p><p>We found out that, overall, the best choice for our case was <a href="https://github.com/googleprojectzero/Jackalope">Jackalope</a>, a fuzzer developed by Google Project Zero which supports coverage-guided black box fuzzing without much overhead and comes with a grammar engine which is especially useful to fuzz our SSML/SAPI parser.</p><p>Since we did not have any experience with the COM framework and how to interact with the ISpVoice service, we asked <a href="https://www.bing.com/search?q=Bing+AI&amp;showconv=1&amp;FORM=hpcodx">Bing Chat</a> to write a harness for us, it sped up our development and worked flawlessly.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/speech_synthesis/image2.png" alt=""/></p><p><em>Prompt: Create a simple C++ program using Windows SAPI API to speak an input string</em></p><p>Then, we modeled SAPI grammar and ran our harness using Jackalope as the main engine.</p><p>This approach quickly resulted in our first bug, which was found in less than a day of fuzzing (!)</p><p>However, we noticed that the coverage measured by Jackalope (Offsets) reached a plateau very quickly in just a few days as you can see from the comparison screenshot, and consequently corpus size also stopped growing.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/speech_synthesis/image8.png" alt=""/></p><p><em>Comparison of Jackalope coverage after 3 days.</em></p><p>This is probably because mutating the existing corpus could not yield new code paths without hitting the same bug, so we did not get any more interesting test cases after the first crash.</p><p>In parallel, we decided to try another approach: generation-based fuzzing with <a href="https://github.com/posidron/dharma">Dharma</a> (shout out to our colleague Christoph, who created it!).</p><p>Dharma is also a powerful solution, it&#39;s extremely quick and easy to set up and it’s not coverage guided. As such, it can generate huge test cases that extensively test all the grammar features right from the start. With this approach, we found again the same bug within a night of fuzzing.</p><h2 id="the-bug">The Bug</h2><p>The bug in question is reachable through the function <a href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ms719820(v=vs.85)">ISpVoice::Speak (SAPI 5.3)</a>, which takes as input an XML string that can support both tags specific to Microsoft SAPI format, and SSML (Speech Synthesis Markup Language) which is the standard for speech synthesis used by many other engines.</p><p>Looking at the source code of that function, we soon realized that the XML input goes through a 2-step processing:</p><ul><li>First, the XML string is parsed using the standard MSXML Windows library (msxml6.dll), looking for SSML tags.</li><li>If the first step fails for whatever reason (e.g. broken XML string, or unrecognized SSML tags), the code falls back to SAPI parsing, which is implemented using a custom XML parser (written in C++)</li></ul><p>Custom parsing of untrusted data is difficult and often results in exploitable security bugs. As you probably guessed, the bug we found resides in the latter part of the code.</p><p>When parsing a tag, the following struct is filled:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>#define MAX_ATTRS 10
</span><span>struct</span> <span>XMLTAG</span>
<span>{</span>
    <span>XMLTAGID</span>  <span>eTag</span><span>;</span>
    <span>XMLATTRIB</span> <span>Attrs</span><span>[</span><span>MAX_ATTRS</span><span>];</span>
    <span>int</span>       <span>NumAttrs</span><span>;</span>
    <span>bool</span>      <span>fIsStartTag</span><span>;</span>
    <span>bool</span>      <span>fIsGlobal</span><span>;</span>
<span>};</span>
</pre></td></tr></tbody></table></code></p></div><p>You may notice that the maximum number of attributes for each tag is set to 10. This is because according to the specification, there is no tag that requires that many.</p><p>Perhaps unsurprisingly, the bug happens when more than 10 attributes are used in a single XML tag, as no bounds checks are performed when adding them to the <code>Attrs</code> array, leading to a buffer overflow.</p><p>A simple PoC that could crash your browser process directly from JavaScript, on the vulnerable version of the library, is this:</p><div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>let</span> <span>text</span> <span>=</span> <span>`&lt;PARTOFSP PART=&#34;modifier&#34; PART=&#34;modifier&#34; PART=&#34;modifier&#34; PART=&#34;modifier&#34; PART=&#34;modifier&#34; PART=&#34;modifier&#34; PART=&#34;modifier&#34; PART=&#34;modifier&#34; PART=&#34;modifier&#34; PART=&#34;modifier&#34; PART=&#34;modifier&#34; PART=&#34;modifier&#34; &gt;&lt;/PARTOFSP&gt;`</span><span>;</span>
<span>speechSynthesis</span><span>.</span><span>speak</span><span>(</span><span>new</span> <span>SpeechSynthesisUtterance</span><span>(</span><span>text</span><span>));</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="the-overflow">The Overflow</h3><p>Trying to reproduce the bug on a vulnerable version of sapi.dll results in a crash due to invalid <code>rip</code> value and completely corrupted stack trace. This immediately points to a possible stack buffer overflow.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/speech_synthesis/image7.png" alt="The crash stack trace"/></p><p><em>WinDBG catching the browser crash.</em></p><p>The first thing we noticed was that the crash did not trigger the corruption of a stack canary. This discovery intrigued us, but we needed to gather more information before digging into this oddity.</p><p>In order to get to the root cause of the bug we wanted to use Time Travel Debugging to easily step backwards to the exact point where the stack got corrupted, we found something similar to this:</p><p><em>Note: we’re omitting the original code and using some equivalent snippets</em></p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>HRESULT</span> <span>CSpVoice</span><span>::</span><span>ParseXML</span><span>(</span><span>…</span><span>)</span>
<span>{</span>
    <span>...</span>
    <span>XMLTAG</span> <span>Tag</span><span>;</span> <span>// XMLTAG struct on the stack</span>
    <span>...</span> 
    <span>ParseTag</span><span>(</span><span>input_str</span><span>,</span> <span>&amp;</span><span>Tag</span><span>,</span> <span>...);</span> <span>// Call to the vulnerable function </span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>In the <code>ParseTag</code> function there is the loop that will parse every attribute and fill in the <code>&amp;Tag-&gt;</code><code>Attrs</code><code>[]</code> array and eventually write past its end:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td><pre><span>HRESULT</span> <span>ParseTag</span><span>(</span><span>wchar</span><span>*</span> <span>pStr</span><span>,</span>  <span>XMLTAG</span><span>*</span> <span>pTag</span><span>,</span> <span>…</span><span>)</span> <span>{</span>
    <span>// some code … //</span>
    <span>while</span> <span>(</span><span>hr</span> <span>==</span> <span>S_OK</span> <span>&amp;&amp;</span> <span>*</span><span>pStr</span><span>)</span> <span>{</span>
        <span>// Fill attribute name from the input string</span>
        <span>hr</span> <span>=</span> <span>FindAttr</span><span>(</span><span>pStr</span><span>,</span>
            <span>&amp;</span><span>pTag</span><span>-&gt;</span><span>Attrs</span><span>[</span><span>pTag</span><span>-&gt;</span><span>NumAttrs</span><span>].</span><span>eAttr</span><span>,</span>
            <span>&amp;</span><span>pStr</span><span>);</span>
        
        <span>if</span><span>(</span> <span>hr</span> <span>==</span> <span>S_OK</span> <span>)</span>
        <span>{</span>
            <span>// Fill attribute value</span>
            <span>hr</span> <span>=</span> <span>FindAttrVal</span><span>(</span><span>pStr</span><span>,</span>
                <span>&amp;</span><span>pTag</span><span>-&gt;</span><span>Attrs</span><span>[</span><span>pTag</span><span>-&gt;</span><span>NumAttrs</span><span>].</span><span>Value</span><span>.</span><span>pStr</span><span>,</span>
                <span>&amp;</span><span>pTag</span><span>-&gt;</span><span>Attrs</span><span>[</span><span>pTag</span><span>-&gt;</span><span>NumAttrs</span><span>].</span><span>Value</span><span>.</span><span>Len</span><span>,</span> 
                <span>&amp;</span><span>pStr</span><span>);</span>
            <span>if</span><span>(</span> <span>hr</span> <span>==</span> <span>S_OK</span> <span>)</span>
            <span>{</span>
                <span>++</span><span>pTag</span><span>-&gt;</span><span>NumAttrs</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><h3 id="stack-cookies-no-thanks">Stack cookies? No thanks</h3><p>At this point it’s clear that we had a stack buffer overflow, and we had a few questions:</p><ol><li>Why didn’t the process crash with a corrupted stack cookie?</li><li>We have control of RIP; is it exploitable? What other primitives does it give us?</li></ol><p>Regarding the first question, we wanted to know why we hadn’t triggered a stack canary exception despite clearly overflowing and corrupting the call stack. We dug out the source code from the OS repository and began to investigate. From the build scripts it was clear that the library was compiled with <code>/GS</code> (Stack Canaries). In disbelief, we opened the binary in IDA pro and saw the canary check in the relevant function.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/speech_synthesis/image5.png" alt="A screenshot of a computer Description automatically generated"/></p><p>It was clear that something fishy was going on and that more investigation was required.</p><p>Let’s start by recalling the structures involved here:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td><pre><span>struct</span> <span>XMLTAG</span>
<span>{</span>
    <span>XMLTAGID</span>  <span>eTag</span><span>;</span>
    <span>XMLATTRIB</span> <span>Attrs</span><span>[</span><span>MAX_ATTRS</span><span>];</span>
    <span>int</span>       <span>NumAttrs</span><span>;</span>
    <span>bool</span>      <span>fIsStartTag</span><span>;</span>
    <span>bool</span>      <span>fIsGlobal</span><span>;</span>
<span>};</span>

<span>struct</span> <span>XMLATTRIB</span>
<span>{</span>
    <span>XMLATTRID</span> <span>eAttr</span><span>;</span> <span>// enum that identifies the attribute name</span>
    <span>SPLSTR</span>     <span>Value</span><span>;</span> 
<span>};</span>

<span>struct</span> <span>SPLSTR</span>
<span>{</span>
    <span>WCHAR</span><span>*</span>  <span>pStr</span><span>;</span> <span>// wstring pointing to the attribute value</span>
    <span>int</span>     <span>Len</span><span>;</span> <span>// length of the attribute value</span>
<span>};</span>
</pre></td></tr></tbody></table></code></p></div><p>Our overflow allows us to write additional XMLATTRIB structures past the end of the <code>XMLTAG.Attrs</code> array. Serializing the members of this structure means we can effectively write content in chunks of 24 bytes as shown:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>XMLATTRID</span> <span>eAttr</span><span>;</span> <span>// 4 bytes enum (padded to 8)</span>
<span>WCHAR</span><span>*</span> <span>pStr</span><span>;</span> <span>// 8 bytes pointer that points to our controlled string</span>
<span>int</span> <span>len</span><span>;</span> <span>// 4 bytes controlled length (padded to 8)</span>
</pre></td></tr></tbody></table></code></p></div><p>What is the first thing we overwrite past the <code>Attrs</code> array?</p><p>It’s the <code>NumAttrs</code> field of <code>XMLTAG</code> structure. We can overlap it with any value from the possible <code>XMLATTRID</code> values. Those are chosen from the attribute name, and it can be any controlled value from 0 to 23.</p><p>Since <code>NumAttrs</code> is used by the vulnerable function to index the array, we can pick this number to cause a non-linear overflow and jump past the current frame’s stack cookie when overwriting the stack.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/speech_synthesis/image6.png" alt=""/></p><p>This is exactly what happened (accidentally) with our first PoC: the 11th attribute <code>PART</code> gets parsed into an XMLATTR structure with <code>eAttr</code> value higher than 10. That value overwrites <code>NumAttrs</code> and then the next attribute (12th attribute) actually overwrites directly the saved <code>rip</code> without touching the stack cookies.</p><p>We tried to modify the PoC by crafting a possible <code>rip</code> value and run on a machine with Intel CET enabled and it resulted in a crash related to shadow stack exception.</p><p>In fact, on most recent devices, overwriting <code>rip</code> wouldn’t be a feasible exploitation strategy because of shadow stack (<a href="https://techcommunity.microsoft.com/t5/windows-os-platform-blog/understanding-hardware-enforced-stack-protection/ba-p/1247815">Understanding Hardware-enforced Stack Protection</a>), which double checks the return address saved on the stack before jumping to it.</p><p>But it’s worth mentioning that most of the current Desktop users are not protected by this mitigation, since it was introduced only recently.</p><p>To summarize: stack canaries are ineffective, CET protection isn’t available on the average customer machine. How easy does it get for attackers?</p><p>Since this bug allows us to corrupt almost anything we want on the stack, even at deeper stack frames, we could look for more possible targets to overwrite, other than saved <code>rip</code>, and there are indeed some object pointers in the stack that we could overwrite, but we need to keep some limitations in mind.</p><p>There are two possible strategies here:</p><p>We can either overwrite a pointer with full qword (the <code>pStr</code> value, that points to our controlled wide string) and in that case we would be able to replace an object with almost arbitrary content.</p><p>However, crafting data, and especially pointers, will not be very feasible, since we can’t include any 2-nullbytes sequence (<code>\x00\x00</code>) because that is a null <em>wchar</em> and the xml parsing will stop early.</p><p>This makes it very hard (impossible?) to craft valid pointers within the controlled content. Moreover, apart from null bytes, there are other invalid byte sequences that will not be accepted as valid wide strings and would break the parsing early.</p><p>Alternatively, we could overwrite a value in the stack that is aligned with our controlled <code>len</code> field. In this case, since <code>len</code> is of type <code>int</code>, only the least significant 4 bytes will be overwritten, leaving the most significant part untouched.</p><p>Even here, to craft a valid pointer, we would need to have a huge length, which doesn’t work in practice.</p><p>Due to time constraints of the project, we didn’t explore exploitation possibilities further, but we believe that starting from a corrupted renderer, exploitation would be much more feasible given these primitives.</p><h2 id="keep-fuzzing-the-surface">Keep fuzzing the surface</h2><p>After the initial quick success and given the necessity to fix the first bug to keep fuzzing further, we decided to spend some time figuring out how to re-compile our target library sapi.dll with <a href="https://learn.microsoft.com/en-us/cpp/sanitizers/asan">ASAN (Address SANitizer)</a> and code coverage to test more effectively.</p><p>Having ASAN enables us to catch potential heap errors that would otherwise have been missed by PageHeap sanitizer (that we used during our first iteration). Plus, it gives detailed information for stack corruptions as well right-away, dramatically reducing debugging time in case we found more of those.</p><p>As mentioned earlier, the Windows Speech API is called from Chromium via the COM interface ISpVoice.</p><p>Our target DLL is not directly linked to the harness, but it is loaded at runtime by the COM framework, based on the path specified in the system registry for that COM CLSID.</p><p>To make our fuzzer simpler to deploy on other infrastructures such as <a href="https://github.com/microsoft/onefuzz">OneFuzz</a>, we decided to use <a href="https://github.com/microsoft/Detours">Detours</a> to hook LoadLibraryEx and replace the DLL path loaded from the system registry with the path of our instrumented DLL instead of modifying the registry.</p><p>Having the library built with ASAN and SANCOV allowed us to use any other fuzzer, such as Libfuzzer which is the standard de-facto (although deprecated).</p><p>Therefore, our second iteration consisted of rewriting and expanding the grammar for the coverage guided whitebox fuzzer. This was done using <a href="https://github.com/google/libprotobuf-mutator">LibProtobuf-Mutator</a>.</p><p>Nowadays, the fuzzer keeps running on our continuous fuzzing infrastructure using <a href="https://github.com/microsoft/onefuzz">OneFuzz</a> and keeps helping our engineers in fixing bugs on this surface.</p><h2 id="conclusion">Conclusion</h2><p>In this blog post, we have shown how we discovered and reported a critical bug on Windows that was reachable from the browser using the Web Speech API. We have explained how we used the SAPI XML grammar to craft malicious inputs that could trigger memory corruption in the <code>sapi.dll</code> library, which runs unsandboxed in the browser process.</p><p>Bugs like the one discussed here are particularly rare since, when exploited, lead to full compromise of the browser process without the need of additional bugs (normally you would need a chain of at least two bugs to gain control over the browser process).</p><p>Moreover, this bug would have been reachable from any Chromium based browser (Edge, Chrome, Brave Browser, and so on…) regardless of their version, which makes this case even more interesting.</p><p>One could wonder: were other browsers affected as well?</p><p>However, some browsers took slightly different approaches that might spare them from this bug. Firefox, for instance, does use <code>sapi.dll</code>, but it strips away XML tags from the input, at the cost of losing all the features that the SSML standard provides.</p><p>The need for modern browsers to interact with multiple OS components in order to offer rich functionalities (like speech synthesis, speech recognition, etc.) makes things harder for security, since third-party libraries are loaded in the browser process and often take inputs from untrusted sources.</p><p>In this case, we limited our analysis to the case of Windows platform and to the Speech API, but there might be other cases where a comparable situation occurs.</p><p>In the future, we plan to investigate more COM components used by browsers and perform audits to external libraries that are loaded in the Browser Process and may expose security risks.</p></div></div>
  </body>
</html>
