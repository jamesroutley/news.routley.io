<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marianogappa.github.io/software/2025/08/24/i-made-two-card-games-in-go/">Original</a>
    <h1>Making games in Go: 3 months without LLMs vs. 3 days with LLMs</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="introduction">Introduction</h2><p>After 15 years as a software engineer, I realized I had never actually built and published a game.</p><p>Since I grew up in üá¶üá∑ Argentina playing card games with my friends, I figured I‚Äôd choose one of those. I asked myself:</p><p><img src="https://marianogappa.github.io/images/posts/i-made-two-card-games-in-go/most-common.png" alt="most-common-card-games"/></p><h2 id="truco-3-months-without-llms">Truco: 3 Months Without LLMs</h2><p>On <a href="https://github.com/marianogappa/truco/commit/80ad842f546ac5bdf0d680d105afc10b66626d0f">June 18th of 2024</a> I started building <a href="https://en.wikipedia.org/wiki/Truco">Truco</a> in my free time. As a longtime Go backend developer, the backend was obvious. The challenge was the UI and long-term hosting without a paid server.</p><table><thead><tr><th>Problem</th><th>Solution</th></tr></thead><tbody><tr><td>UI</td><td>Bit the bullet and learned the minimal required <a href="https://reactjs.org/">React</a> for the UI.</td></tr><tr><td>No server</td><td>Transpiled the server to <a href="https://en.wikipedia.org/wiki/WebAssembly">WASM</a> using <a href="https://tinygo.org/">TinyGo</a>.</td></tr><tr><td>Hosting</td><td>Used <a href="https://pages.github.com/">GitHub Pages</a> to host the static files.</td></tr></tbody></table><p>This was pre-LLM, so every detail had to be figured out by hand. It took about 3 months of trial and error to get it ready.</p><p>I never planned to advertise or monetize it; I just wanted to finish, and maybe give someone the joy of playing their childhood game again. A year later, without any extra effort on my part, people are still playing it!</p><p><img src="https://marianogappa.github.io/images/posts/i-made-two-card-games-in-go/truco-analytics.png" alt="truco-analytics"/></p><p>In case you want to check it out, here are some links for it:</p><p><a href="https://marianogappa.github.io/truco-argentino">Truco (play the game)</a></p><p><a href="https://github.com/marianogappa/truco">Backend in Go</a></p><p><a href="https://github.com/marianogappa/truco-argentino">Frontend in React</a> (don‚Äôt judge me ü§∑‚Äç‚ôÇÔ∏è best I can do with 1-hour React knowledge)</p><h2 id="escoba-3-days-with-llms">‚ÄúEscoba‚Äù: 3 Days With LLMs</h2><p>A year later, visiting family in Argentina, I taught my nephew <a href="https://en.wikipedia.org/wiki/Escoba">Escoba</a>‚Äîthe country‚Äôs second most popular card game (despite what ChatGPT insists).</p><p><img src="https://marianogappa.github.io/images/posts/i-made-two-card-games-in-go/two-most-common.png" alt="two-most-common-card-games"/></p><p>With LLMs now mainstream, I wondered how much faster building a game might be‚Äîso I decided to test it.</p><p>I cloned the backend for Truco and gave <a href="https://claude.ai/">Claude</a> a long prompt explaining the rules of Escoba and asking it to refactor the code to implement it. To my surprise, it worked almost perfectly on the first prompt üò±. For a moment I thought: goodbye, job üò∞.</p><p><img src="https://marianogappa.github.io/images/posts/i-made-two-card-games-in-go/prompt.png" alt="prompt"/></p><p>The only bug I found was that it used <code>append</code> <a href="https://github.com/marianogappa/escoba/commit/e9c373a38cb2ca5e7eefca2870f91e7def1579f7#diff-8e38aecf51e5858a66646d328292fc8abf36f6a602ef3ea4ed7fc1ca2b1a0240L104-L105">incorrectly in one place and mutated actions</a>. Except for that, I only added a few bells and whistles on top (like <a href="https://github.com/marianogappa/escoba/commit/fe1c87bed8e9b60cc902dfc563c356506c2faf4c">a better bot</a>).</p><p>The frontend was a different story; it took me a few days to get it right. The real challenge probably wasn‚Äôt just the LLM ‚Äî it was my own React skills, combined with the unusual setup of letting a black-box WASM function manage game state. Debugging in JavaScript also didn‚Äôt make life easier.</p><p>In case you want to check it out, here are some links for it:</p><p><a href="https://marianogappa.github.io/escoba-de-15">Escoba (play the game)</a></p><p><a href="https://github.com/marianogappa/escoba">Backend in Go</a></p><p><a href="https://github.com/marianogappa/escoba-de-15">Frontend in React</a></p><h2 id="step-by-step-how-to-build-your-own-game">Step-by-Step: How to Build Your Own Game</h2><p>I‚Äôm assuming you might have come here to see if it‚Äôs not too hard to give it a try yourself! So I‚Äôll give you the minimalistic primer to make your own game with this stack.</p><p>I wrote a minimalistic Tic-Tac-Toe game set of repos so you can fork them to get started:</p><p><a href="https://github.com/marianogappa/tictactoe-backend">https://github.com/marianogappa/tictactoe-backend</a>
<a href="https://github.com/marianogappa/tictactoe-frontend">https://github.com/marianogappa/tictactoe-frontend</a></p><p>You can check it out here:</p><p><a href="https://marianogappa.github.io/tictactoe-frontend/">https://marianogappa.github.io/tictactoe-frontend/</a></p><p><img src="https://marianogappa.github.io/images/posts/i-made-two-card-games-in-go/tictactoe.png" alt="TicTacToe"/></p><h3 id="backend-side">Backend-side</h3><p>A turn-based backend is straightforward to outline:</p><ul><li><a href="https://github.com/marianogappa/truco/blob/v0.2.0/truco/truco.go#L157">Initialize</a> a <a href="https://github.com/marianogappa/truco/blob/v0.2.0/truco/truco.go#L16">GameState struct</a> (e.g. initial board setup, empty actions list).</li><li>Implement <a href="https://github.com/marianogappa/truco/blob/v0.2.0/truco/truco.go#L378"><code>CalculatePossibleActions</code></a>, so clients know what‚Äôs valid.</li><li>Add <a href="https://github.com/marianogappa/truco/blob/v0.2.0/truco/truco.go#L213">RunAction</a> to mutate the GameState.</li><li>If there‚Äôs a bot, write a function to <a href="https://github.com/marianogappa/truco/blob/v0.2.0/examplebot/newbot/bot.go#L38">pick an action</a> from the current state.</li></ul><p>That‚Äôs it!</p><p><em>Note: forget human vs human, unless you‚Äôre willing to pay for that server.</em></p><h3 id="frontend-side">Frontend-side</h3><p>I‚Äôm no frontend expert, but the tasks are simple:</p><ul><li>Call the backend to create a new <code>GameState</code>.</li><li>Render it in the UI.</li><li>Let the player pick an action from the valid options.</li><li>Call the backend to apply the action.</li><li>Trigger the bot‚Äôs action when it‚Äôs their turn.</li></ul><p>That‚Äôs it!</p><h3 id="backend-side-interop">Backend-side interop</h3><p>To transpile the backend to WASM, you can build with (docs <a href="https://go.dev/wiki/WebAssembly">here</a>):</p><div><pre tabindex="0"><code data-lang="bash"><span><span>GOARCH<span>=</span>wasm GOOS<span>=</span>js go build -o main.wasm main.go
</span></span></code></pre></div><p>But that produces huge binaries (which is slow on mobile). Use <a href="https://tinygo.org/">TinyGo</a> for smaller ones.</p><p>Before compiling, you need a different entrypoint to the functions that you‚Äôre going to make available to the frontend. <a href="https://github.com/marianogappa/truco/blob/v0.2.0/main_wasm.go">Make a different <code>main.go</code></a> file that exports the functions that you need, and <a href="https://github.com/marianogappa/truco/blob/v0.2.0/main_wasm.go#L2">guard it via build flags</a>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>//go:build tinygo</span>
</span></span><span><span><span>// +build tinygo</span>
</span></span><span><span>
</span></span><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span>[<span>...</span>]
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span>() {
</span></span><span><span>	<span>js</span>.<span>Global</span>().<span>Set</span>(<span>&#34;trucoNew&#34;</span>, <span>js</span>.<span>FuncOf</span>(<span>trucoNew</span>))
</span></span><span><span>	<span>js</span>.<span>Global</span>().<span>Set</span>(<span>&#34;trucoRunAction&#34;</span>, <span>js</span>.<span>FuncOf</span>(<span>trucoRunAction</span>))
</span></span><span><span>	<span>js</span>.<span>Global</span>().<span>Set</span>(<span>&#34;trucoBotRunAction&#34;</span>, <span>js</span>.<span>FuncOf</span>(<span>trucoBotRunAction</span>))
</span></span><span><span>	<span>select</span> {}
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>var</span> (
</span></span><span><span>	<span>state</span> <span>*</span><span>truco</span>.<span>GameState</span> <span>// &#34;Global variable&#34; for the GameState</span>
</span></span><span><span>	<span>bot</span>   <span>truco</span>.<span>Bot</span>
</span></span><span><span>)
</span></span></code></pre></div><p>Don‚Äôt forget to block at the end of <code>main()</code> with <code>select {}</code> to prevent the program from exiting immediately.</p><h3 id="backend-data-interop">Backend data interop</h3><p><code>GameState</code> is typically a free-form struct that you define in Go. WASM can‚Äôt directly serialize/deserialize structs. The trick is to pass everything as JSON. After digging through <a href="https://tinygo.org/docs/guides/webassembly/">TinyGo docs</a>, here‚Äôs the formula:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>trucoRunAction</span>(<span>this</span> <span>js</span>.<span>Value</span>, <span>p</span> []<span>js</span>.<span>Value</span>) <span>interface</span>{} { <span>// Always this signature</span>
</span></span><span><span>	<span>// Read the input JSON</span>
</span></span><span><span>    <span>jsonBytes</span> <span>:=</span> make([]<span>byte</span>, <span>p</span>[<span>0</span>].<span>Length</span>()) 
</span></span><span><span>	<span>js</span>.<span>CopyBytesToGo</span>(<span>jsonBytes</span>, <span>p</span>[<span>0</span>])
</span></span><span><span>
</span></span><span><span>	<span>// 1. Decode the input JSON to your struct</span>
</span></span><span><span>    <span>// 2. Run your Go code, return an output struct</span>
</span></span><span><span>	<span>// 3. Encode the output struct to JSON</span>
</span></span><span><span>	<span>newBytes</span> <span>:=</span> <span>_runAction</span>(<span>jsonBytes</span>)
</span></span><span><span>
</span></span><span><span>	<span>// Return the output JSON</span>
</span></span><span><span>	<span>buffer</span> <span>:=</span> <span>js</span>.<span>Global</span>().<span>Get</span>(<span>&#34;Uint8Array&#34;</span>).<span>New</span>(len(<span>newBytes</span>))
</span></span><span><span>	<span>js</span>.<span>CopyBytesToJS</span>(<span>buffer</span>, <span>newBytes</span>)
</span></span><span><span>	<span>return</span> <span>buffer</span>
</span></span><span><span>}
</span></span></code></pre></div><h3 id="frontend-side-interop">Frontend-side interop</h3><p>Finally, <a href="https://github.com/marianogappa/truco-argentino/blob/main/public/index.html#L45">call the backend functions from the frontend</a> and [track the GameState in a global variable]((<a href="https://github.com/marianogappa/truco-argentino/blob/main/src/gameState.js#L19)">https://github.com/marianogappa/truco-argentino/blob/main/src/gameState.js#L19)</a>:</p><div><pre tabindex="0"><code data-lang="js"><span><span><span>function</span> <span>jsRunAction</span>(<span>data</span>) {
</span></span><span><span>    <span>const</span> <span>encoder</span> <span>=</span> <span>new</span> <span>TextEncoder</span>();
</span></span><span><span>    <span>const</span> <span>encodedData</span> <span>=</span> <span>encoder</span>.<span>encode</span>(<span>JSON</span>.<span>stringify</span>(<span>data</span>));
</span></span><span><span>    <span>const</span> <span>result</span> <span>=</span> <span>trucoRunAction</span>(<span>encodedData</span>);
</span></span><span><span>    <span>const</span> <span>json</span> <span>=</span> <span>new</span> <span>TextDecoder</span>().<span>decode</span>(<span>result</span>);
</span></span><span><span>    <span>return</span> <span>JSON</span>.<span>parse</span>(<span>json</span>);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>let</span> <span>gameState</span> <span>=</span> <span>jsNewGame</span>();
</span></span><span><span>
</span></span><span><span><span>// Note that RunAction doesn&#39;t take a GameState.
</span></span></span><span><span><span>// WASM is the source of truth; your frontend can&#39;t mutate it.
</span></span></span><span><span><span></span><span>gameState</span> <span>=</span> <span>jsRunAction</span>(<span>action</span>); 
</span></span></code></pre></div><p>Every time you modify the backend, you need to recompile it to WASM and replace the old file in the frontend. I put this in <a href="https://github.com/marianogappa/escoba-de-15/blob/main/Makefile">the Makefile</a>:</p><pre tabindex="0"><code>compile_library:
	cd $(GOPATH)/src/github.com/marianogappa/escoba &amp;&amp; \
	TINYGOROOT=/usr/local/Cellar/tinygo/0.38.0 tinygo build -o main.wasm -target wasm main_wasm.go &amp;&amp; \
	mv main.wasm $(CURDIR)/public/wasm/wasm.wasm &amp;&amp; \
	cp /usr/local/Cellar/tinygo/0.38.0/targets/wasm_exec.js $(CURDIR)/public/wasm/wasm_exec.js &amp;&amp; \
	cd -
</code></pre><p>Note that I‚Äôm also copying over <code>wasm_exec.js</code>. This is a requirement for running WASM code. The other requirement is to add the <a href="https://github.com/marianogappa/truco-argentino/blob/main/public/index.html#L16">script tag to the HEAD of the HTML file</a>:</p><div><pre tabindex="0"><code data-lang="html"><span><span>
</span></span><span><span>    &lt;<span>script</span> <span>src</span><span>=</span><span>&#34;wasm/wasm_exec.js&#34;</span>&gt;&lt;/<span>script</span>&gt;
</span></span><span><span>	&lt;<span>script</span>&gt;
</span></span><span><span>        <span>const</span> <span>go</span> <span>=</span> <span>new</span> <span>Go</span>(); <span>// Defined in wasm_exec.js
</span></span></span><span><span><span></span>        <span>const</span> <span>WASM_URL</span> <span>=</span> <span>&#39;wasm/wasm.wasm&#39;</span>;
</span></span><span><span>
</span></span><span><span>        <span>var</span> <span>wasm</span>;
</span></span><span><span>        <span>let</span> <span>wasmReady</span> <span>=</span> <span>false</span>;
</span></span><span><span>
</span></span><span><span>        <span>if</span> (<span>&#39;instantiateStreaming&#39;</span> <span>in</span> <span>WebAssembly</span>) {
</span></span><span><span>            <span>WebAssembly</span>.<span>instantiateStreaming</span>(<span>fetch</span>(<span>WASM_URL</span>), <span>go</span>.<span>importObject</span>).<span>then</span>(<span>function</span> (<span>obj</span>) {
</span></span><span><span>                <span>wasm</span> <span>=</span> <span>obj</span>.<span>instance</span>;
</span></span><span><span>                <span>go</span>.<span>run</span>(<span>wasm</span>);
</span></span><span><span>                <span>wasmReady</span> <span>=</span> <span>true</span>;
</span></span><span><span>            })
</span></span><span><span>        } <span>else</span> {
</span></span><span><span>            <span>fetch</span>(<span>WASM_URL</span>).<span>then</span>(<span>resp</span> =&gt;
</span></span><span><span>                <span>resp</span>.<span>arrayBuffer</span>()
</span></span><span><span>            ).<span>then</span>(<span>bytes</span> =&gt;
</span></span><span><span>                <span>WebAssembly</span>.<span>instantiate</span>(<span>bytes</span>, <span>go</span>.<span>importObject</span>).<span>then</span>(<span>function</span> (<span>obj</span>) {
</span></span><span><span>                    <span>wasm</span> <span>=</span> <span>obj</span>.<span>instance</span>;
</span></span><span><span>                    <span>go</span>.<span>run</span>(<span>wasm</span>);
</span></span><span><span>                    <span>wasmReady</span> <span>=</span> <span>true</span>;
</span></span><span><span>                })
</span></span><span><span>            )
</span></span><span><span>        }
</span></span><span><span>    &lt;/<span>script</span>&gt;
</span></span></code></pre></div><h2 id="troubleshooting">Troubleshooting</h2><h3 id="the-wasm-file-is-not-loading">The WASM file is not loading</h3><p>This works automatically in Github Pages, but locally, you need to serve the files over HTTP. You can use <a href="https://www.npmjs.com/package/http-server">http-server</a> for this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>npx http-server ./public -p <span>8080</span>
</span></span></code></pre></div><p>And then visit <code>http://localhost:8080</code> in your browser.</p><h2 id="conclusion">Conclusion</h2><p>I had a lot of fun making these games and I hope you find it interesting to see how it works. I also hope you find it useful to make your own games! If you have questions, I‚Äôm not hard to find.</p><p><img src="https://marianogappa.github.io/images/posts/i-made-two-card-games-in-go/escoba.png" alt="escoba"/></p></div></div>
  </body>
</html>
