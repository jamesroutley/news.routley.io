<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codon.org.uk/~mjg59/blog/p/what-is-a-pc-compatible/">Original</a>
    <h1>What Is a PC Compatible?</h1>
    
    <div id="readability-page-1" class="page"><article>
    <header>

    

</header>

    <section>
    
    
    <p>Wikipedia says <a href="https://en.wikipedia.org/wiki/IBM_PC_compatible" target="_blank" rel="noopener">“An IBM PC compatible is any personal computer that is hardware- and software-compatible with the IBM Personal Computer (IBM PC) and its subsequent models”</a>. But what does this <em>actually</em> mean? The obvious literal interpretation is for a device to be PC compatible, all software originally written for the IBM 5150 must run on it. Is this a reasonable definition? Is it one that any modern hardware can meet?</p>
<p>Before we dig into that, let’s go back to the early days of the x86 industry. IBM had launched the PC built almost entirely around off-the-shelf Intel components, and shipped full schematics in the <a href="https://bitsavers.org/pdf/ibm/pc/pc/6025008_PC_Technical_Reference_Aug81.pdf" target="_blank" rel="noopener">IBM PC Technical Reference Manual</a>. Anyone could buy the same parts from Intel and build a compatible board. They’d still need an operating system, but Microsoft was happy to sell MS-DOS to anyone who’d turn up with money. The only thing stopping people from cloning the entire board was the BIOS, the component that sat between the raw hardware and much of the software running on it. The concept of a BIOS originated in <a href="https://en.wikipedia.org/wiki/CP/M" target="_blank" rel="noopener">CP/M</a>, an operating system originally written in the 70s for systems based on the Intel 8080. At that point in time there was no meaningful standardisation - systems might use the same CPU but otherwise have entirely different hardware, and any software that made assumptions about the underlying hardware wouldn’t run elsewhere. CP/M’s BIOS was effectively an abstraction layer, a set of code that could be modified to suit the specific underlying hardware without needing to modify the rest of the OS. As long as applications only called BIOS functions, they didn’t need to care about the underlying hardware and would run on all systems that had a working CP/M port.</p>
<p>By 1979, boards based on the 8086, Intel’s successor to the 8080, were hitting the market. The 8086 wasn’t machine code compatible with the 8080, but 8080 assembly code could be assembled to 8086 instructions to simplify porting old code. Despite this, the 8086 version of CP/M was taking some time to appear, and a company called <a href="https://en.wikipedia.org/wiki/Seattle_Computer_Products" target="_blank" rel="noopener">Seattle Computer Products</a> started producing a new OS closely modelled on CP/M and using the same BIOS abstraction layer concept. When IBM started looking for an OS for their upcoming 8088 (an 8086 with an 8-bit data bus rather than a 16-bit one) based PC, a complicated chain of events resulted in Microsoft paying a one-off fee to Seattle Computer Products, porting their OS to IBM’s hardware, and the rest is history.</p>
<p>But one key part of this was that despite what was now MS-DOS existing only to support IBM’s hardware, the BIOS abstraction remained, and the BIOS was owned by the hardware vendor - in this case, IBM. One key difference, though, was that while CP/M systems typically included the BIOS on boot media, IBM integrated it into ROM. This meant that MS-DOS floppies didn’t include all the code needed to run on a PC - you needed IBM’s BIOS. To begin with this wasn’t obviously a problem in the US market since, in a way that seems <em>extremely</em> odd from where we are now in history, it wasn’t clear that machine code was actually copyrightable. In 1982 <a href="https://law.justia.com/cases/federal/appellate-courts/F2/685/870/301267/" target="_blank" rel="noopener">Williams v. Artic</a> determined that it could be even if fixed in ROM - this ended up having broader industry impact in <a href="https://en.wikipedia.org/wiki/Apple_Computer,_Inc._v._Franklin_Computer_Corp." target="_blank" rel="noopener">Apple v. Franklin</a> and it became clear that clone machines making use of the original vendor’s ROM code wasn’t going to fly. Anyone wanting to make hardware compatible with the PC was going to have to find another way.</p>
<p>And here’s where things diverge somewhat. Compaq famously performed clean-room reverse engineering of the IBM BIOS to produce a functionally equivalent implementation without violating copyright. Other vendors, well, were less fastidious - they came up with BIOS implementations that either implemented a subset of IBM’s functionality, or didn’t implement all the same behavioural quirks, and compatibility was restricted. In this era several vendors shipped customised versions of MS-DOS that supported different hardware (which you’d think wouldn’t be necessary given that’s what the BIOS was for, but still), and the set of PC software that would run on their hardware varied wildly. This was the era where vendors even shipped systems based on the <a href="https://en.wikipedia.org/wiki/Intel_80186" target="_blank" rel="noopener">Intel 80186</a>, an improved 8086 that was both faster than the 8086 at the same clock speed and was also available at higher clock speeds. Clone vendors saw an opportunity to ship hardware that outperformed the PC, and some of them went for it.</p>
<p>You’d think that IBM would have immediately jumped on this as well, but no - the 80186 integrated many components that were separate chips on 8086 (and 8088) based platforms, but crucially didn’t maintain compatibility. As long as everything went via the BIOS this shouldn’t have mattered, but there were <em>many</em> cases where going via the BIOS introduced performance overhead or simply didn’t offer the functionality that people wanted, and since this was the era of single-user operating systems with no memory protection, there was nothing stopping developers from just hitting the hardware directly to get what they wanted. Changing the underlying hardware would break them.</p>
<p>And that’s what happened. IBM was the biggest player, so people targeted IBM’s platform. When BIOS interfaces weren’t sufficient they hit the hardware directly - and even if they weren’t doing that, they’d end up depending on behavioural quirks of IBM’s BIOS implementation. The market for DOS-compatible but not PC-compatible mostly vanished, although there were notable exceptions - in Japan the <a href="https://en.wikipedia.org/wiki/PC-98" target="_blank" rel="noopener">PC-98</a> platform achieved significant success, largely as a result of the Japanese market being pretty distinct from the rest of the world at that point in time, but also because it actually handled Japanese at a point where the PC platform was basically restricted to ASCII or minor variants thereof.</p>
<p>So, things remained fairly stable for some time. Underlying hardware changed - the 80286 introduced the ability to access more than a megabyte of address space and would promptly have broken a bunch of things except IBM came up with an utterly terrifying hack that bit me <a href="https://mjg59.livejournal.com/118098.html" target="_blank" rel="noopener">back in 2009</a>, and which ended up sufficiently codified into Intel design that it was one mechanism for <a href="https://connortumbleson.com/2021/07/19/the-xbox-and-a20-line/" target="_blank" rel="noopener">breaking the original XBox security</a>. The first 286 PC even introduced a new keyboard controller that supported better keyboards but which remained backwards compatible with the original PC to avoid breaking software. Even when IBM launched the PS/2, the first significant rearchitecture of the PC platform with a brand new expansion bus and associated patents to prevent people cloning it without paying off IBM, they made sure that all the hardware was backwards compatible.
For decades, PC compatibility meant not only supporting the officially supported interfaces, it meant supporting the underlying hardware. This is what made it possible to ship install media that was expected to work on any PC, even if you’d need some additional media for hardware-specific drivers. It’s something that still distinguishes the PC market from the ARM desktop market. But it’s not as true as it used to be, and it’s interesting to think about whether it ever was as true as people thought.</p>
<p>Let’s take an extreme case. If I buy a modern laptop, can I run 1981-era DOS on it? The answer is clearly no. First, modern systems largely don’t implement the legacy BIOS. The entire abstraction layer that DOS relies on isn’t there, having been replaced with UEFI. When UEFI first appeared it generally shipped with a Compatibility Services Module, a layer that would translate BIOS interrupts into UEFI calls, allowing vendors to ship hardware with more modern firmware and drivers without having to duplicate them to support older operating systems<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. Is this system PC compatible? By the strictest of definitions, no.</p>
<p>Ok. But the hardware is broadly the same, right? There’s projects like <a href="https://github.com/FlyGoat/CSMWrap" target="_blank" rel="noopener">CSMWrap</a> that allow a CSM to be implemented on top of stock UEFI, so everything that hits BIOS should work just fine. And well yes, assuming they implement the BIOS interfaces fully, anything using the BIOS interfaces will be happy. But what about stuff that doesn’t? Old software is going to expect that my <a href="https://en.wikipedia.org/wiki/Sound_Blaster" target="_blank" rel="noopener">Sound Blaster</a> is going to be on a limited set of IRQs and is going to assume that it’s going to be able to install its own interrupt handler and ACK those on the interrupt controller itself and that’s really not going to work when you have a PCI card that’s been mapped onto some <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller" target="_blank" rel="noopener">APIC</a> vector, and also if your keyboard is attached via USB or SPI then reading it via the CSM will work (because it’s calling into UEFI to get the actual data) but trying to read the keyboard controller directly won’t<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>, so you’re still actually relying on the firmware to do the right thing but it’s not, because the average person who wants to run DOS on a modern computer owns three fursuits and some knee length socks and while you are important and vital and I love you all you’re not enough to actually convince a transglobal megacorp to flip the bit in the chipset that makes all this old stuff work.</p>
<p>But imagine you are, or imagine you’re the sort of person who (like me) thinks writing their own firmware for their weird Chinese Thinkpad knockoff motherboard is a good and sensible use of their time - can you make this work fully? Haha no of course not. Yes, you can probably make sure that the PCI Sound Blaster that’s plugged into a Thunderbolt dock has interrupt routing to something that is absolutely no longer an <a href="https://en.wikipedia.org/wiki/Intel_8259" target="_blank" rel="noopener">8259</a> but is pretending to be so you can just handle IRQ 5 yourself, and you can probably still even write some SMM code that will make your keyboard work, but what about the corner cases? What if you’re trying to run something <a href="https://www.os2museum.com/wp/the-a20-gate-it-wasnt-wordstar/" target="_blank" rel="noopener">built with IBM Pascal 1.0</a>? There’s a risk that it’ll assume that trying to access an address just over 1MB will give it the data stored just above 0, and now it’ll break. It’d work fine on an actual PC, and it won’t work here, so are we PC compatible?</p>
<p>That’s a very interesting abstract question and I’m going to entirely ignore it. Let’s talk about PC graphics<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>. The original PC shipped with two different optional graphics cards - the <a href="https://en.wikipedia.org/wiki/IBM_Monochrome_Display_Adapter" target="_blank" rel="noopener">Monochrome Display Adapter</a> and the <a href="https://en.wikipedia.org/wiki/Color_Graphics_Adapter" target="_blank" rel="noopener">Color Graphics Adapter</a>. If you wanted to run games you were doing it on CGA, because MDA had no mechanism to address individual pixels so you could only render full characters. So, even on the original PC, there was software that would run on some hardware but not on other hardware.</p>
<p>Things got worse from there. CGA was, to put it mildly, shit. Even IBM knew this - in 1984 they launched the <a href="https://en.wikipedia.org/wiki/IBM_PCjr" target="_blank" rel="noopener">PCjr</a>, intended to make the PC platform more attractive to home users. As well as maybe the worst keyboard ever to be associated with the IBM brand, IBM added some new video modes that allowed displaying more than 4 colours on screen at once<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>, and software that depended on that wouldn’t display correctly on an original PC. Of course, because the PCjr was a complete commercial failure, it wouldn’t display correctly on any future PCs either. This is going to become a theme.</p>
<p>There’s never been a properly specified PC graphics platform. BIOS support for advanced graphics modes<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> ended up specified by <a href="https://en.wikipedia.org/wiki/VESA_BIOS_Extensions" target="_blank" rel="noopener">VESA</a> rather than IBM, and even then getting good performance involved hitting hardware directly. It wasn’t until Microsoft specced <a href="https://en.wikipedia.org/wiki/DirectX" target="_blank" rel="noopener">DirectX</a> that anything was broadly usable even if you limited yourself to Microsoft platforms, and this was an OS-level API rather than a hardware one. If you stick to BIOS interfaces then CGA-era code will work fine on graphics hardware produced up until the 20-teens, but if you were trying to hit CGA hardware registers directly then you’re going to have a bad time. This isn’t even a new thing - even if we restrict ourselves to the authentic IBM PC range (and ignore the PCjr), by the time we get to the <a href="https://en.wikipedia.org/wiki/Enhanced_Graphics_Adapter" target="_blank" rel="noopener">Enhanced Graphics Adapter</a> we’re <a href="https://www.vogons.org/viewtopic.php?t=44444" target="_blank" rel="noopener">not entirely CGA compatible</a>. Is an IBM PC/AT with EGA PC compatible? You’d likely say “yes”, but there’s software written for the original PC that won’t work there.</p>
<p>And, well, let’s go even more basic. The original PC had a well defined CPU frequency and a well defined CPU that would take a well defined number of cycles to execute any given instruction. People could write software that depended on that. When CPUs got faster, some software broke. This resulted in systems with a <a href="https://en.wikipedia.org/wiki/Turbo_button" target="_blank" rel="noopener">Turbo Button</a> - a button that would drop the clock rate to something approximating the original PC so stuff would stop breaking. It’s fine, we’d later end up with <a href="https://www.os2museum.com/wp/those-win9x-crashes-on-fast-machines/" target="_blank" rel="noopener">Windows crashing on fast machines</a> because hardware details will absolutely bleed through.</p>
<p>So, what’s a PC compatible? No modern PC will run the DOS that the original PC ran. If you try hard enough you can get it into a state where it’ll run most old software, as long as it doesn’t have assumptions about memory segmentation or your CPU or want to talk to your GPU directly. And even then it’ll potentially be unusable or crash because time is hard.</p>
<p>The truth is that there’s no way we can technically describe a PC Compatible now - or, honestly, ever. If you sent a modern PC back to 1981 the media would be amazed and also point out that it didn’t run Flight Simulator. “PC Compatible” is a socially defined construct, just like “Woman”. We can get hung up on the details or we can just chill.</p>


</section>


    


    
</article></div>
  </body>
</html>
