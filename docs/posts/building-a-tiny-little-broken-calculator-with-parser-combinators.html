<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jfo.click/building-a-tiny-little-broken-calculator-with-parser-combinators">Original</a>
    <h1>Building a tiny little broken calculator with parser combinators</h1>
    
    <div id="readability-page-1" class="page"><div><p>Perhaps I have a string lying around somewhere...</p>

<pre><code><span>const</span> testString = <span>&#34;Abcd123&#34;</span>;
</code></pre>
<p>What a lovely little string.</p>
<p>I will start with a function that takes a string as input and tells you if the
input passes some test you&#39;ve set out for it. This is not yet a parser, not
really. Usually, a parser does quite a lot more than simply return a boolean,
but at its most basic, it <em>must</em> make this binary distinction between</p>

<ol>
<li>Input that matches</li>
<li>Input that does not match</li>
</ol>
<p>So conceptually, this is a good place to start.</p>

<pre><code><span>const</span> <span>aParser</span> = input =&gt; input === <span>&#34;Abcd123&#34;</span>
<span>aParser</span>(testString); 

<span>const</span> <span>anotherParser</span> = input =&gt; input === <span>&#34;something else&#34;</span>
<span>anotherParser</span>(testString); 
</code></pre>
<p>That&#39;s not very interesting. Maybe a more interesting question?</p>

<pre><code><span>const</span> <span>aMoreInterestingParser</span> = input =&gt; input[<span>0</span>] === <span>&#34;A&#34;</span>
<span>aMoreInterestingParser</span>(testString); 
<span>aMoreInterestingParser</span>(<span>&#34;Aadjfiojda&#34;</span>); 
</code></pre>
<p>But what now? What do we <em>do</em> with this return value? It would be more useful
if the return value included something else that can be acted upon, like the
remaining portion of the input...</p>
<p>I can do this quite simply as a little informal tuple:</p>

<pre><code><span>const</span> <span>aBetterAndMoreInterestingParser</span> = input =&gt;
  [
    input[<span>0</span>] === <span>&#34;A&#34;</span>,
    input.<span>slice</span>(<span>1</span>, input.<span>length</span>)
  ]
<span>aBetterAndMoreInterestingParser</span>(<span>&#34;Aadjfiojda&#34;</span>); 
<span>aBetterAndMoreInterestingParser</span>(<span>&#34;Zadjfiojda&#34;</span>); 
</code></pre>
<p>But wait, what if the parser <em>fails</em>? We don&#39;t want to keep parsing the input from
there, we want to try the same place again, don&#39;t we? Then the &#34;remaining
input&#34; should include the current character in this case:</p>

<pre><code><span>const</span> <span>aBetterAndMoreInterestingParser</span> = input =&gt; {
  <span>if</span> (input[<span>0</span>] === <span>&#34;A&#34;</span>) {
    <span>return</span> [<span>true</span>, input.<span>slice</span>(<span>1</span>, input.<span>length</span>)]
  } <span>else</span> {
    <span>return</span> [<span>false</span>, input]
  }
}
<span>aBetterAndMoreInterestingParser</span>(<span>&#34;Aadjfiojda&#34;</span>); 
<span>aBetterAndMoreInterestingParser</span>(<span>&#34;Zadjfiojda&#34;</span>); 
</code></pre>
<h2 id="parser-generators">Parser Generators</h2>
<p>A <em>parser generator</em> is a function that returns a parser. Maybe you give it
some input and it decides what to match based on that...</p>

<pre><code><span>const</span> <span>parseChar</span> = char =&gt;
  <span><span>input</span> =&gt;</span> [
    input[<span>0</span>] === char,
    input.<span>slice</span>(<span>1</span>, input.<span>length</span>)
  ];

<span>const</span> parseA = <span>parseChar</span>(<span>&#39;A&#39;</span>);
<span>const</span> parseA = <span>parseChar</span>(<span>&#39;B&#39;</span>);
<span>parseA</span>(testString) 
<span>parseB</span>(testString) 
</code></pre>
<p>Wait wait, I want to back up a bit. I&#39;m describing all these things in plain
english, but I can describe them more succinctly and completely using a type
system. Perhaps I have one of those lying around somewhere...</p>
<h2 id="describing-with-types">Describing with types</h2>
<p>So in this initial (but as of yet incomplete) formulation, a &#34;parser&#34; is a
function that takes a string as input and tells you if the input passes some
test you&#39;ve set out for it. For now, let&#39;s pretend that input is always a
string. It could be binary data or streaming data or some other abstraction
over data, but for now, let&#39;s stick with strings.</p>

<pre><code><span>type</span> <span>Parser</span> = <span>(<span>s: <span>string</span></span>) =&gt;</span> <span>boolean</span>;
</code></pre>
<p>Actually, speaking of &#34;other abstractions over data&#34;, here&#39;s a trick... instead
of passing the string around over and over again, I will pass around an object
that references that string and holds and index denoting where the parsing has
progressed to.</p>

<pre><code><span>type</span> <span>Stream</span> = {
  <span>src</span>: <span>string</span>;
  <span>idx</span>: <span>number</span>;
};
<span>type</span> <span>Parser</span> = <span>(<span>s: Stream</span>) =&gt;</span> <span>boolean</span>;
</code></pre>
<blockquote>
<p>This is pretty similar to how the <code>FILE</code> struct in the C standard library works...</p>

<pre><code>
<span>typedef</span>    <span><span>struct</span> __<span>sFILE</span> {</span>
    <span>unsigned</span> <span>char</span> *_p;    
 
} FILE;
</code></pre>
</blockquote>
<p>Again, these should be composable (<em>much</em> more on that later), so the parser
should itself return a stream with its index advanced.</p>

<pre><code><span>type</span> <span>Stream</span> = {
  <span>src</span>: <span>string</span>;
  <span>idx</span>: <span>number</span>;
};
<span>type</span> <span>Parser</span> = <span>(<span>s: Stream</span>) =&gt;</span> <span>Stream</span>;
</code></pre>
<p>What happens if the parser does not match the input?</p>

<pre><code><span>type</span> <span>Stream</span> = {
  <span>src</span>: <span>string</span>;
  <span>idx</span>: <span>number</span>;
};
<span>type</span> <span>Result</span> = <span>Stream</span> | <span>undefined</span>;
<span>type</span> <span>Parser</span> = <span>(<span>s: Stream</span>) =&gt;</span> <span>Result</span>;
</code></pre>
<p>For the moment, I will return <code>undefined</code> for that case, so a <code>Result</code> is a
union type that can either be another <code>Stream</code> or <code>undefined</code>.</p>
<blockquote>
<p>Yes I know this is a poor imitation of <code>Maybe</code>. We&#39;ll get there, maybe.</p>
</blockquote>
<p>So again, a generator is a function that takes some input and returns a <code>Parser</code>. For the
moment, let&#39;s assume that input is also going to be a string, although for
generators, it could really be anything as long as the output is a <code>Parser</code>.</p>

<pre><code><span>type</span> <span>Generator</span> = <span>(<span>s: <span>string</span></span>) =&gt;</span> <span>Parser</span>;
</code></pre>
<p>Ok enough with the types, what do these look like in practice?</p>

<pre><code><span>const</span> <span>char</span>: <span>Generator</span> = <span>(<span>char</span>) =&gt;</span>
  <span>(<span>{ src, idx }</span>) =&gt;</span>
    char === src?.[idx]
      ? { src, <span>idx</span>: idx + <span>1</span> }
      : <span>undefined</span>;
</code></pre>
<p>This is a <em>higher order function</em>. A function that returns a function.</p>
<p>This generator takes a <code>string</code> and returns a <code>Parser</code>, which is a function
that takes a <code>Stream</code> and returns a <code>Result</code>.</p>

<pre><code><span>const</span> parseA = <span>char</span>(<span>&#39;A&#39;</span>)

<span>parseA</span>({
  <span>src</span>: <span>&#34;Abba was a pretty good pop band&#34;</span>,
  <span>idx</span>: <span>0</span>
})
</code></pre>
<p>returns:</p>

<pre><code>{
  <span>src</span>: <span>&#34;Abba was a pretty good pop band&#34;</span>,
  <span>idx</span>: <span>1</span>
}
</code></pre>
<p>notice that the <code>idx</code> has been advanced, indicating that the parser was successful.</p>
<p>and...</p>

<pre><code><span>parseA</span>({
  <span>src</span>: <span>&#34;But ELO is really good too&#34;</span>,
  <span>idx</span>: <span>0</span>
})
</code></pre>
<p>returns:</p>

<pre><code>undefined
</code></pre>
<h3 id="parser-combinators">Parser Combinators</h3>
<p>A function that takes some number of parsers and combines them somehow into a
new parser:</p>

<pre><code><span>type</span> <span>Combinator</span> = <span>(<span>...parsers: Parser[]</span>) =&gt;</span> <span>Parser</span>;
</code></pre>
<p>This is where it gets spicy.</p>
<p>Here is a simple combinator: <code>or</code>.</p>

<pre><code><span>const</span> <span>or</span>: <span>Combinator</span> = <span>function</span> (<span>p1, p2</span>) {
  <span>return</span> <span>function</span> (<span>input</span>) {
    <span>return</span> <span>p1</span>(input) || <span>p2</span>(input);
  };
};
</code></pre>
<p>Again, a function returning a function, could be written more tersely as:</p>

<pre><code><span>const</span> <span>or</span>: <span>Combinator</span> = <span>(<span>p1, p2</span>) =&gt;</span> <span>(<span>input</span>) =&gt;</span> <span>p1</span>(input) || <span>p2</span>(input);
</code></pre>
<p>And so:</p>

<pre><code><span>const</span> parseA = <span>char</span>(<span>&#39;A&#39;</span>);
<span>const</span> parseB = <span>char</span>(<span>&#39;B&#39;</span>);
<span>const</span> parseAorB = <span>or</span>(parseA, parseB);

<span>parseAorB</span>({<span>src</span>: <span>&#34;Applesauce and orange juice&#34;</span>, <span>idx</span>: <span>0</span>}); 
<span>parseAorB</span>({<span>src</span>: <span>&#34;Buckets of rain&#34;</span>, <span>idx</span>: <span>0</span>}); 
<span>parseAorB</span>({<span>src</span>: <span>&#34;Canada oh Canada&#34;</span>, <span>idx</span>: <span>0</span>}); 
</code></pre>
<p>It&#39;s a bit onerous to initialize these <code>Streams</code> everytime, a helper function
for that might be:</p>

<pre><code><span>const</span> s = (<span>s</span>: <span>string</span>): <span><span>Stream</span> =&gt;</span> ({ <span>src</span>: s, <span>idx</span>: <span>0</span> });
</code></pre>
<p><code>and</code> is a tad bit trickier because we care about how far the first parser has
advanced the index, so we need a reference to it available for the second:</p>

<pre><code><span>const</span> <span>and</span>: <span>Combinator</span> = <span>(<span>p1, p2</span>) =&gt;</span>
  <span>(<span>input</span>) =&gt;</span> {
    <span>const</span> r = <span>p1</span>(input);
    <span>if</span> (r) {
      <span>const</span> r2 = <span>p2</span>(r);
      <span>if</span> (r2) {
        <span>return</span> r2,
      }
    }
  };
</code></pre>

<pre><code>parseAandB = <span>and</span>(parseA, parseB);

<span>parseAandB</span>(<span>s</span>(<span>&#34;Argyle sweaters&#34;</span>)); 
<span>parseAandB</span>(<span>s</span>(<span>&#34;Beer battered bananas&#34;</span>); 
<span>parseAandB</span>(<span>s</span>(<span>&#34;ABBA&#34;</span>); 
</code></pre>
<h2 id="what-is-this-good-for-">What is this good for?</h2>
<p>What I&#39;ve got here so far you could imagine has some practical application for
something like input validation. Let&#39;s say you require a valid input to begin
with <code>&#34;ABBA&#34;</code>, for example:</p>

<pre><code>parseAandB = <span>and</span>(parseA, parseB);
parseBandA = <span>and</span>(parseB, parseA);
parseABBA = <span>and</span>(parseAandB, parseBandA)

<span>parseABBA</span>(<span>s</span>(<span>&#34;ABBAthis is valid input&#34;</span>);
<span>parseABBA</span>(<span>s</span>(<span>&#34;ABBAthis is not&#34;</span>);
</code></pre>
<p>But of course, this is contrived and limited, and not at all what we mean when
we talk about real parsers, real parsers do more than just validate input, they
also return something useful!</p>
<p>Right now, a <code>Result</code> looks like:</p>

<pre><code>type Result = Stream | undefined;
</code></pre>
<p>But actually, we don&#39;t want a <code>Stream</code> by itself, we also want <em>what the parser
matched</em>:</p>

<pre><code><span>type</span> <span>OutputValue</span> = {
  <span>stream</span>: <span>Stream</span>;
  <span>value</span>: <span>any</span>;
};
<span>type</span> <span>Result</span> = <span>OutputValue</span> | <span>undefined</span>;
</code></pre>
<p>This necessitates some changes around what the parsers are returning, so for
example, a character parser generator will now look like this:</p>

<pre><code><span>export</span> <span>const</span> <span>char</span>: <span>Generator</span> = <span>(<span>c</span>) =&gt;</span>
  <span>(<span>{ src, idx }</span>) =&gt;</span>
    c === src?.[idx]
      ? { <span>stream</span>: { src, <span>idx</span>: idx + <span>1</span> }, <span>value</span>: src[idx] }
      : <span>undefined</span>;
</code></pre>
<p>and the <code>and</code> combinator might now look like this:</p>

<pre><code><span>export</span> <span>const</span> <span>and</span>: <span>Combinator</span> = <span>(<span>p1, p2</span>) =&gt;</span>
  <span>(<span>input</span>) =&gt;</span> {
    <span>const</span> r = <span>p1</span>(input);
    <span>if</span> (r) {
      <span>const</span> r2 = <span>p2</span>(r.<span>stream</span>);
      <span>if</span> (r2) {
        <span>return</span> {
          <span>stream</span>: r2.<span>stream</span>,
          <span>value</span>: [r.<span>value</span>, r2.<span>value</span>].<span>flat</span>(),
        };
      }
    }
  };
</code></pre>
<p>In both cases, you can see that I&#39;m returning the matched values in some form.</p>
<p>So now...</p>

<pre><code><span>parseABBA</span>(<span>s</span>(<span>&#34;ABBAthis is valid input&#34;</span>);
</code></pre>
<p>returns:</p>

<pre><code>{
  <span>stream</span>: { <span>src</span>: <span>&#34;ABBAthis is valid input&#34;</span>, <span>idx</span>: <span>4</span> },
  <span>value</span>: [ <span>&#34;A&#34;</span>, <span>&#34;B&#34;</span>, <span>&#34;B&#34;</span>, <span>&#34;A&#34;</span> ]
}
</code></pre>
<p>This is useful because now we can <em>do stuff</em> with the matched values.</p>

<p>I want to start by building a <em>very</em> simple calculator that can add two single
digit numbers together. We&#39;ve already got a <code>char</code> parser generator, so we can
pretty easily create all the parsers we need for this:</p>

<pre><code><span>const</span> zero = <span>char</span>(<span>&#34;1&#34;</span>);
<span>const</span> one = <span>char</span>(<span>&#34;1&#34;</span>);
<span>const</span> two = <span>char</span>(<span>&#34;2&#34;</span>);
<span>const</span> three = <span>char</span>(<span>&#34;3&#34;</span>);
<span>const</span> four = <span>char</span>(<span>&#34;4&#34;</span>);
<span>const</span> five = <span>char</span>(<span>&#34;5&#34;</span>);
<span>const</span> six = <span>char</span>(<span>&#34;6&#34;</span>);
<span>const</span> seven = <span>char</span>(<span>&#34;7&#34;</span>);
<span>const</span> eight = <span>char</span>(<span>&#34;8&#34;</span>);
<span>const</span> nine = <span>char</span>(<span>&#34;9&#34;</span>);

<span>const</span> digit = <span>or</span>(nine, <span>or</span>(eight, <span>or</span>(seven, <span>or</span>(six, <span>or</span>(five, <span>or</span>(four, <span>or</span>(three, <span>or</span>(two, <span>or</span>(one, zero)))))))));
</code></pre>
<p>Terribly difficult to read that, isn&#39;t it? I hope the intent is clear, but
that&#39;s not elegant at all. I need something more streamlined...</p>

<pre><code><span>const</span> <span>any</span>: <span>Combinator</span> = <span>(<span>...ps</span>) =&gt;</span> ps.<span>reduce</span>(<span>(<span>p1, p2</span>) =&gt;</span> <span>or</span>(p1, p2));
</code></pre>
<p>This takes any number of parsers and chains the <code>or</code>s just like I&#39;ve done long hand above,</p>

<pre><code><span>const</span> digit = <span>any</span>(zero, one, two, three, four, five, six, seven, eight, nine);
</code></pre>
<p>Much clearer, but <code>any</code> also facilitates an easier <code>generator</code> too:</p>

<pre><code><span>const</span> <span>anyChar</span>: <span>Generator</span> = (str): <span><span>Parser</span> =&gt;</span>
  <span>(<span>input</span>) =&gt;</span> <span>any</span>(...str.<span>split</span>(<span>&#34;&#34;</span>).<span>map</span>(char))(input);
</code></pre>
<p>This function takes a string, splits it into its constituent characters, maps
<code>char</code> over them to get parsers, and then reduces <code>or</code> over them via <code>any</code> to
produce a parser that will match any character in a string.</p>

<pre><code><span>const</span> digit = <span>anyChar</span>(<span>&#34;0123456789&#34;</span>);
</code></pre>
<p>very compact.</p>
<p>We&#39;ll of course need to match <code>+</code> as well:</p>

<pre><code><span>const</span> plus = <span>char</span>(<span>&#34;+&#34;</span>);
</code></pre>
<p>And now there is enough for a simple expression parser:</p>

<pre><code><span>const</span> expression = <span>and</span>(digit, <span>and</span>(plus, digit));
</code></pre>
<p>This pattern seems familiar, we can <code>reduce</code> <code>and</code> over arbitrary numbers of
parsers as well, to clean up the syntax a bit:</p>

<pre><code><span>export</span> <span>const</span> <span>andThen</span>: <span>Combinator</span> = <span>(<span>...ps</span>) =&gt;</span>
  ps.<span>reduce</span>(<span>(<span>p1, p2</span>) =&gt;</span> <span>and</span>(p1, p2));
</code></pre>
<p>So becomes:</p>

<pre><code><span>const</span> expression = <span>andThen</span>(digit, plus, digit);
</code></pre>
<p>Does this work, then?</p>

<pre><code><span>expression</span>(<span>s</span>(<span>&#34;1+2&#34;</span>));
</code></pre>
<p>It does!</p>

<pre><code>{ <span>stream</span>: { <span>src</span>: <span>&#34;1+2&#34;</span>, <span>idx</span>: <span>3</span> }, <span>value</span>: [ <span>&#34;1&#34;</span>, <span>&#34;+&#34;</span>, <span>&#34;2&#34;</span> ] }
</code></pre>
<p>This is where things start to get <em>fun</em>.</p>
<p>Each individual parser returns what it matched on, and only what it matched on.
For digits, if it matches, then we know it&#39;s going to be a digit- that&#39;s the
whole point of matching on it. But we don&#39;t really <em>want</em> a string
representation of a digit, do we? We want a <em>real digit</em>.</p>
<p>To get this, we&#39;ll create a new higher order function that</p>

<ol>
<li>takes a parser</li>
<li>takes an arbitrary function</li>
<li>if the parser succeeds, run it&#39;s matched value through the function</li>
</ol>

<pre><code><span>const</span> <span>map</span> = (<span>parser: Parser, fn: <span>Function</span></span>) =&gt;
  <span>(<span>input: Stream</span>) =&gt;</span> {
    <span>const</span> out = <span>parser</span>(input);

    <span>if</span> (out) {
      out.<span>value</span> = <span>fn</span>(out.<span>value</span>);
      <span>return</span> out;
    }
  };
</code></pre>
<p>This is general! A simple change to the <code>digit</code> definition above, then</p>

<pre><code><span>const</span> digit = <span>map</span>(<span>anyChar</span>(<span>&#34;0123456789&#34;</span>), <span><span>n</span> =&gt;</span> <span>parseInt</span>(n));
</code></pre>
<p>and:</p>

<pre><code><span>expression</span>(<span>s</span>(<span>&#34;1+2&#34;</span>));
</code></pre>
<p>returns</p>

<pre><code>{ <span>stream</span>: { <span>src</span>: <span>&#34;1+2&#34;</span>, <span>idx</span>: <span>3</span> }, <span>value</span>: [ <span>1</span>, <span>&#34;+&#34;</span>, <span>2</span> ] }
</code></pre>
<p>Look closely, the digits in the value array are <em>actual javascript digits</em>. This may seem trivial, but I assure you, it&#39;s very powerful!</p>
<p>Consider for a moment: All of these parsers are built up from scratch, and the
functions to which they are mapping their values to are similarly arbitrary.
<code>parseInt</code> is a simple example, but you can do basically anything with the
input as it&#39;s being parsed. Some more thoughts on this later, but I think that
it is this power and flexibility that excites people when they first learn
about combinators.</p>
<p>With the constituent parts of <code>expression</code> now being transformed into
javascript numbers, one more step will do it...</p>

<pre><code><span>const</span> calculate = <span>map</span>(expression, <span>(<span>value: <span>any</span></span>) =&gt;</span> {
  <span>if</span> (!value) {
    <span>return</span>;
  }
  <span>const</span> [x, operation, y] = value;

  <span>switch</span> (operation) {
    <span>case</span> <span>&#34;+&#34;</span>: {
      <span>return</span> x + y;
    }
  }
});
</code></pre>

<pre><code><span>calculate</span>(<span>s</span>(<span>&#34;1+2&#34;</span>)) 
<span>calculate</span>(<span>s</span>(<span>&#34;3+4&#34;</span>)) 
</code></pre>
<p>I think this is really cool!</p>

<p>Let&#39;s say we add a few more simple arithmetic operations:</p>

<pre><code><span>const</span> digit = <span>map</span>(<span>anyChar</span>(<span>&#34;0123456789&#34;</span>), <span><span>n</span> =&gt;</span> <span>parseInt</span>(n));
<span>const</span> plus = <span>char</span>(<span>&#34;+&#34;</span>);
<span>const</span> minus = <span>char</span>(<span>&#34;-&#34;</span>);
<span>const</span> times = <span>char</span>(<span>&#34;*&#34;</span>);
<span>const</span> divide = <span>char</span>(<span>&#34;/&#34;</span>);
<span>const</span> op = <span>any</span>(divide, times, plus, minus);
<span>const</span> expression = <span>andThen</span>(digit, op, digit)

<span>const</span> calculate = <span>map</span>(expression, <span>(<span>value: <span>any</span></span>) =&gt;</span> {
  <span>if</span> (!value) {
    <span>return</span>;
  }
  <span>const</span> [x, operation, y] = value;

  <span>switch</span> (operation) {
    <span>case</span> <span>&#34;+&#34;</span>: {
      <span>return</span> x + y;
    }
    <span>case</span> <span>&#34;-&#34;</span>: {
      <span>return</span> x - y;
    }
    <span>case</span> <span>&#34;*&#34;</span>: {
      <span>return</span> x * y;
    }
    <span>case</span> <span>&#34;/&#34;</span>: {
      <span>return</span> x / y;
    }
  }
});
</code></pre>
<p>Very compact! And it will do what it looks like it will do:</p>

<pre><code><span>calculate</span>(<span>s</span>(<span>&#39;1*7&#39;</span>)); 
<span>calculate</span>(<span>s</span>(<span>&#39;1/4&#39;</span>)); 
<span>calculate</span>(<span>s</span>(<span>&#39;5-2&#39;</span>)); 
</code></pre>

<p>So we&#39;re all set up for the next section. It&#39;s one of the more interesting
sections, to be honest, so if you&#39;ve made it this far, I hope it will be worth
it.</p>
<p>My small confession is not the next section, it&#39;s a preamble to the next
section, but the confession is that I&#39;ve attempted several times over the last
couple of years, when I had a little time, to grok parser combinators, and I
just kept failing.</p>
<p>Over and over again, I&#39;d watch the videos linked at the bottom of this post,
and think &#34;now I&#39;ve got it!&#34;</p>
<p>And I wouldn&#39;t have got it, and I would try to get them to work and I wouldn&#39;t
be able to, and I&#39;d give up. They&#39;re kind of tricky!</p>
<p>Finally, at this latest attempt, I worked out a few small details that are
quite subtle, but make all the difference. I&#39;m going to describe those problems
and solutions now.</p>

<p>We&#39;ve got all four basic arithmetic operations available, what about something
like this?</p>

<pre><code><span>calculate</span>(<span>s</span>(<span>&#39;1+2+3&#39;</span>));
</code></pre>
<p>It&#39;s quite obvious that this should resolve to 6, and I have parsers for all
the constituent parts, but of course as written, this doesn&#39;t work the way we
would like it to:</p>

<pre><code>{ <span>stream</span>: { <span>src</span>: <span>&#34;1+2+3&#34;</span>, <span>idx</span>: <span>3</span> }, <span>value</span>: <span>3</span> }
</code></pre>
<p>It only manages to parse the first expression in the series of expressions,
because that&#39;s all we informed it about. An expression is actually a bit more
complicated than that.</p>

<pre><code><span>const</span> expression = <span>or</span>(<span>andThen</span>(expression, op, digit), digit);
</code></pre>
<p>Now, the above definition of an expression is <em>correct</em>, strictly speaking, but
there are a few things wrong with it, and these things in combination kept me
scratching my head for a long while. Let&#39;s examine the issues one by one.</p>
<p>The first is helpfully pointed out, and pretty obvious as well:</p>

<pre><code>error: TS2448 [ERROR]: Block-scoped variable &#39;expression&#39; used before its declaration.
const expression = or(andThen(expression, op, digit), digit);
</code></pre>
<p><code>expression</code> can&#39;t use itself in it&#39;s own definition, which is on the one hand
sensible, but on the other... well recursive grammars do exist, and in fact
recursive function calls are used all the time... this is really a language
constraint.</p>
<p>But there is an easy solution, and that solution is a thunk!</p>
<p>You wrap an operation in a function, the function is then passed around as a value
instead of the operation. This means that we can specify parts of the recursive
definition that are not evaluated when the grammar is defined, because the
<code>thunk</code>, as this function is called, is not evaluated until it&#39;s invoked. It&#39;s
an elegant way to introduce lazy evaluation to a language that doesn&#39;t have it
built into the syntax.</p>

<pre><code><span>function</span> <span>lazyAnd</span>(<span>first: () =&gt; Parser, second: () =&gt; Parser</span>): <span>Parser</span> {
  <span>return</span> <span>function</span> (<span>input</span>) {
    <span>return</span> <span>and</span>(<span>first</span>(), <span>second</span>())(input);
  };
}
</code></pre>
<p>This is not really a combinator, because it doesn&#39;t accept <code>Parser</code>s, it
accepts functions that take no arguments that <em>return</em> <code>Parser</code>s.</p>
<p>Applied to the definition of expression thusly:</p>

<pre><code><span>const</span> expression = <span>or</span>(<span>lazyAnd</span>(<span>() =&gt;</span> expression, <span>() =&gt;</span> <span>and</span>(op, digit)), digit);
</code></pre>
<p>And the recursive definition problem is resolved. As far as the runtime is
concerned, by the time the parser is actually <em>invoked</em>, <code>expression</code> has been
defined.</p>
<p>But now, another showstopper:</p>

<pre><code>error: Uncaught RangeError: Maximum call stack size exceeded
const expression = or(lazyAnd(() =&gt; expression, () =&gt; and(op, digit)), digit);
</code></pre>
<p>Stripping away some of the fancy bits here, it does seem fairly obvious that
since <code>expression</code> is the first parser evaluated as a sub part of <code>expression</code>,
that it lacks a base case and will recurse forever.</p>
<p>But at the same time, that&#39;s certainly a valid definition of an expression, right?</p>

<pre><code>expr
----------------
expr, op, digit
----
(1+2)  +  3
</code></pre>
<p>Honestly, this stumped me for a long while. The solution, when I found it, was
so simple and obvious in retrospect...</p>
<p>There is another way to define the same expression!</p>

<pre><code>expr
---------------
digit, op, expr
          -----
1      +  (2+3)
</code></pre>
<p>This is semantically correct as well, <em>but</em> crucially provides a point where
the recursion can be short circuited.</p>

<pre><code><span>const</span> expression = <span>or</span>(<span>lazyAnd</span>(<span>() =&gt;</span> digit, <span>() =&gt;</span> <span>and</span>(op, expression)), digit);
</code></pre>
<p>With a small tweak to the <code>calculate</code> parser and plugging that into the
<code>expression</code> definition, this works for as many terms as desired!</p>

<pre><code>
<span>const</span> expression = <span>or</span>(<span>lazyAnd</span>(<span>() =&gt;</span> digit, <span>() =&gt;</span> <span>and</span>(op, calculate)), digit);

<span>const</span> calculate = <span>map</span>(expression, <span>(<span>value: <span>any</span></span>) =&gt;</span> {
  <span>if</span> (!value) {
    <span>return</span>;
  }

  
  
  <span>if</span> (<span>typeof</span> value === <span>&#39;number&#39;</span>) {
    <span>return</span> value;
  }

  <span>const</span> [x, operation, y] = value;

  <span>switch</span> (operation) {
    <span>case</span> <span>&#34;+&#34;</span>: {
      <span>return</span> x + y;
    }
    <span>case</span> <span>&#34;-&#34;</span>: {
      <span>return</span> x - y;
    }
    <span>case</span> <span>&#34;*&#34;</span>: {
      <span>return</span> x * y;
    }
    <span>case</span> <span>&#34;/&#34;</span>: {
      <span>return</span> x / y;
    }
  }
});
</code></pre>
<p>and so:</p>

<pre><code><span>calculate</span>(<span>s</span>(<span>&#34;1+2+3+4+5+6+7+8+9&#34;</span>)),
</code></pre>
<p>returns</p>

<pre><code>{ <span>stream</span>: { <span>src</span>: <span>&#34;1+2+3+4+5+6+7+8+9&#34;</span>, <span>idx</span>: <span>17</span> }, <span>value</span>: <span>45</span> }
</code></pre>
<p>It&#39;s alive!</p>
<h2 id="some-more-problems">Some more problems</h2>
<p>This little calculator is quite impressive for just a few lines of parsing
code, and shows off how composable and powerful combinators can be, but it is
certainly nothing but a little toy. For example, it has no concept of ordering
the operations in any intelligible way except from rightmost to leftmost:</p>

<pre><code><span>calculate</span>(<span>s</span>(<span>&#34;2*3+1&#34;</span>)),
</code></pre>
<p>We know this should be interpreted as <code>(2*3)+1 = 7</code> and do the multiplication
first, but the poor simple parser dutifully executes from the bottom of the
stack (the end of the input) to the top (the beginning), and we get <code>2*(3+1) = 8</code>.</p>
<p>The solution to <em>this</em> issue is that, in practice, parsers don&#39;t usually return
arbitrary types of values from their inputs, they return some over-arching
structure like an abstract syntax tree composed of nodes that carry metadata
and thus semantic meaning in context. A real calculator would parse the tree
before evaluating it mathematically, and take into account considerations such
as order of operations <em>then</em>. This parser as written doesn&#39;t keep much state
internally except for where it has advances to in the input, and so decisions
like that can&#39;t be made effectively.</p>
<p>Parsing into an AST is a outside the scope of this post, as it&#39;s already
getting pretty long, though I hope to learn more about that and write about it!
That does seem like the point at which parser combinators become genuinely
useful, and not just fun.</p>
<p>I have also elided the monadic nature of the parsing, though they can
potentially fit quite nicely into that pattern, although it would be necessary
to structure them slightly differently than I have done in this post.</p>
<p>Thanks a LOT to Stefanie Schirmer for helping me work through some of my major
difficulties with these concepts, And my batchmates Ornella Friggit, Isaac
Wilder, and Marcin Jekot for pairing with me extensively, and Julia Evans,
Manuel Odendahl, and Vaibhav Sagar for draft input.</p>
<h2 id="links">Links</h2>


<ul>
<li><a href="https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/">Understanding Parser Combinators</a>
<ul>
<li><a href="https://vimeo.com/171704565">Understanding Parser Combinators: A Deep Dive</a></li>
</ul>
</li>
<li><a href="https://bodil.lol/parser-combinators/">Learning Parser Combinators With Rust</a></li>
<li><a href="https://www.youtube.com/watch?v=oU2418-8_KI">Stefanie Schirmer - Parsers All The Way Down? Exploring Combinator Parsing</a></li>
</ul>
</div></div>
  </body>
</html>
