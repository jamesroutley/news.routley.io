<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2025/bloom-filters/">Original</a>
    <h1>Bloom Filters</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>The original motivation for the creation of Bloom filters is efficient set
membership, using a probabilistic approach to significantly reduce the time and
space required to reject items that are not members in a certain set.</p>
<p>The data structure was proposed by Burton Bloom in <a href="https://dl.acm.org/doi/pdf/10.1145/362686.362692">a 1970 paper</a> titled &#34;Space/Time
Trade-offs in Hash Coding with Allowable Errors&#34;. It&#39;s a good paper that&#39;s
worth reading.</p>
<div id="why-bloom-filters">
<h2>Why Bloom filters?</h2>
<p>Suppose that we store some information on disk and want to check if a certain
file contains a certain entry. Reading from disk is time consuming, so we want
to minimize it as much as possible. A Bloom filter is a data structure that
implements a cache with probabilistic properties:</p>
<ol>
<li>If the cache says the key is not present in a specific file, then it&#39;s
100% certain we should not be reading the file.</li>
<li>If the cache says the key <em>is</em> present in the file, there&#39;s a small chance
this is a false positive (and in fact the key isn&#39;t there). In this case
we just read the file as usual.</li>
</ol>
<p>In a scenario where the majority of queries &#34;is this key in that file?&#34; have a
negative answer, a Bloom filter can significantly speed up the system <a href="#footnote-1" id="footnote-reference-1">[1]</a>.
Moreover, the probabilistic nature (the existence of false positives) allows
Bloom filters to be extremely fast and occupy very little space. Here&#39;s a quote
from the Bloom paper:</p>
<blockquote>
The new hash-coding methods to be introduced are
suggested for applications in which the great majority of
messages to be tested will not belong to the given set. For
these applications, it is appropriate to consider as a unit of
time (called <em>reject time</em>) the average time required to
classify a test message as a nonmember of the given set.</blockquote>
</div>
<div id="how-a-bloom-filter-works">
<h2>How a Bloom filter works</h2>
<p>A Bloom filter is a special kind of a <a href="https://en.wikipedia.org/wiki/Open_addressing">hash table with open addressing</a>.
It&#39;s an array of bits (the length is typically denoted <em>m</em>), and some fixed
number (<em>k</em>) of hash functions. We&#39;ll assume each hash function can take an
arbitrary sequence of bytes and hash it into an integer in the inclusive range
<tt>[0, <span>m-1]</span></tt>. A Bloom filter supports two operations:</p>
<p><strong>Insert an item</strong>: the item is hashed using each of the <em>k</em> hash functions, and the
appropriate bits in the underlying array are set to 1.</p>
<p><strong>Test if an item is a member</strong>: the item is hashed using each of the <em>k</em> hash
functions. If any of the bits indicated by their results is 0, we return &#34;false&#34;
with certainty. If all the bits are 1, we return &#34;true&#34; - and there&#39;s a small
chance of false positives.</p>
<p>Here&#39;s how the Bloom paper describes it:</p>
<blockquote>
<p>The hash area is considered as N individual addressable bits, with addresses 0
through N - 1. It is assumed that all bits in the hash area are first set to 0.</p>
<p>Next, each message in the set to be stored is hash coded into a number of
distinct bit addresses, say a1, a2, . . . , ad. Finally, all d bits addressed by
a1 through ad are set to 1.</p>
<p>To test a new message a sequence of d bit addresses,
say a&#39;1, a&#39;2, ... a&#39;d, is generated in the same manner as for storing a message.
If all d bits are 1, the new message is accepted. If any of these bits is zero,
the message is rejected.</p>
</blockquote>
<p>Hopefully it&#39;s clear why this data structure is probabilistic in nature: it&#39;s
possible that different items hash to the same number, and therefore when
we test some X, all its hashes point to bits turned on by the hashing of other
data. Read the Math appendix for the math behind Bloom filters and how to
calculate (and design for a specific) the false positive rate.</p>
<p>Here&#39;s an example:</p>
<p><img alt="Insertion into Bloom filter" src="https://eli.thegreenplace.net/images/2025/bloom-filter-insert.png"/></p><ol>
<li>We start with an empty bloom filter with <tt>m=16</tt> and <tt>k=3</tt>. All bits
are initialized to 0.</li>
<li>Insertion of &#34;x&#34;. The three hashes return indices 1, 6, 15, so these bits
in the array are set to 1.</li>
<li>Insertion of &#34;y&#34;. Hashing returns indices 6, 9 and 13, so these
bits in the array are set to 1. Note that bit 6 is set for both &#34;x&#34; and &#34;y&#34;,
and that&#39;s fine.</li>
</ol>
<p>Next, let&#39;s look at some membership tests:</p>
<p><img alt="Membership test in a Bloom filter" src="https://eli.thegreenplace.net/images/2025/bloom-filter-test.png"/></p><ol start="4">
<li>Test &#34;x&#34;. Hashing returns 1, 6, 15; all these bits are 1 in the
array, so the answer is &#34;true&#34;. This is a true positive.</li>
<li>Test &#34;w&#34;. Hashing returns 3, 9, 13. Since the bit at position 3 is 0, the
answer is &#34;false&#34;.</li>
<li>Test &#34;v&#34;. Hashing returns 9, 13, 15; all these bits are 1 in the array,
so the answer is &#34;true&#34;. This is a false positive.</li>
</ol>
<p>Note that it&#39;s trivial to prove (by the law of contraposition) that all &#34;false&#34;
answers from a Bloom filter&#39;s test operation are true negatives.</p>
</div>
<div id="implementation">
<h2>Implementation</h2>
<p>Here&#39;s a simple implementation of a Bloom filter in Go:</p>
<div><pre><span></span><span>// New creates a new BloomFilter with capacity m, using k hash functions.</span><span></span>
<span>// You can calculate m and k from the number of elements you expect the</span><span></span>
<span>// filter to hold and the desired error rate using CalculateParams.</span><span></span>
<span>func</span><span> </span><span>New</span><span>(</span><span>m</span><span> </span><span>uint64</span><span>,</span><span> </span><span>k</span><span> </span><span>uint64</span><span>)</span><span> </span><span>*</span><span>BloomFilter</span><span> </span><span>{</span><span></span>
<span>  </span><span>return</span><span> </span><span>&amp;</span><span>BloomFilter</span><span>{</span><span></span>
<span>    </span><span>m</span><span>:</span><span>      </span><span>m</span><span>,</span><span></span>
<span>    </span><span>k</span><span>:</span><span>      </span><span>k</span><span>,</span><span></span>
<span>    </span><span>bitset</span><span>:</span><span> </span><span>newBitset</span><span>(</span><span>m</span><span>),</span><span></span>
<span>    </span><span>seed1</span><span>:</span><span>  </span><span>maphash</span><span>.</span><span>MakeSeed</span><span>(),</span><span></span>
<span>    </span><span>seed2</span><span>:</span><span>  </span><span>maphash</span><span>.</span><span>MakeSeed</span><span>(),</span><span></span>
<span>  </span><span>}</span><span></span>
<span>}</span><span></span>

<span>type</span><span> </span><span>BloomFilter</span><span> </span><span>struct</span><span> </span><span>{</span><span></span>
<span>  </span><span>m</span><span>      </span><span>uint64</span><span></span>
<span>  </span><span>k</span><span>      </span><span>uint64</span><span></span>
<span>  </span><span>bitset</span><span> </span><span>[]</span><span>uint64</span><span></span>

<span>  </span><span>// seeds for the double hashing scheme.</span><span></span>
<span>  </span><span>seed1</span><span>,</span><span> </span><span>seed2</span><span> </span><span>maphash</span><span>.</span><span>Seed</span><span></span>
<span>}</span><span></span>

<span>// Insert a data item into the bloom filter.</span><span></span>
<span>func</span><span> </span><span>(</span><span>bf</span><span> </span><span>*</span><span>BloomFilter</span><span>)</span><span> </span><span>Insert</span><span>(</span><span>data</span><span> </span><span>[]</span><span>byte</span><span>)</span><span> </span><span>{</span><span></span>
<span>  </span><span>h1</span><span> </span><span>:=</span><span> </span><span>maphash</span><span>.</span><span>Bytes</span><span>(</span><span>bf</span><span>.</span><span>seed1</span><span>,</span><span> </span><span>data</span><span>)</span><span></span>
<span>  </span><span>h2</span><span> </span><span>:=</span><span> </span><span>maphash</span><span>.</span><span>Bytes</span><span>(</span><span>bf</span><span>.</span><span>seed2</span><span>,</span><span> </span><span>data</span><span>)</span><span></span>
<span>  </span><span>for</span><span> </span><span>i</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>bf</span><span>.</span><span>k</span><span> </span><span>{</span><span></span>
<span>    </span><span>loc</span><span> </span><span>:=</span><span> </span><span>(</span><span>h1</span><span> </span><span>+</span><span> </span><span>i</span><span>*</span><span>h2</span><span>)</span><span> </span><span>%</span><span> </span><span>bf</span><span>.</span><span>m</span><span></span>
<span>    </span><span>bitsetSet</span><span>(</span><span>bf</span><span>.</span><span>bitset</span><span>,</span><span> </span><span>loc</span><span>)</span><span></span>
<span>  </span><span>}</span><span></span>
<span>}</span><span></span>

<span>// Test if the given data item is in the bloom filter. If Test returns false,</span><span></span>
<span>// it&#39;s guaranteed that data was never added to the filter. If it returns true,</span><span></span>
<span>// there&#39;s an eps probability of this being a false positive. eps depends on</span><span></span>
<span>// the parameters the filter was created with (see CalculateParams).</span><span></span>
<span>func</span><span> </span><span>(</span><span>bf</span><span> </span><span>*</span><span>BloomFilter</span><span>)</span><span> </span><span>Test</span><span>(</span><span>data</span><span> </span><span>[]</span><span>byte</span><span>)</span><span> </span><span>bool</span><span> </span><span>{</span><span></span>
<span>  </span><span>h1</span><span> </span><span>:=</span><span> </span><span>maphash</span><span>.</span><span>Bytes</span><span>(</span><span>bf</span><span>.</span><span>seed1</span><span>,</span><span> </span><span>data</span><span>)</span><span></span>
<span>  </span><span>h2</span><span> </span><span>:=</span><span> </span><span>maphash</span><span>.</span><span>Bytes</span><span>(</span><span>bf</span><span>.</span><span>seed2</span><span>,</span><span> </span><span>data</span><span>)</span><span></span>
<span>  </span><span>for</span><span> </span><span>i</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>bf</span><span>.</span><span>k</span><span> </span><span>{</span><span></span>
<span>    </span><span>loc</span><span> </span><span>:=</span><span> </span><span>(</span><span>h1</span><span> </span><span>+</span><span> </span><span>i</span><span>*</span><span>h2</span><span>)</span><span> </span><span>%</span><span> </span><span>bf</span><span>.</span><span>m</span><span></span>
<span>    </span><span>if</span><span> </span><span>!</span><span>bitsetTest</span><span>(</span><span>bf</span><span>.</span><span>bitset</span><span>,</span><span> </span><span>loc</span><span>)</span><span> </span><span>{</span><span></span>
<span>      </span><span>return</span><span> </span><span>false</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>}</span><span></span>
<span>  </span><span>return</span><span> </span><span>true</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>The <tt>bitsetSet</tt> and <tt>bitsetTest</tt> functions can be seen in the
<a href="https://github.com/eliben/code-for-blog/tree/main/2025/bloom">full code repository</a>.</p>
<p>This implementation uses <a href="https://en.wikipedia.org/wiki/Double_hashing">double hashing</a> to
generate <em>k</em> different hash functions from just two hashes.</p>
<p>The code also mentions the <tt>CalculateParams</tt> function:</p>
<div><pre><span></span><span>// CalculateParams calculates optimal parameters for a Bloom filter that&#39;s</span><span></span>
<span>// intended to contain n elements with error (false positive) rate eps.</span><span></span>
<span>func</span><span> </span><span>CalculateParams</span><span>(</span><span>n</span><span> </span><span>uint64</span><span>,</span><span> </span><span>eps</span><span> </span><span>float64</span><span>)</span><span> </span><span>(</span><span>m</span><span> </span><span>uint64</span><span>,</span><span> </span><span>k</span><span> </span><span>uint64</span><span>)</span><span> </span><span>{</span><span></span>
<span>  </span><span>// The formulae we derived are:</span><span></span>
<span>  </span><span>// (m/n) = -ln(eps)/(ln(2)*ln(2))</span><span></span>
<span>  </span><span>// k = (m/n)ln(2)</span><span></span>

<span>  </span><span>ln2</span><span> </span><span>:=</span><span> </span><span>math</span><span>.</span><span>Log</span><span>(</span><span>2</span><span>)</span><span></span>
<span>  </span><span>mdivn</span><span> </span><span>:=</span><span> </span><span>-</span><span>math</span><span>.</span><span>Log</span><span>(</span><span>eps</span><span>)</span><span> </span><span>/</span><span> </span><span>(</span><span>ln2</span><span> </span><span>*</span><span> </span><span>ln2</span><span>)</span><span></span>
<span>  </span><span>m</span><span> </span><span>=</span><span> </span><span>uint64</span><span>(</span><span>math</span><span>.</span><span>Ceil</span><span>(</span><span>float64</span><span>(</span><span>n</span><span>)</span><span> </span><span>*</span><span> </span><span>mdivn</span><span>))</span><span></span>
<span>  </span><span>k</span><span> </span><span>=</span><span> </span><span>uint64</span><span>(</span><span>math</span><span>.</span><span>Ceil</span><span>(</span><span>mdivn</span><span> </span><span>*</span><span> </span><span>ln2</span><span>))</span><span></span>
<span>  </span><span>return</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>You&#39;ll have to read the Math appendix to understand how it works.</p>
</div>
<div id="practicalities">
<h2>Practicalities</h2>
<p>Let&#39;s look at a practical example of a realistic Bloom filter and how it
performs. Suppose we want to store about 1 billion items, and have a false
positive rate of 1% (meaning that if the filter returns &#34;true&#34; for a test,
there&#39;s a 99% chance that the item was previously added to the filter).
Using these requirements, we can invoke <tt>CalculateParams</tt> to get the Bloom
filter parameters:</p>
<div><pre><span></span>CalculateParams(1000000000, 0.01) ===&gt; (9585058378 7)
</pre></div>
<p>This means <em>m</em> is about 9.6 billion (bits) and <em>k</em> is 7. In other words, our
Bloom filter requires about 1.2 GB of space to cache the membership test of
a billion items (that could be of arbitrary size). Moreover, the lookup is
very fast - it&#39;s just 7 applications of the hash function. The constant lookup
cost is particularly attractive, as it doesn&#39;t depend on the number of items
actually inserted, or on any particular pattern in the data (i.e. there are
no worst case scenarios with asymptotically higher cost).</p>
<p>On my machine, benchmarking with the Go implementation shown above I get ~30
<em>nanoseconds</em> per lookup. Mind you, this is the simplest Go implementation I
could think of - nothing here is optimized; I&#39;m sure this can be improved at
least 2x by using a more speed-optimized hash implementation, for example.</p>
<p>Now imagine how long it would take to ascertain if data is present in a file
with 1 billion entries, even if the file contains proper indexing for fast
lookups. Just asking the OS to read the file&#39;s first few KiBs to get at the
index would take orders of magnitude longer than 30 ns.</p>
<p>Recall that Bloom filters are best suited for cases &#34;in which the great majority
of messages to be tested will not belong to the given set&#34;. Moreover, even if
the data exists in the file, false positives only happen 1% of the time.
Therefore, the number of times we&#39;ll have to go to the disk just to find the
data is not there is a very small fraction of total accesses.</p>
</div>
<div id="code">
<h2>Code</h2>
<p>The full code for this post, with tests, is available
<a href="https://github.com/eliben/code-for-blog/tree/main/2025/bloom">on GitHub</a>.</p>
</div>
<div id="appendix-the-math-behind-bloom-filters">
<h2>Appendix: the Math behind Bloom filters</h2>
<p>A reminder on notation:</p>
<ul>
<li><em>m</em>: size (in bits) of the set</li>
<li><em>n</em>: how many keys were inserted into the filter</li>
<li><em>k</em>: number of hash functions used to insert/test each key</li>
</ul>
<p>For a specific bit in the set, assuming our hash functions distribute
the keys randomly, the probability of it not being set by a specific
hash function is:</p>
<p>And the probability it’s not set by either of our <em>k</em> hash functions is:</p>
<p>The last formula is constructed to use an approximation of 
for a large enough <em>m</em> (see the <a href="https://eli.thegreenplace.net/2022/derivative-of-the-exponential-function/">appendix in this post</a>) to write:</p>
<p>After inserting <em>n</em> elements, the probability that it’s 0 is:</p>
<p>Meaning that the probability of it being 1 is:</p>
<p>Recap: this is the probability of any given bit being 1 after <em>n</em> bits
were inserted into a set of size <em>m</em> with <em>k</em> different hash functions.</p>
<p>Assuming independence between our hash functions (this is not super
rigorous, but a reasonable assumption in practice), let’s calculate the
false positive rate. Suppose we have a new key that’s not in the set,
and we’re trying to check its membership by hashing it with our <em>k</em> hash
functions. The false positive rate is the probability that all hashes
land on a bit that’s already set to 1:</p>
<p>This is also called the <em>error rate</em> of our filter, or
. To get an optimal (minimal) false positive rate,
let’s minimize . Since the logarithm function is
monotonically increasing, it will be more convenient to minimize
:</p>
<p>We’ll calculate the derivative w.r.t. <em>k</em> and set it to 0:</p>
<p>Substituting a variable  and using some more
calculus and algebra, we can find that:</p>
<p>A numerical example: if we have a set with 1 million bits, and we expect
to insert about 100,000 elements, the optimal number of hash functions
is:</p>
<p>However, it’s more useful to aim for a certain error rate, and set the
filter parameters accordingly. Let’s assume we’ll be using this optimal
value of <em>k</em>. Substituting  into the
equation for  from above:</p>
<p>If we use the numerical example from before with ,
the error rate with an optimal <em>k</em> will be
.</p>
<p>What often happens is that we have an error rate in mind and we want to
calculate how many bits per element we want to dedicate in our set.
Let’s take the previous equation and try to isolate 
from it using a logarithm:</p>
<p>Then:</p>
<p>Final numerical example: suppose we want an error (false positive) rate
of 1%. This means our set should have:</p>
<p>... bits per element. So if we expect about 100,000 elements, the bit
set used for our filter should have at least 958,000 bits. And, as
calculated earlier, we should be using  hash functions to
achieve this optimal error rate.</p>
<hr/>

</div>

            </div></div>
  </body>
</html>
