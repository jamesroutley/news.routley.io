<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andrewlock.net/understanding-the-worst-dotnet-vulnerability-request-smuggling-and-cve-2025-55315/">Original</a>
    <h1>Understanding the Worst .NET Vulnerability</h1>
    
    <div id="readability-page-1" class="page"><div><section> <article><header><p><time datetime="October 28, 2025">October 28, 2025</time> <span> ~24 min read</span></p> </header> <section><p>I admit, that&#39;s a very click-baity headline, but Microsoft have given the vulnerability a CVSS score of 9.9, their highest ever. Time to panic, right?</p> <p>In this post I try to provide a bit more context. I explain how request smuggling vulnerabilities work in general, how it works in <em>this</em> case, what attackers could use it for, how the vulnerability was fixed, what you can do to protect yourself.</p> <blockquote> <p>WARNING: I am not a security professional, so do not take anything in this post as gospel or advice. I&#39;m just a developer trying to make sense of things. üòÑ All of the details in this post are based on information that was provided or referenced in the original announcement.</p> </blockquote> <h2 id="what-is-the-cve-2025-55315-vulnerability-"><a href="#what-is-the-cve-2025-55315-vulnerability-">What is the CVE-2025-55315 vulnerability?</a></h2> <p>On October 14th 2025, on a standard Microsoft &#34;patch Tuesday&#34;, Microsoft released new versions of all their supported versions of .NET, and also published a security advisory: <a href="https://github.com/dotnet/aspnetcore/issues/64033">Microsoft Security Advisory CVE-2025-55315: .NET Security Feature Bypass Vulnerability</a>. The high level summary from that announcement said:</p> <blockquote> <p>Inconsistent interpretation of http requests (&#39;http request/response smuggling&#39;) in ASP.NET Core allows an authorized attacker to bypass a security feature over a network.</p> </blockquote> <p>The advice was &#34;patch all of your things&#34;, but the real headline was that this vulnerability was given a <a href="https://en.wikipedia.org/wiki/Common_Vulnerability_Scoring_System">CVSS score</a> of 9.9 our of 10, which you know, sounds pretty bad! <a href="https://github.com/blowdart">Barry Dorrans AKA blowdart</a>, .NET security head honcho, gave <a href="https://github.com/dotnet/aspnetcore/issues/64033#issuecomment-3403054914">an explanation of the reasoning behind the score</a> in a comment on the original issue:</p> <blockquote> <p>The bug enables HTTP Request Smuggling, which on its own for ASP.NET Core would be nowhere near that high, but that&#39;s not how we rate things...</p> <p>Instead, we score based on how the bug might affect applications built on top of ASP.NET.</p> <p>Request Smuggling allows an attacker to hide an extra request inside an another, and what that hidden request can do is very application specific.</p> <p>The smuggled request could cause your application code to</p> <ul><li>Login as a different user (EOP)</li> <li>Make an internal request (SSRF)</li> <li>Bypass CSRF checks</li> <li>Perform an injection attack</li></ul> <p>But we don&#39;t know what&#39;s possible because it&#39;s dependent on how you&#39;ve written your app.</p> </blockquote> <p>That <em>does</em> all sound pretty scary! üò± So you can understand the consternation that the issue has caused, especially given the hesitation to explain exactly what &#34;how you&#39;ve written your app&#34; <em>means</em>.</p> <p>Out of curiosity, I decided to dig in further to really understand this vulnerability, how it could impact you, and what &#34;how you&#39;ve written your app&#34; could mean.</p> <h2 id="how-does-request-smuggling-work-"><a href="#how-does-request-smuggling-work-">How does request smuggling work?</a></h2> <p>Before we get to the actual patched vulnerability in ASP.NET Core and how the vulnerability works, I think it&#39;s important to have some background about the general <em>class</em> of exploits known as <em>HTTP request smuggling</em>.</p> <p><a href="https://en.wikipedia.org/wiki/HTTP_request_smuggling">HTTP request smuggling</a> is a security exploit that has been known about for a <em>long</em> time (according to Wikipedia, <a href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf">it was first documented in 2005</a>). It fundamentally arises when you have two different servers processing an HTTP request (e.g. a server and a proxy server), and where those two servers <em>differ</em> in how they handle &#34;invalid&#34; HTTP requests.</p> <p>In all cases of HTTP request smuggling, the exploit works by creating an invalid HTTP request (or sometimes just an <em>ambiguous</em> request), that looks a bit like two HTTP requests glued together. In summary, the exploit then works a bit like this:</p> <ul><li>The proxy server receives the ambiguous HTTP request</li> <li>The proxy server forwards the request (unmodified) to the destination server</li> <li>The server interprets the ambiguous request as <em>two</em> pipelined HTTP requests sent to the server, and processes them separately.</li></ul> <p>I think it&#39;s easiest to understand the problem with an example, so the request below shows an example from <a href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf">the original 2005 paper</a>.</p> <blockquote> <p>Note that this is <em>not</em> an example of the request smuggling vulnerability in CVE-2025-55315, it&#39;s just a representative example of request smuggling in <em>general</em>.</p> </blockquote> <p>Let&#39;s imagine the attacker sends an HTTP request that looks like this:</p> <div><pre><code><span><span>POST</span> <span>/some_script.jsp</span> <span>HTTP/1.0</span></span>





this=thatPOST /vuln_page.jsp HTTP/1.0



param1=value1&amp;data=&lt;script&gt;alert(&#34;stealing%20your%20data:&#34;%2bdocument.cookie)&lt;/script&gt;&amp;foobar
</code></pre></div> <p>The important feature of this request is that there are <em>two</em> <code>Content-Length</code> headers, with different values: <code>9</code> or <code>204</code>. <strong>This is the core of the exploit</strong>; the difference between <em>which</em> of the these two headers the HTTP proxy and HTTP server honour is what causes the vulnerability.</p> <p>Let&#39;s walk through how the exploit works, step-by-step:</p> <ul><li>The attacker sends the above HTTP request.</li> <li>The HTTP proxy receives the request, notes the duplicate <code>Content-Length</code> headers, and accepts the <em>second</em> header, the <code>204</code> length. That means the <em>whole</em> rest of the request is treated as the message body, and seems fine as far as the proxy is concerned.</li> <li>The HTTP proxy forwards the request on to the destination server.</li> <li>This server also notes the duplicate <code>Content-Length</code> header, but it takes the <em>first</em> of the headers, with the length of <code>9</code>.</li> <li>The server reads <code>9</code> bytes of the body (i.e. <code>this=that</code>) and <em>treats that as the whole request</em>. As far as the server is concerned, the whole (valid) request has been received, and it sees the rest of the data <em>as a whole new request</em>.</li> <li>That means that the destination server sees an entirely new HTTP request to process, <code>POST /vuln_page.jsp</code>, and treats it as a new request.</li></ul> <p>That&#39;s the core of the issue; the proxy saw one request, while the destination server saw <em>two</em>‚Äîthe second request has been &#34;smuggled&#34; past the proxy to the server.</p> <blockquote> <p>The request smuggling technique shown here, where you have multiple <code>Content-Length</code> headers isn&#39;t the &#34;canonical&#34; example you&#39;ll generally see referenced, but I used it here because it&#39;s simpler to understand in a lot of ways.</p> <p>The canonical request smuggling attack is where you send both a <code>Content-Length</code> header and a <code>Transfer-Encoding: chunked</code> header (which specifies the length of the body as part of the body itself). As before, the request smuggling exploit relies on differences in how proxy and destination servers interpret these <a href="https://datatracker.ietf.org/doc/html/rfc9112#section-6.3-2.3">conflicting headers</a>.</p> </blockquote> <p>So as you&#39;ve seen, request smuggling enables sending a secret request to a destination server that an intermediate proxy server hasn&#39;t seen. In the next section we&#39;ll look at why that&#39;s a bad thing, and how it can be exploited.</p> <h2 id="how-can-an-attacker-exploit-request-smuggling-"><a href="#how-can-an-attacker-exploit-request-smuggling-">How can an attacker exploit request smuggling?</a></h2> <p>On the face of it, request smuggling might not <em>seem</em> like a big deal. So the server sees two requests, so what? You could always send two requests to the server <em>anyway</em>, right? Well, yes and no.</p> <p>The issue with request smuggling is really all about the <em>mismatch</em> between the proxy and destination servers. Thanks to this mismatch, and depending on what behaviours and expectations the target application has, attackers can use request smuggling to</p> <ul><li>Reflect malicious data to other users on sites that are vulnerable to cross-site scripting.</li> <li>Poison caches with bad data.</li> <li>Exfiltrate authentication credentials or other data from client requests.</li> <li>Invoke endpoints that shouldn&#39;t be publicly accessible (because the proxy would block external access to them).</li> <li>Replace/override authentication controls handled by the proxy.</li> <li>Redirect users to malicious sites on sites vulnerable to open-redirect attacks.</li> <li>And more‚Ä¶</li></ul> <p>As you can see, these are all Bad‚Ñ¢Ô∏è, so you can kind of understand why the 9.9 rating was given! üò±</p> <p>That said, it&#39;s worth mentioning that not <em>all</em> of these attacks will be fruitful against <em>all</em> applications. Some of the easiest to understand versions of these exploits are where the proxy is not just doing &#34;dumb&#34; forwarding of requests, but rather it&#39;s validating or enhancing the request in some way.</p> <p>For example, if you have a proxy sat in front of your server which is responsible for handling TLS termination and client-authentication and identification using certificates, then request smuggling could be used to bypass these checks and insert your <em>own</em> identification.</p> <p>As an example of <a href="https://portswigger.net/web-security/request-smuggling/exploiting#bypassing-client-authentication">that attack</a>, the HTTP request below demonstrates using a <code>Content-Length</code> and <code>Transfer-Encoding</code> request smuggling attack to &#34;hide&#34; the request to <code>/admin</code> from the front-end proxy, and insert a malicious <code>X-SSL-CLIENT-CN</code> header, which would <em>normally</em> be added by the front-end proxy:</p> <div><pre><code><span><span>POST</span> <span>/example</span> <span>HTTP/1.1</span></span>





0

<span><span>GET</span> <span>/admin</span> <span>HTTP/1.1</span></span>


</code></pre></div> <p>In this example, the server assumes that the <code>X-SSL-CLIENT-CN: administrator</code> header was added by the proxy, and so the server assumes that the proxy already did all the necessary authentication and authorization. The attacker is able to perform a request as an entirely different user.</p> <p>Request smuggling is clearly a big problem whenever you have a front-end proxy that does some functionality, but even when it&#39;s essentially a dumb proxy, request smuggling can still be used to <a href="https://portswigger.net/web-security/request-smuggling/exploiting#capturing-other-users-requests">steal and exfiltrate data</a> from <em>other</em> user&#39;s requests, even if the attacked site is not vulnerable to cross-site scripting or other vulnerabilities.</p> <blockquote> <p>In these attacks, simply having functionality that displays data provided by a user (even sanitised) can be sufficient to <a href="https://portswigger.net/web-security/request-smuggling/exploiting#capturing-other-users-requests">steal the credentials of other users</a>. So something as simple as displaying a user name or a comment could be sufficient.</p> </blockquote> <p>This post is long enough, and there are so many different attacks, that I&#39;m going to leave it there for looking at exploits. If you&#39;d like to learn more about what&#39;s possible, along with simple explanations and examples of exploits, I recommend the <a href="https://portswigger.net/">PortSwigger</a> documentation on <a href="https://portswigger.net/web-security/request-smuggling/exploiting">exploiting request smuggling</a>.</p> <h2 id="does-request-smuggling-only-apply-if-i-have-a-proxy-"><a href="#does-request-smuggling-only-apply-if-i-have-a-proxy-">Does request smuggling only apply if I have a proxy?</a></h2> <p>In general, whenever people talk about request smuggling, they normally talk about the case where you have multiple servers: the canonical example is a proxy server and a destination server, as I&#39;ve discussed so far. But don&#39;t be fooled, these issues and vulnerabilities can apply even if you aren&#39;t strictly using a proxy.</p> <p>The <em>key</em> feature of the vulnerability is that there&#39;s an opportunity for confusion between two &#34;systems&#34;, whether they&#39;re full &#34;servers&#34; or not. This obviously applies to proxy servers, but could also apply to your application if you&#39;re doing anything where you&#39;re reading/manipulating/forwarding request streams, or where there&#39;s the possibility for confusion <em>inside the same application</em>.</p> <p>For ASP.NET Core applications, if you&#39;re working with <code>HttpRequest.Body</code> or <code>HttpRequest.BodyReader</code>, or other similar methods then you <em>may</em> be vulnerable to attacks <em>even if you&#39;re not explicitly using a proxy server</em>. Even if you don&#39;t think of your application as a proxy or as using a proxy, if you&#39;re doing &#34;proxy-like&#34; things, then you could be vulnerable.</p> <blockquote> <p>Put in other words, if you&#39;re reading, manipulating, or forwarding request streams directly in ASP.NET Core, as opposed to just relying on the built-in model binding, then you could be at risk to request smuggling attacks. It&#39;s very hard to enumerate all the attack vectors, so you should consider any code that does so as a potential avenue of exploitation.</p> </blockquote> <p>We&#39;ve now covered how request smuggling works and can be exploited in general, so it&#39;s time to look at the <em>specific</em> version of request smuggling that is targeted in the .NET CVE-2025-55315 vulnerability.</p> <h2 id="how-does-the-request-smuggling-in-cve-2025-55315-work-"><a href="#how-does-the-request-smuggling-in-cve-2025-55315-work-">How does the request smuggling in CVE-2025-55315 work?</a></h2> <p>As we&#39;ve seen, HTTP request smuggling is a general technique that relies on differences between proxies and servers in how they parse HTTP requests. I&#39;ve shown two specific versions of this so far: duplicate <code>Content-Length</code> headers, and <code>Content-Length</code>/<code>Transfer-Encoding</code> confusion, but these are not exhaustive. There are variations on these approaches which also lead to request smuggling.</p> <p>The request smuggling vulnerability in <a href="https://github.com/dotnet/aspnetcore/issues/64033">CVE-2025-55315</a> relies on a variation which (as far as I can tell) was first reported in June 2025 by <a href="https://w4ke.info/2025/06/18/funky-chunks.html">Jeppe Bonde Weikop on their blog</a>. This variation relies on <code>Transfer-Encoding</code> and the <a href="https://datatracker.ietf.org/doc/html/rfc9112#name-chunk-extensions">Chunk Extensions</a> feature.</p> <blockquote> <p>All the details and images in this section are based on the descriptions and examples in <a href="https://w4ke.info/2025/06/18/funky-chunks.html">the original post</a>. That post is excellent, so if you want even more detail and explanation than here, you should definitely read it, and then you can skip the abbreviated version I provide here.</p> </blockquote> <p>To understand the vulnerability, we&#39;ll first look at how chunked transfer encoding works and what chunk extensions are. We&#39;ll then look at how invalid line-endings can lead to differences in interpretation of a request. Finally, we&#39;ll look at how this difference in interpretation can open the way for request smuggling, and how ASP.NET Core fixed the problem.</p> <h3 id="transfer-encoding-chunked-and-chunk-extensions"><a href="#transfer-encoding-chunked-and-chunk-extensions"><code>Transfer-Encoding: chunked</code> and chunk extensions</a></h3> <p>To understand the vulnerability, we first need to understand how <code>Transfer-Encoding: chunked</code> works, and how chunk extensions complicate things.</p> <p>When you&#39;re <em>sending</em> a request, you might not always know up-front how big the request is that you&#39;re sending. Let&#39;s take a practical example of serializing a .NET object to JSON into a request body. The only way to know for sure how big the serialized data is going to be is to actually serialize it. So you <em>could</em> serialize the data to memory <em>before</em> writing the request, but if the data is very big, then that could cause issues with allocating big arrays.</p> <p>Instead, <a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding"><code>Transfer-Encoding: chunked</code></a> allows sending the request data in multiple &#34;chunks&#34;. You need to know the size of each individual chunk, but not the <em>overall</em> size of the data, or how many chunks there are. This works well for serializing to a small buffer, sending that small buffer as a chunk, and then re-using the buffer to serialize the next part, until you have serialized the whole object.</p> <p>In terms of the HTTP request itself, each chunk consists of a header and a body. The header consists of a hexadecimal-formatted number of bytes, followed by a <code>\r\n</code> (<code>CRLF</code>) line ending. The chunk body is then the specified number of bytes, followed by another <code>\r\n</code>. You can have as many chunks as you need, and the request will keep being passed until you send a <code>0</code> length chunk, which indicates the end of the request.</p> <p>As an example, the following HTTP <code>POST</code> shows posting some JSON to an endpoint, but the JSON is sent as three distinct chunks:</p> <p><img src="https://novalis.org/content/images/2025/request_smuggling_01.svg" alt="A simple HTTP request using chunked transfer encoding"/></p> <ul><li>Chunk 1: The header is <code>9</code> indicating 9 bytes will be sent (followed by <code>\r\n</code>), and then the 9 bytes of the start of the JSON document in the chunk body, again followed by <code>\r\n</code>.</li> <li>Chunk 1: The header is <code>e</code> indicating 14 bytes (14 in hexadecimal is <code>e</code>) will be sent (followed by <code>\r\n</code>), and then the remaining 14 bytes of the end of the JSON document, followed by <code>\r\n</code>.</li> <li>The final chunk is an &#34;empty&#34; chunk, <code>0\r\n\r\n</code>, indicating the end of the request.</li></ul> <p>We&#39;re going to see shortly that line endings are very important, so the following diagram shows the same as the above HTTP request, but with the line endings included:</p> <p><img src="https://novalis.org/content/images/2025/request_smuggling_02.svg" alt="A simple HTTP request using chunked transfer encoding with the line endings shown"/></p> <p>That&#39;s &#34;normal&#34; chunked transfer encoding, so now we come to chunk extensions. <a href="https://datatracker.ietf.org/doc/html/rfc9112#name-chunk-extensions">Chunk extensions</a> are part of the HTTP 1.1 protocol which allows for adding key-value pairs of metadata to individual chunks. The following example shows the same request as before, but with a chunk extension, <code>;foo=bar</code> in the second chunk:</p> <p><img src="https://novalis.org/content/images/2025/request_smuggling_03.svg" alt="The same HTTP request with a chunk extension in the second chunk"/></p> <p>A chunk extension is indicated by a <code>;</code> after the chunk header length, followed by one or more key-value pairs in the form <code>key=value</code>. It&#39;s important to understand that chunk extensions are not part of the <em>data</em> that&#39;s seen by a request handler; chunk extensions are just metadata about the individual chunk. And tl;dr; they&#39;re completely useless üòÖ</p> <p>To the closest approximation, no-one cares about chunk extensions; client implementations don&#39;t send them, and servers just ignore them. If that&#39;s the case, how can they be the cause of such a problematic bug in .NET?</p> <p>The problem is <em>how</em> the implementation ignores them‚Ä¶</p> <h3 id="invalid-chunk-extensions-with-incorrect-line-endings"><a href="#invalid-chunk-extensions-with-incorrect-line-endings">Invalid chunk extensions with incorrect line endings</a></h3> <p>In general with HTTP, clients and server implementations often try to follow the <a href="https://en.wikipedia.org/wiki/Robustness_principle"><em>robustness principle</em></a> of &#34;be conservative in what you send, and lenient with what you accept&#34;. Unfortunately, it&#39;s this very leniency which can sometimes leave us in hot water. After all, it was leniency around requests containing both a <code>Content-Length</code> and <code>Transfer-Encoding</code> header that was the root cause of the original request smuggling exploit.</p> <blockquote> <p>Note that the <a href="https://datatracker.ietf.org/doc/html/rfc9112#section-6.3-2.3">HTTP 1.1 RFC now forbids</a> forwarding both these headers, precisely to avoid request smuggling attacks.</p> </blockquote> <p>For chunk extensions though, leniency is often <em>accidentally</em> built in to the server implementations. Given that no implementations actually <em>do</em> anything with the chunk extensions, the canonical approach to handling them when parsing a chunk header is just to <em>ignore</em> them. When a <code>;</code> is parsed, it&#39;s common to just look for the end of the line, and ignore everything in between.</p> <p>For ASP.NET Core (prior to the fix), on finding a <code>;</code> in the chunk header, <a href="https://github.com/dotnet/aspnetcore/blob/4cf89470a7866a963d7118bb1ba90dc35683965c/src/Servers/Kestrel/Core/src/Internal/Http/Http1ChunkedEncodingMessageBody.cs#L348-L356">Kestrel would &#34;parse&#34; the extension</a>, but in practice, it would search for the carriage return <code>\r</code> and then check for the following <code>\n</code>, skipping everything in between, a little bit like this (very simplified compared to <a href="https://github.com/dotnet/aspnetcore/blob/4cf89470a7866a963d7118bb1ba90dc35683965c/src/Servers/Kestrel/Core/src/Internal/Http/Http1ChunkedEncodingMessageBody.cs#L348-L356">original code</a>):</p> <div><pre><code><span>private</span> <span><span>void</span></span> <span>ParseExtension</span><span>(</span><span>ReadOnlySequence<span>&lt;</span><span>byte</span><span>&gt;</span></span> buffer<span>)</span>
<span>{</span>
    <span>while</span><span>(</span><span>true</span><span>)</span>
    <span>{</span>
        
        
        <span><span>var</span></span> extensionCursor <span>=</span> buffer<span>.</span><span>PositionOf</span><span>(</span>ByteCR<span>)</span><span>;</span>
        <span><span>var</span></span> suffixBuffer <span>=</span> buffer<span>.</span><span>Slice</span><span>(</span>extensionCursor<span>)</span><span>;</span> 

        <span><span>var</span></span> suffixSpan <span>=</span> suffixBuffer<span>.</span><span>Slice</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>)</span><span>.</span><span>ToSpan</span><span>(</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span>suffixSpan<span>[</span><span>1</span><span>]</span> <span>==</span> <span>&#39;\n&#39;</span><span>)</span>
        <span>{</span>
            
            <span>return</span><span>;</span>
        <span>}</span>

        
        buffer <span>=</span> <span>ReadMoreData</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div> <p>The implementation in ASP.NET Core wasn&#39;t particularly special; <a href="https://github.com/golang/go/blob/1d45a7ef560a76318ed59dfdb178cecd58caf948/src/net/http/internal/chunked.go#L193-L199">most servers</a> simply skip over the bytes until they find a <code>\r\n</code>. The big question is exactly <em>how</em> the servers search for <code>\r\n</code>. What happens if they see a lone <code>\r</code>, or a lone <code>\n</code>? Do they treat that the same as a <code>\r\n</code>? Do they throw an error if they find an un-paired <code>\r</code> or <code>\n</code>? Or do they ignore it and keep looking for a <code>\r\n</code>?</p> <p>That ambiguity is at the heart of the CVE-2025-55315 request smuggling vulnerability. Differences in how proxy and server implementations treat standalone <code>\r</code> or <code>\n</code> in a chunk header allow for request smuggling exploits that use this ambiguity.</p> <blockquote> <p>Note that according to <a href="https://www.rfc-editor.org/errata/eid7633">the RFC</a>, implementers must <em>not</em> treat <code>\r</code> or <code>\n</code> as &#34;valid&#34; line terminators for a chunk header, and neither <code>\r</code> or <code>\n</code> are allowed elsewhere in chunk headers, so correct implementations must reject requests that include these standalone line endings in chunk headers.</p> </blockquote> <p>For complete clarity, the following example is the same as the previous implementation but with an <em>invalid</em> chunk header in the chunk extension of the second chunk. Instead of ending with <code>\r\n</code>, the chunk extension ends with a single <code>\n</code>:</p> <p><img src="https://novalis.org/content/images/2025/request_smuggling_04.svg" alt="An HTTP request with an ambiguous line ending in a chunk extension"/></p> <p>That&#39;s the root cause of the request smuggling vulnerability, so in the next section we&#39;ll look at <em>how</em> this could be used to craft a malicious HTTP request.</p> <h3 id="exploiting-invalid-chunk-extensions-for-request-smuggling"><a href="#exploiting-invalid-chunk-extensions-for-request-smuggling">Exploiting invalid chunk extensions for request smuggling</a></h3> <p>Just as with other examples of request smuggling, the chunk extensions approach relies on differences in how a proxy parses a request compared to a subsequent server. This difference means the proxy sees one request, while the destination request sees two requests, and allows for <a href="#how-can-an-attacker-exploit-request-smuggling-">all the same exploits I discussed earlier</a>.</p> <blockquote> <p>As discussed, these examples come from <a href="https://w4ke.info/2025/06/18/funky-chunks.html">this excellent blog post</a>, so see that post for more details, variations on the attack, and further ways to exploit the vulnerability.</p> </blockquote> <p>The following example shows a malicious HTTP request that exploits a difference in line-ending handling between a proxy and the destination server to smuggle a request to the <code>/admin</code> endpoint. We can imagine that the proxy is configured to automatically reject requests to <code>/admin</code> normally, and the server assumes that the proxy handles that for us.</p> <p><img src="https://novalis.org/content/images/2025/request_smuggling_05.svg" alt="A request smuggling attack exploiting differences between a proxy and server implementation"/></p> <p>In this example the attacker creates a malformed chunk header with a chunk extension by sending <code>2;\n</code>. The <code>;</code> ensures that both the proxy and and server treat the header as a chunk extension, but using <code>\n</code> instead of <code>\r\n</code> results in differential parsing:</p> <ul><li>The proxy only sees a single request: <ul><li>It treats the <code>\n</code> as a &#34;valid&#34; line-ending for the chunk header</li> <li>It then treats the <code>xx</code> as the chunk body</li> <li><code>47</code> is the next chunk header</li> <li>The next 71 bytes (<code>47</code> is hex, which is 71 in decimal) are treated as the chunk body.</li> <li>Finally there&#39;s the empty chunk block</li></ul> </li> <li>The server sees two requests: <ul><li>The server ignores the lone <code>\n</code>, and skips all the way to <code>xx\r\n</code></li> <li>It then treats the <code>47</code> as the chunk body</li> <li>It sees an ending chunk,<code>0\r\n\r\n</code> and thinks the request is over</li> <li>The remaining data is treated as a completely separate request, which contains only an empty chunk in the body.</li></ul> </li></ul> <p>This is pretty much the simplest example, but you can essentially exploit this difference in all the ways I described previously. <em>Exactly</em> what the implications are for <em>your</em> application are hard to say, but given that all sorts of security bypass, credential stealing, and injection attacks are possible, it&#39;s easy to understand why the vulnerability received a CVSS rating of 9.9.</p> <blockquote> <p>One very interesting thing I found was looking at the security advisories for the same flaw in other HTTP implementations from other languages. In the python <a href="https://github.com/aio-libs/aiohttp">aiohttp</a> and ruby <a href="https://github.com/puma/puma">puma</a> servers, for example, give <a href="https://github.com/advisories/GHSA-8495-4g3g-x7pr">the vulnerability only a moderate severity</a> rating in <a href="https://github.com/advisories/GHSA-c2f4-cvqm-65w2">both cases</a>. In <a href="https://github.com/netty/netty">netty</a> it&#39;s even given <a href="https://github.com/netty/netty/security/advisories/GHSA-fghv-69vj-qj49">a low severity</a>.</p> <p>As far as I can tell, these servers are essentially vulnerable in the same way as ASP.NET Core is, so it&#39;s just an interesting data point, and I think reflects how Microsoft really want to make sure this gets the visibility it deserves and that customers patch their apps!</p> </blockquote> <h3 id="how-was-the-vulnerability-fixed-"><a href="#how-was-the-vulnerability-fixed-">How was the vulnerability fixed?</a></h3> <p>As with most fixes for request-smuggling, the solution is to stop being lenient and/or ambiguous about how standalone line-endings are handled in chunk headers.</p> <p>In ASP.NET Core, <a href="https://github.com/dotnet/aspnetcore/pull/64037">the PR that fixes the issue</a> does so by explicitly checking for <em>any</em> line-endings, instead of just looking for <code>\r</code>. If it finds a line ending and it&#39;s <em>not</em> strictly <code>\r\n</code>, then Kestrel now throws a <code>KestrelBadHttpRequestException</code> and returns a <code>400</code> response.</p> <p><img src="https://novalis.org/content/images/2025/request_smuggling_06.png" alt="A screenshot of the fix from the PR https://github.com/dotnet/aspnetcore/pull/64037"/></p> <blockquote> <p>I&#39;ll mention here there <em>is</em> an <code>AppContext</code> switch for <a href="https://github.com/dotnet/aspnetcore/blob/33ab51daf86b690432f44749824972c1f5019e83/src/Servers/Kestrel/Core/src/Internal/Http/Http1ChunkedEncodingMessageBody.cs#L31"><em>opting-in</em> to the dangerous/vulnerable parsing behaviour</a> after you have patched your application, but please don&#39;t use it, I can&#39;t believe there&#39;s really a good (or <em>safe</em>) reason to.üòÖ</p> </blockquote> <p>The vulnerability has been patched in ASP.NET Core, so what should you do?</p> <h2 id="what-should-you-do-"><a href="#what-should-you-do-">What should you do?</a></h2> <p>Obviously the <em>good</em> news here is that there is a fix for ASP.NET Core. As described <a href="https://github.com/dotnet/aspnetcore/issues/64033">in the original issue</a>, the important thing is to update to the latest supported version of ASP.NET Core as soon as possible.</p> <blockquote> <p>There&#39;s no announced evidence of the request smuggling vulnerability being exploited in the wild, but given the vast number of ways that request smuggling <em>could</em> be used, would we even know? ü§î</p> </blockquote> <p>That means you should update your version of .NET 8, .NET 9, or .NET 10:</p> <table><thead><tr><th></th><th>Vulnerable versions</th><th>Lowest patched version</th></tr></thead><tbody><tr><td>.NET 10</td><td>10.0.0-rc2</td><td>10.0.0-rc2</td></tr><tr><td>.NET 9</td><td>9.0.0 - 9.0.9</td><td>9.0.10</td></tr><tr><td>.NET 8</td><td>8.0.0 - 8.0.20</td><td>8.0.21</td></tr></tbody></table> <p>If you&#39;re using ASP.NET Core 2.3 on .NET Framework, then you&#39;ll need to update your version of <em>Microsoft.AspNetCore.Server.Kestrel.Core</em>:</p> <table><thead><tr><th></th><th>Vulnerable versions</th><th>Lowest patched version</th></tr></thead><tbody><tr><td>Microsoft.AspNetCore.Server.Kestrel.Core</td><td>2.0.0-2.3.0</td><td>2.3.6</td></tr></tbody></table> <p>If you are doing self-contained deployments of your applications, you&#39;ll need to update to the patched versions and then redeploy your applications.</p> <p>And if you&#39;re using older versions of .NET Core? Well, then you <em>can&#39;t</em> patch‚Ä¶ <a href="https://www.herodevs.com/">HeroDevs</a> provide additional support for out-of-support versions of .NET (<a href="https://github.com/dotnet/aspnetcore/issues/64033#issuecomment-3411924593">and have confirmed they&#39;ll be patching it in .NET 6</a>), but this vulnerability is present in basically <em>all</em> versions of .NET Core as far as I can tell. I&#39;ve personally tested down to .NET Core 3.0 and I can confirm that the vulnerability is there <em>and there are no patches coming for you</em>. The best thing to do is to update to a supported version of .NET.</p> <blockquote> <p>‚ö†Ô∏è If you are running ASP.NET Core using &lt;=.NET Core 3.0, .NET Core 3.1, .NET 5, .NET 6 (<a href="https://www.herodevs.com/blog-posts/critical-asp-net-vulnerability-cve-2025-55315-reported-upgrade-now">unless supported by HeroDevs</a>), or .NET 7, then you are vulnerable, and there are no patches. You should update to a supported version of .NET as soon as possible. Ironically, if you&#39;re stuck on old .NET Framework Web Forms or MVC applications <a href="https://github.com/dotnet/aspnetcore/issues/64033#issuecomment-3442910860">you are apparently <em>not</em> vulnerable</a>.</p> </blockquote> <p>It&#39;s worth noting that if you are stuck on one of these old framework versions and <em>can&#39;t</em> upgrade, then probably the best way to protect yourself is to ensure that you have a proxy in front of your application which is confirmed to not be vulnerable (though obviously you are likely vulnerable to <em>other</em> exploits üòÖ).</p> <p>For example, <a href="https://azure.github.io/AppService/2025/10/20/dotnet-on-windows.html">Azure App Services (AAS) confirmed</a> that applications running in AAS are no longer vulnerable, even if you haven&#39;t updated, because the proxy that AAS uses (itself a <a href="https://devblogs.microsoft.com/dotnet/bringing-kestrel-and-yarp-to-azure-app-services/">YARP based ASP.NET Core proxy</a>) has been patched. By blocking the requests at the proxy level, ambiguous requests will never make it to your application, so you are protected.</p> <p>Unfortunately, right now, it&#39;s not clear exactly where you stand if you&#39;re using a service other than AAS for hosting your applications. Even IIS hasn&#39;t been confirmed to be safe or vulnerable at this point, but I did some unofficial testing on my Windows 11 box, and as fat as I can tell, it <em>is</em> vulnerable.</p> <blockquote> <p>Note that various people <a href="https://github.com/dotnet/aspnetcore/issues/64033#issuecomment-3445099135">in the original issue</a> are attempting to test IIS by using the <code>Content-Length</code>/<code>Transfer-Encoding</code> version of request smuggling, which is not applicable here; we&#39;re interested in the chunk-extensions based version.</p> </blockquote> <p>Another interesting point is that this is vulnerability in HTTP/1.0 and HTTP/1.1 <em>only</em>; it is not a vulnerability in HTTP/2 or HTTP/3. HTTP/2 and HTTP/3 do not support chunked transfer encoding, and instead uses a different, more efficient, binary framing layer for data streaming. So another way to protect those applications which you <em>can&#39;t</em> upgrade may be to enforce that client&#39;s can <em>only</em> use HTTP/2 or HTTP/3. Be aware that&#39;s liable to break a <em>lot</em> of clients that are still using HTTP/1.1 though!</p> <blockquote> <p>You can configure the HTTP protocols allowed by Kestrel by configuring your Kestrel endpoints. <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/servers/kestrel/endpoints?view=aspnetcore-9.0#configure-http-protocols">The documentation</a> shows various ways to do this.</p> </blockquote> <h2 id="how-to-know-if-you-re-affected-"><a href="#how-to-know-if-you-re-affected-">How to know if you&#39;re affected?</a></h2> <p>The &#34;simplest&#34; way to know if you&#39;re affected is to check the version of .NET you&#39;re using to run your applications, using <code>dotnet --info</code> and verify that you&#39;re using one of the patched versions. If you are, you&#39;re safe. That&#39;s the only &#34;supported&#34; way to know that you&#39;re safe, and it&#39;s the one way I would recommend. As far as I can tell, there isn&#39;t currently a generalised tool to point at an application to find out if it&#39;s vulnerable, though it would likely be possible to write one.</p> <p>The folks at HeroDevs <a href="https://github.com/sirredbeard/CVE-2025-55315-repro">re-implemented the functional tests</a> from the original ASP.NET Core fix as a console application compiled against multiple versions of ASP.NET Core. They used this to confirm that unpatched versions of .NET 8-.NET 10 are vulnerable, while <em>patched</em> versions are not. They also used this to verify .NET 6 is vulnerable, and I tweaked it to confirm everything down to at least .NET Core 3.0 is vulnerable.</p> <p>The <a href="https://github.com/sirredbeard/CVE-2025-55315-repro">test in the repro</a> works by sending a chunked transfer encoding request to ASP.NET Core, with an invalid line ending in a chunk extension header. The vulnerability is identified by ASP.NET Core &#34;hanging&#34;, waiting for more data, until it eventually times out. The &#34;fixed&#34; version immediately throws the <code>BadRequest</code> exception included in the fix.</p> <blockquote> <p>I <a href="https://www.youtube.com/watch?v=LE758TvUE5c">saw some confusion</a> about this test online; the argument was &#34;if both the fixed and broken versions throw an exception, why does it matter&#34;? However, that&#39;s not the point of the test. The fact that Kestrel is paused waiting for more data indicates that a smuggled HTTP request <em>would</em> have been executed. You can see how this can be leveraged to exfiltrate data or attack other users both in <a href="https://w4ke.info/2025/06/18/funky-chunks.html#exploiting-live-users">the chunk extensions blog</a> or <a href="https://portswigger.net/web-security/request-smuggling/exploiting">on PortSwigger&#39;s site</a>.</p> </blockquote> <p>I used a similar approach to try to understand whether IIS might be vulnerable by sending the same crafted HTTP request to IIS and seeing if it hung until timing out: it did on my version of IIS (<code>10.0.26100.1882</code>):</p> <div><pre><code>

<span>echo</span> <span>-e</span> <span>&#34;GET / HTTP/1.1<span title="\r">\r</span><span title="\n">\n</span>Host:<span title="\r">\r</span><span title="\n">\n</span>Transfer-Encoding: chunked<span title="\r">\r</span><span title="\n">\n</span><span title="\r">\r</span><span title="\n">\n</span>1;<span title="\n">\n</span>&#34;</span> <span>\</span>
  <span>|</span> <span>nc</span> localhost <span>80</span>
</code></pre></div> <p>So does that definitely mean IIS is vulnerable? No, don&#39;t trust me, I&#39;m not a security researcher üòÖ But until you hear otherwise, I would play it safe and assume that IIS <em>won&#39;t</em> protect you from chunk extension request smuggling attacks. And in general, I would apply the same rules to any other proxies you are relying on in your infrastructure.</p> <p>And as a final reminder, even though request smuggling is typically described and demonstrated using a proxy in front of your server, just <em>not</em> using a proxy does <em>not</em> mean you&#39;re automatically safe. If you&#39;re reading, manipulating, or forwarding request streams directly in ASP.NET Core, as opposed to just relying on the built-in model binding, then you <em>might</em> be at risk to request smuggling attacks. It&#39;s best to play it safe, patch your apps, and wherever possible leave the complexity of manipulating requests to ASP.NET Core.</p> <p>In general, I would make sure to subscribe to <a href="https://github.com/dotnet/aspnetcore/issues/64033">the ASP.NET Core issue on GitHub</a>, as it&#39;s likely that any more announcements around the issue will also be reported there.</p> <h2 id="summary"><a href="#summary">Summary</a></h2> <p>In this post I discuss the recent ASP.NET Core vulnerability: <a href="https://github.com/dotnet/aspnetcore/issues/64033">Microsoft Security Advisory CVE-2025-55315: .NET Security Feature Bypass Vulnerability</a>. This advisory warns of a request smuggling vulnerability that affects basically all versions of ASP.NET Core.</p> <p>I described how request smuggling works in general, using a simple example of request smuggling to show how ambiguity in how HTTP is parsed can lead to HTTP proxies and HTTP servers in handling the same HTTP request in different ways. This can lead to the server seeing two requests where the proxy only sees a single request.</p> <p>After walking through a request smuggling example, I discussed some of the ways attackers could exploit a request smuggling vulnerability. That includes reflecting malicious data to other users of your app, exfiltrating authentication credentials or other data from client requests, invoking endpoints that shouldn&#39;t be publicly accessible, and various other attacks.</p> <p>Next I walked through the specific request smuggling vulnerability identified in CVE-2025-55315. This uses ambiguities in the parsing of chunk extensions when sending requests that use chunked transfer encoding. Chunk extensions are generally ignored by all servers, but lenient handling can lead to differential handling between proxy and server, providing an avenue for request smuggling.</p> <p>Finally, I walked through the mitigation steps you should take: patching your applications. I described the information we currently have about vulnerable or patched proxy servers, and how old versions of ASP.NET Core are not going to be getting patches, so will remain vulnerable (shout out again <a href="https://www.herodevs.com/blog-posts/critical-asp-net-vulnerability-cve-2025-55315-reported-upgrade-now">to HeroDevs for supporting .NET 6</a>). If you&#39;re running in AAS, <a href="https://azure.github.io/AppService/2025/10/20/dotnet-on-windows.html">then you&#39;re ok</a>, but otherwise, you need to check with your proxy provider to establish whether you are vulnerable or not.</p> </section></article>  <nav><a rel="next" href="https://novalis.org/adding-metadata-to-fallback-endpoints-in-aspnetcore/"><span><img src="https://novalis.org/content/images/2025/fallbackroutes_banner.png" alt="Adding metadata to fallback endpoints in ASP.NET Core"/></span> <span><label>Previous</label> <span>Adding metadata to fallback endpoints in ASP.NET Core</span></span></a></nav> </section> </div></div>
  </body>
</html>
