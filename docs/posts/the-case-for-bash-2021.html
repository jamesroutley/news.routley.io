<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.neversaw.us/2021/04/02/the-case-for-bash/">Original</a>
    <h1>The Case for Bash (2021)</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
        <nav>
          
            
          
        </nav>
        <section>
          <article>
            
<p><small><code>esac</code></small></p>
<p>Friends, coders, I come not to praise bash, but to contextualize
it.</p>
<p>Bash is oft-maligned: you hear it sneered at in sentences like &#34;our continuous
integration pipeline is just a <a href="https://mobile.twitter.com/search?q=%22pile+of+bash+scripts%22">pile of bash scripts</a>.&#34; It is commonly
regarded as unintelligible and thus unmaintainable. The pile of bash scripts
are the toxic byproduct of an infrastructure team understaffed, pressed for
time, unwilling or unable to do it &#34;the right way&#34; in a blessed programming
language, such as Ruby, Python, or, uh, ... YAML?</p>
<blockquote>
<p>some problems with bash:</p>
<ol>
<li>It&#39;s a weird &amp; counterintuitive language</li>
<li>you probably don&#39;t need to write it that often, so you don&#39;t practice</li>
<li>the times you DO need to use it, it&#39;s often because something important
(like a build) broke and it needs to be fixed RIGHT NOW</li>
</ol>
</blockquote>
<p>-- Julia Evans, <a href="https://twitter.com/b0rk">@b0rk</a>, <a href="https://twitter.com/b0rk/status/1337953874309754880">via tweet</a></p>
<p>Julia has a a <a href="https://wizardzines.com/zines/bite-size-bash/">great zine</a> that will get you comfortable with Bash. I&#39;m not
going to try to do that in this post! Instead, I&#39;m going to try to convince you
why it&#39;s <em>worth</em> learning Bash. To do that, I&#39;m going to talk about the problem
space that Bash thrives in, and why other languages are a bad fit for that same
space.</p>
<p>So, about problem spaces and languages. You might be familiar with the idea
that any language with <a href="https://wiki.c2.com/?TuringEquivalent">sufficient flow-control primitives</a> can express
the same algorithm that any other language of that class can express. In other
words, given access to the same system APIs, the same approach to solving a
problem could be expressed in Java, Ruby, or Bash. By comparison to art, if you
had to render an image of the inky blackness of outer space, you could
accomplish it with pen and ink or with a flat brush and paint. One approach
will save you a lot of time (and wrist problems!)</p>
<p>This is to state by example: certain tools are better adapted to certain
problems. You, as a programmer, are likely to run into a wide range of problems
requiring a corsucating variety of problem-solving approaches in your career.
The first, best tool that we can bring to bear on the problems before us is
<strong>language</strong>, and thankfully we have a variety from which to choose.</p>
<p>Languages lend themselves to solving a subset of the problems you&#39;re likely to
encounter. When selecting a language to fill a particular niche in your
toolset, there are a number of considerations: performance, popularity,
ubiquity, familiarity, capability, amongst others. Languages will overlap
niches: C, C++, Java, Go, and Rust are good choices for problems where
performance is a primary concern. Python, JavaScript, and Ruby are excellent
multitools where performance isn&#39;t a problem. All are popular languages with
active ecosystems. There is no universal correct answer, even amongst languages
with overlapping capabilities, because every language has different values that
suit different people.</p>
<blockquote>
<p>As a programmer, I think it behooves us to think about not just the values
that we hold, but the values of the people that use our software hold and, as
a programmer, you should use tools that align with your values.</p>
</blockquote>
<p>-- <a href="https://www.infoq.com/presentations/rust-tradeoffs/">&#34;How Rust Views Tradeoffs&#34;</a>, Steve Klabnik, <a href="https://twitter.com/steveklabnik">@steveklabnik</a></p>
<p>I haven&#39;t talked about Bash yet.</p>
<hr/>
<p>So, what does Bash value? One might be tempted to say &#34;ubiquity&#34;. Bash is
available nearly everywhere these days; but ubiquity is a quality that is
conferred from outside the language. Preserving ubiquity <em>can</em> be a value --
see JavaScript and backwards compatibility, or C and the PDP-11 -- but it&#39;s
difficult to positively <em>attain</em> ubiquity.</p>
<p>Instead, Bash values a <em>very</em> particular fitness for purpose: the management
and coordination of programs. This includes spawning processes, connecting
processes via pipelines, and parallelizing processes. The purpose of Bash is
<em>running other programs</em>. Consider the following:</p>
<pre data-lang="bash"><code data-lang="bash"><span>tail -fq /var/log/nginx/access.log </span><span>| </span><span>awk </span><span>&#39;{print $7}&#39; </span><span>| </span><span>sort </span><span>| </span><span>uniq -c </span><span>| </span><span>sort -rn
</span></code></pre>
<p>&#34;Follow the ngnix <a href="https://en.wikipedia.org/wiki/Common_Log_Format">access log</a>; print the 7th word (the path); sort those
paths, count the number of unique instances, and then sort the results by
occurrence count.&#34;</p>
<pre data-lang="js"><code data-lang="js"><span>const </span><span>{ </span><span>spawn </span><span>} </span><span>= </span><span>require</span><span>(</span><span>&#39;child_process&#39;</span><span>)
</span><span>
</span><span>const </span><span>tail </span><span>= </span><span>spawn</span><span>(</span><span>&#39;tail&#39;</span><span>, [</span><span>&#39;-fq&#39;</span><span>, </span><span>&#39;/var/log/nginx/access.log&#39;</span><span>])
</span><span>const </span><span>awk </span><span>= </span><span>spawn</span><span>(</span><span>&#39;awk&#39;</span><span>, [</span><span>&#39;{print $7}&#39;</span><span>], {stdio: [tail.stdout, </span><span>&#39;inherit&#39;</span><span>, </span><span>&#39;inherit&#39;</span><span>]})
</span><span>const </span><span>sort </span><span>= </span><span>spawn</span><span>(</span><span>&#39;sort&#39;</span><span>, [], {stdio: [awk.stdout, </span><span>&#39;inherit&#39;</span><span>, </span><span>&#39;inherit&#39;</span><span>])
</span><span>// ...
</span></code></pre>
<p>This is a contrived example, but there&#39;s a lot more <em>going on</em> in the Node
example than there is in the Bash one. The Python and Ruby versions would be
similar. The core data primitive of Bash is a <em>running process</em>. It has
distinct syntax for dealing with the input and output of those processes, for
capturing that output as a variable, and dealing with process exit conditions.
The boilerplate you&#39;d type in another programming language is the <em>default</em> in
Bash.</p>
<p>It values running programs over assigning variables, over branching, over
everything. If you don&#39;t believe me, consider that the common mode for <code>if</code>
statements in Bash is <code>if [ &lt;test&gt; ]; then &lt;stmt&gt;; fi</code>. Now go run <code>less /bin/[</code>. That&#39;s right: <code>[</code> is a <strong>program</strong> being run by the <code>if</code> builtin.</p>
<p>Bash&#39;s choices don&#39;t make a lot of sense coming from other languages: <code>0</code> is
&#34;true&#34; or &#34;success&#34;, strings inside variables often need to be re-quoted on
use, the loop and conditional logic is off-the-wall; but it makes sense in
<em>context</em> of its values (and, well, history.)</p>
<hr/>
<p>It&#39;s true that a lot of what I&#39;ve said about Bash is equally true of other
shell scripting languages: Fish, Zsh, Powershell, and Nushell all value similar
things. It&#39;s worth learning these languages! However, if you&#39;re dealing with
Linux servers on a daily basis, it&#39;s definitely worth learning Bash. Even if
you&#39;re not, it&#39;s worth learning just to understand what these other shell
scripting languages are reacting to. Bash&#39;s <code>for</code> loops might be weird, but if
you can familiarize yourself with them, you can use that knowledge everywhere
from your personal laptop to a server running on AWS and back down to a shell
running on your local router.</p>
<p>You (can) use Bash every time you open a terminal session. This knowledge
compounds over time: you don&#39;t have to learn the entire language to be more
efficient. You can layer in new concepts every few weeks and before you know
it, it&#39;ll be muscle memory. Any time you&#39;re presented with the need to write a
one-off program to accomplish a small task, take the opporunity to puzzle out
how to write it as a shell script. The difficulty of learning Bash is less in
learning the language itself, and more in identifying what programs you should
call to accomplish your goal. This is like any other language: finding the
right API and the right way to call it forms the bulk of day-to-day programming
effort. So, give it a whirl! Remember that there are <a href="https://httpie.io/">alternatives</a> to tricky
APIs! If you do, you&#39;ll have a valuable tool that fills a niche most other
popular programming languages struggle to address.</p>

          </article>
        </section>
    </div></div>
  </body>
</html>
