<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spritely.institute/static/papers/scheme-primer.html">Original</a>
    <h1>A Scheme Primer</h1>
    
    <div id="readability-page-1" class="page"><div id="content">


<p>
The following is a primer for the <a href="https://en.wikipedia.org/wiki/Scheme">Scheme</a> family of programming
languages.
It was originally written to aid newcomers to technology being
developed at <a href="https://spritely.institute/">The Spritely Institute</a> but is designed to be general
enough to be readable by anyone who is interested in Scheme.
</p>

<p>
This document is dual-licensed under <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache v2</a> and
<a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International</a> and its source is
<a href="https://gitlab.com/spritely/scheme-primer">publicly available</a>.
</p>

<div id="outline-container-introduction">
<h2 id="introduction"><span>1.</span> Introduction</h2>
<div id="text-introduction">
<p>
In all the world of computer programming, there are few languages as
simple, clean, comprehensive, powerful, and extensible as Scheme.  The
introduction to the <a href="https://schemers.org/Documents/Standards/R5RS/">R5RS</a> edition of Scheme&#39;s standardization<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup>
explains its philosophy well:
</p>

<blockquote>
<p>
Programming languages should be designed not by piling feature on top of
feature, but by removing the weaknesses and restrictions that make
additional features appear necessary.
</p>
</blockquote>

<p>
This minimalism means that the foundations of Scheme are easy to learn.
The R5RS introduction continues with:
</p>

<blockquote>
<p>
Scheme demonstrates that a very small number of rules for forming
expressions, with no restrictions on how they are composed, suffice to
form a practical and efficient programming language that is flexible
enough to support most of the major programming paradigms in use
today.
</p>
</blockquote>

<p>
With just a few rules and an incredibly simple syntax, Scheme manages
to be able to handle any language paradigm you can throw at it.
Its minimal base and strong support for extensibility means that it is
beloved by and frequently used as a foundation for academic language
research.
</p>

<p>
But a strong reputation in one domain can also be a weak reputation in
another.
Scheme&#39;s association with being an academic language has also lead it
to be frequently interpreted as too difficult for the &#34;average&#34;
programmer to adopt.
</p>

<p>
In reality, there is nothing difficult about Scheme, and any
programmer can learn it in a very short amount of time (even, maybe
especially, children and non-programmers).<sup><a id="fnr.2" href="#fn.2" role="doc-backlink">2</a></sup>
</p>

<p>
At the <a href="https://spritely.institute/">Spritely Institute</a>, we decided to base our core technology,
<a href="https://spritely.institute/goblins/">Spritely Goblins</a>, on Scheme.
We found that while there were excellent in-depth writings on Scheme,
and some simple and short Scheme tutorials, what was lacking was a
middle-of-the-road introduction.
The following is somewhere between a brief and comprehensive overview
of Scheme.
A shallow read of the following text is sufficient to begin being
productive with Scheme, but the enthusiastic reader will find much depth
(especially by reading the footnotes).
</p>

<p>
We begin with no assumption of programming experience, but
such experience will help speed the reader through some of the
early chapters.
The further we go in the tutorial, the more advanced topics become.
We will end with a real whammy:
<a href="#scheme-in-scheme">how to write a Scheme interpreter in Scheme</a>
in a mere 30 single lines of code.
</p>
</div>
</div>

<div id="outline-container-org50d925c">
<h2 id="org50d925c"><span>2.</span> Setting up</h2>
<div id="text-2">
<p>
You will need to choose a Scheme implementation to work with,
as well as an editor.
There are many choices for each, but we will narrow our suggestions
to two paths:
</p>

<ul>
<li><a href="https://www.gnu.org/software/guile/">Guile Scheme</a> + <a href="https://www.gnu.org/software/emacs/">GNU Emacs</a> + <a href="https://www.nongnu.org/geiser/">Geiser</a>: this is what this tutorial was
written using, and is a powerful option (which also opens the door
to working with <a href="https://guix.gnu.org/">Guix</a>, one of the most interesting Scheme projects
out there).  However, it is also a path with a considerable
learning curve.</li>
<li><a href="https://racket-lang.org/">Racket</a>, which comes with a built-in IDE called DrRacket.  This is
an easy path to get started with.</li>
</ul>

<p>
Some code examples are preceded by <code>REPL&gt;</code>.  <i>REPL</i> stands for
&#34;Read Eval Print Loop&#34;, which here means an interactive scheme prompt
to experiment with entering expressions.
</p>
</div>
</div>

<div id="outline-container-hello-scheme">
<h2 id="hello-scheme"><span>3.</span> Hello Scheme!</h2>
<div id="text-hello-scheme">
<p>
Here&#39;s the familiar &#34;hello world&#34;, written in Scheme:
</p>

<div>
<pre><span>(</span><span>display</span> <span>&#34;Hello world!\n&#34;</span><span>)</span>
</pre>
</div>

<p>
This prints &#34;Hello world!&#34; to the screen.
(The <code>&#34;\n&#34;</code> represents a &#34;newline&#34;, like if you pressed enter
after typing some text in a word processor.)
</p>

<p>
If you are familiar with other programming languages, this
might look a little bit familiar and a little bit different.
In most other programming languages, this might look like:
</p>

<div>
<pre>display(<span>&#34;Hello world!\n&#34;</span>)
</pre>
</div>

<p>
In this sense, calling functions in Scheme (and other Lisps like it)
is not too different than other languages, except that the function
name goes inside the parentheses.
</p>
</div>
</div>

<div id="outline-container-scheme-basic-types">
<h2 id="scheme-basic-types"><span>4.</span> Basic types, a few small functions</h2>
<div id="text-scheme-basic-types">
<p>
Unlike in some other languages, math expressions like <code>+</code> and <code>-</code>
are prefix functions just like any other function, and so they go
first:
</p>

<div>
<pre><span>(</span><span>+</span> <span>1</span> <span>2</span><span>)</span>         <span>; </span><span>=&gt; 3</span>
<span>(</span><span>/</span> <span>10</span> <span>2</span><span>)</span>        <span>; </span><span>=&gt; 5</span>
<span>(</span><span>/</span> <span>2</span> <span>3</span><span>)</span>         <span>; </span><span>=&gt; 2/3 </span>
</pre>
</div>

<p>
Most of these can accept multiple arguments:
</p>

<div>
<pre><span>(</span><span>+</span> <span>1</span> <span>8</span> <span>10</span><span>)</span>   <span>; </span><span>equivalent to &#34;1 + 8 + 10&#34; in infix notation</span>
</pre>
</div>

<p>
Procedures can also be nested, and we can use the &#34;substitution
method&#34; to see how they simplify:
</p>

<div>
<pre><span>(</span><span>*</span> <span>(</span><span>-</span> <span>8</span> <span>(</span><span>/</span> <span>30</span> <span>5</span><span>)</span><span>)</span> <span>21</span><span>)</span>   <span>; </span><span>beginning expression</span>
<span>(</span><span>*</span> <span>(</span><span>-</span> <span>8</span> <span>6</span><span>)</span> <span>21</span><span>)</span>          <span>; </span><span>simplify: (/ 30 5) =&gt; 6</span>
<span>(</span><span>*</span> <span>2</span> <span>21</span><span>)</span>                <span>; </span><span>simplify: (- 8 6)  =&gt; 2</span>
<span>42</span>                      <span>; </span><span>simplify: (* 2 21) =&gt; 42</span>
</pre>
</div>

<p>
A variety of types are supported.
For example, here are some math types:
</p>

<div>
<pre><span>42</span>          <span>; </span><span>integer</span>
<span>98.6</span>        <span>; </span><span>floating point</span>
<span>2/3</span>         <span>; </span><span>fractions, or &#34;rational&#34; numbers</span>
<span>-42</span>         <span>; </span><span>these can all also be negative</span>
</pre>
</div>

<p>
Since Scheme supports both &#34;exact&#34; numbers like integers and fractions,
and does not have any restriction on number size, it is very good for
more precise scientific and mathematical computing.
The floating point representation is considered &#34;inexact&#34;, and throws
away precision for speed.
</p>

<p>
Here are some more types:
</p>

<div>
<pre><span>#t</span>                             <span>; </span><span>boolean representing &#34;true&#34;</span>
<span>#f</span>                             <span>; </span><span>boolean representing &#34;false&#34;</span>
<span>&#34;Pangalactic Gargleblaster&#34;</span>    <span>; </span><span>string (text)</span>
&#39;<span>foo</span>                           <span>; </span><span>symbol</span>
&#39;<span>(</span><span>1</span> <span>2</span> <span>3</span><span>)</span>                       <span>; </span><span>a list (of numbers, in this case)</span>
<span>(</span><span>lambda</span> <span>(</span><span>x</span><span>)</span> <span>(</span><span>*</span> <span>x</span> <span>2</span><span>)</span><span>)</span>           <span>; </span><span>procedure (we&#39;ll come back to this)</span>
&#39;<span>(</span><span>lambda</span> <span>(</span><span>x</span><span>)</span> <span>(</span><span>*</span> <span>x</span> <span>2</span><span>)</span><span>)</span>          <span>; </span><span>a list of lists, symbols, and numbers</span>
</pre>
</div>

<p>
Symbols are maybe the strangest type if you&#39;ve come from non-Lisp
programming languages (with some exceptions).
While symbols look kind of like strings, they represent something
more programmatic.
(In <i>Goblins</i>&#39; <code>methods</code> syntax, we use symbols to represent method
names.)
Curiously, if a Lisp expression itself is quoted with <code>&#39;</code>, as in
the quoted <code>lambda</code> expression above, the symbols inside are also
automatically quoted.
</p>

<p>
We will devote some time to discussing lists in
<a href="#scheme-lists-and-cons">Lists and &#34;cons&#34;</a>.
The combination of lists and symbols is featured very prominently in
many Lisps, including Scheme, because they lie at the heart of
Lisp&#39;s extensibility: code which can write code.
We will see how to take advantage of this power in
<a href="#scheme-extensibility">On the extensibility of Scheme (and Lisps in general)</a>.
</p>
</div>
</div>

<div id="outline-container-scheme-variables-and-procedures">
<h2 id="scheme-variables-and-procedures"><span>5.</span> Variables and procedures</h2>
<div id="text-scheme-variables-and-procedures">
<p>
We can assign values to variables using <code>define</code>:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>name</span> <span>&#34;Jane&#34;</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>string-append</span> <span>&#34;Hello &#34;</span> <span>name</span> <span>&#34;!&#34;</span><span>)</span>
<span>; </span><span>=&gt; &#34;Hello Jane!&#34;</span>
</pre>
</div>

<p>
However, if what follows <code>define</code> is wrapped in parentheses,
Scheme interprets this as a procedure definition:
</p>

<div>
<pre><span>(</span><span>define</span> <span>(</span><span>greet</span> <span>name</span><span>)</span>
  <span>(</span><span>string-append</span> <span>&#34;Hello &#34;</span> <span>name</span> <span>&#34;!&#34;</span><span>)</span><span>)</span>
</pre>
</div>

<p>
Now that we have named this procedure we can invoke it:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>greet</span> <span>&#34;Samantha&#34;</span><span>)</span>
<span>; </span><span>=&gt; &#34;Hello Samantha!&#34;</span>
</pre>
</div>

<p>
Note that <i>Scheme</i> has <i>implicit return</i>.
By being the last expression in the procedure, the result
of the <code>string-append</code> is automatically returned to its caller.
</p>

<p>
This second syntax for <code>define</code> is actually just <i>syntactic sugar</i>.
These two definitions of <code>greet</code> are exactly the same:
</p>

<div>
<pre><span>(</span><span>define</span> <span>(</span><span>greet</span> <span>name</span><span>)</span>
  <span>(</span><span>string-append</span> <span>&#34;Hello &#34;</span> <span>name</span> <span>&#34;!&#34;</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>greet</span>
  <span>(</span><span>lambda</span> <span>(</span><span>name</span><span>)</span>
    <span>(</span><span>string-append</span> <span>&#34;Hello &#34;</span> <span>name</span> <span>&#34;!&#34;</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
<code>lambda</code> is the name for an &#34;anonymous procedure&#34; (ie, no name
provided).
While we have given this the name <code>greet</code>, the procedure
would be usable without it:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>(</span><span>lambda</span> <span>(</span><span>name</span><span>)</span>
         <span>(</span><span>string-append</span> <span>&#34;Hello &#34;</span> <span>name</span> <span>&#34;!&#34;</span><span>)</span><span>)</span>
       <span>&#34;Horace&#34;</span><span>)</span>
<span>; </span><span>=&gt; &#34;Hello Horace!&#34;</span>
</pre>
</div>

<p>
There is also another way to name things aside from <code>define</code>,
which is <code>let</code>, which allows for a sequence of bound variables
and then a body which is evaluated with those bindings.
<code>let</code> has the form:
</p>

<div>
<pre><span>(</span><span>let</span> <span>(</span><span>(</span><span>&lt;VARIABLE-NAME&gt;</span> <span>&lt;VALUE-EXPRESSION&gt;</span><span>)</span> <span>...</span><span>)</span>
  <span>&lt;BODY&gt;</span> <span>...</span><span>)</span>
</pre>
</div>

<p>
(The <code>...</code> in the above example represents that its previous
expression can be repeated multiple times.)
</p>

<p>
Here is an example of <code>let</code> in use:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>let</span> <span>(</span><span>(</span><span>name</span> <span>&#34;Horace&#34;</span><span>)</span><span>)</span>
        <span>(</span><span>string-append</span> <span>&#34;Hello &#34;</span> <span>name</span> <span>&#34;!&#34;</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; &#34;Hello Horace!&#34;</span>
</pre>
</div>

<p>
Clever readers may notice that this looks very similar to the previous
example, and in fact, <code>let</code> is <i>syntax sugar</i> for a lambda which is
immediately applied with arguments.
The two previous code examples are fully equivalent:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>let</span> <span>(</span><span>(</span><span>name</span> <span>&#34;Horace&#34;</span><span>)</span><span>)</span>
        <span>(</span><span>string-append</span> <span>&#34;Hello &#34;</span> <span>name</span> <span>&#34;!&#34;</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; &#34;Hello Horace!&#34;</span>
<span>REPL&gt;</span> <span>(</span><span>(</span><span>lambda</span> <span>(</span><span>name</span><span>)</span>
         <span>(</span><span>string-append</span> <span>&#34;Hello &#34;</span> <span>name</span> <span>&#34;!&#34;</span><span>)</span><span>)</span>
       <span>&#34;Horace&#34;</span><span>)</span>
<span>; </span><span>=&gt; &#34;Hello Horace!&#34;</span>
</pre>
</div>

<p>
<code>let*</code> is like <code>let</code>, but allows bindings to refer to previous
bindings within the expression:<sup><a id="fnr.3" href="#fn.3" role="doc-backlink">3</a></sup>
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>let*</span> <span>(</span><span>(</span><span>name</span> <span>&#34;Horace&#34;</span><span>)</span>
             <span>(</span><span>greeting</span>
              <span>(</span><span>string-append</span> <span>&#34;Hello &#34;</span> <span>name</span> <span>&#34;!\n&#34;</span><span>)</span><span>)</span><span>)</span>
        <span>(</span><span>display</span> <span>greeting</span><span>)</span><span>)</span>   <span>; </span><span>print greeting to screen</span>
<span>; </span><span>prints: Hello Horace!</span>
</pre>
</div>

<p>
It is possible to manually apply a list of arguments to a procedure
using <code>apply</code>.
for example, to sum a list of numbers, we can use <code>apply</code> and <code>+</code>
in combination:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>apply</span> <span>+</span> &#39;<span>(</span><span>1</span> <span>2</span> <span>5</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; 8</span>
</pre>
</div>

<p>
As the inverse of this, it is possible to capture a variable-length
set of arguments using &#34;dot notation&#34;.<sup><a id="fnr.4" href="#fn.4" role="doc-backlink">4</a></sup>
Here we show this off while also demonstrating Guile&#39;s <code>format</code>
(which when called with <code>#f</code> as its first argument returns a
formatted string as a value, and when called with <code>#t</code> as its first
argument prints to the screen, the latter of which is what we want
here):
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>chatty-add</span> <span>chatty-name</span> <span>.</span> <span>nums</span><span>)</span>
        <span>(</span><span>format</span> <span>#t</span> <span>&#34;&lt;~a&gt; If you add those together you get ~a!\n&#34;</span>
                <span>chatty-name</span> <span>(</span><span>apply</span> <span>+</span> <span>nums</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>chatty-add</span> <span>&#34;Chester&#34;</span> <span>2</span> <span>4</span> <span>8</span> <span>6</span><span>)</span>
<span>; </span><span>Prints:</span>
<span>;   </span><span>&lt;Chester&gt; If you add those together you get 20!</span>
</pre>
</div>

<p>
While not standard in Scheme, many Scheme implementations also
support optional and keyword arguments.
Guile implements this abstraction as <code>define*</code>:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define*</span> <span>(</span><span>shopkeeper</span> <span>thing-to-buy</span>
                           <span>#:optional</span> <span>(</span><span>how-many</span> <span>1</span><span>)</span>
                           <span>(</span><span>cost</span> <span>20</span><span>)</span>
                           <span>#:key</span> <span>(</span><span>shopkeeper</span> <span>&#34;Sammy&#34;</span><span>)</span>
                           <span>(</span><span>store</span> <span>&#34;Plentiful Great Produce&#34;</span><span>)</span><span>)</span>
        <span>(</span><span>format</span> <span>#t</span> <span>&#34;You walk into ~a, grab something from the shelves,\n&#34;</span>
                <span>store</span><span>)</span>
        <span>(</span><span>display</span> <span>&#34;and walk up to the counter.\n\n&#34;</span><span>)</span>
        <span>(</span><span>format</span> <span>#t</span> <span>&#34;~a looks at you and says, &#34;</span>
                <span>shopkeeper</span><span>)</span>
        <span>(</span><span>format</span> <span>#t</span> <span>&#34;&#39;~a ~a, eh? That&#39;ll be ~a coins!\n&#34;</span>
                <span>how-many</span> <span>thing-to-buy</span>
                <span>(</span><span>*</span> <span>cost</span> <span>how-many</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>shopkeeper</span> <span>&#34;apples&#34;</span><span>)</span>
<span>; </span><span>Prints:</span>
<span>;   </span><span>You walk into Plentiful Great Produce, grab something from the shelves,</span>
<span>;   </span><span>and walk up to the counter.</span>
<span>;</span>
<span>;   </span><span>Sammy looks at you and says, &#39;1 apples, eh? That&#39;ll be 20 coins!&#39;</span>
<span>REPL&gt;</span> <span>(</span><span>shopkeeper</span> <span>&#34;bananas&#34;</span> <span>10</span> <span>28</span><span>)</span>
<span>; </span><span>Prints:</span>
<span>;   </span><span>You walk into Plentiful Great Produce, grab something from the shelves,</span>
<span>;   </span><span>and walk up to the counter.</span>
<span>;</span>
<span>;   </span><span>Sammy looks at you and says, &#39;10 bananas, eh? That&#39;ll be 280 coins!&#39;</span>
<span>REPL&gt;</span> <span>(</span><span>shopkeeper</span> <span>&#34;screws&#34;</span> <span>3</span> <span>2</span>
                  <span>#:shopkeeper</span> <span>&#34;Horace&#34;</span>
                  <span>#:store</span> <span>&#34;Horace&#39;s Hardware&#34;</span><span>)</span>
<span>; </span><span>Prints:</span>
<span>;   </span><span>You walk into Horace&#39;s Hardware, grab something from the shelves,</span>
<span>;   </span><span>and walk up to the counter.</span>
<span>;</span>
<span>;   </span><span>Horace looks at you and says, &#39;3 screws, eh? That&#39;ll be 6 coins!&#39;</span>
</pre>
</div>

<p>
Finally, Scheme&#39;s procedures can do something else interesting:
they can return multiple values using… <code>values</code>!
As a particularly silly example, perhaps we would like to compare
what it&#39;s like to both add and multiply two numbers:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>add-and-multiply</span> <span>x</span> <span>y</span><span>)</span>
        <span>(</span><span>values</span> <span>(</span><span>+</span> <span>x</span> <span>y</span><span>)</span>
                <span>(</span><span>*</span> <span>x</span> <span>y</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>add-and-multiply</span> <span>2</span> <span>8</span><span>)</span>
<span>; </span><span>=&gt; 10</span>
<span>; </span><span>=&gt; 16</span>
<span>REPL&gt;</span> <span>(</span><span>define-values</span> <span>(</span><span>added</span> <span>multiplied</span><span>)</span>
        <span>(</span><span>add-and-multiply</span> <span>3</span> <span>10</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>added</span>
<span>; </span><span>=&gt; 13</span>
<span>REPL&gt;</span> <span>multiplied</span>
<span>; </span><span>=&gt; 30</span>
</pre>
</div>

<p>
As you can see, we can capture said values with <code>define-values</code>, as
shown above.  (<code>let-values</code> and <code>call-with-values</code> can also be used,
but that&#39;s enough new syntax for this section!)
</p>
</div>
</div>

<div id="outline-container-scheme-conditionals-and-predicates">
<h2 id="scheme-conditionals-and-predicates"><span>6.</span> Conditionals and predicates</h2>
<div id="text-scheme-conditionals-and-predicates">
<p>
Sometimes we would like to test whether or not something is true.
For instance, we can see whether or not an object is a string
by using the <code>string?</code>:<sup><a id="fnr.5" href="#fn.5" role="doc-backlink">5</a></sup>
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>string?</span> <span>&#34;apple&#34;</span><span>)</span>
<span>; </span><span>=&gt; #t</span>
<span>REPL&gt;</span> <span>(</span><span>string?</span> <span>128</span><span>)</span>
<span>; </span><span>=&gt; #f</span>
<span>REPL&gt;</span> <span>(</span><span>string?</span> &#39;<span>apple</span><span>)</span>
<span>; </span><span>=&gt; #f</span>
</pre>
</div>

<p>
(Remember that <code>#t</code> represents &#34;true&#34; and <code>#f</code> represents &#34;false&#34;.)
</p>

<p>
We can use this in combination with <code>if</code>, which has the form:
</p>

<div>
<pre><span>(</span><span>if</span> <span>&lt;TEST&gt;</span>
    <span>&lt;CONSEQUENT&gt;</span>
    <span>[</span><span>&lt;ALTERNATE&gt;</span><span>]</span><span>)</span>
</pre>
</div>

<p>
(The square brackets around <code>&lt;ALTERNATE&gt;</code> means that it is optional.)<sup><a id="fnr.6" href="#fn.6" role="doc-backlink">6</a></sup>
</p>

<p>
So, we could write a silly function that excitedly reports on
whether or not an object is a string or not:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>string-enthusiast</span> <span>obj</span><span>)</span>
        <span>(</span><span>if</span> <span>(</span><span>string?</span> <span>obj</span><span>)</span>
            <span>&#34;Oh my gosh you gave me A STRING!!!&#34;</span>
            <span>&#34;That WASN&#39;T A STRING AT ALL!! MORE STRINGS PLEASE!&#34;</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>string-enthusiast</span> <span>&#34;carrot&#34;</span><span>)</span>
<span>; </span><span>=&gt; &#34;Oh my gosh you gave me A STRING!!!&#34;</span>
<span>REPL&gt;</span> <span>(</span><span>string-enthusiast</span> <span>529</span><span>)</span>
<span>; </span><span>=&gt; &#34;That WASN&#39;T A STRING AT ALL!! MORE STRINGS PLEASE!&#34;</span>
</pre>
</div>

<p>
As we can see, unlike in some other popular languages, <code>if</code> also
returns the value of evaluating whichever branch is chosen based on
<code>&lt;TEST&gt;</code>.
</p>

<p>
Scheme also ships with some mathematical comparison tests.  <code>&gt;</code> and
<code>&lt;</code> stand for &#34;greater than&#34; and &#34;less than&#34; respectively, and <code>&gt;=</code>
and <code>&lt;=</code> stand for &#34;greater than or equal to&#34; and &#34;less than or equal
to&#34;, while <code>=</code> checks for numerical equality:<sup><a id="fnr.7" href="#fn.7" role="doc-backlink">7</a></sup>
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>&gt;</span> <span>8</span> <span>9</span><span>)</span>
<span>; </span><span>=&gt; #f</span>
<span>REPL&gt;</span> <span>(</span><span>&lt;</span> <span>8</span> <span>9</span><span>)</span>
<span>; </span><span>=&gt; #t</span>
<span>REPL&gt;</span> <span>(</span><span>&gt;</span> <span>8</span> <span>8</span><span>)</span>
<span>; </span><span>=&gt; #f</span>
<span>REPL&gt;</span> <span>(</span><span>&gt;=</span> <span>8</span> <span>8</span><span>)</span>
<span>; </span><span>=&gt; #t</span>
</pre>
</div>

<p>
If we wanted to test for multiple possibilities, we could use nested
<code>if</code> statements:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>goldilocks</span> <span>n</span> <span>smallest-ok</span> <span>biggest-ok</span><span>)</span>
        <span>(</span><span>if</span> <span>(</span><span>&lt;</span> <span>n</span> <span>smallest-ok</span><span>)</span>
            <span>&#34;Too small!&#34;</span>
            <span>(</span><span>if</span> <span>(</span><span>&gt;</span> <span>n</span> <span>biggest-ok</span><span>)</span>
                <span>&#34;Too big!&#34;</span>
                <span>&#34;Just right!&#34;</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>goldilocks</span> <span>3</span> <span>10</span> <span>20</span><span>)</span>
<span>; </span><span>=&gt; &#34;Too small!&#34;</span>
<span>REPL&gt;</span> <span>(</span><span>goldilocks</span> <span>33</span> <span>10</span> <span>20</span><span>)</span>
<span>; </span><span>=&gt; &#34;Too big!&#34;</span>
<span>REPL&gt;</span> <span>(</span><span>goldilocks</span> <span>12</span> <span>10</span> <span>20</span><span>)</span>
<span>; </span><span>=&gt; &#34;Just right!&#34;</span>
</pre>
</div>

<p>
However, there is a much nicer syntax named <code>cond</code> which
we can use instead which has the following form:<sup><a id="fnr.8" href="#fn.8" role="doc-backlink">8</a></sup>
</p>

<div>
<pre><span>(</span><span>cond</span>
 <span>(</span><span>&lt;TEST&gt;</span>
  <span>&lt;THEN-BODY&gt;</span> <span>...</span><span>)</span> <span>...</span>
 <span>[</span><span>(</span><span>else</span> <span>&lt;ELSE-BODY&gt;</span> <span>...</span><span>)</span><span>]</span><span>)</span>
</pre>
</div>

<p>
Compare how much nicer our <code>goldilocks</code> procedure looks with <code>cond</code>
instead of nested <code>if</code> statements:
</p>

<div>
<pre><span>;; </span><span>Nested &#34;if&#34; version</span>
<span>(</span><span>define</span> <span>(</span><span>goldilocks</span> <span>n</span> <span>smallest-ok</span> <span>biggest-ok</span><span>)</span>
  <span>(</span><span>if</span> <span>(</span><span>&lt;</span> <span>n</span> <span>smallest-ok</span><span>)</span>
      <span>&#34;Too small!&#34;</span>
      <span>(</span><span>if</span> <span>(</span><span>&gt;</span> <span>n</span> <span>biggest-ok</span><span>)</span>
          <span>&#34;Too big!&#34;</span>
          <span>&#34;Just right!&#34;</span><span>)</span><span>)</span><span>)</span>

<span>;; </span><span>&#34;cond&#34; version</span>
<span>(</span><span>define</span> <span>(</span><span>goldilocks</span> <span>n</span> <span>smallest-ok</span> <span>biggest-ok</span><span>)</span>
  <span>(</span><span>cond</span>
   <span>(</span><span>(</span><span>&lt;</span> <span>n</span> <span>smallest-ok</span><span>)</span>
    <span>&#34;Too small!&#34;</span><span>)</span>
   <span>(</span><span>(</span><span>&gt;</span> <span>n</span> <span>biggest-ok</span><span>)</span>
    <span>&#34;Too big!&#34;</span><span>)</span>
   <span>(</span><span>else</span>
    <span>&#34;Just right!&#34;</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
Scheme also provides some different ways to compare whether or not
two objects are the same thing.
The shortest, simplest (but not comprehensive) summary of the zoo of
equality predicates is that <code>equal?</code> compares based on content
equivalence, whereas <code>eq?</code> compares based on object identity (as
defined by the language&#39;s runtime).<sup><a id="fnr.9" href="#fn.9" role="doc-backlink">9</a></sup>
For example, <code>list</code> constructs a fresh list with a new identity
every time, so the following are <code>equal?</code> but not <code>eq?</code>:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>a-list</span> <span>(</span><span>list</span> <span>1</span> <span>2</span> <span>3</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>define</span> <span>b-list</span> <span>(</span><span>list</span> <span>1</span> <span>2</span> <span>3</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>equal?</span> <span>a-list</span> <span>a-list</span><span>)</span>
<span>; </span><span>=&gt; #t</span>
<span>REPL&gt;</span> <span>(</span><span>eq?</span> <span>a-list</span> <span>a-list</span><span>)</span>
<span>; </span><span>=&gt; #t</span>
<span>REPL&gt;</span> <span>(</span><span>equal?</span> <span>a-list</span> <span>b-list</span><span>)</span>
<span>; </span><span>=&gt; #t</span>
<span>REPL&gt;</span> <span>(</span><span>eq?</span> <span>a-list</span> <span>b-list</span><span>)</span>
<span>; </span><span>=&gt; #f</span>
</pre>
</div>

<p>
Finally, in Scheme, anything that&#39;s not <code>#f</code> is considered
true.
This is sometimes used with something like <code>member</code>, which looks
for matching elements and returns the remaining list if anything
is found, and <code>#f</code> otherwise:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>member</span> &#39;<span>b</span> &#39;<span>(</span><span>a</span> <span>b</span> <span>c</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; (b c)</span>
<span>REPL&gt;</span> <span>(</span><span>member</span> &#39;<span>z</span> &#39;<span>(</span><span>a</span> <span>b</span> <span>c</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; #f</span>
<span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>fruit-sleuth</span> <span>fruit</span> <span>basket</span><span>)</span>
        <span>(</span><span>if</span> <span>(</span><span>member</span> <span>fruit</span> <span>basket</span><span>)</span>
            <span>&#34;Found the fruit you&#39;re looking for!&#34;</span>
            <span>&#34;No fruit found! Gadzooks!&#34;</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>define</span> <span>fruit-basket</span> &#39;<span>(</span><span>apple</span> <span>banana</span> <span>citron</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>fruit-sleuth</span> &#39;<span>banana</span> <span>fruit-basket</span><span>)</span>
<span>; </span><span>=&gt; &#34;Found the fruit you&#39;re looking for!&#34;</span>
<span>REPL&gt;</span> <span>(</span><span>fruit-sleuth</span> &#39;<span>pineapple</span> <span>fruit-basket</span><span>)</span>
<span>; </span><span>=&gt; &#34;No fruit found! Gadzooks!&#34;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-scheme-lists-and-cons">
<h2 id="scheme-lists-and-cons"><span>7.</span> Lists and &#34;cons&#34;</h2>
<div id="text-scheme-lists-and-cons">
<p>
&#34;My other CAR is a CDR&#34;</p>

<p>
For structured data, Scheme supports lists, which can contain any
other type.<sup><a id="fnr.10" href="#fn.10" role="doc-backlink">10</a></sup>  Here are two ways to write the
same list:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>list</span> <span>1</span> <span>2</span> <span>&#34;cat&#34;</span> <span>33.8</span> &#39;<span>foo</span><span>)</span>
<span>; </span><span>=&gt; (1 2 &#34;cat&#34; 33.8 foo)</span>
<span>REPL&gt;</span> &#39;<span>(</span><span>1</span> <span>2</span> <span>&#34;cat&#34;</span> <span>33.8</span> <span>foo</span><span>)</span>
<span>; </span><span>=&gt; (1 2 &#34;cat&#34; 33.8 foo)</span>
</pre>
</div>

<p>
One difference between the two above is that in the latter quoted
example, the symbol &#34;foo&#34; did not need to be quoted, since the outer
list&#39;s quoting implicitly quoted it.
</p>

<p>
There is a &#34;special&#34; list known as &#34;the empty list&#34;, which is a list
with no elements, simply designated <code>&#39;()</code> (also known as <i>nil</i>,
and which is the only object which will return <code>#t</code> in response to
the predicate <code>null?</code> in standard Scheme).
Lists in <i>Scheme</i> are actually &#34;linked lists&#34;, which are combinations
of pairs called &#34;cons cells&#34; that terminate in the empty
list:
</p>

<div>
<pre><span>REPL&gt;</span> &#39;<span>()</span>
<span>; </span><span>=&gt; ()</span>
<span>REPL&gt;</span> <span>(</span><span>cons</span> &#39;<span>a</span> &#39;<span>()</span><span>)</span>
<span>; </span><span>=&gt; (a)</span>
<span>REPL&gt;</span> <span>(</span><span>cons</span> &#39;<span>a</span> <span>(</span><span>cons</span> &#39;<span>b</span> <span>(</span><span>cons</span> &#39;<span>c</span> &#39;<span>()</span><span>)</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; (a b c)</span>
</pre>
</div>

<p>
The latter of which is equivalent to either:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>list</span> &#39;<span>a</span> &#39;<span>b</span> &#39;<span>c</span><span>)</span>
<span>; </span><span>=&gt; (a b c)</span>
<span>REPL&gt;</span> &#39;<span>(</span><span>a</span> <span>b</span> <span>c</span><span>)</span>
<span>; </span><span>=&gt; (a b c)</span>
</pre>
</div>

<p>
For very historical reasons,<sup><a id="fnr.11" href="#fn.11" role="doc-backlink">11</a></sup>
accessing the first element of a cons cell is done with <code>car</code> and the
second element of a cons cell with <code>cdr</code> (pronounced &#34;could-er&#34;):<sup><a id="fnr.12" href="#fn.12" role="doc-backlink">12</a></sup>
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>car</span> &#39;<span>(</span><span>a</span> <span>b</span> <span>c</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; a</span>
<span>REPL&gt;</span> <span>(</span><span>cdr</span> &#39;<span>(</span><span>a</span> <span>b</span> <span>c</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; (b c)</span>
<span>REPL&gt;</span> <span>(</span><span>car</span> <span>(</span><span>cdr</span> &#39;<span>(</span><span>a</span> <span>b</span> <span>c</span><span>)</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; b</span>
</pre>
</div>

<p>
The second member of <code>cons</code> does not have to be another cons cell or
the empty list.  If not, it is considered a &#34;dotted list&#34;, and has an
unusual-for-lisp infix syntax:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>cons</span> &#39;<span>a</span> &#39;<span>b</span><span>)</span>
<span>; </span><span>=&gt; (a . b)</span>
</pre>
</div>

<p>
Notice how this is structurally different from the following:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>cons</span> &#39;<span>a</span> <span>(</span><span>cons</span> &#39;<span>b</span> &#39;<span>()</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; (a b)</span>
</pre>
</div>

<p>
It&#39;s easy to get caught up on piecing apart <code>cons</code> cells (arguably
schemers do far too often, but <code>cons</code> is also elegantly
powerful).<sup><a id="fnr.13" href="#fn.13" role="doc-backlink">13</a></sup>
</p>

<p>
In a sense, this subsection is a digression.  We intentionally
do not use <code>cons</code> too much in this paper, and we have entirely
kept <code>car</code> and <code>cdr</code> out of the main text.  This may lead to the
question, why contain this subsection on lists at all?
</p>

<p>
The reason is that we are building up to something we will explore
further shortly, the extensibility of Scheme.  Scheme is written in
its core data types, and is modifiable as such.  We will get to this
more shortly, but as an example, we can quote any expression,
transforming code into data:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>+</span> <span>1</span> <span>2</span> <span>(</span><span>-</span> <span>8</span> <span>4</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; 7</span>
<span>REPL&gt;</span> &#39;<span>(</span><span>+</span> <span>1</span> <span>2</span> <span>(</span><span>-</span> <span>8</span> <span>4</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; (+ 1 2 (- 8 4))</span>
<span>REPL&gt;</span> <span>(</span><span>let</span> <span>(</span><span>(</span><span>name</span> <span>&#34;Horace&#34;</span><span>)</span><span>)</span>
        <span>(</span><span>string-append</span> <span>&#34;Hello &#34;</span> <span>name</span> <span>&#34;!&#34;</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; &#34;Hello Horace!&#34;</span>
<span>REPL&gt;</span> &#39;<span>(</span><span>let</span> <span>(</span><span>(</span><span>name</span> <span>&#34;Horace&#34;</span><span>)</span><span>)</span>
         <span>(</span><span>string-append</span> <span>&#34;Hello &#34;</span> <span>name</span> <span>&#34;!&#34;</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; (let ((name &#34;Horace&#34;)) (string-append &#34;Hello &#34; name &#34;!&#34;))</span>
</pre>
</div>

<p>
This last example is especially curious: we finally see the reason
for symbols in Scheme to be important, as the function and syntax
names become captured as symbols upon being quoted.
In this sense, Lisp (including Scheme) is written in Lisp: there
is little distinction between the representation the programmer
sees and the representation the compiler sees, as see in
<a href="#scheme-extensibility">On the extensibility of Scheme (and Lisps in general)</a>.
</p>

<p>
By the way, the apostrophe quote is just a shorthand for
<code>(quote &lt;EXPR&gt;)</code>:
</p>

<div>
<pre><span>;; </span><span>these two are the same</span>
&#39;<span>foo</span>
<span>(</span><span>quote</span> <span>foo</span><span>)</span>

<span>;; </span><span>and these two are the same</span>
&#39;<span>(</span><span>lambda</span> <span>(</span><span>x</span><span>)</span> <span>(</span><span>*</span> <span>x</span> <span>2</span><span>)</span><span>)</span>
<span>(</span><span>quote</span> <span>(</span><span>lambda</span> <span>(</span><span>x</span><span>)</span> <span>(</span><span>*</span> <span>x</span> <span>2</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>


<p>
Lists can also be used as an associative mapping between keys
and values, called <i>alists</i> (association lists).
A variety of procedures for convenient lookup exist, such as
<code>assoc</code>, which returns the pair if found or <code>#f</code> if not:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>animal-noises</span>
        &#39;<span>(</span><span>(</span><span>cat</span> <span>.</span> <span>meow</span><span>)</span>
          <span>(</span><span>dog</span> <span>.</span> <span>woof</span><span>)</span>
          <span>(</span><span>sheep</span> <span>.</span> <span>baa</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>assoc</span> &#39;<span>cat</span> <span>animal-noises</span>
<span>; </span><span>=&gt; (cat . meow)</span>
<span>REPL&gt;</span> <span>(</span><span>assoc</span> &#39;<span>alien</span> <span>animal-noises</span><span>)</span>
<span>; </span><span>=&gt; #f</span>
</pre>
</div>

<p>
Association lists are easy to implement, look nice enough in
Scheme&#39;s printed representation, and are easy to use with
functional programming.
(Want to add more to an alist?  Just cons on another cons cell!)
This means they tend to be popular with schemers.
However, they are not always efficient.
While <code>assoc</code> is fine for small alists, an alist that is
one thousand elements long will take one thousand steps to find
a key-value pair buried at its bottom.
Other datastructures, such as hashmaps which provide constant-time
average lookups, are commonly provided in many Scheme implementations,
and are sometimes a better choice.
</p>

<p>
Aside from quote, it is also possible to use quasiquote, which uses
the backtick to begin a quasiquote, and the comma to unquote.
In this way we can move quickly between the world of data and code.
For example, using a somewhat apocryphal metric for converting
cat years to human years:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>cat-years</span> <span>years</span><span>)</span>
        <span>(</span><span>cond</span>
         <span>(</span><span>(</span><span>&lt;=</span> <span>years</span> <span>1</span><span>)</span>       <span>; </span><span>first year equivalent to 15</span>
          <span>(</span><span>*</span> <span>years</span> <span>15</span><span>)</span><span>)</span>
         <span>(</span><span>(</span><span>&lt;=</span> <span>years</span> <span>2</span><span>)</span>
          <span>(</span><span>+</span> <span>15</span> <span>(</span><span>*</span> <span>9</span> <span>(</span><span>-</span> <span>years</span> <span>1</span><span>)</span><span>)</span><span>)</span><span>)</span>   <span>;      </span><span>second year 9</span>
         <span>(</span><span>else</span>
          <span>(</span><span>+</span> <span>24</span> <span>(</span><span>*</span> <span>4</span> <span>(</span><span>-</span> <span>years</span> <span>2</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span> <span>; </span><span>years after that 4</span>
<span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>cat-entry</span> <span>name</span> <span>age</span><span>)</span>
        `<span>(</span><span>cat</span> <span>(</span><span>name</span> ,<span>name</span><span>)</span>
              <span>(</span><span>age</span>  ,<span>age</span><span>)</span>
              <span>(</span><span>cat-years-age</span> ,<span>(</span><span>cat-years</span> <span>age</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>cat-entry</span> <span>&#34;Missy Rose&#34;</span> <span>16</span><span>)</span>
<span>; </span><span>=&gt; (cat (name &#34;Missy Rose&#34;)</span>
<span>;         </span><span>(age 16)</span>
<span>;         </span><span>(cat-years-age 80))</span>
<span>REPL&gt;</span> <span>(</span><span>cat-entry</span> <span>&#34;Kelsey&#34;</span> <span>22</span><span>)</span>
<span>; </span><span>=&gt; (cat (name &#34;Kelsey&#34;)</span>
<span>;         </span><span>(age 21)</span>
<span>;         </span><span>(cat-years-age 104))</span>
</pre>
</div>

<p>
Wow!  Those are some old cats!
</p>
</div>
</div>

<div id="outline-container-scheme-closure">
<h2 id="scheme-closure"><span>8.</span> Closures</h2>
<div id="text-scheme-closure">
<p>
Recall our earlier definition and use of <code>goldilocks</code>:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>goldilocks</span> <span>n</span> <span>smallest-ok</span> <span>biggest-ok</span><span>)</span>
        <span>(</span><span>cond</span>
         <span>(</span><span>(</span><span>&lt;</span> <span>n</span> <span>smallest-ok</span><span>)</span>
          <span>&#34;Too small!&#34;</span><span>)</span>
         <span>(</span><span>(</span><span>&gt;</span> <span>n</span> <span>biggest-ok</span><span>)</span>
          <span>&#34;Too big!&#34;</span><span>)</span>
         <span>(</span><span>else</span>
          <span>&#34;Just right!&#34;</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>goldilocks</span> <span>3</span> <span>10</span> <span>20</span><span>)</span>
<span>; </span><span>=&gt; &#34;Too small!&#34;</span>
<span>REPL&gt;</span> <span>(</span><span>goldilocks</span> <span>33</span> <span>10</span> <span>20</span><span>)</span>
<span>; </span><span>=&gt; &#34;Too big!&#34;</span>
<span>REPL&gt;</span> <span>(</span><span>goldilocks</span> <span>12</span> <span>10</span> <span>20</span><span>)</span>
<span>; </span><span>=&gt; &#34;Just right!&#34;</span>
</pre>
</div>

<p>
Entering the same values for <code>smallest-ok</code> and <code>biggest-ok</code> over and
over again is tedious.
Goldilocks&#39; range of preferences are unlikely to change from
invocation to invocation.  Is there a way we could produce a version
of Goldilocks with a kind of memory so we only have to pass in
<code>smallest-ok</code> and <code>biggest-ok</code> once but still test against multiple
versions of <code>n</code>?
Indeed there is… <i>closures</i> to the rescue!
</p>

<div>
<pre><span>(</span><span>define</span> <span>(</span><span>make-goldilocks</span> <span>smallest-ok</span> <span>biggest-ok</span><span>)</span>
  <span>(</span><span>define</span> <span>(</span><span>goldilocks</span> <span>n</span><span>)</span>   <span>; </span><span>make a procedure which encloses</span>
    <span>(</span><span>cond</span>                  <span>;  </span><span>smallest-ok and biggest-ok so</span>
     <span>(</span><span>(</span><span>&lt;</span> <span>n</span> <span>smallest-ok</span><span>)</span>    <span>;  </span><span>that only the n argument needs</span>
      <span>&#34;Too small!&#34;</span><span>)</span>        <span>;  </span><span>to be passed in  </span>
     <span>(</span><span>(</span><span>&gt;</span> <span>n</span> <span>biggest-ok</span><span>)</span>
      <span>&#34;Too big!&#34;</span><span>)</span>
     <span>(</span><span>else</span>
      <span>&#34;Just right!&#34;</span><span>)</span><span>)</span><span>)</span>
  <span>goldilocks</span><span>)</span>              <span>; </span><span>return goldilocks procedure</span>
</pre>
</div>

<p>
We can now invoke <code>make-goldilocks</code>, which returns the <i>enclosed</i>
<code>goldilocks</code> procedure.
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>make-goldilocks</span> <span>10</span> <span>30</span><span>)</span>
<span>; </span><span>=&gt; #&lt;procedure goldilocks (n)&gt;</span>
</pre>
</div>

<p>
Now we can call the inner <code>goldilocks</code> over and over again.
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>goldi</span>
        <span>(</span><span>make-goldilocks</span> <span>10</span> <span>30</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>goldi</span> <span>7</span><span>)</span>
<span>; </span><span>=&gt; &#34;Too small!&#34;</span>
<span>REPL&gt;</span> <span>(</span><span>goldi</span> <span>256</span><span>)</span>
<span>; </span><span>=&gt; &#34;Too big!&#34;</span>
<span>REPL&gt;</span> <span>(</span><span>goldi</span> <span>22</span><span>)</span>
<span>; </span><span>=&gt; &#34;Just right!&#34;</span>
</pre>
</div>

<p>
The outer procedure &#34;closes over&#34; the inner procedure, giving it
access to (and a memory of) <code>smallest-ok</code> and <code>biggest-ok</code>.
</p>

<p>
Notably, this is the same pattern <i>Goblins</i> uses to implement
constructors for its objects: the outer procedure is the constructor,
the inner procedure is the behavior of the object.
(The primary difference is indeed that <i>Goblins</i> objects spawned with
<code>spawn</code> get a <i>bcom</i> capability which they can use to change their
behavior!)
</p>

<p>
Beautifully, we can also build our own cons cells out of pure
abstraction using this same technique.
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>abstract-cons</span> <span>car-data</span> <span>cdr-data</span><span>)</span>
        <span>(</span><span>lambda</span> <span>(</span><span>method</span><span>)</span>
          <span>(</span><span>cond</span>
           <span>(</span><span>(</span><span>eq?</span> <span>method</span> &#39;<span>car</span><span>)</span>
            <span>car-data</span><span>)</span>
           <span>(</span><span>(</span><span>eq?</span> <span>method</span> &#39;<span>cdr</span><span>)</span>
            <span>cdr-data</span><span>)</span>
           <span>(</span><span>else</span> <span>(</span><span>error</span> <span>&#34;Unknown method:&#34;</span> <span>method</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>define</span> <span>our-cons</span> <span>(</span><span>abstract-cons</span> &#39;<span>foo</span> &#39;<span>bar</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>our-cons</span> &#39;<span>car</span><span>)</span>
<span>; </span><span>=&gt; foo</span>
<span>REPL&gt;</span> <span>(</span><span>our-cons</span> &#39;<span>cdr</span><span>)</span>
<span>; </span><span>=&gt; bar</span>
</pre>
</div>

<p>
In this sense, closures are also datastructures built from the code
flow of the program itself.
</p>

<p>
Closures are a property of <i>lexical scoping</i>.
We take advantage of this in Goblins: the capabilities an object
has access to is merely the capabilities it has within its behavior&#39;s
scope.
</p>
</div>
</div>

<div id="outline-container-scheme-iteration-recursion">
<h2 id="scheme-iteration-recursion"><span>9.</span> Iteration and recursion</h2>
<div id="text-scheme-iteration-recursion">
<p>
Much of programming involves sequences of operations, especially
on datastructures which contain other information.
One especially useful procedure for functional programming which
operates on lists is <code>map</code>, which applies its first argument&#39;s
procedure to each element in its series.
</p>

<p>
For example, <code>string-length</code> gives the number of characters which
exist in a given string:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>string-length</span> <span>&#34;cat&#34;</span><span>)</span>
<span>; </span><span>=&gt; 3</span>
<span>REPL&gt;</span> <span>(</span><span>string-length</span> <span>&#34;gorilla&#34;</span><span>)</span>
<span>; </span><span>=&gt; 7</span>
</pre>
</div>

<p>
So, using <code>map</code>, we could easily construct a list representing
the length of each of its strings:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>map</span> <span>string-length</span> &#39;<span>(</span><span>&#34;cat&#34;</span> <span>&#34;dog&#34;</span> <span>&#34;gorilla&#34;</span> <span>&#34;salamander&#34;</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; (3 3 7 10)</span>
</pre>
</div>

<p>
We could also supply a procedure we define:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>symbol-length</span> <span>sym</span><span>)</span>
        <span>(</span><span>string-length</span> <span>(</span><span>symbol-&gt;string</span> <span>sym</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>map</span> <span>symbol-length</span> &#39;<span>(</span><span>basil</span> <span>oregano</span> <span>parsley</span> <span>thyme</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; (5 7 7 5)</span>
</pre>
</div>

<p>
In fact, there is no requirement that we name the procedure… we can
use <code>lambda</code> to construct an anonymous procedure which we pass to
<code>map</code> directly:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>map</span> <span>(</span><span>lambda</span> <span>(</span><span>str</span><span>)</span>
             <span>(</span><span>string-append</span> <span>&#34;I just love &#34;</span>
                            <span>(</span><span>string-upcase</span> <span>str</span><span>)</span>
                            <span>&#34;!!!&#34;</span><span>)</span><span>)</span>
           &#39;<span>(</span><span>&#34;strawberries&#34;</span> <span>&#34;bananas&#34;</span> <span>&#34;grapes&#34;</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; (&#34;I just love STRAWBERRIES!!!&#34;</span>
<span>;     </span><span>&#34;I just love BANANAS!!!&#34;</span>
<span>;     </span><span>&#34;I just love GRAPES!!!&#34;)</span>
</pre>
</div>

<p>
<code>map</code> performs some extra work by building up a list of results every
time.
But what if we wanted to simply display our love of some food to the
screen using <code>display</code> and did not care about operating on the data
any further?
We could use <code>for-each</code>, which has the same structure as <code>map</code> but
does not build a result:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>for-each</span> <span>(</span><span>lambda</span> <span>(</span><span>str</span><span>)</span>
                  <span>(</span><span>display</span>
                   <span>(</span><span>string-append</span> <span>&#34;I just love &#34;</span>
                                  <span>(</span><span>string-upcase</span> <span>str</span><span>)</span>
                                  <span>&#34;!!!\n&#34;</span><span>)</span><span>)</span><span>)</span>
                &#39;<span>(</span><span>&#34;ice cream&#34;</span> <span>&#34;fudge&#34;</span> <span>&#34;cookies&#34;</span><span>)</span><span>)</span>
<span>; </span><span>prints:</span>
<span>;   </span><span>I just love ICE CREAM!!!</span>
<span>;   </span><span>I just love FUDGE!!!</span>
<span>;   </span><span>I just love COOKIES!!!</span>
</pre>
</div>

<p>
<b>NOTE!</b> The following text in this subsection, indeed in the rest
of the Scheme tutorial, is beyond anything required to understand
the main body of our paper &#34;The Heart of Spritely&#34;!
However, it will significantly advance a newcomer&#39;s understanding of
Scheme.
</p>

<p>
Scheme has the surprising property that iteration is actually
defined in terms of recursion!
</p>

<p>
Here is what we mean.
We could define our own version of <code>for-each</code>:
</p>

<div>
<pre><span>(</span><span>define</span> <span>(</span><span>for-each</span> <span>proc</span> <span>lst</span><span>)</span>
  <span>(</span><span>if</span> <span>(</span><span>eq?</span> <span>lst</span> &#39;<span>()</span><span>)</span>  <span>; </span><span>End of the list?</span>
      &#39;<span>done</span>          <span>; </span><span>We&#39;re done, so simply return &#34;done&#34;</span>
      <span>(</span><span>let</span> <span>(</span><span>(</span><span>item</span> <span>(</span><span>car</span> <span>lst</span><span>)</span><span>)</span><span>)</span>  <span>; </span><span>Otherwise... let&#39;s fetch this item</span>
        <span>(</span><span>proc</span> <span>item</span><span>)</span>            <span>; </span><span>Call the procedure with this item</span>
        <span>(</span><span>for-each</span> <span>proc</span> <span>(</span><span>cdr</span> <span>lst</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>  <span>; </span><span>Iterate with the remaining work</span>
</pre>
</div>

<p>
This calls <code>proc</code> successively with each item from <code>lst</code> until it runs
out of items.
If you have experience with other programming languages, your
expectation would probably be that this design could accidentally
&#34;blow the stack&#34;.
However, Scheme is smart: it sees that there is no more work left to
be done within the current version of <code>for-each</code> once we reach the
last line… in other words, where <code>for-each</code> calls itself is
in the &#34;tail position&#34;.
Because of this, Scheme is able to skip allocating a new frame on the
stack and &#34;jump&#34; back to the beginning of <code>for-each</code> again with the
new variables allocated.
This is called <code>tail call elimination</code> and all iteration facilities
are actually defined this way in terms of recursion in Scheme.
</p>

<p>
It is also possible to build recursive procedures.
The following (somewhat advanced, if you don&#39;t follow this it&#39;s ok)
procedure builds a binary tree:
</p>

<div>
<pre><span>(</span><span>define</span> <span>(</span><span>build-tree</span> <span>depth</span><span>)</span>
  <span>(</span><span>if</span> <span>(</span><span>=</span> <span>depth</span> <span>0</span><span>)</span>
      &#39;<span>(</span><span>0</span><span>)</span>
      <span>(</span><span>list</span> <span>depth</span>
            <span>(</span><span>build-tree</span> <span>(</span><span>-</span> <span>depth</span> <span>1</span><span>)</span><span>)</span>
            <span>(</span><span>build-tree</span> <span>(</span><span>-</span> <span>depth</span> <span>1</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>build-tree</span> <span>3</span><span>)</span>
<span>; </span><span>=&gt; (3 (2 (1 (0)</span>
<span>;             </span><span>(0))</span>
<span>;          </span><span>(1 (0)</span>
<span>;             </span><span>(0)))</span>
<span>;       </span><span>(2 (1 (0)</span>
<span>;             </span><span>(0))</span>
<span>;          </span><span>(1 (0)</span>
<span>;             </span><span>(0))))</span>
</pre>
</div>

<p>
Or, better visualized:
</p>

<div>
<pre>       3
      / \
     /   \
    2     2
   / \   / \
  1  1   1  1
 /\  /\ /\  /\
0 0 0 0 0 0 0 0
</pre>
</div>

<p>
However, unlike <code>for-each</code>, <code>build-tree</code> does <i>not</i> call itself
in the tail position.
There is no way to simply &#34;jump&#34; to the beginning of the procedure
without allocating work to be done on the stack with the way this code
is written: more work needs to be done, as cons sits waiting for its
results.
As such, unlike <code>for-each</code>, <code>build-tree</code> is recursive but not
iterative.
</p>

<p>
Finally, come conveniences.
Here are two variants on <code>let</code>, both useful for recursive and
iterative procedures.
The first is <code>letrec</code> which allows for procedures to call and refer to
themselves or others defined by the <code>letrec</code>, regardless of definition
ordering:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>letrec</span> <span>(</span><span>(</span><span>alice</span>
                <span>(</span><span>lambda</span> <span>(</span><span>first?</span><span>)</span>
                  <span>(</span><span>report-status</span> <span>&#34;Alice&#34;</span> <span>first?</span><span>)</span>
                  <span>(</span><span>if</span> <span>first?</span> <span>(</span><span>bob</span> <span>#f</span><span>)</span><span>)</span><span>)</span><span>)</span>
               <span>(</span><span>bob</span>
                <span>(</span><span>lambda</span> <span>(</span><span>first?</span><span>)</span>
                  <span>(</span><span>report-status</span> <span>&#34;Bob&#34;</span> <span>first?</span><span>)</span>
                  <span>(</span><span>if</span> <span>first?</span> <span>(</span><span>alice</span> <span>#f</span><span>)</span><span>)</span><span>)</span><span>)</span>
               <span>(</span><span>report-status</span>
                <span>(</span><span>lambda</span> <span>(</span><span>name</span> <span>first?</span><span>)</span>
                  <span>(</span><span>display</span>
                   <span>(</span><span>string-append</span> <span>name</span> <span>&#34; is &#34;</span>
                                  <span>(</span><span>if</span> <span>first?</span>
                                      <span>&#34;first&#34;</span>
                                      <span>&#34;second&#34;</span><span>)</span>
                                  <span>&#34;!\n&#34;</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
        <span>(</span><span>alice</span> <span>#t</span><span>)</span>
        <span>(</span><span>display</span> <span>&#34;-----\n&#34;</span><span>)</span>
        <span>(</span><span>bob</span> <span>#t</span><span>)</span><span>)</span>
<span>; </span><span>prints:</span>
<span>;   </span><span>Alice is first!</span>
<span>;   </span><span>Bob is second!</span>
<span>;   </span><span>-----</span>
<span>;   </span><span>Bob is first!</span>
<span>;   </span><span>Alice is second!</span>
</pre>
</div>

<p>
The second useful abstraction is the <i>named let</i> variant of <code>let</code>,
where a looping name identifier appears as the first argument:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>let</span> <span>loop</span> <span>(</span><span>(</span><span>words</span> &#39;<span>(</span><span>&#34;carrot&#34;</span> <span>&#34;potato&#34;</span> <span>&#34;pea&#34;</span> <span>&#34;celery&#34;</span><span>)</span><span>)</span>
                 <span>(</span><span>num-words</span> <span>0</span><span>)</span>
                 <span>(</span><span>num-chars</span> <span>0</span><span>)</span><span>)</span>
        <span>(</span><span>if</span> <span>(</span><span>eq?</span> <span>words</span> &#39;<span>()</span><span>)</span>
            <span>(</span><span>format</span> <span>#f</span> <span>&#34;We found ~a words and ~a chars!&#34;</span>
                    <span>num-words</span> <span>num-chars</span><span>)</span>
            <span>(</span><span>loop</span> <span>(</span><span>cdr</span> <span>words</span><span>)</span>
                  <span>(</span><span>+</span> <span>num-words</span> <span>1</span><span>)</span>
                  <span>(</span><span>+</span> <span>num-chars</span> <span>(</span><span>string-length</span> <span>(</span><span>car</span> <span>words</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; &#34;We found 4 words and 21 chars!&#34;</span>
</pre>
</div>

<p>
What a <i>named let</i> does is define the named procedure (here named
<code>loop</code>) and immediately invokes it with the initial bindings of the
<code>let</code>.
The procedure is available within the body of the <code>let</code> for
convenient recursive (perhaps iterative) calls.
</p>
</div>
</div>

<div id="outline-container-scheme-effects">
<h2 id="scheme-effects"><span>10.</span> Mutation, assignment, and other kinds of side effects</h2>
<div id="text-scheme-effects">
<p>
This section is included for completeness.
Notably, Goblins provides a different approach to much of this here
which we will discuss towards the end.
</p>

<p>
Scheme ships with a way to reassign the current value of a variable
using <code>set!</code>:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>chest</span> &#39;<span>sword</span><span>)</span>
<span>REPL&gt;</span> <span>chest</span>
<span>; </span><span>=&gt; sword</span>
<span>REPL&gt;</span> <span>(</span><span>set!</span> <span>chest</span> &#39;<span>gold</span><span>)</span>
<span>REPL&gt;</span> <span>chest</span>
<span>; </span><span>=&gt; gold</span>
</pre>
</div>

<p>
This can even be combined with the techniques shown in <a href="#scheme-closure">Closures</a>.
For instance, here&#39;s an example of an object that counts down
from an initial number <code>n</code> until it reaches its zero, and then
always returns zero afterwards.
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>make-countdown</span> <span>n</span><span>)</span>
        <span>(</span><span>lambda</span> <span>()</span>
          <span>(</span><span>define</span> <span>last-n</span> <span>n</span><span>)</span>
          <span>(</span><span>if</span> <span>(</span><span>zero?</span> <span>n</span><span>)</span>
              <span>0</span>
              <span>(</span><span>begin</span>
                <span>(</span><span>set!</span> <span>n</span> <span>(</span><span>-</span> <span>n</span> <span>1</span><span>)</span><span>)</span>
                <span>last-n</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>define</span> <span>cdown</span> <span>(</span><span>make-countdown</span> <span>3</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>cdown</span><span>)</span>
<span>; </span><span>=&gt; 3</span>
<span>REPL&gt;</span> <span>(</span><span>cdown</span><span>)</span>
<span>; </span><span>=&gt; 2</span>
<span>REPL&gt;</span> <span>(</span><span>cdown</span><span>)</span>
<span>; </span><span>=&gt; 1</span>
<span>REPL&gt;</span> <span>(</span><span>cdown</span><span>)</span>
<span>; </span><span>=&gt; 0</span>
<span>REPL&gt;</span> <span>(</span><span>cdown</span><span>)</span>
<span>; </span><span>=&gt; 0</span>
</pre>
</div>

<p>
There are several interesting things about this example:
</p>

<ul>
<li>We have introduced time and change into our computations.  Before
the introduction of side effects such as assignment, calling a
procedure with the same arguments will always produce the same
result.  But in the above example, <code>cdown</code> changes its response over
time (even without being passed any arguments on invocation).</li>
<li>Since we want to show the initial number the first time the
procedure is called, we have to capture <code>last-n</code> <i>before</i>
using <code>set!</code> to change <code>n</code>.  If we accidentally reverse this order,
we will introduce a bug where <code>cdown</code> would have started with <code>2</code>
instead of <code>3</code> in the example above.</li>
<li>Here we also see an interesting new piece of syntax: <code>begin</code>.
<code>begin</code> executes several expressions in sequence, returning
the value of the last expression.</li>
</ul>

<p>
This last one is interesting.
Prior to introducing effects (such as the assignment shown above,
displaying to the screen, logging to a file or database, etc),
there is never any reason for <code>begin</code>.
To understand this, recall the <i>substitution method</i> demonstrated at
the beginning of this tutorial:
</p>

<div>
<pre><span>(</span><span>*</span> <span>(</span><span>-</span> <span>8</span> <span>(</span><span>/</span> <span>30</span> <span>5</span><span>)</span><span>)</span> <span>21</span><span>)</span>   <span>; </span><span>beginning expression</span>
<span>(</span><span>*</span> <span>(</span><span>-</span> <span>8</span> <span>6</span><span>)</span> <span>21</span><span>)</span>          <span>; </span><span>simplify: (/ 30 5) =&gt; 6</span>
<span>(</span><span>*</span> <span>2</span> <span>21</span><span>)</span>                <span>; </span><span>simplify: (- 8 6)  =&gt; 2</span>
<span>42</span>                      <span>; </span><span>simplify: (* 2 21) =&gt; 42</span>
</pre>
</div>

<p>
Before effects, every procedure invoked is to compute a new part of
the program.
But since each branch of <code>if</code> only evaluates one expression, we must
provide a way to sequence the <i>alternate</i> clause so that we can both
<code>set!</code> and then return a value.<sup><a id="fnr.14" href="#fn.14" role="doc-backlink">14</a></sup>
In other words, a <i>purely functional</i> program is really built to
take a series of inputs and precisely compute a value, the same value,
every time.
This is a clean set of substitutions all the way up and down the
evaluation.
(In other worlds, before introducing time, we will have programs which
are fully <i>deterministic</i>.)
</p>

<p>
However, by introducing <i>mutation</i> and <i>side effects</i>, we have
introduced a powerful, but dangerous, new construct into our program:
time.
Our programs are no longer <i>purely functional</i>, time has made them
<i>imperative</i>: do this, then do that.
Time is change, and change requires sequences of events, not mere
substitutions.
And time means that the same programs and procedures run with the same
inputs will not always produce the same outputs.
We have traded a timeless world for one that changes.
</p>

<p>
Despite the caution, change can be desirable.
We live in a world with time and change, and so too often do our
programs.
Scheme has a (somewhat inconsistent) naming convention for observing
time and change: the addition of a <code>!</code> suffix, as we have seen with
<code>set!</code>.
The <code>!</code> can be seen as a kind of warning, as if the user is shouting
about the possibility of mutation.
(However, the runtime of Scheme provides no guarantee that the
presence or absence of this suffix says anything about mutation
whatsoever.)
</p>

<p>
However, <code>set!</code> is not the only form of change and mutation available
in standard (and nonstandard) Scheme.<sup><a id="fnr.15" href="#fn.15" role="doc-backlink">15</a></sup>
Another example is mutable vectors and <code>vector-set!</code>:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>vec</span> <span>(</span><span>vector</span> &#39;<span>a</span> &#39;<span>b</span> &#39;<span>c</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>vec</span>
<span>; </span><span>=&gt; #(a b c)</span>
<span>REPL&gt;</span> <span>(</span><span>vector-ref</span> <span>vec</span> <span>1</span><span>)</span>
<span>; </span><span>=&gt; b</span>
<span>REPL&gt;</span> <span>(</span><span>vector-set!</span> <span>vec</span> <span>1</span> &#39;<span>boop</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>vector-ref</span> <span>vec</span> <span>1</span><span>)</span>
<span>; </span><span>=&gt; boop</span>
<span>REPL&gt;</span> <span>vec</span>
<span>; </span><span>=&gt; #(a boop c)</span>
</pre>
</div>

<p>
Both of these examples resemble mutation.
However, we have already seen a different form of side effects in
this tutorial, namely <code>display</code>, which writes to the screen.
In fact, <code>display</code> itself builds on the idea of <i>ports</i>, which
are mechanisms in Scheme for reading and writing from and to
input and output devices.
</p>

<p>
All of these carry the same challenges of <code>set!</code>.
Put simply, the introduction of ambient time makes our programs less
timeless.
However, if turns out that we cannot remove <i>all</i> time and change
from our computers, as illustrated in this nested set of quotes:
</p>

<blockquote>
<p>
As Simon Peyton Jones, a well-known functional programmer, likes to
say, &#34;All you can do without side effects is push a button and
watch the box get hot for a while.&#34;  (Which isn&#39;t technically true,
since even the box getting hot is a side effect.)
</p>

<p>
— From <i>Land of Lisp</i> by Conrad Barski, M.D.
</p>
</blockquote>

<p>
As Simon and Conrad point out, the challenge with functional
programming is that even though side effects can be dangerous, they
are in a sense all the user really cares about.
At some point, in order for a computer to be useful, input must
be read from the user and output must be given back, and these
are inherently side-effectful.
Even using the radiant heat of a busy computer to warm your house
is a side effect.
At some point, we must both enter and leave the realm of pure
mathlandia.<sup><a id="fnr.16" href="#fn.16" role="doc-backlink">16</a></sup>
</p>
</div>
</div>

<div id="outline-container-scheme-extensibility">
<h2 id="scheme-extensibility"><span>11.</span> On the extensibility of Scheme (and Lisps in general)</h2>
<div id="text-scheme-extensibility">
<p>
Let&#39;s say we&#39;d like some new syntax.
For instance, maybe we want to run multiple pieces of code in sequence
when a condition is met.
We could write:
</p>

<div>
<pre><span>(</span><span>if</span> <span>(</span><span>our-test</span><span>)</span>
    <span>(</span><span>begin</span>
      <span>(</span><span>do-thing-1</span><span>)</span>
      <span>(</span><span>do-thing-2</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
But this is kind of ugly.
What if we created some new syntax specifically for this purpose?
</p>

<div>
<pre><span>(</span><span>when</span> <span>(</span><span>our-test</span><span>)</span>
  <span>(</span><span>do-thing-1</span><span>)</span>
  <span>(</span><span>do-thing-2</span><span>)</span><span>)</span>
</pre>
</div>

<p>
<code>when</code> cannot be built as a function because we do not want to
execute <code>(do-thing-1)</code> or <code>(do-thing-2)</code> unless <code>(our-test)</code> passes.
We need new syntax.
</p>

<p>
Could we build the new syntax ourselves?
Remembering that we can &#34;write Lisp in Lisp&#34;, the answer seems to be
yes:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>when</span> <span>test</span> <span>.</span> <span>body</span><span>)</span>
        `<span>(</span><span>if</span> ,<span>test</span>
             ,<span>(</span><span>cons</span> &#39;<span>begin</span> <span>body</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>when</span> &#39;<span>(</span><span>our-test</span><span>)</span>
        &#39;<span>(</span><span>do-thing-1</span><span>)</span>
        &#39;<span>(</span><span>do-thing-2</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; (if (our-test)</span>
<span>;        </span><span>(begin</span>
<span>;          </span><span>(do-thing-1)</span>
<span>;          </span><span>(do-thing-2)))</span>
</pre>
</div>

<p>
This does build out the appropriate syntax!
And it does demonstrate that our claim that Lisp can &#34;write code which
writes code&#34; is indeed true.<sup><a id="fnr.17" href="#fn.17" role="doc-backlink">17</a></sup>
</p>

<p>
However, there are two obvious problems with this first attempt:
</p>
<ul>
<li>We had to quote each argument passed to <code>build-when</code>.
This is annoying to do.</li>
<li><code>build-when</code> does not actually run its code, it just returns the
<i>quoted structure</i> that the code should expand to.</li>
</ul>

<p>
However, with just one tweak our procedure can be turned into a
&#34;macro&#34;: a special kind of procedure used by the compiler to expand
code.
Here is all we need to do:
</p>

<div>
<pre><span>(</span><span>define-macro</span> <span>(</span><span>when</span> <span>test</span> <span>.</span> <span>body</span><span>)</span>
  `<span>(</span><span>if</span> ,<span>test</span>
       ,<span>(</span><span>cons</span> &#39;<span>begin</span> <span>body</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
All we needed to do was rename <code>define</code> to <code>define-macro</code>!
Now Scheme knows it should use this for code expansion.
This allows us to define new kinds of syntax forms.
</p>

<p>
<code>define-macro</code> shows very clearly what macros in Lisp and Scheme
do: they operate on structure.
Manually building up a list structure like this is how macros
in Common Lisp work.
However, this is not the general way to write macros in Scheme.
Scheme macros look very similar though:
</p>

<div>
<pre><span>(</span><span>define-syntax-rule</span> <span>(</span><span>when</span> <span>test</span> <span>body</span> <span>...</span><span>)</span>
  <span>(</span><span>if</span> <span>test</span>
      <span>(</span><span>begin</span> <span>body</span> <span>...</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
<code>define-syntax-rule</code> uses <i>pattern matching</i> to implement macros.  The
first argument to <code>define-syntax-rule</code> describes the pattern which the
user will enter, and the second describes the template which will be
expanded.<sup><a id="fnr.18" href="#fn.18" role="doc-backlink">18</a></sup>
We can also notice that <code>body ...</code> appears in both the pattern
and the template; the <code>...</code> ellipsis in the pattern represents that
multiple expressions will be captured from the user&#39;s input and
the <code>...</code> in the template indicates where the repeating should occur.
We can see that we do not need to manually quote things using
this mechanism; Scheme cleverly takes care of it for us.
</p>

<p>
Ultimately, the Scheme version of syntax definitions is less obvious
as to how it works under the hood than the <code>define-macro</code> version is.
However, there is an issue that arrives in syntax transformation
systems called <i>hygiene</i>: that a syntax form / macro not introduce
unexpected temporary identifiers into the body of the form it expands
into.
We will not get into the debate in this primer, but both Common Lisp
and Scheme&#39;s macros have significant tradeoffs, with Scheme being much
more likely to be properly &#34;hygienic&#34;, easier to write for simple
syntax forms, but harder to write for more complicated ones, and less
obvious as to how they work under the hood.
For this reason, even though you will likely never use the <code>define-macro</code>
approach in Scheme, it is a useful way to understand the idea behind
&#34;code that writes code&#34;.
</p>

<p>
Now that we know how to produce new syntax the Scheme way, let&#39;s see
if we can make our life more convenient than before.
Let&#39;s revisit our use of <code>for-each</code> from earlier:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>for-each</span> <span>(</span><span>lambda</span> <span>(</span><span>str</span><span>)</span>
                  <span>(</span><span>display</span>
                   <span>(</span><span>string-append</span> <span>&#34;I just love &#34;</span>
                                  <span>(</span><span>string-upcase</span> <span>str</span><span>)</span>
                                  <span>&#34;!!!\n&#34;</span><span>)</span><span>)</span><span>)</span>
                &#39;<span>(</span><span>&#34;strawberries&#34;</span> <span>&#34;bananas&#34;</span> <span>&#34;grapes&#34;</span><span>)</span><span>)</span>
<span>; </span><span>prints:</span>
<span>;   </span><span>I just love ICE CREAM!!!</span>
<span>;   </span><span>I just love FUDGE!!!</span>
<span>;   </span><span>I just love COKIES!!!</span>
</pre>
</div>

<p>
This works, but it is also unnecessarily tedious.
That <code>lambda</code> is an unnecessary piece of detail!
A small new syntax definition lets us clean things up:
</p>

<div>
<pre><span>(</span><span>define-syntax-rule</span> <span>(</span><span>for</span> <span>(</span><span>item</span> <span>lst</span><span>)</span> <span>body</span> <span>...</span><span>)</span>
  <span>(</span><span>for-each</span> <span>(</span><span>lambda</span> <span>(</span><span>item</span><span>)</span>
              <span>body</span> <span>...</span><span>)</span>
            <span>lst</span><span>)</span><span>)</span>
</pre>
</div>

<p>
Let&#39;s give it a try:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>for</span> <span>(</span><span>str</span> &#39;<span>(</span><span>&#34;strawberries&#34;</span> <span>&#34;bananas&#34;</span> <span>&#34;grapes&#34;</span><span>)</span><span>)</span>
        <span>(</span><span>display</span>
         <span>(</span><span>string-append</span> <span>&#34;I just love &#34;</span>
                        <span>(</span><span>string-upcase</span> <span>str</span><span>)</span>
                        <span>&#34;!!!\n&#34;</span><span>)</span><span>)</span><span>)</span>
<span>; </span><span>prints:</span>
<span>;   </span><span>I just love STRAWBERRIES!!!</span>
<span>;   </span><span>I just love BANANAS!!!</span>
<span>;   </span><span>I just love GRAPES!!!</span>
</pre>
</div>

<p>
It works!  This is much easier to read.<sup><a id="fnr.19" href="#fn.19" role="doc-backlink">19</a></sup>
</p>

<p>
We need not stop here.  The <code>methods</code> feature in Spritely Goblins
is an example of a macro.  Here is a simplified version:
</p>

<div>
<pre><span>(</span><span>define-syntax-rule</span> <span>(</span><span>methods</span> <span>(</span><span>(</span><span>method-id</span> <span>method-args</span> <span>...</span><span>)</span>
                              <span>body</span> <span>...</span><span>)</span> <span>...</span><span>)</span>
  <span>(</span><span>lambda</span> <span>(</span><span>method</span> <span>.</span> <span>args</span><span>)</span>
    <span>(</span><span>letrec</span> <span>(</span><span>(</span><span>method-id</span>
              <span>(</span><span>lambda</span> <span>(</span><span>method-args</span> <span>...</span><span>)</span>
                <span>body</span> <span>...</span><span>)</span><span>)</span> <span>...</span><span>)</span>
      <span>(</span><span>cond</span>
       <span>(</span><span>(</span><span>eq?</span> <span>method</span> <span>(</span><span>quote</span> <span>method-id</span><span>)</span><span>)</span>
        <span>(</span><span>apply</span> <span>method-id</span> <span>args</span><span>)</span><span>)</span> <span>...</span>
       <span>(</span><span>else</span>
        <span>(</span><span>error</span> <span>&#34;No such method:&#34;</span> <span>method</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
We can both see here simultaneously how expressive Scheme style
pattern matching examples are, but also how with multiple layers
of ellipses (the <code>...</code>), it can be a bit challenging to see how
the code expander is figuring out how to unpack things.
</p>

<p>
But let&#39;s not worry about that for now, and instead show
an example of usage:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>(</span><span>make-enemy</span> <span>name</span> <span>hp</span><span>)</span>
        <span>(</span><span>methods</span>
         <span>(</span><span>(</span><span>get-name</span><span>)</span>
          <span>name</span><span>)</span>
         <span>(</span><span>(</span><span>damage-me</span> <span>weapon</span> <span>hp-lost</span><span>)</span>
          <span>(</span><span>cond</span>
           <span>(</span><span>(</span><span>dead?</span><span>)</span>
            <span>(</span><span>format</span> <span>#t</span> <span>&#34;Poor ~a is already dead!\n&#34;</span> <span>name</span><span>)</span><span>)</span>
           <span>(</span><span>else</span>
            <span>(</span><span>set!</span> <span>hp</span> <span>(</span><span>-</span> <span>hp</span> <span>hp-lost</span><span>)</span><span>)</span>
            <span>(</span><span>format</span> <span>#t</span> <span>&#34;You attack ~a, doing ~a damage!\n&#34;</span>
                    <span>name</span> <span>hp-lost</span><span>)</span><span>)</span><span>)</span><span>)</span>
         <span>(</span><span>(</span><span>dead?</span><span>)</span>
          <span>(</span><span>&lt;=</span> <span>hp</span> <span>0</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>define</span> <span>hobgob</span>
        <span>(</span><span>make-enemy</span> <span>&#34;Hobgoblin&#34;</span> <span>25</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>hobgob</span> &#39;<span>get-name</span><span>)</span>
<span>; </span><span>=&gt; &#34;Hobgoblin&#34;</span>
<span>REPL&gt;</span> <span>(</span><span>hobgob</span> &#39;<span>dead?</span><span>)</span>
<span>; </span><span>=&gt; #f</span>
<span>REPL&gt;</span> <span>(</span><span>hobgob</span> &#39;<span>damage-me</span> <span>&#34;club&#34;</span> <span>10</span><span>)</span>
<span>; </span><span>prints: You attack Hobgoblin, doing 10 damage!</span>
<span>REPL&gt;</span> <span>(</span><span>hobgob</span> &#39;<span>damage-me</span> <span>&#34;sword&#34;</span> <span>20</span><span>)</span>
<span>; </span><span>prints: You attack Hobgoblin, doing 20 damage!</span>
<span>REPL&gt;</span> <span>(</span><span>hobgob</span> &#39;<span>damage-me</span> <span>&#34;pickle&#34;</span> <span>2</span><span>)</span>
<span>; </span><span>prints: Poor Hobgoblin is already dead!</span>
<span>REPL&gt;</span> <span>(</span><span>hobgob</span> &#39;<span>dead?</span><span>)</span>
<span>; </span><span>=&gt; #t</span>
</pre>
</div>

<p>
We can go further.
We can extend Scheme to include <a href="http://minikanren.org/">logic programming</a>,
we can <a href="https://wingolog.org/archives/2011/08/30/the-gnu-extension-language">add pattern matching</a>, etc etc etc.
Indeed, we will use a pattern matching system included in Guile&#39;s
standard library in the next subsection.
</p>

<p>
Because of the syntactic extensibility of Lisp/Scheme, advanced
programming language features can be implemented as libraries rather
than as entirely separate sub-languages.
Multiple problem domains can be combined into one system.
For this reason, we say that languages in the Lisp language support
<i>composable domain specific languages</i>.
</p>

<p>
It is also liberating.
In other programming languages, users must pray at the altar of the
programming language implementers for features to show up in the next
official language release, features which would be only a few small
and simple lines of code in the hand of a Lisp/Scheme user.
</p>

<p>
This is true power.
But there is more.
In the next section we will unlock Scheme itself, allowing us to
configure and experiment with its underlying mechanisms, in a
surprisingly compact amount of code.
</p>
</div>
</div>

<div id="outline-container-scheme-in-scheme">
<h2 id="scheme-in-scheme"><span>12.</span> Scheme in Scheme</h2>
<div id="text-scheme-in-scheme">
<p>
Here is a working implementation of Scheme written in Scheme:
</p>

<div>
<pre><span>(</span><span>use-modules</span> <span>(</span><span>ice-9</span> <span>match</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>env-lookup</span> <span>env</span> <span>name</span><span>)</span>
  <span>(</span><span>match</span> <span>(</span><span>assoc</span> <span>name</span> <span>env</span><span>)</span>
    <span>(</span><span>(</span><span>_key</span> <span>.</span> <span>val</span><span>)</span>
     <span>val</span><span>)</span>
    <span>(</span><span>_</span>
     <span>(</span><span>error</span> <span>&#34;Variable unbound:&#34;</span> <span>name</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>extend-env</span> <span>env</span> <span>names</span> <span>vals</span><span>)</span>
  <span>(</span><span>if</span> <span>(</span><span>eq?</span> <span>names</span> &#39;<span>()</span><span>)</span>
      <span>env</span>
      <span>(</span><span>cons</span> <span>(</span><span>cons</span> <span>(</span><span>car</span> <span>names</span><span>)</span> <span>(</span><span>car</span> <span>vals</span><span>)</span><span>)</span>
            <span>(</span><span>extend-env</span> <span>env</span> <span>(</span><span>cdr</span> <span>names</span><span>)</span> <span>(</span><span>cdr</span> <span>vals</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>evaluate</span> <span>expr</span> <span>env</span><span>)</span>
  <span>(</span><span>match</span> <span>expr</span>
    <span>;; </span><span>Support builtin types</span>
    <span>(</span><span>(</span><span>or</span> <span>#t</span> <span>#f</span> <span>(</span><span>?</span> <span>number?</span><span>)</span><span>)</span>
     <span>expr</span><span>)</span>
    <span>;; </span><span>Quoting</span>
    <span>(</span><span>(</span>&#39;<span>quote</span> <span>quoted-expr</span><span>)</span>
     <span>quoted-expr</span><span>)</span>
    <span>;; </span><span>Variable lookup</span>
    <span>(</span><span>(</span><span>?</span> <span>symbol?</span> <span>name</span><span>)</span>
     <span>(</span><span>env-lookup</span> <span>env</span> <span>name</span><span>)</span><span>)</span>
    <span>;; </span><span>Conditionals</span>
    <span>(</span><span>(</span>&#39;<span>if</span> <span>test</span> <span>consequent</span> <span>alternate</span><span>)</span>
     <span>(</span><span>if</span> <span>(</span><span>evaluate</span> <span>test</span> <span>env</span><span>)</span>
         <span>(</span><span>evaluate</span> <span>consequent</span> <span>env</span><span>)</span>
         <span>(</span><span>evaluate</span> <span>alternate</span> <span>env</span><span>)</span><span>)</span><span>)</span>
    <span>;; </span><span>Lambdas (Procedures)</span>
    <span>(</span><span>(</span>&#39;<span>lambda</span> <span>(</span><span>args</span> <span>...</span><span>)</span> <span>body</span><span>)</span>
     <span>(</span><span>lambda</span> <span>(</span><span>.</span> <span>vals</span><span>)</span>
       <span>(</span><span>evaluate</span> <span>body</span> <span>(</span><span>extend-env</span> <span>env</span> <span>args</span> <span>vals</span><span>)</span><span>)</span><span>)</span><span>)</span>
    <span>;; </span><span>Procedure Invocation (Application)</span>
    <span>(</span><span>(</span><span>proc-expr</span> <span>arg-exprs</span> <span>...</span><span>)</span>
     <span>(</span><span>apply</span> <span>(</span><span>evaluate</span> <span>proc-expr</span> <span>env</span><span>)</span>
            <span>(</span><span>map</span> <span>(</span><span>lambda</span> <span>(</span><span>arg-expr</span><span>)</span>
                   <span>(</span><span>evaluate</span> <span>arg-expr</span> <span>env</span><span>)</span><span>)</span>
                 <span>arg-exprs</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
Without comments, blank lines, and the pattern matching import at the
top (not necessary, but convenient), this is a mere 30 lines of code.
This evaluator, while bare bones, is complete enough to be able to
compute anything we can imagine.
(You could even write another similar Scheme evaluator on top of this
one!)<sup><a id="fnr.20" href="#fn.20" role="doc-backlink">20</a></sup>
</p>

<p>
Our <code>evaluator</code> takes two arguments, a Scheme expression <code>expr</code> and an
environment <code>env</code>.
Scheme&#39;s lispy structure is of great benefit here, since as we
have learned we can easily quote entire sections of code.
(Indeed, that is exactly what we are going to do.)
The <code>env</code> of the second argument is an association list mapping
symbols for names and their associated procedures.
</p>

<p>
Seeing is believing.
Let&#39;s do some simple arithmetic, passing in some procedures to
the default environment which can do some math:
</p>

<div>
<pre><span>(</span><span>define</span> <span>math-env</span>
  `<span>(</span><span>(</span><span>+</span> <span>.</span> ,<span>+</span><span>)</span>
    <span>(</span><span>-</span> <span>.</span> ,<span>-</span><span>)</span>
    <span>(</span><span>*</span> <span>.</span> ,<span>*</span><span>)</span>
    <span>(</span><span>/</span> <span>.</span> ,<span>/</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
As we can see, the first &#34;substitution method&#34; example we wrote works
just fine using this environment:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>evaluate</span> &#39;<span>(</span><span>*</span> <span>(</span><span>-</span> <span>8</span> <span>(</span><span>/</span> <span>30</span> <span>5</span><span>)</span><span>)</span> <span>21</span><span>)</span>
                <span>math-env</span><span>)</span>
<span>; </span><span>=&gt; 42</span>
</pre>
</div>

<p>
What do you know, that&#39;s the same answer we got in our own program!
</p>

<p>
We can also make a lambda and apply it.  Let&#39;s make one that can
square a number:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>evaluate</span> &#39;<span>(</span><span>(</span><span>lambda</span> <span>(</span><span>x</span><span>)</span>
                    <span>(</span><span>*</span> <span>x</span> <span>x</span><span>)</span><span>)</span>
                  <span>4</span><span>)</span>
                <span>math-env</span><span>)</span>
<span>; </span><span>=&gt; 16</span>
</pre>
</div>

<p>
Nice, works perfectly.
</p>

<p>
Let&#39;s do something more advanced.
Supplying only two operators, <code>+</code> and <code>-</code>, we are able to compute
the Fibonacci sequence:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>define</span> <span>fib-program</span>
        &#39;<span>(</span><span>(</span><span>lambda</span> <span>(</span><span>prog</span> <span>arg</span><span>)</span>   <span>; </span><span>boot</span>
            <span>(</span><span>prog</span> <span>prog</span> <span>arg</span><span>)</span><span>)</span>
          <span>(</span><span>lambda</span> <span>(</span><span>fib</span> <span>n</span><span>)</span>      <span>; </span><span>main program</span>
            <span>(</span><span>if</span> <span>(</span><span>=</span> <span>n</span> <span>0</span><span>)</span>
                <span>0</span>
                <span>(</span><span>if</span> <span>(</span><span>=</span> <span>n</span> <span>1</span><span>)</span>
                    <span>1</span>
                    <span>(</span><span>+</span> <span>(</span><span>fib</span> <span>fib</span> <span>(</span><span>+</span> <span>n</span> <span>-1</span><span>)</span><span>)</span>
                       <span>(</span><span>fib</span> <span>fib</span> <span>(</span><span>+</span> <span>n</span> <span>-2</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
          <span>10</span><span>)</span><span>)</span>                 <span>; </span><span>argument</span>
<span>REPL&gt;</span> <span>(</span><span>define</span> <span>fib-env</span>
        `<span>(</span><span>(</span><span>+</span> <span>.</span> ,<span>+</span><span>)</span>
          <span>(</span><span>=</span> <span>.</span> ,<span>=</span><span>)</span><span>)</span><span>)</span>
<span>REPL&gt;</span> <span>(</span><span>evaluate</span> <span>fib-program</span> <span>fib-env</span><span>)</span>
<span>; </span><span>=&gt; 55</span>
</pre>
</div>

<p>
This seems like magic.  But it works!  The evaluator really is
performing the underlying computation, using merely addition (on both
positive and negative numbers) and numeric equality check procedures,
which we have provided.
</p>

<p>
The main program needs to be able to call itself, so the first
procedure (labeled <code>boot</code>) takes a program and an argument and invokes
the procedure with itself and that argument.<sup><a id="fnr.21" href="#fn.21" role="doc-backlink">21</a></sup>
The second procedure (labeled <code>main program</code>) takes itself as the
argument <code>fib</code> (supplied by our boot procedure) as well as an argument
of <code>n</code> (also supplied by the boot procedure)… and it works!
Our evaluator recursively builds up the Fibonacci sequence.
</p>

<p>
Our evaluator can also be easily understood.
Let us break it down section by section.
</p>

<div>
<pre><span>(</span><span>define</span> <span>(</span><span>env-lookup</span> <span>env</span> <span>name</span><span>)</span>
  <span>(</span><span>match</span> <span>(</span><span>assoc</span> <span>name</span> <span>env</span><span>)</span>
    <span>(</span><span>(</span><span>_key</span> <span>.</span> <span>val</span><span>)</span>
     <span>val</span><span>)</span>
    <span>(</span><span>_</span>
     <span>(</span><span>error</span> <span>&#34;Variable unbound:&#34;</span> <span>name</span><span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
This one is easy.
We are defining environments as association lists, so all <code>env-lookup</code>
does is search for a matching name in the list.
Newer additions will be found first, meaning that the same name
defined in a deeper scope will <i>shadow</i> the parent scope.
This can be seen by usage:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>env-lookup</span> &#39;<span>(</span><span>(</span><span>foo</span> <span>.</span> <span>newer-foo</span><span>)</span>
                    <span>(</span><span>bar</span> <span>.</span> <span>bar</span><span>)</span>
                    <span>(</span><span>foo</span> <span>.</span> <span>older-foo</span><span>)</span><span>)</span>
                  &#39;<span>foo</span><span>)</span>
<span>; </span><span>=&gt; &#39;newer-foo</span>
</pre>
</div>

<p>
The next one is a utility:
</p>

<div>
<pre><span>(</span><span>define</span> <span>(</span><span>extend-env</span> <span>env</span> <span>names</span> <span>vals</span><span>)</span>
  <span>(</span><span>if</span> <span>(</span><span>eq?</span> <span>names</span> &#39;<span>()</span><span>)</span>
      <span>env</span>
      <span>(</span><span>cons</span> <span>(</span><span>cons</span> <span>(</span><span>car</span> <span>names</span><span>)</span> <span>(</span><span>car</span> <span>vals</span><span>)</span><span>)</span>
            <span>(</span><span>extend-env</span> <span>env</span> <span>(</span><span>cdr</span> <span>names</span><span>)</span> <span>(</span><span>cdr</span> <span>vals</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
<code>extend-env</code> takes an environment and a list of names and a
parallel list of values.
This is a convenience which we will use in procedure definitions
later.
Once again, easily understood by usage:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>extend-env</span> &#39;<span>(</span><span>(</span><span>foo</span> <span>.</span> <span>foo-val</span><span>)</span><span>)</span>
                  &#39;<span>(</span><span>bar</span> <span>quux</span><span>)</span>
                  &#39;<span>(</span><span>bar-val</span> <span>quux-val</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; ((bar . bar-val)</span>
<span>;     </span><span>(quux . quux-val)</span>
<span>;     </span><span>(foo . foo-val))</span>
</pre>
</div>

<p>
And now we are onto the evaluator.  The shell of <code>evaluate</code> looks
like so:
</p>

<div>
<pre><span>(</span><span>define</span> <span>(</span><span>evaluate</span> <span>expr</span> <span>env</span><span>)</span>
  <span>(</span><span>match</span> <span>expr</span>
    <span>(</span><span>&lt;MATCH-PATTERN&gt;</span>
     <span>&lt;MATCH-BODY&gt;</span> <span>...</span><span>)</span> <span>...</span><span>)</span><span>)</span>
</pre>
</div>

<p>
<code>evaluate</code> takes two arguments:
</p>
<ul>
<li><code>expr</code>: the expression to evaluate</li>
<li><code>env</code>: the environment in which we will evaluate the expression</li>
</ul>

<p>
For the body of <code>evaluate</code>, we are dispatching our behavior
depending on which patterns match <code>expr</code>.
We are using <code>match</code> from <a href="https://www.gnu.org/software/guile/manual/html_node/Pattern-Matching.html">Guile&#39;s pattern matching syntax</a>
(which came from our module import at the top).
The short of it is though that if a <code>&lt;MATCH-PATTERN&gt;</code> matches,
we will then stop searching for matches and evaluate
<code>&lt;MATCH-BODY&gt;</code> (possibly with bindings set up from the
<code>&lt;MATCH-PATTERN&gt;</code>).
</p>

<p>
So, now all we need to do is look at each pattern we support.
The first is easy:
</p>

<div>
<pre><span>;; </span><span>Support builtin types</span>
<span>(</span><span>(</span><span>or</span> <span>#t</span> <span>#f</span> <span>(</span><span>?</span> <span>number?</span><span>)</span><span>)</span>
 <span>expr</span><span>)</span>
</pre>
</div>

<p>
The <code>or</code> says we can match any one of its contained patterns.
The first two are literally the true and false values from Scheme
itself.
The parentheses starting with a <code>?</code> symbol indicates that we will
try matching against a predicate, in this case <code>number?</code>.
If any of these match, we simply return the very same <code>expr</code> we
are matching against… borrowing booleans and numbers straight
from the underlying Scheme implementation.
</p>

<p>
In other words, the above powers:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>evaluate</span> <span>#t</span> &#39;<span>()</span><span>)</span>
<span>; </span><span>=&gt; #t</span>
<span>REPL&gt;</span> <span>(</span><span>evaluate</span> <span>#f</span> &#39;<span>()</span><span>)</span>
<span>; </span><span>=&gt; #f</span>
<span>REPL&gt;</span> <span>(</span><span>evaluate</span> <span>33</span> &#39;<span>()</span><span>)</span>
<span>; </span><span>=&gt; 33</span>
<span>REPL&gt;</span> <span>(</span><span>evaluate</span> <span>-2/3</span> &#39;<span>()</span><span>)</span>
<span>; </span><span>=&gt; -2/3</span>
</pre>
</div>

<p>
That was easy!
The next one is also easy:
</p>

<div>
<pre><span>;; </span><span>Quoting</span>
<span>(</span><span>(</span>&#39;<span>quote</span> <span>quoted-expr</span><span>)</span>
 <span>quoted-expr</span><span>)</span>
</pre>
</div>

<p>
Recall that <code>&#39;foo</code> is just shorthand for <code>(quote foo)</code>, and likewise
<code>&#39;(1 2 3)</code> is shorthand for <code>(quote (1 2 3))</code>.
In this pattern, we look for anything matching a list starting
with the <code>&#39;quote</code> symbol and a second element which is the expression
to be quoted.
</p>

<p>
In other words, the above powers:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>evaluate</span> &#39;&#39;<span>foo</span> &#39;<span>()</span><span>)</span>
<span>; </span><span>=&gt; foo</span>
<span>REPL&gt;</span> <span>(</span><span>evaluate</span> &#39;&#39;<span>(</span><span>1</span> <span>2</span> <span>3</span><span>)</span> &#39;<span>()</span><span>)</span>
<span>; </span><span>=&gt; (1 2 3)</span>
<span>REPL&gt;</span> <span>(</span><span>evaluate</span> <span>(</span><span>quote</span> <span>(</span><span>quote</span> <span>(</span><span>1</span> <span>2</span> <span>3</span><span>)</span><span>)</span><span>)</span> &#39;<span>()</span><span>)</span>
<span>; </span><span>=&gt; (1 2 3)</span>
</pre>
</div>

<p>
Those last two are the same.  Note that we quote twice: once for
quoting the entire program to be run, and once within the quoted
program to say we want to quote an expression.
</p>

<p>
So far so good.  The next one is still quite easy:
</p>

<div>
<pre><span>;; </span><span>Variable lookup</span>
<span>(</span><span>(</span><span>?</span> <span>symbol?</span> <span>name</span><span>)</span>
 <span>(</span><span>env-lookup</span> <span>env</span> <span>name</span><span>)</span><span>)</span>
</pre>
</div>

<p>
The <code>(? symbol? name)</code> part binds <code>name</code> to the matching component.
(In this case, <code>name</code> will be bound to the same value as the <code>expr</code>
matched against, but this improves readability a little.)
</p>

<p>
As for the body… why, this is quite simple!
We have already reviewed how <code>env-lookup</code> works.
In other words if we see a symbol (not a quoted one of course, that
has already been handled), we look up its corresponding value in
the environment.
</p>

<p>
In other words, the above powers:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>evaluate</span> &#39;<span>x</span> &#39;<span>(</span><span>(</span><span>x</span> <span>.</span> <span>33</span><span>)</span><span>)</span><span>)</span>
<span>; </span><span>=&gt; 33</span>
</pre>
</div>

<p>
However, it will also empower variable lookups we define through
lambda applications:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>evaluate</span> &#39;<span>(</span><span>(</span><span>lambda</span> <span>(</span><span>x</span><span>)</span> <span>x</span><span>)</span> <span>33</span><span>)</span> &#39;<span>()</span><span>)</span>
<span>; </span><span>=&gt; 33</span>
</pre>
</div>

<p>
Of course, we have not yet gotten to <code>lambda</code>!
But we are nearly there.
</p>

<p>
The next one, conditionals, also turns out to be fairly easy:
</p>

<div>
<pre><span>;; </span><span>Conditionals</span>
<span>(</span><span>(</span>&#39;<span>if</span> <span>test</span> <span>consequent</span> <span>alternate</span><span>)</span>
 <span>(</span><span>if</span> <span>(</span><span>evaluate</span> <span>test</span> <span>env</span><span>)</span>
     <span>(</span><span>evaluate</span> <span>consequent</span> <span>env</span><span>)</span>
     <span>(</span><span>evaluate</span> <span>alternate</span> <span>env</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
In other words, a list starting with the symbol <code>&#39;if</code> will be
matched, with the three sub-expressions following <code>&#39;if</code> bound to
the variables <code>test</code>, <code>consequent</code>, and <code>alternate</code> in the match
body.
We use the underlying Scheme <code>if</code>, and first evaluate <code>test</code> against
the current environment <code>env</code> (notice the recursion!), and the host
Scheme&#39;s <code>if</code> helps us whether to evaluate the <code>consequent</code> or
<code>alternate</code> inside of <code>env</code>, again using <code>evaluate</code> recursively.
</p>

<p>
Okay, now it&#39;s time to build procedures.  This one is a little
bit more complicated, but ultimately not too complicated either:
</p>

<div>
<pre><span>;; </span><span>Lambdas (Procedures)</span>
<span>(</span><span>(</span>&#39;<span>lambda</span> <span>(</span><span>args</span> <span>...</span><span>)</span> <span>body</span><span>)</span>
 <span>(</span><span>lambda</span> <span>(</span><span>.</span> <span>vals</span><span>)</span>
   <span>(</span><span>evaluate</span> <span>body</span> <span>(</span><span>extend-env</span> <span>env</span> <span>args</span> <span>vals</span><span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
The pattern here looks for a list starting with <code>&#39;lambda</code>, with the
second list member being the set of arguments, with the body being
captured as, well, <code>body</code>.
We then return a procedure which is ready to be evaluated with the
same number of arguments.<sup><a id="fnr.22" href="#fn.22" role="doc-backlink">22</a></sup>
The inner body of the procedure we return recursively calls
<code>evaluate</code> against the <code>body</code> expression of the lambda we are
matching against, but with a newly extended environment, binding
together the names within <code>args</code> and the <code>vals</code> from the procedure
invocation.
</p>

<p>
In other words, the above powers:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>(</span><span>evaluate</span> &#39;<span>(</span><span>lambda</span> <span>(</span><span>x</span> <span>y</span><span>)</span> <span>x</span><span>)</span> &#39;<span>()</span><span>)</span>
       &#39;<span>first</span> &#39;<span>second</span><span>)</span>
<span>; </span><span>=&gt; first</span>
<span>REPL&gt;</span> <span>(</span><span>(</span><span>evaluate</span> &#39;<span>(</span><span>lambda</span> <span>(</span><span>x</span> <span>y</span><span>)</span> <span>y</span><span>)</span> &#39;<span>()</span><span>)</span>
       &#39;<span>first</span> &#39;<span>second</span><span>)</span>
<span>; </span><span>=&gt; second</span>
</pre>
</div>

<p>
There is only one more piece left… application!
</p>

<div>
<pre><span>;; </span><span>Procedure Invocation (Application)</span>
<span>(</span><span>(</span><span>proc-expr</span> <span>arg-exprs</span> <span>...</span><span>)</span>
 <span>(</span><span>apply</span> <span>(</span><span>evaluate</span> <span>proc-expr</span> <span>env</span><span>)</span>
        <span>(</span><span>map</span> <span>(</span><span>lambda</span> <span>(</span><span>arg-expr</span><span>)</span>
               <span>(</span><span>evaluate</span> <span>arg-expr</span> <span>env</span><span>)</span><span>)</span>
             <span>arg-exprs</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
This is the general-purpose procedure application piece of the puzzle!
At this point, the pattern will match any list with one or more
arguments, determining that this must mean a procedure applied to
arguments.
We evaluate the <code>proc-expr</code>, representing the procedure to be
evaluated, within the current arguments, calling <code>evaluate</code>
recursively with the current environment, <code>env</code>.
We also gather all the <code>arg-expr</code> argument expressions passed to
this procedure by calling <code>evaluate</code> recursively on each with
the current environment, <code>env</code>.
</p>

<p>
In other words, the above powers:
</p>

<div>
<pre><span>REPL&gt;</span> <span>(</span><span>evaluate</span> &#39;<span>(</span><span>*</span> <span>(</span><span>-</span> <span>8</span> <span>(</span><span>/</span> <span>30</span> <span>5</span><span>)</span><span>)</span> <span>21</span><span>)</span>
                <span>math-env</span><span>)</span>
<span>; </span><span>=&gt; 42</span>
</pre>
</div>

<p>
And with all pieces combined, we have enough power not only to compute
the Fibonacci sequence, but any computable problem imaginable!
</p>

<p>
To be fair, this does borrow a portion of Scheme&#39;s underlying power,
but not as much as it may appear… certainly less than many languages
implemented on top of other languages do (certainly, certainly far
less than Clojure borrows from Java, for instance, or nearly any
popular language borrows from C&#39;s standard library).<sup><a id="fnr.23" href="#fn.23" role="doc-backlink">23</a></sup>
And it is not so complete as to implement any of the Scheme standards.
But without too much extra work, we could get there, and it is enough
for demonstration.
But we also get to <i>choose</i> how much power we give the language,
by modifying the initial environment the code evaluates in.
</p>

<p>
<b>It is also a capability-secure language!</b>
Aside from going into an infinite loop and consuming too many
resources in terms of memory or CPU power, there is nothing
particularly dangerous this language can do.
However, we can decide how much power we would like to give it.
If we choose, we can provide an environment with mutable cells,
or one with access to the filesystem.
The choice is ours.
</p>

<p>
And with tiny tweaks, our evaluator can operate in different and
marvelous ways.
We can add new syntax.
We can add new syntax to add new syntax (macros)!
We can change evaluation order, we can add static type analysis,
we can do many things.
</p>

<p>
We promised that you would have learned Scheme from this tutorial.
If you have reached this point, you have reached much more: you
are no longer just a user of scheme, but a builder of Scheme.
The power is yours!<sup><a id="fnr.24" href="#fn.24" role="doc-backlink">24</a></sup>
</p>
</div>
</div>
</div></div>
  </body>
</html>
