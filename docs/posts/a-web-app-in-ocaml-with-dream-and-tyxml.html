<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sawyer.dev/posts/pomocaml/">Original</a>
    <h1>A Web App in OCaml with Dream and TyXML</h1>
    
    <div id="readability-page-1" class="page"><div>
      



<section id="post">

  <nav>
    &gt; <a href="https://sawyer.dev/">home</a>
    &gt; <a href="https://sawyer.dev/posts">blog posts</a>
  </nav>

  <container>
    <h2 id="post-title"> A Web App in OCaml with Dream and TyXML </h2>

    <article>
      <h2>background and motivation</h2>
<p>I&#39;ve made some progress with OCaml since I wrote my <a href="https://sawyer.dev/posts/first-steps-ocaml">first steps with ocaml post</a>. After that post, I started a project to load CSVs into a database so it&#39;d be easier for me to query the data. This was initially a command-line tool but has since grown to include a REST API. Overall, that project has been really helpful for learning more about building an actual application with OCaml, a step up from solving the coding challenges on the OCaml website.</p>
<p>I now want to explore that data visually, and to do so I&#39;d like to build a frontend component. However, before doing that, I&#39;d like to kind of start over with a project that has a smaller scope. The goal for this smaller project is to explore the options for building frontend applications with OCaml. I&#39;ve heard of a few things over the years - <code>js_of_ocaml</code>, ReScript, ReasonML - but I don&#39;t know how they work.</p>
<p>For this application, I wanted to work on an idea I&#39;d been kicking around for a while: tracking pomodoros. I&#39;ve used the <a href="https://en.wikipedia.org/wiki/Pomodoro_Technique">pomodoro technique</a> for years and have found it to be a very useful way of structuring parts of my day. However, for almost all of the time I&#39;ve used this technique, I&#39;ve done relatively little <em>tracking</em> of that work; I&#39;d just set a timer and try to stay focused on one task for 25 minutes. Maybe I&#39;d take a 5- or 10-minute break, sometimes I&#39;d just keep going. I really only used the technique as a way of getting started and staying focused, not for reflection.</p>
<p>I kept going like that until about a year ago, when my wife mentioned she&#39;d been writing down what she did during each pom (our shorthand for the standard 25-minute window). Even then, it wasn&#39;t until I started contracting (and needed to actually account for my hours) that I started doing the same. Since then, it&#39;s become a core part of my work routine.</p>
<h2>implementation</h2>
<p>This is, more or less, the smallest thing I could think of while still using the tools I&#39;m interested in learning. The &#34;architecture&#34; is a backend web server with two endpoints and a sqlite database serving templated HTML. There&#39;s a form with fields for a title and a description, and then a list of my completed poms underneath that. Eventually I&#39;ll want to add things like start/stop fields to the form, and more interesting ways of displaying completed poms, but for now I just want an example of an end-to-end OCaml web app.</p>
<h3>server</h3>
<p>I&#39;m using <a href="https://aantron.github.io/dream/">Dream</a> for the server. I&#39;ve seen some other Recursers build projects with it and the combination of their blog posts and Dream&#39;s extensive collection of examples made it very easy to get set up. It reminds me of HTTP servers I&#39;ve used before, like Express and Flask, in that the core model seems to be a list of endpoint/function pairs. I&#39;m sure that&#39;s skipping over a lot of details, but that mental model didn&#39;t really seem to get in my way at this point.</p>
<h3>client</h3>
<p>As the name of this post implies, I settled on using TyXML for frontend things rather than Dream&#39;s &#34;Embedded ML&#34; templating language. The reason for this is that, uh, TyXML worked with my emacs configuration right away, and EML didn&#39;t. I realize that&#39;s not exactly picking a technology on its merits, but I&#39;m chalking this one up to &#34;beginner&#39;s impatience&#34;, with the hope of potentially giving EML a more fair assessment in the future.</p>
<p>I&#39;m using TyXML&#39;s <code>Html</code> package (instead of either the Reason/JSX syntax or the preprocessing syntax), mostly because I&#39;m new enough to still be kind of weirded out by ppx stuff. Also, I&#39;ve done a few Elm tutorials and this approach reminded me of Elm&#39;s HTML syntax, so there&#39;s probably also a bit of recognition there that drew me to this method. The TyXML <a href="https://github.com/ocsigen/tyxml/tree/master/examples/basic_website"><code>basic_website</code> example</a> and <a href="https://github.com/aantron/dream/tree/master/example/w-tyxml">Dream&#39;s TyXML example</a> were super helpful to get started. I struggled a bit with translating HTML into TyXML&#39;s syntax, but I eventually got there.</p>
<p>One component I haven&#39;t bothered with yet is client-side scripting, which is kind of funny to me since that&#39;s the only part of OCaml&#39;s web ecosystem I was aware of before I got started. I think the reason I&#39;ve stayed away (aside from the fact that client-side code is probably unnecessary for this project) is that I couldn&#39;t quickly tell which system would feel right to me. I was able to pretty quickly fall into a productive pattern with TyXML. I&#39;m not sure I&#39;m able to do that with any of the common client-side tools. I&#39;m hesitant to try ReScript and ReasonML because I&#39;d prefer to stick to OCaml (although who&#39;s to say where OCaml ends and the other begins?) but the <code>js_of_ocaml</code> code I&#39;ve seen doesn&#39;t really look like it would bring the same joy that I&#39;ve felt with OCaml so far. I also don&#39;t really know what the developer experience or ~~ ergonomics ~~ of each feels like, so I suspect that&#39;ll make for a decent follow-up post.</p>
<h2>reflection</h2>
<p>The more I work with OCaml, the more I enjoy it. My work from the past few years has been mostly Python, JavaScript/TypeScript, and SQL, and I&#39;ve been kind of shocked at the salience of the relief I feel by relying on a strong type system. My head feels less cluttered. I get a more satisfying <em>click</em> in my head when my code runs. Sure, yes, TypeScript does have a really impressive type system, but it&#39;s also super easy to just kind of, like, opt out of it, undercutting the comfort gained from the type system&#39;s safety net.</p>
<p>I&#39;m looking forward to writing more OCaml code, even if it&#39;s just on the side. Maybe it&#39;s just that I know the early versions were written in OCaml, but it does remind me a lot of Rust. I&#39;ve enjoyed learning and writing Rust too, but I like OCaml&#39;s closer ties to CS theory and I haven&#39;t had to thinking about borrowing or lifetimes.</p>
<p>If you&#39;re interested in seeing a true novice at work, feel free to peruse the repo (I&#39;ll try to open up the CSV project at some point, too): <a href="https://gitlab.com/soryrawyer/pomocaml">https://gitlab.com/soryrawyer/pomocaml</a></p>

    </article>

  </container>


</section>

    </div></div>
  </body>
</html>
