<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ahgamut.github.io/2022/10/23/debugging-c-with-cosmo/">Original</a>
    <h1>Debugging C with Cosmopolitan Libc</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<article>
<p><a href="https://justine.lol/cosmopolitan">Cosmopolitan Libc</a> provides a suite of debugging features that enhance
the C development experience: function call tracing, <code>gdb</code> integration, an
ASAN/UBSAN runtime, and more! A lot of fast and critical code is written in C –
If you’re using software written in C, interfacing with C libraries, fixing bugs
in C code, or even rewriting C software in some other language, it helps to
understand what your C code is doing. Debugging isn’t just a diaspora of
<code>printf</code> statements – in this blog post, we’ll look at how Cosmopolitan Libc
helps with debugging C, true and properly, using this <a href="https://github.com/ahgamut/debug-cosmo-example">example repo</a>.</p>
<h2 id="an-example-program">An example program</h2>
<p>Consider <a href="https://github.com/ahgamut/debug-cosmo-example/blob/main/hex16.c"><code>hex16.c</code></a>: the user specifies a file at the command
line, the program opens the file, prints (up to) the first 16 bytes as
hexadecimal values, and then prints the bytes read as an ASCII string. You can
find the entire code <a href="https://github.com/ahgamut/debug-cosmo-example">here</a>.</p>
<div><pre tabindex="0"><code data-lang="c"><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span><span>#define NUM_CHARS 16
</span><span></span>
<span>void</span> <span>hex16</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>filename</span><span>)</span> <span>{</span>
    <span>FILE</span> <span>*</span><span>fp</span> <span>=</span> <span>fopen</span><span>(</span><span>filename</span><span>,</span> <span>&#34;r&#34;</span><span>);</span>
    <span>char</span> <span>res</span><span>[</span><span>NUM_CHARS</span><span>];</span>
    <span>int</span> <span>i</span><span>,</span> <span>c</span><span>;</span>

    <span>printf</span><span>(</span><span>&#34;hex16.c -- reading file %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>filename</span><span>);</span>
    <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>NUM_CHARS</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
        <span>c</span> <span>=</span> <span>fgetc</span><span>(</span><span>fp</span><span>);</span>
        <span>if</span> <span>(</span><span>feof</span><span>(</span><span>fp</span><span>)</span> <span>||</span> <span>c</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>break</span><span>;</span>
        <span>printf</span><span>(</span><span>&#34;0x%02x &#34;</span><span>,</span> <span>c</span><span>);</span>
        <span>res</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>(</span><span>char</span><span>)</span><span>c</span><span>;</span>
    <span>}</span>
    <span>res</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
    <span>fclose</span><span>(</span><span>fp</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>%s</span><span>\n</span><span>&#34;</span><span>,</span> <span>res</span><span>);</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span> <span>{</span>
    <span>hex16</span><span>(</span><span>argv</span><span>[</span><span>1</span><span>]);</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div><p>Let’s build the above program with <code>make</code> and test it on a sample file:</p>
<div><pre tabindex="0"><code data-lang="bash">make hex16.com
./hex16.com ./sample1.txt
<span># hex16.c -- reading file ./sample1.txt</span>
<span># 0x63 0x6f 0x73 0x6d 0x6f 0x20 0x6c 0x69 0x62 0x63 0x0a </span>
<span># cosmo libc</span>
</code></pre></div><p>But what happens if you don’t provide a file or provide a nonexistent file?</p>
<div><pre tabindex="0"><code data-lang="bash">./hex16.com
<span># Segmentation fault</span>
./hex16.com ./missing.txt
<span># Segmentation fault</span>
</code></pre></div><p>Hmm, <code>Segmentation fault</code> is not quite informative – some part of the program
is causing a crash, but where?</p>
<h2 id="gdb-and-backtraces"><code>gdb</code> and backtraces</h2>
<p>With Cosmopolitan Libc, you can have <a href="https://www.sourceware.org/gdb/"><code>gdb</code></a> integration and detailed
backtraces for your C program in just one line: add <code>ShowCrashReports();</code> at the
start of the <code>main</code> function. Let’s build <a href="https://github.com/ahgamut/debug-cosmo-example/blob/main/hex16-backtrace.c"><code>hex16-backtrace.c</code></a>
which is just that:</p>
<div><pre tabindex="0"><code data-lang="bash">make hex16-backtrace.com
<span># try with no arguments</span>
./hex16-backtrace.com
<span># or try with a nonexistent file</span>
./hex16-backtrace.com ./missing.txt
</code></pre></div><p>Now if you have <a href="https://www.sourceware.org/gdb/"><code>gdb</code></a> available on <code>$PATH</code>, you would get a TUI (terminal
user interace) showing the register contents and the backtrace of the crash,
like the image below:</p>
<p><img src="https://ahgamut.github.io/images/debug-cosmo/gdb-cosmo.png" alt="a gdb tui showing register info and the location of the crash"/></p>
<p>Type <code>bt</code> and press <code>Enter</code> to view the backtrace in <code>gdb</code>, and exit by pressing
<code>Ctrl+D</code>. You can set up a config for <code>gdb</code> from the Cosmopolitan Libc README
<a href="https://github.com/jart/cosmopolitan#gdb">here</a>.</p>
<p>If <code>gdb</code> is not available, or if you’re running the program as part of a test
script, you would get the backtrace in text, showing the register contents and
the backtrace of the crash:</p>
<pre tabindex="0"><code>error: Uncaught SIGSEGV (SEGV_MAPERR) on X550LD pid 256891 tid 256891
  ./hex16-backtrace.com
  EUNKNOWN/0/No error information
  Linux #1 SMP Debian 5.10.106-1 (2022-03-17) X550LD 5.10.0-13-amd64

RAX 0000000000000000 RBX 00007ffe5c5c9a70 RDI 000000000042dd48 ST(0) 0.0
RCX 0000000000000000 RDX 0000000000000000 RSI 0000000000000240 ST(1) 0.0
RBP 00007000007fff80 RSP 00007000007fff60 RIP 000000000040b698 ST(2) 0.0
 R8 0000000000000000  R9 0000000000000001 R10 0000000000000004 ST(3) 0.0
R11 0000000000000293 R12 0000000000000000 R13 000000000042dd46 ST(4) 0.0
R14 00007ffe5c5c9a80 R15 00007ffe5c5c9b90 VF PF ZF IF

XMM0  00000000000000000000000000000000 XMM8  00000000000000000000000000000000
XMM1  7865682f656c706d6178652d6f6d736f XMM9  00000000000000000000000000000000
XMM2  632d67756265642f6f6d736f632f6666 XMM10 00000000000000000000000000000000
XMM3  7574732f6d6168747561672f656d6f68 XMM11 00000000000000000000000000000000
XMM4  6f632e65636172746b6361622d363178 XMM12 00000000000000000000000000000000
XMM5  65682f656c706d6178652d6f6d736f63 XMM13 00000000000000000000000000000000
XMM6  2d67756265642f6f6d736f632f666675 XMM14 00000000000000000000000000000000
XMM7  74732f6d6168747561672f656d6f682f XMM15 00000000000000000000000000000000

0x000000000040b697: fixpathname at /home/jart/cosmo/libc/stdio/fopen.c:26
 (inlined by) fopen at /home/jart/cosmo/libc/stdio/fopen.c:62
0x00000000004098d0: hex16 at /home/gautham/stuff/cosmo/debug-cosmo-example/hex16-backtrace.c:5
0x000000000040291e: main at /home/gautham/stuff/cosmo/debug-cosmo-example/hex16-backtrace.c:22
0x00000000004029cb: cosmo at /home/jart/cosmo/libc/runtime/cosmo.S:77
0x0000000000402503: _start at /home/jart/cosmo/libc/crt/crt.S:103

10008004-10008004 rw-pa-   1x automap 64kB w/ 7872kB hole
10008080-100080ff rw-pa- 128x automap 8192kB w/ 96tB hole
6fe00004-6fe00004 rw-paF   1x g_fds 64kB
70000000-7000007f rw-Sa- 128x stack 8192kB
# 16mB total mapped memory
./hex16-backtrace.com 
</code></pre><p>From the backtrace, you now know that not providing a file causes a crash
involving <code>fopen</code>, and so update the program to check if the first parameter of
<code>fopen</code> (ie <code>argv[1]</code>) is NULL or not. Note that backtrace generation depends on
the <code>hex16-backtrace.com.dbg</code> file being located in the same directory as
<code>hex16-backtrace.com</code>, as it contains necessary debugging information.</p>
<p>Just knowing the backtrace of a crash helps reduce the time needed to fix an
error: when porting <a href="https://github.com/jart/cosmopolitan/pull/305"><code>make</code> to Cosmopolitan Libc</a>, adding a
<code>ShowCrashReports</code> showed that <code>make</code> had some large <code>alloca</code> calls which were
causing a crash. The fix was to add a <code>STATIC_STACK_SIZE</code> call in the <code>main</code>
function, and then <code>make</code> could build the entire Cosmopolitan Libc monorepo.</p>
<h2 id="function-call-tracing-with---ftrace">function call tracing with <code>--ftrace</code></h2>
<p>Sometimes a backtrace of the crash alone is not sufficient. Cosmopolitan Libc
allows you to log <em>every function call</em> over the program’s execution – just
pass <a href="https://justine.lol/ftrace/"><code>--ftrace</code></a> at the end of your program, like this:</p>
<div><pre tabindex="0"><code data-lang="bash">./hex16.com ./missing.txt --ftrace
</code></pre></div><pre tabindex="0"><code># truncated example
FUN 257012     1&#39;567&#39;864        48 &amp;main
FUN 257012     1&#39;573&#39;031       112   &amp;hex16
FUN 257012     1&#39;578&#39;356       160     &amp;fopen
FUN 257012     1&#39;612&#39;346       336     &amp;printf
FUN 257012     1&#39;720&#39;829       144     &amp;fgetc
FUN 257012     1&#39;726&#39;479       176       &amp;fgetc_unlocked
Segmentation Fault
</code></pre><ul>
<li>The first column indicates it is a function call</li>
<li>the second column shows the process ID/thread ID calling the function</li>
<li>the third column shows the approximate timestamp from the start of program
execution</li>
<li>the last column shows the name of the function that was called.</li>
</ul>
<p>The <code>ftrace</code> output gets printed to <code>stderr</code> by default; it is useful to
redirect it to a file for later analysis. <code>ftrace</code> does not require
<code>ShowCrashReports()</code> at the start of the <code>main</code> function, though it still
requires the <code>hex16.com.dbg</code> for <code>hex16.com</code>. You can read more about how <code>ftrace</code>
works <a href="https://justine.lol/ftrace/">here</a>.</p>
<p><code>ftrace</code> also provides insight into program performance. I wrote a <a href="https://github.com/jart/cosmopolitan/pull/285">Python
wrapper for <code>ftrace</code></a> so I could examine how the CPython3.6 runtime
behaves. For example, here’s how many calls it takes to add two values in
Python3.6 built with Cosmopolitan Libc:</p>
<div><pre tabindex="0"><code data-lang="python"><span>import</span> <span>cosmo</span>
<span>a</span> <span>=</span> <span>1</span>
<span>b</span> <span>=</span> <span>2</span>
<span>with</span> <span>cosmo</span><span>.</span><span>ftrace</span><span>():</span>
    <span>c</span> <span>=</span> <span>a</span> <span>+</span> <span>b</span>
</code></pre></div><pre tabindex="0"><code>&amp;meth_dealloc
&amp;PyFrame_BlockSetup 76
&amp;object_dealloc 265
  &amp;PyObject_Free 82
    &amp;_PyObject_Free.isra.0 52
&amp;PyDict_GetItem 333
  &amp;lookdict_unicode_nodummy 157
&amp;PyDict_GetItem 166
  &amp;lookdict_unicode_nodummy 34
&amp;PyNumber_Add 273
  &amp;binary_op1 69
    &amp;long_add 178
      &amp;PyLong_FromLong 135
&amp;PyDict_SetItem 273
  &amp;insertdict 164
    &amp;lookdict_unicode_nodummy 53
&amp;PyFrame_BlockPop 320
&amp;PyObject_CallFunctionObjArgs 249
  &amp;object_vacall 40
    &amp;_PyObject_FastCallDict 95
      &amp;_PyCFunction_FastCallDict 53
        &amp;_PyMethodDef_RawFastCallDict 86
          &amp;_PyStack_AsTuple 61
            &amp;PyTuple_New 121
          &amp;FtracerObject_exit 199
</code></pre><p>The numbers on the right are an approximate measure of time each function takes,
which is pretty useful for a “slow” language like Python3.6<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. <code>ftrace</code>
helped write a <a href="https://github.com/jart/cosmopolitan/pull/425">custom <code>sys.meta_path</code> importer</a> for Python3.6 in
Cosmopolitan Libc – I just moved code from Python into C until the size of the
ftrace logs stopped decreasing.</p>
<h2 id="system-call-tracing-with---strace">system call tracing with <code>--strace</code></h2>
<p>Sometimes tracing function calls is too much information, and you just want to
narrow down the error region from some logging information. If your program uses
a bunch of system calls, you can log them like functions, by passing
<code>--strace</code> at the end of your program invocation, like this:</p>
<div><pre tabindex="0"><code data-lang="bash">./hex16.com ./missing.txt --strace
</code></pre></div><pre tabindex="0"><code>SYS 257304  43&#39;627 bell system five system call support 171 magnums loaded on gnu/systemd
SYS 257304  99&#39;854 mmap(0x700000000000, 8&#39;388&#39;608, PROT_READ|PROT_WRITE, MAP_STACK|MAP_ANONYMOUS, -1, 0) → 0x700000000000 (8&#39;388&#39;608 bytes total)
SYS 257304 892&#39;097 getenv(&#34;TERM&#34;) → &#34;xterm-256color&#34;
SYS 257304 908&#39;170 openat(AT_FDCWD, &#34;./missing.txt&#34;, 0, 0) → -1 errno= 2
SYS 257304 932&#39;876 write(1, u&#34;hex16.c -- reading file ./missing.txt◙&#34;, 38) → 38 errno= 2
</code></pre><ul>
<li>The first column indicates it is a system call</li>
<li>the second column shows the process ID/thread ID making the call</li>
<li>the third column shows the approximate timestamp from the start of program
execution</li>
<li>the fourth column shows output of the system call along with errno values</li>
</ul>
<p>Unlike <code>ShowCrashReports</code> and <code>ftrace</code>, the <code>--strace</code> flag does not require the
<code>hex16.com.dbg</code> file to be present. Now you see that the <code>openat</code> resulted in
an <code>-1 errno 2</code> if the file doesn’t exist, so let’s update the code to check the
<code>FILE *</code> pointer before calling <code>fgetc</code>. Thus you get the fixed program
<a href="https://github.com/ahgamut/debug-cosmo-example/blob/main/hex16-fixed.c"><code>hex16-fixed.c</code></a> below:</p>
<div><pre tabindex="0"><code data-lang="c"><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span><span>#define NUM_CHARS 16
</span><span></span>
<span>void</span> <span>hex16</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>filename</span><span>)</span> <span>{</span>
    <span>FILE</span> <span>*</span><span>fp</span> <span>=</span> <span>fopen</span><span>(</span><span>filename</span><span>,</span> <span>&#34;r&#34;</span><span>);</span>
    <span>char</span> <span>res</span><span>[</span><span>NUM_CHARS</span><span>];</span>
    <span>int</span> <span>i</span><span>,</span> <span>c</span><span>;</span>

    <span>if</span> <span>(</span><span>!</span><span>fp</span><span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;unable to read %s!</span><span>\n</span><span>&#34;</span><span>,</span> <span>filename</span><span>);</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>printf</span><span>(</span><span>&#34;hex16.c -- reading file %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>filename</span><span>);</span>
    <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>NUM_CHARS</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
        <span>c</span> <span>=</span> <span>fgetc</span><span>(</span><span>fp</span><span>);</span>
        <span>if</span> <span>(</span><span>feof</span><span>(</span><span>fp</span><span>)</span> <span>||</span> <span>c</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>break</span><span>;</span>
        <span>printf</span><span>(</span><span>&#34;0x%02x &#34;</span><span>,</span> <span>c</span><span>);</span>
        <span>res</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>(</span><span>char</span><span>)</span><span>c</span><span>;</span>
    <span>}</span>
    <span>res</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
    <span>fclose</span><span>(</span><span>fp</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>%s</span><span>\n</span><span>&#34;</span><span>,</span> <span>res</span><span>);</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>argc</span> <span>!=</span> <span>2</span><span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;USAGE:</span><span>\n\t</span><span>%s FILENAME</span><span>\n</span><span>&#34;</span><span>,</span> <span>argv</span><span>[</span><span>0</span><span>]);</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>hex16</span><span>(</span><span>argv</span><span>[</span><span>1</span><span>]);</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="asanubsan">ASAN/UBSAN</h2>
<p>The two errors in <code>hex16.com</code> have been fixed, so it’s time to try another
testcase to see if there are any more. What happens if the input file contains
16 or more characters?</p>
<div><pre tabindex="0"><code data-lang="bash">cat ./sample2.txt
<span># cosmopolitan libc</span>
./hex16.com ./sample2.txt
<span># hex16.c -- reading file ./sample2.txt</span>
<span># 0x63 0x6f 0x73 0x6d 0x6f 0x70 0x6f 0x6c 0x69 0x74 0x61 0x6e 0x20 0x6c 0x69 0x62 </span>
<span># cosmopolitan lib2</span>
./hex16.com ./sample2.txt
<span># hex16.c -- reading file ./sample2.txt</span>
<span># 0x63 0x6f 0x73 0x6d 0x6f 0x70 0x6f 0x6c 0x69 0x74 0x61 0x6e 0x20 0x6c 0x69 0x62 </span>
<span># cosmopolitan lib3</span>
</code></pre></div><p><code>hex16.com</code> has inconsistent behavior with <code>sample2.txt</code> – sometimes it prints
extra garbage characters. But there is a <code>res[i] = &#39;\0&#39;</code> after the loop to
terminate the string, so what’s going on? Let’s build with the Cosmopolitan
Libc’s ASAN/UBSAN runtime and find out:</p>
<div><pre tabindex="0"><code data-lang="bash">make clean
make <span>MODE</span><span>=</span>dbg hex16-backtrace.com
./hex16-backtrace.com ./sample2.txt
</code></pre></div><pre tabindex="0"><code>hex16-backtrace.c:16: ubsan error: &#39;int&#39; index 16 into &#39;char [16]&#39; out of bounds (tid 257624)
0x0000000000480c00: __ubsan_handle_out_of_bounds at /home/jart/cosmo/libc/intrin/ubsan.c:289
0x0000000000421658: hex16 at /home/gautham/stuff/cosmo/debug-cosmo-example/hex16-backtrace.c:16
0x0000000000402bf1: main at /home/gautham/stuff/cosmo/debug-cosmo-example/hex16-backtrace.c:22
0x0000000000402cfd: cosmo at /home/jart/cosmo/libc/runtime/cosmo.S:77
0x0000000000402543: _start at /home/jart/cosmo/libc/crt/crt.S:103
</code></pre><p>Ah – when the file has more than 16 characters, the null terminator is written
<em>outside</em> the buffer, causing a buffer overflow when the string is printed. Now
you can change the buffer to have one extra character, to handle this case,
leading to the now again-fixed <a href="https://github.com/ahgamut/debug-cosmo-example/blob/main/hex16-ubsan.c"><code>hex16-ubsan.c</code></a>.</p>
<p>Cosmopolitan’s ASAN/UBSAN runtime adds a magical improvement to your C
development workflow<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>, for a tiny cost. Your build times increase only
marginally, you avoid any new arguments with the compiler, you still write your
tests as usual, and your binaries have almost the same performance. And of
course, your binaries will now have runtime memory safety.</p>
<h2 id="in-case-of-emergency-or-lack-of-patience">In case of emergency (or lack of patience)</h2>
<p>Sometimes you find an annoying bug that occurs only during a specific sequence
of events, and you just haven’t figured it out. It’s <u>not related to
ASAN/UBSAN</u> – the runtime tells you some memory access is invalid, which is
good to know, but you don’t know where it all started. The <u>system calls are
not shining light into the issue</u>, because it isn’t related to how your
program interacts with the OS. The <u>function call sequences are too many</u>,
and mixed in due to multithreading, so it’s difficult for you to make sense of
what’s going on. You <u>start <code>gdb</code> and setup a dozen breakpoints</u> before
running the program, but it’s too stop-start, and you don’t have enough
experience or patience to poke at the right spots. In frustration, you reach for
the good old <code>printf</code> statements, but they don’t work either! You have no tools,
because your tools haven’t set up enough for your tools, like that bug where
Python hasn’t set up <code>stdin</code> because the <code>encodings</code> module hasn’t been
loaded<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> or the one where Rust’s thread-local storage makes some
seemingly weird memory requests from the libc on startup<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>.</p>
<p>You’re backed into a corner. How do you debug this seemingly impervious
<a href="https://en.wikipedia.org/wiki/Heisenbug">heisenbug</a>?</p>
<ol>
<li>
<p>You imagine yourself as an <code>x86_64</code> chip (complete with power supply, RAM,
and peripherals) and start <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">rubberducking</a> each assembly instruction
to hapless passerby until the end of time or until the bug is found,
whichever is earlier.</p>
</li>
<li>
<p>You use <a href="https://justine.lol/cosmopolitan/documentation.html#kprintf">Cosmopolitan Libc’s <code>kprintf</code></a>.</p>
</li>
</ol>
<p><a href="https://justine.lol/cosmopolitan/documentation.html#kprintf"><code>kprintf</code></a> is the final tool in the Cosmopolitan Libc debugging
arsenal. Look at the <a href="https://github.com/jart/cosmopolitan/blob/ef9776755ee3646029624fe30de5d58a3c03f6f6/libc/intrin/kprintf.greg.c"><code>kprintf</code> source code</a> – It’s a lean
implementation of <code>printf</code> designed to work <em>everywhere</em>. It’s what Cosmopolitan
Libc uses when the other functions want to write logs, even after the program
has crashed. So it has to work at all times. This is what happens if you try to
print some weird memory location using <code>kprintf</code>:</p>
<div><pre tabindex="0"><code data-lang="c"><span>kprintf</span><span>(</span><span>&#34;%s</span><span>\n</span><span>&#34;</span><span>,</span> <span>31415</span><span>);</span>
<span>//!!7ab7
</span></code></pre></div><p>You can even clone the Cosmopolitan Libc monorepo, add <code>kprintf</code> calls in
Cosmopolitan Libc’s internal functions, and test your code with your own
debug-customized libc! When all else fails, <code>kprintf</code> can get the job done,
provided you use it <strike>judiciously</strike> to print the value of every
variable after every statement in every function that your program has to call.</p>
<p><img src="https://ahgamut.github.io/images/debug-cosmo/kprintf.jpg" alt="bell curve meme with printf and kprintf"/></p>
<h2 id="closing-notes">Closing Notes</h2>
<p>Nobody writes perfect code in one try. Many eyes make bugs scarce. With
Cosmopolitan Libc, debugging becomes a game of Scotland Yard, instead of
blind-man’s buff – instead of stumbling around and stubbing your toes, you have
<strong>five</strong> different angles to understand what your program is doing and determine
where it starts going off the rails:</p>
<ul>
<li>you can have a simple backtrace with the register contents</li>
<li>you can log all (or a subset of) the function calls to see which sequence possibly
leads to a crash or a slowdown</li>
<li>you can log all the system calls and examine the interaction between your
program and the OS</li>
<li>you can learn to use <code>gdb</code> and dissect your program with an ever-increasing number
of breakpoints or similar wizardry</li>
<li>when at your wit’s end, you can revert to old habits, only this time you use
<code>kprintf</code> instead of <code>printf</code> and gain superpowers</li>
</ul>
<p>Underneath all the libraries, syntax, abstractions, and optimizations, we still
need to have some idea of what’s going on. Writing programs is a lot more fun
when we can understand what the computer is actually doing. Detailed feedback
helps understand programs better, and quick feedback helps develop programs
faster. Cosmopolitan Libc provides a set of debugging tools we can use to
enrich our understanding of the programs we write.</p>

</article>
</div></div>
  </body>
</html>
