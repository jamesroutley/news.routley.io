<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.robertelder.org/recording-660-fps-on-raspberry-pi-camera/">Original</a>
    <h1>Recording 660FPS Video on a $6 Raspberry Pi Camera (2019)</h1>
    
    <div id="readability-page-1" class="page"><div>
						<div>


<h5>2019-08-01 - By Robert Elder</h5>


<p>     This article will discuss the setup steps that are required for recording videos at high frame rates on cheap Raspberry Pi cameras.  Frame rates up to 660FPS on the V1 camera and up to 1007 on the V2 camera can be achieved.  Filming at these extremely high frame rates on a Raspberry Pi is much more challenging and involves more work than typical point and shoot photography.  This article was primarily written to supplement the instructions in the following video:</p>

<iframe src="https://www.youtube.com/embed/m7gUZpjF-1s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
<p>     The instructions presented here were tested to work on a fresh Raspbian OS image with the following md5 hash:</p>

<p><code><pre>md5sum ~/Downloads/2019-07-10-raspbian-buster-lite.img
921052ef30538b995933078e8779c585  ~/Downloads/2019-07-10-raspbian-buster-lite.img
</pre></code></p><p>     Furthermore, the version of Raspberry Pi that was tested was a <a href="https://www.digikey.ca/product-detail/en/raspberry-pi/RASPBERRY-PI-3/1690-1000-ND/6152799">Raspberry Pi 3 model B</a>.  During the initial setup process, a Raspberry Pi V2 camera was plugged into the Raspberry Pi.  After the install was completed, the camera was switched to a V1 camera which also worked without further steps, so the install steps here should cover bother camera types.  The V1 camera that was tested uses the OV5647 image sensor, and the V2 camera tested uses the IMX219 sensor.</p>



<p>     The instructions I provide below make reference to static forks of the relevant code so that the results described here are repeatable.  You should check out the original &#39;raspiraw&#39; and &#39;dcraw&#39; branches for updates by 6by9:</p>

<p>     <a href="https://github.com/6by9">https://github.com/6by9</a></p>

<p>     and Hermann-SW</p>

<p>     <a href="https://github.com/Hermann-SW">https://github.com/Hermann-SW</a></p>

<p>     These branches are likely to contain updates that you may need to support the Raspberry Pi 4, or more recent camera models.  Several people have reported seeing this error:</p>

<p><code><pre>Failed: don&#39;t know how to set GPIO for this board!
</pre></code></p><p>     and the solution can likely be found in newer updates from the branches listed above.</p>



<p>     The general process for creating high-speed videos consists of the following:</p>

<ul>
	<li>1)  Use <a href="https://github.com/Hermann-SW/fork-raspiraw">a fork</a> of <a href="https://github.com/6by9/raspiraw">&#39;raspiraw&#39;</a> to capture headerless RAW image frames and timestamp metadata at ~660FPS directly into RAM.</li>
	<li>2)  As a post-processing step, concatenate a RAW image header onto all captured RAW frames.</li>
	<li>3)  Use <a href="https://github.com/6by9/dcraw">a fork</a> of <a href="https://en.wikipedia.org/wiki/Dcraw">dcraw</a> to turn the RAW image frames into .tiff files.</li>
	<li>4)  Use ffmpeg along with the captured frame timestamp metadata to turn the image sequence into a video.</li>
</ul>

<p>     The major limitation throughout this process is the speed at which memory can be copied and transmitted.  Only 20-40 seconds of video can be recorded at a time due the memory exhaustion of the Raspberry Pi.  Also limited is the resolution of the recording:  On the $6 camera, a maximum of 640x64 resolution can be recorded due to limitations on memory bandwidth.</p>



<p>     First, make sure your camera is already installed and works correctly for recording normally at lower frame rates using raspivid and raspistill.  See the article <a href="http://blog.robertelder.org/commands-raspberry-pi-camera/">An Overview of How to Do Everything with Raspberry Pi Cameras</a> for details.</p>

<p>     Then, install the following packages that are required by dcraw:</p>

<p><code><pre>sudo apt-get install libjasper-dev libjpeg8-dev liblcms2-dev # required for dcraw.
sudo apt-get install ffmpeg
sudo apt-get install git
</pre></code></p><p>     Then, clone and build the required repositories for dcraw and raspiraw.  The github URLs below are convenient unmodified forks of the original repos which can be found in links elsewhere in this article.  The commit hashes specified below are the exact ones that this process was tested on:</p>

<p><code><pre>cd ~/
git clone https://github.com/RobertElderSoftware/fork-raspiraw &amp;&amp; cd fork-raspiraw &amp;&amp; git checkout 18fac55136f98960ccd4dcfff95112134e5e45db
./buildme
cd ~/
git clone https://github.com/RobertElderSoftware/dcraw &amp;&amp; cd dcraw &amp;&amp; git checkout 8d2bcbe8f9d280a5db8da30af9b6eb034f7f2859
./buildme
</pre></code></p><p>     During the building of dcraw, the following warning message was observed.  It was found that this message could be safely ignored:</p>

<p><code><pre>/usr/bin/ld: warning: libjpeg.so.62, needed by /usr/lib/gcc/arm-linux-gnueabihf/6/../../../arm-linux-gnueabihf/libjasper.so, may conflict with libjpeg.so.8
</pre></code></p><p>     Now, install these dependencies of &#39;raspiraw&#39;:</p>

<p><code><pre>sudo apt-get install wiringpi
sudo apt-get install i2c-tools
</pre></code></p><p>     Append the following inside the file &#39;/boot/config.txt&#39;:</p>

<p><code><pre>dtparam=i2c_vc=on
</pre></code></p><p>     Append the following inside the file &#39;/etc/modules-load.d/modules.conf&#39;:</p>

<p><code><pre>i2c-dev
</pre></code></p><p>     Now reboot in order for the changes to take effect:</p>

<p><code><pre>sudo reboot now
</pre></code></p>

<p>     The steps below will show the process for creating a simple 1 second slow-motion video with a 50x slowdown at a resolution of 640x64.  First, enable the I2C connection with the Camera:</p>

<p><code><pre><span>cd</span> ~/fork-raspiraw
./camera_i2c
</pre></code></p><p>     Now, run this command to capture 1 second worth of RAW images frames into RAM at 660 FPS:</p>

<p><code><pre>./raspiraw <span>-md</span> <span>7</span> <span>-t</span> <span>1000</span> <span>-ts</span> /dev/shm/tstamps.csv <span>-hd</span>0 /dev/shm/hd0.32k <span>-h</span> <span>64</span> <span>-w</span> <span>640</span> <span>--vinc</span> 1F <span>--fps</span> <span>660</span> <span>-sr</span> <span>1</span> <span>-o</span> /dev/shm/out.%06d.raw
</pre></code></p><p>     This command will concatenate the single image frame we saved onto all of the individual image frames:</p>

<p><code><pre><span>ls</span> /dev/shm/*.raw | <span>while </span><span>read</span><span> i</span><span>;</span><span> </span><span>do</span> <span>cat</span> /dev/shm/hd0.32k <span>&#34;</span><span>$i</span><span>&#34;</span> <span>&gt;</span> <span>&#34;</span><span>$i</span><span>&#34;</span>.all<span>;</span> <span>done</span>     
</pre></code></p><p>     Now, run this command to use dcraw to convert each RAW image frame into a .tiff file that ffmpeg can work with:</p>

<p><code><pre><span>ls</span> /dev/shm/*.all | <span>while </span><span>read</span><span> i</span><span>;</span><span> </span><span>do</span> ~/dcraw/dcraw <span>-f</span> <span>-o</span> <span>1</span> <span>-v</span>  <span>-6</span> <span>-T</span> <span>-q</span> <span>3</span> <span>-W</span> <span>&#34;</span><span>$i</span><span>&#34;</span><span>;</span> <span>done</span> 
</pre></code></p><p>     Run this command to output and create a python script that will parse the frame timestamp data into a file that will help ffmpeg display frames at the correct position.  Note that this is a multi-line shell command (you need to copy and paste the entire thing at once):</p>

<p><code><pre><span>cat</span> <span>&lt;&lt; EOF</span><span> &gt; /dev/shm/make_concat.py</span>
<span># Use TS information:</span>
<span>import csv</span>

<span>slowdownx = float(50)</span>
<span>last_microsecond = 0</span>
<span>with open(&#39;/dev/shm/tstamps.csv&#39;) as csv_file:</span>
<span>  csv_reader = csv.reader(csv_file, delimiter=&#39;,&#39;)</span>
<span>  line_count = 0</span>
<span>  for row in csv_reader:</span>
<span>    current_microsecond = int(row[2])</span>
<span>    if line_count &gt; 0:</span>
<span>      print(&#34;file &#39;/dev/shm/out.%06d.raw.tiff&#39;</span><span>\n</span><span>duration %08f&#34; % (int(row[1]), slowdownx * float(current_microsecond - last_microsecond) / float(1000000)))</span>
<span>    line_count += 1</span>
<span>    last_microsecond = current_microsecond</span>
<span>EOF</span>
</pre></code></p><p>     Run the timestamp processing script:</p>

<p><code><pre>python /dev/shm/make_concat.py <span>&gt;</span> /dev/shm/ffmpeg_concats.txt
</pre></code></p><p>     Now run ffmpeg to create the final output:</p>

<p><code><pre>ffmpeg <span>-f</span> concat <span>-safe</span> <span>0</span> <span>-i</span> /dev/shm/ffmpeg_concats.txt <span>-vcodec</span> libx265 <span>-x</span>265-params lossless <span>-crf</span> <span>0</span> <span>-b</span>:v 1M <span>-pix_fmt</span> yuv420p <span>-vf</span> <span>&#34;</span><span>pad=ceil(iw/2)*2:ceil(ih/2)*2</span><span>&#34;</span> /dev/shm/output.mp4
</pre></code></p><p>     The final output video is now located at &#39;/dev/shm/output.mp4&#39;.</p>



<iframe src="https://www.youtube.com/embed/-gMy8k4nHtw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>


<p>     The first video you film is most likely going to come out looking black.  This is because extremely high frame rate photography can only expose the sensor to light for a very short amount of time before the sensor needs to reset and record the next frame.  Thus, you should try pointing the sensor directly at a bright light source to get an idea of how bright your exposures need to be.  Filming at these high frame rates is not like regular point and shoot photography.  You&#39;ll need to be a lot more strategic in how you set up your scenes and record them.  Things like getting the exposure and lighting conditions right are critical.</p>

<p>     The commands above don&#39;t clear out the contents of &#39;/dev/shm&#39; after each recording, so you should take care to modify the steps above to prevent things like the &#39;ls *.all&#39; command from using frames from a previous recording when the recording times are different.  Also, note that &#39;/dev/shm&#39; is often used to store temporary files by other processes, so take care when deleting/overwriting things in this folder.</p>

<p>     As noted above, there are many limitations around memory when recording at these extremely high frame rates.  The default size of /dev/shm is only large enough to record 20-40 seconds of video (depending on the resolution and camera version).  The size of /dev/shm can be increased by a few hundred megabytes without issue, however this only gives on the order of a 25% increase in the max recording time.  Frame can be written to flash memory instead of RAM, however this will affect the frame rate.  You can always request whatever frame rate you want, upon inspecting the timestamps.csv file, you&#39;ll note that the actual timestamps of each frame won&#39;t be consistent with the frame rate you requested if the Raspberry Pi isn&#39;t able to keep up.</p>



<p>     In an effort to make the process of recording videos easier, I have done a bit of work on a <a href="https://github.com/RobertElderSoftware/PatientTurtle">small client/server app</a> that currently allows you to easily request a recording and download the results into a .tar file from the Pi, all in one command.  This is useful since one recording session will usually completely fill up the entire memory of the Pi and prevent you from doing another until you save the results out of memory to somewhere else.  The post-processing is also much faster on a desktop/laptop computer, so it&#39;s usually a good idea just to download the raw image data and save it so you can re-process it later.</p>

<p>     I&#39;ve decided to name the repository <a href="https://github.com/RobertElderSoftware/PatientTurtle">PatientTurtle</a> so that it&#39;s easy to Google for.  This app isn&#39;t very impressive at the moment, but if there is interest in it, perhaps I&#39;ll invest more time later.</p>



<ul>
	<li><a href="https://stamm-wilbrandt.de/en/Raspberry_camera.html">Hermann Stamm-Wilbrandt&#39;s Web Page</a></li>
	<li><a href="https://github.com/6by9/raspiraw">6by9&#39;s GitHub Page for &#39;raspiraw&#39;</a></li>
</ul>






<table>
	<tbody>
		<tr>
			<td>
				<span id="leads-signup-message">Join My Mailing List</span>
				
					
					
						
						
					
				
				<a href="https://www.robertelder.org/privacy-policy/">Privacy Policy</a>
			</td>
			<td>
				<span>Why Bother Subscribing?</span>
				<ul>
					<li><strong>Free Software/Engineering Content.</strong> I publish all of my educational content publicly for free so everybody can make use of it.  Why bother signing up for a paid &#39;course&#39;, when you can just sign up for this email list?</li>
					<li><strong>Read about cool new products that I&#39;m building.</strong> How do I make money? Glad you asked!  You&#39;ll get some emails with examples of things that I sell.  You might even get some business ideas of your own :)</li>
					<li><strong>People actually like this email list.</strong> I know that sounds crazy, because who <em>actually</em> subscribes to email lists these days, right?  Well, some do, and if you end up not liking it, I give you permission to unsubscribe and mark it as spam.</li>
				</ul>
			</td>
		</tr>
	</tbody>
</table>


				</div>
			</div></div>
  </body>
</html>
