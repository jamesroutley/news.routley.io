<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/908347/da67a5162d1bc4a3/">Original</a>
    <h1>Next steps for Rust in the kernel</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-none,v 1.2 2005-11-04 22:11:18 corbet Exp $ -->
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
The Rust for Linux project, which is working to make it possible to write
kernel code in the Rust
programming language, has been underway for a few years, and there is a
growing number of developers who feel that it is time to merge this work into
the mainline.  At the 2022 Linux Kernel Maintainers Summit, Miguel Ojeda
updated the group on the status of the project with the goal of reaching a
conclusion on when this merge might happen.  The answer that came back was
clear enough: Rust in the kernel will be happening soon indeed.
</p><p>
There was little suspense on that front; Linus Torvalds spoke up
at the beginning of the session to say that he plans to accept the Rust
patches for the 6.1 kernel (likely to be released in mid-December) unless
he hears strong objections.  Ojeda
indicated that he would like to see that happen and asked how the patches
should 
be routed into the mainline.  Torvalds said that he would rather not accept
them directly, so it seems likely that Kees Cook will be routing
this work upstream.
</p><p>
<a href="https://lwn.net/Articles/908359/"><img src="https://static.lwn.net/images/conf/2022/lpc/MiguelOjeda-sm.png" alt="[Miguel Ojeda]" title="Miguel Ojeda"/></a>

Dave Airlie said that there are MacBook driver developers who are intent on
doing their work in Rust, so there will likely be real Rust drivers heading
upstream before too long.  Initially, though, Torvalds said that he would
like to see a minimal merge just to get the infrastructure into the kernel
and allow developers to start playing with it.  It should build, but
shouldn&#39;t do much of anything beyond the &#34;hello, world&#34; stage.  That, he
said, will be a signal to the world that &#34;it&#39;s finally happening&#34;.
</p><p>
Greg Kroah-Hartman asked how subsystem-specific Rust bindings will go
upstream; will they go through the Rust tree or via the relevant subsystem
maintainers?  Ojeda answered that core Rust support will go through the
Rust tree, but the rest should go through maintainers.  Alexei Starovoitov
worried that subsystem maintainers would not be able to refuse Rust patches
even if they do not want to see Rust used in their subsystems; James
Bottomley added that Rust can be a hard language for longtime C developers
to understand, and that it would not be good to force it on maintainers.
Torvalds answered that it should be up to the maintainers; there is no need
for global rules at this point.
</p><p>
Paolo Bonzini said that the Rust code implementing abstractions for
subsystems is often the most unreadable for developers who are unfamiliar
with the language, &#34;but it&#39;s stupid code&#34; that is not doing anything
complex.  Driver-level Rust code is a lot more straightforward.  Torvalds
repeated that, for now, maintainers will be able to say that they don&#39;t
want to deal with Rust.  Starovoitov countered, though, that BPF will be
affected regardless of what he might decide; developers will need to be
able to trace Rust
code to debug problems.  Everybody will need to know Rust eventually, he
added.  Torvalds replied that he expects that process to take years.
</p><p>
Cook said that this change will be similar to many of the C language
changes that the kernel has gone through.  The switch away from
variable-length arrays was a similar process, and developers have gotten
used to it.  Torvalds said that it&#39;s closer to the introduction of BPF
instead; it&#39;s a new language that was initially targeted at specific use
cases, but which is now everywhere.
</p><p>
Ted Ts&#39;o noted that the kernel has to use unstable Rust features, and that
creates uncertainty about which version of the language should be used.
Perhaps the
developers should declare a specific version of the compiler as the one to
use for kernel development?  That would encourage distributors to package
that version, making it more widely available.  Thomas Gleixner said
that having
the blessed compiler available on kernel.org would be good enough, but
Torvalds answered that he would rather get compilers from his distributor
if possible.  Bottomley asked when Rust would become mandatory to build the
kernel; the answer was &#34;when the hardware he has requires it&#34;.  Torvalds
said that, if and when that point comes, it will be an indication that Rust
is a success for kernel development.
</p><p>
Gleixner asked about how well specified the Rust language is now; Ojeda
answered that it depends on what one is looking for.  Rust guarantees
backward compatibility for stable features, so those will not break in
surprising ways.  The kernel, though, is using a number of <i>unstable</i>
features; those features are, unsurprisingly, unstable.  Work is being done to
stabilize those features so that the kernel will be able to count on them
going forward.
</p><p>
There is currently an ongoing effort to write a
specification for Rust for safety-critical systems that will lead to a
standard-like document.
At the moment, though, Ojeda said, the developers of the GCC-based gccrs
Rust compiler are finding the current documentation to be vague at times.
Often, behavior is specified as &#34;whatever the rustc compiler does&#34;.  That
is &#34;not good&#34;, he said, but there is a path forward.
</p><p>
Gleixner also inquired into the tools that are generating the Rust bindings
and, specifically, whether there is automation to ensure that the Rust and
C versions of data structures match each other.  Those tools do exist,
Ojeda said, but they do not yet automatically convert all types
successfully.  That can be fixed.
</p><p>
Finally, Gleixner admonished the Rust developers to not change the
semantics of any C locking primitives; it&#39;s worth noting that they have
shown no 
inclination to do that so far.  Ts&#39;o added that Rust&#39;s locking abstractions
should be
made to work with the lockdep locking checker from the beginning.  Chris
Mason interjected that, if lockdep is needed for Rust code, that will be
another sign that the language has succeeded and it will be time to &#34;do a
victory dance&#34;.
</p><p>
It has often been said that the merging of Rust into the kernel tree will
be done on an experimental basis; if it doesn&#39;t work out, it can be removed
again.  Ojeda said that the developers working on Rust for Linux would like
to know how long the trial period is likely to be.  He did not really get
an answer from the group, though.
</p><p>
Instead, Bottomley suggested that, rather than bringing in Rust, it might
be better to just move more Rust-like features into C.  Ojeda said that he
has actually been working with the C language committee to push for that to
happen, but any such change will take a long time if it happens at all.
Christoph Hellwig said that this sort of change will have to happen anyway
unless the plan is to rewrite the whole kernel in Rust; he was not pleased
at the idea of rewriting working code in a new language.  Perhaps the
<a href="https://lwn.net/Articles/689907/">sparse</a> static analyzer could be enhanced to
do more Rust-like checking, he 
said.  Ojeda answered that the result of such efforts would be like having
Rust — but much later.
</p><p>
Hellwig continued that the adoption of Rust-like features could be done
incrementally over time.  It would be &#34;strictly worse than starting in
Rust&#34;, but the kernel community has a massive code base to manage.  There
needs to be a way to get the benefits of a Rust-like language into all of that
C code, he said.  Cook said he&#39;s been pushing compiler developers to create
safer C dialects as well.
</p><p>
Ts&#39;o brought the session to a conclusion by noting that language design is
a long-term research project; perhaps the group should focus on policy
issues for the next year instead.  Torvalds said that he would like to see
the groups running continuous-integration testing services to incorporate
Rust testing — something that is already happening.  Laurent Pinchart said
that the Rust developers need to be ready to provide support to the kernel
community in the early days; developers will pick things up quickly and be
able to help each other after a while.  Torvalds added that Rust isn&#39;t that
terrible in the end; &#34;it&#39;s not Perl&#34;.
</p><p>
When asked about documentation, Ojeda said that the Rust developers are
trying to improve on the documentation that has been done on the C side.
The Rust documentation mechanism makes it easy to ensure that examples are
actually tested, for example.  They are adhering to rules on how unsafe
blocks should be explained.
</p><p>
As time ran out, Matthew Wilcox asked whether kernel developers should be
writing idiomatic Rust code, or whether they will be writing &#34;C in Rust&#34;.
Ojeda answered that code might be more C-like toward the beginning;
adoption of more advanced features (such as async) might take longer.
Gleixner asked what could be done to prevent developers from using unstable
features (once the features used by the kernel are stabilized); the answer
was to specify the version of the compiler to be used with kernel
development.</p>
               </div></div>
  </body>
</html>
