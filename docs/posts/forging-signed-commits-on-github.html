<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://iter.ca/post/gh-sig-pwn/">Original</a>
    <h1>Forging signed commits on GitHub</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article itemprop="articleBody" id="content">
        
        
          <p>A half-year ago, I found a bug in an internal GitHub API that let me trick the internal API into signing commits as any user. So I could create a commit signed by a user I don’t control:</p>
<p><img src="https://iter.ca/post/gh-sig-pwn/forged-sig.png" alt="A signed commit authored by @octocat with message &amp;ldquo;signed from codespace&amp;rdquo; and date Dec 31 2029"/></p>
<p>Before I explain how I did that, first some context on how Git commit signing works:</p>
<h2 id="git-commit-internals">Git commit internals</h2>
<p>Git commits are stored in a custom text-based format that looks like:</p>
<pre tabindex="0"><code>tree 55ca6286e3e4f4fba5d0448333fa99fc5a404a73
parent 7676f1f3b526f05b530a3566211dab5a5225af9a
author loops &lt;me@iter.ca&gt; 1678388328 -0500
committer loops &lt;me@iter.ca&gt; 1678388328 -0500

Commit message
</code></pre><p>Signed commits have a extra <code>gpgsig</code> header that has a signature over every line in the commit except the <code>gpgsig</code> itself:</p>
<pre tabindex="0"><code>tree be0788944df13c5d170e050f2fe178360c3df5a5
author loops &lt;me@iter.ca&gt; 1678388328 -0500
committer loops &lt;me@iter.ca&gt; 1678388328 -0500
gpgsig -----BEGIN PGP SIGNATURE-----
 
 iQIzBAABCgAdFiEEK6cyil0jdmW2bZPmDXSPTJUzsugFAmQKLGgACgkQDXSPTJUz
 [...]
 =756m
 -----END PGP SIGNATURE-----

Legitimate signed commit
</code></pre><p>When you create a commit on GitHub.com, it is signed with GitHub’s <a href="https://github.com/web-flow.gpg">web flow GPG key</a> and has a <code>committer</code> of <code>GitHub &lt;noreply@github.com&gt;</code>. Web-flow signed commits are shown as signed in the GitHub UI:</p>
<p><img src="https://iter.ca/post/gh-sig-pwn/valid-sig.png" alt="This commit was created on GitHub.com and signed with GitHub’s verified signature"/></p>
<p>If we can trick GitHub into signing a commit with any <code>author</code>, we can create forged commits that GitHub shows as signed.</p>
<h2 id="tricking-an-internal-api-endpoint-into-signing-our-commits">Tricking an internal API endpoint into signing our commits</h2>
<p>For some context, I learned how some GitHub internals work by downloading a GitHub Enterprise Server trial VM and deobfuscating the Ruby source code on the VM.</p>
<p><a href="https://github.com/features/codespaces">GitHub Codespaces</a> is a GitHub service that provides you with a development environment in the cloud. One feature of Codespaces is that commits created in it are signed with the web flow GPG key (if enabled in <a href="https://github.com/settings/codespaces">settings</a>).</p>
<p>When a commit is created in a codespace with GPG signing enabled, this happens:</p>
<ol>
<li>git checks the <code>gpg.program</code> config option, which is set to <code>/.codespaces/bin/gh-gpgsign</code></li>
<li>git calls <code>/.codespaces/bin/gh-gpgsign</code> with the raw commit body</li>
<li>The <code>gh-gpgsign</code> binary (which is closed-source) makes an API request to <code>https://api.github.com/vscs_internal/commit/sign</code> with the commit body</li>
<li><code>gh-gpgsign</code> returns the signature returned from the API</li>
<li>git inserts the commit signature into the commit data</li>
</ol>
<p>The <code>/vscs_internal/commit/sign</code> endpoint is interesting because you can give it arbitrary raw commit data, and get a signature back.</p>
<p>That <code>/vscs_internal/commit/sign</code> endpoint checked that the author line in the provided commit data is valid by finding the first line that matches the regex <span><code>/\Aauthor (.+?) &lt;(.+)&gt;/</code></span>, and ensuring the name and email extracted from that regex corresponded to the logged-in user. But this regex doesn’t match author lines with 0-length names! So for this commit:</p>
<pre tabindex="0"><code>tree 251966888982546b81f8bfc8de1f25077f099a56
parent fb5ce469856769a17cca88ec4e2c6159d4669b21
author  &lt;583231+octocat@users.noreply.github.com&gt; 1682188800 +0000
committer GitHub &lt;noreply@github.com&gt; 1682188800 +0000
author username &lt;user@example.com&gt; 1682188800 +0000

commit message
</code></pre><p>Since the first <code>author</code> name is zero characters long, the regex skips that line, and the fake second author line is used instead. Git ignores extra <code>author</code> lines after the first, so Codespaces looks at the second author line but Git looks at the first. This means we can create GitHub-signed commits with any author name+email.</p>
<h2 id="the-fix">The fix</h2>
<p>GitHub fixed the issue by changing the problematic regex to <span><code>/\Aauthor ([^&lt;]*)[ ]{0,1}&lt;(.+)&gt;/</code></span>, which should all <code>author</code> header lines accepted by <code>git-fsck</code>.</p>
<h2 id="timeline">Timeline</h2>
<ul>
<li>April 22 2023: I report the issue to GitHub</li>
<li>April 24 2023: GitHub closes the issue, saying that being able to impersonate your own account is not an issue</li>
<li>April 24 2023: I respond saying that you can use this to attack impersonate other people</li>
<li>May 2 2023: I respond again, demonstrating that the issue still works</li>
<li>May 4 2023: GitHub reopens the issue</li>
<li>May 17 2023: GitHub validates the issue and begins work on a fix</li>
<li>June 2023: GitHub fixes the issue on GitHub.com</li>
<li>June 23 2023: GitHub closes the issue and rewards me with $10000</li>
</ul>

        
        <hr/>
      </article>
    </div></div>
  </body>
</html>
