<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ananthakumaran.in/2023/01/01/solving_n_plus_1_queries_on_rails.html">Original</a>
    <h1>Understanding the N &#43; 1 queries problem</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>In this post, I am going to talk about the N + 1 queries
problem. While trying to solve this problem myself recently, I noticed
most of the blog posts only talk about the very simple version of the
problem and the proposed solutions would break down when the use cases
get complex. I will try to get into more depth and hopefully, you will
leave with a better mental model of the problem.</p>

<h3 id="setup">Setup</h3>

<p><img src="https://ananthakumaran.in/public/images/n_plus_1/erd.png"/></p>

<p>Assume we need to create an endpoint that needs to return the last 3
blog posts, along with their comments and the comments vote count. We
will start with a straightforward approach. Let’s define a controller
action, which loads the last 3 posts.</p>

<div><div><pre><code><span>def</span> <span>latest</span>
  <span>@posts</span> <span>=</span> <span>Post</span><span>.</span><span>order</span><span>(</span><span>created_at: :desc</span><span>).</span><span>limit</span><span>(</span><span>3</span><span>)</span>
  <span>render</span> <span>json: </span><span>@posts</span>
<span>end</span>
</code></pre></div></div>

<p>I will use the <a href="https://github.com/rails-api/active_model_serializers">ActiveModelSerializer</a> gem in this example, but
anything similar should work. Let’s add the attributes and specify the
comments association in the PostSerializer.</p>

<div><div><pre><code><span>class</span> <span>PostSerializer</span> <span>&lt;</span> <span>ActiveModel</span><span>::</span><span>Serializer</span>
  <span>attributes</span> <span>:id</span><span>,</span> <span>:title</span><span>,</span> <span>:content</span>

  <span>has_many</span> <span>:comments</span>
<span>end</span>
</code></pre></div></div>

<p>In the CommentSerializer, let’s include the votes count and other
fields. The votes count is calculated using the ActiveRecord
collection count method.</p>

<div><div><pre><code><span>class</span> <span>CommentSerializer</span> <span>&lt;</span> <span>ActiveModel</span><span>::</span><span>Serializer</span>
  <span>attributes</span> <span>:id</span><span>,</span> <span>:content</span><span>,</span> <span>:votes_count</span>

  <span>def</span> <span>votes_count</span>
    <span>object</span><span>.</span><span>votes</span><span>.</span><span>count</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>Let’s hit the endpoint to see how the data is fetched from the database.</p>

<pre>Started GET &#34;/posts/latest&#34; for 127.0.0.1 at 2023-01-01 13:05:42 +0530
Processing by PostsController#latest as */*
  <span>Post Load (0.1ms)</span>  <span>SELECT &#34;posts&#34;.* FROM &#34;posts&#34; ORDER BY &#34;posts&#34;.&#34;created_at&#34; DESC LIMIT ?</span>  [[&#34;LIMIT&#34;, 3]]
  ↳ app/controllers/posts_controller.rb:11:in `latest&#39;
[active_model_serializers]   <span>Comment Load (0.0ms)</span>  <span>SELECT &#34;comments&#34;.* FROM &#34;comments&#34; WHERE &#34;comments&#34;.&#34;post_id&#34; = ?</span>  [[&#34;post_id&#34;, 3]]
<span>[active_model_serializers]   ↳ app/controllers/posts_controller.rb</span><span>:</span><span>11</span><span>:i</span>n `latest&#39;
[active_model_serializers]   <span>Comment Load (0.0ms)</span>  <span>SELECT &#34;comments&#34;.* FROM &#34;comments&#34; WHERE &#34;comments&#34;.&#34;post_id&#34; = ?</span>  [[&#34;post_id&#34;, 2]]
<span>[active_model_serializers]   ↳ app/controllers/posts_controller.rb</span><span>:</span><span>11</span><span>:i</span>n `latest&#39;
[active_model_serializers]   <span>Comment Load (0.0ms)</span>  <span>SELECT &#34;comments&#34;.* FROM &#34;comments&#34; WHERE &#34;comments&#34;.&#34;post_id&#34; = ?</span>  [[&#34;post_id&#34;, 1]]
<span>[active_model_serializers]   ↳ app/controllers/posts_controller.rb</span><span>:</span><span>11</span><span>:i</span>n `latest&#39;
[active_model_serializers]   <span>Vote Count (0.1ms)</span>  <span>SELECT COUNT(*) FROM &#34;votes&#34; WHERE &#34;votes&#34;.&#34;comment_id&#34; = ?</span>  [[&#34;comment_id&#34;, 3]]
<span>[active_model_serializers]   ↳ app/serializers/comment_serializer.rb</span><span>:</span><span>5</span><span>:i</span>n `votes_count&#39;
[active_model_serializers]   <span>Vote Count (0.0ms)</span>  <span>SELECT COUNT(*) FROM &#34;votes&#34; WHERE &#34;votes&#34;.&#34;comment_id&#34; = ?</span>  [[&#34;comment_id&#34;, 1]]
<span>[active_model_serializers]   ↳ app/serializers/comment_serializer.rb</span><span>:</span><span>5</span><span>:i</span>n `votes_count&#39;
[active_model_serializers]   <span>Vote Count (0.0ms)</span>  <span>SELECT COUNT(*) FROM &#34;votes&#34; WHERE &#34;votes&#34;.&#34;comment_id&#34; = ?</span>  [[&#34;comment_id&#34;, 2]]
<span>[active_model_serializers]   ↳ app/serializers/comment_serializer.rb</span><span>:</span><span>5</span><span>:i</span>n `votes_count&#39;
[active_model_serializers] Rendered ActiveModel::Serializer::CollectionSerializer with ActiveModelSerializers::Adapter::Attributes (9.2ms)
Completed 200 OK in 13ms (Views: 10.5ms | ActiveRecord: 1.1ms | Allocations: 19123)


</pre>

<h3 id="problem">Problem</h3>

<p>We can immediately notice the N + 1 queries. We are making 7 queries
in total, but ideally, it should be done in 3 queries. Before we jump
into solutions, let’s spend more time trying to get a better mental
model of the problem.</p>

<p><img width="250" src="https://ananthakumaran.in/public/images/n_plus_1/depth-first.png"/></p>

<p>The above diagram captures the sequence of queries run by the
system. If you notice the sequence, it kind of mirrors the way we have
written the code. We have written two serializers, each knows how to
serialize an individual model. The post serializer knows how to
serialize a <strong>single</strong> post, the comment serializer knows how to
serialize a single comment and calculate the votes count for a single
comment.</p>

<p>In other words, we have written the code in a depth-first approach,
where a node knows how to serialize itself and immediate children, but
does not know much about the parent and grandchildren. This is the
natural and simple way that composes well and keeps the dependencies
of a serializer to a minimum.</p>

<p><img height="300" src="https://ananthakumaran.in/public/images/n_plus_1/breadth-first.png"/></p>

<p>If we do the queries optimally, we could do it in 3 queries, the above
diagram captures the sequence of the queries. I am hoping the diagram
also hints at the obvious solution: <strong>breadth-first</strong> loading. The
ideal solution requires us to load the data in a breadth-first
approach, but unfortunately, this is harder to write because it does
not compose well. I will talk more about this in the next section, you
will notice the code becomes more complicated as we optimize the
queries.</p>

<h3 id="band-aid-solution">Band-Aid Solution</h3>

<p>I am going to call this a band-aid solution because it’s ugly. But a
band-aid solution is better than nothing, and I will share some
thoughts about what the ideal solution might look like later.</p>

<p>Let’s try to fix the comment queries first, you might already know the
solution. The problem is so common, ActiveRecord has a way to preload
association. <code>includes(:comments)</code> will preload all the comments
associated with all the posts.</p>

<div><div><pre><code><span>def</span> <span>latest</span>
  <span>@posts</span> <span>=</span> <span>Post</span><span>.</span><span>includes</span><span>(</span><span>:comments</span><span>).</span><span>order</span><span>(</span><span>created_at: :desc</span><span>).</span><span>limit</span><span>(</span><span>3</span><span>)</span>
  <span>render</span> <span>json: </span><span>@posts</span>
<span>end</span>
</code></pre></div></div>

<p>This solves the comments loading problem.</p>

<pre>Started GET &#34;/posts/latest&#34; for 127.0.0.1 at 2023-01-01 13:07:34 +0530
Processing by PostsController#latest as */*
  <span>Post Load (0.1ms)</span>  <span>SELECT &#34;posts&#34;.* FROM &#34;posts&#34; ORDER BY &#34;posts&#34;.&#34;created_at&#34; DESC LIMIT ?</span>  [[&#34;LIMIT&#34;, 3]]
  ↳ app/controllers/posts_controller.rb:11:in `latest&#39;
  <span>Comment Load (0.1ms)</span>  <span>SELECT &#34;comments&#34;.* FROM &#34;comments&#34; WHERE &#34;comments&#34;.&#34;post_id&#34; IN (?, ?, ?)</span>  [[&#34;post_id&#34;, 3], [&#34;post_id&#34;, 2], [&#34;post_id&#34;, 1]]
  ↳ app/controllers/posts_controller.rb:11:in `latest&#39;
[active_model_serializers]   <span>Vote Count (0.0ms)</span>  <span>SELECT COUNT(*) FROM &#34;votes&#34; WHERE &#34;votes&#34;.&#34;comment_id&#34; = ?</span>  [[&#34;comment_id&#34;, 3]]
<span>[active_model_serializers]   ↳ app/serializers/comment_serializer.rb</span><span>:</span><span>5</span><span>:i</span>n `votes_count&#39;
[active_model_serializers]   <span>Vote Count (0.0ms)</span>  <span>SELECT COUNT(*) FROM &#34;votes&#34; WHERE &#34;votes&#34;.&#34;comment_id&#34; = ?</span>  [[&#34;comment_id&#34;, 1]]
<span>[active_model_serializers]   ↳ app/serializers/comment_serializer.rb</span><span>:</span><span>5</span><span>:i</span>n `votes_count&#39;
[active_model_serializers]   <span>Vote Count (0.0ms)</span>  <span>SELECT COUNT(*) FROM &#34;votes&#34; WHERE &#34;votes&#34;.&#34;comment_id&#34; = ?</span>  [[&#34;comment_id&#34;, 2]]
<span>[active_model_serializers]   ↳ app/serializers/comment_serializer.rb</span><span>:</span><span>5</span><span>:i</span>n `votes_count&#39;
[active_model_serializers] Rendered ActiveModel::Serializer::CollectionSerializer with ActiveModelSerializers::Adapter::Attributes (4.42ms)
Completed 200 OK in 11ms (Views: 8.7ms | ActiveRecord: 1.0ms | Allocations: 16355)
</pre>

<p>But the votes count problem remains. I can’t find any straightforward
way to solve this problem via ActiveRecord, in fact, I selected this
because I want to show how to solve this issue in a general way.</p>

<h4 id="attempt-1">Attempt 1</h4>

<div><div><pre><code><span>def</span> <span>latest</span>
  <span>@posts</span> <span>=</span> <span>Post</span><span>.</span><span>includes</span><span>(</span><span>:comments</span><span>).</span><span>order</span><span>(</span><span>created_at: :desc</span><span>).</span><span>limit</span><span>(</span><span>3</span><span>)</span>
  <span>@comment_votes_count</span> <span>=</span> <span>Vote</span>
                           <span>.</span><span>where</span><span>(</span><span>comment_id: </span><span>@posts</span><span>.</span><span>flat_map</span><span>(</span><span>&amp;</span><span>:comment_ids</span><span>))</span>
                           <span>.</span><span>group</span><span>(</span><span>:comment_id</span><span>)</span>
                           <span>.</span><span>pluck</span><span>(</span><span>&#39;comment_id&#39;</span><span>,</span> <span>Arel</span><span>.</span><span>sql</span><span>(</span><span>&#39;count(id)&#39;</span><span>))</span>
                           <span>.</span><span>to_h</span>
  <span>render</span> <span>json: </span><span>@posts</span><span>,</span> <span>comment_votes_count: </span><span>@comment_votes_count</span>
<span>end</span>
</code></pre></div></div>

<div><div><pre><code><span>class</span> <span>CommentSerializer</span> <span>&lt;</span> <span>ActiveModel</span><span>::</span><span>Serializer</span>
  <span>attributes</span> <span>:id</span><span>,</span> <span>:content</span><span>,</span> <span>:votes_count</span>

  <span>def</span> <span>votes_count</span>
    <span>instance_options</span><span>[</span><span>:comment_votes_count</span><span>][</span><span>object</span><span>.</span><span>id</span><span>]</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<pre>Started GET &#34;/posts/latest&#34; for 127.0.0.1 at 2023-01-01 13:09:59 +0530
Processing by PostsController#latest as */*
  <span>Post Load (0.1ms)</span>  <span>SELECT &#34;posts&#34;.* FROM &#34;posts&#34; ORDER BY &#34;posts&#34;.&#34;created_at&#34; DESC LIMIT ?</span>  [[&#34;LIMIT&#34;, 3]]
  ↳ app/controllers/posts_controller.rb:12:in `flat_map&#39;
  <span>Comment Load (0.1ms)</span>  <span>SELECT &#34;comments&#34;.* FROM &#34;comments&#34; WHERE &#34;comments&#34;.&#34;post_id&#34; IN (?, ?, ?)</span>  [[&#34;post_id&#34;, 3], [&#34;post_id&#34;, 2], [&#34;post_id&#34;, 1]]
  ↳ app/controllers/posts_controller.rb:12:in `flat_map&#39;
  <span>Vote Pluck (0.1ms)</span>  <span>SELECT &#34;votes&#34;.&#34;comment_id&#34;, count(id) FROM &#34;votes&#34; WHERE &#34;votes&#34;.&#34;comment_id&#34; IN (?, ?, ?) GROUP BY &#34;votes&#34;.&#34;comment_id&#34;</span>  [[&#34;comment_id&#34;, 3], [&#34;comment_id&#34;, 1], [&#34;comment_id&#34;, 2]]
  ↳ app/controllers/posts_controller.rb:14:in `latest&#39;
[active_model_serializers] Rendered ActiveModel::Serializer::CollectionSerializer with ActiveModelSerializers::Adapter::Attributes (1.42ms)
Completed 200 OK in 10ms (Views: 2.0ms | ActiveRecord: 0.9ms | Allocations: 12825)
</pre>

<p>This solution works, but it’s very ugly. The CommentSerializer is not
self-contained anymore, and it expects the caller to pass in the vote
count. So we have essentially spread the logic across many places and
made the code hard to understand.</p>

<h4 id="attempt-2">Attempt 2</h4>



<p>Let’s add a new gem called <a href="https://github.com/exAspArk/batch-loader">batch-loader</a> and update the comment
model.</p>

<div><div><pre><code><span>class</span> <span>Comment</span> <span>&lt;</span> <span>ApplicationRecord</span>
  <span>belongs_to</span> <span>:post</span>
  <span>has_many</span> <span>:votes</span>

  <span>def</span> <span>lazy_votes_count</span>
    <span>BatchLoader</span><span>.</span><span>for</span><span>(</span><span>id</span><span>)</span>
      <span>.</span><span>batch</span><span>(</span><span>key: </span><span>&#39;comment_votes_count&#39;</span><span>)</span> <span>do</span> <span>|</span><span>comment_ids</span><span>,</span> <span>loader</span><span>|</span>
      <span>Vote</span>
        <span>.</span><span>where</span><span>(</span><span>comment_id: </span><span>comment_ids</span><span>)</span>
        <span>.</span><span>group</span><span>(</span><span>:comment_id</span><span>)</span>
        <span>.</span><span>pluck</span><span>(</span><span>&#39;comment_id&#39;</span><span>,</span> <span>Arel</span><span>.</span><span>sql</span><span>(</span><span>&#39;count(id)&#39;</span><span>))</span>
        <span>.</span><span>each</span> <span>{</span> <span>|</span><span>comment_id</span><span>,</span> <span>count</span><span>|</span> <span>loader</span><span>.</span><span>call</span><span>(</span><span>comment_id</span><span>,</span> <span>count</span><span>)</span> <span>}</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>Let’s go step by step. We added a new method called
<code>lazy_votes_count</code>. Instead of specifying how to calculate the
votes_count for a single comment, we are specifying how to do it for
a list of comments. This is essential complexity, there is no way
around it. It’s not possible to magically derive a query to load
multiple objects except for a few simple cases that are currently
supported by ActiveRecord <code>includes</code>.</p>

<p>There is one big difference compared to the previous approach, we are
not specifying how to collect the comment ids. Let’s update the
CommentSerializer to use the new method and revert the changes made to
the controller</p>

<div><div><pre><code><span>class</span> <span>CommentSerializer</span> <span>&lt;</span> <span>ActiveModel</span><span>::</span><span>Serializer</span>
  <span>attributes</span> <span>:id</span><span>,</span> <span>:content</span><span>,</span> <span>:votes_count</span>

  <span>def</span> <span>votes_count</span>
    <span>object</span><span>.</span><span>lazy_votes_count</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<div><div><pre><code><span>def</span> <span>latest</span>
  <span>@posts</span> <span>=</span> <span>Post</span><span>.</span><span>order</span><span>(</span><span>created_at: :desc</span><span>).</span><span>limit</span><span>(</span><span>3</span><span>)</span>
  <span>render</span> <span>json: </span><span>@posts</span>
<span>end</span>
</code></pre></div></div>

<pre>Started GET &#34;/posts/latest&#34; for 127.0.0.1 at 2023-01-01 13:28:49 +0530
Processing by PostsController#latest as */*
  <span>Post Load (0.1ms)</span>  <span>SELECT &#34;posts&#34;.* FROM &#34;posts&#34; ORDER BY &#34;posts&#34;.&#34;created_at&#34; DESC LIMIT ?</span>  [[&#34;LIMIT&#34;, 3]]
  ↳ app/controllers/posts_controller.rb:11:in `latest&#39;
  <span>Comment Load (0.1ms)</span>  <span>SELECT &#34;comments&#34;.* FROM &#34;comments&#34; WHERE &#34;comments&#34;.&#34;post_id&#34; IN (?, ?, ?)</span>  [[&#34;post_id&#34;, 3], [&#34;post_id&#34;, 2], [&#34;post_id&#34;, 1]]
  ↳ app/controllers/posts_controller.rb:11:in `latest&#39;
[active_model_serializers]   <span>Vote Pluck (0.1ms)</span>  <span>SELECT &#34;votes&#34;.&#34;comment_id&#34;, count(id) FROM &#34;votes&#34; WHERE &#34;votes&#34;.&#34;comment_id&#34; IN (?, ?, ?) GROUP BY &#34;votes&#34;.&#34;comment_id&#34;</span>  [[&#34;comment_id&#34;, 3], [&#34;comment_id&#34;, 1], [&#34;comment_id&#34;, 2]]
<span>[active_model_serializers]   ↳ app/models/comment.rb</span><span>:</span><span>11</span><span>:i</span>n `block in lazy_votes_count&#39;
[active_model_serializers] Rendered ActiveModel::Serializer::CollectionSerializer with ActiveModelSerializers::Adapter::Attributes (1.87ms)
Completed 200 OK in 4ms (Views: 3.2ms | ActiveRecord: 0.3ms | Allocations: 7451)
</pre>

<p>Before we have time to understand how the batch-loader works under the
hood, we get a new requirement. Instead of returning the votes count
as an integer, the frontend folks want a string like <code>${i} vote(s)</code></p>

<div><div><pre><code><span>class</span> <span>CommentSerializer</span> <span>&lt;</span> <span>ActiveModel</span><span>::</span><span>Serializer</span>
  <span>attributes</span> <span>:id</span><span>,</span> <span>:content</span><span>,</span> <span>:votes_count</span>

  <span>def</span> <span>votes_count</span>
    <span>count</span> <span>=</span> <span>object</span><span>.</span><span>lazy_votes_count</span>
    <span>count</span> <span>==</span> <span>1</span> <span>?</span> <span>&#39;1 vote&#39;</span> <span>:</span> <span>&#34;</span><span>#{</span><span>count</span><span>}</span><span> votes&#34;</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>Let’s make the update and see what happens. To our surprise, the votes
count reverts back to N + 1 queries.</p>

<pre>Started GET &#34;/posts/latest&#34; for 127.0.0.1 at 2023-01-01 14:17:55 +0530
Processing by PostsController#latest as */*
  <span>Post Load (0.1ms)</span>  <span>SELECT &#34;posts&#34;.* FROM &#34;posts&#34; ORDER BY &#34;posts&#34;.&#34;created_at&#34; DESC LIMIT ?</span>  [[&#34;LIMIT&#34;, 3]]
  ↳ app/controllers/posts_controller.rb:11:in `latest&#39;
  <span>Comment Load (0.1ms)</span>  <span>SELECT &#34;comments&#34;.* FROM &#34;comments&#34; WHERE &#34;comments&#34;.&#34;post_id&#34; IN (?, ?, ?)</span>  [[&#34;post_id&#34;, 3], [&#34;post_id&#34;, 2], [&#34;post_id&#34;, 1]]
  ↳ app/controllers/posts_controller.rb:11:in `latest&#39;
[active_model_serializers]   <span>Vote Pluck (0.1ms)</span>  <span>SELECT &#34;votes&#34;.&#34;comment_id&#34;, count(id) FROM &#34;votes&#34; WHERE &#34;votes&#34;.&#34;comment_id&#34; = ? GROUP BY &#34;votes&#34;.&#34;comment_id&#34;</span>  [[&#34;comment_id&#34;, 3]]
<span>[active_model_serializers]   ↳ app/models/comment.rb</span><span>:</span><span>11</span><span>:i</span>n `block in lazy_votes_count&#39;
[active_model_serializers]   <span>Vote Pluck (0.1ms)</span>  <span>SELECT &#34;votes&#34;.&#34;comment_id&#34;, count(id) FROM &#34;votes&#34; WHERE &#34;votes&#34;.&#34;comment_id&#34; = ? GROUP BY &#34;votes&#34;.&#34;comment_id&#34;</span>  [[&#34;comment_id&#34;, 1]]
<span>[active_model_serializers]   ↳ app/models/comment.rb</span><span>:</span><span>11</span><span>:i</span>n `block in lazy_votes_count&#39;
[active_model_serializers]   <span>Vote Pluck (0.0ms)</span>  <span>SELECT &#34;votes&#34;.&#34;comment_id&#34;, count(id) FROM &#34;votes&#34; WHERE &#34;votes&#34;.&#34;comment_id&#34; = ? GROUP BY &#34;votes&#34;.&#34;comment_id&#34;</span>  [[&#34;comment_id&#34;, 2]]
<span>[active_model_serializers]   ↳ app/models/comment.rb</span><span>:</span><span>11</span><span>:i</span>n `block in lazy_votes_count&#39;
[active_model_serializers] Rendered ActiveModel::Serializer::CollectionSerializer with ActiveModelSerializers::Adapter::Attributes (4.84ms)
Completed 200 OK in 12ms (Views: 9.5ms | ActiveRecord: 0.6ms | Allocations: 18820)
</pre>

<p>Let’s take some time and understand how batch-loader works. When the
lazy_votes_count method is called, what you get back is a lazy
object, not the real integer. This can be easily verified by placing a
breakpoint and inspecting the votes count value.</p>

<pre><span>Frame number:</span> 0/130

<span>From:</span> [redacted]/blog/app/serializers/comment_serializer.rb:5 CommentSerializer#votes_count:

    <span>4</span>: <span>def</span> <span>votes_count</span>
 =&gt; <span>5</span>:   binding.pry
    <span>6</span>:   object.lazy_votes_count
    <span>7</span>: <span>end</span>

[1] pry(#&lt;CommentSerializer&gt;)&gt; object.lazy_votes_count.inspect
=&gt; <span>&#34;</span><span>#&lt;BatchLoader:0x49960&gt;</span><span>&#34;</span>
[2] pry(#&lt;CommentSerializer&gt;)&gt; object.lazy_votes_count
[active_model_serializers]   <span>Vote Pluck (0.7ms)</span>  <span>SELECT &#34;votes&#34;.&#34;comment_id&#34;, count(id) FROM &#34;votes&#34; WHERE &#34;votes&#34;.&#34;co</span>
<span>mment_id&#34; IN (?, ?) GROUP BY &#34;votes&#34;.&#34;comment_id&#34;</span>  [[&#34;comment_id&#34;, 3]]
[active_model_serializers]   ↳ app/models/comment.rb:11:in `block in lazy_votes_count&#39;
=&gt; <span>4</span>
</pre>

<p>The inspect method shows the BatchLoader class instead of an
Integer. When we serialize the posts, a plain JSON hash will be
constructed first, typically what is returned when <code>as_json</code> is
called. During this phase, <code>lazy_votes_count</code> will get called three
times. The batch-loader does not go ahead and fetch the data, instead,
it just keeps track of the value passed to the <code>for</code> method and
returns a lazy object. In the second phase, the plain JSON hash will
be converted to string. During this phase, some methods will be get
called on the lazy object, which will trigger the batch load. Since
the batch loader has collected three ids so far, it will call the
callback once with three ids.</p>

<p>Unfortunately, the changes we made has forced the lazy value, and the
batch loader has to load the data right away after having collected a
single id. One way to solve this problem is by using <a href="https://github.com/HornsAndHooves/lazy_object">LazyObject</a>
directly. LazyObject is implemented by overriding <a href="https://ananthakumaran.in/2023/01/01/metthod">method_missing</a>
callback.</p>

<div><div><pre><code><span>class</span> <span>CommentSerializer</span> <span>&lt;</span> <span>ActiveModel</span><span>::</span><span>Serializer</span>
  <span>attributes</span> <span>:id</span><span>,</span> <span>:content</span><span>,</span> <span>:votes_count</span>

  <span>def</span> <span>votes_count</span>
    <span>count</span> <span>=</span> <span>object</span><span>.</span><span>lazy_votes_count</span>
    <span>LazyObject</span><span>.</span><span>new</span> <span>{</span> <span>count</span> <span>==</span> <span>1</span> <span>?</span> <span>&#39;1 vote&#39;</span> <span>:</span> <span>&#34;</span><span>#{</span><span>count</span><span>}</span><span> votes&#34;</span> <span>}</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>In my opinion, this solution is better than the first version. It
composes better than the previous solution, as all the changes are
contained in the comment serializer and model. Though, everyone on the
team has to understand how the magic works.</p>

<h3 id="ideal-solution">Ideal Solution</h3>

<p>Luckily, this problem is common enough, there is a paper available on
the subject<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>. In fact, the batch-loader is inspired by the
<a href="https://github.com/facebook/Haxl">Haxl</a> implementation. batch-loader provides a good abstraction,
but it is still awkward to integrate it with ActiveModelSerializer. I
initially tried to use it with <a href="https://github.com/procore/blueprinter">Blueprinter</a>, but it didn’t work
because Blueprinter forces the value <a href="https://github.com/procore/blueprinter/blob/60b8f94616e18aa0346fa3c697b9e30c66c4ec8c/lib/blueprinter/extractors/auto_extractor.rb#L15">right away</a>. The way the
second attempt works might be entirely accidental, it is quite
possible some future changes on ActiveModelSerializer might break it.</p>

<p>I kept remembering <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">what color is your function</a> when thinking of a
solution. The ideal solution would be something that clearly separates
the two parts of the problem. One set of methods that defines the data
load part and another set of methods that handles the serialization
part. Since both share the same structure, they could live under same
class.  The serializer could then do two phases. Phase 1: data would
be loaded. Phase 2: models would get serialized. This split would also
make it easy to catch any unexpected network calls in the second
phase.</p>





    </div></div>
  </body>
</html>
