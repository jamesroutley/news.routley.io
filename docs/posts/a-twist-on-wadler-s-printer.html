<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justinpombrio.net/2024/02/23/a-twist-on-Wadlers-printer.html">Original</a>
    <h1>A Twist on Wadler&#39;s Printer</h1>
    
    <div id="readability-page-1" class="page"><div>

<blockquote>
  <p>I present a more expressive variant of Wadler’s “Prettier Printer”.</p>
</blockquote>

<hr/>

<h2 id="whats-a-pretty-printer">What’s a pretty printer?</h2>

<p>You’ve probably used a code formatter like <code>gofmt</code> or <code>rustfmt</code> or JS
<code>prettier</code>. These tools work in two steps: (i) parse the source code in a file,
and (ii) print it out nicely. Step (ii) is pretty printing.</p>

<p>Pretty printing is the reverse of parsing. Parsing turns linear text into a tree
(a <em>parse tree</em>, which after a bit of post-processing becomes an abstract syntax
tree (AST)). Pretty printing is the reverse: it turns the tree-shaped AST into
linear text.</p>

<p>One of the most commonly used pretty printing algorithms is Philip Wadler’s
<a href="https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf">“A Prettier Printer”</a>
[1]. Hereafter I’ll call it <em>Prettier</em>. Prettier is reasonably expressive while
being extremely fast (linear time) and simple (50 lines of code), which probably
accounts for its popularity.</p>
<details>
  <summary>Implementing Prettier in a strict language. (Click to expand.)</summary>
  Prettier is written in Haskell and relies on the language being lazily
  evaluated. If you code it directly in another language, you&#39;ll get something
  that runs in exponential time! But there&#39;s an easy modification to the
  algorithm for strict languages described in
  <a href="https://lindig.github.io/papers/strictly-pretty-2000.pdf">
  &#34;Strictly Pretty&#34;</a>
  [2]. The code in this post will do essentially the same thing.
</details>

<p>In this post, I’ll:</p>

<ul>
  <li>describe how Prettier behaves</li>
  <li>describe a variation of it I came up with that’s just as fast while being more
expressive</li>
  <li>walk through implementing it in Rust, and writing a Json printer using it</li>
</ul>

<h2 id="wadlers-prettier-printer">Wadler’s Prettier Printer</h2>

<p>Say we have a program we want to print. For simplicity of exposition, just a
short list: <code>[hello, world]</code> (imagine that “hello” and “world” are variables).
There are a couple ways you might want to print this. Either all on one line:</p>

<pre><code>[ hello, world ]
</code></pre>

<p>or on separate lines:</p>

<pre><code>[
    hello,
    world
]
</code></pre>

<p>Each of these possibilities is called a <em>layout</em>. A pretty printer will have (i)
a language in which you can express a variety of possible layouts, and (ii) an
algorithm for picking the “best” possible layout from that set. What “best”
means depends on the printer, but for Prettier it’s simply “try not to make
lines too long” (canonically 80 characters, but you can set that to whatever
width you want).</p>

<p>In our tiny example, there are only two possible layouts, but in general there
can be many more. <em>Exponentially</em> more, in fact, since alternatives can be
nested inside each other. This gives a very large space of possibilities to
explore. Prettier’s algorithm explores it in linear time by greedily resolving
alternatives one line at a time. We’ll see that in detail later, but for
now let’s return to the easier problem of how to express the two layouts above.</p>

<p>Those two layouts can be expressed in Prettier using a combination of:</p>

<ul>
  <li><code>txt</code> for the text of each token like “[” and “hello”. I’ll typically omit
the <code>txt</code> and just write the text directly in quotes, so the examples don’t
get too noisy.</li>
  <li><code>nl</code> for newlines.</li>
  <li><code>indent(i, x)</code> to indent every newline in <code>x</code> by <code>i</code> spaces.</li>
  <li><code>x &amp; y</code> to concatenate things together.</li>
</ul>

<p>I’ll call a mix of these operations a <em>notation</em>.</p>

<details>
  <summary>I&#39;m using different words than Wadler does in his paper.</summary>
  If you&#39;re referencing his paper, he calls the above `text`, `line`, `nest`, and `&lt;&gt;`.
  I say &#34;indent&#34; instead of &#34;nest&#34; because that&#39;s a better word for what it does;
  &#34;nl&#34; (newline) instead of &#34;line&#34; because &#34;line&#34; could mean a lot of other
  things; and &#34;&amp;&#34; because you can use that as an operator in Rust.

  Additionally, what I call a &#34;notation&#34; Wadler calls a &#34;document&#34;. I find that
  a particularly unpleasant word choice because &#34;document&#34; sounds like the thing
  you wanted to print in the first place, not the pretty printing expression
  you&#39;ve converted it to to display it. Unfortunately, &#34;document&#34; is pretty well
  embedded as a term in the literature now. Fortunately I&#39;m writing a blog post
  and can call it whatever I please.
</details>

<p>We can write a notation that prints as the first layout like so:</p>

<figure><pre><code data-lang="bash"><span></span><span>&#34;[&#34;</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;hello&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;world&#34;</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;]&#34;</span></code></pre></figure>

<p>⇨</p>
<pre><code>[ hello, world ]
</code></pre>

<p>And a notation that prints as the second layout:</p>

<figure><pre><code data-lang="bash"><span></span><span>&#34;[&#34;</span> <span>&amp;</span> indent<span>(</span><span>4</span>, nl <span>&amp;</span> <span>&#34;hello&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;world&#34;</span><span>)</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;]&#34;</span></code></pre></figure>

<p>⇨</p>
<pre><code>[
    hello,
    world
]
</code></pre>

<p>Notice how much these two notations have in common! If you replace every <code>nl</code>
with a space <code>&#34; &#34;</code>, the second notation becomes almost identical to the first:</p>

<figure><pre><code data-lang="bash"><span></span><span>&#34;[&#34;</span> <span>&amp;</span> indent<span>(</span><span>4</span>, <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;hello&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;world&#34;</span><span>)</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;]&#34;</span></code></pre></figure>

<p>The only difference is the <code>indent</code>, which no longer matters because there are
no newlines to indent.</p>

<p>This is the key to how Prettier represents choices. There’s just one additional
notation operator:</p>

<ul>
  <li><code>group(x)</code> means “Display <code>x</code> with every <code>nl</code> in it replaced by a space,
if that would fit on the current line. Otherwise, display <code>x</code> as-is.”</li>
</ul>

<p>Using <code>group</code>, we can express a choice between the two above layouts with a
single notation:</p>

<figure><pre><code data-lang="bash"><span></span>group<span>(</span><span>&#34;[&#34;</span> <span>&amp;</span> indent<span>(</span><span>4</span>, nl <span>&amp;</span> <span>&#34;hello&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;world&#34;</span><span>)</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;]&#34;</span><span>)</span></code></pre></figure>

<p>Then you can print this notation with various max line widths. If the max width
is 80 chars, the <code>group</code> sees that you can replace newlines with spaces and
things will fit on one line, so it prints:</p>

<pre><code>[ hello, world ]
</code></pre>

<p>but if the max width is 10 it sees that things don’t fit on one line so it prints:</p>
<pre><code>[
    hello,
    world
]
</code></pre>

<p>And that’s all! Prettier is basically these five operations, plus a fairly simple
and fast algorithm for printing a notation.</p>

<!--
<details>
<summary>Lest you think it's <em>completely</em> trivial to print these
notations...</summary>
  It does take some cleverness to determine whether <code>group(x)</code> fits
  on the current line. You can't just check if <code>x</code> fits within the
  max width, because there's also stuff to the left of the <code>group</code>
  and to the right of the <code>group</code>, and this stuff may itself contains
  <code>group</code>s.
</details>
-->

<h2 id="my-twist-on-the-printer">My Twist on the Printer</h2>

<p>I’ve found a slight variation on this that’s more expressive, while being able
to use essentially the same simple and fast printing algorithm.</p>

<p>Instead of <code>group</code>, there are two operations:</p>

<ul>
  <li><code>x | y</code> for a choice between arbitrary notations <code>x</code> and <code>y</code>. The printer
will display <code>x</code> if it fits on the current line, or <code>y</code> otherwise.
There are some rules about the properties of <code>x</code> and <code>y</code> that you should
follow when writing choices, which will be described later!</li>
  <li><code>flat(x)</code> forces every choice inside of it to pick its leftmost option. It’s
called <code>flat</code> because this will typically “flatten” the layout to a single line.</li>
</ul>

<details>
  <summary>This is only a little bit novel.</summary>
  Wadler&#39;s paper also describes this choice operation and defines `group` in
  terms of it, but purposefully doesn&#39;t expose it to the user because they could
  break the invariants the printer relies on. It&#39;s only the `flat` operation
  that&#39;s new. Wadler&#39;s paper has &#34;flatten&#34;, which replaces newlines with spaces,
  while my &#34;flat&#34; picks the first option of each choice.
</details>

<p>This is better than <code>group</code> because it’s more powerful. It allows you to specify
choices between layouts that differ in more than just whitespace. For example,
<code>rustfmt</code> would format our “hello world” example with a trailing comma:</p>

<pre><code>[
    hello,
    world,
]
</code></pre>

<details>
<summary>The trailing comma looks a little silly, but it&#39;s nice for git diffs.</summary>
If you were to add a third line to the list while using a trailing comma:

<pre><code>[
    hello,
    world,
    turtle,
]
</code></pre>

then the diff is only one line:

<pre><code>+    turtle,
</code></pre>

But if you were to add that third line while not using trailing commas, then the
diff is two lines:

<pre><code>-    world
+    world,
+    turtle
</code></pre>

The point is it&#39;s at least sensible to put a trailing comma on lists that are
split across multiple lines, so it would be nice to support that.
</details>

<p>But it would be stupid to put a trailing comma on single line lists!</p>

<pre><code>// stupid:
[ hello, world, ]
</code></pre>

<p>So we’d like a printer that can express choices between layouts that differ in
more complex ways than simply “newline → space”. There are various ways to
<em>slightly</em> extend what Prettier can express, piecemeal. <em>Or</em> we can go all in
and use the two operations I describe above, which give a whole lot of power all
at once. I like to go all in 😃.</p>

<p>The choice operator will let us eliminate the trailing comma from the
single-line layout. As a bonus, we can also remove the spaces just inside the
brackets of the single-line layout, giving:</p>

<pre><code>[hello, world]
</code></pre>

<p>or</p>

<pre><code>[
    hello,
    world,
]
</code></pre>

<p>To express these two alternatives, all we do is take the single-line notation we
want and the multi-line notation we want, and join them with <code>|</code>:</p>

<figure><pre><code data-lang="bash"><span></span><span>&#34;[&#34;</span> <span>&amp;</span> <span>&#34;hello&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;world&#34;</span> <span>&amp;</span> <span>&#34;]&#34;</span>
<span>|</span>
<span>&#34;[&#34;</span> <span>&amp;</span> indent<span>(</span><span>4</span>, nl <span>&amp;</span> <span>&#34;hello&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;world&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span><span>)</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;]&#34;</span></code></pre></figure>

<p>This example doesn’t need <code>flat</code>, but <code>flat</code> comes in handy when we’re writing a
notation but don’t know what might appear inside of it. For example, if we’re
writing a notation for a <em>generic</em> list containing unknown notations <code>$X</code> and
<code>$Y</code>, the single-line layout would want to enforce that the things inside it
don’t span multiple lines. It could do so using <code>flat</code>:</p>

<figure><pre><code data-lang="bash"><span></span><span>&#34;[&#34;</span> <span>&amp;</span> flat<span>(</span><span>$X</span><span>)</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> flat<span>(</span><span>$Y</span><span>)</span> <span>&amp;</span> <span>&#34;]&#34;</span>
<span>|</span>
<span>&#34;[&#34;</span> <span>&amp;</span> indent<span>(</span><span>4</span>, nl <span>&amp;</span> <span>$X</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> nl <span>&amp;</span> <span>$Y</span> <span>&amp;</span> <span>&#34;,&#34;</span><span>)</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;]&#34;</span></code></pre></figure>

<h3 id="the-rule">The Rule</h3>

<p>With great power comes great responsibility. The choice <code>|</code> operator gives great
power, in that you can make a choice between arbitrary notations. But the
printer can’t feasibly check <em>all</em> exponentially many possibilities (remember
that choices can be deeply nested), so it must rely on the choices obeying a
rule.</p>

<p><strong>The Rule.</strong> In every choice <code>x | y</code>, the shortest possible first line of <code>y</code>
must be at least as short as <em>every</em> possible first line of <code>x</code>.</p>

<p>The printing algorithm, which I’ll start describing soon, will rely on this
choice for correctly determining whether things fit on a line.</p>

<!--
When checking if things fit, if it encounters a choice `x | y`, it will _only_
examine `y`, by the reasoning that "if `x` would fit then `y` would too, so I
only need to look at `y`".
-->

<p>There’s another softer rule, which is that if you have a choice <code>x | y</code> then <code>x</code>
should not contain forced newlines. If you obey this rule, then <code>flat</code> does what
its name says and collapses the entire layout onto a single line. If you don’t
the printer will continue to work and <code>flat</code> will continue to pick the first
option, but that first option might span multiple lines.</p>

<h2 id="implementation">Implementation</h2>

<p>Let’s walk through a quick prototype of the printing algorithm in Rust. Then
we’ll use it to print Json.</p>

<h3 id="dependencies">Dependencies</h3>

<p>We’ll initialize a rust project with <code>cargo init --lib</code>, then add two
dependencies to <code>Cargo.toml</code>:</p>

<pre><code>[dependencies]
unicode-width = &#34;0.1.5&#34;

[dev-dependencies]
serde_json = &#34;1.0&#34;
</code></pre>

<ul>
  <li><code>unicode-width</code> is to get accurate string widths for monospaced terminal fonts
including full-width Unicode characters. I’m pretty sure this is an impossible
problem but we can at least try.</li>
  <li><code>serde_json</code> is for parsing Json. It’s only a dev-dependency because the
pretty printing library won’t rely on it. It’s only needed for the Json parser
we’ll build on top of the library later.</li>
</ul>

<h3 id="srclibrs">src/lib.rs</h3>

<p>The library’s going to be split into two modules: one defines a data type for
notations, and the other gives the pretty printing algorithm:</p>

<figure><pre><code data-lang="rust"><span></span><span>mod</span> <span>notation</span><span>;</span><span></span>
<span>mod</span> <span>print</span><span>;</span><span></span>

<span>pub</span><span> </span><span>use</span><span> </span><span>notation</span>::<span>{</span><span>flat</span><span>,</span><span> </span><span>indent</span><span>,</span><span> </span><span>nl</span><span>,</span><span> </span><span>txt</span><span>,</span><span> </span><span>Notation</span><span>};</span><span></span>
<span>pub</span><span> </span><span>use</span><span> </span><span>print</span>::<span>pretty_print</span><span>;</span><span></span></code></pre></figure>

<p>You might notice that we didn’t export any operations for concat or choice. This
is because they’ll be defined with the bitwise operators <code>&amp;</code> and <code>|</code>. (If you
really don’t like overloaded operators, feel free to write functions for these
instead. And then update the use sites, where you’ll see how clunky it can get.)</p>

<h3 id="srcnotationrs">src/notation.rs</h3>

<p>The notation <code>enum</code> has exactly the operators described in this post, though
with a couple interesting details I’ll discuss after showing the code:</p>

<figure><pre><code data-lang="rust"><span></span><span>use</span><span> </span><span>std</span>::<span>ops</span>::<span>{</span><span>BitAnd</span><span>,</span><span> </span><span>BitOr</span><span>};</span><span></span>
<span>use</span><span> </span><span>std</span>::<span>rc</span>::<span>Rc</span><span>;</span><span></span>

<span>#[derive(Debug, Clone)]</span><span></span>
<span>pub</span><span> </span><span>struct</span> <span>Notation</span><span>(</span><span>pub</span><span>(</span><span>crate</span><span>)</span><span> </span><span>Rc</span><span>&lt;</span><span>NotationInner</span><span>&gt;</span><span>);</span><span></span>

<span>#[derive(Debug, Clone)]</span><span></span>
<span>pub</span><span> </span><span>enum</span> <span>NotationInner</span><span> </span><span>{</span><span></span>
<span>    </span><span>Newline</span><span>,</span><span></span>
<span>    </span><span>Text</span><span>(</span><span>String</span><span>,</span><span> </span><span>u32</span><span>),</span><span></span>
<span>    </span><span>Flat</span><span>(</span><span>Notation</span><span>),</span><span></span>
<span>    </span><span>Indent</span><span>(</span><span>u32</span><span>,</span><span> </span><span>Notation</span><span>),</span><span></span>
<span>    </span><span>Concat</span><span>(</span><span>Notation</span><span>,</span><span> </span><span>Notation</span><span>),</span><span></span>
<span>    </span><span>Choice</span><span>(</span><span>Notation</span><span>,</span><span> </span><span>Notation</span><span>),</span><span></span>
<span>}</span><span></span>

<span>/// Display a newline</span>
<span>pub</span><span> </span><span>fn</span> <span>nl</span><span>()</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>Notation</span><span>(</span><span>Rc</span>::<span>new</span><span>(</span><span>NotationInner</span>::<span>Newline</span><span>))</span><span></span>
<span>}</span><span>  </span>

<span>/// Display text exactly as-is. The text should not contain a newline!</span>
<span>pub</span><span> </span><span>fn</span> <span>txt</span><span>(</span><span>s</span>: <span>impl</span><span> </span><span>ToString</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>string</span><span> </span><span>=</span><span> </span><span>s</span><span>.</span><span>to_string</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>width</span><span> </span><span>=</span><span> </span><span>unicode_width</span>::<span>UnicodeWidthStr</span>::<span>width</span><span>(</span><span>&amp;</span><span>string</span><span> </span><span>as</span><span> </span><span>&amp;</span><span>str</span><span>)</span><span> </span><span>as</span><span> </span><span>u32</span><span>;</span><span></span>
<span>    </span><span>Notation</span><span>(</span><span>Rc</span>::<span>new</span><span>(</span><span>NotationInner</span>::<span>Text</span><span>(</span><span>string</span><span>,</span><span> </span><span>width</span><span>)))</span><span></span>
<span>}</span><span></span>

<span>/// Use the leftmost option of every choice in the contained Notation.</span>
<span>/// If the contained Notation follows the recommendation of not</span>
<span>/// putting newlines in the left-most options of choices, then this</span>
<span>/// `flat` will be displayed all on one line.</span>
<span>pub</span><span> </span><span>fn</span> <span>flat</span><span>(</span><span>notation</span>: <span>Notation</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>Notation</span><span>(</span><span>Rc</span>::<span>new</span><span>(</span><span>NotationInner</span>::<span>Flat</span><span>(</span><span>notation</span><span>)))</span><span></span>
<span>}</span><span></span>

<span>/// Increase the indentation level of the contained notation by the</span>
<span>/// given width. The indentation level determines the number of spaces</span>
<span>/// put after `Newline`s. (It therefore doesn&#39;t affect the first line</span>
<span>/// of a notation.)</span>
<span>pub</span><span> </span><span>fn</span> <span>indent</span><span>(</span><span>indent</span>: <span>u32</span><span>,</span><span> </span><span>notation</span>: <span>Notation</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>Notation</span><span>(</span><span>Rc</span>::<span>new</span><span>(</span><span>NotationInner</span>::<span>Indent</span><span>(</span><span>indent</span><span>,</span><span> </span><span>notation</span><span>)))</span><span></span>
<span>}</span><span></span>

<span>impl</span><span> </span><span>BitAnd</span><span>&lt;</span><span>Notation</span><span>&gt;</span><span> </span><span>for</span><span> </span><span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>type</span> <span>Output</span><span> </span><span>=</span><span> </span><span>Notation</span><span>;</span><span></span>

<span>    </span><span>/// Display both notations. The first character of the right</span>
<span>    </span><span>/// notation immediately follows the last character of the</span>
<span>    </span><span>/// left notation.</span>
<span>    </span><span>fn</span> <span>bitand</span><span>(</span><span>self</span><span>,</span><span> </span><span>other</span>: <span>Notation</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>        </span><span>Notation</span><span>(</span><span>Rc</span>::<span>new</span><span>(</span><span>NotationInner</span>::<span>Concat</span><span>(</span><span>self</span><span>,</span><span> </span><span>other</span><span>)))</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span>

<span>impl</span><span> </span><span>BitOr</span><span>&lt;</span><span>Notation</span><span>&gt;</span><span> </span><span>for</span><span> </span><span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>type</span> <span>Output</span><span> </span><span>=</span><span> </span><span>Notation</span><span>;</span><span></span>

<span>    </span><span>/// If inside a `flat`, _or_ the first line of the left notation</span>
<span>    </span><span>/// fits within the required width, then display the left</span>
<span>    </span><span>/// notation. Otherwise, display the right notation.</span>
<span>    </span><span>fn</span> <span>bitor</span><span>(</span><span>self</span><span>,</span><span> </span><span>other</span>: <span>Notation</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>        </span><span>Notation</span><span>(</span><span>Rc</span>::<span>new</span><span>(</span><span>NotationInner</span>::<span>Choice</span><span>(</span><span>self</span><span>,</span><span> </span><span>other</span><span>)))</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>Sub-notations that are used in multiple places must be shared, so they’re stored
in an <code>Rc</code> (ref-counted). This sharing is very important: without it the notation
becomes exponentially larger.  For example, notice that the final “hello world”
notation repeated “hello” and “world” twice. If you start nesting notations like
this, these repetitions multiply together. So it’s important to share them by
having multiple references to the <em>same</em> notation on the heap, which is what
<code>Rc</code> does. Prettier was written in Haskell, which shares by default, so it
didn’t need anything like <code>Rc</code>.</p>

<p>The <code>Text</code> variant contains the width of the string in columns. It makes sense
to compute this up front because it will accessed multiple times when
determining whether things fit on a line.</p>

<details>
<summary>Dive into the rabbit hole of string widths.</summary>

The width of a string in a monospace font is different from how many
<em>bytes</em> it is, because `á` is multiple bytes but width 1, and it&#39;s
different from the number of Unicode code points or grapheme clusters because
&#34;漢&#34; is one character/code-point/grapheme-cluster but has width 2.
<p>
The model we&#39;re relying on here is: &#34;when you print characters in a monospace
font they&#39;ll all be printed in that font, that font will only contain
single-width and double-width glyphs, and these widths can be determined from
the character alone without knowing the OS, terminal, and installed Unicode
version&#34;. This model is false, but we&#39;ll pray it&#39;s sufficiently true to be
useful and that the `unicode_width` library does a good job at approximating it.
</p>
</details>

<h3 id="srcprintrs">src/print.rs</h3>

<p>Here’s the core algorithmic idea from Wadler. When printing a document, we’re
going to break it up into a stack of <em>chunks</em> containing everything we haven’t
yet printed. Each chunk keeps a reference to a notation, together with the
accumulated indentation at that notation and whether it’s inside a <code>flat</code>:</p>

<figure><pre><code data-lang="rust"><span></span><span>use</span><span> </span><span>crate</span>::<span>notation</span>::<span>{</span><span>Notation</span><span>,</span><span> </span><span>NotationInner</span><span>};</span><span></span>

<span>#[derive(Debug, Clone, Copy)]</span><span></span>
<span>struct</span> <span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>notation</span>: <span>&amp;</span><span>&#39;a</span><span> </span><span>Notation</span><span>,</span><span></span>
<span>    </span><span>indent</span>: <span>u32</span><span>,</span><span></span>
<span>    </span><span>flat</span>: <span>bool</span><span>,</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>A few methods for modifying chunks will come in handy later:</p>

<figure><pre><code data-lang="rust"><span></span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>fn</span> <span>with_notation</span><span>(</span><span>self</span><span>,</span><span> </span><span>notation</span>: <span>&amp;</span><span>&#39;a</span><span> </span><span>Notation</span><span>)</span><span> </span>-&gt; <span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>Chunk</span><span> </span><span>{</span><span></span>
<span>            </span><span>notation</span><span>,</span><span></span>
<span>            </span><span>indent</span>: <span>self</span><span>.</span><span>indent</span><span>,</span><span></span>
<span>            </span><span>flat</span>: <span>self</span><span>.</span><span>flat</span><span>,</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span>
<span>    </span><span>fn</span> <span>indented</span><span>(</span><span>self</span><span>,</span><span> </span><span>indent</span>: <span>u32</span><span>)</span><span> </span>-&gt; <span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>Chunk</span><span> </span><span>{</span><span></span>
<span>            </span><span>notation</span>: <span>self</span><span>.</span><span>notation</span><span>,</span><span></span>
<span>            </span><span>indent</span>: <span>self</span><span>.</span><span>indent</span><span> </span><span>+</span><span> </span><span>indent</span><span>,</span><span></span>
<span>            </span><span>flat</span>: <span>self</span><span>.</span><span>flat</span><span>,</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span>
<span>    </span><span>fn</span> <span>flat</span><span>(</span><span>self</span><span>)</span><span> </span>-&gt; <span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>Chunk</span><span> </span><span>{</span><span></span>
<span>            </span><span>notation</span>: <span>self</span><span>.</span><span>notation</span><span>,</span><span></span>
<span>            </span><span>indent</span>: <span>self</span><span>.</span><span>indent</span><span>,</span><span></span>
<span>            </span><span>flat</span>: <span>true</span><span>,</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>The printer needs just three things:</p>

<figure><pre><code data-lang="rust"><span></span><span>struct</span> <span>PrettyPrinter</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>/// Maximum line width that we&#39;ll try to stay within</span>
<span>    </span><span>width</span>: <span>u32</span><span>,</span><span></span>
<span>    </span><span>/// Current column position</span>
<span>    </span><span>col</span>: <span>u32</span><span>,</span><span></span>
<span>    </span><span>/// A stack of chunks to print. The _top_ of the stack is the</span>
<span>    </span><span>/// _end_ of the vector, which represents the _earliest_ part</span>
<span>    </span><span>/// of the document to print.</span>
<span>    </span><span>chunks</span>: <span>Vec</span><span>&lt;</span><span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;&gt;</span><span>,</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>To initialize a <code>Printer</code>, set the starting column to 0 and the chunk stack to
contain a single chunk whose notation represents the entire document to print:</p>

<figure><pre><code data-lang="rust"><span></span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>PrettyPrinter</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>fn</span> <span>new</span><span>(</span><span>notation</span>: <span>&amp;</span><span>&#39;a</span><span> </span><span>Notation</span><span>,</span><span> </span><span>width</span>: <span>u32</span><span>)</span><span> </span>-&gt; <span>PrettyPrinter</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>let</span><span> </span><span>chunk</span><span> </span><span>=</span><span> </span><span>Chunk</span><span> </span><span>{</span><span></span>
<span>            </span><span>notation</span><span>,</span><span></span>
<span>            </span><span>indent</span>: <span>0</span><span>,</span><span></span>
<span>            </span><span>flat</span>: <span>false</span><span>,</span><span></span>
<span>        </span><span>};</span><span></span>
<span>        </span><span>PrettyPrinter</span><span> </span><span>{</span><span></span>
<span>            </span><span>width</span><span>,</span><span></span>
<span>            </span><span>col</span>: <span>0</span><span>,</span><span></span>
<span>            </span><span>chunks</span>: <span>vec</span><span>!</span><span>[</span><span>chunk</span><span>],</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>Here’s the method for printing:</p>

<figure><pre><code data-lang="rust"><span></span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>PrettyPrinter</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>fn</span> <span>print</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span>-&gt; <span>String</span> <span>{</span><span></span>
<span>    </span><span>use</span><span> </span><span>NotationInner</span>::<span>*</span><span>;</span><span></span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>output</span><span> </span><span>=</span><span> </span><span>String</span>::<span>new</span><span>();</span><span></span>
<span>    </span><span>while</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>chunk</span><span>)</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>pop</span><span>()</span><span> </span><span>{</span><span></span>
<span>        </span><span>match</span><span> </span><span>chunk</span><span>.</span><span>notation</span><span>.</span><span>0.</span><span>as_ref</span><span>()</span><span> </span><span>{</span><span></span>
<span>            </span><span>Text</span><span>(</span><span>text</span><span>,</span><span> </span><span>width</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                </span><span>output</span><span>.</span><span>push_str</span><span>(</span><span>text</span><span>);</span><span></span>
<span>                </span><span>self</span><span>.</span><span>col</span><span> </span><span>+=</span><span> </span><span>width</span><span>;</span><span></span>
<span>            </span><span>}</span><span></span>
<span>            </span><span>Newline</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                </span><span>output</span><span>.</span><span>push</span><span>(</span><span>&#39;\n&#39;</span><span>);</span><span></span>
<span>                </span><span>for</span><span> </span><span>_</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>chunk</span><span>.</span><span>indent</span><span> </span><span>{</span><span></span>
<span>                    </span><span>output</span><span>.</span><span>push</span><span>(</span><span>&#39; &#39;</span><span>);</span><span></span>
<span>                </span><span>}</span><span></span>
<span>                </span><span>self</span><span>.</span><span>col</span><span> </span><span>=</span><span> </span><span>chunk</span><span>.</span><span>indent</span><span>;</span><span></span>
<span>            </span><span>}</span><span></span>
<span>            </span><span>Flat</span><span>(</span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span></span>
<span>                </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>).</span><span>flat</span><span>()),</span><span></span>
<span>            </span><span>Indent</span><span>(</span><span>i</span><span>,</span><span> </span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span></span>
<span>                </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>).</span><span>indented</span><span>(</span><span>*</span><span>i</span><span>)),</span><span></span>
<span>            </span><span>Concat</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>y</span><span>));</span><span></span>
<span>                </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>));</span><span></span>
<span>            </span><span>}</span><span></span>
<span>            </span><span>Choice</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                </span><span>if</span><span> </span><span>chunk</span><span>.</span><span>flat</span><span> </span><span>||</span><span> </span><span>self</span><span>.</span><span>fits</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>))</span><span> </span><span>{</span><span></span>
<span>                    </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>));</span><span></span>
<span>                </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>                    </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>y</span><span>));</span><span></span>
<span>                </span><span>}</span><span></span>
<span>            </span><span>}</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>output</span><span></span>
<span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>Walking through each case:</p>

<ul>
  <li><code>Text</code> prints the text and adds the text’s width to <code>col</code>.</li>
  <li><code>Newline</code> prints a newline, followed by spaces for the current indentation
level. It also updates <code>col</code>.</li>
  <li><code>Flat</code> and <code>Indent</code> set the chunk’s flat/indentation and push it back onto the
stack so that we’ll recur on it.</li>
  <li><code>Concat(x, y)</code> splits the chunk into two chunks and pushes them onto the
stack. It has to push first <code>y</code> and then <code>x</code> so that <code>x</code> is on the top of the
stack and we process it next.</li>
  <li><code>Choice(x, y)</code> is the one interesting case. If we’re inside <code>flat</code>, we pick
<code>x</code>. Otherwise we pick <code>x</code> if it fits on the current line or <code>y</code> otherwise.
This calls <code>self.fits()</code> which does the hard work.</li>
</ul>

<p>The <code>fits</code> method is where the sausage gets made. We’re going to essentially
scan ahead to see whether things will fit on the current line, but there are
some important details.</p>

<figure><pre><code data-lang="rust"><span></span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>PrettyPrinter</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>fn</span> <span>fits</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>chunk</span>: <span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span>)</span><span> </span>-&gt; <span>bool</span> <span>{</span><span></span>
<span>        </span><span>use</span><span> </span><span>NotationInner</span>::<span>*</span><span>;</span><span></span>
<span>  </span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>remaining</span><span> </span><span>=</span><span> </span><span>if</span><span> </span><span>self</span><span>.</span><span>col</span><span> </span><span>&lt;=</span><span> </span><span>self</span><span>.</span><span>width</span><span> </span><span>{</span><span>         </span>
<span>            </span><span>self</span><span>.</span><span>width</span><span> </span><span>-</span><span> </span><span>self</span><span>.</span><span>col</span><span></span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>            </span><span>return</span><span> </span><span>false</span><span>;</span><span></span>
<span>        </span><span>};</span><span></span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>stack</span><span> </span><span>=</span><span> </span><span>vec</span><span>!</span><span>[</span><span>chunk</span><span>];</span><span></span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>chunks</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>chunks</span><span> </span><span>as</span><span> </span><span>&amp;</span><span>[</span><span>Chunk</span><span>];</span><span></span>

<span>        </span><span>loop</span><span> </span><span>{</span><span></span>
<span>            </span><span>let</span><span> </span><span>chunk</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>stack</span><span>.</span><span>pop</span><span>()</span><span> </span><span>{</span><span></span>
<span>                </span><span>Some</span><span>(</span><span>chunk</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>chunk</span><span>,</span><span></span>
<span>                </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>match</span><span> </span><span>chunks</span><span>.</span><span>split_last</span><span>()</span><span> </span><span>{</span><span></span>
<span>                    </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>true</span><span>,</span><span></span>
<span>                    </span><span>Some</span><span>((</span><span>chunk</span><span>,</span><span> </span><span>more_chunks</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                        </span><span>chunks</span><span> </span><span>=</span><span> </span><span>more_chunks</span><span>;</span><span></span>
<span>                        </span><span>*</span><span>chunk</span><span></span>
<span>                    </span><span>}</span><span></span>
<span>                </span><span>},</span><span></span>
<span>            </span><span>};</span><span></span>

<span>            </span><span>match</span><span> </span><span>chunk</span><span>.</span><span>notation</span><span>.</span><span>0.</span><span>as_ref</span><span>()</span><span> </span><span>{</span><span></span>
<span>                </span><span>Newline</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>true</span><span>,</span><span></span>
<span>                </span><span>Text</span><span>(</span><span>_text</span><span>,</span><span> </span><span>text_width</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                    </span><span>if</span><span> </span><span>*</span><span>text_width</span><span> </span><span>&lt;=</span><span> </span><span>remaining</span><span> </span><span>{</span><span></span>
<span>                        </span><span>remaining</span><span> </span><span>-=</span><span> </span><span>*</span><span>text_width</span><span>;</span><span></span>
<span>                    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>                        </span><span>return</span><span> </span><span>false</span><span>;</span><span></span>
<span>                    </span><span>}</span><span></span>
<span>                </span><span>}</span><span></span>
<span>                </span><span>Flat</span><span>(</span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>).</span><span>flat</span><span>()),</span><span></span>
<span>                </span><span>Indent</span><span>(</span><span>i</span><span>,</span><span> </span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span></span>
<span>                    </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>).</span><span>indented</span><span>(</span><span>*</span><span>i</span><span>)),</span><span></span>
<span>                </span><span>Concat</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                    </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>y</span><span>));</span><span></span>
<span>                    </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>));</span><span></span>
<span>                </span><span>}</span><span></span>
<span>                </span><span>Choice</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                    </span><span>if</span><span> </span><span>chunk</span><span>.</span><span>flat</span><span> </span><span>{</span><span></span>
<span>                        </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>));</span><span></span>
<span>                    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>                        </span><span>// Relies on the rule that for every choice</span>
<span>                        </span><span>// `x | y`, the first line of `y` is no longer</span>
<span>                        </span><span>// than the first line of `x`.</span>
<span>                        </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>y</span><span>));</span><span></span>
<span>                    </span><span>}</span><span></span>
<span>                </span><span>}</span><span></span>
<span>            </span><span>}</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>Let’s walk through this piece by piece.</p>

<p>The amount of space remaining on the current line is the max line width
<code>self.width</code> minus the current column <code>self.col</code>, though if we’re already
past the width limit we can return <code>false</code> because things really don’t fit.</p>

<figure><pre><code data-lang="rust"><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>remaining</span><span> </span><span>=</span><span> </span><span>if</span><span> </span><span>self</span><span>.</span><span>col</span><span> </span><span>&lt;=</span><span> </span><span>self</span><span>.</span><span>width</span><span> </span><span>{</span><span>         </span>
<span>    </span><span>self</span><span>.</span><span>width</span><span> </span><span>-</span><span> </span><span>self</span><span>.</span><span>col</span><span></span>
<span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>false</span><span>;</span><span></span>
<span>};</span><span></span></code></pre></figure>

<p>Just like in <code>print()</code>, we want to keep a stack of chunks to process. Though now
we’re just going to scan ahead to see if stuff fits on the current line, without
actually printing anything. We therefore don’t want to modify <code>self.chunks</code>
because modifications should not persist after the <code>fits()</code> method finishes.
<em>However</em>, we don’t want to copy <code>self.chunks</code> because that would be
inefficient. So instead we’ll keep a working stack called <code>stack</code> and a
reference to the <code>self.chunks</code> that we haven’t yet processed called <code>chunks</code>:</p>

<figure><pre><code data-lang="rust"><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>stack</span><span> </span><span>=</span><span> </span><span>vec</span><span>!</span><span>[</span><span>chunk</span><span>];</span><span></span>
<span>let</span><span> </span><span>mut</span><span> </span><span>chunks</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>chunks</span><span> </span><span>as</span><span> </span><span>&amp;</span><span>[</span><span>Chunk</span><span>];</span><span></span></code></pre></figure>

<p>The first thing the loop will do is “get the next chunk”. Since there are two
places it might come from this is a little complicated, but all this code
says is “take a chunk from the <code>stack</code>, or if that’s empty take it from
<code>chunks</code>, or if that’s empty too return <code>true</code>”:</p>

<figure><pre><code data-lang="rust"><span></span><span>loop</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>chunk</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>stack</span><span>.</span><span>pop</span><span>()</span><span> </span><span>{</span><span></span>
<span>        </span><span>Some</span><span>(</span><span>chunk</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>chunk</span><span>,</span><span></span>
<span>        </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>match</span><span> </span><span>chunks</span><span>.</span><span>split_last</span><span>()</span><span> </span><span>{</span><span></span>
<span>            </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>true</span><span>,</span><span></span>
<span>            </span><span>Some</span><span>((</span><span>chunk</span><span>,</span><span> </span><span>more_chunks</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                </span><span>chunks</span><span> </span><span>=</span><span> </span><span>more_chunks</span><span>;</span><span></span>
<span>                </span><span>*</span><span>chunk</span><span></span>
<span>            </span><span>}</span><span></span>
<span>        </span><span>},</span><span></span>
<span>    </span><span>};</span><span></span></code></pre></figure>

<p>Then the body of the loop processes the chunk to check whether it fits on the
line:</p>

<figure><pre><code data-lang="rust"><span></span><span>match</span><span> </span><span>chunk</span><span>.</span><span>notation</span><span>.</span><span>0.</span><span>as_ref</span><span>()</span><span> </span><span>{</span><span></span>
<span>    </span><span>Newline</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>true</span><span>,</span><span></span>
<span>    </span><span>Text</span><span>(</span><span>_text</span><span>,</span><span> </span><span>text_width</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>if</span><span> </span><span>*</span><span>text_width</span><span> </span><span>&lt;=</span><span> </span><span>remaining</span><span> </span><span>{</span><span></span>
<span>            </span><span>remaining</span><span> </span><span>-=</span><span> </span><span>*</span><span>text_width</span><span>;</span><span></span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>            </span><span>return</span><span> </span><span>false</span><span>;</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>Flat</span><span>(</span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>).</span><span>flat</span><span>()),</span><span></span>
<span>    </span><span>Indent</span><span>(</span><span>i</span><span>,</span><span> </span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>).</span><span>indented</span><span>(</span><span>*</span><span>i</span><span>)),</span><span></span>
<span>    </span><span>Concat</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>y</span><span>));</span><span></span>
<span>        </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>));</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>Choice</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>if</span><span> </span><span>chunk</span><span>.</span><span>flat</span><span> </span><span>{</span><span></span>
<span>            </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>));</span><span></span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>            </span><span>// Relies on the rule that for every choice</span>
<span>            </span><span>// `x | y`, the first line of `y` is no longer</span>
<span>            </span><span>// than the first line of `x`.</span>
<span>            </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>y</span><span>));</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<ul>
  <li>If we hit a newline, there’s nothing more on the line so things must have fit
and we can return <code>true</code>.</li>
  <li>When we encounter <code>Text</code>, we check if it fits in the remaining space. If it
does, we subtract its width from the remaining space. If it doesn’t, we
return <code>false</code>.</li>
  <li>We handle <code>Flat</code>, <code>Indent</code>, and <code>Concat</code> just like in the <code>print()</code> method,
though here we’re pushing to <code>stack</code> instead of <code>self.chunks</code>.</li>
  <li>The <code>Choice(x, y)</code> case is the crux of the whole algorithm. When we encounter
this choice, it means that we were <em>already checking whether the first option
of a choice fits on the current line</em>, because that’s the only situation where
<code>fits()</code> is invoked.  While doing so, we started looking ahead and encountered
this <em>second</em> choice <code>Choice(x, y)</code>.  There might be a tradeoff between these two
choices: perhaps either one can fit on one line but not both at once. We are
<em>greedily</em> resolving this tradeoff in favor of the first choice, by asking
whether there’s <em>any</em> way the second choice can be resolved such that the
first choice fits on the line.  This is where The Rule comes in! We ignore <code>x</code>
and only check <code>y</code>, by the reasoning that “if <code>y</code> doesn’t fit, then <code>x</code>
wouldn’t fit either, so it’s safe to only check if <code>y</code> fits.”</li>
</ul>

<p>And that’s it! That’s the whole printer.</p>

<h3 id="examplesjsonrs">examples/json.rs</h3>

<p>To test our newly completed pretty printing library, let’s add an example usage
in <code>example/json.rs</code> for printing Json. It will give functions for constructing
<code>Notation</code>s for each kind of Json value (null, number, list, etc.):</p>

<figure><pre><code data-lang="rust"><span></span><span>use</span><span> </span><span>pretty</span>::<span>{</span><span>flat</span><span>,</span><span> </span><span>indent</span><span>,</span><span> </span><span>nl</span><span>,</span><span> </span><span>pretty_print</span><span>,</span><span> </span><span>txt</span><span>,</span><span> </span><span>Notation</span><span>};</span><span></span>

<span>pub</span><span> </span><span>fn</span> <span>json_null</span><span>()</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>txt</span><span>(</span><span>&#34;null&#34;</span><span>)</span><span></span>
<span>}</span><span></span>

<span>pub</span><span> </span><span>fn</span> <span>json_bool</span><span>(</span><span>b</span>: <span>bool</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>b</span><span> </span><span>{</span><span></span>
<span>        </span><span>txt</span><span>(</span><span>&#34;true&#34;</span><span>)</span><span></span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>        </span><span>txt</span><span>(</span><span>&#34;false&#34;</span><span>)</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span>

<span>pub</span><span> </span><span>fn</span> <span>json_string</span><span>(</span><span>s</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>// TODO: escape sequences</span>
<span>    </span><span>txt</span><span>(</span><span>format</span><span>!</span><span>(</span><span>&#34;</span><span>\&#34;</span><span>{}</span><span>\&#34;</span><span>&#34;</span><span>,</span><span> </span><span>s</span><span>))</span><span></span>
<span>}</span><span></span>

<span>pub</span><span> </span><span>fn</span> <span>json_number</span><span>(</span><span>n</span>: <span>impl</span><span> </span><span>ToString</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>txt</span><span>(</span><span>n</span><span>)</span><span></span>
<span>}</span><span></span>

<span>fn</span> <span>comma_sep_single_line</span><span>(</span><span>elems</span>: <span>&amp;</span><span>[</span><span>Notation</span><span>])</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>list</span><span> </span><span>=</span><span> </span><span>flat</span><span>(</span><span>elems</span><span>[</span><span>0</span><span>].</span><span>clone</span><span>());</span><span></span>
<span>    </span><span>for</span><span> </span><span>elem</span><span> </span><span>in</span><span> </span><span>&amp;</span><span>elems</span><span>[</span><span>1</span><span>..]</span><span> </span><span>{</span><span></span>
<span>        </span><span>list</span><span> </span><span>=</span><span> </span><span>list</span><span> </span><span>&amp;</span><span> </span><span>txt</span><span>(</span><span>&#34;, &#34;</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>flat</span><span>(</span><span>elem</span><span>.</span><span>clone</span><span>());</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>list</span><span></span>
<span>}</span><span></span>

<span>fn</span> <span>comma_sep_multi_line</span><span>(</span><span>elems</span>: <span>&amp;</span><span>[</span><span>Notation</span><span>])</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>list</span><span> </span><span>=</span><span> </span><span>elems</span><span>[</span><span>0</span><span>].</span><span>clone</span><span>();</span><span></span>
<span>    </span><span>for</span><span> </span><span>elem</span><span> </span><span>in</span><span> </span><span>&amp;</span><span>elems</span><span>[</span><span>1</span><span>..]</span><span> </span><span>{</span><span></span>
<span>        </span><span>list</span><span> </span><span>=</span><span> </span><span>list</span><span> </span><span>&amp;</span><span> </span><span>txt</span><span>(</span><span>&#34;, &#34;</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>nl</span><span>()</span><span> </span><span>&amp;</span><span> </span><span>elem</span><span>.</span><span>clone</span><span>();</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>list</span><span></span>
<span>}</span><span></span>

<span>fn</span> <span>surrounded</span><span>(</span><span>open</span>: <span>&amp;</span><span>str</span><span>,</span><span> </span><span>elems</span>: <span>&amp;</span><span>[</span><span>Notation</span><span>],</span><span> </span><span>closed</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>elems</span><span>.</span><span>is_empty</span><span>()</span><span> </span><span>{</span><span></span>
<span>        </span><span>return</span><span> </span><span>txt</span><span>(</span><span>open</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>txt</span><span>(</span><span>closed</span><span>);</span><span></span>
<span>    </span><span>}</span><span></span>

<span>    </span><span>let</span><span> </span><span>single_line</span><span> </span><span>=</span><span> </span><span>txt</span><span>(</span><span>open</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>comma_sep_single_line</span><span>(</span><span>elems</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>txt</span><span>(</span><span>closed</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>multi_line</span><span> </span><span>=</span><span> </span><span>txt</span><span>(</span><span>open</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>indent</span><span>(</span><span>4</span><span>,</span><span> </span><span>nl</span><span>()</span><span> </span><span>&amp;</span><span> </span><span>comma_sep_multi_line</span><span>(</span><span>elems</span><span>))</span><span> </span><span>&amp;</span><span> </span><span>nl</span><span>()</span><span> </span><span>&amp;</span><span> </span><span>txt</span><span>(</span><span>closed</span><span>);</span><span></span>
<span>    </span><span>single_line</span><span> </span><span>|</span><span> </span><span>multi_line</span><span></span>
<span>}</span><span></span>

<span>pub</span><span> </span><span>fn</span> <span>json_array</span><span>(</span><span></span>
<span>    </span><span>elems</span>: <span>impl</span><span> </span><span>IntoIterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>Notation</span><span>&gt;</span><span></span>
<span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>elems</span><span> </span><span>=</span><span> </span><span>elems</span><span>.</span><span>into_iter</span><span>().</span><span>collect</span>::<span>&lt;</span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;&gt;</span><span>();</span><span></span>
<span>    </span><span>surrounded</span><span>(</span><span>&#34;[&#34;</span><span>,</span><span> </span><span>&amp;</span><span>elems</span><span>,</span><span> </span><span>&#34;]&#34;</span><span>)</span><span></span>
<span>}</span><span></span>

<span>fn</span> <span>json_object_entry</span><span>(</span><span>key</span>: <span>String</span><span>,</span><span> </span><span>value</span>: <span>Notation</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>json_string</span><span>(</span><span>&amp;</span><span>key</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>txt</span><span>(</span><span>&#34;: &#34;</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>value</span><span></span>
<span>}</span><span></span>

<span>pub</span><span> </span><span>fn</span> <span>json_object</span><span>(</span><span></span>
<span>    </span><span>entries</span>: <span>impl</span><span> </span><span>IntoIterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>(</span><span>String</span><span>,</span><span> </span><span>Notation</span><span>)</span><span>&gt;</span><span></span>
<span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>entries</span><span> </span><span>=</span><span> </span><span>entries</span><span></span>
<span>        </span><span>.</span><span>into_iter</span><span>()</span><span></span>
<span>        </span><span>.</span><span>map</span><span>(</span><span>|</span><span>(</span><span>key</span><span>,</span><span> </span><span>val</span><span>)</span><span>|</span><span> </span><span>json_object_entry</span><span>(</span><span>key</span><span>,</span><span> </span><span>val</span><span>))</span><span></span>
<span>        </span><span>.</span><span>collect</span>::<span>&lt;</span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;&gt;</span><span>();</span><span></span>
<span>    </span><span>surrounded</span><span>(</span><span>&#34;{&#34;</span><span>,</span><span> </span><span>&amp;</span><span>entries</span><span>,</span><span> </span><span>&#34;}&#34;</span><span>)</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>We could call these methods manually:</p>

<figure><pre><code data-lang="rust"><span></span><span>json_array</span><span>([</span><span>json_string</span><span>(</span><span>&#34;hello&#34;</span><span>),</span><span> </span><span>json_string</span><span>(</span><span>&#34;world&#34;</span><span>)])</span><span></span></code></pre></figure>

<p>but it would be tedious to build a large enough example to be interesting.</p>

<p>Instead let’s make a Json code formatter that uses <code>serde_json</code> to parse Json
and then re-prints it with our pretty printer. <code>serde_json</code> has a representation
of <code>Json</code> called <code>serde_json::Value</code>. We’ll need a function to convert that to a
<code>Notation</code>:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>json_to_notation</span><span>(</span><span>json</span>: <span>serde_json</span>::<span>Value</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>use</span><span> </span><span>serde_json</span>::<span>Value</span>::<span>{</span><span>Array</span><span>,</span><span> </span><span>Bool</span><span>,</span><span> </span><span>Null</span><span>,</span><span> </span><span>Number</span><span>,</span><span> </span><span>Object</span><span>,</span><span> </span><span>String</span><span>};</span><span></span>

<span>    </span><span>match</span><span> </span><span>json</span><span> </span><span>{</span><span></span>
<span>        </span><span>Null</span><span> </span><span>=&gt;</span><span> </span><span>json_null</span><span>(),</span><span></span>
<span>        </span><span>Bool</span><span>(</span><span>b</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>json_bool</span><span>(</span><span>b</span><span>),</span><span></span>
<span>        </span><span>Number</span><span>(</span><span>n</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>json_number</span><span>(</span><span>n</span><span>),</span><span></span>
<span>        </span><span>String</span><span>(</span><span>s</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>json_string</span><span>(</span><span>&amp;</span><span>s</span><span>),</span><span></span>
<span>        </span><span>Array</span><span>(</span><span>elems</span><span>)</span><span> </span><span>=&gt;</span><span></span>
<span>            </span><span>json_array</span><span>(</span><span>elems</span><span>.</span><span>into_iter</span><span>().</span><span>map</span><span>(</span><span>json_to_notation</span><span>)),</span><span></span>
<span>        </span><span>Object</span><span>(</span><span>entries</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>json_object</span><span>(</span><span></span>
<span>            </span><span>entries</span><span></span>
<span>                </span><span>.</span><span>into_iter</span><span>()</span><span></span>
<span>                </span><span>.</span><span>map</span><span>(</span><span>|</span><span>(</span><span>key</span><span>,</span><span> </span><span>val</span><span>)</span><span>|</span><span> </span><span>(</span><span>key</span><span>,</span><span> </span><span>json_to_notation</span><span>(</span><span>val</span><span>))),</span><span></span>
<span>        </span><span>),</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>And now we can glue everything together to re-format a Json file. Let’s record
timing info to tell how long each phase takes:</p>

<figure><pre><code data-lang="rust"><span></span><span>const</span><span> </span><span>WIDTH</span>: <span>u32</span> <span>=</span><span> </span><span>120</span><span>;</span><span></span>

<span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>    </span><span>use</span><span> </span><span>std</span>::<span>env</span><span>;</span><span></span>
<span>    </span><span>use</span><span> </span><span>std</span>::<span>fs</span>::<span>File</span><span>;</span><span></span>
<span>    </span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>BufReader</span><span>;</span><span></span>
<span>    </span><span>use</span><span> </span><span>std</span>::<span>time</span>::<span>Instant</span><span>;</span><span></span>

<span>    </span><span>// Get the filename to parse from the command line args</span>
<span>    </span><span>let</span><span> </span><span>env_args</span><span> </span><span>=</span><span> </span><span>env</span>::<span>args</span><span>().</span><span>collect</span>::<span>&lt;</span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;&gt;</span><span>();</span><span></span>
<span>    </span><span>if</span><span> </span><span>env_args</span><span>.</span><span>len</span><span>()</span><span> </span><span>!=</span><span> </span><span>2</span><span> </span><span>{</span><span></span>
<span>        </span><span>panic</span><span>!</span><span>(</span><span>&#34;Usage: cargo run --release --example json FILENAME.json&#34;</span><span>);</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>let</span><span> </span><span>filename</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>env_args</span><span>[</span><span>1</span><span>];</span><span></span>

<span>    </span><span>// Parse the file into json using serde</span>
<span>    </span><span>let</span><span> </span><span>start</span><span> </span><span>=</span><span> </span><span>Instant</span>::<span>now</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>file</span><span> </span><span>=</span><span> </span><span>File</span>::<span>open</span><span>(</span><span>filename</span><span>).</span><span>unwrap</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>reader</span><span> </span><span>=</span><span> </span><span>BufReader</span>::<span>new</span><span>(</span><span>file</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>json</span><span> </span><span>=</span><span> </span><span>serde_json</span>::<span>from_reader</span><span>(</span><span>reader</span><span>).</span><span>unwrap</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>ms_to_parse</span><span> </span><span>=</span><span> </span><span>start</span><span>.</span><span>elapsed</span><span>().</span><span>as_millis</span><span>();</span><span></span>

<span>    </span><span>// Convert it to a Notation</span>
<span>    </span><span>let</span><span> </span><span>start</span><span> </span><span>=</span><span> </span><span>Instant</span>::<span>now</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>notation</span><span> </span><span>=</span><span> </span><span>json_to_notation</span><span>(</span><span>json</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>ms_to_construct</span><span> </span><span>=</span><span> </span><span>start</span><span>.</span><span>elapsed</span><span>().</span><span>as_millis</span><span>();</span><span></span>

<span>    </span><span>// Pretty print the Notation</span>
<span>    </span><span>let</span><span> </span><span>start</span><span> </span><span>=</span><span> </span><span>Instant</span>::<span>now</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>output</span><span> </span><span>=</span><span> </span><span>pretty_print</span><span>(</span><span>&amp;</span><span>notation</span><span>,</span><span> </span><span>WIDTH</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>ms_to_pretty_print</span><span> </span><span>=</span><span> </span><span>start</span><span>.</span><span>elapsed</span><span>().</span><span>as_millis</span><span>();</span><span></span>

<span>    </span><span>// Print it to the terminal</span>
<span>    </span><span>let</span><span> </span><span>start</span><span> </span><span>=</span><span> </span><span>Instant</span>::<span>now</span><span>();</span><span></span>
<span>    </span><span>println</span><span>!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>output</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>ms_to_output</span><span> </span><span>=</span><span> </span><span>start</span><span>.</span><span>elapsed</span><span>().</span><span>as_millis</span><span>();</span><span></span>

<span>    </span><span>// Print timing info to stderr</span>
<span>    </span><span>eprintln</span><span>!</span><span>(</span><span>&#34;Time to parse file as Json:    {} ms&#34;</span><span>,</span><span> </span><span>ms_to_parse</span><span>);</span><span></span>
<span>    </span><span>eprintln</span><span>!</span><span>(</span><span>&#34;Time to construct Notation:    {} ms&#34;</span><span>,</span><span> </span><span>ms_to_construct</span><span>);</span><span></span>
<span>    </span><span>eprintln</span><span>!</span><span>(</span><span>&#34;Time to pretty print Notation: {} ms&#34;</span><span>,</span><span> </span><span>ms_to_pretty_print</span><span>);</span><span></span>
<span>    </span><span>eprintln</span><span>!</span><span>(</span><span>&#34;Time to print to terminal:     {} ms&#34;</span><span>,</span><span> </span><span>ms_to_output</span><span>);</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>Running this on a big Json file of Pokémon on my laptop:</p>

<figure><pre><code data-lang="bash"><span></span>cargo run --release --example json pokemon.json</code></pre></figure>

<p>gives:</p>

<pre><code><small><small>{
    &#34;abilities&#34;: [
        {
            &#34;ability&#34;: {&#34;name&#34;: &#34;overgrow&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/ability/65/&#34;}, 
            &#34;is_hidden&#34;: false, 
            &#34;slot&#34;: 1
        }, 
        {
            &#34;ability&#34;: {&#34;name&#34;: &#34;chlorophyll&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/ability/34/&#34;}, 
            &#34;is_hidden&#34;: true, 
            &#34;slot&#34;: 3
        }
    ], 
    &#34;base_experience&#34;: 64, 
    &#34;cries&#34;: {
        &#34;latest&#34;: &#34;https://raw.githubusercontent.com/PokeAPI/cries/main/cries/pokemon/latest/1.ogg&#34;, 
        &#34;legacy&#34;: &#34;https://raw.githubusercontent.com/PokeAPI/cries/main/cries/pokemon/legacy/1.ogg&#34;
    },
    &#34;forms&#34;: [{&#34;name&#34;: &#34;bulbasaur&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/pokemon-form/1/&#34;}], 
    &#34;game_indices&#34;: [
        {&#34;game_index&#34;: 153, &#34;version&#34;: {&#34;name&#34;: &#34;red&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version/1/&#34;}}, 
        {&#34;game_index&#34;: 153, &#34;version&#34;: {&#34;name&#34;: &#34;blue&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version/2/&#34;}}, 
        {&#34;game_index&#34;: 153, &#34;version&#34;: {&#34;name&#34;: &#34;yellow&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version/3/&#34;}}, 
        {&#34;game_index&#34;: 1, &#34;version&#34;: {&#34;name&#34;: &#34;gold&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version/4/&#34;}}, 
        ...
        {&#34;game_index&#34;: 1, &#34;version&#34;: {&#34;name&#34;: &#34;white-2&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version/22/&#34;}}
    ], 
    &#34;height&#34;: 7, 
    &#34;held_items&#34;: [], 
    &#34;id&#34;: 1,    
    &#34;is_default&#34;: true, 
    &#34;location_area_encounters&#34;: &#34;https://pokeapi.co/api/v2/pokemon/1/encounters&#34;, 
    &#34;moves&#34;: [
        {
            &#34;move&#34;: {&#34;name&#34;: &#34;razor-wind&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/move/13/&#34;}, 
            &#34;version_group_details&#34;: [
                {
                    &#34;level_learned_at&#34;: 0, 
                    &#34;move_learn_method&#34;: {&#34;name&#34;: &#34;egg&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/move-learn-method/2/&#34;}, 
                    &#34;version_group&#34;: {&#34;name&#34;: &#34;gold-silver&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version-group/3/&#34;}
                }, 
                {
                    &#34;level_learned_at&#34;: 0, 
                    &#34;move_learn_method&#34;: {&#34;name&#34;: &#34;egg&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/move-learn-method/2/&#34;}, 
                    &#34;version_group&#34;: {&#34;name&#34;: &#34;crystal&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version-group/4/&#34;}
                }
            ]
        },
...
6737 lines of Json
...
Time to parse file as Json:    2 ms
Time to construct Notation:    8 ms
Time to pretty print Notation: 2 ms
Time to print to terminal:     36 ms
</small></small></code></pre>

<p>(This is printed at width 120 to make the output more interesting by having more
things fit on a line, then hackily squeezed into my website’s rather narrow code
blocks.)</p>

<p>So:</p>

<ul>
  <li>Only 2ms to parse the file. <code>serde_json</code> is fast.</li>
  <li>It takes longer to construct the <code>Notation</code> than to print it! I suspect that
most of the time comes from the <code>Rc</code>s. There are faster techniques for
sharing, but they’re pretty heavy handed so I won’t show them here. But here’s
a branch that does
<a href="https://github.com/justinpombrio/experiments/compare/main...typed-arena">arena allocation</a>.</li>
  <li>The parsing and printing together is much faster than outputting to the
terminal.</li>
</ul>

<p>So there it is: a fairly simple, fairly fast, fairly expressive pretty printer.
It’s Wadler’s Prettier Printer, with a twist.</p>

<p>The full code is <a href="https://github.com/justinpombrio/experiments/tree/main/pretty">on Github</a>.</p>

<h3 id="citations">Citations</h3>

<p>[1] Philip Wadler. “A Prettier Printer”. The Fun of Programming, Cornerstones of
Computing, 2003. <a href="https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf">link</a>.</p>

<p>[2] Christian Lindig. “Strictly Pretty”. Informally published, 2000.
<a href="https://lindig.github.io/papers/strictly-pretty-2000.pdf">Link</a>.</p>

<p>
February 23, 2024
<a href="https://justinpombrio.net/feed.xml"><img width="16rem" src="https://justinpombrio.net/src/img/rss.png"/></a>
</p>
</div></div>
  </body>
</html>
