<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justinpombrio.net/2024/02/23/a-twist-on-Wadlers-printer.html">Original</a>
    <h1>A Twist on Wadler&#39;s Printer</h1>
    
    <div id="readability-page-1" class="page"><div>

<blockquote>
  <p>I present a more expressive variant of Wadler‚Äôs ‚ÄúPrettier Printer‚Äù.</p>
</blockquote>

<hr/>

<h2 id="whats-a-pretty-printer">What‚Äôs a pretty printer?</h2>

<p>You‚Äôve probably used a code formatter like <code>gofmt</code> or <code>rustfmt</code> or JS
<code>prettier</code>. These tools work in two steps: (i) parse the source code in a file,
and (ii) print it out nicely. Step (ii) is pretty printing.</p>

<p>Pretty printing is the reverse of parsing. Parsing turns linear text into a tree
(a <em>parse tree</em>, which after a bit of post-processing becomes an abstract syntax
tree (AST)). Pretty printing is the reverse: it turns the tree-shaped AST into
linear text.</p>

<p>One of the most commonly used pretty printing algorithms is Philip Wadler‚Äôs
<a href="https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf">‚ÄúA Prettier Printer‚Äù</a>
[1]. Hereafter I‚Äôll call it <em>Prettier</em>. Prettier is reasonably expressive while
being extremely fast (linear time) and simple (50 lines of code), which probably
accounts for its popularity.</p>
<details>
  <summary>Implementing Prettier in a strict language. (Click to expand.)</summary>
  Prettier is written in Haskell and relies on the language being lazily
  evaluated. If you code it directly in another language, you&#39;ll get something
  that runs in exponential time! But there&#39;s an easy modification to the
  algorithm for strict languages described in
  <a href="https://lindig.github.io/papers/strictly-pretty-2000.pdf">
  &#34;Strictly Pretty&#34;</a>
  [2]. The code in this post will do essentially the same thing.
</details>

<p>In this post, I‚Äôll:</p>

<ul>
  <li>describe how Prettier behaves</li>
  <li>describe a variation of it I came up with that‚Äôs just as fast while being more
expressive</li>
  <li>walk through implementing it in Rust, and writing a Json printer using it</li>
</ul>

<h2 id="wadlers-prettier-printer">Wadler‚Äôs Prettier Printer</h2>

<p>Say we have a program we want to print. For simplicity of exposition, just a
short list: <code>[hello, world]</code> (imagine that ‚Äúhello‚Äù and ‚Äúworld‚Äù are variables).
There are a couple ways you might want to print this. Either all on one line:</p>

<pre><code>[ hello, world ]
</code></pre>

<p>or on separate lines:</p>

<pre><code>[
    hello,
    world
]
</code></pre>

<p>Each of these possibilities is called a <em>layout</em>. A pretty printer will have (i)
a language in which you can express a variety of possible layouts, and (ii) an
algorithm for picking the ‚Äúbest‚Äù possible layout from that set. What ‚Äúbest‚Äù
means depends on the printer, but for Prettier it‚Äôs simply ‚Äútry not to make
lines too long‚Äù (canonically 80 characters, but you can set that to whatever
width you want).</p>

<p>In our tiny example, there are only two possible layouts, but in general there
can be many more. <em>Exponentially</em> more, in fact, since alternatives can be
nested inside each other. This gives a very large space of possibilities to
explore. Prettier‚Äôs algorithm explores it in linear time by greedily resolving
alternatives one line at a time. We‚Äôll see that in detail later, but for
now let‚Äôs return to the easier problem of how to express the two layouts above.</p>

<p>Those two layouts can be expressed in Prettier using a combination of:</p>

<ul>
  <li><code>txt</code> for the text of each token like ‚Äú[‚Äù and ‚Äúhello‚Äù. I‚Äôll typically omit
the <code>txt</code> and just write the text directly in quotes, so the examples don‚Äôt
get too noisy.</li>
  <li><code>nl</code> for newlines.</li>
  <li><code>indent(i, x)</code> to indent every newline in <code>x</code> by <code>i</code> spaces.</li>
  <li><code>x &amp; y</code> to concatenate things together.</li>
</ul>

<p>I‚Äôll call a mix of these operations a <em>notation</em>.</p>

<details>
  <summary>I&#39;m using different words than Wadler does in his paper.</summary>
  If you&#39;re referencing his paper, he calls the above `text`, `line`, `nest`, and `&lt;&gt;`.
  I say &#34;indent&#34; instead of &#34;nest&#34; because that&#39;s a better word for what it does;
  &#34;nl&#34; (newline) instead of &#34;line&#34; because &#34;line&#34; could mean a lot of other
  things; and &#34;&amp;&#34; because you can use that as an operator in Rust.

  Additionally, what I call a &#34;notation&#34; Wadler calls a &#34;document&#34;. I find that
  a particularly unpleasant word choice because &#34;document&#34; sounds like the thing
  you wanted to print in the first place, not the pretty printing expression
  you&#39;ve converted it to to display it. Unfortunately, &#34;document&#34; is pretty well
  embedded as a term in the literature now. Fortunately I&#39;m writing a blog post
  and can call it whatever I please.
</details>

<p>We can write a notation that prints as the first layout like so:</p>

<figure><pre><code data-lang="bash"><span></span><span>&#34;[&#34;</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;hello&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;world&#34;</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;]&#34;</span></code></pre></figure>

<p>‚á®</p>
<pre><code>[ hello, world ]
</code></pre>

<p>And a notation that prints as the second layout:</p>

<figure><pre><code data-lang="bash"><span></span><span>&#34;[&#34;</span> <span>&amp;</span> indent<span>(</span><span>4</span>, nl <span>&amp;</span> <span>&#34;hello&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;world&#34;</span><span>)</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;]&#34;</span></code></pre></figure>

<p>‚á®</p>
<pre><code>[
    hello,
    world
]
</code></pre>

<p>Notice how much these two notations have in common! If you replace every <code>nl</code>
with a space <code>&#34; &#34;</code>, the second notation becomes almost identical to the first:</p>

<figure><pre><code data-lang="bash"><span></span><span>&#34;[&#34;</span> <span>&amp;</span> indent<span>(</span><span>4</span>, <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;hello&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;world&#34;</span><span>)</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;]&#34;</span></code></pre></figure>

<p>The only difference is the <code>indent</code>, which no longer matters because there are
no newlines to indent.</p>

<p>This is the key to how Prettier represents choices. There‚Äôs just one additional
notation operator:</p>

<ul>
  <li><code>group(x)</code> means ‚ÄúDisplay <code>x</code> with every <code>nl</code> in it replaced by a space,
if that would fit on the current line. Otherwise, display <code>x</code> as-is.‚Äù</li>
</ul>

<p>Using <code>group</code>, we can express a choice between the two above layouts with a
single notation:</p>

<figure><pre><code data-lang="bash"><span></span>group<span>(</span><span>&#34;[&#34;</span> <span>&amp;</span> indent<span>(</span><span>4</span>, nl <span>&amp;</span> <span>&#34;hello&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;world&#34;</span><span>)</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;]&#34;</span><span>)</span></code></pre></figure>

<p>Then you can print this notation with various max line widths. If the max width
is 80 chars, the <code>group</code> sees that you can replace newlines with spaces and
things will fit on one line, so it prints:</p>

<pre><code>[ hello, world ]
</code></pre>

<p>but if the max width is 10 it sees that things don‚Äôt fit on one line so it prints:</p>
<pre><code>[
    hello,
    world
]
</code></pre>

<p>And that‚Äôs all! Prettier is basically these five operations, plus a fairly simple
and fast algorithm for printing a notation.</p>

<!--
<details>
<summary>Lest you think it's <em>completely</em> trivial to print these
notations...</summary>
  It does take some cleverness to determine whether <code>group(x)</code> fits
  on the current line. You can't just check if <code>x</code> fits within the
  max width, because there's also stuff to the left of the <code>group</code>
  and to the right of the <code>group</code>, and this stuff may itself contains
  <code>group</code>s.
</details>
-->

<h2 id="my-twist-on-the-printer">My Twist on the Printer</h2>

<p>I‚Äôve found a slight variation on this that‚Äôs more expressive, while being able
to use essentially the same simple and fast printing algorithm.</p>

<p>Instead of <code>group</code>, there are two operations:</p>

<ul>
  <li><code>x | y</code> for a choice between arbitrary notations <code>x</code> and <code>y</code>. The printer
will display <code>x</code> if it fits on the current line, or <code>y</code> otherwise.
There are some rules about the properties of <code>x</code> and <code>y</code> that you should
follow when writing choices, which will be described later!</li>
  <li><code>flat(x)</code> forces every choice inside of it to pick its leftmost option. It‚Äôs
called <code>flat</code> because this will typically ‚Äúflatten‚Äù the layout to a single line.</li>
</ul>

<details>
  <summary>This is only a little bit novel.</summary>
  Wadler&#39;s paper also describes this choice operation and defines `group` in
  terms of it, but purposefully doesn&#39;t expose it to the user because they could
  break the invariants the printer relies on. It&#39;s only the `flat` operation
  that&#39;s new. Wadler&#39;s paper has &#34;flatten&#34;, which replaces newlines with spaces,
  while my &#34;flat&#34; picks the first option of each choice.
</details>

<p>This is better than <code>group</code> because it‚Äôs more powerful. It allows you to specify
choices between layouts that differ in more than just whitespace. For example,
<code>rustfmt</code> would format our ‚Äúhello world‚Äù example with a trailing comma:</p>

<pre><code>[
    hello,
    world,
]
</code></pre>

<details>
<summary>The trailing comma looks a little silly, but it&#39;s nice for git diffs.</summary>
If you were to add a third line to the list while using a trailing comma:

<pre><code>[
    hello,
    world,
    turtle,
]
</code></pre>

then the diff is only one line:

<pre><code>+    turtle,
</code></pre>

But if you were to add that third line while not using trailing commas, then the
diff is two lines:

<pre><code>-    world
+    world,
+    turtle
</code></pre>

The point is it&#39;s at least sensible to put a trailing comma on lists that are
split across multiple lines, so it would be nice to support that.
</details>

<p>But it would be stupid to put a trailing comma on single line lists!</p>

<pre><code>// stupid:
[ hello, world, ]
</code></pre>

<p>So we‚Äôd like a printer that can express choices between layouts that differ in
more complex ways than simply ‚Äúnewline ‚Üí space‚Äù. There are various ways to
<em>slightly</em> extend what Prettier can express, piecemeal. <em>Or</em> we can go all in
and use the two operations I describe above, which give a whole lot of power all
at once. I like to go all in üòÉ.</p>

<p>The choice operator will let us eliminate the trailing comma from the
single-line layout. As a bonus, we can also remove the spaces just inside the
brackets of the single-line layout, giving:</p>

<pre><code>[hello, world]
</code></pre>

<p>or</p>

<pre><code>[
    hello,
    world,
]
</code></pre>

<p>To express these two alternatives, all we do is take the single-line notation we
want and the multi-line notation we want, and join them with <code>|</code>:</p>

<figure><pre><code data-lang="bash"><span></span><span>&#34;[&#34;</span> <span>&amp;</span> <span>&#34;hello&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> <span>&#34;world&#34;</span> <span>&amp;</span> <span>&#34;]&#34;</span>
<span>|</span>
<span>&#34;[&#34;</span> <span>&amp;</span> indent<span>(</span><span>4</span>, nl <span>&amp;</span> <span>&#34;hello&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;world&#34;</span> <span>&amp;</span> <span>&#34;,&#34;</span><span>)</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;]&#34;</span></code></pre></figure>

<p>This example doesn‚Äôt need <code>flat</code>, but <code>flat</code> comes in handy when we‚Äôre writing a
notation but don‚Äôt know what might appear inside of it. For example, if we‚Äôre
writing a notation for a <em>generic</em> list containing unknown notations <code>$X</code> and
<code>$Y</code>, the single-line layout would want to enforce that the things inside it
don‚Äôt span multiple lines. It could do so using <code>flat</code>:</p>

<figure><pre><code data-lang="bash"><span></span><span>&#34;[&#34;</span> <span>&amp;</span> flat<span>(</span><span>$X</span><span>)</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> <span>&#34; &#34;</span> <span>&amp;</span> flat<span>(</span><span>$Y</span><span>)</span> <span>&amp;</span> <span>&#34;]&#34;</span>
<span>|</span>
<span>&#34;[&#34;</span> <span>&amp;</span> indent<span>(</span><span>4</span>, nl <span>&amp;</span> <span>$X</span> <span>&amp;</span> <span>&#34;,&#34;</span> <span>&amp;</span> nl <span>&amp;</span> <span>$Y</span> <span>&amp;</span> <span>&#34;,&#34;</span><span>)</span> <span>&amp;</span> nl <span>&amp;</span> <span>&#34;]&#34;</span></code></pre></figure>

<h3 id="the-rule">The Rule</h3>

<p>With great power comes great responsibility. The choice <code>|</code> operator gives great
power, in that you can make a choice between arbitrary notations. But the
printer can‚Äôt feasibly check <em>all</em> exponentially many possibilities (remember
that choices can be deeply nested), so it must rely on the choices obeying a
rule.</p>

<p><strong>The Rule.</strong> In every choice <code>x | y</code>, the shortest possible first line of <code>y</code>
must be at least as short as <em>every</em> possible first line of <code>x</code>.</p>

<p>The printing algorithm, which I‚Äôll start describing soon, will rely on this
choice for correctly determining whether things fit on a line.</p>

<!--
When checking if things fit, if it encounters a choice `x | y`, it will _only_
examine `y`, by the reasoning that "if `x` would fit then `y` would too, so I
only need to look at `y`".
-->

<p>There‚Äôs another softer rule, which is that if you have a choice <code>x | y</code> then <code>x</code>
should not contain forced newlines. If you obey this rule, then <code>flat</code> does what
its name says and collapses the entire layout onto a single line. If you don‚Äôt
the printer will continue to work and <code>flat</code> will continue to pick the first
option, but that first option might span multiple lines.</p>

<h2 id="implementation">Implementation</h2>

<p>Let‚Äôs walk through a quick prototype of the printing algorithm in Rust. Then
we‚Äôll use it to print Json.</p>

<h3 id="dependencies">Dependencies</h3>

<p>We‚Äôll initialize a rust project with <code>cargo init --lib</code>, then add two
dependencies to <code>Cargo.toml</code>:</p>

<pre><code>[dependencies]
unicode-width = &#34;0.1.5&#34;

[dev-dependencies]
serde_json = &#34;1.0&#34;
</code></pre>

<ul>
  <li><code>unicode-width</code> is to get accurate string widths for monospaced terminal fonts
including full-width Unicode characters. I‚Äôm pretty sure this is an impossible
problem but we can at least try.</li>
  <li><code>serde_json</code> is for parsing Json. It‚Äôs only a dev-dependency because the
pretty printing library won‚Äôt rely on it. It‚Äôs only needed for the Json parser
we‚Äôll build on top of the library later.</li>
</ul>

<h3 id="srclibrs">src/lib.rs</h3>

<p>The library‚Äôs going to be split into two modules: one defines a data type for
notations, and the other gives the pretty printing algorithm:</p>

<figure><pre><code data-lang="rust"><span></span><span>mod</span> <span>notation</span><span>;</span><span></span>
<span>mod</span> <span>print</span><span>;</span><span></span>

<span>pub</span><span> </span><span>use</span><span> </span><span>notation</span>::<span>{</span><span>flat</span><span>,</span><span> </span><span>indent</span><span>,</span><span> </span><span>nl</span><span>,</span><span> </span><span>txt</span><span>,</span><span> </span><span>Notation</span><span>};</span><span></span>
<span>pub</span><span> </span><span>use</span><span> </span><span>print</span>::<span>pretty_print</span><span>;</span><span></span></code></pre></figure>

<p>You might notice that we didn‚Äôt export any operations for concat or choice. This
is because they‚Äôll be defined with the bitwise operators <code>&amp;</code> and <code>|</code>. (If you
really don‚Äôt like overloaded operators, feel free to write functions for these
instead. And then update the use sites, where you‚Äôll see how clunky it can get.)</p>

<h3 id="srcnotationrs">src/notation.rs</h3>

<p>The notation <code>enum</code> has exactly the operators described in this post, though
with a couple interesting details I‚Äôll discuss after showing the code:</p>

<figure><pre><code data-lang="rust"><span></span><span>use</span><span> </span><span>std</span>::<span>ops</span>::<span>{</span><span>BitAnd</span><span>,</span><span> </span><span>BitOr</span><span>};</span><span></span>
<span>use</span><span> </span><span>std</span>::<span>rc</span>::<span>Rc</span><span>;</span><span></span>

<span>#[derive(Debug, Clone)]</span><span></span>
<span>pub</span><span> </span><span>struct</span> <span>Notation</span><span>(</span><span>pub</span><span>(</span><span>crate</span><span>)</span><span> </span><span>Rc</span><span>&lt;</span><span>NotationInner</span><span>&gt;</span><span>);</span><span></span>

<span>#[derive(Debug, Clone)]</span><span></span>
<span>pub</span><span> </span><span>enum</span> <span>NotationInner</span><span> </span><span>{</span><span></span>
<span>    </span><span>Newline</span><span>,</span><span></span>
<span>    </span><span>Text</span><span>(</span><span>String</span><span>,</span><span> </span><span>u32</span><span>),</span><span></span>
<span>    </span><span>Flat</span><span>(</span><span>Notation</span><span>),</span><span></span>
<span>    </span><span>Indent</span><span>(</span><span>u32</span><span>,</span><span> </span><span>Notation</span><span>),</span><span></span>
<span>    </span><span>Concat</span><span>(</span><span>Notation</span><span>,</span><span> </span><span>Notation</span><span>),</span><span></span>
<span>    </span><span>Choice</span><span>(</span><span>Notation</span><span>,</span><span> </span><span>Notation</span><span>),</span><span></span>
<span>}</span><span></span>

<span>/// Display a newline</span>
<span>pub</span><span> </span><span>fn</span> <span>nl</span><span>()</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>Notation</span><span>(</span><span>Rc</span>::<span>new</span><span>(</span><span>NotationInner</span>::<span>Newline</span><span>))</span><span></span>
<span>}</span><span>  </span>

<span>/// Display text exactly as-is. The text should not contain a newline!</span>
<span>pub</span><span> </span><span>fn</span> <span>txt</span><span>(</span><span>s</span>: <span>impl</span><span> </span><span>ToString</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>string</span><span> </span><span>=</span><span> </span><span>s</span><span>.</span><span>to_string</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>width</span><span> </span><span>=</span><span> </span><span>unicode_width</span>::<span>UnicodeWidthStr</span>::<span>width</span><span>(</span><span>&amp;</span><span>string</span><span> </span><span>as</span><span> </span><span>&amp;</span><span>str</span><span>)</span><span> </span><span>as</span><span> </span><span>u32</span><span>;</span><span></span>
<span>    </span><span>Notation</span><span>(</span><span>Rc</span>::<span>new</span><span>(</span><span>NotationInner</span>::<span>Text</span><span>(</span><span>string</span><span>,</span><span> </span><span>width</span><span>)))</span><span></span>
<span>}</span><span></span>

<span>/// Use the leftmost option of every choice in the contained Notation.</span>
<span>/// If the contained Notation follows the recommendation of not</span>
<span>/// putting newlines in the left-most options of choices, then this</span>
<span>/// `flat` will be displayed all on one line.</span>
<span>pub</span><span> </span><span>fn</span> <span>flat</span><span>(</span><span>notation</span>: <span>Notation</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>Notation</span><span>(</span><span>Rc</span>::<span>new</span><span>(</span><span>NotationInner</span>::<span>Flat</span><span>(</span><span>notation</span><span>)))</span><span></span>
<span>}</span><span></span>

<span>/// Increase the indentation level of the contained notation by the</span>
<span>/// given width. The indentation level determines the number of spaces</span>
<span>/// put after `Newline`s. (It therefore doesn&#39;t affect the first line</span>
<span>/// of a notation.)</span>
<span>pub</span><span> </span><span>fn</span> <span>indent</span><span>(</span><span>indent</span>: <span>u32</span><span>,</span><span> </span><span>notation</span>: <span>Notation</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>Notation</span><span>(</span><span>Rc</span>::<span>new</span><span>(</span><span>NotationInner</span>::<span>Indent</span><span>(</span><span>indent</span><span>,</span><span> </span><span>notation</span><span>)))</span><span></span>
<span>}</span><span></span>

<span>impl</span><span> </span><span>BitAnd</span><span>&lt;</span><span>Notation</span><span>&gt;</span><span> </span><span>for</span><span> </span><span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>type</span> <span>Output</span><span> </span><span>=</span><span> </span><span>Notation</span><span>;</span><span></span>

<span>    </span><span>/// Display both notations. The first character of the right</span>
<span>    </span><span>/// notation immediately follows the last character of the</span>
<span>    </span><span>/// left notation.</span>
<span>    </span><span>fn</span> <span>bitand</span><span>(</span><span>self</span><span>,</span><span> </span><span>other</span>: <span>Notation</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>        </span><span>Notation</span><span>(</span><span>Rc</span>::<span>new</span><span>(</span><span>NotationInner</span>::<span>Concat</span><span>(</span><span>self</span><span>,</span><span> </span><span>other</span><span>)))</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span>

<span>impl</span><span> </span><span>BitOr</span><span>&lt;</span><span>Notation</span><span>&gt;</span><span> </span><span>for</span><span> </span><span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>type</span> <span>Output</span><span> </span><span>=</span><span> </span><span>Notation</span><span>;</span><span></span>

<span>    </span><span>/// If inside a `flat`, _or_ the first line of the left notation</span>
<span>    </span><span>/// fits within the required width, then display the left</span>
<span>    </span><span>/// notation. Otherwise, display the right notation.</span>
<span>    </span><span>fn</span> <span>bitor</span><span>(</span><span>self</span><span>,</span><span> </span><span>other</span>: <span>Notation</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>        </span><span>Notation</span><span>(</span><span>Rc</span>::<span>new</span><span>(</span><span>NotationInner</span>::<span>Choice</span><span>(</span><span>self</span><span>,</span><span> </span><span>other</span><span>)))</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>Sub-notations that are used in multiple places must be shared, so they‚Äôre stored
in an <code>Rc</code> (ref-counted). This sharing is very important: without it the notation
becomes exponentially larger.  For example, notice that the final ‚Äúhello world‚Äù
notation repeated ‚Äúhello‚Äù and ‚Äúworld‚Äù twice. If you start nesting notations like
this, these repetitions multiply together. So it‚Äôs important to share them by
having multiple references to the <em>same</em> notation on the heap, which is what
<code>Rc</code> does. Prettier was written in Haskell, which shares by default, so it
didn‚Äôt need anything like <code>Rc</code>.</p>

<p>The <code>Text</code> variant contains the width of the string in columns. It makes sense
to compute this up front because it will accessed multiple times when
determining whether things fit on a line.</p>

<details>
<summary>Dive into the rabbit hole of string widths.</summary>

The width of a string in a monospace font is different from how many
<em>bytes</em> it is, because `√°` is multiple bytes but width 1, and it&#39;s
different from the number of Unicode code points or grapheme clusters because
&#34;Êº¢&#34; is one character/code-point/grapheme-cluster but has width 2.
<p>
The model we&#39;re relying on here is: &#34;when you print characters in a monospace
font they&#39;ll all be printed in that font, that font will only contain
single-width and double-width glyphs, and these widths can be determined from
the character alone without knowing the OS, terminal, and installed Unicode
version&#34;. This model is false, but we&#39;ll pray it&#39;s sufficiently true to be
useful and that the `unicode_width` library does a good job at approximating it.
</p>
</details>

<h3 id="srcprintrs">src/print.rs</h3>

<p>Here‚Äôs the core algorithmic idea from Wadler. When printing a document, we‚Äôre
going to break it up into a stack of <em>chunks</em> containing everything we haven‚Äôt
yet printed. Each chunk keeps a reference to a notation, together with the
accumulated indentation at that notation and whether it‚Äôs inside a <code>flat</code>:</p>

<figure><pre><code data-lang="rust"><span></span><span>use</span><span> </span><span>crate</span>::<span>notation</span>::<span>{</span><span>Notation</span><span>,</span><span> </span><span>NotationInner</span><span>};</span><span></span>

<span>#[derive(Debug, Clone, Copy)]</span><span></span>
<span>struct</span> <span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>notation</span>: <span>&amp;</span><span>&#39;a</span><span> </span><span>Notation</span><span>,</span><span></span>
<span>    </span><span>indent</span>: <span>u32</span><span>,</span><span></span>
<span>    </span><span>flat</span>: <span>bool</span><span>,</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>A few methods for modifying chunks will come in handy later:</p>

<figure><pre><code data-lang="rust"><span></span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>fn</span> <span>with_notation</span><span>(</span><span>self</span><span>,</span><span> </span><span>notation</span>: <span>&amp;</span><span>&#39;a</span><span> </span><span>Notation</span><span>)</span><span> </span>-&gt; <span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>Chunk</span><span> </span><span>{</span><span></span>
<span>            </span><span>notation</span><span>,</span><span></span>
<span>            </span><span>indent</span>: <span>self</span><span>.</span><span>indent</span><span>,</span><span></span>
<span>            </span><span>flat</span>: <span>self</span><span>.</span><span>flat</span><span>,</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span>
<span>    </span><span>fn</span> <span>indented</span><span>(</span><span>self</span><span>,</span><span> </span><span>indent</span>: <span>u32</span><span>)</span><span> </span>-&gt; <span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>Chunk</span><span> </span><span>{</span><span></span>
<span>            </span><span>notation</span>: <span>self</span><span>.</span><span>notation</span><span>,</span><span></span>
<span>            </span><span>indent</span>: <span>self</span><span>.</span><span>indent</span><span> </span><span>+</span><span> </span><span>indent</span><span>,</span><span></span>
<span>            </span><span>flat</span>: <span>self</span><span>.</span><span>flat</span><span>,</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span>
<span>    </span><span>fn</span> <span>flat</span><span>(</span><span>self</span><span>)</span><span> </span>-&gt; <span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>Chunk</span><span> </span><span>{</span><span></span>
<span>            </span><span>notation</span>: <span>self</span><span>.</span><span>notation</span><span>,</span><span></span>
<span>            </span><span>indent</span>: <span>self</span><span>.</span><span>indent</span><span>,</span><span></span>
<span>            </span><span>flat</span>: <span>true</span><span>,</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>The printer needs just three things:</p>

<figure><pre><code data-lang="rust"><span></span><span>struct</span> <span>PrettyPrinter</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>/// Maximum line width that we&#39;ll try to stay within</span>
<span>    </span><span>width</span>: <span>u32</span><span>,</span><span></span>
<span>    </span><span>/// Current column position</span>
<span>    </span><span>col</span>: <span>u32</span><span>,</span><span></span>
<span>    </span><span>/// A stack of chunks to print. The _top_ of the stack is the</span>
<span>    </span><span>/// _end_ of the vector, which represents the _earliest_ part</span>
<span>    </span><span>/// of the document to print.</span>
<span>    </span><span>chunks</span>: <span>Vec</span><span>&lt;</span><span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;&gt;</span><span>,</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>To initialize a <code>Printer</code>, set the starting column to 0 and the chunk stack to
contain a single chunk whose notation represents the entire document to print:</p>

<figure><pre><code data-lang="rust"><span></span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>PrettyPrinter</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>fn</span> <span>new</span><span>(</span><span>notation</span>: <span>&amp;</span><span>&#39;a</span><span> </span><span>Notation</span><span>,</span><span> </span><span>width</span>: <span>u32</span><span>)</span><span> </span>-&gt; <span>PrettyPrinter</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>let</span><span> </span><span>chunk</span><span> </span><span>=</span><span> </span><span>Chunk</span><span> </span><span>{</span><span></span>
<span>            </span><span>notation</span><span>,</span><span></span>
<span>            </span><span>indent</span>: <span>0</span><span>,</span><span></span>
<span>            </span><span>flat</span>: <span>false</span><span>,</span><span></span>
<span>        </span><span>};</span><span></span>
<span>        </span><span>PrettyPrinter</span><span> </span><span>{</span><span></span>
<span>            </span><span>width</span><span>,</span><span></span>
<span>            </span><span>col</span>: <span>0</span><span>,</span><span></span>
<span>            </span><span>chunks</span>: <span>vec</span><span>!</span><span>[</span><span>chunk</span><span>],</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>Here‚Äôs the method for printing:</p>

<figure><pre><code data-lang="rust"><span></span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>PrettyPrinter</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>fn</span> <span>print</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span>-&gt; <span>String</span> <span>{</span><span></span>
<span>    </span><span>use</span><span> </span><span>NotationInner</span>::<span>*</span><span>;</span><span></span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>output</span><span> </span><span>=</span><span> </span><span>String</span>::<span>new</span><span>();</span><span></span>
<span>    </span><span>while</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>chunk</span><span>)</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>pop</span><span>()</span><span> </span><span>{</span><span></span>
<span>        </span><span>match</span><span> </span><span>chunk</span><span>.</span><span>notation</span><span>.</span><span>0.</span><span>as_ref</span><span>()</span><span> </span><span>{</span><span></span>
<span>            </span><span>Text</span><span>(</span><span>text</span><span>,</span><span> </span><span>width</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                </span><span>output</span><span>.</span><span>push_str</span><span>(</span><span>text</span><span>);</span><span></span>
<span>                </span><span>self</span><span>.</span><span>col</span><span> </span><span>+=</span><span> </span><span>width</span><span>;</span><span></span>
<span>            </span><span>}</span><span></span>
<span>            </span><span>Newline</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                </span><span>output</span><span>.</span><span>push</span><span>(</span><span>&#39;\n&#39;</span><span>);</span><span></span>
<span>                </span><span>for</span><span> </span><span>_</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>chunk</span><span>.</span><span>indent</span><span> </span><span>{</span><span></span>
<span>                    </span><span>output</span><span>.</span><span>push</span><span>(</span><span>&#39; &#39;</span><span>);</span><span></span>
<span>                </span><span>}</span><span></span>
<span>                </span><span>self</span><span>.</span><span>col</span><span> </span><span>=</span><span> </span><span>chunk</span><span>.</span><span>indent</span><span>;</span><span></span>
<span>            </span><span>}</span><span></span>
<span>            </span><span>Flat</span><span>(</span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span></span>
<span>                </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>).</span><span>flat</span><span>()),</span><span></span>
<span>            </span><span>Indent</span><span>(</span><span>i</span><span>,</span><span> </span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span></span>
<span>                </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>).</span><span>indented</span><span>(</span><span>*</span><span>i</span><span>)),</span><span></span>
<span>            </span><span>Concat</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>y</span><span>));</span><span></span>
<span>                </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>));</span><span></span>
<span>            </span><span>}</span><span></span>
<span>            </span><span>Choice</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                </span><span>if</span><span> </span><span>chunk</span><span>.</span><span>flat</span><span> </span><span>||</span><span> </span><span>self</span><span>.</span><span>fits</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>))</span><span> </span><span>{</span><span></span>
<span>                    </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>));</span><span></span>
<span>                </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>                    </span><span>self</span><span>.</span><span>chunks</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>y</span><span>));</span><span></span>
<span>                </span><span>}</span><span></span>
<span>            </span><span>}</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>output</span><span></span>
<span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>Walking through each case:</p>

<ul>
  <li><code>Text</code> prints the text and adds the text‚Äôs width to <code>col</code>.</li>
  <li><code>Newline</code> prints a newline, followed by spaces for the current indentation
level. It also updates <code>col</code>.</li>
  <li><code>Flat</code> and <code>Indent</code> set the chunk‚Äôs flat/indentation and push it back onto the
stack so that we‚Äôll recur on it.</li>
  <li><code>Concat(x, y)</code> splits the chunk into two chunks and pushes them onto the
stack. It has to push first <code>y</code> and then <code>x</code> so that <code>x</code> is on the top of the
stack and we process it next.</li>
  <li><code>Choice(x, y)</code> is the one interesting case. If we‚Äôre inside <code>flat</code>, we pick
<code>x</code>. Otherwise we pick <code>x</code> if it fits on the current line or <code>y</code> otherwise.
This calls <code>self.fits()</code> which does the hard work.</li>
</ul>

<p>The <code>fits</code> method is where the sausage gets made. We‚Äôre going to essentially
scan ahead to see whether things will fit on the current line, but there are
some important details.</p>

<figure><pre><code data-lang="rust"><span></span><span>impl</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>PrettyPrinter</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>fn</span> <span>fits</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>chunk</span>: <span>Chunk</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span>)</span><span> </span>-&gt; <span>bool</span> <span>{</span><span></span>
<span>        </span><span>use</span><span> </span><span>NotationInner</span>::<span>*</span><span>;</span><span></span>
<span>  </span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>remaining</span><span> </span><span>=</span><span> </span><span>if</span><span> </span><span>self</span><span>.</span><span>col</span><span> </span><span>&lt;=</span><span> </span><span>self</span><span>.</span><span>width</span><span> </span><span>{</span><span>         </span>
<span>            </span><span>self</span><span>.</span><span>width</span><span> </span><span>-</span><span> </span><span>self</span><span>.</span><span>col</span><span></span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>            </span><span>return</span><span> </span><span>false</span><span>;</span><span></span>
<span>        </span><span>};</span><span></span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>stack</span><span> </span><span>=</span><span> </span><span>vec</span><span>!</span><span>[</span><span>chunk</span><span>];</span><span></span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>chunks</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>chunks</span><span> </span><span>as</span><span> </span><span>&amp;</span><span>[</span><span>Chunk</span><span>];</span><span></span>

<span>        </span><span>loop</span><span> </span><span>{</span><span></span>
<span>            </span><span>let</span><span> </span><span>chunk</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>stack</span><span>.</span><span>pop</span><span>()</span><span> </span><span>{</span><span></span>
<span>                </span><span>Some</span><span>(</span><span>chunk</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>chunk</span><span>,</span><span></span>
<span>                </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>match</span><span> </span><span>chunks</span><span>.</span><span>split_last</span><span>()</span><span> </span><span>{</span><span></span>
<span>                    </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>true</span><span>,</span><span></span>
<span>                    </span><span>Some</span><span>((</span><span>chunk</span><span>,</span><span> </span><span>more_chunks</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                        </span><span>chunks</span><span> </span><span>=</span><span> </span><span>more_chunks</span><span>;</span><span></span>
<span>                        </span><span>*</span><span>chunk</span><span></span>
<span>                    </span><span>}</span><span></span>
<span>                </span><span>},</span><span></span>
<span>            </span><span>};</span><span></span>

<span>            </span><span>match</span><span> </span><span>chunk</span><span>.</span><span>notation</span><span>.</span><span>0.</span><span>as_ref</span><span>()</span><span> </span><span>{</span><span></span>
<span>                </span><span>Newline</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>true</span><span>,</span><span></span>
<span>                </span><span>Text</span><span>(</span><span>_text</span><span>,</span><span> </span><span>text_width</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                    </span><span>if</span><span> </span><span>*</span><span>text_width</span><span> </span><span>&lt;=</span><span> </span><span>remaining</span><span> </span><span>{</span><span></span>
<span>                        </span><span>remaining</span><span> </span><span>-=</span><span> </span><span>*</span><span>text_width</span><span>;</span><span></span>
<span>                    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>                        </span><span>return</span><span> </span><span>false</span><span>;</span><span></span>
<span>                    </span><span>}</span><span></span>
<span>                </span><span>}</span><span></span>
<span>                </span><span>Flat</span><span>(</span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>).</span><span>flat</span><span>()),</span><span></span>
<span>                </span><span>Indent</span><span>(</span><span>i</span><span>,</span><span> </span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span></span>
<span>                    </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>).</span><span>indented</span><span>(</span><span>*</span><span>i</span><span>)),</span><span></span>
<span>                </span><span>Concat</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                    </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>y</span><span>));</span><span></span>
<span>                    </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>));</span><span></span>
<span>                </span><span>}</span><span></span>
<span>                </span><span>Choice</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                    </span><span>if</span><span> </span><span>chunk</span><span>.</span><span>flat</span><span> </span><span>{</span><span></span>
<span>                        </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>));</span><span></span>
<span>                    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>                        </span><span>// Relies on the rule that for every choice</span>
<span>                        </span><span>// `x | y`, the first line of `y` is no longer</span>
<span>                        </span><span>// than the first line of `x`.</span>
<span>                        </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>y</span><span>));</span><span></span>
<span>                    </span><span>}</span><span></span>
<span>                </span><span>}</span><span></span>
<span>            </span><span>}</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>Let‚Äôs walk through this piece by piece.</p>

<p>The amount of space remaining on the current line is the max line width
<code>self.width</code> minus the current column <code>self.col</code>, though if we‚Äôre already
past the width limit we can return <code>false</code> because things really don‚Äôt fit.</p>

<figure><pre><code data-lang="rust"><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>remaining</span><span> </span><span>=</span><span> </span><span>if</span><span> </span><span>self</span><span>.</span><span>col</span><span> </span><span>&lt;=</span><span> </span><span>self</span><span>.</span><span>width</span><span> </span><span>{</span><span>         </span>
<span>    </span><span>self</span><span>.</span><span>width</span><span> </span><span>-</span><span> </span><span>self</span><span>.</span><span>col</span><span></span>
<span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>false</span><span>;</span><span></span>
<span>};</span><span></span></code></pre></figure>

<p>Just like in <code>print()</code>, we want to keep a stack of chunks to process. Though now
we‚Äôre just going to scan ahead to see if stuff fits on the current line, without
actually printing anything. We therefore don‚Äôt want to modify <code>self.chunks</code>
because modifications should not persist after the <code>fits()</code> method finishes.
<em>However</em>, we don‚Äôt want to copy <code>self.chunks</code> because that would be
inefficient. So instead we‚Äôll keep a working stack called <code>stack</code> and a
reference to the <code>self.chunks</code> that we haven‚Äôt yet processed called <code>chunks</code>:</p>

<figure><pre><code data-lang="rust"><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>stack</span><span> </span><span>=</span><span> </span><span>vec</span><span>!</span><span>[</span><span>chunk</span><span>];</span><span></span>
<span>let</span><span> </span><span>mut</span><span> </span><span>chunks</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>self</span><span>.</span><span>chunks</span><span> </span><span>as</span><span> </span><span>&amp;</span><span>[</span><span>Chunk</span><span>];</span><span></span></code></pre></figure>

<p>The first thing the loop will do is ‚Äúget the next chunk‚Äù. Since there are two
places it might come from this is a little complicated, but all this code
says is ‚Äútake a chunk from the <code>stack</code>, or if that‚Äôs empty take it from
<code>chunks</code>, or if that‚Äôs empty too return <code>true</code>‚Äù:</p>

<figure><pre><code data-lang="rust"><span></span><span>loop</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>chunk</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>stack</span><span>.</span><span>pop</span><span>()</span><span> </span><span>{</span><span></span>
<span>        </span><span>Some</span><span>(</span><span>chunk</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>chunk</span><span>,</span><span></span>
<span>        </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>match</span><span> </span><span>chunks</span><span>.</span><span>split_last</span><span>()</span><span> </span><span>{</span><span></span>
<span>            </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>true</span><span>,</span><span></span>
<span>            </span><span>Some</span><span>((</span><span>chunk</span><span>,</span><span> </span><span>more_chunks</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>                </span><span>chunks</span><span> </span><span>=</span><span> </span><span>more_chunks</span><span>;</span><span></span>
<span>                </span><span>*</span><span>chunk</span><span></span>
<span>            </span><span>}</span><span></span>
<span>        </span><span>},</span><span></span>
<span>    </span><span>};</span><span></span></code></pre></figure>

<p>Then the body of the loop processes the chunk to check whether it fits on the
line:</p>

<figure><pre><code data-lang="rust"><span></span><span>match</span><span> </span><span>chunk</span><span>.</span><span>notation</span><span>.</span><span>0.</span><span>as_ref</span><span>()</span><span> </span><span>{</span><span></span>
<span>    </span><span>Newline</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span> </span><span>true</span><span>,</span><span></span>
<span>    </span><span>Text</span><span>(</span><span>_text</span><span>,</span><span> </span><span>text_width</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>if</span><span> </span><span>*</span><span>text_width</span><span> </span><span>&lt;=</span><span> </span><span>remaining</span><span> </span><span>{</span><span></span>
<span>            </span><span>remaining</span><span> </span><span>-=</span><span> </span><span>*</span><span>text_width</span><span>;</span><span></span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>            </span><span>return</span><span> </span><span>false</span><span>;</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>Flat</span><span>(</span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>).</span><span>flat</span><span>()),</span><span></span>
<span>    </span><span>Indent</span><span>(</span><span>i</span><span>,</span><span> </span><span>x</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>).</span><span>indented</span><span>(</span><span>*</span><span>i</span><span>)),</span><span></span>
<span>    </span><span>Concat</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>y</span><span>));</span><span></span>
<span>        </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>));</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>Choice</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>        </span><span>if</span><span> </span><span>chunk</span><span>.</span><span>flat</span><span> </span><span>{</span><span></span>
<span>            </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>x</span><span>));</span><span></span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>            </span><span>// Relies on the rule that for every choice</span>
<span>            </span><span>// `x | y`, the first line of `y` is no longer</span>
<span>            </span><span>// than the first line of `x`.</span>
<span>            </span><span>stack</span><span>.</span><span>push</span><span>(</span><span>chunk</span><span>.</span><span>with_notation</span><span>(</span><span>y</span><span>));</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<ul>
  <li>If we hit a newline, there‚Äôs nothing more on the line so things must have fit
and we can return <code>true</code>.</li>
  <li>When we encounter <code>Text</code>, we check if it fits in the remaining space. If it
does, we subtract its width from the remaining space. If it doesn‚Äôt, we
return <code>false</code>.</li>
  <li>We handle <code>Flat</code>, <code>Indent</code>, and <code>Concat</code> just like in the <code>print()</code> method,
though here we‚Äôre pushing to <code>stack</code> instead of <code>self.chunks</code>.</li>
  <li>The <code>Choice(x, y)</code> case is the crux of the whole algorithm. When we encounter
this choice, it means that we were <em>already checking whether the first option
of a choice fits on the current line</em>, because that‚Äôs the only situation where
<code>fits()</code> is invoked.  While doing so, we started looking ahead and encountered
this <em>second</em> choice <code>Choice(x, y)</code>.  There might be a tradeoff between these two
choices: perhaps either one can fit on one line but not both at once. We are
<em>greedily</em> resolving this tradeoff in favor of the first choice, by asking
whether there‚Äôs <em>any</em> way the second choice can be resolved such that the
first choice fits on the line.  This is where The Rule comes in! We ignore <code>x</code>
and only check <code>y</code>, by the reasoning that ‚Äúif <code>y</code> doesn‚Äôt fit, then <code>x</code>
wouldn‚Äôt fit either, so it‚Äôs safe to only check if <code>y</code> fits.‚Äù</li>
</ul>

<p>And that‚Äôs it! That‚Äôs the whole printer.</p>

<h3 id="examplesjsonrs">examples/json.rs</h3>

<p>To test our newly completed pretty printing library, let‚Äôs add an example usage
in <code>example/json.rs</code> for printing Json. It will give functions for constructing
<code>Notation</code>s for each kind of Json value (null, number, list, etc.):</p>

<figure><pre><code data-lang="rust"><span></span><span>use</span><span> </span><span>pretty</span>::<span>{</span><span>flat</span><span>,</span><span> </span><span>indent</span><span>,</span><span> </span><span>nl</span><span>,</span><span> </span><span>pretty_print</span><span>,</span><span> </span><span>txt</span><span>,</span><span> </span><span>Notation</span><span>};</span><span></span>

<span>pub</span><span> </span><span>fn</span> <span>json_null</span><span>()</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>txt</span><span>(</span><span>&#34;null&#34;</span><span>)</span><span></span>
<span>}</span><span></span>

<span>pub</span><span> </span><span>fn</span> <span>json_bool</span><span>(</span><span>b</span>: <span>bool</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>b</span><span> </span><span>{</span><span></span>
<span>        </span><span>txt</span><span>(</span><span>&#34;true&#34;</span><span>)</span><span></span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>        </span><span>txt</span><span>(</span><span>&#34;false&#34;</span><span>)</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span>

<span>pub</span><span> </span><span>fn</span> <span>json_string</span><span>(</span><span>s</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>// TODO: escape sequences</span>
<span>    </span><span>txt</span><span>(</span><span>format</span><span>!</span><span>(</span><span>&#34;</span><span>\&#34;</span><span>{}</span><span>\&#34;</span><span>&#34;</span><span>,</span><span> </span><span>s</span><span>))</span><span></span>
<span>}</span><span></span>

<span>pub</span><span> </span><span>fn</span> <span>json_number</span><span>(</span><span>n</span>: <span>impl</span><span> </span><span>ToString</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>txt</span><span>(</span><span>n</span><span>)</span><span></span>
<span>}</span><span></span>

<span>fn</span> <span>comma_sep_single_line</span><span>(</span><span>elems</span>: <span>&amp;</span><span>[</span><span>Notation</span><span>])</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>list</span><span> </span><span>=</span><span> </span><span>flat</span><span>(</span><span>elems</span><span>[</span><span>0</span><span>].</span><span>clone</span><span>());</span><span></span>
<span>    </span><span>for</span><span> </span><span>elem</span><span> </span><span>in</span><span> </span><span>&amp;</span><span>elems</span><span>[</span><span>1</span><span>..]</span><span> </span><span>{</span><span></span>
<span>        </span><span>list</span><span> </span><span>=</span><span> </span><span>list</span><span> </span><span>&amp;</span><span> </span><span>txt</span><span>(</span><span>&#34;, &#34;</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>flat</span><span>(</span><span>elem</span><span>.</span><span>clone</span><span>());</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>list</span><span></span>
<span>}</span><span></span>

<span>fn</span> <span>comma_sep_multi_line</span><span>(</span><span>elems</span>: <span>&amp;</span><span>[</span><span>Notation</span><span>])</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>list</span><span> </span><span>=</span><span> </span><span>elems</span><span>[</span><span>0</span><span>].</span><span>clone</span><span>();</span><span></span>
<span>    </span><span>for</span><span> </span><span>elem</span><span> </span><span>in</span><span> </span><span>&amp;</span><span>elems</span><span>[</span><span>1</span><span>..]</span><span> </span><span>{</span><span></span>
<span>        </span><span>list</span><span> </span><span>=</span><span> </span><span>list</span><span> </span><span>&amp;</span><span> </span><span>txt</span><span>(</span><span>&#34;, &#34;</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>nl</span><span>()</span><span> </span><span>&amp;</span><span> </span><span>elem</span><span>.</span><span>clone</span><span>();</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>list</span><span></span>
<span>}</span><span></span>

<span>fn</span> <span>surrounded</span><span>(</span><span>open</span>: <span>&amp;</span><span>str</span><span>,</span><span> </span><span>elems</span>: <span>&amp;</span><span>[</span><span>Notation</span><span>],</span><span> </span><span>closed</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>if</span><span> </span><span>elems</span><span>.</span><span>is_empty</span><span>()</span><span> </span><span>{</span><span></span>
<span>        </span><span>return</span><span> </span><span>txt</span><span>(</span><span>open</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>txt</span><span>(</span><span>closed</span><span>);</span><span></span>
<span>    </span><span>}</span><span></span>

<span>    </span><span>let</span><span> </span><span>single_line</span><span> </span><span>=</span><span> </span><span>txt</span><span>(</span><span>open</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>comma_sep_single_line</span><span>(</span><span>elems</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>txt</span><span>(</span><span>closed</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>multi_line</span><span> </span><span>=</span><span> </span><span>txt</span><span>(</span><span>open</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>indent</span><span>(</span><span>4</span><span>,</span><span> </span><span>nl</span><span>()</span><span> </span><span>&amp;</span><span> </span><span>comma_sep_multi_line</span><span>(</span><span>elems</span><span>))</span><span> </span><span>&amp;</span><span> </span><span>nl</span><span>()</span><span> </span><span>&amp;</span><span> </span><span>txt</span><span>(</span><span>closed</span><span>);</span><span></span>
<span>    </span><span>single_line</span><span> </span><span>|</span><span> </span><span>multi_line</span><span></span>
<span>}</span><span></span>

<span>pub</span><span> </span><span>fn</span> <span>json_array</span><span>(</span><span></span>
<span>    </span><span>elems</span>: <span>impl</span><span> </span><span>IntoIterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>Notation</span><span>&gt;</span><span></span>
<span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>elems</span><span> </span><span>=</span><span> </span><span>elems</span><span>.</span><span>into_iter</span><span>().</span><span>collect</span>::<span>&lt;</span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;&gt;</span><span>();</span><span></span>
<span>    </span><span>surrounded</span><span>(</span><span>&#34;[&#34;</span><span>,</span><span> </span><span>&amp;</span><span>elems</span><span>,</span><span> </span><span>&#34;]&#34;</span><span>)</span><span></span>
<span>}</span><span></span>

<span>fn</span> <span>json_object_entry</span><span>(</span><span>key</span>: <span>String</span><span>,</span><span> </span><span>value</span>: <span>Notation</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>json_string</span><span>(</span><span>&amp;</span><span>key</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>txt</span><span>(</span><span>&#34;: &#34;</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>value</span><span></span>
<span>}</span><span></span>

<span>pub</span><span> </span><span>fn</span> <span>json_object</span><span>(</span><span></span>
<span>    </span><span>entries</span>: <span>impl</span><span> </span><span>IntoIterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>(</span><span>String</span><span>,</span><span> </span><span>Notation</span><span>)</span><span>&gt;</span><span></span>
<span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>entries</span><span> </span><span>=</span><span> </span><span>entries</span><span></span>
<span>        </span><span>.</span><span>into_iter</span><span>()</span><span></span>
<span>        </span><span>.</span><span>map</span><span>(</span><span>|</span><span>(</span><span>key</span><span>,</span><span> </span><span>val</span><span>)</span><span>|</span><span> </span><span>json_object_entry</span><span>(</span><span>key</span><span>,</span><span> </span><span>val</span><span>))</span><span></span>
<span>        </span><span>.</span><span>collect</span>::<span>&lt;</span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;&gt;</span><span>();</span><span></span>
<span>    </span><span>surrounded</span><span>(</span><span>&#34;{&#34;</span><span>,</span><span> </span><span>&amp;</span><span>entries</span><span>,</span><span> </span><span>&#34;}&#34;</span><span>)</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>We could call these methods manually:</p>

<figure><pre><code data-lang="rust"><span></span><span>json_array</span><span>([</span><span>json_string</span><span>(</span><span>&#34;hello&#34;</span><span>),</span><span> </span><span>json_string</span><span>(</span><span>&#34;world&#34;</span><span>)])</span><span></span></code></pre></figure>

<p>but it would be tedious to build a large enough example to be interesting.</p>

<p>Instead let‚Äôs make a Json code formatter that uses <code>serde_json</code> to parse Json
and then re-prints it with our pretty printer. <code>serde_json</code> has a representation
of <code>Json</code> called <code>serde_json::Value</code>. We‚Äôll need a function to convert that to a
<code>Notation</code>:</p>

<figure><pre><code data-lang="rust"><span></span><span>fn</span> <span>json_to_notation</span><span>(</span><span>json</span>: <span>serde_json</span>::<span>Value</span><span>)</span><span> </span>-&gt; <span>Notation</span><span> </span><span>{</span><span></span>
<span>    </span><span>use</span><span> </span><span>serde_json</span>::<span>Value</span>::<span>{</span><span>Array</span><span>,</span><span> </span><span>Bool</span><span>,</span><span> </span><span>Null</span><span>,</span><span> </span><span>Number</span><span>,</span><span> </span><span>Object</span><span>,</span><span> </span><span>String</span><span>};</span><span></span>

<span>    </span><span>match</span><span> </span><span>json</span><span> </span><span>{</span><span></span>
<span>        </span><span>Null</span><span> </span><span>=&gt;</span><span> </span><span>json_null</span><span>(),</span><span></span>
<span>        </span><span>Bool</span><span>(</span><span>b</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>json_bool</span><span>(</span><span>b</span><span>),</span><span></span>
<span>        </span><span>Number</span><span>(</span><span>n</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>json_number</span><span>(</span><span>n</span><span>),</span><span></span>
<span>        </span><span>String</span><span>(</span><span>s</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>json_string</span><span>(</span><span>&amp;</span><span>s</span><span>),</span><span></span>
<span>        </span><span>Array</span><span>(</span><span>elems</span><span>)</span><span> </span><span>=&gt;</span><span></span>
<span>            </span><span>json_array</span><span>(</span><span>elems</span><span>.</span><span>into_iter</span><span>().</span><span>map</span><span>(</span><span>json_to_notation</span><span>)),</span><span></span>
<span>        </span><span>Object</span><span>(</span><span>entries</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>json_object</span><span>(</span><span></span>
<span>            </span><span>entries</span><span></span>
<span>                </span><span>.</span><span>into_iter</span><span>()</span><span></span>
<span>                </span><span>.</span><span>map</span><span>(</span><span>|</span><span>(</span><span>key</span><span>,</span><span> </span><span>val</span><span>)</span><span>|</span><span> </span><span>(</span><span>key</span><span>,</span><span> </span><span>json_to_notation</span><span>(</span><span>val</span><span>))),</span><span></span>
<span>        </span><span>),</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>And now we can glue everything together to re-format a Json file. Let‚Äôs record
timing info to tell how long each phase takes:</p>

<figure><pre><code data-lang="rust"><span></span><span>const</span><span> </span><span>WIDTH</span>: <span>u32</span> <span>=</span><span> </span><span>120</span><span>;</span><span></span>

<span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>    </span><span>use</span><span> </span><span>std</span>::<span>env</span><span>;</span><span></span>
<span>    </span><span>use</span><span> </span><span>std</span>::<span>fs</span>::<span>File</span><span>;</span><span></span>
<span>    </span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>BufReader</span><span>;</span><span></span>
<span>    </span><span>use</span><span> </span><span>std</span>::<span>time</span>::<span>Instant</span><span>;</span><span></span>

<span>    </span><span>// Get the filename to parse from the command line args</span>
<span>    </span><span>let</span><span> </span><span>env_args</span><span> </span><span>=</span><span> </span><span>env</span>::<span>args</span><span>().</span><span>collect</span>::<span>&lt;</span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;&gt;</span><span>();</span><span></span>
<span>    </span><span>if</span><span> </span><span>env_args</span><span>.</span><span>len</span><span>()</span><span> </span><span>!=</span><span> </span><span>2</span><span> </span><span>{</span><span></span>
<span>        </span><span>panic</span><span>!</span><span>(</span><span>&#34;Usage: cargo run --release --example json FILENAME.json&#34;</span><span>);</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>let</span><span> </span><span>filename</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>env_args</span><span>[</span><span>1</span><span>];</span><span></span>

<span>    </span><span>// Parse the file into json using serde</span>
<span>    </span><span>let</span><span> </span><span>start</span><span> </span><span>=</span><span> </span><span>Instant</span>::<span>now</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>file</span><span> </span><span>=</span><span> </span><span>File</span>::<span>open</span><span>(</span><span>filename</span><span>).</span><span>unwrap</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>reader</span><span> </span><span>=</span><span> </span><span>BufReader</span>::<span>new</span><span>(</span><span>file</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>json</span><span> </span><span>=</span><span> </span><span>serde_json</span>::<span>from_reader</span><span>(</span><span>reader</span><span>).</span><span>unwrap</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>ms_to_parse</span><span> </span><span>=</span><span> </span><span>start</span><span>.</span><span>elapsed</span><span>().</span><span>as_millis</span><span>();</span><span></span>

<span>    </span><span>// Convert it to a Notation</span>
<span>    </span><span>let</span><span> </span><span>start</span><span> </span><span>=</span><span> </span><span>Instant</span>::<span>now</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>notation</span><span> </span><span>=</span><span> </span><span>json_to_notation</span><span>(</span><span>json</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>ms_to_construct</span><span> </span><span>=</span><span> </span><span>start</span><span>.</span><span>elapsed</span><span>().</span><span>as_millis</span><span>();</span><span></span>

<span>    </span><span>// Pretty print the Notation</span>
<span>    </span><span>let</span><span> </span><span>start</span><span> </span><span>=</span><span> </span><span>Instant</span>::<span>now</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>output</span><span> </span><span>=</span><span> </span><span>pretty_print</span><span>(</span><span>&amp;</span><span>notation</span><span>,</span><span> </span><span>WIDTH</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>ms_to_pretty_print</span><span> </span><span>=</span><span> </span><span>start</span><span>.</span><span>elapsed</span><span>().</span><span>as_millis</span><span>();</span><span></span>

<span>    </span><span>// Print it to the terminal</span>
<span>    </span><span>let</span><span> </span><span>start</span><span> </span><span>=</span><span> </span><span>Instant</span>::<span>now</span><span>();</span><span></span>
<span>    </span><span>println</span><span>!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>output</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>ms_to_output</span><span> </span><span>=</span><span> </span><span>start</span><span>.</span><span>elapsed</span><span>().</span><span>as_millis</span><span>();</span><span></span>

<span>    </span><span>// Print timing info to stderr</span>
<span>    </span><span>eprintln</span><span>!</span><span>(</span><span>&#34;Time to parse file as Json:    {} ms&#34;</span><span>,</span><span> </span><span>ms_to_parse</span><span>);</span><span></span>
<span>    </span><span>eprintln</span><span>!</span><span>(</span><span>&#34;Time to construct Notation:    {} ms&#34;</span><span>,</span><span> </span><span>ms_to_construct</span><span>);</span><span></span>
<span>    </span><span>eprintln</span><span>!</span><span>(</span><span>&#34;Time to pretty print Notation: {} ms&#34;</span><span>,</span><span> </span><span>ms_to_pretty_print</span><span>);</span><span></span>
<span>    </span><span>eprintln</span><span>!</span><span>(</span><span>&#34;Time to print to terminal:     {} ms&#34;</span><span>,</span><span> </span><span>ms_to_output</span><span>);</span><span></span>
<span>}</span><span></span></code></pre></figure>

<p>Running this on a big Json file of Pok√©mon on my laptop:</p>

<figure><pre><code data-lang="bash"><span></span>cargo run --release --example json pokemon.json</code></pre></figure>

<p>gives:</p>

<pre><code><small><small>{
    &#34;abilities&#34;: [
        {
            &#34;ability&#34;: {&#34;name&#34;: &#34;overgrow&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/ability/65/&#34;}, 
            &#34;is_hidden&#34;: false, 
            &#34;slot&#34;: 1
        }, 
        {
            &#34;ability&#34;: {&#34;name&#34;: &#34;chlorophyll&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/ability/34/&#34;}, 
            &#34;is_hidden&#34;: true, 
            &#34;slot&#34;: 3
        }
    ], 
    &#34;base_experience&#34;: 64, 
    &#34;cries&#34;: {
        &#34;latest&#34;: &#34;https://raw.githubusercontent.com/PokeAPI/cries/main/cries/pokemon/latest/1.ogg&#34;, 
        &#34;legacy&#34;: &#34;https://raw.githubusercontent.com/PokeAPI/cries/main/cries/pokemon/legacy/1.ogg&#34;
    },
    &#34;forms&#34;: [{&#34;name&#34;: &#34;bulbasaur&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/pokemon-form/1/&#34;}], 
    &#34;game_indices&#34;: [
        {&#34;game_index&#34;: 153, &#34;version&#34;: {&#34;name&#34;: &#34;red&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version/1/&#34;}}, 
        {&#34;game_index&#34;: 153, &#34;version&#34;: {&#34;name&#34;: &#34;blue&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version/2/&#34;}}, 
        {&#34;game_index&#34;: 153, &#34;version&#34;: {&#34;name&#34;: &#34;yellow&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version/3/&#34;}}, 
        {&#34;game_index&#34;: 1, &#34;version&#34;: {&#34;name&#34;: &#34;gold&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version/4/&#34;}}, 
        ...
        {&#34;game_index&#34;: 1, &#34;version&#34;: {&#34;name&#34;: &#34;white-2&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version/22/&#34;}}
    ], 
    &#34;height&#34;: 7, 
    &#34;held_items&#34;: [], 
    &#34;id&#34;: 1,    
    &#34;is_default&#34;: true, 
    &#34;location_area_encounters&#34;: &#34;https://pokeapi.co/api/v2/pokemon/1/encounters&#34;, 
    &#34;moves&#34;: [
        {
            &#34;move&#34;: {&#34;name&#34;: &#34;razor-wind&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/move/13/&#34;}, 
            &#34;version_group_details&#34;: [
                {
                    &#34;level_learned_at&#34;: 0, 
                    &#34;move_learn_method&#34;: {&#34;name&#34;: &#34;egg&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/move-learn-method/2/&#34;}, 
                    &#34;version_group&#34;: {&#34;name&#34;: &#34;gold-silver&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version-group/3/&#34;}
                }, 
                {
                    &#34;level_learned_at&#34;: 0, 
                    &#34;move_learn_method&#34;: {&#34;name&#34;: &#34;egg&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/move-learn-method/2/&#34;}, 
                    &#34;version_group&#34;: {&#34;name&#34;: &#34;crystal&#34;, &#34;url&#34;: &#34;https://pokeapi.co/api/v2/version-group/4/&#34;}
                }
            ]
        },
...
6737 lines of Json
...
Time to parse file as Json:    2 ms
Time to construct Notation:    8 ms
Time to pretty print Notation: 2 ms
Time to print to terminal:     36 ms
</small></small></code></pre>

<p>(This is printed at width 120 to make the output more interesting by having more
things fit on a line, then hackily squeezed into my website‚Äôs rather narrow code
blocks.)</p>

<p>So:</p>

<ul>
  <li>Only 2ms to parse the file. <code>serde_json</code> is fast.</li>
  <li>It takes longer to construct the <code>Notation</code> than to print it! I suspect that
most of the time comes from the <code>Rc</code>s. There are faster techniques for
sharing, but they‚Äôre pretty heavy handed so I won‚Äôt show them here. But here‚Äôs
a branch that does
<a href="https://github.com/justinpombrio/experiments/compare/main...typed-arena">arena allocation</a>.</li>
  <li>The parsing and printing together is much faster than outputting to the
terminal.</li>
</ul>

<p>So there it is: a fairly simple, fairly fast, fairly expressive pretty printer.
It‚Äôs Wadler‚Äôs Prettier Printer, with a twist.</p>

<p>The full code is <a href="https://github.com/justinpombrio/experiments/tree/main/pretty">on Github</a>.</p>

<h3 id="citations">Citations</h3>

<p>[1] Philip Wadler. ‚ÄúA Prettier Printer‚Äù. The Fun of Programming, Cornerstones of
Computing, 2003. <a href="https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf">link</a>.</p>

<p>[2] Christian Lindig. ‚ÄúStrictly Pretty‚Äù. Informally published, 2000.
<a href="https://lindig.github.io/papers/strictly-pretty-2000.pdf">Link</a>.</p>

<p>
February 23, 2024
<a href="https://justinpombrio.net/feed.xml"><img width="16rem" src="https://justinpombrio.net/src/img/rss.png"/></a>
</p>
</div></div>
  </body>
</html>
