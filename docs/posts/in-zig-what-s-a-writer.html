<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.openmymind.net/In-Zig-Whats-a-Writer/">Original</a>
    <h1>In Zig, what&#39;s a writer?</h1>
    
    <div id="readability-page-1" class="page"><article>
  
  
  
<p>I find Zig&#39;s idea of a &#34;writer&#34; confusing. This is probably because there are three different types, each trying to compensate for compromises made by the others. Let&#39;s try to understand what each is and how it fits into a bigger whole.</p>

<h3 id="anytype"><a href="#anytype" aria-hidden="true">writer: anytype</a></h3>
<p>The first writer that you&#39;re likely to run into is a <code>writer: anytype</code>, with the most visible cases found in the <code>std.fmt</code> package, i.e. <code>std.fmt.print</code>.</p>

<p>I&#39;ve written about <a href="https://disk.horse/learning_zig/coding_in_zig/#anytype">anytype</a> before. As a quick recap, think of it as a template. For example, if we have this code:</p>

<pre><code><span>fn</span> <span>writeN</span><span>(</span>writer<span>:</span> <span>anytype</span><span>,</span> data<span>:</span> <span>[</span><span>]</span>cont <span>u8</span><span>,</span> n<span>:</span> <span><span>usize</span></span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
    <span>var</span> i<span>:</span> <span><span>usize</span></span> <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>i <span>&lt;</span> n<span>)</span> <span>:</span> <span>(</span>i <span>+=</span> <span>1</span><span>)</span> <span>{</span>
        <span>try</span> writer<span>.</span><span>writeAll</span><span>(</span>data<span>)</span>
    <span>}</span>
<span>}</span></code></pre>

<p>A copy of this function will be created for every type of <code>writer</code> that is used. Given this invocation:</p>

<pre><code><span>var</span> logger <span>=</span> <span>MyLogger</span><span>{</span><span>}</span><span>;</span>
<span>try</span> <span>writeN</span><span>(</span>logger<span>,</span> <span>&#34;.&#34;</span><span>,</span> <span>10</span><span>)</span><span>;</span></code></pre>

<p>We&#39;d end up with this copy of <code>writeN</code>:</p>

<pre><code>
<span>fn</span> <span>writeN</span><span>(</span>writer<span>:</span> <span>MyLogger</span><span>,</span> data<span>:</span> <span>[</span><span>]</span>cont <span>u8</span><span>,</span> n<span>:</span> <span><span>usize</span></span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
    <span>var</span> i<span>:</span> <span><span>usize</span></span> <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>i <span>&lt;</span> n<span>)</span> <span>:</span> <span>(</span>i <span>+=</span> <span>1</span><span>)</span> <span>{</span>
        <span>try</span> writer<span>.</span><span>writeAll</span><span>(</span>data<span>)</span>
    <span>}</span>
<span>}</span></code></pre>

<p>If <code>MyLogger</code> didn&#39;t implement the necessary <code>writeAll([]const u8) !void</code> method, we&#39;d get a compiler error - just like we&#39;d expect if we wrote the <code>writeN(writer: MyLogger, ...)</code> function ourselves.</p>

<p><code>anytype</code> is super useful and has zero runtime overhead. But there are a few downsides. First, it can make binaries larger and compilation slower. In most cases, there&#39;s ever only one or maybe a few different types that are used, so, it isn&#39;t an issue. Second, it&#39;s a documentation black hole. A function that takes a <code>writer: anytype</code> likely expects one or many of the following methods:</p>

<pre><code><span>write</span><span>(</span>data<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>)</span> <span>!</span><span>void</span>
<span>writeAll</span><span>(</span>data<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>)</span> <span>!</span><span>void</span>
<span>writeByte</span><span>(</span>b<span>:</span> <span><span>u8</span></span><span>)</span> <span>!</span><span>void</span>
<span>writeByteNTimes</span><span>(</span>b<span>:</span> <span><span>u8</span></span><span>,</span> n<span>:</span> <span><span>usize</span></span><span>)</span> <span>!</span><span>void</span>
<span>writeBytesNTimes</span><span>(</span>data<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>,</span> n<span>:</span> <span><span>usize</span></span><span>)</span> <span>!</span><span>void</span></code></pre>

<p>But this is just a convention based on the fact that the parameter name is <code>writer</code>. You either have to go through the source code and see how <code>writer</code> is used, or let the compiler tell you which function is expected.</p>

<p>But the main issue with <code>anytype</code> is that it can only be a used as a function parameter. This isn&#39;t valid:</p>

<pre><code><span>const</span> <span>Opts</span> <span>=</span> <span>struct</span> <span>{</span>
    output<span>:</span> <span>anytype</span>
<span>}</span></code></pre>

<p>For that, we need something else.</p>


<h3 id="anywriter"><a href="#anywriter" aria-hidden="true">std.io.AnyWriter</a></h3>
<p>The <code>std.io.AnyWriter</code> type is the closest thing Zig has to a writer interface. We&#39;ve covered <a href="https://disk.horse/Zig-Interfaces/">Zig interfaces</a> before and <code>AnyWriter</code> is essentially the simplest version we looked at, i.e.:</p>

<pre><code><span>pub</span> <span>const</span> <span>AnyWriter</span> <span>=</span> <span>struct</span> <span>{</span>
  context<span>:</span> <span><span>*</span><span>const</span> anyopaque</span><span>,</span>
  writeFn<span>:</span> <span>*</span><span>const</span> <span>fn</span> <span>(</span>context<span>:</span> <span><span>*</span><span>const</span> anyopaque</span><span>,</span> bytes<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>)</span> <span>anyerror</span><span>!</span><span>usize</span><span>,</span>

    <span>pub</span> <span>fn</span> <span>write</span><span>(</span>self<span>:</span> <span>AnyWriter</span><span>,</span> bytes<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>)</span> <span><span>anyerror</span><span>!</span><span>usize</span></span> <span>{</span>
        <span>return</span> self<span>.</span><span>writeFn</span><span>(</span>self<span>.</span>context<span>,</span> bytes<span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>;</span></code></pre>

<p>Unlike other languages where interfaces are purely a contract with no implementation, Zig tends to stuff a lot of behavior into its interfaces. For example, <code>AnyWriter</code> implements <code>writeAll</code> which relies on the above <code>write</code> function, and <code>writeByteNTimes</code> which relies on <code>writeAll</code>:</p>

<pre><code><span>pub</span> <span>fn</span> <span>writeAll</span><span>(</span>self<span>:</span> <span>AnyWriter</span><span>,</span> bytes<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>)</span> <span><span>anyerror</span><span>!</span><span>void</span></span> <span>{</span>
    <span>var</span> index<span>:</span> <span><span>usize</span></span> <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>index <span>!=</span> bytes<span>.</span>len<span>)</span> <span>{</span>
        index <span>+=</span> <span>try</span> self<span>.</span><span>write</span><span>(</span>bytes<span>[</span>index<span>..</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>pub</span> <span>fn</span> <span>writeByteNTimes</span><span>(</span>self<span>:</span> <span>AnyWriter</span><span>,</span> byte<span>:</span> <span><span>u8</span></span><span>,</span> n<span>:</span> <span><span>usize</span></span><span>)</span> <span><span>anyerror</span><span>!</span><span>void</span></span> <span>{</span>
    <span>var</span> bytes<span>:</span> <span><span>[</span><span>256</span><span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
    <span>@memset</span><span>(</span>bytes<span>[</span><span>0</span><span>..</span><span>]</span><span>,</span> byte<span>)</span><span>;</span>

    <span>var</span> remaining<span>:</span> <span><span>usize</span></span> <span>=</span> n<span>;</span>
    <span>while</span> <span>(</span>remaining <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>const</span> to_write <span>=</span> <span>@min</span><span>(</span>remaining<span>,</span> bytes<span>.</span>len<span>)</span><span>;</span>
        <span>try</span> self<span>.</span><span>writeAll</span><span>(</span>bytes<span>[</span><span>0</span><span>..</span>to_write<span>]</span><span>)</span><span>;</span>
        remaining <span>-=</span> to_write<span>;</span>
    <span>}</span>
<span>}</span></code></pre>

<p>Now this approach can have <a href="https://github.com/ziglang/zig/issues/17985">performance issues</a>, since there&#39;s no way for an implementation to provide, for example, an optimized <code>writeByteNTimes</code>. Still, <code>AnyWriter</code> fills that gap around the limitations of <code>anytype</code>&#39;s usage.</p>

<h3 id="genericwriter"><a href="#genericwriter" aria-hidden="true">std.io.GenericWriter</a></h3>
<p>It would be reasonable to think that when you call <code>file.writer()</code> or <code>array_list.writer()</code>, you&#39;re getting an <code>std.io.AnyWriter</code> interface. In reality though, you&#39;re getting a <code>std.io.GenericWriter</code>, which <code>std.io.Writer</code> aliases. To understand what this type is, we need to look at the <code>writeFn</code> field of <code>AnyType</code>:</p>

<pre><code><span>*</span><span>const</span> <span>fn</span> <span>(</span>context<span>:</span> <span><span>*</span><span>const</span> anyopaque</span><span>,</span> bytes<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>)</span> <span>anyerror</span><span>!</span><span>usize</span></code></pre>

<p>Specifically, notice the <code>anyerror</code> return type. Unlike an inferred error type (i.e. <code>!usize</code>) which will implicitly create an errorset based on the function&#39;s possible error values, <code>anyerror</code> is an implicitly created errorset for the <strong>entire project</strong>. This means that even though your specific writer&#39;s <code>write</code> function might only be able to return an <code>error.OutOfMemory</code>, the <code>AnyError</code> interface will expose any possible error your program might return. In many cases, that won&#39;t be an issue. But projects with strict reliability requirements might need/want to handle every error explicitly, especially when we&#39;re talking about something like writing data. Think of a database persisting a WAL file to disk, for example.</p>

<p>Thus we have<code>std.io.GenericWriter</code> which, as part of its generic contract, takes an error type. Here&#39;s what the generic parameters look like:</p>

<pre><code><span>pub</span> <span>fn</span> <span>GenericWriter</span><span>(</span>
    <span>comptime</span> Context<span>:</span> <span><span>type</span></span><span>,</span>
    <span>comptime</span> WriteError<span>:</span> <span><span>type</span></span><span>,</span>
    <span>comptime</span> writeFn<span>:</span> <span>fn</span> <span>(</span>context<span>:</span> <span>Context</span><span>,</span> bytes<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>)</span> WriteError<span>!</span><span>usize</span><span>,</span>
<span>)</span> <span><span>type</span></span> <span>{</span>
    <span>...</span><span>.</span>
<span>}</span></code></pre>

<p>Notice that the <code>writeFn</code>&#39;s return value is now a typed error - with the type being provided by the implementation.</p>

<p>Let&#39;s look at some examples. Here&#39;s what an implementation that returns an <code>AnyWriter</code> might look like:</p>

<pre><code><span>pub</span> <span>const</span> <span>DummyWriterAny</span> <span>=</span> <span>struct</span> <span>{</span>
    <span>fn</span> <span>write</span><span>(</span>_<span>:</span> <span><span>*</span><span>const</span> anyopaque</span><span>,</span> data<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>)</span> <span>error</span><span>{</span>OutOfMemory<span>}</span><span><span>!</span><span>usize</span></span> <span>{</span>
        _ <span>=</span> data<span>;</span>
        <span>return</span> <span>error</span><span>.</span>OutOfMemory<span>;</span>
    <span>}</span>

    <span>pub</span> <span>fn</span> <span>writer</span><span>(</span>self<span>:</span> <span><span>*</span>DummyWriterAny</span><span>)</span> <span>std<span>.</span>io<span>.</span>AnyWriter</span> <span>{</span>
        <span>return</span> <span>.</span><span>{</span>
            <span>.</span>context <span>=</span> self<span>,</span>
            <span>.</span>writeFn <span>=</span> write<span>,</span>
        <span>}</span><span>;</span>
    <span>}</span>
<span>}</span><span>;</span></code></pre>

<p>Even though our <code>write</code> function returns an explicit error, that type information is lost when we convert our <code>DummyWriterAny</code> to a <code>AnyWriter</code>. Here&#39;s a similar implementation but for a <code>GenericWriter</code>:</p>

<pre><code><span>pub</span> <span>const</span> <span>DummyWriterGen</span> <span>=</span> <span>struct</span> <span>{</span>
    <span>fn</span> <span>write</span><span>(</span>_<span>:</span> <span><span>*</span>DummyWriterGen</span><span>,</span> data<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>)</span> <span>error</span><span>{</span>OutOfMemory<span>}</span><span><span>!</span><span>usize</span></span> <span>{</span>
        _ <span>=</span> data<span>;</span>
        <span>return</span> <span>error</span><span>.</span>OutOfMemory<span>;</span>
    <span>}</span>

    <span>pub</span> <span>const</span> Writer <span>=</span> std<span>.</span>io<span>.</span><span>Writer</span><span>(</span><span>*</span>DummyWriterGen<span>,</span> <span>error</span><span>{</span>OutOfMemory<span>}</span><span>,</span> write<span>)</span><span>;</span>

    <span>pub</span> <span>fn</span> <span>writer</span><span>(</span>self<span>:</span> <span><span>*</span>DummyWriterGen</span><span>)</span> <span>Writer</span> <span>{</span>
        <span>return</span> <span>.</span><span>{</span><span>.</span>context <span>=</span> self<span>}</span><span>;</span>
    <span>}</span>
<span>}</span><span>;</span></code></pre>



<p>Now when we convert our <code>DummyWriterGen</code> to an <code>std.io.GenericWriter</code>, the error type is preserved.</p>

<p><strong>However</strong>, it&#39;s important to realize that <code>GenericWriter</code> isn&#39;t just a better, more type-aware, version of <code>AnyWriter</code>. One is a generic the other is an interface. Specifically, a <code>GenericWriter</code> for a <code>File</code> is a different type than a <code>GenericWriter</code> for an <code>ArrayList(u8)</code>. It isn&#39;t an interface and can&#39;t be used like one.

</p><h3 id="conclusion"><a href="#conclusion" aria-hidden="true">Bringing it all Together</a></h3>
<p>For everyday programming, what all of this means is that if you have a <code>File</code>, <code>ArrayList(u8)</code>, <code>Stream</code> or any other type which has a <code>writer</code> method, you&#39;re almost certainly getting an <code>GenericWriter</code>. This writer can usually be passed to a function with a <code>writer: anytype</code>:</p>

<pre><code><span>const</span> std <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
    <span>var</span> gpa <span>=</span> std<span>.</span>heap<span>.</span><span>GeneralPurposeAllocator</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span><span>{</span><span>}</span><span>;</span>
    <span>const</span> allocator <span>=</span> gpa<span>.</span><span>allocator</span><span>(</span><span>)</span><span>;</span>
    <span>var</span> arr <span>=</span> std<span>.</span><span>ArrayList</span><span>(</span><span>u8</span><span>)</span><span>.</span><span>init</span><span>(</span>allocator<span>)</span><span>;</span>

    
    
    <span>try</span> std<span>.</span>fmt<span>.</span><span>format</span><span>(</span>arr<span>.</span><span>writer</span><span>(</span><span>)</span><span>,</span> <span>&#34;over {d}!!&#34;</span><span>,</span> <span>.</span><span>{</span><span>9000</span><span>}</span><span>)</span><span>;</span>

    std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;{s}\n&#34;</span><span>,</span> <span>.</span><span>{</span>arr<span>.</span>items<span>}</span><span>)</span><span>;</span>
<span>}</span></code></pre>

<p>I say &#34;usually&#34;, because there&#39;s no guarantee; it relies on all of us agreeing that a variable named <code>writer</code> of type <code>anytype</code> only ever uses methods available to a <code>GenericWriter</code>. Sarcasm aside, it does mostly work.</p>

<p>For cases where an <code>std.io.AnyWriter</code> is needed, such as storing a implementation-independent writer in a struct field, you&#39;ll need to use an <code>AnyWriter</code>, which you can easily get by calling <code>any()</code> on your <code>GenericWriter</code>:</p>

<pre><code>
<span>const</span> std <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
    <span>var</span> gpa <span>=</span> std<span>.</span>heap<span>.</span><span>GeneralPurposeAllocator</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span><span>{</span><span>}</span><span>;</span>
    <span>const</span> allocator <span>=</span> gpa<span>.</span><span>allocator</span><span>(</span><span>)</span><span>;</span>

    <span>var</span> arr <span>=</span> std<span>.</span><span>ArrayList</span><span>(</span><span>u8</span><span>)</span><span>.</span><span>init</span><span>(</span>allocator<span>)</span><span>;</span>
    <span>const</span> opts <span>=</span> <span>Opts</span><span>{</span>
        <span>.</span>output <span>=</span> arr<span>.</span><span>writer</span><span>(</span><span>)</span><span>.</span><span>any</span><span>(</span><span>)</span><span>,</span>
    <span>}</span><span>;</span>
    <span>try</span> <span>write</span><span>(</span><span>&#34;hello world&#34;</span><span>,</span> opts<span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>Opts</span> <span>=</span> <span>struct</span> <span>{</span>
    output<span>:</span> <span>std<span>.</span>io<span>.</span>AnyWriter</span><span>,</span>
<span>}</span><span>;</span>

<span>fn</span> <span>write</span><span>(</span>data<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>,</span> opts<span>:</span> <span>Opts</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
    _ <span>=</span> <span>try</span> opts<span>.</span>output<span>.</span><span>write</span><span>(</span>data<span>)</span><span>;</span>
<span>}</span></code></pre>

<p>If I understand correctly, <a href="https://github.com/ziglang/zig/pull/17344">the motivation for this design</a>, was reducing code bloat while providing a mechanism to preserve typed errors. This is possible because <code>GenericWriter</code> relies on the various methods of <code>AnyWriter</code>, like <code>writeAll</code> and <code>writeByteNTimes</code>. So while there will be many copies of <code>GenericWriter</code> (for <code>File</code>, <code>Stream</code>, <code>ArrayList(u8)</code>, etc.), they each have a very small functions which only invoke the <code>AnyReader</code> logic and re-type the error. For example, here&#39;s <code>GenericWriter.writeAll</code>:</p>

<pre><code><span>pub</span> <span>inline</span> <span>fn</span> <span>writeAll</span><span>(</span>self<span>:</span> <span>Self</span><span>,</span> bytes<span>:</span> <span><span>[</span><span>]</span><span>const</span> <span>u8</span></span><span>)</span> <span>Error<span>!</span><span>void</span></span> <span>{</span>
    <span>return</span> <span>@errorCast</span><span>(</span>self<span>.</span><span>any</span><span>(</span><span>)</span><span>.</span><span>writeAll</span><span>(</span>bytes<span>)</span><span>)</span><span>;</span>
<span>}</span></code></pre>

<p>We see that <code>@errorCast</code> does the heavy lifting, converting the <code>anyerror</code> that <code>AnyWriter.writeAll</code> returns into the narrow type-specific error for this implementation.</p>

<p>Like I said, for everyday programming, you&#39;ll mostly be passing the result of <code>writer()</code> to a <code>writer: anytype</code> function parameter. And it mostly works, possibly after you&#39;ve wasted time trying to figure out exactly what the requirements for the <code>writer</code> are. It&#39;s only when you can&#39;t use <code>anytype</code>, i.e. in a structure field, that this <code>GenericWriter</code> / <code>AnyReader</code> chimera becomes something you need to be aware of.</p>

<p>Hopefully the situation can be improved, specifically with some of the <a href="https://github.com/ziglang/zig/issues/21566">performance</a> <a href="https://github.com/ziglang/zig/issues/17985">issues</a> and resulting poor documentation.</p>

</article></div>
  </body>
</html>
