<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pinecone.io/learn/softmax-activation/">Original</a>
    <h1>Softmax Activation Function, Explained</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/3eb5ba698ca125f50b02a99dee4df485445bc06c/b9769/images/softmax-activation.png" alt="Softmax Activation" width="100%"/></p><p>Have you ever trained a neural network to solve the problem of multiclass classification? If yes, you know that the raw outputs of the neural network are often very difficult to interpret. The <strong>softmax activation function</strong> simplifies this for you by making the neural network’s outputs easier to interpret!</p><p>The softmax activation function transforms the raw outputs of the neural network into a vector of <em>probabilities</em>, essentially a probability distribution over the input classes. Consider a multiclass classification problem with <code>N</code> classes. The softmax activation returns an output vector that is <code>N</code> entries long, with the entry at index <code>i</code> corresponding to the probability of a particular input belonging to the class <code>i</code>.</p><p>In this tutorial, you’ll learn all about the softmax activation function. You’ll start by reviewing the basics of multiclass classification, then proceed to understand why you cannot use the sigmoid or argmax activations in the output layer for multiclass classification problems.</p><p>Finally, you’ll learn the mathematical formulation of the softmax function and implement it in Python.</p><p>Let’s get started.</p><h2 id="multiclass-classification-revisited">Multiclass Classification Revisited</h2><p>Recall that in <em>binary</em> classification, there are <em>only two</em> possible classes. For example, a ConvNet trained to classify whether or not a given image is a panda is a binary classifier, whereas, in <em>multiclass</em> classification, there are <em>more than</em> two possible classes.</p><p>Let’s consider the following example: You’re given a dataset containing images of pandas, seals, and ducks. You’d like to train a neural network to predict whether a previously unseen image is that of a seal, a panda, or a duck.</p><p>Notice how the input class labels below are one-hot encoded, and the classes are <em>mutually exclusive</em>. In this context, mutual exclusivity means that a given image can only be <em>one</em> of {seal, panda, duck} at a time.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/8850c924730b56bbbe7955fd6593fd628249ecff/275c5/images/multiclass-classification.png" alt="Multiclass Classification" width="100%"/>
<small>Multiclass Classification Example (Image by the author)</small></p><h2 id="can-you-use-sigmoid-or-argmax-activations-instead">Can You Use Sigmoid or Argmax Activations Instead?</h2><p>In this section, you’ll learn why the sigmoid and argmax functions are not the optimal choices for the output layer in a multiclass classification problem.</p><h3 id="limitations-of-the-sigmoid-function">Limitations of the Sigmoid Function</h3><p>Mathematically, the sigmoid activation function is given by the following equation, and it squishes all inputs onto the range [0, 1].</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/c403cc62806b3aa0de8bf460949afd103b5b942d/240a1/images/sigmoid-func-formula.png" alt="Sigmoid Function Equation" width="100%"/>
<small>Sigmoid Function Equation (Image by the author)</small></p><p>The sigmoid function takes in any <em>real</em> number as the input and maps it to a number between 0 and 1. This is exactly why it’s well-suited for binary classification.</p><p>▶️ You may run the following code cell to plot the values of the sigmoid function over a range of numbers.</p><div><pre><code data-lang="python"><span>import</span> numpy <span>as</span> np
<span>import</span> seaborn <span>as</span> sns

<span>def</span> <span>sigmoid</span>(x):
  exp_x <span>=</span> np<span>.</span>exp(x)
  <span>return</span> np<span>.</span>divide(exp_x,(<span>1</span> <span>+</span> exp_x))
  
x <span>=</span> np<span>.</span>linspace(<span>-</span><span>10</span>,<span>10</span>,num<span>=</span><span>200</span>)
exp_x <span>=</span> np<span>.</span>exp(x)
sigmoid_arr <span>=</span> sigmoid(x)

sns<span>.</span>set_theme()
sns<span>.</span>lineplot(x <span>=</span> x,y <span>=</span> sigmoid_arr)<span>.</span>set(title<span>=</span><span>&#39;Sigmoid Function&#39;</span>)
</code></pre></div><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/ad3f2f65707f0aa10cd5b930950118f26fec5fab/255a2/images/sigmoid-plot.png" alt="Sigmoid Function Plot" width="100%"/>
<small>Plot of the Sigmoid Function</small></p><p>Let’s go back to our example of classifying whether an input image is that of a panda or not. In this case, let z be the raw output of the neural network. If σ(z) is the probability that the given image belongs to class 1 (is a panda), then 1 - σ(z) is the probability that the given image does not belong to class 1 and is not a panda. You can think of σ(z) as a <em>probability score</em>.</p><p>You can now fix a threshold, say T, and predict that class whose probability score is <em>greater</em> than the chosen threshold.</p><p>However, this won’t quite work when you have more than two classes. Softmax to the rescue!</p><p>In fact, you can think of the softmax function as a <strong>vector generalization</strong> of the sigmoid activation. We’ll revisit this later to confirm that for <em>binary</em> classification—when N = 2—the softmax and sigmoid activations are <em>equivalent</em>.</p><h3 id="limitations-of-the-argmax-function">Limitations of the Argmax Function</h3><p>The argmax function returns the <strong>index</strong> of the maximum value in the input array.</p><p>Let’s suppose the neural network’s raw output vector is given by <strong>z</strong> = [0.25, 1.23, -0.8]. In this case, the maximum value is 1.23 and it occurs at index 1. In our image classification example, index 1 corresponds to the second class—and the image is predicted to be that of a panda.</p><p>In vector notation, you’ll have 1 at the index where the maximum occurs (at index 1 for the vector <em>z</em>). And you’ll have 0 at all other indices.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/75c7bdd726acf4461cc43627aa90c4c8c70e1f0c/26f59/images/argmax-output.png" alt="Argmax Output" width="100%"/>
<small>Argmax Output (Image by the author)</small></p><p>One limitation with using the argmax function is that its <em>gradients</em> with respect to the raw outputs of the neural networks are always <em>zero</em>. As you know, it’s the <a href="https://cs231n.github.io/optimization-2/">backpropagation of gradients</a> that facilitates the learning process in neural networks.</p><p>As you’ll have to plug in the value 0 for all gradients of the argmax output during backpropagation, you cannot use the argmax function in training. Unless there’s backpropagation of gradients, the parameters of the neural network cannot be adjusted, and there’s effectively no learning!</p><p>From a probabilistic viewpoint, notice how the argmax function puts all the mass on index 1: the predicted class and 0 elsewhere. So it’s straightforward to infer the predicted class label from the argmax output. However, we would like to know how likely the image is to be that of a panda, a seal, or a duck, and the softmax scores help us with just that!</p><h2 id="the-softmax-activation-function-explained">The Softmax Activation Function, Explained</h2><p>It’s finally time to learn about softmax activation. The softmax activation function takes in a vector of <strong>raw outputs</strong> of the neural network and returns a vector of <strong>probability scores</strong>.</p><p>The equation of the softmax function is given as follows:</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/d6417f15d7db90091e6173ba01edb0355b5ce217/19fe2/images/softmax-formula.png" alt="Softmax Function Equation" width="100%"/>
<small>Softmax Function Equation (Image by the author)</small></p><p>Here,</p><ul><li><strong>z</strong> is the vector of raw outputs from the neural network</li><li>The value of e ≈ 2.718</li><li>The i-th entry in the softmax output vector softmax(<strong>z</strong>) can be thought of as the predicted probability of the test input belonging to class i.</li></ul><p>From the plot of e^x, you can see that, regardless of whether the input x is positive, negative, or zero, e^x is always a positive number.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/fbc4a951b701d7360ac94ce57397784ec22fb11a/19308/images/plot-of-expx.png" alt="Plot of expx" width="100%"/>
<small>Plot of exp(x)</small></p><p>Recall that in our example, N = 3 as we have 3 classes: {seal, panda, duck}, and the valid indices are 0, 1, and 2. Suppose you’re given the vector <strong>z</strong> = [0.25, 1.23, -0.8] of raw outputs from the neural network.</p><p>Let’s apply the softmax formula on the vector <strong>z</strong>, using the steps below:</p><ol><li>Calculate the exponent of each entry.</li><li>Divide the result of step 1 by the sum of the exponents of all entries.</li></ol><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/7b3825da434c7c222ffcc5404eabd59ecb7d1657/48d23/images/computing-softmax-scores.png" alt="Computing softmax scores" width="100%"/>
<small>Computing softmax scores for the 3 classes (Image by the author)</small></p><p>▶️ Now that we’ve computed the softmax scores, let’s collect them into a vector for succinct representation, as shown below:</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/79b093ae2f1d66b98497ddbaeaaa7de9081e8517/09de2/images/softmax-output.png" alt="Softmax Output" width="100%"/>
<small>Softmax Output (Image by the author)</small></p><p>From the softmax output above, we can make the following observations:</p><ul><li>In the vector <strong>z</strong> of raw outputs, the maximum value is 1.23, which on applying softmax activation maps to 0.664: the largest entry in the softmax output vector. Likewise, 0.25 and -0.8 map to 0.249 and 0.087: the second and the third largest entries in the softmax output respectively. Thus, applying softmax preserves the <em>relative ordering</em> of scores.</li><li>All entries in the softmax output vector are between 0 and 1.</li><li>In a multiclass classification problem, where the classes are mutually exclusive, notice how the entries of the softmax output sum up to <strong>1</strong>: 0.664 + 0.249 + 0.087 = 1.</li></ul><p>This is exactly why you can think of softmax output as a probability distribution over the input classes, that makes it <em>readily interpretable</em>.</p><p>As a next step, let’s examine the softmax output for our example.</p><p>In the vector softmax(<strong>z</strong>) = [0.664, 0.294, 0.087], 0.664 at index 1 is the largest value. This means there’s a 66.4% chance that the given image belongs to class 1, which from our one-hot encoding is a class <em>panda</em>.</p><p>And the input image has a 29.4% chance of being a seal and around 8.7% chance of being a duck.</p><p>Therefore, applying softmax gives <em>instant</em> interpretability, as you know how <em>likely</em> the test image is to belong to each of the 3 classes. In this particular example, it’s <em>highly likely</em> to be a panda and <em>least likely</em> to be a duck.</p><p>It now makes sense to call the argmax function on the softmax output to get the predicted class label. As the predicted class label is the one with the highest probability score, you can use <code>argmax(softmax(z))</code> to obtain the predicted class label. In our example, the highest probability score of 0.664 occurs at index 1, corresponding to class 1 (panda).</p><h3 id="how-to-implement-the-softmax-activation-in-python">How to Implement the Softmax Activation in Python</h3><p>In the previous section, we did some simple math to compute the softmax scores for the output vector <strong>z</strong>.</p><p>Now let’s translate the math operations into equivalent operations on NumPy arrays. You may use the following code snippet to get the softmax activation for any vector <strong>z</strong>.</p><div><pre><code data-lang="python"><span>import</span> numpy <span>as</span> np

<span>def</span> <span>softmax</span>(z):
  <span>&#39;&#39;&#39;Return the softmax output of a vector.&#39;&#39;&#39;</span>
  exp_z <span>=</span> np<span>.</span>exp(z)
  sum <span>=</span> exp_z<span>.</span>sum()
  softmax_z <span>=</span> np<span>.</span>round(exp_z<span>/</span>sum,<span>3</span>)
  <span>return</span> softmax_z
</code></pre></div><p>We can parse the definition of the softmax function:</p><ul><li>The function takes in one required parameter <strong>z</strong>, a vector, and returns the softmax output vector <code>softmax_z</code>.</li><li>We use <code>np.exp(z)</code> to compute <code>exp(z)</code> for each <code>z</code> in <strong>z</strong>; call the resultant array <code>exp_z</code>.</li><li>Next, we call sum on the array exp_z to compute the sum of exponents.</li><li>We then divide each entry in exp_z by the sum and round off the result to 3 decimal places, storing the result in a variable, say, <code>softmax_z</code>.</li><li>Finally, the function returns the array <code>softmax_z</code>.</li></ul><p>You may now call the function with the output array z as the argument and verify that the scores are identical to what we had computed manually.</p><div><pre><code data-lang="python">z <span>=</span> [<span>0.25</span>, <span>1.23</span>, <span>-</span><span>0.8</span>]
softmax(z)

<span># Output</span>
array([ <span>0.249</span>, <span>0.664</span>, <span>0.087</span>])
</code></pre></div><p>Are you wondering if normalizing each value by the sum of entries will suffice, to get relative scores? Let’s see why it’s not an efficient solution.</p><h3 id="why-wont-normalization-by-the-sum-suffice">Why Won’t Normalization by the Sum Suffice</h3><p>Why use something math-heavy as the softmax activation? Can we not just divide each of the output values by the sum of all outputs?</p><p>Well, let’s try to answer this by taking a few examples.</p><p>Use the following function to return the array normalized by the sum.</p><div><pre><code data-lang="python"><span>def</span> <span>div_by_sum</span>(z):
  sum_z <span>=</span> np<span>.</span>sum(z)
  out_z <span>=</span> np<span>.</span>round(z<span>/</span>sum_z,<span>3</span>)
  <span>return</span> out_z
</code></pre></div><p>1️⃣ Consider <strong>z1</strong> = [0.25, 1.23, -0.8], and call the function <code>div_by_sum</code>. In this case, though the entries in the returned array sum up to 1, it has both positive and negative values. We still aren’t able to interpret the entries as probability scores.</p><div><pre><code data-lang="python">z1 <span>=</span> [<span>0.25</span>,<span>1.23</span>,<span>-</span><span>0.8</span>]
div_by_sum(z1)

<span># Output</span>
array([ <span>0.368</span>,  <span>1.809</span>, <span>-</span><span>1.176</span>])
</code></pre></div><p>2️⃣ Let <strong>z2</strong> = [-0.25, 1, -0.75]. In this case, all elements in the vector sum up to zero, so the denominator will always be 0. When you divide by the sum to normalize, you’ll face runtime warnings, as division by zero is not defined.</p><div><pre><code data-lang="python">z2 <span>=</span> [<span>-</span><span>0.25</span>,<span>1</span>,<span>-</span><span>0.75</span>]
div_by_sum(z2)

<span># Output</span>
<span>RuntimeWarning</span>: divide by zero encountered <span>in</span> true_divide
array([<span>-</span>inf,  inf, <span>-</span>inf])
</code></pre></div><p>3️⃣ In this example, <strong>z3</strong> = [0.1, 0.9, 0.2]. Let’s check both the softmax and normalized scores.</p><div><pre><code data-lang="python">z3 <span>=</span> [<span>0.1</span>,<span>0.9</span>,<span>0.2</span>] <span># ratio: 1:9:2</span>
<span>print</span>(div_by_sum(z3))
<span>print</span>(softmax(z3))

<span># Output</span>
[<span>0.083</span> <span>0.75</span>  <span>0.167</span>] <span># ratio: 1:9:2</span>
[<span>0.231</span> <span>0.514</span> <span>0.255</span>]
</code></pre></div><p>As shown in the code cell above, when all the inputs are positive, you may interpret the normalized scores as probability scores, but the scores are in the same ratio as in the array <strong>z3</strong>. In this example, the predicted class is still that of a panda.</p><p>However, you can’t guarantee that the neural network’s raw output won’t sum up to 0 or have negative entries.</p><p>4️⃣ In this example, <strong>z4</strong> = [0, 0.9, 0.1]. Let’s check both the softmax and normalized scores.</p><div><pre><code data-lang="python">z4 <span>=</span> [<span>0</span>,<span>0.9</span>,<span>0.1</span>]
<span>print</span>(div_by_sum(z4))
<span>print</span>(softmax(z4))

<span># Output</span>
[<span>0.</span>  <span>0.9</span> <span>0.1</span>]
[<span>0.219</span> <span>0.539</span> <span>0.242</span>]
</code></pre></div><p>As you can see, when one of the entries is 0, upon calling the <code>div_by_sum</code> function, the entry is still 0 in the normalized array. However, in the softmax output, you can see that 0 has been mapped to a score of 0.219.</p><p>In some sense you can think of the softmax activation function as a softer version of the argmax function: It <em>maximizes</em> the probability score corresponding to the predicted output label. At the same time, it’s <em>soft</em> because it does assign some probability mass to the less likely classes as well, unlike the argmax function that puts the entire probability mass of 1 on the maximum, and 0 everywhere else.</p><p>In essence, the softmax activation can be perceived as a smooth approximation to the argmax function.</p><h2 id="equivalence-of-the-sigmoid-softmax-activations-for-n--2">Equivalence of the Sigmoid, Softmax Activations for N = 2</h2><p>Now let’s revisit our earlier claim that the sigmoid and softmax activations are equivalent for binary classification when N = 2.</p><p>Recall that in binary classification, you apply the sigmoid function to the neural network’s output to get a value in the range [0, 1].</p><p>When you’re using the softmax function for multiclass classification, <strong>the number of nodes in the output layer = the number of classes N</strong>.</p><p>You can think of binary classification as a special case of multiclass classification. Assume that the output layer has two nodes: one outputting the score z and the other 0.</p><p>Effectively, there’s <em>only one</em> node as the other is not given any weight at all. The raw output vector now becomes <strong>z</strong> = [z, 0]. Next, we may go ahead and apply softmax activation on this vector <strong>z</strong> and check how it’s equivalent to the sigmoid function we looked at earlier.</p><p><img loading="lazy" src="https://d33wubrfki0l68.cloudfront.net/4c7cc22dfb5a266501e515fbf3151d11cfb6a0d6/99f3e/images/sigmoid-softmax-equiv.png" alt="Equivalence of Sigmoid &amp;amp; Softmax Activations" width="100%"/>
<small>Equivalence of Sigmoid &amp; Softmax Activations (Image by the author)</small></p><p>Observe how the softmax activation scores in this case are the same as the sigmoid activation scores: σ(z) and 1 - σ(z).</p><p>And with this, we wrap up our discussion on the softmax activation function. Let’s quickly summarize all that we’ve learned.</p><h2 id="summing-up">Summing Up</h2><p>In this tutorial, you’ve learned the following:</p><ul><li>How to use the softmax function as output layer activation in a multiclass classification problem.</li><li>The working of the softmax function—how it transforms a vector of raw outputs into a vector of probabilities. And how you can interpret each entry in the softmax output as the probability of the corresponding class.</li><li>How to interpret the softmax activation as an extension of the sigmoid function to multiclass classification, and their equivalence for binary classification where the number of classes N = 2.</li></ul><p>In the next tutorial, we’ll delve deep into cross-entropy loss—a widely-used metric to assess how well your multiclass classification model performs.</p><p>Until then, check out other interesting <a href="https://www.pinecone.io/learn/">NLP tutorials on vector search, algorithms, and more</a>. Happy learning!</p><h2 id="further-reading">Further Reading</h2><p>[1] <a href="https://cs231n.github.io/optimization-2/">Lesson on Backpropagation, Chain Rule, and Vectorization from CS231n</a></p><p>[2] <a href="https://keras.io/api/layers/activations/">Layer Activation Functions: Keras API Reference</a></p><p>[3] <a href="https://d2l.ai/chapter_linear-networks/softmax-regression-scratch.html">Implementation of Softmax Regression from Scratch</a></p></div></div></div></div>
  </body>
</html>
