<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.bruce-hill.com/hill-noise">Original</a>
    <h1>Hill Noise</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>
<p><img src="https://github.com/media/hill-noise/hill_noise.png" alt="Hill
Noise"/>
</p>

<p>A new approach to random noise generation with novel
mathematical properties.</p>
<p>Estimated reading time: 13 mins</p>
<span>Bruce Hill</span>
<span>June 1, 2017</span>

<p>Noise functions are a way to produce continuous pseudorandom values across
one or more dimensions. The simplest example is a one-dimensional noise function
that makes the y-value wobble up and down smoothly, but unpredictably, as you
move along the x-axis. It’s also possible to produce 2-dimensional noise, where
the amplitude of the noise depends on the x,y coordinates you’re sampling.</p>
<p><img src="https://github.com/media/hill-noise/hill_noise.png" alt="" width="50%"/>
</p>
<p>This can be used to create hilly terrain in a video game, or more generally,
it’s used in computer graphics for procedurally generating textures or making
bumpy surfaces. The original version of Minecraft used a 2D noise function to
generate heights for terrain as a function of (x,y) coordinates, and later
versions used a 3D noise function to generate terrain density as a function of
(x,y,z) coordinates to produce overhangs and caves, <a href="http://notch.tumblr.com/post/3746989361/terrain-generation-part-1" target="_blank" rel="noreferrer">as Notch describes here.</a></p>
<h2 id="existing-noise-functions">Existing Noise Functions</h2>
<p>There’s many different techniques for making noise. The simplest is called
“Value Noise” and it works by generating a set of random points, and then
interpolating between them. Most implementations store the random points in a
fixed-width array, and points past the end of the array wrap around. Value noise
looks like this:</p>

<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>class</span> ValueNoise:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    NUM_VALUES <span>=</span> <span>256</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    SPACING <span>=</span> <span>10</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, random<span>=</span>random):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.values <span>=</span> [random() <span>for</span> _ <span>in</span> <span>range</span>(ValueNoise.NUM_VALUES)]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span>def</span> evaluate(<span>self</span>, x):</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span># Look up the nearest two values</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        x1 <span>=</span> floor(x<span>/</span>ValueNoise.SPACING)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        x2 <span>=</span> ceil(x<span>/</span>ValueNoise.SPACING)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        n1 <span>=</span> <span>self</span>.values[x1 <span>%</span> ValueNoise.NUM_VALUES]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        n2 <span>=</span> <span>self</span>.values[x2 <span>%</span> ValueNoise.NUM_VALUES]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span># Smoothly interpolate between them using cosine interpolation</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        k <span>=</span> <span>.5</span> <span>-</span> <span>.5</span><span>*</span>cos((x<span>/</span>ValueNoise.SPACING <span>%</span> <span>1</span>)<span>*</span>pi)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span>return</span> ((<span>1</span><span>-</span>k)<span>*</span>n1 <span>+</span> k<span>*</span>n2)</span></code></pre></div>
<p>More commonly, Perlin Noise and Simplex Noise are used. They are slightly
more complicated algorithms that rely on similar principles: generate a large
amount of random values, then look up and combine those values to get the value
at a particular point. However, with Perlin and Simplex noise, the values are
used as gradients (partial derivative vectors), rather than heights, which
produces slightly better-looking noise.</p>
<h3 id="fine-details">Fine Details</h3>
<p>For many applications, it’s nice to have some extra detail. For example, if
you’re using a noise function to make mountains, it’s good to have both “general
trend” noise like “go upward for 50 miles, then go downward again”, but it’s
also useful to have “local variation” noise like “there’s a bump on the road
here”. Commonly, this is achieved by using multiple layers of noise. You start
with high-amplitude, slow-changing noise (mountains) and then add smaller,
quicker-changing noise (hills), and so on until you get to the smallest level of
detail that you care about (bumps in the road). You can use the same noise
function for each layer, if you scrunch it up by scaling the input and output of
the function. The layers are commonly called “octaves”, and it looks like
this:</p>

<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>class</span> OctaveNoise:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, num_octaves, random<span>=</span>random):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.noise <span>=</span> ValueNoise(random<span>=</span>random)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.num_octaves <span>=</span> num_octaves</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span>def</span> evaluate(<span>self</span>, x):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        noise <span>=</span> <span>0</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span>for</span> i <span>in</span> <span>range</span>(<span>self</span>.num_octaves):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>            size <span>=</span> <span>0.5</span><span>**</span>i</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>            noise <span>+=</span> size <span>*</span> <span>self</span>.noise.evaluate(x<span>/</span>size)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span>return</span> noise<span>/</span><span>2</span></span></code></pre></div>
<p>Unfortunately, most of the existing noise functions require pre-generating
large amounts of random values that need to be interpolated between (commonly
256). If you keep sampling the noise function far enough in any one direction,
the noise function will start repeating itself. Also, most noise functions don’t
make any guarantees about the distribution of values. For example, Value Noise
picks random points and interpolates between them, but most of the interpolated
points are closer to 0.5 than to either 0 or 1, so the distribution of produced
values is skewed towards the middle, and it’s quite rare to see the noise
function get very high or very low, but quite common to see it pass through 0.5.
Perlin Noise and Simplex Noise also suffer from these issues, though they do
tend to produce better-looking results than Value Noise. For example, here’s
what 1D Simplex Noise looks like:</p>

<p>Notice that the values produced by the Simplex Noise tend to be very heavily
biased towards 0.5, and it’s very uncommon to see values close to 0 or 1. (The
implementation here is based on the <a href="https://bitbucket.org/rude/love/src/10f58e78bbfd82b681a45aeaf1177a765726bb31/src/libraries/noise1234/simplexnoise1234.cpp?at=default&amp;fileviewer=file-view-default" target="_blank" rel="noreferrer">SimplexNoise1234 implementation used in the
LÖVE game engine.</a>) For many use cases, it might not matter that the
distribution of values is not uniform. In my opinion though, it’s better to have
a predictable distribution of values, which can be easily modified to get
whatever distribution is desired for your use case.</p>
<h2 id="hill-noise">Hill Noise</h2>
<p>As an alternative to address some of these issues, I present a new noise
function, which I call “Hill Noise”. It’s inspired by <a href="https://en.wikipedia.org/wiki/Fourier_decomposition" target="_blank" rel="noreferrer">Fourier Decomposition</a>: any periodic function can be broken
down into a sum of sine waves of different amplitudes, wavelengths, and offsets.
If you generalize the idea, you can create an arbitrarily complex and wobbly
function by summing together a bunch of sine waves of different amplitudes,
offsets, and wavelengths. If you sum together a bunch of sine waves, then the
pattern will only repeat itself after the <a href="https://en.wikipedia.org/wiki/Least_common_multiple" target="_blank" rel="noreferrer">least common multiple</a> of the periods of the sine waves. For
example, the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>π</mi><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>π</mi><mfrac><mn>1</mn><mn>3</mn></mfrac><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(x) = \sin(2\pi \frac{1}{2} x) + \sin(2\pi \frac{1}{3} x)</annotation></semantics></math>
has a period of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>6</mn><annotation encoding="application/x-tex">6</annotation></semantics></math>.
But the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>π</mi><mfrac><mn>100</mn><mn>201</mn></mfrac><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>π</mi><mfrac><mn>100</mn><mn>301</mn></mfrac><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(x) = \sin(2\pi \frac{100}{201} x) + \sin(2\pi \frac{100}{301} x)</annotation></semantics></math>
has a period of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>605.01</mn><annotation encoding="application/x-tex">605.01</annotation></semantics></math>,
which is <em>much</em> larger because the two sine waves are slightly misaligned
and take a long time to resynchronize. For two sine waves with randomly chosen
periods, the resulting function typically has an incredibly large period. Even
if the periods aren’t randomly chosen, functions with a very long period can be
produced easily. For example:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>π</mi><msup><mn>0.91</mn><mn>0</mn></msup><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>π</mi><msup><mn>0.91</mn><mn>1</mn></msup><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>π</mi><msup><mn>0.91</mn><mn>2</mn></msup><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sin(2\pi 0.91^0 x) + \sin(2\pi 0.91^1 x) + \sin(2\pi 0.91^2 x)</annotation></semantics></math>
has a period of 10,000.</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>class</span> HillNoise:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, num_sines, random<span>=</span>random):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.wavelengths <span>=</span> [random() <span>for</span> _ <span>in</span> <span>range</span>(num_sines)]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span>def</span> evaluate(<span>self</span>, x):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        noise <span>=</span> <span>0</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span>for</span> wavelength <span>in</span> <span>self</span>.wavelengths:</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            noise <span>+=</span> sin(x<span>/</span>wavelength)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>.5</span> <span>+</span> <span>.5</span><span>*</span>noise<span>/</span><span>len</span>(<span>self</span>.wavelengths)</span></code></pre></div>

<p>The result of this is not terribly satisfying, because some of the sine waves
are undesirably steep. If we’re trying to mimic the bumpiness of real life
things, you typically don’t see bumps in the road that are as tall as a
mountain, but as wide as a pebble. Generally, the shorter the length of a bump,
the shorter the height of a bump. So, in order to emulate this, instead of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mi>/</mi><mtext mathvariant="monospace">𝚠𝚊𝚟𝚎𝚕𝚎𝚗𝚐𝚝𝚑</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sin(x/\texttt{wavelength})</annotation></semantics></math>,
let’s use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">𝚠𝚊𝚟𝚎𝚕𝚎𝚗𝚐𝚝𝚑</mtext><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mi>/</mi><mtext mathvariant="monospace">𝚠𝚊𝚟𝚎𝚕𝚎𝚗𝚐𝚝𝚑</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\texttt{wavelength}\sin(x/\texttt{wavelength})</annotation></semantics></math>,
which makes the amplitude directly proportional to the wavelength. This concept
is similar to the <a href="https://sites.math.washington.edu/~conroy/general/weierstrass/weier.htm" target="_blank" rel="noreferrer">Weierstrass Function,</a> which has the sort of
bumpiness we’re looking for.</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>class</span> HillNoise:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, num_sines, random<span>=</span>random):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sizes <span>=</span> [random() <span>for</span> _ <span>in</span> <span>range</span>(num_sines)]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span>def</span> evaluate(<span>self</span>, x):</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        noise <span>=</span> <span>0</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span>for</span> size <span>in</span> <span>self</span>.sizes:</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>            noise <span>+=</span> size<span>*</span>sin(x<span>/</span>size)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>.5</span> <span>+</span> <span>.5</span><span>*</span>noise<span>/</span><span>sum</span>(<span>self</span>.sizes)</span></code></pre></div>
<p>It’s a bit unfortunate that this noise function always evaluates to exactly
0.5 at x=0, so let’s introduce some random offsets. (This will be even more
useful later.)</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>class</span> HillNoise:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, num_sines, random<span>=</span>random):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sizes <span>=</span> [random() <span>for</span> _ <span>in</span> <span>range</span>(num_sines)]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.offsets <span>=</span> [random()<span>*</span><span>2</span><span>*</span>pi <span>for</span> _ <span>in</span> <span>range</span>(num_sines)]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span>def</span> evaluate(<span>self</span>, x):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        noise <span>=</span> <span>0</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span>for</span> size,offset <span>in</span> <span>zip</span>(<span>self</span>.sizes, <span>self</span>.offsets):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            noise <span>+=</span> size<span>*</span>sin(x<span>/</span>size <span>+</span> offset)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>.5</span> <span>+</span> <span>.5</span><span>*</span>noise<span>/</span><span>sum</span>(<span>self</span>.sizes)</span></code></pre></div>
<p>Now, this function is already pretty useful, and it comes with built-in
octaves with different levels of detail. But, ideally it would be nice if you
could ask for different distributions of bumpiness. Maybe you don’t care about
any noise whose amplitude is less than 0.1, or maybe you want a lot of small
noise and a lot of big noise, but not much in between. So, let’s modify the
function to take in an arbitrary set of wavelengths:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>class</span> HillNoise:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, sizes, random<span>=</span>random):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sizes <span>=</span> sizes</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.offsets <span>=</span> [random()<span>*</span><span>2</span><span>*</span>pi <span>for</span> _ <span>in</span> <span>range</span>(<span>len</span>(sizes))]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span>def</span> evaluate(<span>self</span>, x):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        noise <span>=</span> <span>0</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span>for</span> size,offset <span>in</span> <span>zip</span>(<span>self</span>.sizes, <span>self</span>.offsets):</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            noise <span>+=</span> size<span>*</span>sin(x<span>/</span>size <span>+</span> offset)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>.5</span> <span>+</span> <span>.5</span><span>*</span>noise<span>/</span><span>sum</span>(<span>self</span>.sizes)</span></code></pre></div>
<p>Because we added the random offsets earlier, we can now create two different
noise functions with the same wavelengths, but which produce totally different
noise! Nice!</p>
<p>So far, this is looking pretty good, but when we throw in a <em>whole
lot</em> of sine waves of similar amplitude, they kind of tend to average out
and we get a very bland noise function. According to the <a href="https://en.wikipedia.org/wiki/Central_limit_theorem" target="_blank" rel="noreferrer">Central Limit Theorem,</a> randomly sampling points on this
noise function will have an approximately normal distribution, and the standard
deviation will get smaller and smaller when more sine waves are added. In order
to counteract this, we need to use the <a href="https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function" target="_blank" rel="noreferrer">cumulative distribution function</a> of the
normal distribution. Unfortunately, it’s rather tricky to compute the cumulative
distribution function, but luckily we don’t need to be very exact, and Wikipedia
conveniently has <a href="https://en.wikipedia.org/wiki/Normal_distribution#Numerical_approximations_for_the_normal_CDF" target="_blank" rel="noreferrer">an entire section on numerical approximations
of the normal CDF.</a> Using a little bit of math black magic, it’s possible to
calculate the standard deviation of the sum of the sine waves, and plug it into
the CDF approximation.</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>class</span> HillNoise:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, sizes, random<span>=</span>random):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sizes <span>=</span> sizes</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.offsets <span>=</span> [random()<span>*</span><span>2</span><span>*</span>pi <span>for</span> _ <span>in</span> <span>range</span>(<span>len</span>(sizes))]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sigma <span>=</span> sqrt(<span>sum</span>((a<span>/</span><span>2</span>)<span>**</span><span>2</span> <span>for</span> a <span>in</span> <span>self</span>.sizes))</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span>def</span> evaluate(<span>self</span>, x):</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        noise <span>=</span> <span>0</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span>for</span> size,offset <span>in</span> <span>zip</span>(<span>self</span>.sizes, <span>self</span>.offsets):</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            noise <span>+=</span> size<span>*</span>sin(x<span>/</span>size <span>+</span> offset)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span># Approximate normal CDF:</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        noise <span>/=</span> sigma</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span>return</span> (<span>0.5</span><span>*</span>(<span>-</span><span>1</span> <span>if</span> noise <span>&lt;</span> <span>0</span> <span>else</span> <span>1</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>                <span>*</span>sqrt(<span>1</span> <span>-</span> exp(<span>-</span><span>2</span><span>/</span>pi <span>*</span> noise<span>*</span>noise)) <span>+</span> <span>0.5</span>)</span></code></pre></div>
<p>The end result of this is noise that is still quite noisy, but now it’s
(approximately) evenly distributed between 0 and 1:</p>

<p>With this evenly distributed noise function, it’s fairly easy to create noise
with any precise distribution that you want using <a href="https://en.wikipedia.org/wiki/Inverse_transform_sampling" target="_blank" rel="noreferrer">inverse transform sampling.</a> For example, here’s a <a href="https://en.wikipedia.org/wiki/Weibull_distribution" target="_blank" rel="noreferrer">Weibull distribution</a> (with adjustable parameters alpha and
beta):</p>

<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>class</span> WeibullHillNoise:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, sizes, alpha, beta, random<span>=</span>random):</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.hill_noise <span>=</span> HillNoise(sizes, random)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.alpha, <span>self</span>.beta <span>=</span> alpha, beta</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span>def</span> evaluate(<span>self</span>, x):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        u <span>=</span> <span>1.0</span> <span>-</span> <span>self</span>.hill_noise.evaluate(x)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>self</span>.alpha <span>*</span> (<span>-</span>math.log(u)) <span>**</span> (<span>1.0</span><span>/</span><span>self</span>.beta)</span></code></pre></div>
<p>That’s quite powerful! And it’s not something that can be easily achieved
with just any old noise function.</p>
<h3 id="d-hill-noise">2D Hill Noise</h3>
<p>Now, this is a lovely noise function, but it only works for 1 dimension of
input. Let’s expand it to work in 2 dimensions! Instead of summing up sin(x)
values, let’s sum up
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mo>sin</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{\sin(x)+\sin(y)}{2}</annotation></semantics></math>
values.</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>class</span> HillNoise2D:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, sizes, random<span>=</span>random):</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sizes <span>=</span> sizes</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.offsets <span>=</span> [random()<span>*</span><span>2</span><span>*</span>pi <span>for</span> _ <span>in</span> <span>2</span><span>*</span><span>range</span>(<span>len</span>(sizes))]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sigma <span>=</span> sqrt(<span>sum</span>((a<span>/</span><span>2</span>)<span>**</span><span>2</span> <span>for</span> a <span>in</span> <span>self</span>.sizes))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span>def</span> evaluate(<span>self</span>, x, y):</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        noise <span>=</span> <span>0</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span>for</span> i,size <span>in</span> <span>enumerate</span>(<span>self</span>.sizes):</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            noise <span>+=</span> size<span>/</span><span>2</span><span>*</span>(sin(x<span>/</span>size <span>+</span> <span>self</span>.offsets[<span>2</span><span>*</span>i])</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>                             <span>+</span> sin(y<span>/</span>size <span>+</span> <span>self</span>.offsets[<span>2</span><span>*</span>i<span>+</span><span>1</span>]))</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span># Approximate normal CDF:</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        noise <span>/=</span> <span>2</span><span>*</span>sigma</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span>return</span> (<span>0.5</span><span>*</span>(<span>-</span><span>1</span> <span>if</span> noise <span>&lt;</span> <span>0</span> <span>else</span> <span>1</span>)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>                <span>*</span>sqrt(<span>1</span> <span>-</span> exp(<span>-</span><span>2</span><span>/</span>pi <span>*</span> noise<span>*</span>noise)) <span>+</span> <span>0.5</span>)</span></code></pre></div>
<p>These will be axis-aligned, which is problematic because it will make the
noise function much less random-looking, so for each 2D sine wave, let’s rotate
its coordinates by a random angle.</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>class</span> HillNoise2D:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, sizes, random<span>=</span>random):</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sizes <span>=</span> sizes</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.offsets <span>=</span> [random()<span>*</span><span>2</span><span>*</span>pi <span>for</span> _ <span>in</span> <span>range</span>(<span>len</span>(sizes))]</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.rotations <span>=</span> [random()<span>*</span><span>2</span><span>*</span>pi <span>for</span> _ <span>in</span> <span>range</span>(<span>len</span>(sizes))]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sigma <span>=</span> sqrt(<span>sum</span>((a<span>/</span><span>2</span>)<span>**</span><span>2</span> <span>for</span> a <span>in</span> <span>self</span>.sizes))</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span>def</span> evaluate(<span>self</span>, x, y):</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        noise <span>=</span> <span>0</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span>for</span> i,size <span>in</span> <span>enumerate</span>(<span>self</span>.sizes):</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            <span># Rotate coordinates</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            rotation <span>=</span> <span>self</span>.rotations[i]</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>            u <span>=</span> x<span>*</span>cos(rotation) <span>-</span> y<span>*</span>sin(rotation)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            v <span>=</span> <span>-</span>x<span>*</span>sin(rotation) <span>-</span> y<span>*</span>cos(rotation)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            noise <span>+=</span> size<span>/</span><span>2</span><span>*</span>(sin(u<span>/</span>size <span>+</span> <span>self</span>.offsets[<span>2</span><span>*</span>i])</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>                             <span>+</span> sin(v<span>/</span>size <span>+</span> <span>self</span>.offsets[<span>2</span><span>*</span>i<span>+</span><span>1</span>]))</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span># Approximate normal CDF:</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        noise <span>/=</span> <span>2</span><span>*</span>sigma</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span>return</span> (<span>0.5</span><span>*</span>(<span>-</span><span>1</span> <span>if</span> noise <span>&lt;</span> <span>0</span> <span>else</span> <span>1</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>                <span>*</span>sqrt(<span>1</span> <span>-</span> exp(<span>-</span><span>2</span><span>/</span>pi <span>*</span> noise<span>*</span>noise)) <span>+</span> <span>0.5</span>)</span></code></pre></div>
<p>That looks pretty good, but sometimes the randomly generated rotations are
nearly aligned for similar-sized sine waves, and it causes some unfortunate
aliasing. Really, we don’t need the rotations to be random, but we want them to
be fairly evenly distributed, and similarly sized sine waves should have
not-parallel, not-perpendicular rotations. There’s a fairly clever trick for
doing almost exactly this task using the Golden Ratio, that I learned about <a href="http://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/" target="_blank" rel="noreferrer">in this blog post about generating random
colors programmatically.</a> Let’s use that technique instead of purely random
rotations.</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>GOLDEN_RATIO <span>=</span> (sqrt(<span>5</span>)<span>+</span><span>1</span>)<span>/</span><span>2</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span>class</span> HillNoise2D:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, sizes, random<span>=</span>random):</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sizes <span>=</span> sizes</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.offsets <span>=</span> [random()<span>*</span><span>2</span><span>*</span>pi <span>for</span> _ <span>in</span> <span>2</span><span>*</span><span>range</span>(<span>len</span>(sizes))]</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sigma <span>=</span> sqrt(<span>sum</span>((a<span>/</span><span>2</span>)<span>**</span><span>2</span> <span>for</span> a <span>in</span> <span>self</span>.sizes))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span>def</span> evaluate(<span>self</span>, x, y):</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        noise <span>=</span> <span>0</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span>for</span> i,size <span>in</span> <span>enumerate</span>(<span>self</span>.sizes):</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            <span># Rotate coordinates</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            rotation <span>=</span> (i<span>*</span>GOLDEN_RATIO <span>%</span> <span>1</span>)<span>*</span><span>2</span><span>*</span>pi</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>            u <span>=</span> x<span>*</span>cos(rotation) <span>-</span> y<span>*</span>sin(rotation)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            v <span>=</span> <span>-</span>x<span>*</span>sin(rotation) <span>-</span> y<span>*</span>cos(rotation)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            noise <span>+=</span> size<span>/</span><span>2</span><span>*</span>(sin(u<span>/</span>size <span>+</span> <span>self</span>.offsets[<span>2</span><span>*</span>i])</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>                             <span>+</span> sin(v<span>/</span>size <span>+</span> <span>self</span>.offsets[<span>2</span><span>*</span>i<span>+</span><span>1</span>]))</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span># Approximate normal CDF:</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        noise <span>/=</span> <span>2</span><span>*</span>sigma</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span>return</span> (<span>0.5</span><span>*</span>(<span>-</span><span>1</span> <span>if</span> noise <span>&lt;</span> <span>0</span> <span>else</span> <span>1</span>)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>                <span>*</span>sqrt(<span>1</span> <span>-</span> exp(<span>-</span><span>2</span><span>/</span>pi <span>*</span> noise<span>*</span>noise)) <span>+</span> <span>0.5</span>)</span></code></pre></div>
<p>Here’s what the finished product looks like:</p>

<h3 id="d-hill-noise-1">3D Hill Noise</h3>
<p>Great! Now what about 3D noise? Well… it gets a fair bit more complicated.
For one thing, it’s fairly hard to visualize 3D noise, because it has a
different value at every point in 3D space. It’s a lot harder to notice if there
are any artifacts. So instead, I’m going to visualize it as 2D noise and use
time as the 3rd dimension to produce a noise function that wobbles randomly over
time. The trick we used for evenly spacing the rotations last time isn’t going
to work anymore, because now we need random polar coordinate rotations. With a
lot of experimentation, and thanks to the excellent paper <a href="https://www.graphics.rwth-aachen.de/media/hill-noise/papers/jgt.pdf" target="_blank" rel="noreferrer">Golden Ratio Sequences For Low-Discrepancy
Sampling,</a> I managed to come up with a way to generate evenly spaced polar
rotations that satisfy the same requirements we had for 2D noise. The end result
is starting to get a bit hairy, but it looks like this:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>GOLDEN_RATIO <span>=</span> (sqrt(<span>5</span>)<span>+</span><span>1</span>)<span>/</span><span>2</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span>class</span> HillNoise3D:</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span>def</span> <span>__init__</span>(<span>self</span>, sizes, random<span>=</span>random):</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sizes <span>=</span> sizes</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.offsets <span>=</span> [random()<span>*</span><span>2</span><span>*</span>pi <span>for</span> _ <span>in</span> <span>range</span>(<span>len</span>(sizes))]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span>self</span>.sigma <span>=</span> sqrt(<span>sum</span>((a<span>/</span><span>2</span>)<span>**</span><span>2</span> <span>for</span> a <span>in</span> <span>self</span>.sizes))</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span>def</span> evaluate(<span>self</span>, x, y):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        fib_num <span>=</span> floor(log((resolution<span>-</span><span>1</span>)<span>*</span>sqrt(<span>5</span>) <span>+</span> <span>.5</span>)<span>/</span>log(GOLDEN_RATIO))</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        dec <span>=</span> floor(<span>.5</span> <span>+</span> (GOLDEN_RATIO<span>**</span>fib_num)<span>/</span>sqrt(<span>5</span>))</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        inc <span>=</span> floor(<span>.5</span> <span>+</span> dec<span>/</span>GOLDEN_RATIO)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        noise <span>=</span> <span>0</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        j <span>=</span> <span>0</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span>for</span> i <span>in</span> <span>range</span>(<span>len</span>(<span>self</span>.sizes)):</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>            <span>if</span> j <span>&gt;=</span> dec:</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>                j <span>-=</span> dec</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>            <span>else</span>:</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>                j <span>+=</span> inc</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>                <span>if</span> j <span>&gt;=</span> <span>len</span>(<span>self</span>.sizes):</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>                    j <span>-=</span> dec</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>            <span># Convert golden ratio sequence into polar coordinate unit vector</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>            phi <span>=</span> ((i<span>*</span>GOLDEN_RATIO) <span>%</span> <span>1</span>) <span>*</span> <span>2</span><span>*</span>pi</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>            theta <span>=</span> acos(<span>-</span><span>1</span><span>+</span><span>2</span><span>*</span>((j<span>*</span>GOLDEN_RATIO) <span>%</span> <span>1</span>))</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>            <span># Make an orthonormal basis, where n1 is from polar phi/theta,</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>            <span># n2 is roated 90 degrees along phi, and n3 is the</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>            <span># cross product of the two</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>            n1x,n1y,n1z <span>=</span> sin(phi)<span>*</span>cos(theta), sin(phi)<span>*</span>sin(theta), cos(phi)</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>            n2x,n2y,n2z <span>=</span> cos(phi)<span>*</span>cos(theta), cos(phi)<span>*</span>sin(theta), <span>-</span>sin(phi)</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>            <span># Cross product</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>            n3x,n3y,n3z <span>=</span> (n1y<span>*</span>n2z <span>-</span> n1z<span>*</span>n2y,</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>                           n1z<span>*</span>n2x <span>-</span> n1x<span>*</span>n2z,</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>                           n1x<span>*</span>n2y <span>-</span> n1y<span>*</span>n2x)</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>            <span># Convert pos from x/y/z coordinates to n1/n2/n3 coordinates</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>            u <span>=</span> n1x<span>*</span>x <span>+</span> n1y<span>*</span>y <span>+</span> n1z<span>*</span>z</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>            v <span>=</span> n2x<span>*</span>x <span>+</span> n2y<span>*</span>y <span>+</span> n2z<span>*</span>z</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>            w <span>=</span> n3x<span>*</span>x <span>+</span> n3y<span>*</span>y <span>+</span> n3z<span>*</span>z</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>            <span># Pull the amplitude from the shuffled array index (&#34;j&#34;), not &#34;i&#34;,</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>            <span># otherwise neighboring unit vectors will have similar amplitudes!</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>            size <span>=</span> <span>self</span>.sizes[j]</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>            <span># Noise is the average of cosine of distance along</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>            <span># each axis, shifted by offsets and scaled by amplitude.</span></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>            noise <span>+=</span> size<span>/</span><span>3</span><span>*</span>(cos(u<span>/</span>size <span>+</span> <span>self</span>.offsets[<span>3</span><span>*</span>i])</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>                             <span>+</span> cos(v<span>/</span>size <span>+</span> <span>self</span>.offsets[<span>3</span><span>*</span>i<span>+</span><span>1</span>])</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>                             <span>+</span> cos(w<span>/</span>size <span>+</span> <span>self</span>.offsets[<span>3</span><span>*</span>i<span>+</span><span>2</span>]))</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>        <span># Approximate normal CDF:</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>        noise <span>/=</span> <span>3</span><span>*</span>sigma</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>        <span>return</span> (<span>0.5</span><span>*</span>(<span>-</span><span>1</span> <span>if</span> noise <span>&lt;</span> <span>0</span> <span>else</span> <span>1</span>)</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>                <span>*</span>sqrt(<span>1</span> <span>-</span> exp(<span>-</span><span>2</span><span>/</span>pi <span>*</span> noise<span>*</span>noise)) <span>+</span> <span>0.5</span>)</span></code></pre></div>
<p>Whew! That’s a heck of a function! But look at the great results!</p>

<p>(The sizes of the sine waves here are generated by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mi>i</mi><mo>+</mo><mn>0.5</mn></mrow><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mi>m</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi>h</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><annotation encoding="application/x-tex">(\frac{i+0.5}{N+1})^{-\log(smoothness)}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="monospace">𝚜𝚖𝚘𝚘𝚝𝚑𝚗𝚎𝚜𝚜</mtext><annotation encoding="application/x-tex">\texttt{smoothness}</annotation></semantics></math>
is an adjustable parameter.)</p>
<p>With all of these changes, the resulting Hill Noise algorithm:</p>
<ul>
<li>Will (practically) never repeat itself.</li>
<li>Has highly configurable characteristics that are easy to understand (sine
wave counts and size distributions).</li>
<li>Is memory efficient and easy to implement in a shader, even without access
to a pseudorandom number generator.</li>
<li>Produces noise that is (nearly) uniformly distributed across the [0,1]
interval.</li>
<li>Can be modified to calculate exact surface normals/gradients.</li>
</ul>

</article>

</div></div>
  </body>
</html>
