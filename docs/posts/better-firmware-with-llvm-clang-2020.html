<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interrupt.memfault.com/blog/arm-cortexm-with-llvm-clang">Original</a>
    <h1>Better Firmware with LLVM/Clang (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>

        <p>If you have ever done software development that involves Apple products, FreeBSD, WebAssembly, or Rust, you have used the wildly popular compiler toolchain known as LLVM. However, LLVM and the open source C-language compiler built on top of it (Clang) do not get a lot of attention in the embedded world.</p>

<!-- excerpt start -->

<p>In this article, I hope I can convince you that adding a Clang build target to your project can be
a relatively simple and useful endeavor. We will cover how to take advantage of some of the
rich features shipped with the toolchain and identify some memory leaks and mutex deadlocks in an
example project at compile time! We will also walk through a step-by-step example of updating a GCC
based ARM Cortex-M project to cross-compile with LLVM/Clang.</p>

<!-- excerpt end -->

<blockquote>
  <p>Note: While the focus of the article will be using LLVM/Clang with ARM Cortex-M embedded devices, the
general overview of LLVM as well as the features leveraged can be applied to any architecture
supported by the toolchain.</p>
</blockquote>



<h2 id="background-of-gcc-and-clang">Background of GCC and Clang</h2>

<p>The advent of open source compilers and toolchains traces back over 30 years to 1987 and the
release of GCC 1.0. Originally, GCC was meant to compile GNU open source
software written in C. The toolchain grew organically over time to target numerous architectures and support a
variety of different languages. As a consequence, many aspects of the codebase have become complex to extend and work with.</p>

<p>The LLVM project is the “new” open source compiler on the block. It began as a research project at the
University of Illinois at Urbana–Champaign in 2000<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" rel="footnote">1</a></sup>. The early goals of the project were to create a
more modular compiler toolchain by designing a collection of standalone libraries. The LLVM project really took root in 2005 when Apple hired one of the original designers, Chris
Lattner, and invested heavily in making LLVM the default used for its own developer ecosystem. This
bore Clang, the C, C++, and objective-C frontend to LLVM and modern day GNU GCC competitor.</p>

<p>Today, the LLVM toolchain has become ubiquitous in the software world and, in recent years, it has seen
adoption in the embedded world as well. Its favorable license in comparison to the GNU
toolchain (Apache 2 vs GPL3) along with its more modular architecture has made the LLVM toolchain a
default choice in the proprietary embedded compiler market. ARM scrapped their original compiler in
favor of an LLVM/Clang based one with the release of ARM Compiler 6 (<code>armclang</code>) and, more recently,
SEGGER built an ARM compiler based on the LLVM/Clang toolchain as
well<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" rel="footnote">2</a></sup>.</p>

<h2 id="benefits-of-adding-a-clang-build">Benefits of Adding a Clang Build</h2>

<p>Many embedded projects use GCC, or one of other proprietary compilers such as IAR or the ARM
Compiler. You <em>do not</em> have to stop using your current compiler for builds to start benefiting from
LLVM/Clang.</p>

<p>Adding a Clang build target to your pre-existing project has the following benefits:</p>

<ul>
  <li>Static analysis! (More on this in the following sections)</li>
  <li>Makes your codebase less dependent on a single compiler feature set and makes it easier to transition from one compiler to another in the future (for example, a proprietary one to a free one).</li>
  <li>Two sets of error flags is better than one. You can use both compilers <code>-Werror</code> equivalent to maximize the issues you
find before needing to do any debug on target.</li>
  <li>By compiling with Clang, you are setting yourself up nicely for running unit tests and simulated
builds on host platforms.</li>
</ul>

<h2 id="example-project">Example Project</h2>

<p>Throughout the article we will use a simple example project that runs FreeRTOS and can be
run on the NRF52840. If you would like to follow along locally all of the code can be found on <a href="https://github.com/memfault/interrupt/tree/master/example/freertos-example-llvm/" target="_blank">GitHub</a>.</p>

<h2 id="installing-llvmclang">Installing LLVM/Clang</h2>

<p>The easiest way to get your hands on the latest release of the LLVM/Clang toolchain is to download
the release for your OS from the
<a href="https://releases.llvm.org/download.html" target="_blank">“Pre-Built Binaries” section</a> on the official website.</p>

<p>In this article, we use LLVM 10.0.0:</p>

<div><div><pre><code># OSX
$ wget &#34;https://github.com/llvm/llvm-project/releases/download/llvmorg-10.0.0/clang+llvm-10.0.0-x86_64-apple-darwin.tar.xz&#34;
$ tar -xf clang+llvm-10.0.0-x86_64-apple-darwin.tar.xz

# Ubuntu
$ wget &#34;https://github.com/llvm/llvm-project/releases/download/llvmorg-10.0.0/clang+llvm-10.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz&#34;
$ tar -xf clang+llvm-10.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz
</code></pre></div></div>

<p>Let’s add the toolchain to our path:</p>

<div><div><pre><code><span># OSX</span>
<span>$ </span><span>export </span><span>PATH</span><span>=</span><span>`</span><span>pwd</span><span>`</span>/clang+llvm-10.0.0-x86_64-apple-darwin/bin:<span>$PATH</span>

<span># Ubuntu</span>
<span>$ </span><span>export </span><span>PATH</span><span>=</span><span>`</span><span>pwd</span><span>`</span>/clang+llvm-10.0.0-x86_64-linux-gnu-ubuntu-18.04/bin:<span>$PATH</span>
</code></pre></div></div>

<p>You can sanity check that the install is working by running <code>clang --version</code>:</p>

<div><div><pre><code><span>$ </span>clang <span>--version</span>
clang version 10.0.0
Target: x86_64-apple-darwin18.5.0
Thread model: posix
InstalledDir: &lt;SHOULD MATCH PATH YOU JUST ADDED ABOVE&gt;
</code></pre></div></div>

<h2 id="static-analysis-with-clang-and-scan-build">Static Analysis With Clang and scan-build</h2>

<p><a href="#porting-gcc-to-clang">Further down in this post</a>, we will dive into how to migrate a project using GCC to Clang, but
first, let’s take a look at some of the awesome static analysis passes and checkers we can run on
our example project with LLVM/Clang!</p>

<h3 id="overview-of-scan-build">Overview of scan-build</h3>

<p><code>scan-build</code> is a static analyzer included as part of the LLVM toolchain. It works by intercepting calls to <code>gcc</code> or <code>clang</code> and making a static analysis pass.</p>

<p><code>scan-build</code> works by overriding the <code>CC</code> and <code>CXX</code> used by <code>CMake</code> and <code>Make</code>. If you aren’t doing anything tricky in your project, invoking the tool is as simple as:</p>

<div><div><pre><code><span>$ </span>scan-build make
<span>$ </span>scan-build cmake ..
</code></pre></div></div>

<p><code>scan-build</code> has a number of “Checkers”<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" rel="footnote">3</a></sup> enabled by default. You can view them by running <code>scan-build --help</code>:</p>

<div><div><pre><code><span>$ </span>scan-build <span>--help</span>
CONTROLLING CHECKERS:

 A default group of checkers are always run unless explicitly disabled.
 Checkers may be enabled/disabled using the following options:

 <span>-enable-checker</span> <span>[</span>checker name]
 <span>-disable-checker</span> <span>[</span>checker name]
<span>[</span>...]
AVAILABLE CHECKERS:

 + core.CallAndMessage           Check <span>for </span>logical errors <span>for function </span>calls and Objective-C message expressions <span>(</span>e.g., uninitialized arguments, null <span>function </span>pointers<span>)</span>
 + core.DivideZero               Check <span>for </span>division by zero
 + core.DynamicTypePropagation   Generate dynamic <span>type </span>information
 + core.NonNullParamChecker      Check <span>for </span>null pointers passed as arguments to a <span>function </span>whose arguments are references or marked with the <span>&#39;nonnull&#39;</span> attribute
 + core.NullDereference          Check <span>for </span>dereferences of null pointers
 + core.StackAddressEscape       Check that addresses to stack memory <span>do </span>not escape the <span>function</span>
 + core.UndefinedBinaryOperatorResult Check <span>for </span>undefined results of binary operators
<span>[</span>...]
NOTE: <span>&#34;+&#34;</span> indicates that an analysis is enabled by default.
</code></pre></div></div>

<p>The default set is a good starting point, and you can easily enable non-default ones or
disable individual defaults. You can even implement your own custom pugins but these topics are outside the scope of this article.</p>

<p>Let’s run scan-build on our example project. We’ll see it finds a few interesting potential issues that neither Clang or GCC noticed during compilation.</p>

<p>Results will be emitted directly to the console but you can also browse them using the <code>scan-view</code>
command bundled with LLVM. <code>scan-view</code> will open an html representation of all the issues
discovered. From this view, you can easily filter by issue type and dig into the specifics of an analysis pass.</p>

<p>I’ve included <a href="https://interrupt.memfault.com/misc/llvm_scan_build_report">the full output for the example project here</a> but here’s an
example of the type of information you will see:</p>

<h4 id="report-overview">Report Overview</h4>

<p><img src="https://interrupt.memfault.com/img/llvm/example_llvm_scanbuild_report.png" alt=""/></p>

<h4 id="report-analysis-example">Report Analysis Example</h4>

<p><img src="https://interrupt.memfault.com/img/llvm/example_llvm_scanbuild_analysis.png" alt=""/></p>

<h4 id="running-scan-build">Running scan-build</h4>

<div><div><pre><code><span>$ </span><span>cd </span>interrupt/examples/freertos-example-llvm/
<span>$ </span>make clean
<span>$ </span>scan-build make
scan-build: Using <span>&#39;bin/clang-10&#39;</span> <span>for </span>static analysis
<span>[</span>...]
Linking library
Generated build/nrf52.elf
scan-build: 8 bugs found.
scan-build: Run <span>&#39;scan-view /var/folders/dm/b0yt&#39;</span> to examine bug reports.
</code></pre></div></div>

<p><code>scan-build</code> uses <code>gcc</code> by default on some platforms.
If this happens, you may see error messages related to unrecognized command line options and the <code>===GCC Compiler Detected===</code> message.
Set the compiler for <code>scan-build</code> to clang with the <code>--use-cc</code> and <code>--use-c++</code> options:</p>
<div><div><pre><code><span>$ </span>scan-build <span>--use-cc</span><span>=</span>clang <span>--use-c</span>++<span>=</span>clang make
</code></pre></div></div>

<h4 id="corenulldereference-checker">core.NullDereference Checker</h4>

<div><div><pre><code><span>int</span> <span>example_operate_on_pointer</span><span>(</span><span>uint8_t</span> <span>*</span><span>pointer</span><span>)</span> <span>{</span>
  <span>int</span> <span>result</span> <span>=</span> <span>0</span><span>;</span>
  <span>if</span> <span>(</span><span>pointer</span> <span>==</span> <span>NULL</span><span>)</span> <span>{</span>
    <span>result</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
  <span>}</span>
  <span>result</span> <span>+=</span> <span>*</span><span>pointer</span><span>;</span>
  <span>return</span> <span>result</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code>src/builtin_scanbuild_examples.c:13:13:
  warning: Dereference of null pointer <span>(</span>loaded from variable <span>&#39;pointer&#39;</span><span>)</span>
  result +<span>=</span> <span>*</span>pointer<span>;</span>
</code></pre></div></div>

<blockquote>
  <p>NOTE: The NullDereference Checker only looks for null pointer accesses <em>after</em> there has already been a nullability check. This helps prevent the generation of false positives for functions that never get passed a NULL pointer.</p>
</blockquote>

<h4 id="coredividezero-checker">core.DivideZero Checker</h4>

<div><div><pre><code><span>int</span> <span>example_divide_by_zero</span><span>(</span><span>int</span> <span>denominator</span><span>)</span> <span>{</span>
  <span>int</span> <span>rv</span> <span>=</span> <span>5</span><span>;</span>
  <span>if</span> <span>(</span><span>denominator</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>rv</span> <span>=</span> <span>1</span> <span>/</span> <span>denominator</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>rv</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code>src/builtin_scanbuild_examples.c:20:11: warning: Division by zero
  rv <span>=</span> 1 / denominator<span>;</span>
</code></pre></div></div>

<h3 id="enabling-malloc-static-analysis-checkers">Enabling “Malloc” Static Analysis Checkers</h3>

<p><code>scan-build</code> also includes a sophisticated suite of dynamic memory checkers to catch bugs such as
memory leaks, use-after-free and double free errors (These are mostly run as part of the <code>unix.Malloc</code> checker). If you use the C standard library calls (i.e
<code>calloc</code>, <code>malloc</code>, <code>free</code>, etc) in your embedded project, these checks will work out of the box.</p>

<p>However, for many embedded projects this is not the case. It’s typical to have a heap (or “byte
pool”) per subsystem (i.e network stack, graphics, sensor data, etc). This can help prevent
one subsystem from taking down the other. In other embedded systems, RAM speed may not be heterogeneous, and it may
be desirable to partition RAM into pools by access speed. This way subsystems requiring the
fastest RAM (i.e graphics) can use one heap and subsystems which do not care can use slower RAM.</p>

<p>Conveniently, you can use compiler attributes to flag functions that behave like “malloc” and enable the
<code>unix.Malloc</code> checkers on them. Let’s set this up for the <code>memory_pool.h</code> file in our example project:</p>

<div><div><pre><code><span>#pragma once
</span><span>//! @file memory_pool.h</span>

<span>#include &lt;stddef.h&gt;
</span>
<span>void</span> <span>*</span><span>memory_pool_allocate</span><span>(</span><span>size_t</span> <span>size</span><span>);</span>
<span>void</span> <span>memory_pool_free</span><span>(</span><span>void</span> <span>*</span><span>ptr</span><span>);</span>
</code></pre></div></div>

<h4 id="attributes-for-malloc-checking-on-custom-functions">Attributes For Malloc Checking on Custom Functions</h4>

<p>In our <code>compiler.h</code> header we will add the following:</p>

<div><div><pre><code><span>#if defined(__clang__)
</span>
<span>#define EXAMPLE_PROJ_MALLOC_LIKE_FUNC \
  __attribute__((ownership_returns(malloc)))
</span>
<span>//! Note: Second Argument is the argument index for</span>
<span>//! the pointer being free&#39;d. For simplicity, let&#39;s assume</span>
<span>//! the pointer is always in the 1st argument</span>
<span>#define EXAMPLE_PROJ_FREE_LIKE_FUNC \
__attribute__((ownership_takes(malloc, 1)))
</span>
<span>#else
</span>
<span>#define EXAMPLE_PROJ_MALLOC_LIKE_FUNC
#define EXAMPLE_PROJ_FREE_LIKE_FUNC
</span>
<span>#endif
</span></code></pre></div></div>

<h5 id="aside-prefix-project-macros">Aside: Prefix Project Macros!</h5>

<p>Due to the C language’s lack of namespacing, it’s a good idea to prefix your macros to avoid collisions with
other libraries. (i.e <code>MY_PROJECT_MIN()</code> instead of <code>MIN()</code>).</p>

<p>This helps avoid define collisions with poorly structured libraries and prevents the use of the
<code>#ifndef</code>-<code>#define</code>-<code>#endif</code> anti-pattern:</p>

<div><div><pre><code><span>#ifndef MIN
#define MIN(a, b) (((a) &lt; (b)) ? (a) : (b))
#endif
</span></code></pre></div></div>

<h4 id="instrument-custom-malloc-implementation">Instrument Custom Malloc Implementation</h4>

<p>We’ll update <code>memory_pool.h</code> to use the attributes defined above and apply one small workaround so the checker
works with our custom functions:</p>

<div><div><pre><code><span>#pragma once
</span><span>//! @file memory_pool.h</span>

<span>#include &lt;stddef.h&gt;
</span>
<span>EXAMPLE_PROJ_MALLOC_LIKE_FUNC</span>
<span>void</span> <span>*</span><span>memory_pool_allocate</span><span>(</span><span>size_t</span> <span>size</span><span>);</span>

<span>//! As of LLVM 10, the &#34;unix.MismatchedDeallocator&#34; expects</span>
<span>//! memory to always be released with free() and will emit</span>
<span>//! the following error if not:</span>
<span>//!</span>
<span>//! &#34;warning: Memory allocated by my_malloc_func(), should be</span>
<span>//! deallocated by free(), not my_free_func()&#34;</span>
<span>//!</span>
<span>//! To circumvent the error for now we remap our custom free</span>
<span>//! function to free() when scan-build is running. Hopefully, future</span>
<span>//! releases of Clang make it possible to change this rule via annotations.</span>
<span>#ifdef __clang_analyzer__
#define memory_pool_free free
#endif
</span>
<span>EXAMPLE_PROJ_FREE_LIKE_FUNC</span>
<span>void</span> <span>memory_pool_free</span><span>(</span><span>void</span> <span>*</span><span>ptr</span><span>);</span>
</code></pre></div></div>

<p>Let’s try it out on a few examples:</p>

<div><div><pre><code><span>uint32_t</span> <span>example_access_garbage</span><span>(</span><span>void</span><span>)</span> <span>{</span>
  <span>const</span> <span>size_t</span> <span>size</span> <span>=</span> <span>10</span><span>;</span>
  <span>uint8_t</span> <span>*</span><span>ptr</span> <span>=</span> <span>memory_pool_allocate</span><span>(</span><span>size</span><span>);</span>
  <span>if</span> <span>(</span><span>ptr</span> <span>==</span> <span>NULL</span><span>)</span> <span>{</span>
    <span>return</span> <span>0</span><span>;</span>
  <span>}</span>

  <span>// access the data before setting it</span>
  <span>uint32_t</span> <span>sum</span> <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>size_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>size</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>sum</span> <span>+=</span> <span>ptr</span><span>[</span><span>i</span><span>];</span>
  <span>}</span>

  <span>return</span> <span>sum</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code>$ cd interrupt/examples/freertos-example-llvm/
$ make clean
$ scan-build make
[...]
src/memory_leak_examples.c:31:9:
  warning: Assigned value is garbage or undefined
    sum += ptr[i];
</code></pre></div></div>

<div><div><pre><code><span>uint32_t</span> <span>example_memory_leak</span><span>(</span><span>void</span><span>)</span> <span>{</span>
  <span>const</span> <span>size_t</span> <span>size</span> <span>=</span> <span>10</span><span>;</span>
  <span>uint8_t</span> <span>*</span><span>ptr</span> <span>=</span> <span>memory_pool_allocate</span><span>(</span><span>size</span><span>);</span>
  <span>if</span> <span>(</span><span>ptr</span> <span>==</span> <span>NULL</span><span>)</span> <span>{</span>
    <span>return</span> <span>0</span><span>;</span>
  <span>}</span>

  <span>// ... do something with the pointer ...</span>
  <span>const</span> <span>uint8_t</span> <span>return_code</span> <span>=</span> <span>((</span><span>uint32_t</span><span>)(</span><span>uintptr_t</span><span>)</span><span>ptr</span><span>)</span> <span>?</span> <span>0xa5</span> <span>:</span> <span>0xef</span><span>;</span>
  <span>if</span> <span>(</span><span>return_code</span> <span>==</span> <span>0xa5</span><span>)</span> <span>{</span>
    <span>return</span> <span>1</span><span>;</span>
  <span>}</span>

  <span>memory_pool_free</span><span>(</span><span>ptr</span><span>);</span>
  <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code>$ cd interrupt/examples/freertos-example-llvm/
$ make clean
$ scan-build make
[...]
src/memory_leak_examples.c:47:12:
  warning: Potential leak of memory pointed to by &#39;ptr&#39;
    return 1;
</code></pre></div></div>

<h3 id="using-clangs-thread-safety-analysis-for-rtos-mutexes">Using Clangs Thread Safety Analysis for RTOS Mutexes</h3>

<p>Clang also supports a Thread Safety Analyzer which can catch deadlocks and race
conditions that arise when writing multi-threaded applications (or using multiple tasks in a RTOS). The checkers are enabled at
compile time by using the <code>-Wthread-safety</code> compiler flag so there is zero runtime overhead!</p>

<p>The analyzer was contributed and is maintained by Google and is used “extensively in Google’s
internal code base”.<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" rel="footnote">4</a></sup> There is pretty good documentation about
how to leverage the feature for C++. However, the analyzers can be used for C code as well via compiler attributes.
It’s pretty common in an embedded system with an RTOS to have mutexes for subsystems such as
an accelerometer or flash driver. In our example project we have:</p>

<div><div><pre><code><span>//! @file mutex.h</span>
<span>void</span> <span>flash_lock</span><span>(</span><span>void</span><span>);</span>
<span>void</span> <span>flash_unlock</span><span>(</span><span>void</span><span>);</span>

<span>void</span> <span>accel_lock</span><span>(</span><span>void</span><span>);</span>
<span>void</span> <span>accel_unlock</span><span>(</span><span>void</span><span>);</span>
</code></pre></div></div>

<p>To use the analyzer we need to annotate where locks are given and released. We can also
flag if certain functions require a lock. We can wrap all of these behind macros in <code>compiler.h</code>:</p>

<h4 id="macros-helpers-for-utilizing--wthread-safety-in-c">Macros helpers for utilizing -Wthread-safety in C</h4>

<div><div><pre><code><span>//! The Thread Safety Analyzers need an identifier to track things by</span>
<span>//! When using C++, this capability attribute can be bound to a Class.</span>
<span>//! For C, we&#39;ll just create a dummy variable that is not referenced</span>
<span>//! by actual code so it gets optimized away during compilation.</span>
<span>typedef</span> <span>int</span> <span>__attribute__</span><span>((</span><span>capability</span><span>(</span><span>&#34;mutex&#34;</span><span>)))</span>
  <span>_ClangThreadSafetyLockReference</span><span>;</span>
<span>#define INTERNAL_EXAMPLE_PROJ_DECLARE_LOCK_TRACKER(name) \
  extern _ClangThreadSafetyLockReference _##name
</span>
<span>//! Flags a function that acquires a resource. In our example</span>
<span>//! we&#39;ll want to apply this attribute to flash_lock() and</span>
<span>//! accel_lock().</span>
<span>#define EXAMPLE_PROJ_FUNC_ACQUIRES_LOCK(name) \
  INTERNAL_EXAMPLE_PROJ_DECLARE_LOCK_TRACKER(name); \
  __attribute__((acquire_capability(_##name)))
</span>
<span>//! Flags a function that releases a resource. For our example,</span>
<span>//! the accel_unlock() and flash_unlock() functions need this.</span>
<span>#define EXAMPLE_PROJ_FUNC_RELEASES_LOCK(name) \
  __attribute__((release_capability(_##name)))
</span>
<span>//! Flags a function as requiring a lock be held by the time</span>
<span>//! it is invoked. For example, an &#34;accel_read()&#34; function.</span>
<span>#define EXAMPLE_PROJ_FUNC_REQUIRES_LOCK_HELD(name) \
  __attribute__((requires_capability(_##name)))
</span>
<span>//! Disables thread safety checks for a function</span>
<span>//! This is required for the *_lock and *_unlock functions</span>
<span>//! in our example to prevent False positives.</span>
<span>#define EXAMPLE_PROJ_FUNC_DISABLE_LOCK_CHECKS \
  __attribute__((no_thread_safety_analysis))
</span></code></pre></div></div>

<p>Let’s update our code to take advantage of the annotations:</p>

<div><div><pre><code><span>#pragma once
</span>
<span>//! @file mutex.h</span>
<span>#include &#34;example_project/compiler.h&#34;
</span>
<span>// ...</span>

<span>EXAMPLE_PROJ_FUNC_ACQUIRES_LOCK</span><span>(</span><span>flash</span><span>)</span>
<span>void</span> <span>flash_lock</span><span>(</span><span>void</span><span>);</span>

<span>EXAMPLE_PROJ_FUNC_RELEASES_LOCK</span><span>(</span><span>flash</span><span>)</span>
<span>void</span> <span>flash_unlock</span><span>(</span><span>void</span><span>);</span>

<span>EXAMPLE_PROJ_FUNC_ACQUIRES_LOCK</span><span>(</span><span>accel</span><span>)</span>
<span>void</span> <span>accel_lock</span><span>(</span><span>void</span><span>);</span>

<span>EXAMPLE_PROJ_FUNC_RELEASES_LOCK</span><span>(</span><span>accel</span><span>)</span>
<span>void</span> <span>accel_unlock</span><span>(</span><span>void</span><span>);</span>

<span>EXAMPLE_PROJ_FUNC_REQUIRES_LOCK_HELD</span><span>(</span><span>accel</span><span>)</span>
<span>extern</span> <span>void</span> <span>example_func_requires_accel</span><span>(</span><span>void</span><span>);</span>
</code></pre></div></div>

<p>Now let’s try out a few examples:</p>

<div><div><pre><code><span>void</span> <span>example_flash_lock_bug</span><span>(</span><span>void</span><span>)</span> <span>{</span>
  <span>flash_lock</span><span>();</span>

  <span>int</span> <span>rv</span> <span>=</span> <span>do_some_work_while_holding_locks</span><span>();</span>
  <span>if</span> <span>(</span><span>rv</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
    <span>return</span><span>;</span>
  <span>}</span>
  <span>flash_unlock</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code><span>$ </span><span>cd </span>interrupt/examples/freertos-example-llvm/
<span>$ </span>make clean
<span>$ CLI_CFLAG_OVERRIDES</span><span>=</span><span>-Wthread-safety</span> <span>COMPILER</span><span>=</span>clang make
<span>[</span>...]
src/mutex_examples.c:14:1:
  error: mutex <span>&#39;_flash&#39;</span> is not held on every path through here
      <span>[</span><span>-Werror</span>,-Wthread-safety-analysis]
<span>}</span>
^
src/mutex_examples.c:7:3: note: mutex acquired here
  flash_lock<span>()</span><span>;</span>
</code></pre></div></div>

<div><div><pre><code><span>void</span> <span>example_accel_lock_bug</span><span>(</span><span>void</span><span>)</span> <span>{</span>
  <span>example_func_requires_accel</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code><span>$ </span><span>cd </span>interrupt/examples/freertos-example-llvm/
<span>$ </span>make clean
<span>$ CLI_CFLAG_OVERRIDES</span><span>=</span><span>-Wthread-safety</span> <span>COMPILER</span><span>=</span>clang make
<span>[</span>...]
src/mutex_examples.c:17:3:
  error: calling <span>function</span> <span>&#39;example_func_requires_accel&#39;</span> requires holding
      mutex <span>&#39;_accel&#39;</span> exclusively <span>[</span><span>-Werror</span>,-Wthread-safety-analysis]
  example_func_requires_accel<span>()</span><span>;</span>
</code></pre></div></div>

<p>Pretty neat, right?!</p>

<p>Some additional checkers can be enabled via annotations as well to enforce certain locks are acquired
before/after others. Take a look at the official documentation for more ideas!<sup id="fnref:8:1" role="doc-noteref"><a href="#fn:8" rel="footnote">4</a></sup>.</p>

<h3 id="additional-clang-specific-compiler-warnings">Additional Clang Specific Compiler Warnings</h3>

<p>Once you can compile your project with Clang, there are other compiler warnings not
supported by other compilers that you can enable. These can be helpful for catching potential bugs or issues.</p>

<p>The exhaustive list of “Diagnostic Warnings” supported by Clang can be found in the official documentation online<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">5</a></sup>. However, I find it easiest to run a build with all the possible Clang warnings enabled by using <code>-Weverything</code>, disabling all errors (<code>-Wno-error</code>) and piping the compilation output to a file I can grep after the fact. Let’s try it out on the example project:</p>

<div><div><pre><code><span>$ </span>make clean <span>&amp;&amp;</span> <span>CLI_CFLAG_OVERRIDES</span><span>=</span><span>&#34;-Weverything -Wno-error&#34;</span> <span>\</span>
  <span>COMPILER</span><span>=</span>clang make &amp;&gt; compilation_results.txt
<span>$ </span><span>grep</span> <span>-o</span> <span>&#34;</span><span>\[\-</span><span>W.*</span><span>\]</span><span>.*&#34;</span> compilation_results.txt | <span>sort</span> <span>-u</span>
<span>[</span><span>-Wcovered-switch-default</span><span>]</span>
<span>[</span><span>-Wdocumentation-html</span><span>]</span>
<span>[</span><span>-Wdocumentation-unknown-command</span><span>]</span>
<span>[</span><span>-Wdocumentation</span><span>]</span>
<span>[</span><span>-Wextra-semi-stmt</span><span>]</span>
<span>[</span><span>-Wimplicit-int-conversion</span><span>]</span>
<span>[</span><span>-Wmissing-noreturn</span><span>]</span>
<span>[</span><span>-Wmissing-prototypes</span><span>]</span>
<span>[</span><span>-Wmissing-variable-declarations</span><span>]</span>
<span>[</span><span>-Wpadded</span><span>]</span>
<span>[</span><span>-Wpedantic</span><span>]</span>
<span>[</span><span>-Wunused-macros</span><span>]</span>
<span>[</span><span>-Wunused-parameter</span><span>]</span>
</code></pre></div></div>

<p>Sweet! We have discovered quite a few warnings we can go and investigate as to whether we want to enable or not.</p>

<blockquote>
  <p>Tip: For a production project, I actually like to leave
<code>-Weverything</code> enabled. You can use a tool such as <a href="https://interrupt.memfault.com/blog/conda-developer-environments">Conda</a> to ensure all developers are on the same version of
LLVM/Clang and see the exact same errors and <code>-Wno-&lt;warning&gt;</code> (i.e <code>-Wno-pedantic</code>) to disable
any warnings that are not useful for your application.</p>
</blockquote>

<blockquote>
  <p>Note: I haven’t had a chance to try it out yet but it’s worth noting that GCC is catching up on
the static analysis front. In GCC 10, a bunch of new static analyzers
were added via the <code>-fanalyzer</code> option.<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" rel="footnote">6</a></sup></p>
</blockquote>

<h2 id="porting-gcc-to-clang">Setting up your project to compile with GCC &amp; Clang</h2>

<p>Now that we have seen a small sampling of what we can do with LLVM/Clang, let’s walk through the
steps involved to update a GCC based project to compile with it!</p>

<p>Fortunately, the LLVM/Clang project has made every effort to support GNU GCC assembly,
attributes, compiler flags &amp; GNU linker script syntax, so a majority of the code in your project
should already be compatible and the migration effort should be quite minimal.</p>

<h3 id="make-build-system-compiler-aware">Make Build System Compiler Aware</h3>

<p>There will be a few system updates we will want to make depending on the compiler we are using. For example, Clang has a number of flags that GCC does not support so we will only want to enable those when Clang is in use.</p>

<p>Here is a template of what a makefile supporting both Clang and GCC targets can look like:</p>

<div><div><pre><code><span># Set things up to use the arm-none-eabi-gcc that is on</span>
<span># our path by default but allow things to be easily overridden, i.e:</span>
<span>#</span>
<span># COMPILER=&lt;PATH_TO_OTHER_GCC_VERSION&gt;/arm-none-eabi-gcc make</span>
<span># COMPILER=clang make</span>
COMPILER ?<span>=</span> arm-none-eabi-gcc
CC <span>=</span> <span>$(</span>COMPILER<span>)</span>

<span># [ ... ]</span>

ifneq <span>&#39;&#39;</span> <span>&#39;$(findstring clang,$(CC_VERSION_INFO))&#39;</span>
<span>$(</span>info <span>===</span>Clang Compiler <span>Detected</span><span>===</span><span>)</span>

COMPILER_SPECIFIC_CFLAGS +<span>=</span>
COMPILER_SPECIFIC_LDFLAGS +<span>=</span>

endif


ifneq <span>&#39;&#39;</span> <span>&#39;$(findstring gcc,$(CC_VERSION_INFO))&#39;</span>
<span>$(</span>info <span>===</span>GCC Compiler <span>Detected</span><span>===</span><span>)</span>

COMPILER_SPECIFIC_CFLAGS +<span>=</span>
COMPILER_SPECIFIC_LDFLAGS +<span>=</span>

endif

CFLAGS +<span>=</span> <span>$(</span>COMPILER_SPECIFIC_CFLAGS<span>)</span>
LDFLAGS +<span>=</span> <span>$(</span>COMPILER_SPECIFIC_LDFLAGS<span>)</span>
</code></pre></div></div>



<p>You’ll probably encounter some code in your project that is compatible with GCC but not Clang. For
any project supporting multiple compilers you will find a “compiler.h” style header that wraps
compiler specifics behind a common macro. For example, for Clang you need to use a different
attribute to disable optimizations on a function.</p>

<div><div><pre><code><span>//! @file example_project/compiler.h</span>

<span>#if defined(__clang__)
</span>
<span>#define EXAMPLE_PROJ_NO_OPT __attribute__((optnone))
</span>
<span>#elif defined(__GNUC__)
</span>
<span>#define EXAMPLE_PROJ_NO_OPT __attribute__((optimize(&#34;O0&#34;)))
</span>
<span>#else
#  error &#34;Unsupported Compiler&#34;
#endif
</span></code></pre></div></div>

<h2 id="cross-compiling-with-clang">Cross Compiling With Clang</h2>

<p>Unlike GCC, a default build of Clang is multi-target capable. To cross compile all you have to do
is specify the appropriate <code>--target</code> argument into Clang. If no <code>--target</code> is specified it falls
back to its default behavior of targeting the native host architecture.</p>

<p>You can dump a list of the architectures supported by running <code>llc --version</code>:</p>

<div><div><pre><code><span>$ </span>llc <span>--version</span>
LLVM <span>(</span>http://llvm.org/<span>)</span>:
  LLVM version 10.0.0
  Optimized build.
  Default target: x86_64-apple-darwin18.5.0
  Host CPU: skylake

  Registered Targets:
    aarch64    - AArch64 <span>(</span>little endian<span>)</span>
    aarch64_32 - AArch64 <span>(</span>little endian ILP32<span>)</span>
    aarch64_be - AArch64 <span>(</span>big endian<span>)</span>
    amdgcn     - AMD GCN GPUs
    arm        - ARM
<span>[</span> ... <span>]</span>
</code></pre></div></div>

<h4 id="the-clang-target-triple">The Clang Target Triple</h4>

<p>The value passed to <code>--target</code> itself is a bit complicated. The good thing is for ARM Cortex-M, you
can always pass the same value: <code>--target=arm-none-eabi</code>.</p>

<blockquote>
  <p>Feel free to skip to the <a href="#update-clang-baremetal">next section</a> if you aren’t interested in
learning more about the <code>--target</code> argument internals.</p>
</blockquote>

<h5 id="clang-target-triple-internals">Clang Target Triple Internals</h5>

<p>The makeup of a <code>--target</code> value is actually:</p>

<p><code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code></p>

<p>A rough breakdown of what is expected for ARM targets is:</p>

<ul>
  <li>
<code>arch</code>: One of the “registered targets” that was output from <code>llc --version</code> so for ARM it is <code>arm</code>.</li>
  <li>
<code>sub</code> : When left blank the value is inferred from other flags specified as part of the
compilation. For ARM Cortex-M, <code>v6m</code>, <code>v7m</code>, <code>v7em</code>, <code>v8m</code>, etc are all be legal values.</li>
  <li>
<code>vendor</code>: For ARM this can be left blank or you can specify <code>unknown</code> explicitly.</li>
  <li>
<code>sys</code>: For embedded targets this will be <code>none</code>. If you are compiling code targeting an OS, the
name of the OS will be used. For example, <code>linux</code> or <code>darwin</code>.</li>
  <li>
<code>abi</code>: For Embedded ARM this will always be <code>eabi</code> (“embedded-application binary interface”)</li>
</ul>

<p>If you stick with the <code>--target=arm-none-eabi</code> option suggested, the architecture will be resolved from the GCC compiler flags. (i.e Notably <code>-mcpu</code> or <code>-march</code>)</p>

<p>Confusingly, unspecified or invalid fields will be filled in or replaced under the hood by the
LLVM toolchain. This can make it hard to determine if you have specified a legal target or not:</p>

<div><div><pre><code><span>$ </span>clang <span>--target</span><span>=</span>armv7notrealsub-none-eabi <span>--print-target-triple</span>
armv7notrealsub-none-unknown-eabi
</code></pre></div></div>

<p>If you want to sanity check that the target being targeted is correct, the most reliable way I
have found to do this is by compiling an empty file and emitting LLVM Intermediate Representation (IR). The “target triple” line will inform
you what architecture code is actually being generated for:</p>

<h5 id="checking-target-triple-by-dumping-llvm-ir">Checking Target Triple By Dumping LLVM IR</h5>

<div><div><pre><code><span>$ </span><span>touch </span>test.c
<span>$ </span>clang <span>--target</span><span>=</span>armv7notrealsub-none-eabi <span>-emit-llvm</span> <span>-S</span> test.c
<span>$ </span><span>cat </span>test.ll | <span>grep</span> <span>&#34;target triple&#34;</span>
  target triple <span>=</span> <span>&#34;armv4t-none-unknown-eabi&#34;</span>
</code></pre></div></div>

<h3 id="update-clang-baremetal">Updating Clang to cross-compile a “bare-metal” target</h3>

<h4 id="arm-cortex-m-bare-metal-targets">ARM Cortex-M “bare-metal” targets</h4>

<p>When you compile an application to run on an operating system (i.e <code>darwin</code> or <code>linux</code> instead of <code>none</code>),
the C standard libraries will be picked up automatically for you. Code not targeting an OS is
often referred to as running on a “bare-metal” environment. With LLVM/Clang you
are responsible for providing locations of the standard libraries in this scenario, which is comprised of:</p>

<ul>
  <li>The C standard library<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">7</a></sup> – <code>libc.a</code>
</li>
  <li>Mathematical Functions of C standard library – Often, this is exported in a separate library, <code>libm.a</code>.</li>
  <li>Compiler Built-Ins – Most compilers include a set of built-in functions. The compiler will
opportunistically replace parts of your code with builtins for better performance or to save code
space. With GNU GCC these builtins are exposed via <code>libgcc.a</code><sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">8</a></sup>. With clang they are exposed
via <code>libclang_rt.builtins.*.a</code>. There is no formal specification for what builtins need to be
implemented but Clang makes every effort to match the exact subset required by GCC.</li>
</ul>

<p>Fortunately, for ARM Cortex-M development, the official GNU Arm toolchain<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">9</a></sup> bundles pre-compiled
variants of <a href="https://interrupt.memfault.com/blog/boostrapping-libc-with-newlib">Newlib’s libc and libm</a>.</p>

<p>When you compile a project with the GNU Arm toolchain, <code>libc.a</code> &amp; <code>libm.a</code> from the pre-compiled
Newlib as well as GCC’s <code>libgcc.a</code> will be linked into your project automatically.</p>

<p>I would suggest instead using the compiler flag <code>--nostdlib</code> to disable this behavior. This will force you
to manually specify these targets (by adding <code>-lc</code>, <code>-lm</code>, &amp; <code>-lgcc</code> to your LDFLAGS). It makes it
more explicit when library dependencies are pulled into your project and easier to experiment with
swapping in alternative versions of the standard library.</p>

<h4 id="adding-standard-libraries-to-clang-bare-metal-compilation">Adding standard libraries to Clang “bare-metal” compilation</h4>

<p>Clang does not bundle a C standard library for “bare-metal” ARM Cortex-M targets, so the
recommendation in this scenario is to use the libraries included with the GNU Arm toolchain.</p>

<p>GCC and Clang expose some useful compiler arguments to make this straightforward to accomplish. Notably, with
Clang we can use <code>--sysroot</code> to change the default search path Clang uses for standard includes.</p>

<p>In our Makefile we can use the following <code>arm-none-eabi-gcc</code> compiler commands to programmatically
build the paths we need to provide to Clang.</p>

<ul>
  <li>
<code>-print-sysroot</code> for the path to pass to Clangs <code>--sysroot</code> option</li>
  <li>
<code>-print-multi-directory</code> this will display where libc.a and libm.a within the gcc toolchain are located relative to <code>$SYS_ROOT/lib</code>
</li>
  <li>
<code>-print-libgcc-file-name</code> will dump the complete path to GCC builtin functions (<code>libgcc.a</code>)</li>
</ul>

<h5 id="makefile-modifications">Makefile Modifications</h5>

<p>Putting it all together and updating the Makefile we started above we have:</p>

<div><div><pre><code><span># Note: These arguments will be used by clang to select</span>
<span># the specific architecture target when we use the</span>
<span># invoke Clang with --target=arm-none-eabi</span>
ARCH_CFLAGS +<span>=</span> <span>\</span>
  <span>-mthumb</span> <span>-mcpu</span><span>=</span>cortex-m4 <span>\</span>
  <span>-mfloat-abi</span><span>=</span>hard <span>-mfpu</span><span>=</span>fpv4-sp-d16 <span>\</span>

<span># [ ... ]</span>

ifneq <span>&#39;&#39;</span> <span>&#39;$(findstring clang,$(CC_VERSION_INFO))&#39;</span>
<span>$(</span>info <span>===</span>Clang Compiler <span>Detected</span><span>===</span><span>)</span>

<span># Default assumes a GNU Arm toolchain is on your path</span>
<span># but an explicit path can also be provided by doing</span>
<span># ARM_GNU_CC=&lt;PATH_TO_GCC&gt; make</span>
ARM_CORTEXM_SYSROOT <span>=</span> <span>\</span>
  <span>$(</span>shell <span>$(</span>ARM_GNU_CC<span>)</span> <span>$(</span>ARCH_CFLAGS<span>)</span> <span>-print-sysroot</span> 2&gt;&amp;1<span>)</span>

<span># The directory where Newlib&#39;s libc.a &amp; libm.a reside</span>
<span># for the specific target architecture</span>
ARM_CORTEXM_MULTI_DIR <span>=</span> <span>\</span>
  <span>$(</span>shell <span>$(</span>ARM_GNU_CC<span>)</span> <span>$(</span>ARCH_CFLAGS<span>)</span> <span>-print-multi-directory</span> 2&gt;&amp;1<span>)</span>

<span># Pick up builtins needed for compilation</span>
ARM_CORTEXM_BUILTINS ?<span>=</span> <span>\</span>
<span>$(</span>shell <span>$(</span>ARM_GNU_CC<span>)</span> <span>$(</span>ARCH_CFLAGS<span>)</span> <span>-print-libgcc-file-name</span> 2&gt;&amp;1<span>)</span>

COMPILER_SPECIFIC_CFLAGS +<span>=</span> <span>\</span>
  <span>--target</span><span>=</span>arm-none-eabi <span>\</span>
  <span>--sysroot</span><span>=</span><span>$(</span>ARM_CORTEXM_SYSROOT<span>)</span>

COMPILER_SPECIFIC_LDFLAGS +<span>=</span> <span>\</span>
  <span>-L</span><span>$(</span>ARM_CORTEXM_SYSROOT<span>)</span>/lib/<span>$(</span>ARM_CORTEXM_MULTI_DIR<span>)</span> <span>\</span>
  <span>$(</span>ARM_CORTEXM_BUILTINS<span>)</span>
endif
</code></pre></div></div>

<h3 id="use-clangs--oz-instead-of--os">Use Clang’s <code>-Oz</code> instead of <code>-Os</code>
</h3>

<p>For embedded projects, the quality of a compiler is often evaluated by how small of a binary it can
create. With GCC, the smallest code is emitted when compiling with the <code>-Os</code> option. With Clang,
you will want to use <code>-Oz</code> instead which enables additional space optimizations beyond those
enabled by Clang’s version of <code>-Os</code>.</p>

<div><div><pre><code>ifneq <span>&#39;&#39;</span> <span>&#39;$(findstring clang,$(CC_VERSION_INFO))&#39;</span>
<span>$(</span>info <span>===</span>Clang Compiler <span>Detected</span><span>===</span><span>)</span>
<span># [ ... ]</span>

COMPILER_SPECIFIC_CFLAGS +<span>=</span> <span>\</span>
...
  <span>-0z</span>
endif

ifneq <span>&#39;&#39;</span> <span>&#39;$(findstring gcc,$(CC_VERSION_INFO))&#39;</span>
<span>$(</span>info <span>===</span>GCC Compiler <span>Detected</span><span>===</span><span>)</span>

COMPILER_SPECIFIC_CFLAGS +<span>=</span> <span>\</span>
  <span>-Os</span>
endif
</code></pre></div></div>

<h3 id="compiling-libclang_rtbuiltinsa-for-arm-cortex-m">Compiling libclang_rt.builtins*.a for ARM Cortex-M</h3>

<p>If you are interested in taking the road less traveled, it <em>is</em> possible to compile LLVMs builtin
library for ARM Cortex-M though I would not recommend it.</p>

<blockquote>
  <p>At this point we can compile our project with either GCC and Clang! <a href="#using-gcc-and-clang">Skip ahead</a>
to the next section to try that out instead!</p>
</blockquote>

<p>You can even find some documentation
about the endeavor <a href="https://llvm.org/docs/HowToCrossCompileBuiltinsOnArm.html" target="_blank">here</a>.</p>

<p>Disclaimers: At the time of writing this article,</p>

<ul>
  <li>Some of the official documentation, such as the instructions for “Alternative using a cmake cache” no
longer work.</li>
  <li>It does not appear possible to compile a builtin targeting the Cortex-M hard float ABI (i.e
<code>armv7em</code> target).</li>
  <li>It does not appear possible to compile <code>libclang_rt</code> for ARM Cortex-M on OSX. You need to use
Docker or be running on Linux natively.</li>
</ul>

<h4 id="setting-up-environment-for-libclang_rt-build">Setting up environment for libclang_rt build</h4>

<div><div><pre><code><span>$ </span><span>export </span><span>ARM_SYSROOT</span><span>=</span><span>$(</span>arm-none-eabi-gcc <span>-print-sysroot</span><span>)</span>

<span># This needs to be a complete ARM target triple to pick up</span>
<span># architecture specific optimizations</span>
<span>#   Cortex M0, M0+: armv6m-none-eabi</span>
<span>#   Cortex M3: armv7m-none-eabi</span>
<span>#   Cortex M4, M7: armv7em-none-eabi</span>
<span>#   Cortex M33: armv8m-none-eabi</span>
<span># Let&#39;s target Cortex M3 as an example:</span>
<span>$ </span><span>export </span><span>NONE_EABI_TARGET</span><span>=</span>armv7m-none-eabi

<span>$ </span><span>export </span><span>LLVM_BIN_PATH</span><span>=</span><span>$(</span><span>dirname</span> <span>$(</span>which clang<span>))</span>

<span># Only Soft Float ABI seems to work</span>
<span>$ </span><span>export </span><span>NONE_EABI_TARGET_FLAGS</span><span>=</span><span>&#34;-mthumb -mfloat-abi=soft -mfpu=none&#34;</span>
</code></pre></div></div>

<h4 id="configuring-and-compiling-libclang_rt-for-baremetal">Configuring and Compiling libclang_rt for baremetal</h4>

<p>Once you have set up the env you will need to checkout the compiler-rt project and compiler:</p>

<div><div><pre><code><span>$ </span>git clone https://github.com/llvm/llvm-project.git llvm-project
<span>$ </span><span>cd </span>llvm-project/compiler-rt
<span>$ </span><span>mkdir </span>build
<span>$ </span><span>cd </span>build

<span>$ </span>cmake <span>-G</span> <span>&#34;Unix Makefiles&#34;</span> <span>-DCMAKE_BUILD_TYPE</span><span>=</span>Release <span>\</span>
<span>-DCMAKE_TRY_COMPILE_TARGET_TYPE</span><span>=</span>STATIC_LIBRARY <span>\</span>
<span>-DCOMPILER_RT_OS_DIR</span><span>=</span><span>&#34;baremetal&#34;</span> <span>\</span>
<span>-DCOMPILER_RT_BUILD_BUILTINS</span><span>=</span>ON <span>\</span>
<span>-DCOMPILER_RT_BUILD_SANITIZERS</span><span>=</span>OFF <span>\</span>
<span>-DCOMPILER_RT_BUILD_XRAY</span><span>=</span>OFF <span>\</span>
<span>-DCOMPILER_RT_BUILD_LIBFUZZER</span><span>=</span>OFF <span>\</span>
<span>-DCOMPILER_RT_BUILD_PROFILE</span><span>=</span>OFF <span>\</span>
<span>-DCMAKE_C_COMPILER</span><span>=</span><span>${</span><span>LLVM_BIN_PATH</span><span>}</span>/clang <span>\</span>
<span>-DCMAKE_C_COMPILER_TARGET</span><span>=</span><span>${</span><span>NONE_EABI_TARGET</span><span>}</span> <span>\</span>
<span>-DCMAKE_ASM_COMPILER_TARGET</span><span>=</span><span>${</span><span>NONE_EABI_TARGET</span><span>}</span> <span>\</span>
<span>-DCMAKE_AR</span><span>=</span><span>${</span><span>LLVM_BIN_PATH</span><span>}</span>/llvm-ar <span>\</span>
<span>-DCMAKE_NM</span><span>=</span><span>${</span><span>LLVM_BIN_PATH</span><span>}</span>/llvm-nm <span>\</span>
<span>-DCMAKE_LINKER</span><span>=</span><span>${</span><span>LLVM_BIN_PATH</span><span>}</span>/ld.lld <span>\</span>
<span>-DCMAKE_RANLIB</span><span>=</span><span>${</span><span>LLVM_BIN_PATH</span><span>}</span>/llvm-ranlib <span>\</span>
<span>-DCOMPILER_RT_BAREMETAL_BUILD</span><span>=</span>ON <span>\</span>
<span>-DCOMPILER_RT_DEFAULT_TARGET_ONLY</span><span>=</span>ON <span>\</span>
<span>-DLLVM_CONFIG_PATH</span><span>=</span><span>${</span><span>LLVM_BIN_PATH</span><span>}</span>/llvm-config <span>\</span>
<span>-DCMAKE_C_FLAGS</span><span>=</span> <span>${</span><span>NONE_EABI_TARGET_FLAGS</span><span>}</span> <span>\</span>
<span>-DCMAKE_ASM_FLAGS</span><span>=</span><span>${</span><span>NONE_EABI_TARGET_FLAGS</span><span>}</span> <span>\</span>
<span>-DCOMPILER_RT_INCLUDE_TESTS</span><span>=</span>OFF <span>\</span>
<span>-DCMAKE_SYSROOT</span><span>=</span><span>${</span><span>ARM_SYSROOT</span><span>}</span> ..

<span>$ </span>make
...
<span>[</span>100%] Built target clang_rt.builtins-armv7m
Scanning dependencies of target builtins
<span>[</span>100%] Built target builtins
Scanning dependencies of target compiler-rt-headers
<span>[</span>100%] Built target compiler-rt-headers
Scanning dependencies of target compiler-rt
<span>[</span>100%] Built target compiler-rt
</code></pre></div></div>

<p>At the end of the build, the Clang <code>libgcc.a</code> equivalent will be emitted to <code>./lib/baremetal/libclang_rt.builtins-armv7m.a</code></p>

<p>You can swap <code>libgcc</code> with the generated <code>libclang_rt</code>in our example project by overrding
<code>ARM_CORTEXM_BUILTINS</code> when invoking make:</p>

<h5 id="swapping-libgcc-with-libclang_rtbuiltins-armv7m">Swapping libgcc with libclang_rt.builtins-armv7m</h5>

<div><div><pre><code><span>$ </span><span>cd </span>interrupt/examples/freertos-example-llvm/
<span>$ </span>make clean
<span>$ ARM_CORTEXM_BUILTINS</span><span>=</span><span>\</span>
  &lt;PATH_TO&gt;/lib/baremetal/libclang_rt.builtins-armv7m.a make
</code></pre></div></div>

<h2 id="using-gcc-and-clang">Compile Example Project with Both Clang and GCC!</h2>

<p>At this point, we can compile our example project with either GCC or Clang! Let’s take a look at the results:</p>

<h4 id="clang-build">Clang Build</h4>

<div><div><pre><code><span>$ </span><span>cd </span>interrupt/examples/freertos-example-llvm/
<span>$ </span>make clean
<span>$ COMPILER</span><span>=</span>clang make
<span>===</span>Clang Compiler <span>Detected</span><span>===</span>
<span># [...]</span>
Linking library
Generated build/nrf52.elf
   text    data     bss     dec     hex	filename
  10094    2368   13048   25510    63a6	build/nrf52.elf
</code></pre></div></div>

<h4 id="gcc-build">GCC Build</h4>

<div><div><pre><code><span>$ </span><span>cd </span>interrupt/examples/freertos-example-llvm/
<span>$ </span>make clean
<span>$ COMPILER</span><span>=</span>arm-none-eabi-gcc make
<span>===</span>GCC Compiler <span>Detected</span><span>===</span>
<span># [...]</span>
Linking library
Generated build/nrf52.elf
Generated build/nrf52.elf
   text    data     bss     dec     hex	filename
   9846    2112   13328   25286    62c6	build/nrf52.elf
</code></pre></div></div>

<h4 id="observations">Observations</h4>

<p>We can see for our simple example app the sizes are within about 1% of each other (25,510 bytes for Clang vs 25,286 bytes for GCC).</p>

<h2 id="linking-gcc-objects-with-llvms-linker">Linking GCC Objects with LLVMs Linker</h2>

<p>The LLVM linker (ld.lld) <sup id="fnref:9" role="doc-noteref"><a href="#fn:9" rel="footnote">10</a></sup> strives to be a drop-in replacement for the GNU linkers and has come a long way in
recent years in terms of compatibility.</p>

<p>There’s some pretty bold claims made on the official docs that may make you want to try it out:</p>

<blockquote>
  <p>LLD is very fast. When you link a large program on a multicore machine, you can expect that LLD runs more than twice as fast as the GNU gold linker. Your mileage may vary, though.</p>
</blockquote>

<p>As of GCC9<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" rel="footnote">11</a></sup>, it is even possible to tell GCC to use it instead of the GNU linker with the
<code>-fuse-ld=lld</code> option:</p>

<div><div><pre><code><span>$ </span><span>export </span><span>LLVM_BIN_PATH</span><span>=</span><span>$(</span><span>dirname</span> <span>$(</span>which ld.lld<span>))</span>
<span>$ </span>make clean
<span># NOTE: The -B&lt;PATH&gt; argument tells GCC to search PATH</span>
<span># for binaries</span>
<span>$ CLI_LDFLAG_OVERRIDES</span><span>=</span><span>&#34;-B</span><span>${</span><span>LLVM_ROOT</span><span>}</span><span> -Wl,-fuse-ld=lld&#34;</span> <span>\</span>
  <span>COMPILER</span><span>=</span>arm-none-eabi-gcc make
</code></pre></div></div>

<h2 id="final-thoughts">Final Thoughts</h2>

<p>I first experimented with Clang for Cortex-M in 2013 and at the time the backend for code-size
optimization for ARM just didn’t compete with other compilers like GCC. These days it seems like
things are getting pretty close, and I’m quite impressed at how the toolchain has progressed overall.</p>

<p>I hope this post gave you a useful overview of how to cross-compile your embedded ARM project with
LLVM/Clang and some of the neat things you can do once you have that working.</p>

<p>I’d love to hear if you already using LLVM/Clang in your embedded project today and if so, whether
it is for static analysis or for generating actual binaries. Either way, let us know in the discussion area below!</p>

<p>See anything you&#39;d like to change? Submit a pull request or open an issue on our <a href="https://github.com/memfault/interrupt" target="_blank">GitHub</a></p>

<h2 id="references">References</h2>




    </div><p><img src="https://interrupt.memfault.com/img/author/chris.jpg"/>
            
            <span>
                <a href="https://interrupt.memfault.com/authors/chris">Chris Coleman</a> is a founder and CTO at Memfault. Prior to founding Memfault, Chris worked on the embedded software teams at Sun, Pebble, and Fitbit.</span>

        </p></div>
  </body>
</html>
