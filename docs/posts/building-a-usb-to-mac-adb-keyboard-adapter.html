<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://paperstack.com/adb_usb_converter/">Original</a>
    <h1>Building a USB to Mac ADB keyboard adapter</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        
<p>
  <small>
  
  
  Jan 13, 2024
  </small>
  
<small><code><a href="https://paperstack.com/tags/qmk">QMK</a></code></small>
<small><code><a href="https://paperstack.com/tags/adb">ADB</a></code></small>
<small><code><a href="https://paperstack.com/tags/mac">Mac</a></code></small>
<small><code><a href="https://paperstack.com/tags/keyboard">Keyboard</a></code></small>
<small><code><a href="https://paperstack.com/tags/atmega32u4">Atmega32u4</a></code></small>
<small><code><a href="https://paperstack.com/tags/pro-micro">Pro Micro</a></code></small>
<small><code><a href="https://paperstack.com/tags/electronics">Electronics</a></code></small>
</p>
<p>About a year ago I started a new job as a Staff Engineer with a larger FinTech. Plenty of
upside, and I’m enjoying myself a lot, but the downside is that I’m obliged to work on
a Mac. I kind of hate Macs. Not quite as bad as Windows, but damn I’m missing Linux in
the workplace.</p>
<p>Note: <em>If you plan on following in my footsteps, do note that I did all the work described here
on my personal Linux machine over a weekend - it’s only the end result that I used on the
actual work Mac</em></p>
<p>However, this did give me an excuse to indulge my taste for retro-computing by picking up
an original <strong>Macintosh Extended Keyboard II</strong> - this beauty:</p>
<figure><img src="https://paperstack.com/img/adb_usb/keyboard.jpg"/><figcaption>
            <h4>Macintosh Extended Keyboard II</h4>
        </figcaption>
</figure>

<p>Partly I chose it because it’s of the vintage that I occasionally used during my final
year at university in the Mac lab - mostly while coding up a fairly hapless AI project
in Macintosh Common Lisp (MCL).</p>
<p>Apple always did things a bit differently, so while the IBM PC derived machines had
more-or-less standardised on the PS/2 based connectors, Macs had their own serial
bus system for keyboards and mice. The PC stuff and the Mac stuff both used a four
pin DIN connector just to ensure maximum confusion, and of course they were completely
incompatible.</p>
<p>The nice thing about the Apple system was that you could daisy chain it - and the keyboards
generally had a connector on both sides, making a rare concession to lefties who could thus
connect the keyboard on the right and chain the mouse off of it on the left side of the
keyboard if they chose.</p>
<p>Incidentally, if you were in a whimsical student mood, you could also chain all of the
keyboards on a row of machines end to end resulting in five or six machines completely
unconnected from their keyboard and the one at the end taking any and all input from
the neighbours. Ok, it was kind of a dick move, but in a lab full of IT students it
wasn’t too mean a trick and nobody was stymied for long.</p>
<p>The old connection system was called “<a href="https://en.wikipedia.org/wiki/Apple_Desktop_Bus">Apple Desktop Bus</a>”
(ADB). These days Macs are firmly USB oriented for their minor peripherals, so getting an old-skool
keyboard to talk to a spiffy modern M1 Mac requires a suitable adapter. There are a handful of
commercially available adapters, but it’s more fun to build something and it’s the kind of
project that’s actually within reach of even my meagre electronics skills.</p>
<p>The <a href="https://qmk.fm/">QMK Project</a> is the basis for the device that I therefore built - it’s
better known as a basis for building custom keyboards, but it also contains some code for
building adapters.  The wiring required is well documented in the README for the source
folder for the adapter logic: <a href="https://github.com/qmk/qmk_firmware/tree/master/keyboards/converter/adb_usb">https://github.com/qmk/qmk_firmware/tree/master/keyboards/converter/adb_usb</a></p>
<p>The ASCII art wiring diagram stolen from that is:</p>
<pre tabindex="0"><code>ADB Socket from front: 

  ,--_--.
 / o4 3o \      1: DATA
| o2   1o |     2: Power SW
 -  ===  -      3: VCC
  `-___-&#39;       4: GND
  

  Keyboard       Converter
               ,------.
5V------+------|VCC   |
        |      |      |
       [R]     |      |
        |      |      |
Signal--+------|PD0   |
               |      |
GND------------|GND   |
               `------&#39;
R: 1K Ohm resistor
</code></pre><p>I think I ended up using a 4.7KΩ resistor - but I can’t remember why. Probably I saw it in some online
instructions somewhere, but I’ve lost it now - my apologies to whichever reference I’m thus failing to
cite here.</p>
<p>I picked up a cheap clone of a <a href="https://learn.sparkfun.com/tutorials/pro-micro--fio-v3-hookup-guide">Pro Micro</a>
board on Amazon. The original and the clone are both based around
the <a href="https://www.microchip.com/en-us/product/atmega32u4">atmega32u4</a> and the pinouts are
identical. The circuit consists of the board, a single resistor, and the DIN connector,
so there’s really very little to do.</p>
<p>The one “gotcha” worth mentioning is that the <code>PD0</code> pin mentioned in the QMK documentation
corresponds to the <code>D3</code> pin on the processor board, <em>not</em> the <code>D0</code> pin as you might (I did)
assume initially.</p>
<p>Burning the firmware was actually (marginally) harder than soldering it all together! However
you should ignore the instructions on the README for the adapter logic - that’s a bit outdated
and seems to be left over from the original <a href="https://github.com/tmk/tmk_keyboard">TMK</a> origin
of the code. Instead, follow the instructions
<a href="https://docs.qmk.fm/#/newbs_flashing?id=flash-your-keyboard-from-the-command-line">outlined in the main QMK documentation</a>:</p>
<p>After cloning <a href="https://github.com/qmk/qmk_firmware/">the QMK repository</a> locally, the first
steps were actually to install a <code>qmk</code> python command independently of that:</p>
<div><pre tabindex="0"><code data-lang="bash">python3 -m pip install --user qmk
export PATH<span>=</span>$PATH:$HOME/.local/bin
qmk setup
</code></pre></div><p>Note in the above that the <code>.local/bin</code> directory is not, on Ubuntu, in your path by default due to
a long-standing Ubuntu bug. Running the <code>qmk setup</code> command will prompt you to install all
the pre-requisites necessary for building the actual adapter logic.</p>
<p>With that complete you’re good to go to build the adapter-specific code from the root of the
checked out QMK repository:</p>
<div><pre tabindex="0"><code data-lang="bash">qmk compile -kb converter/adb_usb -km default
</code></pre></div><p>The <code>default</code> here is the keyboard map - you can alternatively build and compile
in any weird mapping you choose.</p>
<p>The result of the build should be a file <code>converter_adb_usb_rev1_default.hex</code> and
the next task is to get that loaded into the microcontroller.</p>
<p>Happily this requires no special steps and everything is auto-detected with the following
command:</p>
<div><pre tabindex="0"><code data-lang="bash">qmk flash converter_adb_usb_rev1_default.hex
</code></pre></div><p>With the adapter logic flashed onto the microcontroller and everything wired up, you should
see the adapter show up in the USB device list as <code>QMK ADB to USB Keyboard Converter</code>:</p>
<div><pre tabindex="0"><code data-lang="bash">dcminter@kanelbulle:~$ lsusb
Bus <span>002</span> Device 010: ID 413c:81b6 Dell Computer Corp. DW5811e Snapdragon™ X7 LTE
Bus <span>002</span> Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus <span>001</span> Device 005: ID feed:0adb QMK ADB to USB Keyboard Converter
Bus <span>001</span> Device 003: ID 8087:0a2b Intel Corp. Bluetooth wireless interface
Bus <span>001</span> Device 002: ID 0bda:568c Realtek Semiconductor Corp. Integrated Webcam HD
Bus <span>001</span> Device 004: ID 0a5c:5834 Broadcom Corp. <span>5880</span>
Bus <span>001</span> Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
</code></pre></div><p>A minor gotcha to mention - I had a lot of initial trouble flashing the image, but I eventually
realised that this was because the cable I was using was garbage. It came with some cheap crap
audio gadget and was apparently barely good enough to use for charging and nothing else. All
my issues went away when I swapped it for a good one!</p>
<p>I built my adapter on a bit of veroboard and I wanted to hide that away. A bit of measuring
with calipers, some tinkering in <a href="https://www.tinkercad.com/">Tinkercad</a>, and sliiiightly more do-overs due to my horrible
3D design skills than I might have liked, and I had a design for a case to put it all in:</p>
<figure><img src="https://paperstack.com/img/adb_usb/tinkercad.jpg"/><figcaption>
            <h4>Case design in Tinkercad</h4>
        </figcaption>
</figure>

<p>I know Tinkercad is the wrong tool for the job, but it’s so quick to get
started even if it ends up taking longer. I swear I will learn SolveSpace properly
real soon now (tm). I did have a go at learning FreeCad a while back, but that thing
is so buggy and inconsistent that TinkerCad seems like the better bet of the two!</p>
<p>Anyway, with the design in hand and exported as an STL file I fired up Cura, pushed it
over to my 3D printer, and ran off the case</p>
<figure><img src="https://paperstack.com/img/adb_usb/printing.jpg"/><figcaption>
            <h4>The case printing on my Ender 3 Pro</h4>
        </figcaption>
</figure>

<p>The end result was a good fit for the electronics - though I’m kicking myself for soldering
the DIN adapter on first and not after I’d decided on the dimensions of the case because the
wires are all the wrong length. I could unsolder and re-solder it, but it’s not quite worth
the effort as it will all be hidden from the eye. Here are the innards resting in the base
of the case:</p>
<figure><img src="https://paperstack.com/img/adb_usb/exposed_electronics.jpg"/><figcaption>
            <h4>The exposed electronics</h4>
        </figcaption>
</figure>

<p>You can see there’s almost nothing except the microcontroller here - a resistor and a few wires with
all the smarts being the pre-existing controller board. I was pleased with the fit of the
DIN connector though - it has a 1mm ridge that holds it securely in place and I got a
good fit for this despite the necessary variability in the physical output versus digital
input.</p>
<p>The result, inline to the keyboard and bolted together, is respectably beige. If I
retro-bright the keyboard it would be a better match for the shade, but I quite enjoy
the legacy-discoloration of the keyboard.</p>
<figure><img src="https://paperstack.com/img/adb_usb/wired_up.jpg"/><figcaption>
            <h4>The adapter inline</h4>
        </figcaption>
</figure>

<p>Anyway, it worked out ok as I’m typing these words on the Apple
Extended Keyboard now!</p>
<p>Next steps are to figure out how (if) one can get a suitable key mapped as the
function key - though since I mostly use it to switch between multimedia mode
and “natural” F1 to F12 keys, I can do without it if necessary. In that case I’d
set up for F-keys to be default and hit the laptop keyboard’s Fn key directly when I
need the multimedia ones.</p>
<p>So far the only problem I have is that … I don’t actually like it as much as the
modern external keyboard that work supplied. We’ll see if it grows on me, but
building it was fun so I consider myself amply rewarded regardless.</p>

      </article>
    </div></div>
  </body>
</html>
