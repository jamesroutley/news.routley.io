<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://darthnull.org/noisestorms/">Original</a>
    <h1>Ping Storms at GreyNoise</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    <div itemprop="articleBody">
    <p>Earlier this month, I attended BSidesNoVA in Arlington, where the keynote was presented by Andrew Morris of GreyNoise. Using sensors distributed all over the world, GreyNoise collects…background noise…on the Internet. Basically, they watch and monitor activity that hits lots of hosts randomly – network mapping, port scanning, doorknob rattling. If you see someone trying to break into your SSH server, you can check GreyNoise to see if that person (well, their IP, anyway) has been seen doing such things in the past.</p>
<p>In January 2020, they started seeing massive increases in background noise, especially in ICMP and incomplete TCP handshakes. This was discussed during the talk, along with how the noise seems to come and go, and it’s been driving them crazy. On September 17, GreyNoise dedicated their regular Storm Watch program on YouTube to the phenomenon, and they posted a <a href="https://www.greynoise.io/blog/greynoise-reveals-new-internet-noise-storm-secret-messages-and-the-china-connection">blog entry about it the next day</a>.</p>
<p>After his talk, we spent about an hour geeking about these storms. I’d worked with him some years back, and he knew how I love these weird puzzles, so he was as eager to talk about it as I was. We discussed all kinds of things – the most intriguing idea was covert communication – and I asked about a million questions, most of which he’d looked into already.</p>
<p>I didn’t get much of a chance to poke at things for the next couple weeks, but after their Storm Watch, I cracked my knuckles <em>(not really – I’ve never been able to do that reliably)</em> and got to work. Yesterday afternoon, I may have figured it out. Well, figured out some of it, anyway.</p>
<h2 id="gotta-write-a-script">Gotta Write a Script</h2>
<p>But first, I have to figure out how to work with the data. Grey Noise published a huge tranche of data on GitHub, but I wanted to play with a smaller set. Andrew was kind enough to give me access to some other pcaps, and I selected about 200 packets of data from mid-September.</p>
<p>During the Storm Watch segment, we briefly saw a crazy command-line script using tshark and a huge gawk pipeline to parse and display the data. That’s right up my alley – but super complicated. I wanted something where I could easily select which fields I cared about, filter down on specific data, and start to do things like frequency analysis, etc. So I turned to an old favorite: scapy. In short order, I had a tool written that made it a lot easier for me to slice-and-dice the data. Pretty quickly, I came to notice a few details.</p>
<p>But wait, I should back up. One of the more intriguing parts of all this was what’s in these packets. We’re focusing on the ICMP traffic (since it’s much more common in the noise than TCP). These packets look like normal ping requests, but with some random-looking data in the payload. Plus, the word “LOVE.”</p>
<figure>
  <a href="https://darthnull.org/media/2024/09/payload.png"><img src="https://darthnull.org/media/2024/09/payload.png" alt="I just LOVE a good mystery..."/></a>
  <figcaption><p>I just LOVE a good mystery...</p></figcaption>
</figure>
    

<p>That hex dump is..hard to focus on. You can see why I wanted my own tool to play with the data. Here’s some of my pcap dump, with just a few fields selected:</p>
<figure>
  <a href="https://darthnull.org/media/2024/09/dump1.png"><img src="https://darthnull.org/media/2024/09/dump1.png" alt="(in the payload, 4c4f5645 = &#39;LOVE&#39;)"/></a>
  <figcaption><p>(in the payload, 4c4f5645 = &#39;LOVE&#39;)</p></figcaption>
</figure>
    

<h2 id="always-crazy-in-arlington">Always Crazy in Arlington</h2>
<p>Let’s jump back a little, to earlier discussions of just what’s going on. As he talked about the noise during Q&amp;A, I thought of ways this could work as a covert communications channel. The idea being… If the “from” addresses are somehow spoofed, one could broadcast a message, using random sites (GreyNoise sensors) to reflect the traffic to places where you’re watching.</p>
<p>Let’s say it’s WWII, but we have the internet, and you have an agent in Paris. They send a message via a series of pings:</p>
<ul>
<li>From Starbucks (I make no judgement about visiting a Starbucks while in Paris), to a GreyNoise sensor in Virginia</li>
<li>The source address is spoofed, so it looks like the pings are coming from Mexico</li>
<li>The sensor in Virginia dutifully sends replies to the “source,” that is, some random server in Mexico</li>
<li>Your handler has a sensor in Mexico City that can receive the packets, which sends them, securely, to your actual destination in London</li>
</ul>
<p>So the agent has sent a message from Paris to London, but the packets went from Paris, to Virginia, to Mexico. So nobody who’s watching the WiFi in all of the coffeehouses in Paris will ever know that messages are being sent to London.</p>
<p>This sounds super cool! But there are several problems with this theory:</p>
<ul>
<li>First, this relies on the packets with spoofed origin addresses even getting sent out. From what I understand, a properly configured network that sees these packets, should just drop them (since they obviously shouldn’t be there in the first place).</li>
<li>Why is there no background noise? This traffic come in long bursts (sometimes days or weeks at a time), but there’s nothing in between the bursts. If you want the channel to look like noise, it needs to be noisy <em>all the time</em>, like Numbers Stations constantly transmitting on shortwave frequencies.</li>
<li>Similarly, why call attention to yourself with the word “LOVE” in cleartext in the message?</li>
<li>Finally, there’s simply not enough data in these packets. In particular, it seems like there’s really only 3 or 4 bytes per packet that could be carrying an actual message – that’s a lot of work to send a highly important message <em><strong>three letters at a time</strong></em>.</li>
<li>Finally, couldn’t you just use…about anything from the App Store? (okay, maybe not, but still, this seems like a pretty complicated approach). This isn’t WWII, and we’re not talking about Special Operations Executive with hand-coded messages going out over shortwave transmitters in haylofts and Parisian attics.</li>
</ul>
<p>Don’t get me wrong – I love the idea, and have already imagined a half-dozen approaches using pseudorandom keystreams and encrypted data… But if I can come up with a much better way to do this, then anything that actual, professional, you know, SPIES, could do, would probably not be something we’d even notice.</p>
<h2 id="looking-at-the-data">Looking at the Data</h2>
<p>So…just how much data is in here? Is there any chance there’s some information being transmitted? Let’s look more closely at the payload.</p>
<p>In the screenshot above, I broke the payload up into four 32-bit words (broken up here a little more for readability):</p>
<table>
<thead>
<tr>
<th>4C4F 5645</th>
<th>BD58 0000</th>
<th>3A44 48F3</th>
<th>9101 0000</th>
</tr>
</thead>
</table>
<ul>
<li>The first column is the word “LOVE” in ASCII (4c 4f 56 45). It doesn’t change.</li>
<li>The second column here is all BD58 0000. The second half (0000) never changes, but the first half varies among maybe a half-dozen different numbers in the 200 packets I’m playing with. So these may be some kind of marker, grouping indicator, etc. But certainly not variable packet-by-packet data.</li>
<li>The last column is 9101 0000 all the way through. Again…intriguingly boring.</li>
<li>It’s the third column that seems interesting. The first three bytes (3a 44 48 in the first row) change constantly, and I don’t need math to see that they’re probably hitting all 256 possible values. The last byte is f3 in just about every packet I have (except for three which are f1).</li>
</ul>
<p>Okay, so… There’s maybe 3 bytes of actual, variable traffic here. Could these somehow be assembled into an encrypted message? Possibly, but again, it seems like a lot of work.</p>
<h2 id="more-data">More Data!</h2>
<p>At this point, I’ve got a tool that kind of works, and now I should really start looking at more data. So I pull down one of the big capture files from GitHub, point my script at it, and…I wait. And wait. And wait some more. Turns out, the scapy library is loading the entire 44 megabyte capture file into memory at once. That’s not gonna work for rapid “try this field” and “filter on that field” poking around. So I need to rewrite my tool with a different packet analysis library.</p>
<p>Turns out, Wireshark has a good python library, and doesn’t have to pre-load the whole file into memory. It’s an easy job to convert my script to use that, and — wait, it crashes? Okay, print() to the rescue! There’s something broken about the data field (maybe it’s missing?), so I set a trap there, and show the broken packet. Wait. WTF? A chill runs down my spine..I may have accidentally figured this out.</p>
<figure>
  <a href="https://darthnull.org/media/2024/09/hiper_packet.png"><img src="https://darthnull.org/media/2024/09/hiper_packet.png" alt="Suddenly, I have chills..."/></a>
  <figcaption><p>Suddenly, I have chills...</p></figcaption>
</figure>
    

<p>What is this showing? The pyshark library is interpreting the ping payload as a “HIPERCONTRACER” packet. This causes the ICMP payload field to be discarded, which makes my script crash when it tries to print the (now non-existent) field.</p>
<p>Looking at the packet, I see “LOVE” identified as a “Magic Number,” which is a way to easily identify files, packets, etc., as belonging to a particular data type (like a Zip file starting with “PK” or a .png starting (nearly) with “PNG”). That makes sense. Then, the BD58 bytes are split into a TTL (time-to-live) figure and a “round” (like…sending multiple groups of pings). Whatever, sure. The next block, all 0s, is itself identified as a field, which again, is consistent with what I’m seeing. And…a timestamp? But the date is all wrong.</p>
<p>Okay, this is intriguing. But why this one packet? Here’s the whole payload for that one:</p>
<table>
<thead>
<tr>
<th>2024-09-15  01:25:34.956</th>
<th>4c4f 5645</th>
<th>bd58 0000</th>
<th>0006 49f3</th>
<th>9101 0000</th>
</tr>
</thead>
</table>
<p>So…it’s treating 000649f391010000 as a timestamp. Let’s do some silly python magic (I’ve already guessed that it’s in milliseconds, so I’m dividing the number by 1000 to get a “normal” UNIX epoch time):</p>
<pre><code>&gt;&gt;&gt; print(time.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;, time.localtime(0x000649f391010000/1000)))
58064-02-23 10:41:46
</code></pre>
<p>Nope. That’s clearly not right. Wait! What if it’s backwards!</p>
<pre><code>&gt;&gt;&gt; print(time.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;, time.localtime(0x00000191f3490600/1000)))
2024-09-14 21:25:34
</code></pre>
<p>BOOM! That matches the GreyNoise sensor’s sniff time. This is a timestamp. It’s a UNIX epoch time, in milliseconds, stored in little-endian format (that means the lowermost bytes come first. Like writing 8,675,309 as 9035768. It’s a thing that goes back to how the computer hardware actually accesses data from memory).</p>
<p>Why doesn’t it match what Wireshark shows? No idea. Why did <em>this</em> packet pop? I think it’s that “00” in “0006” – in every other packet in my test file, that’s non-zero. This zero makes the date look “plausible”, and so Wireshark recognizes it.</p>
<p>If that byte hadn’t been 00, and I hadn’t moved to pyshark, I might never have made this connection.</p>
<p><em><strong>Sometimes, life’s victories are just dumb luck.</strong></em></p>
<h2 id="hipercontracer">HiPerConTracer</h2>
<p>So what exactly is this HIPERCONTRACER thing? A quick search leads me to <a href="https://www.nntb.no/~dreibh/hipercontracer/">this old-school academic page</a>. It’s used, as far as I can gather from the various papers and presentations, to monitor and analyze packet travel time on the internet. This seems like a very reasonable explanation for what we’re seeing. Someone started a project to monitor traffic, and either they are trying to graph its changes throughout the day (over multiple weeks), or…they just forgot to turn it off.</p>
<p>And because this is an academic project, it’s virtually all available online, including source. Some quick poking around gets me to this snippet in the source code:</p>
<pre><code>// ==========================================================================
// Format:
// 00 4 MagicNumber
// 04 1 SendTTL
// 05 1 Round
// 06 2 Checksum Tweak
// 08 8 Send Time Stamp
// ==========================================================================
</code></pre>
<p>This not only matches what Wireshark showed, but definitely confirms my thinking, and what the other packets look like.</p>
<p>But..is this really it? Let’s see if I can look more closely at the other packets. I spent some time trying to get them to show up in Wireshark itself, thinking that maybe I’ll see obvious patterns in the “BD 58” fields, but I just couldn’t get them to be recognized, no matter what I did to tweak the timestamp data.</p>
<p>By now, I’m just tired, and aimlessly poking around at how Wireshark filters work. Maybe I make my own packet “dissector” to decode my packets, if the default parser won’t work. I find the source code for the HiPerConTracer dissector in the Wireshark repository on Gitlab, and it expects a header that’s different from the tool’s source:</p>
<pre><code>/* Setup list of header fields */
static hf_register_info hf[] = {
  { &amp;hf_magic_number,   { &#34;Magic Number&#34;,    &#34;hipercontracer.magic_number&#34;,   FT_UINT32, BASE_HEX, NULL,                 0x0, &#34;An identifier chosen by the sender upon startup&#34;,                       HFILL } },
  { &amp;hf_send_ttl,       { &#34;Send TTL&#34;,        &#34;hipercontracer.send_ttl&#34;,       FT_UINT8,  BASE_DEC, NULL,                 0x0, &#34;The IP TTL/IPv6 Hop Count used by the sender&#34;,                          HFILL } },
  { &amp;hf_round,          { &#34;Round&#34;,           &#34;hipercontracer.round&#34;,          FT_UINT8,  BASE_DEC, NULL,                 0x0, &#34;The round number the packet belongs to&#34;,                                HFILL } },
  { &amp;hf_checksum_tweak, { &#34;Checksum Tweak&#34;,  &#34;hipercontracer.checksum_tweak&#34;, FT_UINT16, BASE_HEX, NULL,                 0x0, &#34;A 16-bit value to ensure a given checksum for the ICMP/ICMPv6 message&#34;, HFILL } },
  { &amp;hf_seq_number,     { &#34;Sequence Number&#34;, &#34;hipercontracer.seq_number&#34;,     FT_UINT16, BASE_DEC, NULL,                 0x0, &#34;A 16-bit sequence number&#34;,                                              HFILL } },
  { &amp;hf_send_timestamp, { &#34;Send Time Stamp&#34;, &#34;hipercontracer.send_timestamp&#34;, FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC, NULL, 0x0, &#34;The send time stamp (microseconds since September 29, 1976, 00:00:00)&#34;, HFILL } }
};
</code></pre>
<p>Wireshark may be expecting an additional 2-byte word (the “Sequence Number” field) that I’m not seeing. That’s interesting, especially since that’s not being displayed in the packet dump. Or maybe the mac version is out of date?</p>
<p>But what’s more telling is the definition of the timestamp. Instead of UNIX epoch (Jan 1, 1970), and milliseconds, it’s using <em>micro</em>second precision, with the epoch date of Sep 29, 1976. Not sure why 1976, but this explains why the displayed timestamp was so weird, and why I couldn’t get Wireshark to like any of my “fixed” packets.</p>
<p>Oh, and there’s another interesting tidbit: The “Checksum Tweak” is, according to what I’ve been reading, an arbitrary 16-bit field that gets automatically adjusted to ensure that all packets in the same “session” have the same ICMP checksum. This should fool network gear into thinking they’re the same packet, so they get routed over the same path, for consistency in timing. In the packets I have, that field is always zero.</p>
<h2 id="sois-this-it">So…is this it?</h2>
<p>At this point, I’m pretty confident that I’ve got this figured out. (well, the “LOVE” packets, at least). Obviously I’m confident, otherwise, I wouldn’t be writing this post.</p>
<p>It looks like:</p>
<ul>
<li>Someone is using a modified version of HiPerConTracer:
<ul>
<li>Designed to use UNIX timestamps with slightly less resolution</li>
<li>Not using the Checksum tweaking to ensure consistent routing</li>
</ul>
</li>
<li>It’s either running continuously, to gather hour-by-hour congestion data, or they started an experiment and forgot to stop the program</li>
</ul>
<p>Is this it, then? Not really. There’s still a lot to look at in the storms. Looking through the larger packet capture files shared by GreyNoise, I see:</p>
<ul>
<li>Packets with a payload of “liboping – ICMP ping library <a href="http://octo.it/liboping/">http://octo.it/liboping/</a>”</li>
<li>“Normal” ping sweeps (payload: !&#34;#$%&amp;&#39;()*+,-./01234567)</li>
<li>Lots of packets that start with “17ec436a” (or a few other blocks of numbers) and lots of random, or near-random, looking data afterwards.
<ul>
<li>In the one big dump I was looking at, those mostly went away and were replaced by LOVE packets, so maybe they’re an earlier test version?</li>
</ul>
</li>
<li>There’s also the incomplete TCP handshakes, though those may have even less data to look at</li>
</ul>
<p>But for the LOVE packets, at least, I think this seems a pretty likely explanation.</p>
<p>Thanks for the quick diversion, Grey Noise!</p>

    </div>
    </div></div>
  </body>
</html>
