<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://oshub.org/projects/retros-32/posts/object-oriented-design-patterns-in-osdev">Original</a>
    <h1>Object-oriented design patterns in C and kernel development</h1>
    
    <div id="readability-page-1" class="page"><div><div>
  <div><action-text-attachment sgid="eyJfcmFpbHMiOnsiZGF0YSI6ImdpZDovL29zLWh1Yi9BY3RpdmVTdG9yYWdlOjpCbG9iLzBhNTE5MzQ4LWIwZjMtNGVmYS1hYTgxLTFlODdmZmE2OGNmMz9leHBpcmVzX2luIiwicHVyIjoiYXR0YWNoYWJsZSJ9fQ==--56ac2e4278062179fc9fffe57fc3ff793860d837" content-type="image/png" url="https://oshub.org/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsiZGF0YSI6IjBhNTE5MzQ4LWIwZjMtNGVmYS1hYTgxLTFlODdmZmE2OGNmMyIsInB1ciI6ImJsb2JfaWQifX0=--4c0890894842e3ae094c17a2ed56ee45d7aead50/Screenshot%202025-08-20%20181545.png" filename="Screenshot 2025-08-20 181545.png" filesize="36254" width="865" height="348" previewable="true" presentation="gallery" caption="My scheduler operations implementation"><figure>
    <img src="https://cdn.oshub.org/rails/active_storage/representations/proxy/eyJfcmFpbHMiOnsiZGF0YSI6IjBhNTE5MzQ4LWIwZjMtNGVmYS1hYTgxLTFlODdmZmE2OGNmMyIsInB1ciI6ImJsb2JfaWQifX0=--4c0890894842e3ae094c17a2ed56ee45d7aead50/eyJfcmFpbHMiOnsiZGF0YSI6eyJmb3JtYXQiOiJwbmciLCJyZXNpemVfdG9fbGltaXQiOlsxMDI0LDc2OF19LCJwdXIiOiJ2YXJpYXRpb24ifX0=--3809ed6c4e3d2e44bade8a316b9825d8584dbfa4/Screenshot%202025-08-20%20181545.png"/>

  <figcaption>
      My scheduler operations implementation
  </figcaption>
</figure></action-text-attachment></div><p>In the OSDev world you’re usually alone, and that solitude gives you the freedom to experiment with unusual programming patterns.</p><pre>/* &#34;Interface&#34; with function pointers */
struct device_ops {
    void (*start)(void);
    void (*stop)(void);
};</pre><pre>/* Device struct holding a pointer to its ops */
struct device {
    const char *name;
    const struct device_ops *ops;
};</pre><pre>struct device netdev = { &#34;eth0&#34;, &amp;net_ops };
struct device disk   = { &#34;sda&#34;,  &amp;disk_ops };

netdev.ops-&gt;start();   // net: up
disk.ops-&gt;start();     // disk: spinning

netdev.ops-&gt;stop();    // net: down
disk.ops-&gt;stop();      // disk: stopped</pre><div><p>I’ve used this pattern to implement the idea of “services” in my operating system. Services are the key kernel threads that keep the system going: the networking manager, worker pools, the window server, and so on. I wanted a consistent way to start, stop, and restart these threads interactively from the terminal, without having to hard-code special logic for each one.</p></div><pre>/* &#34;Interface&#34; with function pointers */
struct service_ops {
    void (*start)(void);
    void (*stop)(void);
    void (*restart)(void);
};

struct service {
    pid_t pid;
    const struct service_ops *ops;
    ...
};</pre><pre>struct file_operations {
    struct module *owner;
    fop_flags_t fop_flags;
    loff_t (*llseek) (struct file *, loff_t, int);
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
    ...
} __randomize_layout;</pre><p><strong>Combination with Kernel Modules<br/></strong><br/></p><div><p>This approach also pairs nicely with kernel modules. Much like how Linux modules work, custom drivers or hooks can be loaded dynamically in my system by replacing the vtables of certain structures. It’s a neat way to extend the kernel while it’s running, without recompiling or rebooting.</p></div><div><p><strong>Drawbacks</strong>Of course, there are drawbacks. The biggest one for me is the syntax. Invoking operations through these structs often ends up looking like:</p></div><pre>object-&gt;ops-&gt;start(object)</pre><pre>static void object_start(struct object* this){
    this-&gt;id = ...
    ...
}</pre>
</div>
</div></div>
  </body>
</html>
