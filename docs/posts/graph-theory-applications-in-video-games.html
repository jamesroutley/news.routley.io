<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utk.claranguyen.me/talks.php?id=videogames">Original</a>
    <h1>Graph Theory Applications in Video Games</h1>
    
    <div id="readability-page-1" class="page"><div><p>
			Maze Generation is an element in games that can give players a unique
			experience every time they play. Doing them efficiently can be
			accomplished via Graph Theory. If you attended
			<a href="https://www.geoffreylitt.com/2025/06/29/talks.php?id=gextract">my previous talk</a>, you will know
			how powerful the Disjoint-Set data structure is for object detection.
			In this talk, however, we&#39;re going to use it to generate mazes...
			the right way.

			</p><h3>Observing Properties of Mazes</h3><p>
			Let&#39;s see what we got here... There are a few things about mazes that
			we should pay attention to prior to making one ourselves:

			</p><ul>
				<li>
					Cells are &#34;matched&#34; with a select few adjacent ones. Cells that
					have been matched do not have a wall between them.
					</li>
				<li>
					All cell pairs that are not &#34;matched&#34; have a wall separating
					them.
					</li>
				<li>
					Mazes can be represented as graphs. Depending on the properties
					of the maze, it can be a minimum spanning tree.
					</li>
				<li>
					We can use typical graph algorithms to find solutions to mazes.
					Popular choices include DFS (Depth-First Search) and BFS
					(Breadth-First Search). We can use them to find a solution from
					any <i>S</i> to any <i>T</i>, easily.
					</li>
			</ul><p>

			Now then, let&#39;s talk about Disjoint-Sets...

			</p></div></div>
  </body>
</html>
