<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scoutapm.com/blog/how-to-use-lambdas-in-ruby">Original</a>
    <h1>How to Use Lambdas in Ruby (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
    <!-- Post title -->
    

    <!-- Publish date -->
    

    <!-- Post image -->
    <p><img src="https://cdn.buttercms.com/vEyPDrNsThWI1DoQpvb8"/></p><!-- Social -->
    

    <!-- Post body -->
    <p><span>Lambdas are a powerful feature of the Ruby language. They allow you to wrap logic and data into a portable package. In this post, we’ll cover how and when to use lambdas. You&#39;ll also learn about the difference between lambdas and Procs, and the performance profile of lambda functions. The code examples have been tested with 2.6 and 2.7 and should work with most modern Rubys.</span></p>
<p><span>Use the links below to skip ahead in the tutorial:</span></p>
<ul>
<li><a href="#whatislambda" rel="follow"><span>What is a Lambda Function </span></a></li>
<li><a href="http://buttercms.com#purposelambdas" rel="follow"><span>What Purpose to Lambdas Serve</span></a></li>
<li><a href="#rubyproc" rel="follow"><span>Ruby Proc vs. Lambda </span></a></li>
<li><a href="#lambdasinuse" rel="follow"><span>Ruby Lambdas in Use</span></a></li>
<li><a href="#performance" rel="follow"><span>Performance </span></a></li>
<li><a href="#closingthoughts" rel="follow"><span>Closing Thoughts </span></a></li>
</ul>
<h2 id="whatislambda"><b>What is a Lambda Function?</b></h2>
<p><span>A lambda function is a general software concept, not specific to <a href="https://scoutapm.com/ruby-monitoring" rel="follow">Ruby</a>. They are available in many programming languages. A lambda function encapsulates control flow, parameters and local variables into a single package assigned to a variable or used inline. If assigned to a variable, it can be passed to other functions or stored in data structures, just like a more typical variable containing a string or float. A lambda function can then be executed far from the code location where it was defined. Lambda functions are often called anonymous functions or a function literal.</span></p>
<p><span>Languages that support lambda functions are often said to have ‘first-class functions’. The lambda function is a middle ground between normal functions, which have no state, and full-blown objects, with state and multiple methods to operate on that state. Because of their simplicity and power, lambda functions can help you write compact, elegant programs. </span></p>
<h3><b>What is a Lambda in Ruby?</b></h3>
<p><span>With Ruby, the </span><code><span>lambda</span></code><span> keyword is used to create a lambda function. It requires a block and can define zero or more parameters. You call the resulting lambda function by using the </span><code><span>call</span></code><span> method.</span></p>
<p><span>Here’s a normal Ruby function:</span></p>
<pre><code>def my_function

   puts &#34;hello&#34;

end</code></pre>
<p><span>You call this using the name:</span></p>
<pre><code>my_function</code></pre>
<p><span>The output:</span></p>
<pre><code>hello</code></pre>
<p><span>You can define a lambda function with the same output:</span></p>
<pre><code>my_lambda = lambda { puts &#34;hello&#34; }</code></pre>
<p><span>Using the name outputs nothing as the lambda function is not executed:</span></p>
<pre><code>my_lambda</code></pre>
<p><span>The call method takes as many arguments as you’ve defined, in this case zero:</span></p>
<pre><code>my_lambda.call</code></pre>
<p><span>The output:</span></p>
<pre><code>hello</code></pre>
<p><span>There is more than one way to call a lambda function:</span></p>
<pre><code>my_lambda = lambda { puts &#34;hello&#34; }



my_lambda.call

my_lambda.()

my_lambda.[]

my_lambda.===</code></pre>
<p><span>The output:</span></p>
<pre><code>hello

hello

hello

hello

</code></pre>
<p><span>You can also create a lambda with the literal lambda operator, which looks like this and can have zero or more arguments: -&gt;</span></p>
<pre><code>my_lambda = -&gt; { puts &#34;hello&#34; }

my_lambda_with_args = -&gt; (v) { puts &#34;hello &#34;+v }</code></pre>

<pre><code>my_lambda.call

my_lambda_with_args.call(&#34;newman&#34;)</code></pre>

<p><span>The output: </span></p>
<pre><code>hello

hello newman</code></pre>

<p><span>The literal operator is succinct and commonly used. However, in the interests of clarity, I’ll use the </span><code><span>lambda</span></code><span> keyword for the rest of this post.</span></p>

<p><span>You can also use default arguments with a Ruby lambda:</span></p>

<pre><code>my_lambda = lambda {|name=&#34;jerry&#34;| puts &#34;hello &#34; +name}



my_lambda.call

my_lambda.call(&#34;newman&#34;)

</code></pre>
<p><span>The output:</span></p>
<pre><code>hello jerry

hello newman</code></pre>

<p><span>Finally, the block you are passing to a lambda can be either a single line block with curly braces or a multi-line block with do and end:</span></p>

<pre><code>my_one_line_lambda = lambda { puts &#34;hello&#34; }



my_one_line_lambda.call



my_multi_line_lambda = lambda do

  puts &#34;hello&#34;

end</code></pre>
<pre><code>my_multi_line_lambda.call</code></pre>
<p><span>The output:</span></p>
<pre><code>hello

hello</code></pre>
<p><span>Please note that a Ruby lambda function is different from an AWS Lambda function, which is an AWS service that executes code without requiring you to run a server. AWS Lambda functions can be written in Ruby but are entirely different from Ruby lambda functions.</span></p>

<h2 id="purposelambdas"><b>What Purpose do Lambdas Serve?</b></h2>
<p><span>The additional indirection that lambda functions provide give you flexibility when writing a Ruby program. For instance, you can pass a lambda to a function:</span></p>
<pre><code>double_it = lambda { |num| num * 2 }

triple_it = lambda { |num| num * 3 }


def apply_lambda(lmbda, number)

  puts lmbda.call(number)

end



apply_lambda(double_it, 10)

apply_lambda(triple_it, 20)

</code></pre>
<p><span>The output:</span></p>
<pre><code>20

60</code></pre>
<p><span>You can also create an array of lambdas to execute in a pipeline:</span></p>
<pre><code>double_it = lambda { |num| num * 2 }

triple_it = lambda { |num| num * 3 }

half_it  = lambda { |num| num / 2 }

value = 5

lambda_pipeline = [double_it, triple_it, half_it]



lambda_pipeline.each do |lmb|

  value = lmb.call(value)

end

puts value</code></pre>
<p><span>The output:</span></p>
<pre><code>15</code></pre>

<p><span>Of course, this pipeline is overengineered. This calculation would be better done with a statement ( </span><code><span>num  = num * 2 * 3 / 2</span></code><span> ). If the lambda functions are defined elsewhere, pulled from configuration at runtime or are more complex, a processing pipeline lead to clearer code.</span></p>

<p><span>A lambda has an execution context, represented in Ruby by a </span><a href="https://ruby-doc.org/core-2.7.0/Binding.html"><span>Binding</span></a><span> object. This is the environment in which your code executes, including, among other things, local variables. This means that lambdas can be </span><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)"><span>closures</span></a><span> which allow the code in the function to access these captured local variables. Here’s an example:</span></p>
<pre><code>def build_lambda

  output = &#34;output from function&#34;

  return lambda { puts output }

end



output = &#34;output from top level&#34;

my_lambda = build_lambda



my_lambda.call</code></pre>
<p><span>What do you think will be printed? The top-level </span><span>output</span><span> variable or the </span><span>output </span><span>variable from within the lambda?</span></p>
<p><span>The output:</span></p>
<pre><code>output from function</code></pre>
<p><span>We see “</span><span>output from function</span><span>”. The lambda function retains the local variable values at the time it was defined. To illustrate this further, here is a dynamic lambda creation function:</span></p>
<pre><code>def build_lambda(text)

  my_text = text

  return lambda { puts my_text }

end



my_lambda = build_lambda(&#34;first function&#34;)

another_lambda = build_lambda(&#34;second function&#34;)



my_lambda.call

another_lambda.call</code></pre>
<p><span>The output:</span></p>
<pre><code>first function

second function</code></pre>
<p><span>The following are specific situations in which you might want to use a Ruby lambda.</span></p>
<h3><span><strong>Encapsulating complicated logic </strong></span></h3>
<p><span>With a Ruby lambda, you may put logic and pass it to other code as a parameter. You could do the same by creating a class with a method, creating an object, and then passing that object. But if you don’t need much state and only need one function on your object, a lambda function can provide a simpler way to convey the intent.</span></p>
<h3><span><strong>An in-memory state machine or data pipeline</strong></span></h3>
<p><span>As seen above, you can chain lambdas. If you have in-memory data that transitions between states in a deterministic manner, such as in a state machine or workflow, you can represent each of the transformations as a lambda function. This will allow you to assemble and reorder such transformations easily.</span></p>
<h3><span><strong>Callbacks</strong></span></h3>
<p><span>Lambdas are perfect for simple callbacks. When used in that way, they can be defined close to where they will be executed, or even inline.</span></p>
<h3><span><strong>ActiveRecord scopes</strong></span></h3>
<p><span>ActiveRecord scopes, used in <a href="https://scoutapm.com/frameworks/rails-monitoring" rel="follow">Rails</a> applications, are commonplace to see a lambda function, at least for web developers. These scopes must be callable because they should be evaluated at run time. </span></p>
<p><span>For instance, if you want your controller to show articles published in the last week, you’d write a scope like this:</span></p>
<pre><code>scope :new_posts, lambda { where(&#34;created_at &gt; ?&#34;, 1.week.ago) }</code></pre>
<p><span>If this wasn’t a lambda, then </span><code><span>1.week.ago</span></code><span> would be evaluated when the class is loaded, rather than when the lambda runs. That is not the correct behavior and would be more incorrect as time went on.</span></p>
<p><span>Rails checks and doesn’t allow such behavior for scopes. This code will not execute and throws a message: <code>&#34;The scope body needs to be callable&#34;</code></span></p>
<pre><code>scope :new_posts_broken, where(&#34;created_at &gt; ?&#34;, 1.week.ago)</code></pre>
<h3><span><strong>Preventing a collection from being preloaded in active admin</strong></span></h3>
<p><span>Similar to ActiveRecord, you can use lambdas to evaluate collections at run time in ActiveAdmin. You can speed up the index page load times by using lambdas to lazily load some of your UI elements:</span></p>
<p><span>“The :check_boxes and :select types accept options for the collection. By default, it attempts to create a collection based on an association. But you can pass in the collection as a proc to be called at render time.” - https://activeadmin.info/3-index-pages.html</span></p>

<h2 id="rubyproc"><b>Ruby Proc vs. Lambda - What’s the Difference?</b></h2>
<p><span>Lambdas are closely related to Ruby Procs. In fact, creating a lambda is almost “</span><a href="https://ruby-doc.org/core-2.7.0/Kernel.html#method-i-lambda"><span>equivalent to Proc.new</span></a><span>”. There are, however, a few differences that may catch you unawares.</span></p>
<h3><span><strong>Lambdas enforce argument count</strong></span></h3>
<p><span>Lambda functions check the number of parameters passed when they are called. If you create a lambda function that accepts one parameter, and you call the lambda with zero parameters, it will fail. If you call it with two or more parameters, it will also fail. The lambda must be called with exactly one parameter. </span></p>
<p><span>Procs, on the other hand, accept any number of arguments. If they are passed too few arguments, the unpassed arguments are set to a value of nil. If they are passed too many arguments, the extraneous arguments are dropped silently. Here’s some example code to illustrate the point:</span></p>
<pre><code>my_proc = Proc.new {|name| puts &#34;proc says hello &#34; + name.to_s }

my_lambda = lambda {|name| puts &#34;lambda says hello &#34; + name.to_s }



my_proc.call(&#34;jerry&#34;)

my_lambda.call(&#34;jerry&#34;)



my_proc.call

my_lambda.call

</code></pre>
<p><span>The output with the last call to the lambda throwing an exception:</span></p>
<pre><code>proc says hello jerry

lambda says hello jerry

proc says hello

Traceback (most recent call last):

     1: from proc_vs_lambda.rb:8:in `&lt;main&gt;&#39;

proc_vs_lambda.rb:2:in `block in &lt;main&gt;&#39;: wrong number of arguments (given 0, expected 1) (ArgumentError)</code></pre>
<p><span>You can, of course, use the splat operator allow a lambda to take multiple arguments:</span></p>
<pre><code>my_lambda = lambda do |*args|

  args.each do |arg|

puts &#34;I saw &#34; +arg

  end

end



my_lambda.call(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;)</code></pre>
<p><span>The output:</span></p>
<pre><code>I saw a

I saw b

I saw c</code></pre>
<h3><strong>The behavior of the return statement</strong></h3>
<p><span>The return statement is handled differently as well. The return statement in a lambda function stops the lambda and returns control to the calling code. The return statement in a Proc, in contrast, returns from both the Proc and the calling code. Here’s an example:</span></p>
<pre><code>my_lambda = lambda do |name|

  puts &#34;lambda says hello &#34; + name

  return &#34;lambda done&#34;

end



my_proc = Proc.new do |name|

  puts &#34;proc says hello &#34; + name

  return &#34;proc done&#34;

end



def call_lambda(lmbda)

  value = lmbda.call(&#34;jerry&#34;)

  puts value

end



call_lambda(my_lambda)



def call_proc(prc)

  value = prc.call(&#34;jerry&#34;)

  puts value

end



call_proc(my_proc)</code></pre>
<p><span>The output:</span></p>
<pre><code>lambda says hello jerry

lambda done

proc says hello jerry</code></pre>
<p><span>You see “</span><span>lambda done</span><span>” but not “</span><span>proc done</span><span>” because the return statement in the proc terminates the program flow.</span></p>
<h2 id="lambdasinuse"><b>Ruby Lambdas in Use</b></h2>
<p><span>Ruby Lambdas can be used in a number of situations. Sometimes, there’s no need for state, so an object would be overkill, but the logic is complicated enough to be pulled out to a separate, portable variable. In other cases the value of writing a lambda is the runtime flexibility.</span></p>
<h3><strong>ActiveRecord scopes</strong></h3>
<p><span>As mentioned previously, ActiveRecord scopes are a common use of Ruby lambdas. Here’s an ActiveRecord scope on an Article model which only displays published articles:</span></p>
<pre><code>  scope :published, lambda { where(published: true) }</code></pre>
<p><span>In the controller you can call the scope like this:</span></p>
<pre><code>@articles = Article.published.all</code></pre>
<p><span>In the </span><a href="https://guides.rubyonrails.org/active_record_querying.html#scopes"><span>Rails ActiveRecord guide</span></a><span>, the scopes are all written in the lambda literal syntax, but the functionality is the same:</span></p>
<pre><code>scope :published,  -&gt; { where(published: true) }</code></pre>
<h3><span><strong>Callbacks</strong></span></h3>
<p><span>Lambdas are great choices for simple callbacks. You can define them right before you use them or inline, without the cognitive overhead of an object or the namespace pollution of a function. In the Rails codebase, lambdas are used to capture success or failures in tests. Here’s an </span><a href="https://github.com/rails/rails/blob/master/actioncable/test/subscription_adapter/base_test.rb#L24"><span>ActionCable test</span></a><span>:</span></p>
<pre><code>  test &#34;#subscribe returns NotImplementedError by default&#34; do

callback = lambda { puts &#34;callback&#34; }

success_callback = lambda { puts &#34;success&#34; }



assert_raises NotImplementedError do

   BrokenAdapter.new(@server).subscribe(&#34;channel&#34;, callback, success_callback)

end

  end</code></pre>
<h3><span><strong>Dynamic mapping</strong></span></h3>
<p><span>If you want to map over a collection, but the map function changes based on the input, you can use a lambda to encapsulate the changing logic. Here’s an example of code in which the mapping function differs based on the input--any number that is a multiple of 5 is omitted and any odd number is doubled. This logic could also be defined and tested elsewhere.</span></p>
<pre><code>collection = [1,2,3,4,5,6,7,8]



my_lambda = lambda do |num|

  if num % 2 == 0

return num

  end

  if num % 5 == 0

return

  end

  num*2

end



new_collection = collection.map { |c| my_lambda.call(c) }.compact

puts new_collection

</code></pre>
<p><span>The output:</span></p>
<pre><code>2

2

6

4

6

14

8</code></pre>
<h3><strong>A faux hash</strong></h3>
<p><span>Because a lambda can be called with the syntax: </span><span>my_lambda[“argument”]</span><span>, you can create a hash-like read-only object which returns values from a key based on code.  Here’s an example of a lambda that disallows certain keys that are specified at creation. All other keys are concatenated with their value.</span></p>
<pre><code>def build_lambda(restricted_values)

  my_hash = {}

  my_lambda = lambda do |key|

if restricted_values.include? key

   return &#34;n/a&#34;

else

   return key + key

end

  end

  my_lambda

end



my_multiplying_hash_like_object = build_lambda([&#39;hi&#39;])

puts my_multiplying_hash_like_object[&#34;hi&#34;]

puts my_multiplying_hash_like_object[&#34;bye&#34;]

</code></pre>
<p><span>The output:</span></p>
<pre><code>n/a

byebye</code></pre>
<p><span>If you were providing read-only access to configuration values pulled from a database or a file and wanted to allow hash-like access, you could use such a lambda. Beware, if you use any of the other hash methods, the lambda fails:</span></p>
<pre><code>puts my_multiplying_hash_like_object.keys</code></pre>
<p><span>The output:</span></p>
<pre><code> undefined method `keys&#39; for #&lt;Proc:0x00000000026972b8@lambda_as_hash.rb:3 (lambda)&gt; (NoMethodError)</code></pre>

<h2 id="performance"><b>Performance</b></h2>
<p><span>If you are using a lambda in a tight loop or other high-performance situation, benchmark it to make sure your needs are met. As always, premature optimization is the root of all evil. From my testing, it looks like lambda functions are about 30% slower than method or function calls, but here’s a benchmark script to run on your system:</span></p>
<pre><code>require &#39;benchmark&#39;



def my_function(a,b)

  return a*b

end



my_lambda = lambda {|a,b| return a*b }



class Calc

  def mult(a,b)

return a*b

  end

end

puts &#34;function&#34;

puts Benchmark.measure {

  50_000_000.times do

my_function(rand, rand)

  end

}

puts &#34;lambda&#34;

puts Benchmark.measure {

  50_000_000.times do

my_lambda.call(rand, rand)

  end

}

puts &#34;object method&#34;

calc = Calc.new

puts Benchmark.measure {

  50_000_000.times do

calc.mult(rand, rand)

  end

}</code></pre>

<h2 id="closingthoughts"><b>Closing Thoughts</b></h2>
<p><span>Ruby lambdas allow you to encapsulate logic and data in an eminently portable variable. A lambda function can be passed to object methods, stored in data structures, and executed when needed. Lambda functions occupy a sweet spot between normal functions and objects. They can have state but don’t have the complexity of a full-fledged object. While many folks are familiar with lambdas because of Rails model scopes, they can be useful in other areas of your codebase.</span></p>

    <!-- Post footer -->
    <!-- TODO: ? this assets scale badly in new blog width
    <a target="_blank" rel="nofollow" href="/users/sign_up">
      <img src="https://assets.scoutapm.com/assets/blog/footer/1-4540bcd4d4e6982dbed6760c4a22a36c16c0c6ac1dfe26defd637025c31e7064.png" />
</a>    -->
    </div></div>
  </body>
</html>
