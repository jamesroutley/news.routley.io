<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arangodb.com/2021/02/cpp-memory-model-migrating-from-x86-to-arm/">Original</a>
    <h1>C&#43;&#43; Memory Model: Migrating from x86 to ARM (2021)</h1>
    
    <div id="readability-page-1" class="page"><div data-node="5imagwz7plnd">
	<div>
		
<p><span><svg aria-hidden="true" focusable="false" data-icon="clock" width="20" height="20" fill="none" stroke="currentColor" style="display:inline-block;vertical-align:-0.1em" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></span><span></span><span>Estimated reading time:  </span><span>19</span><span> minutes</span></p>



<p>Over the past years, we have seen a shift in processors from the previously dominant x86 architecture to the more energy-efficient (and often cheaper) ARM architecture. This trend is true for both consumer hardware, e.g., <a href="https://en.wikipedia.org/wiki/Apple_M1">Apple’s M1</a> SoC and also server hardware, e.g. <a href="https://aws.amazon.com/ec2/graviton/">AWS’s Gravitron</a> processor. Given that the ARM architecture has a more relaxed memory model, this might have some subtle impact on C++ programs…</p>



<p>With the introduction of multi-threaded execution in C++11, the standard also introduced a <em>memory model</em>. For many developers, this memory model is one of the least well-understood parts of the C++ standard and a common source of confusion. While an in-depth explanation of the C++ memory model is beyond this blog post’s scope, we will cover some basics and take a brief look at two of the most common hardware memory models and how the C++ memory model maps to these hardware models.</p>



<p>But first, let’s take a step back and consider why we need a memory model in the first place.</p>



<p>A memory model defines what happens whenever we access the memory. Given a potentially concurrent program, the memory model defines the possible values a read might return when a write by one thread becomes visible to other threads, as well as the final values of each location in memory.</p>



<p>The memory model can be refined to differentiate between the <em>programming language memory model</em> and the <em>hardware memory model</em>.</p>



<ul><li><strong>Language memory model:</strong> Defines the optimizations, memory access rewrites, and reorderings a compiler is allowed to perform when transforming a program into code.</li><li><strong>Hardware memory model:</strong> Defines the optimizations and memory access reorderings a specific hardware architecture is allowed to perform while executing the machine code.</li></ul>



<p>These optimizations can cause memory accesses to be executed or perceived in orders that differ from what is defined in the source code, leading to distinguishing between the following four orderings:</p>



<ul><li><strong>Source code order:</strong> The order in which the memory operations are specified in the source code.</li><li><strong>Program order:</strong> The order in which the memory operations are specified in the machine code. The program order can differ from the source code order because, based on the language memory model, compilers can reorder instructions as part of the optimization process.</li><li><strong>Execution order:</strong> The order in which the individual memory-reference instructions are executed on a given CPU. The execution order can differ from the program order due to optimizations based on the specific CPU-implementations’ hardware memory model (e.g., out-of-order execution).</li><li><strong>Perceived order:</strong> The order in which a CPU perceives its and other CPUs’ memory operations. The perceived order can differ from the execution order due to caching, interconnect, and memory-system optimizations defined by the hardware memory model. On some architectures, different CPUs can perceive the same set of memory operations as occurring in different orders.</li></ul>



<h2>Sequential consistency </h2>



<p>The sequentially consistent memory model is the simplest memory model and describes how most people intuitively expect memory to behave. A natural view of a multi-threaded program’s execution is as follows: we repeatedly choose a random thread and execute the next step in that thread’s execution until the program terminates. This is effectively equivalent to taking all steps of all threads in order and interleaving them in some way, resulting in a <em>single total order</em> of all steps. Therefore, whenever an object is accessed, the last value stored to the object in this order is retrieved. An execution that can be understood as such an interleaving is referred to as <em>sequentially consistent</em>. This more formal definition of the sequential consistent model was first proposed by Leslie Lamport [Lamport79].</p>



<p>Due to the strong guarantees sequential consistency provides, it is much easier to reason about the correctness of some code. That is why most publications on concurrent algorithms or data structure assume a sequentially consistent memory model. And for the same reason, all atomic operations in C++ default to sequential consistency unless specified otherwise (we will discuss this in more detail later).</p>



<p>Unfortunately, ensuring sequential consistency is quite expensive, and none of today’s processor architectures provide a fully sequentially consistent memory model. While they allow enforcing sequential consistency at certain points, normal execution is not sequentially consistent but depends highly on the specific architecture’s implementation.</p>



<h2 id="block-f0702236-3e8e-4e0e-8c50-84eeaa0701a0">x86-TSO</h2>



<p>The Intel x86 memory model is one of the strongest models amongst today’s modern CPU implementations. For a long time, the information provided by Intel and AMD on their respective x86 architecture implementations were mostly informal, missing concrete examples, and sometimes even inconsistent with the actual implementation.</p>



<p>Sewell et al. [Sewell2010] formally described a new memory model called <em>x86-TSO</em> (Total Store Order), which is consistent with the concrete examples in Intel’s and AMD’s latest documentation available at that time. This model is illustrated here:</p>



<figure><img decoding="async" loading="lazy" width="670" height="430" src="https://usarangodb.wpengine.com/wp-content/uploads/2021/02/x86-TSO.png" alt="" srcset="https://arangodb.com/wp-content/uploads/2021/02/x86-TSO.png 670w, https://arangodb.com/wp-content/uploads/2021/02/x86-TSO-600x385.png 600w" sizes="(max-width: 670px) 100vw, 670px"/></figure>



<p><em>x86-TSO block diagram from [Sewell2010].</em></p>



<p>As can be seen, the hardware threads interact with a storage subsystem represented by the dotted box. The storage subsystem comprises a shared memory that maps addresses to values, one write buffer per hardware thread (also referred to as “store buffer”), and a global lock to indicate when a particular hardware thread has exclusive access to memory. The complete formal definition can be found in [Sewell2010], but the main points are:</p>



<ul><li>The store buffers are FIFO, and a reading thread must read its own most recent buffered write, if there is one, to that address. Otherwise, reads are satisfied from shared memory. Since writes are buffered, the new value is not visible to other threads until it has propagated to the shared memory.</li><li>The <code>mfence</code> instruction flushes the store buffer of that thread, ensuring that the writes become globally visible.</li><li>To execute a <code>lock</code>‘d instruction, a thread must first acquire the global lock. At the end of the instruction, it flushes its store buffer and releases the lock. While the lock is held by one thread, no other thread can read. This essentially means that <code>lock</code>‘d instructions enforce sequential consistency.</li><li>A buffered write from a thread can propagate to the shared memory at any time except when some other thread holds the lock.</li></ul>



<p>x86-TSO does not permit local reordering except for reads after writes to different addresses.</p>



<p>It is important to note that x86-TSO is a highly simplified model that does not fully describe actual CPU implementations by Intel or AMD. However, this simplified model is <em>consistent</em> with the concrete examples in Intel’s and AMD’s latest documentation when the model was defined. So, it should be possible to model any effect that is observable in x86 CPUs with x86-TSO.</p>



<h2>ARM and POWER</h2>



<p>POWER is an architecture developed by IBM. Even though it is not as widely known as ARM, POWER CPUs are not only used in servers and supercomputers, but also in many consumer devices like satellite receivers or game consoles (e.g., Nintendo Wii, Xbox 360, PlayStation 3). Although ARM and POWER are completely different architectures, their memory models are quite similar. In particular, both have considerably more relaxed memory models, allowing a wider range of hardware optimizations. Maranget et al. [Maranget2012] provide a detailed and extensive description of both architectures and their observable behaviors.</p>



<p>While memory order relaxations can improve performance, power efficiency and hardware complexity, it makes the life of a programmer, who is implementing concurrent data structures, significantly harder. In contrast to TSO models, the following behaviors are possible on these architectures:</p>



<ul><li>Hardware threads can perform reads and writes out-of-order, or even speculatively, i.e., before preceding conditional branches have been resolved. Any local reordering is allowed unless otherwise specified.</li><li>The memory system does not guarantee that a write becomes visible to all other hardware threads simultaneously (this behavior is called <em>non-multicopy-atomicity</em>).</li></ul>



<p>It can be helpful to think of each hardware thread as effectively having its own copy of memory as illustrated:</p>



<p>.</p>



<figure><img decoding="async" loading="lazy" width="527" height="494" src="https://usarangodb.wpengine.com/wp-content/uploads/2021/02/ARM-POWER-1.png" alt=""/></figure>



<p id="block-532b1605-b219-42f4-a9df-8332e81fe0bb"><em>ARM/POWER storage subsystem from [Maranget2012]</em></p>



<p>This collection of memories and their interconnect (i.e., everything except the threads) is usually referred to as the <em>storage subsystem</em>. A write by one thread may propagate to other threads in any order, and the propagations of writes to different addresses can be interleaved arbitrarily, unless they are constrained by barriers or cache coherence. One can also think of barriers as propagating from the hardware thread that executed them to each of the other threads.</p>



<p>Since a particular ordering of instructions is crucial for the simplest non-blocking data structures, these architectures provide various memory barriers and dependency guarantees that the programmer must use correctly to enforce a desired appropriate ordering of memory operations.</p>



<p>The ARM <code>dbm</code> and POWER <code>sync</code> barrier (fence) instructions can enforce the following orderings between two instructions:</p>



<ul><li><strong>Read/Read</strong> the barrier ensures that they are satisfied and committed in program order.</li><li><strong>Read/Write</strong> the barrier ensures that the read is satisfied and committed before the write can be committed (and thus propagated and become visible to others).</li><li><strong>Write/Write</strong> the barrier ensures that the first write is committed and has propagated to all other threads before the second write is committed.</li><li><strong>Write/Read</strong> the barrier ensures that the write is committed and has propagated to all other threads before the read is satisfied.</li></ul>



<p>In addition to barriers, these architectures provide the following (implicit) dependencies to enforce orderings:</p>



<ul><li><strong>Address Dependency:</strong> There is an address dependency from a read to a program-order-later read or write if the value read by the first instruction is used to compute the address of the second instruction.</li><li><strong>Control Dependency:</strong> There is a control dependency from a read to a program-order-later read/write if the value read by the first instruction is used to compute the condition of a conditional branch that is program-order-before the second instruction.</li><li><strong>Data Dependency:</strong> There is a data dependency from a read to a program-order-later write if the value read by the first instruction is used to compute the value written by the second instruction.</li></ul>



<p>The ARMv8 architecture has been revised and now has a multicopy-atomic model. It has also been simplified in other respects, including more straightforward notions of dependency, and the architecture now includes a formal concurrency model. More details are available in [Pulte2017].</p>



<h2>The C++ memory model </h2>



<p>The C++ standard provides a formal definition of an abstract machine with its execution model. Before C++11, this execution model was purely sequential. C++11 redefined this execution model to support multi-threaded executions and introduced the memory model as a common ground between the programmer, the runtime library, the compiler, and the hardware.</p>



<p>Together with the memory model, C++11 also introduced the concept of a <em>data race</em>. A data race occurs when we have two conflicting actions, at least one of which is not atomic, and neither “happens before” the other. Two actions conflict if both access the same memory location and at least one of them is a write. Any such data race results in undefined behavior. We will discuss in a minute what this “happens before” part means exactly.</p>



<p>The C++ standard contains a paragraph commonly referred to as the “as-if” rule. It states that “conforming implementations are required to emulate (only) the observable behavior of the abstract machine.” Basically this means an implementation is free to disregard any requirement of the standard as long as the result is <em>as if</em> the requirement had been obeyed, as far as can be determined from the observable behavior of the program. This rule is the basis for virtually all compiler optimizations because it effectively allows any and all code transformations that do not change the program’s observable behavior.</p>



<p>The observable behavior of a multi-threaded program is defined by means of the <em>happens before</em> relationship, which can be roughly described as follows:</p>



<blockquote><p>Let <em>A</em> and <em>B</em> represent operations performed by a multi-threaded process. If <em>A</em> happens-before <em>B</em>, then the memory effects of <em>A</em> effectively become visible to the thread performing <em>B</em> before <em>B</em> is performed.</p></blockquote>



<p>For C++, the standard defines “happens before” as follows: An evaluation <em>A</em> happens before an evaluation <em>B</em> if:</p>



<ul><li><em>A</em> is sequenced before <em>B</em>, or</li><li><em>A</em> inter-thread happens before <em>B</em>.</li></ul>



<p><em>Sequenced before</em> is an anti-symmetric, transitive, pair-wise</p>



<p><em>Inter-thread-happens-before</em> describes a happens-before order between two operations from different threads.</p>



<p>An evaluation <em>A</em> inter-thread happens before an evaluation <em>B</em> if</p>



<ul><li><em>A</em> synchronizes with <em>B</em>, or</li><li><em>A</em> is dependency-ordered before <em>B</em>, or</li><li>we have some arbitrary concatenation of <em>sequenced before</em>, <em>synchronizes with</em> and <em>dependency-ordered before</em> relationships.</li></ul>



<p>There are two minor exceptions to the last case of arbitrary concatenations, but that is beyond our scope here. For more details see [C++17, 4.7.1.10, pp. 15-19].</p>



<p>An inter-thread happens-before relation can be established via high-level synchronization objects like <code>std::mutex</code> or via atomic synchronization operations. Since we are focusing on the memory model, we only look at the latter. Each atomic operation takes a parameter of type <code>std::memory_order</code>, which is an enumeration type with the following values:</p>







<figure><img decoding="async" loading="lazy" width="608" height="364" src="https://usarangodb.wpengine.com/wp-content/uploads/2021/02/memory-orders.png" alt="" srcset="https://arangodb.com/wp-content/uploads/2021/02/memory-orders.png 608w, https://arangodb.com/wp-content/uploads/2021/02/memory-orders-600x359.png 600w" sizes="(max-width: 608px) 100vw, 608px"/></figure>



<p><code>memory_order_seq_cst</code> is the strongest order and used for sequential consistency. This is the default memory order for all operations, so unless specified otherwise, all atomic operations are sequentially consistent. As previously explained, there is a single total order <em>S</em> of all sequentially consistent operations. An operation <em>B</em> that performs a load on an object <em>M</em> will observe the result of the last modification <em>A</em> of <em>M</em> that precedes <em>B</em> in <em>S</em> [C++17, 32.4.3, p. 1347].</p>



<p>The orders <code>memory_order_consume</code> and <code>memory_order_acquire</code> can only be used for operations that perform a <em>read</em>, <code>memory_order_release</code> can only be used for operations that perform a <em>write</em> and <code>memory_order_acq_rel</code> can only be used for operations that perform a <em>read-modify-write</em> operation. Some implementations check these constraints at runtime (e.g., MSVC in debug builds).</p>



<p><code>memory_order_consume</code> is used in conjunction with <em>dependency-ordered before</em>. However, the C++17 standard contains the following note:</p>



<blockquote><p>Prefer <code>memory_order_acquire</code>, which provides stronger guarantees than <code>memory_order_consume</code>. Implementations have found it infeasible to provide performance better than that of <code>memory_order_acquire</code>. Specification revisions are under consideration.</p></blockquote>



<p>For that reason, we will only consider the remaining memory orders and the <em>synchronize-with</em> relation.</p>



<p>A <em>synchronize-with</em> relation is established by using acquire/release operations. An atomic operation <em>A</em> that performs a store-release operation on an atomic object <em>M</em> <em>synchronizes with</em> an atomic operation <em>B</em> that performs a load-acquire operation on <em>M</em> and observes the value written by <em>A</em>, or some value from any side effect in the release sequence headed by <em>A</em>. This <em>synchronize-with</em> order is compatible with the inter-thread-happens-before order, i.e., if <em>A</em> synchronizes with <em>B</em>, then <em>A</em> inter-thread-happens-before <em>B</em>. Release sequences are beyond our scope here, so we will only consider the simple case where <em>B</em> observes the value written by <em>A</em>; for more details on release sequences see [C++17, 4.7.1.5, p. 16].</p>



<p><code>memory_order_relaxed</code> is the weakest order and does not provide any ordering guarantees. In particular, relaxed atomic operations are not <em>synchronization operations</em>, as they do not affect any assignment’s visibility to other threads. However, of course, relaxed atomic operations are still fully atomic, so a relaxed <code>fetch_add</code> is still guaranteed to increase monotonically without any lost or duplicate updates.</p>



<p>There are also synchronization operations without an associated memory location, which are called <em>fences</em>, but these are beyond this post’s scope.</p>



<h2>Compiler optimizations </h2>



<p>As previously explained, virtually all compiler optimizations are based on the so-called “as-if” rule. In particular, the compiler is free to reorder instructions as long as the observable behavior is not affected.</p>



<p>One might assume that the definition of sequenced-before relation effectively prevents the compiler from performing any instruction reordering. After all, it states that “if <em>A</em> is sequenced before <em>B</em>, then the execution of <em>A</em> shall precede the execution of <em>B</em>.” Nevertheless, the sequenced-before relation is only defined between instructions executed by <em>a single thread</em>, so as long as these changes are not observable by some other thread (without a data race!), the compiler may freely reorder these instructions. For example, the compiler can freely reorder two relaxed atomic write operations. Remember that the perceived order can differ from the execution order? Since the two operations are relaxed, there is no guarantee in which order they become visible, so they can just as well be reordered.</p>



<p>So essentially, it boils down to this – the compiler is free to reorder operations as long as the observable behavior is retained. Moreover, since for multi-threaded execution, the observable behavior is defined by means of the (inter-thread) happens-before relation, the compiler can freely reorder operations that are not ordered by such an (inter-thread) happens-before relation.</p>



<p>As a rule of thumb, an operation cannot be reordered <em>after</em> a release-store or <em>before</em> an acquire-load because the acquire/release-operations can potentially establish a happens-before relation, and such reorderings would spoil the transitivity. However, any correctness argument about concurrent code using relaxed atomics should be based on happens-before relations and <em>not</em> on possible reorderings because if or when operations can be reordered is merely a result of applying the happens-before rules.</p>



<h2>Example</h2>



<p>It can be quite difficult to correctly apply these more relaxed memory orders. And to make matters worse, an incorrect usage often does not cause any obvious issues. Consider this example:</p>



<pre><code>struct Node {
  int x;
};
std::atomic&lt;node*&gt; node{nullptr};

// Thread A:
auto n = new Node();
n-&gt;x = 42;
node.store(n, std::memory_order_relaxed);

// Thread B:
Node* n = nullptr;
while (n == nullptr) {
  n = node.load(std::memory_order_relaxed);
}
assert(n-&gt;x == 42);</code></pre>



<p>This code contains a data race because the initialization of <code>x</code> in Thread A and the read operation on <code>x</code> in Thread B is not ordered by a happens-before relation. Nevertheless, this code will <em>probably</em> work on x86. In particular, if the initialization of <code>x</code> is executed before the <code>node.store</code>, then the x86 model guarantees that <code>n-&gt;x</code> in Thread B will observe the value written in the initialization, so the assertion is guaranteed to hold. This is because all load/store operations on x86 have acquire/release semantic, even if the C++ code uses <code>memory_order_relaxed</code>. There is no such guarantee on ARM, so the value returned by <code>n-&gt;x</code> in Thread B is undefined.</p>



<p>It will only <em>probably</em> work on x86 because the memory model not only relates to the <em>hardware</em> memory model but also interacts with the compiler.</p>



<p>The pointer to the newly created node is written with <code>memory_order_relaxed</code>, which does not provide any ordering guarantees. In particular, it can never establish an inter-thread-happens before relation (ignoring the possibility of combining it with an explicit <code>atomic_thread_fence</code>, which is beyond this post’s scope). For that reason, the compiler is well in its right to assume that no thread may access that node yet because doing so would send us to the land of undefined behavior. So there is no need to guarantee that the node is already fully initialized at the time we store the pointer, and the compiler may reorder the code as if it had been written as follows:</p>



<pre><code>// Thread A
auto n = new Node();
node.store(n);
n-&gt;x = 42;</code></pre>



<p>Obviously, such an optimization may also cause the assertion to fail on x86. But because such an optimization for this example is rather unlikely, chances are that the incorrect code runs flawlessly on your x86 machine, resulting in a false sense of security.</p>



<p>The correct way to fix this is by using acquire/release operations:</p>



<pre><code>// Thread A:
auto n = new Node{42};
// (1) - this release-store synchronizes with the acquire-load (2)
node.store(n, std::memory_order_release);

// Thread B:
Node* n = nullptr;
while (n == nullptr) {
  // (2) - this acquire-load synchronizes with the release-store (1)
  n = node.load(std::memory_order_acquire);
}
assert(n-&gt;x == 42);</code></pre>



<p>Once Thread B observes the value written by Thread A, the acquire-load <em>synchronizes-with</em> the release-store, thereby establishing an inter-thread-happens-before relation. This means that all operations preceding the release-store must become visible to the thread performing the acquire-operation. In particular, this means that:</p>



<ol><li>The compiler must ensure that the initialization is executed before storing the pointer, i.e., the initialization code must not be reordered <em>past</em> the store.</li><li>For weak hardware models, the compiler must generate the necessary instructions to enforce that ordering.</li></ol>



<h2>ThreadSanitizer</h2>



<p>The best way to test whether code contains any data races is using <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual"><em>ThreadSanitizer</em></a>, or short <em>TSan</em>. ThreadSanitizer is yet another sanitizer available in gcc and clang. If enabled during compilation, it adds instrumentation code to the binary. Typical slowdown introduced by ThreadSanitizer is about 5x-15x, and typical memory overhead is about 5x-10x. TSan can report a number of typical issues in concurrent code (like lock inversion), but more importantly, it also understands the C++ memory model, which allows it to detect <em>data races</em>. Essentially, TSan checks every single memory access operation for conflicting actions (as defined before). If such conflicting actions are not ordered by a happens-before relation, TSan reports a data race. Since these checks are performed at runtime, the fact whether a data race can be detected or not depends on the order in which the program’s code is executed – which TSan has no control over. So it is important to realize that TSan does not guarantee that it can find <em>all</em> data races. Even if the code runs hundreds of times without any warnings from TSan, it does not mean that the code is free of data races, just that TSan could not find any. An alternative to TSan are model checkers like <a href="http://plrg.ics.uci.edu/software_page/42-2/" data-type="URL" data-id="http://plrg.ics.uci.edu/software_page/42-2/">CDSChecker</a>, which exhaustively explore the behavior of code under the C/C++ memory model. But since these checkers essentially explore the complete state space, they are only feasible for small, self-contained examples. For large applications, TSan is still the best tool available to check code for data races.</p>



<p>However, there are some limitations – at the moment, TSan does not support explicit memory fences, nor the <a href="https://github.com/google/sanitizers/issues/970">failure-order for <code>compare_exchange</code></a> operations. Relying on either will almost certainly result in false-positives. These are long-standing issues, but there is no roadmap for a fix for either of them to the best of my knowledge. However, dynamic data race analysis is still an active research topic (e.g., <a href="https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf">Dynamic Race Detection for C++11</a>), but it is unclear if or when such improvements will find their way into the official TSan implementation.</p>



<h2>Conclusion</h2>



<p>Writing concurrent code that is correct and efficient can already be quite challenging, but throwing relaxed atomics into the mix adds yet another level of complexity. Intuitively, most people expect memory operations to behave sequentially consistent, and it can be mind-boggling to realize that real-world architectures don’t behave that way. Wrapping your head around this fact and coming to grips with how to deal with it can take quite a while.</p>



<p>It takes a lot of practice to use relaxed atomic operations correctly. When writing code with relaxed operations, try to reason about its correctness. To that end, think about the requirements:</p>



<ul><li>Which operations need to be ordered?</li><li>Where do we need happens-before relations?</li><li>How can these be established?</li></ul>



<p>Even then, code should be run with ThreadSanitizer to ensure (as far as possible) that the assumptions hold and you did not miss anything.</p>



<p>“It works on my machine” is never a good argument, even less so for concurrent code using relaxed atomics!</p>



<p>This post is largely based on the white paper <a href="https://arxiv.org/abs/1803.04432">Memory Models for C/C++ Programmers</a> which provides more in-depth details, including those topics that were outside this post’s scope.</p>



<h2><strong>References</strong> </h2>



<figure><table><tbody><tr><td>[C++17]</td><td>Richard Smith C++ Standards Committee. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf">Working Draft, Standard for Programming Language C++.</a> C++ standards committee paper, March 2017.</td></tr><tr><td>[Lamport79]</td><td>Leslie Lamport. <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/How-to-Make-a-Multiprocessor-Computer-That-Correctly-Executes-Multiprocess-Programs.pdf">How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs.</a> IEEE Computer, 28(9):690–691, 1979.</td></tr><tr><td>[Maranget2012]</td><td>Luc Maranget, Susmit Sarkar, and Peter Sewell. <a href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf">A tutorial introduction to the ARM and POWER relaxed memory models.</a> Technical report, October 2012.</td></tr><tr><td>[Pulte2017]</td><td>Christopher Pulte, Shaked Flur, Will Deacon, Jon French, Susmit Sarkar, and Peter Sewell. <a href="https://www.cl.cam.ac.uk/~pes20/armv8-mca/armv8-mca-draft.pdf">Simplifying ARM concurrency: multicopy-atomic axiomatic and operational models for ARMv8</a>. Proceedings of the ACM on Programming Languages, POPL, December 2017.</td></tr><tr><td>[Sewell2010]</td><td>Peter Sewell, Susmit Sarkar, Scott Owens, Francesco Zappa Nardelli, and Magnus O. Myreen. <a href="http://www.cl.cam.ac.uk/~pes20/weakmemory/cacm.pdf">X86-TSO: A rigorous and usable programmer’s model for x86 multiprocessors</a>. Communications of the ACM, 53(7):89–97, 2010.</td></tr></tbody></table></figure>



<h2>Continue Reading</h2>



<p><a href="https://www.arangodb.com/2020/07/do-graph-databases-scale-yes-no-lets-see/">Do Graph Databases Scale? Yes? No? Let’s see!</a></p>



<p><a href="https://www.arangodb.com/2020/06/arangodb-3-7-beta-1-graph-database-and-search-engine-upgrades/">ArangoDB 3.7 BETA – Graph &amp; Search Engine Upgrades</a></p>



<p><a href="https://www.arangodb.com/2020/05/red-hat-certifies-arangodb-kubernetes-operator/">Red Hat Certifies ArangoDB Kubernetes Operator</a></p>
	</div>
</div></div>
  </body>
</html>
