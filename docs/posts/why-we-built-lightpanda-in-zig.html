<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lightpanda.io/blog/posts/why-we-built-lightpanda-in-zig">Original</a>
    <h1>Why we built Lightpanda in Zig</h1>
    
    <div id="readability-page-1" class="page"><div><p>Because We&#39;re Not Smart Enough for C++ or Rust</p><div><div><p><img src="https://cdn.lightpanda.io/website/assets/images/blog/authors/francis-bouvier.jpg" alt="Francis Bouvier"/></p><div><h3>Francis Bouvier</h3><h4>Cofounder &amp; CEO</h4></div></div></div><figure><img src="https://cdn.lightpanda.io/website/assets/images/blog/posts/why-we-built-lightpanda-in-zig/zigligihtpandalarge.png" alt="Why We Built Lightpanda in Zig"/></figure><h2 id="tldr">TL;DR<a href="#tldr" aria-label="Permalink for this section"></a></h2>
<p>To be honest, when I began working on Lightpanda, I chose Zig because I’m not smart enough to build a big project in C++ or Rust.</p>
<p>I like simple languages. I like Zig for the same reasons I like Go, C, and the KISS principle. Not just because I believe in this philosophy, but because I’m not capable of handling complicated abstractions at scale.</p>
<p>Before Lightpanda, I was doing a lot of Go. But building a web browser from scratch requires a low-level systems programming language to ensure great performance, so Go wasn’t an option. And for a project like this, I wanted more safety and modern tooling than C.</p>
<h2 id="why-we-built-lightpanda-in-zig">Why We Built Lightpanda in Zig<a href="#why-we-built-lightpanda-in-zig" aria-label="Permalink for this section"></a></h2>
<p>Our requirements were performance, simplicity, and modern tooling. Zig seemed like the perfect balance: simpler than C++ and Rust, top-tier performance, and better tooling and safety than C.</p>
<p>As we built the first iterations of the browser and dug deeper into the language, we came to appreciate features where Zig particularly shines: comptime metaprogramming, explicit memory allocators, and best-in-class C interoperability. Not to mention the ongoing work on compilation times.</p>
<p>Of course it’s a big bet. Zig is a relatively new language with a small ecosystem. It’s pre-1.0 with regular breaking changes. But we’re very bullish on this language, and we’re not the only ones: <a href="https://ghostty.org/" target="_blank" rel="noreferrer">Ghostty<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>, <a href="https://bun.com/" target="_blank" rel="noreferrer">Bun<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>, <a href="https://tigerbeetle.com/" target="_blank" rel="noreferrer">TigerBeetle<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>, and <a href="https://zml.ai/" target="_blank" rel="noreferrer">ZML<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> are all building with Zig. And with <a href="https://bun.com/blog/bun-joins-anthropic" target="_blank" rel="noreferrer">Anthropic’s recent acquisition of Bun<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>, big tech is taking notice.</p>
<p>Here’s what we’ve learned.</p>
<h2 id="what-lightpanda-needs-from-a-language">What Lightpanda Needs from a Language<a href="#what-lightpanda-needs-from-a-language" aria-label="Permalink for this section"></a></h2>
<p>Before diving into specifics, let’s talk about what building a browser for web automation requires.</p>
<p>First, we needed a JavaScript engine. Without one, a browser only sees static HTML: no client-side rendering and no dynamic content. We chose V8, Chrome’s JavaScript engine, because it’s state of the art, widely used (<a href="https://nodejs.org/en" target="_blank" rel="noreferrer">Node.js<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>, <a href="https://github.com/denoland/deno" target="_blank" rel="noreferrer">Deno<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>), and relatively easy to embed.</p>
<p>V8 is written in C++, and doesn’t have a C API, which means any language integrating with it must handle C++ boundaries. Zig doesn’t interoperate directly with C++, but it has first-class C interop, and C remains the lingua franca of systems programming. We use C headers generated primarily from <a href="https://github.com/denoland/rusty_v8" target="_blank" rel="noreferrer">rusty_v8<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>, part of the <a href="https://github.com/denoland/deno" target="_blank" rel="noreferrer">Deno project<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>, to bridge between V8’s C++ API and our Zig code.</p>
<p>Beyond integration, performance and memory control were essential. When you’re crawling thousands of pages or running automation at scale, every millisecond counts. We also needed precise control over short-lived allocations like DOM trees, JavaScript objects, and parsing buffers. Zig’s explicit allocator model fits that need perfectly.</p>
<h2 id="why-not-c">Why Not C++?<a href="#why-not-c" aria-label="Permalink for this section"></a></h2>
<p>C++ was the obvious option: it powers virtually every major browser engine. But here’s what gave us pause.</p>
<ul>
<li><strong>Four decades of features</strong>: C++ has accumulated enormous complexity over the years. There are multiple ways to do almost everything: template metaprogramming, multiple inheritance patterns, various initialization syntaxes. We wanted a language with one clear way to do things.</li>
<li><strong>Memory management</strong>: Control comes with constant vigilance. Use-after-free bugs, memory leaks, and dangling pointers are real risks. Smart pointers help, but they add complexity and runtime overhead. Zig’s approach of passing allocators explicitly makes memory management clearer and enables patterns like arenas more naturally.</li>
<li><strong>Build systems</strong>: Anyone who’s fought with CMake or dealt with header file dependencies knows this pain. For a small team trying to move quickly, we didn’t want to waste time debugging build configuration issues.</li>
</ul>
<p>We’re not saying C++ is bad. It powers incredible software. But for a small team starting from scratch, we wanted something simpler.</p>
<h2 id="why-not-rust">Why not Rust?<a href="#why-not-rust" aria-label="Permalink for this section"></a></h2>
<p>Many people ask this next. It’s a fair challenge. Rust is a more mature language than Zig, offers memory safety guarantees, has excellent tooling, and a growing ecosystem.</p>
<p>Rust would have been a viable choice. But for Lightpanda’s specific needs (and honestly, for our team’s experience level) it introduced friction we didn’t want.</p>
<h3 id="the-unsafe-rust-problem">The Unsafe Rust Problem<a href="#the-unsafe-rust-problem" aria-label="Permalink for this section"></a></h3>
<p>When you need to do things the borrow checker doesn’t like, you end up writing unsafe Rust, which is surprisingly hard. <a href="https://zackoverflow.dev/" target="_blank" rel="noreferrer">Zack<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> from <a href="https://bun.com/" target="_blank" rel="noreferrer">Bun<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> explores this in depth in his article <a href="https://zackoverflow.dev/writing/unsafe-rust-vs-zig/" target="_blank" rel="noreferrer">When Zig is safer and faster than Rust<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>.</p>
<p>Browser engines and garbage-collected runtimes are classic examples of code that fights the borrow checker. You’re constantly juggling different memory regions: per-page arenas, shared caches, temporary buffers, objects with complex interdependencies. These patterns don’t map cleanly to Rust’s ownership model. You end up either paying performance costs (using indices instead of pointers, unnecessary clones) or diving into unsafe code where raw pointer ergonomics are poor and Miri becomes your constant companion.</p>
<p>Zig takes a different approach. Rather than trying to enforce safety through the type system and then providing an escape hatch, Zig is designed for scenarios where you’re doing memory-unsafe things. It gives you tools to make that experience better: non-null pointers by default, the GeneralPurposeAllocator that catches use-after-free bugs in debug mode, and pointer types with good ergonomics.</p>
<h2 id="why-zig-works-for-lightpanda">Why Zig Works for Lightpanda<a href="#why-zig-works-for-lightpanda" aria-label="Permalink for this section"></a></h2>
<p>Zig sits in an interesting space. It’s a simple language that’s easy to learn, where everything is explicit: no hidden control flow, no hidden allocations.</p>
<h3 id="explicit-memory-management-with-allocators">Explicit Memory Management with Allocators<a href="#explicit-memory-management-with-allocators" aria-label="Permalink for this section"></a></h3>
<p>Zig makes you choose how memory is managed through allocators. Every allocation requires you to specify which allocator to use. This might sound tedious at first, but it gives you precise control.</p>
<p>Here’s what this looks like in practice, using an arena allocator:</p>

<p>This pattern matches browser workloads perfectly. Each page load gets its own arena. When the page is done, we throw away the entire memory chunk. No tracking individual allocations, no reference counting overhead, no garbage collection pauses. (Though we’re learning that single pages can grow large in memory, so we’re also exploring mid-lifecycle cleanup strategies). And you can chain arenas, to create short-lived objects inside a page lifecycle.</p>
<h3 id="compile-time-metaprogramming">Compile-Time Metaprogramming<a href="#compile-time-metaprogramming" aria-label="Permalink for this section"></a></h3>
<p>Zig’s comptime feature lets you write code that runs during compilation. We use this extensively to reduce boilerplate when bridging Zig and JavaScript.</p>
<p>When integrating V8, you need to expose native types to JavaScript. In most languages, this requires glue code for each type. To generate this glue you need some code generation, usually through Macros (Rust, C, C++). Macros are a completely different language, which has a lot of downsides. Zig’s comptime lets us automate this:</p>

<p>The registerType function uses comptime reflection to:</p>
<ul>
<li>Find all public methods on Point</li>
<li>Generate JavaScript wrapper functions</li>
<li>Create property getters/setters for x and y</li>
<li>Handle type conversions automatically</li>
</ul>
<p>This eliminates manual binding code and makes adding new types simple by using the same language at compile time and runtime.</p>
<h3 id="c-interop-that-just-works">C Interop That Just Works<a href="#c-interop-that-just-works" aria-label="Permalink for this section"></a></h3>
<p>Zig’s C interop is a first-class feature: you can directly import C header files and call C functions without wrapper libraries.</p>
<p>For example, we use cURL as our HTTP library. We can just import libcurl C headers in Zig and use the C functions directly:</p>

<p>It feels as simple as using C, except you are programming in Zig.</p>
<p>And with the build system it’s also very simple to add the C sources to build everything together (your zig code and the C libraries):</p>

<p>This simplicity of importing C mitigates the fact that the Zig ecosystem is still small, as you can use all the existing C libraries.</p>
<h3 id="the-build-system-advantage">The Build System Advantage<a href="#the-build-system-advantage" aria-label="Permalink for this section"></a></h3>
<p>Zig includes its own build system written in Zig itself. This might sound unremarkable, but compared to CMake, it’s refreshingly straightforward. Adding dependencies, configuring compilation flags, and managing cross-compilation all happen in one place with clear semantics. Runtime, comptime, build system: everything is in Zig, which makes things easier.</p>
<p>Cross-compilation in particular is usually a difficult topic, but it’s very easy with Zig. Some projects like <a href="https://thamizhelango.medium.com/why-uber-chose-zig-as-their-c-c-toolchain-a-technical-deep-dive-771584e57c5b" target="_blank" rel="noreferrer">Uber<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> use Zig mainly as a build system and toolchain.</p>
<h3 id="compile-times-matter">Compile times matter<a href="#compile-times-matter" aria-label="Permalink for this section"></a></h3>
<p>Zig compiles fast. Our full rebuild takes under a minute. Not as fast as Go or an interpreted language, but enough to have a feedback loop that makes development feel responsive. In that regard, Zig is considerably faster than Rust or C++.</p>
<p>This is a strong focus of the Zig team. They are also a small team and they need fast compilation for the development of the language, as Zig is written in Zig (self-hosted). For that purpose, they are developing native compiler backends (i.e. not using LLVM), which is very ambitious and yet successful: it’s already the default backend for x86 in debug mode, with a significant improvement in build times (<a href="https://ziglang.org/devlog/2025/#2025-06-08" target="_blank" rel="noreferrer">3.5x faster for the Zig project itself<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>). And <a href="https://ziglang.org/download/0.15.1/release-notes.html#Incremental-Compilation" target="_blank" rel="noreferrer">incremental compilation<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> is on its way.</p>
<h2 id="what-weve-learned">What We’ve Learned<a href="#what-weve-learned" aria-label="Permalink for this section"></a></h2>
<p>After months of building Lightpanda in Zig, here’s what stands out.</p>
<ul>
<li><strong>The learning curve is manageable.</strong> Zig’s simplicity means you can understand the entire language in a few weeks. Compared to Rust or C++, this makes a real difference.</li>
<li><strong>The allocator model pays off.</strong> Being able to create arena allocators per page load, per request, or per task gives us fine-grained memory control without tracking individual allocations.</li>
<li><strong>The community</strong> is small but helpful. Zig is still growing. The Discord community and <a href="https://ziggit.dev/" target="_blank" rel="noreferrer">ziggit.dev<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> are active, and the language is simple enough that you can often figure things out by reading the standard library source.</li>
</ul>
<h2 id="conclusion">Conclusion<a href="#conclusion" aria-label="Permalink for this section"></a></h2>
<p>Lightpanda wouldn’t exist without the work of the Zig Foundation and the community behind it. Zig has made it possible to build something as complex as a browser with a small team and a clear mental model, without sacrificing performance.</p>
<ul>
<li>If you’re curious about Zig’s design philosophy or want to see how its compiler and allocator model work, the <a href="https://ziglang.org/documentation/" target="_blank" rel="noreferrer">official documentation<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> is the best place to start.</li>
<li>You can also explore the <a href="https://github.com/lightpanda-io/browser" target="_blank" rel="noreferrer">Lightpanda source code<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> and follow the project on GitHub</li>
<li><a href="https://console.lightpanda.io/signup" target="_blank" rel="noreferrer">Sign up<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> to test the cloud version</li>
</ul>
<h2 id="faq">FAQ<a href="#faq" aria-label="Permalink for this section"></a></h2>
<h3 id="is-zig-stable-enough-for-production-use">Is Zig stable enough for production use?<a href="#is-zig-stable-enough-for-production-use" aria-label="Permalink for this section"></a></h3>
<p>Zig is still pre-1.0, which means breaking changes can happen between versions. That said, we’ve found it stable enough for our production use, especially since the ecosystem has largely standardized on tracking the latest tagged releases rather than main. The language itself is well-designed, and most changes between versions are improvements that are worth adapting to. Just be prepared to update code when upgrading Zig versions.</p>
<h3 id="whats-the-hardest-part-about-learning-zig">What’s the hardest part about learning Zig?<a href="#whats-the-hardest-part-about-learning-zig" aria-label="Permalink for this section"></a></h3>
<p>The allocator model takes adjustment if you’re coming from garbage-collected languages. You need to think about where memory comes from and when it gets freed. But compared to Rust’s borrow checker or C++‘s memory management, it’s relatively straightforward once you understand the patterns.</p>
<h3 id="can-zig-really-replace-c-for-browser-development">Can Zig really replace C++ for browser development?<a href="#can-zig-really-replace-c-for-browser-development" aria-label="Permalink for this section"></a></h3>
<p>For building a focused browser like Lightpanda, yes. For replacing Chromium or Firefox, that’s unlikely: those projects have millions of lines of C++ and decades of optimization. We’re more likely to see Rust complementing C++ in those projects over time, for example how Firefox is leveraging <a href="https://github.com/servo/servo" target="_blank" rel="noreferrer">Servo<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>. But for new projects where you control the codebase, Zig is absolutely viable.</p>
<h3 id="where-can-i-learn-more-about-zig">Where can I learn more about Zig?<a href="#where-can-i-learn-more-about-zig" aria-label="Permalink for this section"></a></h3>
<p>Start with the <a href="https://ziglang.org/documentation/master/" target="_blank" rel="noreferrer">official Zig documentation<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>. The <a href="https://ziglearn.org/" target="_blank" rel="noreferrer">Zig Learn<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> site provides practical tutorials. And join the community on <a href="https://discord.gg/zig" target="_blank" rel="noreferrer">Discord<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> or <a href="https://ziggit.dev/" target="_blank" rel="noreferrer">ziggit.dev<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> where developers actively help newcomers. The language is simple enough that reading standard library source code is also a viable learning approach.</p><hr/><div><div><p><img src="https://cdn.lightpanda.io/website/assets/images/blog/authors/francis-bouvier.jpg" alt="Francis Bouvier"/></p><div><h3>Francis Bouvier</h3><h4>Cofounder &amp; CEO</h4></div></div><p>Francis previously cofounded BlueBoard, an ecommerce analytics platform acquired by ChannelAdvisor in 2020. While running large automation systems he saw how limited existing browsers were for this kind of work. Lightpanda grew from his wish to give developers a faster and more reliable way to automate the web.</p></div></div></div>
  </body>
</html>
