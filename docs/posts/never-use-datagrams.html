<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://quic.video/blog/never-use-datagrams/">Original</a>
    <h1>Never* Use Datagrams</h1>
    
    <div id="readability-page-1" class="page"><article>
<p>Click-bait title, but hear me out.</p>
<h2 id="tcp-vs-udp">TCP vs UDP</h2>
<p>So you‚Äôre reading this blog over the internet.
I would wager you do a lot of things over the internet.</p>
<p>If you‚Äôve built an application on the internet, you‚Äôve undoubtedly had to decide whether to use TCP or UDP.
Maybe you‚Äôre trying to make, oh I dunno, a live video protocol or something.
There are more choices than just those two but let‚Äôs pretend like we‚Äôre a networking textbook from the 90s.</p>
<p>The common wisdom is:</p>
<ul>
<li>use <strong>TCP</strong> if you want <strong>reliable</strong> delivery</li>
<li>use <strong>UDP</strong> if you want <strong>unreliable</strong> delivery</li>
</ul>
<p>What the fuck does that mean?
Who <em>wants</em> unreliability?</p>
<ul>
<li>You don‚Äôt want a hard-drive that fails 5% of writes.</li>
<li>You don‚Äôt want something with random holes in the middle (unless it‚Äôs cheese).</li>
<li>You don‚Äôt want a service that is randomly unavailable because ¬Ø\_(„ÉÑ)_/¬Ø.</li>
</ul>
<p>Nobody* wants memory corruption or deadzones or artifacts or cosmic rays.
Unreliability is a consequence, not a goal.</p>
<figure><p><img src="https://quic.video/blog/never-use-datagrams/glitch.gif" alt="Video glitch"/></p><figcaption><p>*Unless you‚Äôre making some cursed GIF art.
<a href="https://en.wikipedia.org/wiki/Glitch_art">Source</a></p></figcaption></figure>
<h2 id="properties">Properties</h2>
<p>So what do we actually want?</p>
<p>If you go low enough level, you can use electrical impulses to do neat stuff like:</p>
<ul>
<li>Power on LEDs in a desired configuration.</li>
<li>Spin magnets at ludicrous speeds.</li>
<li>Make objects tingle and shake.</li>
<li>etc you get the idea.</li>
</ul>
<p>But we don‚Äôt want to deal with electrical impulses.
We want higher level functionality.</p>
<p>Fortunately, software engineering is all about standing on the shoulders of others.
There are layers on top of layers on top of layers of abstraction.
Each layer provides properties so you don‚Äôt have to reinvent the personal computer every time.</p>
<p>Our job as developers is to decide which shoulders we want to stand on.
But some shoulders are awful, so we have to be selective.
Over-abstraction is bad but so is under-abstraction.</p>
<p>What user experience are we trying to build, and how can we leverage the properties of existing layers to achieve that?</p>
<h2 id="unreliable">‚ÄúUnreliable‚Äù</h2>
<p>There was a recent <a href="https://datatracker.ietf.org/wg/moq/meetings/">MoQ interim</a> in Denver.
For those unaware, it‚Äôs basically a meetup of masochistic super nerds who want to design a live video protocol.
We spent hours debating the semantic differences between <strong>FETCH</strong> and <strong>SUBSCRIBE</strong> among other riveting topics.</p>
<figure><p><img src="https://quic.video/blog/never-use-datagrams/denver.jpeg" alt="Denver interim"/></p><figcaption><p>I‚Äôm the one in the back right corner, the one with the stupid grin on their face.</p></figcaption></figure>
<p>A few times, it was stated that <strong>SUBSCRIBE</strong> should be <em>unreliable</em>.
The room cringed, and I hard cringed enough to write this blog post.</p>
<p>What I actually want is <strong>timeliness</strong>.
If the internet can choose between delivering two pieces of data, I want it to deliver the newest one.</p>
<p>In the live video scenario, this is the difference between buffering and skipping ahead.
If you‚Äôre trying to have a conversation with someone on the internet, there can‚Äôt be a delay.
You don‚Äôt want a buffering spinner on top of their face, nor do you want to hear what they said 5 seconds ago.</p>
<p>To accomplish timeliness, the live video industry often uses UDP datagrams instead of TCP streams.
As does the video game industry apparently.
But why?</p>
<h2 id="datagrams">Datagrams</h2>
<p>A datagram, aka an IP packet, is an envelope of 0s and 1s that gets sent from a source address to a destination address.
Each device has a different maximum size allowed, which is super annoying, but 1200 bytes is generally safe.
And of course, they can be silently lost or even arrive out of order.</p>
<p>But the physical world doesn‚Äôt work in discrete packets; it‚Äôs yet another layer of abstraction.
I‚Äôm not a scientist-man, but the data is converted to analog signals and sent through some medium.
It all gets serialized and deserialized and buffered and queued and retransmitted and dropped and corrupted and delayed and reordered and duplicated and lost and all sorts of other things.</p>
<p>So why does this abstraction exist?</p>
<h2 id="internet-of-queues">Internet of Queues</h2>
<p>It‚Äôs pretty simple actually: something‚Äôs got to give.</p>
<figure><p><img src="https://quic.video/blog/never-use-datagrams/bodies.jpeg" alt="Screamer Rock"/></p><figcaption><p>Let the packets hit the FLOOR</p></figcaption></figure>
<p>When there‚Äôs too much data sent over the network, the network has to decide what to do.
In theory it could drop random bits but oh lord that is a nightmare, as evidenced by over-the-air TV.
So instead, a bunch of smart people got together and decided that routers should drop at packet boundaries.</p>
<p>But why drop packets again?
Why can‚Äôt we just queue and deliver them later?
Well yeah, that‚Äôs what a lot of routers do these days since RAM is cheap.
It‚Äôs a phenomenon called <a href="https://en.wikipedia.org/wiki/Bufferbloat">bufferbloat</a> and my <a href="https://discord.com">coworkers</a> can attest that it‚Äôs my favorite thing to talk about. üê∑</p>
<p>But RAM is a finite resource so the packets will eventually get dropped.
Then you finally get the <strong>unreliability</strong> you wanted all along‚Ä¶</p>
<h2 id="oh-no">Oh no</h2>
<p>Oh shit, I forgot, I actually want <strong>timeliness</strong> and bufferbloat is the worst possible scenario.
Naively, you would expect the internet to deliver packets immediately, with some random packets getting dropped.
However bufferbloat causes <em>all</em> packets to get queued, possibly for seconds, ruling out any hope of timely delivery.</p>
<p>How do you avoid this?
Basically, the only way to avoid queuing is to detect it, and then send less.
The sender uses some feedback from the receiver to determine how long it took a packet to arrive.
We can use that signal to infer when routers are queuing packets, and back off to drain any queues.</p>
<p>This is called <a href="https://en.wikipedia.org/wiki/TCP_congestion_control">congestion control</a> and it‚Äôs a huge, never ending area of research.
I briefly summarized it in the <a href="https://quic.video/blog/replacing-webrtc">Replacing WebRTC</a> post if you want more CONTENT.
But all you need to know is that sending packets at unlimited rate is a recipe for disaster.</p>
<figure><p><img src="https://quic.video/blog/never-use-datagrams/bbr.png" alt="BBR"/></p><figcaption><p><a href="https://datatracker.ietf.org/meeting/99/materials/slides-99-iccrg-iccrg-presentation-2-00.pdf">Source</a>:
Riveting slides from IETF meetings that you‚Äôre missing out on.</p></figcaption></figure>
<h2 id="you-the-application-developer">You, The Application Developer</h2>
<p>Speaking of a recipe for disaster.
Let‚Äôs say you made the mistake of using UDP directly because you want them datagrams.
You‚Äôre bound to mess up, and you won‚Äôt even realize why.</p>
<p>If you want to build your own transport protocol on top of UDP, you ‚Äúneed‚Äù to implement:</p>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-packetization-and-reliabili">retransmissions</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9002.html#name-congestion-control">congestion control</a></li>
</ul>
<p>And if you want a great protocol, you also need:</p>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc9001">encryption</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9002.html#name-estimating-the-round-trip-t">RTT estimates</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-address-validation">path validation</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-connection-migration">path migration</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9002.html#name-pacing">pacing</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-flow-control">flow control</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-version-negotiation">version negotiation</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-transport-parameter-encodin">extensions</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-stream-prioritization">prioritization</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-idle-timeout">keep-alives</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-streams">multiplexing</a></li>
</ul>
<p>And if you want an AMAZING protocol, you also need:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebTransport_API">web support</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-matching-packets-to-connect">port reuse</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html#name-datagram-size">dynamic MTUs</a></li>
<li><a href="https://datatracker.ietf.org/doc/draft-ietf-quic-multipath/">multi-path</a></li>
<li><a href="https://datatracker.ietf.org/doc/draft-ietf-quic-load-balancers/">stateless load balancing</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc9000.html#section-9.6.1">anycast load balancing</a></li>
</ul>
<p>Let‚Äôs be honest, you don‚Äôt even know what half of those are, nor why they are worth implementing.
Just use a <a href="https://en.wikipedia.org/wiki/QUIC">QUIC</a> library instead.</p>
<p>But if you still insist on UDP, you‚Äôre actually in good company with a lot of the video industry.
Building a live video protocol on top of UDP is all the rage; for example, <a href="https://webrtc.org/">WebRTC</a>, <a href="https://www.haivision.com/products/srt-secure-reliable-transport/">SRT</a>, <a href="https://nscreenmedia.com/amazon-buys-sye/">Sye</a>, <a href="https://www.rist.tv/">RIST</a>, etc.
With the exception of Google, it‚Äôs very easy make a terrible protocol on top of UDP.
Look forward to the upcoming <strong>Replacing RTMP <em>but please not with SRT</em></strong> blog post!</p>
<h2 id="timeliness">Timeliness</h2>
<p>But remember, I ultimately want to achieve <strong>timeliness</strong>.
How can we do that with QUIC?</p>
<ol>
<li>
<p><strong>Avoid bloating the buffers</strong> üê∑.
Use a delay-based congestion controller like <a href="https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-01.html">BBR</a> that will detect queueing and back off.
There are better ways of doing this, like how WebRTC uses <a href="https://webrtc.googlesource.com/src/+/refs/heads/main/docs/native-code/rtp-hdrext/transport-wide-cc-02/README.md">transport-wide-cc</a>, which I‚Äôll personally make sure gets added to QUIC.</p>
</li>
<li>
<p><strong>Split data into streams</strong>.
The bytes within each stream are ordered, reliable, and can be any size; it‚Äôs nice and convenient.
Each stream could be a video frame, or a game update, or a chat message, or a JSON blob, or really any atomic unit.</p>
</li>
<li>
<p><strong>Prioritize the streams</strong>.
Streams are independent and can arrive in any order.
But you can tell the QUIC stack to focus on delivering important streams first.
The low priority streams will be starved, and can be closed to avoid wasting bandwidth.</p>
</li>
</ol>
<p>That‚Äôs it.
That‚Äôs the secret behind <a href="https://datatracker.ietf.org/wg/moq/about/">Media over QUIC</a>.
Now all that‚Äôs left is to bikeshed the details.</p>
<p>And guess what?
This approach works with higher latency targets too.
It turns out that the fire-and-forget nature of datagrams only works when you need real-time latency.
For everything else, there‚Äôs QUIC streams.</p>
<p>You don‚Äôt need datagrams.</p>
<figure><p><img src="https://quic.video/home/quic.svg" alt="QUIC logo"/></p></figure>
<h2 id="in-defense-of-datagrams">In Defense of Datagrams</h2>
<p><strong>Never* use Datagrams</strong> got you to click, but the direction of QUIC and MoQ seems to tell another story:</p>
<ol>
<li>QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9221">has support for datagrams</a> via an extension.</li>
<li>WebTransport <a href="https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3-08#section-3.1-6">requires support for datagrams</a>.</li>
<li>The latest MoQ version <a href="https://www.ietf.org/archive/id/draft-ietf-moq-transport-02.html#object-message-formats">adds support for datagrams</a>.</li>
<li>The next MoQ version <a href="https://github.com/moq-wg/moq-transport/pull/384">will require support for datagrams</a>.</li>
</ol>
<p>Like all things designed by committee, there‚Äôs going to be some compromise.
There are some folks who think datagram support is important.
And frankly, it‚Äôs trivial to support and allow people to experiment.
For example, OPUS has FEC support built-in, which is why MoQ supports the ability to send each audio ‚Äúframe‚Äù as a datagram.</p>
<p>But it‚Äôs a trap.
Designed to lure in developers who don‚Äôt know any better.
Who wouldn‚Äôt give up their precious UDP datagrams otherwise.</p>
<p>If you want some more of my hot-takes:</p>
<ul>
<li>The next <a href="https://quic.video/blog/forward-error-correction">blog post about FEC in OPUS</a>, and why layers are important.</li>
<li>The previous <a href="https://quic.video/blog/quic-powers">blog post gushed over QUIC</a>, except for the datagram extension which is frankly terrible.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>There is no conclusion.
This is a rant.</p>
<p>Please don‚Äôt design your application on top of datagrams.
Old protocols like <a href="https://en.wikipedia.org/wiki/Domain_Name_System">DNS</a> get a pass, but be like <a href="https://en.wikipedia.org/wiki/DNS_over_HTTPS">DNS over HTTPS</a> instead.</p>
<p>And please, please don‚Äôt make yet another video protocol on top of UDP.
Get involved with <a href="https://datatracker.ietf.org/wg/moq/about/">Media over QUIC</a> instead!
Join our <a href="https://discord.gg/FCYF3p99mr">Discord</a> and tell me how wrong I am.</p>
<p>Written by <a href="https://github.com/kixelated">@kixelated</a>.</p>
<img src="https://quic.video/blog/kixelCat.png"/></article></div>
  </body>
</html>
