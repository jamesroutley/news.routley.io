<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ramanlabs.in/static/blog/Generate_Python_extensions_using_Nim_language.html">Original</a>
    <h1>Generate Python extensions using Nim language</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <h2> Generate Python extensions using Nim language </h2>
        <!-- Blog content -->
        <p>A Python Extension is generally some code written in language other than python to extend the python ecosystem by  exposing an interface compatible with Python API.Such extensions are generally in form of compiled code and loaded dynamically by the Python runtime.</p>
<p>The ability to create extensions quickly, to be used directly from Python, would be a great advantage.Ideally, users would be able to write the bottleneck parts of their code in their favorite language (generally faster than Python), to offload compute-intensive parts, and use them from Python language with all its flexibility. The extensions written in such a way allow users to utilize all the features offered by foreign language/dialect including but not limited to multiprocessing, assembly level instructions, meta-progamming hence also bypassing Python <a href="https://wiki.python.org/moin/GlobalInterpreterLock">GIL</a>. Lots of extensions(modules) like <code>numpy</code>, <code>scikit-learn</code> fundamental to <code>data-science</code> are also written in <code>C/C++</code>.</p>
<p>There are lots of options for writing such extensions ranging from more specific dialects like <a href="https://cython.org/">Cython</a>, <a href="https://numba.pydata.org/">Numba</a>(for accelerating Numpy array based operations) to general foreign language bindings like Rust, C++, C. Writing extensions for Python is anything but a delightful experience,generally because a  lot of boiler-plate/glue code is needed to wrap the extension.</p>
<p>In this post, we would be looking at <a href="https://nim-lang.org">Nim</a>. Nim compiles to C, hence it can generate compiled code to be loaded as a module from Python. I personally found Nim as a highly productive language and have written a lot of code for various use-cases. For me, it fulfills what it promises while offering a lot of flexibility like directly compiling any already existing C code for fast prototyping.</p>
<p>We would cover a concrete example to show the practical usefulness of Nim based Python extension by writing a simple <code>Image Preprocessing Pipeline</code>. We will try to establish a simple baseline with generic single threaded code without going into optimizations.</p>
<h3>Image preprocessing.</h3>
<p>Image preprocessing is generally the first step in computer-vision based ML models, and follows roughly the same order as:</p>
<h4>Order:</h4>
<ol>
<li>Converting Uint8 [HWC] to float32 format ranging [0-1].</li>
<li>Optionally [HWC] format to [CHW] depending on the framework.</li>
<li>Resizing to expected INPUT-SIZE (dictated by the model being used), like 224x224, 256x256.</li>
<li>Normalization of data (by subtracting MEAN and dividing by standard-deviation).</li>
</ol>
<p>Optimizing this part would be an advantage since this pipeline would need to be run for each frame/image.
Preprocessing and post-processing code is generally least optimized code given that code is highly specific for each model, hence contribute a significant latency if not properly optimized.</p>
<h3>Code:</h3>
<h4>Assumptions:</h4>
<ol>
<li>We assume that input data is contiguous in memory i.e. data is packed without any padding and in consecutive memory locations.</li>
<li>Input data contains <code>Uint8</code> data i.e. value from [0-255].</li>
<li>Input data follows HWC format, i.e. <code>stride</code> for channels&#39; dimension is 1.</li>
<li>Output data produced would also be <code>contiguous</code>.</li>
<li>Output data format is [CHW], i.e. <code>stride</code> for Width dimension would be 1.</li>
</ol>
<p>Since <code>resizing</code> would involve collecting an input/source pixel (nearest neighbour) or <code>weighted combination</code> of input pixels (bilinear), based on the logical coordinates (i, j) for each output pixel location.
We can convert the collected input (<code>uint8</code>) data into <code>float32</code>, before updating corresponding output/destination memory location thus effectively fusing steps 1 and 3.</p>
<p>We can decide if we want output format to be <code>CHW</code> or <code>HWC</code> beforehand or by writing 2 different implementations, thus also fusing step 2.</p>
<div><pre><span></span><code><span># Writing a simple Resize function that fuses steps 1, 2 and 3 in our pipeline for case if output format is CHW.</span>

<span>import</span> <span>math</span>

<span># nearest neighbour based routine to calculate the correponding input source index, given the output index.</span>
<span>proc </span><span>nearest_neighbour_compute_source_index</span><span>(</span><span>scale</span><span>:</span><span>float</span><span>,</span> <span>out_index</span><span>:</span><span>int</span><span>,</span> <span>input_size</span><span>:</span><span>int</span><span>):</span><span>int</span><span>=</span>
    <span>return</span> <span>min</span><span>(</span> <span>int</span><span>(</span> <span>floor</span><span>(</span><span>out_index</span><span>.</span><span>float</span> <span>*</span> <span>scale</span><span>)),</span> <span>input_size</span><span>-</span><span>1</span> <span>)</span>

<span>proc </span><span>hwc2chw_resize_simple</span><span>(</span><span>inpRawData_ptr</span><span>:</span><span>ptr</span> <span>uint8</span><span>,</span> <span>outRawData_ptr</span><span>:</span><span>ptr</span> <span>float32</span><span>,</span> <span>inpH</span><span>:</span><span>int</span><span>,</span> <span>inpW</span><span>:</span><span>int</span><span>,</span> <span>outH</span><span>:</span><span>int</span><span>,</span> <span>outW</span><span>:</span><span>int</span><span>,</span> <span>C</span><span>:</span><span>int</span><span>=</span><span>3</span><span>)</span><span>=</span>

    <span>let</span>
        <span>inpRawData</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>UncheckedArray</span><span>[</span><span>uint8</span><span>]]</span><span>(</span><span>inpRawData_ptr</span><span>)</span>
        <span>outRawData</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>UncheckedArray</span><span>[</span><span>float32</span><span>]]</span><span>(</span><span>outRawData_ptr</span><span>)</span>

    <span>let</span>
        <span>scale_h</span><span>:</span><span>float</span> <span>=</span> <span>inpH</span><span>.</span><span>float</span><span>/</span><span>outH</span><span>.</span><span>float</span>
        <span>scale_w</span><span>:</span><span>float</span> <span>=</span> <span>inpW</span><span>.</span><span>float</span><span>/</span><span>outW</span><span>.</span><span>float</span>

    <span># For each position in output image/array, get the correponding input pixel value. </span>
    <span>for</span> <span>h</span> <span>in</span> <span>0</span><span>..</span><span>&lt;</span><span>outH</span><span>:</span>
      <span>for</span> <span>w</span> <span>in</span> <span>0</span><span>..</span><span>&lt;</span><span>outW</span><span>:</span>
        <span>for</span> <span>c</span> <span>in</span> <span>0</span><span>..</span><span>&lt;</span><span>C</span><span>:</span>
          <span>let</span> <span>src_h</span> <span>=</span> <span>nearest_neighbour_compute_source_index</span><span>(</span><span>scale</span><span>=</span><span>scale_h</span><span>,</span> <span>out_index</span><span>=</span><span>h</span><span>,</span> <span>input_size</span><span>=</span><span>inpH</span><span>)</span> <span># logical index</span>
          <span>let</span> <span>src_w</span> <span>=</span> <span>nearest_neighbour_compute_source_index</span><span>(</span><span>scale</span><span>=</span><span>scale_w</span><span>,</span> <span>out_index</span><span>=</span><span>w</span><span>,</span> <span>input_size</span><span>=</span><span>inpW</span><span>)</span> <span># logical index</span>

          <span>var</span> <span>inp_f32</span> <span>=</span> <span>float32</span><span>(</span><span>inpRawData</span><span>[</span><span>src_h</span><span>*</span><span>inpW</span><span>*</span><span>C</span> <span>+</span> <span>src_w</span><span>*</span><span>C</span> <span>+</span> <span>c</span><span>]</span><span>)</span><span>/</span><span>255&#39;f32</span>

          <span>outRawData</span><span>[</span><span>c</span><span>*</span><span>outH</span><span>*</span><span>outW</span> <span>+</span> <span>h</span><span>*</span><span>outW</span> <span>+</span> <span>w</span><span>]</span> <span>=</span> <span>inp_f32</span>
</code></pre></div>

<p>Model may need image-data either in <code>BGR</code> format or in <code>RGB</code> format depending on data model was trained with. Let us try to include that constraint into our code with no extra cost.</p>
<div><pre><span></span><code><span>proc </span><span>hwc2chw_resize_simple</span><span>(</span><span>inpRawData_ptr</span><span>:</span><span>ptr</span> <span>uint8</span><span>,</span> <span>outRawData_ptr</span><span>:</span><span>ptr</span> <span>float32</span><span>,</span> <span>inpH</span><span>:</span><span>int</span><span>,</span> <span>inpW</span><span>:</span><span>int</span><span>,</span> <span>outH</span><span>:</span><span>int</span><span>,</span> <span>outW</span><span>:</span><span>int</span><span>,</span> <span>C</span><span>=</span><span>3</span><span>,</span> <span>reverse_channels</span><span>:</span><span>bool</span><span>=</span><span>false</span><span>)</span><span>=</span>

    <span>let</span> <span>reverse_channels</span> <span>=</span> <span>int</span><span>(</span><span>reverse_channels</span><span>)</span> <span>#0/1</span>
    <span>let</span>
        <span>inpRawData</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>UncheckedArray</span><span>[</span><span>uint8</span><span>]]</span><span>(</span><span>inpRawData_ptr</span><span>)</span>
        <span>outRawData</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>UncheckedArray</span><span>[</span><span>float32</span><span>]]</span><span>(</span><span>outRawData_ptr</span><span>)</span>

    <span>let</span>
        <span>scale_h</span><span>:</span><span>float</span> <span>=</span> <span>inpH</span><span>.</span><span>float</span><span>/</span><span>outH</span><span>.</span><span>float</span>
        <span>scale_w</span><span>:</span><span>float</span> <span>=</span> <span>inpW</span><span>.</span><span>float</span><span>/</span><span>outW</span><span>.</span><span>float</span>

    <span>#For each position in output image/array, get the correponding input pixel value. </span>
    <span>for</span> <span>h</span> <span>in</span> <span>0</span><span>..</span><span>&lt;</span><span>outH</span><span>:</span>
      <span>for</span> <span>w</span> <span>in</span> <span>0</span><span>..</span><span>&lt;</span><span>outW</span><span>:</span>
        <span>for</span> <span>c</span> <span>in</span> <span>0</span><span>..</span><span>&lt;</span><span>C</span><span>:</span>
          <span>let</span> <span>src_h</span> <span>=</span> <span>nearest_neighbour_compute_source_index</span><span>(</span><span>scale</span><span>=</span><span>scale_h</span><span>,</span> <span>out_index</span><span>=</span><span>h</span><span>,</span> <span>input_size</span><span>=</span><span>inpH</span><span>)</span> <span>#logical index</span>
          <span>let</span> <span>src_w</span> <span>=</span> <span>nearest_neighbour_compute_source_index</span><span>(</span><span>scale</span><span>=</span><span>scale_w</span><span>,</span> <span>out_index</span><span>=</span><span>w</span><span>,</span> <span>input_size</span><span>=</span><span>inpW</span><span>)</span> <span>#logical index</span>

          <span>#if reverse_channels is true, we get (C-1-c)&#39;th channel, otherwise c&#39;th channel.  </span>
          <span>var</span> <span>inp_f32</span> <span>=</span> <span>float32</span><span>(</span><span>inpRawData</span><span>[</span><span>src_h</span><span>*</span><span>inpW</span><span>*</span><span>C</span> <span>+</span> <span>src_w</span><span>*</span><span>C</span> <span>+</span> <span>(</span><span>1</span><span>-</span><span>reverse_channels</span><span>)</span><span>*</span><span>c</span> <span>+</span> <span>reverse_channels</span><span>*</span><span>(</span><span>C</span><span>-</span><span>1</span><span>-</span><span>c</span><span>)</span><span>]</span><span>)</span><span>/</span><span>255&#39;f32</span>


          <span>#update corresponding memory-location for output array by converting logical indices to array indices.</span>
          <span>outRawData</span><span>[</span><span>c</span><span>*</span><span>outH</span><span>*</span><span>outW</span> <span>+</span> <span>h</span><span>*</span><span>outW</span> <span>+</span> <span>w</span><span>]</span> <span>=</span> <span>inp_f32</span>
</code></pre></div>

<p>Let us also fuse <code>normalization</code> step i.e. subtracting Mean and dividing std-deviation along Channel dimension.</p>
<div><pre><span></span><code><span>proc </span><span>hwc2chw_resize_simple</span><span>(</span><span>inpRawData_ptr</span><span>:</span><span>ptr</span> <span>uint8</span><span>,</span> <span>outRawData_ptr</span><span>:</span><span>ptr</span> <span>float32</span><span>,</span> <span>inpH</span><span>:</span><span>int</span><span>,</span> <span>inpW</span><span>:</span><span>int</span><span>,</span> <span>outH</span><span>:</span><span>int</span><span>,</span> <span>outW</span><span>:</span><span>int</span><span>,</span> <span>C</span><span>=</span><span>3</span><span>,</span> <span>mean_array</span><span>:</span><span>array</span><span>[</span><span>3</span><span>,</span> <span>float32</span><span>]=[</span><span>0&#39;f32</span><span>,</span><span>0</span><span>,</span><span>0</span><span>]</span><span>,</span> <span>std_array</span><span>:</span><span>array</span><span>[</span><span>3</span><span>,</span> <span>float32</span><span>]=[</span><span>1&#39;f32</span><span>,</span><span>1</span><span>,</span><span>1</span><span>]</span><span>,</span> <span>reverse_channels</span><span>:</span><span>bool</span><span>=</span><span>false</span><span>)</span><span>=</span>

    <span>let</span> <span>reverse_channels</span> <span>=</span> <span>int</span><span>(</span><span>reverse_channels</span><span>)</span> <span>#0/1</span>
    <span>let</span>
        <span>inpRawData</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>UncheckedArray</span><span>[</span><span>uint8</span><span>]]</span><span>(</span><span>inpRawData_ptr</span><span>)</span>
        <span>outRawData</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>UncheckedArray</span><span>[</span><span>float32</span><span>]]</span><span>(</span><span>outRawData_ptr</span><span>)</span>

    <span>let</span>
        <span>scale_h</span><span>:</span><span>float</span> <span>=</span> <span>inpH</span><span>.</span><span>float</span><span>/</span><span>outH</span><span>.</span><span>float</span>
        <span>scale_w</span><span>:</span><span>float</span> <span>=</span> <span>inpW</span><span>.</span><span>float</span><span>/</span><span>outW</span><span>.</span><span>float</span>

    <span>#For each position in output image/array, get the correponding input pixel value. </span>
    <span>for</span> <span>h</span> <span>in</span> <span>0</span><span>..</span><span>&lt;</span><span>outH</span><span>:</span>
      <span>for</span> <span>w</span> <span>in</span> <span>0</span><span>..</span><span>&lt;</span><span>outW</span><span>:</span>
        <span>for</span> <span>c</span> <span>in</span> <span>0</span><span>..</span><span>&lt;</span><span>C</span><span>:</span>
          <span>let</span> <span>src_h</span> <span>=</span> <span>nearest_neighbour_compute_source_index</span><span>(</span><span>scale</span><span>=</span><span>scale_h</span><span>,</span> <span>out_index</span><span>=</span><span>h</span><span>,</span> <span>input_size</span><span>=</span><span>inpH</span><span>)</span> <span>#logical index</span>
          <span>let</span> <span>src_w</span> <span>=</span> <span>nearest_neighbour_compute_source_index</span><span>(</span><span>scale</span><span>=</span><span>scale_w</span><span>,</span> <span>out_index</span><span>=</span><span>w</span><span>,</span> <span>input_size</span><span>=</span><span>inpW</span><span>)</span> <span>#logical index</span>

          <span>#if reverse_channels is true, we get (C-1-c)&#39;th channel, otherwise c&#39;th channel.  </span>
          <span>var</span> <span>inp_f32</span> <span>=</span> <span>float32</span><span>(</span><span>inpRawData</span><span>[</span><span>src_h</span><span>*</span><span>inpW</span><span>*</span><span>C</span> <span>+</span> <span>src_w</span><span>*</span><span>C</span> <span>+</span> <span>(</span><span>1</span><span>-</span><span>reverse_channels</span><span>)</span><span>*</span><span>c</span> <span>+</span> <span>reverse_channels</span><span>*</span><span>(</span><span>C</span><span>-</span><span>1</span><span>-</span><span>c</span><span>)</span><span>]</span><span>)</span><span>/</span><span>255&#39;f32</span>

          <span>#minus correponding mean and divide by standard deviation.</span>
          <span>inp_f32</span> <span>=</span> <span>(</span><span>inp_f32</span> <span>-</span> <span>mean_array</span><span>[</span><span>(</span><span>1</span><span>-</span><span>reverse_channels</span><span>)</span><span>*</span><span>c</span> <span>+</span> <span>reverse_channels</span><span>*</span><span>(</span><span>C</span><span>-</span><span>1</span><span>-</span><span>c</span><span>)</span><span>]</span><span>)</span><span>/</span><span>(</span><span>std_array</span><span>[</span><span>(</span><span>1</span><span>-</span><span>reverse_channels</span><span>)</span><span>*</span><span>c</span> <span>+</span> <span>reverse_channels</span><span>*</span><span>(</span><span>C</span><span>-</span><span>1</span><span>-</span><span>c</span><span>)</span><span>]</span> <span>+</span> <span>1e-5&#39;f32</span><span>)</span>

          <span>#update corresponding memory-location for output array by converting logical indices to array indices.</span>
          <span>outRawData</span><span>[</span><span>c</span><span>*</span><span>outH</span><span>*</span><span>outW</span> <span>+</span> <span>h</span><span>*</span><span>outW</span> <span>+</span> <span>w</span><span>]</span> <span>=</span> <span>inp_f32</span>
</code></pre></div>

<p>In this way we were able to fuse generally all the steps for a preprocessing pipeline with almost no-extra cost. We can write more specific code depending on the model needs but with similar speeds hence significantly reducing the latency for preprocessing part for a model.</p>
<h2>Generating Python extension.</h2>
<p>We now can generate a Python extension to include this functionality in a Python compiled module.
We would be using an awesome module <a href="https://github.com/yglukhov/nimpy">nimpy</a> which is designed with ABI compatibility, and hence should work independent of Python versions.</p>
<h3>Reading the <code>rawData</code> produced from Python side.</h3>
<p>According to code written in Nim,we would be needing access to raw Uint8 values for given frame/image.
To produce the data from the Python side, we would be using <code>Numpy</code> which implements <a href="https://docs.python.org/3/c-api/buffer.html">buffer protocol</a>, hence easily allowing access to underlying <code>buffer/rawData</code> on the Nim side, which is exactly what we need.
Since Numpy is one of the most-used modules for matrix/array manipulation, being directly able to provide a Numpy array to routines exposed by the compiled extension is a great benefit.</p>
<h2>Writing code for extension</h2>
<div><pre><span></span><code><span>import</span> <span>nimpy</span>
<span>import</span> <span>nimpy</span> <span>/</span> <span>[</span><span>raw_buffers</span><span>,</span> <span>py_types</span><span>]</span>

<span>proc </span><span>preprocessPipeline_nim</span><span>(</span><span>image</span><span>:</span><span>PyObject</span><span>,</span> <span>output</span><span>:</span><span>PyObject</span><span>,</span> <span>reverse_channels</span><span>:</span><span>bool</span><span>=</span><span>false</span><span>){.</span><span>exportpy</span><span>.}</span><span>=</span>

  <span>var</span> <span>image_buf</span><span>:</span><span>RawPyBuffer</span>
  <span>image</span><span>.</span><span>getBuffer</span><span>(</span><span>image_buf</span><span>,</span> <span>PyBUF_SIMPLE</span> <span>or</span> <span>PyBUF_ND</span><span>)</span>

  <span>var</span> <span>output_buf</span><span>:</span><span>RawPyBuffer</span>
  <span>output</span><span>.</span><span>getBuffer</span><span>(</span><span>output_buf</span><span>,</span> <span>PyBUF_WRITABLE</span> <span>or</span> <span>PyBUF_ND</span><span>)</span>


  <span>#access to rawData</span>
  <span>let</span> <span>rawData_ptr</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>uint8</span><span>]</span><span>(</span><span>image_buf</span><span>.</span><span>buf</span><span>)</span>
  <span>let</span> <span>output_ptr</span> <span>=</span>  <span>cast</span><span>[</span><span>ptr</span> <span>float32</span><span>]</span><span>(</span><span>output_buf</span><span>.</span><span>buf</span><span>)</span>

  <span>#get dimensions of our input image.</span>
  <span>let</span>
      <span>H</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>UncheckedArray</span><span>[</span><span>Py_ssize_t</span><span>]]</span><span>(</span><span>image_buf</span><span>.</span><span>shape</span><span>)</span><span>[</span><span>0</span><span>]</span><span>.</span><span>int</span>  
      <span>W</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>UncheckedArray</span><span>[</span><span>Py_ssize_t</span><span>]]</span><span>(</span><span>image_buf</span><span>.</span><span>shape</span><span>)</span><span>[</span><span>1</span><span>]</span><span>.</span><span>int</span>
      <span>C</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>UncheckedArray</span><span>[</span><span>Py_ssize_t</span><span>]]</span><span>(</span><span>image_buf</span><span>.</span><span>shape</span><span>)</span><span>[</span><span>2</span><span>]</span><span>.</span><span>int</span>

      <span>outH</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>UncheckedArray</span><span>[</span><span>Py_ssize_t</span><span>]]</span><span>(</span><span>output_buf</span><span>.</span><span>shape</span><span>)</span><span>[</span><span>1</span><span>]</span><span>.</span><span>int</span>  
      <span>outW</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>UncheckedArray</span><span>[</span><span>Py_ssize_t</span><span>]]</span><span>(</span><span>output_buf</span><span>.</span><span>shape</span><span>)</span><span>[</span><span>2</span><span>]</span><span>.</span><span>int</span>
      <span>C_out</span> <span>=</span> <span>cast</span><span>[</span><span>ptr</span> <span>UncheckedArray</span><span>[</span><span>Py_ssize_t</span><span>]]</span><span>(</span><span>output_buf</span><span>.</span><span>shape</span><span>)</span><span>[</span><span>0</span><span>]</span><span>.</span><span>int</span>

  <span>assert</span> <span>C</span> <span>==</span> <span>C_out</span>
  <span>doAssert</span> <span>C</span> <span>==</span> <span>3</span><span>,</span><span>&#34;Expected No of channels to be 3&#34;</span> <span>&amp;</span> <span>&#34; but got &#34;</span> <span>&amp;</span> <span>$</span><span>C</span>


  <span>hwc2chw_resize_simple</span><span>(</span>
    <span>inpRawData_ptr</span> <span>=</span> <span>rawData_ptr</span><span>,</span>
    <span>outRawData_ptr</span> <span>=</span> <span>output_ptr</span><span>,</span>
    <span>inpH</span> <span>=</span> <span>H</span><span>,</span>
    <span>inpW</span> <span>=</span> <span>W</span><span>,</span>
    <span>outH</span> <span>=</span> <span>outH</span><span>,</span>
    <span>outW</span> <span>=</span> <span>outW</span><span>,</span>
    <span>C</span> <span>=</span> <span>C</span><span>,</span>
    <span>reverse_channels</span> <span>=</span> <span>bool</span><span>(</span><span>reverse_channels</span><span>)</span>
  <span>)</span>


  <span>#release the buffers reference for Python GC.</span>
  <span>image_buf</span><span>.</span><span>release</span><span>()</span>
  <span>output_buf</span><span>.</span><span>release</span><span>()</span>
</code></pre></div>

<h2>Compiling the extension</h2>
<p>Since i am compiling on <strong>Windows</strong>, to please <code>Windows</code> gods I have to offer some sacrifice in the form of extra flags like <code>--tlsEmulation:off</code> and <code>-passL:-static</code>.</p>
<div><pre><span></span><code><span>#</span> <span>default</span> <span>cc</span><span>/</span><span>compiler</span> <span>is</span> <span>gcc</span><span>,</span>
<span>nim</span> <span>c</span> <span>[</span><span>-</span><span>d</span><span>:</span><span>danger</span><span>]</span> <span>--</span><span>cc</span><span>:</span><span>gcc</span> <span>--</span><span>threads</span><span>:</span><span>on</span> <span>--</span><span>app</span><span>:</span><span>lib</span> <span>--tlsEmulation:off</span> <span>--</span><span>passL</span><span>:-</span><span>static</span> <span>--</span><span>out</span><span>:</span><span>preprocessPipeline</span><span>.</span><span>pyd</span> <span>preprocessPipeline</span><span>.</span><span>nim</span>
</code></pre></div>

<h2>Using the extension from Python</h2>
<div><pre><span></span><code><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>

<span>import</span> <span>preprocessPipeline</span> <span>as</span> <span>pipeline</span>

<span>#wrap this into a simple function, for easy usage.minimal extra latency in form of function call overhead.</span>
<span>def</span> <span>preprocess</span><span>(</span><span>image</span><span>,</span> <span>output_shape</span><span>:</span><span>tuple</span><span>,</span> <span>reverse_channels</span><span>:</span><span>bool</span><span>=</span><span>False</span><span>):</span>
  <span>&#34;&#34;&#34; Takes an input image of uint8 , HWC format, returns resized image float32[0-1] with format CHW&#34;&#34;&#34;</span>

  <span>#image: numpy nd array of uint8 data-type of shape [H, W, C]</span>
  <span>#output_shape: (out_height, out_width)</span>

  <span>#returns: np.array of shape [C, out_height, out_width]</span>
  <span>inpH</span> <span>=</span> <span>image</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>]</span>
  <span>inpW</span> <span>=</span> <span>image</span><span>.</span><span>shape</span><span>[</span><span>1</span><span>]</span>
  <span>C</span> <span>=</span> <span>image</span><span>.</span><span>shape</span><span>[</span><span>2</span><span>]</span>

  <span>outH</span> <span>=</span> <span>output_shape</span><span>[</span><span>0</span><span>]</span>
  <span>outW</span> <span>=</span> <span>output_shape</span><span>[</span><span>1</span><span>]</span>

  <span>output</span> <span>=</span> <span>np</span><span>.</span><span>empty</span><span>((</span><span>C</span><span>,</span> <span>outH</span><span>,</span> <span>outW</span><span>),</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>float32</span><span>)</span>
  <span>pipeline</span><span>.</span><span>preprocessPipeline_nim</span><span>(</span><span>image</span><span>,</span> <span>output</span><span>,</span> <span>reverse_channels</span><span>=</span><span>False</span><span>)</span><span>#output would be updated in-place.</span>

  <span>return</span> <span>output</span>
</code></pre></div>

<h3>Timing:</h3>
<p>Now we can try out our extension to visualize some results.
It takes about <code>~700 microseconds</code> on my system for <code>preprocess</code> function to run with an image with resolution of <code>576x768x3</code>.</p>
<div><pre><span></span><code><span>import</span> <span>cv2</span>
<span>import</span> <span>numpy</span> <span>as</span> <span>np</span>

<span>frame</span> <span>=</span> <span>cv2</span><span>.</span><span>imread</span><span>(</span><span>&#34;test.jpg&#34;</span><span>)</span> <span>#Uint8 HWC format [576,768,3]</span>
<span>output</span> <span>=</span> <span>preprocess</span><span>(</span><span>frame</span><span>,</span> <span>output_shape</span><span>=</span><span>(</span><span>240</span><span>,</span><span>256</span><span>),</span> <span>reverse_channels</span><span>=</span><span>False</span><span>)</span>
<span>output_reversed</span> <span>=</span> <span>preprocess</span><span>(</span><span>frame</span><span>,</span> <span>output_shape</span><span>=</span><span>(</span><span>240</span><span>,</span><span>256</span><span>),</span> <span>reverse_channels</span><span>=</span><span>True</span><span>)</span>

<span>#This preprocessed output, can be directly used as an input to computer-vision model.</span>

<span>cv2</span><span>.</span><span>imshow</span><span>(</span><span>&#34;frame&#34;</span><span>,</span> <span>output</span><span>.</span><span>transpose</span><span>(</span><span>1</span><span>,</span><span>2</span><span>,</span><span>0</span><span>))</span>
<span>cv2</span><span>.</span><span>waitKey</span><span>(</span><span>0</span><span>)</span>
</code></pre></div>

<p>Corresponding pipeline in Pytorch framework would look like as shown below. Even though Pytorch is research oriented framework but pipeline like shown below is used quite regularly for making predictions even with trained/deployed-in-production models.</p>
<div><pre><span></span><code><span>import</span> <span>PIL</span>
<span>from</span> <span>torchvision</span> <span>import</span> <span>transforms</span>

<span>pipeline</span> <span>=</span> <span>transforms</span><span>.</span><span>Compose</span><span>([</span>
        <span>transforms</span><span>.</span><span>Resize</span><span>((</span><span>240</span><span>,</span><span>256</span><span>),</span><span>1</span><span>),</span> <span>#1 for interpolation Nearest-neighbour</span>
        <span>transforms</span><span>.</span><span>ToTensor</span><span>(),</span>  <span>#[HWC] -&gt; [CHW] [0-1] float32</span>
        <span>transforms</span><span>.</span><span>Normalize</span><span>(</span><span>mean</span><span>=</span><span>[</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>],</span> <span>std</span><span>=</span><span>[</span><span>1</span><span>,</span><span>1</span><span>,</span><span>1</span><span>])</span>
<span>])</span>

<span>image</span> <span>=</span> <span>PIL</span><span>.</span><span>Image</span><span>.</span><span>open</span><span>(</span><span>&#34;test.jpg&#34;</span><span>)</span> <span>##Uint8 HWC format [576,768,3]</span>
<span>output</span> <span>=</span> <span>pipeline</span><span>(</span><span>image</span><span>)</span>
</code></pre></div>

<h3>Timing:</h3>
<p>It takes about <code>5.6 milliseconds</code>, without even <code>color-conversion</code> routine being run/fused.
Even though it is a very basic comparison of timing, it indicates the flexibility we can have when writing extension for very specific needs and with much lower latency than already compiled modules.</p>
<h2>Remarks:</h2>
<p>Like this we should be able to fuse more operations depending upon model requirements, like resizing with keeping aspect ratio unchanged.</p>
<p>In our experience we have found by writing preprocessing/postprocessing code from scratch in Nim/C/Rust/Zig and wrapping existing fast-implementations of operations like <code>Convolution</code> we can make a lot of deep-learning based models run in real-time on Consumer Grade CPUs even without <code>AVX512</code> instructions, thus opening a lot of exciting opportunities, along with added benefit of deploying them in production without much friction.</p>
      </div>
    </div><p><i>If you think i made a mistake or have any comments,please reach out to anubhav@ramanlabs.in .</i>
  </p></div>
  </body>
</html>
