<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wasmgroundup.com/blog/wasm-compiler-in-a-tweet/">Original</a>
    <h1>A WebAssembly compiler that fits in a tweet</h1>
    
    <div id="readability-page-1" class="page"><div id="__blog-post-container" itemprop="articleBody">
<!-- -->
<!-- -->
<!-- -->

<p>One of the initial explorations that started this book was how small and simple a compile-to-WebAssembly language implemented in JavaScript could be. Our first “WebAssembly compiler in a tweet” was 269 bytes; since then, we’ve managed to whittle it down to a measly 192 bytes.</p>
<p>The final result is a compiler that takes an arithmetic expression — written in reverse polish notation — and compiles it down to a valid WebAssembly module. That module exports a single function which returns the result of the original arithmetic expression. Here it is:</p>

<p>And here’s an example of how you can use it:</p>

<p>But this is not just a clever trick — if you take the time to understand what this code does, you’ll learn a surprising amount about WebAssembly! In the rest of the post, we’ll explain how it all works by de-obfuscating the code one step at a time.</p>
<p>You can play with the code in this post here: <a href="https://stackblitz.com/edit/rpn-to-wasm-js-compiler?file=index.js" target="_blank" rel="noopener noreferrer">stackblitz.com/edit/rpn-to-wasm-js-compiler</a>.</p>

<p>The first thing we can do to make it more readable is to format it:</p>

<p>While it’s still pretty unreadable, now we can at least identify different parts of the code.</p>
<p>At a high level, what we’re doing is ‘parsing’ the expression in a very simple way, turning it into the appropriate Wasm bytecode,
and then hand-crafting the bytes for a single-function module.</p>
<p>In a more complex compiler you would probably use a library to generate the WebAssembly module and compile the expressions but our main metric
here is code size so we write the bytes directly in an array.</p>

<p>The first trick to undo is the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment" target="_blank" rel="noopener noreferrer">assignment expression</a>.</p>
<p>In JavaScript the assignment operator is an expression. This means that it generates a result after evaluating, as you can see in the following examples:</p>

<p>The code above will output:</p>

<p>This is because <code>a = 42</code> assigns <code>42</code> to <code>a</code> and the whole assignment expression evaluates to the value being assigned.</p>
<p>In <code>a = b = 43</code>, we assign the result of evaluating <code>b = 43</code> to <code>a</code>. This equivalent expression may be easier to understand: <code>a = (b = 43)</code>.</p>
<p>In our code, we use this trick to reuse variables and update their value in places where
we can also use the value being assigned. It also allows us to have our compiler in a single expression, avoiding the need for curly braces, semicolons and return statements.</p>
<p>To undo it, we turn the body of our function into a block and do each assignment on its own line:</p>
<section></section>

<p>Now the assignments are easier to identify but the meaning of variables and function
arguments are still hard to understand. Let’s fix that by undoing a couple of variable tricks.</p>
<p>The first step is to stop using single letter variables, and to use more descriptive names instead. The next step is to stop reusing variables: for example, <code>b</code> initially holds the code to compile, but once we don’t need that any more we reuse it to hold the bytecode instructions.</p>
<p>To undo this we are going to introduce a new <code>instrs</code> variable and rename <code>b</code> to <code>code</code>. We’ll also rename <code>l</code> to <code>len</code>. This variable contains a value that is close to the number of bytecodes.</p>
<p>By declaring <code>l</code> in the body we can remove it from the function argument’s list. We did this
as a trick to avoid the need to declare it with <code>let</code> or <code>const</code>, saving some bytes and the need for a function body.</p>
<p>The trick works by adding unused arguments at the end of the function argument list and using them as local variables. Our compiler function expects a single argument with the code; <code>l</code> is there for us to use since we don’t expect the caller to provide any value for it.</p>
<p>Here’s the code without this trick:</p>
<section></section>

<p>If you look at the array in our code, you may notice that there are many commas followed by another comma instead of a value. This syntax defines “sparse arrays”. Here’s an example:</p>

<p>Which is equivalent to:</p>

<p>We use this syntactic trick to save one byte each time we need a <code>0</code> to appear in the array. This works because <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Typed_arrays" target="_blank" rel="noopener noreferrer">Typed Arrays</a> coerce all array items to numbers, and an “empty item” will be converted to 0:</p>

<p>which produces:</p>

<p>Let’s undo this trick by adding all the zeroes back:</p>
<section></section>

<p>In our code, we have a variable <code>len</code> that contains a number that is close to the number
of bytecodes in the compiled expression, but not exactly the same:</p>

<p>In the WebAssembly module we need to use the number of bytes in the function body (the expression to evaluate) in two places:</p>
<ul>
<li>To define the code section’s length</li>
<li>To define the function body’s length</li>
</ul>
<p>Since there’s only one function in the code section both values are similar:</p>
<ul>
<li>The section takes two extra bytes (section identifier and number of code entries)</li>
<li>The function body takes another two bytes (number of locals and <code>end</code> instruction)</li>
</ul>
<p>To avoid writing <code>b.length</code> twice we assign to <code>l</code> the value of <code>b.length + 4</code> in the place where we need the code section byte count
and then calculate <code>l - 2</code> (<code>b.length + 2</code>) where we need the function body byte count.</p>

<p>This is all a trick to avoid having to write <code>b.length</code> twice.</p>
<p>let’s assign the length to <code>len</code> and calculate the right value in each place:</p>
<section></section>

<p>The next trick to undo is <code>code.split` `</code>. In this case, we use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates" target="_blank" rel="noopener noreferrer">Tagged Template</a> feature of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener noreferrer">String Template Literals</a>.</p>
<p>Let’s see how it works by creating a simple tagged template that turns the string to uppercase:</p>

<p>And use it:</p>

<p>As you can see, the first argument to the tagged template function is an array. Luckily for us, the first argument of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split#separator" target="_blank" rel="noopener noreferrer">String.prototype.split</a> is handled in the following way:</p>
<blockquote>
<p>All values that are not undefined or objects with a <code>[Symbol.split]()</code> method are coerced to strings.</p>
</blockquote>
<p>And coercing an array with one string in it is the same as the string itself:</p>


<p>Since the function we want to call takes a single string argument, we can use it as a tagged template and save the parentheses in the function call.</p>
<p>Let’s write it as a function call instead:</p>
<section></section>

<p>Next, let’s undo the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator" target="_blank" rel="noopener noreferrer">Ternary Operator</a> and turn it into an <em>if</em> statement.</p>
<p>The ternary operator has expressions on each branch saving us the <code>return</code> statements. Here’s what the code looks like when we use an <em>if</em> statement instead:</p>
<section></section>

<p>The next trick to undo is the one present twice in the following code:</p>

<p>First we use coercion in <code>t &gt; -1</code> to check if the token <code>t</code> is a string representing a
positive number. Then we use coercion again in <code>[65, t]</code> to let JavaScript turn <code>t</code> into a <code>Number</code> in the <code>Int8Array</code>:</p>

<p>The code above evaluates to:</p>

<p>Let’s write the parsing and checking explicitly:</p>
<section></section>
<p>The semantics of our compiler change a little bit here. The original version will only accept
positive integers as input; if you want a negative number you have to subtract from zero: <code>0 - 1</code> to get <code>-1</code>. The new version allows negative numbers since it checks with <code>Number.isFinite(num)</code> instead of <code>t &gt; -1</code>.</p>

<p>The next trick is in the <em>else</em> branch:</p>

<p>Our calculator compiler only accepts four arithmetic operations: <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. But
in the code above you can only see three: <code>-*/</code> and a magical number: <code>107</code>. Here’s how it works — these are the bytecode numbers for arithmetic operations in WebAssembly:</p>
<ul>
<li><code>+</code>: <code>106</code></li>
<li><code>-</code>: <code>107</code></li>
<li><code>*</code>: <code>108</code></li>
<li><code>/</code>: <code>109</code></li>
</ul>
<p>We only enter this branch if the token <code>t</code> is not a number, which means it can only be
one of the arithmetic operators above. So, given a single character which is one of those four operators, we want to produce the appropriate opcode.</p>
<p>We <em>could</em> have written <code>106 + &#34;+-*/&#34;.indexOf(t)</code>. That is, we find the symbol’s index in the string:</p>
<ul>
<li><code>+</code>: <code>0</code></li>
<li><code>-</code>: <code>1</code></li>
<li><code>*</code>: <code>2</code></li>
<li><code>/</code>: <code>3</code></li>
</ul>
<p>…and add <code>106</code> to it to get the bytecode number. But when <code>t</code> is not in the string, <code>&#34;+-*/&#34;</code> <code>indexOf</code> returns <code>-1</code>. We can use that to our advantage, and treat <code>-1</code> to mean “plus or any other token”:</p>
<ul>
<li><code>+</code>: <code>-1</code> (any other token will be <code>-1</code> too)</li>
<li><code>-</code>: <code>0</code></li>
<li><code>*</code>: <code>1</code></li>
<li><code>/</code>: <code>2</code></li>
</ul>
<p>And that’s why we add <code>107</code> instead of <code>106</code>. Let’s undo the <code>-1</code> trick:</p>
<section></section>
<p>Here again the semantics change a little bit. Before, if the token <code>t</code> wasn’t found, the expression would evaluate to <code>107 + -1</code> which would map to an addition. Now it will evaluate to <code>106 + -1</code> which will map to bytecode <code>105</code> which is the <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Reference/Numeric/Population_count" target="_blank" rel="noopener noreferrer"><code>popcnt</code></a> instruction.</p>
<p>But don’t worry, we’ll fix it in the next step.</p>

<p>After explaining how the <code>indexOf</code> trick works and removing the <code>-1</code> part, let’s
go ahead and remove the trick completely. To do it we are going to create an object that maps from an arithmetic operation token to its bytecode:</p>
<section></section>
<p>To keep the initial semantics, if the token is not a valid operation we return the bytecode for <code>+</code>: in <code>OP_TO_BYTECODE[t] ?? 106</code>.</p>

<p>From the usage example at the beginning of the post, you may have noticed that the exported
function’s name is the empty string:</p>

<p>We did this to save us the bytes needed to specify the export name,
but also to save an extra byte/character in the code because with the length of the export name being <code>0</code>
we can use the sparse array syntax to leave an empty spot in the WebAssembly module array.</p>
<p>To revert this trick we are going to name the exported function as <code>a</code>, which in UTF-8 is the byte <code>97</code>:</p>

<section></section>
<p>We can now call it with a nicer name:</p>


<p>Our initial implementation only supported positive numbers, but that’s not the only number restriction in our compiler.</p>
<p>To keep WebAssembly modules as small as possible, numbers are encoded using a variable-length encoding algorithm called <a href="https://en.wikipedia.org/wiki/LEB128" target="_blank" rel="noopener noreferrer">LEB128</a>. You can tell we are not implementing the whole algorithm by looking at the part of the code that encodes numbers: <code>[65,t]</code>. We’re assuming the number being encoded fits in 7 bits, the shortest possible LEB128 representation.</p>
<p>Let’s try the limits of our implementation:</p>


<p>This means the only numbers that will be parsed correctly are from <code>0</code> to <code>63</code>.</p>


<p>Fails with:</p>
<blockquote>
<p>Uncaught CompileError: WebAssembly.instantiate(): Compiling function #0 failed: function body must end with “end” opcode @+33</p>
</blockquote>
<p>In the last one we went over the 7 bits and the module was rejected during validation.</p>
<p>Explaining and implementing LEB128 takes a lot of text and code. If you want to read more
about it we have a whole deep dive on LEB128 in <a href="https://wasmgroundup.com/" target="_blank" rel="noopener noreferrer">our book</a>.</p>

<p>During the code golfing phase I had a literal shower thought but sadly it didn’t work.</p>
<p>The idea was to simplify <code>106 + &#34;+-*/&#34;.indexOf(t)</code> by using the UTF-8 character code plus an offset like this: <code>63 + t.charCodeAt()</code> and saving 3 bytes in the process. The reason it didn’t work is that the characters <code>+-*/</code> don’t appear in the same order in UTF-8 and WebAssembly bytecode.</p>

<p>The last part to expand/explain is the array of numbers used to build the WebAssembly module.</p>
<p>It takes a big part of a <a href="https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/" target="_blank" rel="noopener noreferrer">specification</a> to explain every byte in the array, but here’s a commented version that should give you a high level idea of what each part does:</p>


<p>There you go! We’ve turned a rather opaque 192-byte snippet into something that’s almost readable. And in the process, you hopefully learned a little bit about WebAssembly.</p>
<p>If we dropped the size restrictions, there are lots of things we might want to improve in this compiler: handle numbers greater than 127, add nicer syntax, add support for conditionals, loops, etc. If you’re interested in what that might look like, I encourage you to check out our book <a href="https://wasmgroundup.com/" target="_blank" rel="noopener noreferrer">WebAssembly from the Ground Up</a>. You’ll learn the ins and outs of WebAssembly by writing a real compiler for a simple programming language. It’s a lot of fun!</p>
<p>Special thanks to <a href="https://bsky.app/profile/orthoplex.bsky.social" target="_blank" rel="noopener noreferrer">lexi</a> for contributing some of the tricks used above.</p></div></div>
  </body>
</html>
