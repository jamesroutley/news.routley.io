<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/">Original</a>
    <h1>SQLite Index Visualization</h1>
    
    <div id="readability-page-1" class="page"><div>
    
<p>After learning about indexes, I understood their basic structure, but I wanted to dig deeper — to explore the data structure, understand the algorithm, and learn how the index data is stored on disk.</p>
<p>I wanted to see how a database management system (DBMS) stores an index in both disk and memory, and how it searches through an Index.</p>
<ul>
<li>it’s a widely used DBMS, found in browsers, mobile apps, and operating systems;</li>
<li>it&#39;s easier to debug: no separate server, just a client-side application;</li>
<li>its codebase is smaller than MySQL or PostgreSQL but uses similar data structures for Indexes;</li>
<li>it’s open-source.</li>
</ul>
<a href="#h2-node-and-page-structure" id="h2-node-and-page-structure"><h2>Node and Page Structure</h2></a>
<p>According to SQLite <a href="https://sqlite.org/fileformat2.html" target="_blank">documentation</a>, Indexes are stored in a B-Tree structure, which is a balanced tree where each node has multiple children.</p>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/b-tree.svg"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/b-tree.svg" alt=""/></a></p>
<p>To understand how SQLite stores Nodes, let’s look at the Page and Cell structures.</p>
<p>Here’s a visual example of a B-Tree Index in SQLite:</p>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/b-tree-sqlite.svg"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/b-tree-sqlite.svg" alt=""/></a></p>
<p>Index data is stored on disk in this structure:</p>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/b-tree-store.svg"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/b-tree-store.svg" alt=""/></a></p>
<p>Each Page has a fixed size, ranging from 512 to 65,536 bytes. Page and Cell headers use 4 bytes to store child links.</p>
<pre><code>get4byte(...)</code></pre>
<p>For other Page and Cell data, we can use these C structures:</p>
<a href="#h3-page" id="h3-page"><h3>Page</h3></a>
<p>sqlite/src/btreeInt.h</p>
<pre><code>struct MemPage {
  Pgno pgno;           /* Page number for this page */
  u16 nCell;           /* Number of cells on this page, local and ovfl */
  u8 *aCellIdx;        /* The cell index area */
  u8 *aData;           /* Pointer to disk image of the page data */ 
  ...
};</code></pre>
<a href="#h3-cell" id="h3-cell"><h3>Cell</h3></a>
<p>sqlite/src/btreeInt.h</p>
<pre><code>struct CellInfo {
  u8 *pPayload;  /* Pointer to the start of payload */
  ...
};</code></pre>
<p>To view index data, we can use <a href="https://www.sqlite.org/sqlanalyze.html" target="_blank">sqlite3 analyzer</a>:</p>
<pre><code>sqlite3_analyzer database.sqlite
...
Page size in bytes................................ 4096      
...
*** Index IDX of table TABLE_TEST *********************************************  
Number of entries................................. 1000      
B-tree depth...................................... 2         
Total pages used.................................. 4        
..</code></pre>
<p>This tool provides only general information about index.</p>
<a href="#h2-analyzing-sqlite-source-code" id="h2-analyzing-sqlite-source-code"><h2>Analyzing SQLite Source Code</h2></a>
<p>After a few weeks of experimenting, I wrote my functions for index analysis.</p>
<p>You can view the code <a href="https://github.com/mrsuh/sqlite-index/blob/main/sqlite.patch" target="_blank">here</a>:</p>
<pre><code>char *sqlite3DebugGetMemoryPayload(Mem *mem);

char **sqlite3DebugGetCellPayloadAndRowId(BtCursor *pCur, MemPage *pPage, int cellIndex);

void sqlite3DebugBtreeIndexDump(BtCursor *pCur, int pageNumber);</code></pre>
<p>The function reads the content of selected index and outputting data to STDOUT:</p>
<pre><code>SQL query -&gt; selected index -&gt; stdout</code></pre>
<p>Here’s an example output:</p>
<pre><code>sqlite3BtreeIndexDump: page, number=3, rightChildPageNumber=99
sqlite3BtreeIndexDump: cell, number=0, leftChildPageNumber=7, payload=384, rowId=384
sqlite3BtreeIndexDump: cell, number=1, leftChildPageNumber=8, payload=742, rowId=742
...</code></pre>
<p>I packed everything into a docker if you want to test it: </p>
<pre><code>docker run -it --rm -v &#34;$PWD&#34;:/app/data --platform linux/x86_64 mrsuh/sqlite-index bash</code></pre>
<p>You can use the script like this:</p>
<pre><code>sh bin/dump-index.sh database.sqlite &#34;SELECT * FROM table INDEXED BY index WHERE column=1&#34; dump.txt</code></pre>
<p>dump.txt</p>
<pre><code>sqlite3BtreeIndexDump: page, number=3, rightChildPageNumber=99
sqlite3BtreeIndexDump: cell, number=0, leftChildPageNumber=7, payload=384, rowId=384
sqlite3BtreeIndexDump: cell, number=1, leftChildPageNumber=8, payload=742, rowId=742
...
sqlite3BtreeIndexDump: page, number=99, rightChildPageNumber=-1
sqlite3BtreeIndexDump: cell, number=0, leftChildPageNumber=-1, payload=9642, rowId=9642
sqlite3BtreeIndexDump: cell, number=1, leftChildPageNumber=-1, payload=9643, rowId=9643
...
sqlite3BtreeIndexDump: page, number=7, rightChildPageNumber=-1
sqlite3BtreeIndexDump: cell, number=0, leftChildPageNumber=-1, payload=1, rowId=1
sqlite3BtreeIndexDump: cell, number=1, leftChildPageNumber=-1, payload=2, rowId=2
...</code></pre>
<p>Great!</p>
<p>I found a library called <a href="https://github.com/benyasin/d3-org-tree" target="_blank">d3-org-tree</a> for visualizing index structures.</p>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/test-tree-d3.png"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/test-tree-d3.png" alt=""/></a></p>
<p>However, there was a problem: I couldn’t adjust the spacing between Pages, so as the tree became deeper and more Pages were added at each level, the image became too large and hard to read.</p>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/test-tree-d3-wide.png"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/test-tree-d3-wide.png" alt=""/></a></p>
<p>I tried adjusting it with JavaScript and CSS, but it didn’t work well.</p>
<p>Example:</p>
<pre><code>------------------------------------------------------------------------------------------------------------------------
 Total Pages: 29
 Total Cells: 1000
------------------------------------------------------------------------------------------------------------------------
 Level: 1                           |============================================|
 Pages: 1                           |Page: 3   | RightChildPage: 53  | Cells: 27 │
 Cells: 29                          |============================================|
                                    |Cell: 0   | LeftChildPage: 47   | RowId: 1  │
                                    |Payload: 000000000000000000000000000000     │
                                    |--------------------------------------------│
                                    |                  * * *                     │
                                    |--------------------------------------------│
                                    |Cell: 26   | LeftChildPage: 78   | RowId: 5 │
                                    |Payload: 000000000000000000000000000000     │
                                    |============================================|
------------------------------------------------------------------------------------------------------------------------
 Level: 2      |============================================| |============================================|
 Pages: 50     |Page: 3   | RightChildPage: 53  | Cells: 27 | │Page: 3   | RightChildPage: 53  | Cells: 27 |
 Cells: 400    |============================================| |============================================|
               |Cell: 0   | LeftChildPage: 47   | RowId: 1  | │Cell: 0   | LeftChildPage: 47   | RowId: 1  |
               |Payload: 000000000000000000000000000000     | │Payload: 000000000000000000000000000000     |
               |--------------------------------------------| │--------------------------------------------|
               |                  * * *                     | │                  * * *                     |
               |--------------------------------------------| │--------------------------------------------|
               |Cell: 26   | LeftChildPage: 78   | RowId: 5 | │Cell: 26   | LeftChildPage: 78   | RowId: 5 |
               |Payload: 000000000000000000000000000000     | │Payload: 000000000000000000000000000000     |
               |============================================| |============================================|
------------------------------------------------------------------------------------------------------------------------</code></pre>
<p>Not bad, but I could go further.</p>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/test-tree-php.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/test-tree-php.webp" alt=""/></a></p>
<p>The image now includes all the needed data and is easy to read.</p>
<p>In the top-left corner, there’s general information about the Index.</p>
<p>Use this command to generate an image from the dump </p>
<pre><code>php bin/console app:render-index --dumpIndexPath=dump.txt --outputImagePath=image.webp</code></pre>
<p>Now it&#39;s time to experiment!</p>
<p>We can create different data for the Indexes and explore what&#39;s inside them.</p>
<a href="#h2-index-with-1-record" id="h2-index-with-1-record"><h2>Index with 1 record</h2></a>
<pre><code>CREATE TABLE table_test (column1 INT NOT NULL);
INSERT INTO table_test (column1) VALUES (1);
CREATE INDEX idx ON table_test (column1 ASC);</code></pre>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-1.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-1.webp" alt=""/></a></p>
<p>One level, one Page, one Cell. Simple!</p>
<a href="#h2-index-with-1000-records" id="h2-index-with-1000-records"><h2>Index with 1000 records</h2></a>
<pre><code>CREATE TABLE table_test (column1 INT NOT NULL);
INSERT INTO table_test (column1) VALUES (1),(2),(3),...,(998),(999),(1000);
CREATE INDEX idx ON table_test (column1 ASC);</code></pre>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-1000.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-1000.webp" alt=""/></a></p>
<a href="#h2-index-with-1.000.000-records" id="h2-index-with-1.000.000-records"><h2>Index with 1.000.000 records</h2></a>
<pre><code>CREATE TABLE table_test (column1 INT NOT NULL);
INSERT INTO table_test (column1) VALUES (1),(2),(3),...,(999998),(999999),(1000000);
CREATE INDEX idx ON table_test (column1 ASC);</code></pre>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-1000000.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-1000000.webp" alt=""/></a></p>
<p>Now we’ve reached the image I used earlier as an example.</p>
<a href="#h2-comparing-asc-and-desc-indexes" id="h2-comparing-asc-and-desc-indexes"><h2>Comparing ASC and DESC Indexes</h2></a>
<p>Now, let&#39;s add two Indexes with different sort directions.</p>
<pre><code>CREATE TABLE table_test (column1 INT NOT NULL);
INSERT INTO table_test (column1) VALUES (1),(2),(3),...,(999998),(999999),(1000000);
CREATE INDEX idx_asc ON table_test (column1 ASC);
CREATE INDEX idx_desc ON table_test (column1 DESC);</code></pre>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-order-asc.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-order-asc.webp" alt=""/></a></p>
<p>The ASC Index is the same as above, as ASC sorting is used by default.</p>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-order-desc.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-order-desc.webp" alt=""/></a></p>
<p>The DESC Index is reversed.</p>
<a href="#h2-index-with-expression-based-data" id="h2-index-with-expression-based-data"><h2>Index with expression-based data</h2></a>
<pre><code>CREATE TABLE table_test (column1 TEXT NOT NULL);
INSERT INTO table_test (column1) VALUES (&#39;{&#34;timestamp&#34;:1}&#39;),(&#39;{&#34;timestamp&#34;:2}&#39;),(&#39;{&#34;timestamp&#34;:3}&#39;),...,(&#39;{&#34;timestamp&#34;:999998}&#39;),(&#39;{&#34;timestamp&#34;:999999}&#39;),(&#39;{&#34;timestamp&#34;:1000000}&#39;);
CREATE INDEX idx ON table_test (strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, json_extract(column1, &#39;$.timestamp&#39;), &#39;unixepoch&#39;) ASC);</code></pre>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-expression.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-expression.webp" alt=""/></a></p>
<p>The Index now stores a string generated by the expression.</p>
<a href="#h2-unique-index-with-null-values" id="h2-unique-index-with-null-values"><h2>Unique Index with NULL values</h2></a>
<pre><code>CREATE TABLE table_test (column1 INT)
INSERT INTO table_test (column1) VALUES (1),(NULL),(NULL),...,(NULL),(NULL),(1000000);
CREATE UNIQUE INDEX idx ON table_test (column1 ASC);</code></pre>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-unique.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-unique.webp" alt=""/></a></p>
<p>SQLite supports unique Indexes with NULL values.</p>
<a href="#h2-filtering-null-values-with-partial-indexes" id="h2-filtering-null-values-with-partial-indexes"><h2>Filtering NULL Values with Partial Indexes</h2></a>
<pre><code>CREATE TABLE table_test (column1 INT)
INSERT INTO table_test (column1) VALUES (1),(NULL),(NULL),...,(NULL),(NULL),(1000000);
CREATE INDEX idx ON table_test (column1 ASC) WHERE column1 IS NOT NULL;</code></pre>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-partial.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-partial.webp" alt=""/></a></p>
<p>The Index now contains just one Page, leading to faster searches than the previous example.</p>
<a href="#h2-multi-column-index" id="h2-multi-column-index"><h2>Multi-Column Index</h2></a>
<pre><code>CREATE TABLE table_test (column1 INT NOT NULL, column2 INT NOT NULL);
INSERT INTO table_test (column1, column2) VALUES (1,1),(2,2),(3,3),...,(999998,999998),(999999,999999),(1000000,1000000);
CREATE INDEX idx ON table_test (column1 ASC, column2 ASC);</code></pre>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-complex.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-complex.webp" alt=""/></a></p>
<p>As we can see, the data for all fields in a cell are stored one after another.</p>
<a href="#h2-comparing-indexes-created-before-and-after-data-population" id="h2-comparing-indexes-created-before-and-after-data-population"><h2>Comparing Indexes Created Before and After Data Population</h2></a>
<pre><code>CREATE TABLE table_test (column1 INT NOT NULL);
CREATE INDEX idx_before ON table_test (column1 ASC);
INSERT INTO table_test (column1) VALUES (1),(2),(3),...,(999998),(999999),(1000000);
CREATE INDEX idx_after ON table_test (column1 ASC);</code></pre>
<a href="#h3-before" id="h3-before"><h3>Before</h3></a>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-time-before.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-time-before.webp" alt=""/></a></p>
<a href="#h3-after" id="h3-after"><h3>After</h3></a>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-time-after.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-time-after.webp" alt=""/></a></p>
<p>The tree must rebalance itself when new data is added. Creating an Index on existing data should be much more efficient.</p>
<pre><code>+--------+-------------+-------------+
|        | Total Pages | Total Cells |
+--------+-------------+-------------+
| Before | 3342        | 1000000     |
| After  | 2930        | 1000000     |
+--------+-------------+-------------+</code></pre>
<a href="#h2-vacuum-and-reindex" id="h2-vacuum-and-reindex"><h2>VACUUM and REINDEX</h2></a>
<p>To achieve similar optimization, we can rebuild an existing Index with these commands:</p>
<p><a href="https://www.sqlite.org/lang_vacuum.html" target="_blank">VACUUM</a> recreates Indexes and tables with data:</p>
<pre><code>CREATE TABLE table_test (column1 INT NOT NULL);
CREATE INDEX idx ON table_test (column1 ASC);
INSERT INTO table_test (column1) VALUES (1),(2),(3),...,(999998),(999999),(1000000);
VACUUM;</code></pre>
<pre><code>+--------+-------------+-------------+
|        | Total Pages | Total Cells |
+--------+-------------+-------------+
| Before | 3342        | 1000000     |
| After  | 2930        | 1000000     |
+--------+-------------+-------------+</code></pre>
<p><a href="https://www.sqlite.org/lang_reindex.html" target="_blank">REINDEX</a> -  recreates Indexes only:</p>
<pre><code>CREATE TABLE table_test (column1 INT NOT NULL);
CREATE INDEX idx ON table_test (column1 ASC);
INSERT INTO table_test (column1) VALUES (1),(2),(3),...,(999998),(999999),(1000000);
REINDEX idx;</code></pre>
<pre><code>+--------+-------------+-------------+
|        | Total Pages | Total Cells |
+--------+-------------+-------------+
| Before | 3342        | 1000000     |
| After  | 2930        | 1000000     |
+--------+-------------+-------------+</code></pre>
<p>After running VACUUM/REINDEX, the number of Pages in the Index decreased a lot. </p>
<a href="#h2-text-data-in-indexes" id="h2-text-data-in-indexes"><h2>Text Data in Indexes</h2></a>
<p>Let&#39;s look at how text is stored. Short strings are saved directly in the Index Cells, but longer text must be stored separately.</p>
<pre><code>CREATE TABLE table_test (column1 text NOT NULL);
INSERT INTO table_test (column1) VALUES (&#39;text-1&#39;),(&#39;text-2&#39;),(&#39;text-3&#39;),...,(&#39;text-999998&#39;),(&#39;text-999999&#39;),(&#39;text-1000000&#39;);
CREATE INDEX idx ON table_test (column1 ASC);</code></pre>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-text.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-text.webp" alt=""/></a></p>
<p>You can easily see the actual string stored directly in the Index.</p>
<a href="#h2-float-point-data-in-indexes" id="h2-float-point-data-in-indexes"><h2>Float-point Data in Indexes</h2></a>
<pre><code>CREATE TABLE table_test (column1 REAL NOT NULL);
INSERT INTO table_test (column1) VALUES (&#39;1.14&#39;),(&#39;2.14&#39;),(&#39;3.14&#39;),...,(&#39;999998.14&#39;),(&#39;999999.14&#39;),(&#39;1000000.14&#39;);
CREATE INDEX idx ON table_test (column1 ASC);</code></pre>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-real.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-real.webp" alt=""/></a></p>
<a href="#h2-combining-integer-and-text-in-a-single-index:" id="h2-combining-integer-and-text-in-a-single-index:"><h2>Combining integer and text in a single Index:</h2></a>
<pre><code>CREATE TABLE table_test (column1 INT NOT NULL, column2 TEXT NOT NULL);
INSERT INTO table_test (column1, column2) VALUES (1,&#39;text-1&#39;),(2,&#39;text-2&#39;),(3,&#39;text-3&#39;),...,(999998,&#39;text-999998&#39;),(999999,&#39;text-999999&#39;),(1000000,&#39;text-1000000&#39;);
CREATE INDEX idx ON table_test (column1 ASC, column2 ASC);</code></pre>
<p><a href="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-integer-text.webp"><img src="https://mrsuh.com/articles/2024/sqlite-index-visualization-structure/images/index-integer-text.webp" alt=""/></a></p>
<p>The integer and string are stored together in the Cell, just as we specified when creating the Index.</p>
<a href="#h2-conclusion" id="h2-conclusion"><h2>Conclusion</h2></a>
<p>Based on the work done, we saw how Indexes in SQLite are structured.</p>
<p>To reproduce all of these examples, you can run the following:</p>
<pre><code>docker run -it --rm -v &#34;$PWD&#34;:/app/data --platform linux/x86_64 mrsuh/sqlite-index bash
sh bin/test-index.sh</code></pre>
<p>Code and examples are available <a href="https://github.com/mrsuh/sqlite-index" target="_blank">here</a></p>
<p>Next, I&#39;ll focus on visualizing Index-based searches and explore some interesting SQL queries.</p>
</div></div>
  </body>
</html>
