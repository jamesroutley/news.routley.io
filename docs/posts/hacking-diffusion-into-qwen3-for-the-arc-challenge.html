<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.matthewnewton.com/blog/arc-challenge-diffusion">Original</a>
    <h1>Hacking Diffusion into Qwen3 for the Arc Challenge</h1>
    
    <div id="readability-page-1" class="page"><div>
            <article>
                <h2 id="overview">Overview</h2>

<p>I&#39;ve been playing with the ARC AGI Prize recently<sup><a href="#fn1" id="fnref1">1</a></sup>. There are a lot of things that surprised me while replicating the approach of last year&#39;s grand prize winner, &#34;The ARChitects&#34;<sup><a href="#fn2" id="fnref2">2</a></sup>. For example, when the model was less sure about a pixel, the solution was more likely wrong. Another was that a per-pixel token encoding even worked. It was like the poor model was forced to type its solutions out, character by character, on a typewriter with no backspace. </p>

<p>Imagine solving a jigsaw puzzle but you have to place pieces starting from the top-left corner in order. No jumping around. No doing the edges first. That&#39;s what we&#39;re making these models do.</p>

<p>Instead of forcing the model to work in typewriter-order, what if we let it fill in the easy parts first? Maybe you can use the uncertainty to measure what is obvious and what is tricky. As it turns out, it works:</p>


<p><em>Video 1: A comparison of autoregressive (left) and diffusion (right) approaches on the same task. The diffusion model first fills in &#34;easy&#34; tokens and works its way in to more complicated tokens.</em></p>

<p>Based on recent work in converting autoregressive LLMs into diffusion models<sup><a href="#fn3" id="fnref3">3</a></sup>, I took my autoregressive model and hacked it to be able to decode in any order. Then I had it unmask tokens it was more confident about first. You can see more animated detail below in <a href="#how-generation-works">How Generation Works</a>.</p>

<p>Skipping ahead a bit to the results: it still needs more work. My diffusion approach is faster at 10 timesteps and achieves modestly better token accuracy, but this doesn&#39;t translate into solving more tasks. At 30 timesteps - where it finally matches the baseline&#39;s task success rate - it&#39;s actually <em>slower</em> than autoregressive.</p>

<p>Why? One thing the typewriter approach has going for it is that the constraint of only moving forward makes it easy to cache. My implementation can&#39;t do this. I&#39;ve converted the &#34;decoder&#34; style LLM into a single fully connected &#34;encoder&#34; style, where activations of previous tokens are allowed to change based on later tokens. Currently this makes the input tokens uncachable. However, I think changing the input activations based on output changes is more flexibility than ARC tasks need. I can get back caching of the input tokens with some tweaks to disable this, which I get into in the <a href="#next-steps">Next Steps</a> section at the end.</p>

<p>This post chronicles my process in adapting a fine-tuned Qwen3-8B model<sup><a href="#fn4" id="fnref4">4</a></sup> for diffusion-based ARC solving, following recent work on converting language models to diffusion<sup><a href="#fn3" id="fnref3">3</a></sup>. I crammed in a lot of detail, I recommend reading the process section and then skipping around.</p>

<h3 id="table-of-contents">Table of Contents</h3>
<p><strong><a href="#the-process">The Process</a>:</strong> How diffusion decoding works on ARC tasks  </p>
<p>    <a href="#what-do-the-tasks-look-like">What Do the Tasks Look Like?</a> • <a href="#how-generation-works">How Generation Works</a> • <a href="#why-better-pixel-accuracy-alone-doesnt-solve-puzzles">Why Better Pixel Accuracy Alone Doesn&#39;t Solve Puzzles</a></p>

<p><strong><a href="#background">Background</a>:</strong> Motivation and failed alternatives  </p>
<p>    <a href="#the-architects-baseline">The ARChitects Baseline</a> • <a href="#computational-bottlenecks-in-autoregressive-approaches">Computational Bottlenecks</a> • <a href="#alternatives-considered">Alternatives Considered</a> • <a href="#diffusion-models-are-hard-to-train-from-scratch">Diffusion Models Are Hard To Train From Scratch</a></p>

<p><strong><a href="#technical-implementation">Technical Implementation</a>:</strong> Training details and code snippets </p>
<p>    <a href="#the-approach">The Approach</a> • <a href="#hyperparameters">Hyperparameters</a> • <a href="#training-process">Training Process</a> • <a href="#batch-structure">Batch Structure</a> • <a href="#training-data-and-augmentation">Training Data and Augmentation</a> • <a href="#handling-fixed-sequence-lengths">Handling Fixed Sequence Lengths</a></p>

<p><strong><a href="#results-on-arc-prize-2025-evaluation-set">Results on ARC Prize 2025 Evaluation Set</a>:</strong> Performance metrics and analysis  </p>
<p>    <a href="#overall-performance-comparison">Overall Performance Comparison</a> • <a href="#performance-by-output-size">Performance by Output Size</a> • <a href="#task-success-rates">Task Success Rates</a> • <a href="#results-analysis">Results Analysis</a></p>

<p><strong><a href="#next-steps">Next Steps</a></strong> • <strong><a href="#conclusion">Conclusion</a></strong> • <strong><a href="#acknowledgments">Acknowledgments</a></strong></p>

<h2 id="the-process">The Process</h2>

<h3 id="what-do-the-tasks-look-like">What Do the Tasks Look Like?</h3>

<p>You can click to expand the images below to see the complete encoding grid. Note that while the videos focus only on the final test output for clarity, the model actually processes the entire context including multiple demonstration examples. The vocabulary of the model has been reduced to a set of 24 new tokens, representing each of the 10 numbers a grid cell can have as well as several &#34;tags&#34; that denote the structure of the grid or whether a grid is an input or an output, an example or the final test. </p>

<a href="http://approximateknowledge.net/etym/2025/08/04/ef7e1ffa70d00899" target="_blank" data-lightbox="task-grid">
<p><img src="http://approximateknowledge.net/images/generate_arc_task_images/ARCTask05269061Light_ManimCE_v0.19.0.png" alt="Complete ARC task encoding showing all input-output demonstration pairs and the test case in a structured grid layout"/></p>
<p><img src="http://approximateknowledge.net/ARCTask05269061Dark_ManimCE_v0.19.0.79b37f47.png" alt="Complete ARC task encoding showing all input-output demonstration pairs and the test case in a structured grid layout"/></p>
</a>

<div data-lightbox-target="task-grid">
<p><span>×</span></p>
<p><img src="http://approximateknowledge.net/images/generate_arc_task_images/ARCTask05269061Light_ManimCE_v0.19.0.png" alt="Complete ARC task encoding showing all input-output demonstration pairs and the test case in a structured grid layout"/></p>
<p><img src="http://approximateknowledge.net/ARCTask05269061Dark_ManimCE_v0.19.0.79b37f47.png" alt="Complete ARC task encoding showing all input-output demonstration pairs and the test case in a structured grid layout"/></p>
</div>


<p>While I display it in grids in other visualizations, the model actually &#34;sees&#34; a 1D stream of tokens. This is the first part of that sequence, truncated right after the first input grid of the first example.</p>

<a href="http://approximateknowledge.net/etym/2025/08/04/74fb3d02085afe99" target="_blank" data-lightbox="1d-sequence">
<p><img src="http://approximateknowledge.net/ARCTokenSequence1DLight_thumb.21f61a80.png" alt="ARC task encoded as a 1D token sequence showing input grids, demonstration pairs, and test output in linear format"/></p>
<p><img src="http://approximateknowledge.net/ARCTokenSequence1DDark_thumb.fc1bea30.png" alt="ARC task encoded as a 1D token sequence showing input grids, demonstration pairs, and test output in linear format"/></p>
</a>

<div data-lightbox-target="1d-sequence">
<p><span>×</span></p>
<p><img src="http://approximateknowledge.net/images/generate_arc_task_images/ARCTokenSequence1DLight_cropped.png" alt="ARC task encoded as a 1D token sequence showing input grids, demonstration pairs, and test output in linear format"/></p>
<p><img src="http://approximateknowledge.net/ARCTokenSequence1DDark_cropped.0436d6f1.png" alt="ARC task encoded as a 1D token sequence showing input grids, demonstration pairs, and test output in linear format"/></p>
</div>

<h3 id="how-generation-works">How Generation Works</h3>

<p>As you can see in the comparison in the overview above, while the autoregressive model fills in tokens left-to-right, the diffusion model starts with tokens matching what the test input gives for the answer, then works its way into the harder tokens that require understanding the task to fill in correctly. The core idea is to start with a fully masked output grid and iteratively fill in the tokens the model is most confident about, regardless of their position.</p>

<p>In each step, the model:</p>
<p>1. Evaluates all masked positions</p>
<p>2. Ranks predictions by entropy (lower entropy = higher &#34;confidence&#34;)<sup><a href="#fn5" id="fnref5">5</a></sup></p>
<p>3. Unmasks the most certain predictions</p>
<p>4. Repeats with the partially solved grid</p>

<p>Here&#39;s an animation of the whole process: </p>


<p><em>Video 2: Confidence-based diffusion process on a simple task from the training set. Note that the numbers in the visualization of this particular task are too close and all round to 1.0, but the color range has been tightened to show the differences.</em></p>

<p>In the example above, you can see it first fill in the shape of the pattern and cells that match the test input. In other cases, it selects the background tokens first, and then gradually gains confidence around the more complicated patterns:</p>


<p><em>Video 3: Qwen3-8b finetune with a Diffusion LoRA solving <a href="http://approximateknowledge.net/etym/2025/08/04/3ddbcc8cbc09c927" target="_blank" data-lightbox="complex-task">a more complex task</a>.</em></p>

<div data-lightbox-target="complex-task">
<p><span>×</span></p>
<p><img src="http://approximateknowledge.net/images/generate_arc_task_images/ARCTask00d62c1bLight_ManimCE_v0.19.0.png" alt="Complex ARC task showing multiple pattern transformations"/></p>
<p><img src="http://approximateknowledge.net/ARCTask00d62c1bDark_ManimCE_v0.19.0.d167dde8.png" alt="Complex ARC task showing multiple pattern transformations"/></p>
</div>

<p>This behavior is entirely emergent from choosing low entropy predictions - the model learned this without explicit supervision.</p>

<p><strong>What worked well:</strong> Despite the accuracy-speed tradeoff, the diffusion approach successfully achieved non-sequential solving. For simple patterns, it can generate correct outputs in just 10 timesteps, and the emergent &#34;easy-first&#34; behavior shows the model learned meaningful confidence estimates without explicit supervision.</p>

<h3 id="why-better-pixel-accuracy-alone-doesnt-solve-puzzles">Why Better Pixel Accuracy Alone Doesn&#39;t Solve Puzzles</h3>

<p>While diffusion achieves 3% higher token accuracy overall, this doesn&#39;t translate to more correctly solved tasks. Here&#39;s <a href="http://approximateknowledge.net/etym/2025/08/04/ef62683a005fe12e" target="_blank" data-lightbox="eval-task">a revealing example task</a> - even with higher average accuracy, the model still misses the underlying symmetrical patterns:</p>

<div data-lightbox-target="eval-task">
<p><span>×</span></p>
<p><img src="http://approximateknowledge.net/images/generate_arc_task_images/ARCTask135a2760Light_ManimCE_v0.19.0.png" alt="Complete ARC evaluation task showing the pattern the model failed to generalize"/></p>
<p><img src="http://approximateknowledge.net/ARCTask135a2760Dark_ManimCE_v0.19.0.81dbe9da.png" alt="Complete ARC evaluation task showing the pattern the model failed to generalize"/></p>
</div>


<p><em>Video 4: An example of the model failing to solve a task from the evaluation set despite better average accuracy</em></p>

<p>Take this failure case - the model needs to recognize what the pattern <em>should</em> be, not just copy what it&#39;s seen. And as shown above, this isn&#39;t something solving the problem out of order really helps with.</p>

<p>Humans benefit from extensive pretraining on geometric patterns and symmetries that these models lack. The ARChitects&#39; augmented re-ranking approach<sup><a href="#fn6" id="fnref6">6</a></sup> makes up for this by including the symmetries and invariants as part of the ranking process. When you rotate or reflect a candidate solution, correct patterns like this maintain their symmetry while errors create obvious asymmetries. This technique improved their accuracy by ~25%.</p>

<p>The diffusion LoRA does not translate into additional completely solved tasks on its own. The hope is: diffusion speeds up generation → more time for generating candidates to rank → exploit augmentation to catch errors during ranking → better generalization. </p>

<h2 id="background">Background</h2>

<p>I detail below a bit more about the motivations of why this might be useful, how I got it working, and where it still falls short.</p>

<h3 id="the-architects-baseline">The ARChitects Baseline</h3>

<p>I started this project by replicating the work of last year&#39;s winner, the ARChitects team<sup><a href="#fn2" id="fnref2">2</a></sup>. There were four main steps to replicating their work: </p>
<p>1. Fine tuning an existing LLM (I chose Qwen3-8B <sup><a href="#fn4" id="fnref4">4</a></sup>) on arc tasks encoded as sequences of tokens</p>
<p>2. Writing a harness that does further training on the examples presented at test time<sup><a href="#fn7" id="fnref7">7</a></sup>, </p>
<p>3. Implementing a clever sampling method to generate a bunch of candidates from this model. They basically do a depth first search where you stop and backtrack if the total probability of the sequence you are generating decreases below some minimum threshold. </p>
<p>4. Finally, re-ranking the answers based on augmented probabilities<sup><a href="#fn6" id="fnref6">6</a></sup>, basically how confident the model was when looking at them flipped, rotated or palette swapped. </p>

<p>The Autoregressive baseline here refers to my replica of only the first part of their approach, which is to fine tune Qwen3-8b on a vocabulary of 24 new tokens for encoding ARC tasks. Step 4 is the only part that can be reused as-is, to get this diffusion model to a competitive state I would need to modify the test time training to instead be an unmasking task, and consider alternatives to their depth first sampling to generate a bunch of high quality candidates for the ranker. Steps 2 and 3 are where almost all of the time is spent in the method, so unlocking improvements to the speed of either one was a big goal. </p>

<h3 id="computational-bottlenecks-in-autoregressive-approaches">Computational Bottlenecks in Autoregressive Approaches</h3>

<p>In the naive autoregressive approach, the model spends the same amount of compute on every token - whether it&#39;s a tricky pattern boundary or a boring background pixel. That seems wasteful when most tokens are pretty easy to predict.</p>

<p>The model&#39;s uncertainty patterns show that uncertainty spikes occur primarily at pattern boundaries and complex transitions, while background regions show consistently high confidence. This guided my approach to allocate computation where it matters most.</p>

<h3 id="alternatives-considered">Alternatives Considered</h3>

<p><strong>Speculative decoding</strong> uses a smaller model to cheaply generate tokens that a larger model verifies in parallel. But on Kaggle&#39;s fixed L4 GPU allocation, dedicating compute to a draft model doesn&#39;t beat simple task parallelization - especially when all tasks must be solved in batch with no latency constraints.</p>

<p><strong>Reasoning tokens</strong> would let models spend more compute on hard parts, but they&#39;d blow up memory requirements and need a complete rewrite of the puzzle encoding. Worse, they can&#39;t be trained at test time, which is where leading solutions get most of their performance gains.</p>

<p>The diffusion approach aims to be faster at the same accuracy, freeing up time for more iterations or test-time training.</p>

<p>Within diffusion, I tried <strong>probabilistic unmasking</strong> - randomly selecting tokens to unmask based on their predicted probabilities rather than ranking by confidence. This follows the original discrete diffusion formulation and saves ~20% per step by skipping the sorting. But it completely failed: 0.3% token accuracy at 30 timesteps, 0% at 10-20. Apparently random sampling unmasks critical structural tokens (like grid separators) too early, breaking the model&#39;s ability to understand the task structure.</p>

<h3 id="diffusion-models-are-hard-to-train-from-scratch">Diffusion Models Are Hard To Train From Scratch</h3>

<p>My initial attempts involved training discrete diffusion models from scratch, an approach I quickly pivoted away from. Training a BERT-style encoder from noise-initialized weights showed poor convergence, with eval and train loss plateauing at a level nearly 10x what similarly-sized autoregressive models achieved. This indicated that my diffusion training process required larger models and longer training times to fit the same data - more compute than I was willing to spend on this experiment.</p>


<h2 id="technical-implementation">Technical Implementation</h2>

<p>This section gets more into the details of what was loosely described above - feel free to skip to the <a href="#results-on-arc-prize-2025-evaluation-set">Results</a> or <a href="#next-steps">Next Steps</a> sections below.</p>

<h3 id="the-approach">The Approach</h3>

<p>Previous ARC challenge winners fine-tuned pre-trained LLMs as useful starting points. I also observed that fine tuning decoder-only models went much more smoothly on ARC tasks, even when learning entirely new tokens. I had successfully replicated the autoregressive approach the previous winners applied by fine tuning Qwen3-8b.</p>

<p>This led me to a new strategy: instead of starting from scratch, could I <em>adapt</em> a pre-trained autoregressive model for this new, non-sequential task? I looked into methods to convert my ARC Qwen3-8b fine tune to an encoder-only structure, and found the DiffuGPT/DiffuLLaMA paper particularly helpful<sup><a href="#fn3" id="fnref3">3</a></sup>. Their work demonstrated that fine tuning on simple unmasking tasks worked, and that more complex techniques like attention annealing were likely unnecessary.</p>

<p>I adapted the autoregressive Qwen3-8B model using a rank 256 LoRA on 8x A100 GPUs. The key insight from the DiffuLLaMA adaptation paper: you can convert autoregressive models to diffusion by simply further training with a fully connected attention, with masked out inputs, rather than causal attention and predicting the next token. While their paper implemented a full fine-tune, I started with a LoRA. For compute efficiency, I first trained just the embedding layer and final LM head to add a new <code>&lt;|mask|&gt;</code> token (with the rest of the weights frozen), then I trained a LoRA over the weights to adapt them to the encoder-only structure. This lightweight approach proved effective and did not introduce obvious bottlenecks over a full fine-tune, while allowing me to test this approach much faster and more cheaply.</p>

<h3 id="hyperparameters">Hyperparameters</h3>

<p>A few different hyperparameter configurations were tried for an epoch and then stopped, and I continued with the most promising one for 50 epochs (~130 million tokens):</p>
<ul>
<li>3e-5 learning rate, 500 warmup steps then cosine decay to 3e-6</li>
<li>Max sequence length of 6144 tokens (discarding a couple of longer tasks for simplicity)</li>
<li>Standard diffusion loss with autoregressive position shifting</li>
<li>Mixed precision (BF16) training </li>
<li>An effective batch size of 64 (8 minibatches of 8)</li>
</ul>

<h3 id="training-process">Training Process</h3>

<p>Following the DiffuLLaMA approach, this is fundamentally what&#39;s called <strong>discrete diffusion with absorbing states</strong><sup><a href="#fn8" id="fnref8">8</a></sup> - tokens are probabilistically &#34;absorbed&#34; into mask tokens during the forward process, then the model learns to &#34;denoise&#34; them back to their original values. Crucially interpreting each token as still predicting the next one in the sequence (step 4 below) preserves the autoregressive training structure.</p>

<p>The training process implements the following discrete diffusion steps:</p>

<p>1. <strong>Sample masking timestep</strong> t uniformly from [1e-3, 1] for each sequence. This acts as the &#34;noise level&#34; in discrete diffusion - higher t means more tokens get masked.</p>

<p>2. <strong>Apply absorbing transition</strong> to output tokens only. Each output token has probability t of being &#34;absorbed&#34; into the special <code>&lt;|mask|&gt;</code> token, while input grids remain completely unmasked. This preserves the task context that the model needs.</p>

<p>3. <strong>Forward pass</strong> through the model with the partially masked sequence. The model sees the full context but must predict the original tokens at masked positions.</p>

<p>4. <strong>Apply autoregressive shifting</strong> for next-token prediction. We have to maintain the meaning of each token prediction where position i predicts token i+1.</p>

<p>5. <strong>Compute cross-entropy loss</strong> only on positions that were masked in the input (after applying the autoregressive shift). This means the model learns to predict the original token from the masked context.</p>

<p>6. <strong>Scale loss by inverse timestep</strong> (1/t) following the discrete diffusion formulation. This gives more weight to examples with fewer masked tokens, as they should be easier to reconstruct. The scaled loss is then averaged over all masked positions.</p>

<details>
<summary>Click to expand example Python implementation</summary>

<pre><code>
<span>from</span> typing <span>import</span> <span>Dict</span>, <span>Any</span>
<span>import</span> torch
<span>from</span> torch <span>import</span> nn, Tensor

<span>def</span> <span>apply_random_masking</span>(<span>
    tokens: Tensor, 
    mask_probability: Tensor, 
    mask_token_id: <span>int</span>, 
    maskable_positions: Tensor
</span>) -&gt; Tensor:
    <span>&#34;&#34;&#34;Apply random masking to tokens based on probability.&#34;&#34;&#34;</span>
    move_chance = mask_probability[:, <span>None</span>]  
    move_indices = (torch.rand(*tokens.shape, device=tokens.device) &lt; move_chance) &amp; maskable_positions
    masked_tokens = torch.where(move_indices, mask_token_id, tokens)
    <span>return</span> masked_tokens

<span>def</span> <span>train_diffusion_step</span>(<span>
    model: nn.Module,
    batch: <span>Dict</span>[<span>str</span>, Tensor],
    mask_token_id: <span>int</span>,
    gradient_accumulation_steps: <span>int</span> = <span>1</span>,
    cross_entropy_loss: nn.Module = nn.CrossEntropyLoss(<span>reduction=<span>&#39;none&#39;</span></span>)
</span>) -&gt; <span>float</span>:
    <span>&#34;&#34;&#34;Execute one training step for diffusion model.
    
    Args:
        model: The transformer model to train
        batch: Dictionary containing &#39;input_ids&#39;, &#39;attention_mask&#39;, &#39;output_mask&#39;
        mask_token_id: Token ID used for masking
        gradient_accumulation_steps: Number of steps to accumulate gradients
        cross_entropy_loss: Loss function (must have reduction=&#39;none&#39;)
    
    Returns:
        Loss tensor for gradient computation
        
    Note:
        - Assumes batch_size is accessible from batch[&#39;input_ids&#39;].shape[0]
        - Requires model to output logits tensor of shape [batch, seq_len, vocab_size]
        - Backward pass should be called by the training loop on the returned loss
    &#34;&#34;&#34;</span>
    batch_size = batch[<span>&#39;input_ids&#39;</span>].shape[<span>0</span>]
    
    
    sampling_eps = <span>1e-3</span>
    t = (<span>1</span> - sampling_eps) * torch.rand(batch_size, device=batch[<span>&#39;input_ids&#39;</span>].device) + sampling_eps
    dsigma = <span>1</span> / t  

    
    
    x_t = apply_random_masking(
        tokens=batch[<span>&#39;input_ids&#39;</span>],  
        mask_probability=t,
        mask_token_id=mask_token_id,
        maskable_positions=batch[<span>&#39;output_mask&#39;</span>]  
    )

    
    loss_mask = (x_t == mask_token_id)

    
    
    logits = model(x_t, attention_mask=batch[<span>&#39;attention_mask&#39;</span>]).logits  

    
    
    
    <span>if</span> logits.shape[<span>1</span>] &lt;= <span>1</span>:
        <span>return</span> <span>0.0</span>  
        
    shift_logits = logits[..., :-<span>1</span>, :].contiguous()  
    shift_labels = batch[<span>&#39;input_ids&#39;</span>][..., <span>1</span>:].contiguous()  
    shift_loss_mask = loss_mask[..., <span>1</span>:].contiguous()  

    
    loss = cross_entropy_loss(
        shift_logits.view(-<span>1</span>, shift_logits.size(-<span>1</span>)),
        shift_labels.view(-<span>1</span>)
    ).view(shift_labels.shape)

    
    loss = loss.masked_fill(~shift_loss_mask, <span>0</span>)

    
    
    num_masked = shift_loss_mask.<span>sum</span>()
    <span>if</span> num_masked &gt; <span>0</span>:
        loss = (dsigma[:, <span>None</span>] * loss).<span>sum</span>() / num_masked
    <span>else</span>:
        
        loss = torch.tensor(<span>1e-8</span>, device=loss.device, requires_grad=<span>True</span>)

    <span>return</span> loss</code></pre>

</details>

<h3 id="batch-structure">Batch Structure</h3>

<p>The <code>collate_arc_batch</code> function creates batches with the following structure:</p>

<pre><code>batch = {
    <span>&#34;input_ids&#34;</span>: torch.tensor,        
                                      
    <span>&#34;attention_mask&#34;</span>: torch.tensor,   
                                      
    <span>&#34;labels&#34;</span>: torch.tensor,           
                                      
    <span>&#34;output_mask&#34;</span>: torch.tensor,      
                                      
    <span>&#34;task_id&#34;</span>: <span>List</span>[<span>str</span>]              
}</code></pre>

<p>The crucial element is that <code>output_mask</code> identifies which positions can be masked during training - only the test output tokens, never the input grids or demonstration examples. This ensures the model can always see the task context during training.</p>

<h3 id="training-data-and-augmentation">Training Data and Augmentation</h3>

<p>The model is trained on three complementary datasets and randomly generated augmentations of them:</p>
<ul>
<li><strong>ARC Prize 2024 &amp; 2025</strong>: Official training challenges and solutions</li>
<li><strong>RE-ARC</strong>: Reverse-engineered additional training examples</li>
<li><strong>Augmented Data</strong>: Systematically generated variations (some combination of rotations, reflections, and color permutations) generated on the fly</li>
</ul>

<p>Each training example is converted to the serialized token format that includes input grids, special tokens, and 930 token output grids with appropriate padding. For the autoregressive training run, the rare few tasks that encoded over the 6144 max token length were truncated on the left or dropped entirely. </p>

<h3 id="handling-fixed-sequence-lengths">Handling Fixed Sequence Lengths</h3>

<p>Initial testing revealed a challenge with fixed sequence lengths: the model needed to predict all 930 tokens including padding, despite most problems being much smaller<sup><a href="#fn9" id="fnref9">9</a></sup>. In early testing after a couple epochs, the model would waste many steps unmasking tokens past where the end of sequence token would end up. Sometimes these predictions seemed to confuse the model even more about what shape the solution should be, and it never predicted an end-of-sequence token. (This could have been because there aren&#39;t any training examples with non-padding tokens after the end of sequence token). But, after 50 epochs, the model dramatically increased its confidence in end-of-sequence token predictions, to the point where it was reliably unmasked early in the process. This allowed me to truncate the mask tokens after the end of sequence was predicted and not have to devise anything more clever and brittle.</p>

<h2 id="results-on-arc-prize-2025-evaluation-set">Results on ARC Prize 2025 Evaluation Set</h2>

<p>I evaluated both approaches on all 120 tasks from the ARC Prize 2025 public evaluation set<sup><a href="#fn12" id="fnref12">12</a></sup>. Rather than measuring full task success (which hovers around 1% for base models), I focused on token accuracy - how many individual pixels the model gets right.</p>

<p>This might seem like an odd choice, but here&#39;s my thinking: the ARChitects showed you need to combine the base model with test-time training, candidate generation, and clever re-ranking to get fully correct solutions. Since adapting some of those components for diffusion could take a fair amount of detail work, token accuracy gives me an early signal about whether this direction is worth pursuing. If diffusion can generate partial solutions more accurately or faster, that improvement should flow through to the final system. And if it can&#39;t? Well, better to find out now.</p>

<p>Note: These are k=1 results (single greedy output), while ARC allows k=2. Full pipelines generate many candidates for re-ranking.</p>

<h3 id="overall-performance-comparison">Overall Performance Comparison</h3>



<h3 id="performance-by-output-size">Performance by Output Size</h3>



<p>The 0% mean task accuracy on small tasks (&lt;100 tokens) is a surprising finding<sup><a href="#fn11" id="fnref11">11</a></sup>. Both models struggle with these compact outputs, though the failure mode is primarily shape inference - models predict incorrect dimensions for 8 out of 9 small tasks. This suggests the models may rely on output size patterns learned from the training data, which skews toward larger grids.</p>

<p><em>Note: Token Accuracy = (total correct tokens across all tasks) / (total tokens across all tasks), while Mean Task Accuracy = average of individual task token accuracies. The metrics are close but token accuracy properly weights by task size.</em></p>

<h3 id="task-success-rates">Task Success Rates</h3>



<p><em>Note: These percentages include all 120 evaluation tasks. Tasks where the model predicted incorrect output dimensions (33 for autoregressive) are counted as 0% accuracy.</em></p>

<h3 id="results-analysis">Results Analysis</h3>

<p>Diffusion achieves 85.7% token accuracy vs 82.6% for autoregressive at 10 timesteps while being 1.68x faster. But it produces zero perfect solutions, while autoregressive manages one. The ~3% improvement is spread across many partial solutions rather than concentrated into fully correct ones.</p>

<p>For ARC, where a single wrong pixel means failure, this is a problem. Without the full pipeline (test-time training, candidate generation, re-ranking), we can&#39;t know if these slightly-better partial solutions would translate to more perfect solutions.</p>

<p>The speed advantage at 10 timesteps disappears at 30 timesteps (0.56x slower) due to a fundamental architectural mismatch: the diffusion model can&#39;t use KV caching. Every timestep, it must recompute attention over the entire 6144-token sequence, including the unchanging input context. The autoregressive model, by contrast, caches all previous computations and only computes attention for each new token. Since ARC sequences include ~3 demonstration pairs plus the test input (making them ~8x larger than just the output<sup><a href="#fn10" id="fnref10">10</a></sup>), this architectural difference becomes the bottleneck.</p>

<h2 id="next-steps">Next Steps</h2>

<p>Three main issues are holding back this approach:</p>

<p>1. <strong>Cache-Resistant Encoder-only Architecture:</strong> My diffusion model treats the entire sequence as one fully connected encoder. This means the input examples get recomputed every step even though they never change during generation. Meanwhile, the autoregressive model&#39;s KV cache lets it reuse all past computations. Since sequence lengths in this encoding scheme are many thousands of tokens this adds up.</p>

<p>   <strong>Potential Fix:</strong> Cache the key-value pairs for the static input portion of the sequence. While inputs can technically attend to newly unmasked output tokens in the current implementation, this doesn&#39;t seem particularly useful. A cleaner approach would be retraining with attention masking that prevents inputs from attending to outputs, and then implementing proper input caching. Avoiding recomputing the input latents like this should cut the per-step computation from O(n²) on the full sequence to O(n m) where n is the input size and m is just the output size.</p>

<p>2. <strong>The adaptation is Under Trained:</strong> My diffusion model achieved 0.628 train loss vs 0.0033 for the autoregressive baseline, and was still converging. With more pretraining this might close, but the architectural issues remain.</p>

<p>   <strong>Potential Fix:</strong> Continue training the LoRA until convergence. Only then can we properly assess whether the remaining gap is purely architectural or if there&#39;s still room for improvement through training.</p>

<p>3. <strong>Depth-First Search Dominates Sampling Time:</strong> The real bottleneck isn&#39;t generating a single greedy solution - it&#39;s the depth-first search to find all solutions above a minimum probability threshold (as described in the ARChitects paper<sup><a href="#fn2" id="fnref2">2</a></sup>). This search gets exponentially slower as you lower the probability threshold. Just confidence-based unmasking alone doesn&#39;t offer an alternative to this exhaustive search.</p>

<p>   <strong>Potential Fix:</strong> Develop an iterative remasking strategy where we regenerate regions around low-confidence tokens. This could potentially find diverse high-quality candidates faster than depth-first search, but the exact algorithm needs both theoretical development and empirical tuning. </p>

<h2 id="conclusion">Conclusion</h2>

<p>The KV cache really is hard to beat! While I successfully adapted an LLM for diffusion and got some neat non-sequential generation behavior, the practical performance just isn&#39;t there yet, and I am out of time for this particular experiment. Still, it was a valuable journey through model adaptation and discrete diffusion, and I got another lesson into why architectural advantages matter more than clever sampling tricks. Sometimes you need to build the alternative to truly appreciate why the standard approach became standard.</p>














<h2 id="acknowledgments">Acknowledgments</h2>

<p>Special thanks to <a href="https://lambdalabs.com/">Lambda Labs</a> for providing $1000 in compute credits for this project. Their generous support enabled both the Qwen3-8B autoregressive fine-tuning and all the diffusion experiments described in this article.</p>

<p>The visualizations in this article were created using the excellent <a href="https://www.manim.community/">Manim Community</a> library, an open-source animation engine for mathematical and programmatic animations originally created by Grant Sanderson (3Blue1Brown). Thanks to Grant for creating this powerful tool and to the Manim community for maintaining and improving it!</p>

<p>Thanks also to <a href="https://claude.ai/code">Claude Code</a> for proofreading this article and for enabling me to vibecode the first draft of the Manim visualizations based on actual data, super quickly.</p>




                <hr/>
                
                <p>
                    <em>
                        Are you interested in the ARC Prize and have comments, corrections or questions?
                        <a href="http://approximateknowledge.net/cdn-cgi/l/email-protection#5835392c2c303d2f343d2f312b363d2f2c3736183f35393134763b3735">I&#39;d love to hear from you.</a> 
                         
                    </em>
                </p>
            </article>
        </div></div>
  </body>
</html>
