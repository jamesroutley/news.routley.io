<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://comsci.blog/posts/intuitive-harris">Original</a>
    <h1>Intuitively Understanding Harris Corner Detector</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>If you ever tried to learn how the Harris corner detection algorithm works, you might have
noticed that the process is not intuitive at all. First, you start with an energy function, approximate it
using Taylor approximation, get a matrix from that, then find the eigenvalues of that matrix, etc.
But when you come to the final implementation, it is rather simple and seems easier.
If you are like me, this is not intuitive at all. But today I will present you a much easier way to understand
how the Harris corner detection algorithm works.</p>

<p>Let’s start with understanding what is a corner. We can simply think of it as a connection of edges. For two edges
to be able to connect, they sure need to be not parallel, so looking at a corner, we should see that
edges moving in different directions (they would be parallel if they moved in the same directions):</p>

<p><img src="https://comsci.blog/assets/intuitive-harris-0.png" alt="" width="400"/></p>

<p><em>Figure source: <a href="https://www.cse.psu.edu/~rtc12/CSE486/lecture06.pdf" target="_blank">https://www.cse.psu.edu/~rtc12/CSE486/lecture06.pdf</a></em></p>

<p>So it is obvious that the gradients of the image I<sub>x</sub> and I<sub>y</sub> will both be active in the corner
region. We know that adding I<sub>x</sub><sup>2</sup> and I<sub>y</sub><sup>2</sup> shows the regions with change
in x <strong><em>or</em></strong> y directions (which is the basis of the all edge detection algorithms). So one thing that comes to mind is multiplying the I<sub>x</sub><sup>2</sup>
and I<sub>y</sub><sup>2</sup> so that we will only see regions on the image that have a change in both x <strong><em>and</em></strong> y
directions at the same time, just like corners!</p>

<p>Let’s start implementing this. First, let’s find a pretty basic image that will have lots of corners inside it.</p>

<div><div><pre><code><span>import</span> <span>cv2</span>
<span>import</span> <span>matplotlib.pyplot</span> <span>as</span> <span>plt</span>

<span># wget https://logowik.com/content/uploads/images/bbc-america9038.jpg -O assets/bbc.jpg
</span>
<span>img</span> <span>=</span> <span>cv2</span><span>.</span><span>imread</span><span>(</span><span>&#34;assets/bbc.jpg&#34;</span><span>,</span> <span>cv2</span><span>.</span><span>IMREAD_GRAYSCALE</span><span>)</span>
<span>plt</span><span>.</span><span>imshow</span><span>(</span><span>img</span><span>,</span> <span>cmap</span><span>=</span><span>&#34;gray&#34;</span><span>)</span>
</code></pre></div></div>

<p><img src="https://comsci.blog/assets/intuitive-harris_1_1.png" alt="png"/></p>

<p>Now we can start finding the gradient of this image using the Sobel operator:</p>

<div><div><pre><code><span>Ix</span> <span>=</span> <span>cv2</span><span>.</span><span>Sobel</span><span>(</span><span>img</span><span>,</span> <span>ddepth</span><span>=</span><span>cv2</span><span>.</span><span>CV_32F</span><span>,</span> <span>dx</span><span>=</span><span>1</span><span>,</span> <span>dy</span><span>=</span><span>0</span><span>)</span>
<span>Iy</span> <span>=</span> <span>cv2</span><span>.</span><span>Sobel</span><span>(</span><span>img</span><span>,</span> <span>ddepth</span><span>=</span><span>cv2</span><span>.</span><span>CV_32F</span><span>,</span> <span>dx</span><span>=</span><span>0</span><span>,</span> <span>dy</span><span>=</span><span>1</span><span>)</span>
</code></pre></div></div>

<p>Okay, we are there now. Let’s plot the I<sub>x</sub><sup>2</sup>I<sub>y</sub><sup>2</sup>, we are expecting it to give us regions with both x and y directions:</p>

<div><div><pre><code><span>plt</span><span>.</span><span>imshow</span><span>(</span><span>Ix</span><span>**</span><span>2</span> <span>*</span> <span>Iy</span><span>**</span><span>2</span><span>,</span> <span>cmap</span><span>=</span><span>&#39;gray&#39;</span><span>)</span>
</code></pre></div></div>

<p><img src="https://comsci.blog/assets/intuitive-harris_5_1.png" alt="png"/></p>

<p>As you can see, we are kind of not successful, because this shows us the both corners and edges that move along in
both x and y directions. But we need to get rid of the edges.</p>

<p>If you carefully look at this resulting image, you will notice that corners are either isolated like the top left
corner of the B logo, or they are at the end of these edges. Maybe we can’t get rid of the edges directly,
but if somehow we can remove the corners from I<sub>x</sub><sup>2</sup>I<sub>y</sub><sup>2</sup>, we can subtract it from the original I<sub>x</sub><sup>2</sup>I<sub>y</sub><sup>2</sup> and
get only the corners. Actually, we can get rid of the corners. Since the corners are isolated in this image,
applying a Gaussian blur will decrease the intensities of the corners a lot!</p>

<p>Let’s see this:</p>

<div><div><pre><code><span>corners_suppressed</span> <span>=</span> <span>cv2</span><span>.</span><span>GaussianBlur</span><span>(</span><span>Ix</span><span>**</span><span>2</span> <span>*</span> <span>Iy</span><span>**</span><span>2</span><span>,</span> <span>ksize</span><span>=</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>),</span> <span>sigmaX</span><span>=</span><span>1</span><span>)</span>
<span>plt</span><span>.</span><span>imshow</span><span>(</span><span>corners_suppressed</span><span>,</span> <span>cmap</span><span>=</span><span>&#39;gray&#39;</span><span>)</span>
</code></pre></div></div>

<p><img src="https://comsci.blog/assets/intuitive-harris_7_1.png" alt="png"/></p>

<p>We can even do a better job of removing the corners by applying the blur before squaring. Because square will increase
the intensity of isolated corners, making it less affected by the blur. So we can instead do:</p>

<div><div><pre><code><span>corners_suppressed</span> <span>=</span> <span>cv2</span><span>.</span><span>GaussianBlur</span><span>(</span><span>Ix</span><span>*</span> <span>Iy</span><span>,</span> <span>ksize</span><span>=</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>),</span> <span>sigmaX</span><span>=</span><span>1</span><span>)</span> <span>**</span> <span>2</span>
<span>plt</span><span>.</span><span>imshow</span><span>(</span><span>corners_suppressed</span><span>,</span> <span>cmap</span><span>=</span><span>&#39;gray&#39;</span><span>)</span>
</code></pre></div></div>

<p><img src="https://comsci.blog/assets/intuitive-harris_9_1.png" alt="png"/></p>

<p>Now that we have the corners mostly suppressed image, we can try subtracting this from the I<sub>x</sub><sup>2</sup>I<sub>y</sub><sup>2</sup> and get only the corners. Let’s try it:</p>

<div><div><pre><code><span>plt</span><span>.</span><span>imshow</span><span>(</span><span>Ix</span><span>**</span><span>2</span> <span>*</span> <span>Iy</span><span>**</span><span>2</span> <span>-</span> <span>corners_suppressed</span><span>,</span> <span>cmap</span><span>=</span><span>&#39;gray&#39;</span><span>)</span>
</code></pre></div></div>

<p><img src="https://comsci.blog/assets/intuitive-harris_11_1.png" alt="png"/></p>

<p>That doesn’t seem to work, but the reason is clear. Edges of the I<sub>x</sub><sup>2</sup>I<sub>y</sub><sup>2</sup>
have different intensity than <code>corners_suppressed</code>, since <code>corners_suppressed</code> has been blurred.
We want them to have the same intensity in edges so that they cancel the edges when they are subtracted.</p>

<p>We can make the edges of I<sub>x</sub><sup>2</sup>I<sub>y</sub><sup>2</sup> similar intensity to edges of <code>corners_suppressed</code>
by applying Gaussian blur to I<sub>x</sub><sup>2</sup> and I<sub>y</sub><sup>2</sup> seperately before multiplying them.
We will apply the blur to squared gradients to make sure the corners are less affected by the blur.</p>

<div><div><pre><code><span>Ix_squared</span> <span>=</span> <span>cv2</span><span>.</span><span>GaussianBlur</span><span>(</span><span>Ix</span><span>**</span><span>2</span><span>,</span> <span>ksize</span><span>=</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>),</span> <span>sigmaX</span><span>=</span><span>1</span><span>)</span>
<span>Iy_squared</span> <span>=</span> <span>cv2</span><span>.</span><span>GaussianBlur</span><span>(</span><span>Iy</span><span>**</span><span>2</span><span>,</span> <span>ksize</span><span>=</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>),</span> <span>sigmaX</span><span>=</span><span>1</span><span>)</span>

<span>corners</span> <span>=</span> <span>Ix_squared</span> <span>*</span> <span>Iy_squared</span> <span>-</span> <span>corners_suppressed</span>
<span>plt</span><span>.</span><span>imshow</span><span>(</span><span>corners</span><span>,</span> <span>cmap</span><span>=</span><span>&#39;gray&#39;</span><span>)</span>
</code></pre></div></div>
<p><img src="https://comsci.blog/assets/intuitive-harris_13_1.png" alt="png"/></p>

<p>Yes! We successfully get the corners of the image. Now if we look at the data inside the <code>corners</code> matrix, you will notice that
corners have extremely large values and other parts have smaller values. Let’s threshold it:</p>

<div><div><pre><code><span>corners</span><span>[</span><span>corners</span> <span>&lt;</span> <span>corners</span><span>.</span><span>max</span><span>()</span> <span>/</span> <span>5</span><span>]</span> <span>=</span> <span>0</span>
<span>corners</span><span>[</span><span>corners</span> <span>!=</span> <span>0</span><span>]</span> <span>=</span> <span>255</span>

<span>plt</span><span>.</span><span>imshow</span><span>(</span><span>corners</span><span>,</span> <span>cmap</span><span>=</span><span>&#34;gray&#34;</span><span>)</span>
</code></pre></div></div>

<p><img src="https://comsci.blog/assets/intuitive-harris_15_1.png" alt="png"/></p>

<p>Okay, let’s plot these points as circles in our image:</p>

<div><div><pre><code><span>new_img</span> <span>=</span> <span>cv2</span><span>.</span><span>cvtColor</span><span>(</span><span>img</span><span>,</span> <span>cv2</span><span>.</span><span>COLOR_GRAY2RGB</span><span>)</span>

<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>img</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>]):</span>
    <span>for</span> <span>j</span> <span>in</span> <span>range</span><span>(</span><span>img</span><span>.</span><span>shape</span><span>[</span><span>1</span><span>]):</span>
        <span>if</span> <span>corners</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span> <span>==</span> <span>255</span><span>:</span>
            <span>cv2</span><span>.</span><span>circle</span><span>(</span><span>new_img</span><span>,</span> <span>(</span><span>j</span><span>,</span> <span>i</span><span>),</span> <span>radius</span><span>=</span><span>2</span><span>,</span> <span>color</span><span>=</span><span>(</span><span>255</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>),</span> <span>thickness</span><span>=-</span><span>1</span><span>)</span>

<span>plt</span><span>.</span><span>imshow</span><span>(</span><span>new_img</span><span>,</span> <span>cmap</span><span>=</span><span>&#34;gray&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>show</span><span>()</span>
</code></pre></div></div>

<p><img src="https://comsci.blog/assets/intuitive-harris_17_0.png" alt="png"/></p>

<p>And with this, we have implemented the Harris corner detection algorithm and we haven’t talked about things like
fitting ellipses, Taylor series approximation, or any of that stuff. This implementation is equivalent to the
other implementations of this algorithm.</p>

<p>Here is the full code:</p>
<div><div><pre><code><span>import</span> <span>cv2</span>
<span>import</span> <span>matplotlib.pyplot</span> <span>as</span> <span>plt</span>

<span># wget https://logowik.com/content/uploads/images/bbc-america9038.jpg -O assets/bbc.jpg
</span>
<span>img</span> <span>=</span> <span>cv2</span><span>.</span><span>imread</span><span>(</span><span>&#34;assets/bbc.jpg&#34;</span><span>,</span> <span>cv2</span><span>.</span><span>IMREAD_GRAYSCALE</span><span>)</span>

<span>Ix</span> <span>=</span> <span>cv2</span><span>.</span><span>Sobel</span><span>(</span><span>img</span><span>,</span> <span>ddepth</span><span>=</span><span>cv2</span><span>.</span><span>CV_32F</span><span>,</span> <span>dx</span><span>=</span><span>1</span><span>,</span> <span>dy</span><span>=</span><span>0</span><span>)</span>
<span>Iy</span> <span>=</span> <span>cv2</span><span>.</span><span>Sobel</span><span>(</span><span>img</span><span>,</span> <span>ddepth</span><span>=</span><span>cv2</span><span>.</span><span>CV_32F</span><span>,</span> <span>dx</span><span>=</span><span>0</span><span>,</span> <span>dy</span><span>=</span><span>1</span><span>)</span>

<span>corners_suppressed</span> <span>=</span> <span>cv2</span><span>.</span><span>GaussianBlur</span><span>(</span><span>Ix</span><span>*</span> <span>Iy</span><span>,</span> <span>ksize</span><span>=</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>),</span> <span>sigmaX</span><span>=</span><span>1</span><span>)</span> <span>**</span> <span>2</span>
<span>Ix_squared</span> <span>=</span> <span>cv2</span><span>.</span><span>GaussianBlur</span><span>(</span><span>Ix</span><span>**</span><span>2</span><span>,</span> <span>ksize</span><span>=</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>),</span> <span>sigmaX</span><span>=</span><span>1</span><span>)</span>
<span>Iy_squared</span> <span>=</span> <span>cv2</span><span>.</span><span>GaussianBlur</span><span>(</span><span>Iy</span><span>**</span><span>2</span><span>,</span> <span>ksize</span><span>=</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>),</span> <span>sigmaX</span><span>=</span><span>1</span><span>)</span>

<span>corners</span> <span>=</span> <span>Ix_squared</span> <span>*</span> <span>Iy_squared</span> <span>-</span> <span>corners_suppressed</span>
<span>corners</span><span>[</span><span>corners</span> <span>&lt;</span> <span>corners</span><span>.</span><span>max</span><span>()</span> <span>/</span> <span>5</span><span>]</span> <span>=</span> <span>0</span>
<span>corners</span><span>[</span><span>corners</span> <span>!=</span> <span>0</span><span>]</span> <span>=</span> <span>255</span>

<span>new_img</span> <span>=</span> <span>cv2</span><span>.</span><span>cvtColor</span><span>(</span><span>img</span><span>,</span> <span>cv2</span><span>.</span><span>COLOR_GRAY2RGB</span><span>)</span>

<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>img</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>]):</span>
    <span>for</span> <span>j</span> <span>in</span> <span>range</span><span>(</span><span>img</span><span>.</span><span>shape</span><span>[</span><span>1</span><span>]):</span>
        <span>if</span> <span>corners</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span> <span>==</span> <span>255</span><span>:</span>
            <span>cv2</span><span>.</span><span>circle</span><span>(</span><span>new_img</span><span>,</span> <span>(</span><span>j</span><span>,</span> <span>i</span><span>),</span> <span>radius</span><span>=</span><span>2</span><span>,</span> <span>color</span><span>=</span><span>(</span><span>255</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>),</span> <span>thickness</span><span>=-</span><span>1</span><span>)</span>

<span>plt</span><span>.</span><span>imshow</span><span>(</span><span>new_img</span><span>,</span> <span>cmap</span><span>=</span><span>&#34;gray&#34;</span><span>)</span>
<span>plt</span><span>.</span><span>show</span><span>()</span>
</code></pre></div></div>
<p>Hopefully, you now understand how this algorithm works and enjoy the process.</p>

  </div>
</article>



      </div>
    </div></div>
  </body>
</html>
