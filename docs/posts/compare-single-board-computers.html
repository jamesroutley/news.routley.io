<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sbc.compare/">Original</a>
    <h1>Compare Single Board Computers</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>
It is time for Sudoku, once more (we are more than half-way through)! In case you are new here, this is a series about building six different Sudoku solvers in six different programming languages. <a href="https://blog.veitheller.de/Six_Simple_Sudoku_Solvers_I:_Python_(Reference).html">Check the first part</a> for more information on the algorithm as well as a reference implementation.
  </p>
<p>
Today we’re going to look at Haskell, including types, monads, the whole thing. We’re going to look at monadic state, internal mutation, and laziness as a backtracking mechanism.
  </p>
<p>
As with Common Lisp and Prolog, it won’t necessarily be a good primer for the language, and I suggest following all the rabbit holes you can find if you want to dig deeper; it’s a rewarding if a little exhausting exercise.
  </p>

<p>
Haskell is mostly known for being a language with an advanced type system and for the scary word “monads”. In my opinion, that’s a pity. Haskell is a deeply elegant weapon, designed for sharp problems of all shapes and sizes, and while it doesn’t necessarily produce aesthetically pleasing solutions, it makes damn sure it doesn’t get in your way if you want to follow your stylistic intuitions.
  </p>
<p>
Apart from that, however, it also has more substantive qualities that lend themselves well to algorithms like Sudoku solvers:
  </p>
<div>
  <ul><li><b>Laziness</b>. Haskell expressions only get evaluated when they’re actually used. This is cool, powerful, and sometimes a nightmare to debug. In this case, we will use it to short-circuit our backtracking once we’ve found a solution, and I just think that’s awesome.</li>
<li><b>Algebraic combinators</b>. Haskell is combinator-heavy. This one is somewhat hard to explain, but it’s abundance of algebraic combinators makes it easy to express things like searches and constraints, and we’ll make lots of use of it.</li>
<li><b>Applicatives, Monads, Category Theory</b>. We’ll use both Applicatives and Monads today—for control flow and state, respectively—, and that’s only the tip of the iceberg! These concepts are scary and the names don’t help, but they are definitely worth a look, and I’ll try my best to demystify the small bits we’ll be using today.</li></ul>
</div>
<p>
I hope those things are enough to make a compelling case for why Haskell is worth a look. And, once again, our solver will be less than 100 lines of code (we could golf it down more, but that would defeat the purpose).
  </p>
<p>
I do want to warn you that there would be a much simpler way to solve this in Haskell, but I simply could not resist the urge to show how internal mutation is still a possibility in a language that has the reputation of being the most pure used in industry.
  </p>

<p>
As always, we’ll start with the main solver. As with most of our solutions except for Prolog, we’ll then look at propagation, candidates, and MRV search.
  </p>
<p>
Before we do so, however, we’ll define a type alias to feel comfortable when looking at types.
  </p>

<p>
This is, of course, not strictly necessary, but it makes things a bit more intuitive to look at.
  </p>

<p>
The main <code>solve</code> function is deceptively short, but quite involved.
  </p>
<div>
  <div>
      <pre><code>solve :: Board -&gt; Maybe Board
solve b0 = do
  b &lt;- propagate b0
  if solved b
  then pure b
  else
    let ((i,j), cs) = findMRV b
    in foldr (&lt;|&gt;) empty [ solve (set b i j v) | v &lt;- cs ]</code></pre>
    </div>
  
</div>
<p>
The type declaration of the function here is above the function definition. It tells us that we give the function a <code>Board</code>, and we get a <code>Maybe Board</code>—equivalent to <code>Option(Board)</code> in other languages—back. <code>Maybe</code> is a type with multiple constructors—in Haskell, we refer to these as sum types—, with the constructors <code>Just value</code> or <code>Nothing</code>. The former transports a value, the latter shows the absence of a value. It’s an explicit way of demarking return value optionality.
  </p>
<p>
First we’ll call our usual propagation (by now you should have an idea what that means), and check if we’ve solved the puzzle. If yes, we’ll return the solution. If no, we’ll get all the candidates and use <code>foldr</code>—algebra-speak for <code>reduce</code> or <code>inject:into:</code>—to iterate over them.
  </p>
<p>
Now, this is our first bit of magic. How do we iterate over them? How do we short-circuit? What is this whole fold line?
  </p>
<p>
I already teased laziness in the beginning, and this is where it gets crucial. For every candidate, we insert it (<code>set b i j v</code>) and plug it into <code>solve</code>. This is a list comprehension akin to what you might find, for instance, in Python. We then take the resulting list and plug it into <code>foldr</code>, using <code>&lt;|&gt;</code>  as a fold function, and <code>empty</code> (which is implemented by <code>Maybe</code> as <code>Nothing</code>) as a first accumulator.
  </p>
<p>
What does <code>&lt;|&gt;</code> do? It is the choice operator, and it comes from the <code>Alternative</code> type class, which is “a monoid on applicative functors”—in our case, simply a thing we can combine with other instances of that thing. You can think of it like this:
  </p>
<div>
  <div>
      <pre><code>empty      = Nothing
Nothing &lt;|&gt; r = r
Just x  &lt;|&gt; _ = Just x</code></pre>
    </div>
  
</div>
<p>
So, we’re just combining things and take the first <code>Just</code> value we find and stick with it. And because of laziness and the fact that the unused computations will never be performed, we end up with something akin to:
  </p>
<div>
  <div>
      <pre><code>recur []     = Nothing
recur (v:vs) =
  case solve (set b i j v) of
    Just s  -&gt; Just s
    Nothing -&gt; recur vs</code></pre>
    </div>
  
</div>
<p>
But a bit slicker and generic over all instances of the <code>Alternative</code> type class (think of it as an interface). You could also try swapping the fold for <code>asum</code> from <code>Data.Foldable</code> as an exercise, if you were so inclined.
  </p>

<p>
Next, we’ll try to run a fill-in pass.
  </p>
<div>
  <div>
      <pre><code>propagate :: Board -&gt; Maybe Board
propagate b0 = runST $ do
  a &lt;- thawBoard b0
  ok &lt;- fixpoint a
  if not ok then pure Nothing else Just &lt;$&gt; freezeBoard a</code></pre>
    </div>
  
</div>
<p>
Again with the magic. This time we do it for performance reasons, however. We get internal mutation inside a monad called <code>ST</code> (State Threads) that we let execute with runST, so the outside world stays pure. I will, for the purposes of this post, ignore <code>thawBoard</code> and <code>freezeBoard</code>. They simply transform our nice little board into a dirty, mutable array encapsulated in said monad and back, so we can do our unclean mutations. If you do want to check it out, you can do so <a href="https://github.com/hellerve/sudoku/blob/main/sudoku.hs">by looking at the repo version</a> or by going to the documentation of <a href="https://hackage.haskell.org/package/array-0.5.8.0/docs/Data-Array-Base.html#t:STUArray">`STUArray`</a> directly. Our actual work happens in <code>fixpoint</code>, which will, as is tradition, mutate the board in place and return a marker whether the board is solvable.
  </p>
<div>
  <div>
      <pre><code>fixpoint :: STUArray s (Int,Int) Int -&gt; ST s Bool
fixpoint a = go True
  where
    go ch = if ch then do
               (ch&#39;, ok) &lt;- sweep a
               if not ok then pure False else go ch&#39;
             else pure True

sweep :: STUArray s (Int,Int) Int -&gt; ST s (Bool, Bool)
sweep a = do
  changed &lt;- newSTRef False
  ok &lt;- newSTRef True
  forM_ [0..8] $ \i -&gt;
    forM_ [0..8] $ \j -&gt; do
      v &lt;- readArray a (i,j)
      when (v == 0) $ do
        cs &lt;- candidatesST a i j
        case cs of
          []   -&gt; writeSTRef ok False
          [x]  -&gt; writeArray a (i,j) x &gt;&gt; writeSTRef changed True
          _    -&gt; pure ()
  (,) &lt;$&gt; readSTRef changed &lt;*&gt; readSTRef ok</code></pre>
    </div>
  
</div>
<p>
Have you ever seen code so pretty? I kid, but let’s try it anyway.
  </p>
<p>
The function <code>fixpoint</code> is our helper that will run passes over the board until it doesn’t change anymore. <code>sweep</code> is the function that actually performs that pass. Taking away all the state-fu, we are left with a function that has a marker for whether the board has been mutated this pass (<code>changed</code>) and a marker for whether it’s still solvable (<code>ok</code>). We then go into the nested loop, reading the value from the array, and checking for candidates for those that are still <code>0</code>. If we don’t find any, the board is unsolvable and we set <code>ok</code> to false. If we find exactly one candidate, we set the value and mark the pass as having changed something. Otherwise we do nothing.
  </p>
<p>
So why is this so clumsy? This is what it looks like to try and write imperative code in a pure functional language. It is still safe and encapsulated, and the state remains local. But it’s a pain to deal with and to look at, as all state should be—I’m only partially joking.
  </p>

<p>
Next up, we’ll look at finding the individual candidates, which is done using <code>candidatesST</code> (the same <code>ST</code> as above, so you know it’ll be good).
  </p>
<div>
  <div>
      <pre><code>candidatesST :: STUArray s (Int,Int) Int -&gt; Int -&gt; Int -&gt; ST s [Int]
candidatesST a i j = do
  usedR &lt;- mapM (\c -&gt; readArray a (i,c)) [0..8]
  usedC &lt;- mapM (\r -&gt; readArray a (r,j)) [0..8]
  let r0 = (i `div` 3) * 3
  let c0 = (j `div` 3) * 3
  usedB &lt;- sequence [ readArray a (r,c)
                    | r &lt;- [r0..r0+2], c &lt;- [c0..c0+2] ]
  let used = filter (/=0) (usedR ++ usedC ++ usedB)
  pure (digits \\ used)</code></pre>
    </div>
  
</div>
<p>
Where is the eye bleach?! Let’s try and figure it out.
  </p>
<p>
<code>usedR</code> and <code>usedC</code> are the rows and columns, respectively. <code>usedB</code> is the block, and functions essentially the same way as in the other algorithms. We then add them together, filter out any <code>0</code>, and return the difference of <code>digits</code> (which is bound to <code>[1..9]</code>), so all the values we haven’t found.
  </p>
<p>
Once again, bending Haskell to our will has worked, but left us with code that looks less than elegant. Let’s press on to resolve that issue!
  </p>

<p>
Finally, the candidates for our depth first search await!
  </p>
<div>
  <div>
      <pre><code>row i b = b !! i
col j b = map (!! j) b
box i j b =
  [ b !! r !! c | r &lt;- [r0..r0+2], c &lt;- [c0..c0+2] ]
  where r0 = (i `div` 3) * 3; c0 = (j `div` 3) * 3

cands b i j =
  let v = b !! i !! j
  in if v /= 0
     then [v]
     else digits \\ filter (/=0) (row i b ++ col j b ++ box i j b)

findMRV :: Board -&gt; ((Int,Int), [Int])
findMRV b = minimumBy (comparing (length . snd))
  [ ((i,j), cands b i j) | i &lt;- [0..8], j &lt;- [0..8], b !! i !! j == 0 ]</code></pre>
    </div>
  
</div>
<p>
That’s more like it! Here, unencumbered by low-level array accesses, we can make Haskell’s combinators truly shine.
  </p>
<p>
The heuristics are the same as before: we compute the candidates (that’s the list expression at the bottom there together with the functions at the top), and then get the result with the shortest list of candidates (<code>minimumBy . length</code> with extra steps).
  </p>
<p>
It might seem awkward to basically redo all the candidate search we already did in the state monad, but here this was a deliberate choice to show you how mutable, efficient code looks like next to pure, slightly less efficient (though not by as much as you might think) code.
  </p>
<p>
But, as is tradition by now, we can now pat ourselves on the back: we’ve written a Sudoku solver!
  </p>

<p>
Once again, we’ve tried to use a language to its fullest by showing off all the things it can do and is good for in a humble Sudoku solver, in under 100 lines of code. I might be slightly biased, but I think that’s kind of neat!
  </p>
<p>
Now, we might have dipped our toes in the waters of mutability and efficiency with this one, but in the next one we’ll take it up a notch by taking Rust through its paces, lettin’ ’er rip! Stay tuned!
  </p>
      
    </div></div>
  </body>
</html>
