<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cockroachlabs.com/blog/demonic-nondeterminism/">Original</a>
    <h1>Antithesis of a One-in-a-Million Bug: Taming Demonic Nondeterminism</h1>
    
    <div id="readability-page-1" class="page"><div>
          
          <div>

            
            <p><img src="https://www.cockroachlabs.com/img/screenshot-2024-03-20-at-4.15.05%e2%80%afpm.png"/></p><h3>
              DoorDash&#39;s Journey from Aurora PostgreSQL to CockroachDB
            </h3>
            
            
  
             
              <p><a href="https://www.cockroachlabs.com/roachfest/2023/doordashs-journey-from-aurora-postgres-to-cockroachdb/">Watch now</a> 
            
          </p></div>
            

        <p><em>Editor’s note: The one-in-a-million bug detailed below has never been reported by customers of Cockroach Labs. It was autofiled by Sentry’s crash reporting module, which led us on a long journey to uncover its root cause(s). The story below details our investigation into and ultimate resolution of said bug.</em></p>
<h2 id="background-nondeterminism">Background: Nondeterminism</h2>
<p><a href="https://en.wiktionary.org/wiki/nondeterminism" target="_blank" rel="noopener">Nondeterminism</a>–the property of being in any of the possible next states, is a double-edged sword. In Computer Science (CS), the notion of nondeterminism is instrumental to managing complexity of reasoning about the state space. The earliest uses of nondeterminism appear in [Chomsky, 1959] and [Rabin and Scott, 1959]. The former gave us succinct context-free grammars (CFG), e.g., arithmetic expressions,</p>
<p><code>S ::= x | y | z | S + S | S * S | (S)</code></p>
<p>The latter gave us non-deterministic finite automata (NFAs), aka regular expressions. Both CFGs and NFAs are fundamental concepts, known virtually to any CS grad.</p>
<p>And of course, who can forget the elusive problem of P = NP [Cook, 1971 and Levin, 1973], and the eternal search for taming NP-completeness? As an example, testing <em>serializability</em> of a given history of committed transactions is NP-complete (see <a href="https://anishathalye.com/testing-distributed-systems-for-linearizability/" target="_blank" rel="noopener">Testing Distributed Systems for Linearizability</a>). However, if we’re given a total (per-object) order, the verification problem is now in P. Indeed, the <a href="https://github.com/jepsen-io/elle" target="_blank" rel="noopener">Elle</a> checker runs in <em>linear</em> time.</p>
<p>In software verification, nondeterminism allows techniques like symbolic model checking (SMC) in cases where exhaustive state enumeration is infeasible, such as pretty much any modern distributed system like CockroachDB. For a recent, large-scale application of SMC, see <a href="https://www.amazon.science/publications/model-checking-boot-code-from-aws-data-centers" target="_blank" rel="noopener">Model checking boot code from AWS data centers</a>. Nondeterminism also makes TLA+ more expressive. The one-in-a-million bug we discuss below is a byproduct of the implementation of the <a href="https://github.com/cockroachdb/cockroach/blob/master/docs/tla-plus/ParallelCommits/ParallelCommits.tla#L187" target="_blank" rel="noopener">ParallelCommits.tla</a> model.</p>
<h2 id="demonic-nondeterminism">Demonic Nondeterminism</h2>
<p>While CS theoreticians mostly see the good side of nondeterminism, practitioners of distributed systems often fall prey to its bad side–(distributed) failure reproduction. Indeed as <a href="https://sampa.cs.washington.edu/new/papers/asplos021-hunt.pdf" target="_blank" rel="noopener">others</a> have pointed out, “<em>Nondeterminism makes the development of distributed systems difficult.</em>”. Inability to reproduce bugs is one of the main reasons that distributed systems are notoriously hard to debug. Nondeterminism of this type is known as <em>demonic</em>. (Intuitively, “worst” possible action is chosen.) E.g., Go’s <a href="https://go.dev/ref/spec#Select_statements" target="_blank" rel="noopener">select statement</a> behaves like Dijkstra’s guarded commands. Ignoring its demonic nondeterminism leads to bugs like <a href="https://github.com/moby/moby/pull/24007" target="_blank" rel="noopener">this</a>. (The <a href="https://github.com/system-pclub/go-concurrency-bugs?tab=readme-ov-file#message-passing-1" target="_blank" rel="noopener">bug</a> is triggered when multiple goroutines execute inside the default clause.)</p>
<p>Despite decades of R&amp;D improvements, there is an obvious gap in available tools to help debug and reproduce a “one-in-a-million” type of bug. Colloquially, we refer to such bugs whose probability of failure is extremely low; they typically require several, correlated internal state transitions, e.g., race conditions and/or intermittent (hardware) failure(s). Until recently, one such bug lurked in CockroachDB. Achieving world class resiliency is one of our highest product principles, and by enlisting the help of <a href="https://antithesis.com/" target="_blank" rel="noopener">Antithesis</a>, a startup from the founders of FoundationDB, we were able to track down and reproduce this most elusive bug, nearly deterministically! With additional instrumentation in the form of (distributed) traces, many reruns, and much log spelunking, a fix was merged, thanks to Alex Sarkesian, co-author of this post and former KV engineer at Cockroach Labs.</p>
<p>Without deterministic reproduction, conventional debugging and (stress) testing don’t yield an effective strategy; for “one-in-a-million” type of bug, it’s really no different than pure chance. Sadly, the state-of-the-art of deterministic debugging leaves much to be desired.</p>
<p>Below we review existing tools. Then, we describe our experience with <a href="https://antithesis.com/" target="_blank" rel="noopener">Antithesis</a>, a system for autonomous testing. We conclude with an intuitive description of the discovered bug and its fix. (See <a href="https://www.cockroachlabs.com/blog/demonic-nondeterminism/#appendix">Appendix</a> for technical details.)</p>
<h2 id="thesis">Thesis</h2>
<p>The idea behind “deterministic debugging” is not new. In <a href="https://dslab.epfl.ch/pubs/debug_determinism.pdf" target="_blank" rel="noopener">Debug Determinism</a> (~2011), the authors argue for, “a new determinism model premised on the idea that effective debugging entails reproducing the <em>same failure</em> and the <em>same root cause</em> as the original execution”. Conceptually, it’s exactly what we’re after; in practice, it’s hard to achieve. Let’s quickly review why and what’s currently available.</p>
<h3 id="sources-of-nondeterminism">Sources of Nondeterminism</h3>
<p>For a stateful, distributed system like CockroachDB, running on a wide variety of deployment environments, sources of nondeterminism can seem endless. Unexpected network delays, thread timings, and disk faults can conspire to manifest rare bugs hidden in the system, particularly in ways that can be nearly impossible to reliably reproduce, diagnose, and fix.</p>
<p><em>Flaky tests, particularly integration tests</em>, can offer many examples of the bugs found due to this unexpected nondeterminism. Usual suspects like TCP port collision and out of file descriptors result due to resource limits; race conditions and timeouts are examples of scheduler non-determinism. (See <a href="https://dl.acm.org/doi/fullHtml/10.1145/3476105" target="_blank" rel="noopener">A Survey of Flaky Tests</a> and <a href="https://krs85.github.io/dettrace.pdf" target="_blank" rel="noopener">Reproducible Containers</a>.)</p>
<p>Hardware (interrupts), clocks (e.g., <code>clock_gettime</code>), <code>/dev/(u)random</code>, and CPU instructions (e.g., <code>RDRAND</code>) are other examples. Beyond single address space, network is a major source of nondeterminism.</p>
<h3 id="ptrace-to-the-rescue"><code>ptrace</code> to the Rescue</h3>
<p><code>ptrace</code> is a system call that’s been around since <a href="https://en.wikipedia.org/wiki/Version_6_Unix" target="_blank" rel="noopener">Version 6 Unix</a> (~1975). Originally added to support debugging with breakpoints, today it supports a whole gamut of applications such as syscall tracing (strace) and syscall record and replay (rr). In essence, <code>ptrace</code> allows to emulate any syscall by intercepting the original call and modifying its result(s). (See <a href="https://github.com/lizrice/strace-from-scratch" target="_blank" rel="noopener">Liz Rice’s Demo strace in Go</a>). Thus, nondeterministic syscalls, e.g., clock_gettime, can be emulated by their deterministic counterparts, e.g., using a <em>logical</em> clock.</p>
<p>In fact, <code>ptrace</code>, a logical clock, a single-threaded scheduler, and a RAM disk is roughly all you need for deterministic debugging on a single machine; beyond a single machine, network is a great non-determinizer. Note that a logical clock can be effectively derived from the precise CPU hardware performance counter–<em>retired conditional branches (RCB)</em>.</p>
<h3 id="history-of-deterministic-debuggers">History of Deterministic Debuggers</h3>
<p>
  <img loading="lazy" src="https://crl2020.imgix.net/img/01-histogram-deterministic-debuggers.png?auto=format,compress&amp;max-w=640" alt="history of non-determinism from 2002 to 2024: vlagrind, rr, dettrace, hermit"/>
</p>


<p>To our knowledge, deterministic debugging is fairly sparse and experimental. The above timeline depicts some of the noteworthy tools developed in the last two decades. While <a href="https://valgrind.org/" target="_blank" rel="noopener">valgrind</a> isn’t strictly deterministic, it implements a single-threaded (fair) scheduler. It served as an inspiration for <a href="https://rr-project.org/" target="_blank" rel="noopener">rr</a>. The more recent development is <a href="https://developers.facebook.com/blog/post/2022/11/22/hermit-deterministic-linux-testing/" target="_blank" rel="noopener">hermit</a> which was inspired by <a href="https://github.com/dettrace/dettrace" target="_blank" rel="noopener">dettrace</a>.</p>
<p><code>rr</code> is perhaps the most widely known deterministic debugger. However, it’s only able to replay deterministically what was previously recorded; hermit, on the other hand, can deterministically execute any binary. (That is, under <code>rr</code>, a pair of runs of the same binary and input would yield two different recordings; see <a href="https://github.com/rr-debugger/rr/issues/1566#issuecomment-152406145" target="_blank" rel="noopener">Explanation</a>.)</p>
<p>At this time, the latter is highly experimental whereas the former is production-ready, assuming you can find a Cloud VM which exposes CPU perf. counters :)</p>
<p>Recall, <a href="https://en.wikipedia.org/wiki/Uncertainty_principle" target="_blank" rel="noopener">Heisenberg’s Uncertainty Principle</a>. Physicists discovered another bad side of nondeterminism way before computer scientists. Deterministic debuggers exhibit side-effects similar to quantum mechanics–deterministic recording alters original execution. </p>
<p>All of the above rely on <code>ptrace</code>, which incurs a significant overhead, 2-3x additional syscalls, plus context-switching. Using seccomp with eBPF can remove the overhead for non-emulated syscalls. The remaining overhead is still quite substantial although <code>rr</code> employs several optimization tricks, e.g., syscall buffering. Nevertheless, <code>ptrace</code> is a poorman’s deterministic debugger at best. Instead, what if determinism could be built directly into a <em>hypervisor</em>?</p>
<h2 id="antithesis">Antithesis</h2>
<p>The <a href="https://antithesis.com/" target="_blank" rel="noopener">Antithesis platform</a> was inspired by <a href="https://www.foundationdb.org/files/fdb-paper.pdf" target="_blank" rel="noopener">FoundationDB</a>, which is deeply embedded with a deterministic simulation framework. FoundationDB’s framework can simulate network and disk I/O, as well as inject faults. The simulation framework code is interleaved with the database code. E.g., <a href="https://github.com/apple/foundationdb/blob/35efd7b04838cd06427a87d21f91a785a0bf05ca/fdbserver/ConsistencyScan.actor.cpp#L782-L796" target="_blank" rel="noopener">here</a> a corrupted key can be injected when FDB’s consistency checker is running inside the simulator. During simulation, an entire database cluster is running single-threaded in the same address space. Since all hardware I/O and non-deterministic syscalls are simulated, it’s effectively a whitebox, deterministic debugger. However, it’s not without limitations. E.g., third-party code like the RocksDB storage engine renders simulation <a href="https://github.com/apple/foundationdb/blob/35efd7b04838cd06427a87d21f91a785a0bf05ca/fdbserver/SimulatedCluster.actor.cpp#L1774-L1782" target="_blank" rel="noopener">non-deterministic</a>.</p>
<p>While FoundationDB is unique in its inherent design to enable deterministic simulation testing, it is frequently far too complex to retrofit the large-scale code base of an existing database with such a system. The Antithesis platform solves this problem by using a deterministic hypervisor, thereby enabling virtually any binary to benefit from deterministic simulation testing!</p>
<p>Similar to FoundationDB, failure injection is built into the Antithesis platform. In running its  autonomous tests, Antithesis will catch errors by monitoring for process failures, such as those caused by assertions like Go’s <strong><code>panic</code></strong>, as well as, by monitoring logs for errors and failures to maintain system invariants. These can be caught by providing <code>regexes</code> to fail on matching patterns of log messages. Intuitively, it runs many short experiments (scenarios), optimizing for a maximum amount of code (i.e. unique edges) explored over the course of a full test run, encountering a number of distinct failures. Roughly, each scenario denotes a simulator run under deterministically random failures. The example below shows thousands of scenarios executed over 25 hours.</p>
<p>
  <img loading="lazy" src="https://crl2020.imgix.net/img/02-example-monitoring-antithesis.png?auto=format,compress&amp;max-w=640" alt="monitoring in antithesis platform"/>
</p>


<p>The Antithesis platform is more than just a deterministic simulator. It uses a fuzzer to find “interesting” scenarios. When available, code coverage instrumentation can provide further (optimization) guidance to the fuzzer, such that faults are injected to explore branches of the code not previously covered in the tests. In the above example, we can see a sharp increase in branches covered during the first ~5 hours. Then, coverage stabilizes as is often the case with distributed systems. (Absent any new failure, the same event loops are executed.)</p>
<p>Given what we now know about the Antithesis platform, we can succinctly describe it as <em>Greybox Deterministic Simulator with Coverage-Guided Failure Injection</em>. In layman’s terms it’s a marriage of a fuzzer and a deterministic debugger.</p>
<h2 id="synthesis">Synthesis</h2>
<p>The one-in-a-million bug first showed up on our radar in 2021. None of our customers reported the issue but; it was <a href="https://github.com/cockroachdb/cockroach/issues/67765" target="_blank" rel="noopener">autofiled</a> by Sentry’s crash reporting module. The stacktrace revealed it to be a <em>violated invariant</em>–an undefined state. For this invariant, like many others, CockroachDB’s code asserts to ensure the invariant holds, using Go’s panic to crash the node and recover diagnostics for further troubleshooting. Unfortunately, besides the stacktrace and the anonymized cluster metadata, we didn’t have any actionable information. Furthermore, this failure mode never appeared in any of our extensive test runs.</p>
<p>In the investigation of these rare crash reports, engineers on our KV Team started to develop plausible <a href="https://github.com/cockroachdb/cockroach/issues/67765#issuecomment-1006491408" target="_blank" rel="noopener">theories</a>; it appeared to implicate <em>ambiguous errors</em> which occur during retries of distributed SQL request batches. In 2023, we started evaluating the Antithesis platform. Fortuitously, one of the scenarios terminates in exactly the same, elusive state as seen in the log below.</p>
<p>
  <img loading="lazy" src="https://crl2020.imgix.net/img/03-elusive-bug.png?auto=format,compress&amp;max-w=640" alt="code screenshot of elusive bug"/>
</p>


<p>The error message “transaction unexpectedly committed” denotes a serious bug–it should not be possible to perform additional operations (such as writes) on an <em>already committed</em> transaction. Any data written by an atomically committed transaction can immediately be read by other transactions. Thus, any subsequent operations that could change that data would violate the <a href="https://www.cockroachlabs.com/blog/consistency-model/#transaction-isolation-levels-and-serializability">transaction isolation model</a>. Examining the above log output, we developed a few leads. (Recall, the crash reports gave us only a stacktrace without a full log.)</p>
<p>The failure message indicates the batch of inflight requests (ba), as well as, transaction record (<code>txn</code>), and the <a href="https://www.cockroachlabs.com/docs/stable/architecture/transaction-layer#writes-and-reads-phase-1">affected (key) ranges</a>. Suspiciously, we see a batch with <code>EndTxn(commit)</code> and <code>Put</code> requests which, upon evaluation, is rejected due to being against an already committed transaction – particularly one previously noted as being in an indeterminate commit state. Immediately before the failure message is an indication of a <a href="https://www.cockroachlabs.com/docs/stable/architecture/transaction-layer#parallel-commits-step-by-step">“transaction recovery”</a>. Lastly, we see an RPC error; though it is unclear if this is related, or simply a correlated symptom due to the simulation’s introduction of network interference.  The RPC error is immediately preceded by a network failure injection message.</p>
<p>Armed with these new insights, the root cause should now be imminent, right? Not exactly. The transaction recovery message seemed to implicate the <a href="https://www.cockroachlabs.com/blog/parallel-commits/">Parallel Commit</a> protocol. However, the actual root cause analysis took a fairly long time, during which distributed traces and deterministic replays began to tease out the state machine behind the sufficient conditions for “transaction unexpectedly committed”. Many rinse-and-repeat cycles later, the root cause, its fix, and a reproducing unit test have emerged.</p>
<p>For an in-depth analysis of the root cause, see <a href="https://www.cockroachlabs.com/blog/demonic-nondeterminism/#appendix">Appendix</a>. The culprit, as it turns out, was an attempt to retry the <em>ambiguous</em> (or, “indeterminately committed”) <code>write</code> at a higher timestamp, which results in <em>non-idempotency</em>. More generally, we need to protect the transaction coordinator against non-idempotent replays of request batches that result in ambiguous failures (e.g., RPC error). That’s exactly what our fix implements. By explicitly tracking potentially non-idempotent replays, the transaction coordinator now responds with <a href="https://www.cockroachlabs.com/docs/stable/common-errors#result-is-ambiguous">result is ambiguous</a> error to the SQL client, if any replay fails the idempotency check, e.g., change of write timestamp.</p>
<p>This may not seem like the most graceful recovery; effectively, we’re shifting the burden of non-idempotent transaction retries to the SQL client. Sadly, <a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="noopener">CAP Theorem</a> postulates we can’t have it all ways. In this case, owing to (partial) unavailability of the network, the transaction coordinator cannot verify, with any deterministic time bound, whether the transaction committed. We conclude by noting that while the Parallel Commit protocol was verified using TLA+, the model is an <em>underapproximation</em> of the actual implementation. Specifically, the <a href="https://github.com/cockroachdb/cockroach/blob/master/docs/tla-plus/ParallelCommits/ParallelCommits.tla" target="_blank" rel="noopener">TLA+ specification</a> doesn’t model the above scenario.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Bugs are compounded by the number of distinct nodes operating in a distributed system, each providing their own sources of nondeterminism with thread timings, network conditions, hardware, and more. Finding and fixing these bugs requires new approaches to testing and debugging. At a recent seminar on <a href="https://www.dagstuhl.de/de/seminars/seminar-calendar/seminar-details/23441" target="_blank" rel="noopener">Database Reliability and Robustness</a>, industry practitioners summarized the state-of-the-art,</p>
<blockquote>
<p>The current state-of-the-art is often simply rerunning a test a large number of times (e.g., 1000x), potentially after augmenting the system with additional logging, a slightly modified configuration, runtime sanitizers, or with changes to the system or test workload to increase the likelihood of perturbing the issue.</p>
</blockquote>
<p>Like any emerging technology, the Antithesis platform is not without rough edges. Deterministic replay doesn’t immediately get you a reproduction, particularly across distinct code changes as you might see with a unit or integration test. In our experience, a significant amount of effort was invested in instrumenting the logs, as well as reasoning about injected failure states in order to recover the state machine which reproduces the bug. The rinse-and-repeat cycle means that a modified binary (with new instrumentation) may not always hit the same terminal state. Although, in practice determinism between runs is very high assuming the code changes are localized. (Recall that the retired conditional branches counter models a logical clock; thus, straight-line code tends to preserve determinism.)</p>
<p>Unlike <code>rr</code>, the Antithesis platform doesn’t support step-through debugging during replay. Thus, the ability to observe internal state outside of logging is missing. This feedback loop could reduce the rinse-and-repeat cycle and shorten the time to reproduction.</p>
<p>Despite the rough edges, the Antithesis platform remains a promising technology, with the potential to neutralize many hard-to-detect lurking bugs. It’s our belief that deterministic debugging is the future, and Antithesis is paving the way toward that goal.</p>
<h2 id="appendix">Appendix</h2>
<h3 id="root-cause-birds-eye-view">Root Cause Bird’s-eye View</h3>
<p>The sequence diagram below illustrates the bug scenario. The crux of the issue is an <em>ambiguous write</em>, denoted by the first attempt of <code>txn.Batch{CPut(200, ‘y’)}</code>. In other words, an RPC failure - the RPC performing the write on key y can time out or fail to respond, and if so the node performing the role of the transaction coordinator will not know if the first attempt succeeded to update ‘y’.</p>
<p>
  <img loading="lazy" src="https://crl2020.imgix.net/img/04-rpc-failure.png?auto=format,compress&amp;max-w=640" alt="ambiguous write transaction error"/>
</p>


<p>Immediately after the first write attempt fails due to the network failure, the leaseholder moves from <code>n2</code> to <code>n3</code>. Subsequently, the second write attempt reaches a fresh leaseholder on <code>n3</code>, which results in requiring the transaction coordinator to move the transaction’s timestamp using something called a  <a href="https://www.cockroachlabs.com/docs/stable/architecture/transaction-layer#read-refreshing">“read refresh”</a>. The injected network failures also cause the transaction coordinator to miss heartbeats of the transaction’s record. Simultaneously, a contending transaction triggers a <a href="https://www.cockroachlabs.com/docs/stable/architecture/transaction-layer#parallel-commits-step-by-step">“transaction status recovery”</a> process, which races with the transaction’s own retries. The former succeeds, marking the transaction record explicitly committed. The latter - i.e. the transaction’s retry after the ambiguous state - results in the transaction coordinator panicking.</p>
<h3 id="parallel-commits">Parallel Commits</h3>
<p>In more technical detail, we can understand what caused this bug if we look deeper into the <a href="https://www.cockroachlabs.com/blog/parallel-commits/">Parallel Commits</a> protocol used in CockroachDB, with particular consideration for its Transaction Recovery mechanism and the race conditions that arise from it. Consider an implicit transaction like the following SQL statement:</p>
<p><code>INSERT INTO accounts (account_id, name) VALUES (100, ‘x’), (200, ‘y’)</code></p>
<p>In CockroachDB, rows are stored as key-value pairs, partitioned into many ranges - for example, we could have <code>100 &lt;= account_id &lt; 200 in one range,</code> and <code>200 &lt;= account_id &lt; 300</code> in another, with leaseholders for these ranges spread across various nodes in the cluster. This requires usage of an explicit transaction record in order to ensure that the writes happen atomically; i.e. that they can be made visible to other reads at the same time, using an explicit transaction timestamp. This can look something like the following:</p>
<pre tabindex="0"><code>TransactionRecord{
    Status: COMMITTED,
    Timestamp: 5,
    ...
}
</code></pre><p>We’ll leave detailed description of the protocol to the previously mentioned blog post, however in short: while a traditional two-phase commit (2PC) makes writes visible by marking a transaction record as <code>COMMITTED</code>, and does so only after all writes have been acknowledged, CockroachDB’s Parallel Commits protocol works a bit differently. In addition to writes being visible once their transaction record is marked explicitly as <code>COMMITTED</code>, it also introduces a new state known as implicitly committed, where a transaction’s writes can be read if the reader can verify that all writes have been acknowledged. This looks instead like the following:</p>
<pre tabindex="0"><code>TransactionRecord{
    Status: STAGING,
    Timestamp: 30,
    Writes: []Key{100, 200, ...},
    ...
}
</code></pre><p>This allows the transaction coordinator to write the transaction record in parallel with the transaction’s writes, and instead leaves the final step of marking the transaction as explicitly  <code>COMMITTED</code> as post-transaction follow-up work that can happen asynchronously, decreasing transaction latency experienced by clients and improving throughput. In terms of CockroachDB’s underlying Key-Value Storage (KV) Operations, this process can look something like the following:</p>
<p>
  <img loading="lazy" src="https://crl2020.imgix.net/img/05-cockroachdb-transaction-kv-storage-operation.png?auto=format,compress&amp;max-w=640" alt="parallel commit in cockroachdb transaction"/>
</p>


<p>In order to ensure that all transaction records are eventually marked as explicitly <code>COMMITTED</code>, a “Transaction Status Recovery Procedure” had to be introduced; the TLA+ Specification (mentioned previously) formally verifies that all implicitly committed transactions will eventually become explicitly committed, and is explained further in the Parallel Commits blog post. The Recovery Procedure ensures that a transaction coordinator that dies before finishing the asynchronous follow-up work can still result in an explicitly <code>COMMITTED</code> record by allowing any other transaction that performs reads or writes on these keys (and thus encounters the transaction record) to kick off recovery. Once the Recovery Procedure has been initiated, the database can ensure that the keys noted in the transaction record were either correctly and durably written, in which case the transaction can be marked <code>COMMITTED</code>, or they were not, in which case the transaction must be marked <code>ABORTED</code>. This is an all-or-none proposition, of course, in order to ensure transaction atomicity.</p>
<h3 id="unexpected-commits">Unexpected Commits</h3>
<p>How does this lead to a bug in which the transaction coordinator doesn’t realize its transaction was already committed, you might ask? Well, recall that we mentioned RPC failures earlier. In the case that one of the RPCs for performing one of a transaction’s writes fail, the transaction coordinator literally does not know if that write is durable or not. It is possible that the remote side of the RPC performed correctly, durably wrote the new value to disk, and the node simply lost power or network connection before returning its gRPC <code>codes.OK</code> response. In the terminology of the 2PC protocol, the write has not been acknowledged.  So the transaction coordinator must re-attempt the write, sending a new RPC - if the value is already durably written, we simply validate it, this is called an <em><strong>idempotent replay</strong></em>. If the value was not durably written, the write is re-attempted. In KV operations, this looks like the following:</p>
<p>
  <img loading="lazy" src="https://crl2020.imgix.net/img/06-cockroachdb-transaction-re-attempt.png?auto=format,compress&amp;max-w=640" alt="cockroachdb transaction retry - diagram"/>
</p>


<p>As mentioned above, however, once a transaction’s writes are durably written and the record is marked as <code>STAGING</code>, it is considered implicitly committed by other transactions. This means that it is possible for the RPC failure of a transaction’s writes to cause the transaction coordinator to be <strong>out of sync</strong> with the correct state of the transaction, as it is viewed by other transactions operating in the database.  Additionally, once a transaction is implicitly committed, it may be eligible for the Transaction Status Recovery Procedure, initiated by other operations in the database. Hence, not only can the transaction coordinator have an ambiguous state, but it is possible for another operation to correctly interpret the “implicitly committed” state of the transaction, and mark it explicitly committed before the transaction coordinator can verify the writes and attempt to finalize the transaction itself - essentially losing a race and ending up finding that the transaction was <code>unexpectedly committed</code>!</p>
<h3 id="fixing-idempotency">Fixing Idempotency</h3>
<p>Once a transaction is committed - either explicitly or implicitly - any changes to that transaction would be illegal, causing breaks to the rules of transaction atomicity and isolation. This makes sense - once some other operation performs a read at timestamp <code>ts=6</code> and sees the following query results:</p>
<pre tabindex="0"><code>&gt; SELECT account_id, value FROM accounts;
 account_id | value 
------------+-------
        100 |   x   
        200 |   y   
(2 rows)
</code></pre><p>With <code>account_id=100</code> having <code>value=‘x’</code> as written by <code>TxnID=1</code>, it should be illegal for <code>TxnID=1</code> to later perform additional operations like writing <code>value=’z’</code>. Similarly, it would also be illegal for <code>TxnID=1</code> to later rewrite the transaction’s timestamp to <code>ts=10</code>, as it would also retroactively change the query at <code>ts=6</code> to have the following results:</p>
<pre tabindex="0"><code>&gt; SELECT account_id, value FROM accounts;
 account_id | value 
------------+-------
(0 rows)
</code></pre><p>These behaviors are not allowed in CockroachDB, as they could cause significant bugs in client applications if our guarantees around transaction isolation were not respected. This is what the transaction coordinator is asserting when it validates its expected transaction status, and why the transaction coordinator would crash if it found itself in an unexpected state.</p>
<p>It turns out that the tricky part is the definition around the <em><strong>idempotent replay</strong></em> that happens when the transaction coordinator retries a failed write RPC. Generally, the idempotent replay is just validating that if we wrote <code>value=’x’</code> for <code>account_id=100</code>, we are still writing the same value, regardless of the timestamp, since the transaction isn’t yet committed. In most cases, the timestamp of a transaction’s writes are fungible prior to the transaction being committed - the timestamp can be incremented, provided any prior read operations in the transaction could be validated via an operation known as a Read Refresh. However, once it is possible for a transaction to be considered committed, its writes become visible to other readers - and thus, changing the timestamp of a write is actually breaking idempotency by having a side effect.</p>
<p>How can we fix this?
If the transaction coordinator is in an ambiguous state due to RPC failures, we can essentially incorporate that into our evaluation of the idempotent replay. If we are attempting to change the timestamp of a transaction for some reason (such as the start of a new range leaseholder), and the transaction coordinator isn’t sure if the transaction could be considered committed by other readers, rather than attempting to break our guarantees or panic, we should instead acknowledge that ambiguity and instead return <code>SQL error 40003 statement_completion_unknown</code>. This allows the client to determine how to proceed in the face of RPC failures - the transaction can be verified externally, and potentially reattempted if it did not complete successfully. In terms of KV operations, this looks like the following:</p>
<p>
  <img loading="lazy" src="https://crl2020.imgix.net/img/07-rpc-failure-verified-transaction.png?auto=format,compress&amp;max-w=640" alt="RPC failure - verified transaction"/>
</p>



      </div></div>
  </body>
</html>
