<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spritely.institute/news/building-interactive-web-pages-with-guile-hoot.html">Original</a>
    <h1>Building interactive web pages with Guile Hoot</h1>
    
    <div id="readability-page-1" class="page"><div><section><article><address>Dave Thompson — <time datetime="2023-11-30">November 30, 2023</time></address><p><img src="https://files.spritely.institute/images/blog/hoot-todo.jpg" alt="Hoot owl with a to-do list scroll"/></p>
<p>A question we frequently hear in discussions about WebAssembly (Wasm)
is:</p>
<p><strong>&#34;Can Wasm call the DOM (Document Object Model) API?&#34;</strong></p>
<p>The answer is: <strong>Yes, thanks to <a href="https://v8.dev/blog/wasm-gc-porting">Wasm Garbage
Collection</a>!</strong></p>
<p>In this post, we will use <a href="https://spritely.institute/hoot">Guile Hoot</a> (our Scheme to Wasm
compiler) to demonstrate how a language that compiles to Wasm GC can
be used to implement the kind of interactivity we&#39;re used to
implementing with JavaScript.  We&#39;ll start very simple and build up to
something that resembles a <a href="https://react.dev/">React</a>-like
application.</p>
<p>In our <a href="https://spritely.institute/news/scheme-wireworld-in-browser.html">previous post about running Scheme in the
browser</a>, we had to use quite
a lot of JavaScript code to call Scheme procedures (functions), render
the user interface, and handle user input. However, today we&#39;re
pleased to announce that those days are behind us; Hoot 0.2.0,
<a href="https://spritely.institute/news/guile-hoot-v020-released.html">released today</a>, now includes a
foreign function interface (FFI) for calling JavaScript from Scheme.
In other words, the vast majority of code in a Hoot application can
now be written directly in Scheme!</p>
<h2>Hello, world!</h2>
<p>Let&#39;s start with a &#34;Hello, world&#34; application that simply adds a text
node to the document body.</p>
<pre><code infostring="scheme"><span>(</span><span>define-foreign</span> <span>document-body</span>
  <span>&#34;document&#34;</span> <span>&#34;body&#34;</span>
      <span>-&gt;</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>make-text-node</span>
  <span>&#34;document&#34;</span> <span>&#34;createTextNode&#34;</span>
      <span>(</span><span>ref</span> <span>string</span><span>)</span> <span>-&gt;</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>append-child!</span>
  <span>&#34;element&#34;</span> <span>&#34;appendChild&#34;</span>
      <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span><span>)</span>

<span>(</span><span>append-child!</span> <span>(</span><span>document-body</span><span>)</span> <span>(</span><span>make-text-node</span> <span>&#34;Hello, world!&#34;</span><span>)</span><span>)</span>
</code></pre>
<p>The <code>define-foreign</code> syntax declares a Wasm import with a given
signature that is bound to a Scheme variable.  In this example, we&#39;d
like access to <code>document.body</code>, <code>document.createTextNode</code>, and
<code>element.appendChild</code>.</p>
<p>Each import has a two-part name, which correspond to the strings in
the <code>define-foreign</code> expressions above.  Imported functions have a
signature specifying the parameter and result types.</p>
<p>WebAssembly follows the <a href="https://en.wikipedia.org/wiki/Capability-based_security"><em>capability security</em>
model</a> (and
if you know us, you know <a href="https://spritely.institute/goblins">we&#39;re big fans</a>).  Wasm modules
act as guests within a host environment — in our case, the host is the
browser.  By default, a Wasm module has no access to functions that
interact with its host.  The Wasm guest must be granted explicit
permission by its host to be able to, for example, add DOM elements to
a web page.</p>
<p>The way capabilities work in Wasm is as follows:</p>
<ul>
<li>The Wasm module declares a set of imports.</li>
<li>When the Wasm module is
<a href="https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiateStreaming">instantiated</a>,
the host maps the import names to concrete implementations.</li>
</ul>
<p>So, <code>define-foreign</code> merely <em>declares</em> the module&#39;s need for a
particular function import; it does <em>not</em> bind to a particular
function on the host.  The Wasm guest cannot grant capabilities unto
itself.</p>
<p>The host environment in the browser is the JavaScript engine, so we
must use JavaScript to bootstrap our Wasm program.  To do so, we
instantiate the Wasm module and pass along the implementations for the
declared imports.  The import names in JavaScript match up to the
import names in the Wasm module.  For our &#34;Hello, world&#34; example, that
code looks like this:</p>
<pre><code infostring="javascript"><span>window</span><span>.</span><span>addEventListener</span><span>(</span><span>&#34;load&#34;</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>Scheme</span><span>.</span><span>load_main</span><span>(</span><span>&#34;hello.wasm&#34;</span><span>,</span> <span>{</span><span>}</span><span>,</span> <span>{</span>
    <span>document</span><span>:</span> <span>{</span>
      <span>body</span><span>(</span><span>)</span> <span>{</span> <span>return</span> <span>document</span><span>.</span><span>body</span><span>;</span> <span>}</span><span>,</span>
      <span>createTextNode</span><span>:</span> <span>Document</span><span>.</span><span>prototype</span><span>.</span><span>createTextNode</span><span>.</span><span>bind</span><span>(</span><span>document</span><span>)</span>
    <span>}</span><span>,</span>
    <span>element</span><span>:</span> <span>{</span>
      <span>appendChild</span><span>(</span><span>parent</span><span>,</span> <span>child</span><span>)</span> <span>{</span> <span>return</span> <span>parent</span><span>.</span><span>appendChild</span><span>(</span><span>child</span><span>)</span><span>;</span> <span>}</span>
    <span>}</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<p>The <code>Scheme</code> class is provided by our JavaScript integration library,
<a href="https://codeberg.org/spritely/hoot/src/tag/v0.1.0/js-runtime/reflect.js">reflect.js</a>.
This library provides a Scheme abstraction layer on top of the
<a href="https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface"><code>WebAssembly</code>
API</a>
and is used to load Hoot binaries and manipulate Scheme values from
JavaScript.</p>
<p>The result:</p>
<p><img src="https://files.spritely.institute/images/blog/hoot-ffi-hello-world.png" alt="The text &amp;quot;Hello, world!&amp;quot; rendered in a web browser."/></p>
<h2>HTML as Scheme data</h2>
<p>Now that we&#39;ve explained the basics, let&#39;s move on to something more
interesting.  How about rendering an entire tree of DOM elements?  For
that, we&#39;ll need to declare imports for <code>document.createElement</code> and
<code>element.setAttribute</code>:</p>
<pre><code infostring="scheme"><span>(</span><span>define-foreign</span> <span>make-element</span>
  <span>&#34;document&#34;</span> <span>&#34;createElement&#34;</span>
  <span>(</span><span>ref</span> <span>string</span><span>)</span> <span>-&gt;</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>set-attribute!</span>
  <span>&#34;element&#34;</span> <span>&#34;setAttribute&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>(</span><span>ref</span> <span>string</span><span>)</span> <span>(</span><span>ref</span> <span>string</span><span>)</span> <span>-&gt;</span> <span>none</span><span>)</span>
</code></pre>
<p>And here&#39;s the additional JavaScript wrapper code:</p>
<pre><code infostring="javascript"><span>{</span>
  <span>document</span><span>:</span> <span>{</span>
    <span>createElement</span><span>:</span> <span>Document</span><span>.</span><span>prototype</span><span>.</span><span>createElement</span><span>.</span><span>bind</span><span>(</span><span>document</span><span>)</span><span>,</span>
      <span>}</span><span>,</span>
  <span>element</span><span>:</span> <span>{</span>
    <span>setAttribute</span><span>(</span><span>elem</span><span>,</span> <span>name</span><span>,</span> <span>value</span><span>)</span> <span>{</span> <span>elem</span><span>.</span><span>setAttribute</span><span>(</span><span>name</span><span>,</span> <span>value</span><span>)</span><span>;</span> <span>}</span><span>,</span>
      <span>}</span>
<span>}</span>
</code></pre>
<p>Now we need some markup to render.  Thanks to the symbolic
manipulation powers of Scheme, we have no need for an additional
language like React&#39;s
<a href="https://react.dev/learn/writing-markup-with-jsx">JSX</a> to cleanly mix
markup with code.  Scheme has <a href="https://www.gnu.org/software/guile/manual/html_node/Expression-Syntax.html#index-quote">a lovely little thing called
<code>quote</code></a>
which we can use to represent arbitrary data as Scheme expressions.
We&#39;ll use this to embed HTML within our Scheme code.</p>
<p>We use <code>quote</code> by prepending a single quote (<code>&#39;</code>) to an expression.
For example, the expression <code>(+ 1 2 3)</code> calls <code>+</code> with the numbers
<code>1</code>, <code>2</code>, and <code>3</code> and returns <code>6</code>.  However, the expression <code>&#39;(+ 1 2 3)</code> (note the <code>&#39;</code>) does not call <code>+</code> but instead returns a list of 4
elements: the symbol <code>+</code>, followed by the numbers <code>1</code>, <code>2</code>, and <code>3</code>.
In other words, <code>quote</code> turns code into data.</p>
<p>Now, to write HTML from within Scheme, we can leverage a format called
<a href="https://okmij.org/ftp/Scheme/SXML.html">SXML</a>:</p>
<pre><code infostring="scheme"><span>(</span><span>define</span> <span>sxml</span>
  <span>&#39;</span><span>(</span><span>section</span>
    <span>(</span><span>h1</span> <span>&#34;Scheme rocks!&#34;</span><span>)</span>
    <span>(</span><span>p</span> <span>&#34;With Scheme, data is code and code is data.&#34;</span><span>)</span>
    <span>(</span><span>small</span> <span>&#34;Made with &#34;</span>
           <span>(</span><span>a</span> <span>(</span><span>@</span> <span>(</span><span>href</span> <span>&#34;https://spritely.institute/hoot&#34;</span><span>)</span><span>)</span>
              <span>&#34;Guile Hoot&#34;</span><span>)</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<p><code>section</code>, <code>h1</code>, etc. are not procedure calls, they are literal
symbolic data.</p>
<p>To transform this Scheme data into a rendered document, we need to
walk the SXML tree and make the necessary DOM API calls, like so:</p>
<pre><code infostring="scheme"><span>(</span><span>define</span> <span>(</span><span>sxml-&gt;dom</span> <span>exp</span><span>)</span>
  <span>(</span><span>match</span> <span>exp</span>
        <span>(</span><span>(</span><span>?</span> <span>string?</span> <span>str</span><span>)</span>
     <span>(</span><span>make-text-node</span> <span>str</span><span>)</span><span>)</span>
        <span>(</span><span>(</span><span>(</span><span>?</span> <span>symbol?</span> <span>tag</span><span>)</span> <span>.</span> <span>body</span><span>)</span>
          <span>(</span><span>let</span> <span>(</span><span>(</span><span>elem</span> <span>(</span><span>make-element</span> <span>(</span><span>symbol-&gt;string</span> <span>tag</span><span>)</span><span>)</span><span>)</span><span>)</span>
       <span>(</span><span>define</span> <span>(</span><span>add-children</span> <span>children</span><span>)</span>
                           <span>(</span><span>for-each</span> <span>(</span><span>lambda</span> <span>(</span><span>child</span><span>)</span>
                     <span>(</span><span>append-child!</span> <span>elem</span> <span>(</span><span>sxml-&gt;dom</span> <span>child</span><span>)</span><span>)</span><span>)</span>
                   <span>children</span><span>)</span><span>)</span>
       <span>(</span><span>match</span> <span>body</span>
                  <span>(</span><span>(</span><span>(</span><span>&#39;@</span> <span>.</span> <span>attrs</span><span>)</span> <span>.</span> <span>children</span><span>)</span>
                    <span>(</span><span>for-each</span> <span>(</span><span>lambda</span> <span>(</span><span>attr</span><span>)</span>
                      <span>(</span><span>match</span> <span>attr</span>
                                                <span>(</span><span>(</span><span>(</span><span>?</span> <span>symbol?</span> <span>name</span><span>)</span> <span>(</span><span>?</span> <span>string?</span> <span>val</span><span>)</span><span>)</span>
                         <span>(</span><span>set-attribute!</span> <span>elem</span>
                                         <span>(</span><span>symbol-&gt;string</span> <span>name</span><span>)</span>
                                         <span>val</span><span>)</span><span>)</span><span>)</span><span>)</span>
                    <span>attrs</span><span>)</span>
          <span>(</span><span>add-children</span> <span>children</span><span>)</span><span>)</span>
                  <span>(</span><span>children</span> <span>(</span><span>add-children</span> <span>children</span><span>)</span><span>)</span><span>)</span>
       <span>elem</span><span>)</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<p>Then we can use our newly defined <code>sxml-&gt;dom</code> procedure to generate
the element tree and add it to the document body:</p>
<pre><code infostring="scheme"><span>(</span><span>append-child!</span> <span>(</span><span>document-body</span><span>)</span> <span>(</span><span>sxml-&gt;dom</span> <span>sxml</span><span>)</span><span>)</span>
</code></pre>
<p>The result:</p>
<p><img src="https://files.spritely.institute/images/blog/hoot-ffi-sxml.png" alt="SXML rendered to DOM elements."/></p>
<h2>HTML templating with Scheme</h2>
<p>That was pretty neat, but we don&#39;t need JavaScript, let alone
WebAssembly, to render a simple static document!  In other words,
we&#39;re far from done here.  Let&#39;s introduce some interactivity by
adding a button and a counter that displays how many times the button
was clicked.  We could take an
<a href="https://en.wikipedia.org/wiki/Imperative_programming">imperative</a>
approach and modify the element by mutating the counter value every
time the button is clicked.  Indeed, for something this simple that
would be fine.  But just for fun, let&#39;s take a look at a more
functional approach that uses a template to create the entire document
body.</p>
<p>Scheme provides support for structured templating via
<a href="https://www.gnu.org/software/guile/manual/html_node/Expression-Syntax.html#index-quasiquote"><code>quasiquote</code></a>,
which uses backticks (<code>`</code>) instead of single-quotes (<code>&#39;</code>).
Arbitrary code can be evaluated in the template by using <code>unquote</code>,
represented by a comma (<code>,</code>).  The expression <code>`(+ 1 2 ,(+ 1 2))</code>
produces the list <code>(+ 1 2 3)</code>.  The first <code>(+ ...)</code> expression is
quoted, but the second is not, and thus <code>(+ 1 2)</code> is evaluated as code
and the value <code>3</code> is placed into the final list element.</p>
<p>Scheme&#39;s <code>quasiquote</code> stands in stark contrast to the limited string
templating available in most other languages.  In JavaScript, we could
do <code>`1 + 2 + ${1 + 2}`</code>, but this form of templating lacks
structure.  The result is just a flat string, which makes it clumsy to
work with and vulnerable to <a href="https://www.more-magic.net/posts/structurally-fixing-injection-bugs.html">injection
bugs</a>.</p>
<p>Below is an SXML template. It is a procedure which generates a
document based on the current value of <code>*clicks*</code>, a global mutable
variable that stores how many times the button was clicked:</p>
<pre><code infostring="scheme"><span>(</span><span>define</span> <span>*clicks*</span> <span>0</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>template</span><span>)</span>
  <span>`</span><span>(</span><span>div</span> <span>(</span><span>@</span> <span>(</span><span>id</span> <span>&#34;container&#34;</span><span>)</span><span>)</span>
    <span>(</span><span>p</span> <span>,</span><span>(</span><span>number-&gt;string</span> <span>*clicks*</span><span>)</span> <span>&#34; clicks&#34;</span><span>)</span>
        <span>(</span><span>button</span> <span>(</span><span>@</span> <span>(</span><span>click</span> <span>,</span><span>(</span><span>lambda</span> <span>(</span><span>event</span><span>)</span>
                         <span>(</span><span>set!</span> <span>*clicks*</span> <span>(</span><span>+</span> <span>*clicks*</span> <span>1</span><span>)</span><span>)</span>
                         <span>(</span><span>render</span><span>)</span><span>)</span><span>)</span><span>)</span>
            <span>&#34;Click me&#34;</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<p>To handle interactive elements, we&#39;ve added a new feature on top of
SXML. Notice that the button has a <code>click</code> property with a procedure
as its value.  To get some interactivity, we need event handlers, and
we&#39;ve chosen to encode the click handler into the template much like
how you could use the <code>onclick</code> attribute in plain HTML.</p>
<p>To make this work, we need imports for <code>document.getElementById</code>,
<code>element.addEventListener</code> and <code>element.remove</code>:</p>
<pre><code infostring="scheme"><span>(</span><span>define-foreign</span> <span>get-element-by-id</span>
  <span>&#34;document&#34;</span> <span>&#34;getElementById&#34;</span>
  <span>(</span><span>ref</span> <span>string</span><span>)</span> <span>-&gt;</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>add-event-listener!</span>
  <span>&#34;element&#34;</span> <span>&#34;addEventListener&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>(</span><span>ref</span> <span>string</span><span>)</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>none</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>remove!</span>
  <span>&#34;element&#34;</span> <span>&#34;remove&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>none</span><span>)</span>
</code></pre>
<p>And the JavaScript bindings:</p>
<pre><code infostring="javascript"><span>{</span>
  <span>document</span><span>:</span> <span>{</span>
    <span>getElementById</span><span>:</span> <span>Document</span><span>.</span><span>prototype</span><span>.</span><span>getElementById</span><span>.</span><span>bind</span><span>(</span><span>document</span><span>)</span><span>,</span>
      <span>}</span><span>,</span>
  <span>element</span><span>:</span> <span>{</span>
    <span>remove</span><span>(</span><span>elem</span><span>)</span> <span>{</span> <span>elem</span><span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>,</span>
    <span>addEventListener</span><span>(</span><span>elem</span><span>,</span> <span>name</span><span>,</span> <span>f</span><span>)</span> <span>{</span> <span>elem</span><span>.</span><span>addEventListener</span><span>(</span><span>name</span><span>,</span> <span>f</span><span>)</span><span>;</span> <span>}</span><span>,</span>
      <span>}</span>
<span>}</span>
</code></pre>
<p>Here is what the attribute handling code in the <code>sxml-&gt;dom</code> procedure
looks like now:</p>
<pre><code infostring="scheme"><span>(</span><span>match</span> <span>body</span>
  <span>(</span><span>(</span><span>(</span><span>&#39;@</span> <span>.</span> <span>attrs</span><span>)</span> <span>.</span> <span>children</span><span>)</span>
   <span>(</span><span>for-each</span> <span>(</span><span>lambda</span> <span>(</span><span>attr</span><span>)</span>
               <span>(</span><span>match</span> <span>attr</span>
                 <span>(</span><span>(</span><span>(</span><span>?</span> <span>symbol?</span> <span>name</span><span>)</span> <span>(</span><span>?</span> <span>string?</span> <span>val</span><span>)</span><span>)</span>
                  <span>(</span><span>set-attribute!</span> <span>elem</span>
                                  <span>(</span><span>symbol-&gt;string</span> <span>name</span><span>)</span>
                                  <span>val</span><span>)</span><span>)</span>
                                                                                     <span>(</span><span>(</span><span>(</span><span>?</span> <span>symbol?</span> <span>name</span><span>)</span> <span>(</span><span>?</span> <span>procedure?</span> <span>proc</span><span>)</span><span>)</span>
                  <span>(</span><span>add-event-listener!</span> <span>elem</span>
                                       <span>(</span><span>symbol-&gt;string</span> <span>name</span><span>)</span>
                                       <span>(</span><span>procedure-&gt;external</span> <span>proc</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
             <span>attrs</span><span>)</span>
   <span>(</span><span>add-children</span> <span>children</span><span>)</span><span>)</span>
  <span>(</span><span>children</span> <span>(</span><span>add-children</span> <span>children</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<p>To keep things simple (for now), every time the button is clicked
we&#39;ll delete what&#39;s in the document and re-render the template:</p>
<pre><code infostring="scheme"><span>(</span><span>define</span> <span>(</span><span>render</span><span>)</span>
  <span>(</span><span>let</span> <span>(</span><span>(</span><span>old</span> <span>(</span><span>get-element-by-id</span> <span>&#34;container&#34;</span><span>)</span><span>)</span><span>)</span>
    <span>(</span><span>unless</span> <span>(</span><span>external-null?</span> <span>old</span><span>)</span> <span>(</span><span>remove!</span> <span>old</span><span>)</span><span>)</span><span>)</span>
  <span>(</span><span>append-child!</span> <span>(</span><span>document-body</span><span>)</span> <span>(</span><span>sxml-&gt;dom</span> <span>(</span><span>template</span><span>)</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<p>The result:</p>
<p><img src="https://files.spritely.institute/images/blog/hoot-ffi-counter.png" alt="Button click counter screenshot."/></p>
<h2>Building a virtual DOM</h2>
<p>Wouldn&#39;t it be <em>even cooler</em> if we could apply some kind of React-like
diffing algorithm that only updates the parts of the document that
have changed when we need to re-render?  Why yes, that would be cool!
Let&#39;s do that now.</p>
<p>We&#39;ll add bindings for the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker">TreeWalker</a>
interface to traverse the document, as well as some additional element
methods to get/set the <code>value</code> and <code>checked</code> properties, remove event
listeners, replace elements, remove attributes, and get event targets:</p>
<pre><code infostring="scheme"><span>(</span><span>define-foreign</span> <span>make-tree-walker</span>
  <span>&#34;document&#34;</span> <span>&#34;createTreeWalker&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>current-node</span>
  <span>&#34;treeWalker&#34;</span> <span>&#34;currentNode&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>set-current-node!</span>
  <span>&#34;treeWalker&#34;</span> <span>&#34;setCurrentNode&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>next-node!</span>
  <span>&#34;treeWalker&#34;</span> <span>&#34;nextNode&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>first-child!</span>
  <span>&#34;treeWalker&#34;</span> <span>&#34;firstChild&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>next-sibling!</span>
  <span>&#34;treeWalker&#34;</span> <span>&#34;nextSibling&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>element-value</span>
  <span>&#34;element&#34;</span> <span>&#34;value&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>(</span><span>ref</span> <span>string</span><span>)</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>set-element-value!</span>
  <span>&#34;element&#34;</span> <span>&#34;setValue&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>(</span><span>ref</span> <span>string</span><span>)</span> <span>-&gt;</span> <span>none</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>remove-event-listener!</span>
  <span>&#34;element&#34;</span> <span>&#34;removeEventListener&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>(</span><span>ref</span> <span>string</span><span>)</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>none</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>replace-with!</span>
  <span>&#34;element&#34;</span> <span>&#34;replaceWith&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>none</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>remove-attribute!</span>
  <span>&#34;element&#34;</span> <span>&#34;removeAttribute&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>(</span><span>ref</span> <span>string</span><span>)</span> <span>-&gt;</span> <span>none</span><span>)</span>

<span>(</span><span>define-foreign</span> <span>event-target</span>
  <span>&#34;event&#34;</span> <span>&#34;target&#34;</span>
  <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span> <span>-&gt;</span> <span>(</span><span>ref</span> <span>null</span> <span>extern</span><span>)</span><span>)</span>
</code></pre>
<p>And the JavaScript bindings:</p>
<pre><code infostring="javascript"><span>{</span>
  <span>document</span><span>:</span> <span>{</span>
    <span>createTreeWalker</span><span>:</span> <span>Document</span><span>.</span><span>prototype</span><span>.</span><span>createTreeWalker</span><span>.</span><span>bind</span><span>(</span><span>document</span><span>)</span><span>,</span>
      <span>}</span><span>,</span>
  <span>element</span><span>:</span> <span>{</span>
    <span>value</span><span>(</span><span>elem</span><span>)</span> <span>{</span> <span>return</span> <span>elem</span><span>.</span><span>value</span><span>;</span> <span>}</span><span>,</span>
    <span>setValue</span><span>(</span><span>elem</span><span>,</span> <span>value</span><span>)</span> <span>{</span> <span>elem</span><span>.</span><span>value</span> <span>=</span> <span>value</span><span>;</span> <span>}</span><span>,</span>
    <span>checked</span><span>(</span><span>elem</span><span>)</span> <span>{</span> <span>return</span> <span>elem</span><span>.</span><span>checked</span><span>;</span> <span>}</span><span>,</span>
    <span>setChecked</span><span>(</span><span>elem</span><span>,</span> <span>checked</span><span>)</span> <span>{</span> <span>elem</span><span>.</span><span>checked</span> <span>=</span> <span>(</span><span>checked</span> <span>=</span><span>=</span> <span>1</span><span>)</span><span>;</span> <span>}</span><span>,</span>
    <span>removeAttribute</span><span>(</span><span>elem</span><span>,</span> <span>name</span><span>)</span> <span>{</span> <span>elem</span><span>.</span><span>removeAttribute</span><span>(</span><span>name</span><span>)</span><span>;</span> <span>}</span><span>,</span>
    <span>removeEventListener</span><span>(</span><span>elem</span><span>,</span> <span>name</span><span>,</span> <span>f</span><span>)</span> <span>{</span> <span>elem</span><span>.</span><span>removeEventListener</span><span>(</span><span>name</span><span>,</span> <span>f</span><span>)</span><span>;</span> <span>}</span><span>,</span>
      <span>}</span><span>,</span>
  <span>treeWalker</span><span>:</span> <span>{</span>
    <span>currentNode</span><span>(</span><span>walker</span><span>)</span> <span>{</span> <span>return</span> <span>walker</span><span>.</span><span>currentNode</span><span>;</span> <span>}</span><span>,</span>
    <span>setCurrentNode</span><span>(</span><span>walker</span><span>,</span> <span>node</span><span>)</span> <span>{</span> <span>walker</span><span>.</span><span>currentNode</span> <span>=</span> <span>node</span><span>;</span> <span>}</span><span>,</span>
    <span>nextNode</span><span>(</span><span>walker</span><span>)</span> <span>{</span> <span>return</span> <span>walker</span><span>.</span><span>nextNode</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>,</span>
    <span>firstChild</span><span>(</span><span>walker</span><span>)</span> <span>{</span> <span>return</span> <span>walker</span><span>.</span><span>firstChild</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>,</span>
    <span>nextSibling</span><span>(</span><span>walker</span><span>)</span> <span>{</span> <span>return</span> <span>walker</span><span>.</span><span>nextSibling</span><span>(</span><span>)</span><span>;</span> <span>}</span>
  <span>}</span><span>,</span>
  <span>event</span><span>:</span> <span>{</span>
    <span>target</span><span>(</span><span>event</span><span>)</span> <span>{</span> <span>return</span> <span>event</span><span>.</span><span>target</span><span>;</span> <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<p>Now we can implement the diffing algorithm.  Below is an abridged
version, but you can see the beautiful, fully-fledged source code on
<a href="https://codeberg.org/spritely/hoot-ffi-demo/src/branch/main/todo.scm">Codeberg</a>:</p>
<pre><code infostring="scheme"><span>(</span><span>define</span> <span>(</span><span>virtual-dom-render</span> <span>root</span> <span>old</span> <span>new</span><span>)</span>
    <span>(</span><span>let</span> <span>(</span><span>(</span><span>walker</span> <span>(</span><span>make-tree-walker</span> <span>root</span><span>)</span><span>)</span><span>)</span>
    <span>(</span><span>first-child!</span> <span>walker</span><span>)</span>
    <span>(</span><span>let</span> <span>loop</span> <span>(</span><span>(</span><span>parent</span> <span>root</span><span>)</span>
               <span>(</span><span>old</span> <span>old</span><span>)</span>
               <span>(</span><span>new</span> <span>new</span><span>)</span><span>)</span>
      <span>(</span><span>match</span> <span>old</span>
        <span>(</span><span>#f</span>
                                    <span>(</span><span>let</span> <span>loop</span> <span>(</span><span>(</span><span>node</span> <span>(</span><span>current-node</span> <span>walker</span><span>)</span><span>)</span><span>)</span>
           <span>(</span><span>unless</span> <span>(</span><span>external-null?</span> <span>node</span><span>)</span>
             <span>(</span><span>let</span> <span>(</span><span>(</span><span>next</span> <span>(</span><span>next-sibling!</span> <span>walker</span><span>)</span><span>)</span><span>)</span>
               <span>(</span><span>remove!</span> <span>node</span><span>)</span>
               <span>(</span><span>loop</span> <span>next</span><span>)</span><span>)</span><span>)</span><span>)</span>
         <span>(</span><span>append-child!</span> <span>parent</span> <span>(</span><span>sxml-&gt;dom</span> <span>new</span><span>)</span><span>)</span><span>)</span>
        <span>(</span><span>(</span><span>?</span> <span>string?</span><span>)</span>
                                    <span>(</span><span>unless</span> <span>(</span><span>and</span> <span>(</span><span>string?</span> <span>new</span><span>)</span> <span>(</span><span>string-=?</span> <span>old</span> <span>new</span><span>)</span><span>)</span>
           <span>(</span><span>let</span> <span>(</span><span>(</span><span>new-node</span> <span>(</span><span>sxml-&gt;dom</span> <span>new</span><span>)</span><span>)</span><span>)</span>
             <span>(</span><span>replace-with!</span> <span>(</span><span>current-node</span> <span>walker</span><span>)</span> <span>new-node</span><span>)</span>
             <span>(</span><span>set-current-node!</span> <span>walker</span> <span>new-node</span><span>)</span><span>)</span><span>)</span><span>)</span>
        <span>(</span><span>(</span><span>(</span><span>?</span> <span>symbol?</span> <span>old-tag</span><span>)</span> <span>.</span> <span>old-rest</span><span>)</span>
         <span>(</span><span>let-values</span> <span>(</span><span>(</span><span>(</span><span>old-attrs</span> <span>old-children</span><span>)</span>
                       <span>(</span><span>attrs+children</span> <span>old-rest</span><span>)</span><span>)</span><span>)</span>
           <span>(</span><span>match</span> <span>new</span>
             <span>(</span><span>(</span><span>?</span> <span>string?</span><span>)</span>
                                                        <span>(</span><span>let</span> <span>(</span><span>(</span><span>new-text</span> <span>(</span><span>make-text-node</span> <span>new</span><span>)</span><span>)</span><span>)</span>
                <span>(</span><span>replace-with!</span> <span>(</span><span>current-node</span> <span>walker</span><span>)</span> <span>new-text</span><span>)</span>
                <span>(</span><span>set-current-node!</span> <span>walker</span> <span>new-text</span><span>)</span><span>)</span><span>)</span>
             <span>(</span><span>(</span><span>(</span><span>?</span> <span>symbol?</span> <span>new-tag</span><span>)</span> <span>.</span> <span>new-rest</span><span>)</span>
              <span>(</span><span>let-values</span> <span>(</span><span>(</span><span>(</span><span>new-attrs</span> <span>new-children</span><span>)</span>
                            <span>(</span><span>attrs+children</span> <span>new-rest</span><span>)</span><span>)</span><span>)</span>
                <span>(</span><span>cond</span>
                                                   <span>(</span><span>(</span><span>eq?</span> <span>old-tag</span> <span>new-tag</span><span>)</span>
                  <span>(</span><span>let</span> <span>(</span><span>(</span><span>parent</span> <span>(</span><span>current-node</span> <span>walker</span><span>)</span><span>)</span><span>)</span>
                    <span>(</span><span>update-attrs</span> <span>parent</span> <span>old-attrs</span> <span>new-attrs</span><span>)</span>
                    <span>(</span><span>first-child!</span> <span>walker</span><span>)</span>
                    <span>(</span><span>let</span> <span>child-loop</span> <span>(</span><span>(</span><span>old</span> <span>old-children</span><span>)</span>
                                     <span>(</span><span>new</span> <span>new-children</span><span>)</span><span>)</span>
                      <span>(</span><span>match</span> <span>old</span>
                        <span>(</span><span>(</span><span>)</span>
                                                                                                                             <span>(</span><span>for-each</span>
                          <span>(</span><span>lambda</span> <span>(</span><span>new</span><span>)</span>
                            <span>(</span><span>append-child!</span> <span>parent</span> <span>(</span><span>sxml-&gt;dom</span> <span>new</span><span>)</span><span>)</span><span>)</span>
                          <span>new</span><span>)</span><span>)</span>
                        <span>(</span><span>(</span><span>old-child</span> <span>.</span> <span>old-rest</span><span>)</span>
                         <span>(</span><span>match</span> <span>new</span>
                                                                                                                                       <span>(</span><span>(</span><span>)</span>
                            <span>(</span><span>let</span> <span>rem-loop</span> <span>(</span><span>(</span><span>node</span> <span>(</span><span>current-node</span> <span>walker</span><span>)</span><span>)</span><span>)</span>
                              <span>(</span><span>unless</span> <span>(</span><span>external-null?</span> <span>node</span><span>)</span>
                                <span>(</span><span>let</span> <span>(</span><span>(</span><span>next</span> <span>(</span><span>next-sibling!</span> <span>walker</span><span>)</span><span>)</span><span>)</span>
                                  <span>(</span><span>remove!</span> <span>node</span><span>)</span>
                                  <span>(</span><span>rem-loop</span> <span>next</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
                                                                                 <span>(</span><span>(</span><span>new-child</span> <span>.</span> <span>new-rest</span><span>)</span>
                            <span>(</span><span>loop</span> <span>parent</span> <span>old-child</span> <span>new-child</span><span>)</span>
                            <span>(</span><span>next-sibling!</span> <span>walker</span><span>)</span>
                            <span>(</span><span>child-loop</span> <span>old-rest</span> <span>new-rest</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
                    <span>(</span><span>set-current-node!</span> <span>walker</span> <span>parent</span><span>)</span><span>)</span><span>)</span>
                                                   <span>(</span><span>else</span>
                  <span>(</span><span>replace-with!</span> <span>(</span><span>current-node</span> <span>walker</span><span>)</span>
                                 <span>(</span><span>sxml-&gt;dom</span> <span>new</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<p>Now, instead of deleting and recreating every single element on the
DOM tree to update the text for the counter, we can call the
<code>virtual-dom-render</code> procedure and it will replace just one text node
instead.</p>
<pre><code infostring="scheme"><span>(</span><span>define</span> <span>*current-vdom*</span> <span>#f</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>render</span><span>)</span>
  <span>(</span><span>let</span> <span>(</span><span>(</span><span>new-vdom</span> <span>(</span><span>template</span><span>)</span><span>)</span><span>)</span>
    <span>(</span><span>virtual-dom-render</span> <span>(</span><span>document-body</span><span>)</span> <span>*current-vdom*</span> <span>new-vdom</span><span>)</span>
    <span>(</span><span>set!</span> <span>*current-vdom*</span> <span>new-vdom</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<h2>To-do app</h2>
<p>Let&#39;s wrap things up with our take on a classic: the to-do list.</p>
<p><img src="https://files.spritely.institute/images/blog/hoot-ffi-todo.png" alt="A to-do list application inside a web browser."/></p>
<p>The humble to-do list is often used as a &#34;Hello, world&#34; of sorts for
client-side UI libraries (there&#39;s even <a href="https://todomvc.com/">an entire
website</a> dedicated to them).</p>
<p>A to-do list has many tasks.  Tasks have a name and a flag indicating
if the task has been completed.  We&#39;ll use Scheme&#39;s
<code>define-record-type</code> to encapsulate a task:</p>
<pre><code infostring="scheme"><span>(</span><span>define-record-type</span> <span>&lt;task&gt;</span>
  <span>(</span><span>make-task</span> <span>name</span> <span>done?</span><span>)</span>
  <span>task?</span>
  <span>(</span><span>name</span> <span>task-name</span><span>)</span>
  <span>(</span><span>done?</span> <span>task-done?</span> <span>set-task-done!</span><span>)</span><span>)</span>
</code></pre>
<p>Tasks can be created and deleted.  We&#39;ll use a bit of global state for
managing the task list as a substitute for actual persistent storage:</p>
<pre><code infostring="scheme"><span>(</span><span>define</span> <span>*tasks*</span> <span>&#39;</span><span>(</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>add-task!</span> <span>task</span><span>)</span>
  <span>(</span><span>set!</span> <span>*tasks*</span> <span>(</span><span>cons</span> <span>task</span> <span>*tasks*</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>remove-task!</span> <span>task</span><span>)</span>
  <span>(</span><span>set!</span> <span>*tasks*</span> <span>(</span><span>delq</span> <span>task</span> <span>*tasks*</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<p>Now we can define a template for rendering the UI:</p>
<pre><code infostring="scheme"><span>(</span><span>define</span> <span>(</span><span>template</span><span>)</span>
  <span>(</span><span>define</span> <span>(</span><span>task-template</span> <span>task</span><span>)</span>
    <span>`</span><span>(</span><span>li</span> <span>(</span><span>input</span> <span>(</span><span>@</span> <span>(</span><span>type</span> <span>&#34;checkbox&#34;</span><span>)</span>
                                      <span>(</span><span>change</span> <span>,</span><span>(</span><span>lambda</span> <span>(</span><span>event</span><span>)</span>
                              <span>(</span><span>let*</span> <span>(</span><span>(</span><span>checkbox</span> <span>(</span><span>event-target</span> <span>event</span><span>)</span><span>)</span>
                                     <span>(</span><span>checked?</span> <span>(</span><span>element-checked?</span> <span>checkbox</span><span>)</span><span>)</span><span>)</span>
                                <span>(</span><span>set-task-done!</span> <span>task</span> <span>checked?</span><span>)</span>
                                <span>(</span><span>render</span><span>)</span><span>)</span><span>)</span><span>)</span>
                                      <span>(</span><span>checked</span> <span>,</span><span>(</span><span>task-done?</span> <span>task</span><span>)</span><span>)</span><span>)</span><span>)</span>
         <span>(</span><span>span</span> <span>(</span><span>@</span> <span>(</span><span>style</span> <span>&#34;padding: 0 1em 0 1em;&#34;</span><span>)</span><span>)</span>
                              <span>,</span><span>(</span><span>if</span> <span>(</span><span>task-done?</span> <span>task</span><span>)</span>
                    <span>`</span><span>(</span><span>s</span> <span>,</span><span>(</span><span>task-name</span> <span>task</span><span>)</span><span>)</span>
                    <span>(</span><span>task-name</span> <span>task</span><span>)</span><span>)</span><span>)</span>
         <span>(</span><span>a</span> <span>(</span><span>@</span> <span>(</span><span>href</span> <span>&#34;#&#34;</span><span>)</span>
                              <span>(</span><span>click</span> <span>,</span><span>(</span><span>lambda</span> <span>(</span><span>event</span><span>)</span>
                         <span>(</span><span>remove-task!</span> <span>task</span><span>)</span>
                         <span>(</span><span>render</span><span>)</span><span>)</span><span>)</span><span>)</span>
            <span>&#34;remove&#34;</span><span>)</span><span>)</span><span>)</span>
  <span>`</span><span>(</span><span>div</span>
    <span>(</span><span>h2</span> <span>&#34;Tasks&#34;</span><span>)</span>
        <span>(</span><span>ul</span> <span>,@</span><span>(</span><span>map</span> <span>task-template</span> <span>(</span><span>reverse</span> <span>*tasks*</span><span>)</span><span>)</span><span>)</span>
    <span>(</span><span>input</span> <span>(</span><span>@</span> <span>(</span><span>id</span> <span>&#34;new-task&#34;</span><span>)</span>
              <span>(</span><span>placeholder</span> <span>&#34;Write more Scheme&#34;</span><span>)</span><span>)</span><span>)</span>
        <span>(</span><span>button</span> <span>(</span><span>@</span> <span>(</span><span>click</span> <span>,</span><span>(</span><span>lambda</span> <span>(</span><span>event</span><span>)</span>
                         <span>(</span><span>let*</span> <span>(</span><span>(</span><span>input</span> <span>(</span><span>get-element-by-id</span> <span>&#34;new-task&#34;</span><span>)</span><span>)</span>
                                <span>(</span><span>name</span> <span>(</span><span>element-value</span> <span>input</span><span>)</span><span>)</span><span>)</span>
                           <span>(</span><span>unless</span> <span>(</span><span>string-=?</span> <span>name</span> <span>&#34;&#34;</span><span>)</span>
                             <span>(</span><span>add-task!</span> <span>(</span><span>make-task</span> <span>name</span> <span>#f</span><span>)</span><span>)</span>
                             <span>(</span><span>set-element-value!</span> <span>input</span> <span>&#34;&#34;</span><span>)</span>
                             <span>(</span><span>render</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
            <span>&#34;Add task&#34;</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<p>For this final example, we&#39;ve embedded the result in an iframe below.
This requires a browser capable of Wasm GC and tail calls, such as
Chrome 119 or Firefox 121:</p>

<p>It should be said that a React-like virtual DOM isn&#39;t necessarily the
best way to implement a UI layer.  We like how the abstraction turns
the state of the UI into a function mapping application state to HTML
elements, as it avoids an entire class of synchronization bugs that
impact more imperative approaches.  That said, the overhead introduced
by a virtual DOM is not always acceptable.  Simple web pages are
better off with little to no client-side code so that they are more
usable on low power devices.  Still, a to-do application with a
virtual DOM diffing algorithm is a neat yet familiar way to show off
the expressive power of Hoot and its FFI.</p>
<h2>Looking forward</h2>
<p>With the introduction of an FFI, you can now implement nearly your
entire web frontend in Scheme; the examples we&#39;ve looked at today are
but a glimpse of what&#39;s now possible!</p>
<p>In the future, we hope the Guile community will join us in developing
a colorful variety of wrapper libraries for commonly-used web APIs, so
that building with Hoot becomes increasingly fun and easy.</p>
<p>If you&#39;d like to start playing around with the demos today, you can
find the complete source code <a href="https://codeberg.org/spritely/hoot-ffi-demo">on
Codeberg</a>.</p>
<p>To see everything that&#39;s new in Hoot 0.2.0, be sure to check out our
<a href="https://spritely.institute/news/guile-hoot-v020-released.html">release announcement post</a>!</p>
</article></section></div></div>
  </body>
</html>
