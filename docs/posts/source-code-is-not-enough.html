<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fuzzypixelz.com/blog/source-code-is-not-enough/">Original</a>
    <h1>Source code is not enough</h1>
    
    <div id="readability-page-1" class="page"><article id="blog-page-article">
<h2 id="premise">Premise</h2>
<blockquote>
<p>A program is free software if the program&#39;s users have the four essential
freedoms:</p>
<ol>
<li>The freedom to run the program as you wish, for any purpose (freedom 0).</li>
<li>The freedom to study how the program works, and change it so it does your
computing as you wish (freedom 1). Access to the source code is a
precondition for this.</li>
<li>The freedom to redistribute copies so you can help others (freedom 2).</li>
<li>The freedom to distribute copies of your modified versions to others (freedom
3). By doing this you can give the whole community a chance to benefit from
your changes. Access to the source code is a precondition for this.</li>
</ol>
<p>— <strong>What is Free Software?</strong>, <a href="https://www.gnu.org/philosophy/free-sw.en.html">gnu.org</a></p>
</blockquote>
<p>People will often claim that since <code>X</code> is Free and Open Source Software, every
user of <code>X</code> is enabled to hack on it and bend it to their will.</p>
<p>I will argue that this is rarely the case; after so many hours of
doom-scrolling the orange website, the contrarian in me is finally taking over.</p>
<h2 id="cost-of-building-software">Cost of building software</h2>
<p>Aseprite is a popular sprite editing program. You can buy a copy of it on the
official website for $20 and get access to binaries for Windows, macOS, and
Ubuntu. The thing is, the source code for Aseprite is available on
<a href="https://github.com/aseprite/aseprite">GitHub</a> — released under <a href="https://raw.githubusercontent.com/aseprite/aseprite/main/EULA.txt">EULA for
Aseprite</a>
which disallows the re-distribution of the source code, among other things.</p>
<p>Still, you can just compile it from source! The developers were nice enough to
provide detailed, albeit quite involved, compilation
<a href="https://github.com/aseprite/aseprite/blob/main/INSTALL.md">instructions</a>. There
are even pre-built binary releases of their fork of Skia, which Aseprite depends
on; without which you would&#39;ve had to go through the trouble of building Skia
too.</p>
<p>If you enjoy watching processors churn out machine code you might be wondering:
what&#39;s the catch? After all, you can even tweak the source code a little before
running <code>ninja</code>.</p>
<blockquote>
<p>You may only compile and modify the source code of the SOFTWARE PRODUCT for
your own personal purpose or to propose a contribution to the SOFTWARE
PRODUCT. </p>
<p>— END-USER LICENSE AGREEMENT FOR ASEPRITE</p>
</blockquote>
<p>Well, it turns out that building software isn&#39;t completely painless. Here&#39;s a
list of potential issues you might encounter:</p>
<ul>
<li>Inability to satisfy build dependencies because your system is too old or too new.</li>
<li>Abhorrent compile times on older and cheaper hardware.</li>
<li>Hard to debug build failures because &#34;works on my machine&#34; only concerns the
developer&#39;s local environment.</li>
</ul>
<p>Not only that, but you will deal with these issues every time there is a new Aseprite
version, and every time you decide to move to another system.</p>
<p>Suddenly, having someone else take care of this mess sounds like a good
idea. That&#39;s probably why most Aseprite users go this route.</p>
<p>There is a cost associated with building Aseprite, whether you know what
<code>ninja</code> is or not; freedom (1) doesn&#39;t attenuate this burden. Granted, if you
had freedoms (3) and (4) you could&#39;ve made use of an economy of scale, serving
many users automatic builds for a much smaller cost. But the cost is still
non-zero nonetheless. And that&#39;s an opportunity to sell a service. The Aseprite
developers decided to reserve the right to sell said service, that is their
business model and is well within their legal rights. I am not making a moral
judgment here.</p>
<h2 id="where-is-the-heckin-manual">Where is the Heckin&#39; Manual?</h2>
<p>When was the last time you took a tour inside Linux, Chromium, LLVM, or VS Code?
It&#39;s nice that these titans are Free and Open Source Software, but their
codebases are unapproachable to a casual user. Even with knowledge of the
domain, potential hackers will need to make their way through layers of
cleverness, accidental complexity, and technical debt before making that small
change.</p>
<p>VS Code is open-source software. Nobody cares. Everyone uses the plugin interface
designed to extend the editor in well-defined ways. That&#39;s why you never see
drastic changes to its UI like you would in Emacs — and that might even be a good
thing. Point is, the rest of the codebase isn&#39;t designed to be hackable, and so
very few people will actually attempt to hack on it.</p>
<p>I will be taking the venerable Arthur Whitney as my scapegoat here. When Arthur
was only 11, he was introduced to the irredeemably terse APL programming
language by Ken Iverson himself. This might have contributed to what people call
&#34;Arthur Style&#34; — a tendency to fit as many symbols as possible onto the screen
at once, so that you may reason about all of it simultaneously.</p>
<p>I came across <a href="https://github.com/tlack/b-decoded">several</a>
<a href="https://docs.google.com/document/d/1W83ME5JecI2hd5hAUqQ1BVF32wtCel8zxb7WPq-D4f8/edit">attempts</a>
at <em>deciphering</em> Arthur&#39;s <code>b</code> programming language. In the words of the author <code>b</code> is fast,
interactive, and isomorphic to C.</p>
<table><thead><tr><th><img src="https://fuzzypixelz.com/images/b_compiler.png" alt="b.c"/></th></tr></thead><tbody>
<tr><td><code>b.c</code>: Almost all the C source code of the <code>b</code> interpreter; the file only spans 55 lines.</td></tr>
</tbody></table>
<p>The above code contains exactly one comment which reads:</p>
<pre data-lang="c"><code data-lang="c">// :+-*% ^&amp;|&lt;=&gt;  x64 JJ Jj o2 cc tst RET cll psh pop acdbsbsd89.. \
o[m[s|d]] c3 eb+1 e8+4 e9+4 [f2/66/4*][0f] 5* 7*+1 b*+4 0f8*+4 \
03 23 2b 3b (6b 83) 89 8b ..
</code></pre>
<p>Need I say more?</p>
<p><code>b</code> is an extreme example of an inaccessible FOSS project. However, this little
anecdote raises valid concerns: what if the documentation of an open-source
codebase is scarce or (in this case) non-existent? What if the algorithms and
data structures are so complex that understanding them through source code is no
better than observing them through machine code? Because then you might as well
reverse-engineer the whole thing!</p>
<p>The Free Software Foundation considers obfuscated JavaScript blobs to be unfree,
even though they are source code. As long as we&#39;re being whiny hackers, why not
go the extra mile and declare all unreadable code unfree? Where exactly would
you draw the line here?</p>
<p>If the issue with a binary blob (that you&#39;re legally allowed to modify, run and
redistribute) is that it&#39;s hard to decipher, then any sufficiently complex and
unapproachable FOSS program is equally unfree.</p>
<h2 id="upstream-has-the-high-ground">Upstream has the high ground</h2>
<p>The amount of resources needed to maintain a fork of a FOSS project is roughly
proportional to the amount of effort put into the main project. A handful of
developers cannot play catch-up with a fast-moving upstream.</p>
<p>A good example of this is what I like to call &#34;The Tragedy of <code>llvm-hs</code> The
Complete&#34;. In a nutshell, LLVM is a C++ codebase by default, and only wraps
<em>some</em> of its C++ API in the official C API. Consequently, the Haskell people
had taken on the brave task of implementing some features which were missing in
the C API. Needless to say, this is an enormous maintenance burden.</p>
<blockquote>
<p>Since anyone last touched our FFI layer, the LLVM C API has been updated
significantly. Most importantly, the LLVM C API now has functions which do
things for which we have hand-rolled code in our FFI.</p>
<p>Where the LLVM C API now has a function that does something, and we have
hand-rolled code that does something, we should remove our hand-rolled code
and instead call the LLVM C API function.</p>
<p>This is quite a large undertaking, effectively being an audit of the entire
FFI layer. However, it can be done piecewise, module-by-module.</p>
<p>— @andrew-wja&#39;s <a href="https://github.com/llvm-hs/llvm-hs/issues/358">PR358</a> on
<code>llvm-hs</code>, August 2021</p>
</blockquote>
<p>This is very unfortunate. It&#39;s the reason why Hackage still distributes bindings
for LLVM 9 which was released back in 2019. Meanwhile, the <code>llvm-hs</code> project is
busy trying to roll out support for LLVM 12.</p>
<p>At the time of writing, the latest LLVM release is <code>15.0.3</code>. This is a case where
downstream doesn&#39;t have enough resources to maintain non-trivial modifications
to a giant upstream project, let alone influence its development.</p>
<h2 id="truly-free-software">Truly Free Software</h2>
<p>A true definition of free software would also include the freedom <em>from</em>
tinkering with source code. A truly free program would be designed from the
ground up with customizability and extensibility in mind, through an interface
accessible to regular users, not just developers. </p>
<p>A truly free program would be independently audited for security and
privacy. Knowing that their programs were verified not to perform arbitrary
instructions would put users at ease. Such a practice could be enforced through
regulation.</p>
<p>Requiring that the source code be public doesn&#39;t guarantee that it will be
checked for security and privacy let alone for good engineering practices. The
fact that most free software is privacy-respecting is due to cultural
circumstances and the personal views of its developers, and <em>not</em> a binding contract.</p>
<p><strong>Join the TFS Foundation today.</strong></p>
<p>Just kidding.</p>
<hr/>



</article></div>
  </body>
</html>
