<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://goto.ucsd.edu/~ucsdpl-blog/liquidtypes/2015/09/19/liquid-types/">Original</a>
    <h1>A Gentle Introduction to Liquid Types</h1>
    
    <div id="readability-page-1" class="page"><div>
    
<p>Type systems have been successfully used to statically catch errors,
like dividing an integer with a boolean.  Still, well typed programs
<em>can</em> go wrong, for example, with a division by zero resulting in a
run-time exception!</p>

<p>Liquid Types enrich existing type systems with <em>logical predicates</em>
and let you specify and automatically verify <em>semantic</em> properties of your code.</p>

<p><img src="http://goto.ucsd.edu/~nvazou/liquid.jpg" title="Liquid Types"/> 
</p>

<!--break-->

<h2 id="structural-vs-semantics-properties">Structural vs. Semantics Properties</h2>

<p>Most type systems reason about the <em>structure</em> of program values.
integers and booleans have different structure, i.e., they are usually
internally represented in different ways and they can be used with a
different set of operations: integers can be divided and booleans can
be conjuncted.</p>

<p>Other than the structure, values also have <em>semantics</em>.  Liquid Types
enrich existing type systems with <em>logical predicates</em> and let you
specify semantic properties of values.  For example, the Int type, can
be refined with logical predicates to describe integer values
different than <code>0</code>:</p>

<pre><code>{v:Int | v /= 0}
</code></pre>

<p>or natural numbers:</p>

<pre><code>{v:Int | v &gt;= 0}
</code></pre>

<p>Since with Liquid Types we are able to talk about semantics of values,
we can also statically
catch semantic type errors, like division by zero.</p>

<h2 id="tracking-division-by-zero-by-specifications">Tracking division by zero by Specifications</h2>

<p>A type for the divisor operator states that given two integers, you
will get back an integer.</p>

<pre><code>div :: Int -&gt; Int -&gt; Int
</code></pre>

<p>This type effectively specifies the <em>structure</em> of the operator.  If
your program compiles you can rest assured that all the arguments to
<code>div</code> are integers and not, say, booleans.</p>

<p>Using Liquid Types we can refine the above type to describe <em>semantic</em> properties
of the operator, specifically that the divisor should never be <code>0</code>.</p>

<pre><code>div :: Int -&gt; {v:Int | v /= 0} -&gt; Int
</code></pre>

<p>The above type provides a <em>specification</em> for the <code>div</code> operator.  If
your program liquid-typechecks, the system has <em>verified</em> that the
second argument of <code>div</code> is different than <code>0</code>, thus no
division-by-zero run-time exception will ever occur.  Next let’s see how
this verification happens.</p>

<h2 id="verification-of-specifications">Verification of Specifications</h2>


<p><em>Verification</em> is a process that given your code and some specifications,
here in the form of liquid-type signatures, decides whether the code satisfies the specifications.</p>

<p>Consider three uses of the <code>div</code> operator, the <code>good</code>, the <code>bad</code>, and the <code>impr</code>ecise:</p>

<pre><code>good = div 42 one  -- OK
bad  = div 42 zero -- type error
impr = div 42 nat  -- type error

one  :: { v:Int | 0 &lt; v  }
one  = 1

zero :: { v:Int | 0 == v }
zero = 0

nat  :: { v:Int | 0 &lt;= v }
nat  = 42
</code></pre>

<p>Verification will decide that only <code>good</code> is a good use of <code>div</code>, as follows.</p>

<p><em>First</em>, it fires <em>subtyping</em> queries.
<code>t1</code> is a subtype of <code>t2</code>, written <code>t1 &lt;: t2</code> <em>iff</em>
each expression that has type <code>t1</code> also has type <code>t2</code>.</p>

<p>In our case, subtyping will check that at each call of <code>div</code>
the type of the divisor, is a subtype of the second argument of
the specification, namely <code>{v:Int | v /= 0}</code>.
For example, <code>good</code> will fire the following subtyping query:</p>

<pre><code>{v:Int | 0 &lt; v} &lt;: {v:Int | 0 /= v}
</code></pre>

<p><em>Then</em>, subtyping queries are discharged, via implication checking.
<code>{v:Int | p } &lt;: {v:Int | q }</code> holds if <code>p ⟹ q</code>. For example:</p>

<pre><code>{v:Int | 0 &lt; v} &lt;: {v:Int | 0 /= v}
</code></pre>

<p>⬄</p>

<pre><code>∀ v. 0 &lt; v ⟹ 0 ≠ v</code></pre>

<p>Thus, verification of <code>good</code> succeeds as <code>0 &lt; v ⟹ 0
≠ v</code>, but verification of <code>bad</code> and <code>impr</code> fails as neither
<code>0 = v ⟹ 0 ≠ v</code>, nor <code>0 ≤
v ⟹ 0 ≠ v</code>.</p>

<p>Note that types provide an <em>abstraction</em> of your program.
When we defined <code>nat</code> we abstracted the value <code>42</code> as a natural number,
<code>nat :: {v:Int | 0 &lt;= v}</code>.
This is a proper specification for <code>42</code> but imprecise, as it misses the information
that <code>42</code> is not <code>0</code>, thus it is a good divisor.
In short, our analysis is <em>not complete</em> in that it may create type errors
that are not true errors.
On the good side, our analysis is <em>sound</em> in that if it says <code>OK</code>
there cannot be a violation of a specification.</p>

<h2 id="the-liquid-story-further-reading">The Liquid Story (Further Reading)</h2>

<p>Liquid Types (<em>Logically Qualified Data Types</em>) were
<a href="http://goto.ucsd.edu/~rjhala/liquid/liquid_types.pdf">introduced</a> in 2008
by Rondon, Kawaguchi and Jhala at the ProgSys groups of UCSD.
Since then they have been used to specify and verify
<a href="http://goto.ucsd.edu/~rjhala/papers/safety_verification_with_liquid_types.pdf">ML</a>,
<a href="http://goto.ucsd.edu/~rjhala/papers/deterministic_parallelism_via_liquid_effects.pdf">C</a>, and
<a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/about/">Haskell</a>.</p>

<p>Liquid Types are
<a href="https://en.wikipedia.org/wiki/Dependent_type">dependent types</a>,
i.e., types that depend on <em>arbitrary program expressions</em> like the ones we see in
<a href="https://en.wikipedia.org/wiki/Coq">Coq</a>,
<a href="https://en.wikipedia.org/wiki/Agda_(programming_language)">Agda</a>, etc.</p>

<p>Liquid Types are refinement types,
that is types that are refined with logical predicates that
cannot be <em>arbitrary</em> expressions (like dependent types)
but are expressions drawn from a <em>sublanguage</em>.
Example of refinement type systems include
<a href="http://www.cs.bu.edu/~hwxi/DML/DML.html">DML</a>,
<a href="https://sage.soe.ucsc.edu/">Sage</a>,
<a href="http://research.microsoft.com/en-us/projects/fstar/">F*</a>, etc.</p>

<p>Liquid Types are a constraint form of refinement types
in that logical predicates come from a <em>decidable</em> sublanguage,
that is a logical language for which implication checking is decidable.
Examples of such decidable languages are
quantifier-free theories as arrays, integer linear, set theory etc.</p>

<p>On one hand, the decidable constraint allows us to predictably use
<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT</a>
solvers to decide implication checking.
As we discussed <a href="#verification">earlier</a>,
type checking reduces to implication checking,
thus liquid types allow decidable type checking, and type inference!</p>

<p>On the other hand, the decidable constraint syntactically restricts the specification language.
What kind of specifications can be expressed using a decidable logic?
This is still an open question,
but using tricks like
<a href="http://goto.ucsd.edu/~rjhala/liquid/abstract_refinement_types.pdf">Abstract</a>
or
<a href="http://goto.ucsd.edu/~nvazou/icfp15/main.pdf">Bounded</a>
Refinement Types we can express sophisticated properties
using only decidable logics.</p>

<h2 id="in-few-words">In few words</h2>

<p>Liquid Types provide a means to <em>specify</em> and <em>automatically verify</em>
semantic properties of your code.
They are a constraint form of dependent types
where the specification language is decidable
thus leading to a highly automated type system with low requirement of
type annotations.</p>

    </div></div>
  </body>
</html>
