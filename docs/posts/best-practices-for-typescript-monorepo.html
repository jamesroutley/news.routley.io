<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.flycode.com/best-practices-for-typescript-monorepo">Original</a>
    <h1>Best practices for TypeScript monorepo</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-wrapper"><p>Managing dependencies of multiple projects across multiple repositories can be time-consuming and error-prone. A monorepo, on the other hand, is a code management or architectural concept that consolidates all the isolated codebases of multiple projects into a single mega repository rather than managing them individually. Monorepos can be advantageous when used with the proper tools. Hence, many organizations have adopted the strategy of maintaining several projects in a single repository.</p>
<p>Large corporations such as Google, Meta, and Microsoft often manage the codebases of multiple projects within the organization in a single monorepo. This approach enables them to share dependencies, libraries, components, utilities, docs, e.t.c. between projects. Sharing code between projects ensures uniformity and predictability in the codebase. However, dependency management is where the real power lies. In the event that somebody makes a breaking change to a shared library, all affected applications will receive that update immediately.</p>
<p>Although monorepos do come with their own set of challenges, they also offer a number of benefits with the right tool. One of those tools is Typescript, and in this post, we will be looking at best practices for managing a Typescript monorepo.</p>
<h2 id="heading-using-typescript-project-references">Using TypeScript Project References</h2>
<p>The main goal of the development of TypeScript project references was always to assist solve the issue of long compilation times in big TypeScript projects such as a monorepo. They make it possible to divide a huge project into several smaller modules that may all be independently built. Additionally, it enables the creation of more modular code. With this approach, build times can be greatly improved, components can be logically separated, and your code can be reorganized in a more organized and logical manner.</p>
<p>Visit the <a target="_blank" href="https://www.typescriptlang.org/docs/handbook/project-references.html">Docs</a> to learn more about TypeScropt Project Reference.</p>
<h2 id="heading-managing-packages-that-depend-on-other-packages">Managing Packages that Depend on Other Packages</h2>
<p>When working on multiple packages that depend on another package in a Typescript monorepo, you have to explicitly let Typescript know of this dependency. For example, <a href="https://hashnode.com/@projectName" target="_blank" rel="noopener">@projectName</a>/package-A depends on <a href="https://hashnode.com/@projectName" target="_blank" rel="noopener">@projectName</a>/package-B. We need to add the following steps to let Typescrip know about this dependency.</p>
<p>First, you have to add this in the tsconfig of the first package.</p>
<pre><code>
{
    <span>&#34;extends&#34;</span>: <span>&#34;../../tsconfig.json&#34;</span>,
    <span>&#34;compilerOptions&#34;</span>: {
      <span>&#34;outDir&#34;</span>: <span>&#34;./dist&#34;</span>,
      <span>&#34;composite&#34;</span>: <span>true</span>
    },
    <span>&#34;include&#34;</span>: [<span>&#34;./src&#34;</span>]
  }
</code></pre>
<p>The next step is to reference the package in package-a.</p>
<pre><code>{
  <span>&#34;extends&#34;</span>: <span>&#34;../../tsconfig.json&#34;</span>,
  <span>&#34;compilerOptions&#34;</span>: {
    <span>&#34;outDir&#34;</span>: <span>&#34;dist&#34;</span>,
    }
  },
  <span>&#34;include&#34;</span>: [<span>&#34;**/*.ts&#34;</span>, <span>&#34;**/*.tsx&#34;</span>],
  <span>&#34;exclude&#34;</span>: [<span>&#34;dist/*&#34;</span>],
  <span>&#34;references&#34;</span>: [{ <span>&#34;path&#34;</span>: <span>&#34;../package-b/tsconfig.json&#34;</span> }]
}
</code></pre>
<h2 id="heading-set-up-workspaces">Set Up Workspaces</h2>
<p>Workspaces are a concept found in yarn, NPM, and other tooling that can be used to give packages and apps in a monorepo repository their own workspace in the form of an organized and consistent folder structure. Large projects such as monorepos can benefit from workspaces for managing packages and dependencies.</p>
<p>In Yarn workspaces, it is possible to create projects such as:</p>
<pre><code>packages/  
  localPackageA/  
    package.json   
    ...  
  localPackageB/   
    package.json   
    ...
</code></pre>
<p>With Yarn Workspaces, installing packages across workspaces becomes faster and lighter. Additionally, it prevents package duplication across workspaces and also makes it possible to create links between directories that depend on each other, ensuring that all directories are consistent in the monorepo.</p>
<p>You can choose between <a target="_blank" href="https://classic.yarnpkg.com/lang/en/docs/workspaces/">yarn workspaces</a>, <a target="_blank" href="https://docs.npmjs.com/cli/v7/using-npm/workspaces">npm workspaces</a>, or <a target="_blank" href="https://pnpm.io/workspaces">pnpm workspaces</a>.</p>
<h2 id="heading-use-absolute-paths-for-importing-code-blocks"><strong>Use Absolute Paths for Importing Code Blocks</strong></h2>
<p>It is best practice to use absolute paths when importing code rather than long relative paths. This is important for code clarity because, as the codebase becomes larger, there will be more deeply nested folders and files, and importing them using their relative paths is one of the quickest ways to make a mess in a codebase, as this will make the code messy and unreadable. </p>
<p>Let&#39;s take a look at the example below.</p>
<pre><code><span>import</span> { FormType } <span>from</span> <span>&#39;../../../../types/form&#39;</span>;
<span>import</span> { DateType }   <span>from</span> <span>&#39;../../../../types/date&#39;</span>;


</code></pre>
<p>Looking at the code above, any developer assigned to work on this file will find it hard to know exactly which folder these code blocks—in this case, Types—were picked and imported from. So it is best to use an absolute path. Let&#39;s see a better example of the above code below:</p>
<pre><code><span>import</span> { FormType } <span>from</span> <span>&#39;utils/types/form&#39;</span>;
<span>import</span> { DateType }   <span>from</span> <span>&#39;utils/types/date&#39;</span>;


</code></pre>
<p>From the code above, the import is now clear, readable, and predictable, as the developers are aware of the exact folder where the piece of code being imported is coming from.</p>
<p>Using the absolute import method may be stressful as it involves more writing as opposed to adding dots and slashes till you get to your destination. However, it serves well in the long run when the codebase becomes larger with more folders and files.</p>
<p>There are tools that can help you achieve this; tools that will add a new resolver for your modules when your code is being compiled. One of those tools is the Babel Plugin Module Resolver, which you can read more about here: <a target="_blank" href="https://github.com/tleunen/babel-plugin-module-resolver#readme">Babel Plugin Module Resolver</a>.</p>
<h2 id="heading-prettier-and-eslint">Prettier and ESLint</h2>
<p>A large codebase with multiple projects that have multiple people working on them daily over a long period of time has the tendency to be inconsistent in coding style. Catching common errors during development should be considered a core part of a developer&#39;s work, silly and unintentional mistakes that might have passed the compiler test would get caught in the net of a linter such as Eslint, wrong file imports, unused variables <a href="http://e.tc" target="_blank">e.tc</a> to mention just a few, can be avoided if Eslint is used.</p>
<p>The use of Prettier and ESLint in a monorepo generally works well. With Prettier, you can maintain consistency in your formatting across all of your projects. Simply create a .prettierrc configuration file in the monorepo&#39;s root directory with your desired configuration settings and it will be applied to all packages in the monorepo automatically.</p>
<p>With ESLint, JavaScript or TypeScript source code can be analyzed in a sophisticated manner. As with Prettier, it can be configured as easy for monorepos. You simply define a .eslintrc.json configuration file in the main repository of the monorepo and it will apply to all projects.</p>
<p>However, if there are many files in the monorepo, Prettier or ESLint may take a very long time to run. This can be resolved by adding script definitions to a local package&#39;s package.json that reference the Prettier and ESLint configuration in the root of the project, so that Prettier and ESLint only run for specific packages.</p>
<h2 id="heading-using-turborepo">Using Turborepo</h2>
<p>There are several amazing tools to aid monorepos and ship with a smooth developer experience. One of those tools is <a target="_blank" href="https://turborepo.org/">Turborepo</a>, which is a powerful tool that aids in the development of high-quality and performant build systems in JavaScript and Typescript monorepos. It comes with advanced features, one of them being parallel execution.</p>
<p>When executing <code>npm run dev</code> or <code>yarn dev</code> from the root folder, it starts all of the projects available in the monorepo that have a <code>dev</code> script in their <code>package.json</code> file. The same thing applies when other commands such as  <code>npm run build</code>, <code>npm run lint</code>, <code>npm run start</code>. In Turborepo, you can achieve this by configuring the <code>package.json</code> file top-level folder:</p>
<pre><code><span>&#34;scripts&#34;</span>: {
  <span>&#34;dev&#34;</span>: <span>&#34;turbo run dev&#34;</span>,
  <span>&#34;lint&#34;</span>: <span>&#34;turbo run lint&#34;</span>,
  <span>&#34;build&#34;</span>: <span>&#34;turbo run build&#34;</span>,
  <span>&#34;clean&#34;</span>: <span>&#34;turbo run clean&#34;</span>,
  ...
},
<span>&#34;devDependencies&#34;</span>: {
  ...
  <span>&#34;turbo&#34;</span>: <span>&#34;latest&#34;</span>
}
</code></pre>
<p>Turborepo also comes with various tools and many other configurations that allow you to execute scripts in deeply nested workspaces in parallel by default or you can choose to do them by order or filter them.</p>
<pre><code><span>&#34;scripts&#34;</span>: {
  <span>&#34;dev&#34;</span>: <span>&#34;turbo run dev --filter=\&#34;docs\&#34;&#34;</span>,
  ...
},
</code></pre>
<p>Turborepo comes with an advanced remote caching feature, high-performant builds for files locally which is a default feature, and also for files remotely. You can choose to opt out of local caching at any time. </p>
<p>Furthermore, you can also create a monorepo pipeline for the execution of your scripts using Turborepo. You can check out Turborepo&#39;s documentation to learn more. There are other alternative tools like <a target="_blank" href="https://lerna.js.org/">Lerna</a> and <a target="_blank" href="https://nx.dev/">Nx</a> which you can use to achieve the same result.</p>

<p>Choosing the right build tools for the deployments of your monorepo is a very important decision and should be done carefully because, without efficient bundling, we can run into the issue of having to deploy all the code in the repository even if deployments should compose of only necessary source files.</p>
<p>Just as we used Jest, we can also employ the use of <a target="_blank" href="https://webpack.js.org/">Webpack</a> for bundling in a monorepo that can be configured to use Typescript references. This can be achieved by simply using <a target="_blank" href="https://webpack.js.org/guides/typescript/">ts-loader</a> and everything is set to work automatically.</p>
<p>There are also more tools to use, such as <a target="_blank" href="https://github.com/evanw/esbuild">esbuild</a>. Esbuild ships with TypeScript support by default and because of this it automatically resolves any local references because we already have TypeScript project references configured. You can also add additional configuration using the <code>@yarnpkg</code> <a target="_blank" href="https://github.com/yarnpkg/berry/tree/master/packages/esbuild-plugin-pnp">plugin</a>, this helps Esbuild resolve external dependencies from the local Yarn cache.</p>
<p> <a target="_blank" href="https://github.com/changesets/changesets">Changesets</a> is also a popular versioning tool used for managing multiple packages in a repository such as monorepo, it provides maintainers a workflow that helps automate updating of package versions and publishing of new packages.</p>
<h2 id="heading-conclusion">Conclusion</h2>
<p>Using Typescript in a monorepo may require some configurations and the use of some best practices. You will, however, be able to increase the maintainability of your codebase and provide uniformity and visibility across your company&#39;s entire code base without the need to track down different repos.</p>
</div></div>
  </body>
</html>
