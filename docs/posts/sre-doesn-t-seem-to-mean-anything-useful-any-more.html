<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2024/09/03/ops/">Original</a>
    <h1>&#34;SRE&#34; doesn&#39;t seem to mean anything useful any more</h1>
    
    
<p>
This seems to be a thing now: someone finds out that you worked as an 
SRE (&#34;site reliability engineer&#34;, something from the big G back in the 
day) somewhere, and now all you&#39;re good for is &#34;devops&#34; - that is, 
you&#39;re going to be the &#34;ops bitch&#34; for the &#34;real&#34; programmers.  You are 
the consumer.  They are the producer.  They squeeze one out and you 
have to make it sing and dance.  You keep things running and you shut 
the hell up.  You wear the pager so they don&#39;t have to.
</p>
<p>
I&#39;ve seen this from the hiring side of things: when we were trying to 
hire well-rounded people and put up a job posting with &#34;SRE&#34; in the 
title, all of the sudden we got a bunch of applications from people who 
basically *were* ops monkeys.  They wanted to be that and do that.  
That was their life, and they enjoyed it.  Those of us on the hiring 
side were taken aback by this and didn&#39;t want that kind of hire getting 
into the place.
</p>
<p>
Clearly, somewhere along the line, someone lost the thread, and it has 
completely destroyed any notion of what a SRE was supposed to be.
</p>
<p>
Just so we&#39;re operating on a level playing ground here, I&#39;ll lay down my 
own personal definition of the term, and what I expected from people in 
that role and what I expected from myself.
</p>
<p>
To me, a SRE is *both* a sysadmin AND a programmer, developer, whatever 
you want to call it.  It&#39;s a logical-and, not an XOR.
</p>
<p>
By sysadmin, I mean &#34;runs a mean Unix box, including fixing things 
and diving deeply when they break&#34;, and by the programmer/whatever part 
of it, I mean &#34;makes stuff come into existence that wasn&#39;t there 
before&#34;.  In particular, I expect someone to run the *right* things on 
those boxes, to find the actual problems and not just reboot stuff that 
looks squirrelly, and that they write good, solid code that&#39;s respectful 
of the systems and the network.  They probably write programs to make 
the sysadmin part of the job run itself.  Automation for the win.
</p>
<p>
That, to me, is my first order approximation of what a SRE should be.
</p>
<p>
Now, there must be some reason I&#39;m writing about this, right?  Yes, and 
there is.  I put out some feelers to see about maybe working with a 
small company that&#39;s building some interesting things.  They&#39;re 
wrangling Linux, C and C++, embedded stuff, networking, and they&#39;re 
almost certainly going to need a certain amount of pickiness regarding 
correctness and security to keep bad people from breaking into stuff.
Also, they didn&#39;t have the usual lists of godawful clown software that 
most places rattle off that you&#39;d be expected to work with. 
</p>
<p>
In short, it was a place that&#39;s Actually Building Stuff and isn&#39;t just 
throwing their money at one of the usual clown vendors.  That&#39;s rare!
</p>
<p>
So, I reached out... and heard nothing.  Then, much later, I reached out 
a different way, and eventually heard back: they looked me over, figured 
I&#39;m a SRE and they have devops people already, so, uh, no thanks.
</p>
<p>
That&#39;s it.  That&#39;s the whole thing.  The door is closed.
</p>
<p>
I&#39;m obviously not happy with this situation.  In sharing with some 
friends, they also mentioned &#34;having to have this conversation&#34; (that 
they are not just an ops monkey) a great many times in the course of 
looking for employment over the years.
</p>
<p>
Clearly, things have gone to hell, and unless you WANT that kind of 
ops-only life, you probably don&#39;t want to sell yourself this way.
</p>
<p>
Just to be annoying, I&#39;m going to rattle off an example of something an 
ops monkey would never do.  I wrote this C++ build tool, right?  I&#39;ve 
<a href="https://rachelbythebay.com/w/2021/03/24/comp/">mentioned it </a>
a few times in various posts over the years, and there have 
been a few anemic web pages on my main server talking about what it is 
and how it works.
</p>
<p>
I won&#39;t go into the full history of it here.  A quick description is: 
it knows how to build C++ using #includes to figure out dependencies, 
and so you need not write a build script, a Makefile, a CMakefile, or 
any other config language file.  This goes both for the stuff inside 
the local source tree, and for external system library dependencies: 
stuff like libcurl, a pgsql or mysql client library, GNU Radio, 
libmicrohttpd, jansson, or basically anything else you might think of.  
It knows how to use pkg-config to get the details for some well-known 
targets, and you can add entries to a config file to map the
&#34;#include &lt;proj/lib.h&gt;&#34; onto the pkg-config name for anything else.
</p>
<p>
So, again, that&#39;s all old news.  I first wrote that over a decade ago 
and have been using it all this time, with small improvements over the 
years.  What&#39;s new?  Well, a couple of months back, I decided it was 
finally time to make the thing run its operations in parallel to take 
advantage of a multi-processor system.
</p>
<p>
It now scans the targets to determine the dependency graph in parallel, 
then kicks off compiles, then kicks off the linker.  Everything that 
used to be serialized has now been made as parallel as possible.
</p>
<p>
Obviously, you can&#39;t just do this as a rash decision.  There are any 
number of things which can go terribly wrong if you don&#39;t manage your 
data structures properly for safe cross-thread accesses.  You need to be 
able to put things to sleep and have them wake up later without having 
them needlessly &#34;spin&#34; on the CPU.  You need to do depth-first 
processing and then have it kick off the &#34;parents&#34; as the &#34;children&#34; 
finish up.  You still have to catch errors and stop the process where 
appropriate, and you also have to make sure you don&#39;t just boil the 
damn machine by launching EVERYTHING at once.  &#34;Just use std::async&#34;, 
it is not!
</p>
<p>
To give some idea of the impact, touching a file that gets included into 
a whole bunch of stuff forces everything above it in the graph to get 
rebuilt.  This used to take about 77 seconds on the same 2011-built
8-way workstation box I&#39;ve had all along.  With just the early 
work on parallelization, it became something more like 21 seconds.
</p>
<p>
77s -&gt; 21s, just like that.  That&#39;s a lot of win that was just waiting 
to be realized by using the hardware appropriately.
</p>
<p>
Yeah, I did that.  Little old me.  This is not the behavior of someone 
who just twiddles other people&#39;s config files for a living.
</p>
<p>
Raar, I&#39;m cranky.
</p>

  </body>
</html>
