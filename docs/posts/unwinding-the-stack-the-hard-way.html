<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lesenechal.fr/en/linux/unwinding-the-stack-the-hard-way">Original</a>
    <h1>Unwinding the Stack the Hard Way</h1>
    
    <div id="readability-page-1" class="page"><article>
  <header>
    Kévin Lesénéchal</header>

  <p>Let’s say you have a program, in C or Rust, whatever; and this program has a
bug. The only thing you see in your terminal is the dreaded
<code>Segmentation fault (core dumped)</code>. Well… let’s say it’s a <em>C</em> program then. You would like
to know what happened, and even fix that! Normal people would launch GDB and run
<code>bt</code> to get a backtrace; but we aren’t normal people, we like to suffer. We will do
our backtrace ourselves, and I don’t mean calling <a href="https://man7.org/linux/man-pages/man3/backtrace.3.html"><code>backtrace()</code></a>: that is a rookie solution. And no, <a href="https://www.nongnu.org/libunwind/"><code>libunwind</code></a>
is not acceptable either; real developpers unwind their stack themselves with bare hands.
In this article, we will delve into the intricacies of stack unwinding,
exception-handling, call frames, and dissect ELFs and DWARFs.</p>

<p>I was doing some programming work on my personal project
<a href="https://github.com/kevin-lesenechal/nucloid">Nucloid</a>, a kernel written in Rust.
At one point, the kernel raised a page fault, because of faulty page tables. As
usual, the kernel crashed, dumping the machine state:</p>
<pre><code><span>PANIC! Invalid read at 00000000&#39;00010000: page is not mapped
rax=00000000&#39;00010000  rbx=ffff8000&#39;00b40b38  rcx=ffff8000&#39;0164cf00  rdx=ffff8000&#39;00b03bd0
rdi=ffff8000&#39;00b40210  rsi=00000000&#39;00000000  rbp=00000000&#39;00000000  rsp=ffff8000&#39;00b3f798
 r8=00000000&#39;00000000   r9=ffff8000&#39;0018d200  r10=00000000&#39;0000003d  r11=ffff8000&#39;00180e10
r12=00000000&#39;00000000  r13=00000000&#39;00000000  r14=00000000&#39;00000000  r15=00000000&#39;00000000
rip=ffff8000&#39;0010c93e      cs=0008   ss=0010   ds=0000   es=0000   fs=0000   gs=0000</span></code></pre>
<p>Something’s lacking though: a stack trace! Based on the <code>%rip</code> value (<code>0xffff8000&#39;0010c93e</code>),
we can determine in which function the faulty instruction is located. But who
called us? That’s an essential information after all! Especially if the instruction happens
to live in the standard library, that doesn’t help at all to know that
<code>Result::unwrap()</code> panicked for example.</p>
<p>With normal programs, we have debuggers, and the kernel offers mechanisms like
<code>ptrace</code> to handle such task. But who debugs the kernel? Certainly not a
debugger. The kernel will have to debug itself. Normally, a progam will not
try debugging itself —yet I’ve seen programs handling <code>SIGSEGV</code>: for God’s sake,
don’t do that! Nevertheless, the kernel is no normal program, and if it wants to offer some
amount of debugging experience, it will have to handle it all by itself.</p>
<p>So I started to do some research on how to compute a stack trace in a freestanding
environment. Solutions generally involved the <code>backtrace()</code> function, a GNU
extension; that won’t do it. There’s <code>libunwind</code>, I don’t know if that would’ve
worked, I never tried: I just told myself I’m going to roll my own backtrace
function, that can’t be hard, I heard of that thing the <em>frame pointer</em> or
<code>%rbp</code> stuff.</p>
<p>At that time, I had no idea what a rabbit hole I was about to dive into. If I
had known at that moment what was required, I likely wouldn’t have started. Fortunately for
me, I was ill-informed and naive: a blessing in disguise. I ushered in the task,
navigating blindly, and when the fog finally dissipated, when I realized what it
takes to make a stack trace, it was too late: I was too involved, I had done too
much research, I had to finish.</p>
<p>So, let’s do the <em>frame pointer</em> thing and call it a day.</p>
<h2 id="h1-just-use-the-frame-pointer">Just use the frame pointer</h2>
<p>Some of you may have heard of the <em>frame pointer</em>; on x86-64, this refers to the
<code>%rbp</code> register: it contains the address of a fixed point within the current
function’s call frame. That register is updated each time we enter or leave a
function. Anywhere you are, you read <code>%rbp</code> and you know where the current call
frame starts. Moreover, at that address on the stack is saved the previous value
of <code>%rbp</code> for the calling function. Knowing this reference point, we can use
relative addresses to access specific elements of the call frame: the return
address, the local variables, and even some parameters if those were passed
via the stack.</p>
<table><tbody><tr>
<td>
<table>
  <tbody><tr>
    <th>.text segment</th>
    <th></th>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>bar</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>baz</td>
    <td><span>← %rip</span></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>foo</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
</tbody></table>
</td>
<td></td>
<td>
<table>
  <tbody><tr>
    <th>Stack segment</th>
    <th></th>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>return address</td>
    <td></td>
  </tr>
  <tr>
    <td>saved %rbp</td>
    <td></td>
  </tr>
  <tr>
    <td>
<b>foo</b>’s</td>
    <td></td>
  </tr>
  <tr>
    <td>return address</td>
    <td></td>
  </tr>
  <tr>
    <td>saved %rbp</td>
    <td></td>
  </tr>
  <tr>
    <td>
<b>bar</b>’s</td>
    <td></td>
  </tr>
  <tr>
    <td>return address</td>
    <td><span>← %rbp + 8</span></td>
  </tr>
  <tr>
    <td>saved %rbp</td>
    <td><span>← <b>%rbp</b></span></td>
  </tr>
  <tr>
    <td>
<b>baz</b>’s</td>
    <td><span>← %rsp</span></td>
  </tr>
</tbody></table>
</td>
</tr></tbody></table>
<p>In this example, we have three functions: <code>foo</code> calling <code>bar</code> calling <code>baz</code>.
As a reminder, on x86, the stack grows down towards the lower addresses.
<code>%rsp</code> points to the bottom of the stack, i.e. the last pushed value. <code>%rbp</code>
gives us information on the current (last) call frame. To access the previous
call frames, we just need to read the previous <code>%rbp</code> value that is saved on the
stack at the address contained in <code>%rbp</code>.</p>
<p>So, it seems that all we have to do is read the <code>%rbp</code> register, then access the
stack at <code>%rbp + 8</code> to find the return address. That return address gives us the
information of which instruction in which function called us, which is quite the
whole point of a stack trace. Then we read the stack at the address <code>%rbp</code> to
get the saved <code>%rbp</code> value of the previous call frame. You then repeat the
process, navigating the linked list of <code>%rbp</code> values until we find a saved value
of 0 that denotes the first call frame.</p>
<p>That is <em>so</em> easy! I wonder why anyone would write an <em>entire</em> article about such an
obvious and easy thing to do.</p>
<p>If only that was so simple… What’s the catch?
Well, it’s been a while that compilers <em>omit the frame pointer</em><sup><a href="#ref-1">[1]</a></sup>; you
see, that frees up <code>%rbp</code>! It’s not like x86 has a whole lot of registers to
start with, so having a spare register is something to take.</p>
<p>Without <code>%rbp</code>, our <em>frame pointer</em>, here is what our stack looks like:</p>
<table>
  <tbody><tr>
    <th>Stack segment</th>
    <th></th>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>return address</td>
    <td></td>
  </tr>
  <tr>
    <td>
<b>foo</b>’s</td>
    <td></td>
  </tr>
  <tr>
    <td>return address</td>
    <td></td>
  </tr>
  <tr>
    <td>
<b>bar</b>’s</td>
    <td></td>
  </tr>
  <tr>
    <td>return address</td>
    <td></td>
  </tr>
  <tr>
    <td>
<b>baz</b>’s</td>
    <td><span>← %rsp</span></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
</tbody></table>
<p>We are left with <code>%rsp</code>. How do we figure out where the return address is? Well,
it is still 8 bytes below the top of our call frame. And how do we figure out
where the top of the call frame is? Well, we are screwed, we don’t have this information.
We would need to know how much space the function’s local variables take to infer
the call frame’s start address from <code>%rsp</code>. Even worse, as we execute instructions
within the function, <code>%rsp</code> moves as local variables are allocated and freed.
Not only do we miss critical information, we are aiming at a moving target.</p>
<p>In practice, this is not a problem for compilers: they don’t <em>need</em> the frame
pointer, they know how the call frame is structured, what size it has, where it
begins, where the return address is located, etc. since <em>they</em> created it.
But when the compiler has finished compiling our program, that information is
lost. Is it really though?</p>
<h2 id="h2-eh_frame-call-frame-information-cfi">
<code>.eh_frame</code>: call frame information (CFI)</h2>
<p>Let’s compile a very simple C program:</p>
<pre><code><span><span><span>#include</span> <span><span>&lt;</span>stdio.h<span>&gt;</span></span>
</span>
<span>int</span> <span><span>main</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
    <span><span>printf</span><span><span>(</span></span></span><span><span><span><span>&#34;</span>Hello, world!<span>\n</span><span>&#34;</span></span></span></span><span><span><span>)</span></span></span><span>;</span>

    <span>return</span> <span>0</span><span>;</span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre>
<pre><code><span>kevin</span>@<span>kevin-desktop</span>:<span>~</span> <span>»</span> gcc main.c</code></pre>
<p>Now, let’s inspect the ELF using the wonderful
<a href="https://crates.io/crates/elf-info"><code>elf-info</code></a> command and list
all sections:</p>
<pre><code><span>kevin</span>@<span>kevin-desktop</span>:<span>~</span> <span>»</span> export ELF=a.out
<span>kevin</span>@<span>kevin-desktop</span>:<span>~</span> <span>»</span> elf sh
<span>───┤ SECTIONS (30) ├─────────────────────────────────────────────────────────</span>
<span>No │ Name                 │ Type         │ Virt. addr.         │ Size                   │</span>
<span>───┼──────────────────────┼──────────────┼─────────────────────┼────────────────────────┤</span>
 0 <span>│</span>                      <span>│</span> <span>NULL         </span><span>│</span> <span>0x00000000&#39;00000000 </span><span>│</span> <span>0x0000&#39;0000      0 B   </span><span>│</span>
 1 <span>│</span> .interp              <span>│</span> <span>PROGBITS     </span><span>│</span> 0x00000000&#39;00000318 <span>│</span> 0x0000&#39;001c     28 B   <span>│</span>
 2 <span>│</span> .note.gnu.property   <span>│</span> <span>NOTE         </span><span>│</span> 0x00000000&#39;00000338 <span>│</span> 0x0000&#39;0040     64 B   <span>│</span>
 3 <span>│</span> .note.gnu.build-id   <span>│</span> <span>NOTE         </span><span>│</span> 0x00000000&#39;00000378 <span>│</span> 0x0000&#39;0024     36 B   <span>│</span>
 4 <span>│</span> .note.ABI-tag        <span>│</span> <span>NOTE         </span><span>│</span> 0x00000000&#39;0000039c <span>│</span> 0x0000&#39;0020     32 B   <span>│</span>
 5 <span>│</span> .gnu.hash            <span>│</span> GNU_HASH     <span>│</span> 0x00000000&#39;000003c0 <span>│</span> 0x0000&#39;001c     28 B   <span>│</span>
 6 <span>│</span> .dynsym              <span>│</span> <span>DYNSYM       </span><span>│</span> 0x00000000&#39;000003e0 <span>│</span> 0x0000&#39;00a8    168 B   <span>│</span>
 7 <span>│</span> .dynstr              <span>│</span> <span>STRTAB       </span><span>│</span> 0x00000000&#39;00000488 <span>│</span> 0x0000&#39;008d    141 B   <span>│</span>
 8 <span>│</span> .gnu.version         <span>│</span> GNU_VERSYM   <span>│</span> 0x00000000&#39;00000516 <span>│</span> 0x0000&#39;000e     14 B   <span>│</span>
 9 <span>│</span> .gnu.version_r       <span>│</span> GNU_VERNEED  <span>│</span> 0x00000000&#39;00000528 <span>│</span> 0x0000&#39;0030     48 B   <span>│</span>
10 <span>│</span> .rela.dyn            <span>│</span> <span>RELA         </span><span>│</span> 0x00000000&#39;00000558 <span>│</span> 0x0000&#39;00c0    192 B   <span>│</span>
11 <span>│</span> .rela.plt            <span>│</span> <span>RELA         </span><span>│</span> 0x00000000&#39;00000618 <span>│</span> 0x0000&#39;0018     24 B   <span>│</span>
12 <span>│</span> .init                <span>│</span> <span>PROGBITS     </span><span>│</span> 0x00000000&#39;00001000 <span>│</span> 0x0000&#39;001b     27 B   <span>│</span>
13 <span>│</span> .plt                 <span>│</span> <span>PROGBITS     </span><span>│</span> 0x00000000&#39;00001020 <span>│</span> 0x0000&#39;0020     32 B   <span>│</span>
14 <span>│</span> .text                <span>│</span> <span>PROGBITS     </span><span>│</span> 0x00000000&#39;00001040 <span>│</span> 0x0000&#39;0113    275 B   <span>│</span>
15 <span>│</span> .fini                <span>│</span> <span>PROGBITS     </span><span>│</span> 0x00000000&#39;00001154 <span>│</span> 0x0000&#39;000d     13 B   <span>│</span>
16 <span>│</span> .rodata              <span>│</span> <span>PROGBITS     </span><span>│</span> 0x00000000&#39;00002000 <span>│</span> 0x0000&#39;0012     18 B   <span>│</span>
17 <span>│</span> <span>.eh_frame_hdr</span>        <span>│</span> <span>PROGBITS     </span><span>│</span> 0x00000000&#39;00002014 <span>│</span> 0x0000&#39;0024     36 B   <span>│</span>
18 <span>│</span> <span>.eh_frame</span>            <span>│</span> <span>PROGBITS     </span><span>│</span> 0x00000000&#39;00002038 <span>│</span> 0x0000&#39;007c    124 B   <span>│</span>
19 <span>│</span> .init_array          <span>│</span> INIT_ARRAY   <span>│</span> 0x00000000&#39;00003dd0 <span>│</span> 0x0000&#39;0008      8 B   <span>│</span>
20 <span>│</span> .fini_array          <span>│</span> FINI_ARRAY   <span>│</span> 0x00000000&#39;00003dd8 <span>│</span> 0x0000&#39;0008      8 B   <span>│</span>
21 <span>│</span> .dynamic             <span>│</span> <span>DYNAMIC      </span><span>│</span> 0x00000000&#39;00003de0 <span>│</span> 0x0000&#39;01e0    480 B   <span>│</span>
22 <span>│</span> .got                 <span>│</span> <span>PROGBITS     </span><span>│</span> 0x00000000&#39;00003fc0 <span>│</span> 0x0000&#39;0028     40 B   <span>│</span>
23 <span>│</span> .got.plt             <span>│</span> <span>PROGBITS     </span><span>│</span> 0x00000000&#39;00003fe8 <span>│</span> 0x0000&#39;0020     32 B   <span>│</span>
24 <span>│</span> .data                <span>│</span> <span>PROGBITS     </span><span>│</span> 0x00000000&#39;00004008 <span>│</span> 0x0000&#39;0010     16 B   <span>│</span>
25 <span>│</span> .bss                 <span>│</span> <span>NOBITS       </span><span>│</span> 0x00000000&#39;00004018 <span>│</span> 0x0000&#39;0008      8 B   <span>│</span>
26 <span>│</span> .comment             <span>│</span> <span>PROGBITS     </span><span>│</span> <span>0x00000000&#39;00000000 </span><span>│</span> 0x0000&#39;001b     27 B   <span>│</span>
27 <span>│</span> .symtab              <span>│</span> <span>SYMTAB       </span><span>│</span> <span>0x00000000&#39;00000000 </span><span>│</span> 0x0000&#39;0240    576 B   <span>│</span>
28 <span>│</span> .strtab              <span>│</span> <span>STRTAB       </span><span>│</span> <span>0x00000000&#39;00000000 </span><span>│</span> 0x0000&#39;0126    294 B   <span>│</span>
29 <span>│</span> .shstrtab            <span>│</span> <span>STRTAB       </span><span>│</span> <span>0x00000000&#39;00000000 </span><span>│</span> 0x0000&#39;0116    278 B   <span>│</span></code></pre>
<p>Two of these sections will be the subject of this article: <code>.eh_frame</code> and <code>.eh_frame_hdr</code>.
We will talk about <code>.eh_frame_hdr</code> later. The <code>.eh_frame</code> section contains the
missing information the compiler saved for us. It stands
for exception-handling frames, this is because in languages like C++ or Rust,
exceptions (we call them <em>panics</em> in Rust) are handled through stack unwinding:
we unwind the stack by popping call frames as we move up and restore register
values, call destructors, etc.</p>
<p>That information is therefore needed <strong>at runtime</strong> to perform stack unwinding
in cases of exceptions, panics, or requesting a stack trace. That’s why those two
sections are actually loaded in memory unlike debugging information.</p>
<p>So, what does <code>.eh_frame</code> contain in our program? Let’s use our favorite
<a href="https://crates.io/crates/elf-info">ELF-dissecting tool</a>:</p>
<pre><code><span>kevin</span>@<span>kevin-desktop</span>:<span>~</span> <span>»</span> elf sh -x .eh_frame
<span>───┤ SECTION &#34;.eh_frame&#34; ├───────────────────────────────────────────────────</span>
<span>              Name</span> │ .eh_frame
<span>              Type</span> │ <span>PROGBITS</span> (0x00000001)
<span>   Virtual address</span> │ 0x00000000&#39;00002038
<span>     Offset in ELF</span> │ 0x00000000&#39;00002038 B
<span>              Size</span> │ 0x00000000&#39;0000007c B (124 B)
<span>         Alignment</span> │ 0x00000000&#39;00000008 B
<span>        Entry size</span> │ <span>0x00000000&#39;00000000 B</span>

<span>       0 │</span>  14 00 00 00 00 00 00 00 <span>│</span> 01 7a 52 00 01 78 10 01  <span>│</span><span>╳╳╳╳╳╳╳╳</span><span>│</span><span>╳</span>zR<span>╳╳</span>x<span>╳╳</span><span>│</span>
<span>      10 │</span>  1b 0c 07 08 90 01 00 00 <span>│</span> 14 00 00 00 1c 00 00 00  <span>│</span><span>╳╳╳╳╳╳╳╳</span><span>│</span><span>╳╳╳╳╳╳╳╳</span><span>│</span>
<span>      20 │</span>  e8 ef ff ff 26 00 00 00 <span>│</span> 00 44 07 10 00 00 00 00  <span>│</span><span>╳╳╳╳</span>&amp;<span>╳╳╳</span><span>│</span><span>╳</span>D<span>╳╳╳╳╳╳</span><span>│</span>
<span>      30 │</span>  24 00 00 00 34 00 00 00 <span>│</span> b0 ef ff ff 20 00 00 00  <span>│</span>$<span>╳╳╳</span>4<span>╳╳╳</span><span>│</span><span>╳╳╳╳</span> <span>╳╳╳</span><span>│</span>
<span>      40 │</span>  00 0e 10 46 0e 18 4a 0f <span>│</span> 0b 77 08 80 00 3f 1a 3b  <span>│</span><span>╳╳╳</span>F<span>╳╳</span>J<span>╳</span><span>│</span><span>╳</span>w<span>╳╳╳</span>?<span>╳</span>;<span>│</span>
<span>      50 │</span>  2a 33 24 22 00 00 00 00 <span>│</span> 1c 00 00 00 5c 00 00 00  <span>│</span>*3$&#34;<span>╳╳╳╳</span><span>│</span><span>╳╳╳╳</span>\<span>╳╳╳</span><span>│</span>
<span>      60 │</span>  a1 f0 ff ff 1a 00 00 00 <span>│</span> 00 41 0e 10 86 02 43 0d  <span>│</span><span>╳╳╳╳╳╳╳╳</span><span>│</span><span>╳</span>A<span>╳╳╳╳</span>C<span>╳</span><span>│</span>
<span>      70 │</span>  06 55 0c 07 08 00 00 00 <span>│</span> 00 00 00 00              <span>│</span><span>╳</span>U<span>╳╳╳╳╳╳</span><span>│</span><span>╳╳╳╳────</span><span>│</span></code></pre>
<p>Well, 124 bytes is not <em>that</em> long fortunately. But we still have no idea what’s
inside. The <code>.eh_frame</code> section actually contains <strong>DWARF</strong> information<sup><a href="#ref-2">[2]</a></sup><sup><a href="#ref-6">[6]</a></sup>.
Yes, you heard right, DWARF, like for the debugging symbols. But here, DWARF isn’t used
for actual debugging but to express data that are loaded and can be accessed at
runtime. This is how functions like <a href="https://man7.org/linux/man-pages/man3/backtrace.3.html"><code>backtrace()</code></a>
or libraries like <a href="https://www.nongnu.org/libunwind/"><code>libunwind</code></a>
find the necessary information to move up the stack of call frames. Each time
an exception or panic is raised, we need to unwind the stack and, therefore, need
to consult <code>.eh_frame</code> for how to do that.</p>
<p>We could check out the DWARF reference documentation to manually parse such a
structure, but instead we will rely on <a href="https://crates.io/crates/elf-info"><code>elf-info</code></a>
to perform that job; to do so,
just remove the <code>-x</code> option I passed earlier: this asks to always show a hexdump
instead of interpreting the section’s content.</p>
<pre><code><span>kevin</span>@<span>kevin-desktop</span>:<span>~</span> <span>»</span> elf sh .eh_frame
<span>───┤ SECTION &#34;.eh_frame&#34; ├───────────────────────────────────────────────────</span>
<span>              Name</span> │ .eh_frame
<span>              Type</span> │ <span>PROGBITS</span> (0x00000001)
<span>   Virtual address</span> │ 0x00000000&#39;00002038
<span>     Offset in ELF</span> │ 0x00000000&#39;00002038 B
<span>              Size</span> │ 0x00000000&#39;0000007c B (124 B)
<span>         Alignment</span> │ 0x00000000&#39;00000008 B
<span>        Entry size</span> │ <span>0x00000000&#39;00000000 B</span>

│
├╴ <span>CIE</span>  offset=0x00000000&#39;00000000
│  ├╴<span>             Version</span> │ 1
│  ├╴<span>              Length</span> │ 20
│  ├╴<span>        Augmentation</span> │
│  ├╴<span>      Code alignment</span> │ 1
│  ├╴<span>      Data alignment</span> │ -8
│  ├╴<span>Return addr register</span> │ 16 (%RA)
│  ├──⮞ DW_CFA_def_cfa(7, 8)            cfa = %rsp + 8
│  ├──⮞ DW_CFA_offset(16, 1)            %RA @ cfa − 8
│  ├──⮞ <span>DW_CFA_nop()</span>
│  ├──⮞ <span>DW_CFA_nop()</span>
│  │
│  ├╴ <span>FDE</span>  offset=0x00000000&#39;00000018  CIE=0x00000000&#39;00000000
│  │  ├╴<span>  PC range</span> │ 0x00000000&#39;00001040..0x00000000&#39;00001066
│  │  ├╴<span>    Symbol</span> │ _start + 0x0
│  │  ├──⮞ DW_CFA_advance_loc(4)        loc += 4        loc = 0x00000000&#39;00001044
│  │  ├──⮞ DW_CFA_undefined(16)         %RA @ ??? (unrecoverable)
│  │  ├──⮞ <span>DW_CFA_nop()</span>
│  │  ├──⮞ <span>DW_CFA_nop()</span>
│  │  ├──⮞ <span>DW_CFA_nop()</span>
│  │  ├──⮞ <span>DW_CFA_nop()</span>
│  │
│  ├╴ <span>FDE</span>  offset=0x00000000&#39;00000030  CIE=0x00000000&#39;00000000
│  │  ├╴<span>  PC range</span> │ 0x00000000&#39;00001020..0x00000000&#39;00001040
│  │  ├╴<span>    Symbol</span> │ _init + 0x20
│  │  ├──⮞ DW_CFA_def_cfa_offset(16)    cfa = <span>%rsp</span> + 16
│  │  ├──⮞ DW_CFA_advance_loc(6)        loc += 6        loc = 0x00000000&#39;00001026
│  │  ├──⮞ DW_CFA_def_cfa_offset(24)    cfa = <span>%rsp</span> + 24
│  │  ├──⮞ DW_CFA_advance_loc(10)       loc += 10       loc = 0x00000000&#39;00001030
│  │  ├──⮞ DW_CFA_def_cfa_expression([77, 08, 80, 00, 3f, 1a, 3b, 2a, 33, 24, 22])
│  │  ├──⮞ <span>DW_CFA_nop()</span>
│  │  ├──⮞ <span>DW_CFA_nop()</span>
│  │  ├──⮞ <span>DW_CFA_nop()</span>
│  │  ├──⮞ <span>DW_CFA_nop()</span>
│  │
│  ├╴ <span>FDE</span>  offset=0x00000000&#39;00000058  CIE=0x00000000&#39;00000000
│  │  ├╴<span>  PC range</span> │ 0x00000000&#39;00001139..0x00000000&#39;00001153
│  │  ├╴<span>    Symbol</span> │ main + 0x0
│  │  ├──⮞ DW_CFA_advance_loc(1)        loc += 1        loc = 0x00000000&#39;0000113a
│  │  ├──⮞ DW_CFA_def_cfa_offset(16)    cfa = <span>%rsp</span> + 16
│  │  ├──⮞ DW_CFA_offset(6, 2)          %rbp @ cfa − 16
│  │  ├──⮞ DW_CFA_advance_loc(3)        loc += 3        loc = 0x00000000&#39;0000113d
│  │  ├──⮞ DW_CFA_def_cfa_register(6)   cfa = %rbp + <span>16</span>
│  │  ├──⮞ DW_CFA_advance_loc(21)       loc += 21       loc = 0x00000000&#39;00001152
│  │  ├──⮞ DW_CFA_def_cfa(7, 8)         cfa = %rsp + 8
│  │  ├──⮞ <span>DW_CFA_nop()</span>
│  │  ├──⮞ <span>DW_CFA_nop()</span>
│  │  ├──⮞ <span>DW_CFA_nop()</span></code></pre>
<p>Wow, that’s a lot to digest. At first glance, there seems to be a hierarchical
structure made of <strong>CIE</strong>s and <strong>FDE</strong>s. Each <strong>FDE</strong>, or <em>frame description entry</em>,
is associated with a parent <strong>CIE</strong>, or <em>common information entry</em>. The reason
for this hierarchy is simply to reduce the binary size by factoring out the FDEs’
common information, hence the name. To compute the full entry, simply append the
FDE to its parent CIE.</p>
<p>We also see that an FDE has a <strong>PC range</strong>, a range of <em>program counter</em> addresses,
i.e. machine instructions contained in the <code>.text</code> and pointed by the <code>%rip</code>
register. This PC range actually refers to functions. We will typically have an
FDE for each function. <a href="https://crates.io/crates/elf-info"><code>elf-info</code></a> is nice
enough to show to which symbol the PC addresses belong.</p>
<p>Below the FDE header is a list of <em>instructions</em><sup><a href="#ref-3">[3]</a></sup> that, when followed,
will give us everything we need to know about the structure of the call frame.
We are going to build a mental table out of these instructions: for each row,
there will be the address of an instruction within the function; and for each column,
a register. In each cell of this table, there will be a <em>rule</em> that governs how
to restore the value of the register at that code location.</p>
<div>
<table>
  <tbody><tr>
    <th>PC</th>
    <th>CFA</th>
    <th>%rax</th>
    <th>%rbx</th>
    <th>%rcx</th>
    <th>…</th>
  </tr>
  <tr>
    <td>0x0000</td>
    <td>%rsp + 80</td>
    <td>undefined</td>
    <td>undefined</td>
    <td>offset(-16)</td>
    <td>…</td>
  </tr>
  <tr>
    <td>0x0001</td>
    <td>%rsp + 80</td>
    <td>undefined</td>
    <td>undefined</td>
    <td>offset(-16)</td>
    <td>…</td>
  </tr>
  <tr>
    <td>0x0002</td>
    <td>%rsp + 80</td>
    <td>undefined</td>
    <td>undefined</td>
    <td>offset(-16)</td>
    <td>…</td>
  </tr>
  <tr>
    <td>0x0003</td>
    <td>%rsp + 100</td>
    <td>undefined</td>
    <td>register(%r10)</td>
    <td>offset(-16)</td>
    <td>…</td>
  </tr>
  <tr>
    <td>…</td>
    <td>…</td>
    <td>…</td>
    <td>…</td>
    <td>…</td>
    <td>…</td>
  </tr>
</tbody></table>
</div>
<p>With this example table, we know that if we are at the instruction at address
<code>0x0002</code>, then the saved values of <code>%rax</code> and <code>%rbx</code> are undefined, i.e. those
registers can’t be restored, and the saved value of <code>%rcx</code> can be found at
<code>CFA - 16</code>. For this instruction, the CFA is <code>%rsp + 80</code>.</p>
<p>Of course, such a table is conceptual; we would never actually allocate and fill
it: it would be way too large.</p>
<h3 id="h2.1-cfa-canonical-frame-address">CFA: canonical frame address</h3>
<p>The <strong>CFA</strong>, or <em>canonical frame address</em> is of paramount importance: it is, in
essence, our “base pointer”, that points at the top of our call frame. By
definition, the <strong>CFA</strong> is the value of the stack pointer, <code>%rsp</code>, at the call
site in the previous frame, just before the <code>call</code> instruction; which is not the
same as the value of <code>%rsp</code> once in the callee function. The CFA is our anchor
point from which we can address elements of our frame.</p>
<p>In order to determine the CFA, we must lookup the call frame information for the
CFA rule at that specific instruction address we want. In our example, the CFA is
computed using the value of <code>%rsp</code> with an offset. That offset changes as
values are push/popped to/from the stack, i.e. as <code>%rsp</code> moves, because the CFA
must remain fixed for a given call frame.</p>
<table>
  <tbody><tr>
    <th>Stack segment</th>
    <th></th>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>return address</td>
    <td></td>
  </tr>
  <tr>
    <td>
<b>foo</b>’s</td>
    <td></td>
  </tr>
  <tr>
    <td>return address</td>
    <td></td>
  </tr>
  <tr>
    <td>
<b>bar</b>’s</td>
    <td><span>← <b>CFA</b> (%rsp + 100)</span></td>
  </tr>
  <tr>
    <td>return address</td>
    <td><span>← CFA − 8</span></td>
  </tr>
  <tr>
    <td>saved %rcx</td>
    <td><span>← CFA − 16</span></td>
  </tr>
  <tr>
    <td>
<b>baz</b>’s</td>
    <td><span>← %rsp</span></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
</tbody></table>
<p>In this example, let’s say we are at instruction 0x0003. The call frame information
table says that to find the CFA, we need to take the current value of <code>%rsp</code> and add 100.
To get the previous value of the <code>%rcx</code> we just need to read the stack at <code>CFA - 16</code>.</p>
<p>There are only two possible rules to compute the CFA: either a register plus
offset (the usual way), or a <strong>DWARF expression</strong><sup><a href="#ref-8">[8]</a></sup>: some bytecode
for an ad-hoc stack-based virtual machine you must implement and evaluate the
expression into; this is a kafkaesque way of expressing arbitrarily complex rules.</p>
<h3 id="h2.2-register-rules">Register rules</h3>
<p>There are several rules<sup><a href="#ref-4">[4]</a></sup> to restore a register’s previous value, here are <em>some</em>
of them:</p>
<ul>
<li>
<code>undefined</code>: the register’s value can’t be restored;</li>
<li>
<code>same value</code>: the value is untouched, no restoration is needed;</li>
<li>
<code>offset(n)</code>: the value is located at address <code>CFA + n</code>;</li>
<li>
<code>val_offset(n)</code>: the value is <code>CFA + n</code> itself, no dereferencing;</li>
<li>
<code>register(r)</code>: the value is the same as the one in register <code>r</code>.</li>
<li>
<code>expression(e)</code> and <code>val_expression(e)</code>: both calculate a value from the
<strong>DWARF expression</strong><sup><a href="#ref-8">[8]</a></sup> <code>e</code>, the previous register’s value is
either the computed value itself in case of <code>val_expression(e)</code>, or the
value located at that address in case of <code>expression(e)</code>.</li>
</ul>
<p>Of course, restoring registers only makes sense for registers that must be
preserved by the called function, the so-called <em>callee-saved registers</em>, which
depends on the ABI’s calling convention. In the case of the x86-64 System V ABI,
callee-saved registers include <code>%rbx</code>, <code>%rsp</code>, <code>%rbp</code>, <code>%r12</code>, <code>%r13</code>, <code>%r14</code>,
and <code>%r15</code><sup><a href="#ref-7">[7]</a></sup>.</p>
<h3 id="h2.3-call-frame-instructions">Call frame instructions</h3>
<p>We now need to know <em>how</em> to build such a table based on the FDE’s instructions.
Let’s focus on the <code>main</code> function, and use <a href="https://crates.io/crates/elf-info"><code>elf-info</code></a>
again to display all CFI about this function:</p>
<pre><code><span>kevin</span>@<span>kevin-desktop</span>:<span>~</span> <span>»</span> elf eh -s main
│
├╴ <span>CIE</span>  offset=0x00000000&#39;00000000
│  ├╴<span>             Version</span> │ 1
│  ├╴<span>              Length</span> │ 20
│  ├╴<span>        Augmentation</span> │
│  ├╴<span>      Code alignment</span> │ 1
│  ├╴<span>      Data alignment</span> │ -8
│  ├╴<span>Return addr register</span> │ 16 (%RA)
│  ├──⮞ DW_CFA_def_cfa(7, 8)            cfa = %rsp + 8
│  ├──⮞ DW_CFA_offset(16, 1)            %RA @ cfa − 8
│  ├──⮞ <span>DW_CFA_nop()</span>
│  ├──⮞ <span>DW_CFA_nop()</span>
│  │
│  ├╴ <span>FDE</span>  offset=0x00000000&#39;00000058  CIE=0x00000000&#39;00000000
│  │  ├╴<span>  PC range</span> │ 0x00000000&#39;00001139..0x00000000&#39;00001153
│  │  ├╴<span>    Symbol</span> │ main + 0x0
│  │  ├──⮞ DW_CFA_advance_loc(1)        loc += 1        loc = 0x00000000&#39;0000113a
│  │  ├──⮞ DW_CFA_def_cfa_offset(16)    cfa = <span>%rsp</span> + 16
│  │  ├──⮞ DW_CFA_offset(6, 2)          %rbp @ cfa − 16
│  │  ├──⮞ DW_CFA_advance_loc(3)        loc += 3        loc = 0x00000000&#39;0000113d
│  │  ├──⮞ DW_CFA_def_cfa_register(6)   cfa = %rbp + <span>16</span>
│  │  ├──⮞ DW_CFA_advance_loc(21)       loc += 21       loc = 0x00000000&#39;00001152
│  │  ├──⮞ DW_CFA_def_cfa(7, 8)         cfa = %rsp + 8
│  │  ├──⮞ <span>DW_CFA_nop()</span>
│  │  ├──⮞ <span>DW_CFA_nop()</span>
│  │  ├──⮞ <span>DW_CFA_nop()</span></code></pre>
<p>Instructions are the lines starting with <code>──⮞</code>. To get the full list of
instructions for an FDE, we need to combine both the CIE and the FDE; we will also
ignore <code>DW_CFA_nop</code> instructions which do nothing and are used as padding.
This gives us:</p>
<pre><code>DW_CFA_def_cfa(7, 8)         cfa = %rsp + 8
DW_CFA_offset(16, 1)         %RA @ cfa − 8
DW_CFA_advance_loc(1)        loc += 1        loc = 0x00000000&#39;0000113a
DW_CFA_def_cfa_offset(16)    <span>%rsp</span> + 16
DW_CFA_offset(6, 2)          %rbp @ cfa − 16
DW_CFA_advance_loc(3)        loc += 3        loc = 0x00000000&#39;0000113d
DW_CFA_def_cfa_register(6)   cfa = %rbp + <span>16</span>
DW_CFA_advance_loc(21)       loc += 21       loc = 0x00000000&#39;00001152
DW_CFA_def_cfa(7, 8)         cfa = %rsp + 8</code></pre>
<p>We won’t list all DWARF call frame instructions<sup><a href="#ref-3">[3]</a></sup>, but here are <em>some</em>:</p>
<ul>
<li>
<strong><code>DW_CFA_def_cfa(register, offset)</code></strong></li>
<li>
<strong><code>DW_CFA_def_cfa_offset(offset)</code></strong></li>
<li>
<strong><code>DW_CFA_def_cfa_register(register)</code></strong></li>
<li>
<strong><code>DW_CFA_offset(register, n)</code></strong></li>
<li>
<strong><code>DW_CFA_undefined(register)</code></strong></li>
</ul>
<p>And then there is <strong><code>DW_CFA_advance_loc(n)</code></strong> that advances the current PC by <code>n</code>.
All following call frame instructions must be followed only if the instruction
is passed the new PC.</p>
<p>If we follow all the instructions for the <code>main</code> function, this gives this table:</p>
<div>
<table>
  <tbody><tr>
    <th>PC</th>
    <th>CFA</th>
    <th>%RA</th>
    <th>%rbp</th>
  </tr>
  <tr>
    <td>0x1139</td>
    <td>%rsp + 8</td>
    <td>offset(-8)</td>
    <td>undefined</td>
  </tr>
  <tr>
    <td>0x113a</td>
    <td>%rsp + <b>16</b>
</td>
    <td>offset(-8)</td>
    <td><b>offset(-16)</b></td>
  </tr>
  <tr>
    <td>0x113b</td>
    <td>%rsp + 16</td>
    <td>offset(-8)</td>
    <td>offset(-16)</td>
  </tr>
  <tr>
    <td>0x113c</td>
    <td>%rsp + 16</td>
    <td>offset(-8)</td>
    <td>offset(-16)</td>
  </tr>
  <tr>
    <td>0x113d</td>
    <td>
<b>%rbp</b> + 16</td>
    <td>offset(-8)</td>
    <td>offset(-16)</td>
  </tr>
  <tr>
    <td>0x113e</td>
    <td>%rbp + 16</td>
    <td>offset(-8)</td>
    <td>offset(-16)</td>
  </tr>
  <tr>
    <td>…</td>
    <td>…</td>
    <td>…</td>
    <td>…</td>
  </tr>
  <tr>
    <td>0x1152</td>
    <td><b>%rsp + 8</b></td>
    <td>offset(-8)</td>
    <td>offset(-16)</td>
  </tr>
</tbody></table>
</div>
<p><code>%RA</code> is the register containing the <strong>return address</strong>. Of course, on x86, there
is no such thing, so this is a fake register, a pseudo-register. Knowing the
CFA definition, we deduce that on x86-64, the rule for <code>%RA</code> will always be
to look at <code>CFA - 8</code>: this is where the return address is pushed on the stack
when doing <code>call</code>.</p>
<p>Before moving on, let’s use again <a href="https://crates.io/crates/elf-info"><code>elf-info</code></a>
this time to get a better view of
the <code>main</code>’s CFI instructions. <code>elf fn</code> is a command to disassemble a function by
its symbol name. If we add the <code>--cfi</code> option, the disassembly will be annoted
with call frame information.</p>
<pre><code><span>kevin</span>@<span>kevin-desktop</span>:<span>~</span> <span>»</span> elf fn --cfi main
<span>main:</span>
<span>[CFI]</span> DW_CFA_def_cfa(7, 8)           cfa = %rsp + 8
<span>[CFI]</span> DW_CFA_offset(16, 1)           %RA @ cfa − 8
0x00000000&#39;00001139 <span>│</span>  55                       <span>│</span>  <span>push</span>    <span>%rbp</span>
<span>[CFI]</span> DW_CFA_def_cfa_offset(16)      cfa = <span>%rsp</span> + 16
<span>[CFI]</span> DW_CFA_offset(6, 2)            %rbp @ cfa − 16
0x00000000&#39;0000113a <span>│</span>  48 89 e5                 <span>│</span>  <span>mov</span>     <span>%rsp</span>, <span>%rbp</span>
<span>[CFI]</span> DW_CFA_def_cfa_register(6)     cfa = %rbp + <span>16</span>
0x00000000&#39;0000113d <span>│</span>  48 8d 05 c0 0e 00 00     <span>│</span>  <span>lea</span>     <span>0x2004</span>, <span>%rax</span>
0x00000000&#39;00001144 <span>│</span>  48 89 c7                 <span>│</span>  <span>mov</span>     <span>%rax</span>, <span>%rdi</span>
0x00000000&#39;00001147 <span>│</span>  e8 e4 fe ff ff           <span>│</span>  <span>call</span>    <span>0x0000000000001030</span>
0x00000000&#39;0000114c <span>│</span>  b8 00 00 00 00           <span>│</span>  <span>mov</span>     <a href="https://lesenechal.fr/cdn-cgi/l/email-protection" data-cfemail="26027979455e4779404f48474a4f5c4366616a6f6465">[email protected]</a>_2.2.5, <span>%eax</span>
0x00000000&#39;00001151 <span>│</span>  5d                       <span>│</span>  <span>pop</span>     <span>%rbp</span>
<span>[CFI]</span> DW_CFA_def_cfa(7, 8)           cfa = %rsp + 8
0x00000000&#39;00001152 <span>│</span>  c3                       <span>│</span>  <span>ret</span></code></pre>
<p>The first two CFI instructions come from the CIE, they define the default rule to
determine the CFA: <code>CFA = %rsp + 8</code>. Then, instruction at <code>0x1139</code> pushes <code>%rbp</code>
onto the stack; this lowers the value of <code>%rsp</code>, requiring the CFA rule to be
updated (the CFA must remain fixed) and becomes <code>CFA = %rsp + 16</code>. Because we
just saved <code>%rbp</code>, a CFI instruction is emitted to inform that <code>%rbp</code> is saved
at <code>CFA - 16</code>. Instruction <code>0x113a</code> then moves <code>%rsp</code> into <code>%ebp</code> and a new CFA
rule is set: <code>CFA = %rbp + 16</code>. We conclude that this function does use <code>%rbp</code>
as a frame pointer.</p>
<h3 id="h2.4-dwarf-expressions">DWARF expressions</h3>
<p>Before moving on, I would like to talk about <strong>DWARF expressions</strong><sup><a href="#ref-8">[8]</a></sup>: they allow
expressing complex value calculations used for CFA rules or register rules that
other types of rules can’t express.</p>
<p>There is one such rule in our test program:</p>
<pre><code>│  ├╴ <span>FDE</span>  offset=0x00000000&#39;00000030  CIE=0x00000000&#39;00000000
│  │  ├╴<span>  PC range</span> │ 0x00000000&#39;00001020..0x00000000&#39;00001040
│  │  ├╴<span>    Symbol</span> │ _init + 0x20
│  │  ├──⮞ DW_CFA_def_cfa_offset(16)    cfa = <span>%rsp</span> + 16
│  │  ├──⮞ DW_CFA_advance_loc(6)        loc += 6        loc = 0x00000000&#39;00001026
│  │  ├──⮞ DW_CFA_def_cfa_offset(24)    cfa = <span>%rsp</span> + 24
│  │  ├──⮞ DW_CFA_advance_loc(10)       loc += 10       loc = 0x00000000&#39;00001030
│  │  ├──⮞ <span>DW_CFA_def_cfa_expression([77, 08, 80, 00, 3f, 1a, 3b, 2a, 33, 24, 22])</span></code></pre>
<p>This FDE, by the way, refers to the PLT trampoline code for <code>puts</code> (yes, the compiler
actually transformed our <code>printf</code> call to a <code>puts</code> call, which makes sense as an optimization).
The <code>DW_CFA_def_cfa_expression</code> instruction defines the CFA as the computation
result of the DWARF expression expressed by this bytecode:</p>
<pre><code><span>77, 08, 80, 00, 3f, 1a, 3b, 2a, 33, 24, 22
</span></code></pre>
<p>Let’s decode that into DWARF symbolic names<sup><a href="#ref-9">[9]</a></sup>:</p>
<pre><code><span>DW_OP_breg7
DW_OP_breg16
DW_OP_lit15
DW_OP_and
DW_OP_lit11
DW_OP_ge
DW_OP_lit3
DW_OP_shl
DW_OP_plus
</span></code></pre>
<p>They represent instructions that must be evalutated in a stack-based virtual machine.
<code>DW_OP_breg7</code> and <code>DW_OP_breg16</code> push the values of <code>%rsp</code> and <code>%rip</code> respectively
onto the VM’s stack, <code>DW_OP_lit15</code> pushes the literal <code>15</code>. <code>DW_OP_and</code>
pops the last two values, performs a bitwise AND on them, and pushes the result on the
stack. We go ahead and execute all instructions this way. The final result is the value
at the top of the stack: the last pushed value.</p>
<p>Let’s rewrite this expression in pseudo-assembly code:</p>
<pre><code>  <span>push</span> <span>%rsp</span>
        <span>push</span> <span>%rip</span>
        <span>push</span> <span>0xf</span>
      <span>and</span>
      <span>push</span> <span>11</span>
    <span>ge</span>
    <span>push</span> <span>3</span>
  <span>shl</span>
<span>plus</span></code></pre>
<p>The indentation helps visualize the structure of operands. For example, <code>plus</code>
takes two arguments: <code>%rsp</code> and the result of <code>shl</code>. <code>shl</code> takes two arguments:
the result of <code>ge</code> and <code>3</code>. We can rewrite one more time the expression in pseudo-code:</p>
<pre><code>CFA = <span>%rsp</span> + ((<span>%rip</span> &amp; <span>0xf</span>) &gt;= <span>11</span> ? <span>1</span> : <span>0</span>) &lt;&lt; <span>3</span>;</code></pre>
<h2 id="h3-generating-cfi-from-assembly">Generating CFI from assembly</h2>
<p>If you are writing C, C++, or Rust, the compiler will emit call frame information
in <code>.eh_frame</code> on your behalf; you don’t have to worry about it. But, if you
write assembly, the onus of describing your functions’ call frames is on you.</p>
<p>Fortunately, assemblers are equipped for the task. In the case of the GNU assembler
<code>as</code>, there is a set of <strong>CFI directives</strong><sup><a href="#ref-10">[10]</a></sup> to generate the call
frame information. Those directives will resemble DWARF CFI instructions for a
reason: the directive will emit the appropriate instructions in <code>.eh_frame</code>.</p>
<p>Here is an example of a function written in GNU assembly for x86-64 with CFI
directives:</p>
<pre><code>    <span>.global</span> foo
    <span>.type</span> foo<span>,</span> @function
<span>foo</span>:
    <span>.cfi_startproc</span>
    
    
    
    <span>push</span>    <span>%rbp</span>
    <span>.cfi_def_cfa_offset</span> 16  
    <span>.cfi_offset</span> 6<span>,</span> -16      

    
    <span>add</span>     <span>%rsi</span><span>,</span> <span>%rdi</span>      
    <span>mov</span>     <span>%rdi</span><span>,</span> <span>%rax</span>      

    
    <span>pop</span>     <span>%rbp</span>
    
    <span>.cfi_def_cfa_offset</span> 8   

    <span>ret</span>
    <span>.cfi_endproc</span>
    <span>.size</span> foo<span>,</span> .-foo
</code></pre>
<p>If we use <a href="https://crates.io/crates/elf-info"><code>elf-info</code></a> to extract CFI from
the binary for the <code>foo</code> symbol, we get this FDE:</p>
<pre><code>│  ├╴ <span>FDE</span>  offset=0x00000000&#39;00000078  CIE=0x00000000&#39;00000000
│  │  ├╴<span>  PC range</span> │ 0x00000000&#39;0000116a..0x00000000&#39;00001173
│  │  ├╴<span>    Symbol</span> │ foo + 0x0
│  │  ├──⮞ DW_CFA_advance_loc(1)          loc += 1      loc = 0x00000000&#39;0000116b
│  │  ├──⮞ DW_CFA_def_cfa_offset(16)      cfa = <span>%rsp</span> + 16
│  │  ├──⮞ DW_CFA_offset(6, 2)            %rbp @ cfa − 16
│  │  ├──⮞ DW_CFA_advance_loc(7)          loc += 7      loc = 0x00000000&#39;00001172
│  │  ├──⮞ DW_CFA_def_cfa_offset(8)       cfa = <span>%rsp</span> + 8</code></pre>
<p>Which, indeed, corresponds to what is described in assembly. Using an assembler
has the advantage of handling <code>DW_CFA_advance_loc</code> for us.</p>
<p>If you use <code>gcc -S</code> option to inspect what assembly GCC generates when compiling
C, you will notice those CFI directives as well; here is what our hello world
main looks like:</p>
<pre><code>        <span>.globl</span>  main
        <span>.type</span>   main<span>,</span> @function
<span>main</span>:
<span>.LFB0</span>:
        <span>.cfi_startproc</span>
        <span>pushq</span>   <span>%rbp</span>
        <span>.cfi_def_cfa_offset</span> 16    
        <span>.cfi_offset</span> 6<span>,</span> -16        
        <span>movq</span>    <span>%rsp</span><span>,</span> <span>%rbp</span>
        <span>.cfi_def_cfa_register</span> 6   
        <span>leaq</span>    .LC0(<span>%rip</span>)<span>,</span> <span>%rax</span>
        <span>movq</span>    <span>%rax</span><span>,</span> <span>%rdi</span>
        <span>call</span>    <a href="https://lesenechal.fr/cdn-cgi/l/email-protection" data-cfemail="a5d5d0d1d6e5f5e9f1">[email protected]</a>
        <span>movl</span>    <span>$0</span><span>,</span> <span>%eax</span>
        <span>popq</span>    <span>%rbp</span>
        <span>.cfi_def_cfa</span> 7<span>,</span> 8         
        <span>ret</span>
        <span>.cfi_endproc</span>
<span>.LFE0</span>:
        <span>.size</span>   main<span>,</span> .-main
</code></pre>
<p>Which is almost the same as the <code>foo</code> function.</p>
<h2 id="h4-eh_frame_hdr-binary-search-lookup-table">
<code>.eh_frame_hdr</code>: binary search lookup table</h2>
<p>We now know that by looking up the <code>.eh_frame</code> section for a given function’s
instruction address (PC), we can find information on how the call frames of this
function are structured, and, therefore, how to unwind them. But how do we
exactly find the <code>.eh_frame</code>’s FDE from that instruction address? One way would
be to iterate over all FDEs until the search address falls into an FDE’s PC
range. That would work; it would also be very inefficient.</p>
<p>Fortunately for us, there is another section we haven’t talked about yet:
<code>.eh_frame_hdr</code><sup><a href="#ref-6">[6]</a></sup>. This section is basically a sorted table of instruction
addresses on which we can perform fast binary search.</p>
<p>Our beloved <a href="https://crates.io/crates/elf-info"><code>elf-info</code></a> can help us once
again to take a look of what’s inside that table:</p>
<pre><code><span>kevin</span>@<span>kevin-desktop</span>:<span>~</span> <span>»</span> elf sh .eh_frame_hdr
<span>───┤ SECTION &#34;.eh_frame_hdr&#34; ├───────────────────────────────────────────────</span>
<span>              Name</span> │ .eh_frame_hdr
<span>              Type</span> │ <span>PROGBITS</span> (0x00000001)
<span>   Virtual address</span> │ 0x00000000&#39;00002014
<span>     Offset in ELF</span> │ 0x00000000&#39;00002014 B
<span>              Size</span> │ 0x00000000&#39;00000024 B (36 B)
<span>         Alignment</span> │ 0x00000000&#39;00000004 B
<span>        Entry size</span> │ <span>0x00000000&#39;00000000 B</span>

<span>─── Header ───</span>
<span>               Version</span> │ 1
<span> eh_frame_ptr encoding</span> │ 0x1b (i32, relative to program counter)
<span>    fde_count encoding</span> │ 0x03 (u32, as is)
<span>        Table encoding</span> │ 0x3b (i32, relative to .eh_frame_hdr start)
<span>     .eh_frame pointer</span> │ 32  (-&gt; 0x00000000&#39;00002038)
<span>            Nr entries</span> │ 3

<span>─── Table content ───</span>
        <span>(     -4084)</span>  0x00000000&#39;00001020  -&gt;  0x00000000&#39;00002068  <span>(        84)</span>
        <span>(     -4052)</span>  0x00000000&#39;00001040  -&gt;  0x00000000&#39;00002050  <span>(        60)</span>
        <span>(     -3803)</span>  0x00000000&#39;00001139  -&gt;  0x00000000&#39;00002090  <span>(       124)</span></code></pre>
<p>There are 3 entries in this program. Each entry associates an instruction address
(PC) in <code>.text</code> to the address of the associated FDE in <code>.eh_frame</code>. The PC
addresses are sorted, so a binary search is possible.</p>
<p>There isn’t much more to say about <code>.eh_frame_hdr</code>, it is simply a
shortcut to quickly find out the FDE associated with an instruction address.</p>
<h2 id="h5-implementing-the-backtrace">Implementing the backtrace</h2>
<p>It is now time to get our hands dirty and actually implement the backtrace
function. Needless to say the implementation will be written in Rust. You could
choose not to have any crate dependencies, but for the sake of staying focused
on the matter, I chose to delegate the DWARF parsing to the
<a href="https://crates.io/crates/gimli"><code>gimli</code></a> crate (0.27.2).</p>
<p>I made a few simplifications for conciseness: first, it is up to you to determine where the
<code>.eh_frame</code> and <code>.eh_frame_hdr</code> live in memory and what size they have. If you
use GNU ld, there will be a <code>__GNU_EH_FRAME_HDR</code> symbol defined pointing to the
<code>.eh_frame_hdr</code> segment which, in turn, contains a pointer to <code>.eh_frame</code>. You
will have to determine yourself the size of those segments: something Gimli doesn’t
make easy unfortunately. Also, I won’t implement all possible CFI rules for
registers and CFA; in particular, I will certainly <em>not</em> implement DWARF
expressions evaluation. Last, this implementation will be tied to x86-64.</p>
<p>What we will do is called <strong>virtual unwinding</strong> since we will <em>simulate</em> the
stack unwinding, we won’t actually restore register values and pop call frames.
Real exceptions <em>do</em> physically unwind the stack and touch registers though, but
computing a backtrace doesn’t.</p>
<h3 id="h5.1-parsing-eh_frame-and-eh_frame_hdr-with-gimli">Parsing <code>.eh_frame</code> and <code>.eh_frame_hdr</code> with Gimli</h3>
<p>Let’s start by parsing the two sections using the
<a href="https://crates.io/crates/gimli"><code>gimli</code></a> crate. We will store the information
in a <code>EhInfo</code> struct that our stack unwinder will consult to produce the stack
trace.</p>
<pre><code><span><span>use</span> <span>gimli<span>::</span></span><span><span>{</span>BaseAddresses<span>,</span> EhFrame<span>,</span> EhHdrTable<span>,</span> EndianSlice<span>,</span> LittleEndian<span>,</span>
            ParsedEhFrameHdr</span><span><span>}</span></span><span>;</span>

<span><span>struct</span> </span><span><span>EhInfo</span> </span><span><span><span>{</span>
        <span>base_addrs</span><span>:</span> BaseAddresses,

        <span>hdr</span><span>:</span> <span>&amp;</span><span>&#39;static</span> <span>ParsedEhFrameHdr<span>&lt;</span><span>EndianSlice<span>&lt;</span><span>&#39;static</span>, LittleEndian<span>&gt;</span></span><span>&gt;</span></span>,

        <span>hdr_table</span><span>:</span> <span>EhHdrTable<span>&lt;</span><span>&#39;static</span>, <span>EndianSlice<span>&lt;</span><span>&#39;static</span>, LittleEndian<span>&gt;</span></span><span>&gt;</span></span>,

        <span>eh_frame</span><span>:</span> <span>EhFrame<span>&lt;</span><span>EndianSlice<span>&lt;</span><span>&#39;static</span>, LittleEndian<span>&gt;</span></span><span>&gt;</span></span>,
</span><span><span>}</span></span></span>
</span></code></pre>
<p>To instantiate the struct, the address of <code>.eh_frame_hdr</code> is passed to the
constructor; the address of <code>.eh_frame</code> will be fetched from the header. The
size of both sections must be retrieved; we will use constants to represent them.</p>
<pre><code><span><span>use</span> <span>gimli<span>::</span></span><span><span>{</span>EhFrameHdr<span>,</span> Pointer</span><span><span>}</span></span><span>;</span>
<span>use</span> <span>std<span>::</span></span>slice<span>;</span>

<span>const</span> <span>EH_FRAME_HDR_SIZE</span><span>:</span> <span>usize</span> <span>=</span> <span>todo!</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
<span>const</span> <span>EH_FRAME_SIZE</span><span>:</span> <span>usize</span> <span>=</span> <span>todo!</span><span><span>(</span></span><span><span>)</span></span><span>;</span>

<span><span>impl</span> </span><span><span>EhInfo</span> </span><span><span><span>{</span>
    <span>unsafe</span> <span><span><span>fn</span> </span><span>from_hdr_ptr</span></span><span><span><span>(</span><span>eh_frame_hdr</span><span>:</span> *const <span>u8</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
        <span>let</span> <span>mut</span> base_addrs <span>=</span> <span>BaseAddresses<span>::</span></span>default<span><span>(</span></span><span><span>)</span></span><span>;</span>
                        base_addrs <span>=</span> base_addrs.<span>set_eh_frame_hdr</span><span><span>(</span>eh_frame_hdr <span>as</span> <span>u64</span></span><span><span>)</span></span><span>;</span>

                        <span>let</span> hdr <span>=</span> <span>Box</span><span><span>::</span></span>leak<span><span>(</span><span>Box</span><span><span>::</span></span>new<span><span>(</span><span>EhFrameHdr<span>::</span></span>new<span><span>(</span>
            <span>unsafe</span> <span><span>{</span> <span>slice<span>::</span></span>from_raw_parts<span><span>(</span>eh_frame_hdr<span>,</span> <span>EH_FRAME_HDR_SIZE</span></span><span><span>)</span></span> </span><span><span>}</span></span><span>,</span>
            LittleEndian<span>,</span>
        </span><span><span>)</span></span>.<span>parse</span><span><span>(</span><span>&amp;</span>base_addrs<span>,</span> <span>8</span></span><span><span>)</span></span>.<span>unwrap</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>

                <span>let</span> eh_frame <span>=</span> <span>match</span> hdr.<span>eh_frame_ptr</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
            <span>Pointer<span>::</span></span>Direct<span><span>(</span>addr</span><span><span>)</span></span> <span>=&gt;</span> addr <span>as</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span>
            <span>_</span> <span>=&gt;</span> <span>unimplemented!</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
        </span><span><span>}</span></span><span>;</span>

                        base_addrs <span>=</span> base_addrs.<span>set_eh_frame</span><span><span>(</span>eh_frame <span>as</span> <span>u64</span></span><span><span>)</span></span><span>;</span>

                <span>let</span> eh_frame <span>=</span> <span>EhFrame<span>::</span></span>new<span><span>(</span>
            <span>unsafe</span> <span><span>{</span> <span>slice<span>::</span></span>from_raw_parts<span><span>(</span>eh_frame<span>,</span> <span>EH_FRAME_SIZE</span></span><span><span>)</span></span> </span><span><span>}</span></span><span>,</span>
            LittleEndian<span>,</span>
        </span><span><span>)</span></span><span>;</span>

        <span>Self</span> <span><span>{</span>
            base_addrs<span>,</span>
            hdr<span>,</span>
            hdr_table<span>:</span> hdr.<span>table</span><span><span>(</span></span><span><span>)</span></span>.<span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
            eh_frame<span>,</span>
        </span><span><span>}</span></span>
    </span><span><span>}</span></span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<h3 id="h5.2-designing-our-stack-unwinder">Designing our stack unwinder</h3>
<p>The core part is the <code>Unwinder</code> struct. It has a reference to the call frame
information via <code>EhInfo</code>, but also stores our unwinding context: what is the
current CFA and the current values of registers for the virtual unwinding.</p>
<pre><code><span><span>use</span> <span>gimli<span>::</span></span><span><span>{</span>EndianSlice<span>,</span> LittleEndian<span>,</span> UnwindContext</span><span><span>}</span></span><span>;</span>

<span><span>struct</span> </span><span><span>Unwinder</span> </span><span><span><span>{</span>
        <span>eh_info</span><span>:</span> EhInfo,

        <span>unwind_ctx</span><span>:</span> <span>UnwindContext<span>&lt;</span><span>EndianSlice<span>&lt;</span><span>&#39;static</span>, LittleEndian<span>&gt;</span></span><span>&gt;</span></span>,

            <span>regs</span><span>:</span> RegisterSet,

        <span>cfa</span><span>:</span> <span>u64</span>,

        <span>is_first</span><span>:</span> <span>bool</span>,
</span><span><span>}</span></span></span>
</span></code></pre>
<p>The unwinder will have a <code>next()</code> method to iterate over call frames:</p>
<pre><code><span><span><span>impl</span> </span><span><span>Unwinder</span> </span><span><span><span>{</span>
    <span><span><span>fn</span> </span><span>new</span></span><span><span><span>(</span>
        <span>eh_info</span><span>:</span> EhInfo,
        <span>register_set</span><span>:</span> RegisterSet,
    </span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
        <span>Self</span> <span><span>{</span>
            eh_info<span>,</span>
            unwind_ctx<span>:</span> <span>UnwindContext<span>::</span></span>new<span><span>(</span></span><span><span>)</span></span><span>,</span>
            regs<span>:</span> register_set<span>,</span>
            cfa<span>:</span> <span>0</span><span>,</span>
            is_first<span>:</span> <span>true</span><span>,</span>
        </span><span><span>}</span></span>
    </span><span><span>}</span></span></span>

    <span><span><span>fn</span> </span><span>next</span></span><span><span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Result<span>&lt;</span><span>Option<span>&lt;</span>CallFrame<span>&gt;</span></span>, UnwinderError<span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>todo!</span><span><span>(</span></span><span><span>)</span></span>
    </span><span><span>}</span></span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>It is up to the caller to know the current value of registers by passing an
instance of <code>RegisterSet</code>. The <code>next()</code> method returns instances of <code>CallFrame</code>:</p>
<pre><code><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>struct</span> </span><span><span>CallFrame</span> </span><span><span><span>{</span>
    <span>pub</span> <span>pc</span><span>:</span> <span>u64</span>,
</span><span><span>}</span></span></span>
</span></code></pre>
<p>It simply contains the instruction pointer: the current instruction for the last
frame, and the calling instruction for all other frames. The method can return
<code>None</code> if there is no more frames, or <code>Err(...)</code> if an error occurred during
unwinding. Possible errors are:</p>
<pre><code><span><span>use</span> <span>gimli<span>::</span></span>Register<span>;</span>

<span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>enum</span> <span>UnwinderError</span> <span><span>{</span>
    UnexpectedRegister<span><span>(</span>Register</span><span><span>)</span></span><span>,</span>
    UnsupportedCfaRule<span>,</span>
    UnimplementedRegisterRule<span>,</span>
    CfaRuleUnknownRegister<span><span>(</span>Register</span><span><span>)</span></span><span>,</span>
    NoUnwindInfo<span>,</span>
    NoPcRegister<span>,</span>
    NoReturnAddr<span>,</span>
</span><span><span>}</span></span></span>
</span></code></pre>
<h3 id="h5.3-the-set-of-registers">The set of registers</h3>
<p>To keep track of register values, we create a <code>RegisterSet</code> struct:</p>
<pre><code><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> Default</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>struct</span> </span><span><span>RegisterSet</span> </span><span><span><span>{</span>
    <span>rip</span><span>:</span> <span>Option<span>&lt;</span><span>u64</span><span>&gt;</span></span>,
    <span>rsp</span><span>:</span> <span>Option<span>&lt;</span><span>u64</span><span>&gt;</span></span>,
    <span>rbp</span><span>:</span> <span>Option<span>&lt;</span><span>u64</span><span>&gt;</span></span>,
    <span>ret</span><span>:</span> <span>Option<span>&lt;</span><span>u64</span><span>&gt;</span></span>,
</span><span><span>}</span></span></span>
</span></code></pre>
<p>As you see, we aren’t interested in all registers. <code>ret</code> is the return address,
it is considered a register in DWARF (named <code>%RA</code>), as it is an actual register on some
architectures; on x86, the return address is stored on the stack.</p>
<p>If <code>None</code>, this means the register’s value is currently undefined; trying to
compute an offset based on that register will therefore raise an error.</p>
<p>We then add a few methods to get and set values:</p>
<pre><code><span><span>use</span> <span>gimli<span>::</span></span><span><span>{</span><span>X86_64</span><span>,</span> Register</span><span><span>}</span></span><span>;</span>

<span><span>impl</span> </span><span><span>RegisterSet</span> </span><span><span><span>{</span>
    <span><span><span>fn</span> </span><span>get</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>reg</span><span>:</span> Register</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Option<span>&lt;</span><span>u64</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>match</span> reg <span><span>{</span>
            <span>X86_64</span><span><span>::</span></span><span>RSP</span> <span>=&gt;</span> <span>self</span>.rsp<span>,</span>
            <span>X86_64</span><span><span>::</span></span><span>RBP</span> <span>=&gt;</span> <span>self</span>.rbp<span>,</span>
            <span>X86_64</span><span><span>::</span></span><span>RA</span> <span>=&gt;</span> <span>self</span>.ret<span>,</span>
            <span>_</span> <span>=&gt;</span> <span>None</span><span>,</span>
        </span><span><span>}</span></span>
    </span><span><span>}</span></span></span>

    <span><span><span>fn</span> </span><span>set</span></span><span><span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span>, <span>reg</span><span>:</span> Register, <span>val</span><span>:</span> <span>u64</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Result<span>&lt;</span><span>(</span><span>)</span>, UnwinderError<span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>*</span><span>match</span> reg <span><span>{</span>
            <span>X86_64</span><span><span>::</span></span><span>RSP</span> <span>=&gt;</span> <span>&amp;</span><span>mut</span> <span>self</span>.rsp<span>,</span>
            <span>X86_64</span><span><span>::</span></span><span>RBP</span> <span>=&gt;</span> <span>&amp;</span><span>mut</span> <span>self</span>.rbp<span>,</span>
            <span>X86_64</span><span><span>::</span></span><span>RA</span> <span>=&gt;</span> <span>&amp;</span><span>mut</span> <span>self</span>.ret<span>,</span>
            <span>_</span> <span>=&gt;</span> <span>return</span> <span>Err</span><span><span>(</span><span>UnwinderError<span>::</span></span>UnexpectedRegister<span><span>(</span>reg</span><span><span>)</span></span></span><span><span>)</span></span><span>,</span>
        </span><span><span>}</span></span> <span>=</span> <span>Some</span><span><span>(</span>val</span><span><span>)</span></span><span>;</span>

        <span>Ok</span><span><span>(</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span>
    </span><span><span>}</span></span></span>

    <span><span><span>fn</span> </span><span>undef</span></span><span><span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span>, <span>reg</span><span>:</span> Register</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
        <span>*</span><span>match</span> reg <span><span>{</span>
            <span>X86_64</span><span><span>::</span></span><span>RSP</span> <span>=&gt;</span> <span>&amp;</span><span>mut</span> <span>self</span>.rsp<span>,</span>
            <span>X86_64</span><span><span>::</span></span><span>RBP</span> <span>=&gt;</span> <span>&amp;</span><span>mut</span> <span>self</span>.rbp<span>,</span>
            <span>X86_64</span><span><span>::</span></span><span>RA</span> <span>=&gt;</span> <span>&amp;</span><span>mut</span> <span>self</span>.ret<span>,</span>
            <span>_</span> <span>=&gt;</span> <span>return</span><span>,</span>
        </span><span><span>}</span></span> <span>=</span> <span>None</span><span>;</span>
    </span><span><span>}</span></span></span>

    <span><span><span>fn</span> </span><span>get_pc</span></span><span><span><span>(</span><span>&amp;</span><span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Option<span>&lt;</span><span>u64</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>self</span>.rip
    </span><span><span>}</span></span></span>

    <span><span><span>fn</span> </span><span>set_pc</span></span><span><span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span>, <span>val</span><span>:</span> <span>u64</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
        <span>self</span>.rip <span>=</span> <span>Some</span><span><span>(</span>val</span><span><span>)</span></span><span>;</span>
    </span><span><span>}</span></span></span>

    <span><span><span>fn</span> </span><span>get_ret</span></span><span><span><span>(</span><span>&amp;</span><span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Option<span>&lt;</span><span>u64</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>self</span>.ret
    </span><span><span>}</span></span></span>

    <span><span><span>fn</span> </span><span>set_stack_ptr</span></span><span><span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span>, <span>val</span><span>:</span> <span>u64</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
        <span>self</span>.rsp <span>=</span> <span>Some</span><span><span>(</span>val</span><span><span>)</span></span><span>;</span>
    </span><span><span>}</span></span></span>

    <span><span><span>fn</span> </span><span>iter</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> impl <span>Iterator<span>&lt;</span>Item = Register<span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span><span>[</span><span>X86_64</span><span><span>::</span></span><span>RSP</span><span>,</span> <span>X86_64</span><span><span>::</span></span><span>RBP</span><span>,</span> <span>X86_64</span><span><span>::</span></span><span>RA</span><span>]</span></span>.<span>into_iter</span><span><span>(</span></span><span><span>)</span></span>
    </span><span><span>}</span></span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>The purpose of this struct is to facilitate portability across architectures.</p>
<h3 id="h5.4-unwinding-the-stack">Unwinding the stack</h3>
<p>We are now ready to implement the <code>next()</code> method of our <code>Unwinder</code>.</p>
<pre><code><span><span>use</span> <span>gimli<span>::</span></span><span><span>{</span>UnwindSection<span>,</span> CfaRule<span>,</span> RegisterRule</span><span><span>}</span></span><span>;</span>

<span><span>impl</span> </span><span><span>Unwinder</span> </span><span><span><span>{</span>
    
    <span><span><span>fn</span> </span><span>next</span></span><span><span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Result<span>&lt;</span><span>Option<span>&lt;</span>CallFrame<span>&gt;</span></span>, UnwinderError<span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>let</span> pc <span>=</span> <span>self</span>.regs.<span>get_pc</span><span><span>(</span></span><span><span>)</span></span>.<span>ok_or</span><span><span>(</span><span>UnwinderError<span>::</span></span>NoPcRegister</span><span><span>)</span></span><span>?</span><span>;</span>

        <span>if</span> <span>self</span>.is_first <span><span>{</span>
            <span>self</span>.is_first <span>=</span> <span>false</span><span>;</span>
            <span>return</span> <span>Ok</span><span><span>(</span><span>Some</span><span><span>(</span>CallFrame <span><span>{</span> pc </span><span><span>}</span></span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
        </span><span><span>}</span></span>
</span></span></span></span></span></code></pre>
<p>The current PC (instruction pointer) value is retrieved from the register set.
If this is the first time we call <code>next()</code>, we don’t unwind anything and simply
return the value of that PC value, since we already are in the last call frame.</p>
<pre><code><span>        <span>let</span> row <span>=</span> <span>self</span>.eh_info.hdr_table.<span>unwind_info_for_address</span><span><span>(</span>
            <span>&amp;</span><span>self</span>.eh_info.eh_frame<span>,</span>
            <span>&amp;</span><span>self</span>.eh_info.base_addrs<span>,</span>
            <span>&amp;</span><span>mut</span> <span>self</span>.unwind_ctx<span>,</span>
            pc<span>,</span>
            <span><span><span>|</span></span></span><span><span><span>section</span><span>,</span> <span>bases</span><span>,</span> <span>offset</span><span>|</span></span> </span><span>section.<span>cie_from_offset</span><span><span>(</span>bases<span>,</span> offset</span><span><span>)</span></span><span>,</span>
        </span></span><span><span>)</span></span>.<span>map_err</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>|</span></span> </span><span><span>UnwinderError<span>::</span></span>NoUnwindInfo</span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></code></pre>
<p>We then lookup through the <code>.eh_frame_hdr</code> table for the call frame information
associated with the current instruction pointer. This returns a
<strong>row</strong>; remember the conceptual table of CFI? This is exactly that: the row
describes the CFA and register rules for the target instruction.</p>
<p>We first compute the CFA:</p>
<pre><code><span>        <span>match</span> row.<span>cfa</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
            <span>CfaRule<span>::</span></span>RegisterAndOffset <span><span>{</span> register<span>,</span> offset </span><span><span>}</span></span> <span>=&gt;</span> <span><span>{</span>
                <span>let</span> reg_val <span>=</span> <span>self</span>.regs.<span>get</span><span><span>(</span><span>*</span>register</span><span><span>)</span></span>
                    .<span>ok_or</span><span><span>(</span><span>UnwinderError<span>::</span></span>CfaRuleUnknownRegister<span><span>(</span><span>*</span>register</span><span><span>)</span></span></span><span><span>)</span></span><span>?</span><span>;</span>
                <span>self</span>.cfa <span>=</span> <span><span>(</span>reg_val <span>as</span> <span>i64</span> <span>+</span> offset</span><span><span>)</span></span> <span>as</span> <span>u64</span><span>;</span>
            </span><span><span>}</span></span><span>,</span>
            <span>_</span> <span>=&gt;</span> <span>return</span> <span>Err</span><span><span>(</span><span>UnwinderError<span>::</span></span>UnsupportedCfaRule</span><span><span>)</span></span><span>,</span>
        </span><span><span>}</span></span>
</span></code></pre>
<p>We don’t support evaluating DWARF expressions, this is left as an exercise to
the reader. Computing the CFA is pretty straight forward: fetch the value of the
register named in the rule and add the given offset. We return an error if we
don’t keep track of the requested register or if its value is undefined.</p>
<p>Then, for each tracked register, we apply its rule:</p>
<pre><code><span>        <span>for</span> reg <span>in</span> <span>RegisterSet<span>::</span></span>iter<span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
            <span>match</span> row.<span>register</span><span><span>(</span>reg</span><span><span>)</span></span> <span><span>{</span>
                <span>RegisterRule<span>::</span></span>Undefined <span>=&gt;</span> <span>self</span>.regs.<span>undef</span><span><span>(</span>reg</span><span><span>)</span></span><span>,</span>
                <span>RegisterRule<span>::</span></span>SameValue <span>=&gt;</span> <span><span>(</span></span><span><span>)</span></span><span>,</span>
                <span>RegisterRule<span>::</span></span>Offset<span><span>(</span>offset</span><span><span>)</span></span> <span>=&gt;</span> <span><span>{</span>
                    <span>let</span> ptr <span>=</span> <span><span>(</span><span>self</span>.cfa <span>as</span> <span>i64</span> <span>+</span> offset</span><span><span>)</span></span> <span>as</span> <span>u64</span> <span>as</span> <span>*</span><span>const</span> <span>usize</span><span>;</span>
                    <span>self</span>.regs.<span>set</span><span><span>(</span>reg<span>,</span> <span>unsafe</span> <span><span>{</span> ptr.<span>read</span><span><span>(</span></span><span><span>)</span></span> </span><span><span>}</span></span> <span>as</span> <span>u64</span></span><span><span>)</span></span><span>?</span><span>;</span>
                </span><span><span>}</span></span><span>,</span>
                <span>_</span> <span>=&gt;</span> <span>return</span> <span>Err</span><span><span>(</span><span>UnwinderError<span>::</span></span>UnimplementedRegisterRule</span><span><span>)</span></span><span>,</span>
            </span><span><span>}</span></span>
        </span><span><span>}</span></span>
</span></code></pre>
<p>If the rule says the register is now undefined, we set it to <code>None</code> in our
register set. <code>SameValue</code> is a no-op. For the <code>Offset</code> rule, we simply retrieve
the value from the stack at the address <code>CFA + offset</code>. All other rules are
unimplemented and return an error.</p>
<pre><code><span>        <span>let</span> pc <span>=</span> <span>self</span>.regs.<span>get_ret</span><span><span>(</span></span><span><span>)</span></span>.<span>ok_or</span><span><span>(</span><span>UnwinderError<span>::</span></span>NoReturnAddr</span><span><span>)</span></span><span>?</span> <span>-</span> <span>1</span><span>;</span>
        <span>self</span>.regs.<span>set_pc</span><span><span>(</span>pc</span><span><span>)</span></span><span>;</span>
        <span>self</span>.regs.<span>set_stack_ptr</span><span><span>(</span><span>self</span>.cfa</span><span><span>)</span></span><span>;</span>

        <span>Ok</span><span><span>(</span><span>Some</span><span><span>(</span>CallFrame <span><span>{</span> pc </span><span><span>}</span></span></span><span><span>)</span></span></span><span><span>)</span></span>
    }
}
</span></code></pre>
<p>We then get the new value of <code>%rip</code> from the function’s return value and
subtract 1 to it: the address actually points to the <em>next</em> instruction right
after the <code>call</code>; by subtracting 1, the address now points to the <code>call</code>. The
fact that the address doesn’t point to the <em>first</em> byte of the <code>call</code> instruction
will be good enough for us.</p>
<p>Then, the CFA becomes our new <code>%rsp</code>: this, in fact, simulates the return from the
function, we basically destroyed the call frame. <em>Virtual</em> unwinding takes on its
full meaning here.</p>
<p>Finally, the value of the new <code>%rip</code> is returned as it now points to the calling
instruction in the above call frame.</p>
<h3 id="h5.5-going-further">Going further</h3>
<p>That’s it, you made it to the end. We were able to construct a stack trace based
on the CFI information the compiler provided us via <code>.eh_frame</code> by performing
virtual stack unwinding.</p>
<p>What the caller receives are only instruction addresses though. A good stack trace
must also display additional information:</p>
<ul>
<li>The name of the function, its demangled symbol (for languages like Rust or C++);</li>
<li>The address offset from the start of the function;</li>
<li>The source file and line number of the instruction;</li>
<li>The parameter types and values.</li>
</ul>
<p>These are not covered in this article. You will have to consult the other
DWARF debugging symbols.</p>
<h2 id="h6-references">References</h2>
<ol>
<li>
<span id="ref-1"></span> <a href="https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Optimize-Options.html">GCC 12.2 manual, §3.11, “Options That Control Optimization”</a>
</li>
<li>
<span id="ref-2"></span> <a href="https://dwarfstd.org/doc/DWARF5.pdf">DWARF format v5</a>, §6.4 “Call Frame Information”, p. 171</li>
<li>
<span id="ref-3"></span> <a href="https://dwarfstd.org/doc/DWARF5.pdf">DWARF format v5</a>, §6.4.2 “Call Frame Instructions”, p. 176</li>
<li>
<span id="ref-4"></span> <a href="https://dwarfstd.org/doc/DWARF5.pdf">DWARF format v5</a>, §6.4.1 “Structure of Call Frame Information”, p. 173</li>
<li>
<span id="ref-5"></span> <a href="https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html#EHFRAMEHDR">Linux LSB 5.0.0, §10.6.2 “The <code>.eh_frame_hdr</code> section”</a>
</li>
<li>
<span id="ref-6"></span> <a href="https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html#EHFRAMECHPT">Linux LSB 5.0.0, §10.6 “Exception Frames”</a>
</li>
<li>
<span id="ref-7"></span> <a href="https://www.uclibc.org/docs/psABI-x86_64.pdf">System V ABI, AMD64 supplement</a>, §3.2.3 “Parameter Passing”, p. 21</li>
<li>
<span id="ref-8"></span> <a href="https://dwarfstd.org/doc/DWARF5.pdf">DWARF format v5</a>, §2.5 “DWARF Expressions”, p. 26</li>
<li>
<span id="ref-9"></span> <a href="https://dwarfstd.org/doc/DWARF5.pdf">DWARF format v5</a>, §7.7.1 “DWARF Expressions”, pp. 223–226</li>
<li>
<span id="ref-10"></span> <a href="https://sourceware.org/binutils/docs/as/CFI-directives.html">binutils documentation, §7.12 “CFI directives”</a>
</li>
</ol>

</article></div>
  </body>
</html>
