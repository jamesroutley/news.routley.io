<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jacko.io/safety_and_soundness.html">Original</a>
    <h1>Safety and Soundness in Rust</h1>
    
    <div id="readability-page-1" class="page"><article>
<p><a href="https://jacko.io/index.html">â†« Home</a></p>



<section>

<p>Rust is designed around safety and soundness. Roughly speaking, safe code is
code that doesn&#39;t use the <code>unsafe</code> keyword,<label for="sidenote-safe_meanings"></label><span>What we mean by &#34;safe&#34; depends on context, which is partly
what this post is about. Sometimes we even talk about safety and soundness
interchangeably, but here I want to emphasize the differences between them.</span> and sound code is
code that can&#39;t cause memory corruption or other undefined
behavior.<label for="sidenote-undefined_behavior"></label><span>&#34;Undefined behavior&#34; (UB) has a <a href="https://en.wikipedia.org/wiki/Undefined_behavior">specific
meaning</a> in languages like
C, C++, and Rust, which is different from &#34;unspecified&#34; or
&#34;implementation-defined&#34; behavior.</span> One of Rust&#39;s most important features is the
promise that all safe code is sound. But that promise can be broken when
<code>unsafe</code> code is involved, and <code>unsafe</code> code is almost always involved
somewhere. Data structures like <code>Vec</code> and <code>HashMap</code> have <code>unsafe</code> code in their
implementations, as does any function like <code>File::open</code> that talks to the OS.
This leads to a common question: <strong>&#34;If Rust can&#39;t guarantee that all safe code
is sound, how can it be a memory-safe language?&#34;</strong> It&#39;s hard to give a short
answer to that question, so this post is my attempt at a medium-length answer.</p>
</section>

<section>
<h2>The short answer</h2>

<p>This version is dense and technical. You might want to take a quick look at it,
move on to the next section, and then come back for a another look at the end.</p>

<blockquote><p>Rust has a list of <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">behaviors considered
undefined</a>.<label for="sidenote-formal_spec"></label><span>Rust doesn&#39;t yet have a formal specification, but <a href="https://blog.m-ou.se/rust-standard/">there&#39;s
general agreement</a> that it needs one,
and there&#39;s at least one <a href="https://ferrous-systems.com/ferrocene/">serious ongoing
effort</a> to write one. Shortcuts like
&#34;do what C does&#34; are complicated by known gaps in the C specification in
<a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">areas like &#34;pointer
provenance&#34;</a>. There are
<a href="https://github.com/rust-lang/rust/issues/95228">ongoing experiments</a> around
how to close those gaps, and the <a href="https://github.com/rust-lang/miri">Miri</a>
project is also trying to make sure that the formal rules for UB will be
programmatically checkable.</span>
A &#34;sound&#34; function is one that maintains the following invariant: any program
that only calls sound functions and doesn&#39;t contain any other <code>unsafe</code> code,
can&#39;t commit UB.<label for="sidenote-self_referential"></label><span>This definition is self-referential; the soundness of a
function depends on what other functions are considered sound. It&#39;s possible
to come up with two functions where either one could be sound, but not both
at the same time. Niko Matsakis described how <a href="http://smallcultfollowing.com/babysteps/blog/2016/10/02/observational-equivalence-and-unsafe-code/#composing-unsafe-abstractions">a hypothetical safe wrapper
around
<code>setjmp</code>/<code>longjmp</code></a>
could be sound in combination with &#34;fundamental&#34; Rust but unsound in
combination with common (and now
<a href="https://doc.rust-lang.org/stable/std/thread/fn.scope.html">standard</a>)
threading libraries. There are <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/379">a few other known
examples</a> of
&#34;soundness forks&#34;, but these issues are rare in application code.</span> A function that doesn&#39;t use any <code>unsafe</code>
code, either directly or indirectly, is guaranteed to be
sound.<label for="sidenote-soundness_holes"></label><span>The Rust compiler has <a href="https://lcnr.de/blog/diving-deep-implied-bounds-and-variance/">known
bugs</a> where it
accepts some programs that should&#39;ve failed to compile, and these bugs make
it possible for 100% safe programs to commit UB. We call these bugs
&#34;soundness holes&#34;. It&#39;s rare for these to affect real-world code, though, and
the minimized examples that trigger them are often pretty hard to understand.
All the soundness holes we know of will get fixed eventually. Formally
proving that Rust can fix all its soundness holes is a <a href="https://plv.mpi-sws.org/rustbelt/">major research
project</a> and the sort of thing you might
<a href="https://research.ralfj.de/thesis.html">write your PhD thesis about</a>.</span> A function that doesn&#39;t use any <code>unsafe</code> code
directly and only calls other sound functions, is also sound by definition.
But functions and modules that use <code>unsafe</code> code directly could be unsound,
and a transitive caller of an unsound function could also be unsound. Any
unsoundness in the safe, public API of a module is a bug.<label for="sidenote-module_soundness"></label><span>We usually evaluate soundness at module boundaries,
because a safe write to a private field that other <code>unsafe</code> code depends on
is often enough to commit UB. For example, any function in the implementation
of <code>Vec</code> could overwrite the private <code>len</code> field and then do out-of-bounds
reads and writes without using the <code>unsafe</code> keyword directly.</span></p></blockquote>
</section>

<section>
<h2>The medium-length answer</h2>

<p>Consider the following Rust function, <code>foo1</code>, which reads a byte out of a
static string:<label for="sidenote-implicit_return"></label><span>When the last line of a Rust function doesn&#39;t end in a
semicolon, that&#39;s an implicit <code>return</code>.</span></p>

<pre><code><span>static </span><span>BYTES</span><span>: </span><span>&amp;</span><span>[</span><span>u8</span><span>] </span><span>= </span><span>b</span><span>&#34;</span><span>hello world</span><span>&#34;</span><span>;</span></code></pre>

<p>Here&#39;s a C version of <code>foo1</code>:</p>

<pre><code><span>const </span><span>char</span><span>*</span><span> BYTES = </span><span>&#34;</span><span>hello world</span><span>&#34;</span><span>;</span></code></pre>

<p>Both versions of <code>foo1</code> bounds-check the value of <code>index</code> before they use it.
This check is automatic in the Rust version. Because of this check, we can&#39;t
make <code>foo1</code> commit UB just by giving it a large <code>index</code>. Instead, the only way
I can think of to make <code>foo1</code> commit UB is to <a href="https://godbolt.org/z/e5bbq95hx">give it an <em>uninitialized</em>
<code>index</code></a>. In C, we&#39;d probably think of the
resulting UB as &#34;the caller&#39;s fault&#34;. In Rust, using an uninitialized argument
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e23c9b052892c7c3e2b8bf5cd9f5cd98">won&#39;t compile in safe
code</a>,
and doing it with <code>unsafe</code> code is <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=be72905a4c634a62298d4aca5cca6dc4">already UB in the
caller</a>,
before we even get to the body of <code>foo1</code>. Since the Rust version of <code>foo1</code> will
never cause UB without the caller committing UB first, <code>foo1</code> is <strong>sound</strong>.
Rust guarantees that functions like <code>foo1</code>, which don&#39;t use any <code>unsafe</code> code
either directly or indirectly, will always be sound.</p>

<p>Now consider a slightly different function, <code>foo2</code>, which doesn&#39;t do a bounds
check:</p>

<pre><code><span>unsafe </span><span>fn </span><span>foo2</span><span>(</span><span>index</span><span>: </span><span>usize</span><span>) -&gt; </span><span>u8 </span><span>{</span></code></pre>

<p>Here&#39;s a C version of <code>foo2</code>:</p>

<pre><code><span>char </span><span>foo2</span><span>(</span><span>size_t </span><span>index</span><span>) {</span></code></pre>

<p>Calling either version of <code>foo2</code> with an <code>index</code> that&#39;s too large will read
past the end of <code>BYTES</code>, which is UB. Note that the Rust version of <code>foo2</code> is
declared <code>unsafe</code> in its signature, so calling it outside of another <code>unsafe</code>
function or <code>unsafe</code> block <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ad9e08dd2e82a7411549a959c3eecf6b">is a compiler
error</a>.
Since we can&#39;t call <code>foo2</code> in safe code, we don&#39;t usually ask whether <code>foo2</code> is
sound or unsound; we just say that it&#39;s &#34;unsafe&#34;.<label for="sidenote-unsafe_and_sound"></label><span>In theory there&#39;s nothing wrong with a function that&#39;s
both sound and <code>unsafe</code>, but in practice it&#39;s odd. Why not allow safe code to
call the function, if it can&#39;t lead to UB? One answer could be that the
function is expected to become unsound in the future, so it&#39;s marked <code>unsafe</code>
now for compatibility.</span>
Dereferencing raw pointers like this isn&#39;t allowed in safe Rust, so deleting
the <code>unsafe</code> keyword <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e032302c44ce33a78b8c189ef488fc50">is also a compiler
error</a>.</p>

<p>But if we move the <code>unsafe</code> keyword down a bit, we start to get into trouble.
This function compiles:</p>

<pre><code><span>fn </span><span>foo3</span><span>(</span><span>index</span><span>: </span><span>usize</span><span>) -&gt; </span><span>u8 </span><span>{</span></code></pre>

<p><code>foo3</code> is like <code>foo2</code>, except we&#39;ve removed the <code>unsafe</code> keyword from the
declaration and replaced it with an <code>unsafe</code> block in the body. That means we
can <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=2546a5a170867d564e26ca01edd03b80">call <code>foo3</code> and commit UB from safe
code</a>.
In other words, <code>foo3</code> is <strong>unsound</strong>.</p>

<p>We can get in deeper trouble by adding some indirection:</p>

<pre><code><span>fn </span><span>foo4</span><span>(</span><span>index</span><span>: </span><span>usize</span><span>) -&gt; </span><span>u8 </span><span>{</span></code></pre>

<p><code>foo4</code> is a thin wrapper around <code>foo3</code>, so <code>foo4</code> is <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=a6d4a020eecfd0f01f8252ed24c4a254">also
unsound</a>.
But <code>foo4</code> doesn&#39;t contain any <code>unsafe</code> code of its own. Instead, the
unsoundness of <code>foo3</code> has &#34;infected&#34; <code>foo4</code>. This sort of thing is why we can&#39;t
make a strong guarantee that all safe code is sound.</p>

<p>However, there&#39;s a slightly weaker guarantee that we can make. <code>foo4</code> doesn&#39;t
contain any <code>unsafe</code> code of its own, so it can&#39;t be unsound all by itself.
There must be some <code>unsafe</code> code somewhere that&#39;s
responsible.<label for="sidenote-weird_exceptions"></label><span>Apart from &#34;soundness holes&#34; in the compiler, it&#39;s also
possible for safe code to corrupt memory by asking the OS to do it in ways
the compiler doesn&#39;t know about. This includes tricks like writing to
<code>/proc/$PID/mem</code>, or spawning a debugger and attaching it to yourself. If we
wanted to execute <em>malicious</em> safe code and still guarantee memory safety,
we&#39;d need lots of help from the OS, and relying on process isolation instead
of memory safety would probably make more sense.</span> In this case of course, it&#39;s <code>foo3</code> that&#39;s
broken. There are two different ways we could fix <code>foo3</code>: We could declare that
it&#39;s <code>unsafe</code> in its signature, like <code>foo2</code>, which would <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=62bc28bc732a2c861544ccdfd1b4854d">make <code>foo4</code> a
compiler
error</a>.
Or we could make it do bounds checks, like <code>foo1</code>, which would make <code>foo4</code>
sound with no changes. If we got rid of the <code>unsafe</code> code in <code>foo3</code>, then one
way or another Rust would make us do bounds checks.</p>

<p>So the simple promise of &#34;no UB in safe code&#34; can be broken. The slightly
weaker guarantee above is harder to explain, but it&#39;s the more correct idea,
and it&#39;s arguably Rust&#39;s most fundamental principle: <strong>A safe caller can&#39;t be
&#34;at fault&#34; for memory corruption or other UB.</strong></p>

<p>In this sense, wrapping <code>unsafe</code> Rust in a safe API is similar to wrapping C
code in a Python API, or in any other memory-safe language.<label for="sidenote-google_jni"></label><span>The Google Security Blog <a href="https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html">made a similar
comparison</a>
between <code>unsafe</code> Rust and JNI in Java.</span>
Mistakes in Python aren&#39;t supposed to cause memory corruption, and if they do,
we usually consider that a bug in the C bindings. Writing and reviewing
bindings isn&#39;t easy, but most applications contain little or no binding code of
their own. Similarly, most Rust applications contain little or no <code>unsafe</code> code
of their own, and memory corruption is rare.</p>

<hr/>

<p>Discussion threads on
<a href="https://www.reddit.com/r/rust/comments/11j8k8d/safety_and_soundness_in_rust/?">r/rust</a>
and <a href="https://news.ycombinator.com/item?id=35032915">Hacker News</a>.</p>

</section>
</article></div>
  </body>
</html>
