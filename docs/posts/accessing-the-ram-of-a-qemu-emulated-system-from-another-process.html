<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.reds.ch/?p=1379">Original</a>
    <h1>Accessing the RAM of a QEMU Emulated System from Another Process</h1>
    
    <div id="readability-page-1" class="page"><section id="pagetitle">
	<div>
		<p><a href="https://blog.reds.ch">Home</a><span></span><span>Accessing the RAM of a QEMU Emulated System from another Process</span>
</p>	</div>
</section><div id="main">
	<div>
		<section id="content">
									<article id="post-1379"> 
		
	<div>
				
		<div>
			
<p>Sometimes it may be of interest to expose the RAM of a hardware platform emulated in <a rel="noreferrer noopener" href="https://www.qemu.org" target="_blank">QEMU</a> to an outside process, e.g., for monitoring, testing, or co-simulation.</p>



<p>The <a rel="noreferrer noopener" href="https://qemu.readthedocs.io/en/latest/system/monitor.html" target="_blank">QEMU monitor</a> allows to inspect the memory but is not necessarily the most practical tool when you need to access it from another process, e.g., a C program or an external simulator, maybe Questasim simulating a device written in SystemVerilog.</p>



<p>In this post I will show how to make the memory of an x86_64 emulated PC system visible to other processes. There are some <a rel="noreferrer noopener" href="https://github.com/qemu/qemu/blob/master/docs/memory-hotplug.txt" target="_blank">examples</a> online, I could not find any that would expose the main memory, only parts, like <a rel="noreferrer noopener" href="https://docs.pmem.io/persistent-memory/getting-started-guide/creating-development-environments/virtualization/qemu" target="_blank">NVDIMMs</a> (Non Volatile DIMMs). The <a rel="noreferrer noopener" href="https://qemu.readthedocs.io/en/latest/" target="_blank">QEMU documentation</a> is very complete, however, it is not always easy to find what you are looking for.</p>



<p>I wrote this post to provide a demonstration on how to make the main memory of a system emulated in QEMU accessible to other processes because I could not find a complete example online.</p>



<p>TL DR : <a href="#tldr">See section TL DR</a></p>



<h2>Introduction</h2>



<p>Let’s say we are launching QEMU with the following command :</p>



<p><code>qemu -M pc -nographic -m 512m -smp cpus=2 -kernel ./bzImage_5.9 -drive file=./rootfs-target.img,if=ide -append &#34;console=ttyS0 root=/dev/sda rw panic=1 earlyprintk=serial,ttyS0,115200&#34;</code></p>



<p>This launches a machine of type “pc”, without graphics, 512M of RAM, two CPUs, a provided Linux 5.9 kernel as well as a single IDE drive. The <code>-append</code> string is passed to the Linux kernel and serves to indicate the serial console and the location of the rootfs.</p>



<p>The 512M of main memory specified with<code> -m 512m</code> uses the default QEMU memory backend. However, QEMU has alternative <a rel="noreferrer noopener" href="https://github.com/qemu/qemu/blob/master/include/sysemu/hostmem.h" target="_blank">memory backends</a>.</p>



<ul><li><code>memory-backend-ram</code> – The default backend</li><li><code>memory-backend-file</code> – Memory backed by a file, typcially used for non volatile memories (to save the contents when powering off the machine)</li><li><code>memory-backend-memfd</code> – Anonymous memory file backend</li></ul>



<p>The <a rel="noreferrer noopener" href="https://qemu.readthedocs.io/en/latest/system/invocation.html#hxtool-10" target="_blank">QEMU Documentation</a> suggests to use <code>memory-backend-memfd</code> to share the memory with external processes. But I prefer to use the <code>memory-backend-file</code> with the <code><a rel="noreferrer noopener" href="https://www.cyberciti.biz/tips/what-is-devshm-and-its-practical-usage.html" target="_blank">/dev/shm</a></code> virtual <a rel="noreferrer noopener" href="https://superuser.com/questions/45342/when-should-i-use-dev-shm-and-when-should-i-use-tmp" target="_blank">filesystem</a>. The result will be the same, both use shared memory, but with the file backend I can give the file a name (instead of it being anonymous). This makes sharing the memory easier because it can be done by file name instead of file descriptor.</p>



<h2>The journey to shared memory</h2>



<p>The <a rel="noreferrer noopener" href="https://qemu.readthedocs.io/en/latest/system/invocation.html#hxtool-10" target="_blank">QEMU Documentation</a> gives the following <a href="https://qemu.readthedocs.io/en/latest/system/invocation.html#hxtool-10" target="_blank" rel="noreferrer noopener">command and options</a></p>



<p><code>-object memory-backend-file,id=id,size=size,mem-path=dir,share=on|off,discard-data=on|off,merge=on|off,dump=on|off,prealloc=on|off,host-nodes=host-nodes,policy=default|preferred|bind|interleave,align=align,readonly=on|off</code></p>



<p>“Creates a memory file backend object, which can be used to back the guest RAM with huge pages.”</p>



<p>So now, how should we adapt the QEMU launch command to make our memory use this backend ?</p>



<p>There are some <a rel="noreferrer noopener" href="https://github.com/qemu/qemu/blob/master/docs/memory-hotplug.txt" target="_blank">examples</a> of this command being used, for example with <a rel="noreferrer noopener" href="https://docs.pmem.io/persistent-memory/getting-started-guide/creating-development-environments/virtualization/qemu" target="_blank">NVDIMMs</a>, as well as <a rel="noreferrer noopener" href="https://unix.stackexchange.com/questions/616596/mapping-guest-ram-to-file-in-qemu" target="_blank">an unanswered question on stackexchange</a>.</p>



<p>With this info I tried running QEMU with the following command</p>



<p><code>qemu -M pc -nographic -m 512m <strong>-object memory-backend-file,id=mem,size=512M,mem-path=/dev/shm/qemu-ram,share=on</strong> -smp cpus=2 -kernel ./bzImage_5.9 -drive file=./rootfs-target.img,if=ide -append &#34;console=ttyS0 root=/dev/sda rw panic=1 earlyprintk=serial,ttyS0,115200&#34;</code></p>



<p>This launches QEMU and creates the file <code>/dev/shm/qemu-ram</code> however, the <code>/dev/shm/qemu-ram</code> file is blank and does not reflect the RAM contents, (e.g., running <code>shasum</code> on the file always returns the same value).</p>



<p>So I went back to check if the memory region was used in QEMU. I opened a QEMU console (ctrl-a c) and with</p>



<p><code>(qemu) info mtree</code></p>



<p>I get</p>



<figure><img loading="lazy" width="916" height="1024" src="http://blog.reds.ch/wp-content/uploads/2021/02/qemu-mtree-916x1024.png" alt="" srcset="https://blog.reds.ch/wp-content/uploads/2021/02/qemu-mtree-916x1024.png 916w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-mtree-268x300.png 268w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-mtree-768x859.png 768w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-mtree-1374x1536.png 1374w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-mtree.png 1662w" sizes="(max-width: 916px) 100vw, 916px"/></figure>



<p>Where I can see that the main RAM (512M) is called pc.ram and is visible in the system memory region (<code>0x0000&#39;0000-0x1fff&#39;ffff</code>). However, the object <code>mem</code> I added is nowhere to be found (you can switch back from the QEMU console with the same (ctrl-a c) command).</p>



<p>The first thing that comes in mind is renaming my object <code>pc.ram</code></p>



<p><code>qemu -M pc -nographic -m 512m -object memory-backend-file,id=<strong>pc.ram</strong>,size=512M,mem-path=/dev/shm/qemu-ram,share=on -smp cpus=2 -kernel ./bzImage_5.9 -drive file=./rootfs-target.img,if=ide -append &#34;console=ttyS0 root=/dev/sda rw panic=1 earlyprintk=serial,ttyS0,115200&#34;</code></p>



<p>When running QEMU the following error appears</p>



<figure><img loading="lazy" width="1024" height="46" src="http://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-error-1024x46.png" alt="" srcset="https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-error-1024x46.png 1024w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-error-300x13.png 300w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-error-768x34.png 768w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-error-1536x68.png 1536w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-error.png 1662w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>The main memory already exists, with id <code>pc.ram</code>, so a new object with this id cannot be added.</p>



<p>The problem still remains… The solution was nowhere to be found in the QEMU documentation, after searching the web for some time I came across the –<code>machine memory-backend</code> option in some posts in the QEMU development mailing list. Later I found <a rel="noreferrer noopener" href="https://www.mail-archive.com/qemu-devel@nongnu.org/msg777397.html" target="_blank">a post that indicates that the option is currently undocumented and suggests it should be</a>.</p>



<p>With this extra information I was able to create the following QEMU command</p>



<p><code>qemu -M pc -nographic -m 512m -object memory-backend-file,id=pc.ram,size=512M,mem-path=/dev/shm/qemu-ram,share=on <strong>-machine memory-backend=pc.ram</strong> -smp cpus=2 -kernel ./bzImage_5.9 -drive file=./rootfs-target.img,if=ide -append &#34;console=ttyS0 root=/dev/sda rw panic=1 earlyprintk=serial,ttyS0,115200&#34;</code></p>



<p>This does launch without errors and creates the file <code>/dev/shm/qemu-ram</code>, running <code>shasum</code> on the file gives different results each time meaning the file is being updated, a good sign !</p>



<h2>Sharing the memory – Demonstration</h2>



<p>The solution was to add the machine memory backend option highlighted above to the QEMU command so that it would use the file backed memory object created. Note that the id can be something else than <code>pc.ram</code> but needs to be the same in both the object and machine options. It will appear with the chosen id in the QEMU memory tree.</p>



<p>The QEMU launch command with highlighted extra options for the memory backend is</p>



<p><code>qemu -M pc -nographic -m 512m <strong>-object memory-backend-file,id=pc.ram,size=512M,mem-path=/dev/shm/qemu-ram,share=on -machine memory-backend=pc.ram</strong> -smp cpus=2 -kernel ./bzImage_5.9 -drive file=./rootfs-target.img,if=ide -append &#34;console=ttyS0 root=/dev/sda rw panic=1 earlyprintk=serial,ttyS0,115200&#34;</code></p>



<p>As a demonstration to access and modify the RAM of the emulated PC from another process, I’ve written a small utility <code><a rel="noreferrer noopener" href="https://github.com/rick-heig/devmem2" target="_blank">shmem2</a> </code>(based on <code>devmem2</code>) to read and write shared memory files. Compile with </p>



<p><code>gcc -m32 -o shmem2 shmem2.c -lrt</code></p>



<p>Usage of this utility is shown below</p>



<figure><img loading="lazy" width="1024" height="226" src="http://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-shmem2-1024x226.png" alt="" srcset="https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-shmem2-1024x226.png 1024w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-shmem2-300x66.png 300w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-shmem2-768x170.png 768w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-shmem2.png 1484w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>To test that it works let’s just look at physical address <code>0x0000&#39;0000</code> of the RAM from inside the emulated system with <code>devmem2</code> (my emulated pc is running a Linux 5.9 kernel with a Ubuntu rootfs with the devmem2 utility installed, but you can compile it from source if needed or maybe already have access to physical memory if you are emulating a “bare-metal” platform).</p>



<figure><img loading="lazy" width="1024" height="128" src="http://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-a-1024x128.png" alt="" srcset="https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-a-1024x128.png 1024w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-a-300x38.png 300w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-a-768x96.png 768w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-a.png 1484w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>The RAM holds the value <code>0xF000FF53</code>. Now let’s open the shared memory file with <code>shmem2</code> at the same physical address <code>0x0000&#39;0000</code></p>



<figure><img loading="lazy" width="1024" height="225" src="http://blog.reds.ch/wp-content/uploads/2021/02/shmem2-a-1024x225.png" alt="" srcset="https://blog.reds.ch/wp-content/uploads/2021/02/shmem2-a-1024x225.png 1024w, https://blog.reds.ch/wp-content/uploads/2021/02/shmem2-a-300x66.png 300w, https://blog.reds.ch/wp-content/uploads/2021/02/shmem2-a-768x169.png 768w, https://blog.reds.ch/wp-content/uploads/2021/02/shmem2-a.png 1484w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>We can see that we read the correct value ! Now let’s write something back. It is usually not advisable to write random values to random addresses of RAM, unless maybe you are trying to simulate data corruption. Here I do it for the demonstration.</p>



<figure><img loading="lazy" width="1024" height="226" src="http://blog.reds.ch/wp-content/uploads/2021/02/shmem2-b-1024x226.png" alt="" srcset="https://blog.reds.ch/wp-content/uploads/2021/02/shmem2-b-1024x226.png 1024w, https://blog.reds.ch/wp-content/uploads/2021/02/shmem2-b-300x66.png 300w, https://blog.reds.ch/wp-content/uploads/2021/02/shmem2-b-768x170.png 768w, https://blog.reds.ch/wp-content/uploads/2021/02/shmem2-b.png 1484w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Let’s read the memory at physical address <code>0x0000&#39;0000</code> from inside the emulated machine again.</p>



<figure><img loading="lazy" width="1024" height="128" src="http://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-b-1024x128.png" alt="" srcset="https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-b-1024x128.png 1024w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-b-300x38.png 300w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-b-768x96.png 768w, https://blog.reds.ch/wp-content/uploads/2021/02/qemu-ram-b.png 1484w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>The RAM contents have indeed changed ! We have successfully demonstrated sharing the memory of a machine emulated in QEMU with an external process, here <code><a href="https://github.com/rick-heig/devmem2" target="_blank" rel="noreferrer noopener">shmem2</a></code>.</p>



<h2>Mapping the shared memory in a C program</h2>



<p>You may be interested in mapping the RAM of the emulated system in C. For example, to code a library, maybe that you can call from python, to read and write the RAM of the emulated system.</p>



<p>All you have to do is <a rel="noreferrer noopener" href="https://linux.die.net/man/3/shm_open" target="_blank">open</a> the shared memory file and <a rel="noreferrer noopener" href="https://linux.die.net/man/2/mmap" target="_blank">map</a> it</p>



<p><code>int schmid = 0;</code></p>



<p>Now your C program has access to the whole RAM of the emulated system through the <code>*qemu_ram</code> pointer.</p>



<p>This can be done for other QEMU emulated systems as well, not only the “pc” machine shown here, this applies to embedded systems and can really come in handy, especially if some devices are externally simulated and require to access the main RAM.</p>



<p>Other use cases can be to monitor the RAM or to edit it from outside QEMU for testing purposes, or maybe to access the RAM from a simulated RTL (e.g., VHDL, Verilog) design through the <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/SystemVerilog_DPI" target="_blank">SysteVerilog DPI</a>.</p>



<h2>Conclusion</h2>



<p>Sharing the memory of an emulated machine in QEMU is relatively simple once you know the options to use. I hope that this feature will be useful to you and that this post saves you some time where I had to find the solution by trial and error.</p>



<h2 id="tldr">TL DR</h2>



<p>Step 1) Add</p>



<p><code>-object memory-backend-file,id=mem,size=512M,mem-path=/dev/shm/qemu-ram,share=on -machine memory-backend=mem</code></p>



<p>To your QEMU command</p>



<p>Note : Choose the correct size, the same as specified by <code>-m</code>, here <code>-m 512m</code>, therefore <code>size=512M</code>.</p>



<p>Step 2) Open <code>/dev/shm/qemu-ram</code> from your external process</p>



<p>Step 3) <strong>Profit !</strong></p>
		</div>
					</div>
	
</article>						

	<!-- #respond -->
	
								</section>
		


		
	</div>
</div></div>
  </body>
</html>
