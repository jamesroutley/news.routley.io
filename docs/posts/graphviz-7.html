<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gitlab.com/graphviz/graphviz/-/tree/main">Original</a>
    <h1>Graphviz 7</h1>
    
    <div id="readability-page-1" class="page"><section>
        <p>
          I’ve written a lot of Kotlin code over the past three years, but I
          didn’t get Kotlin’s <code>in</code> and <code>out</code> keywords…
          until yesterday. Here I’ll record my understanding so hopefully I
          don’t forget how they work. I’m basing this on Kotlin’s documentation
          on generics.
        </p>
        <h2><code>in</code> and <code>out</code> on classes</h2>
        <p>
          <code>in</code> and <code>out</code> can appear in two different
          places and have slightly different meanings depending on the context.
          First, they can appear on a type variable in a class definition:
        </p>
        <pre><code>interface Producer&lt;out T&gt; {
  fun produceT(): T
}
</code></pre>
        <p>
          In this case, <code>out T</code> is telling the compiler that methods
          on Source only return values of type T. Methods on Source are
          prohibited from taking arguments of type T. The following is a
          compiler error:
        </p>
        <pre><code>interface Producer&lt;out T&gt; {
    fun consumeT(t: T) // Type parameter T is declared as &#39;out&#39; but occurs in &#39;in&#39; position in type T
}
</code></pre>
        <p>
          (Side note: Why couldn’t the Kotlin compiler figure out that T is only
          returned from methods on Source and automatically infer out? Maybe
          there are situations where we explicitly don’t want T to be
          <code>out</code>.)
        </p>
        <p>
          Conversely, <code>in T</code> tells the compiler that methods on
          Source only take values of type T as arguments:
        </p>
        <pre><code>interface Consumer&lt;in T&gt; {
    fun consumeT(t: T) // No type error

    fun produceT(): T // Type parameter T is declared as &#39;in&#39; but occurs in &#39;out&#39; position in type T
}
</code></pre>
        <p>
          Why do we need <code>in</code> and <code>out</code> in this context?
          Kotlin’s documentation on generics gives a good set of examples
          explaining why these keywords are useful. In brief:
        </p>
        <p>
          For a class <code>Producer&lt;out T&gt;</code>, Kotlin will treat
          <code>Producer&lt;Derived&gt;</code> as a subclass of
          <code>Producer&lt;Base&gt;</code>. For a class
          <code>Consumer&lt;in T&gt;</code>, Kotlin will treat
          <code>Consumer&lt;Base&gt;</code> as a superclass of
          <code>Consumer&lt;Derived&gt;</code>. By default, without the
          <code>in</code> and <code>out</code> keywords,
          <code>Producer&lt;Base&gt;</code> and
          <code>Producer&lt;Derived&gt;</code> are unrelated classes.
        </p>
        <p>
          This is useful because sometimes we want to treat the return value of
          a method on <code>Producer&lt;Derived&gt;</code> as a Base. Or we want
          to pass a Derived into a method on
          <code>Consumer&lt;Base&gt;</code> that takes a Base.
        </p>
        <h2>
          <code>in</code> and <code>out</code> on variable and argument types
        </h2>
        <p>
          Some classes need to have a mix of methods that take arguments of type
          T and that return a value of type T. An example from Kotlin’s generics
          documentation:
        </p>
        <pre><code>class Array&lt;T&gt;(vararg elements: T) {
    operator fun get(index: Int): T { ... }
    operator fun set(index: Int, value: T) { ... }
}
</code></pre>
        <p>
          This is where it comes in handy that we can use <code>in</code> and
          <code>out</code> in a second place: on type variables when specifying
          the type of a method argument or just of a value. We can do something
          like:
        </p>
        <pre><code>val array: Array&lt;out String&gt; = Array(&#34;hello&#34;, &#34;world&#34;)
array.get(0) // No type error
array.set(0, &#34;cool&#34; /* Type mismatch, required: Nothing, found: String */)
</code></pre>
        <p>Or:</p>
        <pre><code>val array: Array&lt;in String&gt; = Array(&#34;hello&#34;, &#34;world&#34;)
val result = array.get(0) // result has type Any?
array.set(0, &#34;cool&#34;) // No type error
</code></pre>
        <p>
          Again this is nice because <code>Array&lt;out String&gt;</code> is a
          subtype of <code>Array&lt;Any&gt;</code>, while
          <code>Array&lt;in String&gt;</code> is a supertype of
          <code>Array&lt;SomeHypotheticalSubTypeOfString&gt;</code>.
        </p>
      </section></div>
  </body>
</html>
