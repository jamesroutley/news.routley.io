<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danilafe.com/blog/chapel_x_macros/">Original</a>
    <h1>My Favorite C&#43;&#43; Pattern: X Macros (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>When I first joined the <a href="https://github.com/chapel-lang/chapel/">Chapel</a> team,
one pattern used in its C++-based compiler made a strong impression on me. Since
then, I’ve used the pattern many more times, and have been very satisfied with
how it turned out. However, it feels like the pattern is relatively unknown, so
I thought I’d show it off, and some of its applications in the
<a href="https://github.com/chapel-lang/chapel/">Chapel compiler</a>. I’ve slightly tweaked
a lot of the snippets I directly show in this article for the sake of simpler
presentation; I’ve included links to the original code (available on GitHub)
if you want to see the unabridged version.</p>
<p>Broadly speaking, the “X Macros” pattern is about generating code. If you have a <em>lot</em>
of repetitive code to write (declaring many variables or classes, performing
many very similar actions, etc.), this pattern can save a lot of time, lead
to much more maintainable code, and reduce the effort required to add <em>more</em>
code.</p>
<p>I will introduce the pattern in its simplest form with my first example:
<a href="https://en.wikipedia.org/wiki/String_interning">interning strings</a>.</p>
<a href="#application-1-string-interning">
  <h3 id="application-1-string-interning">Application 1: String Interning</h3>
</a>
<p>The Chapel compiler interns a lot of its strings. This way, it can reduce the
memory footprint of keeping identifiers in memory (every string <code>&#34;x&#34;</code> is
actually the <em>same</em> string) and make for much faster equality comparisons
(you can just perform a pointer comparison!). Generally, a <code>Context</code> class
is used to manage interning state. A new interned string can be constructed
using the context object in the following manner:</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>UniqueString</span><span>::</span><span>get</span><span>(</span><span>ctxPtr</span><span>,</span> <span>&#34;the string&#34;</span><span>);</span>
</span></span></code></pre></div>
<p>Effectively, this performs a search of the currently existing unique strings.
If one with the content (<code>&#34;the string&#34;</code> in this case) doesn’t exist, it’s
created and registered with the <code>Context</code>. Otherwise, the existing string is
returned. Some strings, however, occur a lot in the compiler, to the point that
it would be inefficient to perform the whole “find-or-create” operation every
time. One example is the <code>&#34;this&#34;</code> string, which is an identifier with a lot of
special behavior in the language (much like <code>this</code> in languages such as Java).
To support such frequent flier strings, the compiler initializes them once,
and creates a variable per-string that can be accessed to get that string’s value.</p>
<p>There’s that repetitive code. Defining a brand new variable for each string,
of which there are around 100 at the time of writing, is a lot of boilerplate.
There are also at least two places where code needs to be added:
<span>
<label for="template-note">once in the declaration of the variables, once in the code that initializes them.</label>
<span><span>[note:</span>
A third use in the compiler is actually a variadic template defined over
character arrays. The template is defined and specialized in such a way that
you can refer to a variable by its string contents (i.e., you can write
<code>USTR(&#34;the string&#34;)</code> instead of
<code>theStringVariable</code>).
<span>]</span>
</span>
</span>

It would be very easy to accidentally modify the former but not the latter,
especially for developers not familiar with how these “common strings” are
implemented.</p>
<p>This is where the X Macros come in. If you look around the compiler source code,
there’s a header file that looks something like the following:</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="frontend/include/chpl/framework/all-global-strings.h">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>X</span><span>(</span><span>align</span>          <span>,</span> <span>&#34;align&#34;</span><span>)</span>
</span></span><span><span><span>X</span><span>(</span><span>atomic</span>         <span>,</span> <span>&#34;atomic&#34;</span><span>)</span>
</span></span><span><span><span>X</span><span>(</span><span>bool_</span>          <span>,</span> <span>&#34;bool&#34;</span><span>)</span>
</span></span><span><span><span>X</span><span>(</span><span>borrow</span>         <span>,</span> <span>&#34;borrow&#34;</span><span>)</span>
</span></span><span><span><span>X</span><span>(</span><span>borrowed</span>       <span>,</span> <span>&#34;borrowed&#34;</span><span>)</span>
</span></span><span><span><span>X</span><span>(</span><span>by</span>             <span>,</span> <span>&#34;by&#34;</span><span>)</span>
</span></span><span><span><span>X</span><span>(</span><span>bytes</span>          <span>,</span> <span>&#34;bytes&#34;</span><span>)</span>
</span></span><span><span><span>// A lot more of these...
</span></span></span></code></pre></div>
</div>


<p>What’s this <code>X</code> thing? That right there is the essence of the pattern: the macro
<code>X</code> <em>isn’t defined in the header!</em> Effectively, <code>all-global-strings.h</code> is just
a list, and we can “iterate” over this list to generate some code for each
one of its elements, in as many places as we want. What I mean by this is
that we can then write code like the following:</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="frontend/include/chpl/framework/global-strings.h">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span>    <span>struct</span> <span>GlobalStrings</span> <span>{</span>
</span></span><span><span><span>#define X(field, str) UniqueString field;
</span></span></span><span><span><span>#include</span> <span>&#34;all-global-strings.h&#34;</span><span>
</span></span></span><span><span><span>#undef X
</span></span></span><span><span><span></span>    <span>};</span></span></span></code></pre></div>
</div>


<p>In this case, we define the macro <code>X</code> to ignore the value of the string (we’re
just declaring it here), and create a new <code>UniqueString</code> variable declaration.
Since the declaration is inside the <code>GlobalStrings</code> struct, this ends up
creating a field. Just like that, we’ve declared a class with over 100
fields. Initialization is equally simple:</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="frontend/lib/framework/Context.cpp">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span>    <span>GlobalStrings</span> <span>globalStrings</span><span>;</span>
</span></span><span><span>    <span>Context</span> <span>rootContext</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>static</span> <span>void</span> <span>initGlobalStrings</span><span>()</span> <span>{</span>
</span></span><span><span><span>#define X(field, str) globalStrings.field = UniqueString::get(&amp;rootContext, str);
</span></span></span><span><span><span>#include</span> <span>&#34;chpl/framework/all-global-strings.h&#34;</span><span>
</span></span></span><span><span><span>#undef X
</span></span></span><span><span><span></span>    <span>}</span></span></span></code></pre></div>
</div>


<p>With this, we’ve completely automated the code for for both declaring and
initializing all 100 of our unique strings. Adding a new string doesn’t require
a developer to know all of the places where this is implemented: just by
modifying the <code>all-global-strings.h</code> header with a new call to <code>X</code>, they can
add both a new variable and code to initialize it. Pretty robust!</p>
<a href="#application-2-ast-class-hierarchy">
  <h3 id="application-2-ast-class-hierarchy">Application 2: AST Class Hierarchy</h3>
</a>
<p>Altough the interned strings are an excellent first example, it wasn’t the
first usage of X Macros that I encountered in the Chapel compiler. Beyond
strings, the compiler uses X Macros to represent the whole class hierarchy
of <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree (AST)</a>
nodes that it uses. Here, the code is actually a bit more complicated; the
class hierarchy isn’t a <em>list</em> like the strings were; it is itself a tree.
To represent such a structure, we need more than a single <code>X</code> macro; the
compiler went with <code>AST_NODE</code>, <code>AST_BEGIN_SUBCLASSES</code>, and <code>AST_END_SUBCLASSES</code>.
Here’s what that looks like:</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="frontend/include/chpl/uast/uast-classes-list.h">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span>  <span>// Other AST nodes above...
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>AST_BEGIN_SUBCLASSES</span><span>(</span><span>Loop</span><span>)</span>
</span></span><span><span>      <span>AST_NODE</span><span>(</span><span>DoWhile</span><span>)</span>
</span></span><span><span>      <span>AST_NODE</span><span>(</span><span>While</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>AST_BEGIN_SUBCLASSES</span><span>(</span><span>IndexableLoop</span><span>)</span>
</span></span><span><span>      <span>AST_NODE</span><span>(</span><span>BracketLoop</span><span>)</span>
</span></span><span><span>      <span>AST_NODE</span><span>(</span><span>Coforall</span><span>)</span>
</span></span><span><span>      <span>AST_NODE</span><span>(</span><span>For</span><span>)</span>
</span></span><span><span>      <span>AST_NODE</span><span>(</span><span>Forall</span><span>)</span>
</span></span><span><span>      <span>AST_NODE</span><span>(</span><span>Foreach</span><span>)</span>
</span></span><span><span>    <span>AST_END_SUBCLASSES</span><span>(</span><span>IndexableLoop</span><span>)</span>
</span></span><span><span>
</span></span><span><span>  <span>AST_END_SUBCLASSES</span><span>(</span><span>Loop</span><span>)</span>
</span></span><span><span>
</span></span><span><span>  <span>// Other AST nodes below...
</span></span></span></code></pre></div>
</div>


<p>The class hierarchy defined in this header, called <code>uast-classes-list.h</code>, is
used for a lot of things, both in the compiler itself and in some libraries
that <em>use</em> the compiler. I’ll go through the use cases in turn.</p>
<a href="#tags-and-dynamic-casting">
  <h4 id="tags-and-dynamic-casting">Tags and Dynamic Casting</h4>
</a>
<p>First, to deal with a general absence of
<a href="https://en.wikipedia.org/wiki/Run-time_type_information">RTTI</a>, the hierarchy header
is used to declare a “tag” enum. Each AST node has a tag matching its class;
this allows us inspect the AST and perform safe casts similar to <code>dynamic_cast</code>.
Note that for parent classes (defined via <code>BEGIN_SUBCLASSES</code>), we actually
end up creating <em>two</em> tags: one <code>START_...</code> and one <code>END_...</code>. The reason
for this will become clear in a moment.</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="frontend/include/chpl/uast/AstTag.h">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>enum</span> <span>AstTag</span> <span>{</span>
</span></span><span><span><span>#define AST_NODE(NAME) NAME ,
</span></span></span><span><span><span>#define AST_BEGIN_SUBCLASSES(NAME) START_##NAME ,
</span></span></span><span><span><span>#define AST_END_SUBCLASSES(NAME) END_##NAME ,
</span></span></span><span><span><span>#include</span> <span>&#34;chpl/uast/uast-classes-list.h&#34;</span><span>
</span></span></span><span><span><span>#undef AST_NODE
</span></span></span><span><span><span>#undef AST_BEGIN_SUBCLASSES
</span></span></span><span><span><span>#undef AST_END_SUBCLASSES
</span></span></span><span><span><span></span>  <span>NUM_AST_TAGS</span><span>,</span>
</span></span><span><span>  <span>AST_TAG_UNKNOWN</span>
</span></span><span><span><span>};</span></span></span></code></pre></div>
</div>


<p>The above snippet makes <code>AstTag</code> contain elements such as <code>DoWhile</code>,
<code>While</code>, <code>START_Loop</code>, and <code>END_Loop</code>. For convenience, we also add a couple
of other elements: <code>NUM_AST_TAGS</code>, which is
<span>
<label for="numbering-node">automatically assigned the number of tags we generated,</label>
<span><span>[note:</span>
This is because C++ assigns integer values to enum elements sequentially, starting
at zero.
<span>]</span>
</span>
</span>

and a generic “unknown tag” value.</p>
<p>Having generated the enum elements in this way, we can write query functions.
This way, the API consumer can write <code>isLoop(tag)</code> instead of manually performing
a comparison. Code generation here is actually split into two distinct forms
of “is bla” methods: those for concrete AST nodes (<code>DoWhile,</code> <code>While</code>) and
those for abstract base classes (<code>Loop</code>). The reason for this is simple:
only a <code>AstTag::DoWhile</code> represents a do-while loop, but both <code>DoWhile</code>
and <code>While</code> are instances of <code>Loop</code>. So, <code>isLoop</code> should return true for both.</p>
<p>This is where the <code>START_...</code> and <code>END_...</code> enum elements come in. Reading
the header file top-to-bottom, we first end up generating <code>START_Loop</code>,
then <code>DoWhile</code> and <code>While</code>, and then <code>END_Loop</code>. Since C++ assigns integer
value to enums sequentially, to check if a tag “extends” a base class, it’s
sufficient to check if its value is greater than the <code>START</code> token, and
smaller than the <code>END</code> token – this means it was declared within the
matching pair of <code>BEGIN_SUBCLASSES</code> and <code>END_SUBCLASES</code>.</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="frontend/include/chpl/uast/AstTag.h">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>// define is___ for leaf and regular nodes
</span></span></span><span><span><span>// (not yet for abstract parent classes)
</span></span></span><span><span><span></span><span>#define AST_NODE(NAME) \
</span></span></span><span><span><span>  static inline bool is##NAME(AstTag tag) { \
</span></span></span><span><span><span>    return tag == NAME; \
</span></span></span><span><span><span>  }
</span></span></span><span><span><span>#define AST_BEGIN_SUBCLASSES(NAME)
</span></span></span><span><span><span>#define AST_END_SUBCLASSES(NAME)
</span></span></span><span><span><span></span><span>// Apply the above macros to uast-classes-list.h
</span></span></span><span><span><span></span><span>#include</span> <span>&#34;chpl/uast/uast-classes-list.h&#34;</span><span>
</span></span></span><span><span><span></span><span>// clear the macros
</span></span></span><span><span><span></span><span>#undef AST_NODE
</span></span></span><span><span><span>#undef AST_BEGIN_SUBCLASSES
</span></span></span><span><span><span>#undef AST_END_SUBCLASSES
</span></span></span><span><span><span></span>
</span></span><span><span><span>// define is___ for abstract parent classes
</span></span></span><span><span><span></span><span>#define AST_NODE(NAME)
</span></span></span><span><span><span>#define AST_BEGIN_SUBCLASSES(NAME) \
</span></span></span><span><span><span>  static inline bool is##NAME(AstTag tag) { \
</span></span></span><span><span><span>    return START_##NAME &lt; tag &amp;&amp; tag &lt; END_##NAME; \
</span></span></span><span><span><span>  }
</span></span></span><span><span><span>#define AST_END_SUBCLASSES(NAME)
</span></span></span><span><span><span></span><span>// Apply the above macros to uast-classes-list.h
</span></span></span><span><span><span></span><span>#include</span> <span>&#34;chpl/uast/uast-classes-list.h&#34;</span><span>
</span></span></span><span><span><span></span><span>// clear the macros
</span></span></span><span><span><span></span><span>#undef AST_NODE
</span></span></span><span><span><span>#undef AST_BEGIN_SUBCLASSES
</span></span></span><span><span><span>#undef AST_END_SUBCLASSES</span></span></span></code></pre></div>
</div>


<p>These helpers are quite convenient. Here are a few examples of what we end up
with:</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>isFor</span><span>(</span><span>AstTag</span><span>::</span><span>For</span><span>)</span>             <span>// Returns true; a &#39;for&#39; loop is indeed a &#39;for&#39; loop.
</span></span></span><span><span><span></span><span>isIndexableLoop</span><span>(</span><span>AstTag</span><span>::</span><span>For</span><span>)</span>   <span>// Returns true; a &#39;for&#39; loop is &#34;indexable&#34; (&#39;for i in ...&#39;)
</span></span></span><span><span><span></span><span>isLoop</span><span>(</span><span>AstTag</span><span>::</span><span>For</span><span>)</span>            <span>// Returns true; a &#39;for&#39; loop is a loop.
</span></span></span><span><span><span></span><span>isFor</span><span>(</span><span>AstTag</span><span>::</span><span>While</span><span>)</span>           <span>// Returns false; a &#39;while&#39; loop is not a &#39;for&#39; loop.
</span></span></span><span><span><span></span><span>isIndexableLoop</span><span>(</span><span>AstTag</span><span>::</span><span>While</span><span>)</span> <span>// Returns false; a &#39;while&#39; loop uses a boolean condition, not an index
</span></span></span><span><span><span></span><span>isLoop</span><span>(</span><span>AstTag</span><span>::</span><span>While</span><span>)</span>          <span>// Returns true; a &#39;while&#39; loop is a loop.
</span></span></span></code></pre></div>
<p>On the top-level AST node class, we generate <code>isWhateverNode</code> and
<code>toWhateverNode</code> for each AST subclass. Thus, user code is able to inspect the
AST and perform (checked) casts using plain methods. I omit <code>isWhateverNode</code>
here for brevity (its definition is very simple), and include only
<code>toWhateverNode</code>.</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="frontend/include/chpl/uast/AstNode.h">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span>  <span>#define AST_TO(NAME) \
</span></span></span><span><span><span>    const NAME * to##NAME() const { \
</span></span></span><span><span><span>      return this-&gt;is##NAME() ? (const NAME *)this : nullptr; \
</span></span></span><span><span><span>    } \
</span></span></span><span><span><span>    NAME * to##NAME() { \
</span></span></span><span><span><span>      return this-&gt;is##NAME() ? (NAME *)this : nullptr; \
</span></span></span><span><span><span>    }
</span></span></span><span><span><span></span>  <span>#define AST_NODE(NAME) AST_TO(NAME)
</span></span></span><span><span><span></span>  <span>#define AST_LEAF(NAME) AST_TO(NAME)
</span></span></span><span><span><span></span>  <span>#define AST_BEGIN_SUBCLASSES(NAME) AST_TO(NAME)
</span></span></span><span><span><span></span>  <span>#define AST_END_SUBCLASSES(NAME)
</span></span></span><span><span><span></span>  <span>// Apply the above macros to uast-classes-list.h
</span></span></span><span><span><span></span>  <span>#include</span> <span>&#34;chpl/uast/uast-classes-list.h&#34;</span><span>
</span></span></span><span><span><span></span>  <span>// clear the macros
</span></span></span><span><span><span></span>  <span>#undef AST_NODE
</span></span></span><span><span><span></span>  <span>#undef AST_LEAF
</span></span></span><span><span><span></span>  <span>#undef AST_BEGIN_SUBCLASSES
</span></span></span><span><span><span></span>  <span>#undef AST_END_SUBCLASSES
</span></span></span><span><span><span></span>  <span>#undef AST_TO</span></span></span></code></pre></div>
</div>


<p>These methods are used heavily in the compiler. For example, here’s a completely
random snippet of code I pulled out:</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="frontend/lib/resolution/Resolver.cpp">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span>  <span>if</span> <span>(</span><span>auto</span> <span>var</span> <span>=</span> <span>decl</span><span>-&gt;</span><span>toVarLikeDecl</span><span>())</span> <span>{</span>
</span></span><span><span>    <span>// Figure out variable type based upon:
</span></span></span><span><span><span></span>    <span>//  * the type in the variable declaration
</span></span></span><span><span><span></span>    <span>//  * the initialization expression in the variable declaration
</span></span></span><span><span><span></span>    <span>//  * the initialization expression from split-init
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>auto</span> <span>typeExpr</span> <span>=</span> <span>var</span><span>-&gt;</span><span>typeExpression</span><span>();</span>
</span></span><span><span>    <span>auto</span> <span>initExpr</span> <span>=</span> <span>var</span><span>-&gt;</span><span>initExpression</span><span>();</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>(</span><span>auto</span> <span>var</span> <span>=</span> <span>decl</span><span>-&gt;</span><span>toVariable</span><span>())</span>
</span></span><span><span>      <span>if</span> <span>(</span><span>var</span><span>-&gt;</span><span>isField</span><span>())</span>
</span></span><span><span>        <span>isField</span> <span>=</span> <span>true</span><span>;</span></span></span></code></pre></div>
</div>


<p>Thus, developers adding new AST nodes are not required to manually implement
the <code>isWhatever</code>, <code>toWhatever</code>, and other functions. This and a fair bit
of other AST functionality (which I will cover in the next subsection) is
automatically generated using X Macros.</p>
<p>
<span>
    <span></span>
    <span>
You haven&#39;t actually shown how the AST node classes are declared, only the
tags. It seems implausible that they be generated using this same strategy -
doesn&#39;t each AST node have its own different methods and implementation code?
</span>
</span>

<span>
    <span></span>
    <span>
You&#39;re right. The AST node classes are defined &#34;as usual&#34;, and their constructors
must explicitly set their <code>tag</code> field to the corresponding
<code>AstTag</code> value. It&#39;s also on the person defining the new class to
extend the node that they promise to extend in <code>uast-classes-list.h</code>.
</span>
</span>

<span>
    <span></span>
    <span>
This seems like an opportunity for bugs. Nothing is stopping a developer
from returning the wrong tag, which would break the auto-casting behavior.
</span>
</span>

<span>
    <span></span>
    <span>
Yes, it&#39;s not bulletproof. Just recently, a team meber found
<a href="https://github.com/chapel-lang/chapel/pull/23508"> a bug</a> in which
a node was listed to inherit from <code>AstNode</code>, but actually inherited
from <code>NamedDecl</code>. The <code>toNamedDecl</code> method would not
have worked on it, even though it inherited from the class.</span>
</span>

</p>

<a href="#the-visitor-pattern-without-double-dispatch">
  <h4 id="the-visitor-pattern-without-double-dispatch">The Visitor Pattern without Double Dispatch</h4>
</a>
<p>The Visitor Pattern is very important in general, but it’s beyond ubiquitous
for us compiler developers. It helps avoid bloating AST node classes with methods
and state required for the various operations we perform on them. It also often
saves us from writing AST traversal code.</p>
<p>Essentially, rather than adding each new operation (e.g. convert to string,
compute the type, assign IDs) as methods on each AST node class, we extract
this code into a per-operation <em>visitor</em>. This visitor is a class that has methods
implementing the custom behavior on the AST nodes. A <code>visit(WhileLoop*)</code> method
might be used to perform the operation on ‘while’ loops, and <code>visit(ForLoop*)</code> might
do the same for ‘for’ loops. The AST nodes themselves only have a <code>traverse</code>
method that accepts a visitor, whatever it may be, and calls the appropriate
visit methods. This way, the AST node implementations remain simple and relatively
stable.</p>
<p>As a very simple example, suppose you wanted to count the number of loops used
in a program for an unspecified reason. You could add a <code>countLoops</code> method,
but then you’ve introduced a method to the AST node API for what might be a
one-time, throwaway operation. With the visitor pattern, you don’t need to do
that; you can just create a new class:</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>struct</span> <span>MyVisitor</span> <span>{</span>
</span></span><span><span>    <span>int</span> <span>count</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>void</span> <span>visit</span><span>(</span><span>const</span> <span>Loop</span><span>*</span><span>)</span> <span>{</span> <span>count</span> <span>+=</span> <span>1</span><span>;</span> <span>}</span>
</span></span><span><span>    <span>void</span> <span>visit</span><span>(</span><span>const</span> <span>AstNode</span><span>*</span><span>)</span> <span>{</span> <span>/* do nothing for other nodes */</span> <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>countLoops</span><span>(</span><span>const</span> <span>AstNode</span><span>*</span> <span>root</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>MyVisitor</span> <span>visitor</span><span>;</span>
</span></span><span><span>    <span>root</span><span>-&gt;</span><span>traverse</span><span>(</span><span>visitor</span><span>);</span>
</span></span><span><span>    <span>return</span> <span>visitor</span><span>.</span><span>count</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div>
<p>The <code>traverse</code> method is a nice API, isn’t it? It’s very easy to add operations
that work on your syntax trees, without modifying them. There is still an important
open question, though: how does <code>traverse</code> know to call the right <code>visit</code> function?</p>
<p>If <code>traverse</code> were only defined on <code>AstNode*</code>, and it simply called <code>visit(this)</code>,
we’d always end up calling the <code>AstNode</code> version of the <code>visit</code> function. This
is because C++ doesn’t dynamic dispatch
<span>
<label for="vtable-note">based on the types of method arguments.</label>
<span><span>[note:</span>
Obviously, C++ has the ability to pick the right method based on the runtime
type of the <em>receiver</em>: that&#39;s just <code>virtual</code> functions
and <code>vtable</code>s.
<span>]</span>
</span>
</span>

Statically, the call clearly accepts an <code>AstNode</code>, and nothing more specific.
The compiler therefore picks that version of the <code>visit</code> method.</p>
<p>The “traditional” way to solve this problem in a language like C++ or Java
is called <em>double dispatch</em>. Using our example as reference, this involves
making <em>each</em> AST node class have its own <code>traverse</code> method. This way,
calls to <code>visit(this)</code> have more specific type information, and are resolved
to the appropriate overload. But that’s more boilerplate code: each new AST
node will need to have a virtual traverse method that looks something like this:</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>void</span> <span>MyNode</span><span>::</span><span>traverse</span><span>(</span><span>Visitor</span><span>&amp;</span> <span>v</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>v</span><span>.</span><span>visit</span><span>(</span><span>this</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div>
<p>It would also require all visitors to extend from <code>Visitor</code>. So now you have:</p>
<ul>
<li>Boilerplate code on every AST node that looks the same but needs to be duplicated</li>
<li>A parent <code>Visitor</code> class that must have a <code>visit</code> method for each AST node in
the language (so that children can override it).</li>
<li>To make it easier to write code like our <code>MyVisitor</code> above, the <code>visit</code>
methods in the <code>Visitor</code> must be written such that <code>visit(ChildNode*)</code> calls
<code>visit(ParentNode*)</code> by default. Otherwise, the <code>Loop</code> overload wouldn’t
have been called by the <code>DoWhile</code> overload (e.g.).</li>
</ul>
<p>So there’s a fair bit of tedious boilerplate, and more code to manually modify
when adding an AST node: you have to go and adjust the <code>Visitor</code> class with
new <code>visit</code> stub.</p>
<p>The reason all of this is necessary is that everyone (myself included) generally
agrees that code like the following is generally a bad idea:</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>struct</span> <span>AstNode</span> <span>{</span>
</span></span><span><span>  <span>void</span> <span>traverse</span><span>(</span><span>Visitor</span><span>&amp;</span> <span>visitor</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>auto</span> <span>forLoop</span> <span>=</span> <span>toForLoop</span><span>())</span> <span>{</span>
</span></span><span><span>      <span>visitor</span><span>.</span><span>visit</span><span>(</span><span>forLoop</span><span>);</span>
</span></span><span><span>    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>whileLoop</span> <span>=</span> <span>toWhileLoop</span><span>())</span> <span>{</span>
</span></span><span><span>      <span>visitor</span><span>.</span><span>visit</span><span>(</span><span>whileLoop</span><span>);</span>
</span></span><span><span>    <span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>      <span>// 100 more lines like this...
</span></span></span><span><span><span></span>    <span>}</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div>
<p>After all, what happens when you add a new AST node? You’d still have to modify
this list, and since everything still extends <code>Visitor</code>, you’d still need to
add a new <code>visit</code> stub there. But what if there were no base class? Instead,
what if <code>traverse</code> were a template?</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>struct</span> <span>AstNode</span> <span>{</span>
</span></span><span><span>  <span>template</span> <span>&lt;</span><span>typename</span> <span>VisitorType</span><span>&gt;</span>
</span></span><span><span>  <span>void</span> <span>traverse</span><span>(</span><span>VisitorType</span><span>&amp;</span> <span>visitor</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>auto</span> <span>forLoop</span> <span>=</span> <span>toForLoop</span><span>())</span> <span>{</span>
</span></span><span><span>      <span>visitor</span><span>.</span><span>visit</span><span>(</span><span>forLoop</span><span>);</span>
</span></span><span><span>    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>auto</span> <span>whileLoop</span> <span>=</span> <span>toWhileLoop</span><span>())</span> <span>{</span>
</span></span><span><span>      <span>visitor</span><span>.</span><span>visit</span><span>(</span><span>whileLoop</span><span>);</span>
</span></span><span><span>    <span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>      <span>// 100 more lines like this...
</span></span></span><span><span><span></span>    <span>}</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div>
<p>Note that this wouldn’t be possible to write in C++ if <code>visit</code> were a virtual
method; have you ever heard of a virtual template? With code like this, the
<code>VisitorType</code> wouldn’t need to define <em>every</em> overload, as long as it had
a version for <code>AstNode</code>. Furthermore, C++’s regular overload resolution rules
would take care of calling the <code>Loop</code> overload if a more specific one for
<code>DoWhile</code> didn’t exist.</p>
<p>The only problem that remains is that of having a 100-line if-else (which could
be a <code>switch</code> to little aesthetic benefit). But this is exactly where the
X Macro pattern shines again! We already have a list of all AST node classes,
and the code for invoking them is nearly identical. Thus, the Chapel compiler
has a <code>doDispatch</code> function (used by <code>traverse</code>) that looks like this:</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="frontend/include/chpl/uast/AstNode.h">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span>    <span>static</span> <span>void</span> <span>doDispatch</span><span>(</span><span>const</span> <span>AstNode</span><span>*</span> <span>ast</span><span>,</span> <span>Visitor</span><span>&amp;</span> <span>v</span><span>)</span> <span>{</span>
</span></span><span><span>
</span></span><span><span>      <span>switch</span> <span>(</span><span>ast</span><span>-&gt;</span><span>tag</span><span>())</span> <span>{</span>
</span></span><span><span>        <span>#define CONVERT(NAME) \
</span></span></span><span><span><span>          case chpl::uast::asttags::NAME: \
</span></span></span><span><span><span>          { \
</span></span></span><span><span><span>            v.visit((const chpl::uast::NAME*) ast); \
</span></span></span><span><span><span>            return; \
</span></span></span><span><span><span>          }
</span></span></span><span><span><span></span>
</span></span><span><span>        <span>#define IGNORE(NAME) \
</span></span></span><span><span><span>          case chpl::uast::asttags::NAME: \
</span></span></span><span><span><span>          { \
</span></span></span><span><span><span>            CHPL_ASSERT(false &amp;&amp; &#34;this code should never be run&#34;); \
</span></span></span><span><span><span>          }
</span></span></span><span><span><span></span>
</span></span><span><span>        <span>#define AST_NODE(NAME) CONVERT(NAME)
</span></span></span><span><span><span></span>        <span>#define AST_BEGIN_SUBCLASSES(NAME) IGNORE(START_##NAME)
</span></span></span><span><span><span></span>        <span>#define AST_END_SUBCLASSES(NAME) IGNORE(END_##NAME)
</span></span></span><span><span><span></span>
</span></span><span><span>        <span>#include</span> <span>&#34;chpl/uast/uast-classes-list.h&#34;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span>        <span>IGNORE</span><span>(</span><span>NUM_AST_TAGS</span><span>)</span>
</span></span><span><span>        <span>IGNORE</span><span>(</span><span>AST_TAG_UNKNOWN</span><span>)</span>
</span></span><span><span>
</span></span><span><span>        <span>#undef AST_NODE
</span></span></span><span><span><span></span>        <span>#undef AST_BEGIN_SUBCLASSES
</span></span></span><span><span><span></span>        <span>#undef AST_END_SUBCLASSES
</span></span></span><span><span><span></span>        <span>#undef CONVERT
</span></span></span><span><span><span></span>        <span>#undef IGNORE
</span></span></span><span><span><span></span>      <span>}</span>
</span></span><span><span>
</span></span><span><span>      <span>CHPL_ASSERT</span><span>(</span><span>false</span> <span>&amp;&amp;</span> <span>&#34;this code should never be run&#34;</span><span>);</span>
</span></span><span><span>    <span>}</span></span></span></code></pre></div>
</div>


<p>And that’s it. We have automatically generated the traversal code, allowing
us to use the visitor pattern in what I think is a very elegant way. Assuming
a developer adding a new AST node updates the <code>uast-classes-list.h</code> header,
the traversal logic will be auto-modified to properly handle the new node.</p>
<a href="#generating-a-python-class-hierarchy">
  <h4 id="generating-a-python-class-hierarchy">Generating a Python Class Hierarchy</h4>
</a>
<p>This is a fun one. For a while, in my spare time, I was working on
<a href="https://github.com/chapel-lang/chapel/tree/main/tools/chapel-py">Python bindings for Chapel</a>.
These bindings are oriented towards developing language tooling: it feels much
easier to write a language linter, auto-formatter, or maybe even a language
server in Python rather than in C++. It’s definitely much easier to use Python to
develop throwaway scripts that work with Chapel programs, which is something
that developers on the Chapel team tend to do quite often.</p>
<p>I decided I wanted the Python AST node class hierarchy to match the C++ version.
This is convenient for many reasons, including being able to wrap methods on
parent AST nodes and have them be available through child AST nodes and having
<code>isinstance</code> work properly. It’s also advantageous from the point of view
of conceptual simplicity. However, I very much did not want to write CPython
API code to define the many AST node classes that are available in the Chapel
language.</p>
<p>Once again, the <code>uast-classes-list.h</code> header came into play here. With little
effort, I was able to auto-generate <code>PyTypeObject</code>s for each AST node in the
class hierarchy:</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="tools/chapel-py/chapel.cpp">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>#define DEFINE_PY_TYPE_FOR(NAME, TAG, FLAGS)\
</span></span></span><span><span><span>  PyTypeObject NAME##Type = { \
</span></span></span><span><span><span>    PyVarObject_HEAD_INIT(NULL, 0) \
</span></span></span><span><span><span>    .tp_name = #NAME, \
</span></span></span><span><span><span>    .tp_basicsize = sizeof(NAME##Object), \
</span></span></span><span><span><span>    .tp_itemsize = 0, \
</span></span></span><span><span><span>    .tp_flags = FLAGS, \
</span></span></span><span><span><span>    .tp_doc = PyDoc_STR(&#34;A Chapel &#34; #NAME &#34; AST node&#34;), \
</span></span></span><span><span><span>    .tp_methods = (PyMethodDef*) PerNodeInfo&lt;TAG&gt;::methods, \
</span></span></span><span><span><span>    .tp_base = parentTypeFor(TAG), \
</span></span></span><span><span><span>    .tp_init = (initproc) NAME##Object_init, \
</span></span></span><span><span><span>    .tp_new = PyType_GenericNew, \
</span></span></span><span><span><span>  };
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define AST_NODE(NAME) DEFINE_PY_TYPE_FOR(NAME, chpl::uast::asttags::NAME, Py_TPFLAGS_DEFAULT)
</span></span></span><span><span><span>#define AST_BEGIN_SUBCLASSES(NAME) DEFINE_PY_TYPE_FOR(NAME, chpl::uast::asttags::START_##NAME, Py_TPFLAGS_BASETYPE)
</span></span></span><span><span><span>#define AST_END_SUBCLASSES(NAME)
</span></span></span><span><span><span>#include</span> <span>&#34;chpl/uast/uast-classes-list.h&#34;</span><span>
</span></span></span><span><span><span>#undef AST_NODE
</span></span></span><span><span><span>#undef AST_BEGIN_SUBCLASSES
</span></span></span><span><span><span>#undef AST_END_SUBCLASSES</span></span></span></code></pre></div>
</div>


<p>You may have noticed that I snuck templates into the code above. The motivation there
is to avoid writing out the (usually empty) Python method table for every single
AST node. In particular, I have a template that, by default, provides an empty
method table, which can be specialized per node to add methods when necessary.
This detail is useful for application 3 below, but not necessary to understand
the use of X Macros here.</p>
<p>I used the same <code>&lt;</code> and <code>&gt;</code> trick to generate the <code>parentTypeFor</code> each tag:</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="tools/chapel-py/chapel.cpp">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>static</span> <span>PyTypeObject</span><span>*</span> <span>parentTypeFor</span><span>(</span><span>chpl</span><span>::</span><span>uast</span><span>::</span><span>asttags</span><span>::</span><span>AstTag</span> <span>tag</span><span>)</span> <span>{</span>
</span></span><span><span><span>#define AST_NODE(NAME)
</span></span></span><span><span><span>#define AST_LEAF(NAME)
</span></span></span><span><span><span>#define AST_BEGIN_SUBCLASSES(NAME)
</span></span></span><span><span><span>#define AST_END_SUBCLASSES(NAME) \
</span></span></span><span><span><span>  if (tag &gt; chpl::uast::asttags::START_##NAME &amp;&amp; tag &lt; chpl::uast::asttags::END_##NAME) { \
</span></span></span><span><span><span>    return &amp;NAME##Type; \
</span></span></span><span><span><span>  }
</span></span></span><span><span><span>#include</span> <span>&#34;chpl/uast/uast-classes-list.h&#34;</span><span>
</span></span></span><span><span><span>#include</span> <span>&#34;chpl/uast/uast-classes-list.h&#34;</span><span>
</span></span></span><span><span><span>#undef AST_NODE
</span></span></span><span><span><span>#undef AST_LEAF
</span></span></span><span><span><span>#undef AST_BEGIN_SUBCLASSES
</span></span></span><span><span><span>#undef AST_END_SUBCLASSES
</span></span></span><span><span><span></span>  <span>return</span> <span>&amp;</span><span>AstNodeType</span><span>;</span>
</span></span><span><span><span>}</span></span></span></code></pre></div>
</div>


<p>A few more invocations of the <code>uast-classes-list.h</code> macro, and I had a working
class hierarchy. I didn’t explicitly mention any AST node at all; all was derived
from the Chapel compiler header. This also meant that as the language changed
and the AST class hierarchy developed, the Python bindings’ code would not need
to be updated. As long as it was compiled with an up-to-date version of the
header, the hierarchy would match that present within the language.</p>
<p>This allows for code like the following to be written in Python:</p>
<div><pre tabindex="0"><code data-lang="Python"><span><span><span>def</span> <span>print_decls</span><span>(</span><span>mod</span><span>):</span>
</span></span><span><span>    <span>&#34;&#34;&#34;
</span></span></span><span><span><span>    Print all the things declared in this Chapel module.
</span></span></span><span><span><span>    &#34;&#34;&#34;</span>
</span></span><span><span>    <span>for</span> <span>child</span> <span>in</span> <span>mod</span><span>:</span>
</span></span><span><span>        <span>if</span> <span>isinstance</span><span>(</span><span>child</span><span>,</span> <span>NamedDecl</span><span>):</span>
</span></span><span><span>            <span>print</span><span>(</span><span>child</span><span>.</span><span>name</span><span>())</span>
</span></span></code></pre></div>
<a href="#application-3-cpython-method-tables-and-getters">
  <h3 id="application-3-cpython-method-tables-and-getters">Application 3: CPython Method Tables and Getters</h3>
</a>
<p>The Chapel Python bindings use the X Macro pattern another time, actually.
Like I mentioned earlier, I use <a href="https://en.cppreference.com/w/cpp/language/template_specialization">template specialization</a>
to reduce the amount of boilerplate code required for declaring Python objects.
In particular, there’s a general method table declared as follows:</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="tools/chapel-py/chapel.cpp">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>template</span> <span>&lt;</span><span>chpl</span><span>::</span><span>uast</span><span>::</span><span>asttags</span><span>::</span><span>AstTag</span> <span>tag</span><span>&gt;</span>
</span></span><span><span><span>struct</span> <span>PerNodeInfo</span> <span>{</span>
</span></span><span><span>  <span>static</span> <span>constexpr</span> <span>PyMethodDef</span> <span>methods</span><span>[]</span> <span>=</span> <span>{</span>
</span></span><span><span>    <span>{</span><span>NULL</span><span>,</span> <span>NULL</span><span>,</span> <span>0</span><span>,</span> <span>NULL</span><span>}</span>  <span>/* Sentinel */</span>
</span></span><span><span>  <span>};</span>
</span></span><span><span><span>};</span></span></span></code></pre></div>
</div>


<p>Then, when I need to add methods, I use template specialization by writing
something like the following:</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>template</span> <span>&lt;&gt;</span>
</span></span><span><span><span>struct</span> <span>PerNodeInfo</span><span>&lt;</span><span>TheAstTag</span><span>&gt;</span> <span>{</span>
</span></span><span><span>  <span>static</span> <span>constexpr</span> <span>PyMethodDef</span> <span>methods</span><span>[]</span> <span>=</span> <span>{</span>
</span></span><span><span>    <span>{</span><span>&#34;method_name&#34;</span><span>,</span> <span>TheNode_method_name</span><span>,</span> <span>METH_NOARGS</span><span>,</span> <span>&#34;Documentation string&#34;</span><span>},</span>
</span></span><span><span>    <span>// ... more like the above ...
</span></span></span><span><span><span></span>    <span>{</span><span>NULL</span><span>,</span> <span>NULL</span><span>,</span> <span>0</span><span>,</span> <span>NULL</span><span>}</span>  <span>/* Sentinel */</span>
</span></span><span><span>  <span>};</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div>
<p>When reviewing a PR that adds more methods to the Python bindings (by
defining new <code>TheNode_methodname</code> functions and then including them in the
method table), I noticed that in the PR, the developer added some methods
but forgot to put them into the respective table, leaving them unusable by
the Python client code. This came with the additional observation that there
was a moderate amount of duplication when declaring the C++ functions and then
listing them in the table. The name (<code>method_name</code> in the code) occurred many
times.</p>
<p>The developer who opened the PR suggesting using X Macros to combine the
information (declaration of function and its use in the corresponding method table)
into a single list. This led to the following header file:</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="tools/chapel-py/method-tables.h">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>CLASS_BEGIN</span><span>(</span><span>FnCall</span><span>)</span>
</span></span><span><span>  <span>METHOD_PROTOTYPE</span><span>(</span><span>FnCall</span><span>,</span> <span>actuals</span><span>,</span> <span>&#34;Get the actuals of this FnCall node&#34;</span><span>)</span>
</span></span><span><span>  <span>PLAIN_GETTER</span><span>(</span><span>FnCall</span><span>,</span> <span>used_square_brackets</span><span>,</span> <span>&#34;Check if this FnCall was made using square brackets&#34;</span><span>,</span>
</span></span><span><span>               <span>&#34;b&#34;</span><span>,</span> <span>return</span> <span>node</span><span>-&gt;</span><span>callUsedSquareBrackets</span><span>())</span>
</span></span><span><span><span>CLASS_END</span><span>(</span><span>FnCall</span><span>)</span></span></span></code></pre></div>
</div>


<p>The <code>PLAIN_GETTER</code> macro in this case is used to define trivial getters
(precluding the need for handling the Python-object-to-AST-node conversion,
and other CPython-specific things), whereas the <code>METHOD_PROTOTYPE</code> is used
to refer to methods that needed explicit implementations. With
this, the method tables are generated as follows:</p>





<div data-base-path="%!s(&lt;nil&gt;)" data-file-path="tools/chapel-py/chapel.cpp">
    
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>#define CLASS_BEGIN(TAG) \
</span></span></span><span><span><span>  template &lt;&gt; \
</span></span></span><span><span><span>  struct PerNodeInfo&lt;chpl::uast::asttags::TAG&gt; { \
</span></span></span><span><span><span>    static constexpr PyMethodDef methods[] = {
</span></span></span><span><span><span>#define CLASS_END(TAG) \
</span></span></span><span><span><span>      {NULL, NULL, 0, NULL}  </span><span>/* Sentinel */</span><span> \
</span></span></span><span><span><span>    }; \
</span></span></span><span><span><span>  };
</span></span></span><span><span><span>#define PLAIN_GETTER(NODE, NAME, DOCSTR, TYPESTR, BODY) \
</span></span></span><span><span><span>  {#NAME, NODE##Object_##NAME, METH_NOARGS, DOCSTR},
</span></span></span><span><span><span>#define METHOD_PROTOTYPE(NODE, NAME, DOCSTR) \
</span></span></span><span><span><span>  {#NAME, NODE##Object_##NAME, METH_NOARGS, DOCSTR},
</span></span></span><span><span><span>#include</span> <span>&#34;method-tables.h&#34;</span></span></span></code></pre></div>
</div>


<p>The <code>CLASS_BEGIN</code> generates the initial <code>template &lt;&gt;</code> header and the code up
to the opening curly brace of the table definition. Then, for each method,
<code>PLAIN_GETTER</code> and <code>METHOD_PROTOTYPE</code> generate the relevant entries. Finally,
<code>CLASS_END</code> inserts the sentinel and the closing curly brace.</p>
<p>Another invocation of the macros in <code>method-tables.h</code> is used to generate the
implementations of “plain getters”, which is boilerplate that I won’t get into
it here, since it’s pretty CPython specific.</p>
<a href="#discussion">
  <h3 id="discussion">Discussion</h3>
</a>
<p>I’ve presented to you a three applications of the pattern, in an order that happens
to be from least to most “extreme”. It’s possible that some of these are
over the line for using macros, especially for those who think of macros as
unfortunate remnants of C++’s past. However, I think that what I’ve demonstrated
demonstrates the versatility of the X Macro pattern – feel free to apply it to
the degree that you find appropriate.</p>
<p>The thing I like the most about this pattern is that the header files read quite nicely:
you end up with a very declarative “scaffold” of what’s going on. The
<code>uast-classes-list.h</code> makes for an excellent and fairly readable reference of
all the AST nodes in the Chapel compiler. The <code>method-tables.h</code> header provides
a fairly concise summary of what methods are available on what (Python) AST
node.</p>
<p>Of course, this approach is not without its drawbacks. Drawback zero is
the heavy use of macros: to the best of my knowledge, modern C++ tends to
discourage the usage of macros in favor of C++-specific features. Of course,
this “pure C++” preference is applicable to variable degrees in different use
cases and code bases; because of this, I won’t count macros as (too much of)
a drawback.</p>
<p>The more significant downside is that this approach introduces a lot of dependencies
between source files. Any time the header changes, anything that uses any part
of the code generated by the header must be recompiled. Thus, if you’re generating
classes, changing any one class will “taint” any code that uses <em>any</em> of the
generated classes. In the Chapel compiler, touching the AST class hierarchy
requires a recompilation of all the AST nodes, and any compiler code that uses
the AST nodes (a lot). This is because each AST node needs access to the
<code>AstTag</code> enum, and that enum is generated from the hierarchy header.</p>
<p>That’s all I have for today! Thanks for reading. I hope you got something useful
for your day-to-day programming out of this.</p>
</div></div>
  </body>
</html>
