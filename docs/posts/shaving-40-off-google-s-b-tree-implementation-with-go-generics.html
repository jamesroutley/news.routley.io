<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scylladb.com/2022/04/27/shaving-40-off-googles-b-tree-implementation-with-go-generics/">Original</a>
    <h1>Shaving 40% Off Google’s B-Tree Implementation with Go Generics</h1>
    
    <div id="readability-page-1" class="page"><div>
                    <div>
                        <p>There are many reasons to be excited about generics in Go. In this blog post I’m going to show how, using the generics, we got a 40% performance gain in an already well optimized package, the <a href="https://github.com/google/btree" target="_blank" rel="noopener">Google B-Tree</a> implementation.</p>
<p>A <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener">B-Tree</a> is a kind of self-balancing tree. For the purpose of this blog post it’s sufficient to say that it is a collection. You can add, remove, get or iterate over its elements. The Google B-Tree is well optimized, measures are taken to make sure memory consumption is correct. There is a benchmark for every exported method. The benchmark results show that there are zero allocations in the B-Tree code for all operations but cloning. Probably it would be hard to further optimize using traditional techniques.</p>
<h2>ScyllaDB and the University of Warsaw</h2>
<p>We have had a longstanding relationship with the Computer Science department at the University of Warsaw. You may remember some of our original projects, including those integrating <a href="https://www.scylladb.com/2020/08/05/scylla-student-projects-part-i-parquet/" target="_blank" rel="noopener">Parquet</a>, an <a href="https://www.scylladb.com/2020/08/25/scylla-student-projects-part-ii-implementing-an-async-userspace-file-system/" target="_blank" rel="noopener">async userspace filesystem</a>, or a <a href="https://www.scylladb.com/2020/11/17/scylla-student-projects-part-iii-kafka-client-for-seastar-and-scylla/" target="_blank" rel="noopener">Kafka client for Seastar</a>. Or more recent ones like a system for <a href="https://www.scylladb.com/2021/09/07/linear-algebra-in-scylla/" target="_blank" rel="noopener">linear algebra</a> in ScyllaDB or a design for a new <a href="https://www.scylladb.com/2021/07/13/scylla-rust-driver-update-and-benchmarks/" target="_blank" rel="noopener">Rust driver</a>.</p>
<p>This work was also part of our ongoing partnership with the University of Warsaw.</p>
<h2>Making Faster B-Trees with Generics</h2>
<p>While working on a new Scylla Go Driver with students of University of Warsaw, we ported the B-tree code to <a href="https://github.com/Michal-Leszczynski/btree" target="_blank" rel="noopener">generics</a>. (If you’re not familiar with generics in Go, check out <a href="https://go.dev/doc/tutorial/generics" target="_blank" rel="noopener">this tutorial</a>.).</p>
<p>The initial result: the generics code is faster by 20 to 30 percent according to the Google benchmarks (<a href="https://github.com/google/btree/issues/41" target="_blank" rel="noopener">link to issue we opened</a>). Below a full benchmark comparison done with benchstat.</p>

<p>This is great but within those numbers there is a troubling detail. The zero allocations is not something that you would normally see given that the functions accept an interface as a parameter.</p>

<p>For the rest of the blog post we’ll focus on benchmarking the <code>ReplaceOrInsert</code> function responsible for ingesting data. Let’s consider a simplified benchmark.</p>

<p>The results show even greater improvement: 31% vs. 27%, and allocations drop from 1, in case of the interface based implementation, to 0 in the case of generics.</p>

<p>Let’s try to understand what happens here.</p>
<h2>The Additional Allocation</h2>
<p>The Google benchmarks operate on a B-tree of integers <a href="https://github.com/google/btree/blob/ac7cc57f11e692c57831c3d9bcffb4b7a649b738/btree.go#L885" target="_blank" rel="noopener">hidden by an Item interface</a>. They use pre-generated random data in a slice. When an Item is passed to the <code>ReplaceOrInsert</code> function the underlying integer is already on the heap, technically we are copying a pointer. This is not the case when a plain integer needs to be converted to an Item interface — the parameter values start “escaping to heap”.</p>
<p>Go has a feature of deciding if a variable you initialized should live in the function’s stack or in the heap. Traditionally the compiler was very “conservative” and when it saw a function like <code>func bind(v interface{})</code> anything you wanted to pass as <code>v</code> would have to go to heap first. This is referred to as variable escaping to the heap. Over the years the compiler has gotten smarter, and calls to local functions or functions in other packages in your project can be optimized, preventing the variables from escaping. You can check for yourself by running  <code>go build -gcflags=&#34;-m&#34; .</code> in a Go package.</p>
<p>In the below example Go can figure out that it’s safe to take a pointer to the main functions stack.</p>

<p>As you can see the compiler informs us that variables do not escape to heap.</p>

<p>By changing the ToString implementation to</p>

<p>we see that the variables and literal values do start escaping.</p>

<p>In practical examples, when calling a function that accepts an interface as a parameter, the value almost always escapes to heap. When this happens it not only slows down the function call by the allocation, but also increases the GC pressure. Why is this important? The generics approach enables a truly zero allocation API, with zero GC pressure added as we will learn in the remainder of this blog post.</p>
<h2>Why is it faster?</h2>
<p>The B-tree, being a tree, consists of nodes. Each node holds a list of items.</p>

<p>When the Item is a pre-generics plain old interface, the value it holds must live separately somewhere on the heap. The compiler is not able to tell what is the size of an Item. From the runtime perspective an interface value is an unsafe pointer to data (word), a pointer to its type definition (typ), a pointer to interface definition (ityp); see <a href="https://github.com/golang/go/blob/357c9141369361101345f3048a6b2b3e149299d5/src/reflect/value.go#L180" target="_blank" rel="noopener">definitions in the reflect package</a>. It’s easier to digest than the runtime package. In that case we have items as a slice of int pointers.</p>
<p>On the other hand, with generic interface</p>

<p>and a generic type definition</p>

<p>items are a slice of ints — this reduces the number of small heap objects by a factor of 32.</p>
<p>Enough of theory, let’s try to examine a concrete usage. For the purpose of this blog I wrote a test program that is a scaled up version of my benchmark code.</p>

<p>We are adding 100 million integers, and the degree of the B-tree (number of items in a node) is 1k. There are two versions of this program: one uses generics, the other plain old interface. The difference in code is minimal, it’s literally changing <code>btree.New(degree)</code> to <code>btree.New[btree.Int](degree)</code> in line 13. Let’s compare data gathered by running both versions under `<code>/usr/bin/time -l -p</code>`.</p>
<table>
<tbody>
<tr>
<td></td>
<td>generics</td>
<td>interface</td>
<td>delta</td>
</tr>
<tr>
<td>real</td>
<td>11.49</td>
<td>16.59</td>
<td>-30.74%</td>
</tr>
<tr>
<td><span><strong>user</strong></span></td>
<td>11.27</td>
<td>18.61</td>
<td><span><strong>-39.44%</strong></span></td>
</tr>
<tr>
<td><span><strong>sys</strong></span></td>
<td>0.24</td>
<td>0.6</td>
<td><span><strong>-60.00%</strong></span></td>
</tr>
<tr>
<td><strong>maximum resident set size</strong></td>
<td><span>2334212096</span></td>
<td><span>6306217984</span></td>
<td><span><strong>-62.99%</strong></span></td>
</tr>
<tr>
<td>average shared memory size</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>average unshared data size</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>average unshared stack size</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>page reclaims</td>
<td><span>142624</span></td>
<td><span>385306</span></td>
<td>-62.98%</td>
</tr>
<tr>
<td>page faults</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>swaps</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>block input operations</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>block output operations</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>messages sent</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>messages received</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>signals received</td>
<td>600</td>
<td>843</td>
<td>-28.83%</td>
</tr>
<tr>
<td>voluntary context switches</td>
<td>25</td>
<td>48</td>
<td>-47.92%</td>
</tr>
<tr>
<td>involuntary context switches</td>
<td>1652</td>
<td>2943</td>
<td>-43.87%</td>
</tr>
<tr>
<td>instructions retired</td>
<td><span>204760684966</span></td>
<td><span>288827272312</span></td>
<td>-29.11%</td>
</tr>
<tr>
<td>cycles elapsed</td>
<td><span>37046278867</span></td>
<td><span>60503503105</span></td>
<td>-38.77%</td>
</tr>
<tr>
<td>peak memory footprint</td>
<td><span>2334151872</span></td>
<td><span>6308147904</span></td>
<td>-63.00%</td>
</tr>
<tr>
<td><span><strong>HeapObjects</strong></span></td>
<td><span>236884</span></td>
<td><span>50255826</span></td>
<td><span><strong>-99.53%</strong></span></td>
</tr>
<tr>
<td>HeapAlloc</td>
<td><span>2226292560</span></td>
<td><span>6043893088</span></td>
<td>-63.16%</td>
</tr>
</tbody>
</table>
<p>Here using generics solves a version of <em>N</em>+1 problem for slices of interfaces. Instead of one slice and <em>N</em> integers in heap we now can have just the slice of ints. The results are profound, the new code behaves better in every aspect. The wall time duration is down by 40%, context switches are down by 40%, system resources utilization is down by 60% — all thanks to a 99.53% reduction of small heap objects.</p>
<p>I’d like to conclude by taking a look at top CPU utilization.</p>
<p><code>go tool pprof -top cpu.pprof</code></p>
<table>
<tbody>
<tr>
<td>generics</td>
<td>interface</td>
</tr>
<tr>
<td><code><span>Type: cpu</span></code></td>
<td><code><span>Type: cpu</span></code></td>
</tr>
</tbody>
</table>
<p>You can literally see how messy the interface profile is, how gc starts kicking in killing it… It’s even more evident when we focus on gc.</p>
<p><code>go tool pprof -focus gc -top cpu.pprof</code></p>
<table>
<tbody>
<tr>
<td>generics</td>
<td>interface</td>
</tr>
<tr>
<td><code><span>Type: cpu</span></code></td>
<td><code><span>Type: cpu</span></code></td>
</tr>
</tbody>
</table>
<p>The generic version spent <strong>0.29s</strong> (<strong>2.62%</strong>) in GC while the interface version spent <strong>6.06s</strong> accounting for, hold your breath, <em><strong>32.49% of the total time!</strong></em></p>
<p><a href="https://www.scylladb.com/wp-content/uploads/image2-9.png"><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;800&#39;%20height=&#39;242&#39;%20viewBox=&#39;0%200%20800%20242&#39;%3E%3C/svg%3E" alt="" width="800" height="242" data-src="https://www.scylladb.com/wp-content/uploads/image2-9.png" data-srcset="https://www.scylladb.com/wp-content/uploads/image2-9.png 1999w, https://www.scylladb.com/wp-content/uploads/image2-9-300x91.png 300w, https://www.scylladb.com/wp-content/uploads/image2-9-1100x332.png 1100w, https://www.scylladb.com/wp-content/uploads/image2-9-768x232.png 768w, https://www.scylladb.com/wp-content/uploads/image2-9-1536x464.png 1536w" data-sizes="(max-width: 800px) 100vw, 800px"/></a><em>Generics: CPU profile flame focused on GC related function</em></p>

<p><a href="https://www.scylladb.com/wp-content/uploads/image3-5.png"><img decoding="async" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20width=&#39;800&#39;%20height=&#39;263&#39;%20viewBox=&#39;0%200%20800%20263&#39;%3E%3C/svg%3E" alt="" width="800" height="263" data-src="https://www.scylladb.com/wp-content/uploads/image3-5.png" data-srcset="https://www.scylladb.com/wp-content/uploads/image3-5.png 1999w, https://www.scylladb.com/wp-content/uploads/image3-5-300x99.png 300w, https://www.scylladb.com/wp-content/uploads/image3-5-1100x362.png 1100w, https://www.scylladb.com/wp-content/uploads/image3-5-768x253.png 768w, https://www.scylladb.com/wp-content/uploads/image3-5-1536x506.png 1536w" data-sizes="(max-width: 800px) 100vw, 800px"/></a><em>Interface: CPU profile flame focused on GC related functions</em></p>
<h2>Conclusion</h2>
<p>By shifting the implementation from one using interfaces, to one using generics, we were able to significantly improve performance, minimize garbage collection time, and minimize CPU and other resource utilization, such as heap size. Particularly with heap size, we were able to reduce HeapObjects by <strong>99.53%</strong>.</p>
<p>The future of Go generics is bright especially in the domain of slices.</p>

<p><a href="https://resources.scylladb.com/scylladb-engineering" target="_blank" rel="noopener">EXPLORE MORE SCYLLADB ENGINEERING CONTENT</a></p>
<h2>Want to be a ScyllaDB Monster?</h2>
<p>We’re definitely proud of the work we do with the students at the University of Warsaw. Yet ScyllaDB is a growing company with a talented workforce drawn from all over the world. If you enjoy writing high performance generic Go code, <a href="https://www.scylladb.com/company/careers/co/engineering/B4.424/back-end-golang-team-leader/all/" target="_blank" rel="noopener">come join us</a>. Or if you specialize in other languages or talents, check out our full list of careers at ScyllaDB:</p>
<p><a href="https://www.scylladb.com/company/careers/" target="_blank" rel="noopener">CAREERS AT SCYLLADB</a></p>



                    </div>
                    
                </div></div>
  </body>
</html>
