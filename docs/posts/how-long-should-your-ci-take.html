<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://graphite.dev/blog/how-long-should-ci-take">Original</a>
    <h1>How long should your CI take?</h1>
    
    <div id="readability-page-1" class="page"><div id="__next"><main><section id="hero"><p><img alt="Background gradient" loading="lazy" decoding="async" data-nimg="fill" src="https://graphite.dev/images/blog/backgrounds/1.png"/></p></section><section id="content"><div><div><div><p><img alt="author" loading="lazy" width="40" height="40" decoding="async" data-nimg="1" src="https://www.datocms-assets.com/85246/1677776207-greg.png"/></p><p>Greg Foster</p></div></div><article><p>Continuous Integration (CI) is a cornerstone of modern software development. By automatically checking for regressions and linter errors on each Pull Request (PRs), CI frees engineers to focus on more nuanced, qualitative aspects of code review.</p><p>If you’re reading this, you likely already use CI. You may also be familiar with waiting for CI to finish. You may dread rebasing a PR or fixing a nit, knowing it’ll restart a long CI run. This dread is a common one, leading to an obvious truth - CI is good, but long CI can be bad. That begs the question - how long is too long for CI tests?</p><h2><strong>The popular rule-of-thumb: the 10-minute ideal</strong><span id="the-popular-rule-of-thumb-the-10-minute-ideal"></span><a aria-label="Permalink for this section" theme="link" href="https://graphite.dev/blog/how-long-should-ci-take#the-popular-rule-of-thumb-the-10-minute-ideal"><span></span></a></h2><p>Various industry resources suggest an ideal CI time of around 10 minutes for completing a full build, test, and analysis cycle. As Kent Beck, author of Extreme Programming, <a href="https://books.google.com/books?id=32RGBAAAQBAJ&amp;pg=PA49&amp;lpg=PA49&amp;dq=%22A+build+that+takes+longer+than+ten+minutes+will+be+used+much+less+often,+missing+the+opportunity+for+feedback.+A+shorter+build+doesn%E2%80%99t+give+you+time+to+drink+your+coffee%22&amp;source=bl&amp;ots=-wptJVotin&amp;sig=ACfU3U1goiXkHBDEUq4VZU2m0G57-QYyBQ&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwj1zfGX_6WCAxVck4kEHbhxBxoQ6AF6BAgOEAM#v=onepage&amp;q=%22A%20build%20that%20takes%20longer%20than%20ten%20minutes%20will%20be%20used%20much%20less%20often%2C%20missing%20the%20opportunity%20for%20feedback.%20A%20shorter%20build%20doesn%E2%80%99t%20give%20you%20time%20to%20drink%20your%20coffee%22&amp;f=false">said</a>, “A build that takes longer than ten minutes will be used much less often, missing the opportunity for feedback. A shorter build doesn’t give you time to drink your coffee.” While taking time out of your day to drink coffee is hardly a contentious ideal, there is some debate around this <a href="https://semaphoreci.com/blog/2017/03/16/measure-and-improve-your-ci-speed.html">10-minute &#34;golden time,&#34;</a> with some arguing “<a href="https://news.ycombinator.com/item?id=27007236">Even if it takes 1 day to release commit A, that&#39;s OK b/c 10min later commit B has been released (because it was pushed 10min after commit A)</a>.”</p><p>As in other debates like <a href="https://graphite.dev/blog/the-best-pr-title-of-all-time">how to write good commit messages</a>, we couldn’t just sit on the sidelines; we had to see for ourselves!</p><h2><strong>Graphite&#39;s journey to uncover the truth</strong><span id="graphites-journey-to-uncover-the-truth"></span><a aria-label="Permalink for this section" theme="link" href="https://graphite.dev/blog/how-long-should-ci-take#graphites-journey-to-uncover-the-truth"><span></span></a></h2><p>At Graphite, we&#39;ve always taken a data-driven approach to validating conventional wisdom. In the case of CI, Graphite already syncs millions of GitHub action workflow runs in order to power our review experience.</p><p>In this investigation, we sampled PRs merged over the last three months, focusing on those which had at least one GitHub action workflow run and which had at least one code review. By correlating these times with other metrics like time-to-merge and weekly throughput, some interesting patterns emerged.</p><h2><strong>Insights</strong><span id="insights"></span><a aria-label="Permalink for this section" theme="link" href="https://graphite.dev/blog/how-long-should-ci-take#insights"><span></span></a></h2><h3><strong>The correlation between CI time and time-to-merge</strong><span id="the-correlation-between-ci-time-and-time-to-merge"></span><a aria-label="Permalink for this section" theme="link" href="https://graphite.dev/blog/how-long-should-ci-take#the-correlation-between-ci-time-and-time-to-merge"><span></span></a></h3><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMzQyIiBoZWlnaHQ9IjE0ODMiPjwvc3ZnPg==" aria-hidden="true" alt=""/><img aria-hidden="true" alt="" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLDhILDhgNEQ0NDhcVDg0OFxYjGBYVIhUaLysjGikoHRUiJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHA4QFTsdFh07Ly8vLy87NS8vLzUvLy8vLy81Ly8vLzUvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABAAGAMBIgACEQEDEQH/xAAZAAABBQAAAAAAAAAAAAAAAAAEAQIFBgf/xAAeEAABBAEFAAAAAAAAAAAAAAABAAIDBBIFESIxQf/EABcBAAMBAAAAAAAAAAAAAAAAAAIDBAH/xAAWEQEBAQAAAAAAAAAAAAAAAAABAgD/2gAMAwEAAhEDEQA/ANkOPpCDt3YIO3BNsxSMadnKuXadiwTs4rQHFMi4mfVK0spGYSKDi0Cy6c8ykTyTUkTv/9k="/></p><p>Our analysis found a clear correlation between CI time and the average time for a PR to get merged. That is expected - longer tests means more waiting before pressing the merge button. Surprisingly, however, this relationship is not one to one - an additional 5 minutes in CI time appear to increase average time-to-merge by over an hour.</p><p>This makes sense intuitively as CI runs many times over the course of a PR’s lifecycle. As it’s updated, reviewed, and merged oftentimes, the code will have to go through various build, run, and test cycles. A small increase in the time these cycles take can lead to a snowballing effect as the number of CI runs scales.</p><p>This highlights how important it is to <a href="https://about.gitlab.com/topics/ci-cd/continuous-integration-best-practices/">always use best practices when building out your CI infrastructure</a>.</p><h3><strong>The paradox: most merges in 15-30 minute CI times?</strong><span id="the-paradox-most-merges-in-15-30-minute-ci-times"></span><a aria-label="Permalink for this section" theme="link" href="https://graphite.dev/blog/how-long-should-ci-take#the-paradox-most-merges-in-15-30-minute-ci-times"><span></span></a></h3><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMzMxIiBoZWlnaHQ9IjE0ODMiPjwvc3ZnPg==" aria-hidden="true" alt=""/><img aria-hidden="true" alt="" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLFQoLDh4ZDg0NDh0NFhETHR4ZHhYTFiEaJysjHR4oHSEiJEExKC0vMjI1GSU4PTcwPCsxMi8BCgsLDg0OHBAQHDsoIig7Ly87Ozs7Oy87LzsvNS81Ly81Lzs7Oy8vLy8vLy8vLzUvOy8vLy8vLy81Ly81Ly8vL//AABEIABAAGAMBIgACEQEDEQH/xAAZAAACAwEAAAAAAAAAAAAAAAAFBgECBwD/xAAfEAAABgIDAQAAAAAAAAAAAAAAAQIEBRIDEQYhIhP/xAAWAQEBAQAAAAAAAAAAAAAAAAADBAL/xAAYEQADAQEAAAAAAAAAAAAAAAAAAQIhA//aAAwDAQACEQMRAD8A1h++wNdGtRbAXPyRt9CK5Ck9GOMq+ln2AGTirlZXuYSUiXrfRPB5jZFu7R5WWxwWoOHdYF1uYkZaQs3bWn//2Q=="/></p><p>While shorter CI times lead to any one PR merging in faster, it doesn’t seem to correlate to net more changes merging. Counterintuitively, we found CI times between 15-30 minutes correspond to the highest number of PRs merged per week per author. This graph shows that engineers with average CI run times around the 15-30 minute mark have the highest output in terms of number of PRs merged.</p><p>Our hypothesis around this conundrum is two-fold. Lightning fast CI times can be explained by products that are simply less complex: smaller builds, less tests, etc. On the other hand, extremely high CI runtimes indicate a lack of optimization: the builds are bloated, CI runs are flaky and include a lot of retries, tests are not written in an efficient way.</p><p>Teams centered in the middle of this curve are most typical of high-performing ,well-staffed teams with more complex products and optimized CI infrastructure.</p><p>It must be noted also that there IS indeed a drop off from the 5-10 minute bucket to the 10-15 minute bucket suggesting that the “10 minute golden rule” may still hold some validity.</p><h3><strong>The stacking solution</strong><span id="the-stacking-solution"></span><a aria-label="Permalink for this section" theme="link" href="https://graphite.dev/blog/how-long-should-ci-take#the-stacking-solution"><span></span></a></h3><p>Engineering organizations need to find a balance. CI takes time, and it often takes longer than one would like. Based on the data, it would be fair to say that 10 minutes is indeed a sweet spot for many small fast PRs, however you shouldn’t beat yourself up too much if your CI times start creeping up into the 25-30 minute range. Once you get past that though and start hitting 30+ minutes? It’s probably time to sit down with your DevOps engineers.</p><p>If you don’t have easy ways to shorten your CI execution time, consider stacking your pull requests. Stacking allows engineers to break up changes into dependency graphs of small PRs, each able to run CI in parallel. PRs can be created, modified, and reviewed all while other code is waiting for CI to finish. The workflow is ideal for maintaining velocity despite long individual CI times.</p><h2><strong>Key takeaways and recommendations</strong><span id="key-takeaways-and-recommendations"></span><a aria-label="Permalink for this section" theme="link" href="https://graphite.dev/blog/how-long-should-ci-take#key-takeaways-and-recommendations"><span></span></a></h2><ul><li><p><strong>No Lower Bound</strong>: Our data reveals no diminishing returns to optimizing CI speed, even below 5 minutes - even while filtering on PRs that awaited code review.</p></li><li><p><strong>New Rule of Thumb</strong>: Expect a 1-2 hour decrease in time-to-merge for every 5 minutes shaved off CI time.</p></li><li><p><strong>Consider Stacking Workflows</strong>: Teams with CI times in the 15-30 minute range should evaluate stacking to maximize efficiency.</p></li><li><p><strong>Check your own stats:</strong> <a href="https://app.graphite.dev/insights">Review your stats today</a> like “publish to merge time” and “number of PRs merged”. See how you stack up against the average developer and where you can improve.</p></li></ul></article></div></section><hr/></main></div></div>
  </body>
</html>
