<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytes.zone/posts/give-aliases-when-inverting-relations/">Original</a>
    <h1>give aliases when inverting relations</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>Brian Hicks, February 27, 2023</em></p><p>Say you&#39;re using <a href="https://bytes.zone/projects/learning-alloy/">Alloy</a> to model some tree structure. For example, a file system with directories and files:</p><pre data-lang="alloy"><code data-lang="alloy"><span>abstract sig</span><span> Node {
</span><span>  parent</span><span>: lone</span><span> Node,
</span><span>}
</span><span>
</span><span>sig</span><span> File, Directory </span><span>extends</span><span> Node {}
</span><span>
</span><span>fact</span><span> &#34;a node cannot be its own parent&#34; {
</span><span>  </span><span>no</span><span> n</span><span>:</span><span> Node </span><span>|</span><span> n </span><span>in</span><span> n</span><span>.^</span><span>parent
</span><span>}
</span><span>
</span><span>fact</span><span> &#34;there is only </span><span>one</span><span> root node&#34; {
</span><span>  </span><span>one</span><span> n</span><span>:</span><span> Node </span><span>| no</span><span> n</span><span>.</span><span>parent
</span><span>}
</span></code></pre><p>This gives us nice file system objects that always terminate in a single node and without any recursive shenanigans, like this one:</p><p><img src="https://bytes.zone/images/filesystem-two-dirs-two-files.png" alt="an Alloy diagram showing two directories, each containing one file. One directory also contains the other."/></p><p>However, the model currently implicitly allows this that we don&#39;t want to include based on our mental model of the filesystem. For example, files that have other files as their parent:</p><p><img src="https://bytes.zone/images/filesystem-parenting-files.png" alt="an Alloy diagram showing a file containing to other files"/></p><p>That doesn&#39;t work: a directory can have children, but a file needs to have contents instead (e.g., images, text, etc.) So let&#39;s disallow that! We&#39;ll do that by adding a new fact like “files shouldn&#39;t have any children.” We <em>could</em> do that by saying this:</p><pre data-lang="alloy"><code data-lang="alloy"><span>fact</span><span> &#34;files shouldn&#39;t have any children&#34; {
</span><span>  </span><span>no</span><span> File</span><span>.~</span><span>parent
</span><span>}
</span></code></pre><p>(In case you haven&#39;t encountered the <code>~</code> operator before, it just flips the relation. That makes it child-to-parent instead of parent-to-child. More about this in <a href="https://bytes.zone/posts/fields-as-sets/">fields as sets</a>)</p><p>Alloy can work fine with this, but in my opinion, using <code>~</code> like this makes the intent of the spec less clear. I always have to think about what the <code>~</code> is changing, even if I wrote the code not ten minutes before! Fortunately, we can clarify this by making an alias with a <code>fun</code> and then define our <code>fact</code> in those terms instead:</p><pre data-lang="alloy"><code data-lang="alloy"><span>fun</span><span> children</span><span>:</span><span> Node </span><span>-&gt;</span><span> Node {
</span><span>  </span><span>~</span><span>parent
</span><span>}
</span><span>
</span><span>fact</span><span> &#34;files shouldn&#39;t have any children&#34; {
</span><span>  </span><span>no</span><span> File</span><span>.</span><span>children
</span><span>}
</span></code></pre><p>This seems much clearer to me; the assertion we&#39;re making reads almost exactly how we&#39;d write it in English. I like that a lot! It makes communicating about the spec easier, both for me and for anyone else who ends up reading it.</p><p>In general, I&#39;m finding that I really like to use <code>fun</code>s to clarify my intent, or to put a durable label on some form of node. Doing this requires a little mindset shift from writing <code>pred</code>s or <code>fact</code>s, since <code>fun</code>s have to yield a subset of data instead of a boolean, but in my experience it results in higher-quality communication!</p></article></div>
  </body>
</html>
