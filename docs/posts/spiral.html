<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spiraldb.com/post/announcing-spiral">Original</a>
    <h1>Spiral</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>I&#39;ve been building data systems for long enough to be skeptical of “revolutionary” claims, and I’m uncomfortable with grandiose statements like “Built for the AI Era”. Nevertheless, AI workloads have tipped us into what I&#39;ll call the Third Age of data systems, and legacy platforms can&#39;t meet the moment.</p><h2 id="three-eras-of-data-systems">Three Eras of Data Systems</h2><p>In the beginning, databases had human-scale inputs and human-scale outputs. Postgres—the king of databases, first released in <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/1989_(album)"><span>1989</span></a>[1] —is the archetypal application database. A trivial example of a core Postgres workflow is letting a user create a profile, view it, and then update the email address. Postgres needs to support many users doing so at the same time, but it was built for a world in which the rate of database writes was implicitly limited by humans taking discrete actions.</p><p>Then came the age of &#34;Big Data&#34;, when we automated data collection at &#34;web scale&#34;, with much more granular events. Early internet giants scraped every link on the entire internet and captured every click on their websites. For data systems, this was the dawn of machine-scale <em>inputs</em>. However, the only way for a human to engage with this machine-collected data was to distill it down—into a dashboard, a chart, or even a single number. The inputs to a data system might have been in petabytes, but the end products were still measurable in kilobytes.</p><p>This unprecedented scale of data collection also led to a technological schism: on one side, we saw the rise of data lakes, massive shared filesystems where we would dump files and run MapReduce jobs. On the other side were (cloud) data warehouses, which provided both scalability and ergonomics for simple data types like dates, numbers, and short text. This branching then eventually converged into &#34;the Lakehouse&#34;, wherein the descendants of Hadoop discovered that<a target="_blank" rel="noopener noreferrer" href="https://db.cs.cmu.edu/papers/2024/whatgoesaround-sigmodrec2024.pdf"> </a><a target="_blank" rel="noopener noreferrer" href="https://db.cs.cmu.edu/papers/2024/whatgoesaround-sigmodrec2024.pdf"><span>tables were useful all along</span></a>.[2]</p><p>Now, we are witnessing another epochal shift: the rise of the &#34;Machine Consumer&#34;. In addition to machine-scale <em>inputs</em>, future data systems must be able to produce machine-scale <em>outputs</em>. Editing a few rows or aggregating a few simple columns is no longer enough. Machines don&#39;t want dashboards &amp; summaries—they want <em>everything</em>.</p><h2 id="what-machines-want">What Machines Want</h2><p>When I say machines want &#34;everything,&#34; let me be specific. An NVIDIA H100 has enough memory bandwidth to consume 4 <em>million</em> 100KiB images per second. A Monte Carlo tree search might need to perform billions of random reads across your entire dataset. Machines want to perform fast scans, fast point lookups, and fast searches over petabyte–or exabyte!–scale data.</p><p>This is fundamentally different from the Second Age, when we optimized for human-friendly aggregations and reports. And here&#39;s where our current infrastructure completely breaks down: there&#39;s an uncanny valley between 1KB and 25MB where Parquet files and object storage are both wildly inefficient. Stored individually and assuming 50ms of S3 latency, reading 4 million individual 100KiB images—enough to saturate the H100 for one <em>second</em>—would accrue 55 <em>hours</em> of aggregate network overhead. Vector embeddings, small images, large documents—these are exactly what AI systems need, and exactly what current systems handle poorly.</p><h2 id="symptoms-of-the-same-disease">Symptoms of the Same Disease</h2><p>This architectural mismatch between Third Age needs and Second Age tools manifests in two ways that are destroying teams’ ability to ship:</p><p><span>First, price-performance.</span> Your AI engineers are stuck in a Sisyphean loop: Read Parquet → Explode to Arrow (10x memory) → Convert to tensors → Cache intermediate results → (Finally) train -&gt; Repeat. Five steps to do what should be simple: feed data to a GPU. Meanwhile, that H100 capable of consuming 4 million images per second sits idle ~70% of the time. Your even-more-expensive AI Engineer is manually shepherding each iteration (and possibly hoping for Zuck to show up with $1B).</p><p><span>Second, security.</span> Raw performance is only half the problem. The other half should terrify your security team. Simon Willison recently noted that<a target="_blank" rel="noopener noreferrer" href="https://simonwillison.net/2025/Jul/6/supabase-mcp-lethal-trifecta/"> </a><a target="_blank" rel="noopener noreferrer" href="https://simonwillison.net/2025/Jul/6/supabase-mcp-lethal-trifecta/"><span>Supabase&#39;s MCP connector can leak your entire database</span></a> to anyone who can manipulate prompts.</p><p>Teams need to move fast. They need to experiment, iterate, and ship. But when their foundational needs aren’t met, they duct-tape solutions together. Database credentials get passed to AI agents. S3 bucket permissions get opened too wide. Audit logs are a fiction.</p><p>Here&#39;s the kicker: security isn&#39;t just a compliance checkbox. It&#39;s a performance multiplier. Every hack you ship today is technical debt you&#39;ll pay 10x to fix later. Every permissions model you bypass is a multitenant feature you can&#39;t build. The same missing primitives that force performance workarounds make security nearly impossible to bolt on later.</p><p>Both problems stem from the same root cause: cobbling together Second Age tools to solve Third Age problems. The tragedy isn&#39;t that teams are choosing between speed and security—it&#39;s that our infrastructure forces this false choice.</p><h2 id="were-not-the-first-to-notice">We’re Not the First to Notice</h2><p>Of course, we&#39;re not the first to recognize these problems. Smart people have been trying to bridge this gap.</p><p>The “Lakehouse” is the right high-level idea—object storage native is indeed the future.[3] But it&#39;s still duct-taping together a data lake and a data warehouse, duck-typing files as tables without fundamentally solving the unified storage problem. You end up managing multiple components with different permission models, different APIs, and different performance characteristics. As Ali Ghodsi likes to call it, you&#39;re managing a &#34;data estate&#34;—and like many estates, it&#39;s expensive, messy, and full of relics &amp; the occasional skeleton.</p><p>WebDataset solved an immediate need for AI teams, but it&#39;s essentially equivalent to CSV files for the deep learning era: convenient for simple cases but lacking the performance, expressivity, &amp; governance features that production systems demand.</p><p>These are all good Second Age solutions trying to solve Third Age problems. But Third Age problems need Third Age infrastructure—built from the ground up with machines as the primary consumer.</p><p>When OpenAI processes billions of images or Anthropic trains on massive document collections, they&#39;re not using traditional data warehouses. They&#39;ve built custom infrastructure because they had to.</p><p>We realized these weren&#39;t just technical problems to work around—they required rethinking the entire architecture.</p><p>Data systems must evolve.</p><h2 id="building-for-what-comes-next">Building for What Comes Next</h2><p>We started Spiral to take that next evolutionary step. Adapting legacy systems wasn&#39;t going to cut it; we needed to design for machine consumption from day one.</p><p>First, we created<a target="_blank" rel="noopener noreferrer" href="https://vortex.dev/"> </a><a target="_blank" rel="noopener noreferrer" href="https://vortex.dev/"><span>Vortex</span></a>—a state-of-the-art columnar file format—and donated it to the Linux Foundation. The technical validation has been overwhelmingly positive: Microsoft, Snowflake, Palantir, and other leading data companies are backing it. TUM&#39;s fabled database group just released their latest paper<a target="_blank" rel="noopener noreferrer" href="https://gienieczko.com/anyblox-paper"> </a><a target="_blank" rel="noopener noreferrer" href="https://gienieczko.com/anyblox-paper"><span>&#34;Anyblox&#34;</span></a>, independently calling Vortex the &#34;cutting edge&#34; in file formats.</p><p>Vortex achieves Parquet&#39;s compression ratios with 10-20x faster scans, 5-10x faster writes, and<a target="_blank" rel="noopener noreferrer" href="https://bench.vortex.dev/#Random_Access"> 100-200x faster random access reads (</a><a target="_blank" rel="noopener noreferrer" href="https://bench.vortex.dev/#Random_Access"><span>1.5 milliseconds vs Parquet’s 200 milliseconds</span></a>). Depending on the query and the engine, it is no slower, and often dramatically faster. But the real, long-term breakthrough? Vortex is designed to support decoding data directly from S3 to GPU, skipping the CPU bottleneck entirely.</p><p>Spiral is our database built on Vortex: object store native from day one; unified governance across all data types; machine-scale throughput that actually saturates your GPUs; and one API that handles everything from tiny embeddings to massive video files. All with what we call &#34;fearless permissioning&#34;—move as fast as you want without compromising security, because the right primitives are built in from the ground up.[4] </p><p>Remember that uncanny valley between 1KB and 25MB? The problem isn&#39;t the sizes—it&#39;s that Second Age systems force you to choose between two bad options: inline the data (killing performance) or store pointers (breaking governance). Spiral eliminates this false choice. We store 10KB embeddings directly in Vortex for microsecond access, intelligently batch 10MB blocks of images for optimal S3 throughput, and externalize 4GB videos without copying a single byte. One system, no compromises.</p><p>When you stop pretending machines are just very fast humans, the entire architecture inverts. Throughput becomes the critical constraint, not latency. Object storage becomes the foundation, not an afterthought. Security becomes unified, not bolted on.</p><p>With $22 million in Seed &amp; Series A funding from Amplify Partners &amp; General Catalyst, we&#39;re well on our way to building the infrastructure that the Third Age of Data demands.</p><h2 id="what-spiral-delivers">What Spiral Delivers</h2><p>Here&#39;s what this means in practice:</p><ul><li><p>That H100 capable of consuming 4 million images per second? With Spiral, it actually can.</p></li><li><p>Sharing data without the security nightmare? Solved with time-bounded, audited, granular permissions.</p></li><li><p>The five-step data loading dance? A single query.</p></li><li><p>Your AI engineers? <em>Actually working on AI</em>.</p></li></ul><p>This is what happens when you build for the world ahead, not the world we used to know.</p><h2 id="the-future-is-machine-scale">The Future is Machine Scale</h2><p>We&#39;re tackling how to work with <em>complex</em> data at <em>machine scale</em>. A modern GPU can consume <em>terabits</em> per second, and in ways that existing systems aren&#39;t built for. Whether you&#39;re loading data from object storage into a GPU for pre-training, doing millions of concurrent point reads for Monte Carlo tree search, or trying to wrangle data that other systems can&#39;t, we&#39;re building for you.</p><p>The gap between AI leaders and laggards is widening. While some teams cobble together solutions with duct tape and custom scripts, their competitors are already training next-generation models. The enterprises that get their data AI-ready today will have an insurmountable advantage tomorrow.</p><p>We&#39;re working with design partners across computer vision, robotics, and multimodal AI. If you&#39;re spending more than 10% of your time on data infrastructure instead of model development, we should talk.</p><p>I started by saying I&#39;m skeptical of revolutionary claims. But when the revolution is already here—when your GPUs are starving and you’re drowning in data—skepticism becomes denial. The question isn&#39;t whether your infrastructure will need to evolve—it&#39;s whether you&#39;ll lead that evolution or be left behind.</p><p>The future doesn&#39;t care if you&#39;re ready. But we do.</p><p><a target="_blank" rel="noopener noreferrer" href="https://spiraldb.com/careers"><span>Join us</span></a> or reach out (hello at spiraldb dot com).</p><p>—</p><p>P.S. If you&#39;re sttill managing data in spreadsheets, this post isn&#39;t for you. Yet.</p><ol><li><p>Taylor Swift, Postgres, and I are all roughly the same age. Coincidentally, I don&#39;t believe in dates before ~1989.</p></li><li><p>Tables are apparently like low rise jeans: cool in 2005 and back with a vengeance.</p></li><li><p>See e.g., <a target="_blank" rel="noopener noreferrer" href="https://www.warpstream.com/"><span>Warpstream</span></a>, <a target="_blank" rel="noopener noreferrer" href="https://turbopuffer.com/"><span>Turbopuffer</span></a>, and <a target="_blank" rel="noopener noreferrer" href="https://slatedb.io/"><span>SlateDB</span></a> for great examples of how powerful object storage native architectures can be.</p></li><li><p>I tried not to mention “written in Rust”, but yes, this term is inspired by <a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/book/ch16-00-concurrency.html"><span>fearless concurrency</span></a>. </p></li></ol></div></div></div>
  </body>
</html>
