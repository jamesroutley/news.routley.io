<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://docs.paradedb.com/blog/introducing_bm25">Original</a>
    <h1>Pg_bm25: Elastic-Quality Full Text Search Inside Postgres</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="https://mintlify.s3-us-west-1.amazonaws.com/paradedb/blog/images/bm25.png"/></p><p>We’re unveiling <code>pg_bm25</code>: a Rust-based Postgres extension that significantly improves Postgres’ full text
search capabilities. <code>pg_bm25</code> is named after BM25, the algorithm used by modern search engines to calculate the
relevance scores of search results.</p>
<p>Today, Postgres’ native full text search, which uses the <code>tsvector</code> type, has two main problems:</p>
<ol role="list">
<li><strong>Performance</strong>: Searching and ranking over large tables is sluggish. When tables grow to millions of rows, a single full text search can take several minutes.</li>
<li><strong>Functionality</strong>: Postgres has no support for operations like fuzzy search, relevance tuning, or
BM25 relevance scoring, which are the bread and butter of modern search engines.</li>
</ol>
<p><code>pg_bm25</code> aims to bridge the gap between the native capabilities of Postgres’ full text search and those of a specialized search engine like ElasticSearch.
The goal is to eliminate the need to bring a cumbersome service like ElasticSearch into the data stack.</p>
<p>Some features of <code>pg_bm25</code> include:</p>
<ul role="list">
<li>100% Postgres native, with zero dependencies on an external search engine</li>
<li>Built on top of Tantivy, a Rust-based alternative to the Apache Lucene search library</li>
<li>Query times over 1M rows are 20x faster compared to <code>tsquery</code> and <code>ts_rank</code>, Postgres’ built-in full text search and sort functions</li>
<li>Support for fuzzy search, aggregations, highlighting, and relevance tuning</li>
<li>Relevance scoring uses BM25, the same algorithm used by ElasticSearch</li>
<li>Real-time search — new data is immediately searchable without manual reindexing</li>
</ul>
<p><code>pg_bm25</code> stands on the shoulders of several open-source giants. The goal of this blog post is to recognize these projects
and to share how <code>pg_bm25</code> was built.</p>
<h2 id="the-shoulders-of-giants"><span>The Shoulders of Giants</span></h2>
<p>Putting a search engine inside of Postgres is hard. A few projects have attempted it, but with one caveat: every
single one has relied on an external ElasticSearch instance. This means introducing a
complex and expensive piece of infrastructure into the data stack. Perhaps the best-known example of this kind of design
is a Postgres extension called <a href="https://github.com/zombodb/zombodb" target="_blank" rel="noreferrer">ZomboDB</a>.</p>
<p>In 2016, an open source search library called <a href="https://github.com/quickwit-oss/tantivy" target="_blank" rel="noreferrer">Tantivy</a> emerged. Tantivy
was designed as a Rust-based alternative to Apache Lucene, the search library that powers ElasticSearch.
Three years later, a library called <a href="https://github.com/pgcentralfoundation/pgrx" target="_blank" rel="noreferrer">pgrx</a> — built by the same
author of ZomboDB — made it possible to build Postgres extensions in Rust.
Combined, these projects laid the groundwork for a Postgres extension that could create Elastic-quality
search experiences within Postgres.</p>
<h2 id="creating-the-inverted-index"><span>Creating the Inverted Index</span></h2>
<p>Like ElasticSearch, the backbone of Tantivy’s search engine is a data structure called the inverted index,
which stores a mapping from words to their locations in a set of documents. An inverted index
is like the table of contents of a book — without it, you might have to examine every page to find
a specific chapter.</p>
<p>Rather than creating this inverted index externally, <code>pg_bm25</code> stores the
index inside Postgres as a new, Postgres-native index type, which we call the BM25 index. This is made possible
through Postgres’ <a href="https://www.postgresql.org/docs/current/indexam.html" target="_blank" rel="noreferrer">index access method</a> API.</p>
<p>When a BM25 index is created, Postgres automatically updates it as new data arrives
or is deleted in the underlying SQL table. In this way, <code>pg_bm25</code> enables real-time search without any
additional reindexing logic.</p>
<h2 id="building-the-sql-interface"><span>Building the SQL Interface</span></h2>
<p>Following index creation, the next step was to expose an intuitive SQL interface for users to write search queries.
This was accomplished through the Postgres <a href="https://www.postgresql.org/docs/current/sql-createoperator.html" target="_blank" rel="noreferrer">operator API</a>,
which enables the creation of custom Postgres operators. We chose the <code>@@@</code> operator to signify the beginning
of a query to the BM25 index in homage to the <code>@@</code> operator used by Postgres’ native full text search.</p>
<p>The end result is the ability to search any table with a single SQL query.</p>
<div><div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> my_table
<span>WHERE</span> my_table @@@ <span>&#39;&#34;my query string&#34;&#39;</span>
</code></pre></div></div>
<p>Wherever possible, we designed the SQL interface to transparently mirror Tantivy’s API. For instance,
the right-hand side of the <code>@@@</code> operator accepts Tantivy’s mini query language and configuration options.</p>
<div><div><pre><code><span>SELECT</span> <span>*</span>
<span>FROM</span> my_table
<span>WHERE</span> my_table @@@ <span>&#39;description:keyboard^2 OR electronics:::fuzzy_fields=description&amp;distance=2&#39;</span>
</code></pre></div></div>
<h2 id="performance-benchmarks"><span>Performance Benchmarks</span></h2>
<p>On a table with one million rows, <code>pg_bm25</code> indexes 50 seconds faster than <code>tsvector</code> and ranks results
20x faster. Indexing and search times are nearly identical to those of a dedicated ElasticSearch instance.
With further optimizations, we’re aiming to reduce the query times compared to ElasticSearch
by an additional 2x.</p>
<p>More detailed benchmark results can be found in the extension <a href="https://github.com/paradedb/paradedb/tree/dev/pg_bm25#benchmarks" target="_blank" rel="noreferrer">README</a>.</p>
<h2 id="wrapping-up"><span>Wrapping Up</span></h2>
<p><code>pg_bm25</code> is ready for use today. There are two ways to try it: <a href="https://github.com/paradedb/paradedb/tree/dev/pg_bm25#installation" target="_blank" rel="noreferrer">installing it</a> inside an existing, self-hosted Postgres instance,
or <a href="https://github.com/paradedb/paradedb#from-self-hosted-postgres" target="_blank" rel="noreferrer">running the Postgres Docker image</a>.</p>
<p><code>pg_bm25</code> is open-source and licensed under AGPL. If you’d like to contribute, the best place to start is our
<a href="https://join.slack.com/t/paradedbcommunity/shared_invite/zt-217mordsh-ielS6BiZf7VW3rqKBFgAlQ" target="_blank" rel="noreferrer">Slack community</a>. And please don’t hesitate to show your support by
<a href="https://github.com/paradedb/paradedb" target="_blank" rel="noreferrer">giving us a star</a>!</p></div></div>
  </body>
</html>
