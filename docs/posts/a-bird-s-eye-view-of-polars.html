<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pola.rs/posts/polars_birds_eye_view/">Original</a>
    <h1>A bird&#39;s eye view of Polars</h1>
    
    <div id="readability-page-1" class="page"><section><div><div><div><p>A good library abstracts away many complexities for its user. Polars is no different in this regard, as it maintains a philosophy that queries you write should be performant by default without knowing any of the internals. However, many users are interested in what happens under the hood either as a learning experience or to squeeze that last bit of performance out of their queries. In this blog post, we will provide a bird’s eye view of how Polars works and in future posts we will deep dive into each of its components.</p>
<h2 id="high-level-overview">High level overview</h2>
<p>So, what is Polars? A short description would be “a query engine with a DataFrame frontend”. This is too high level even for a bird’s eye view. So let’s dive into the two elements, DataFrame and query engine, a bit more by looking at how a query gets executed. By taking a step-by-step journey through the execution of a query, we can observe each component in action and understand its role and purpose.</p>
<p>From a bird’s eye view, the execution of a query goes as follows. First we parse the query and validate it into a logical plan. The plan describes what the user intends to do, but not the how. Then our query optimizer traverses this plan (several times) to optimize any unnecessary work and produces an optimized logical plan. Following this optimization phase, the query planner transforms this logical plan into a physical plan, which outlines how the query is to be executed. This finalized physical plan serves as the ultimate input for the actual execution of the query and runs our compute kernels.</p>
<p><img alt="" src="https://pola.rs/_astro/birds-eye-overview.6f8aa92d_ZVHkQh.webp" width="3074" height="209" loading="lazy" decoding="async"/></p>
<h2 id="query">Query</h2>
<p>When you interact with Polars, you use our DataFrame API. This API is specifically designed to allow for parallel execution and with performance in mind. Writing a Polars query in that sense is writing a small program (or this case query) in a domain-specific language (<a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>) designed by Polars. This DSL has its own set of rules governing which queries are valid and which ones are not.</p>
<p>For this post, let’s use the famous NYE taxi dataset with taxi trips<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>. In the example below we calculate the average cost per minute for a trip over 25 dollars by zone. This case is simple enough to be easily understood while containing enough depth to showcase the purpose of the query engine.</p>
<pre tabindex="0"><code><span><span>import</span><span> polars </span><span>as</span><span> pl</span></span>
<span></span>
<span><span>query </span><span>=</span><span> (</span></span>
<span><span>    pl</span><span>.</span><span>scan_parquet</span><span>(</span><span>&#34;yellow_tripdata_2023-01.parquet&#34;</span><span>)</span></span>
<span><span>    .</span><span>join</span><span>(pl.</span><span>scan_csv</span><span>(</span><span>&#34;taxi_zones.csv&#34;</span><span>), left_on</span><span>=</span><span>&#34;PULocationID&#34;</span><span>, right_on</span><span>=</span><span>&#34;LocationID&#34;</span><span>)</span></span>
<span><span>    .</span><span>filter</span><span>(pl.</span><span>col</span><span>(</span><span>&#34;total_amount&#34;</span><span>) </span><span>&gt;</span><span> 25</span><span>)</span></span>
<span><span>    .</span><span>group_by</span><span>(</span><span>&#34;Zone&#34;</span><span>)</span></span>
<span><span>    .</span><span>agg</span><span>(</span></span>
<span><span>        (pl.</span><span>col</span><span>(</span><span>&#34;total_amount&#34;</span><span>) </span><span>/</span></span>
<span><span>        (pl.</span><span>col</span><span>(</span><span>&#34;tpep_dropoff_datetime&#34;</span><span>) </span><span>-</span><span> pl.</span><span>col</span><span>(</span><span>&#34;tpep_pickup_datetime&#34;</span><span>)).dt.</span><span>total_minutes</span><span>()</span></span>
<span><span>        ).</span><span>mean</span><span>().</span><span>alias</span><span>(</span><span>&#34;cost_per_minute&#34;</span><span>)</span></span>
<span><span>    ).</span><span>sort</span><span>(</span><span>&#34;cost_per_minute&#34;</span><span>,descending</span><span>=</span><span>True</span><span>)</span></span>
<span><span>)</span></span></code></pre>
<p>The query above is of type <code>LazyFrame</code>. It returns instantly while the NY taxi trips dataset is over 3 million rows, so what has happened? The statement defines the query, but does not yet execute it. This concept is known as lazy evaluation and is one of the key strengths of Polars. If you look into the data structure on the Rust side, you will see it contains two elements: a <code>logical_plan</code> and configuration flags for the optimizer <code>opt_state</code>.</p>
<pre tabindex="0"><code><span><span>pub</span><span> struct</span><span> LazyFrame</span><span> {</span></span>
<span><span>    pub</span><span> logical_plan</span><span>:</span><span> LogicalPlan</span><span>,</span></span>
<span><span>    pub</span><span>(</span><span>crate</span><span>) opt_state</span><span>:</span><span> OptState</span><span>,</span></span>
<span><span>}</span></span></code></pre>
<p>The logical plan is a tree with the data sources as leaves of the tree and the transformations as nodes. The plan describes the structure of a query and the expressions it contains.</p>
<pre tabindex="0"><code><span><span>pub</span><span> enum</span><span> LogicalPlan</span><span> {</span></span>
<span><span>    /// Filter on a boolean mask</span></span>
<span><span>    Selection</span><span> {</span></span>
<span><span>        input</span><span>:</span><span> Box</span><span>&lt;</span><span>LogicalPlan</span><span>&gt;,</span></span>
<span><span>        predicate</span><span>:</span><span> Expr</span><span>,</span></span>
<span><span>    },</span></span>
<span><span>    /// Column selection</span></span>
<span><span>    Projection</span><span> {</span></span>
<span><span>        expr</span><span>:</span><span> Vec</span><span>&lt;</span><span>Expr</span><span>&gt;,</span></span>
<span><span>        input</span><span>:</span><span> Box</span><span>&lt;</span><span>LogicalPlan</span><span>&gt;,</span></span>
<span><span>        schema</span><span>:</span><span> SchemaRef</span><span>,</span></span>
<span><span>        options</span><span>:</span><span> ProjectionOptions</span><span>,</span></span>
<span><span>    },</span></span>
<span><span>    /// Join operation</span></span>
<span><span>    Join</span><span> {</span></span>
<span><span>        input_left</span><span>:</span><span> Box</span><span>&lt;</span><span>LogicalPlan</span><span>&gt;,</span></span>
<span><span>        input_right</span><span>:</span><span> Box</span><span>&lt;</span><span>LogicalPlan</span><span>&gt;,</span></span>
<span><span>        schema</span><span>:</span><span> SchemaRef</span><span>,</span></span>
<span><span>        left_on</span><span>:</span><span> Vec</span><span>&lt;</span><span>Expr</span><span>&gt;,</span></span>
<span><span>        right_on</span><span>:</span><span> Vec</span><span>&lt;</span><span>Expr</span><span>&gt;,</span></span>
<span><span>        options</span><span>:</span><span> Arc</span><span>&lt;</span><span>JoinOptions</span><span>&gt;,</span></span>
<span><span>    },</span></span>
<span><span>    ...</span></span>
<span><span>}</span></span></code></pre>
<p>One important step when converting your query into a logical plan is validation. Polars knows the schema of the data upfront and can validate if the transformations are correct. This ensures you don’t run into any errors halfway through executing a query. For instance, defining a query where you select a column that does not exist returns an error before execution</p>
<pre tabindex="0"><code><span><span>pl</span><span>.</span><span>LazyFrame</span><span>([]).</span><span>select</span><span>(pl.</span><span>col</span><span>(</span><span>&#34;does_not_exist&#34;</span><span>))</span></span></code></pre>
<pre tabindex="0"><code><span><span>polars.exceptions.ColumnNotFoundError: column_does_not_exist</span></span>
<span><span></span></span>
<span><span>Error originated just after this operation:</span></span>
<span><span>DF []; PROJECT */0 COLUMNS; SELECTION: &#34;None&#34;</span></span></code></pre>
<p>We can view the logical plan by calling <code>show_graph</code> on a <code>LazyFrame</code>:</p>
<pre tabindex="0"><code><span><span>query</span><span>.</span><span>show_graph</span><span>(optimized</span><span>=</span><span>False</span><span>)</span></span></code></pre>
<p><img alt="non optimized query plan" src="https://pola.rs/_astro/non-optimized.82896225_ZbNItr.svg" width="984" height="383" loading="lazy" decoding="async"/></p>
<h2 id="query-optimization">Query Optimization</h2>
<p>The goal of the query optimizer is to optimize the <code>LogicalPlan</code> for performance. It does this by traversing the tree structure and modifying/adding/removing nodes.There are many types of optimizations that will lead to faster execution, for instance changing the order of operations. Generally, you want <code>filter</code> operations to occur as early as possible as it allows you to throw away any unused data and avoid unnessary work. In the example we can show our optimized logical plan with the same <code>show_graph</code> function:</p>
<pre tabindex="0"><code><span><span>query</span><span>.</span><span>show_graph</span><span>()</span></span></code></pre>
<p><img alt="optimized query plan" src="https://pola.rs/_astro/optimized.e46e3f3c_ZSiab5.svg" width="1083" height="383" loading="lazy" decoding="async"/></p>
<p>At first glance, it might look like both plans (optimized vs non optimized) are the same. However, two important optimizations have occured <strong>Projection pushdown</strong> and <strong>Predicate pushdown</strong>.</p>
<p>Polars has analyzed the query and noted that only use a small set of columns is used. For the trip data there are four columns. For the zone data there are two columns. Reading in the entire dataset would be wasteful as there is no need for the other columns. Therefore, by analyzing your query, <strong>Projection Pushdown</strong> will speed up reading in the data significantly. You can see the optimization in the leaf nodes under $\pi$  4/19 and $\pi$ 2/4.</p>
<p>With <strong>Predicate pushdown</strong> Polars filters data as close to the source as possible. This avoids reading in data that a later stage in the query will be discarded. The filter node has been moved to the parquet reader under $\sigma$ which indicates our reader will immediately remove rows which do not match our filter. The next join operation will a lot faster as there is less data coming in.</p>
<p>Polars supports a range of optimizations which can be viewed <a href="https://docs.pola.rs/user-guide/lazy/optimizations/">here</a>.</p>
<h2 id="query-execution">Query Execution</h2>
<p>Once the logical plan has been optimized, it is time for execution. The logical plan is a blueprint for what the user wants to execute, not the how. This is where the physical plan comes into play. A naive solution would be to have one join algorithm and one sort algorithm; that way, you could execute the logical plan directly. However, this comes at a huge performance cost, because knowing the characteristics of your data and the environment you run in allows Polars to select more specialized algorithms. Thus there is not one join algorithm, but multiple, each with their own unique style and performance. The query planner converts the LogicalPlan into a PhysicalPlan and picks the best algorithms for the query. Then our compute engine performs the operations. This post will not go into much detail about the execution model of our engines or how it is able to work so fast. That is left for another time.</p>
<p>When we look the performance difference of both plans (optimized vs non-optimized), we can see a 4x improvement. This is the power of lazy execution and using a query engine instead of eagerly evaluating every expression in order. It allows the engine to optimize and avoid unnecessary work. This whole improvement comes at zero cost for the user as all they have to do is write the query. All the complexity is hidden inside the query engine.</p>
<pre tabindex="0"><code><span><span>%%</span><span>time</span></span>
<span><span>query</span><span>.</span><span>collect</span><span>(no_optimization</span><span>=</span><span>True</span><span>)</span><span>;</span></span></code></pre>
<pre tabindex="0"><code><span><span>CPU times: user 2.45 s, sys: 1.18 s, total: 3.62 s</span></span>
<span><span>Wall time: 544 ms</span></span></code></pre>
<pre tabindex="0"><code><span><span>%%</span><span>time</span></span>
<span><span>query</span><span>.</span><span>collect</span><span>()</span><span>;</span></span></code></pre>
<pre tabindex="0"><code><span><span>CPU times: user 616 ms, sys: 54.2 ms, total: 670 ms</span></span>
<span><span>Wall time: 135 ms</span></span></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>During this post we covered the main components of Polars. Hopefully by now you will have a better understanding of how Polars works from its API down to execution. The next posts will dive deeper into every component, so stay tuned!</p>
</div></div></div></section></div>
  </body>
</html>
