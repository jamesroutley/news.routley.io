<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.specfy.io/blog/7-git-like-versioning-in-postgres">Original</a>
    <h1>Versioning data in Postgres? Testing a Git like approach</h1>
    
    <div id="readability-page-1" class="page"><div><p>Postgres is probably the software I love the most. Battle tested, resilient and scalable, it has been perfectly crafted in the last 30 years into one the most critical piece of technology out there.
However one could complain it&#39;s not the fastest software to introduce new feature. And when something is missing you might end up being stuck, adding plugins is not easy and often impossible in the cloud, new version migration can be tricky or very slow.
Moreover, a much-anticipated feature might take years to see the light of day, like table partitioning. And a <strong>notable absence in PostgreSQL</strong> is: data versioning.</p>
<p>Over the years, I had to add versioning in Postgres more than 10 times, and every time in a slightly different way. When I started prototyping Specfy I knew it would my 11th. Keeping <strong>history of different tables is critical</strong> to this project, so I needed a simple way to do it at scale with different tables, evolving schema and with as little maintenance as possible.</p>
<p>I listed alternatives and ready to use solution, but all of them had drawbacks (listed at the end) so I continued my search. I got curious about <strong>storing everything in Git.</strong> It has out of the box versioning, branching, conflict resolution, scale, etc.
After a few days of digging, I realised it was a bit overkill and not the best for structured content like JSON, but it motivated me to try something new, a generic git-like versioning <strong>but in Postgres</strong>.</p>
<h2 id="h-how-git-internal-works"><a href="#h-how-git-internal-works">ยง</a>How Git internal works?</h2>
<p>I think it&#39;s important to understand how git works internally before jumping on the solution. We won&#39;t replicate all git&#39;s pattern in Postgres but try to achieve the same way to store and version objects. Please note that the following section is a simplification to make it easier to understand.</p>
<h3 id="h-creating-a-file"><a href="#h-creating-a-file">ยง</a>Creating a file</h3>
<p>A git commit flow usually looks like this:</p>
<pre><div><pre><code>git add myfile.txt
git commit -m &#34;initial commit&#34;
git push
</code></pre></div></pre>
<p>Those are high level commands that hides the complexity of git. It&#39;s actually possible to write a commit using more low-level commands, like this:</p>
<div><div><pre><div><pre><code># Get the hash of the file&#39;s content
$hash=${git hash-object -w myfile.txt}

# Add this hash with the file to object storage
git update-index --add --cacheinfo 100644 \
  $hash myfile.txt

# Write this file to a tree
# A tree is representation of a folder and its files
#  each folder has a tree hash
# For the sake of simplicity we are still using some plumbing
$treeHash=${git write-tree}

# Commit the tree
git commit-tree $treeHash -m &#34;initial commit&#34;

# Update the ref to point the HEAD to the new tree
git update-ref refs/heads/main $treeHash
git push
</code></pre></div></pre></div><p><img src="https://www.specfy.io/posts/7/git_hash_explanation_create.png" alt=""/></p></div>
<p>Basically at each step you get an hash: a file has an hash, a tree has an hash, a commit has an hash, a branch is a reference to hash, a tag is a reference to hash, a stash has an hash, etc...</p>
<pre><div><pre><code>git log --pretty=raw

commit 7db0d9cefc38d263af8be1fa4b2f84531c151a60
tree 93d8ccbc3f275695ad86ca6126f0154b3973be42
parent 2f4eef4ad79ffda62f9b940d5a95fab7d17c0bd2
author Samuel Bodin &lt;1637651+bodinsamuel@users.noreply.github.com&gt; 1697460399 +0200
</code></pre></div></pre>
<h3 id="h-updating-a-file"><a href="#h-updating-a-file">ยง</a>Updating a file</h3>
<p>Now that we understood the internals we can use the plumbing to update our file.</p>
<pre><div><pre><code>echo &#34;foobar&#34; &gt; myfile.txt
git add myfile.txt
git commit -m &#34;fix: something&#34;
git push
</code></pre></div></pre>
<p>After our &#34;initial commit&#34; we now have a <code>.git</code> with one object and one commit. When we update the file, add it and commit it, we create a new object, a new tree and a new commit.
Then we push it to the current branch. The new commit will become the new HEAD.</p>
<p><img src="https://www.specfy.io/posts/7/git_hash_explanation_update.png" alt=""/></p>
<p>As you can see a new commit is a full copy of the file tree, and all previous objects are still there.
So when you switch to a branch, checkout a commit or a file, you are getting all the information inside a single commit hash.</p>
<h3 id="h-git-is-not-storing-patches"><a href="#h-git-is-not-storing-patches">ยง</a>Git is not storing patches</h3>
<p>After 10 years of using Git, I realised something, it is not storing patches.
Naively when you read a git diff or a pull request, you might think like me, that git is storing a diff between A and B and just displays it when needed.
But in reality it stores the full file in the object storage. So <strong>each modification is just a new file</strong> (or object), described by an hash, added to a file tree and linked to a commit hash.</p>
<p>That also means at any given time, git has a copy of all your files since the beginning of the project. If you have rewrote a file 999 times, there is 999 times copy of this file in the object storage. That&#39;s why it can be slow to clone a git repository.</p>
<p>All of this combined, it has many advantages:</p>
<ol>
<li>You can follow history by just following an object hash and its parent hash, like a linked list</li>
<li>You can navigate history instantly without having to recompute any diff</li>
<li>You can switch to a branch by changing the HEAD hash</li>
<li>You can rebase by changing a single parent hash</li>
<li>You can diff two versions years appart because you have access to the full files</li>
<li>You can revert to any version by changing a single hash</li>
<li>You can rewrite history by changing a single parent hash</li>
</ol>
<div><p>Using <code>git clone --depth 1</code> allows you to fasten your clone by not downloading all the history</p></div>
<p>&#34;Storing everything at each update&#34; sounds counter-intuitive and naive, but it is actually the most efficient solution in this scenario. Especially considering storage is cheap and computation is costly and slow.</p>
</div></div>
  </body>
</html>
