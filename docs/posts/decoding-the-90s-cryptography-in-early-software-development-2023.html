<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.botanica.software/post/decoding-the-90s">Original</a>
    <h1>Decoding the 90s: Cryptography in Early Software Development (2023)</h1>
    
    <div id="readability-page-1" class="page"><div data-hook="post-description"><div><div><div data-rce-version="10.123.1"><div dir="ltr" data-id="content-viewer"><div><div><div data-breakout="normal"><div id="viewer-71v5q"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="71v5q"><wow-image id="fab603_66b3724efe074fc6ae9c2576665d13fc~mv2.gif" data-image-info="{&#34;containerId&#34;:&#34;71v5q&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:640,&#34;height&#34;:400,&#34;uri&#34;:&#34;fab603_66b3724efe074fc6ae9c2576665d13fc~mv2.gif&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_66b3724efe074fc6ae9c2576665d13fc~mv2.gif/v1/fill/w_640,h_400,al_c,pstr/fab603_66b3724efe074fc6ae9c2576665d13fc~mv2.gif" alt="QText 5.0 loading animation on MS-DOS" data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_66b3724efe074fc6ae9c2576665d13fc~mv2.gif" draggable="false"/></wow-image></div></div></figure></div></div></div><p data-breakout="normal"><h2 dir="auto" id="viewer-3ce2u"><span><span>Intro</span></span></h2></p><p dir="auto" id="viewer-88e1j"><span><span>In August 2020, we were commissioned by a client with a cache of locked QText documents from the mid 90s - to which he has lost the passcode.</span></span></p><p dir="auto" id="viewer-9t5un"><span><a target="_blank" href="https://en.wikipedia.org/wiki/QText_(word_processor)" rel="noopener" data-hook="web-link"><span>QText</span></a><span> was a DOS era Hebrew-English word processor written in Turbo Pascal, released 15 or so odd years before neither I nor </span><a target="_blank" href="https://www.linkedin.com/in/elisha-eshed" rel="noopener" data-hook="web-link"><u><span>@Elisha</span></u></a><span> had laid hands on a reverse engineering tool.</span></span></p><p dir="auto" id="viewer-5f76u"><span><span>In this blog post, weâ€™ll describe the process of analyzing the encrypted documents and reverse engineering a DOS program.</span></span></p><p dir="auto" id="viewer-ft3f9"><span><span>Hopefully weâ€™ll be able to provide some insight into the early days of software development in Israel, and more generally into how cryptography was viewed and implemented in the early days of consumer software development. We also hope to help preserve the knowledge and tools utilized here - a lot of which have scarcely survived to this day.</span></span></p><p data-breakout="normal"><h2 dir="auto" id="viewer-5se58"><span><span>Getting started - QText</span></span></h2></p><p dir="auto" id="viewer-epgeo"><span><span>Luckily, we had access to working QText binaries, supplied by our client. We loaded up an instance of the </span><a target="_blank" href="https://www.dosbox.com/" rel="noopener" data-hook="web-link"><span>DOSBOX</span></a><span> emulator and proceeded to play around with the word processor for a while - focusing on the document encryption feature.</span></span></p><p dir="auto" id="viewer-bc2a3"><span><span>Our initial conclusions included the following:</span></span></p><div data-breakout="normal"><ul><li dir="auto" aria-level="1"><p dir="" id="viewer-5rupo"><span><span>The passcode is short - 4 characters and limited to uppercase characters and numbers - which represents a very small keyspace relative to modern compute power.</span></span></p></li><li dir="auto" aria-level="1"><p dir="" id="viewer-b0kdm"><span><span>Documents are normally some form of plain rich text - but locked documents have a 0ğ‘¥1ğ’Ÿ header prepended to them. Documents with the same passcode have the same header (no salt).</span></span></p></li><li dir="auto" aria-level="1"><p dir="" id="viewer-eu5ps"><span><span>Out of 0ğ‘¥1ğ’Ÿ header bytes - 1616 are actually variable and correlate directly to the passcode - could it be the encryption key is included in the file?</span></span></p></li><li dir="auto" aria-level="1"><p dir="" id="viewer-7d4ea"><span><span>Unfamiliar encryption - seems to work on per-line and per-column basis, meaning equal plaintext lines would result in equal ciphertext lines. Spaces are skipped when encrypting, which indicates the per-column charateristic.</span></span></p></li></ul></div><div data-breakout="normal"><div id="viewer-5m70l"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="5m70l"><wow-image id="fab603_e3c1face5e6345109089964c152bfc86~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;5m70l&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:976,&#34;height&#34;:204,&#34;uri&#34;:&#34;fab603_e3c1face5e6345109089964c152bfc86~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_e3c1face5e6345109089964c152bfc86~mv2.png/v1/fill/w_976,h_204,al_c,q_85,enc_avif,quality_auto/fab603_e3c1face5e6345109089964c152bfc86~mv2.png" alt="Headers shown in the hex dump of an encrypted QText documents" data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_e3c1face5e6345109089964c152bfc86~mv2.png/v1/fill/w_1171,h_245,al_c,lg_1,q_85/fab603_e3c1face5e6345109089964c152bfc86~mv2.png" draggable="false"/></wow-image></div></div><div id="viewer-5m70l-caption"><p><figcaption><span>First line of two documents with different passcodes - key is underlined</span></figcaption></p></div></figure></div></div></div><div data-breakout="normal"><div id="viewer-fflgb"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="fflgb"><wow-image id="fab603_815cc71170ee4be1afa225a26d34b616~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;fflgb&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:1228,&#34;height&#34;:314,&#34;uri&#34;:&#34;fab603_815cc71170ee4be1afa225a26d34b616~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_815cc71170ee4be1afa225a26d34b616~mv2.png/v1/fill/w_980,h_251,al_c,q_85,usm_0.66_1.00_0.01,enc_avif,quality_auto/fab603_815cc71170ee4be1afa225a26d34b616~mv2.png" alt="Payload from two documents with same passcode and plaintext - one is interlaced with spaces" data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_815cc71170ee4be1afa225a26d34b616~mv2.png/v1/fill/w_1228,h_314,al_c,q_90/fab603_815cc71170ee4be1afa225a26d34b616~mv2.png" draggable="false"/></wow-image></div></div><div id="viewer-fflgb-caption"><p><figcaption><span>Payload from two documents with same passcode and plaintext - one is interlaced with spaces</span></figcaption></p></div></figure></div></div></div><p dir="auto" id="viewer-8fosk"><span><span>So a very rudimentary system, as you might expect considering this was developed at a time before the internet was commonplace - let alone knowledge of cryptographic best-practice.</span></span></p><p dir="auto" id="viewer-2avn9"><span><span>The key seems to be included in the file, but we donâ€™t know the encryption mechanism. We could try and reverse engineer the encryption function, but brute-forcing the passcode is feasible, and in this case much simpler - if we have a fast way to test the passcodes.</span></span></p><p dir="auto" id="viewer-a80hp"><span><span>Working under the relatively safe assumption that the 16 byte key in the file is somehow derived from the passcode - we can try and focus our RE efforts on the key derivation algorithm. Our first guess was that the passcode was simply hashed using a hash function from that time, but that direction unfortunately didnâ€™t pan out.</span></span></p><p dir="auto" id="viewer-4j41v"><span><span>We set our sight on the key derivation algorithm and started taking apart the executable.</span></span></p><p data-breakout="normal"><h2 dir="auto" id="viewer-2uj4f"><span><span>Reversing MS-DOS binaries</span></span></h2></p><p dir="auto" id="viewer-5ka5i"><span><span>DOS operates in </span><a target="_blank" href="https://wiki.osdev.org/Real_Mode" rel="noopener" data-hook="web-link"><span>real mode</span></a><span>, meaning the entire 16 bit address space is shared between all processes and is addressed using a 16 bit </span><a target="_blank" href="https://wiki.osdev.org/Segmentation" rel="noopener" data-hook="web-link"><span>segment</span></a><span> selector and an additional 16 bit address - which are used to cover a usable memory range of 640KB.</span></span></p><p dir="auto" id="viewer-274nm"><span><span>Executables are not PEs, but </span><a target="_blank" href="https://en.wikipedia.org/wiki/DOS_MZ_executable" rel="noopener" data-hook="web-link"><span>DOS MZ executables</span></a><span>. The </span><span><span>file</span></span><span> utility recognizes our QTtext binary as a </span><a target="_blank" href="https://en.wikipedia.org/wiki/PKZIP" rel="noopener" data-hook="web-link"><span>PKZip</span></a><span> packed SFX - self extracting executable.</span></span></p><div data-breakout="normal"><div id="viewer-39dlu"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="39dlu"><wow-image id="fab603_64643d78239f4c6d83ebd8de02ff5b97~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;39dlu&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:1088,&#34;height&#34;:78,&#34;uri&#34;:&#34;fab603_64643d78239f4c6d83ebd8de02ff5b97~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_64643d78239f4c6d83ebd8de02ff5b97~mv2.png/v1/fill/w_980,h_70,al_c,q_85,usm_0.66_1.00_0.01,enc_avif,quality_auto/fab603_64643d78239f4c6d83ebd8de02ff5b97~mv2.png" alt="" data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_64643d78239f4c6d83ebd8de02ff5b97~mv2.png/v1/fill/w_1523,h_109,al_c,lg_1,q_85/fab603_64643d78239f4c6d83ebd8de02ff5b97~mv2.png" draggable="false"/></wow-image></div></div></figure></div></div></div><p data-breakout="normal"><h3 dir="auto" id="viewer-5olec"><span><span>PKZip</span></span></h3></p><p dir="auto" id="viewer-144cu"><span><a target="_blank" href="https://en.wikipedia.org/wiki/PKWare" rel="noopener" data-hook="web-link"><u><span>PKWare</span></u></a><span> is responsible for the popularity of the ZIP file format as we know it today, and also for a for a widely used executable packer in the MS-DOS age.</span></span></p><p dir="auto" id="viewer-3o4n1"><span><span>There isnâ€™t a lot of readily available information about the PKZip packer - presumably it utilized the same compression algorithm as the non-SFX zip utility, but we were struggling to find a tool that would properly unpack the SFX to a functioning executable.</span></span></p><p dir="auto" id="viewer-fekvm"><span><span>Having failed to find additional information about this packer, and wanting to avoid reverse engineering the unpacker stub - we attempted to use the DOSBOX debuggers CPU </span><span><span>LOG</span></span><span> feature to step past the unpacker code, sometime after the original entry point - and then extract the code from memory.</span></span></p><p dir="auto" id="viewer-1c98c"><span><span>While this did work, it only accounted for a small part of the code - the executable was 24K in size (packed).</span></span></p><p dir="auto" id="viewer-5arc4"><span><span>Recalling older days of reversing crackmes (though not as old as this program), we went looking for a generic executable unpacking tool which used to be a dime a dozen on cracking sites.</span></span></p><p dir="auto" id="viewer-du39e"><span><span>Preceding some open-source trends by over a decade, their inner-working were often mysterious, but most of the time they did the job. Eventually we found the </span><a target="_blank" href="http://blog.ssokolow.com/archives/2018/12/02/resources-for-reverse-engineering-16-bit-applications/" rel="noopener" data-hook="web-link"><span>following ssokolow blog post</span></a><span> which guided us to the the a mythical reverse engineering relic - </span><a target="_blank" href="https://www.exetools.com/" rel="noopener" data-hook="web-link"><span>exetools</span></a><span>.</span></span></p><p dir="auto" id="viewer-a56au"><span><span>The unpacker page had a huge list of unpackers, we assume a lot of them would have done the job - as PKZip was fairly common. We first tried the one called </span><span><span>PKUNLITE</span></span><span>, and when that didnâ€™t work (but looked promising) - we found success with </span><span><span>DISLITE v1.15.</span></span></span></p><div data-breakout="normal"><div id="viewer-o6ra"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="o6ra"><wow-image id="fab603_1c503223a3ff414da13d062977a59e0c~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;o6ra&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:589,&#34;height&#34;:87,&#34;uri&#34;:&#34;fab603_1c503223a3ff414da13d062977a59e0c~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_1c503223a3ff414da13d062977a59e0c~mv2.png/v1/fill/w_589,h_87,al_c,q_85,enc_avif,quality_auto/fab603_1c503223a3ff414da13d062977a59e0c~mv2.png" alt="" data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_1c503223a3ff414da13d062977a59e0c~mv2.png/v1/fill/w_825,h_122,al_c,lg_1,q_85/fab603_1c503223a3ff414da13d062977a59e0c~mv2.png" draggable="false"/></wow-image></div></div></figure></div></div></div><p data-breakout="normal"><h3 dir="auto" id="viewer-fj39r"><span><span>int 3f - MS-DOS Overlays</span></span></h3></p><p dir="auto" id="viewer-7m32n"><span><span>Loading the binary in IDA Free 5.0 (which luckily is still in distribution - hosted at the </span><a target="_blank" href="https://www.scummvm.org/" rel="noopener" data-hook="web-link"><span>ScummVM</span></a><span> website) showed that the executable utilized Turbo Pascal like memory overlays.</span></span></p><p dir="auto" id="viewer-iido"><span><span>Since weâ€™re running in real mode, paging/swapping memory wasnâ€™t possible, and overlays were the solution to the limited memory space.</span></span></p><p dir="auto" id="viewer-40q3u"><span><span>The overlay mechanism was essentially an implementation of page swapping in user-space: The executable contained root segments of non-movable memory, and was accompanied by an </span><span><span>.ovr</span></span><span> file which contained additional code (in this case, a LOT of additional code).</span></span></p><p dir="auto" id="viewer-20tun"><span><span>The root code (which originates from the </span><span><span>.exe</span></span><span> file) is always mapped into memory, while segments of the overlay were mapped into memory selectively and swapped on-demand.</span></span></p><p dir="auto" id="viewer-eospa"><span><span>Calls between overlays (and the root segment) occured through a jump table, if the overlay was already mapped into memory, the jump table stubs were â€œlinkedâ€ to its current location in memory.</span></span></p><p dir="auto" id="viewer-f03bm"><span><span>Otherwise, it led to (in this case) an </span><a target="_blank" href="https://dos4gw.org/3F_-_Overlay_manager_interrupt_Microsoft_LINK_EXE_Borland_TLINK_VROOMM" rel="noopener" data-hook="web-link"><span>int 3f</span></a><span> instruction, and alongside it - the overlay metadata.</span></span></p><p dir="auto" id="viewer-ak1tn"><span><span>The overlay metadata contained - among other things - the file offset of the relevant code segment.</span></span></p><p dir="auto" id="viewer-alfgv"><span><span>The interrupt handler would then map the relevant overlay into memory, in place of another overlay, and fix up the stubs, before resuming execution.</span></span></p><div data-breakout="normal"><div id="viewer-9sl17"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="9sl17"><wow-image id="fab603_c162b62ba88f48beb2b4c51d3d8eb39e~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;9sl17&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:475,&#34;height&#34;:427,&#34;uri&#34;:&#34;fab603_c162b62ba88f48beb2b4c51d3d8eb39e~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_c162b62ba88f48beb2b4c51d3d8eb39e~mv2.png/v1/fill/w_475,h_427,al_c,q_85,enc_avif,quality_auto/fab603_c162b62ba88f48beb2b4c51d3d8eb39e~mv2.png" alt="An example of an unlinked stub. Note the overlay metadata above. Screenshot from IDA pro." data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_c162b62ba88f48beb2b4c51d3d8eb39e~mv2.png/v1/fill/w_570,h_512,al_c,lg_1,q_85/fab603_c162b62ba88f48beb2b4c51d3d8eb39e~mv2.png" draggable="false"/></wow-image></div></div><div id="viewer-9sl17-caption"><p><figcaption><span>An example of an unlinked stub. Note the overlay metadata above.</span></figcaption></p></div></figure></div></div></div><div data-breakout="normal"><div id="viewer-1lg5v"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="1lg5v"><wow-image id="fab603_6733bcd871514511a343bcf62f3708bb~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;1lg5v&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:601,&#34;height&#34;:416,&#34;uri&#34;:&#34;fab603_6733bcd871514511a343bcf62f3708bb~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_6733bcd871514511a343bcf62f3708bb~mv2.png/v1/fill/w_601,h_416,al_c,q_85,enc_avif,quality_auto/fab603_6733bcd871514511a343bcf62f3708bb~mv2.png" alt="Same stub, now linked after its overlay was loaded into memory. Screenshot from IDA pro." data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_6733bcd871514511a343bcf62f3708bb~mv2.png/v1/fill/w_721,h_499,al_c,lg_1,q_85/fab603_6733bcd871514511a343bcf62f3708bb~mv2.png" draggable="false"/></wow-image></div></div><div id="viewer-1lg5v-caption"><p><figcaption><span>Same stub, now linked after its overlay was loaded into memory.</span></figcaption></p></div></figure></div></div></div><p dir="auto" id="viewer-3052m"><span><span>IDA does an excellent job in flattening and statically linking the stubs so we can reverse engineer the program in its entirety.</span></span></p><p dir="auto" id="viewer-f80ih"><span><span>However this presented a challenge for us in dynamically debugging the code, since while the root segments were always loaded into the same memory area, the overlays would change location very often, making it impossible for us to place breakpoints properly.</span></span></p><p dir="auto" id="viewer-6ukl1"><span><span>Dredging up information about the Turbo Pascal overlay system was difficult, and the DOSBOX debugger did not conveniently support stepping out of the interrupt.</span></span></p><p dir="auto" id="viewer-mmbr"><span><span>Itâ€™s likely that we could have reverse engineering the interrupt handler and found a place to break in right before resuming program execution in the newly loaded overlay, but we eventually opted for a simpler solution - finding an overlay-to-root call that we could break on and then step out into the newly loaded overlay.</span></span></p><div data-breakout="normal"><div id="viewer-64la"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="64la"><wow-image id="fab603_8999438071f946a4b65ebc5bfabe1500~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;64la&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:648,&#34;height&#34;:129,&#34;uri&#34;:&#34;fab603_8999438071f946a4b65ebc5bfabe1500~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_8999438071f946a4b65ebc5bfabe1500~mv2.png/v1/fill/w_648,h_129,al_c,q_85,enc_avif,quality_auto/fab603_8999438071f946a4b65ebc5bfabe1500~mv2.png" alt="An example of a call from an overlay to the root segment.overlay-to-root.PNG" data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_8999438071f946a4b65ebc5bfabe1500~mv2.png/v1/fill/w_907,h_181,al_c,lg_1,q_85/fab603_8999438071f946a4b65ebc5bfabe1500~mv2.png" draggable="false"/></wow-image></div></div><div id="viewer-64la-caption"><p><figcaption><span>An example of a call from an overlay to the root segment.overlay-to-root.PNG</span></figcaption></p></div></figure></div></div></div><p dir="auto" id="viewer-fi0ab"><span><span>In the above example </span><span><span>pascal_strncpy</span></span><span> is located in the root segment and its address is fixed and predictable. To break into the calling function in overlay 73, we would instead place a breakpoint at </span><span><span>pascal_strncpy</span></span><span> and step out into the calling function.</span></span></p><p dir="auto" id="viewer-coovf"><span><span>This is slightly arduous but for the fairly short task at hand it would work, and we had ample overlay-to-root calls to break on since the root segment hosted a lot of Turbo Pascal standard functions.</span></span></p><p data-breakout="normal"><h2 dir="auto" id="viewer-1f2ne"><span><span>Key expansion function</span></span></h2></p><p data-breakout="normal"><h3 dir="auto" id="viewer-9567l"><span><span>Tracing through passcode flow</span></span></h3></p><p dir="auto" id="viewer-e5ng3"><span><span>Finding the key expansion function took some reversing and a lot of tracing. Our initial idea was perform hot spot analysis by using DOSBOXâ€™s CPU </span><span><span>LOG</span></span><span> command to trace execution while repeatedly failing the passcode check on a locked document.</span></span></p><div data-breakout="normal"><div id="viewer-d449t"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="d449t"><wow-image id="fab603_8ae6b33856a546d186ab562f2fd0fd54~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;d449t&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:452,&#34;height&#34;:400,&#34;uri&#34;:&#34;fab603_8ae6b33856a546d186ab562f2fd0fd54~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_8ae6b33856a546d186ab562f2fd0fd54~mv2.png/v1/fill/w_452,h_400,al_c,q_85,enc_avif,quality_auto/fab603_8ae6b33856a546d186ab562f2fd0fd54~mv2.png" alt="QText screenshot of loading an encrypted document " data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_8ae6b33856a546d186ab562f2fd0fd54~mv2.png/v1/fill/w_542,h_480,al_c,lg_1,q_85/fab603_8ae6b33856a546d186ab562f2fd0fd54~mv2.png" draggable="false"/></wow-image></div></div></figure></div></div></div><p dir="auto" id="viewer-artgj"><span><span>Eventually we went for a more direct approach and simply placed a breakpoint on the int 21 interrupt handler to catch open and read calls.</span></span></p><div data-breakout="normal"><div id="viewer-b62mb"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="b62mb"><wow-image id="fab603_d28f85c585214816a54c8840158bb44a~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;b62mb&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:725,&#34;height&#34;:584,&#34;uri&#34;:&#34;fab603_d28f85c585214816a54c8840158bb44a~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_d28f85c585214816a54c8840158bb44a~mv2.png/v1/fill/w_725,h_584,al_c,q_90,enc_avif,quality_auto/fab603_d28f85c585214816a54c8840158bb44a~mv2.png" alt="The DOSBOX debugger at a interrupt call to open. The requested path is seen in the data overview." data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_d28f85c585214816a54c8840158bb44a~mv2.png/v1/fill/w_725,h_584,al_c,q_90/fab603_d28f85c585214816a54c8840158bb44a~mv2.png" draggable="false"/></wow-image></div></div><div id="viewer-b62mb-caption"><p><figcaption><span>The DOSBOX debugger at a interrupt call to open. The requested path is seen in the data overview.</span></figcaption></p></div></figure></div></div></div><p dir="auto" id="viewer-cl8mp"><span><span>We traced through an open on the document path and a read of 0ğ‘¥1ğ’Ÿ bytes - which is the exact size of the header we saw in locked documents. Continuing with dynamic debugging, we pinpointed a function that takes the entered passcode string and the 0ğ‘¥1ğ’Ÿ header as parameters.</span></span></p><p dir="auto" id="viewer-ddcbr"><span><span>Digging in, we see how the the passcode is passed into an internal function, and the result is compared to the header.</span></span></p><div data-breakout="normal"><div id="viewer-43f7o"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="43f7o"><wow-image id="fab603_5ec9f24ddf884d70a8e6cc8fbdaf516b~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;43f7o&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:618,&#34;height&#34;:470,&#34;uri&#34;:&#34;fab603_5ec9f24ddf884d70a8e6cc8fbdaf516b~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_5ec9f24ddf884d70a8e6cc8fbdaf516b~mv2.png/v1/fill/w_618,h_470,al_c,q_85,enc_avif,quality_auto/fab603_5ec9f24ddf884d70a8e6cc8fbdaf516b~mv2.png" alt="Part of the passcode check flow - this function returns 1 if the passcode was valid. Screenshot from IDA pro." data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_5ec9f24ddf884d70a8e6cc8fbdaf516b~mv2.png/v1/fill/w_742,h_564,al_c,lg_1,q_90/fab603_5ec9f24ddf884d70a8e6cc8fbdaf516b~mv2.png" draggable="false"/></wow-image></div></div><div id="viewer-43f7o-caption"><p><figcaption><span>Part of the passcode check flow - this function returns 1 if the passcode was valid.</span></figcaption></p></div></figure></div></div></div><p dir="auto" id="viewer-b982g"><span><span>Presumably, the function call prior to the </span><span><span>memcmp</span></span><span> performs key expansion, and the result is then compared to the file header.</span></span></p><p data-breakout="normal"><h3 dir="auto" id="viewer-80ioj"><span><span>Key derivation function</span></span></h3></p><p dir="auto" id="viewer-5o6oh"><span><span>The passcode is first passed through a permutation function which iteratively increments each byte of the passcode by the sum of all bytes in the string. Before proceeding to the byte in the next position, a certain predicate is tested by using the value of the resulting byte as an index into a static bitmap - where each bit represents whether or not that byte value is valid (1) or not (0). A more modern example of this sort of bitmap in use can be found in </span><a target="_blank" href="https://en.wikipedia.org/wiki/Control-flow_integrity" rel="noopener" data-hook="web-link"><span>CFG</span></a><span>.</span></span></p><div data-breakout="normal"><div id="viewer-8g2c1"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="8g2c1"><wow-image id="fab603_142b8940134f421e9e3f93588422a34b~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;8g2c1&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:586,&#34;height&#34;:378,&#34;uri&#34;:&#34;fab603_142b8940134f421e9e3f93588422a34b~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_142b8940134f421e9e3f93588422a34b~mv2.png/v1/fill/w_586,h_378,al_c,q_85,enc_avif,quality_auto/fab603_142b8940134f421e9e3f93588422a34b~mv2.png" alt="This function is used in several places to check a byte value vs a bitmap." data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_142b8940134f421e9e3f93588422a34b~mv2.png/v1/fill/w_703,h_454,al_c,lg_1,q_85/fab603_142b8940134f421e9e3f93588422a34b~mv2.png" draggable="false"/></wow-image></div></div><div id="viewer-8g2c1-caption"><p><figcaption><span>This function is used in several places to check a byte value vs a bitmap.</span></figcaption></p></div></figure></div></div></div><p dir="auto" id="viewer-201d0"><span><span>After each byte is permutated, the byte value is tested. If the value is invalid - it is incremented by 0ğ‘¥22. In the case of our immutable bitmap - this â€œcorrectionâ€ is always enough to push it into the valid value range - meaning it can only occur once per byte.</span></span></p><div data-breakout="normal"><div id="viewer-2an0v"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="2an0v"><wow-image id="fab603_49b6449437534095a0571a7c84f5b6bf~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;2an0v&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:936,&#34;height&#34;:143,&#34;uri&#34;:&#34;fab603_49b6449437534095a0571a7c84f5b6bf~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_49b6449437534095a0571a7c84f5b6bf~mv2.png/v1/fill/w_936,h_143,al_c,q_85,enc_avif,quality_auto/fab603_49b6449437534095a0571a7c84f5b6bf~mv2.png" alt="The bitmap used in the permutation function." data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_49b6449437534095a0571a7c84f5b6bf~mv2.png/v1/fill/w_1310,h_200,al_c,lg_1,q_85/fab603_49b6449437534095a0571a7c84f5b6bf~mv2.png" draggable="false"/></wow-image></div></div><div id="viewer-2an0v-caption"><p><figcaption><span>The bitmap used in the permutation function.</span></figcaption></p></div></figure></div></div></div><div data-breakout="normal"><pre dir="auto" id="viewer-f4ili"><span><span><span> </span></span><span><span><span>24</span></span></span><span><span> </span></span><em><span><span><span># Taken from binary
</span></span></span></em><span><span> </span></span><span><span><span>25</span></span></span><span><span> BITMAP </span></span><strong><span><span>=</span></span></strong><span><span>  b</span></span><span><span><span>&#34;\xff\xff\xff\xff\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80&#34;</span></span></span><span><span>
 ... 
 </span></span><span><span><span>28</span></span></span><span><span> </span></span><strong><span><span>def is_valid_char</span></span></strong><span><span>(c):
 </span></span><span><span><span>29</span></span></span><span><span>     </span></span><em><span><span><span># Can be simplified as 0x20 &lt; c &lt; 0x100
</span></span></span></em><span><span> </span></span><span><span><span>30</span></span></span><span><span>     </span></span><strong><span><span>assert</span></span></strong><span><span> </span></span><span><span><span>type</span></span></span><span><span>(c) </span></span><strong><span><span>is</span></span></strong><span><span> </span></span><span><span><span>int</span></span></span><span><span>
 </span></span><span><span><span>31</span></span></span><span><span>     </span></span><strong><span><span>assert</span></span></strong><span><span> c </span></span><strong><span><span>&lt;=</span></span></strong><span><span> </span></span><span><span><span>0xFF</span></span></span><span><span>
 </span></span><span><span><span>32</span></span></span><span><span>     upper_idx </span></span><strong><span><span>=</span></span></strong><span><span> c </span></span><strong><span><span>&gt;&gt;</span></span></strong><span><span> </span></span><span><span><span>3</span></span></span><span><span>  </span></span><em><span><span><span># upper 5 bits
</span></span></span></em><span><span> </span></span><span><span><span>33</span></span></span><span><span>     lower_idx </span></span><strong><span><span>=</span></span></strong><span><span> c </span></span><strong><span><span>&amp;</span></span></strong><span><span> 0b111  </span></span><em><span><span><span># Lower 3 bits
</span></span></span></em><span><span> </span></span><span><span><span>34</span></span></span><span><span>     </span></span><strong><span><span>return not</span></span></strong><span><span> </span></span><span><span><span>bool</span></span></span><span><span>((BITMAP[upper_idx] </span></span><strong><span><span>&gt;&gt;</span></span></strong><span><span> lower_idx) </span></span><strong><span><span>&amp;</span></span></strong><span><span> </span></span><span><span><span>1</span></span></span><span><span>)</span></span></span></pre></div><p dir="auto" id="viewer-a694m"><span><span>			</span><em><span>Excerpt from qtext_cracker.py - the predicate recreated in python</span></em></span></p><p dir="auto" id="viewer-r4iq"><span><span>Concretely, this can be represented by simply checking if 0ğ‘¥22 &lt; </span><em><span>value</span></em><span> &lt; 0ğ‘¥100 ğŸ¤·</span></span></p><p dir="auto" id="viewer-9dn2p"><span><span>The permutation function ğ‘ƒ(ğ‘¥) is simple - it iteratively increments each byte by the sum of the entire string at that point:</span></span></p><div data-breakout="normal"><pre dir="auto" id="viewer-5r0j1"><span><span><span> </span></span><span><span><span>37</span></span></span><span><span> </span></span><strong><span><span>def key_transform</span></span></strong><span><span>(input_key, modifier</span></span><strong><span><span>=</span></span></strong><span><span><span>0x22</span></span></span><span><span>):
 </span></span><span><span><span>38</span></span></span><span><span>     </span></span><strong><span><span>assert</span></span></strong><span><span> </span></span><span><span><span>type</span></span></span><span><span>(input_key) </span></span><strong><span><span>is</span></span></strong><span><span> </span></span><span><span><span>bytearray</span></span></span><span><span>
 </span></span><span><span><span>39</span></span></span><span><span>     key </span></span><strong><span><span>=</span></span></strong><span><span> </span></span><span><span><span>bytearray</span></span></span><span><span>(input_key)  </span></span><em><span><span><span># copy
</span></span></span></em><span><span> </span></span><span><span><span>40</span></span></span><span><span>     </span></span><strong><span><span>for</span></span></strong><span><span> i </span></span><strong><span><span>in</span></span></strong><span><span> </span></span><span><span><span>range(len</span></span></span><span><span>(key)):
 </span></span><span><span><span>41</span></span></span><span><span>         </span></span><strong><span><span>for</span></span></strong><span><span> j </span></span><strong><span><span>in</span></span></strong><span><span> </span></span><span><span><span>range(len</span></span></span><span><span>(key)):
 </span></span><span><span><span>42</span></span></span><span><span>             key[i] </span></span><strong><span><span>=</span></span></strong><span><span> (key[i] </span></span><strong><span><span>+</span></span></strong><span><span> key[j]) </span></span><strong><span><span>&amp;</span></span></strong><span><span> </span></span><span><span><span>0xFF</span></span></span><span><span>
 </span></span><span><span><span>43</span></span></span><span><span>         </span></span><strong><span><span>while not</span></span></strong><span><span> is_valid_char(key[i]):
 </span></span><span><span><span>44</span></span></span><span><span>             key[i] </span></span><strong><span><span>=</span></span></strong><span><span> (key[i] </span></span><strong><span><span>+</span></span></strong><span><span> modifier) </span></span><strong><span><span>&amp;</span></span></strong><span><span> </span></span><span><span><span>0xFF</span></span></span><span><span>
 </span></span><span><span><span>45</span></span></span><span><span>     </span></span><strong><span><span>return</span></span></strong><span><span> key</span></span></span></pre></div><p dir="auto" id="viewer-crjof"><span><span>		</span><em><span>Excerpt from qtext_cracker.py - the permutation function recreated in python</span></em></span></p><p dir="auto" id="viewer-nscs"><span><span>After that, the string is concatenated to itself (in place) 3 times, and passed through the permutation function again. The result of this is indeed the key as it appears in the header.</span></span></p><p dir="auto" id="viewer-7c6d"><span><span>Thus the key derivation function ğ¾(</span><em><span>passcode</span></em><span>) is:</span></span></p><p dir="auto" id="viewer-d99vv"><span><span><span>ğ¾</span></span><span>(</span><em><span>passcode) </span></em><span>= </span><span><span>ğ‘ƒ</span></span><span><span>(</span></span><span><span>ğ‘ƒ</span></span><span>(</span><em><span>passcode)</span></em><span>|</span><span><span>ğ‘ƒ</span></span><span>(</span><em><span>passcode)</span></em><span>|</span><span><span>ğ‘ƒ</span></span><span>(</span><em><span>passcode)</span></em><span>|</span><span><span>ğ‘ƒ</span></span><span>(</span><em><span>passcode))</span></em></span></p><p dir="auto" id="viewer-es2kp"><span><span>Now we can brute-force the passcode which has a very small input space very quickly. However, with our new-found knowledge of the key derivation function, we can try to reverse it for an even quicker solution.</span></span></p><p data-breakout="normal"><h2 dir="auto" id="viewer-e9t12"><span><span>Reversing the key derivation</span></span></h2></p><p dir="auto" id="viewer-d7l1v"><span><span>Letâ€™s first examine a simple case - the result of permutating a simple two character string - â€˜00â€™:</span></span></p><div data-breakout="normal"><div id="viewer-d2dq5"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="d2dq5"><wow-image id="fab603_bc739719a3b348db94577d05266a28a6~mv2.gif" data-image-info="{&#34;containerId&#34;:&#34;d2dq5&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:600,&#34;height&#34;:164,&#34;uri&#34;:&#34;fab603_bc739719a3b348db94577d05266a28a6~mv2.gif&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_bc739719a3b348db94577d05266a28a6~mv2.gif/v1/fill/w_600,h_164,al_c,pstr/fab603_bc739719a3b348db94577d05266a28a6~mv2.gif" alt="Permutation process for the string &#39;00&#39; (animation)" data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_bc739719a3b348db94577d05266a28a6~mv2.gif" draggable="false"/></wow-image></div></div></figure></div></div></div><p dir="auto" id="viewer-20c0a"><span><span>The permutation process for a string of length 2 can also be described as:</span></span></p><div data-breakout="normal"><div id="viewer-3t2jb"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="3t2jb"><wow-image id="fab603_efcbf82ce8994dfa8f8aee2b0a8ca09d~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;3t2jb&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:1598,&#34;height&#34;:372,&#34;uri&#34;:&#34;fab603_efcbf82ce8994dfa8f8aee2b0a8ca09d~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_efcbf82ce8994dfa8f8aee2b0a8ca09d~mv2.png/v1/fill/w_980,h_228,al_c,q_85,usm_0.66_1.00_0.01,enc_avif,quality_auto/fab603_efcbf82ce8994dfa8f8aee2b0a8ca09d~mv2.png" alt="Permutation process for the string &#39;00&#39;" data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_efcbf82ce8994dfa8f8aee2b0a8ca09d~mv2.png/v1/fill/w_1598,h_372,al_c,q_90/fab603_efcbf82ce8994dfa8f8aee2b0a8ca09d~mv2.png" draggable="false"/></wow-image></div></div></figure></div></div></div><p dir="auto" id="viewer-12m3s"><span><span>The permutation only involves combinations of our input values - so itâ€™s linear, but it isnâ€™t strictly linear - we lose the carry bit in any operation that overflows 0ğ‘¥ğ¹ğ¹</span></span></p><p dir="auto" id="viewer-2vqoq"><span><span>Letâ€™s say we want to reverse the permutation - starting from the last byte. We know that </span><span>
</span><span><span>ğŸ¸ğ‘â‚ï¼‹ğ‘â‚‚</span></span><span> evaluated to </span><span><span>0x90</span></span><span> so we can substitute for it: </span></span></p><div data-breakout="normal"><div id="viewer-39ido"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="39ido"><wow-image id="fab603_6a086ab0112447d48ebf4800a3ea6ecb~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;39ido&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:898,&#34;height&#34;:174,&#34;uri&#34;:&#34;fab603_6a086ab0112447d48ebf4800a3ea6ecb~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_6a086ab0112447d48ebf4800a3ea6ecb~mv2.png/v1/fill/w_898,h_174,al_c,q_85,enc_avif,quality_auto/fab603_6a086ab0112447d48ebf4800a3ea6ecb~mv2.png" alt="Calculation of the two permutations" data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_6a086ab0112447d48ebf4800a3ea6ecb~mv2.png/v1/fill/w_1257,h_244,al_c,lg_1,q_85/fab603_6a086ab0112447d48ebf4800a3ea6ecb~mv2.png" draggable="false"/></wow-image></div></div></figure></div></div></div><p dir="auto" id="viewer-8q40o"><span><span>But now, since we have to divide by 2 (which is not invertible in this field) - there are two possible solutions:</span></span></p><div data-breakout="normal"><div id="viewer-3acl6"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="3acl6"><wow-image id="fab603_c6afaed43ef64cc89a1f6c17df3685ac~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;3acl6&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:1340,&#34;height&#34;:352,&#34;uri&#34;:&#34;fab603_c6afaed43ef64cc89a1f6c17df3685ac~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_c6afaed43ef64cc89a1f6c17df3685ac~mv2.png/v1/fill/w_980,h_257,al_c,q_85,usm_0.66_1.00_0.01,enc_avif,quality_auto/fab603_c6afaed43ef64cc89a1f6c17df3685ac~mv2.png" alt="Choosing the right case out of the permutations" data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_c6afaed43ef64cc89a1f6c17df3685ac~mv2.png/v1/fill/w_1340,h_352,al_c,q_90/fab603_c6afaed43ef64cc89a1f6c17df3685ac~mv2.png" draggable="false"/></wow-image></div></div></figure></div></div></div><p dir="auto" id="viewer-3bsab"><span><span>We happen to know that the correct value here is 0ğ‘¥30 , but generally speaking when trying to invert the permutation function weâ€™ll have to superimpose both results. Simply put - at each step of the decomposition process, we â€œsplitâ€ into two branches - one for each result.</span></span></p><p dir="auto" id="viewer-4mo2"><span><span>In addition, for a certain range of values, another split occurs - at the end of each byte permutation, if the byte falls into a certain set of values (0ğ‘¥20 &lt; ğ‘ &lt; 0ğ‘¥100) it is incremented by 0ğ‘¥22.</span></span></p><p dir="auto" id="viewer-ademq"><span><span>That means that if the byte weâ€™re currently looking at is between 0ğ‘¥20 ï¼‹ 0ğ‘¥22 â‰¡ 0ğ‘¥24 and 0ğ‘¥100 ï¼‹ 0ğ‘¥22 â‰¡ 0ğ‘¥22, we need to consider a case where it may have been incremented to that value, and not arrived at naturally.</span></span></p><p dir="auto" id="viewer-fck1p"><span><span>Thankfully, the correction accounts for the entire span of the â€œforbiddenâ€ values, so it can only occur once - and thus only accounts for one additional branch.</span></span></p><p dir="auto" id="viewer-fvui3"><span><span>Summarizing - at each stage of the key decomposition we branch out between once and twice. Below is an implementation of the decomposition algorithm using recursion:</span></span></p><div data-breakout="normal"><pre dir="auto" id="viewer-fn7ci"><span><span><span> </span></span><span><span><span>48</span></span></span><span><span> </span></span><strong><span><span>def recursive_decomposition</span></span></strong><span><span>(input_key, decomposed_part</span></span><strong><span><span>=</span></span></strong><span><span><span>None</span></span></span><span><span>, stop_at</span></span><strong><span><span>=</span></span></strong><span><span><span>4</span></span></span><span><span>):
 </span></span><span><span><span>49</span></span></span><span><span>     </span></span><strong><span><span>assert</span></span></strong><span><span> </span></span><span><span><span>type</span></span></span><span><span>(input_key) </span></span><strong><span><span>is</span></span></strong><span><span> </span></span><span><span><span>bytearray</span></span></span><span><span>
 </span></span><span><span><span>50</span></span></span><span><span>     key </span></span><strong><span><span>=</span></span></strong><span><span> </span></span><span><span><span>bytearray</span></span></span><span><span>(input_key)  </span></span><em><span><span><span># copy
</span></span></span></em><span><span> </span></span><span><span><span>51</span></span></span><span><span>     </span></span><strong><span><span>if</span></span></strong><span><span> decomposed_part </span></span><strong><span><span>is</span></span></strong><span><span> </span></span><span><span><span>None</span></span></span><span><span>:
 </span></span><span><span><span>52</span></span></span><span><span>         decomposed_part </span></span><strong><span><span>=</span></span></strong><span><span> </span></span><span><span><span>bytearray</span></span></span><span><span>()
 </span></span><span><span><span>53</span></span></span><span><span>
 </span></span><span><span><span>54</span></span></span><span><span>     </span></span><strong><span><span>if</span></span></strong><span><span> </span></span><span><span><span>len</span></span></span><span><span>(key) </span></span><strong><span><span>==</span></span></strong><span><span> </span></span><span><span><span>0</span></span></span><span><span>:
 </span></span><span><span><span>55</span></span></span><span><span>         </span></span><em><span><span><span># Stopping condition
</span></span></span></em><span><span> </span></span><span><span><span>56</span></span></span><span><span>         </span></span><strong><span><span>return</span></span></strong><span><span> [
 </span></span><span><span><span>57</span></span></span><span><span>             decomposed_part,
 </span></span><span><span><span>58</span></span></span><span><span>         ]
 </span></span><span><span><span>59</span></span></span><span><span>
 </span></span><span><span><span>60</span></span></span><span><span>     </span></span><strong><span><span>if</span></span></strong><span><span> stop_at </span></span><strong><span><span>is not</span></span></strong><span><span> </span></span><span><span><span>None</span></span></span><span><span>:
 </span></span><span><span><span>61</span></span></span><span><span>         </span></span><strong><span><span>if</span></span></strong><span><span> </span></span><span><span><span>len</span></span></span><span><span>(decomposed_part) </span></span><strong><span><span>&gt;=</span></span></strong><span><span> stop_at:
 </span></span><span><span><span>62</span></span></span><span><span>             </span></span><strong><span><span>return</span></span></strong><span><span> [
 </span></span><span><span><span>63</span></span></span><span><span>                 decomposed_part,
 </span></span><span><span><span>64</span></span></span><span><span>             ]
 </span></span><span><span><span>65</span></span></span><span><span>
 </span></span><span><span><span>66</span></span></span><span><span>     results </span></span><strong><span><span>=</span></span></strong><span><span> []
 </span></span><span><span><span>67</span></span></span><span><span>     value </span></span><strong><span><span>=</span></span></strong><span><span> key.pop()
 </span></span><span><span><span>68</span></span></span><span><span>     </span></span><strong><span><span>if not</span></span></strong><span><span> is_valid_char((value </span></span><strong><span><span>-</span></span></strong><span><span> </span></span><span><span><span>0x22</span></span></span><span><span>) </span></span><strong><span><span>%</span></span></strong><span><span> </span></span><span><span><span>0x100</span></span></span><span><span>):
 </span></span><span><span><span>69</span></span></span><span><span>         </span></span><em><span><span><span># We have an additional case to process
</span></span></span></em><span><span> </span></span><span><span><span>70</span></span></span><span><span>         new_key </span></span><strong><span><span>=</span></span></strong><span><span> </span></span><span><span><span>bytearray</span></span></span><span><span>(key)  </span></span><em><span><span><span># copy
</span></span></span></em><span><span> </span></span><span><span><span>71</span></span></span><span><span>         new_key.append((value </span></span><strong><span><span>-</span></span></strong><span><span> </span></span><span><span><span>0x22</span></span></span><span><span>) </span></span><strong><span><span>%</span></span></strong><span><span> </span></span><span><span><span>0x100</span></span></span><span><span>)
 </span></span><span><span><span>72</span></span></span><span><span>         </span></span><em><span><span><span># Where to save this?
</span></span></span></em><span><span> </span></span><span><span><span>73</span></span></span><span><span>         results.extend(recursive_decomposition(new_key, decomposed_part, stop_at))
 </span></span><span><span><span>74</span></span></span><span><span>
 </span></span><span><span><span>75</span></span></span><span><span>     value </span></span><strong><span><span>=</span></span></strong><span><span> (value </span></span><strong><span><span>-</span></span></strong><span><span> </span></span><span><span><span>sum</span></span></span><span><span>(decomposed_part)) </span></span><strong><span><span>%</span></span></strong><span><span> </span></span><span><span><span>0x100</span></span></span><span><span>
 </span></span><span><span><span>76</span></span></span><span><span>     </span></span><em><span><span><span># Subtract trailing (decomposed) characters
</span></span></span></em><span><span> </span></span><span><span><span>77</span></span></span><span><span>     </span></span><em><span><span><span># Compute two candidates
</span></span></span></em><span><span> </span></span><span><span><span>78</span></span></span><span><span>     candidate_1 </span></span><strong><span><span>=</span></span></strong><span><span> ((value </span></span><strong><span><span>//</span></span></strong><span><span> </span></span><span><span><span>2</span></span></span><span><span>) </span></span><strong><span><span>-</span></span></strong><span><span> </span></span><span><span><span>sum</span></span></span><span><span>(key)) </span></span><strong><span><span>%</span></span></strong><span><span> </span></span><span><span><span>0x100</span></span></span><span><span>
 </span></span><span><span><span>79</span></span></span><span><span>     candidate_2 </span></span><strong><span><span>=</span></span></strong><span><span> (((</span></span><span><span><span>0x100</span></span></span><span><span> </span></span><strong><span><span>+</span></span></strong><span><span> value) </span></span><strong><span><span>//</span></span></strong><span><span> </span></span><span><span><span>2</span></span></span><span><span>) </span></span><strong><span><span>-</span></span></strong><span><span> </span></span><span><span><span>sum</span></span></span><span><span>(key)) </span></span><strong><span><span>%</span></span></strong><span><span> </span></span><span><span><span>0x100</span></span></span><span><span>
 </span></span><span><span><span>80</span></span></span><span><span>     new_decomposed_left </span></span><strong><span><span>=</span></span></strong><span><span> </span></span><span><span><span>bytearray</span></span></span><span><span>([candidate_1,]) </span></span><strong><span><span>+</span></span></strong><span><span> decomposed_part
 </span></span><span><span><span>81</span></span></span><span><span>     new_decomposed_right </span></span><strong><span><span>=</span></span></strong><span><span> </span></span><span><span><span>bytearray</span></span></span><span><span>([candidate_2,]) </span></span><strong><span><span>+</span></span></strong><span><span> decomposed_part
 </span></span><span><span><span>82</span></span></span><span><span>
 </span></span><span><span><span>83</span></span></span><span><span>     results.extend(recursive_decomposition(key, new_decomposed_left, stop_at))
 </span></span><span><span><span>84</span></span></span><span><span>     results.extend(recursive_decomposition(key, new_decomposed_right, stop_at))
 </span></span><span><span><span>85</span></span></span><span><span>
 </span></span><span><span><span>86</span></span></span><span><span>     </span></span><strong><span><span>return</span></span></strong><span><span> results</span></span></span></pre></div><p dir="auto" id="viewer-16v9o"><span><span>			</span><em><span>Excerpt from qtext_cracker.py - the decomposition function</span></em><span>	</span></span></p><p dir="auto" id="viewer-8n988"><span><span>Considering a 16 byte key, that means between 2</span><span><span>Â¹â¶</span></span><span> and 2</span><span><span>Â¹â·</span></span><span> branches, which isnâ€™t too bad, but luckily there are a couple of constraints that help us minimize the search space considerably.</span></span></p><p data-breakout="normal"><h3 dir="auto" id="viewer-egpmi"><span><span>Reversing the first stage - 4 bytes to 4 printable characters</span></span></h3></p><p dir="auto" id="viewer-1ekpi"><span><span>The first constraint is pretty straightforward - any decomposed byte was originally a passcode byte - meaning an uppercase letter or number.</span></span></p><div data-breakout="normal"><div id="viewer-1cnqs"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="1cnqs"><wow-image id="fab603_c930bf75641b400198af865ddeab9e61~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;1cnqs&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:1080,&#34;height&#34;:160,&#34;uri&#34;:&#34;fab603_c930bf75641b400198af865ddeab9e61~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_c930bf75641b400198af865ddeab9e61~mv2.png/v1/fill/w_980,h_145,al_c,q_85,usm_0.66_1.00_0.01,enc_avif,quality_auto/fab603_c930bf75641b400198af865ddeab9e61~mv2.png" alt="" data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_c930bf75641b400198af865ddeab9e61~mv2.png/v1/fill/w_1296,h_192,al_c,lg_1,q_85/fab603_c930bf75641b400198af865ddeab9e61~mv2.png" draggable="false"/></wow-image></div></div></figure></div></div></div><p dir="auto" id="viewer-aqakm"><span><span>Considering our example from before - itâ€™s clear we could have only chosen the printable value - 0ğ‘¥30.</span></span></p><p data-breakout="normal"><h3 dir="auto" id="viewer-d6bh5"><span><span>Reversing the second stage - 16 bytes to ğŸ¦Ã—ğŸ¦ byte string</span></span></h3></p><p dir="auto" id="viewer-91foh"><span><span>The second constraint isnâ€™t as trivial, but still pretty simple - the format of the 16 byte key right before the second permutation is a sequence of 4 bytes, repeated 4 times. That means we only have to decompose a 4 byte suffix - and then test that 4 byte suffix by feeding it through the permutation function and checking if the result is the original key.</span></span></p><p dir="auto" id="viewer-bcm2s"><span><span>That narrows our search space down to 2</span><span><span>âµ</span></span><span> for each step - or 2</span><span><span>â¶</span></span><span> in total. You could realistically break this encryption on a piece of paper if you have the patience!</span></span></p><p data-breakout="normal"><h2 dir="auto" id="viewer-da2fc"><span><span>Putting it all together</span></span></h2></p><p dir="auto" id="viewer-b032i"><span><span>So - starting from the 16 byte key (</span><strong><span>ğ‘˜</span></strong><span>) as extracted from the document:</span></span></p><div data-breakout="normal"><ol><li dir="auto" aria-level="1"><p dir="" id="viewer-edq7u"><span><span>Run </span><strong><span>ğ‘˜</span></strong><span> through the decomposition function, accumulating all possible 4 byte suffixes.</span></span></p></li><li dir="auto" aria-level="1"><p dir="" id="viewer-cbbsl"><span><span>Feed suffixes back through permutation function to find the correct one.</span></span></p></li><li dir="auto" aria-level="1"><p dir="" id="viewer-d55qt"><span><span>Run resulting suffix through the decomposition function, again accumulating all results.</span></span></p></li><li dir="auto" aria-level="1"><p dir="" id="viewer-9l15h"><span><span>Narrow results down to those matching the passcode input space to arrive at the original passcode.</span></span></p></li></ol></div><div data-breakout="normal"><div id="viewer-7i0j7"><div><figure data-hook="figure-IMAGE"><div role="button" data-hook="image-viewer" tabindex="0" aria-haspopup="true"><div id="7i0j7"><wow-image id="fab603_cb19a6dd4b384753814f675d47315ff7~mv2.png" data-image-info="{&#34;containerId&#34;:&#34;7i0j7&#34;,&#34;displayMode&#34;:&#34;fill&#34;,&#34;isLQIP&#34;:false,&#34;isSEOBot&#34;:true,&#34;encoding&#34;:&#34;AVIF&#34;,&#34;imageData&#34;:{&#34;width&#34;:1044,&#34;height&#34;:390,&#34;uri&#34;:&#34;fab603_cb19a6dd4b384753814f675d47315ff7~mv2.png&#34;,&#34;name&#34;:&#34;&#34;,&#34;displayMode&#34;:&#34;fill&#34;}}" data-motion-part="BG_IMG" data-bg-effect-name="" data-has-ssr-src=""><img src="https://static.wixstatic.com/media/fab603_cb19a6dd4b384753814f675d47315ff7~mv2.png/v1/fill/w_980,h_366,al_c,q_85,usm_0.66_1.00_0.01,enc_avif,quality_auto/fab603_cb19a6dd4b384753814f675d47315ff7~mv2.png" alt="Screenshot of qtext_cracker.py, a Python script to crack QText files" data-pin-url="https://www.botanica.software/post/decoding-the-90s" data-pin-media="https://static.wixstatic.com/media/fab603_cb19a6dd4b384753814f675d47315ff7~mv2.png/v1/fill/w_1044,h_390,al_c,q_90/fab603_cb19a6dd4b384753814f675d47315ff7~mv2.png" draggable="false"/></wow-image></div></div></figure></div></div></div><p dir="auto" id="viewer-90c9t"><span><span>The qtext cracker script in its entirety can found </span><a target="_blank" href="https://github.com/botanica-consulting/qtext" rel="noopener" data-hook="web-link"><span>here</span></a><span>.</span></span></p></div></div></div></div></div></div></div></div>
  </body>
</html>
