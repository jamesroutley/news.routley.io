<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.imperialviolet.org/tourofwebauthn/tourofwebauthn.html">Original</a>
    <h1>A Tour of WebAuthn</h1>
    
    <div id="readability-page-1" class="page">
<p>This book was distributed at the FIDO Authenticate conference in
2024. Its intended format was as a PDF, which you can find <a href="https://www.imperialviolet.org/tourofwebauthn/tourofwebauthn.pdf">here</a>.</p>
<p>The following is the contents of the PDF converted to HTML.</p>

<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#chapter-introduction" id="toc-chapter-introduction">1:
Introduction</a></li>
<li><a href="#universal-second-factor" id="toc-universal-second-factor">2: Universal Second Factor</a></li>
<li><a href="#fido2-and-passkeys" id="toc-fido2-and-passkeys">3: FIDO2
and passkeys</a></li>
<li><a href="#webauthn-1" id="toc-webauthn-1">4: WebAuthn</a></li>
<li><a href="#relying-party-ids" id="toc-relying-party-ids">5: Relying
party IDs</a></li>
<li><a href="#ctap2" id="toc-ctap2">6: CTAP2</a></li>
<li><a href="#attestation-1" id="toc-attestation-1">7:
Attestation</a></li>
<li><a href="#webauthn-on-the-web" id="toc-webauthn-on-the-web">8:
WebAuthn on the web</a></li>
<li><a href="#extensions" id="toc-extensions">9: Extensions</a></li>
<li><a href="#hybrid-transport" id="toc-hybrid-transport">10: Hybrid
transport</a></li>
<li><a href="#platform-apis" id="toc-platform-apis">11: Platform
APIs</a></li>
<li><a href="#the-server-side" id="toc-the-server-side">12: The server
side</a></li>
<li><a href="#public-key-formats" id="toc-public-key-formats">13: Public
key formats</a></li>
</ul>
</nav>

<p>Passwords are rubbish.</p>
<p>If you’re reading this book then hopefully you’re already on board
with this idea, but let’s recap anyway.</p>
<p>The typical practice with passwords is to remember a few different
ones and re-use them widely. (Password managers support generating
random passwords, but people mostly don’t.) Sites must store hashes of
these passwords to recognize them, but most passwords have too little
entropy to resist brute-forcing when the hashes leak. (The website
haveibeenpwned.com now has records of about 13.5 billion accounts that
have been found in account database leaks from nearly 800 websites.)</p>
<p>When a password database leaks, not only can any successfully cracked
passwords be used immediately to sign in to that site but, because of
password re-use, those users’ accounts on other sites may also be
compromised.</p>
<p>Next, because users typically remember their passwords, they can be
tricked into entering them on lookalike websites. These “phishing”
attacks are common, effective, and can have global implications when
used to <a href="https://www.nytimes.com/interactive/2017/01/06/us/russian-hack-evidence.html">interfere
in elections</a>.</p>
<p>Lastly, passwords can leak from many other parts of the software
stack. Facebook <a href="https://krebsonsecurity.com/2019/03/facebook-stored-hundreds-of-millions-of-user-passwords-in-plain-text-for-years/">inadvertently
logged</a> hundreds of millions of passwords over many years, and
Javascript-injection <a href="https://arstechnica.com/information-technology/2018/09/british-airways-site-had-credit-card-skimming-code-injected">attacks</a>
can exfiltrate anything entered on a site, including passwords.</p>
<p>This book is about using public key signature schemes to try and
build a better system of authentication. These schemes have names like
ECDSA, RSA, and ML-DSA. They vary in how large their outputs are, how
fast they operate, and whether they’re resistant to (still theoretical)
large quantum computers. In this book we’ll consider them only in the
abstract—the construction of public key signature schemes is a deep and
fascinating topic, but we will cover none of it here.</p>
<p>In the abstract, a public key signature scheme provides three
operations:</p>
<ol type="1">
<li>A <code>generate</code> operation takes some random bits and returns
two byte strings that we will call a public key and a private key.</li>
<li>A <code>sign</code> operation that takes a private key and an
arbitrary byte string (called the “message”), and produces another byte
string that we will call a “signature”.</li>
<li>A <code>verify</code> operation that takes a public key, a message,
and a claimed signature, and returns whether that signature was
generated by the <code>sign</code> operation with the corresponding
private key.</li>
</ol>
<p>The names of these operations have obviously been chosen to suggest
analogs in the real world, but that is a double-edged sword. These are
not handwritten marks on a piece of paper; they are only defined by the
operations above. For example, there can be multiple valid “signature”
values by a public key for a given message. But while these subtleties
are important in some contexts, like cryptocurrencies, they aren’t for
us.</p>
<p>To be useful, a public key signature scheme must have properties like
the following:</p>
<ol type="1">
<li>It’s not possible to compute the private key from the public
key.</li>
<li>It’s not possible to compute a signature without the private
key.</li>
</ol>
<p>Those properties are vaguely defined. (Indeed, the second implies the
first.) Readers are welcome to research the formal definition of
security (“EUF-CMA”) to better understand the topic, but a rough
understanding is all you need in this context.</p>
<p>Let’s sketch out a toy example of an authentication scheme using
public key signatures.</p>
<p>In this sketch, rather than registering with a website by creating a
username and password, people will create a username and then their
computer will run the <code>generate</code> operation, record the
private key, and submit the public key and username to the site.</p>
<p>In order to sign in, people will enter their username. Then their
computer will run the <code>sign</code> operation with their private key
on the message “let me in”. It’ll send the username and signature to the
website. Lastly, the website uses the public key that it recorded when
the user signed up, and runs the <code>verify</code> operation on that,
the message “let me in”, and the submitted signature. If the signature
is valid then the user is signed in.</p>
<p>We have immediately solved the problem of database leaks because now
websites only need to record public keys, not password hashes. A public
key can’t be used to generate a signature, only validate one. So, unlike
passwords, when they leak, they can’t be used to sign in to that site
(or any other).</p>
<p>But we haven’t solved the phishing problem because people might
submit a signature value to the wrong site. Also, if an attacker learns
a single signature value, they can use it to sign in as the user.
Lastly, we breezed over where private keys are stored and how many there
are.</p>
<p>Don’t worry, we’ll solve all of those issues with more realistic
designs. Firstly, let’s deal with phishing.</p>
<p>Phishing involves an attacker proxying a user’s sign-in information.
The victim mistakenly signs in to a fake website, and then that
information can be reused with the real website. The toy scheme above
was vulnerable to phishing because the message, “let me in”, was the
same for all sites and so a signature was valid everywhere.</p>
<p>So our first design tweak is to change the signed message to name the
intended destination. Let’s start using JSON for the message too.</p>
<p>Now, when a user signs in, their computer runs the <code>sign</code>
operation with the private key. But rather than using the message “let
me in”, we’ll make it <code>{&#34;origin&#34;: &#34;https://example.com&#34;}</code>.
The site needs to run the <code>verify</code> operation on the resulting
signature, and the <code>verify</code> operation requires the message as
an input, so we’ll also have the user’s computer send the message along
with the signature and username.</p>
<p>Now consider what happens when the user clicks a malicious link and
tries to sign in to <code>exampl3.com</code> (an evil phishing website).
The user’s computer will sign the message
<code>{&#34;origin&#34;: &#34;https://exampl3.com&#34;}</code>. When the phishing site
proxies the sign-in details to the real website, the signature will be
valid, but the real website can notice that the user was attempting to
sign in to a different website and reject it. (Computers, unlike humans,
can reliably notice single-character differences in URLs.)</p>
<p>The phishing site can’t change the message because the real site will
reject the signature when <code>verify</code> checks it, and they can’t
update the signature because they don’t have the private key.</p>
<p>So phishing has been solved with a small tweak, but we’re still left
with the problem that if a signature value for the real site leaks then
that can be used to sign in as a user. While, unlike password hashes,
signature values don’t need to be stored, we’ve seen that similar values
can be exfiltrated via Javascript-injection and inadvertent logging.</p>
<p>To solve phishing, we made the message specific to a given site. To
solve this problem, we’ll make the message specific to an authentication
attempt.</p>
<p>So our next tweak to the design will be that, when a user tries to
sign in, the site will send a large random challenge to the user’s
computer, to be included in the signed message. Each time a user
attempts to sign in, the random challenge will be different (with
extremely high probability).</p>
<p>So a signed message will now look like this:
<code>{&#34;origin&#34;: &#34;https://example.com&#34;, &#34;challenge&#34;: &#34;8065afbaa4faee78123ad2061bc78df3&#34;}</code>.</p>
<p>Now if a signature gets logged or exfiltrated by malicious
JavaScript, it quickly becomes useless. A signature is only valid for a
specific message, but the challenge (and thus the message) will be
different in the future.</p>
<p>We still need to consider how many public keys a person has and where
they are stored.</p>
<p>A simple answer would be that each person has a single public key and
uses it across all sites and apps, but the obvious problem with that is
that it is a unique tracking value for that person, and people don’t
want to be linked across all their sites and apps.</p>
<p>For now, we will say that each website or app gets its own set of
keys. Things are more complicated than this in practice, but we will
cover these complexities in future chapters.</p>
<p>Unlike a password, the value of a private key never needs to be sent
anywhere to be used. So for maximum security, we’ll start by generating
and keeping private keys in dedicated hardware, usually connected via
USB. This hardware can be designed to be resistant even to a degree of
physical attack. Later in the book we’ll see how this can be relaxed so
that these authentication schemes can be usable in a consumer
context.</p>
<p>The next chapter will dive into the concrete and cover the
nitty-gritty of the first implementation of this design, but we should
keep in mind the limits of any authentication system:</p>
<p>In a digital context, people are always acting through their
computer. While we talk about authenticating a user, the thing that
directly gains authority as a result of authenticating is that user’s
computer. So if that computer is controlled by an attacker, the
authentication system is moot. Tackling the authentication problem does
not solve all security issues, but many security issues are
authentication problems, so better authentication systems are necessary
part of fixing the world.</p>
<p>WebAuthn, the subject of this book, is such a system.</p>

<p>The first embodiment of the broad design that we sketched out in the
previous chapter was the Universal Second Factor (U2F) system from the
FIDO Alliance. The FIDO Alliance is a consortium of companies, all of
whom care about the problems of online authentication, and they
developed a pair of standards to try and solve phishing by adding a
public-key authentication system as a second factor to sign-ins. (I.e.
in addition to a password.)</p>
<p>The first of these standards, called <a href="https://fidoalliance.org/specs/fido-u2f-v1.2-ps-20170411/fido-u2f-raw-message-formats-v1.2-ps-20170411.html">CTAP1</a>,
defines a protocol between computers and dedicated devices called
security keys that perform the <code>generate</code> and
<code>sign</code> operations. The second defines a Javascript API so
that websites can make use of them.</p>
<p>At this point, the U2F Javascript API is thoroughly obsolete and is
not worth covering even for historical reasons. But millions of U2F
security keys were produced over the years and, while security keys now
use the more modern CTAP2 protocol, CTAP1 is very simple, is still
supported, and is worth understanding because it contains the core
elements of everything that follows. So we’ll discuss CTAP1 in some
detail in this chapter.</p>
<h2 id="ctap1">CTAP1</h2>
<p>CTAP1 only includes two commands: one that implements the
<code>generate</code> operation and another that implements
<code>sign</code>. To cause a CTAP1 security key to run
<code>generate</code>, a computer sends a command consisting of the
following bytes, concatenated together: (There’s quite a long list of
fields here, but don’t worry. Each will be explained.)</p>
<ol type="1">
<li>A byte with value 0.</li>
<li>A byte with value 1—the command code for <code>generate</code>.</li>
<li>A flags byte with two flags set: 0x1 for “user presence required”
and 0x2 for “user presence consumed”.</li>
<li>Another zero byte.</li>
<li>The length of the following data as a 24-bit, big-endian value. This
is always 64.</li>
<li>The SHA-256 hash of the “client data”.</li>
<li>The SHA-256 hash of the “relying party ID”.</li>
<li>Two zero bytes which indicate that the maximum response length is
supported.</li>
</ol>
<p>(This message format comes from a smart card format called an
application protocol data unit or APDU. This chapter will include the
needed details without further reference to APDUs.)</p>
<p>The response consists of the following, concatenated together:</p>
<ol type="1">
<li>A byte with value 5.</li>
<li>A public key (X9.62 encoded P-256, see chapter 13. U2F only supports
ECDSA with P-256).</li>
<li>An 8-bit credential ID length.</li>
<li>The credential ID.</li>
<li>A certificate (X.509 DER encoded).</li>
<li>A signature.</li>
</ol>
<p>The number of values going back and forth should be somewhat
surprising in light of the previous chapter. There, the
<code>generate</code> operation was defined as requiring random bits as
the sole input, and as producing a private key (which we expect the
security key to store) plus a public key (which it should report to the
computer). In U2F, the random bits come from within the security key so
there are two unexpected inputs (“client data” and “relying party ID”)
and three unexpected outputs (the credential ID, a certificate, and a
signature).</p>
<p>An ID is the most obvious addition: we need some way to refer to the
generated keys. Credential IDs are generated by security keys for that
purpose and can be assumed to be globally unique because they must be at
least 16 bytes long and contain at least 100 bits of entropy. Given that
the ID length in the response is only eight bits, a U2F credential ID
is, at most, 255 bytes long.</p>
<p>We have already mentioned that we want to avoid reusing public keys
too widely for privacy reasons. Thus, to stop sites from sharing public
keys and tracking users with them, U2F allows an arbitrary value called
the relying party ID (RP ID) to be associated with each public key. (A
relying party is any entity that does authentication, i.e. a website in
the examples that we’ve been using.) The same relying party ID must be
sent whenever the <code>sign</code> operation is invoked, therefore
public keys cannot be used outside the context in which they were
intended.</p>
<p>Typically, an RP ID is a domain name, like <code>example.com</code>.
So even if <code>anothersite.com</code> knows the ID for an
<code>example.com</code> credential, it can’t use it because the browser
will specify that the RP ID is <code>anothersite.com</code> at signing
time, and so the security key will reject the request. (See chapter 5
for more about RP IDs.)</p>
<p>The security key checks the RP ID, and not the browser, because
security keys are assumed to move with the user, between different
computers. So a browser on a specific computer or phone might not have
been involved in creating the credential that is now being used.</p>
<h3 id="user-presence">User presence</h3>
<p>The term “user presence” appears in the description of the request
flags. This refers to the idea that an operation should only be
performed when a human physically touches the security key.</p>
<p>Most security keys will have a capacitive sensor: a metal band or
disc that can recognize a touch by the change in capacitance it causes.
Requiring user presence (a physical touch) for each operation stops any
malware on the computer from making requests to the security key in the
background.</p>
<p>Since security keys typically don’t have screens, when users touch
them they don’t know what operation is being requested and have to trust
that the computer is requesting a legitimate operation. So the benefit
of requiring user presence is modest. But the principle of requiring a
user interaction for every operation has become a core part of the
WebAuthn ecosystem that developed from U2F, and thus of everything
covered in this book.</p>
<p>U2F splits the concept into “user presence required” and “user
presence consumed”. The former requires that the security key have been
recently touched and the latter resets that flag. But this split didn’t
survive into later versions of the standards which instead specify when
the flag is reset rather than deferring to the request.</p>
<h4 id="attestation">Attestation</h4>
<p>To explain the remaining values, we’ll have to briefly cover the
topic of attestation.</p>
<p>Suppose you’re a company worried about the security of your employees
signing in to your corporate systems. In that case, you may want the
private keys that they’re using to do so to be stored in a specific type
of security key. (Probably the type of security key you issued them for
this purpose.) You may even want to ensure that the security key they
use is the specific one that was inventory-tracked from the factory and
assigned to them.</p>
<p>Attestation is designed to solve these problems.</p>
<p>The concept is that the security key has a private key installed in
the factory. This private key is not used for signing in, but rather to
prove that future <code>generate</code> operations were performed in a
known model of security key, or in a specific security key.</p>
<p>The “client data” hash, and the certificate and signature outputs,
are all part of this process. They are covered in detail in chapter 7,
but most uses of security keys don’t deal with attestation, and so we’ll
ignore these fields for now.</p>
<h3 id="invoking-the-generate-operation">Invoking the
<code>generate</code> operation</h3>
<p>The easiest way to trigger a generate operation is in a web browser.
We’ll use the following snippet of JavaScript to ask the browser to
generate a public and private key, and we’ll have the browser do that
with a U2F security key so that we can inspect the request and the
response. (This will be our first example of using the WebAuthn
Javascript API, which will be covered extensively in chapter 4. We could
also have used the APIs on Android or iOS, which are covered in chapter
11.)</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>create</span>({</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span>publicKey</span><span>:</span> {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span>// Unused in this example.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span>challenge</span><span>:</span> <span>new</span> <span>Uint8Array</span>([<span>0</span>])<span>.</span><span>buffer</span><span>,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span>// Boilerplate required values.</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span>pubKeyCredParams</span><span>:</span> [{</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            <span>alg</span><span>:</span> <span>-</span><span>7</span><span>,</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        }]<span>,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span>// The relying party ID.</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span>rp</span><span>:</span> {<span>name</span><span>:</span> <span>window</span><span>.</span><span>location</span><span>.</span><span>host</span>}<span>,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span>// Required values that are inapplicable in U2F.</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span>user</span><span>:</span> {</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            <span>id</span><span>:</span> <span>new</span> <span>Uint8Array</span>(<span>1</span>)<span>,</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            <span>name</span><span>:</span> <span>&#34;user&#34;</span><span>,</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            <span>displayName</span><span>:</span> <span>&#34;&#34;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        }<span>,</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>})<span>.</span><span>then</span>(<span>console</span><span>.</span><span>log</span><span>,</span> <span>console</span><span>.</span><span>log</span>)<span>;</span></span></code></pre></div>
<p>Here is the message sent by the browser, to the U2F security key,
broken down into the same parts as listed above.</p>
<p><img src="https://www.imperialviolet.org/tourofwebauthn/u2f-1.png"/></p>
<p>And here’s the response, similarly broken down:</p>
<p><img src="https://www.imperialviolet.org/tourofwebauthn/u2f-2.png"/></p>
<p>(Note that the UP flag was set in the request so you know that I had
to touch the security key before it would generate that response.)</p>
<p>Now that we have performed a <code>generate</code> operation, the
next step is to perform a <code>sign</code> operation with the private
key that has just been generated.</p>
<h3 id="invoking-the-sign-operation">Invoking the <code>sign</code>
operation</h3>
<p>Again, we’ll foreshadow future chapters by using a snippet of the
WebAuthn Javascript API to ask a browser to perform a <code>sign</code>
operation with a U2F security key.</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>get</span>({</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span>publicKey</span><span>:</span> {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span>allowCredentials</span><span>:</span> [{</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>          <span>type</span><span>:</span> <span>&#39;public-key&#39;</span><span>,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>          <span>transports</span><span>:</span> [<span>&#39;usb&#39;</span>]<span>,</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>          <span>id</span><span>:</span> <span>hexStringToArrayBuffer</span>(</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>              <span>&#34;a28874e5d0e17b6796ed14b60447278a&#34;</span> <span>+</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>              <span>&#34;c544e6b8dec18e54ccb178afb797e21e&#34;</span> <span>+</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>              <span>&#34;e54a0cf264741b6cf4f8f89f41d12fff&#34;</span> <span>+</span> </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>              <span>&#34;18aafeff82ee318225c5339fd3fedb2a&#34;</span>)<span>,</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        }]<span>,</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span>challenge</span><span>:</span> <span>new</span> <span>Uint8Array</span>([<span>0</span><span>,</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>,</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                                   <span>8</span><span>,</span><span>9</span><span>,</span><span>10</span><span>,</span><span>11</span><span>,</span><span>12</span><span>,</span><span>13</span><span>,</span><span>14</span><span>,</span><span>15</span>])<span>.</span><span>buffer</span><span>,</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    }<span>,</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>})<span>.</span><span>then</span>(<span>console</span><span>.</span><span>log</span><span>,</span> <span>console</span><span>.</span><span>log</span>)<span>;</span></span></code></pre></div>
<p>Note the appearance of the credential ID from the previous response
in this request, so that the security key knows which private key to
sign with.</p>
<p>The request format is an APDU again and so follows a similar
structure. This time we’ll dive directly into the concrete request that
the browser sent and explain the structure as we go:</p>
<ul>
<li><code>00</code> (all CTAP1 commands start with a zero byte)</li>
<li><code>02</code> (the command code for <code>sign</code>)</li>
<li><code>03</code> (a flags byte with two flags set: 0x1 for “user
presence required” and 0x2 for “user presence consumed”.)</li>
<li><code>00</code> (an unused flags byte)</li>
<li><code>000081</code> (the 24-bit length of the following data: 129
bytes)</li>
<li><code>a438...c659</code> (the SHA-256 hash of the “client data”,
described below.)</li>
<li><code>a379...1947</code> (the SHA-256 hash of the relying party ID,
<code>example.com</code>. Note that this is the same value that was sent
when generating the credential, otherwise the request would be
rejected.)</li>
<li><code>40</code> (the length of the credential ID; 64 bytes.)</li>
<li><code>a288...db2a</code> (the credential ID. The same value that was
returned from the <code>generate</code> operation, and given in the
Javascript request to the browser.)</li>
<li><code>0000</code> (indicating that the maximum response length is
supported).</li>
</ul>
<p>The response to a <code>sign</code> request is the simplest message
so far:</p>
<ul>
<li><code>01</code> (a flags byte with one flag set: 0x01 for “user
presence”—covered later)</li>
<li><code>00000004</code> (a 32-bit signature counter, also covered
later)</li>
<li><code>3045...0e2d</code> (the signature itself).</li>
</ul>
<p>Recall that, in the previous chapter, we considered a series of
shapes for the signed message. Firstly, we tried using a constant value
(“let me in”). Next we realized that the message should include the
site’s origin to prevent phishing, so it became a JSON object:
<code>{&#34;origin&#34;: &#34;https://example.com&#34;}</code>. Then we realized that it
should contain a random challenge value from the site to make it unique
to an authentication attempt. This JSON is called the client data
because it comes from the client (i.e. computer), rather than from the
security key. It’s hashed and combined with the authenticator data
(which comes from the security key) to form the message that is
ultimately signed.</p>
<p>The client data generated by a modern browser has evolved slightly
and, for the Javascript request above, looks like this: (With whitespace
and line breaks added for clarity.)</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span>&#34;type&#34;</span><span>:</span> <span>&#34;webauthn.get&#34;</span><span>,</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span>&#34;challenge&#34;</span><span>:</span> <span>&#34;AAECAwQFBgcICQoLDA0ODw&#34;</span><span>,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span>&#34;origin&#34;</span><span>:</span> <span>&#34;https://example.com&#34;</span><span>,</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span>&#34;crossOrigin&#34;</span><span>:</span> <span>false</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We’ve seen the <code>origin</code> and <code>challenge</code> fields
before, although note that the challenge is encoded with base64url,
rather than the more common base64 encoding. The <code>type</code> field
is just good security hygiene: you never want to allow ambiguity, so
it’s good to be explicit about the intended meaning of all messages. The
<code>crossOrigin</code> field communicates whether the authentication
was done within an iframe inside another site.</p>
<p>(Browsers may add more fields in the future, so always parse such
JSON rather than assuming that the challenge can be inserted into a
template.)</p>
<p>The authenticator data is the concatenation of the following:</p>
<ol type="1">
<li>The SHA-256 of the relying party ID.</li>
<li>The flags byte from the <code>sign</code> response.</li>
<li>The signature counter from the <code>sign</code> response.</li>
</ol>
<p>Then the signed message, i.e. the final value given to the
<code>sign</code> operation, is the authenticator data followed by the
SHA-256 hash of the client data.</p>
<p>We now have all the pieces to implement the public-key authentication
scheme sketched out in the previous chapter:</p>
<p>When an account is first registered, we have a Javascript snippet
that will cause the browser to send a request to a U2F security key to
generate a public and private key. The server can store the credential
ID and public key from the response and associate them with the new
account. Then, when that account tries to sign in, the server generates
a random challenge and makes a Javascript call with that challenge and
the credential ID. The browser will send a request to a U2F security key
to sign a message containing that challenge (and other values) and
return the resulting client data, authenticator data, and signature.</p>
<p>The server can now:</p>
<ul>
<li>Run the <code>verify</code> operation with its stored public key and
the response from the browser.</li>
<li>Check that the client data’s <code>type</code>, <code>origin</code>,
<code>crossOrigin</code>, and <code>challenge</code> fields are as
expected.</li>
<li>Check that the authenticator data is well-structured and contains
the expected relying party ID, and that the flags byte has “user
presence” set.</li>
</ul>
<p>This is still a simplistic example and there are more steps in a full
implementation. (For example, unless the user provides a password as
well then it would be possible to take a security key from someone’s
desk and sign in as them!) But you can now see the core ideas in action,
all the way from a server, through a browser, to concrete messages sent
over USB to a security key.</p>
<h3 id="statelessness">Statelessness</h3>
<p><span id="stateless"></span> Nearly all U2F security keys are
designed in a manner that avoids the need to actually store the private
keys, thus they can generate an unlimited number of credentials with
only a constant amount of onboard storage. The exact details are private
to the security key but go something like this:</p>
<p>Either at the factory or on first use, the security key will generate
and store a random symmetric key. We’ll call this the “root secret”.
Then, when the security key is asked to generate a public and private
key, it chooses a random seed value and encrypts it with the root
secret. Next, it authenticates the encrypted seed, along with the hash
of the relying party ID and any other pertinent values, using an
algorithm like HMAC.</p>
<p>Together, the encrypted seed and the HMAC form the credential ID.
Then the security key generates a public key and private key from the
seed, discards the private key, and returns the credential ID and public
key to the computer.</p>
<p>When asked to do a sign operation, the security key splits the
credential ID into an encrypted seed and an HMAC value. It checks
whether the HMAC is correct for the relying party ID hash and the
encrypted seed. If not, then either this credential ID came from a
different security key or the relying party ID is incorrect. In either
case, it returns an error.</p>
<p>But, if the HMAC is correct, it decrypts the seed using its root
secret and can then derive the same private key as it did before. Then
it performs the <code>sign</code> operation with that private key and
returns the resulting signature.</p>
<p>At no point did the security key need to store anything other than
the root secret, and there is only a single root secret for all
credentials, so the storage requirements are constant. The state
necessary for a credential is kept in the credential ID, and that is
stored on the server.</p>
<p>There are a couple of consequences of this style of design:</p>
<p>First, a credential can never be used without knowing the credential
ID. In chapter 3 we’ll discuss “discoverable” credentials that change
this assumption but, in U2F, a credential ID is always needed.</p>
<p>Second, there’s no way to delete an individual credential from a
security key because the credential isn’t stored on the security key,
it’s “stored” in the ID, on the server. Instead, U2F security keys will
typically support a reset command that generates a fresh root secret.
Once the root secret has been changed, all previous credential IDs are
invalidated and will appear to be IDs generated by a different security
key.</p>
<p>In U2F this reset functionality, if it exists for a particular model
of security key, is a vendor-specific command. It gets standardized in
CTAP2, see <a href="#reset">here</a>.</p>
<h3 id="signature-counters">Signature counters</h3>
<p>The rest of this chapter contains details that can be skipped on a
first reading.</p>
<p>The last unexplained field is the “signature counter” that is
returned from <code>sign</code> operations. In the example above, it was
four, but that doesn’t mean that I discarded three responses while
trying to capture that example.</p>
<p>Signature counters are optional for the security key to implement,
although the majority of them do. If there’s no counter then the value
in the response is always zero. But once a security key has produced a
non-zero value then it has to ensure that the counter, for all future
signatures from that credential, strictly increases.</p>
<p>The motivation for having a counter is that it might allow websites
to detect when a security key has been cloned. Cloning a security key is
supposed to be very difficult but, if you assume someone managed to do
it (probably destroying it in the process), then one could create a
working replica which could be slipped back into the possession of the
legitimate user, leaving them unaware that anything has happened. At
this point the attacker, who presumably also created a replica for
themselves, can create signatures as easily as the legitimate user.</p>
<p>If all that has happened, then the signature counter might uncover
it. Unless the attacker can know exactly when the legitimate user has
used their security key, and thus incremented the counter, then
eventually either they or the real user will create a signature where
the counter didn’t increase.</p>
<p>If the website noticed this, it could sound the alarm. At a minimum,
the security key in question should be replaced. Ideally, the account
and security key would be investigated carefully for signs of
compromise.</p>
<p>This is a rather far-fetched scenario. Generally, when signature
counters are checked by a site, any error is treated as a transient
authentication failure. But that defeats the point: the user or attacker
will simply try again after the signature counter has naturally
incremented, and then it’ll work. The user will simply come to think of
their security key as a bit worn out and will learn that sometimes it
requires a couple of attempts to work.</p>
<p>On the other hand, many security keys only have a single, global
signature counter, and this allows different websites to correlate the
use of the same security key between them. That is, the current counter
value of your security key is somewhat identifying and can be combined
with information about how often it increases. (Better security keys
will implement more granular signature counters.)</p>
<p>Signature counters are also incompatible with syncing private keys
between computers (see chapter 3) and thus are not implemented in an
increasing fraction of cases.</p>
<p>So signature counters might be useful in the most extreme cases if
carefully implemented and coupled with a robust incident response
process, but they can otherwise be ignored.</p>
<h3 id="platform-behavior">Platform behavior</h3>
<p>The computers (or phones) that security keys are used with are called
platforms and U2F is a bit more complex for platforms than suggested in
the sketch above. There can be multiple security keys plugged into a
laptop, and a WebAuthn request can list many credential IDs. The browser
has to find the right credential ID for the right security key.</p>
<p>Also, U2F was designed so that security keys could be implemented in
a Java-based framework that did not allow requests to block. But
requests cannot complete until user-presence is satisfied, i.e. until
someone touches the sensor on the security key.</p>
<p>These factors mean that browsers have to poll U2F security keys. Two
protocol features facilitate this:</p>
<p>First, whenever an operation cannot be completed because the security
key is waiting for a touch, the request will immediately result in a
special error code (“test of user presence required”). The security key
will usually blink an indicator for a short while after this.</p>
<p>Second, the flags byte in <code>sign</code> requests can be set to
0x07 (“check only”). This causes the request to always fail but with one
of two distinct error codes. If the credential ID and relying party ID
hash are valid for the security key, then it returns the same “test of
user presence required” error as before. (Whether the security key has
been touched recently or not!) Otherwise it returns a different error
(“bad key handle”).</p>
<p>Browsers combine these two features with the following algorithm for
handling U2F security keys:</p>
<p>For <code>generate</code> requests, the request is sent to all
security keys. The security keys will fail the request because they
haven’t been touched, so the requests are repeated every few hundred
milliseconds until the user touches one of the security keys to select
it.</p>
<p>For <code>sign</code> requests, each credential ID is sent to each
security key in “check only” mode until either a valid credential ID is
found, or until all credential IDs have been tried with a given security
key. If a valid credential ID is found for a security key then a stream
of sign requests are sent, waiting for a touch. If a security key
doesn’t recognize any IDs then either a message is displayed on the
screen, or else a stream of <code>generate</code> requests are sent,
waiting for a touch. These generate requests are sent just to cause the
security key to blink its indicator, and to see whether the security key
is touched—any resulting public key is discarded. If the security key is
touched, an error is displayed to the user because that security key
isn’t going to work.</p>
<h3 id="the-transport-layer">The transport layer</h3>
<p>A fully working spec also needs to define how security keys are
discovered on the USB bus and how the U2F messages are encoded for
transmission.</p>
<p>Security keys advertise themselves as USB Human Interface Devices.
HID devices can advertise a number of usage pages that describe broadly
what kind of device they are. For example, usage page one covers
keyboards, mice, joysticks, and other common input devices. Security
keys advertise the usage page 0xf1d0 (“FIDO”, get it?) to identify
themselves.</p>
<p>HID devices communicate using short report messages and FIDO <a href="https://fidoalliance.org/specs/fido-v2.2-rd-20230321/fido-client-to-authenticator-protocol-v2.2-rd-20230321.html#usb-message-and-packet-structure">defines</a>
how longer messages are fragmented and reassembled so that they can be
sent as a series of reports.</p>
<p>To deal with the issue of multiple applications trying to talk to the
same security key at the same time, and potentially interleaving their
streams of report messages, every report starts with a channel
identifier. Applications get an identifier by sending a 64-bit nonce and
watching for a channel allocation report from the device that echoes
that nonce.</p>
<p>Thus, in theory, a security key can handle multiple concurrent
communication streams with different applications on the computer. In
practice, since security keys are embedded devices, they often only
support a single active channel and so an application requesting a new
channel will disable the previously active one. However, this mechanism
still allows communications to be cleanly broken off rather than having
fragments from different applications interleaved, producing
unpredictable results.</p>
<p>Security keys often also support communication over NFC, so that a
security key can simply be held near the top of a mobile phone to be
used. While the underlying technology and framing differs completely
between USB and NFC, it is ultimately just another way of exchanging
messages and so the underlying transport can be switched out without
affecting any of the higher-level protocol.</p>
<p>A Bluetooth Low Energy (BLE) transport was also defined, but this
requires the security key to have its own power source. The primary
motivation was to use security keys with iPhones before they had support
for NFC security keys, but now that the issue has been resolved, BLE
security keys are very rarely seen. (This transport is unrelated to the
one used between computers and phones, which is covered in chapter
10.)</p>

<p>The standards described in the previous chapter are sufficient to
enable the classic 2nd-factor pattern of entering a username, then a
password, and then tapping a security key. Many companies have deployed
this sort of system to their employees to very great effect.
Authenticating employees with just a password in this day and age is
bordering on negligence and, unlike code-based second factors (whether
delivered over SMS or from an app on a phone), security keys aren’t
phishable.</p>
<p>But a password is still necessary. Otherwise, the security key alone
would be sufficient to authenticate, and mislaid security keys would be
a significant concern.</p>
<p>U2F also doesn’t solve the problem of usernames. Remembering
usernames is a bother that password managers help solve today. So, if
public key authentication is going to find a broader audience, it needs
to solve this too. Thus we want to be able to ask a security key what
accounts have been registered for a particular site, and for it to store
the corresponding usernames.</p>
<p>The U2F protocol outlined in the previous chapter cannot support
this. It assumes that the credential ID is already known before a
<code>sign</code> operation can be performed, and thus the account must
be known before the security key can be used. Indeed, the vast majority
of U2F security keys do not store any per-credential data, as described
on <a href="#stateless">here</a>, and so it’s impossible for them to
work with any other pattern of interaction.</p>
<p>So security keys, and the protocol for communicating with them, had
to evolve. Within the FIDO Alliance this was broadly done under the
umbrella term “FIDO2”, which covered both a new security key protocol
(CTAP2) and a new Javascript API (WebAuthn), which we’ve already seen
examples of.</p>
<p>The first major new concept in FIDO2 is discoverable credentials.</p>
<h3 id="the-model-of-discoverable-credentials">The model of discoverable
credentials</h3>
<p>Credentials on a U2F security key, which we’ll now call
non-discoverable credentials, conceptually consist of three values: the
credential ID, the private key, and the relying party ID. Since U2F
security keys generally don’t store any per-credential state, they can
be thought of as an infinite bucket of such credentials.</p>
<p>A security key that stores discoverable credentials can be thought of
as a database table. The first two columns of this table form the
primary key, and those columns are the relying party ID and the user ID.
A user ID is a new concept for discoverable credentials: an identifier
for an account chosen by the site. It is not (and should not be) the
username, for reasons that will be explained on
<a href="#ctap2-user-id">here</a>. Instead, it is better to think of it
as the “user UUID”.</p>
<p>Since these two columns are a primary key, that implies that the
security key stores at most one credential for any given pair of relying
party ID and user ID. So if you create a second discoverable credential
that has the same RP ID and user ID as an existing one, then the
existing one is overwritten.</p>
<p>The third and fourth columns of this conceptual table are familiar:
the credential ID and the private key. Discoverable credentials still
have credential IDs and can be specified by them just like
non-discoverable credentials. But the crux is that it’s also possible to
ask for some credential for a given RP ID, without specifying any
credential IDs. This is the key distinction between discoverable and
non-discoverable credentials, and the one that lets them act like a
username as well as an authentication factor.</p>
<p>There are many more columns in the table. Of course there’s a
username (in fact, two), and an increasing number of extensions require
more fields to be added to the credential row. These values will be
covered in chapters 4 and 9.</p>
<p>Since discoverable credentials require per-credential storage on a
security key, many security keys support creating both discoverable and
non-discoverable credentials and have a limit on the number of
discoverable credentials.</p>
<h3 id="user-verification">User verification</h3>
<p><span id="uv"></span> Discoverable credentials solve the problem of
usernames, but we would still need a password to avoid risks from
mislaid security keys. In fact, discoverable credentials make that
problem even more acute: you wouldn’t even have to guess whose security
key it was, it would tell you!</p>
<p>U2F introduced the concept of user presence—that some human was
physically present. Coupled with discoverable credentials comes the
stronger notion of user verification—that the correct human is
physically present. The mechanism for establishing this varies. Some
security keys have fingerprint readers, a few security keys have a
physical PIN pad on the device, but most security keys use a PIN that is
entered on the computer.</p>
<p>The implied contract with the security key is that it will maintain a
user verification chain: if user verification is performed with a PIN,
then that PIN may be changed, but the old PIN has to be presented to do
so. If the PIN is lost and needs to be reset, then all the credentials
must be deleted to do so. Different security keys may differ in the
details, but each should maintain such a chain of verification.</p>
<p>While the term “PIN” is used, these PINs can be alphanumeric, so you
could also call them passwords. But since FIDO2 was supposed to be
replacing passwords, calling them passwords would have been awkward, and
so they were called PINs. But the difference is more than just a name:
these PINs are never sent over the network, can never be disclosed in a
database leak, and, if they’re being used with a security key, then the
security key can enforce hardware-based guess limits.</p>
<h3 id="platform-authenticators">Platform authenticators</h3>
<p>It also became apparent with U2F that many people wanted to keep
their security keys plugged into their computer all the time. In
response, a form factor of security key that mostly fits inside a USB
port, and leaves only a small lump on the outside of the computer,
became quite popular.</p>
<p>But this was driven by more than the realization that a USB port was
a useful place to keep a security key where it wouldn’t get lost.</p>
<p>Malware that steals cookies is a serious concern because, no matter
how strong the initial authentication is, if malware can steal the
results of that authentication, you still have a security problem. So
enterprises often ask their users to re-authenticate with their security
keys, perhaps daily. Since a hardware-bound private key cannot be stolen
by malware, this establishes that the active session is still
legitimate.</p>
<p>But many computers already have a <a href="https://en.wikipedia.org/wiki/Trusted_Platform_Module">Trusted
Platform Module</a> or similar device within them that can store a
hardware-bound private key and sign with it. So why not use those as
opposed to having a security key permanently inserted? Since the
computers or phones that security keys are used with are called
platforms, these are called platform authenticators.</p>
<p>Traditional platform authenticators cannot help you with signing in
on a different computer, but they can provide proof that an active
session hasn’t been stolen by malware and, when coupled with user
verification, they can provide evidence that the correct human is still
behind the keyboard. They are also far more common than security keys
since no extra hardware has to be purchased.</p>
<p>(From this point, we’ll start to use the more generic term
authenticator, rather than security key, unless specifically speaking
about the latter type of device.)</p>
<h3 id="webauthn">WebAuthn</h3>
<p>In the next chapter we’ll cover the Javascript API that was developed
as part of the broader FIDO2 effort in order to expose these concepts:
WebAuthn. The APIs for Android, iOS, macOS, and Windows are strongly
shaped by it and, collectively, they form the WebAuthn family of APIs.
So even if you never touch Javascript, you need to understand the core
of WebAuthn. While the syntax of these different APIs varies, they’ll
generally use the same terminology, and they all produce compatible
outputs.</p>
<h3 id="passkeys">Passkeys</h3>
<p>Since (traditional) platform authenticators can’t be used to sign in
on other devices, FIDO2 originally assumed that all users had security
keys. Otherwise losing or reinstalling a laptop would leave a user
without any usable credentials.</p>
<p>Security keys are great and should be deployed with gusto in all
enterprise and government environments that require strong
authentication. But it’s unlikely that regular people are going to adopt
them and, even if they did, security keys work much better when there’s
a helpdesk that can be a backstop after the dog has chewed on one.</p>
<p>If the benefits of FIDO2 are going to be enjoyed more widely,
credentials are going to have to be more usable, and that means syncing
them. In this book, thus far, there has been a firm link between a
credential and a single physical device that created and holds the
private key. That device might be a security key, or it might be a
platform authenticator, but either way you can point to where the
private key is stored and it never moves. Syncing changes that, in good
ways (people can recover from losing a device), and bad (a sync account
could be compromised).</p>
<p>Wider deployment also needs to avoid overly technical terms;
“WebAuthn credential” doesn’t sound very friendly. Thus the term passkey
was invented by Apple, but they nicely let everyone use it.</p>
<p>A passkey is a synced, discoverable WebAuthn credential. Or, when
that’s awkward, sometimes it’s just a discoverable credential. But this
book will stick to the former definition. In general, passkeys are an
attempt to take WebAuthn outside the enterprise.</p>
<p>The passkey ecosystem consists of providers, provider APIs, passkey
APIs, and the hybrid transport. We’ll cover the hybrid transport in
chapter 10. It’s the fallback for when syncing doesn’t bring a passkey
to where you need it: you can pull out your phone, scan a QR code, and
send a signature to a computer.</p>
<p>Passkey providers are services that store and sync passkeys (which
are, remember, just another name for discoverable WebAuthn credentials).
Within the Apple ecosystem, iCloud Keychain is the most common provider.
On Android, you’ll commonly find Google Password Manager or Samsung
Pass. Most other password managers are also passkey providers, such as
1Password, Dashlane, and Bitwarden.</p>
<p>Provider APIs are the way that passkey providers register with an
operating system. We won’t be covering these APIs in detail in this
book, but the Apple platforms and Android both provide APIs where
providers can register. Then providers can offer passkeys to
applications that want them.</p>
<p>The flip side of the provider APIs are the passkey APIs. These are
covered in detail in chapter 11. They provide applications with access
to registered providers so that they can request that passkeys be
created, and can request signatures from them. These APIs are all based
on the original FIDO2 API: WebAuthn.</p>
<p>When credentials are synced, the sync account (rather than a device)
is considered to be the authenticator. So when the model of discoverable
credentials says that only one credential with a given pair of RP ID and
user ID exists within an authenticator, that applies to the sync
account, not to each individual device that is syncing.</p>
<p>For example, if a credential is created in iCloud Keychain on a Mac
for a given site and user ID, and then another credential is created on
an iPhone, signed into the same iCloud account, with matching RP ID and
user ID values, then the latter will overwrite the former because the
sync account is the same, and the invariant applies to the whole
account.</p>

<p>WebAuthn (short for “Web Authentication”) is a web API that lets a
site interact with U2F-era security keys (see chapter 2), but also take
advantage of all the new concepts in FIDO2, as outlined in the previous
chapter.</p>
<p>The data formats and structures in WebAuthn are also strongly
reflected in the platform APIs that exist for apps running on the Apple
family of platforms, on Android, and on Windows. So even non-Web
developers will need to understand the concepts from this chapter.</p>
<h3 id="patterns-in-webauthn">Patterns in WebAuthn</h3>
<p>WebAuthn is integrated with the W3C <a href="https://www.w3.org/TR/credential-management-1/">Credential Manager
API</a>, which lives in the <code>navigator.credentials</code>
namespace. You don’t need to know this API to use Web­Authn and it’s not
covered here. But you’ll notice that the APIs are structured to support
other credential types too. That’s not an accident: both passwords and
federated credentials can be used via Credential Management.</p>
<h3 id="creating-a-credential">Creating a credential</h3>
<p>Creating a credential looks like this:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>const</span> promise <span>=</span> <span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>create</span>({</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span>publicKey</span><span>:</span> creationOptions<span>,</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>})<span>;</span></span></code></pre></div>
<p>The resulting promise either resolves with a representation of the
newly created credential, or else an error. But first we’ll look in
detail at the options that control what is created and where it’ll be
stored.</p>
<p>The <code>creationOptions</code> above is a <a href="https://www.w3.org/TR/webauthn-2/#dictionary-credential-params"><code>PublicKeyCredentialCreationOptions</code></a>
dictionary and it contains the following members:</p>
<pre><code>dictionary PublicKeyCredentialCreationOptions {
    // Selecting the public key signature scheme to use.
    required sequence&lt;PublicKeyCredentialParameters&gt; pubKeyCredParams;

    // Controlling the location and type of the new credential.
    AuthenticatorSelectionCriteria          authenticatorSelection;
    sequence&lt;PublicKeyCredentialDescriptor&gt; excludeCredentials = [];
    
    // Metadata stored with the credential.
    required PublicKeyCredentialRpEntity    rp;
    required PublicKeyCredentialUserEntity  user;

    // Guiding the UI.
    unsigned long                           timeout;
    sequence&lt;DOMString&gt;                     hints = [];

    // Extension features, covered in a later chapter.
    AuthenticationExtensionsClientInputs    extensions;

    // Fields related to attestation; covered in a later chapter
    required BufferSource                   challenge;
    DOMString                               attestation = &#34;none&#34;;
    sequence&lt;DOMString&gt;                     attestationFormats = [];
};</code></pre>
<h4 id="selecting-a-signature-scheme">Selecting a signature scheme</h4>
<p>Signature schemes are identified by integers assigned by the IETF’s
COSE group. A site specifies the set of schemes that it accepts (in
preference order) by listing them in <code>pubKeyCredParams</code>.
Since the values assigned by the COSE group leave some parameters
unspecified, WebAuthn additionally defines those parameters for the
common schemes.</p>
<p>ECDSA with P-256 and SHA-256 is the dominant scheme, by far, in the
WebAuthn ecosystem. (If you recall from chapter 2, it’s the only scheme
that was supported in U2F.) It has been given identifier -7.
<span id="pubkeyparams"></span> (Yes, a negative number.)</p>
<p>Many PCs have a <a href="https://en.wikipedia.org/wiki/Trusted_Platform_Module">TPM</a>
that only supports the older RSA PKCS#1 v1.5 standard and so, to be
compatible with them, sites are advised to support that scheme too. RSA
PKCS#1 v1.5 uses the identifier -257 and also specifies SHA-256 as the
hash function.</p>
<p>So most sites should set <code>pubKeyCredParams</code> to the
following:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>[{<span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span> <span>alg</span><span>:</span> <span>-</span><span>7</span>}<span>,</span> {<span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span> <span>alg</span><span>:</span> <span>-</span><span>257</span>}]</span></code></pre></div>
<p>Some other, less common schemes are -8 for Ed25519 and -35 for ECDSA
with P-384 and SHA-384. Ed25519 is superior to ECDSA P-256 but the
difference is often not sufficient to outweigh how common ECDSA is.
ECDSA with P-384 can be used in order to meet certain <a href="https://media.defense.gov/2022/Sep/07/2003071834/-1/-1/0/CSA_CNSA_2.0_ALGORITHMS_.PDF">regulatory
requirements</a> but, given that the primary risks are implementation
issues, it is likely less secure in practice. In the future ML-DSA
(previously called Dilithium) is likely to replace ECDSA due to concerns
about quantum attacks, but that transition is still some years in the
future.</p>
<h4 id="controlling-the-location-and-type-of-the-new-credential">Controlling
the location and type of the new credential</h4>
<p>The <code>authenticatorSelection</code> field is, itself, another
dictionary with the following fields:</p>
<pre><code>dictionary AuthenticatorSelectionCriteria {
    // Controlling whether the credential is discoverable.
    DOMString    residentKey;
    boolean      requireResidentKey = false;

    // Controlling whether user verification is performed.
    DOMString    userVerification = &#34;preferred&#34;;

    // Controlling which types of authenticators can store the
    // credential.
    DOMString    authenticatorAttachment;
};</code></pre>
<p>The first two fields control whether the credential must be
discoverable. But why are there two of them, and why are they named
“resident”, not “discoverable”?</p>
<p>Historically, discoverable credentials were first called resident
credentials so this term will pop up in several places in the protocol.
It is inaccurate, however. Resident credentials are those where the
authenticator keeps state about the credential. Discoverable credentials
are always resident, but non-discoverable credentials can be resident
too. The important point is whether the credential follows the model of
discoverable credentials and can be used without knowing the credential
ID, not whether the authenticator operates statelessly.</p>
<p>So, despite the naming, these fields control whether the credential
must be discoverable.</p>
<p><code>requireResidentKey</code> was defined first but is just a
boolean. In order to allow sites to express that they prefer, but do not
require, a discoverable credential it was necessary to add a second
field, <code>residentKey</code>. A site must pick one of the following
scenarios in order to set these two fields:</p>
<ol type="1">
<li>If the site will always use the credential in the 2nd-factor
pattern, i.e. the U2F style where credential IDs will always be provided
when requesting a signature, set <code>requireResidentKey</code> to
false. (The resulting credential may still be discoverable, but
discoverable credentials work perfectly well with credential IDs. This
is the default if neither field is set.)</li>
<li>If the site will use the credential without first collecting a
username, thus no credential IDs can be given, then set
<code>requireResidentKey</code> to true. The resulting credential will
be discoverable. (But will still work when credential IDs are
given.)</li>
<li>If the site will take advantage of discoverable credentials when
possible, but also supports using credentials in a 2nd-factor flow with
credential IDs, then set <code>residentKey</code> to
<code>&#34;preferred&#34;</code>. (It’s possible to optionally take advantage of
discoverable credentials with conditional UI, see chapter 8.) Whether
the credential is known to be discoverable is reported via the
<code>credProps</code> extension (see
<a href="#credprops">here</a>).</li>
</ol>
<p>Note that there’s no way to require a non-discoverable credential.
Created credentials can always be discoverable and these controls only
allow a site to insist that they must be.</p>
<h5 id="user-verification-1">User verification</h5>
<p><span id="uv-param"></span> See <a href="#uv">here</a> for a
discussion of the concept of user verification. The
<code>userVerification</code> field can be set to one of the strings
<code>discouraged</code>, <code>preferred</code>, or
<code>required</code>, and the default is <code>preferred</code>.
Creating a credential with user verification ensures that the capability
will be available when getting a signature. It also marks the start of a
user verification chain: each future signature from the credential with
the UV flag set must have collected some proof of user verification, and
that proof must chain back to the proof collected at creation time. For
example, if user verification is established with a PIN, then changing
that PIN must require the old PIN. If a fingerprint is used, then
enrolling a new fingerprint must require an old fingerprint or PIN,
etc.</p>
<p>As with <code>residentKey</code>, setting
<code>userVerification</code> to <code>preferred</code> means that the
site would make use of user verification if performed, but will accept a
credential without it. But how “preferred” is it? For example, should a
PIN be set up on a security key in order to create a credential with
user verification, or should a PIN only be used if it happens to already
be set up? That’s up to the platform. Windows tends towards a stronger
interpretation of “preferred” than other platforms and will, indeed, set
up a PIN on a security key in response to a request that prefers user
verification.</p>
<p>When it comes to platform authenticators and passkeys, the
interpretation of the <code>userVerification</code> value varies by
provider, and might change over time. Here are the cases when user
verification will be performed today, for three common passkey
providers:</p>
<p>iCloud Keychain</p>
<table>
<thead>
<tr>
<th></th>
<th>Discouraged</th>
<th>Preferred</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr>
<td>Biometrics available</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Biometrics not available</td>
<td></td>
<td></td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>Google password manager (desktop)</p>
<table>
<thead>
<tr>
<th></th>
<th>Discouraged</th>
<th>Preferred</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr>
<td>Biometrics available</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Biometrics not available</td>
<td></td>
<td></td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>Windows Hello</p>
<table>
<thead>
<tr>
<th></th>
<th>Discouraged</th>
<th>Preferred</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr>
<td>Biometrics available</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Biometrics not available</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>For simple sites, the presence or absence of user verification will
often make no difference: if the WebAuthn signature is valid, the user
is signed in and, if not, they aren’t. If user verification makes no
difference, the parameter should be set to <code>discouraged</code>.</p>
<p>More complex sites might base the sign-in decision on a risk
analysis, or might subject sign-ins without user verification to
additional challenges. In this case, the parameter should be set to
<code>preferred</code> since doing user verification has value to the
user.</p>
<p>Some sites might decide to only ever accept sign-ins that include
user verification. In this case, set the parameter to
<code>required</code>.</p>
<h5 id="applicable-authenticators">Applicable authenticators</h5>
<p>The <code>authenticatorAttachment</code> field can be left undefined,
set to <code>platform</code>, or set to <code>cross-platform</code>.
This controls which types of authenticators can be used.</p>
<p>Setting this to <code>platform</code> means that no external
authenticators can be used. So security keys and external mobile devices
are not applicable. For example, if a site offers to register “this
computer” in its UI then it might set this field to
<code>platform</code>. The resulting platform UI will skip or remove
other options.</p>
<p>Setting this to <code>cross-platform</code> means that only
authenticators that can be moved between devices are applicable. I.e.
security keys and external mobile devices. If a company website knows
that users have been issued security keys to use with company resources,
it might set this to <code>cross-platform</code>.</p>
<p>Leaving this field undefined, the default, permits all
authenticators, but the platform UI will generally default to a platform
authenticator if available. If a site offers to register a passkey in
its account settings, it might thus leave this value undefined.</p>
<h5 id="excluded-credentials">Excluded credentials</h5>
<p>Another way in which applicable authenticators can be controlled is
by setting <code>excludeCredentials</code> in the top-level dictionary.
This should contain the credential IDs of all currently known
credentials for the user. It communicates that those credentials should
not be overwritten, and that any external authenticator with one of
those credentials should not be registered again.</p>
<p>Consider a user who is attempting to register a second security key
on an account that uses the 2nd-factor flow. Their security key will
likely create a stateless, non-discoverable credential and thus no
existing credential can be overwritten. But it’s completely useless to
register two credentials on the same security key: two credentials will
appear in the user’s account, but there’s only a single security key
that contains them both. It would be confusing.</p>
<p>By listing all existing credential IDs in
<code>excludeCredentials</code>, the site can instruct the platform to
forbid an existing security key to be registered. If the user tries to
do so, they should see an error message and the platform will usually
allow them to try again with a different security key.</p>
<p>Next, consider a platform authenticator that always creates
discoverable credentials. Recall that the model of discoverable
credentials only allows at most one credential with a given RP ID and
user ID to exist in an authenticator. So, if the user were to register a
second credential it would overwrite the first. There would be two
credentials listed on the site, but one would no longer exist in the
platform authenticator. This would also be confusing for the user.</p>
<p>In the case of a platform authenticator, however, the platform will
do something different if a credential in
<code>excludeCredentials</code> already exists. The creation process
will appear to succeed from the point of view of the user, but the
platform will return <code>InvalidStateError</code> to the website. This
special error code is unique to this situation and the website can
choose to show an error. (E.g. “You’ve already registered this
computer”.) The site can also choose to ignore this error: the user
wanted the platform registered as an authenticator and it already is; no
need to complicate things with an error message.</p>
<p>Note that the <code>excludeCredentials</code> field is not just a
list of credential IDs. It’s written like this:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>[</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  {<span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span> <span>id</span><span>:</span> <span>/* credential ID in ArrayBuffer */</span>}<span>,</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span>/* more such elements ... */</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<p>There is no <code>type</code> other than “public-key”—that’s
extensibility that was never used. The <code>id</code> is binary and
binary values in WebAuthn, of which there are a lot, are passed in
<code>ArrayBuffer</code> and <code>BufferSource</code> objects. This is
awkward because these objects don’t convert to/from JSON automatically.
There is light on the horizon in the form of native JSON support in
WebAuthn (see <a href="#json-conversion">here</a>) but this cannot be
relied on to be present in current browsers. So for now, when receiving
messages from a server to make WebAuthn calls, any binary data has to be
handled specially.</p>
<h3 id="metadata-stored-with-the-credential.">Metadata stored with the
credential.</h3>
<p>The <code>rp</code> (relying party) and <code>user</code> fields in
the top-level options dictionary contain metadata that is stored with
the credential. The <code>rp</code> field has this structure:</p>
<pre><code>dictionary PublicKeyCredentialRpEntity {
             DOMString id;
    required DOMString name;
};</code></pre>
<p>This <code>id</code> field specifies the relying party ID. This topic
is complex enough that it’s covered separately in chapter 5. If omitted,
it defaults to the domain of the current origin.</p>
<p>The <code>name</code> field is required, but currently never used. It
was intended to be a human-friendly name for the site, e.g. “ACME
Corporation”. If there’s no obvious value to use, just pass the empty
string as this field will probably be unused forever.</p>
<p>The <code>user</code> dictionary looks like this:</p>
<pre><code>dictionary PublicKeyCredentialUserEntity {
    required BufferSource id;
    required DOMString    name; 
    required DOMString    displayName;
};</code></pre>
<p>The <code>id</code> field here is the user ID. Recall from the
discussion of the discoverable credential model that an authenticator
stores at most one credential with a given pair of RP ID and user ID
values. The user ID is not the username and users will never see this
value. It is an opaque, binary identifier for an account that can be up
to 64 bytes long. However, since the user ID is treated as less
sensitive than a username by security keys, it should not be equal to
the username. It cannot be empty either. It’s recommended to be a large
random value (e.g. a UUID) that is stored by the site for each account.
<span id="user-id"></span></p>
<p>(In this book we’ll always call this value the user ID. But it’s also
sometimes called the “user handle”, including in the WebAuthn API later
on! These are two names for the same thing.)</p>
<p>The <code>name</code> field is the username. This is a human-readable
string that usually uniquely identifies an account. It might be an email
address. This value will be displayed in account selectors and
management UIs so the user can understand which account a credential
corresponds to.</p>
<p>The <code>displayName</code> field is for a more “friendly” name for
the account. For example, a site may require an account to have a unique
username, but allow users to configure a (potentially non-unique) name
that they will appear as on the site. That second name would appear in
this field. This field cannot be omitted but, if there is no obvious
value to put in it, set it to the empty string.</p>
<p>Unlike the username, the display name is not always shown in account
selectors and management UI, depending on the platform. Apple’s
platforms, for example, do not show display names.</p>
<h3 id="controlling-the-platform-ui">Controlling the platform UI</h3>
<p>The platform will show UI to help guide the user in creating the
requested credential and there are a couple of ways in which the UI can
be guided.</p>
<p>Firstly, there’s the <code>timeout</code> parameter. If a site will
reject a credential that took too long to create (because it’s concerned
that the user has walked away and that someone else could be behind the
keyboard) it can set a timeout, in milliseconds. But it can take a while
for people to create credentials! They may have to dig a security key
out from the back of a drawer. Because of this, platforms are likely to
silently increase small timeouts to some minimum value. So a timeout of
less than five minutes (the recommended default) may be rounded up.</p>
<p>Secondly, there is the <code>hints</code> parameter. This is a
catch-all for expressing non-binding requests to the platform. It is a
list of strings and currently three are defined:</p>
<ul>
<li><code>security-key</code> suggests that the platform should show a
security key-focused UI. Enterprise cases where security keys have been
issued to employees should set this.</li>
<li><code>client-device</code> suggests that the platform should focus
the UI on using a platform authenticator.</li>
<li><code>hybrid</code> suggests that the platform should expect the
user to use an external mobile device to complete the request. (See
chapter 10.)</li>
</ul>
<p>The first two of these somewhat duplicate the
<code>authenticatorAttachment</code> field, described above. Unlike that
field, they do not forbid the use of other types of authenticators.
However, hints are not yet supported by all platforms and so cannot be
assumed to have any effect.</p>
<p>Attestation and extensions get their own chapters and are not covered
here, but the <code>challenge</code> parameter, which is unused during
creation except for attestation, is required. You can set it to
<code>new Uint8Array([0]).buffer</code> in all non-attestation
cases.</p>
<h3 id="common-patterns-of-options">Common patterns of options</h3>
<p>A consumer site, prompting to create a first passkey with the local
device:</p>
<p>(A website would have checked if a local authenticator exists first.
See <a href="#isuvpaa">here</a>.)</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>let</span> promise <span>=</span> <span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>create</span>({</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span>publicKey</span><span>:</span> {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span>pubKeyCredParams</span><span>:</span> [</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>            {<span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span> <span>alg</span><span>:</span> <span>-</span><span>7</span>}<span>,</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>            {<span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span> <span>alg</span><span>:</span> <span>-</span><span>257</span>}<span>,</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        ]<span>,</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span>authenticatorSelection</span><span>:</span> {</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            <span>authenticatorAttachment</span><span>:</span> <span>&#34;platform&#34;</span><span>,</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            <span>userVerification</span><span>:</span> <span>&#34;discouraged&#34;</span><span>,</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            <span>requireResidentKey</span><span>:</span> <span>true</span><span>,</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        }<span>,</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span>rp</span><span>:</span> {<span>id</span><span>:</span> <span>&#34;example.com&#34;</span><span>,</span> <span>name</span><span>:</span> <span>&#34;&#34;</span>}<span>,</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span>user</span><span>:</span> {</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            <span>id</span><span>:</span> userId<span>,</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            <span>name</span><span>:</span> <span>&#34;jsmith&#34;</span><span>,</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>            <span>displayName</span><span>:</span> <span>&#34;John Smith&#34;</span><span>,</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        }<span>,</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span>hints</span><span>:</span> [<span>&#34;client-device&#34;</span>]<span>,</span> </span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        <span>challenge</span><span>:</span> <span>new</span> <span>Uint8Array</span>([<span>0</span>])<span>.</span><span>buffer</span><span>,</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>})<span>;</span></span></code></pre></div>
<p>A consumer site, after a user clicks “Add passkey” in their account
settings:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>let</span> promise <span>=</span> <span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>create</span>({</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span>publicKey</span><span>:</span> {</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span>pubKeyCredParams</span><span>:</span> [</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>            {<span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span> <span>alg</span><span>:</span> <span>-</span><span>7</span>}<span>,</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>            {<span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span> <span>alg</span><span>:</span> <span>-</span><span>257</span>}<span>,</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        ]<span>,</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span>authenticatorSelection</span><span>:</span> {</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>            <span>userVerification</span><span>:</span> <span>&#34;discouraged&#34;</span><span>,</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>            <span>requireResidentKey</span><span>:</span> <span>true</span><span>,</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        }<span>,</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span>rp</span><span>:</span> {<span>id</span><span>:</span> <span>&#34;example.com&#34;</span><span>,</span> <span>name</span><span>:</span> <span>&#34;&#34;</span>}<span>,</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        <span>user</span><span>:</span> {</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            <span>id</span><span>:</span> userId<span>,</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>            <span>name</span><span>:</span> <span>&#34;jsmith&#34;</span><span>,</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>            <span>displayName</span><span>:</span> <span>&#34;John Smith&#34;</span><span>,</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        }<span>,</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        <span>hints</span><span>:</span> [<span>&#34;client-device&#34;</span>]<span>,</span> </span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        <span>challenge</span><span>:</span> <span>new</span> <span>Uint8Array</span>([<span>0</span>])<span>.</span><span>buffer</span><span>,</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>})<span>;</span></span></code></pre></div>
<h2 id="interpreting-the-response">Interpreting the response</h2>
<p><span id="interp-pkc"></span> When the <code>Promise</code> returned
by <code>navigator.credentials.create</code> resolves it might result in
an error. There are only three buckets of errors that need to be
considered: <code>InvalidStateError</code>, a programming error, and
everything else.</p>
<p><code>InvalidStateError</code> arises when the user attempts to use a
platform authenticator that already holds one of the credentials listed
in <code>excludeCredentials</code>. Sites may wish to report an error to
the user in this case (“This device is already registered”) or they may
validly conclude that the user wanted the local device registered, and
it is registered, therefore that’s not really an error.</p>
<p>If there’s an error in the structure of the options (e.g. a required
field is missing), or the site is attempting to use an RP ID that it
cannot use (see chapter 5), then a descriptive error will be returned.
But this is a bug in the Javascript that should be resolved during
development.</p>
<p>For privacy reasons, all other errors are essentially
indistinguishable. They will often be of type
<code>NotAllowedError</code>, and the error message may contain more
details. However the error messages are not stable and should not be
used for anything other than logging and debugging.</p>
<p>Assuming that promise resolves successfully, it returns a
<code>PublicKeyCredential</code>. Let’s take a look at what that
contains.</p>
<pre><code>interface PublicKeyCredential {
    // The credential ID.
    USVString   id;
    ArrayBuffer rawId;

    // The type of authenticator used.
    DOMString?  authenticatorAttachment;

    // More about the credential.
    AuthenticatorAttestationResponse response;

    // See extensions chapter.
    AuthenticationExtensionsClientOutputs getClientExtensionResults();
}</code></pre>
<p>Firstly, you get the credential ID. Twice! <code>id</code> contains
the credential ID as a string. Then <code>rawId</code> contains it as an
<code>ArrayBuffer</code>.</p>
<p>Where binary data is encoded in a string, WebAuthn always uses the
base64url variant of base64. This replaces the <code>+</code> and
<code>/</code> characters with <code>-</code> and <code>_</code> and
doesn’t include any <code>=</code> padding characters at the end. So the
<code>id</code> field is the base64url encoding of
<code>rawId</code>.</p>
<p>Next, <code>authenticatorAttachment</code> will probably contain
either <code>platform</code> or <code>cross-platform</code> depending on
the type of authenticator used. (The platform can omit this field if it
doesn’t know, and beware that it’s always possible that future versions
of WebAuthn will define new values.)</p>
<p>You should be expecting at least a public key too in order to be able
to use this credential, so let’s look inside <code>response</code>:</p>
<pre><code>interface AuthenticatorAttestationResponse {
    // The public key
    COSEAlgorithmIdentifier  getPublicKeyAlgorithm();
    ArrayBuffer?             getPublicKey();

    // Information from the authenticator.
    sequence&lt;DOMString&gt;      getTransports();
    ArrayBuffer              getAuthenticatorData();

    // Only used for attestation.
    ArrayBuffer              clientDataJSON;
    ArrayBuffer              attestationObject;
};</code></pre>
<p><code>getTransports</code> returns a list of strings that the site
needs to store if it’ll ever request this credential by ID. This will be
covered later, in the section about getting signatures from
credentials.</p>
<p>Next there’s <code>getAuthenticatorData</code>. This returns a binary
blob that comes directly from the authenticator. It’s returned both when
creating a credential and when getting a signature from one and is
covered in more detail later.</p>
<h5 id="getting-the-public-key">Getting the public key</h5>
<p>The public key signature scheme of the new credential is returned by
<code>getPublicKeyAlgorithm</code>. It uses the same identifiers as
<code>pubKeyCredParams</code> in the options and the value must be one
of the algorithms that was listed there. (See
<a href="#pubkeyparams">here</a>.)</p>
<p><code>getPublicKey</code> returns the public key itself in Subject
Public Key Info (SPKI) format. This is a commonly used format for public
keys, but there are so many public key formats that they get a chapter
to themselves. (Chapter 13.) SPKI format can be passed to, at least:</p>
<ul>
<li>Java’s <code>java.security.spec.X509EncodedKeySpec</code>.</li>
<li>.NET’s
<code>System.Security.Cryptography.ECDsa.ImportSubjectPublicKeyInfo</code>.</li>
<li>Go’s <code>crypto/x509.ParsePKIXPublicKey</code>.</li>
</ul>
<p>(For more obscure public key schemes, the platform might not know how
to convert the public key and so <code>getPublicKey</code> can return
<code>null</code>. That doesn’t apply to any of the common formats
discussed here but, if you’re using such a format, you’ll have to
extract the public key from the authenticator data, see chapter 7.)</p>
<p>There are more options in WebAuthn than in the U2F protocol! But we
have finally reached the core values that we expected to get when
creating a credential: the credential ID and its public key. Think back
to the introduction and recall that the other major operation is getting
a signature, where we expect to provide some credential IDs (or not,
with discoverable credentials) and a challenge value, and get back a
signature and the message that was signed, which should contain the
challenge and contextual information to prevent phishing.</p>
<p>Keep that big-picture view in mind as we dive into the second (and
final) major operation in WebAuthn.</p>
<h2 id="getting-signatures">Getting signatures</h2>
<p>Getting signatures from credentials is also performed through the
Credential Management API and looks like this:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>const</span> promise <span>=</span> <span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>get</span>({<span>publicKey</span><span>:</span> options})<span>;</span></span></code></pre></div>
<p>That’s exactly the same as creating a credential except that, rather
than <code>create</code>, the operation is <code>get</code>. Again, a
dictionary of options is passed in:</p>
<pre><code>dictionary PublicKeyCredentialRequestOptions {
    // Core parameters for getting a signature.
    required BufferSource                   challenge;
    sequence&lt;PublicKeyCredentialDescriptor&gt; allowCredentials = [];

    // The relying party ID.
    USVString rpId;

    // Whether to perform user verification.
    DOMString userVerification = &#34;preferred&#34;;

    // Controlling the platform UI. 
    unsigned long       timeout;
    sequence&lt;DOMString&gt; hints = [];

    // Extension features.
    AuthenticationExtensionsClientInputs extensions;
};</code></pre>
<p>The first option is hopefully familiar from the previous chapters.
The <code>challenge</code> makes the signature specific to a request so
that it can’t be used again. It should be a large, random value
generated at the server and stored there, temporarily, to check against
when the signature is received.</p>
<p>The <code>allowCredentials</code> is the list of credential IDs or,
if you’re using discoverable credentials, it can be empty. If you do
wish to pass a list of IDs, they’re not passed directly but rather as a
list of objects that look like this:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>[{</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>   <span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>   <span>transports</span><span>:</span> [<span>&#34;hybrid&#34;</span><span>,</span> <span>&#34;internal&#34;</span>]<span>,</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>   <span>id</span><span>:</span> <span>/* ArrayBuffer */</span><span>,</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>}]</span></code></pre></div>
<p>It’s structured just like <code>excludeCredentials</code> except for
the additional transports list. That list of transports should be copied
verbatim from the result of calling <code>getTransports</code> when
creating a credential. (See above.)</p>
<p>The <code>rpId</code> is the relying party ID. It must match the
value used when the credential was created. See chapter 5 about picking
a relying party ID.</p>
<p>The <code>userVerification</code> field is either
<code>discouraged</code>, <code>preferred</code>, or
<code>required</code>. This has the same meaning as when the credential
was created, see <a href="#uv-param">here</a>. Note that requiring user
verification when it wasn’t performed at registration time might not
work: the credential might have been created on an authenticator that
doesn’t support it. So this value will usually be the same as when the
credential was created.</p>
<p>The <code>timeout</code> and <code>hints</code> parameters also have
the same meaning as during creation, and the <code>extensions</code> get
their own chapter. And with that, we’re done. Handling the response is
more complex, however…</p>
<h3 id="interpreting-the-response-1">Interpreting the response</h3>
<p>The result of the promise from <code>get</code> might, of course, be
an error. There are no particular error cases that you need to handle,
so all errors can be treated as generic failures.</p>
<p>Otherwise the response to a signature request is also a
<code>PublicKeyCredential</code> object, but the type of the
<code>response</code> field within it is different. Here’s a recap of
the structure, which was discussed on
<a href="#interp-pkc">here</a>.</p>
<pre><code>interface PublicKeyCredential {
    // The credential ID.
    USVString   id;
    ArrayBuffer rawId;

    // The type of authenticator used.
    DOMString?  authenticatorAttachment;

    // More about the assertion.
    AuthenticatorAssertionResponse response;

    AuthenticationExtensionsClientOutputs getClientExtensionResults();
}</code></pre>
<p>This structure contains the credential ID (twice, again) which lets
you know which credential was used. If the <code>allowCredentials</code>
list was empty, this tells you who the purported user was. But, even if
it wasn’t, <code>allowCredentials</code> can contain multiple
credentials and so this tells you which to validate against.</p>
<p>The rest of the new values are contained in the <code>response</code>
field:</p>
<pre><code>interface AuthenticatorAssertionResponse {
    ArrayBuffer? userHandle;
    ArrayBuffer  signature;
    ArrayBuffer  authenticatorData;

    // Part of the signed message.
    ArrayBuffer clientDataJSON;
};</code></pre>
<p>The name of this structure is the first time that we’ve come across
the term assertion. Until now we’ve always called the thing generated
from the private key a signature. The term assertion refers to the whole
response, as defined here, and the rest of the text will only use the
word signature when specifically referring to that field.</p>
<p>An assertion contains several fields. First there’s a field called
the <code>userHandle</code>. Above, it was mentioned that the user ID is
sometimes called the user handle, and here it is! The value
unfortunately has different names in the two places that it appears in
WebAuthn, but it is the <code>user.id</code> value that was set at
creation time.</p>
<p>Note that it’s optional. There was no user ID field in the U2F
protocol when we covered it, so U2F security keys cannot possibly store
this value. In fact, non-discoverable credentials aren’t required to
store it, only discoverable ones. In either case, this field should only
be used in very particular situations:</p>
<p>The credential ID is the best identifier for a credential, but it’s
randomly generated by the authenticator. Some sites cannot support
looking up an account based on an identifier like that and must generate
the identifiers themselves. The user ID can serve that need since it’s
specified by the site but, in order to ensure that it’s always returned,
such a site must require discoverable credentials. (See also
<a href="#user-id-universe">here</a>.)</p>
<p>The next field is the <code>signature</code>. This must be validated
by the public key signature scheme used by this credential. But, to do
so, you need to construct the message that was signed. That’s where the
authenticator data comes in.</p>
<h3 id="authenticator-data">Authenticator data</h3>
<p><span id="authdata"></span> The authenticator data is so named
because it comes directly from the authenticator. Since it’s included in
the signed message, it must be exposed directly by WebAuthn: any
transformation would change the bits and cause the signature
verification to fail. So here you have to deal with a binary format; no
more Javascript objects.</p>
<p><img src="https://www.imperialviolet.org/tourofwebauthn/authdata.svg"/></p>
<p>You might notice that looks very similar to the signed message format
in the U2F protocol. That is no accident! Since this data cannot be
modified, in order to be backwards compatible the format has only been
added to since U2F. (Otherwise U2F security keys wouldn’t be
interoperable with WebAuthn.)</p>
<p>The flags are named with two-character abbreviations, as shown in the
diagram above:</p>
<ul>
<li><code>UP</code>: User Presence. (Discussed previously.)</li>
<li><code>UV</code>: User Verification. (Discussed previously.)</li>
<li><code>BE</code>: Backup Eligible. Indicates that the credential can
be backed up (i.e. is a passkey).</li>
<li><code>BS</code>: Backup State. Indicates that the credential has
been backed up. In practice, passkey providers just set both BE and BS
flags at all times. In theory, if syncing was paused, then you could see
BE set without BS, indicating that syncing was pending.</li>
<li><code>AT</code>: Attested credential data. Indicates that an
“attested credential data” structure follows. This will always be set
when creating a credential and never set when getting an assertion. (See
chapter 7.)</li>
<li><code>ED</code>: Extension Data. Indicates that a CBOR map of
extension data follows. If both AT and ED are set, then the extension
data always comes second.</li>
</ul>
<p>We are finally at the point where we can validate the
<code>signature</code>! Since WebAuthn is backwards compatible with U2F
security keys, the signed message must be compatible with what U2F did,
so it’s the concatenation of the authenticator data with the hash of the
<code>clientDataJSON</code>.</p>
<p>There are many checks that the server should make on the signed
response in order to be secure. These are covered in chapter 12. But
congratulations, you now understand the core of WebAuthn.</p>
<h2 id="client-data">Client Data</h2>
<p>We saw an example of the client data in the U2F chapter. It appears
as the <code>clientDataJSON</code> in the assertion response. Let’s look
at it again and discuss each value in more detail:</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a> <span>&#34;type&#34;</span><span>:</span> <span>&#34;webauthn.get&#34;</span><span>,</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a> <span>&#34;challenge&#34;</span><span>:</span> <span>&#34;AAECAwQFBgcICQoLDA0ODw&#34;</span><span>,</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a> <span>&#34;origin&#34;</span><span>:</span> <span>&#34;https://example.com&#34;</span><span>,</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a> <span>&#34;crossOrigin&#34;</span><span>:</span> <span>false</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h4 id="type"><code>type</code></h4>
<p>It’s good security hygiene to ensure that any signed message is
unambiguous about what it is. Many security issues have been caused by
inducing two parties in a system to have divergent views about what is
going on. So the client data uses the <code>type</code> field to specify
the context in which it should be interpreted.</p>
<h4 id="challenge"><code>challenge</code></h4>
<p>This field is the base64url encoding of the challenge specified in
the request. As discussed in the introduction, this ensures that the
signature is specific to an authentication request and doesn’t devolve
into what is effectively a password for the account that could be reused
later.</p>
<h4 id="origin"><code>origin</code></h4>
<p>The origin field specifies the entity that requested the signature,
here a URL. This prevents phishing by ensuring that the signature is
specific to the requester and cannot be proxied by a malicious site. But
the requester is not always a website. Mobile apps can also make
WebAuthn requests using platform APIs covered in chapter 11.</p>
<p>For Android apps this field will contain
<code>android:apk-key-hash:</code> followed by the base64url encoding of
the SHA-256 hash of the APK signing certificate. For iOS/iPadOS, the
origin will contain the requested RP ID with <code>https://</code>
prefixed. This is a mistake! It’s probably too late to change it now
but, because of this, it’s not possible to distinguish between requests
from apps and requests from websites with the Apple APIs.</p>
<h4 id="crossorigin"><code>crossOrigin</code></h4>
<p>This specifies whether the request came from an iframe that is not
same-origin with all its parent frames. This is obviously specific to
the web, and most sign-in pages will use the
<code>frame-ancestors</code> directive in a
<code>Content-Security-Policy</code> header to prevent ever being shown
in an iframe. But, if you need to make WebAuthn requests from an iframe,
see <a href="#iframe">here</a>.</p>
<h4 id="toporigin"><code>topOrigin</code></h4>
<p>If <code>crossOrigin</code> is true, this contains the origin of the
top-level frame, so that the server can see where the iframe was
embedded.</p>
<p>It’s important to note that these fields are not exclusive: more
fields have been added to WebAuthn over time. So a server-side validator
must be able to handle unknown fields in the JSON. But some validators
do not want to have the complexity of a full JSON parser. For them,
WebAuthn does guarantee some additional structure:</p>
<p>The fields <code>type</code>, <code>challenge</code>,
<code>origin</code>, and <code>crossOrigin</code> are guaranteed to
appear and guaranteed to appear in that order without any spaces or
newlines between the JSON tokens. If <code>crossOrigin</code> is true
then the next field is guaranteed to be <code>topOrigin</code>, again
without any spaces or newlines between tokens. All strings in this
prefix are guaranteed to be minimally escaped.</p>
<p>Any implementation taking advantage of this should carefully follow
<a href="https://www.w3.org/TR/webauthn-2/#clientdatajson-verification">these
steps</a>.</p>
<h3 id="common-patterns-of-options-1">Common patterns of options</h3>
<p>A site using discoverable credentials:</p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span>let</span> promise <span>=</span> <span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>get</span>({</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span>publicKey</span><span>:</span> {</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>        <span>challenge</span><span>:</span> <span>new</span> <span>Uint8Array</span>([</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>            <span>// Must be a cryptographically-random number sent</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>            <span>// by the server</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>            <span>0x79</span><span>,</span> <span>0x50</span><span>,</span> <span>0x68</span><span>,</span> <span>0x71</span><span>,</span> <span>0xDA</span><span>,</span> <span>0xEE</span><span>,</span> <span>0xEE</span><span>,</span> <span>0xB9</span><span>,</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>            <span>0x94</span><span>,</span> <span>0xC3</span><span>,</span> <span>0xC2</span><span>,</span> <span>0x15</span><span>,</span> <span>0x67</span><span>,</span> <span>0x65</span><span>,</span> <span>0x26</span><span>,</span> <span>0x22</span><span>,</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>            <span>0xE3</span><span>,</span> <span>0xF3</span><span>,</span> <span>0xAB</span><span>,</span> <span>0x3B</span><span>,</span> <span>0x78</span><span>,</span> <span>0x2E</span><span>,</span> <span>0xD5</span><span>,</span> <span>0x6F</span><span>,</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>            <span>0x81</span><span>,</span> <span>0x26</span><span>,</span> <span>0xE2</span><span>,</span> <span>0xA6</span><span>,</span> <span>0x01</span><span>,</span> <span>0x7D</span><span>,</span> <span>0x74</span><span>,</span> <span>0x50</span><span>,</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        ])<span>.</span><span>buffer</span><span>,</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    }<span>,</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>})<span>;</span></span></code></pre></div>
<p>An enterprise site, requesting that an employee authenticate with
their issued security key:</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span>let</span> promise <span>=</span> <span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>get</span>({</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span>publicKey</span><span>:</span> {</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span>allowCredentials</span><span>:</span> [{</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>          <span>type</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>          <span>id</span><span>:</span> <span>new</span> <span>Uint8Array</span>([</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>              <span>0x94</span><span>,</span> <span>0x38</span><span>,</span> <span>0x2b</span><span>,</span> <span>0x37</span><span>,</span> <span>0xbf</span><span>,</span> <span>0x38</span><span>,</span> <span>0xc0</span><span>,</span> <span>0x05</span><span>,</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>              <span>0x9a</span><span>,</span> <span>0xbd</span><span>,</span> <span>0x16</span><span>,</span> <span>0x09</span><span>,</span> <span>0xdd</span><span>,</span> <span>0xf5</span><span>,</span> <span>0xd7</span><span>,</span> <span>0x0c</span><span>,</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>          ])<span>.</span><span>buffer</span><span>,</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>          <span>transports</span><span>:</span> [<span>&#34;usb&#34;</span>]<span>,</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        }]<span>,</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span>challenge</span><span>:</span> <span>new</span> <span>Uint8Array</span>([</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>            <span>// Must be a cryptographically-random number sent</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>            <span>// by the server</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>            <span>0x79</span><span>,</span> <span>0x50</span><span>,</span> <span>0x68</span><span>,</span> <span>0x71</span><span>,</span> <span>0xDA</span><span>,</span> <span>0xEE</span><span>,</span> <span>0xEE</span><span>,</span> <span>0xB9</span><span>,</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>            <span>0x94</span><span>,</span> <span>0xC3</span><span>,</span> <span>0xC2</span><span>,</span> <span>0x15</span><span>,</span> <span>0x67</span><span>,</span> <span>0x65</span><span>,</span> <span>0x26</span><span>,</span> <span>0x22</span><span>,</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>            <span>0xE3</span><span>,</span> <span>0xF3</span><span>,</span> <span>0xAB</span><span>,</span> <span>0x3B</span><span>,</span> <span>0x78</span><span>,</span> <span>0x2E</span><span>,</span> <span>0xD5</span><span>,</span> <span>0x6F</span><span>,</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>            <span>0x81</span><span>,</span> <span>0x26</span><span>,</span> <span>0xE2</span><span>,</span> <span>0xA6</span><span>,</span> <span>0x01</span><span>,</span> <span>0x7D</span><span>,</span> <span>0x74</span><span>,</span> <span>0x50</span><span>,</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>        ])<span>.</span><span>buffer</span><span>,</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    }<span>,</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>})<span>;</span></span></code></pre></div>
<h2 id="threats">Threats</h2>
<p>Keep in mind that WebAuthn is only about authentication. If you
authenticate yourself on a machine that is controlled by malware, then
the malware has all the same authority that you do. At best, some sites
require frequent reauthentication with WebAuthn so that the malware
can’t exfiltrate long-lived cookies and has to remain active on the
compromised machine. That increases the attacker’s costs, but is no
silver bullet.</p>
<p>In the introduction we mentioned that Javascript injected into a site
could steal passwords. WebAuthn certainly stops passwords from being
stolen by removing the need to enter them. But, similar to the malware
case, if the malicious Javascript controls the origin context in the
browser, it can make authenticated HTTP requests just as if it were the
user. It’s certainly a lot less convenient for the attacker than
exfiltrating a password, but an attack is still possible.</p>
<p>Lastly, many sites add WebAuthn as an authentication method alongside
a password. But, as long as the password is still a valid way to sign
in, a phishing site can try to get the user to enter it by pretending
that WebAuthn isn’t working. The ultimate goal must be to remove
passwords from accounts. The “backup state” flag in the authenticator
data reports whether a credential has been backed up and, if an account
has a backed-up credential, and the user has a history of successfully
using it, perhaps prompt them to disable their password.</p>
<p>It’s still the case that passwords cause a lot of problems and we
should try to address them. WebAuthn is by far the best prospect in that
direction and the world would be much better off if it succeeds. But
magical thinking only leads to disappointment, and WebAuthn isn’t
magic.</p>

<p>As discussed in the previous chapter, relying party IDs (RP IDs)
identify sites and prevent the use of credentials between them.</p>
<p>This happens to result in some degree of phishing protection, but
this mechanism is not designed to prevent phishing. Phishing is stopped
by the <code>origin</code> field in the client data, which goes into the
signed message. RP IDs, on the other hand, are:</p>
<ol type="1">
<li>A constraint to prevent credentials from being used too widely.
WebAuthn deliberately does not want people to have a single credential
that is used everywhere.</li>
<li>A way to filter candidate discoverable credentials so that a user is
only shown a list of applicable accounts to choose from.</li>
<li>A way to prevent other sites from obtaining any secrets linked to
the credential. (See <a href="#prf">here</a>.)</li>
</ol>
<p>RP IDs are “domain shaped” rather than “URL shaped”. E.g.
<code>example.com</code> is an RP ID, but
<code>https://example.com</code> is not.</p>
<p>(The U2F Javascript API, which was mentioned in chapter 2, did use
URL-shaped values as RP IDs, which it called AppIDs. That has an impact
on WebAuthn in the form of the <code>appid</code> and
<code>appidExclude</code> extensions, which are covered on
<a href="#appid">here</a>. But otherwise AppIDs are irrelevant now.)</p>
<p>Every operation has an RP ID associated with it, whether it’s using
the WebAuthn API or one of the platform APIs. While an API may pick a
default RP ID if one isn’t specified, it’s always possible to request a
specific RP ID, and so every API defines a way of validating whether a
website or app is allowed to request a specific RP ID.</p>
<p>For WebAuthn, the default RP ID is the domain of the current origin.
So for <code>https://example.com</code> the default RP ID is
<code>example.com</code>. WebAuthn allows an origin to claim any RP ID
that can be formed by discarding zero or more “labels” from the left of
its domain name until it hits an <a href="https://en.wikipedia.org/wiki/Public_Suffix_List">effective
TLD</a>. A label in a domain name is a substring delimited by periods.
So for <code>www.example.com</code>, the labels are <code>www</code>,
<code>example</code>, and <code>com</code>. (Plus the empty label at the
end to represent the root, but we’ll ignore that.)</p>
<p>An effective TLD is an effective top-level domain. That is either a
top-level domain, like <code>com</code>, or a domain that acts like a
top-level domain and is listed in the <a href="https://publicsuffix.org/">Public Suffix List</a>, like
<code>co.uk</code>.</p>
<p>So say that the current origin
is <code>https://www.example.co.uk</code>: it can specify an RP ID
of <code>www.example.co.uk</code> (discarding zero
labels), <code>example.co.uk</code> (discarding one label), but
not <code>co.uk</code> because that’s an effective TLD. It also couldn’t
specify an RP ID of <code>example.com</code> because that’s a different
site: that domain cannot be formed simply by discarding labels from the
left of <code>www.example.co.uk</code>.</p>
<p>Note: There is no relationship between similar-looking RP IDs beyond
WebAuthn’s rules for which origins can claim which RP IDs. So
<code>www.example.co.uk</code> is as different to
<code>example.co.uk</code> as to <code>example.org</code>. Recall that
RP IDs are hashed before being sent to U2F security keys, enforcing that
all internal structure is irrelevant.</p>
<h3 id="android">Android</h3>
<p><span id="rp-id-mobile"></span> Android checks whether a given app is
allowed to use an RP ID by treating the RP ID as a domain name and
fetching <code>https://example.com/.well-known/assetlinks.json</code>.
This needs to be a JSON file in the Digital Asset Links format, which
broadly attempts to describe the relations between different
entities.</p>
<p>Note: In fact, it’s incorrect to say that “Android” checks this
because the check is actually performed by the passkey provider handling
the request. Google Password Manager, which ships as part of Play
Services, uses <code>assetlinks.json</code> and has defined the norm on
that platform, but, technically, other password managers could decide to
do something different.</p>
<p>The <code>assetlinks.json</code> file needs to contain JSON similar
to the following:</p>
<div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span>[</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span>{</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span>&#34;relation&#34;</span> <span>:</span> <span>[</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>      <span>&#34;delegate_permission/common.handle_all_urls&#34;</span><span>,</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>      <span>&#34;delegate_permission/common.get_login_creds&#34;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span>]</span><span>,</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span>&#34;target&#34;</span> <span>:</span> <span>{</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>      <span>&#34;namespace&#34;</span> <span>:</span> <span>&#34;android_app&#34;</span><span>,</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>      <span>&#34;package_name&#34;</span> <span>:</span> <span>&#34;PACKAGE_NAME&#34;</span><span>,</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>      <span>&#34;sha256_cert_fingerprints&#34;</span> <span>:</span> <span>[</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        <span>&#34;APK_CERTIFICATE_FINGERPRINT&#34;</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>      <span>]</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span>]</span></span></code></pre></div>
<p>The <code>PACKAGE_NAME</code> placeholder should be replaced with the
name of the Android package, e.g. <code>com.example.myapp</code>. The
<code>APK_CERTIFICATE_FINGERPRINT</code> should be replaced with a
hex-with-colons encoded, SHA-256 hash of the APK signing certificate.
You can get this value from an APK with:</p>
<div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span>keytool</span> <span>-list</span> <span>-printcert</span> <span>-jarfile</span> app.apk</span></code></pre></div>
<p>Or you can run <code>./gradlew signingReport</code> in your build
directory. Either way, the fingerprint value must separate each pair of
hex digits with a colon, like <code>ab:cd:12:34:...</code>.</p>
<p>This JSON object should be replicated for each app that needs access
to the RP ID. When doing so, consider that this is declaring a
significant level of trust for each listed app. Not only can they use
the RP ID, but saved passwords may be shared between these apps and the
website too.</p>
<p>Currently, the only relation needed is
<code>delegate_­permission/common.­handle_­all_­urls</code>, but Google
hopes to transition to the more specific
<code>delegate_­permission/common.­get_­login_­creds</code> relation in the
future and currently documents that apps should list both.</p>
<p>The <code>assetlinks.json</code> is currently not allowed to be
behind a redirect. So, if <code>https://example.com</code> just serves
redirects to <code>https://www.example.com</code> then that won’t work.
To debug issues, run:</p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span>curl</span> <span>&#39;https://digitalassetlinks.googleapis.com/v1/assetlinks:check?source.web.site=https://example.com&amp;relation=delegate_permission/common.handle_all_urls&amp;target.android_app.package_name=PACKAGE_NAME&amp;target.android_app.certificate.sha256_fingerprint=APK_CERTIFICATE_FINGERPRINT&#39;</span></span></code></pre></div>
<p>Remember to replace <code>PACKAGE_NAME</code> and
<code>APK_CERTIFICATE_FINGERPRINT</code> with the same values as in the
JSON above.</p>
<p>To see an example of an <code>assetlinks.json</code> file, try
fetching it for a commonly-known site. E.g.
<code>https://amazon.com/.well-known/assetlinks.json</code>.</p>
<h3 id="apple-platforms">Apple platforms</h3>
<p>The Apple platforms use a similar system of <code>.well-known</code>
files in order to decide which apps are allowed to use a given RP ID.
For Apple devices, the file is
<code>https://example.com/.well-known/apple-app-site-association</code>
and it should include something like this:</p>
<div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span>&#34;webcredentials&#34;</span><span>:</span> <span>{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>      <span>&#34;apps&#34;</span><span>:</span> <span>[</span> <span>&#34;T7AYYU7S6A.example.com.YourApp&#34;</span> <span>]</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>   <span>}</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>The first label of the app identifier (<code>T7AYYU7S6A</code> in the
example) is your “Team ID”. You can find this under “Membership details”
on <code>https://developer.apple.com/account</code>. The rest is the
“bundle identifier” for your app, which is set when the project is
created.</p>
<p>Requests for this file will come from Apple’s servers by default but,
for testing, it’s possible to enable “Associated Domains Development” in
the Developer menu on iOS. (But only, it seems, on devices. The option
doesn’t appear in the simulator.) If you want to see what Apple’s
servers see for your domain, fetch
<code>https://app-site-association.cdn-apple.com/a/v1/example.com</code>.</p>
<p>An app also needs to list <code>webcredentials:example.com</code> as
a domain in the “Associated Domains” capability.</p>
<p>If you change your site association file, delete the app and
reinstall to ensure that any caches are updated on the device.</p>
<h3 id="browsers-and-other-privileged-apps">Browsers and other
privileged apps</h3>
<p>Browsers have to be special. Consider what would happen if you
browsed to <code>https://example.com</code> on a phone and tried to use
a passkey to sign in. Using just the rules specified above, example.com
would have to authorize every possible browser app to use its RP ID.</p>
<p>This would be untenable, so browsers have to be trusted to act as any
RP ID. There are processes run by both Apple and Google to recognize
trusted browser apps for this purpose.</p>
<p>Note: As with <code>assetlinks.json</code>, the set of recognized
browsers on Android is just a norm established by Google Password
Manager, which publishes its list of trusted browsers at
<code>https://gstatic.com/gpm-passkeys-privileged-apps/apps.json</code>.
Other password managers on Android tend to follow this norm.</p>
<h2 id="considerations-when-choosing-an-rp-id">Considerations when
choosing an RP ID</h2>
<p>It’s important to carefully consider RP IDs from the outset. Let’s
take the example of <code>https://www.example.co.uk</code>. That site
might happily be creating credentials with its default RP ID
(<code>www.example.co.uk</code>) but later decide that it wants to move
all sign-in activity to an isolated origin,
<code>https://accounts.example.co.uk</code>. But none of its credentials
could be used from that origin. It could discard a label from the left
to form <code>example.co.uk</code>, but the rules don’t allow any labels
to be prepended, so <code>www.example.co.uk</code> isn’t a valid RP ID
for that origin. The site would have needed to create credentials with
an RP ID of <code>example.co.uk</code> from the outset.</p>
<p>But the rule is not to always use the most general RP ID possible.
Going back to our example,
if <code>https://usercontent.example.co.uk</code> existed to host
uploaded content, then pages on that origin could create credentials
with an RP ID of <code>example.co.uk</code>. We can assume
that <code>accounts.example.co.uk</code> is checking the origin of any
assertions, so <code>usercontent.example.co.uk</code> can’t use its
ability to set an RP ID of <code>example.co.uk</code> to generate valid
signatures, but it can still try to get the user to create new
credentials which could overwrite the legitimate ones. It can also get
any secrets associated with the credentials because it can assert them.
(See <a href="#prf">here</a>.)</p>
<p>All this means that the choice of RP ID needs to be considered
carefully at the beginning of any deployment.</p>

<p>As described above, you have a lot more freedom with the native APIs
than you do on the web. With the native APIs, you can nominate many apps
to be able to use your RP ID, but the rules on the web don’t allow any
other website, even with permission, to use another site’s RP ID.</p>
<p>Not all websites fit into that structure. Some are spread across
country code top-level domains and exist as <code>example.com</code>,
<code>example.de</code>, <code>example.in</code>, etc. But with the
rules above, none of those country-specific instances of the site could
share credentials. Sometimes two different brands are intimately linked,
but have separate websites, like Hilton and DoubleTree.</p>
<p>Probably the best option in this case is to use a single origin to
handle all sign-ins, and use a federation protocol like <a href="https://openid.net/developers/how-connect-works/">OpenID
Connect</a> on the related sites. But not all websites can do that, thus
the RP ID rules for the web were relaxed somewhat with the introduction
of related origins. When a WebAuthn request specifies an RP ID that
would not be permitted under the rules above, browsers that implement
related origins will attempt to fetch a document hosted at the following
URL.</p>
<pre><code>https://example.com/.well-known/webauthn</code></pre>
<p>If it exists, and has the MIME type <code>application/json</code>,
then it is parsed as JSON and can contain something like the
following.</p>
<pre><code>{
    &#34;origins&#34;: [
        &#34;https://example.com&#34;,
        &#34;https://example.co.uk&#34;,
        &#34;https://example.in&#34;,
        &#34;https://www.example.in&#34;,
        &#34;https://otherbrand.com&#34;
    ]
}</code></pre>
<p>If the origin that made the WebAuthn request is listed as one of the
permitted origins in that document, then the request will be allowed to
continue. However, there are limits on how many origins can be listed
like that:</p>
<p>For each listed origin, its eTLD+1 label is extracted from its domain
name. The eTLD+1 label is the rightmost label that is not part of the
effective TLD. For the example origins above:</p>
<table>
<thead>
<tr>
<th>Origin</th>
<th>eTLD+1 label</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>https://example.com</code></td>
<td><code>example</code></td>
</tr>
<tr>
<td><code>https://example.co.uk</code></td>
<td><code>example</code></td>
</tr>
<tr>
<td><code>https://example.in</code></td>
<td><code>example</code></td>
</tr>
<tr>
<td><code>https://www.example.in</code></td>
<td><code>example</code></td>
</tr>
<tr>
<td><code>https://otherbrand.com</code></td>
<td><code>otherbrand</code></td>
</tr>
</tbody>
</table>
<p>The maximum number of distinct eTLD+1 labels currently permitted by
browsers is five. So for sites that are spread across many country-code
top-level domains, all of those domains only count as one label. But if
you have many different brands, then you could quickly hit the
limit.</p>

<p>Chapter 2 covered the protocol for communicating with U2F security
keys, but that protocol doesn’t support discoverable credentials, user
verification, or many other features of WebAuthn. So a new protocol for
communicating with security keys was needed: CTAP2. (Computer To
Authenticator Protocol Two; the U2F protocol can be considered to be
CTAP1.)</p>
<p>CTAP2 is a significantly more complex protocol which involves the
computer and security key exchanging messages encoded in a format called
CBOR. This use of CBOR breaks through into WebAuthn in several places
so, even if you’re going to skip most of this chapter, a familiarity
with CBOR will be valuable.</p>
<h2 id="cbor">CBOR</h2>
<p>CBOR officially stands for “Concise Binary Object Representation”,
but the lead author’s name is C. Bormann, which might have had more to
do with it. It is described in <a href="https://www.rfc-editor.org/rfc/rfc8949.html">RFC 8949</a> and is a
MsgPack-inspired format in the family of “binary JSONs”.</p>
<p>CTAP2 (and thus WebAuthn) only uses a subset of CBOR, which will be
described here. CBOR used in CTAP2 and WebAuthn must conform to this
subset, so beware of using generic CBOR libraries for encoding as they
may not stay within it.</p>
<p>Each CBOR value (called a data item) starts with a leading byte. The
most-significant three bits specify the major type from zero to seven.
The value of the five least-significant bits specifies how to calculate
the argument:</p>
<ul>
<li>≤23: the argument is the value of the five least significant
bits.</li>
<li>24: the argument is taken from the following byte.</li>
<li>25: the argument is taken from the following two bytes, in
big-endian order.</li>
<li>26: the argument is taken from the following four bytes, in
big-endian order.</li>
<li>27: the argument is taken from the following eight bytes, in
big-endian order.</li>
<li>≥ 28: invalid in CTAP2.</li>
</ul>
<p>The argument is then interpreted depending on the value of the major
type:</p>
<ul>
<li>0: the argument is an unsigned integer.</li>
<li>1: the argument is a negative integer formed by adding one to the
value and negating. Thus an argument of 19 represents -20.</li>
<li>2: a byte string. The argument specifies the number of following
bytes that make up the byte string.</li>
<li>3: a text string: The argument specifies the number of following
bytes that are a UTF-8 encoded string. (But see below because text
strings aren’t always valid UTF-8 in CTAP2.)</li>
<li>4: an array. The argument specifies the number of following data
items in the array.</li>
<li>5: a map. The argument specifies the number of pairs of data items
that follow. The first value in each pair is a key, and the second is
the corresponding value.</li>
<li>6: invalid in CTAP2</li>
<li>7: the argument is either 20 to represent the <code>false</code>
value or 21 to represent <code>true</code>. All other values are invalid
in CTAP2.</li>
</ul>
<p>There are some additional rules applied to ensure that the CBOR is
canonically encoded. I.e. that a given CBOR message has exactly one
valid encoding:</p>
<ol type="1">
<li>Arguments must be encoded in the fewest possible bytes. So the value
10 is always encoded in a single byte and a byte string of length 10
never encodes that length with any additional bytes.</li>
<li>The pairs of data items in a map are sorted by key. Lower major
types sort first with ties resolved in favor of shorter keys. If two
keys have the same major type and length, then they are compared
lexicographically. (Two identical keys cannot appear in a map.)</li>
</ol>
<p>This canonical form is the same as the <a href="https://datatracker.ietf.org/doc/html/rfc8949#name-core-deterministic-encoding">Core
Deterministic Encoding Requirements</a> from the CBOR RFC, since only
integers and strings appear as map keys in CTAP2, but it is not the same
as the “Canonical CBOR” section of the older RFC 7049.</p>
<p>Note: Since security keys are either impossible or very difficult to
update, and often under significant code-size pressure, using canonical
encodings minimizes interoperability problems.</p>
<p>In the underlying CBOR data model, integers are signed, 65-bit
values. However, since support for 65-bit integers is rare in
programming languages, treating integers as signed 64-bit values is
always sufficient in CTAP2.</p>
<p>One point about UTF-8 strings is worth keeping in mind. Security keys
are embedded devices with limited storage and CPU. WebAuthn allows sites
to specify arbitrary strings for things like user names, which security
keys have to store (at least for discoverable credentials). Since
storage is limited, security keys are allowed to truncate overly-long
strings. However, when they do that truncation, they often do so after a
fixed number of bytes, which may fall in the middle of a multi-byte
UTF-8 sequence. Thus, when that string is returned in response to a
future operation, the UTF-8 will be invalid. Platforms have to make
accommodations for this because that makes the CBOR from security keys
technically invalid and standard CBOR parsers will reject it.</p>
<h2 id="commands-and-responses">Commands and responses</h2>
<p>Commands in CTAP2 consist of a single byte to identify the command,
followed by a CBOR map with all the parameters. Responses consist of a
single-byte response code which is either non-zero, representing an
error, or zero for success. Successful responses are optionally followed
by a CBOR map with details of the response.</p>
<p>Let’s look at the first command sent to a CTAP2 security key:
<code>authen­tica­tor­Get­Info</code>. It’s command number four, and it
doesn’t have any parameters, so the whole command is a single byte with
value 0x04. The response will consist of a zero byte (to indicate
success) followed by a CBOR map. Let’s look at the contents of that map
(translated into CBOR’s diagnostic notation) to get a feel for the
protocol. <span id="getinfo"></span></p>
<p>(There’s a lot here, you don’t need to understand everything. It’s
just to give a sketch of all that’s contained in CTAP2.)</p>
<pre><code>{
  # Supported protocol revisions
  1: [&#34;FIDO_2_0&#34;, &#34;FIDO_2_1_PRE&#34;, &#34;FIDO_2_1&#34;],
  # Supported extensions.
  2: [
       &#34;credProtect&#34;,
       &#34;hmac-secret&#34;,
       &#34;largeBlobKey&#34;,
       &#34;credBlob&#34;,
       &#34;minPinLength&#34;
  ],
  # The AAGUID of the security key. This identifies the make &amp; model
  # of security key. 
  3: h&#39;D8522D9F575B486688A9BA99FA02F35B&#39;,
  4: {
    # Supports discoverable credentials.
    &#34;rk&#34;: true,
    # Supports user presence tests.
    &#34;up&#34;: true,
    # Supports user verification, but it&#39;s not configured.
    &#34;uv&#34;: false,
    # Is not a platform authenticator.
    &#34;plat&#34;: false,
    # Not actually an official option! 
    &#34;uvToken&#34;: true,
    # The security key will do user verification for all operations.
    &#34;alwaysUv&#34;: true,
    # Supports listing and deleting discoverable credentials.
    &#34;credMgmt&#34;: true,
    # Supports the `authenticatorConfig` CTAP2 command.
    &#34;authnrCfg&#34;: true,
    # Has a biometric sensor, but it&#39;s not configured.
    &#34;bioEnroll&#34;: false,
    # Supports PIN entry on the computer.
    &#34;clientPin&#34;: true,
    # Supports the largeBlob extension.
    &#34;largeBlobs&#34;: true,
    # Supports tokenized user verification.
    &#34;pinUvAuthToken&#34;: true,
    # Supports configuring the minimum PIN length.
    &#34;setMinPINLength&#34;: true,
    # Doesn&#39;t support creating credentials without user verification.
    &#34;makeCredUvNotRqd&#34;: false,
    # Whether the authenticator supports older versions of a couple
    # of commands.
    &#34;credentialMgmtPreview&#34;: true,
    &#34;userVerificationMgmtPreview&#34;: false
  },
  # Maximum command size, in bytes.
  5: 1200,
  # User verification token protocol versions, in preference order.
  6: [2, 1],
  # Maximum number of credential IDs that can be included in a
  # single command
  7: 8,
  # The maximum length of a credential ID from this security key.
  8: 128,
  # The list of supported transports.
  9: [&#34;usb&#34;],
  # The list of supported signature schemes: ECDSA with P-256
  # and Ed25519.
  10: [
     {&#34;alg&#34;: -7, &#34;type&#34;: &#34;public-key&#34;},
     {&#34;alg&#34;: -8, &#34;type&#34;: &#34;public-key&#34;}
  ],
  # Maximum largeBlob array.
  11: 1024,
  # The current PIN doesn&#39;t have to be changed immediately.
  12: false,
  # The minimum PIN length.
  13: 4,
  # Firmware version.
  14: 328966,
  # Maximum length of a credBlob value.
  15: 32,
  # Number of RP IDs that can be configured to receive the minimum
  # PIN length.
  16: 1,
  # Number of biometric attempts that can fail before falling back
  # to using a PIN.
  17: 3,
  # The type of biometric sensor used: a fingerprint reader
  18: 2,
  # How many more discoverable credentials can the security key store.
  20: 25
}</code></pre>
<p>A few patterns of the protocol are demonstrated here: the top-level
keys in the CBOR maps are integers for compactness, but strings can be
used to identify things too. Sometimes WebAuthn Javascript structures
are transliterated into CBOR: key 10 clearly mirrors the
<code>pubKeyCredParams</code> structure which should be familiar from
chapter 4. Lastly, it’s obviously a lot more complex than U2F!</p>
<p>We won’t be covering every corner of CTAP2 in this book; instead
we’ll be focusing on some of the higher-level concepts. The FIDO
Alliance publishes the <a href="https://fidoalliance.org/specs/fido-v2.2-rd-20230321/fido-client-to-authenticator-protocol-v2.2-rd-20230321.html">CTAP2
specification</a> if you want all the details.</p>
<p>If you want to see the <code>authenticatorGetInfo</code> response for
a given CTAP2 security key, do an operation with it in Chrome on macOS
or Linux and then open <code>chrome://device-log</code>. It’ll be logged
there along with other details of the request.</p>
<h2 id="user-verification-2">User verification</h2>
<p>User verification is one of the headline features of CTAP2. But
performing a single WebAuthn operation can require many CTAP2 commands,
in the same way that it required many U2F messages. So the platform has
to ask the security key to verify the user, and the security key returns
a secret value to the platform to represent that verification, which the
platform uses as an HMAC key to authenticate all the commands to which
that verification applies. The platform is then trusted to discard the
token (although there are limits, as we’ll see).</p>
<p>There are broadly two forms of user verification supported in CTAP2.
Either the user verification is built into the security key itself (with
a fingerprint reader or a PIN pad), or user verification is done by
entering a PIN on the computer and sending it to the security key to be
checked. The CTAP2 spec refers to the computer as the “client” and thus
the latter pattern is called client PIN.</p>
<p>The former is more secure because it eliminates the risk of the PIN
being captured while it is entered on the computer. But a client PIN
allows for security keys to be simpler and cheaper.</p>
<h3 id="pin-protocols">PIN protocols</h3>
<p>CTAP2 does not expose PINs and user verification tokens as plaintext
in the protocol. While that’s not a huge concern for USB-connected
security keys, security keys can also work via NFC. So the computer and
security key perform an elliptic-curve Diffie–Hellman (ECDH) key
agreement whenever UV is used in order to mutually calculate a secret
key to encrypt any PINs and tokens with.</p>
<p>The PIN protocol (which, despite the name, is also used for built-in
user verification methods to protect the resulting token) specifies the
key agreement, encryption, and authentication primitives to use. There
are only two defined by CTAP2 and the second is just a tweak of the
first to make it easier to certify under NIST’s FIPS 140 programs. The
second version is now required to be implemented by security keys and so
will slowly replace the first. That’s what will be described here.</p>
<h3 id="client-pin">Client PIN</h3>
<p>In the <code>authenticatorGetInfo</code> response above, both
<code>clientPin</code> and <code>pinUvAuthToken</code> are true, which
means that the security key has a PIN set and supports getting a token
to represent a user verification. To get this token, the platform would
do the following:</p>
<ol type="1">
<li>Ask the user to enter their PIN.</li>
<li>Hash it with SHA-256.</li>
<li>Send an <code>authenticatorClientPIN</code> command to get an
ephemeral ECDH value from the security key.</li>
<li>Send another <code>authenticatorClientPIN</code> with its own ECDH
value and 16 bytes of the hashed PIN, encrypted with the mutual shared
secret from the ECDH calculation.</li>
</ol>
<p>The security key decrypts the PIN hash and compares it against the
correct value. The security key can enforce a maximum number of attempts
but, if it’s satisfied, it encrypts a random value, called a PIN/UV
Authentication Token (PUAT), and returns it to the platform.</p>
<p>Now that the platform has the PUAT, it can use it as an HMAC key to
authenticate future commands. When it requested the PUAT, the platform
had to specify what type of commands it was planning to use it for, and
the relying party ID for all those commands. Thus, even if the PUAT
leaks, its scope is limited.</p>
<p>That doesn’t make a lot of difference if UV is implemented with
client PIN because a misbehaving platform could just save the PIN
itself, and obtain as many PUATs as it needed. But when user
verification is built into the security key, it does limit the abilities
of misbehaving platforms a little.</p>
<p>Getting a PUAT from a security key that has a built-in method of user
verification, like a fingerprint reader, looks very similar, but there’s
no encrypted PIN in the request. In contrast with U2F, CTAP2 security
keys don’t have to immediately respond to commands and so can take their
time, flashing and waiting for the user to present their
fingerprint.</p>
<p>However, security keys with fingerprint readers will often have a
client PIN too because fingerprint readers can be temperamental.</p>
<h2 id="making-credentials-and-getting-assertions">Making credentials
and getting assertions</h2>
<p>Having covered these operations in detail in chapter 4, there is not
much more that needs to be said about them here, because the CTAP2
commands for these operations simply transliterate most of the WebAuthn
structures into CBOR.</p>
<p>The complexity of implementing these operations in CTAP2 comes from
the fact that the size of the commands can exceed the message buffer of
the security key. If you look at the example
<code>authenticatorGetInfo</code> result above, key 5 specifies the
maximum number of bytes in a command, but the
<code>excludedCredentials</code> list in a <code>create()</code>
operation, or the <code>allowCredentials</code> list in a
<code>get()</code>, can be arbitrarily long. While it’s unusual, it’s
valid to have 50 credential IDs, each of which are 100 bytes. That would
exceed the message buffer of nearly any security key.</p>
<p>The <code>authenticatorGetInfo</code> result specifies the maximum
length of a credential ID that the security key will generate (in key
8). So any credential IDs longer than this can be discarded by the
platform when interacting with this security key, potentially reducing
the problem but the core issue remains.</p>
<p>So, after doing that filtering, the platform needs to split up the
list of credential IDs into batches such that no batch causes a command
to be too long. It will then probe for credential IDs with these
batches, very much like the U2F protocol, until it finds a batch where
one of the credential IDs was recognized by the security key. Each of
these probe messages sets the <code>up</code> (user presence) flag to
false, so that no physical interaction with the security key is
needed.</p>
<p>Things get particularly complicated when user verification interacts
with the <code>appId</code> extension (see <a href="#appid">here</a>)
but these are details that only platform implementers need to concern
themselves with, and so we won’t cover them here.</p>
<h3 id="management-commands">Management commands</h3>
<p>CTAP2 also includes a number of commands that aren’t directly used
for implementing WebAuthn operations, but it’s still useful to be aware
of them.</p>
<h4 id="reset">Reset</h4>
<p><span id="reset"></span> Security keys support being reset. This
erases all credentials and configuration, and rotates any root secret
for stateless credentials such that they are invalidated. For obvious
reasons, this is a dangerous command! Thus, security keys don’t always
support this command over NFC if they also support USB and, over USB,
this command is only valid within a few seconds of inserting the
security key.</p>
<h4 id="fingerprint-enrollment">Fingerprint enrollment</h4>
<p>CTAP2 allows the platform to drive fingerprint enrollment and to
manage fingerprint templates. The enrollment process is like that for
any fingerprint reader: you have to press your finger repeatedly on the
sensor until it has gathered enough data to compute a template that it
can later match against. The security key can return a series of status
messages (“finger too far to the left”, “finger wasn’t pressed for long
enough”, etc) for the platform to report back to the user.</p>
<p>The <code>authenticatorBioEnrollment</code> command also allows the
platform to list and delete any existing templates, each of which can
have a “friendly name” set so that the user can identify them.</p>
<h4 id="credential-management">Credential management</h4>
<p>The <code>authenticatorCredentialManagement</code> lets the platform
list the RP IDs of all the discoverable credentials on a security key.
Then, for a given RP ID, it lets the platform list each discoverable
credential recorded, including the user information. Discoverable
credentials can be deleted, and the user information can be updated.</p>
<h4 id="miscellaneous-configuration">Miscellaneous configuration</h4>
<p><span id="authenticator-config"></span> The
<code>authenticatorConfig</code> command allows a number of
miscellaneous features to be controlled:</p>
<ul>
<li>Enterprise attestation (see
<a href="#enterprise-attestation">here</a>) can be turned on and
off.</li>
<li>If the security key supports it, the policy to require user
verification for every operation can be turned on and off.</li>
<li>The set of RP IDs that can query for the minimum PIN length (see
<a href="#min-pin-length">here</a>) can be set.</li>
</ul>

<p>If a company has distributed security keys to its employees in order
to protect authentication to its corporate resources, it might want to
know if those employees are actually using them and not others. It might
even want to know that they are using the precise security key that was
inventory tracked and assigned to them. That is what attestation is
for.</p>
<p>Nearly all security keys ship from the factory with an attestation
private key included within them. Unlike every other private key that we
have dealt with so far, it is not generated on demand and it is not
specific to any given credential; it is global to the security key. When
you create a credential in these security keys, they will sign over the
resulting public key with their attestation private key to show that the
newly generated key was generated within that security key.</p>
<p>This creates a tension: if the attestation private key were specific
to the security key then all credentials generated in that security key
could be correlated across RPs. But if the same private key were used in
lots of security keys then the potential would exist for an attacker to
extract it from another security key of the same model, and so the
security of the attestation private key would be reduced.</p>
<p>FIDO balanced this tension by requiring that attestation private keys
must be used over a batch of at least 100 000 security keys. So they do
not uniquely identify an individual security key, they instead identify
a large batch of them and so convey only the make and model of the
security key. Correspondingly, this means that if you have the right
(expensive) equipment, you could buy a security key from that batch and
extract the attestation private key. (And some security keys don’t sell
well enough to ever have a full 100 000-unit batch and, for those, the
privacy is proportionally limited.)</p>
<p>For cases where this level of attestation is insufficient, and the
attestation private key really needs to be specific to a security key,
the concept of “enterprise attestation” was created, which allows this
in a restricted fashion.</p>
<h2 id="getting-attestation">Getting attestation</h2>
<p>WebAuthn does not provide attestation by default; it’s assumed that
most sites will not want it. To request attestation when making a
credential, set the <code>attestation</code> parameter in the
<code>PublicKeyCredentialCreationOptions</code> dictionary to
<code>direct</code>.</p>
<p>Just like a regular signature in WebAuthn, you want to bind the
signature from the attestation private key to the specific creation,
thus it needs a challenge. Therefore, when doing attestation, set the
<code>challenge</code> parameter in that dictionary to a large random
value from the server.</p>
<p>Once the credential has been successfully created, you may have
received an attestation. To find out, you need to look at the
<code>response.attestationObject</code> field of the resulting
<code>PublicKeyCredential</code>.</p>
<p>Since this field can contain data that comes directly from the
security key, and is signed by the attestation private key, we are
leaving the realm of JavaScript. It is a CBOR map in the CTAP2 subset of
CBOR (see chapter 6). It contains the attestation information but also
the credential public key and the authenticator data (see
<a href="#authdata">here</a>).</p>
<p>Having the public key inside <code>attestationObject</code> may sound
duplicative because chapter 4 already covered how to get the public key.
But the server cannot use the <code>getPublicKey</code>,
<code>getAuthenticatorData</code>, and
<code>getPublicKeyAlgorithm</code> methods when checking attestation.
Those methods are convenient because the platform will do the parsing
and conversion for you, but the attestation private key doesn’t sign the
nicely parsed and converted values, it signs the raw data from the
security key. And so an implementation that wants to check attestation
must only trust the raw data in <code>attestationObject</code>.</p>
<p>The CBOR map will contain at least the following keys:</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fmt</code></td>
<td>A string that specifies the type of attestation provided. If this is
<code>none</code>, then no attestation has been provided.</td>
</tr>
<tr>
<td><code>authData</code></td>
<td>The authenticator data, a byte string.</td>
</tr>
<tr>
<td><code>attStmt</code></td>
<td>The attestation information itself.</td>
</tr>
</tbody>
</table>
<p>The authenticator data here is the same authenticator data that is
returned when getting a regular signature (see
<a href="#authdata">here</a>) except that it will have the AT flag set,
indicating that “ATtested credential data” follows the signature
counter. This new data has the following format:</p>
<p><img src="https://www.imperialviolet.org/tourofwebauthn/at.svg"/></p>
<p><span id="aaguid"></span> The AAGUID is a random, 16-byte value that
identifies a model of security key and is used when validating the
attestation. The variable-length credential ID is as explained in
chapter 2, but the public key is in the obscure COSE format. (See
chapter 13 for details of public key formats and how to convert between
them.) There’s no length prefix for the public key and the attested
credential data may be followed by extension data if the ED flag is set.
So, in order to find the end of the COSE key and thus the start of the
extension data, you have to parse the CBOR map.</p>
<p>When checking an attestation, you also need to extract the
<code>clientDataJSON</code> field from the
<code>PublicKeyCredential</code>’s <code>response</code> field. This
JSON is similar to what you have seen before except that the
<code>type</code> will now be <code>webauthn.create</code>. When not
checking attestation there’s no point looking at this field because, if
an attacker was trying to do something nefarious, they could just update
it. But it is covered by the attestation signature so it’s meaningful to
check it in the same way as when processing a regular credential
signature.</p>
<h3 id="u2f-attestation">U2F attestation</h3>
<p>Recall from chapter 2 that when a U2F security key creates a
credential, it returns an X.509 certificate and a signature. That
certificate contains the attestation public key and the signature is
made by the attestation private key.</p>
<p>Any attestations from a U2F security key will appear in WebAuthn with
a <code>fmt</code> of <code>fido-u2f</code> because the platform will
convert them. Seeing this format thus indicates that you have to
validate a U2F attestation. The <code>attStmt</code> in this case will
be a CBOR map (in CTAP2 format, as always) with the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x5c</code></td>
<td>The X.509 certificate as a byte string</td>
</tr>
<tr>
<td><code>sig</code></td>
<td>A P-256 ECDSA signature in ASN.1 DER format</td>
</tr>
</tbody>
</table>
<p>The data signed by the attestation private key for this format is the
following, concatenated:</p>
<ul>
<li>A zero byte.</li>
<li>The SHA-256 hash of the RP ID.</li>
<li>The SHA-256 hash of the <code>clientDataJSON</code> value.</li>
<li>The credential ID.</li>
<li>The credential public key in uncompressed X9.62 format. (See chapter
13 for details of different formats.)</li>
</ul>
<p>The X.509 certificate contains the attestation public key, but how do
you trust it? One answer is that, if your company is purchasing a large
number of security keys to distribute to its employees, it can simply
ask the vendor of those security keys for their root certificate. The
attestation certificate in <code>x5c</code> should be signed by that
root certificate to show that it is authentic. The FIDO Alliance also
provides a repository of information about certified security keys,
indexed by AAGUID, which is covered in the next section.</p>
<p>The U2F protocol, however, doesn’t include any AAGUIDs, so the AAGUID
for a <code>fido-u2f</code> attestation will always be zero and some
bespoke configuration will be needed to know the attestation roots for
validation. That’s fixed with CTAP2 authenticators which use the
<code>packed</code> attestation format.</p>
<h3 id="packed-attestation">Packed attestation</h3>
<p>The significant changes with packed attestation are the
following:</p>
<ul>
<li>The <code>fmt</code> is <code>packed</code>.</li>
<li>The <code>x5c</code> key in <code>attStmt</code> now contains a CBOR
array of one or more byte strings. The first is the attestation
certificate and the remainder (if any) are additional X.509 certificates
that form a certificate chain to the root.</li>
<li>There is also an <code>alg</code> key in the <code>attStmt</code>
that contains the COSE algorithm ID of the signature scheme used to
produce the signature.</li>
<li>The signed data is now the concatenation of the authenticator data
and the SHA-256 hash of the <code>clientDataJSON</code>—matching the
form used for regular credential signatures.</li>
</ul>
<p>CTAP2 security keys will produce attestations in this form. Let’s do
a worked example with one.</p>
<p>After creating a credential with <code>attestation</code> set to
<code>direct</code>, we inspect <code>response.attestationObject</code>
in the resulting <code>PublicKeyCredential</code> and decode it as the
CTAP2 subset of CBOR (see chapter 6) to get:</p>
<pre><code>{
  &#34;fmt&#34;: &#34;packed&#34;,
  &#34;attStmt&#34;: {
    &#34;alg&#34;: -7,  # ECDSA with P-256 and SHA-256
    &#34;sig&#34;: h&#39;30460221...&#39;,
    &#34;x5c&#34;: [h&#39;308202be30...&#39;]
  },
  &#34;authData&#34;: h&#39;f95bc73828...&#39;
}</code></pre>
<p>The authenticator data from <code>authData</code> (see
<a href="#authdata">here</a>) breaks down as:</p>
<pre><code># SHA-256 hash of the RP ID
f95bc73828ee210f9fd3bbe72d97908013b0a3759e9aea3d0ae318766cd2e1ad
# Flags: AT, UV, and UP set.
45
# Signature counter
0000001f
# Attested credential data
#  AAGUID
f8a011f38c0a4d15800617111f9edc7d
#  Credential ID length
0040
#  Credential ID
3429904107e65bf06f19fd8fa55b4bda
04ede99c1a6994c6bc315252cc6940bf
aeb0c7c62dc88214fc52cb7105aa33da
7b480da9012c36853d4179f159c9348c
#  Public key in COSE format
a5010203262001215820bc767fb6069f
fd51dbd04916030ec23399e72eefab22
352f29906621351dc83122582066c21d
877c48527407f891ba9611ba85eed1b9
b00164daf2f0a67c39038d771f</code></pre>
<p>While packed attestation can contain multiple X.509 certificates to
form a chain to the root, this attestation only includes a single
certificate, which contains the following:</p>
<pre><code>Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1955003842 (0x7486fdc2)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=Yubico U2F Root CA Serial 457200631
        Validity
            Not Before: Aug  1 00:00:00 2014 GMT
            Not After : Sep  4 00:00:00 2050 GMT
        Subject: C=SE, O=Yubico AB, OU=Authenticator Attestation,
                 CN=Yubico U2F EE Serial 1955003842
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub:
                    04:95:5d:f3:ad:f7:24:7d:31:75:ef:fd:9c:c4:f3:
                    1a:4e:87:8e:ba:e1:81:09:56:61:50:fb:38:8b:2e:
                    5f:65:27:bf:57:40:9a:a5:81:a5:0d:0a:c5:2f:18:
                    44:5c:0a:13:54:8a:13:53:c8:a4:e5:9a:70:4e:52:
                    3b:c0:4d:eb:ed
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            1.3.6.1.4.1.41482.2:
                1.3.6.1.4.1.41482.1.1
            1.3.6.1.4.1.45724.2.1.1:
                ...
            1.3.6.1.4.1.45724.1.1.4:
                .......M........}
            X509v3 Basic Constraints: critical
                CA:FALSE
    Signature Algorithm: sha256WithRSAEncryption
         31:5c:48:80:e6:9a:52:7e:38:66:89:bd:69:fd:0a:a8:6f:49:
         ...</code></pre>
<p>The AAGUID (<code>f8a011f3-8c0a-4d15-8006-17111f9edc7d</code>) from
the authenticator data can be used to look the security key up in the
FIDO Alliance’s metadata. The set of metadata can be downloaded by
fetching <code>https://mds.fidoalliance.org/</code>, which results in a
signed JWT. (Information about the metadata service can be found at <a href="https://fidoalliance.org/metadata/"><code>https://fidoalliance.org/metadata/</code></a>.)</p>
<p>We can find the record for this security key by running:</p>
<div id="cb33"><pre><code><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span>curl</span> https://mds.fidoalliance.org/ <span>|</span> <span>\</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span>cut</span> <span>-d.</span> <span>-f2</span> <span>|</span> <span>\</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span>python3</span> <span>-c</span> <span>&#34;import sys, base64; </span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span>sys.stdout.buffer.write(</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span>  base64.urlsafe_b64decode(sys.stdin.read().strip()))&#34;</span> <span>|</span> <span>\</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span>jq</span> <span>&#39;.entries[] |</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span>    select(.aaguid == &#34;f8a011f3-8c0a-4d15-8006-17111f9edc7d&#34;)&#39;</span></span></code></pre></div>
<p>Note: While the data is being downloaded using HTTPS, this one-liner
doesn’t validate the JWT signature. You may wish to do that.</p>
<p>Within the JSON record is an <code>attestationRootCertificates</code>
field that contains the attestation root certificate for this device.
Now we can check that the attestation certificate is valid using
standard X.509 libraries. For illustration we’ll use the OpenSSL
command-line tool:</p>
<div id="cb34"><pre><code><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span>openssl</span> verify <span>-CAfile</span> root-certificate.pem attestation-certificate.pem</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span>attestation-certificate.pem:</span> OK</span></code></pre></div>
<p>The public key from the attestation certificate can be used to verify
the attestation signature by appending the SHA-256 hash of
<code>clientDataJSON</code> to the authenticator data. This provides
evidence that the COSE-format public key in the authenticator data
really was generated inside a security key of the attested make &amp;
model. A real implementation wouldn’t use command line tools, of course,
and should perform each step of the <a href="https://www.w3.org/TR/webauthn-2/#sctn-packed-attestation">validation
procedures</a> from the specification.</p>
<p>Note: CTAP2 security keys often also still support the U2F protocol,
and will produce <code>fido-u2f</code> attestations if used via that
protocol. Since early CTAP2 security keys could not create credentials
without doing user verification once a PIN had been configured, attempts
to create non-discoverable credentials without user verification may
still use the U2F protocol even though a security key supports
CTAP2.</p>
<p>You might also come across a packed attestation that is missing the
<code>x5c</code> key completely. That is a variant of packed attestation
called a self-attestation.</p>
<h3 id="self-attestation">Self-attestation</h3>
<p>Regular credential creation in WebAuthn does not involve the newly
created private key signing anything. Thus, when a credential is
created, there’s no proof that the entity submitting the new credential
actually holds the private key, and thus it’s possible to submit someone
else’s public key as your own.</p>
<p>This does not obviously cause any problems in WebAuthn but the
standard solution is a “self-signature” and self-attestation provides
this. It is a packed attestation, as described above, where there is no
<code>x5c</code> key in the attestation statement, and the public key
used to validate the attestation signature is the newly-created
credential public key. The signature shows that the private key was
involved in the creation.</p>
<p>However, self-attestations are not really attestations! They claim
nothing about how the private key was generated nor where it is stored.
They simply reuse some of the mechanisms. Because of this,
self-attestations are rarely encountered.</p>
<h3 id="other-attestation-formats">Other attestation formats</h3>
<p>There are several other, less common attestation formats. If you are
building a WebAuthn deployment and come across an unexpected attestation
<code>fmt</code>, you may be able to find details in <a href="https://w3c.github.io/webauthn/#sctn-defined-attestation-formats">this
section</a> of the WebAuthn spec. Hopefully now that you understand the
broad shape of attestation, the specification will be easier to
understand.</p>
<h2 id="enterprise-attestation">Enterprise attestation</h2>
<p><span id="enterprise-attestation"></span> None of the attestations
above identify an individual security key, otherwise it would be
possible to track a specific security key as it was used on different
websites and in apps. However, if you are a company purchasing security
keys for your employees, you might legitimately want to be able to
individually track these security keys.</p>
<p>There is one straightforward way to do that, which is to pre-create
credentials on the security keys before distribution. This is a viable
solution in many cases but it does not always work so, for the
exceptions, CTAP2 and WebAuthn define a concept of enterprise
attestation, where the attestation certificate individually identifies a
specific security key for inventory tracking purposes.</p>
<p>If this simply replaced the standard attestation certificate, that
would cause all of the privacy problems outlined above. So an enterprise
attestation certificate is in addition to a regular attestation
certificate and requests have to be authorized to use it. Security keys
with enterprise attestation must also be specially purchased from the
vendor.</p>
<p>There are two ways that enterprise attestation can be authorized for
a specific request:</p>
<ol type="1">
<li>The platform communicating with the security key can be configured
to authorize the use of enterprise attestation for certain relying party
IDs.</li>
<li>The security key itself can recognize specific relying party IDs and
use enterprise attestation when credentials are created for them.</li>
</ol>
<p>In both cases the WebAuthn <code>create</code> request has to request
enterprise attestation by setting the <code>attestation</code> parameter
to <code>enterprise</code>. If the security key has an enterprise
attestation certificate, and if the request meets at least one of the
two requirements above, then the enterprise attestation certificate will
be returned (and the corresponding attestation private key will be used
to sign the attestation).</p>
<h3 id="implementation-in-ctap2">Implementation in CTAP2</h3>
<p>When a request specifies enterprise attestation, the platform will
consider whether its configuration specifies that the relying party ID
from the request is authorized to receive it. The mechanism of this
configuration is specific to the platform but, for Chrome/Edge, the
policy is called <a href="https://chromeenterprise.google/policies/#SecurityKeyPermitAttestation"><code>SecurityKeyPermitAttestation</code></a>.</p>
<p>If, by whatever mechanism the platform uses, the relying party ID is
authorized, then the platform will send an extra <code>ep</code>
parameter with the CTAP2 <code>authenticatorMakeCredential</code>
command, and will give it the value <code>2</code>. This informs the
security key that the platform believes that the request is authorized
to use any enterprise attestation certificate that the security key may
have configured.</p>
<p>Otherwise, the platform sends the value <code>1</code>, which informs
the security key that enterprise attestation has been requested, but the
platform policy doesn’t authorize it. Still, the security key itself may
recognize the relying party ID and decide to use enterprise
attestation.</p>
<p>The security key is always free to decide that it doesn’t want to
return enterprise attestation for any request, and the feature is
disabled by default and must be explicitly enabled with an
<code>authenticatorConfig</code> command after purchase, and after each
reset (see <a href="#authenticator-config">here</a>). The presence of
the <code>ep</code> field in the <code>authenticatorGetInfo</code>
response indicates that enterprise attestation is supported by a
security key, and its value indicates whether it is currently
enabled.</p>
<p>The enterprise attestation signature signs the authenticator data.
When considering the output of extensions (see chapter 9), a server may
need to extract extension outputs directly from the authenticator data
where possible, rather than use the browser’s reflection of them in the
<code>PublicKeyCredential</code> object, in order to ensure that it’s
getting authentic extension results. This is most applicable to the
<code>minPinLength</code> extension (see
<a href="#min-pin-length">here</a>).</p>

<p>Chapter 4 covered the core of WebAuthn, which is reflected in the
platform-specific APIs detailed in chapter 11. However there are several
aspects of WebAuthn that are specific to operating on the web. This
chapter covers those parts.</p>
<h2 id="feature-detection">Feature detection</h2>
<p>Nothing works unless WebAuthn is available in the browser. While
WebAuthn is very widely supported now, there are still contexts (such as
WebViews) where support might be lacking. To check whether WebAuthn is
available, test for the existence of
<code>window.PublicKeyCredential</code>:</p>
<div id="cb35"><pre><code><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span>if</span> (<span>!</span><span>window</span><span>.</span><span>PublicKeyCredential</span>) {</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span>// WebAuthn is not available in this context.</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="platform-authenticator-detection">Platform authenticator
detection</h3>
<p><span id="isuvpaa"></span> If WebAuthn is available then sites can
silently detect whether a platform authenticator that supports user
verification exists:</p>
<div id="cb36"><pre><code><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span>const</span> promise <span>=</span> <span>window</span><span>.</span><span>PublicKeyCredential</span><span>.</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span>isUserVerifyingPlatformAuthenticatorAvailable</span>()<span>;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>promise<span>.</span><span>then</span>((hasUVPlatformAuthenticator) <span>=&gt;</span> <span>...,</span> (error) <span>=&gt;</span> <span>...</span>)<span>;</span></span></code></pre></div>
<p>Sites would typically check this before proactively prompting users
to create a credential. Users may wish to use security keys, so the
option to create a credential should still appear in the account
settings, but it is unwise to try and upsell the user unless this
promise resolves with <code>true</code>.</p>
<h2 id="conditional-ui">Conditional UI</h2>
<p>Hopefully there will come a day when WebAuthn dominates the
authentication landscape and sites just have a sign-in button that
starts a WebAuthn flow. But today that is not the case.</p>
<p>Today, most users recognize a pair of text boxes as the way that they
start a sign-in process, and they may well be used to their password
manager auto-filling their username and password into them. Conditional
UI is a way for that autofill to also include WebAuthn credentials.</p>
<p>The way it works is that a page can make a
<code>navigator.credentials.get</code> call and pass
<code>mediation: &#34;conditional&#34;</code> in the top-level dictionary. (So
at the same level as <code>publicKey</code>, not inside the assertion
options.) That will cause the request not to show a modal UI, but
instead the returned promise will hang around, unresolved.</p>
<div id="cb37"><pre><code><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span>const</span> abortController <span>=</span> <span>new</span> <span>AbortController</span>()<span>;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span>const</span> promise <span>=</span> <span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>get</span>({</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span>// The `requestOptions` are the same as for a regular request.</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span>publicKey</span><span>:</span> requestOptions<span>,</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  <span>mediation</span><span>:</span> <span>&#39;conditional&#39;</span><span>,</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  <span>signal</span><span>:</span> abortController<span>.</span><span>signal</span><span>,</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>})<span>;</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span>// `promise` may not ever resolve but, if it does, it&#39;ll return a</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span>// `PublicKeyCredential`, just like a regular `get()` call.</span></span></code></pre></div>
<p>The contract with the browser is that it may present WebAuthn as an
option to the user in whatever unobtrusive manner that it wishes.
Currently, that means that credentials can be offered in autofill for
fields that have <code>webauthn</code> as the final autocomplete
token:</p>
<div id="cb38"><pre><code><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span>&lt;</span><span>input</span><span> type</span><span>=</span><span>&#34;text&#34;</span><span> name</span><span>=</span><span>&#34;username&#34;</span><span> autocomplete</span><span>=</span><span>&#34;username webauthn&#34;</span><span>&gt;</span></span></code></pre></div>
<p>If the user selects a WebAuthn credential from the browser’s autofill
menu then any needed user verification will be completed and the promise
from the conditional request will be resolved. The Javascript for the
page is then responsible for sending the assertion to the server and
getting the user signed in.</p>
<p>Before starting a conditional request, check that the browser
supports them: (Otherwise the <code>mediation</code> parameter will be
ignored and the call will trigger a modal UI.)</p>
<div id="cb39"><pre><code><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span>if</span> (PublicKeyCredential<span>.</span><span>​​isConditionalMediationAvailable</span>) {</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  <span>const</span> promise <span>=</span> PublicKeyCredential<span>.</span><span>​​</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>      <span>isConditionalMediationAvailable</span>()<span>;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>  promise<span>.</span><span>then</span>((isSupported) <span>=&gt;</span> <span>...,</span> (error) <span>=&gt;</span> <span>...</span>)<span>;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A conditional request should be made as soon as possible after page
load because credentials won’t appear in autofill unless a conditional
request is pending to receive the resulting credential.</p>
<h3 id="mixing-modal-and-conditional-requests">Mixing modal and
conditional requests</h3>
<p>A page may well use conditional UI and also have a “Sign in with
passkey” button that triggers a modal request. However, only one
WebAuthn request can be outstanding at any given time. So if the
conditional request is hanging, waiting for a possible credential from
autofill, trying to make a regular request in response to the user
clicking on the button will fail immediately.</p>
<p>Instead, conditional requests need to be aborted before the modal
request can be started. In the example above, the conditional request
also took a <code>signal</code> parameter. This allows an <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController"><code>AbortController</code></a>
to abort a conditional request by calling
<code>abortController.abort()</code> and waiting for the promise from
the conditional request to fail. Then another WebAuthn request can be
started.</p>
<p>If the modal request fails, then you need to restart the conditional
request; otherwise credentials won’t appear in autofill after the user
clicks the button.</p>
<h3 id="the-challenge-of-challenges">The challenge of challenges</h3>
<p><span id="challenge-of"></span> Conditional UI makes generating the
<code>challenge</code> parameter in the request more, well, challenging.
This is also the case with the
<code>prefer­Immediately­Available­Credentials</code> option to the
platform APIs that we’ll cover in chapter 11.</p>
<p>Recall that the properties that we want of a challenge are that:</p>
<ol type="1">
<li>It has never been used before, so no previous signature can be
reused for the current request.</li>
<li>It is unpredictable, so that an attacker with temporary access
cannot generate signatures that will be valid in the future.</li>
</ol>
<p>The ideal way to meet these requirements is to generate a random
challenge at the server, record it, and check against it when the
signature is received. But conditional requests want to be started as
soon as possible after page load. Any delay to fetch a challenge is a
problem. This is also the case with mobile apps that want to show the
option to sign in as soon as the app is opened.</p>
<p>With conditional UI, the challenge can be dynamically embedded in the
page contents to avoid making a separate request for it. But this isn’t
applicable when opening an app because that is a purely local
operation.</p>
<p>Conditional UI challenges also have a second tension (which the app
case doesn’t) because the signature from a conditional request could
come days later. How long does the server have to store session
information for the possibility that a page load is still in a tab
somewhere, waiting for the user to sign in?</p>
<p>The best answer for these issues is probably a feature that doesn’t
exist at the time of writing but which has been proposed: a
<code>challengeUrl</code> parameter as an alternative to the
<code>challenge</code> parameter. This would specify a URL from which a
challenge can be downloaded at the point that one is needed. For
conditional UI, the challenge wouldn’t be downloaded until the user has
selected a credential and the signing operation is ready to happen. For
apps, fetching the challenge could happen concurrently with showing UI
to the user, thus minimizing latency.</p>
<p>An alternative that is often suggested is encrypted timestamps;
i.e. distribute a stateless service around the world (to minimize
latency) that encrypts and returns a timestamp on demand to serve as a
challenge. When validating signatures, the timestamp can be decrypted
and checked to be reasonably recent.</p>
<p>On the plus side, this avoids needing storage and can make latency
acceptable. But there are several drawbacks. Firstly, it limits replay
but doesn’t prevent it. The extent that replays are possible is bounded
by how old a received challenge is allowed to be. If it’s just a few
minutes, perhaps you deem that acceptable, but larger windows are
progressively more concerning. Thus any conditional UI requests need to
be restarted frequently.</p>
<p>Second, it would also obviously be bad if the encryption key leaked.
Public-key cryptography doesn’t help here because, in order for future
valid challenges to be unpredictable, it mustn’t be possible for an
attacker to generate a valid encrypted timestamp. Thus public-key
cryptography shouldn’t be used because public keys are assumed to be
public, and making non-standard assumptions of cryptosystems is usually
disastrous.</p>
<h2 id="conditional-create">Conditional create</h2>
<p>If a user is already using a password manager to store a password for
a site it would be great if that password manager would just start
storing a passkey instead. That’s why browsers increasingly support
setting <code>mediation: &#34;conditional&#34;</code> on <code>create</code>
calls. This requests that a passkey be automatically created,
i.e. without the user having to confirm or present any biometrics.
<span id="conditional-create"></span></p>
<p>Before attempting this, check whether the browser supports
conditional create calls:</p>
<div id="cb40"><pre><code><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span>if</span> (<span>window</span><span>.</span><span>PublicKeyCredential</span> <span>&amp;&amp;</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span>window</span><span>.</span><span>PublicKeyCredential</span><span>.</span><span>getClientCapabilities</span>) {</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <span>window</span><span>.</span><span>PublicKeyCredential</span><span>.</span><span>getClientCapabilities</span>()<span>.</span><span>then</span>(</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    (capabilities) <span>=&gt;</span> {</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>      <span>if</span> (capabilities<span>.</span><span>conditionalCreate</span> <span>??</span> <span>false</span>) {</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>        <span>attemptConditionalCreate</span>()<span>;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>      }})<span>;</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Since conditional creation doesn’t involve any confirmation UI, the
user presence and user verification bits in the resulting authenticator
data will both be false. Thus, the request should set
<code>authenti­cator­Selection.­user­Verifi­cation</code> to
<code>discouraged</code>.</p>
<p>A site can technically attempt to conditionally create a passkey at
any time. However, passkey providers will impose requirements before
doing so. They will likely require that they already have an account
with the same username to confirm that the user is happy storing that
credential. They may also require that the password has been recently
filled to try and confirm that any saved password is valid. Because of
these requirements, the correct time to attempt a conditional create is
immediately after a user has signed in using a password.</p>
<p>If the conditional creation attempt is rejected, the promise will
fail immediately with a <code>Not­Allowed­Error</code>.</p>
<p>(Conditional creation may also be available in platform APIs. See
chapter 11.)</p>
<h2 id="iframes">iframes</h2>
<p>WebAuthn works without fuss in iframes that are same-origin with the
main frame. But when people ask about iframes, they usually mean
cross-origin iframes. <span id="iframe"></span> WebAuthn
<code>get</code> requests do work in cross-origin iframes, but the
parent frame has to grant permission for the iframe to make that call.
To do so, use the permissions policy framework:</p>
<div id="cb41"><pre><code><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span>&lt;</span><span>iframe</span><span> src</span><span>=</span><span>&#34;...&#34;</span><span> allow</span><span>=</span><span>&#34;publickey-credentials-get&#34;</span><span>&gt;</span></span></code></pre></div>
<p>Chromium-based browsers also allow <code>create</code> calls within
cross-origin iframes. Again, the parent frame has to grant permission,
this time with the <code>publickey-credentials-create</code> permission.
At the time of writing, Safari does not allow this, however.</p>
<h2 id="json-conversion">JSON conversion</h2>
<p><span id="json-conversion"></span> Ideally, WebAuthn requests would
be created in your backend and sent to the frontend to be performed by
the browser. But because WebAuthn requests and responses contain
ArrayBuffers, which can’t be expressed in JSON, this is not as easy as
it should be.</p>
<p>Thus dedicated JSON conversion functions were added to WebAuthn.
These functions are aware of the WebAuthn structures and, wherever an
ArrayBuffer is needed, accept a base64url-encoded string instead.</p>
<p>Here’s an example WebAuthn registration converted to JSON by taking
all ArrayBuffers and base64url encoding them:</p>
<div id="cb42"><pre><code><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>createJSON <span>=</span> <span>`</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span>  &#34;challenge&#34;: &#34;cmFuZG9tIGNoYWxsZW5nZQ&#34;,</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span>  &#34;rp&#34;: { &#34;id&#34;: &#34;example.com&#34;, &#34;name&#34;: &#34;example.com&#34; },</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span>  &#34;user&#34;: {</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span>    &#34;id&#34;: &#34;dXNlcmlk&#34;,</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span>    &#34;name&#34;: &#34;name&#34;,</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span>    &#34;displayName&#34;: &#34;displayName&#34;</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span>  },</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span>  &#34;pubKeyCredParams&#34;: [ {&#34;type&#34;: &#34;public-key&#34;, &#34;alg&#34;: -7} ],</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a><span>  &#34;authenticatorSelection&#34;: {</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a><span>    &#34;requireResidentKey&#34;: true,</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span>    &#34;authenticatorAttachment&#34;: &#34;platform&#34;</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a><span>  }</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a><span>}`</span><span>;</span></span></code></pre></div>
<p>A browser with support for these JSON functions will accept the
following to trigger a creation request:</p>
<div id="cb43"><pre><code><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>create</span>({</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span>publicKey</span><span>:</span> <span>window</span><span>.</span><span>PublicKeyCredential</span><span>.</span><span>parseCreationOptionsFromJSON</span>(</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>      <span>JSON</span><span>.</span><span>parse</span>(createJSON))<span>,</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>})<span>.</span><span>then</span>(<span>console</span><span>.</span><span>log</span><span>,</span> <span>console</span><span>.</span><span>log</span>)<span>;</span></span></code></pre></div>
<p>The static <code>parse­Creation­Options­From­JSON</code> method on
<code>window.­Public­Key­Credential</code> takes a parsed JSON object and
converts it to a WebAuthn creation request. Similarly,
<code>Public­Key­Credential.­parse­Request­Options­From­JSON</code> also exists
for assertion requests.</p>
<p>Once a promise has resolved with a <code>Public­Key­Credential</code>
object, there’s also a function to convert it to JSON for sending back
to the server:</p>
<div id="cb44"><pre><code><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span>JSON</span><span>.</span><span>stringify</span>(pubKeyCred<span>.</span><span>toJSON</span>())<span>;</span></span></code></pre></div>
<p>That results in JSON string where, again, all ArrayBuffers have been
encoded as base64url strings.</p>
<p>To test whether a browser supports these functions, do:</p>
<div id="cb45"><pre><code><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span>if</span> (<span>window</span><span>.</span><span>PublicKeyCredential</span><span>.</span><span>parseCreationOptionsFromJSON</span>) {</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span>// JSON functions supported.</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>These JSON formats are also used by the Android platform APIs (see
<a href="#android">here</a>) and so it’s possible for a backend to
generate WebAuthn JSON objects that will transparently work for both web
and Android clients.</p>
<h2 id="testing">Testing</h2>
<p>WebAuthn involves interacting with security keys or local biometric
sensors. These are all things that make automated testing very
challenging. However, browsers can implement a virtual authenticator—a
fake WebAuthn authenticator that skips showing any UI, but which creates
credentials and generates signatures like any other.</p>
<p>Chromium-based browsers can add a virtual authenticator to a tab for
when different types of security keys aren’t available for manual
testing, or for when a platform authenticator isn’t available (although
that’s rare these days). To do so, find “WebAuthn” under “More tools” in
the developer tools, check the option to enable the environment, select
the configuration of the virtual authenticator, and click “Add”.
WebAuthn requests will now use the virtual authenticator and the state
of the authenticator appears in the developer tools pane.</p>
<p>It’s also possible to do completely automated tests with a virtual
authenticator by configuring it using <a href="https://developer.mozilla.org/en-US/docs/Web/WebDriver">WebDriver</a>.
See <a href="https://www.w3.org/TR/webauthn-2/#sctn-automation-webdriver-capability">the
WebDriver section</a> of the WebAuthn specification for more
details.</p>

<p>Recall from chapter 4 that WebAuthn accepts an
<code>extensions</code> parameter when creating or asserting a
credential. These parameters are dictionaries mapping extension names to
extension-specific inputs. When an operation completes successfully, the
resulting <code>PublicKeyCredential</code> has a
<code>getClientExtensionResults</code> method that returns a dictionary
mapping those same names to the extension’s outputs.</p>
<p>This extension mechanism allows a number of non-core features to be
cleanly added to WebAuthn and several of them are covered in this
chapter, along with descriptions of how they are implemented for
security keys.</p>
<p>To save reading this whole chapter just to discover whether any of
these extensions are useful to you, here’s a quick summary of what each
does:</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Extension</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>credProps</td>
<td>Learning whether a newly created credential is discoverable or
not</td>
</tr>
<tr>
<td>PRF</td>
<td>Getting secret keys for encrypting data</td>
</tr>
<tr>
<td>credProtect</td>
<td>Setting a minimum security bar for credentials kept on security
keys</td>
</tr>
<tr>
<td>credBlob</td>
<td>Storing 32 bytes of data with a credential</td>
</tr>
<tr>
<td>minPinLength</td>
<td>Checking that company PIN-length requirements are being
enforced</td>
</tr>
<tr>
<td>largeBlob</td>
<td>Storing certificates for offline operation of a security key</td>
</tr>
<tr>
<td>appId / appIdExclude</td>
<td>Backwards compatibility with credentials created via the U2F web
API</td>
</tr>
</tbody>
</table>
<p>Extensions are processed by the platform or browser and some of them,
like <code>credProps</code> don’t involve any explicit work by the
authenticator or security key. For others, the extension is forwarded
entirely to the authenticator for processing. There is also a third
class of extensions where the authenticator is involved in the
processing of the extension, but the platform also has to do work.</p>
<p>In all cases, the results are returned via
<code>getClientExtensionResults</code>. Even for extensions that are
entirely processed by the authenticator, the platform will generally
take the authenticator’s output and rewrite it into a JavaScript object
to include there.</p>
<p>If you are using attestation (see chapter 7) then you need to
consider that the platform’s output is not signed by the attestation
private key. So for each extension used, you need to decide whether your
implementation will extract the extension output from the returned
authenticator data instead—which is signed. This is not always possible,
for example with the <code>prf</code> and <code>largeBlob</code>
extensions, but sometimes it’s nonsensical not to, for example with the
<code>minPinLength</code> extension.</p>
<p>Note: Attestation is not commonly used and most implementations do
not need to worry about this.</p>
<h2 id="credprops">credProps</h2>
<p><span id="credprops"></span> Recall from chapter 4 that the
<code>authenticatorSelection</code> field of the creation parameters
lets you specify <code>residentKey</code> as <code>preferred</code>.
(And recall that a “resident key” is a historical name for a
discoverable credential.)</p>
<p>If you configure that, <code>credProps</code> is the way that you
learn whether a discoverable credential was actually created or not. To
request this information, set this extension in the creation
options:</p>
<div id="cb46"><pre><code><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>options<span>.</span><span>extensions</span> <span>=</span> {<span>credProps</span><span>:</span> {}}<span>;</span></span></code></pre></div>
<p>Then there are three possible outcomes in a successful response:</p>
<ul>
<li>The extension isn’t supported: the credential probably isn’t
discoverable if it was created on a security key, but we don’t
know.</li>
<li>The extension is supported, but the discoverability isn’t reported.
(With some security keys the platform can’t know whether a credential is
discoverable or not. Rather than guess, it’ll say nothing at all.)</li>
<li>The credential explicitly is (or isn’t) discoverable.</li>
</ul>
<p>These possibilities can be extracted from the resulting
<code>PublicKeyCredential</code> object like this:</p>
<div id="cb47"><pre><code><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span>const</span> extensionOutputs <span>=</span> credential<span>.</span><span>getClientExtensionResults</span>()<span>;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span>const</span> hasCredProps <span>=</span> <span>&#39;credProps&#39;</span> <span>in</span> extensionOutputs<span>;</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span>if</span> (<span>!</span>hasCredProps) {</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  <span>// Platform doesn&#39;t support the extension.</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>&#34;probablynot&#34;</span><span>;</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span>const</span> propertyReported <span>=</span> <span>&#39;rk&#39;</span> <span>in</span> extensionOutputs<span>.</span><span>credProps</span><span>;</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a><span>if</span> (<span>!</span>propertyReported) {</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>  <span>// The platform doesn&#39;t know whether the authenticator used creates</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>  <span>// discoverable credentials or not.</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>&#34;probablynot&#34;</span><span>;</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a><span>return</span> extensionOutputs<span>.</span><span>credProps</span><span>.</span><span>rk</span> <span>?</span> <span>&#34;yes&#34;</span> <span>:</span> <span>&#34;no&#34;</span><span>;</span></span></code></pre></div>
<h2 id="prf">PRF</h2>
<p><span id="prf"></span> A pseudo-random function (PRF) is a
cryptographic abstraction that approximates a random oracle. A random
oracle is a function that takes an arbitrary byte-string input and
produces a fixed-sized output. It works like this:</p>
<p>Conceptually, the oracle contains a table mapping inputs to outputs
that starts off empty. Each time the oracle is evaluated, it looks in
its table to see whether the input has been seen before. If so, it
returns the corresponding output from its table. Otherwise, it generates
an output uniformly at random, records it in its table, and returns
it.</p>
<p>As an example, we start off with an oracle with an empty table, and
we evaluate it on the input “apples”. The table is empty, so “apples”
isn’t in it, and so the oracle generates a random output, records it,
and returns it.</p>
<p>Next, we evaluate it on the input “bananas” and the same thing
happens. (Although the output, being randomly generated, will be
different with very high probability.)</p>
<p>Finally, we evaluate it on “apples” again. This time “apples” is in
its table, and it so returns the same output as it did the first time we
evaluated it.</p>
<p>If you built such a function, that would be an ideal random oracle.
But storing the table is problematic so, instead, PRFs approximate a
random oracle by using functions like HMAC-SHA256. They are
computationally indistinguishable from a random oracle but, by using a
hash function, do not require storing all the input and output
pairs.</p>
<p>The result of all this theory is that attaching a PRF to a credential
allows you to derive an unlimited number of secret keys from it. These
secret keys can be used for whatever you want, but encrypting data is
the most common use.</p>
<p>The <code>prf</code> extension to WebAuthn lets you attach a PRF to
each credential. The PRF is credential-specific and can only be
evaluated when the credential is created or asserted. During each
operation the PRF can be evaluated on up to two inputs in order to
support key rotation.</p>
<p>To use the <code>prf</code> extension with a credential, it should be
requested at creation time. (It is possible for authenticators to
support PRF evaluation at assertion time even when it wasn’t configured
at creation time, but this is authenticator-specific behavior and can’t
be depended upon.)</p>
<p>To request PRF support during credential creation, just create an
empty extension:</p>
<div id="cb48"><pre><code><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>options<span>.</span><span>extensions</span> <span>=</span> {<span>prf</span><span>:</span> {}}<span>;</span></span></code></pre></div>
<p>In the resulting <code>PublicKeyCredential</code>, see whether PRF
was supported:</p>
<div id="cb49"><pre><code><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span>const</span> extensionOutputs <span>=</span> credential<span>.</span><span>getClientExtensionResults</span>()<span>;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span>const</span> hasPrf <span>=</span> <span>&#39;prf&#39;</span> <span>in</span> extensionOutputs <span>&amp;&amp;</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>               extensionOutputs<span>.</span><span>prf</span><span>.</span><span>enabled</span> <span>===</span> <span>true</span><span>;</span></span></code></pre></div>
<p>Unlike capabilities such as user verification, there is no way to
express that the PRF extension is required, so the possibility that an
authenticator doesn’t support it must always be handled.</p>
<p>It’s also possible to opportunistically evaluate the newly-created
PRF during the creation operation. (Because security keys can’t support
this, this is not guaranteed to succeed.)</p>
<div id="cb50"><pre><code><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>options<span>.</span><span>extensions</span> <span>=</span> {<span>prf</span><span>:</span> {</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  <span>eval</span><span>:</span> {</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span>first</span><span>:</span> <span>new</span> <span>Uint8Array</span>([<span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span>])<span>,</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span>second</span><span>:</span> <span>new</span> <span>Uint8Array</span>([<span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span>])<span>,</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>  }<span>,</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>}}<span>;</span></span></code></pre></div>
<p>The PRF can be evaluated at two inputs, as shown above, but
<code>second</code> is optional if you don’t need that ability.</p>
<p>The outputs will always be 32 bytes long and are in the
<code>results</code> member of the extension outputs if supported:</p>
<div id="cb51"><pre><code><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span>const</span> extensionOutputs <span>=</span> credential<span>.</span><span>getClientExtensionResults</span>()<span>;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span>const</span> hasPrf <span>=</span> <span>&#39;prf&#39;</span> <span>in</span> extensionOutputs <span>&amp;&amp;</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>               extensionOutputs<span>.</span><span>prf</span><span>.</span><span>enabled</span> <span>===</span> <span>true</span><span>;</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span>const</span> hasOutputs <span>=</span> hasPrf <span>&amp;&amp;</span> <span>&#39;results&#39;</span> <span>in</span> extensionOutputs<span>.</span><span>prf</span><span>;</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span>if</span> (hasOutputs) {</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>  <span>const</span> output1 <span>=</span> extensionOutputs<span>.</span><span>prf</span><span>.</span><span>results</span><span>.</span><span>first</span><span>;</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>  <span>const</span> output2 <span>=</span> extensionOutputs<span>.</span><span>prf</span><span>.</span><span>results</span><span>.</span><span>second</span><span>;</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The same code works at assertion time except that there will always
be PRF results if <code>hasPrf</code> was true at creation time.</p>
<p>But at assertion time, there might be multiple credential IDs listed
in <code>allowedCredentials</code> and the PRF of each may need to be
evaluated at different inputs depending on which credential was used. If
that’s the case, <code>evalByCredential</code> can be set instead of
<code>eval</code>.</p>
<div id="cb52"><pre><code><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>options<span>.</span><span>extensions</span> <span>=</span> {<span>prf</span><span>:</span> {</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  <span>evalByCredential</span><span>:</span> {</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span>&#34;Y3JlZGVudGlhbElEMQ&#34;</span><span>:</span> {</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>      <span>first</span><span>:</span> <span>new</span> <span>Uint8Array</span>([<span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span>])<span>,</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>      <span>second</span><span>:</span> <span>new</span> <span>Uint8Array</span>([<span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span>])<span>,</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    }<span>,</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    <span>&#34;b3RoZXJJRA&#34;</span><span>:</span> {</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>        <span>first</span><span>:</span> <span>new</span> <span>Uint8Array</span>([<span>4</span><span>,</span><span>3</span><span>,</span><span>2</span><span>,</span><span>1</span>])<span>,</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>        <span>second</span><span>:</span> <span>new</span> <span>Uint8Array</span>([<span>8</span><span>,</span><span>7</span><span>,</span><span>6</span><span>,</span><span>5</span>])<span>,</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    }<span>,</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>}}<span>;</span></span></code></pre></div>
<p>The keys in <code>evalByCredential</code> are base64url-encoded
credential IDs. It can only be used if <code>allowCredentials</code> is
non-empty and every credential ID listed in
<code>evalByCredential</code> must be present in
<code>allowCredentials</code>. If both <code>evalByCredential</code> and
<code>eval</code> are both set then the former will be used for any
credential ID listed in it, with <code>eval</code> used as the fallback
for any other credentials.</p>
<h3 id="choosing-the-inputs">Choosing the inputs</h3>
<p>As a general rule, one shouldn’t use the same secret key for multiple
purposes. So, if you’re using a PRF output to encrypt data with AES-GCM,
and then you later switch to a different algorithm, you should use a
different key obtained from a different PRF input.</p>
<p>However, that doesn’t exclude the possibility that a service uses the
same PRF input globally for all users. For example, you could always use
<code>new TextEncoder().encode(&#34;user data encryption key&#34;).buffer</code>
as the sole PRF input.</p>
<p>A worry with that design would be that, if an attacker were ever to
be able to request an assertion with your RP ID, then they could get
that secret key for a specific credential. Thus a step up from that
design is to have random, per-user PRF inputs that an attacker would
struggle to obtain: even if the attacker were able to request an
assertion somehow, they would not know what input to use to get the
secret key.</p>
<p>A further step up is to be continually rotating the secret key, which
is why it’s possible to evaluate the PRF at two different inputs each
time.</p>
<p>In this design, in addition to a per-user PRF input, each account
also has a second, random PRF input that is “pending”. The PRF is then
evaluated for both inputs and the data can be decrypted with the secret
key from the first evaluation and then re-encrypted with the secret key
from the second. Then the second PRF input becomes the primary one and
the server generates a new “pending” input for the next rotation.</p>
<p>In this case, even if the server’s database of PRF inputs leaked, it
would rapidly and automatically become out of date.</p>
<p>The decision of which style of PRF evaluation makes sense for a given
service has to be made in light of the security needs of that service.
Each additional step adds a meaningful amount of complexity and so
there’s no uniformly applicable advice about which is appropriate.</p>
<h3 id="input-hashing">Input hashing</h3>
<p>PRF inputs from WebAuthn, and WebAuthn-like APIs, are prefixed with
the string <code>&#34;WebAuthn PRF&#34;</code>, followed by a zero byte, and
hashed with SHA-256 before being used. This means that there are two
layers of “access” to the PRF. An API that allows PRF inputs to be
specified without hashing has more authority than WebAuthn, because it
can evaluate the PRF at all the inputs that WebAuthn can, plus it can
evaluate the PRF at inputs that WebAuthn cannot express.</p>
<p>PRF inputs sent over CTAP2 and hybrid (the protocol used between
computers and phones) are already hashed. So applications that have
direct CTAP2 access can choose to use PRF inputs that are inexpressible
in WebAuthn. But this also causes problems when CTAP2 requests are sent
over hybrid and need to be translated back into WebAuthn-like requests,
because the hashing of PRF inputs cannot be undone. Thus credential
providers on Android might see a <code>prfAlreadyHashed</code>
extension. See <a href="#prfalreadyhashed">here</a>.</p>
<h3 id="implementation-in-ctap2-1">Implementation in CTAP2</h3>
<p>The <code>prf</code> extension is implemented for security keys by
using a different extension: <code>hmac-secret</code>; security keys
don’t implement <code>prf</code> directly.</p>
<p>When creating a credential, the <code>hmac-secret</code> extension
only takes a boolean parameter to specify whether HMAC support is
requested or not. Because of this it’s not possible to evaluate any PRFs
at creation time when using a security key, and that’s why creation time
evaluation is optional in WebAuthn.</p>
<p>At assertion time, in order to protect data when it is on the USB
bus, or transmitted to an NFC security key, the PRF inputs and results
are encrypted using the same Elliptic Curve Diffie–Hellman derived key
as described in the section on user verification. (See
<a href="#client-pin">here</a>.)</p>
<p>Those <code>hmac-secret</code> inputs simply specify the input(s) for
evaluation, i.e. there is no equivalent of WebAuthn’s
<code>evalByCredential</code> field. So to implement
<code>evalByCredential</code> with security keys, platforms have to
probe the possible credentials from <code>allowCredentials</code> to
find a match, and only then select the PRF inputs for the final
<code>authenticatorGetAssertion</code> command.</p>
<p>The <code>hmac-secret</code> extension also defines that two PRFs are
created per credential. Which PRF is used is determined automatically
based on whether user verification was done for a request. These dual
PRFs are not exposed through WebAuthn, however. Rather, WebAuthn defines
that when two PRFs are present in an authenticator, the user
verification PRF must always be used. Thus, if a WebAuthn request
includes PRF evaluation, user verification will be done with security
keys if they support it, irrespective of the
<code>userVerification</code> parameter in the WebAuthn request
itself.</p>
<p>Because the <code>prf</code> extension is implemented this way on
security keys, you’re actually able to see <code>hmac-secret</code>
appearing in the authenticator data when getting an assertion. We can
take a look at the authenticator data from a security key operation
after requesting a PRF evaluation:</p>
<pre><code># Hash of RP ID
26bd7278be463761f1faa1b10ab4c4f82670269c410c726a1fd6e05855e19b46
# Flags: ED + UV + UP
85
# Signature counter
00000023
# Because the ED flag is set, the remainder is extension data.
# This is CBOR-encoded.
a16b686d61632d7365637265745840a2
0f1e5cd69d341c5e98fe1f2e90834a10
d1df55f835f45e69f2e53650bc3c579a
08d3919308582656a4658c876d1521f6
d703a63a55db81ad9c64b94808a454</code></pre>
<p>The CBOR-encoded extension data decodes as
<code>{&#34;hmac-secret&#34;: h&#39;A20F1E5CD69D341C5E9...&#39;}</code>. The payload is
64 bytes long because two PRF inputs were sent, and two 32-byte outputs
thus require 64 bytes. The result is encrypted with an ephemeral key
that isn’t accessible outside of the platform/browser, so neither
Javascript nor the server can learn anything about the PRF results from
this. It’s mentioned here to connect different concepts rather than for
any practical use.</p>
<h2 id="credprotect">credProtect</h2>
<p><span id="credprotect"></span> Security keys can get lost. If someone
picks up your lost security key in the car park, how much can they learn
about you?</p>
<p>They have physical access to the security key, so they can send
<code>authen­ticator­Get­Assertion</code> commands to it and query for
discoverable credentials associated with any RP ID. Should security keys
better protect this information?</p>
<p>Perhaps, but maybe you also want to use a security key like an access
card, where you tap it on an NFC reader and a door unlocks for you. That
inherently requires that the security key disclose the existence of
credentials to any NFC reader that gets close to it.</p>
<p>The <code>credProtect</code> extension exists to let the privacy
level of a credential be specified at creation time. It only applies to
security keys, since phones and laptops have screen locks to protect the
information on them already.</p>
<p>Note: Security keys may disclose the existence of a discoverable
credential, its credential ID, and its user ID without user verification
being performed. But they never disclose the user name or user display
name without it. That’s why WebAuthn says that the user ID should not
contain identifiable information. <span id="ctap2-user-id"></span></p>
<p>There are three levels of credential protection:</p>
<ul>
<li>“userVerificationOptional”: a credential’s existence may be
disclosed.</li>
<li>“userVerificationOptionalWithCredentialIDList”: a credential’s
existence may be disclosed only if user verification is done, or if a
request specifies its credential ID.</li>
<li>“userVerificationRequired”: a credential’s existence may not be
disclosed without user verification.</li>
</ul>
<p>If you want to use a credential like an access card then it must use
“userVerificationOptional”. Otherwise, you might want a more restrictive
value. Security keys can enforce a higher level of privacy for all
credentials, but most don’t.</p>
<p>Tucking this away into an extension is a little obscure and so some
platforms will set a higher default. Chromium (and thus Chrome and Edge)
will default to at least “userVerificationOptionalWithCredentialIDList”
whenever a WebAuthn creation request requires or prefers a discoverable
credential.</p>
<p>Additionally, if a discoverable credential is required, and
<code>userVerification</code> is set to <code>preferred</code> (which is
the default in WebAuthn), then Chromium will set the credProtect level
to “userVerificationRequired”. This protects users when a site accepts
both user-verified and non-verified assertions. That’s a reasonable
thing to do in the context of a platform authenticator where access is
protected by a screen lock, even if user verification isn’t done for a
specific assertion. But with a security key, a discoverable credential
with optional user verification may mean that finding a lost security
key grants immediate access to the owner’s accounts.</p>
<p>We can observe this happening because the security key will echo the
<code>credProtect</code> setting in the authenticator data. When
inspecting the authenticator data from a creation request made in Edge
with <code>requireResidentKey</code> set, we see the ED (Extension Data)
flag set. After skipping over the attested credential data, the
extensions decode as the following CBOR map:
<code>{&#34;credProtect&#34;: 3}</code>. So Edge has set this extension for us,
based on the parameters. The value “3” corresponds to
“userVerificationRequired” as, over CTAP2, the three protection levels
are simply numbered 1, 2, and 3.</p>
<p>A WebAuthn request can overwrite these defaults if it wishes:</p>
<div id="cb54"><pre><code><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>options<span>.</span><span>extensions</span> <span>=</span> {</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  <span>credentialProtectionPolicy</span><span>:</span> <span>&#34;userVerificationOptional&#34;</span><span>,</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  <span>enforceCredentialProtectionPolicy</span><span>:</span> <span>false</span><span>,</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The <code>enforceCredentialProtectionPolicy</code> can be set to
<code>true</code> to require that a credential only be created if the
specified protection policy can be implemented. So it excludes security
keys that don’t implement the <code>credProtect</code> extension. (For
this purpose, platform authenticators are always considered to be
sufficiently privacy-preserving.)</p>
<p>After setting the extensions shown above, and doing a creation in
Edge, the resulting extensions in the authenticator data decode as
<code>{&#34;credProtect&#34;: 1}</code>. So indeed, the explicit extension
overrode the defaults.</p>
<h2 id="credblob">credBlob</h2>
<p>The <code>credBlob</code> extension allows at least 32 bytes of
arbitrary data to be stored with a credential. The data is set once,
when the credential is created, and can be read when it’s asserted. At
the time of writing no platform authenticators implement this, only some
security keys.</p>
<p>To attempt to set a blob, just set the extension to an
<code>ArrayBuffer</code> containing the blob’s data:</p>
<div id="cb55"><pre><code><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>options<span>.</span><span>extensions</span> <span>=</span> {</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>  <span>credBlob</span><span>:</span> <span>new</span> <span>TextEncoder</span>()<span>.</span><span>encode</span>(<span>&#34;credBlob contents&#34;</span>)<span>.</span><span>buffer</span><span>,</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Note: If the contents of the blob are sensitive, combine this
extension with <code>credProtect</code> to ensure that user verification
is required for the credential to be asserted.</p>
<p>Just because this extension was set doesn’t mean that the security
key supports storing a blob, so the extension results have to be checked
after a successful creation to see whether the blob was stored:</p>
<div id="cb56"><pre><code><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span>const</span> extensionOutputs <span>=</span> credential<span>.</span><span>getClientExtensionResults</span>()<span>;</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span>const</span> credBlobStored <span>=</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>      <span>&#39;credBlob&#39;</span> <span>in</span> extensionOutputs <span>&amp;&amp;</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>      extensionOutputs<span>.</span><span>credBlob</span> <span>===</span> <span>true</span><span>;</span></span></code></pre></div>
<p>Later, when asserting the credential, the credBlob data can be
requested:</p>
<div id="cb57"><pre><code><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>options<span>.</span><span>extensions</span> <span>=</span> { <span>getCredBlob</span><span>:</span> <span>true</span> }<span>;</span></span></code></pre></div>
<p>And the contents, if any, will be found in the extension outputs:</p>
<div id="cb58"><pre><code><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span>const</span> extensionOutputs <span>=</span> credential<span>.</span><span>getClientExtensionResults</span>()<span>;</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span>let</span> credBlob <span>=</span> <span>&#39;getCredBlob&#39;</span> <span>in</span> extensionOutputs <span>?</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    (<span>new</span> <span>TextDecoder</span>()<span>.</span><span>decode</span>(extensionOutputs<span>.</span><span>getCredBlob</span>)) <span>:</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span>undefined</span><span>;</span></span></code></pre></div>
<p>(<code>TextEncoder</code> and <code>TextDecoder</code> are used here
only for illustration. The contents of a credBlob can be arbitrary
binary data.)</p>
<p>However, this extension is not suitable for storing secret keys
because the contents end up in the authenticator data, which has to be
sent to the server for the assertion signature to be validated. If we
look at the authenticator data that resulted from the assertion request
above, the extensions within decode as
<code>{&#34;credBlob&#34;: h&#39;63726564426C6F6220636F6E74656E7473&#39;}</code>, and
that hex string is the UTF-8 encoding of “credBlob contents”. Not very
secret! To store secret keys, use the PRF extension (see
<a href="#prf">here</a>).</p>
<h2 id="minpinlength">minPinLength</h2>
<p><span id="min-pin-length"></span> This extension requests that a
security key report its configured minimum PIN length. In an enterprise
environment, this can be used to enforce that a minimum length policy is
in effect for all created credentials.</p>
<p>The minimum PIN length can be configured on some security keys using
the <code>authenticatorConfig</code> CTAP2 command (see
<a href="#authenticator-config">here</a>). The minimum can be raised but
cannot be reduced without resetting the security key, which erases all
credentials. So the minimum length reported during credential creation
will be in effect for the lifetime of that credential.</p>
<p>To request that the minimum PIN length be reported during a
credential creation, just set the <code>minPinLength</code>
extension:</p>
<div id="cb59"><pre><code><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>options<span>.</span><span>extensions</span> <span>=</span> { <span>minPinLength</span><span>:</span> <span>true</span> }<span>;</span></span></code></pre></div>
<p>The minimum will only be reported if the RP ID has been previously
configured via the <code>authenticatorConfig</code> command. The result
can be found in the extensions block of the authenticator data under the
key <code>minPinLength</code>. The result must be taken from the
authenticator data because this extension typically has to be combined
with attestation (see chapter 7) to meet compliance requirements, and
only the authenticator data is signed by the attestation private
key.</p>
<h2 id="largeblob">largeBlob</h2>
<p>Sometimes the entity that creates a credential is not the entity that
verifies assertions from it, and communication between those two
entities may be difficult or impossible. The classic case for this are
air-gapped systems, where authority to access them may be issued
centrally, but has to be checked by a system that cannot communicate
with that central authority.</p>
<p>Typically the central authority will sign a public key with a
certificate. The certificate specifies what the holder of the
corresponding private key is permitted to access. Such a private key can
be stored in a security key, but where are we going to put the
certificate? That’s what the largeBlob extension is for.</p>
<p>Keep in mind that while this extension does have the word “large” in
the name, security keys are embedded devices and the term is relative.
The amount of storage available on a security key that supports this
extension is only guaranteed to be 1024 bytes.</p>
<p>A largeBlob can only be read and written during assertions, meaning
that it cannot be written during creation. But you don’t get the public
key to put in the certificate until the creation is complete, so that
shouldn’t be a constraint.</p>
<p>You won’t see <code>largeBlob</code> appearing in the authenticator
data extensions. Given the size, the implementation in security keys is
a bit more complex than that.</p>
<p>Security keys that support largeBlob expose a single storage extent
to the platform. That storage can only be read or written completely,
albeit in a streaming fashion to satisfy message buffer limits. The
largeBlob values for every credential on the security key have to fit
within that storage and the platforms perform a read/update/write
pattern in order to update any part of it.</p>
<p>The storage extent is formatted as a CBOR array by the platforms.
Each element of the array is a CBOR map that contains a compressed and
encrypted largeBlob value. The encryption key is returned by the
authenticator when a credential is asserted, thus, while platforms can
read the security key’s storage at will, they cannot learn the contents
of a largeBlob without its corresponding encryption key, which requires
them to have successfully asserted the credential. If
<code>credProtect</code> is set on the credential (see
<a href="#credprotect">here</a>) then the platform can be required to
know the credential ID, or to complete user verification, before that
occurs.</p>
<p>The largeBlob storage does not include any credential IDs because
doing so would render credProtect’s
“userVerificationOptionalWithCredentialIDList” policy moot. Instead
platforms trial-decrypt each element of the CBOR array in order to find
the correct largeBlob entry for a credential once they have the key.</p>
<p>Platforms can, however, always see the number of largeBlobs stored by
a security key, and their compressed and uncompressed sizes.</p>
<h2 id="appid-appidexclude">appId / appIdExclude</h2>
<p><span id="appid"></span> Before WebAuthn existed there was a U2F web
API. Firefox supported it and Chrome shipped a hidden, internal
extension by which it could be polyfilled. It has long been deprecated
but had meaningful usage while it existed. It had an equivalent of
relying party IDs called AppIDs, but AppIDs were origins, rather than
domain names.</p>
<p>When WebAuthn was introduced, sites that had used this U2F API faced
a problem. All the credentials that they had registered were associated
with AppIDs, like <code>https://example.com</code>. But WebAuthn used RP
IDs, like <code>example.com</code>. Those two strings are different and
so security keys would consider them distinct, forever making all
AppID-based credentials inaccessible to WebAuthn. That would block a
transition to WebAuthn.</p>
<p>The <code>appId</code> extension exists so that sites can express
that they may also have credentials registered to an AppID. The value of
the extension is the AppID that they used, and platforms have to
validate that they can request that AppID, similar to how they have to
validate RP IDs.</p>
<p>When doing an assertion that contains an <code>appId</code>
extension, platforms will check for any credentials that match an ID
from the <code>allowCredentials</code> list, and then check all those
IDs again using the given AppID.</p>
<p>This gets complex when doing user verification with a PUAT (see
chapter 6) because using a PUAT will bind it to the RP ID or AppID
requested. Naively, platforms would have to request two PUATs, and get
the user to complete user verification twice. However, any credential
created with an AppID must have been created with the old U2F web API.
That API didn’t support user verification and didn’t support
<code>credProtect</code>, therefore any credential with an AppID can be
probed without user verification. So platforms actually probe for each
credential ID with the AppID first, and then probe for each ID again
with an RP ID and with the PUAT.</p>
<p>The <code>appIdExclude</code> extension has the same shape but
applies at creation time. It specifies that one or more of the
credential IDs in <code>excludeCredentials</code> may have been created
with an AppID rather than an RP ID. The processing complexity is
similar.</p>
<p>At this time, these extensions are only of historical interest
because they are only useful if a site needs compatibility with
credentials created with the old U2F web API. The set of sites that ever
used that API is small, and no new site will ever have had an AppID. But
these extensions are mentioned here because they appear in modern API
references, and so they should be explained.</p>

<p>Security keys are great, but realistically regular people are not
going to carry one around with them. But people do carry around their
phones. Wouldn’t it be great if a phone could work like a security
key?</p>
<p>That’s what the hybrid transport is for. It allows phones or tablets
to communicate with laptops and desktops in a way that shows that they
are physically proximal. The evidence of proximity is the key factor
here: there are plenty of “sign in by scanning this QR code” schemes in
use today that simply work across the internet, and they’re phishable.
An attacker can request a sign-in QR code from the legitimate site,
display it on their own site and, if they can persuade a user to scan it
with their phone, that user will be authorizing the attacker’s
computer.</p>
<p>In contrast, a security key requires that a computer be physically
connected to its USB connector, or within NFC range, thus no remote
attack is possible. (Unless the computer itself is compromised.)</p>
<p>Sadly, NFC is rare on laptops, but Bluetooth support is common. Could
we have the phone and laptop communicate via Bluetooth to ensure
proximity? Unfortunately this didn’t turn out to be practical.
Measurements of this scheme in the real world showed an unacceptably
high rate of Bluetooth communication failures. But broadcasting a single
Bluetooth message from the phone to establish proximity, and running the
rest of the communication over the internet, did work acceptably well.
This scheme was called “<a href="https://fidoalliance.org/specs/fido-v2.2-rd-20230321/fido-client-to-authenticator-protocol-v2.2-rd-20230321.html#sctn-hybrid">hybrid</a>”
(Bluetooth + internet).</p>
<p>Note: During development, this transport was called caBLE, for Cloud
Assisted Bluetooth Low Energy. That was a cute name, but calling a
wireless protocol “caBLE” caused some confusion and thus it was changed.
But you might still see the old name hanging around as caBLE reached
version 2.1 before being renamed.</p>
<h3 id="how-it-works">How it works</h3>
<p>The device making a WebAuthn request, usually a laptop, will display
a QR code if it wants to use the hybrid transport. That QR code contains
a CBOR map that contains the following values:</p>
<ul>
<li>A public key for the laptop.</li>
<li>A secret key, so that the phone can prove that it has seen the QR
code.</li>
<li>Whether the request is to make a credential, or to get a signature,
so that the phone can show a specific message when scanning the QR
code.</li>
</ul>
<p>If the user scans the QR code and triggers the operation on the
phone, then the phone connects to its tunnel service. This is some
service on the internet that is willing to relay messages between
laptops and phones as part of this protocol. It’s run by whomever is
implementing the phone side of the protocol, so iPhones use a tunnel
service operated by Apple and Android phones (at least if they’re using
Google’s Play Services) use one operated by Google. The phone asks the
tunnel service to wait for a connection from the laptop which will be
identified by a long, random ID.</p>
<p>Then the phone starts broadcasting a Bluetooth Low Energy (BLE)
advert to tell the laptop that it’s ready. Adverts are small messages
used by BLE devices to advertise their supported services. Importantly,
they can be sent and received without needing to do a Bluetooth pairing
between the devices. The BLE advert sent by the phone advertises a
service number assigned to the FIDO Alliance (0xfff9) and the advert can
include a small (20-byte), service-specific payload.</p>
<p>Twenty bytes is not a lot! For this protocol it’s split into 16 bytes
of encrypted message and four bytes of authentication tag. Both are
keyed based on the secret key that was in the QR code and thus is shared
by the two devices. The authentication tag means that two different
hybrid transactions happening within BLE range of each other are very
unlikely to interfere because the tag will only be valid for one of
them.</p>
<p>As soon as the laptop displays a QR code, it starts listening for a
matching BLE advert. When it receives one with a correct authentication
tag, it decrypts it. The resulting 16 bytes specify the domain of the
phone’s tunnel server and the laptop connects to it. By knowing the
contents of the QR code and the BLE advert, the laptop can calculate the
random ID that the phone told the tunnel server to expect and now the
tunnel server can relay messages between the two devices.</p>
<p>Note: A domain name often won’t fit in a 16-byte message and so the
tunnel server’s domain isn’t included directly. Rather a 16-bit field is
used. The first 256 values specify pre-defined tunnel server domains (of
which only two values have been defined so far). The remaining values
are hashed to generate a random-looking domain name. So, to set up your
own tunnel service, either get its name into the FIDO Alliance
specification as a pre-defined name, or else register one of the
random-looking domains generated by the hash function.</p>
<p>We don’t want the tunnel server to be able to see the contents of any
of the messages, thus the two devices run a cryptographic handshake.
During this protocol the laptop proves to the phone that it holds the
private key corresponding to the public key in the QR code, and that it
received the BLE advert and thus is in Bluetooth range. Also, the phone
proves to the laptop that it knows the secret key from the QR code.</p>
<p>The two devices can now exchange encrypted messages. The phone is
convinced that the device on the other end of the connection received a
BLE message that it broadcast, and thus is physically close. CTAP2 is
used between the two devices and, in order to save a round-trip, the
phone preemptively sends the result of the
<code>authenticatorGetInfo</code> command (see
<a href="#getinfo">here</a>) so that the laptop can immediately send an
<code>authenticatorMakeCredential</code> or
<code>authenticatorGetAssertion</code> command. The messages are padded
up to the next multiple of 32 bytes to reduce the amount that a tunnel
server could learn from seeing the lengths of the messages
exchanged.</p>
<h2 id="threats-1">Threats</h2>
<p>This protocol is a practical way for a phone to act as an
authenticator, but it’s worth knowing about the limits of its threat
model.</p>
<p>The protocol ensures that the device connected to the phone was able
to learn the contents of a BLE advert that the phone broadcast. So one
option for an attacker is to have a BLE receiver with internet access
physically close to the victim, for example hidden in a busy coffee
shop. The attacker can then email a QR code to the victim and, if the
victim scans it, the BLE receiver can play the part of the laptop, proxy
a challenge from an important site, and send a signature request to the
phone. Hopefully the victim notices the UI on their phone and declines
to authorize the operation, but some small fraction of people may fall
for it.</p>
<p>Simpler still, an attacker could hide a BLE receiver somewhere near a
poster with a QR code claiming “Free WiFi!” Again, the BLE receiver
would need internet access, but could proxy a challenge and hope that
the user ignores all the messages and signs in.</p>
<p>In both cases, from the phone’s perspective the transaction is
indistinguishable from a legitimate sign-in request. If these attacks
start happening in the real world, there are a couple of defenses.
Firstly, the messaging on the phone can be sharpened to make people less
likely to misunderstand what they’re authorizing. Secondly, the QR code
already includes a timestamp and phones could start enforcing that it’s
current. This will have false negatives because clocks are not always
accurate, but it would force attackers to produce a fresh QR code—a
“Free WiFi” poster would no longer suffice.</p>
<p>While the hybrid transport isn’t perfect, these attacks are far more
difficult and far less scalable than phishing attacks.</p>
<h2 id="skipping-the-qr-code">Skipping the QR code</h2>
<p>There is another part of this protocol that allows scanning the QR
code to be skipped if the phone and laptop have interacted
previously.</p>
<p>During a QR-initiated connection, the phone can optionally send
information to the laptop that will allow the laptop to contact the
phone again in the future. This includes a public key for the phone and
an identifier that the laptop can send to the phone’s tunnel server in
order to request a connection to that phone.</p>
<p>Note: Since the phone picks which tunnel server will be used, we can
assume that the tunnel server knows some private way to contact the
phone. So these connections are always triggered by the laptop
connecting to the phone’s tunnel server. They are not triggered by the
laptop broadcasting any kind of Bluetooth message.</p>
<p>Later, when the laptop wants to contact the phone again, it connects
to the tunnel server and sends the phone’s identifier. Using that, the
tunnel server figures out which phone to contact and establishes a
connection with it, forwarding a small message from the laptop as it
does so. But, even though there is a pre-established relationship
between the phone and laptop, we always want to establish proximity for
security reasons. So the phone starts broadcasting a BLE advert.</p>
<p>Both parties to the transaction already have a connection to the
tunnel server, so the BLE advert doesn’t need to include the tunnel
server’s domain again, it just needs to include random data so that it’s
unpredictable. Once the laptop receives the BLE advert, it starts the
cryptographic handshake over the already established tunnel and proves
receipt to the phone. Now the devices once again have an encrypted
tunnel established between them and no QR scanning was necessary.</p>
<h2 id="ctap2-changes">CTAP2 changes</h2>
<p>While CTAP2 is used over the encrypted tunnel, it is a slight variant
of the protocol. As discussed in chapter 6, a single WebAuthn request
may generate many CTAP2 commands: in order to respect the memory limits
of security keys, lists of credential IDs might need to be batched, and
extensions such as largeBlob are implemented using a sequence of
commands to manage the storage on the security key.</p>
<p>But smartphones do not have the tight resource limits of an embedded
device. They also don’t want to disclose any information without the
user authorizing it. So, when working over a hybrid connection, the
phone really wants to receive a single CTAP2 command that contains
everything.</p>
<p>A phone also doesn’t want to produce a PUAT to represent user
verification (see <a href="#client-pin">here</a>) because it wants to
display the request to the user before asking the user for biometrics.
At best, the phone would return a dummy PUAT without actually collecting
user verification from the user and then do the actual user verification
after processing the main command. But all that would consume round
trips which, given that a hybrid connection runs over the internet,
could cause a significant delay.</p>
<p>Thus the flavor of CTAP2 used over hybrid does not do any PUAT
exchange, nor does it do any batching of credential IDs. Also, there is
a special flavor of the largeBlob extension used over hybrid which looks
just like the WebAuthn extension (but expressed in CBOR), and which
avoids the many round-trips used to implement largeBlob on a security
key. There is also a special version of the PRF extension, again looking
like the WebAuthn version, where the evaluation points for all possible
credentials are sent.</p>
<p><span id="prfalreadyhashed"></span> The PRF extension has another
problem when going over hybrid. If you recall, the evaluation points are
hashed before being sent to security keys, so the evaluation points sent
over hybrid are already hashed. But when the request is received at the
phone, the platform APIs typically expect unhashed inputs and would
normally hash them again, which would result in the wrong value. But it
is not possible for the phone to unhash the inputs as hash functions
are, by their very nature, irreversible.</p>
<p>So, on Android, a synthetic extension called
<code>prfAlreadyHashed</code> is synthesized for requests received over
hybrid, which has the same shape as the regular PRF extension, but where
the evaluation points are already hashed.</p>
<p>These tweaks to CTAP2 suggest that it was probably not the correct
protocol to use over hybrid. Instead, JSON-encoded WebAuthn requests and
responses should have been used. A future revision of the protocol may
thus change this.</p>

<p>Much of this book focuses on WebAuthn as implemented in browsers—its
original context. But Android, iOS, macOS, and Windows all implement
WebAuthn-inspired APIs that produce compatible signed messages. These
are the platform APIs.</p>
<h2 id="apple-platforms-1">Apple platforms</h2>
<p>In order to use the <a href="https://developer.apple.com/passkeys/">WebAuthn-like API on Apple
platforms</a>, start by importing <code>Authentication­Services</code>.
(This book assumes that you’re using Swift. If you’re using Objective C
then everything is the same, modulo syntax, and you’re probably very
used to translating from Swift at this point.)</p>
<h3 id="creating-credentials">Creating credentials</h3>
<p>Apple’s API is divided between one set of classes for handling
security keys and another for handling credentials on the local device
or over the hybrid transport. They have overlapping, but distinct, sets
of parameters. If you want to handle both in a given request (which will
often be the case) then you can pass one request of each type to the
ultimate <code>AS­Authorization­Controller</code>.</p>
<p>To create credentials on the local device (or on another phone via
scanning a QR code) then start with:</p>
<div id="cb60"><pre><code><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span>let</span> <span>provider</span> <span>=</span> ASAuthorizationPlatformPublicKeyCredentialProvider<span>(</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>      relyingPartyIdentifier<span>:</span> <span>&#34;example.com&#34;</span><span>)</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span>let</span> <span>request</span> <span>=</span> provider<span>.</span>createCredentialRegistrationRequest<span>(</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>      challenge<span>:</span> Data<span>([</span><span>0</span><span>]),</span>  <span>// fine unless attestation is used</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>      name<span>:</span> <span>&#34;user.name&#34;</span><span>,</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>      userID<span>:</span> Data<span>(</span><span>&#34;user.id&#34;</span><span>.</span>utf8<span>))</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a><span>let</span> <span>controller</span> <span>=</span> ASAuthorizationController<span>.</span><span>init</span><span>(</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>    authorizationRequests<span>:</span> <span>[</span>request<span>])</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>controller<span>.</span>delegate <span>=</span> <span>self</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>controller<span>.</span>presentationContextProvider <span>=</span> <span>self</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>controller<span>.</span>performRequests<span>()</span></span></code></pre></div>
<p>(Make sure that you’ve read chapter 5, have configured the associated
domains for your RP ID, and have set the <code>webcredentials</code>
entitlement for your project.)</p>
<p>The names in the API mirror the WebAuthn parameters and so should be
immediately clear. If not, see chapter 4.</p>
<p>Note: There’s no <code>displayName</code> parameter. Apple platforms
only support display names for security key requests and never show them
in their UI.</p>
<p>In iOS 18, the <code>request</code> object has a
<code>requestStyle</code> property that can be set to
<code>.conditional</code> to request that the creation happen silently.
This will only succeed soon after the user has filled a password from a
password manager into your app, but it lets you easily upgrade users
from passwords to passkeys. (See
<a href="#conditional-create">here</a>.)</p>
<p>There are also <code>largeBlob</code> and <code>prf</code> properties
to enable support for those extensions. See chapter 9.</p>
<p>You might notice that there’s no <code>excludeList</code> mentioned
so far. The Apple API doesn’t support setting an exclude list, except
for security key requests. Thus it’s not possible to avoid overwriting
existing credentials! Perhaps Apple will address this in a future
revision but currently you’ll need to think carefully about the
implications of this.</p>
<p>As a common pattern across all the calls documented here,
<code>controller</code> is passed two delegates (which can be the same
object). The <code>presentation­Context­Provider</code> answers a
<code>presentation­Anchor</code> message which provides the
<code>UIWindow</code> for the app:</p>
<div id="cb61"><pre><code><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span>class</span> ExamplePresentationDelegateClass<span>:</span> <span>NSObject</span><span>,</span> </span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>      <span>ASAuthorizationControllerPresentationContextProviding</span> <span>{</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  <span>var</span> <span>anchor</span><span>:</span> ASPresentationAnchor<span>?</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>  <span>func</span> <span>presentationAnchor</span><span>(</span><span>for</span> <span>controller</span><span>:</span> <span>ASAuthorizationController</span><span>)</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>         -&gt; <span>ASPresentationAnchor</span> <span>{</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>    <span>return</span> anchor<span>!</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>The <code>delegate</code> object handles success and failure
callbacks from the controller:</p>
<div id="cb62"><pre><code><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span>class</span> ExampleDelegateClass<span>:</span> <span>NSObject</span><span>,</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>      <span>ASAuthorizationControllerDelegate</span> <span>{</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  <span>...</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  <span>func</span> <span>authorizationController</span><span>(</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    <span>controller</span><span>:</span> <span>ASAuthorizationController</span><span>,</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    <span>didCompleteWithAuthorization</span> <span>authorization</span><span>:</span> <span>ASAuthorization</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>  <span>)</span> <span>{</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>      <span>switch</span> authorization<span>.</span>credential <span>{</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>      <span>case</span> <span>let</span> <span>registration</span> <span>as</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>           ASAuthorizationPublicKeyCredentialRegistration<span>:</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>          <span>let</span> <span>credID</span> <span>=</span> registration<span>.</span>credentialID</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>          <span>let</span> <span>clientDataJSON</span> <span>=</span> registration<span>.</span>rawClientDataJSON</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>          <span>let</span> <span>attestationObject</span> <span>=</span> registration<span>.</span>rawAttestationObject<span>!</span></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>          Self<span>.</span>logger<span>.</span>log<span>(</span></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>              <span>&#34;success: </span><span>\(</span><span>credID.base64EncodedString()) </span><span>\</span></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>              <span>(</span>clientDataJSON<span>.</span>base64EncodedString<span>())</span>    \</span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>              <span>(</span>attestationObject<span>.</span>base64EncodedString<span>())</span><span>&#34;)</span></span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>      <span>default</span><span>:</span></span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>          Self<span>.</span>logger<span>.</span>error<span>(</span><span>&#34;unknown ASAuthorization type received&#34;</span><span>)</span></span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true" tabindex="-1"></a>      <span>}</span></span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-24"><a href="#cb62-24" aria-hidden="true" tabindex="-1"></a>  <span>func</span> <span>authorizationController</span><span>(</span></span>
<span id="cb62-25"><a href="#cb62-25" aria-hidden="true" tabindex="-1"></a>    <span>controller</span><span>:</span> <span>ASAuthorizationController</span><span>,</span></span>
<span id="cb62-26"><a href="#cb62-26" aria-hidden="true" tabindex="-1"></a>    <span>didCompleteWithError</span> <span>error</span><span>:</span> <span>Error</span></span>
<span id="cb62-27"><a href="#cb62-27" aria-hidden="true" tabindex="-1"></a>  <span>)</span> <span>{</span></span>
<span id="cb62-28"><a href="#cb62-28" aria-hidden="true" tabindex="-1"></a>    Self<span>.</span>logger<span>.</span>error<span>(</span><span>&#34;failed: </span><span>\(</span><span>error)&#34;</span><span>)</span></span>
<span id="cb62-29"><a href="#cb62-29" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb62-30"><a href="#cb62-30" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Unfortunately, unlike with WebAuthn and the Android APIs, the
authenticator data and public key aren’t exposed directly. Instead you
must parse the CBOR in the attestation structure and extract the public
key and authenticator data from the raw contents. See chapter 7 for
details on how to do this, or seek a wrapper library that makes iOS more
friendly in this respect.</p>
<p>Let’s have a look at the authenticator data returned after creating a
credential in iCloud Keychain, the default passkey provider on Apple
platforms. We’ll break down the hex-encoded data with comments:</p>
<pre><code># The hash of the RP ID
26bd7278be463761f1faa1b10ab4c4f82670269c410c726a1fd6e05855e19b46
# Flags: AT + BE + BS + UV + UP
5d
# Signature counter; always zero
00000000

# Attested credential data
#  The AAGUID of iCloud Keychain
fbfc3007154e4ecc8c0b6e020557d7bd
#  Credential ID length: 20 bytes
0014
#  Credential ID
df46b51df21331fb23bbfa3e9622ae9fc92fc9ea
#  Public key in COSE format.
a501020326200121582071f5ce7ba3e4
4960ddc7f7026e708fc98a835039aa58
97f0d3c80373f3759d542258209e5f26
ec5c054c5841ac4b331bd79b196f006b
7a75e8e5ad585947b4edd3a5ac</code></pre>
<p>Since iCloud Keychain syncs credentials, the BE (Backup Eligible) and
BS (Backup State) flags are both set. The signature counter is always
zero because it would be implausible to synchronize a signature counter
between devices. iCloud Keychain sets a distinct AAGUID so that it can
be identified in account management UIs. (See
<a href="#settings">here</a>.)</p>
<p>To support creating a credential on a security key, add a security
key credential provider too:</p>
<div id="cb64"><pre><code><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>  <span>let</span> <span>provider</span> <span>=</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  ASAuthorizationSecurityKeyPublicKeyCredentialProvider<span>(</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    relyingPartyIdentifier<span>:</span> <span>&#34;example.com&#34;</span><span>)</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  <span>let</span> <span>skRequest</span> <span>=</span> provider<span>.</span>createCredentialRegistrationRequest<span>(</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    challenge<span>:</span> Data<span>([</span><span>0</span><span>]),</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    displayName<span>:</span> <span>&#34;user.displayName&#34;</span><span>,</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    name<span>:</span> <span>&#34;user.name&#34;</span><span>,</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>    userID<span>:</span> Data<span>(</span><span>&#34;user.id&#34;</span><span>.</span>utf8<span>))</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>  skRequest<span>.</span>credentialParameters <span>=</span> <span>[</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    ASAuthorizationPublicKeyCredentialParameters<span>.</span><span>init</span><span>(</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>        algorithm<span>:</span> ASCOSEAlgorithmIdentifier<span>.</span>ES256<span>)</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>  <span>]</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>  <span>let</span> <span>controller</span> <span>=</span> ASAuthorizationController<span>.</span><span>init</span><span>(</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>      authorizationRequests<span>:</span> <span>[</span>request<span>,</span> skRequest<span>])</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>  controller<span>.</span>delegate <span>=</span> <span>self</span></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>  controller<span>.</span>presentationContextProvider <span>=</span> <span>self</span></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>  controller<span>.</span>performRequests<span>()</span></span></code></pre></div>
<p>This time <code>display­Name</code> and
<code>credential­Parameters</code> are required to be set. Other
properties that can be set are <code>excluded­Credentials</code>,
<code>resident­Key­Preference</code>, <code>attestation­Preference</code>,
and <code>user­Verification­Preference</code>. Although the names are
slightly different, the meaning of all of these is the same as in
WebAuthn.</p>
<p>Most of the time you’ll want to support creating a credential both
locally and on a security key and thus will create requests from both
types of provider and pass both requests when initializing the
<code>AS­Authorization­Controller</code>.</p>
<h3 id="getting-signatures-1">Getting signatures</h3>
<p>When requesting a signature, the classes are again split between
using security keys or using a local credential / showing a QR code.</p>
<div id="cb65"><pre><code><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>assertCredentialOnPlatform</span><span>(</span><span>anchor</span><span>:</span> <span>ASPresentationAnchor</span><span>)</span> <span>{</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    <span>self</span><span>.</span>authenticationAnchor <span>=</span> anchor</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    <span>let</span> <span>provider</span> <span>=</span> ASAuthorizationPlatformPublicKeyCredentialProvider<span>(</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>      relyingPartyIdentifier<span>:</span> <span>&#34;example.com&#34;</span><span>)</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>    <span>let</span> <span>request</span> <span>=</span> provider<span>.</span>createCredentialAssertionRequest<span>(</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>      challenge<span>:</span> Data<span>(</span><span>&#34;SHOULDBERANDOMVALUEFROMSERVER!&#34;</span><span>.</span>utf8<span>))</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>    <span>let</span> <span>controller</span> <span>=</span> ASAuthorizationController<span>.</span><span>init</span><span>(</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>        authorizationRequests<span>:</span> <span>[</span>request<span>])</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    controller<span>.</span>delegate <span>=</span> <span>self</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    controller<span>.</span>presentationContextProvider <span>=</span> <span>self</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>    controller<span>.</span>performRequests<span>()</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span></code></pre></div>
<p>The properties <code>allowedCredentials</code>, <code>prf</code>, and
<code>largeBlob</code> are available on the <code>request</code> object,
with the same meanings as in WebAuthn. Obviously the challenge value
should be random and come from the server—the fixed value used in this
code example here is only for illustration and a fixed value should
never be used in real code.</p>
<p>The same pair of delegates is used and results are returned via a
different subclass of <code>ASAuthorization</code>:</p>
<div id="cb66"><pre><code><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>authorizationController</span><span>(</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    <span>controller</span><span>:</span> <span>ASAuthorizationController</span><span>,</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>    <span>didCompleteWithAuthorization</span> <span>authorization</span><span>:</span> <span>ASAuthorization</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>  <span>)</span> <span>{</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    <span>switch</span> authorization<span>.</span>credential <span>{</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    <span>case</span> <span>let</span> <span>assertion</span> <span>as</span> ASAuthorizationPublicKeyCredentialAssertion<span>:</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>        <span>let</span> <span>credID</span> <span>=</span> assertion<span>.</span>credentialID</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>        <span>let</span> <span>userID</span> <span>=</span> assertion<span>.</span>userID<span>;</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>        <span>let</span> <span>clientDataJSON</span> <span>=</span> assertion<span>.</span>rawClientDataJSON</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>        <span>let</span> <span>signature</span> <span>=</span> assertion<span>.</span>signature</span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>        <span>let</span> <span>authenticatorData</span> <span>=</span> assertion<span>.</span>rawAuthenticatorData</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>        Self<span>.</span>logger<span>.</span>log<span>(</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>            <span>&#34;success: </span><span>\(</span><span>credID.base64EncodedString()) </span><span>\</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>            \<span>(</span>clientDataJSON<span>.</span>base64EncodedString<span>())</span>   \</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>            \<span>(</span>signature<span>!.</span>base64EncodedString<span>())</span>       \</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>            \<span>(</span>authenticatorData<span>!.</span>base64EncodedString<span>())</span><span>&#34;</span></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>        <span>)</span></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>    <span>default</span><span>:</span></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>      Self<span>.</span>logger<span>.</span>error<span>(</span><span>&#34;unknown ASAuthorization type received&#34;</span><span>)</span></span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span></code></pre></div>
<p>Recall from chapter 5 that, for Apple platforms, the client data’s
<code>origin</code> is always a web origin (taken from the RP ID) even
when called from an app. For example, here’s the client data JSON from
the sample request above:</p>
<div id="cb67"><pre><code><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>  <span>&#34;type&#34;</span><span>:</span> <span>&#34;webauthn.get&#34;</span><span>,</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  <span>&#34;challenge&#34;</span><span>:</span> <span>&#34;Y2hhbGxlbmdl&#34;</span><span>,</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  <span>&#34;origin&#34;</span><span>:</span> <span>&#34;https://example.com&#34;</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>You would have expected the origin to be something like
<code>ios:­T7AYYU7S6A.­com.­YourApp</code>, but Apple platforms don’t let
you distinguish between apps and web origins!</p>
<p>The <code>performRequests</code> call also has a useful option to
control whether UI is shown or not:</p>
<div id="cb68"><pre><code><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>controller<span>.</span>performRequests<span>(</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    options<span>:</span> <span>.</span>preferImmediatelyAvailableCredentials<span>)</span></span></code></pre></div>
<p>When <code>prefer­Immediately­Available­Credentials</code> is given,
requests that don’t have any matching local credentials will fail
immediately and no UI will be shown. So this option lets you prompt for
a passkey only if one exists. When a request fails for this reason, the
error passed to
<code>authorization­Controller(controller:did­Complete­With­Error:)</code>
has code <code>AS­Authorization­Error­Canceled</code> and domain
<code>AS­AuthorizationError­Domain</code>. That is the same error that you
get if the user declines to use a passkey that does exist, although you
can tell the two apart based on how fast the error occurs. (And based on
the error message, although you can’t assume that will be stable.)</p>
<p>To accept a signature from a security key, as you generally should, a
second request object is needed:</p>
<div id="cb69"><pre><code><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>  <span>self</span><span>.</span>authenticationAnchor <span>=</span> anchor</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>  <span>let</span> <span>provider</span> <span>=</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  ASAuthorizationSecurityKeyPublicKeyCredentialProvider<span>(</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    relyingPartyIdentifier<span>:</span> <span>&#34;example.com&#34;</span><span>)</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  <span>let</span> <span>skRequest</span> <span>=</span> provider<span>.</span>createCredentialAssertionRequest<span>(</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    challenge<span>:</span> Data<span>(</span><span>&#34;SHOULDBERANDOMVALUEFROMSERVER&#34;</span><span>.</span>utf8<span>))</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>  <span>// Omit setting this property to request a discoverable credential.</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>  skRequest<span>.</span>allowedCredentials <span>=</span> <span>[</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>    ASAuthorizationSecurityKeyPublicKeyCredentialDescriptor<span>(</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>        credentialID<span>:</span> Data<span>(</span>base64Encoded<span>:</span> <span>&#34;AM==&#34;</span><span>)!,</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>        transports<span>:</span> <span>[</span><span>&#34;usb&#34;</span><span>])</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>  <span>]</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>  <span>let</span> <span>controller</span> <span>=</span> ASAuthorizationController<span>.</span><span>init</span><span>(</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>      authorizationRequests<span>:</span> <span>[</span>request<span>,</span> skRequest<span>])</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>  controller<span>.</span>delegate <span>=</span> <span>self</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>  controller<span>.</span>presentationContextProvider <span>=</span> <span>self</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>  controller<span>.</span>performRequests<span>()</span></span></code></pre></div>
<h2 id="android-1">Android</h2>
<p><span id="android"></span> To use <a href="https://developer.android.com/design/ui/mobile/guides/patterns/passkeys">WebAuthn
on Android</a>, start by importing these libraries:</p>
<pre><code>implementation(&#34;androidx.credentials:credentials:1.2.2&#34;)  
implementation(
  &#34;androidx.credentials:credentials-play-services-auth:1.2.2&#34;)</code></pre>
<p>(Although keep in mind that there’s likely a <a href="https://developer.android.com/jetpack/androidx/releases/credentials">newer
version</a> of them that you should use by the time you’re reading
this.)</p>
<p>Don’t forget to configure the <code>assetlinks.json</code> for your
RP ID. See chapter 5.</p>
<p>Rather than having an API that mirrors WebAuthn, Android just uses
JSON-encoded WebAuthn structures with any <code>ArrayBuffer</code>s
encoded using base64url. This is the same format that
<code>window.­Public­Key­Credential.­parse­Creation­Options­From­JSON</code>
takes on the web, allowing a backend to generate this form of request
and have it be easily consumed by web and Android frontends. (See
<a href="#json-conversion">here</a>.)</p>
<div id="cb71"><pre><code><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span>val</span> <span>request</span> <span>=</span> CreatePublicKeyCredentialRequest<span>(</span>  </span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>        requestJson <span>=</span> <span>&#34;&#34;&#34;  </span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span>  &#34;challenge&#34;: &#34;cmFuZG9tIGNoYWxsZW5nZQ&#34;,</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span>  &#34;rp&#34;: { &#34;id&#34;: &#34;example.com&#34;, &#34;name&#34;: &#34;example.com&#34; },</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a><span>  &#34;user&#34;: {</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span>    &#34;id&#34;: &#34;dXNlcmlk&#34;,</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a><span>    &#34;name&#34;: &#34;name&#34;,</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a><span>    &#34;displayName&#34;: &#34;displayName&#34;</span></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a><span>  },</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a><span>  &#34;pubKeyCredParams&#34;: [ {&#34;type&#34;: &#34;public-key&#34;, &#34;alg&#34;: -7} ],</span></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a><span>  &#34;authenticatorSelection&#34;: {</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a><span>    &#34;requireResidentKey&#34;: true,</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a><span>    &#34;authenticatorAttachment&#34;: &#34;platform&#34;</span></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a><span>  }</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a><span>}&#34;&#34;&#34;</span><span>,</span>  </span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a>    <span>)</span></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a>    <span>val</span> <span>credentialManager</span> <span>=</span> CredentialManager<span>.</span>create<span>(</span>requireContext<span>())</span>  </span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a>    coroutineScope<span>.</span>launch <span>{</span>  </span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a>        <span>try</span> <span>{</span>  </span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a>            <span>val</span> <span>result</span> <span>=</span> credentialManager<span>.</span>createCredential<span>(</span>  </span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a>                context <span>=</span> requireActivity<span>(),</span>  </span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a>                request <span>=</span> request<span>,</span>  </span>
<span id="cb71-25"><a href="#cb71-25" aria-hidden="true" tabindex="-1"></a>            <span>)</span>  </span>
<span id="cb71-26"><a href="#cb71-26" aria-hidden="true" tabindex="-1"></a>            <span>when</span> <span>(</span>result<span>)</span> <span>{</span>  </span>
<span id="cb71-27"><a href="#cb71-27" aria-hidden="true" tabindex="-1"></a>                <span>is</span> CreatePublicKeyCredentialResponse <span>-&gt;</span> <span>{</span></span>
<span id="cb71-28"><a href="#cb71-28" aria-hidden="true" tabindex="-1"></a>                    <span>// This is a JSON-encoded response. See below for</span></span>
<span id="cb71-29"><a href="#cb71-29" aria-hidden="true" tabindex="-1"></a>                    <span>// an example.</span></span>
<span id="cb71-30"><a href="#cb71-30" aria-hidden="true" tabindex="-1"></a>                    println<span>(</span>result<span>.</span>registrationResponseJson<span>)</span>  </span>
<span id="cb71-31"><a href="#cb71-31" aria-hidden="true" tabindex="-1"></a>                <span>}</span>  </span>
<span id="cb71-32"><a href="#cb71-32" aria-hidden="true" tabindex="-1"></a>                <span>else</span> <span>-&gt;</span> <span>{</span>  </span>
<span id="cb71-33"><a href="#cb71-33" aria-hidden="true" tabindex="-1"></a>                    <span>// Unknown response type.  </span></span>
<span id="cb71-34"><a href="#cb71-34" aria-hidden="true" tabindex="-1"></a>                <span>}</span>  </span>
<span id="cb71-35"><a href="#cb71-35" aria-hidden="true" tabindex="-1"></a>            <span>}</span>  </span>
<span id="cb71-36"><a href="#cb71-36" aria-hidden="true" tabindex="-1"></a>        <span>}</span> <span>catch</span> <span>(</span>e<span>:</span> CreateCredentialException<span>)</span> <span>{</span>  </span>
<span id="cb71-37"><a href="#cb71-37" aria-hidden="true" tabindex="-1"></a>            <span>when</span> <span>(</span>e<span>)</span> <span>{</span>  </span>
<span id="cb71-38"><a href="#cb71-38" aria-hidden="true" tabindex="-1"></a>                <span>is</span> CreatePublicKeyCredentialDomException <span>-&gt;</span> <span>{</span>  </span>
<span id="cb71-39"><a href="#cb71-39" aria-hidden="true" tabindex="-1"></a>                    <span>when</span> <span>(</span>e<span>.</span>domError<span>)</span> <span>{</span>  </span>
<span id="cb71-40"><a href="#cb71-40" aria-hidden="true" tabindex="-1"></a>                        <span>is</span> InvalidStateError <span>-&gt;</span> <span>{</span>  </span>
<span id="cb71-41"><a href="#cb71-41" aria-hidden="true" tabindex="-1"></a>                            <span>// Credential already exists  </span></span>
<span id="cb71-42"><a href="#cb71-42" aria-hidden="true" tabindex="-1"></a>                        <span>}</span>  </span>
<span id="cb71-43"><a href="#cb71-43" aria-hidden="true" tabindex="-1"></a>                        <span>// Other error  </span></span>
<span id="cb71-44"><a href="#cb71-44" aria-hidden="true" tabindex="-1"></a>                    <span>}</span>  </span>
<span id="cb71-45"><a href="#cb71-45" aria-hidden="true" tabindex="-1"></a>                <span>}</span>  </span>
<span id="cb71-46"><a href="#cb71-46" aria-hidden="true" tabindex="-1"></a>                <span>else</span> <span>-&gt;</span> <span>{</span>  </span>
<span id="cb71-47"><a href="#cb71-47" aria-hidden="true" tabindex="-1"></a>                  <span>// Other error  </span></span>
<span id="cb71-48"><a href="#cb71-48" aria-hidden="true" tabindex="-1"></a>                <span>}</span>  </span>
<span id="cb71-49"><a href="#cb71-49" aria-hidden="true" tabindex="-1"></a>            <span>}</span> </span>
<span id="cb71-50"><a href="#cb71-50" aria-hidden="true" tabindex="-1"></a>        <span>}</span>  </span>
<span id="cb71-51"><a href="#cb71-51" aria-hidden="true" tabindex="-1"></a>    <span>}</span>  </span></code></pre></div>
<p>The only non-boilerplate above is the request JSON, and it should be
familiar to you from chapter 4. The responses are also just JSON-encoded
WebAuthn structures:</p>
<div id="cb72"><pre><code><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>  <span>&#34;rawId&#34;</span><span>:</span> <span>&#34;uGZDSrbiPsPDJ1gv1ebluA&#34;</span><span>,</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>  <span>&#34;id&#34;</span><span>:</span> <span>&#34;uGZDSrbiPsPDJ1gv1ebluA&#34;</span><span>,</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>  <span>&#34;authenticatorAttachment&#34;</span><span>:</span> <span>&#34;platform&#34;</span><span>,</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>  <span>&#34;type&#34;</span><span>:</span> <span>&#34;public-key&#34;</span><span>,</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>  <span>&#34;response&#34;</span><span>:</span> <span>{</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>    <span>&#34;clientDataJSON&#34;</span><span>:</span> <span>&#34;eyJ0eXBlIjoi...&#34;</span><span>,</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>    <span>&#34;attestationObject&#34;</span><span>:</span> <span>&#34;o2NmbXRkbm...&#34;</span><span>,</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>    <span>&#34;transports&#34;</span><span>:</span> <span>[</span><span>&#34;internal&#34;</span><span>,</span> <span>&#34;hybrid&#34;</span><span>]</span><span>,</span></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>    <span>&#34;authenticatorData&#34;</span><span>:</span> <span>&#34;Jr1yeL5GN2Hx-qGxCrTE-CZwJpxBDHJqH9bgWFXhm...&#34;</span><span>,</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>    <span>&#34;publicKeyAlgorithm&#34;</span><span>:</span> <span>-7</span><span>,</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>    <span>&#34;publicKey&#34;</span><span>:</span> <span>&#34;MFkwEwYHKoZ...&#34;</span></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>  <span>},</span></span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>  <span>&#34;clientExtensionResults&#34;</span><span>:</span> <span>{</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>    <span>&#34;credProps&#34;</span><span>:</span> <span>{</span><span>&#34;rk&#34;</span><span>:</span> <span>true</span><span>}</span></span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>The first two lines of the JSON might look odd but, if you recall
from the WebAuthn chapter, the <code>id</code> field of WebAuthn’s
<code>PublicKey­Credential</code> dictionary is the base64url-encoded
credential ID, while the <code>rawId</code> field is the credential ID
as an <code>ArrayBuffer</code>. Since, in the JSON form,
<code>ArrayBuffer</code>s are base64url-encoded, the JSON does indeed
end up with two copies of the same value!</p>
<p>But otherwise there’s nothing new that you need to learn here due to
the adherence to regular WebAuthn. Also note that the
<code>getPublicKey</code>, <code>get­Public­Key­Algorithm</code>, and
<code>get­AuthenticatorData</code> helpers in WebAuthn have been turned
into fields in the above JSON. So the public key is directly available
in the more useful SPKI format.</p>
<p>Note: the JSON result is the same as
<code>Public­Key­Credential.­to­JSON</code> will produce on the web.</p>
<p>Long fields have been elided in the example above, but here’s the
decoded <code>clientDataJSON</code>:</p>
<div id="cb73"><pre><code><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>  <span>&#34;type&#34;</span><span>:</span> <span>&#34;webauthn.create&#34;</span><span>,</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>  <span>&#34;challenge&#34;</span><span>:</span> <span>&#34;cmFuZG9tIGNoYWxsZW5nZQ&#34;</span><span>,</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>  <span>&#34;origin&#34;</span><span>:</span> <span>&#34;android:apk-key-hash:wGsazqR2MsDW-DBK0TJQqBlYUK2MD59aPxzt5rl5Bsc&#34;</span><span>,</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>  <span>&#34;androidPackageName&#34;</span><span>:</span> <span>&#34;com.example.webauthn&#34;</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Note that the origin reflects that the caller was an app, not a
website. The app is identified by the hash of the signing certificate
but the package name is also available. Your server will need to be
updated to recognize the app as legitimate.</p>
<p>(This value after <code>apk-key-hash</code> is the same SHA-256
signing-certificate hash as you put in your <code>assetlinks.json</code>
file, but base64url-encoded, rather than hex-encoded.)</p>
<h3 id="getting-an-assertion">Getting an assertion</h3>
<p>Getting an assertion looks very similar, just with some different
classes. Again, the request and response are just JSON-encoded WebAuthn
structures:</p>
<div id="cb74"><pre><code><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span>val</span> <span>request</span> <span>=</span> GetPublicKeyCredentialOption<span>(</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    requestJson <span>=</span> <span>&#34;&#34;&#34;  </span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span>  &#34;challenge&#34;: &#34;cmFuZG9tIGNoYWxsZW5nZQ&#34;,</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span>  &#34;rpId&#34;: &#34;example.com&#34;</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a><span>&#34;&#34;&#34;</span><span>)</span>  </span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a><span>val</span> <span>credentialManager</span> <span>=</span> CredentialManager<span>.</span>create<span>(</span>requireContext<span>())</span>  </span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>coroutineScope<span>.</span>launch <span>{</span>  </span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>    <span>try</span> <span>{</span>  </span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>        <span>val</span> <span>result</span> <span>=</span> credentialManager<span>.</span>getCredential<span>(</span>  </span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>            context <span>=</span> requireActivity<span>(),</span>  </span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>            request <span>=</span> GetCredentialRequest<span>(</span>listOf<span>(</span>request<span>)),</span>  </span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>        <span>)</span>  </span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>        <span>when</span> <span>(</span><span>val</span> <span>cred</span> <span>=</span> result<span>.</span>credential<span>)</span> <span>{</span>  </span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>            <span>is</span> PublicKeyCredential <span>-&gt;</span> <span>{</span>  </span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>                println<span>(</span>cred<span>.</span>authenticationResponseJson<span>)</span>  </span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>            <span>}</span>  </span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a>            <span>else</span> <span>-&gt;</span> <span>{</span>  </span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true" tabindex="-1"></a>                <span>// Unknown response type.  </span></span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true" tabindex="-1"></a>            <span>}</span>  </span>
<span id="cb74-22"><a href="#cb74-22" aria-hidden="true" tabindex="-1"></a>        <span>}</span>  </span>
<span id="cb74-23"><a href="#cb74-23" aria-hidden="true" tabindex="-1"></a>    <span>}</span> <span>catch</span> <span>(</span>e<span>:</span> GetCredentialException<span>)</span> <span>{</span>  </span>
<span id="cb74-24"><a href="#cb74-24" aria-hidden="true" tabindex="-1"></a>        println<span>(</span>e<span>)</span>  </span>
<span id="cb74-25"><a href="#cb74-25" aria-hidden="true" tabindex="-1"></a>    <span>}</span>  </span>
<span id="cb74-26"><a href="#cb74-26" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Just for reference, here’s the resulting JSON. Again, none of the
fields should be surprising. (The <code>clientDataJSON</code> has a
similar form to the one shown above.)</p>
<div id="cb75"><pre><code><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>  <span>&#34;rawId&#34;</span><span>:</span><span>&#34;uGZDSrbiPsPDJ1gv1ebluA&#34;</span><span>,</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>  <span>&#34;id&#34;</span><span>:</span><span>&#34;uGZDSrbiPsPDJ1gv1ebluA&#34;</span><span>,</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>  <span>&#34;authenticatorAttachment&#34;</span><span>:</span><span>&#34;platform&#34;</span><span>,</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>  <span>&#34;type&#34;</span><span>:</span><span>&#34;public-key&#34;</span><span>,</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>  <span>&#34;response&#34;</span><span>:{</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>    <span>&#34;clientDataJSON&#34;</span><span>:</span><span>&#34;eyJ0eXBlIjoid2ViYXV...&#34;</span><span>,</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>    <span>&#34;authenticatorData&#34;</span><span>:</span><span>&#34;Jr1yeL5GN2Hx-qGxCrTE-CZw...&#34;</span><span>,</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>    <span>&#34;signature&#34;</span><span>:</span><span>&#34;MEUCIQDi0o8OOtUJQDKtFLBMU_Cnuycd...&#34;</span><span>,</span></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>    <span>&#34;userHandle&#34;</span><span>:</span><span>&#34;dXNlcmlk&#34;</span></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>  <span>},</span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>  <span>&#34;clientExtensionResults&#34;</span><span>:{}</span></span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Like the Apple platform API,
<code>Get­Public­Key­Credential­Option</code> supports a
<code>prefer­Immediately­Available­Credentials</code> argument, which will
cause the operation to return immediately if there are no local
credentials available.</p>
<h2 id="windows">Windows</h2>
<p>Although non-browser applications use WebAuthn much less frequently
on Windows than on mobile platforms, Windows does provide an API for it.
We won’t dive into it in detail, but it is well explained in the <a href="https://github.com/microsoft/webauthn/blob/master/webauthn.h">header
file</a> provided by Microsoft.</p>
<p>Unlike the mobile platforms, there is no need to configure any files
on your server to authorize the use of an RP ID, as the Windows API
trusts applications to assert any RP ID.</p>
<p>Windows also enjoys the most complete security key support of any of
the platform APIs, although the platform authenticator, Windows Hello,
does not sync credentials at the time of writing.</p>

<p>This chapter will cover some of the details of a server-side
implementation of Web­Authn. This helps you understand what’s going on,
but doing everything yourself is not necessarily the best choice: when
implementing the server side you may well be best served by using an
existing library for WebAuthn support. However, I do claim that it’s
perfectly practical to build support yourself if you wish.</p>
<p>This chapter will assume that you’re building a flow based on
discoverable credentials because that’s the most common option. Some
changes are needed if you want to build a purely 2nd-factor flow but, if
you’ve read chapter 4, you should be well positioned to make those
tweaks.</p>
<p>First, a brief checklist of basics to take care of:</p>
<ol type="1">
<li>If your website doesn’t already use HTTPS, fix that first. WebAuthn
only works on secure origins.</li>
<li>Pick your RP ID. (See chapter 5.) We’ll assume here that the RP ID
will be <code>example.com</code>.</li>
<li>Set up assetlinks and associated domains files to support mobile
platforms as needed. (See <a href="#rp-id-mobile">here</a>.)</li>
</ol>
<p>Presumably you already have a database table of users. Perhaps it
contains salted and hashed passwords for authentication, and maybe phone
numbers for SMS OTP. Passkeys aren’t just another column because, while
an account can only have one password, an account can have multiple
passkeys. Don’t make the mistake of limiting accounts to a single
passkey!</p>
<p>So you need to have a separate table for passkeys with a foreign-key
relation to the primary key used to identify accounts:</p>
<div id="cb76"><pre><code><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span>CREATE</span> <span>TABLE</span> passkeys (</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>  cred_id <span>BLOB</span> <span>PRIMARY</span> <span>KEY</span>,</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>  username STRING <span>NOT</span> <span>NULL</span>,</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>  public_key_spki <span>BLOB</span>,</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>  backed_up <span>BOOLEAN</span>,</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>  <span>/* You may also want creation_time, last_used_time, and perhaps</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a><span>     aaguid columns. */</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>  <span>FOREIGN</span> <span>KEY</span>(username) <span>REFERENCES</span> users(username));</span></code></pre></div>
<p>Recall from <a href="#user-id">here</a> that the <code>user.id</code>
in a credential creation request should be an opaque identifier for an
account, and from <a href="#ctap2-user-id">here</a> that security keys
don’t consider this value to be sensitive thus it shouldn’t be possible
to identify the user from this value. You may already have a user ID in
your system, but are you sure that it doesn’t leak out anywhere else? If
so, perhaps it’s a reasonable value to use as the user ID. But otherwise
it might be safer to generate a fresh identifier for just this
purpose:</p>
<div id="cb77"><pre><code><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span>ALTER</span> <span>TABLE</span> users <span>ADD</span> <span>COLUMN</span> passkey_id <span>blob</span> <span>DEFAULT</span>(randomblob(<span>16</span>));</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span>/* The CASE expression causes the function to be non-constant. */</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a><span>UPDATE</span> users <span>SET</span> passkey_id<span>=</span>hex(randomblob(<span>CASE</span> <span>rowid</span> <span>WHEN</span> <span>0</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>                                                      <span>THEN</span> <span>16</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>                                                      <span>ELSE</span> <span>16</span> <span>END</span>));</span></code></pre></div>
<p>(This SQL is just an example. You’ll need to adjust it for your
specific environment.)</p>
<p>These SQL snippets assume that your table of passkeys is keyed by the
credential ID, and that your user IDs are random. These are the correct
choices for the majority of sites.</p>
<p>However, there are some cases where your users are split up. Perhaps
as the result of an acquisition or the merging of disparate systems, you
might need to know in which universe an account lives in order to be
able to efficiently look it up. But when you get a WebAuthn assertion
that contains a credential ID, the ID is random: you don’t know from
which universe it came. <span id="user-id-universe"></span></p>
<p>In this case, you can use structured user ID values. Because an
assertion from a discoverable credential also returns the user ID, and
that’s a value chosen by the server, you can encode whatever universe
information you need in it.</p>
<p>We won’t develop this possibility any further as it’s mentioned only
for the handful of people who will find this hint useful.</p>
<h3 id="enrolling-existing-users">Enrolling existing users</h3>
<p>When a user signs-in with a password, you might want them to create a
passkey on the local device for easier sign-in next time. First, check
that a local platform authenticator exists and that the browser or
mobile platform supports passkeys / conditional UI. (See
<a href="#isuvpaa">here</a>.)</p>
<p>Next, try conditionally creating a passkey; see
<a href="#conditional-create">here</a>. (Conditional creation may also
be available via platform APIs.) If this doesn’t work, you may want to
prompt the user to create a passkey and use the traditional modal UI
flow.</p>
<p>In both the conditional and modal cases, the server will need to send
creation parameters to the client. Below the parameters are represented
as a Javascript object for the purposes of exposition but note that both
Android and, increasingly, the web support accepting JSON-encoded
requests. (See <a href="#json-conversion">here</a>.) Unfortunately, the
iOS API does not accept JSON, and so either your backend will need to
produce a different style of output for any iOS apps, or else you’ll
need to implement a converter in the app from JSON to the native API on
that platform.</p>
<div id="cb78"><pre><code><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span>var</span> createOptions <span>:</span> CredentialCreationOptions <span>=</span> {</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>  publicKey<span>:</span> {</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    rp<span>:</span> {</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>      <span>// The RP ID.</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>      id<span>:</span> <span>&#34;example.com&#34;</span><span>,</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>      <span>// This field is required to be set to something but is not</span></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>      <span>// currently used by any implementations.</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>      name<span>:</span> <span>&#34;&#34;</span><span>,</span></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>    }<span>,</span></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>    user<span>:</span> {</span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>      <span>// `userIdBase64` is the passkey_id field from the users table,</span></span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>      <span>// base64-encoded.</span></span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a>      id<span>:</span> <span>Uint8Array</span><span>.</span><span>from</span>(<span>atob</span>(userIdBase64)<span>,</span> c <span>=&gt;</span> c<span>.</span><span>charCodeAt</span>(<span>0</span>))<span>,</span></span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a>      <span>// `username` is the username field from the users table.</span></span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a>      name<span>:</span> username<span>,</span></span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a>      <span>// `displayName` can be a more human name for the user, or</span></span>
<span id="cb78-18"><a href="#cb78-18" aria-hidden="true" tabindex="-1"></a>      <span>// just leave it blank.</span></span>
<span id="cb78-19"><a href="#cb78-19" aria-hidden="true" tabindex="-1"></a>      displayName<span>:</span> <span>&#34;&#34;</span><span>,</span></span>
<span id="cb78-20"><a href="#cb78-20" aria-hidden="true" tabindex="-1"></a>    }<span>,</span></span>
<span id="cb78-21"><a href="#cb78-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-22"><a href="#cb78-22" aria-hidden="true" tabindex="-1"></a>    <span>// This lists the ids of the user&#39;s existing credentials. I.e.</span></span>
<span id="cb78-23"><a href="#cb78-23" aria-hidden="true" tabindex="-1"></a>    <span>//   SELECT cred_id FROM passkeys WHERE username = ?</span></span>
<span id="cb78-24"><a href="#cb78-24" aria-hidden="true" tabindex="-1"></a>    <span>// and supply the resulting list of values, base64-encoded, as</span></span>
<span id="cb78-25"><a href="#cb78-25" aria-hidden="true" tabindex="-1"></a>    <span>// existingCredentialIdsBase64 here.</span></span>
<span id="cb78-26"><a href="#cb78-26" aria-hidden="true" tabindex="-1"></a>    excludeCredentials<span>:</span> existingCredentialIdsBase64<span>.</span><span>map</span>(id <span>=&gt;</span> {</span>
<span id="cb78-27"><a href="#cb78-27" aria-hidden="true" tabindex="-1"></a>      <span>return</span> {</span>
<span id="cb78-28"><a href="#cb78-28" aria-hidden="true" tabindex="-1"></a>        type<span>:</span> <span>&#34;public-key&#34;</span><span>,</span></span>
<span id="cb78-29"><a href="#cb78-29" aria-hidden="true" tabindex="-1"></a>        id<span>:</span> <span>Uint8Array</span><span>.</span><span>from</span>(<span>atob</span>(id)<span>,</span> c <span>=&gt;</span> c<span>.</span><span>charCodeAt</span>(<span>0</span>))<span>,</span></span>
<span id="cb78-30"><a href="#cb78-30" aria-hidden="true" tabindex="-1"></a>      }<span>;</span></span>
<span id="cb78-31"><a href="#cb78-31" aria-hidden="true" tabindex="-1"></a>    })<span>,</span></span>
<span id="cb78-32"><a href="#cb78-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-33"><a href="#cb78-33" aria-hidden="true" tabindex="-1"></a>    <span>// Boilerplate that advertises support for P-256 ECDSA and RSA</span></span>
<span id="cb78-34"><a href="#cb78-34" aria-hidden="true" tabindex="-1"></a>    <span>// PKCS#1v1.5. Supporting these key types results in universal</span></span>
<span id="cb78-35"><a href="#cb78-35" aria-hidden="true" tabindex="-1"></a>    <span>// coverage so far.</span></span>
<span id="cb78-36"><a href="#cb78-36" aria-hidden="true" tabindex="-1"></a>    pubKeyCredParams<span>:</span> [{</span>
<span id="cb78-37"><a href="#cb78-37" aria-hidden="true" tabindex="-1"></a>      type<span>:</span> <span>&#34;public-key&#34;</span><span>,</span></span>
<span id="cb78-38"><a href="#cb78-38" aria-hidden="true" tabindex="-1"></a>      alg<span>:</span> <span>-</span><span>7</span></span>
<span id="cb78-39"><a href="#cb78-39" aria-hidden="true" tabindex="-1"></a>    }<span>,</span> {</span>
<span id="cb78-40"><a href="#cb78-40" aria-hidden="true" tabindex="-1"></a>      type<span>:</span> <span>&#34;public-key&#34;</span><span>,</span></span>
<span id="cb78-41"><a href="#cb78-41" aria-hidden="true" tabindex="-1"></a>      alg<span>:</span> <span>-</span><span>257</span></span>
<span id="cb78-42"><a href="#cb78-42" aria-hidden="true" tabindex="-1"></a>    }]<span>,</span></span>
<span id="cb78-43"><a href="#cb78-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-44"><a href="#cb78-44" aria-hidden="true" tabindex="-1"></a>    <span>// Unused during registrations, except when doing attestation.</span></span>
<span id="cb78-45"><a href="#cb78-45" aria-hidden="true" tabindex="-1"></a>    <span>// (But don&#39;t do this during sign-in!)</span></span>
<span id="cb78-46"><a href="#cb78-46" aria-hidden="true" tabindex="-1"></a>    challenge<span>:</span> <span>new</span> <span>Uint8Array</span>([<span>0</span>])<span>,</span></span>
<span id="cb78-47"><a href="#cb78-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-48"><a href="#cb78-48" aria-hidden="true" tabindex="-1"></a>    authenticatorSelection<span>:</span> {</span>
<span id="cb78-49"><a href="#cb78-49" aria-hidden="true" tabindex="-1"></a>      authenticatorAttachment<span>:</span> <span>&#34;platform&#34;</span><span>,</span></span>
<span id="cb78-50"><a href="#cb78-50" aria-hidden="true" tabindex="-1"></a>      requireResidentKey<span>:</span> <span>true</span><span>,</span></span>
<span id="cb78-51"><a href="#cb78-51" aria-hidden="true" tabindex="-1"></a>    }<span>,</span></span>
<span id="cb78-52"><a href="#cb78-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-53"><a href="#cb78-53" aria-hidden="true" tabindex="-1"></a>    <span>// Five minutes.</span></span>
<span id="cb78-54"><a href="#cb78-54" aria-hidden="true" tabindex="-1"></a>    timeout<span>:</span> <span>300000</span><span>,</span></span>
<span id="cb78-55"><a href="#cb78-55" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb78-56"><a href="#cb78-56" aria-hidden="true" tabindex="-1"></a>}<span>;</span></span>
<span id="cb78-57"><a href="#cb78-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-58"><a href="#cb78-58" aria-hidden="true" tabindex="-1"></a><span>navigator</span><span>.</span><span>credentials</span><span>.</span><span>create</span>(createOptions)<span>.</span><span>then</span>(</span>
<span id="cb78-59"><a href="#cb78-59" aria-hidden="true" tabindex="-1"></a>  handleCreation<span>,</span> handleCreationError)<span>;</span></span></code></pre></div>
<h3 id="recording-a-passkey">Recording a passkey</h3>
<p>When the promise
from <code>navigator.credentials.create</code> resolves successfully,
you have a newly created passkey! Now you have to ensure that it gets
recorded by the server.</p>
<p>The promise will result in a <a href="https://www.w3.org/TR/webauthn-2/#iface-pkcredential"><code>PublicKeyCredential</code></a> object,
the <code>response</code> field of which is an <a href="https://www.w3.org/TR/webauthn-2/#authenticatorattestationresponse"><code>AuthenticatorAttestationResponse</code></a>.</p>
<p>Call <code>getAuthenticatorData()</code> and <code>getPublicKey()</code> on <code>response</code> and
send those ArrayBuffers to the server. (These fields also exist in the
JSON output from the Android platform APIs but, sadly, not on iOS where
they would have to be polyfilled.)</p>
<p>At the server, we want to insert a row into
the <code>passkeys</code> table for this user. The <a href="https://w3c.github.io/webauthn/#authenticator-data">authenticator
data</a> is a fairly simple, binary format (see
<a href="#authdata">here</a>). Offset 32 contains the flags byte. Sanity
check that bit 6 is set and then extract:</p>
<ol type="1">
<li>Bit 4 as the value of <code>backed_up</code>.
(I.e. <code>(authData[32] &gt;&gt; 4) &amp; 1</code>.)</li>
<li>The big-endian, uint16 at offset 53 as the length of the credential
ID.</li>
<li>That many bytes from offset 55 as the value of <code>id</code>.</li>
</ol>
<p>The ArrayBuffer that came from <code>getPublicKey()</code> is the
value for <code>public_key_spki</code>. That should be all the values
needed to insert the row.</p>
<p>Note: Neither the user presence nor user verification bits are
checked above. This works for conditional creation (see
<a href="#conditional-create">here</a>) but might not be right for every
deployment.</p>
<h3 id="handling-a-registration-exception">Handling a registration
exception</h3>
<p>The promise from <code>create()</code> might also result in an
exception. <code>InvalidStateError</code> is special and means that a
passkey already exists for the local device. This is not an error, and
no error will have been shown to the user. They’ll have seen a UI just
like they were registering a passkey but the server doesn’t need to
update anything.</p>
<p><code>NotAllowedError</code> means that the user canceled the
operation. Other exceptions mean that something more unexpected
happened.</p>
<p>The WebAuthn-family APIs on mobile platforms will have similarly
structured errors. See chapter 11.</p>
<h3 id="signing-in">Signing in</h3>
<p>See chapter 8 for details on using conditional UI for signing in on
the web, and chapter 11 for details of invoking the APIs on mobile
platforms to do something similar.</p>
<p>One thing that all of these APIs will need is a challenge value. See
<a href="#challenge-of">here</a> about picking challenge values.
Otherwise, assuming that you’re using discoverable credentials, there
aren’t any other inputs. (There couldn’t be because, at this point, you
don’t know who the user is!)</p>
<p>A successful response from all these APIs will include the:</p>
<ul>
<li>Credential ID (called the <code>rawId</code> in WebAuthn’s
result).</li>
<li>Client data JSON (see <a href="#client-data">here</a>).</li>
<li>Authenticator data (see <a href="#authdata">here</a>).</li>
<li>Signature.</li>
</ul>
<p>Those values should be sent to the server for validation. At the
server, first look up the
passkey: <code>SELECT username, public_key_spki, backed_up FROM passkeys WHERE cred_id = ?</code> and
give the credential ID value for matching.
The <code>cred_id</code> column is a primary key, so there can either be
zero or one matching row(s). If there are zero rows then the user is
signing in with a passkey that the server doesn’t know about—perhaps
they deleted it. This is an error, reject the sign-in.</p>
<p>Otherwise, the server now knows the claimed username and public key.
To validate the signature you’ll need to construct the signed data and
parse the public key. The <code>public_key_spki</code> values from the
database are stored in SubjectPublicKeyInfo format and most languages
will have some way to ingest them. See chapter 13.</p>
<p>Your language’s crypto library should provide a function that takes a
signature and some signed data and tells you whether that signature is
valid for a given public key. For the signed data, calculate the SHA-256
hash of the client data JSON and append it to the contents of the
authenticator data. If the signature isn’t valid, reject the
sign-in.</p>
<p>But there are still a number of things that you need to check!</p>
<p>Parse the client data as UTF-8 JSON and check that:</p>
<ol type="1">
<li>It’s valid JSON.</li>
<li>The <code>type</code> member is <code>webauthn.get</code>.</li>
<li>The <code>challenge</code> member is equal to the base64url encoding
of the challenge that the server gave for this sign-in.</li>
<li>The <code>origin</code> member is equal to your site’s sign-in
origin (e.g. a string like <code>“https://www.example.com”</code>), or
is a recognised Android app.</li>
<li>The <code>crossOrigin</code> member, if present, is false.</li>
</ol>
<p>There’s more! Take the <code>authenticatorData</code> and check
that:</p>
<ol type="1">
<li>The first 32 bytes are equal to the SHA-256 hash of the RP ID that
you’re using.</li>
<li>That bit zero of the byte at offset 32 is one.
I.e. <code>(authData[32] &amp; 1) == 1</code>. This is the <a href="https://www.w3.org/TR/webauthn-2/#test-of-user-presence">user
presence bit</a> that indicates that a user approved the signature.</li>
</ol>
<p>If all those checks work out, then sign in the user whose passkey it
was. E.g. set a cookie and respond to the running Javascript so that it
can update the page.</p>
<p>If the stored value of <code>backed_up</code> is not equal
to <code>(authData[32] &gt;&gt; 4) &amp; 1</code> then update that in
the database.</p>
<p>Note: The user verification bit isn’t checked above, but some sites
might want to require user verification.</p>
<h2 id="removing-passwords">Removing passwords</h2>
<p>Once a user is using passkeys to sign in, great! But if they were
upgraded from a password then that password is hanging around on the
account, doing nothing useful yet creating risk. It would be good to ask
the user about removing the password.</p>
<p>Doing this is reasonable if the account has a backed-up passkey. I.e.
if <code>SELECT 1 FROM passkeys WHERE username = ? AND backed_up = TRUE</code> returns
results. A site might consider prompting the user to remove the password
on an account when they sign in with a passkey and have a backed-up one
registered.</p>
<h2 id="settings">Settings</h2>
<p>If you’ve used passkeys with any sites, then you’ll have noticed that
they tend to list registered passkeys in their account settings, let
users name each one, show the last used time, and let them be
individually removed. If you want to do this then you’ll need to add
more columns to the <code>passkeys</code> table that we sketched above
to support this. You might also want to record the AAGUID in order to
automatically show where a passkey is stored.</p>
<p>Recall from <a href="#aaguid">here</a> that the AAGUID is the first
16 bytes of the attested credential data that is inside the
authenticator data when creating a credential. It will generally reveal
which passkey provider created a given credential. (If it was a passkey
provider and not a security key, that is.) If the AAGUID is not the
all-zero value, then it might be one of the following values:</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>08987058-cadc-4b81-b6e1-30de50dcbe96</code></td>
<td>Windows Hello</td>
</tr>
<tr>
<td><code>0ea242b4-43c4-4a1b-8b17-dd6d0b6baec6</code></td>
<td>Keeper</td>
</tr>
<tr>
<td><code>17290f1e-c212-34d0-1423-365d729f09d9</code></td>
<td>Thales PIN iOS SDK</td>
</tr>
<tr>
<td><code>39a5647e-1853-446c-a1f6-a79bae9f5bc7</code></td>
<td>IDmelon</td>
</tr>
<tr>
<td><code>50726f74-6f6e-5061-7373-50726f746f6e</code></td>
<td>Proton Pass</td>
</tr>
<tr>
<td><code>531126d6-e717-415c-9320-3d9aa6981239</code></td>
<td>Dashlane</td>
</tr>
<tr>
<td><code>53414d53-554e-4700-0000-000000000000</code></td>
<td>Samsung Pass</td>
</tr>
<tr>
<td><code>6028b017-b1d4-4c02-b4b3-afcdafc96bb2</code></td>
<td>Windows Hello</td>
</tr>
<tr>
<td><code>66a0ccb3-bd6a-191f-ee06-e375c50b9846</code></td>
<td>Thales Bio iOS SDK</td>
</tr>
<tr>
<td><code>771b48fd-d3d4-4f74-9232-fc157ab0507a</code></td>
<td>Edge on Mac</td>
</tr>
<tr>
<td><code>8836336a-f590-0921-301d-46427531eee6</code></td>
<td>Thales Bio Android SDK</td>
</tr>
<tr>
<td><code>891494da-2c90-4d31-a9cd-4eab0aed1309</code></td>
<td>Sésame</td>
</tr>
<tr>
<td><code>9ddd1817-af5a-4672-a2b9-3e3dd95000a9</code></td>
<td>Windows Hello</td>
</tr>
<tr>
<td><code>adce0002-35bc-c60a-648b-0b25f1f05503</code></td>
<td>Chrome on Mac</td>
</tr>
<tr>
<td><code>b5397666-4885-aa6b-cebf-e52262a439a2</code></td>
<td>Chromium Browser</td>
</tr>
<tr>
<td><code>b84e4048-15dc-4dd0-8640-f4f60813c8af</code></td>
<td>NordPass</td>
</tr>
<tr>
<td><code>bada5566-a7aa-401f-bd96-45619a55120d</code></td>
<td>1Password</td>
</tr>
<tr>
<td><code>cc45f64e-52a2-451b-831a-4edd8022a202</code></td>
<td>ToothPic Passkey Provider</td>
</tr>
<tr>
<td><code>cd69adb5-3c7a-deb9-3177-6800ea6cb72a</code></td>
<td>Thales PIN Android SDK</td>
</tr>
<tr>
<td><code>d548826e-79b4-db40-a3d8-11116f7e8349</code></td>
<td>Bitwarden</td>
</tr>
<tr>
<td><code>dd4ec289-e01d-41c9-bb89-70fa845d4bf2</code></td>
<td>iCloud Keychain (Managed)</td>
</tr>
<tr>
<td><code>ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4</code></td>
<td>Google Password Manager</td>
</tr>
<tr>
<td><code>f3809540-7f14-49c1-a8b3-8f813b225541</code></td>
<td>Enpass</td>
</tr>
<tr>
<td><code>fbfc3007-154e-4ecc-8c0b-6e020557d7bd</code></td>
<td>iCloud Keychain</td>
</tr>
<tr>
<td><code>fdb141b2-5d84-443e-8a35-4698c205a502</code></td>
<td>KeePassXC</td>
</tr>
</tbody>
</table>
<p>(This comes from <a href="https://github.com/passkeydeveloper/passkey-authenticator-aaguids">https://github.com/passkeydeveloper/passkey-authenticator-aaguids</a>,
which may be more up to date by the time that you read this, and also
contains icons for many of the providers.)</p>
<p>For simpler sites it’s also perfectly valid to avoid all that
complexity and have a “reset passkeys” button (like a “reset password”
button). It would prompt for a new passkey registration (with no
<code>excludeCredentials</code> listed), delete all other passkeys, and
invalidate all other active sessions for the user. Unfortunately the
deleted passkeys would still exist on the client side. Work is underway
to add an API (called the signal API) that would let sites inform
platforms during subsequent sign-ins that other passkeys have been
invalidated, but it’s not ready at the time of writing.</p>

<p>There are several different public key formats that you’ll encounter
around WebAuthn. This chapter will help you to recognize and handle
them. Overwhelmingly, WebAuthn uses a signature scheme called ECDSA
P-256, so we’ll discuss the different public key formats for this
scheme.</p>
<h2 id="ecdsa">ECDSA</h2>
<h3 id="x9.62-format">X9.62 format</h3>
<p>ECDSA public keys are (x, y) coordinate pairs. The coordinates in
P-256 are 256-bit numbers. The simplest public key format zero-pads the
coordinates so that they’re each 32-byte, big-endian values, sticks them
together, and prepends an 0x04 byte. This is X9.62 format.</p>
<p>You can recognize it because these public keys are always 65 bytes
long and they start with an 0x04 byte. Although not commonly encountered
directly in WebAuthn, raw X9.62 keys are found within the next format
discussed.</p>
<p>Note that, technically, this is the uncompressed X9.62 format. Since
the coordinate values are related by an equation, you can derive the y
value given the x value, although the square root operation means you
obtain a value that is either equal to y or -y.</p>
<p>Because of this, there’s also compressed X9.62 format where only the
x coordinate is given and the leading byte is 0x02 or 0x03, depending on
which of the two y values from the square root operation is the correct
one. However, this is extremely rare in general. In WebAuthn, it only
appears inside the QR code of a hybrid connection (see chapter 10) and
hybrid is a feature implemented only by the platform.</p>
<h3 id="subjectpublickeyinfo-format">SubjectPublicKeyInfo format</h3>
<p>X9.62 works great, but it’s nice for public key formats to be able to
describe which signature scheme they apply to. There are other elliptic
curves with 256-bit coordinates and it would be nice if the public keys
for all these schemes weren’t mutually ambiguous.</p>
<p>So a <a href="https://datatracker.ietf.org/doc/html/rfc5280#section-4.1">SubjectPublicKeyInfo</a>
(SPKI) wraps a public key in ASN.1 that identifies a signature scheme.
This is the format used inside of X.509 certificates, and so is quite
widely supported. It’s also the format that WebAuthn’s
<code>getPublicKey()</code> returns.</p>
<p>You can recognize it because it starts with an 0x30 byte. (Although
that’s common to all ASN.1-based formats.) You can convert from X9.62
format to SPKI by prepending the following bytes:</p>
<p><code>3059301306072a8648ce3d020106082a8648ce3d030107034200</code></p>
<p>Those bytes include the algorithm identifier for ECDSA P-256 and the
needed prefix such that the X9.62 bytes can follow, without any suffix.
However, the format is sufficiently flexible that it would be unwise to
try matching and removing that prefix to convert in the other direction.
Since SPKI is widely supported, that shouldn’t be necessary anyway.</p>
<p>If you’re looking for functions in your favorite language to parse an
SPKI, see <code>java.­security.­spec.­X509EncodedKeySpec</code> in Java,
<code>System.­Security.­Cryptography.­ECDsa.­ImportSubjectPublicKeyInfo</code>
in .NET, or <code>crypto/x509.­ParsePKIXPublicKey</code> in Go.</p>
<h3 id="cose-format">COSE format</h3>
<p><a href="https://datatracker.ietf.org/doc/html/rfc8152">COSE</a> is
the “CBOR Object Signing and Encryption” framework and it’s the format
used by public keys in the authentication data. If you’re doing
attestation (see chapter 7) or dealing with the Apple API (see chapter
11) then you’ll have to process this format. Unfortunately, it’s rare
and is not commonly supported by general cryptographic libraries.</p>
<p>As the name suggests, it’s encoded with CBOR and, in the case of
WebAuthn, that’ll be the CTAP2 subset of CBOR (see chapter 6).
Technically speaking you can read RFC 8152 and figure out how to process
a COSE public key, but the RFC is not straightforward. You’re better off
looking at an example:</p>
<pre><code>{
  1: 2,   # key type = elliptic curve
  3: -7,  # alg = ECDSA P-256
  -1: 1,  # curve = P-256
  # x and y coordinates
  -2: h&#39;950F7AF17D9E...&#39;,
  -3: h&#39;7A6B0654742C...&#39;,
}</code></pre>
<p>The x and y coordinates in the CBOR are zero-padded and so, for
P-256, must always be 32-bytes long.</p>
<p>You can recognize these keys because they’ll start with 0xa5 (for a
CBOR map with five entries) and, as mentioned, they appear in the
authenticator data. In order to convert to X9.62 format you can parse
the CBOR, check that keys 1, 3, and -1 are present with the expected
values, check that keys -2 and -3 are present with 32-byte values, then
concatenate an 0x04 byte and the x and y values. Once you have X9.62
format, see above for how to convert to SPKI format if you need.</p>


</div>
  </body>
</html>
