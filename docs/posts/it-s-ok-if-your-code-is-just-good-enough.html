<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://shiftmag.dev/code-quality-good-enough-2034/">Original</a>
    <h1>It&#39;s OK if your code is just good enough</h1>
    
    <div id="readability-page-1" class="page"><div>
  
  <div>
    <p>
      Good enough code is a nice middle ground between implementing a feature fast and maintaining the code quality.    </p>
  </div>
  
</div><div>
          <figure><img fetchpriority="high" decoding="async" width="1200" height="630" src="https://shiftmag.dev/wp-content/uploads/2023/11/Code-quality.png?x35993" alt="" srcset="https://shiftmag.dev/wp-content/uploads/2023/11/Code-quality.png 1200w, https://shiftmag.dev/wp-content/uploads/2023/11/Code-quality-300x158.png 300w, https://shiftmag.dev/wp-content/uploads/2023/11/Code-quality-1024x538.png 1024w, https://shiftmag.dev/wp-content/uploads/2023/11/Code-quality-768x403.png 768w" sizes="(max-width: 1200px) 100vw, 1200px"/></figure>


<p>I’ve heard a story about a student who had to write an essay to pass the exam. He had a three-month deadline. During those months he struggled a lot<strong> rewriting pages again and again</strong>. Every now and then the professor checked on him and he would always respond with “I’m not done yet, it’s simply not good enough”. </p>



<p>Finally, the professor suggested: “Write the essay as if it would be graded <em>good enough</em>“. As much as this approach was strange to him, he took the advice. Surprisingly, he <strong>finished the essay in a whip </strong>earning a <strong>higher grade than expected.</strong></p>



<p>Where I come from, <em>good enough</em> would be a “three”, simply an average grade on a 1 to 5 scale. Solid, acceptable, good.</p>



<h2><span id="the-five-shades-of-code-quality">The five shades of code quality</span></h2>



<p>We, as software developers, not only write essays but dissertations to bring our pile of zeros and ones to life. <strong>Most of us would want our code to be 5 out of 5.</strong> But is this something worth pursuing? Let’s explore five shades of code quality:</p>



<p>1 – Shit</p>



<p>2 – Proof of concept</p>



<p>3 – Good enough</p>



<p>4 – Very good </p>



<p>5 – Perfection</p>



<h2><span id="grade-1-shit">Grade 1: Shit</span></h2>



<p>This is the type of code that makes you sweat. Your heart sinks when you hear about a new requirement. You know it will take up ages to implement it. The best thing you can do is to throw everything away and rewrite it. Such code<strong> shouldn’t be acceptable</strong>, we shouldn’t ship shit.</p>



<h2><span id="grade-2-poc">Grade 2: PoC</span></h2>



<p>Typical PoC code. You know that this code is <strong>not good but you can live with it for a while</strong>. </p>



<p>Usual problems:</p>



<ul>
<li>doesn’t have clear architecture, clear boundaries</li>



<li>many things are tightly coupled</li>



<li>many edge cases are not covered</li>



<li>missing validations</li>



<li>inadequate domain object modeling</li>



<li>too complex or too tiny test suite</li>



<li>code is not clean</li>
</ul>



<p>While this may not sound ideal, it can serve to <strong>quickly determine the direction you want to go</strong>. You can move really fast and iterate as you go. This code quality is particularly suitable for PoC initiatives.</p>





<h2><span id="grade-3-good-enough">Grade 3: Good enough</span></h2>



<p>Good enough code is a nice middle ground between implementing a feature fast and maintaining the code quality.</p>



<p>It addresses many of the issues typically found in grade 2 code, with some exceptions:</p>



<ul>
<li>some unnecessary levels of abstraction</li>



<li>some unclear naming</li>



<li>few larger functions or classes (nothing too big)</li>



<li>misuse of exceptions here and there</li>



<li>some code duplications</li>



<li>redundant commenting</li>



<li>readability issues in tests</li>
</ul>



<p>This code is suited for most applications. It’s probably the best for those dealing with CRUD operations. You can also achieve good results using this approach on components involved in traffic flow. </p>



<h2><span id="grade-4-very-good">Grade 4: Very good</span></h2>



<p>Grade 4 is a <strong>highly maintainable clean code paradise</strong>. Doesn’t have any problems that <em>good enough</em> has. </p>



<p>The problem with this grade is that<strong> it is difficult to achieve.</strong> We have different backgrounds and views about how a really good code should look like.</p>



<p>I’ve worked with a freelancing company whose code was on this level. In order to achieve it, they enforced <strong>highly strict static code analysis</strong> and <strong>really challenging code reviews</strong>. Static code analysis was the cornerstone to stop most of the common problems from <em>good enough</em> entering the codebase. You can view them <a href="https://www.elegantobjects.org/" target="_blank" rel="noreferrer noopener">here</a> – under principles. Code review consisted of <strong>two reviewers</strong>, <strong>one developer and an architect, plus a QA </strong>person who would check the quality of the review. </p>



<p>If you want to tackle with grade 4 you need to <strong>build infrastructure for it</strong> and have everyone onboard with it. Aiming for <strong>this grade will slow you down</strong> so it should be taken into consideration when doing estimations with PD. Clear benefits will be seen in the long run.</p>



<p>This grade might be suited for building libraries that would be used by multiple projects/teams or when building critical parts of a system.</p>



<h2><span id="grade-5-perfection">Grade 5: Perfection</span></h2>



<p>Doesn’t exist.</p>



<h2><span id="good-enough-is-the-way-to-go">Good enough is the way to go</span></h2>



<p>Daily we are faced with different requirements, different deadlines, scopes, and so on. They are, of course, not always quick and simple to solve but most of the time, the <em>good enough</em> approach is the way to go. </p>



<p>To me, the code that has a clear architecture, understandable names of services, and good tests ticks all the boxes. And I like it! It doesn’t have to be a clean-code candy. If you prefer candies, then you have to convince PD and your team that this extra sugar will benefit the project.</p>



<p>What would you say, what would be your preferred coding approach?</p>
        </div></div>
  </body>
</html>
