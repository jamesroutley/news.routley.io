<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sm2n.ca/log/tips-lean4-aoc/">Original</a>
    <h1>Tips from using Lean 4 for Advent of Code</h1>
    
    <div id="readability-page-1" class="page"><div>  <p>New year, new <a href="https://adventofcode.com/">Advent of Code</a>. I like to use it to provide momentum to learn something new about programming. I think there’s a lot to be said for experimenting with different ways to write the same (class of) programs. Last year I did <a href="https://www.metalevel.at/prolog">Prolog</a> and learned about constraint logic programming. This year I’ve been using <a href="https://lean-lang.org/">Lean 4</a>, and trying to learn more about program verification and dependently typed programming.</p>
<p>It’s already been a fun learning experience, and I thought I’d note down some stuff I learned that wasn’t immediately obvious from the popular learning materials like the official lean books (<a href="https://lean-lang.org/functional_programming_in_lean/">Programming in Lean</a> and <a href="https://lean-lang.org/theorem_proving_in_lean4/">Theorem Proving in Lean 4</a>).</p>
<h2 id="lean-is-very-interactive">Lean is very interactive</h2>
<p>Say you have a function <code>foo</code>, and you want to make sure <code>foo 2 = 5</code>. Well, in lean you can start off with this:</p>
<pre tabindex="0" data-language="lean4"><code><span><span>def</span><span> foo</span><span> (x : Nat) := </span><span>sorry</span></span>
<span></span>
<span><span>#eval</span><span> foo </span><span>2</span></span></code></pre>
<p>Now, you have foo defined, and you’ll get live updates in the infoview on the output as you edit the file.</p>
<p>Once you’re done being sorry, you can replace <code>#eval</code> with <code>#guard</code>, which takes a boolean and does nothing if it’s true and a compile error otherwise:</p>
<pre tabindex="0" data-language="lean4"><code><span><span>#guard foo </span><span>2</span><span> = </span><span>5</span></span></code></pre>
<p>If you like snapshot testing, that’s also built-in:</p>
<pre tabindex="0" data-language="lean4"><code><span><span>/--</span></span>
<span><span>info: 5</span></span>
<span><span>-/</span></span>
<span><span>#guard_msgs </span><span>in</span></span>
<span><span>#eval</span><span> foo </span><span>2</span></span></code></pre>
<p>This will print a diff to the infoview whenever the stdout from <code>#eval</code> isn’t equal to the docstring above, and nothing otherwise.</p>
<p>As a longtime lisper, this workflow in some ways feels even more interactive than what you get with a traditional REPL, even nice ones like in Common Lisp (though obviously there are other things that aren’t there).</p>
<p>One thing to note is that you can run IO actions in <code>#eval</code>, and that they reevaluate in an unpredictable way. Sometimes I had to do spurious edits to a <code>#eval</code> line to deal with a stale evaluation in the infoview. As such, you probably don’t want to run nontrivial IO actions in <code>#eval</code> (printing to stdout is fine).</p>
<h2 id="local-mutation-is-easy">Local mutation is easy</h2>
<p>You can write code with local mutable variables anywhere pretty easily. Lean’s support for do-notation comes with local mutable variables out of the box. It also gives you for loops.</p>
<p>All you have to do to get access to these features is enter the Identity monad using <code>Id.run</code>. Here’s what it looks like in practice:</p>
<pre tabindex="0" data-language="lean4"><code><span><span>def</span><span> part1_solve</span><span> (input: List Int) : Nat := Id.run </span><span>do</span></span>
<span><span>  let</span><span> mut</span><span> count : Nat := </span><span>0</span></span>
<span><span>  let</span><span> mut</span><span> pos : {x : Int // </span><span>0</span><span> ≤ x ∧ x &lt; </span><span>100</span><span>} := ⟨</span><span>50</span><span>, </span><span>by</span><span> omega⟩</span></span>
<span><span>  for</span><span> op </span><span>in</span><span> input </span><span>do</span></span>
<span><span>    pos := ⟨(pos + op) % </span><span>100</span><span>, </span><span>by</span><span> omega⟩</span></span>
<span><span>    if</span><span> pos.val == </span><span>0</span><span> then</span></span>
<span><span>      count := count + </span><span>1</span></span>
<span><span>  return</span><span> count</span></span></code></pre>
<h2 id="lean-has-print-debugging">Lean has print <a href="https://lean-lang.org/doc/api/Init/Util.html">debugging</a></h2>
<h3 id="printf-has-a-strange-type-signature">printf has a strange type signature</h3>
<pre tabindex="0" data-language="lean4"><code><span><span>def</span><span> dbgTrace</span><span> {α : </span><span>Type</span><span> u} (s : String) (f : Unit → α) : α</span></span></code></pre>
<p>It prints <code>s</code>, and then calls <code>f</code> on the unit value and returns that.</p>
<p>One thing to note is that the compiler <em>will absolutely</em> throw away your <code>dbgTrace</code> expressions if they look like dead code (i.e you must use the return value). Debug printing itself is not considered a side-effect as far as the compiler is concerned (Lean is a referentially transparent language).</p>
<p>More convenient is <code>dbgTraceVal</code>:</p>
<pre tabindex="0" data-language="lean4"><code><span><span>def</span><span> dbgTraceVal</span><span> {α : </span><span>Type</span><span> u} [ToString α] (a : α) : α</span></span></code></pre>
<p>It’s the identity function except it also debug prints its argument.</p>
<h3 id="string-formatting">String formatting</h3>
<p>Good printf debugging means custom format strings. Lean has those too! You can access the lean equivalent of python-style f-strings with the <code>s!</code> sigil. It looks like this:</p>
<pre tabindex="0" data-language="lean4"><code><span><span>dbgTrace </span><span>s!</span><span>&#34;woah: </span><span>{</span><span>expr1</span><span>}</span><span>&#34;</span><span> (</span><span>fun</span><span> () =&gt; expr2)</span></span></code></pre>
<p>Note that unlike say Rust, you can write expressions in the template strings, not just variable names.</p>
<p>There’s also <code>m!</code> and <code>f!</code> which produce different forms of structured data instead of strings which I won’t get into. You can define your own sigils too, <code>f!</code> is a <a href="https://github.com/leanprover/lean4/blob/9d4ad1273f6cea397c3066c2c83062a4410d16bf/src/Init/Data/Format/Macro.lean#L16-L16">macro defined in the stdlib</a>.</p>
<h2 id="lightweight-verification-is-easy">Lightweight verification is easy</h2>
<p>Lean has the full gamut of assertions, and it also has easy access to automatic theorem proving as well as interactive theorem proving.</p>
<p>It has <code>assert!</code> and <code>debug_assert!</code> which do what you expect. But you can go further with refinement types. Those look like <code>{x : T // P(x)}</code> which is a type that contains a term of type <code>T</code> as well as a proof that the predicate <code>P</code> holds on it. You can construct them with the syntax <code>⟨value, proof_term⟩</code>. This is just a regular struct under the hood, with two fields <code>.val</code> and <code>.property</code> which are what you expect.</p>
<p>The cool bit is that you can use many kinds of proof automation (i.e tactics) to construct the proofs, which can make it very lightweight. If you see my simple example from earlier, you can see that the proof term I had to construct was just <code>by omega</code>, because the <code>omega</code> tactic is strong enough to construct the proof on its own!</p>
<p>More and smarter tactics is an active area of development.</p>
<p>I think it’s pretty cool that you can write a normal program and then increase the level of assurance using verification in a gradual way like this.</p>

<h3 id="you-dont-have-to-use-vscode">You don’t have to use VSCode</h3>
<p>Being forced to use VSCode, as silly as it sounds, has put me off playing with Lean before. As it happens, it’s actually really easy to use Emacs (and supposedly vim, but I wouldn’t know).</p>
<p>I just added this to my emacs config (I use <code>use-package</code> with <code>straight.el</code>):</p>
<pre tabindex="0" data-language="emacs-lisp"><code><span><span>(</span><span>use-package lean4-mode</span></span>
<span><span>  :</span><span>commands</span><span> lean4-mode</span></span>
<span><span>  :</span><span>mode</span><span> &#34;</span><span>\\</span><span>.lean</span><span>\\</span><span>&#39;</span><span>&#34;</span></span>
<span><span>  :</span><span>straight</span><span> (</span><span>lean4-mode </span><span>:</span><span>type</span><span> git </span><span>:</span><span>host</span><span> github</span></span>
<span><span>                        :</span><span>repo</span><span> &#34;</span><span>leanprover-community/lean4-mode</span><span>&#34;</span></span>
<span><span>                        :</span><span>files</span><span> (</span><span>&#34;</span><span>*.el</span><span>&#34;</span><span> &#34;</span><span>data</span><span>&#34;</span><span>)))</span></span></code></pre>
<p>Note that <code>lean4-mode</code> is integrated with <code>lsp-mode</code> which is nonnegotiable. I normally use <code>eglot</code> as my lsp-client so now I have both installed which is stinky IMO but eh I can deal with it. It’s also hardcoded to use <code>company-mode</code>, and I had to locally disable <code>corfu-mode</code> in lean4 buffers or it would automatically hang every once in a while.</p>
<p>Putting those nits aside, the experience is pretty good. The only thing you need other than the mode is to have lean in your path.</p>
<h3 id="you-can-not-use-elan">You can (not) use <code>elan</code></h3>
<p>To have lean in your path the thing you have to use is <code>elan</code> which is lean’s toolchain manager (like <code>rustup</code>, <code>ghcup</code>, etc). It downloads lean toolchain binaries (i.e lean itself, the build tool lake, etc) to <code>~/.elan/</code> and puts them in your path. <code>elan</code> itself is available on nixpkgs so I could grab it with a <code>nix shell nixpkgs#elan</code>.</p>
<p>These days I like to have all my software projects be at least somewhat reproducible using a nix flake devshell, so I would prefer to have my toolchain version pinned and managed by nix. Also I don’t like “download random binary” to be part of my workflow.</p>
<p>Lean 4 removed their user-facing nix flake a while back though, because they didn’t want to maintain it. But, a brave soul has created <a href="https://github.com/lenianiva/lean4-nix">lean4-nix</a> which provides an overlay for nix toolchains. This works for me.</p>
<p>The caveat here is that it seems that without an <code>elan</code> in the path, <code>lake</code> refuses to create or update <code>lake-manifest.json</code> (basically the package lockfile), which becomes necessary if you want to use dependencies.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Lean is pretty cool. I’ve been having a lot of fun exploring it and I think the trend towards more ergonomic program verification is the future of software.</p>
<p>Also <a href="https://perfect-math-class.leni.sh/">Stanford CS ⑨⑨ - Perfect Math Class</a> is a great resource to learn from.</p>  </div></div>
  </body>
</html>
