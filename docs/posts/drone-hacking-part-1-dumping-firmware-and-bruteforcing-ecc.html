<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neodyme.io/en/blog/drone_hacking_part_1/">Original</a>
    <h1>Drone Hacking Part 1: Dumping Firmware and Bruteforcing ECC</h1>
    
    <div id="readability-page-1" class="page"><div> <h2 id="intro">Intro<a aria-hidden="true" tabindex="-1" href="#intro"><span>¶</span></a></h2>
<p>In July 2025, we from Neodyme got together in Munich and did security research on a bunch of IoT devices, ranging from bluetooth headsets, to door locks, to drones. One of these was the Potensic Atom 2. It’s a photo and video drone with a gimbal-stabilized 4K camera and a remote control that you hook up to your own smartphone and the proprietary app. If you’ve ever flown a DJI Mini 4K, this drone will look very familiar to you.</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/atom2.png" alt="Potensic Atom 2"/>
						<figcaption>
							<p>
								Potensic Atom 2
							</p>
						</figcaption>
					</figure>
					</center>
<p>This post is part of a <strong>two-part series</strong> that will cover how we disassembled the drone and dumped the firmware from the NAND chip and how we analyzed the drone’s firmware, app, and remote control to find some backdoors and vulnerabilities.</p>
<h3 id="goal-dumping-the-firmware">Goal: Dumping the Firmware<a aria-hidden="true" tabindex="-1" href="#goal-dumping-the-firmware"><span>¶</span></a></h3>
<p>One of the most important pieces of information you can acquire when setting up to hack a device is its firmware. If you want to reverse engineer the software that’s running on the drone and find vulnerabilities in that, then you need a copy of it in the first place.</p>
<p>Now there are a couple of ways to go about that, some are less intrusive and some are more effective.</p>
<p>You might get lucky and be able to just <strong>download the firmware</strong> as a firmware update from the manufacturer’s website. However, those update sites are often not publicly documented and can be locked behind authorization checks or encrypted. Encrypted firmwares can still be useful - you “just” need to reverse engineer the on-device decryption process. For the Atom 2, downloading the firmware updates required having a valid drone and remote control serial number <em>and</em> the firmware update was also encrypted. Without having the decryption logic, we put this approach on ice during our initial research.</p>
<p>Another really comfortable approach is to use exposed <strong>debug interfaces</strong> like JTAG or UART. However, those are often undocumented, unlabeled, or entirely removed for public versions. We didn’t find any on the Atom 2.</p>
<p>What we can always do, though not necessarily always successful, is solder off the entire NAND chip and <strong>dump the firmware</strong> byte by byte. This has the risk of breaking the NAND chip and/or the rest of the board if you’re not careful. Also, some devices, like modern smart phones, encrypt their persistent storage with key material stored in, e.g., the TPM. If that is the case, then simply soldering off the NAND chip will leave you with unusable encrypted data. Fortunately, the Atom 2’s NAND contents are not encrypted, as we find out later.</p>
<h2 id="dumping-the-nand-chip">Dumping the NAND Chip<a aria-hidden="true" tabindex="-1" href="#dumping-the-nand-chip"><span>¶</span></a></h2>
<p>Dumping a NAND chip generally always follows the same pattern:</p>
<ol>
<li>Identifying the NAND Chip</li>
<li>Removing it from the board</li>
<li>Identifying the data pins and communication protocol of the NAND chip</li>
<li>Connecting the NAND chip to some kind of reading device</li>
<li>Reading the NAND content</li>
<li>Reassembling the read contents into a working firmware - usually containing one or more file systems</li>
</ol>
<h3 id="identifying-the-nand-chip">Identifying the NAND Chip<a aria-hidden="true" tabindex="-1" href="#identifying-the-nand-chip"><span>¶</span></a></h3>
<p>The Atom 2 has multiple boards:</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/drone-top-side.png" alt="Top side of the drone"/>
						<figcaption>
							<p>
								Top side of the drone
							</p>
						</figcaption>
					</figure>
					<figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/drone-bottom-side.png" alt="Bottom side of the drone, with the mainboard and some of its RF shields already removed"/>
						<figcaption>
							<p>
								Bottom side of the drone, with the mainboard and some of its RF shields already removed
							</p>
						</figcaption>
					</figure>
					</center>
<p>We are mainly interested in the <strong>main board</strong> because that’s where the NAND flash is going to be. The main board had several metal RF shields that we have already pried off or cut through on the photos.</p>
<p>We can identify most of these chips through their markings. Note that while we’re mainly interested in the NAND chip, knowing the others can help with recognizing things during reversing later on. Roughly knowing which SoC we were working with was crucial, as you will see in later sections of this blog post.</p>
<p><em>(Note that the markings below might not match the photos completely. We had multiple drones. The markings are mostly from the first drone and the photos are mostly of the second drone.)</em></p>
<h4 id="top-side">Top-side<a aria-hidden="true" tabindex="-1" href="#top-side"><span>¶</span></a></h4>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/mainboard-top-side.png" alt="Top side of the mainboard, with all RF shields removed"/>
						<figcaption>
							<p>
								Top side of the mainboard, with all RF shields removed
							</p>
						</figcaption>
					</figure>
					</center>
<p><strong>SoC (System on a Chip, aka “the main thingy”)</strong></p>
<ul>
<li>Markings: 23AP10 VTQMSQKJYJ 4978-CN B3</li>
<li>We didn’t find an exact match, but <a href="https://blog.csdn.net/szhorsway/article/details/144353108">this site</a> references the 21AP10.
<ul>
<li>The page title is <code>21AP10 SS928 平替SD3403V100 海思 SOC芯片</code></li>
<li><code>21AP10 SS928 平替</code> =&gt; <code>21AP10 SS928 Drop-In Replacement</code></li>
<li><code>SD3403V100 海思 SOC芯片</code> =&gt; <code>HiSilicon SD3403V100 SOC Chip</code></li>
<li>That is a mobile camera SoC.</li>
</ul>
</li>
<li>It makes sense that this is the SoC because it is close to both external RAM chips and the NAND flash.</li>
<li>In <a href="https://www.reddit.com/r/Potensic/comments/1diwuxo/potensic_atom_se_teardown_and_discussion/">this teardown of a previous Atom model</a>, the device had a <code>HiSilicon Hi 3559 camera MCU</code></li>
<li>We found a data sheet for the HiSilicon Hi3519 V100.
<ul>
<li>Close enough for now.</li>
</ul>
</li>
</ul>
<p><strong>RAM</strong></p>
<ul>
<li>Markings: SEC340 K4A8G16 5WC BCTD G2F9190AC</li>
<li>Data sheet can be found on the internet.</li>
</ul>
<p><strong>ARM Cortex-M4</strong></p>
<ul>
<li>Markings: GD32F470 VGH6 BUMK618 AL2451 GigaDevice ARM</li>
<li>Data sheet can be found on the internet.</li>
<li>Might be SD-card related since the SD card slot is on the other side.</li>
</ul>
<p><strong>Unknown Chips</strong></p>
<ul>
<li>Markings: V2 2441TM4N190.00
<ul>
<li>The name <code>2441TM</code> appears in some WizSense surveillance cameras</li>
<li>Not sure if related</li>
</ul>
</li>
<li>2 chips with markings: 8285HE 426656 CS2441</li>
</ul>
<h4 id="bottom-side">Bottom Side<a aria-hidden="true" tabindex="-1" href="#bottom-side"><span>¶</span></a></h4>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/mainboard-bottom-side.png" alt="Bottom side of the mainboard, with all RF shields removed"/>
						<figcaption>
							<p>
								Bottom side of the mainboard, with all RF shields removed
							</p>
						</figcaption>
					</figure>
					</center>
<p><strong>NAND flash</strong></p>
<ul>
<li>Markings: MXIC X243662 MX35UF4GE4AD-241 5P231800A1</li>
<li>Data sheet can be found on the internet.</li>
</ul>
<p><strong>RAM</strong></p>
<ul>
<li>Markings: SEC407 K4A8G16 5WC BCTD G2K43304C</li>
<li>Same as on top side</li>
</ul>
<p><strong>ARM Cortex-M4</strong></p>
<ul>
<li>Markings: F460JEUA P8VR4400 2416021</li>
<li>Not sure what it’s used for.</li>
<li>A data sheet for the HC32<strong>F460JEUA</strong>-QFN48TR (looks close enough?) can be found on the internet.</li>
</ul>
<p><strong>WLAN + Bluetooth</strong></p>
<ul>
<li>RTL8821CS</li>
<li>Data sheet can be found on the internet.</li>
</ul>
<h3 id="removing-the-nand-chip-from-the-board">Removing the NAND Chip from the board<a aria-hidden="true" tabindex="-1" href="#removing-the-nand-chip-from-the-board"><span>¶</span></a></h3>
<p>Now that we have identified the NAND chip, we fasten the board and tape off the remaining components with heat-shielding tape.</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/drone-and-mainboard.png" alt="Drone and mainboard, partially taped off with heat-shielding tape. The mainboard was still connected via the flex cable while we were searching for debug pins."/>
						<figcaption>
							<p>
								Drone and mainboard, partially taped off with heat-shielding tape. The mainboard was still connected via the flex cable while we were searching for debug pins.
							</p>
						</figcaption>
					</figure>
					</center>
<p>Usually getting the chip off of the board is just a matter of using hot air station and flux. However, you can see on the photos that the chip is actually glued to the main board with what is probably epoxy. That’s a thing you can do if you want to secure the chips more securely and not depend on the solder joints to hold your chip in place (and risk breaking them). Or you can do that <em>just</em> to the NAND chip to make it harder for researcher to pry off your NAND chip and dump your firmware.</p>
<p>Anyway, a few cuts with a sharp knife, some heat and a <em>generous</em> amount of flux later, the little bugger came off in one piece.</p>
<p><em>(And with it, a couple of extremely tiny resistors that I knocked off with my pliers and promptly lost. This main board is now broken. But don’t worry, <a href="https://youtu.be/D_qFWoa_HR4&amp;t=293">through the magic of buying <del>two</del> three of them</a>, we can still fly the drone.)</em></p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/nand-chip.png" alt="As you can see, this chip has a large ground pad in the middle. This allows the chip to transfer a lot of heat to the ground plane in the mainboard, which makes soldering it off a little harder."/>
						<figcaption>
							<p>
								As you can see, this chip has a large ground pad in the middle. This allows the chip to transfer a lot of heat to the ground plane in the mainboard, which makes soldering it off a little harder.
							</p>
						</figcaption>
					</figure>
					</center>
<h3 id="identifying-the-data-pins-and-communication-protocol-of-the-nand-chip">Identifying the data pins and communication protocol of the NAND chip<a aria-hidden="true" tabindex="-1" href="#identifying-the-data-pins-and-communication-protocol-of-the-nand-chip"><span>¶</span></a></h3>
<p>According to the data sheet of the MX35UF4GE4AD NAND chip, the flash chip can either come in a 24-pin BGA package or an 8-pin WSON package, which we have here. A quick look at the pin descriptions tell us that the NAND chip is communicating via SPI.</p>













































<table><thead><tr><th>Pin Symbol</th><th>Pin Description</th></tr></thead><tbody><tr><td>CS#</td><td>Chip Select</td></tr><tr><td>SI</td><td>Serial Data Input</td></tr><tr><td>SO</td><td>Serial Data Output</td></tr><tr><td>SCLK</td><td>Clock Input</td></tr><tr><td>WP#</td><td>Write protection</td></tr><tr><td>HOLD#</td><td>Hold</td></tr><tr><td>VCC</td><td>Power Supply (1.8 V)</td></tr><tr><td>GND</td><td>Ground</td></tr><tr><td>DNU</td><td>Do Not Use</td></tr></tbody></table>
<p>Well, let’s solder tiny copper cables to all of those pins and drown them in a bit of hot glue to stop them from breaking off.</p>
<center><p><img src="https://exclav.es/blog/drone_hacking_part_1/nand-chip-wires.jpg" alt="nand chip with wires"/></p></center>
<p>Note that you <em>can</em> get a proper socket for 8-WSON chips into which you simply clamp the chip and which exposes easy-to-work-with breakout pins. None of our sockets we brought fit though, so we just did it the old-school way.</p>
<h3 id="connecting-the-nand-chip-to-some-kind-of-reading-device">Connecting the NAND chip to some kind of reading device<a aria-hidden="true" tabindex="-1" href="#connecting-the-nand-chip-to-some-kind-of-reading-device"><span>¶</span></a></h3>
<p>SPI is pretty easy to work with. We have two main data lines called <strong>SI</strong> and <strong>SO</strong> (Serial In/Out). You will also find them under the names “MOSI” and “MISO” (Master Out Slave In / Master In Slave Out). As the names of these suggest, SPI follows a master-slave architecture. The microcontroller drives the communication and the peripheral device reacts.</p>
<p>Fortunately, we are simulating the microcontroller-side of the communication, which means that we have a large amount of control. Specifically, we control the clock (<strong>SCLK</strong>). Sometimes it is hard to talk to embedded hardware because of the speed at which they operate. With SPI, however, we can slow down the clock to however fast we want the devices to talk.</p>
<p>Since SPI is a bus protocol, more than one slave device can be hooked up to a master device on the same data lines. To avoid collisions, each device is also assigned its own “Chip Select” line (<strong>CS</strong>). When the master device wants to talk to a specific slave device, it pulls the corresponding CS line <em>low</em>. Devices that have their CS line <em>high</em> won’t react at all.</p>
<p>Obviously there are fancy devices on the market that will make dumping a NAND chip via SPI pretty easy and straightforward. Problem is, we couldn’t get <em>any</em> of them to work. They either didn’t fit (physically), were too fast or failed for some other strange reason we didn’t understand. So we wrote <strong>our own dump script onto an ESP32</strong> using the SPI commands in the data sheet and let it forward the data to our computer via the USB console.</p>
<p>Doing that, we ended up with a 544 MiB dump, containing 131,072 pages of 4096+256 bytes. <em>(We will come back to that “+256” later on.)</em></p>
<p>Let’s dig into what this the flash dump contains with <code>binwalk</code>:</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/dump-01-01.png" alt="Binwalk output of the raw NAND dump"/>
						<figcaption>
							<p>
								Binwalk output of the raw NAND dump
							</p>
						</figcaption>
					</figure>
					</center>
<p>Sweet! We get a working ASCII copyright string, so <em>something</em> must have worked. And at the end of the image we have a bunch of UBIFS images. That’s probably where all the juicy files are!</p>
<p>Let’s extract them with <code>dd</code> and take a look inside with <a href="https://github.com/onekey-sec/ubi_reader">ubi_reader</a>:</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/dump-01-02.png" alt="Extracting the the first UBI image from the NAND flash dump via dd. Note that the offsets don’t match the binwalk output directly because we are using a bigger blocksize to speed this up (bs=1024)."/>
						<figcaption>
							<p>
								Extracting the the first UBI image from the NAND flash dump via dd. Note that the offsets don’t match the binwalk output directly because we are using a bigger blocksize to speed this up (bs=1024).
							</p>
						</figcaption>
					</figure>
					<figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/dump-01-03.png" alt="ubi_reader finds three file systems but fails to extract any files from them before crashing"/>
						<figcaption>
							<p>
								ubi_reader finds three file systems but fails to extract any files from them before crashing
							</p>
						</figcaption>
					</figure>
					</center>
<p>Hmm. That doesn’t work. Spoiler: The extracted image is broken.</p>
<p>Now if you’ve ever done something as hacky as this, you will know about a pesky little phenomenon that happens when you just solder copper wires onto a chip, stick that onto the ports of an ESP32 and do SPI communication - which has <strong>no built-in integrity checks</strong>.</p>
<h4 id="random-bit-flips">Random Bit Flips<a aria-hidden="true" tabindex="-1" href="#random-bit-flips"><span>¶</span></a></h4>
<p>These are three dumps taken from the same NAND chip:</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/md5sums.png" alt="The MD5 hashes of the three separate dumps from the same NAND chip are different, indicating that our reading process introduces bit errors."/>
						<figcaption>
							<p>
								The MD5 hashes of the three separate dumps from the same NAND chip are different, indicating that our reading process introduces bit errors.
							</p>
						</figcaption>
					</figure>
					</center>
<p>If you read 4 MiB of data from the chip, not all of the bits you receive are correct. And without any additional data, you have little way of knowing which ones are correct and which are not. If you are lucky, then the dumped data will still “work”, i.e., the contained file system will mount and you can browse files, but futher down the line you will have no way of knowing whether that weird function you’re reversing is actually weird or just the product of random bit flips messing up the CPU instructions.</p>
<p>A relatively simple yet time-consuming way to get around this: Read the flash <em>often</em> (at least three times) and hold a majority vote for every bit. Since the bit flips are random and not too prevalent, they are less likely to hit the same bit twice.</p>
<p>Hot tip: If you’re gonna work with python, use numpy and work on arrays and  memory-mapped files. Otherwise this can take a lot of time and a lot of RAM - even for a 512 MiB flash dump.</p>
<div><figure><pre data-language="python"><code><div><p><span>import</span><span> numpy </span><span>as</span><span> np</span></p></div><div><p><span>import</span><span> sys</span></p></div><div></div><div><p><span>if</span><span> </span><span>len</span><span>(sys.argv) </span><span>!=</span><span> </span><span>4</span><span>:</span></p></div><div><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;Usage: </span><span>{</span><span>sys.argv[</span><span>0</span><span>]</span><span>}</span><span> dump1 dump2 dump3&#34;</span><span>, </span><span>file</span><span>=</span><span>sys.stderr)</span></p></div><div><p><span><span>    </span></span><span>sys.exit(</span><span>1</span><span>)</span></p></div><div></div><div><p><span>dump_filenames </span><span>=</span><span> sys.argv[</span><span>1</span><span>:]</span></p></div><div></div><div><p><span>a, b, c </span><span>=</span><span> [np.memmap(f, </span><span>dtype</span><span>=</span><span>np.uint8, </span><span>mode</span><span>=</span><span>&#34;r&#34;</span><span>) </span><span>for</span><span> f </span><span>in</span><span> dump_filenames]</span></p></div><div></div><div><p><span>majority </span><span>=</span><span> np.memmap(</span></p></div><div><p><span>    </span><span>&#34;dump-majority-voting.bin&#34;</span><span>,</span></p></div><div><p><span>    </span><span>dtype</span><span>=</span><span>np.uint8,</span></p></div><div><p><span>    </span><span>mode</span><span>=</span><span>&#34;write&#34;</span><span>,</span></p></div><div><p><span>    </span><span>shape</span><span>=</span><span>(a.size,),</span></p></div><div><p><span>)</span></p></div><div></div><div><p><span># quick three-way majority voting</span></p></div><div><p><span>majority[:] </span><span>=</span><span> np.where(</span></p></div><div><p><span><span>    </span></span><span>(a </span><span>==</span><span> b) </span><span>|</span><span> (a </span><span>==</span><span> c) </span><span>|</span><span> (b </span><span>!=</span><span> c),</span></p></div><div><p><span><span>    </span></span><span>a,</span></p></div><div><p><span><span>    </span></span><span>b,</span></p></div><div><p><span>)</span></p></div></code></pre></figure></div>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/majority-voting.png" alt="After majority-voting, we get a different MD5 sum. This one remains stable even when pulling more samples."/>
						<figcaption>
							<p>
								After majority-voting, we get a different MD5 sum. This one remains stable even when pulling more samples.
							</p>
						</figcaption>
					</figure>
					</center>
<p>But isn’t there a better way? Yes, there is. And - btw - even with completely correct majority voting, the flash content is still broken. But we’ll get to that.</p>
<p>Trying to work with the majority-voted dump:</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/dump-02-01.png" alt="Binwalk output on the majority-voted NAND dump"/>
						<figcaption>
							<p>
								Binwalk output on the majority-voted NAND dump
							</p>
						</figcaption>
					</figure>
					<figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/dump-02-02.png" alt="Trying to parse the UBI image with ubi_reader still fails - this time even before finding any file systems (wtf?)"/>
						<figcaption>
							<p>
								Trying to parse the UBI image with ubi_reader still fails - this time even before finding any file systems (wtf?)
							</p>
						</figcaption>
					</figure>
					</center>
<h2 id="out-of-band-bytes-and-ecc-troubles">Out-of-band bytes and ECC troubles<a aria-hidden="true" tabindex="-1" href="#out-of-band-bytes-and-ecc-troubles"><span>¶</span></a></h2>
<p>One thing we have have silently brushed aside for now: The NAND chip distinguishes between “user data” and “extra data”. In our dump above, we have naively concatenated it all together and assumed that a page size of 4096+256 bytes somehow makes sense. Of course, it doesn’t.</p>
<p>Also, this majority voting hack is obviously not the “correct” way to work with a NAND chip. And even the proper SoC mounted on the proper mainboard can’t run a system off of a flash chip that gives it random bit flips that it can’t detect or recover from. The problem is that NAND is just inherently imperfect storage. Majority voting only corrects for transmission errors during dumping, but does nothing to bit errors that are stored on the device! Bits on the storage might decay over time, or the CPU might also have some transmission errors during writing.</p>
<p>Of course this problem has been very well known for a long time, so manufacturers always include some extra space next to user data for “error correction”. These extra bytes are called “out-of-band” bytes. And they are used to implement <strong>Error Correction Codes</strong> (ECC).</p>
<h3 id="ecc-according-to-the-nand-chip-data-sheet">ECC according to the NAND chip data sheet<a aria-hidden="true" tabindex="-1" href="#ecc-according-to-the-nand-chip-data-sheet"><span>¶</span></a></h3>
<p>The flash chip implements its own error correction algorithm by reserving some of the space for ECC. It is split into</p>
<ul>
<li>2048 blocks of</li>
<li>64 pages of</li>
<li>4096 user data bytes + 256 “extra” bytes (aka out-of-band bytes)</li>
<li>=&gt; 512 MiB of user data (the chip is 4 Gb, not 4 GB)</li>
<li>=&gt; 32 MiB of extra data</li>
</ul>
<p>If the chip-internal ECC is enabled, some of those extra bytes are used for ECC.</p>
<p>At this point, we naively assumed that each page would be</p>
<ul>
<li>4096 bytes of user data followed by</li>
<li>256 (or less?) bytes of ECC covering the previous 4096 bytes.</li>
</ul>
<p>However, we quickly found out that the sequences classified as “extra data” contain readable strings! That definitely suggests that this isn’t ECC data.</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/hexdump-01.png" alt="In-page addresses at and above 0x1000 (= 4096) are extra data"/>
						<figcaption>
							<p>
								In-page addresses at and above 0x1000 (= 4096) are extra data
							</p>
						</figcaption>
					</figure>
					</center>
<p>You can also see that there are parts within the user data where strings are suddenly cut off. This suggests that the ECC layout we assumed was wrong. It took us quite a while to figure out what exactly we missed.</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/hexdump-02.png" alt="Text “ignoring the CPU number” cut off at 0x824"/>
						<figcaption>
							<p>
								Text “ignoring the CPU number” cut off at 0x824
							</p>
						</figcaption>
					</figure>
					<figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/hexdump-03.png" alt="Text “IRQ_WAKE_THREAD” cut off at 0x824"/>
						<figcaption>
							<p>
								Text “IRQ_WAKE_THREAD” cut off at 0x824
							</p>
						</figcaption>
					</figure>
					</center>
<h4 id="entropy-analysis">Entropy Analysis<a aria-hidden="true" tabindex="-1" href="#entropy-analysis"><span>¶</span></a></h4>
<p>Turns out, the ECC layout is not just 4096 bytes of user data followed by 256 bytes of ECC. If we put all pages next to each other and then calculate the entropy over each n-th byte of a page, we will find that there are multiple sections with high entropy:</p>
<center><p><img src="https://exclav.es/blog/drone_hacking_part_1/entropy.png" alt=""/></p></center>
<p>Why are we looking at entropy? Well, because we expect the user data to have  ASCII text (low entropy) every now and then and the ECC data to be mostly random-looking byte values (high entropy).</p>
<p>The graph we’re seeing up here suggests that there are sections of <em>roughly</em> 1 KiB of user data, followed by 28 bytes of ECC data. Specifically,</p>
<ul>
<li>1028 B user data + 28 B ECC</li>
<li>1028 B user data + 28 B ECC</li>
<li>1028 B user data + 28 B ECC</li>
<li>1014 B user data + 28 B ECC</li>
<li>142 B unused</li>
</ul>
<p>Why these stranges values? And which ECC algorithm is that? We <em>can</em> choose to ignore that and just extract the user data sections and stitch them together. I won’t spam you with more <code>binwalk</code> and <code>dd</code> screenshots and just <em>tell</em> you that that also won’t result in a readable UBIFS image. Fortunately, we find an explanation for these values in the next section!</p>
<h3 id="ecc-according-to-the-soc-data-sheet">ECC according to the SoC data sheet<a aria-hidden="true" tabindex="-1" href="#ecc-according-to-the-soc-data-sheet"><span>¶</span></a></h3>
<p>At this point, we had already spent a lot of time fiddling with unstable reading setups and ECC layouts. And then we found that some further digging into the <em>right</em> documentation could have saved us a lot of time during our research. Because the SoC <em>also</em> does ECC. Not just the NAND chip. In fact, we can ignore the NAND chips ECC feature completely.</p>
<p>The SoC’s data sheet lists several possible ECC layouts. One of them is the following:</p>
<center><p><img src="https://exclav.es/blog/drone_hacking_part_1/layout-01.png" alt=""/></p></center>
<p>Well, that fits our findings perfectly, plus a BB (“bad blocks”) and CTRL (some kind of control bytes?) area that we didn’t identify before.</p>
<p>Using this diagram, we can cut out all the ECC, BB and CTRL sections and reconstruct the pure 512 MiB user data flash content.</p>
<div><figure><pre data-language="python"><code><div><p><span>import</span><span> sys</span></p></div><div></div><div><p><span>import</span><span> numpy </span><span>as</span><span> np</span></p></div><div></div><div><p><span>if</span><span> </span><span>len</span><span>(sys.argv) </span><span>!=</span><span> </span><span>2</span><span>:</span></p></div><div><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;Usage: </span><span>{</span><span>sys.argv[</span><span>0</span><span>]</span><span>}</span><span> dump&#34;</span><span>, </span><span>file</span><span>=</span><span>sys.stderr)</span></p></div><div><p><span><span>    </span></span><span>sys.exit(</span><span>1</span><span>)</span></p></div><div></div><div><p><span>dump_filename </span><span>=</span><span> sys.argv[</span><span>1</span><span>]</span></p></div><div></div><div><p><span>PAGE_SIZE_WITH_EXTRA</span><span> </span><span>=</span><span> </span><span>4352</span></p></div><div><p><span>PAGE_SIZE_USER_DATA</span><span> </span><span>=</span><span> </span><span>4096</span></p></div><div></div><div><p><span>user_data_slices </span><span>=</span><span> [</span></p></div><div><p><span>    </span><span>slice</span><span>(</span><span>0</span><span>, </span><span>1028</span><span>),</span></p></div><div><p><span>    </span><span>slice</span><span>(</span><span>1056</span><span>, </span><span>2084</span><span>),</span></p></div><div><p><span>    </span><span>slice</span><span>(</span><span>2112</span><span>, </span><span>3140</span><span>),</span></p></div><div><p><span>    </span><span>slice</span><span>(</span><span>3168</span><span>, </span><span>4096</span><span>),</span></p></div><div><p><span>    </span><span>slice</span><span>(</span><span>4098</span><span>, </span><span>4182</span><span>),</span></p></div><div><p><span>]</span></p></div><div></div><div><p><span>dump </span><span>=</span><span> np.memmap(dump_filename, </span><span>dtype</span><span>=</span><span>np.uint8, </span><span>mode</span><span>=</span><span>&#34;r&#34;</span><span>)</span></p></div><div><p><span>num_pages </span><span>=</span><span> dump.size </span><span>//</span><span> </span><span>PAGE_SIZE_WITH_EXTRA</span></p></div><div><p><span>dump_pages </span><span>=</span><span> dump.reshape(num_pages, </span><span>PAGE_SIZE_WITH_EXTRA</span><span>)</span></p></div><div></div><div><p><span>out </span><span>=</span><span> np.memmap(</span></p></div><div><p><span>    </span><span>&#34;dump-user-data.bin&#34;</span><span>,</span></p></div><div><p><span>    </span><span>dtype</span><span>=</span><span>np.uint8,</span></p></div><div><p><span>    </span><span>mode</span><span>=</span><span>&#34;write&#34;</span><span>,</span></p></div><div><p><span>    </span><span>shape</span><span>=</span><span>(num_pages, </span><span>PAGE_SIZE_USER_DATA</span><span>),</span></p></div><div><p><span>)</span></p></div><div><p><span>out_pages </span><span>=</span><span> out.reshape(num_pages, </span><span>PAGE_SIZE_USER_DATA</span><span>)</span></p></div><div></div><div><p><span>offset </span><span>=</span><span> </span><span>0</span></p></div><div><p><span>for</span><span> s </span><span>in</span><span> user_data_slices:</span></p></div><div><p><span><span>    </span></span><span>s_len </span><span>=</span><span> s.stop </span><span>-</span><span> s.start</span></p></div><div><p><span>    </span><span># note: this is an array operation,</span></p></div><div><p><span>    </span><span># so we only need to do this once per slice</span></p></div><div><p><span><span>    </span></span><span>out_pages[:, offset : offset </span><span>+</span><span> s_len] </span><span>=</span><span> dump_pages[:, s]</span></p></div><div><p><span><span>    </span></span><span>offset </span><span>+=</span><span> s_len</span></p></div></code></pre></figure></div>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/dump-03-01.png" alt="Binwalk output of the correctly defragmented user data section"/>
						<figcaption>
							<p>
								Binwalk output of the correctly defragmented user data section
							</p>
						</figcaption>
					</figure>
					<figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/dump-03-02.png" alt="ubi_reader still fails to extract any files - but at least we are seeing one of the file systems again"/>
						<figcaption>
							<p>
								ubi_reader still fails to extract any files - but at least we are seeing one of the file systems again
							</p>
						</figcaption>
					</figure>
					</center>
<p>Heyyy, look at that! We managed to extract a file system again - albeit with some error remaining. Let’s see what’s on it:</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/dump-03-03.png" alt="Empty extracted filesystem…"/>
						<figcaption>
							<p>
								Empty extracted filesystem…
							</p>
						</figcaption>
					</figure>
					</center>
<p>Hmm. Damn. The UBIFS image is now at least <em>somewhat</em> syntactically correct. But it is still broken enough to not have any files. Why could that be?
Well, we are looking at <em>exactly</em> what the SoC would see after reading the data from the NAND chip. <em>Plus</em> that we have done majority voting on the bytes - so our version is even better than what the SoC would see.</p>
<p><strong>But</strong>, there is no guarantee that there aren’t any random bit flips <em>on the NAND chip</em>, i.e., that random bit flipping happened during <em>writing</em>, desoldering or anytime between that!
So, there seems to no way around actually implementing the ECC algorithm and correcting the bit flips on the flash dump. Problem is: <strong>What kind of ECC algorithm is the SoC running?</strong> Unfortunately, the datasheet is silent here, so we had to find out on our own.</p>
<h3 id="a-short-primer-on-reverse-engineering-ecc-algorithms">A short primer on reverse engineering ECC algorithms<a aria-hidden="true" tabindex="-1" href="#a-short-primer-on-reverse-engineering-ecc-algorithms"><span>¶</span></a></h3>
<p>Typical ECC algorithms on NAND chips use <a href="https://en.wikipedia.org/wiki/BCH_code">BCH codes</a>, which are parametrized by the following properties:</p>
<ol>
<li>The amount of parity bits.</li>
<li>The correction capacity <code>t</code>, i.e., how many simultaneous bit flips may appear in the same data block before the block is “too broken” and the ECC algorithm fails.</li>
<li>The primitive polynomial used in the equation. If you don’t know what this is, just think of it as an integer parameter for now.</li>
<li>Whether and how the data is transformed <em>before</em> the parity bits are calculated.</li>
<li>Whether and how the parity bits are transformed <em>after</em> they are calculated.</li>
</ol>
<p>We can deduce (1) and (2) from our flash dump. For (3), (4), and (5) we have to either find the code of the SoC (if it is implement in software at all) and reverse engineer the ECC algorithm - or just bruteforce them.</p>
<h4 id="amount-of-parity-bits">Amount of parity bits<a aria-hidden="true" tabindex="-1" href="#amount-of-parity-bits"><span>¶</span></a></h4>
<p>As we have seen in the SoC’s data sheet, we have 112 byte of ECC / parity bits. However, the fragmented layout on the flash suggests that we actually have 4 ECC groups of 28 byte, each covering a different part of the user data. Note that this is an educated guess and does not have to be true. If we’re not getting anywhere, we should consider dropping this assumption later on. But spoiler: We’re right about this.</p>
<p>This means that we have <strong>224 parity bits</strong> (= 28 bytes).</p>
<h4 id="correction-capacity">Correction capacity<a aria-hidden="true" tabindex="-1" href="#correction-capacity"><span>¶</span></a></h4>
<p>This part we can just calculate if we make one very realistic assumption. We have 1028 bytes of user data, which is 8224 bits. If we want to represent these 8224 bits as a binary polynomial, we need at least degree 14:</p>
<p><code>2^13 =  8192</code> &lt; - Too small
<code>2^14 = 16384</code> &lt; - Fits!</p>
<p>This means our primitive polynomial needs to be at least degree 14 (<code>m &gt;= 14</code>).</p>
<p>The correction capacity is determined by the degree <code>m</code> and the amount of parity bits. The more parity bits we have in relation to <code>m</code>, the higher our correction capacity <code>t</code>:</p>
<p><code>t = parity_bits / m</code></p>
<p>Now given that <code>parity_bits</code> is fixed at 224 and assuming that the engineers chose <code>t</code> to be maximal, we conclude that <code>m = 14</code> and</p>
<p><code>t = 224 / 14 = 16</code></p>
<p>meaning that we can correct for up to 16 bit flips in the covered user data chunk. Anything more than that and the chunk is lost.</p>
<p><code>t = 16</code> also fits the description of the ECC section in the SoC’s data sheet: “16-Bit/1KB Error Correction Performance” (see our diagram above). So we are pretty certain that this assumption is correct.</p>
<h4 id="primitive-polynomial">Primitive polynomial<a aria-hidden="true" tabindex="-1" href="#primitive-polynomial"><span>¶</span></a></h4>
<p>We don’t know that and we will have to bruteforce it. Given that it is a <em>binary</em> polynomial, it is usually represented as a bit vector or simply as an integer. Given that <code>m = 14</code> we already know that our polynomial must have its 14th bit set and that the 14th bit is the highest bit that is set:</p>
<p><code>2^14 &lt;= prim_poly &lt; 2^15</code></p>
<p>which is well within bruteforcing range.</p>
<h4 id="pre-encode-and-post-encode-transformations">Pre-encode and post-encode transformations<a aria-hidden="true" tabindex="-1" href="#pre-encode-and-post-encode-transformations"><span>¶</span></a></h4>
<p>There are a few transformations that are commonly applied to either the user data <em>before</em> calculating the parity bits (“encoding”) or applied to the parity bits <em>after</em> calculating them. Examples include</p>
<ul>
<li>reverse bit order</li>
<li>reverse byte order</li>
<li>swap nibbles</li>
<li>invert</li>
</ul>
<p>Why you ask? Well, one of these combinations for example is very useful for NAND storage devices. You see, when NAND pages are erased and then read, their values are all <code>0xFF</code>. Problem is, a page full of <code>0xFF</code> will have</p>
<ul>
<li>user data = <code>0xFFFF...</code></li>
<li>ECC = <code>0xFFFF...</code></li>
</ul>
<p>and that is <em>not</em> a valid parity, meaning a cleanly erased page will be read as containing a lot of errors. That is because</p>
<p><code>parity(0xFF...) != 0xFF...</code></p>
<p>But we can pull a trick to make this work: Before encoding, invert the user data. And after encoding, invert the parity bits:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>user_data            = 0xFF...</span></p></div><div></div><div><p><span>inverted_user_data   = 0x00...</span></p></div><div></div><div><p><span>parity_bits          = parity(inverted_user_data)</span></p></div><div><p><span><span>                     </span></span><span>= parity(0x00...)</span></p></div><div><p><span><span>                     </span></span><span>= 0x00...</span></p></div><div></div><div><p><span>inverted_parity_bits = 0xFF...</span></p></div></code></pre></figure></div>
<p>Notice that the parity of an all-zero page <em>is</em> all-zero:</p>
<p><code>parity(0x00...) != 0x00...</code></p>
<p>So by implementing our ECC algorithm with these two inversions, we make a freshly erased page (<code>0xFF...</code>) have a valid parity (<code>0xFF...</code>) and the SoC’s error correction won’t need special handling for erased NAND pages.</p>
<p>Okay, back to the actual algorithm at hand here. How do we know that these two inversions are what the engineers actually chose? We don’t! We just try all these different transformations and see if one of them works. The amount of possible combinations of these 4 transformations is quite low and easily bruteforcable.</p>
<h3 id="brute-forcing-ecc-parameters">Brute-forcing ECC parameters<a aria-hidden="true" tabindex="-1" href="#brute-forcing-ecc-parameters"><span>¶</span></a></h3>
<p>In summary, to test our guessed parameters, we need a user data section without errors, generate its ECC and check if it matches the ECC that we read off of the NAND chip. Our bruteforce script thus has to do the following:</p>
<ol>
<li>Find a “good” user data section with no bit flips and the corresponding ECC section.</li>
<li>Iterate through all possible transformations.</li>
<li>Iterate through all possible primitive polynomials of degree 14</li>
<li>For each iteration, generate the ECC of the userdata section. If it matches the existing ECC, we have found the parameters.</li>
</ol>
<h4 id="picking-a-good-user-data-section">Picking a “good” user data section<a aria-hidden="true" tabindex="-1" href="#picking-a-good-user-data-section"><span>¶</span></a></h4>
<p>We need a user data section and its corresponding ECC section without bit flips. But how do we know that a section does not have bit flips? We don’t! We <em>could</em> try to be clever here. One possible approach would be to pick a section with a lot of text and check if the text makes sense. But the lazy approach works just as well: Just try a lot of sections and hope that one of them is correct. <em>More bruteforce. Yeah.</em></p>
<div><figure><pre data-language="python"><code><div><p><span>PAGE_SIZE</span><span> </span><span>=</span><span> </span><span>4096</span><span> </span><span>+</span><span> </span><span>256</span></p></div><div><p><span>SLICE_DATA_0</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>0</span><span>, </span><span>1028</span><span>)</span></p></div><div><p><span>SLICE_ECC_0</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>1028</span><span>, </span><span>1056</span><span>)</span></p></div><div></div><div><p><span>def</span><span> </span><span>main</span><span>():</span></p></div><div><p><span>    </span><span>if</span><span> </span><span>len</span><span>(sys.argv) </span><span>!=</span><span> </span><span>2</span><span>:</span></p></div><div><p><span>        </span><span>print</span><span>(</span></p></div><div><p><span>            </span><span>f</span><span>&#34;Usage: </span><span>{</span><span>sys.argv[</span><span>0</span><span>]</span><span>}</span><span> full_flash_dump.bin &#34;</span></p></div><div><p><span>            </span><span>f</span><span>&#34;(with </span><span>{PAGE_SIZE}</span><span> byte pages)&#34;</span><span>,</span></p></div><div><p><span>            </span><span>file</span><span>=</span><span>sys.stderr,</span></p></div><div><p><span><span>        </span></span><span>)</span></p></div><div><p><span><span>        </span></span><span>sys.exit(</span><span>1</span><span>)</span></p></div><div></div><div><p><span><span>    </span></span><span>f </span><span>=</span><span> </span><span>open</span><span>(sys.argv[</span><span>1</span><span>], </span><span>&#34;rb&#34;</span><span>)</span></p></div><div></div><div><p><span>    </span><span>while</span><span> (page </span><span>:=</span><span> f.read(</span><span>PAGE_SIZE</span><span>)) </span><span>!=</span><span> </span><span>b</span><span>&#34;&#34;</span><span>:</span></p></div><div><p><span><span>        </span></span><span>user_data </span><span>=</span><span> page[</span><span>SLICE_DATA_0</span><span>]</span></p></div><div><p><span><span>        </span></span><span>known_ecc </span><span>=</span><span> page[</span><span>SLICE_ECC_0</span><span>]</span></p></div><div></div><div><p><span>        </span><span># ...</span></p></div></code></pre></figure></div>
<p>As you can see in the script above, we only look at the first section of every page and then move on to the next page entirely. We’re not completely sure yet which ECC bytes cover which user data sections - especially since the 4th section looks fragmented. But we will stick to our assumption that the first 1028 bytes of user data are covered by the first 28 bytes of ECC. Spoiler: We’re right about this. Another Spoiler: The first 3 pages have bit-flips in their first section. The 4th one is good.</p>
<h4 id="iterate-through-all-possible-transformations">Iterate through all possible transformations<a aria-hidden="true" tabindex="-1" href="#iterate-through-all-possible-transformations"><span>¶</span></a></h4>
<p>We will try out 4 different transformations:</p>
<ul>
<li>reverse bit order</li>
<li>reverse byte order</li>
<li>swap nibbles</li>
<li>invert</li>
</ul>
<div><figure><pre data-language="python"><code><div><p><span>def</span><span> </span><span>reverse_bit_order</span><span>(b: </span><span>bytes</span><span>) -&gt; </span><span>bytes</span><span>:</span></p></div><div><p><span>    </span><span># credit to this hack at</span></p></div><div><p><span>    </span><span># https://graphics.stanford.edu/~seander/bithacks.html#ReverseByteWith64BitsDiv</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>bytes</span><span>((x </span><span>*</span><span> </span><span>0x</span><span>0202020202</span><span> </span><span>&amp;</span><span> </span><span>0x</span><span>010884422010</span><span>) </span><span>%</span><span> </span><span>1023</span><span> </span><span>for</span><span> x </span><span>in</span><span> b)</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>reverse_byte_order</span><span>(b: </span><span>bytes</span><span>) -&gt; </span><span>bytes</span><span>:</span></p></div><div><p><span>    </span><span>return</span><span> b[::</span><span>-</span><span>1</span><span>]</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>swap_nibbles</span><span>(b: </span><span>bytes</span><span>) -&gt; </span><span>bytes</span><span>:</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>bytes</span><span>((x </span><span>&gt;&gt;</span><span> </span><span>4</span><span> </span><span>|</span><span> x </span><span>&lt;&lt;</span><span> </span><span>4</span><span>) </span><span>&amp;</span><span> </span><span>0x</span><span>FF</span><span> </span><span>for</span><span> x </span><span>in</span><span> b)</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>invert</span><span>(b: </span><span>bytes</span><span>) -&gt; </span><span>bytes</span><span>:</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>bytes</span><span>(x </span><span>^</span><span> </span><span>0x</span><span>FF</span><span> </span><span>for</span><span> x </span><span>in</span><span> b)</span></p></div></code></pre></figure></div>
<p>For these transformation we want all possible subsets and orderings, but without using the same transformation twice in one run.</p>
<div><figure><pre data-language="python"><code><div><p><span>TRANSFORMATIONS</span><span> </span><span>=</span><span> [reverse_bit_order, reverse_byte_order, swap_nibbles, invert]</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>all_transformation_sequences</span><span>():</span></p></div><div><p><span>    </span><span>&#34;&#34;&#34;</span></p></div><div><p><span><span>    </span></span><span>:return:  Iterator over all possible subsets and</span></p></div><div><p><span><span>              </span></span><span>orderings of transformations</span></p></div><div><p><span><span>              </span></span><span>(without duplicate transformations).</span></p></div><div><p><span><span>    </span></span><span>&#34;&#34;&#34;</span></p></div><div><p><span>    </span><span>for</span><span> transformation_count </span><span>in</span><span> </span><span>range</span><span>(</span><span>0</span><span>, </span><span>len</span><span>(</span><span>TRANSFORMATIONS</span><span>)):</span></p></div><div><p><span>        </span><span>for</span><span> subset </span><span>in</span><span> itertools.combinations(</span><span>TRANSFORMATIONS</span><span>, transformation_count):</span></p></div><div><p><span>            </span><span>for</span><span> permutation </span><span>in</span><span> itertools.permutations(subset):</span></p></div><div><p><span>                </span><span>yield</span><span> permutation</span></p></div></code></pre></figure></div>
<p>Then we can run through all these combinations as both pre-transformations as well as post-transformations:</p>
<div><figure><pre data-language="python"><code><div><p><span># try all combinations of pre-transformations</span></p></div><div><p><span>for</span><span> pre_transform_seq </span><span>in</span><span> all_transformation_sequences():</span></p></div><div><p><span><span>    </span></span><span>user_data_transformed </span><span>=</span><span> user_data</span></p></div><div><p><span>    </span><span>for</span><span> pre_transform </span><span>in</span><span> pre_transform_seq:</span></p></div><div><p><span><span>        </span></span><span>user_data_transformed </span><span>=</span><span> pre_transform(user_data_transformed)</span></p></div><div></div><div><p><span><span>    </span></span><span>ecc </span><span>=</span><span> bch.encode(user_data_transformed)</span></p></div><div></div><div><p><span>    </span><span># try all combinations of post-transformations</span></p></div><div><p><span>    </span><span>for</span><span> post_transform_seq </span><span>in</span><span> all_transformation_sequences():</span></p></div><div><p><span><span>        </span></span><span>ecc_transformed </span><span>=</span><span> ecc</span></p></div><div><p><span>        </span><span>for</span><span> post_transform </span><span>in</span><span> post_transform_seq:</span></p></div><div><p><span><span>            </span></span><span>ecc_transformed </span><span>=</span><span> post_transform(ecc_transformed)</span></p></div><div></div><div><p><span>        </span><span>if</span><span> ecc_transformed </span><span>==</span><span> known_ecc:</span></p></div><div><p><span>            </span><span># success</span></p></div><div><p><span>            </span><span>...</span></p></div></code></pre></figure></div>
<p>Note that some combinations are equivalent:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>reverse_bit_order(invert(data)) == invert(reverse_bit_order(data))</span></p></div></code></pre></figure></div>
<p>We don’t optimize for that though.</p>
<h4 id="iterate-through-all-possible-primitive-polynomials-of-degree-14">Iterate through all possible primitive polynomials of degree 14<a aria-hidden="true" tabindex="-1" href="#iterate-through-all-possible-primitive-polynomials-of-degree-14"><span>¶</span></a></h4>
<p>There are three ways to do this:</p>
<ol>
<li>A simple and slow way</li>
<li>A math-heavy and fast way</li>
<li>A much better way that is about as simple as (1) and as fast as (2)</li>
</ol>
<p>Of course, we went with (1) during our initial research because sometimes thinking just takes longer than computing inefficiently. Afterwards, I spent hours digging into polynomial algebra to come up with (2) and was very happy about it - only to also find (3) right afterwards which was a lot simpler and equally as good… Oh well, at least I got to freshen up on first- and second-semester linear algebra.</p>
<p><strong>(1) Simple and slow</strong>
The simple way would be to just try all polynomials of degree 14. In their integer representation, that’s all integers in
<code>range(2**14, 2**15)</code>
While this <em>will</em> eventually cover the correct primitive polynomial, it will also make bchlib crash the entire script with a SIGSEGV for a lot of non-primitive polynomials.</p>
<p>A quick-and-dirty workaround is to just spawn a new process for every candidate polynomial so your main script doesn’t die. And that’s what we did during initial research. It works - but the creation of over 16,000 processes makes this a bit slow. Not <em>too</em> slow to work with though. This approach works in practice.</p>
<p><strong>(2) Math-heavy and fast</strong>
The <em>proper</em> way to do this is to only pass primitive polynomials into BCH’s constructor. But how do we know if the polynomial that is represented by our integer is primitive? By doing lots of math. If you’re not familiar with polynomial algebra (like I was) but really want to know how this works, read the section <strong>A brief detour into polynomial algebra</strong> in the addendum.</p>
<p>Spoiler: It is a lot of thinking work and only about 5% faster than (3) in my tests.</p>
<p><strong>(3) Simple and fast</strong>
Turns out, bchlib only crashes for polynomials with a constant term of 0, i.e., even integers. So if we use <code>range(2**14 + 1, 2**15, 2)</code>, then it just works without having to fiddle with multiprocessing or math.</p>
<p>This will still throw a runtime error for a lot of non-primitive polynomials but we can catch that via try-except:</p>
<div><figure><pre data-language="python"><code><div><p><span>for</span><span> prim_poly </span><span>in</span><span> </span><span>range</span><span>(</span><span>2</span><span>**</span><span>14</span><span> </span><span>+</span><span> </span><span>1</span><span>, </span><span>2</span><span>**</span><span>15</span><span>, </span><span>2</span><span>):</span></p></div><div><p><span>    </span><span>try</span><span>:</span></p></div><div><p><span><span>        </span></span><span>bch </span><span>=</span><span> bchlib.BCH(</span><span>t</span><span>=</span><span>16</span><span>, </span><span>prim_poly</span><span>=</span><span>prim_poly)</span></p></div><div><p><span>    </span><span>except</span><span> </span><span>RuntimeError</span><span>:</span></p></div><div><p><span>        </span><span>continue</span></p></div></code></pre></figure></div>
<h4 id="checking-the-generated-ecc">Checking the generated ECC<a aria-hidden="true" tabindex="-1" href="#checking-the-generated-ecc"><span>¶</span></a></h4>
<p>This is straight-forward and self-explanatory.</p>
<p>You can find the full <strong>ECC Bruteforce Script</strong> in the addendum.</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>Trying page 0, userdata segment 0</span></p></div><div><p><span>Trying page 1, userdata segment 0</span></p></div><div><p><span>Trying page 2, userdata segment 0</span></p></div><div><p><span>Trying page 3, userdata segment 0</span></p></div><div><p><span>========== ECC parameters found!</span></p></div><div><p><span>- prim_poly = 17475</span></p></div><div><p><span>- pre_transform_seq = (&lt;function reverse_bit_order at 0x7f7ff1f8f560&gt;, &lt;function invert at 0x7f7ff1f8fd80&gt;)</span></p></div><div><p><span>- post_transform_seq = (&lt;function reverse_bit_order at 0x7f7ff1f8f560&gt;, &lt;function invert at 0x7f7ff1f8fd80&gt;)</span></p></div><div><p><span>- time to brute force: 0:00:22.094555</span></p></div></code></pre></figure></div>
<h3 id="restoring-the-full-firmware">Restoring the full firmware<a aria-hidden="true" tabindex="-1" href="#restoring-the-full-firmware"><span>¶</span></a></h3>
<p>Now that we have a working ECC setup, let’s reassemble the entire firmware! There is just one little detail that we still need to find out:</p>
<p>Which parts of user data are covered by which parts of ECC? We already confirmed that the first user data section is covered by the first 28 bytes of ECC. And the same turns out to be true for the second and third user data section. The fourth section is a bit tricky: It is 928+84 bytes of user data long, with additional BB and CTRL bytes around. What is that about? Turns out, a bit of trial-and-error and looking at the SoC’s data sheet revealed how ECC works for that section.</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/layout-02.png" alt="Mapping of ECC bytes to ECC-covered bytes. The fourth section is fragmented and out of order."/>
						<figcaption>
							<p>
								Mapping of ECC bytes to ECC-covered bytes. The fourth section is fragmented and out of order.
							</p>
						</figcaption>
					</figure>
					</center>
<p>Now we just need to apply that to every page and - voilà - full firmware dump. :tada:</p>
<p>The <strong>Final Restore Script</strong> can be found in the addendum.</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>&gt; python restore_from_flash_dump.py ../majority-voting/dump-majority-voting.bin</span></p></div><div></div><div><p><span>[   0 % ] Extracted page        1 /   131072 (no errors)</span></p></div><div><p><span>[   0 % ] Extracted page        2 /   131072 (errors in page: 5)</span></p></div><div><p><span>[   0 % ] Extracted page        3 /   131072 (errors in page: 6)</span></p></div><div></div><div><p><span>...</span></p></div><div><p><span>[ 100 % ] Extracted page   131070 /   131072 (no errors)</span></p></div><div><p><span>[ 100 % ] Extracted page   131071 /   131072 (no errors)</span></p></div><div><p><span>[ 100 % ] Extracted page   131072 /   131072 (no errors)</span></p></div><div></div><div><p><span>======== DONE EXTRACTING</span></p></div><div><p><span>- Total pages: 131072</span></p></div><div><p><span>- Pages with errors: 61387 (46.83 %)</span></p></div><div><p><span>- Total bit errors: 247134 (0.0054 %)</span></p></div><div><p><span>- ECC polynomial: 17475</span></p></div><div><p><span>- Correction capacity per chunk: 16</span></p></div><div><p><span>- Highest error count in a single chunk: 9 (56.25 %)</span></p></div></code></pre></figure></div>
<p>If we look at the binwalk output for that file, it is <em>much</em> better and looks like it is actually free of errors:</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/dump-04-01.png" alt="Binwalk output of the corrected page. Note that binwalk is now much more confident in its findings (green text)."/>
						<figcaption>
							<p>
								Binwalk output of the corrected page. Note that binwalk is now much more confident in its findings (green text).
							</p>
						</figcaption>
					</figure>
					</center>
<p>When trying to extract the first ubifs image with ubi_reader, we actually get a working file system!</p>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/dump-04-02.png" alt="ubi_reader finally extracts two of the three file systems including files!"/>
						<figcaption>
							<p>
								ubi_reader finally extracts two of the three file systems including files!
							</p>
						</figcaption>
					</figure>
					</center>
<p>ubi_reader still throws an error in the later segments of UBIFS image but this extraction is good enough to start reverse engineering the successfully extracted files. Notably, it is enough to reverse engineer the firmware decryption!</p>
<p>Stay tuned for <strong>Part 2</strong> of our drone hacking blogpost where we dive into the reverse engineering and vulnerability analysis of the Potensic Atom 2!</p>
<hr/>
<h2 id="addendum">Addendum<a aria-hidden="true" tabindex="-1" href="#addendum"><span>¶</span></a></h2>
<h3 id="final-restore-script">Final Restore Script<a aria-hidden="true" tabindex="-1" href="#final-restore-script"><span>¶</span></a></h3>
<div><figure><pre data-language="python"><code><div><p><span>import</span><span> os.path</span></p></div><div><p><span>import</span><span> sys</span></p></div><div></div><div><p><span>import</span><span> bchlib</span></p></div><div></div><div><p><span>ECC_POLYNOMIAL</span><span> </span><span>=</span><span> </span><span>17475</span></p></div><div><p><span>CORRECTION_CAPACITY</span><span> </span><span>=</span><span> </span><span>16</span></p></div><div></div><div><p><span>USER_DATA_SIZE</span><span> </span><span>=</span><span> </span><span>4096</span></p></div><div><p><span>PAGE_SIZE</span><span> </span><span>=</span><span> </span><span>USER_DATA_SIZE</span><span> </span><span>+</span><span> </span><span>256</span></p></div><div></div><div><p><span>SLICE_DATA_0</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>0</span><span>, </span><span>1028</span><span>)</span></p></div><div><p><span>SLICE_ECC_0</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>1028</span><span>, </span><span>1056</span><span>)</span></p></div><div><p><span>SLICE_DATA_1</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>1056</span><span>, </span><span>2084</span><span>)</span></p></div><div><p><span>SLICE_ECC_1</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>2084</span><span>, </span><span>2112</span><span>)</span></p></div><div><p><span>SLICE_DATA_2</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>2112</span><span>, </span><span>3140</span><span>)</span></p></div><div><p><span>SLICE_ECC_2</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>3140</span><span>, </span><span>3168</span><span>)</span></p></div><div><p><span>SLICE_DATA_3</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>3168</span><span>, </span><span>4096</span><span>)</span></p></div><div><p><span>SLICE_BB</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>4096</span><span>, </span><span>4098</span><span>)</span></p></div><div><p><span>SLICE_DATA_4</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>4098</span><span>, </span><span>4182</span><span>)</span></p></div><div><p><span>SLICE_ECC_3</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>4182</span><span>, </span><span>4210</span><span>)</span></p></div><div><p><span>SLICE_CTRL</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>4210</span><span>, </span><span>4224</span><span>)</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>parse_flash_page</span><span>(flash_page: </span><span>bytes</span><span>) -&gt; list[tuple[</span><span>bytearray</span><span>, </span><span>bytearray</span><span>]]:</span></p></div><div><p><span>    </span><span>&#34;&#34;&#34;</span></p></div><div><p><span><span>    </span></span><span>Transforms a flash-layout page into a userdata-layout page according to SoC datasheet,</span></p></div><div><p><span><span>    </span></span><span>chunked according to ECC coverage.</span></p></div><div></div><div><p><span><span>    </span></span><span>Flash layout:</span></p></div><div><p><span><span>    </span></span><span>data + ecc + data + ecc + data + ecc + data + bb + data + ecc + ctrl</span></p></div><div></div><div><p><span><span>    </span></span><span>Userdata layout:</span></p></div><div><p><span><span>    </span></span><span>data + bb + ctrl</span></p></div><div></div><div><p><span><span>    </span></span><span>ECC coverage:</span></p></div><div><p><span><span>    </span></span><span>data0 &lt;- ECC0</span></p></div><div><p><span><span>    </span></span><span>data1 &lt;- ECC1</span></p></div><div><p><span><span>    </span></span><span>data2 &lt;- ECC2</span></p></div><div><p><span><span>    </span></span><span>data3+data4+bb+ctrl &lt;- ECC3</span></p></div><div></div><div><p><span><span>    </span></span><span>:param flash_page: The 4224 or 4352 byte flash-layout page</span></p></div><div><p><span><span>    </span></span><span>&#34;&#34;&#34;</span></p></div><div></div><div><p><span><span>    </span></span><span>chunks </span><span>=</span><span> []</span></p></div><div></div><div><p><span>    </span><span># three simple chunks of full-sized data + ecc</span></p></div><div><p><span><span>    </span></span><span>chunks.append((flash_page[</span><span>SLICE_DATA_0</span><span>], flash_page[</span><span>SLICE_ECC_0</span><span>]))</span></p></div><div><p><span><span>    </span></span><span>chunks.append((flash_page[</span><span>SLICE_DATA_1</span><span>], flash_page[</span><span>SLICE_ECC_1</span><span>]))</span></p></div><div><p><span><span>    </span></span><span>chunks.append((flash_page[</span><span>SLICE_DATA_2</span><span>], flash_page[</span><span>SLICE_ECC_2</span><span>]))</span></p></div><div></div><div><p><span>    </span><span># last chunk is fragmented a bit</span></p></div><div><p><span><span>    </span></span><span>userdata_chunk </span><span>=</span><span> </span><span>bytearray</span><span>()</span></p></div><div><p><span><span>    </span></span><span>userdata_chunk.extend(flash_page[</span><span>SLICE_DATA_3</span><span>])</span></p></div><div><p><span><span>    </span></span><span>userdata_chunk.extend(flash_page[</span><span>SLICE_DATA_4</span><span>])</span></p></div><div><p><span><span>    </span></span><span>userdata_chunk.extend(flash_page[</span><span>SLICE_BB</span><span>])</span></p></div><div><p><span><span>    </span></span><span>userdata_chunk.extend(flash_page[</span><span>SLICE_CTRL</span><span>])</span></p></div><div></div><div><p><span><span>    </span></span><span>chunks.append((userdata_chunk, flash_page[</span><span>SLICE_ECC_3</span><span>]))</span></p></div><div></div><div><p><span>    </span><span>return</span><span> chunks</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>invert</span><span>(b: </span><span>bytearray</span><span>) -&gt; </span><span>bytearray</span><span>:</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>bytearray</span><span>(x </span><span>^</span><span> </span><span>0x</span><span>FF</span><span> </span><span>for</span><span> x </span><span>in</span><span> b)</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>fix_chunk_inplace</span><span>(data: </span><span>bytearray</span><span>, ecc: </span><span>bytearray</span><span>) -&gt; tuple[</span><span>int</span><span>, </span><span>bytearray</span><span>]:</span></p></div><div><p><span><span>    </span></span><span>data_transformed </span><span>=</span><span> invert(data)</span></p></div><div><p><span><span>    </span></span><span>ecc_transformed </span><span>=</span><span> invert(ecc)</span></p></div><div></div><div><p><span><span>    </span></span><span>bch </span><span>=</span><span> bchlib.BCH(</span><span>t</span><span>=</span><span>CORRECTION_CAPACITY</span><span>, </span><span>prim_poly</span><span>=</span><span>ECC_POLYNOMIAL</span><span>, </span><span>swap_bits</span><span>=</span><span>True</span><span>)</span></p></div><div><p><span><span>    </span></span><span>err_count </span><span>=</span><span> bch.decode(data_transformed, ecc_transformed)</span></p></div><div><p><span><span>    </span></span><span>bch.correct(data_transformed, ecc_transformed)</span></p></div><div></div><div><p><span>    </span><span>return</span><span> err_count, invert(data_transformed)</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>main</span><span>():</span></p></div><div><p><span>    </span><span>if</span><span> </span><span>len</span><span>(sys.argv) </span><span>!=</span><span> </span><span>2</span><span>:</span></p></div><div><p><span>        </span><span>print</span><span>(</span></p></div><div><p><span>            </span><span>f</span><span>&#34;Usage: </span><span>{</span><span>sys.argv[</span><span>0</span><span>]</span><span>}</span><span> full_flash_dump.bin &#34;</span></p></div><div><p><span>            </span><span>f</span><span>&#34;(with </span><span>{PAGE_SIZE}</span><span> byte pages)&#34;</span><span>,</span></p></div><div><p><span>            </span><span>file</span><span>=</span><span>sys.stderr,</span></p></div><div><p><span><span>        </span></span><span>)</span></p></div><div><p><span><span>        </span></span><span>sys.exit(</span><span>1</span><span>)</span></p></div><div></div><div><p><span><span>    </span></span><span>total_page_count </span><span>=</span><span> os.path.getsize(sys.argv[</span><span>1</span><span>]) </span><span>//</span><span> </span><span>PAGE_SIZE</span></p></div><div><p><span><span>    </span></span><span>f_in </span><span>=</span><span> </span><span>open</span><span>(sys.argv[</span><span>1</span><span>], </span><span>&#34;rb&#34;</span><span>)</span></p></div><div><p><span><span>    </span></span><span>f_out </span><span>=</span><span> </span><span>open</span><span>(</span><span>&#34;firmware-corrected.bin&#34;</span><span>, </span><span>&#34;wb&#34;</span><span>)</span></p></div><div><p><span><span>    </span></span><span>page_index </span><span>=</span><span> </span><span>0</span></p></div><div></div><div><p><span><span>    </span></span><span>total_errors </span><span>=</span><span> </span><span>0</span></p></div><div><p><span><span>    </span></span><span>pages_with_errors </span><span>=</span><span> </span><span>0</span></p></div><div><p><span><span>    </span></span><span>highest_chunk_error_count </span><span>=</span><span> </span><span>0</span></p></div><div><p><span>    </span><span>while</span><span> (page </span><span>:=</span><span> f_in.read(</span><span>PAGE_SIZE</span><span>)) </span><span>!=</span><span> </span><span>b</span><span>&#34;&#34;</span><span>:</span></p></div><div><p><span><span>        </span></span><span>page_index </span><span>+=</span><span> </span><span>1</span></p></div><div></div><div><p><span><span>        </span></span><span>chunks </span><span>=</span><span> parse_flash_page(page)</span></p></div><div></div><div><p><span><span>        </span></span><span>errors_in_page </span><span>=</span><span> </span><span>0</span></p></div><div><p><span><span>        </span></span><span>page_corrected </span><span>=</span><span> </span><span>bytearray</span><span>()</span></p></div><div><p><span>        </span><span>for</span><span> i, (data, ecc) </span><span>in</span><span> </span><span>enumerate</span><span>(chunks):</span></p></div><div><p><span><span>            </span></span><span>err_count, data </span><span>=</span><span> fix_chunk_inplace(data, ecc)</span></p></div><div><p><span><span>            </span></span><span>page_corrected.extend(data)</span></p></div><div><p><span><span>            </span></span><span>errors_in_page </span><span>+=</span><span> err_count</span></p></div><div><p><span><span>            </span></span><span>highest_chunk_error_count </span><span>=</span><span> </span><span>max</span><span>(highest_chunk_error_count, err_count)</span></p></div><div></div><div><p><span>        </span><span># cut off BB and CTRL</span></p></div><div><p><span><span>        </span></span><span>f_out.write(page_corrected[:</span><span>USER_DATA_SIZE</span><span>])</span></p></div><div></div><div><p><span>        </span><span>print</span><span>(</span></p></div><div><p><span>            </span><span>f</span><span>&#34;[</span><span>{</span><span>page_index</span><span>/</span><span>total_page_count</span><span>*</span><span>100</span><span>: 4.0f</span><span>}</span><span> % ] Extracted page </span><span>{</span><span>page_index</span><span>: 8d</span><span>}</span><span> / </span><span>{</span><span>total_page_count</span><span>: 8d</span><span>}</span><span> &#34;</span></p></div><div><p><span>            </span><span>+</span><span> (</span></p></div><div><p><span>                </span><span>f</span><span>&#34;(errors in page: </span><span>{</span><span>errors_in_page</span><span>}</span><span>)&#34;</span></p></div><div><p><span>                </span><span>if</span><span> errors_in_page </span><span>&gt;</span><span> </span><span>0</span></p></div><div><p><span>                </span><span>else</span><span> </span><span>f</span><span>&#34;(no errors)&#34;</span></p></div><div><p><span><span>            </span></span><span>)</span></p></div><div><p><span><span>        </span></span><span>)</span></p></div><div><p><span><span>        </span></span><span>total_errors </span><span>+=</span><span> errors_in_page</span></p></div><div><p><span>        </span><span>if</span><span> errors_in_page </span><span>&gt;</span><span> </span><span>0</span><span>:</span></p></div><div><p><span><span>            </span></span><span>pages_with_errors </span><span>+=</span><span> </span><span>1</span></p></div><div></div><div><p><span>    </span><span>print</span><span>()</span></p></div><div><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;======== DONE EXTRACTING&#34;</span><span>)</span></p></div><div><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;- Total pages: </span><span>{</span><span>total_page_count</span><span>}</span><span>&#34;</span><span>)</span></p></div><div><p><span>    </span><span>print</span><span>(</span></p></div><div><p><span>        </span><span>f</span><span>&#34;- Pages with errors: </span><span>{</span><span>pages_with_errors</span><span>}</span><span> (</span><span>{</span><span>pages_with_errors</span><span>/</span><span>total_page_count</span><span>*</span><span>100</span><span>:.02f</span><span>}</span><span> %)&#34;</span></p></div><div><p><span><span>    </span></span><span>)</span></p></div><div><p><span>    </span><span>print</span><span>(</span></p></div><div><p><span>        </span><span>f</span><span>&#34;- Total bit errors: </span><span>{</span><span>total_errors</span><span>}</span><span> (</span><span>{</span><span>total_errors </span><span>/</span><span> (total_page_count</span><span>*</span><span>PAGE_SIZE</span><span>*</span><span>8</span><span>)</span><span>*</span><span>100</span><span>:.04f</span><span>}</span><span> %)&#34;</span></p></div><div><p><span><span>    </span></span><span>)</span></p></div><div><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;- ECC polynomial: </span><span>{ECC_POLYNOMIAL}</span><span>&#34;</span><span>)</span></p></div><div><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;- Correction capacity per chunk: </span><span>{CORRECTION_CAPACITY}</span><span>&#34;</span><span>)</span></p></div><div><p><span>    </span><span>print</span><span>(</span></p></div><div><p><span>        </span><span>f</span><span>&#34;- Highest error count in a single chunk: </span><span>{</span><span>highest_chunk_error_count</span><span>}</span><span> &#34;</span></p></div><div><p><span>        </span><span>f</span><span>&#34;(</span><span>{</span><span>highest_chunk_error_count</span><span>/</span><span>CORRECTION_CAPACITY</span><span>*</span><span>100</span><span>:.02f</span><span>}</span><span> %)&#34;</span></p></div><div><p><span><span>    </span></span><span>)</span></p></div><div></div><div></div><div><p><span>if</span><span> </span><span>__name__</span><span> </span><span>==</span><span> </span><span>&#34;__main__&#34;</span><span>:</span></p></div><div><p><span><span>    </span></span><span>main()</span></p></div></code></pre></figure></div>
<h3 id="ecc-bruteforce-script">ECC Bruteforce Script<a aria-hidden="true" tabindex="-1" href="#ecc-bruteforce-script"><span>¶</span></a></h3>
<div><figure><pre data-language="python"><code><div><p><span>import</span><span> datetime</span></p></div><div><p><span>import</span><span> itertools</span></p></div><div><p><span>import</span><span> sys</span></p></div><div></div><div><p><span>import</span><span> bchlib</span></p></div><div></div><div><p><span>PAGE_SIZE</span><span> </span><span>=</span><span> </span><span>4096</span><span> </span><span>+</span><span> </span><span>256</span></p></div><div></div><div><p><span>SLICE_DATA_0</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>0</span><span>, </span><span>1028</span><span>)</span></p></div><div><p><span>SLICE_ECC_0</span><span> </span><span>=</span><span> </span><span>slice</span><span>(</span><span>1028</span><span>, </span><span>1056</span><span>)</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>reverse_bit_order</span><span>(b: </span><span>bytes</span><span>) -&gt; </span><span>bytes</span><span>:</span></p></div><div><p><span>    </span><span># credit to this hack at</span></p></div><div><p><span>    </span><span># https://graphics.stanford.edu/~seander/bithacks.html#ReverseByteWith64BitsDiv</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>bytes</span><span>((x </span><span>*</span><span> </span><span>0x</span><span>0202020202</span><span> </span><span>&amp;</span><span> </span><span>0x</span><span>010884422010</span><span>) </span><span>%</span><span> </span><span>1023</span><span> </span><span>for</span><span> x </span><span>in</span><span> b)</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>reverse_byte_order</span><span>(b: </span><span>bytes</span><span>) -&gt; </span><span>bytes</span><span>:</span></p></div><div><p><span>    </span><span>return</span><span> b[::</span><span>-</span><span>1</span><span>]</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>swap_nibbles</span><span>(b: </span><span>bytes</span><span>) -&gt; </span><span>bytes</span><span>:</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>bytes</span><span>((x </span><span>&gt;&gt;</span><span> </span><span>4</span><span> </span><span>|</span><span> x </span><span>&lt;&lt;</span><span> </span><span>4</span><span>) </span><span>&amp;</span><span> </span><span>0x</span><span>FF</span><span> </span><span>for</span><span> x </span><span>in</span><span> b)</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>invert</span><span>(b: </span><span>bytes</span><span>) -&gt; </span><span>bytes</span><span>:</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>bytes</span><span>(x </span><span>^</span><span> </span><span>0x</span><span>FF</span><span> </span><span>for</span><span> x </span><span>in</span><span> b)</span></p></div><div></div><div></div><div><p><span>TRANSFORMATIONS</span><span> </span><span>=</span><span> [reverse_bit_order, reverse_byte_order, swap_nibbles, invert]</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>all_transformation_sequences</span><span>():</span></p></div><div><p><span>    </span><span>&#34;&#34;&#34;</span></p></div><div><p><span><span>    </span></span><span>:return:  Iterator over all possible subsets and</span></p></div><div><p><span><span>              </span></span><span>orderings of transformations</span></p></div><div><p><span><span>              </span></span><span>(without duplicate transformations).</span></p></div><div><p><span><span>    </span></span><span>&#34;&#34;&#34;</span></p></div><div><p><span>    </span><span>for</span><span> transformation_count </span><span>in</span><span> </span><span>range</span><span>(</span><span>0</span><span>, </span><span>len</span><span>(</span><span>TRANSFORMATIONS</span><span>)):</span></p></div><div><p><span>        </span><span>for</span><span> subset </span><span>in</span><span> itertools.combinations(</span><span>TRANSFORMATIONS</span><span>, transformation_count):</span></p></div><div><p><span>            </span><span>for</span><span> permutation </span><span>in</span><span> itertools.permutations(subset):</span></p></div><div><p><span>                </span><span>yield</span><span> permutation</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>main</span><span>():</span></p></div><div><p><span>    </span><span>if</span><span> </span><span>len</span><span>(sys.argv) </span><span>!=</span><span> </span><span>2</span><span>:</span></p></div><div><p><span>        </span><span>print</span><span>(</span></p></div><div><p><span>            </span><span>f</span><span>&#34;Usage: </span><span>{</span><span>sys.argv[</span><span>0</span><span>]</span><span>}</span><span> full_flash_dump.bin &#34;</span></p></div><div><p><span>            </span><span>f</span><span>&#34;(with </span><span>{PAGE_SIZE}</span><span> byte pages)&#34;</span><span>,</span></p></div><div><p><span>            </span><span>file</span><span>=</span><span>sys.stderr,</span></p></div><div><p><span><span>        </span></span><span>)</span></p></div><div><p><span><span>        </span></span><span>sys.exit(</span><span>1</span><span>)</span></p></div><div></div><div><p><span><span>    </span></span><span>f </span><span>=</span><span> </span><span>open</span><span>(sys.argv[</span><span>1</span><span>], </span><span>&#34;rb&#34;</span><span>)</span></p></div><div></div><div><p><span>    </span><span># Both of these work about equally fast</span></p></div><div><p><span>    </span><span># primitive_polynomials = list(primitive_binary_polynomials(14))</span></p></div><div><p><span><span>    </span></span><span>primitive_polynomials </span><span>=</span><span> </span><span>list</span><span>(</span><span>range</span><span>(</span><span>2</span><span>**</span><span>14</span><span> </span><span>+</span><span> </span><span>1</span><span>, </span><span>2</span><span>**</span><span>15</span><span>, </span><span>2</span><span>))</span></p></div><div></div><div><p><span>    </span><span># try all pages</span></p></div><div><p><span><span>    </span></span><span>t0 </span><span>=</span><span> datetime.datetime.now()</span></p></div><div><p><span><span>    </span></span><span>page_index </span><span>=</span><span> </span><span>0</span></p></div><div><p><span>    </span><span>while</span><span> (page </span><span>:=</span><span> f.read(</span><span>PAGE_SIZE</span><span>)) </span><span>!=</span><span> </span><span>b</span><span>&#34;&#34;</span><span>:</span></p></div><div><p><span>        </span><span>print</span><span>(</span><span>f</span><span>&#34;Trying page </span><span>{</span><span>page_index</span><span>}</span><span>, userdata segment 0&#34;</span><span>)</span></p></div><div><p><span><span>        </span></span><span>page_index </span><span>+=</span><span> </span><span>1</span></p></div><div></div><div><p><span><span>        </span></span><span>user_data </span><span>=</span><span> page[</span><span>SLICE_DATA_0</span><span>]</span></p></div><div><p><span><span>        </span></span><span>known_ecc </span><span>=</span><span> page[</span><span>SLICE_ECC_0</span><span>]</span></p></div><div></div><div><p><span>        </span><span># try all primitive polynomials of the correct degree</span></p></div><div><p><span>        </span><span>for</span><span> prim_poly </span><span>in</span><span> primitive_polynomials:</span></p></div><div><p><span>            </span><span>try</span><span>:</span></p></div><div><p><span><span>                </span></span><span>bch </span><span>=</span><span> bchlib.BCH(</span><span>t</span><span>=</span><span>16</span><span>, </span><span>prim_poly</span><span>=</span><span>prim_poly)</span></p></div><div><p><span>            </span><span>except</span><span> </span><span>RuntimeError</span><span>:</span></p></div><div><p><span>                </span><span>continue</span></p></div><div></div><div><p><span>            </span><span># try all combinations of pre-transformations</span></p></div><div><p><span>            </span><span>for</span><span> pre_transform_seq </span><span>in</span><span> all_transformation_sequences():</span></p></div><div><p><span><span>                </span></span><span>user_data_transformed </span><span>=</span><span> user_data</span></p></div><div><p><span>                </span><span>for</span><span> pre_transform </span><span>in</span><span> pre_transform_seq:</span></p></div><div><p><span><span>                    </span></span><span>user_data_transformed </span><span>=</span><span> pre_transform(user_data_transformed)</span></p></div><div></div><div><p><span><span>                </span></span><span>ecc </span><span>=</span><span> bch.encode(user_data_transformed)</span></p></div><div></div><div><p><span>                </span><span># try all combinations of post-transformations</span></p></div><div><p><span>                </span><span>for</span><span> post_transform_seq </span><span>in</span><span> all_transformation_sequences():</span></p></div><div><p><span><span>                    </span></span><span>ecc_transformed </span><span>=</span><span> ecc</span></p></div><div><p><span>                    </span><span>for</span><span> post_transform </span><span>in</span><span> post_transform_seq:</span></p></div><div><p><span><span>                        </span></span><span>ecc_transformed </span><span>=</span><span> post_transform(ecc_transformed)</span></p></div><div></div><div><p><span>                    </span><span>if</span><span> ecc_transformed </span><span>==</span><span> known_ecc:</span></p></div><div><p><span>                        </span><span>print</span><span>(</span><span>f</span><span>&#34;========== ECC parameters found!&#34;</span><span>)</span></p></div><div><p><span>                        </span><span>print</span><span>(</span><span>f</span><span>&#34;- prim_poly = </span><span>{</span><span>prim_poly</span><span>}</span><span>&#34;</span><span>)</span></p></div><div><p><span>                        </span><span>print</span><span>(</span><span>f</span><span>&#34;- pre_transform_seq = </span><span>{</span><span>pre_transform_seq</span><span>}</span><span>&#34;</span><span>)</span></p></div><div><p><span>                        </span><span>print</span><span>(</span><span>f</span><span>&#34;- post_transform_seq = </span><span>{</span><span>post_transform_seq</span><span>}</span><span>&#34;</span><span>)</span></p></div><div><p><span><span>                        </span></span><span>t1 </span><span>=</span><span> datetime.datetime.now()</span></p></div><div><p><span>                        </span><span>print</span><span>(</span><span>f</span><span>&#34;- time to brute force: </span><span>{</span><span>t1 </span><span>-</span><span> t0</span><span>}</span><span>&#34;</span><span>)</span></p></div><div><p><span>                        </span><span>return</span></p></div><div></div><div></div><div><p><span>if</span><span> </span><span>__name__</span><span> </span><span>==</span><span> </span><span>&#34;__main__&#34;</span><span>:</span></p></div><div><p><span><span>    </span></span><span>main()</span></p></div></code></pre></figure></div>
<h3 id="primitive-binary-polynomial-generator">Primitive Binary Polynomial Generator<a aria-hidden="true" tabindex="-1" href="#primitive-binary-polynomial-generator"><span>¶</span></a></h3>
<div><figure><pre data-language="python"><code><div><p><span>def</span><span> </span><span>prime_factorization</span><span>(n):</span></p></div><div><p><span><span>    </span></span><span>fac </span><span>=</span><span> []</span></p></div><div><p><span><span>    </span></span><span>p </span><span>=</span><span> </span><span>2</span></p></div><div><p><span>    </span><span>while</span><span> p </span><span>*</span><span> p </span><span>&lt;=</span><span> n:</span></p></div><div><p><span>        </span><span>if</span><span> n </span><span>%</span><span> p </span><span>==</span><span> </span><span>0</span><span>:</span></p></div><div><p><span><span>            </span></span><span>fac.append(p)</span></p></div><div><p><span>            </span><span>while</span><span> n </span><span>%</span><span> p </span><span>==</span><span> </span><span>0</span><span>:</span></p></div><div><p><span><span>                </span></span><span>n </span><span>//=</span><span> p</span></p></div><div><p><span><span>        </span></span><span>p </span><span>+=</span><span> </span><span>1</span></p></div><div><p><span>    </span><span>if</span><span> n </span><span>&gt;</span><span> </span><span>1</span><span>:</span></p></div><div><p><span><span>        </span></span><span>fac.append(n)</span></p></div><div><p><span>    </span><span>return</span><span> fac</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>poly_mod</span><span>(a, mod):</span></p></div><div><p><span><span>    </span></span><span>d_a </span><span>=</span><span> a.bit_length() </span><span>-</span><span> </span><span>1</span></p></div><div><p><span><span>    </span></span><span>d_m </span><span>=</span><span> mod.bit_length() </span><span>-</span><span> </span><span>1</span></p></div><div><p><span>    </span><span>while</span><span> a </span><span>and</span><span> d_a </span><span>&gt;=</span><span> d_m:</span></p></div><div><p><span><span>        </span></span><span>a </span><span>^=</span><span> mod </span><span>&lt;&lt;</span><span> (d_a </span><span>-</span><span> d_m)</span></p></div><div><p><span><span>        </span></span><span>d_a </span><span>=</span><span> a.bit_length() </span><span>-</span><span> </span><span>1</span></p></div><div><p><span>    </span><span>return</span><span> a</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>poly_mul</span><span>(a, b):</span></p></div><div><p><span><span>    </span></span><span>result </span><span>=</span><span> </span><span>0</span></p></div><div><p><span>    </span><span>while</span><span> b:</span></p></div><div><p><span>        </span><span>if</span><span> b </span><span>&amp;</span><span> </span><span>1</span><span>:</span></p></div><div><p><span><span>            </span></span><span>result </span><span>^=</span><span> a</span></p></div><div><p><span><span>        </span></span><span>b </span><span>&gt;&gt;=</span><span> </span><span>1</span></p></div><div><p><span><span>        </span></span><span>a </span><span>&lt;&lt;=</span><span> </span><span>1</span></p></div><div><p><span>    </span><span>return</span><span> result</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>poly_gcd</span><span>(a, b):</span></p></div><div><p><span>    </span><span>while</span><span> b:</span></p></div><div><p><span><span>        </span></span><span>a, b </span><span>=</span><span> b, poly_mod(a, b)</span></p></div><div><p><span>    </span><span>return</span><span> a</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>poly_pow_mod</span><span>(x, e, mod):</span></p></div><div><p><span><span>    </span></span><span>res </span><span>=</span><span> </span><span>1</span></p></div><div><p><span>    </span><span>while</span><span> e:</span></p></div><div><p><span>        </span><span>if</span><span> e </span><span>&amp;</span><span> </span><span>1</span><span>:</span></p></div><div><p><span><span>            </span></span><span>res </span><span>=</span><span> poly_mod(poly_mul(res, x), mod)</span></p></div><div><p><span><span>        </span></span><span>x </span><span>=</span><span> poly_mod(poly_mul(x, x), mod)</span></p></div><div><p><span><span>        </span></span><span>e </span><span>&gt;&gt;=</span><span> </span><span>1</span></p></div><div><p><span>    </span><span>return</span><span> res</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>is_reducible</span><span>(fx):</span></p></div><div><p><span><span>    </span></span><span>degree </span><span>=</span><span> fx.bit_length() </span><span>-</span><span> </span><span>1</span></p></div><div><p><span><span>    </span></span><span>x </span><span>=</span><span> </span><span>2</span></p></div><div><p><span><span>    </span></span><span>y </span><span>=</span><span> x</span></p></div><div><p><span>    </span><span>for</span><span> _ </span><span>in</span><span> </span><span>range</span><span>(degree </span><span>//</span><span> </span><span>2</span><span> </span><span>+</span><span> </span><span>1</span><span>):</span></p></div><div><p><span><span>        </span></span><span>y </span><span>=</span><span> poly_mod(poly_mul(y, y), fx)</span></p></div><div><p><span><span>        </span></span><span>y_minus_x </span><span>=</span><span> y </span><span>^</span><span> x</span></p></div><div><p><span>        </span><span>if</span><span> poly_gcd(y_minus_x, fx) </span><span>!=</span><span> </span><span>1</span><span>:</span></p></div><div><p><span>            </span><span>return</span><span> </span><span>False</span></p></div><div></div><div><p><span>    </span><span>for</span><span> _ </span><span>in</span><span> </span><span>range</span><span>(degree </span><span>//</span><span> </span><span>2</span><span> </span><span>+</span><span> </span><span>1</span><span>, degree):</span></p></div><div><p><span><span>        </span></span><span>y </span><span>=</span><span> poly_mod(poly_mul(y, y), fx)</span></p></div><div><p><span>    </span><span>return</span><span> y </span><span>==</span><span> x</span></p></div><div></div><div></div><div><p><span>def</span><span> </span><span>primitive_binary_polynomials</span><span>(degree):</span></p></div><div><p><span><span>    </span></span><span>n </span><span>=</span><span> </span><span>2</span><span>**</span><span>degree </span><span>-</span><span> </span><span>1</span></p></div><div><p><span><span>    </span></span><span>prime_factors </span><span>=</span><span> </span><span>set</span><span>(prime_factorization(n))</span></p></div><div><p><span><span>    </span></span><span>x </span><span>=</span><span> </span><span>2</span></p></div><div></div><div><p><span>    </span><span>for</span><span> fx </span><span>in</span><span> </span><span>range</span><span>(</span><span>2</span><span>**</span><span>degree </span><span>+</span><span> </span><span>1</span><span>, </span><span>2</span><span> </span><span>**</span><span> (degree </span><span>+</span><span> </span><span>1</span><span>), </span><span>2</span><span>):</span></p></div><div><p><span>        </span><span># check irreducible</span></p></div><div><p><span>        </span><span>if</span><span> </span><span>not</span><span> is_reducible(fx):</span></p></div><div><p><span>            </span><span>continue</span></p></div><div></div><div><p><span>        </span><span># check primitive</span></p></div><div><p><span>        </span><span>for</span><span> q </span><span>in</span><span> prime_factors:</span></p></div><div><p><span>            </span><span>if</span><span> poly_pow_mod(x, n </span><span>//</span><span> q, fx) </span><span>==</span><span> </span><span>1</span><span>:</span></p></div><div><p><span>                </span><span>break</span></p></div><div><p><span>        </span><span>else</span><span>:</span></p></div><div><p><span>            </span><span>yield</span><span> fx</span></p></div><div></div><div></div><div><p><span>if</span><span> </span><span>__name__</span><span> </span><span>==</span><span> </span><span>&#34;__main__&#34;</span><span>:</span></p></div><div><p><span><span>    </span></span><span>m </span><span>=</span><span> </span><span>14</span></p></div><div><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;All primitive polynomials of degree </span><span>{</span><span>m</span><span>}</span><span>:&#34;</span><span>)</span></p></div><div></div><div><p><span><span>    </span></span><span>i </span><span>=</span><span> </span><span>0</span></p></div><div><p><span>    </span><span>for</span><span> px </span><span>in</span><span> primitive_binary_polynomials(m):</span></p></div><div><p><span><span>        </span></span><span>i </span><span>+=</span><span> </span><span>1</span></p></div><div><p><span>        </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>px</span><span>}</span><span> = </span><span>{bin</span><span>(px)</span><span>}</span><span>&#34;</span><span>)</span></p></div><div></div><div><p><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;Total primitive polynomials of degree </span><span>{</span><span>m</span><span>}</span><span>: </span><span>{</span><span>i</span><span>}</span><span>&#34;</span><span>)</span></p></div></code></pre></figure></div>
<h3 id="fun-fuckups">Fun Fuckups<a aria-hidden="true" tabindex="-1" href="#fun-fuckups"><span>¶</span></a></h3>
<center><figure>
						<img src="https://exclav.es/blog/drone_hacking_part_1/fuckup-01.png" alt="Forgot to order a battery, had to power with a lab supply…"/>
						<figcaption>
							<p>
								Forgot to order a battery, had to power with a lab supply…
							</p>
						</figcaption>
					</figure>
					</center>
<h2 id="a-brief-detour-into-polynomial-algebra">A brief detour into polynomial algebra<a aria-hidden="true" tabindex="-1" href="#a-brief-detour-into-polynomial-algebra"><span>¶</span></a></h2>
<p>If you are like me and you’re not really familiar with polynomial algebra, it makes sense to talk about related concepts in the integer world first and then move on to their counterparts in the polynomial world. This helps to get an intuition of what we are actually dealing with.</p>
<p>I assume that you are generally familiar with modular arithmetic and prime numbers.</p>
<h3 id="integers-and-modulo-rings">Integers and Modulo Rings<a aria-hidden="true" tabindex="-1" href="#integers-and-modulo-rings"><span>¶</span></a></h3>
<p>For now, we are working on the field of integers, i.e., <span><span aria-hidden="true"><span><span></span><span>{</span><span>...</span><span>,</span><span></span><span>−</span><span>2</span><span>,</span><span></span><span>−</span><span>1</span><span>,</span><span></span><span>0</span><span>,</span><span></span><span>1</span><span>,</span><span></span><span>2</span><span>,</span><span></span><span>...</span><span>}</span></span></span></span>, mathematically denoted <span><span aria-hidden="true"><span><span></span><span>Z</span></span></span></span>.</p>
<p>When we introduce a modulus, we get <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>n</span><span>Z</span></span></span></span>. Explanation for the notation:</p>
<p><span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span> is some modulus. Not necessary prime at this point. Just an integer - a member of <span><span aria-hidden="true"><span><span></span><span>Z</span></span></span></span>.</p>
<p><span><span aria-hidden="true"><span><span></span><span>n</span><span>Z</span></span></span></span> is all multiples of <span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span>. So <span><span aria-hidden="true"><span><span></span><span>{</span><span>...</span><span>,</span><span></span><span>−</span><span>2</span><span>n</span><span>,</span><span></span><span>−</span><span>1</span><span>n</span><span>,</span><span></span><span>0</span><span>,</span><span></span><span>n</span><span>,</span><span></span><span>2</span><span>n</span><span>,</span><span></span><span>...</span><span>}</span></span></span></span>.
If <span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span> were <span><span aria-hidden="true"><span><span></span><span>7</span></span></span></span>, this would be <span><span aria-hidden="true"><span><span></span><span>{</span><span>...</span><span>,</span><span></span><span>−</span><span>14</span><span>,</span><span></span><span>−</span><span>7</span><span>,</span><span></span><span>0</span><span>,</span><span></span><span>7</span><span>,</span><span></span><span>14</span><span>,</span><span></span><span>...</span><span>}</span></span></span></span>.</p>
<p>Now <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>n</span><span>Z</span></span></span></span> means:
The field <span><span aria-hidden="true"><span><span></span><span>Z</span></span></span></span> but treat all elements as equivalent if they are a multiple of <span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span> apart - meaning their difference is in <span><span aria-hidden="true"><span><span></span><span>n</span><span>Z</span></span></span></span>.
If <span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span> were <span><span aria-hidden="true"><span><span></span><span>7</span></span></span></span>, then <span><span aria-hidden="true"><span><span></span><span>2</span></span></span></span> and <span><span aria-hidden="true"><span><span></span><span>16</span></span></span></span> would be equivalent, because their difference is <span><span aria-hidden="true"><span><span></span><span>14</span></span></span></span>, which is a multiple of <span><span aria-hidden="true"><span><span></span><span>7</span></span></span></span> and thus in <span><span aria-hidden="true"><span><span></span><span>7</span><span>Z</span></span></span></span>.</p>
<p>This is exactly what “mod 7” is: <span><span aria-hidden="true"><span><span></span><span>16</span><span></span><span>=</span><span></span></span><span><span></span><span>2</span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>7</span></span></span></span></span></p>
<p>So <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>n</span><span>Z</span></span></span></span> is just all of <span><span aria-hidden="true"><span><span></span><span>Z</span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>n</span></span></span></span></span>.</p>
<p>Note that this collapses the infinite field of all possible integers <span><span aria-hidden="true"><span><span></span><span>Z</span></span></span></span> down to a finite set of equivalence classes. In <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/7</span><span>Z</span></span></span></span>, all numbers are either in <span><span aria-hidden="true"><span><span></span><span>{</span><span>0</span><span>,</span><span></span><span>1</span><span>,</span><span></span><span>2</span><span>,</span><span></span><span>3</span><span>,</span><span></span><span>4</span><span>,</span><span></span><span>5</span><span>,</span><span></span><span>6</span><span>}</span></span></span></span> or are equivalents of one of those. So for practical purposes, there are only <span><span aria-hidden="true"><span><span></span><span>7</span></span></span></span> possible values in <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/7</span><span>Z</span></span></span></span>.</p>
<p>What do we need primes for?
Well, <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>n</span><span>Z</span></span></span></span> has a practical problem: Sometimes multiplying two things results in a zero. Example for <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/8</span><span>Z</span></span></span></span>:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>4  * 2 = 0 mod 8</span></p></div><div><p><span>8  * 2 = 0 mod 8</span></p></div><div><p><span>12 * 2 = 0 mod 8</span></p></div></code></pre></figure></div>
<p>That is bad if we want to do a lot of multiplication within our modulo ring. Because if we ever accidentally hit a multiple of <span><span aria-hidden="true"><span><span></span><span>8</span></span></span></span>, we will get <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span> and that point it doesn’t matter what we multiply onto that - it will stay <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span>. So there are a lot of possible values that all collapse into the same <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span> when multiplied with certain numbers.</p>
<p>In the field of all integers, <span><span aria-hidden="true"><span><span></span><span>Z</span></span></span></span>, we don’t have that problem. As long as we don’t multiply with <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span> itself, the results of a multiplication will never be <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span>. Good thing there is a solution for that: Using a <strong>prime modulus</strong>.</p>
<h3 id="prime-numbers-finite-fields-and-cycles">Prime Numbers, Finite Fields, and Cycles<a aria-hidden="true" tabindex="-1" href="#prime-numbers-finite-fields-and-cycles"><span>¶</span></a></h3>
<p>Prime numbers <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> have the nice feature that the modulo rings they induce, <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>p</span><span>Z</span></span></span></span>, are <em>fields</em> and not just <em>rings</em>, meaning addition and multiplication work just as well as they do in <span><span aria-hidden="true"><span><span></span><span>Z</span></span></span></span>. In <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>p</span><span>Z</span></span></span></span>, multiplying by something other than <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span> will <em>never</em> result in a multiple of <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> - because <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> is prime and you can’t reach a prime from another number through multiplication. (Multiplying by <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> itself doesn’t count, because <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>=</span><span></span></span><span><span></span><span>0</span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>p</span></span></span></span></span>.)</p>
<p>Because <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>p</span><span>Z</span></span></span></span> is a <em>field</em> and it has a finite amount of elements <span><span aria-hidden="true"><span><span></span><span>{</span><span>0</span><span>,</span><span></span><span>1</span><span>,</span><span></span><span>2</span><span>,</span><span></span><span>...</span><span>,</span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span><span>}</span></span></span></span>, it is called a “finite field” or a “Galois field” and sometimes denoted <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>p</span><span>)</span></span></span></span> instead of <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>p</span><span>Z</span></span></span></span>. To be super precise, <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>p</span><span>)</span></span></span></span> is a generalization and means “any finite field with <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> elements”. <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>p</span><span>Z</span></span></span></span> just happens to be one of those - and is the most popular one.</p>
<p>Now we go a step further and look at a concept called <strong>primitive root</strong>. Before explaining that, let’s take a look at a use case for them first.</p>
<p>Imagine you want a pseudorandom permutation of <span><span aria-hidden="true"><span><span></span><span>{</span><span>0</span><span>,</span><span></span><span>1</span><span>,</span><span></span><span>2</span><span>,</span><span></span><span>3</span><span>,</span><span></span><span>4</span><span>,</span><span></span><span>5</span><span>,</span><span></span><span>6</span><span>}</span></span></span></span>, i.e., you don’t want the sequence <span><span aria-hidden="true"><span><span></span><span>0</span><span>,</span><span></span><span>1</span><span>,</span><span></span><span>2</span><span>,</span><span></span><span>3</span><span>,</span><span></span><span>4</span><span>,</span><span></span><span>5</span><span>,</span><span></span><span>6</span></span></span></span> but a more random-looking sequence tha still hits all of these numbers. It doesn’t have to be cryptographically random or unpredictable. It just needs to look at bit random - perhaps to de-cluster memory writes for better wear-leveling. Primitive roots give us a nice implementation for that.</p>
<p>In <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>p</span><span>Z</span></span></span></span>, multiplication never yields <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span> unless you multiply by <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span>. That means you can, e.g., keep doubling a number and will never accidentally hit <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span>:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>1       = 1 mod 7</span></p></div><div><p><span>1 * 2   = 2 mod 7</span></p></div><div><p><span>1 * 2^2 = 4 mod 7</span></p></div><div></div><div><p><span>1 * 2^3 = 1 mod 7</span></p></div><div><p><span>1 * 2^4 = 2 mod 7</span></p></div><div><p><span>1 * 2^5 = 4 mod 7</span></p></div><div></div><div><p><span>1 * 2^6 = 1 mod 7</span></p></div><div><p><span>...</span></p></div></code></pre></figure></div>
<p>Oh look at that, a <em>cycle</em>! This is what will <em>always</em> happen in a finite field. When you keep multiplying by the same number, you will eventually reach the number you started with. And at that point, you are in a cycle.</p>
<p><span><span aria-hidden="true"><span><span></span><span>2</span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>7</span></span></span></span></span> is a bit impractical though because its induced cycle only ever hits the numbers <span><span aria-hidden="true"><span><span></span><span>{</span><span>1</span><span>,</span><span></span><span>2</span><span>,</span><span></span><span>4</span><span>}</span></span></span></span> and never hits <span><span aria-hidden="true"><span><span></span><span>{</span><span>3</span><span>,</span><span></span><span>5</span><span>,</span><span></span><span>6</span><span>}</span></span></span></span>. Note that <em>no</em> cycle will ever hit <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span>, so the maximum cycle we can possible get with a modulus of <span><span aria-hidden="true"><span><span></span><span>7</span></span></span></span> is cycle length <span><span aria-hidden="true"><span><span></span><span>6</span></span></span></span>.</p>
<h3 id="primitive-roots-and-prime-factors">Primitive Roots and Prime Factors<a aria-hidden="true" tabindex="-1" href="#primitive-roots-and-prime-factors"><span>¶</span></a></h3>
<p>And there are indeed numbers that generate a full cycle!</p>
<div><figure><pre data-language="plaintext"><code><div><p><span># 3</span></p></div><div><p><span>1 * 3^0 = 1 mod 7</span></p></div><div><p><span>1 * 3^1 = 3 mod 7</span></p></div><div><p><span>1 * 3^2 = 2 mod 7</span></p></div><div><p><span>1 * 3^3 = 6 mod 7</span></p></div><div><p><span>1 * 3^4 = 4 mod 7</span></p></div><div><p><span>1 * 3^5 = 5 mod 7</span></p></div><div></div><div><p><span>1 * 3^6 = 1 mod 7</span></p></div><div><p><span>1 * 3^7 = 3 mod 7</span></p></div><div><p><span>...</span></p></div><div></div><div><p><span># 5</span></p></div><div><p><span>1 * 5^0 = 1 mod 7</span></p></div><div><p><span>1 * 5^1 = 5 mod 7</span></p></div><div><p><span>1 * 5^2 = 4 mod 7</span></p></div><div><p><span>1 * 5^3 = 6 mod 7</span></p></div><div><p><span>1 * 5^4 = 2 mod 7</span></p></div><div><p><span>1 * 5^5 = 3 mod 7</span></p></div><div></div><div><p><span>1 * 5^6 = 1 mod 7</span></p></div><div><p><span>1 * 5^7 = 5 mod 7</span></p></div><div><p><span>...</span></p></div></code></pre></figure></div>
<p>These numbers, numbers that induce a full cycle in a finite field, are called <em>primitive roots</em>. <span><span aria-hidden="true"><span><span></span><span>3</span></span></span></span> and <span><span aria-hidden="true"><span><span></span><span>5</span></span></span></span> are each primitive roots modulo <span><span aria-hidden="true"><span><span></span><span>7</span></span></span></span>. Since their induced cycle has a length of <span><span aria-hidden="true"><span><span></span><span>6</span></span></span></span>, the so-called <em>order</em> of <span><span aria-hidden="true"><span><span></span><span>3</span></span></span></span> and <span><span aria-hidden="true"><span><span></span><span>5</span></span></span></span> is <span><span aria-hidden="true"><span><span></span><span>6</span></span></span></span>.</p>
<p>More generally, a primitive root <span><span aria-hidden="true"><span><span></span><span>g</span></span></span></span> modulo some prime <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> is a number whose order is <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span>, i.e., whose induced cycle has a length of <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span>. In that case <span><span aria-hidden="true"><span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span><span>p</span><span>−</span><span>1</span></span></span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>1</span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>p</span></span></span></span></span>. Expressed more formally: <span><span aria-hidden="true"><span><span></span><span>g</span></span></span></span> is a primitive root modulo <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> if and only if the <em>smallest</em> <span><span aria-hidden="true"><span><span></span><span>k</span><span></span><span>&gt;</span><span></span></span><span><span></span><span>0</span></span></span></span> for which <span><span aria-hidden="true"><span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span>k</span></span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>1</span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>p</span></span></span></span></span> is true, is <span><span aria-hidden="true"><span><span></span><span>k</span><span></span><span>=</span><span></span></span><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span></p>
<p>Now then how would you best check if a number <span><span aria-hidden="true"><span><span></span><span>g</span></span></span></span> is a primitive root modulo <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span>? The obvious solution is to just count <span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> upwards from 1 through <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>2</span></span></span></span> and check <span><span aria-hidden="true"><span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span>k</span></span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>1</span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>p</span></span></span></span></span> each time. That <em>works</em> but it can take a long time for big numbers. Turns out, we don’t have to check every possible <span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> from <span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span> through <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>2</span></span></span></span>. To understand that, take a look at <span><span aria-hidden="true"><span><span></span><span>g</span><span></span><span>=</span><span></span></span><span><span></span><span>2</span></span></span></span> from before:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>1       = 1 mod 7</span></p></div><div><p><span>1 * 2   = 2 mod 7</span></p></div><div><p><span>1 * 2^2 = 4 mod 7</span></p></div><div><p><span>...repeat</span></p></div></code></pre></figure></div>
<p>We can see that the cycle has length <span><span aria-hidden="true"><span><span></span><span>3</span></span></span></span> and contains the numbers <span><span aria-hidden="true"><span><span></span><span>{</span><span>1</span><span>,</span><span></span><span>2</span><span>,</span><span></span><span>4</span><span>}</span></span></span></span>. We <em>don’t</em> see the numbers <span><span aria-hidden="true"><span><span></span><span>{</span><span>3</span><span>,</span><span></span><span>5</span><span>,</span><span></span><span>6</span><span>}</span></span></span></span>. But what happens when we use <span><span aria-hidden="true"><span><span></span><span>g</span><span></span><span>=</span><span></span></span><span><span></span><span>2</span></span></span></span> but we <em>start</em> at <span><span aria-hidden="true"><span><span></span><span>3</span></span></span></span>?</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>3       = 3 mod 7</span></p></div><div><p><span>3 * 2^1 = 6 mod 7</span></p></div><div><p><span>3 * 2^2 = 5 mod 7</span></p></div><div><p><span>...repeat</span></p></div></code></pre></figure></div>
<p>Again, a cycle of <span><span aria-hidden="true"><span><span></span><span>3</span></span></span></span>! And this time we’ve seen all the remaining numbers <span><span aria-hidden="true"><span><span></span><span>{</span><span>3</span><span>,</span><span></span><span>5</span><span>,</span><span></span><span>6</span><span>}</span></span></span></span>. If we instead start at <span><span aria-hidden="true"><span><span></span><span>5</span></span></span></span> or <span><span aria-hidden="true"><span><span></span><span>6</span></span></span></span>, we will get the same cycle over <span><span aria-hidden="true"><span><span></span><span>{</span><span>3</span><span>,</span><span></span><span>5</span><span>,</span><span></span><span>6</span><span>}</span></span></span></span>. So <span><span aria-hidden="true"><span><span></span><span>g</span><span></span><span>=</span><span></span></span><span><span></span><span>2</span></span></span></span> splits the entire finite field excluding 0 into two subsets: <span><span aria-hidden="true"><span><span></span><span>{</span><span>1</span><span>,</span><span></span><span>2</span><span>,</span><span></span><span>4</span><span>}</span></span></span></span> and <span><span aria-hidden="true"><span><span></span><span>{</span><span>3</span><span>,</span><span></span><span>5</span><span>,</span><span></span><span>6</span><span>}</span></span></span></span>.</p>
<p>Let’s look at another example: <span><span aria-hidden="true"><span><span></span><span>g</span><span></span><span>=</span><span></span></span><span><span></span><span>6</span></span></span></span> and try to find all cycles.</p>
<div><figure><pre data-language="plaintext"><code><div><p><span># start at 1</span></p></div><div><p><span>1 * 6^0 = 1 mod 7</span></p></div><div><p><span>1 * 6^1 = 6 mod 7</span></p></div><div><p><span>...repeat</span></p></div><div></div><div><p><span># start at 2</span></p></div><div><p><span>2 * 6^0 = 2 mod 7</span></p></div><div><p><span>2 * 6^1 = 5 mod 7</span></p></div><div><p><span>...repeat</span></p></div><div></div><div><p><span># start at 3</span></p></div><div><p><span>3 * 6^0 = 3 mod 7</span></p></div><div><p><span>3 * 6^1 = 4 mod 7</span></p></div><div><p><span>...repeat</span></p></div></code></pre></figure></div>
<p>So <span><span aria-hidden="true"><span><span></span><span>g</span><span></span><span>=</span><span></span></span><span><span></span><span>6</span></span></span></span> partitions the non-zero elements into <span><span aria-hidden="true"><span><span></span><span>{</span><span>1</span><span>,</span><span></span><span>6</span><span>}</span><span>,</span><span></span><span>{</span><span>2</span><span>,</span><span></span><span>5</span><span>}</span><span>,</span><span></span><span>{</span><span>3</span><span>,</span><span></span><span>4</span><span>}</span></span></span></span>`.</p>
<p>Notice how all those cycles induced by the same number always have the same size? If you think about it, then that makes perfect sense. When you have <span><span aria-hidden="true"><span><span></span><span>g</span><span></span><span>=</span><span></span></span><span><span></span><span>6</span></span></span></span> but you “start at <span><span aria-hidden="true"><span><span></span><span>3</span></span></span></span>”, you’re basically just taking the regular <span><span aria-hidden="true"><span><span></span><span>{</span><span>1</span><span>,</span><span></span><span>6</span><span>}</span></span></span></span> cycle and multiply its elements by <span><span aria-hidden="true"><span><span></span><span>3</span></span></span></span>. So the resulting cycle must have the same length: <span><span aria-hidden="true"><span><span></span><span>2</span></span></span></span>.</p>
<p>And this isn’t a coincidence. In fact, all cycles induced by the same number <em>always</em> have the same length. And that number always partitions the entire finite field without <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span> into disjoint sets of the same size.</p>
<p>How does that help us? Well, for <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>=</span><span></span></span><span><span></span><span>7</span></span></span></span> it makes the cycle lengths <span><span aria-hidden="true"><span><span></span><span>4</span></span></span></span> and <span><span aria-hidden="true"><span><span></span><span>5</span></span></span></span> impossible! Because you can’t cover all <span><span aria-hidden="true"><span><span></span><span>6</span></span></span></span> non-zero elements <span><span aria-hidden="true"><span><span></span><span>{</span><span>1</span><span>,</span><span></span><span>2</span><span>,</span><span></span><span>3</span><span>,</span><span></span><span>4</span><span>,</span><span></span><span>5</span><span>,</span><span></span><span>6</span><span>}</span></span></span></span> by splitting them into sets of size <span><span aria-hidden="true"><span><span></span><span>4</span></span></span></span> or <span><span aria-hidden="true"><span><span></span><span>5</span></span></span></span>. More generally, cycles lengths (and thus orders) must always be a divisor of <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span>, i.e., the amount of all non-zero elements.</p>
<p>This is called <a href="https://en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory)">Lagrange’s theorem</a>: The order of the subgroup divides the order of the whole group.</p>
<p>So to check if <span><span aria-hidden="true"><span><span></span><span>g</span></span></span></span> is a primitive root, we don’t have to check all <span><span aria-hidden="true"><span><span></span><span>k</span></span></span></span> from <span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span> through <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>2</span></span></span></span>. We only have to check all divisors of <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span>! Also, we obviously don’t have to check <span><span aria-hidden="true"><span><span></span><span>k</span><span></span><span>=</span><span></span></span><span><span></span><span>1</span></span></span></span>. The only number for which <span><span aria-hidden="true"><span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>1</span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>p</span></span></span></span></span> is <span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span> itself, which <em>always</em> induces a cycle of <span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span> and is thus never a primitive root for <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>&gt;</span><span></span></span><span><span></span><span>2</span></span></span></span>.</p>
<p>So we’re down to only having to check all divisors of <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span> that are larger than <span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span>. That already eliminates most of the candidates.</p>
<p>But we can go <em>even further</em>!</p>
<h3 id="fast-primitivity-check">Fast Primitivity Check<a aria-hidden="true" tabindex="-1" href="#fast-primitivity-check"><span>¶</span></a></h3>
<p>We only need to check <em>some</em> of the divisors. This is where prime factorization comes into play. Let’s say that we have the prime factors of <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span>. We will call these prime factors <span><span aria-hidden="true"><span><span></span><span>{</span><span><span>q</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span><span>q</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span>...</span><span>}</span></span></span></span>. Note that <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> itself does not have any prime factors because - well - it is a <em>prime number</em>. But <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span> <em>does</em> have prime factors. In fact, <span><span aria-hidden="true"><span><span></span><span>2</span></span></span></span> will always be one of those prime factors because <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>&gt;</span><span></span></span><span><span></span><span>2</span></span></span></span> must be odd to be a prime and <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span> must therefore be even.</p>
<p>Now what if I told you that we only need to check the divisors of <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span> that we can obtain by dividing through a prime factor. Specifically, we only need to check</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>(p-1) / q_1</span></p></div><div><p><span>(p-1) / q_2</span></p></div><div><p><span>...</span></p></div></code></pre></figure></div>
<p>Example:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>p   = 37</span></p></div><div></div><div><p><span>p-1 = 36</span></p></div><div><p><span><span>    </span></span><span>= 2 * 2 * 3 * 3</span></p></div><div></div><div><p><span>set of non-trivial divisors = {2, 3, 4, 6, 9, 12, 18}</span></p></div><div><p><span>set of prime factors        = {2, 3}</span></p></div><div></div><div><p><span>We only have to check</span></p></div><div><p><span><span>  </span></span><span>36 / 2 = 18</span></p></div><div><p><span><span>    </span></span><span>and</span></p></div><div><p><span><span>  </span></span><span>36 / 3 = 12</span></p></div><div></div><div><p><span>We don&#39;t have to check the other divisors</span></p></div><div><p><span>{2, 3, 4, 6, 9}</span></p></div></code></pre></figure></div>
<p>Why is that? Well, first of all, notice that the “other divisors” <span><span aria-hidden="true"><span><span></span><span>{</span><span>2</span><span>,</span><span></span><span>3</span><span>,</span><span></span><span>4</span><span>,</span><span></span><span>6</span><span>,</span><span></span><span>9</span><span>}</span></span></span></span> are themselves divisors of either <span><span aria-hidden="true"><span><span></span><span>12</span></span></span></span> or <span><span aria-hidden="true"><span><span></span><span>18</span></span></span></span>:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>12 = 2 * 6</span></p></div><div><p><span><span>   </span></span><span>= 3 * 4</span></p></div><div><p><span><span>   </span></span><span>= 4 * 3</span></p></div><div><p><span><span>   </span></span><span>= 6 * 2</span></p></div><div></div><div><p><span>18 = 2 * 9</span></p></div><div><p><span><span>   </span></span><span>= 3 * 6</span></p></div><div><p><span><span>   </span></span><span>= 6 * 3</span></p></div><div><p><span><span>   </span></span><span>= 9 * 2</span></p></div></code></pre></figure></div>
<p>And if <span><span aria-hidden="true"><span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span><span>12</span></span></span></span></span></span></span></span></span><span></span><span><span><span><span><span><span></span><span><span><span></span></span></span><span></span></span></span></span></span><span>=</span></span><span></span></span><span><span></span><span>1</span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>37</span></span></span></span></span>, then that implies that</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>g^2 != 1 mod 37</span></p></div><div><p><span>g^3 != 1 mod 37</span></p></div><div><p><span>g^4 != 1 mod 37</span></p></div><div><p><span>g^6 != 1 mod 37</span></p></div></code></pre></figure></div>
<p>and so on.</p>
<p>Why? Well, because <em>if</em> <span><span aria-hidden="true"><span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span>6</span></span></span></span></span></span></span></span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>37</span></span></span></span></span> <em>were</em> equal to one, then</p>
<div><figure><pre data-language="plaintext"><code><div><p><span><span> </span></span><span>g^6    = 1   mod 37</span></p></div><div><p><span>(g^6)^2 = 1^2 mod 37</span></p></div><div><p><span><span> </span></span><span>g^12   = 1   mod 37</span></p></div></code></pre></figure></div>
<p>and that is a contradiction! You can prove the same for any <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> in general if you want. The general proof works just like this example.</p>
<p>Alright, so we only have to check all possible <span><span aria-hidden="true"><span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span><span>(</span><span>p</span><span>−</span><span>1</span><span>)</span><span>/</span><span>q</span></span></span></span></span></span></span></span></span><span></span><span><span><span><span><span><span></span><span><span><span></span></span></span><span></span></span></span></span></span><span>=</span></span><span></span></span><span><span></span><span>1</span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>p</span></span></span></span></span> with <span><span aria-hidden="true"><span><span></span><span>q</span></span></span></span> being a prime factor of <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span>.</p>
<p>Here is a generator function that will return all primitive roots for a given prime modulus <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span>:</p>
<div><figure><pre data-language="python"><code><div><p><span>def</span><span> </span><span>primitive_roots</span><span>(p):</span></p></div><div><p><span><span>    </span></span><span>N </span><span>=</span><span> p </span><span>-</span><span> </span><span>1</span></p></div><div><p><span><span>    </span></span><span>prime_factors </span><span>=</span><span> </span><span>set</span><span>(prime_factorization(N))</span></p></div><div></div><div><p><span>    </span><span>for</span><span> g </span><span>in</span><span> </span><span>range</span><span>(</span><span>2</span><span>, N </span><span>+</span><span> </span><span>1</span><span>):</span></p></div><div><p><span>        </span><span>for</span><span> q </span><span>in</span><span> prime_factors:</span></p></div><div><p><span>            </span><span>if</span><span> </span><span>pow</span><span>(g, N </span><span>//</span><span> q, p) </span><span>==</span><span> </span><span>1</span><span>:</span></p></div><div><p><span>                </span><span>break</span></p></div><div><p><span>        </span><span>else</span><span>:</span></p></div><div><p><span>            </span><span>yield</span><span> g</span></p></div></code></pre></figure></div>
<p>And you know what? Armed with this, we can not just find <strong>primitive roots</strong> but also <strong>primitive polynomials</strong>! We <em>just</em> need to translate this concept to polynomials!</p>
<p>… which is a bit tricky.</p>
<h3 id="binary-polynomials-irreducibility-and-primitive-elements">Binary Polynomials, Irreducibility and Primitive Elements<a aria-hidden="true" tabindex="-1" href="#binary-polynomials-irreducibility-and-primitive-elements"><span>¶</span></a></h3>
<p>Alright, first things first: Polynomials. They can look something like this:</p>
<p><span><span aria-hidden="true"><span><span></span><span>f</span><span>(</span><span>x</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span>14</span><span><span>x</span><span><span><span><span><span><span></span><span><span>4</span></span></span></span></span></span></span></span><span></span><span>+</span><span></span></span><span><span></span><span>2</span><span><span>x</span><span><span><span><span><span><span></span><span><span>3</span></span></span></span></span></span></span></span><span></span><span>+</span><span></span></span><span><span></span><span>0</span><span><span>x</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span><span></span><span>+</span><span></span></span><span><span></span><span>53</span><span>x</span><span></span><span>+</span><span></span></span><span><span></span><span>42</span></span></span></span></p>
<p>And through the black magic of math, we can treat these polynomials as multidimensional numbers:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>Polynomial:   f(x) = 14x^4 + 2x^3 + 0x^2 + 53x + 42</span></p></div><div><p><span>Coefficients:       [14,     2,     0,     53,   42]</span></p></div></code></pre></figure></div>
<p>And on these, we can perform the same kind of arithmetic as on integers: Addition, Multiplication, Subtraction, Division - and thus Modulo. Dividing one polynomial by another sounds odd? It is. We’ll skip the details here since we’ve already derailed enough. Just know that the intuition from integer arithmetic carries over to polynomials.</p>
<p>Now keep in mind that we are working with <em>binary</em> polynomials, i.e., polynomials whose coefficients are either <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span> or <span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span>. And we can represent those as integers. For example, <span><span aria-hidden="true"><span><span></span><span>51</span></span></span></span> represents the polynomial</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>Polynomial:             f(x) = 1x^5 + 1x^4 + 0x^3 + 0x^2 + 1x + 1</span></p></div><div><p><span>Binary coefficients:           1      1      0      0      1    1</span></p></div><div><p><span>Decimal representation:        51</span></p></div></code></pre></figure></div>
<p>We use these binary polynomials because they have a numbers of nice properties that things like BCH error correction codes rely on. For example, we can represent all binary strings of length <span><span aria-hidden="true"><span><span></span><span>K</span></span></span></span> as a <span><span aria-hidden="true"><span><span></span><span>K</span></span></span></span>-degree polynomial with binary coefficients. For integers, we’d represent those strings as integers from <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span> to <span><span aria-hidden="true"><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span>K</span></span></span></span></span></span></span></span></span></span></span>. But we would have problems doing modular arithmetic on those strings because <span><span aria-hidden="true"><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span>K</span></span></span></span></span></span></span></span></span></span></span> isn’t necessarily prime and then <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span><span>2</span><span><span><span><span><span><span></span><span><span>K</span></span></span></span></span></span></span></span><span>Z</span></span></span></span> isn’t a field. For polynomials, there are nice and efficient ways to build a field over <span><span aria-hidden="true"><span><span></span><span>K</span></span></span></span>-degree binary polynomials.</p>
<p>Throughout this section we have to keep in mind that the integer representation (<span><span aria-hidden="true"><span><span></span><span>51</span></span></span></span> in the example above) is just a <em>representation of the polynomial in memory</em>. The polynomial is <em>not</em> an integer and we can’t just do regular <em>integer</em> arithmetic like addition and multiplication with Python’s <code>+</code> and <code>*</code> with it. Polynomials have their own arithmetic and they work differently.</p>
<p>Since we are dealing with binary polynomials, the coefficients of the polynomials are all either <span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span> or <span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span>. More formally, the coefficients are elements of <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span></span></span></span>, which is basically the same as <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/2</span><span>Z</span></span></span></span> or “mod 2”.</p>
<p>The set of all binary polynomials is called <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span><span>[</span><span>x</span><span>]</span></span></span></span>. In CompSci terms, these are all possible bit arrays.</p>
<p>So since we’re moving from working on integers to working on binary polynomials, <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span><span>[</span><span>x</span><span>]</span></span></span></span> is our binary polynomial-equivalent of <span><span aria-hidden="true"><span><span></span><span>Z</span></span></span></span>, with <span><span aria-hidden="true"><span><span></span><span>Z</span></span></span></span> being all integers and <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span><span>[</span><span>x</span><span>]</span></span></span></span> being all binary polynomials.</p>
<p>While we used <span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span> to represent a single integer in <span><span aria-hidden="true"><span><span></span><span>Z</span></span></span></span>, we will use <span><span aria-hidden="true"><span><span></span><span>f</span><span>(</span><span>x</span><span>)</span></span></span></span> to represent a single polynomial in <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span><span>[</span><span>x</span><span>]</span></span></span></span>.</p>
<p>Similar to how <span><span aria-hidden="true"><span><span></span><span>n</span><span>Z</span></span></span></span> is the set of all multiples of n, <span><span aria-hidden="true"><span><span></span><span>(</span><span>f</span><span>(</span><span>x</span><span>))</span></span></span></span> is the set of all multiples of <span><span aria-hidden="true"><span><span></span><span>f</span><span>(</span><span>x</span><span>)</span></span></span></span> - <em>notice the double-paranthesis</em>.</p>
<p>And similar to how <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>n</span><span>Z</span></span></span></span> is <span><span aria-hidden="true"><span><span></span><span>Z</span></span></span></span> but treating two integers as equivalent if their difference is a multiple of <span><span aria-hidden="true"><span><span></span><span>n</span></span></span></span>, <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span><span>[</span><span>x</span><span>]</span><span>/</span><span>(</span><span>f</span><span>(</span><span>x</span><span>))</span></span></span></span> is <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span><span>[</span><span>x</span><span>]</span></span></span></span> but treating two polynomials as equivalent if their difference is a multiple of <span><span aria-hidden="true"><span><span></span><span>f</span><span>(</span><span>x</span><span>)</span></span></span></span>. It is essentially “mod <span><span aria-hidden="true"><span><span></span><span>f</span><span>(</span><span>x</span><span>)</span></span></span></span>” in polynomial world.</p>
<p>If we have an integer <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> and <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> can’t be divided by another integer, then <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> is <em>prime</em>. Analogously, if we have a polynomial <span><span aria-hidden="true"><span><span></span><span>p</span><span>(</span><span>x</span><span>)</span></span></span></span> and <span><span aria-hidden="true"><span><span></span><span>p</span><span>(</span><span>x</span><span>)</span></span></span></span> can’t be reduced by another polynomial, then <span><span aria-hidden="true"><span><span></span><span>p</span><span>(</span><span>x</span><span>)</span></span></span></span> is <strong>irreducible</strong>.</p>
<p>If <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span> is prime, then there is at least one <em>primitive root</em> <span><span aria-hidden="true"><span><span></span><span>g</span></span></span></span> in <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>p</span><span>Z</span></span></span></span>, so that <span><span aria-hidden="true"><span><span></span><span>{</span><span><span>g</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span>3</span></span></span></span></span></span></span></span><span>,</span><span></span><span>...</span><span>}</span></span></span></span> spans the entire <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>p</span><span>Z</span></span></span></span>. If <span><span aria-hidden="true"><span><span></span><span>p</span><span>(</span><span>x</span><span>)</span></span></span></span> is irreducible, then there is at least one <strong>primitive element</strong> <span><span aria-hidden="true"><span><span></span><span>g</span><span>(</span><span>x</span><span>)</span></span></span></span> in <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span><span>[</span><span>x</span><span>]</span><span>/</span><span>(</span><span>p</span><span>(</span><span>x</span><span>))</span></span></span></span> so that <span><span aria-hidden="true"><span><span></span><span>{</span><span><span>g</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span>3</span></span></span></span></span></span></span></span><span>,</span><span></span><span>...</span><span>}</span></span></span></span> spans the entire <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span><span>[</span><span>x</span><span>]</span><span>/</span><span>(</span><span>p</span><span>(</span><span>x</span><span>))</span></span></span></span>.</p>
<p>(Side note: “primitive root” is a legacy term only used for <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>p</span><span>Z</span></span></span></span>. “primitive element” is the general term. They mean the same thing.)</p>
<p>Also, while the order of <span><span aria-hidden="true"><span><span></span><span>Z</span><span>/</span><span>p</span><span>Z</span></span></span></span> is just <span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span>, the order of <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span><span>[</span><span>x</span><span>]</span><span>/</span><span>(</span><span>p</span><span>(</span><span>x</span><span>))</span></span></span></span> is <span><span aria-hidden="true"><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span><span>d</span><span>e</span><span>g</span><span>ree</span><span>(</span><span>p</span><span>(</span><span>x</span><span>))</span></span></span></span></span></span></span></span></span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span>, which is the amount of all possible <span><span aria-hidden="true"><span><span></span><span>d</span><span>e</span><span>g</span><span>ree</span><span>(</span><span>p</span><span>(</span><span>x</span><span>))</span></span></span></span>-bit arrays.</p>
<p>Now we are almost there! We have already come far enough where we can recognize that an irreducible polynomial <span><span aria-hidden="true"><span><span></span><span>p</span><span>(</span><span>x</span><span>)</span></span></span></span> is analogous to a prime integer <span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span>.</p>
<p>Now, what is a <strong><em>primitive</em> polynomial</strong> then?</p>
<h3 id="primitive-polynomials">Primitive Polynomials<a aria-hidden="true" tabindex="-1" href="#primitive-polynomials"><span>¶</span></a></h3>
<p>Well, that’s simple! A <em>primitive</em> polynomial is an irreducible polynomial with one additional requirement:</p>
<p>The super simple polynomial
<span><span aria-hidden="true"><span><span></span><span>x</span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>p</span><span>(</span><span>x</span><span>)</span></span></span></span></span>
must be a primitive element, i.e., <span><span aria-hidden="true"><span><span></span><span>{</span><span><span>x</span><span><span><span><span><span><span></span><span><span>0</span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>3</span></span></span></span></span></span></span></span><span>,</span><span></span><span>...</span><span>}</span></span></span></span> must span the entire <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span><span>[</span><span>x</span><span>]</span><span>/</span><span>(</span><span>p</span><span>(</span><span>x</span><span>))</span></span></span></span>.</p>
<p>Why is that useful? Well, because that means that every non-zero polynomial in <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span><span>[</span><span>x</span><span>]</span><span>/</span><span>(</span><span>p</span><span>(</span><span>x</span><span>))</span></span></span></span> can be represented as <span><span aria-hidden="true"><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>t</span></span></span></span></span></span></span></span></span></span></span> for some integer <span><span aria-hidden="true"><span><span></span><span>t</span></span></span></span>. So every non-zero polynomial can be represented as an integer and we have a random-looking permutation of all non-zero binary polynomials in <span><span aria-hidden="true"><span><span></span><span>GF</span><span>(</span><span>2</span><span>)</span><span>[</span><span>x</span><span>]</span><span>/</span><span>(</span><span>p</span><span>(</span><span>x</span><span>))</span></span></span></span>.</p>
<p>And <em>that</em> is what BCH codes use and why we require a primitive polynomial.</p>
<p>Now, how do we calculate all primitive polynomials then? We don’t. There are infinitely many. But we can calculate all primitive polynomials of some specific degree <span><span aria-hidden="true"><span><span></span><span>m</span></span></span></span>! And how do we do that? Well, using what we have already built for finding primitive roots for integers:</p>
<ul>
<li>Iterate through all possible polynomials of degree <span><span aria-hidden="true"><span><span></span><span>m</span></span></span></span>. For each candidate <span><span aria-hidden="true"><span><span></span><span>p</span><span>(</span><span>x</span><span>)</span></span></span></span>, <strong>(step 1)</strong>
<ul>
<li>check if <span><span aria-hidden="true"><span><span></span><span>p</span><span>(</span><span>x</span><span>)</span></span></span></span> irreducible. Discard if not. <strong>(step 2)</strong></li>
<li>check if <span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span> (the simple polynomial with integer representation 2) is a primitive element in the finite field induced by <span><span aria-hidden="true"><span><span></span><span>p</span><span>(</span><span>x</span><span>)</span></span></span></span>. <strong>(step 3)</strong>
<ul>
<li>the wanted cycle length <span><span aria-hidden="true"><span><span></span><span>N</span></span></span></span> is the amount of all possible polynomials of degree <span><span aria-hidden="true"><span><span></span><span>m</span></span></span></span>:
<span><span aria-hidden="true"><span><span></span><span>N</span><span></span><span>=</span><span></span></span><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span>m</span></span></span></span></span></span></span></span><span></span><span>−</span><span></span></span><span><span></span><span>1</span></span></span></span></li>
<li>get all prime factors <span><span aria-hidden="true"><span><span></span><span>q</span></span></span></span> of <span><span aria-hidden="true"><span><span></span><span>N</span></span></span></span></li>
<li>check if <span><span aria-hidden="true"><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span><span>N</span><span>/</span><span>q</span></span></span></span></span></span></span></span></span><span></span><span><span><span><span><span><span></span><span><span><span></span></span></span><span></span></span></span></span></span><span>=</span></span><span></span></span><span><span></span><span>1</span><span></span><span></span><span><span><span>mod</span></span></span><span></span><span></span></span><span><span></span><span><span>p</span><span>(</span><span>x</span><span>)</span></span></span></span></span> for all prime factors <span><span aria-hidden="true"><span><span></span><span>q</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>For (step 1)</strong>, we want a primitive polynomial with degree <span><span aria-hidden="true"><span><span></span><span>m</span></span></span></span>, so we only consider polynomials where their m-th coefficient is 1 and all higher-order coefficients are 0. This means that their integer representations are in</p>
<p><code>range(2^m, 2^(m+1))</code>.</p>
<p>To speed it up by factor 2: We can’t have any polynomials where the constant term, i.e., the lowest-order coefficient is zero. Example:</p>
<p><span><span aria-hidden="true"><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>5</span></span></span></span></span></span></span></span><span></span><span>+</span><span></span></span><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>3</span></span></span></span></span></span></span></span><span></span><span>+</span><span></span></span><span><span></span><span>x</span></span></span></span> (note that there is no <span><span aria-hidden="true"><span><span></span><span>+</span><span>1</span></span></span></span> at the end)</p>
<p>That’s because every polynomial with a zero constant term is divisible by the polynomial <span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span> and is thus not irreducible and thus not primitive. So we only iterate over polynomials with a constant term of <span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span>. In the integer representation, those are the odd integers, so we use</p>
<p><code>range(2^m + 1, 2^(m-1), 2)</code></p>
<p><strong>For (step 2)</strong>, checking whether a polynomial is irreducible is the analogue to checking whether an integer is prime.</p>
<p>Ruling out even integer representations of polynomials in (1) skips half the possible candidates because those are all reducible. Unfortunately, there will still be plenty of reducible polynomials left. Just like there are a lot of non-prime numbers among the odd integers.</p>
<p>For a full irreducibility test, we use <a href="https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Rabin&#39;s_test_of_irreducibility">Rabin’s Test</a>. The implementation has a similar structure as the <a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test">Rabin-Miller Test</a> for integers. We won’t cover either here because this section is long enough already.</p>
<div><figure><pre data-language="python"><code><div><p><span>def</span><span> </span><span>is_reducible</span><span>(fx):</span></p></div><div><p><span>    </span><span># check irreducible with rabin&#39;s irreducibility test</span></p></div><div><p><span>    </span><span>#   for all k &lt;= n//2, check that</span></p></div><div><p><span>    </span><span>#   x^(2^k) - x does not divide fx</span></p></div><div><p><span><span>    </span></span><span>degree </span><span>=</span><span> fx.bit_length() </span><span>-</span><span> </span><span>1</span></p></div><div><p><span><span>    </span></span><span>x </span><span>=</span><span> </span><span>2</span></p></div><div><p><span><span>    </span></span><span>y </span><span>=</span><span> x</span></p></div><div><p><span>    </span><span>for</span><span> _ </span><span>in</span><span> </span><span>range</span><span>(degree </span><span>//</span><span> </span><span>2</span><span> </span><span>+</span><span> </span><span>1</span><span>):</span></p></div><div><p><span>        </span><span># y = y^2 mod fx</span></p></div><div><p><span><span>        </span></span><span>y </span><span>=</span><span> poly_mod(poly_mul(y, y), fx)</span></p></div><div><p><span><span>        </span></span><span>y_minus_x </span><span>=</span><span> y </span><span>^</span><span> x</span></p></div><div><p><span>        </span><span>if</span><span> poly_gcd(y_minus_x, fx) </span><span>!=</span><span> </span><span>1</span><span>:</span></p></div><div><p><span>            </span><span>return</span><span> </span><span>False</span></p></div><div></div><div><p><span>    </span><span>#   check that fx divides</span></p></div><div><p><span>    </span><span>#   x^(2^n) - x</span></p></div><div><p><span>    </span><span>for</span><span> _ </span><span>in</span><span> </span><span>range</span><span>(degree </span><span>//</span><span> </span><span>2</span><span> </span><span>+</span><span> </span><span>1</span><span>, degree):</span></p></div><div><p><span><span>        </span></span><span>y </span><span>=</span><span> poly_mod(poly_mul(y, y), fx)</span></p></div><div><p><span>    </span><span>return</span><span> y </span><span>==</span><span> x</span></p></div></code></pre></figure></div>
<p><strong>For (step 3)</strong>, we do the same as for primitive roots in integer-world, except we use a polynomial-compatible <code>pow</code> function:</p>
<div><figure><pre data-language="python"><code><div><p><span>def</span><span> </span><span>primitive_binary_polynomials</span><span>(degree):</span></p></div><div><p><span><span>    </span></span><span>n </span><span>=</span><span> </span><span>2</span><span>**</span><span>degree </span><span>-</span><span> </span><span>1</span></p></div><div><p><span><span>    </span></span><span>prime_factors </span><span>=</span><span> </span><span>set</span><span>(prime_factorization(n))</span></p></div><div><p><span><span>    </span></span><span>x </span><span>=</span><span> </span><span>2</span></p></div><div></div><div><p><span>    </span><span>for</span><span> fx </span><span>in</span><span> </span><span>range</span><span>(</span><span>2</span><span>**</span><span>degree </span><span>+</span><span> </span><span>1</span><span>, </span><span>2</span><span> </span><span>**</span><span> (degree </span><span>+</span><span> </span><span>1</span><span>), </span><span>2</span><span>):</span></p></div><div><p><span>        </span><span># check irreducible</span></p></div><div><p><span>        </span><span>if</span><span> </span><span>not</span><span> is_reducible(fx):</span></p></div><div><p><span>            </span><span>continue</span></p></div><div></div><div><p><span>        </span><span># check primitive</span></p></div><div><p><span>        </span><span>for</span><span> q </span><span>in</span><span> prime_factors:</span></p></div><div><p><span>            </span><span>if</span><span> poly_pow_mod(x, n </span><span>//</span><span> q, fx) </span><span>==</span><span> </span><span>1</span><span>:</span></p></div><div><p><span>                </span><span>break</span></p></div><div><p><span>        </span><span>else</span><span>:</span></p></div><div><p><span>            </span><span>yield</span><span> fx</span></p></div></code></pre></figure></div>
<h3 id="finding-all-primitive-polynomials">Finding all Primitive Polynomials<a aria-hidden="true" tabindex="-1" href="#finding-all-primitive-polynomials"><span>¶</span></a></h3>
<p>And now we can <em>finally</em> compute all the primitive polynomials with degree 14. The full script is attached in the addendum. It takes about 1 second (single-threaded, on my laptop) to list all 756 primitive polynomials for degree 14. Yes - there are only 756!</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>All primitive polynomials of degree 14:</span></p></div><div><p><span>16427 = 0b100000000101011</span></p></div><div><p><span>16441 = 0b100000000111001</span></p></div><div><p><span>16467 = 0b100000001010011</span></p></div><div><p><span>16479 = 0b100000001011111</span></p></div><div><p><span>16507 = 0b100000001111011</span></p></div><div><p><span>16553 = 0b100000010101001</span></p></div><div><p><span>...</span></p></div><div><p><span>32653 = 0b111111110001101</span></p></div><div><p><span>32671 = 0b111111110011111</span></p></div><div><p><span>32709 = 0b111111111000101</span></p></div><div><p><span>32721 = 0b111111111010001</span></p></div><div><p><span>32743 = 0b111111111100111</span></p></div><div><p><span>Total primitive polynomials of degree 14: 756</span></p></div></code></pre></figure></div>
<p>And how much faster does this make our script compared to the naive
<code>range(2**14 + 1, 2**15, 2)</code>
that lists half of all possible binary polynomials of degree 14?</p>
<p>About 1 second on a single-threaded run on my laptop…</p>
<p>Turns out just throwing a bunch of mostly non-primitive polynomials against bchlib and catching the exception is just as fast as doing it properly…</p>
<p>Oh, and you know what? You could have also just pulled a list of all primitive polynomials of degree 14 from the internet. Because, well, we aren’t the first to generate that list.</p>
<p>But hey, we learned some math.</p> </div></div>
  </body>
</html>
