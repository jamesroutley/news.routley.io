<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://missfunmi.com/building-a-playdate-game-in-rust/">Original</a>
    <h1>Building a Playdate Game in Rust</h1>
    
    <div id="readability-page-1" class="page"><div id="skip"><section><p>Building a Playdate Game in Rust</p><p>A step-by-step guide to writing your first Playdate game in Rust using the crankstart crate.</p><p><time datetime="2025-06-13">Published June 13, 2025</time></p></section><section><p><em>I recently built a <a href="https://github.com/missfunmi/tictactoe-playdate/" target="_blank" rel="noopener">Playdate game in Rust</a>. I thought I‚Äôd share the process for anyone else considering doing the same thing.</em></p><p><a href="https://play.date" target="_blank" rel="noopener">Playdate</a> is a handheld gaming console that launched in 2019. Its most recognizable feature is a fun little crank that many (but not all) games incorporate into their gameplay in really creative and sometimes funny ways.</p><p><picture><source type="image/webp" srcset="/building-a-playdate-game-in-rust/Kz-7hMm----480.webp 480w"/><img loading="lazy" decoding="async" src="https://news.ycombinator.com/building-a-playdate-game-in-rust/Kz-7hMm----480.gif" alt="playdate" width="480" height="270"/></picture></p><p>I‚Äôve personally never really been a big gamer, but I love the peppy, bright yellow colorway of the Playdate and its quirky form factor. Separately, I recently became interested in learning Rust, and I wanted to do so by building something practical in addition to going through the Rust book.</p><p>While Rust is not officially supported by Playdate, there are unofficial libraries that facilitate Playdate game development in Rust, so I thought I‚Äôd try my hand at one of them. I chose to use the <a href="https://github.com/pd-rs/crankstart" target="_blank" rel="noopener">crankstart</a> crate, mostly because it was the first one I came across and it‚Äôs been around the longest. Since it‚Äôs an unofficially maintained library, feature-wise it‚Äôs several versions behind the official Playdate SDK, but it‚Äôs still totally functional for basic/core game functions.</p><blockquote><blockquote><p><strong>üí° Note:</strong> The code in this game works with Playdate SDK v2.6.2. It will probably also work with the <a href="https://sdk.play.date/changelog/#_2_7_0" target="_blank" rel="noopener">latest SDK v2.7</a>, but I‚Äôve not tested that yet!</p></blockquote></blockquote><h2 id="goals" tabindex="-1">Goals</h2><p>For this exercise, we‚Äôre going to build a game that has a player that can be moved around the screen via the keypad. Pressing the <code>A</code> button on the Playdate will put a dot on the screen at the player‚Äôs current location, and pressing the <code>B</code> button will clear the screen of all dots. A very simplistic drawing ‚Äúgame‚Äù, if you will. You can view the complete source code here: <a href="https://github.com/missfunmi/hello-world-playdate" target="_blank" rel="noopener">https://github.com/missfunmi/hello-world-playdate</a></p><p><picture><source type="image/webp" srcset="/building-a-playdate-game-in-rust/5eYinV_fOf-480.webp 480w"/><img loading="lazy" decoding="async" src="https://news.ycombinator.com/building-a-playdate-game-in-rust/5eYinV_fOf-480.png" alt="screenshot of the game" width="480" height="464"/></picture></p><h2 id="pre-requisites" tabindex="-1">Pre-requisites</h2><ol><li><a href="https://www.rust-lang.org/" target="_blank" rel="noopener"><strong>Rust</strong></a> ‚Üí If you‚Äôre here, you probably already have this installed. If not, I recommend installing via <a href="https://www.rust-lang.org/tools/install" target="_blank" rel="noopener">Rustup</a>.<ul><li><strong>cargo</strong> ‚Üí This is automatically installed for you by Rustup</li><li><strong>Rust nightly toolchain</strong> ‚Üí Building games for devices uses non-standard Rust features, which is only available on the nightly toolchain. Install by running <code>rustup toolchain install nightly</code>. This makes the nightly toolchain available on your system but does not change your global Rust version to the nightly one.</li></ul></li><li><a href="https://play.date/dev/" target="_blank" rel="noopener"><strong>Playdate SDK</strong></a> ‚Üí Download v2.6.2 from <a href="https://download-cdn.panic.com/playdate_sdk/" target="_blank" rel="noopener">here</a> for your relevant OS.<ul><li>Follow the <a href="https://sdk.play.date/2.6.2/Inside%20Playdate.html#_installation" target="_blank" rel="noopener">Installation steps</a> to complete the process. Be sure to update your <code>PATH</code> variable to include the Playdate SDK by following the instructions <a href="https://sdk.play.date/2.6.2/Inside%20Playdate.html#_set_playdate_sdk_path_environment_variable" target="_blank" rel="noopener">here</a>.</li><li>Feel free to poke around the downloaded SDK to see what it comes with. You can even try running some of the sample games (written in Lua) that come with the SDK! The Playdate Simulator is automatically installed for you as well.</li></ul></li><li><a href="https://github.com/pd-rs/crank" target="_blank" rel="noopener"><strong>crank</strong></a> ‚Üí This is the command line tool that will build your game into a Playdate binary.<ul><li>Install according to the instructions on <a href="https://github.com/pd-rs/crank" target="_blank" rel="noopener">GitHub</a>. If you‚Äôve already installed Rust and the Playdate SDK, you‚Äôll only need to run the following command additionally: <code>cargo install --git=https://github.com/pd-rs/crank</code></li></ul></li></ol><h2 id="setting-up-your-project" tabindex="-1">Setting up your project</h2><p>In your project directory, run:</p><pre tabindex="0"><code><span>cargo</span> new <span>--lib</span> hello-world-playdate</code></pre><p>You can now open the <code>hello-world-playdate</code> project in your IDE of choice. I personally like <a href="https://www.jetbrains.com/rust/" target="_blank" rel="noopener">RustRover</a>, which is free for non-commercial use.</p><p>To use Rust nightly in this project without overriding your global Rust version, create a file in the project root called <code>rust-toolchain.toml</code> and add the following entry:</p><pre tabindex="0"><code>

<span>[</span><span>toolchain</span><span>]</span>
<span>channel</span> <span>=</span> <span>&#34;nightly&#34;</span></code></pre><p>There are a few tweaks you need to make to the auto-generated <code>Cargo.toml</code> for your Playdate game:</p><pre tabindex="0"><code>

<span>[</span><span>package</span><span>]</span>
<span>name</span> <span>=</span> <span>&#34;hello-world-playdate&#34;</span>
<span>version</span> <span>=</span> <span>&#34;0.1.0&#34;</span>
<span>edition</span> <span>=</span> <span>&#34;2018&#34;</span>

<span>[</span><span>package.metadata.cargo-xbuild</span><span>]</span>
<span>memcpy</span> <span>=</span> <span>false</span>
<span>sysroot_path</span> <span>=</span> <span>&#34;target/sysroot&#34;</span>
<span>panic_immediate_abort</span> <span>=</span> <span>false</span>

<span>[</span><span>profile.dev</span><span>]</span>
<span>panic</span> <span>=</span> <span>&#34;abort&#34;</span>
<span>opt-level</span> <span>=</span> <span>&#39;z&#39;</span>
<span>lto</span> <span>=</span> <span>true</span>

<span>[</span><span>profile.release</span><span>]</span>
<span>panic</span> <span>=</span> <span>&#34;abort&#34;</span>
<span>opt-level</span> <span>=</span> <span>&#39;z&#39;</span>
<span>lto</span> <span>=</span> <span>true</span>

<span>[</span><span>lib</span><span>]</span>
<span>crate-type</span> <span>=</span> <span>[</span><span>&#34;staticlib&#34;</span><span>,</span> <span>&#34;cdylib&#34;</span><span>]</span>

<span>[</span><span>dependencies</span><span>]</span>
<span>crankstart</span> <span>=</span> <span>{</span> <span>git</span> <span>=</span> <span>&#34;https://github.com/pd-rs/crankstart.git&#34;</span><span>,</span> <span>rev</span> <span>=</span> <span>&#34;2d2e99c&#34;</span> <span>}</span>
<span>crankstart-sys</span> <span>=</span> <span>{</span> <span>git</span> <span>=</span> <span>&#34;https://github.com/pd-rs/crankstart.git&#34;</span><span>,</span> <span>rev</span> <span>=</span> <span>&#34;2d2e99c&#34;</span> <span>}</span>
<span>anyhow</span> <span>=</span> <span>{</span> <span>version</span> <span>=</span> <span>&#34;1.0.98&#34;</span><span>,</span> <span>default-features</span> <span>=</span> <span>false</span> <span>}</span>
<span>euclid</span> <span>=</span> <span>{</span> <span>version</span> <span>=</span> <span>&#34;0.22.11&#34;</span><span>,</span> <span>default-features</span> <span>=</span> <span>false</span><span>,</span> <span>features</span> <span>=</span> <span>[</span><span>&#34;libm&#34;</span><span>]</span> <span>}</span></code></pre><p>Let‚Äôs cover some of the changes we‚Äôve made here:</p><ol><li><code>edition = &#34;2018&#34;</code>: I haven‚Äôt tested with <a href="https://doc.rust-lang.org/stable/edition-guide/rust-2024/index.html" target="_blank" rel="noopener">Rust 2024</a>, but feel free to ‚Äî it might work!</li><li><code>package.metadata.cargo-xbuild</code>: These settings override some default build behavior so that crankstart and crank can manage things differently when targeting the Playdate.</li><li><code>[profile.dev]</code> and <code>[profile.release]</code>: These settings make your build smaller and more suitable for tiny systems like the Playdate.</li><li><code>crate-type = [&#34;staticlib&#34;, &#34;cdylib&#34;]</code>: This compiles your game as both a static library and a C-compatible dynamic library, which is necessary because the Playdate system can only load and run compiled C-compatible code.</li><li><code>crankstart</code> and <code>crankstart-sys</code>: These are the core libraries that let you build your Playdate game in Rust. We pin them to a <a href="https://github.com/pd-rs/crankstart/commit/2d2e99c89326d16b3ee6b465bdfea39c1a25d8ce" target="_blank" rel="noopener">specific commit</a> that includes important fixes not yet published to <a href="http://crates.io" target="_blank" rel="noopener">crates.io</a>.</li><li><code>anyhow</code> and <code>euclid</code>: These are optional helper crates we‚Äôll use in our game. We disable default features because we‚Äôll be building in a <code>no_std</code> environment which does not support them (more on <code>no_std</code> below).</li></ol><h2 id="setting-up-your-game-template" tabindex="-1">Setting up your game template</h2><p>Create a <code>Crank.toml</code> file at the same level as your auto-generated <code>Cargo.toml</code> containing the following configuration:</p><pre tabindex="0"><code>

<span>[</span><span>[</span><span>target</span><span>]</span><span>]</span>
<span>name</span> <span>=</span> <span>&#34;hello_world_playdate&#34;</span>
<span>assets</span> <span>=</span> <span>[</span>
    <span>&#34;assets/background.png&#34;</span><span>,</span>
    <span>&#34;assets/dot.png&#34;</span><span>,</span>
    <span>&#34;assets/player.png&#34;</span><span>,</span>
<span>]</span>

<span>[</span><span>target.metadata</span><span>]</span>
<span>name</span> <span>=</span> <span>&#34;Hello World&#34;</span>
<span>version</span> <span>=</span> <span>&#34;0.1.0&#34;</span>
<span>author</span> <span>=</span> <span>&#34;&lt;your name&gt;&#34;</span>
<span>bundle_id</span> <span>=</span> <span>&#34;com.example.hello_world&#34;</span>
<span>description</span> <span>=</span> <span>&#34;A simple interactive Playdate game built in Rust&#34;</span></code></pre><p>These properties map to the Playdate metadata defined <a href="https://sdk.play.date/2.6.2/#pdxinfo" target="_blank" rel="noopener">here</a>, so you can refer to that documentation for information on what each property does. Note that due to <a href="https://github.com/pd-rs/crankstart/issues/89" target="_blank" rel="noopener">an open issue in the crankstart library</a>, hyphens will not work in the target name in <code>Crank.toml</code> (this is not a limitation in Playdate itself).</p><p>Next, create the <code>assets</code> folder at the same level as your <code>src</code> folder and populate this folder with the contents of the assets folder in the <a href="https://github.com/missfunmi/hello-world-playdate/tree/master/assets" target="_blank" rel="noopener">project repository</a>.</p><p>Open <code>src/lib.rs</code> file and replace its contents with the template below:</p><pre tabindex="0"><code>

<span>#![no_std]</span>

<span>extern</span> <span>crate</span> <span>alloc</span><span>;</span>
<span>use</span> <span>alloc<span>::</span>boxed<span>::</span></span><span>Box</span><span>;</span>
<span>use</span> <span>anyhow<span>::</span></span><span>Error</span><span>;</span>
<span>use</span> <span>crankstart<span>::</span>sprite<span>::</span></span><span>Sprite</span><span>;</span>
<span>use</span> <span>crankstart<span>::</span></span><span>{</span>crankstart_game<span>,</span> <span>Game</span><span>,</span> <span>Playdate</span><span>}</span><span>;</span>
<span>use</span> <span>crankstart_sys<span>::</span></span><span>PDRect</span><span>;</span>

<span>struct</span> <span>HelloWorldGame</span> <span>{</span><span>}</span>

<span>impl</span> <span>HelloWorldGame</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>new</span><span>(</span>_playdate<span>:</span> <span>&amp;</span><span>Playdate</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>,</span> <span>Error</span><span>&gt;</span> <span>{</span>
        <span>todo!</span><span>(</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>impl</span> <span>Game</span> <span>for</span> <span>HelloWorldGame</span> <span>{</span>
    <span>fn</span> <span>update_sprite</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> sprite<span>:</span> <span>&amp;</span><span>mut</span> <span>Sprite</span><span>,</span> _playdate<span>:</span> <span>&amp;</span><span>mut</span> <span>Playdate</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>Error</span><span>&gt;</span> <span>{</span>
        <span>todo!</span><span>(</span><span>)</span>
    <span>}</span>

    <span>fn</span> <span>draw_sprite</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> sprite<span>:</span> <span>&amp;</span><span>Sprite</span><span>,</span> _bounds<span>:</span> <span>&amp;</span><span>PDRect</span><span>,</span> _draw_rect<span>:</span> <span>&amp;</span><span>PDRect</span><span>,</span> _playdate<span>:</span> <span>&amp;</span><span>Playdate</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>Error</span><span>&gt;</span> <span>{</span>
        <span>todo!</span><span>(</span><span>)</span>
    <span>}</span>

    <span>fn</span> <span>update</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> _playdate<span>:</span> <span>&amp;</span><span>mut</span> <span>Playdate</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>Error</span><span>&gt;</span> <span>{</span>
        <span>todo!</span><span>(</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>crankstart_game!</span><span>(</span><span>HelloWorldGame</span><span>)</span><span>;</span></code></pre><p>This is the bare minimum for what your game needs to launch. We‚Äôll populate the <code>todo()!</code>&#39;s with real game logic shortly, but first, let‚Äôs talk about what‚Äôs happening here:</p><ol><li><code>#![no_std]</code>: This tells Rust to exclude the use of its standard library, <a href="https://doc.rust-lang.org/std/" target="_blank" rel="noopener">libstd</a> when compiling your game. This is required when writing applications for embedded systems like a gaming console. Don‚Äôt ask me why ‚Äî I‚Äôm just the messenger. You can read more about <code>no_std</code> <a href="https://docs.rust-embedded.org/book/intro/no-std.html" target="_blank" rel="noopener">here</a>.</li><li><code>extern crate alloc</code> and <code>use alloc::boxed::Box</code>: These enable heap allocation via <code>Box</code>, a smart pointer in Rust to heap memory in your <code>no_std</code> environment. Since you can‚Äôt always know the exact size or lifetime of your game state ahead of time, <code>crankstart</code> (and your game) use <code>Box</code> to store data on the heap instead of the limited stack.</li><li><code>struct HelloWorldGame</code> and <code>impl HelloWorldGame</code>: This is your singleton game object, where you‚Äôll implement all your game logic: instantiating graphics and text, spawning entities, managing game state, and so on. Your game must define a <code>pub fn *new*(_playdate: &amp;Playdate) -&gt; Result&lt;Box&lt;Self&gt;, Error&gt;</code> function that takes the <a href="https://github.com/pd-rs/crankstart/blob/main/src/lib.rs?rev=2d2e99c#L35" target="_blank" rel="noopener">Playdate</a> object as an argument and returns a boxed instance of your game. This is how <code>crankstart</code> initializes and kicks off your game flow.</li><li><code>impl Game for HelloWorldGame</code>: <a href="https://github.com/pd-rs/crankstart/blob/main/src/lib.rs?rev=2d2e99c#L102" target="_blank" rel="noopener">Game</a> is the main trait from <code>crankstart</code> that defines how your game updates in response to state changes (typically by rendering stuff to the screen). In particular, <code>fn update(&amp;mut self, playdate: &amp;mut Playdate)</code> maps directly to <a href="https://sdk.play.date/2.6.2/Inside%20Playdate.html#c-update" target="_blank" rel="noopener">playdate.update()</a>, which the Playdate system calls <a href="https://sdk.play.date/2.6.2/Inside%20Playdate.html#_playdate_specifications" target="_blank" rel="noopener">30 times per second</a> by default. There are some additional trait functions that your game can optionally implement. For convenience, I‚Äôve left them out of this post, but feel free to look through the crate‚Äôs source to read through the others.</li><li><code>crankstart_game!(HelloWorldGame)</code>: This macro kicks off your game flow by telling <code>crankstart</code> which game struct to use. You can place it anywhere in your Rust project, but it‚Äôs idiomatic (from what I can see) to put it at the bottom after all your game logic.</li></ol><p>Now let‚Äôs try running the game. In your terminal, from your project root, run the command:</p><pre tabindex="0"><code><span>cd</span> hello-world-playdate/    
crank run <span>--release</span></code></pre><p>We use the crank CLI we installed earlier to compile the game into a Playdate binary and launch it on the simulator. The <code>--release</code> flag merely optimizes your game build. Right now, running this command may only briefly launch the simulator before immediately crashing. This is because we don‚Äôt actually have any logic implemented in our game, so there‚Äôs nothing (yet) for the simulator to render.</p><h2 id="writing-your-game-logic" tabindex="-1">Writing your game logic</h2><p>Now that we‚Äôve squared away the basics, let‚Äôs implement some actual game logic.</p><h3 id="loading-the-background-image" tabindex="-1">Loading the background image</h3><p>We‚Äôll start by loading the background image onto the screen. First, we‚Äôll define an enum for the different types of sprites our game will have, which is just <code>Background</code> for now:</p><pre tabindex="0"><code>

<span>#[repr(u8)]</span>
<span>enum</span> <span>SpriteType</span> <span>{</span>
    <span>Background</span> <span>=</span> <span>0</span><span>,</span>
<span>}</span>

<span>impl</span> <span>From</span><span>&lt;</span><span>u8</span><span>&gt;</span> <span>for</span> <span>SpriteType</span> <span>{</span>
    <span>fn</span> <span>from</span><span>(</span>tag<span>:</span> <span>u8</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>let</span> sprite_type <span>=</span> <span>match</span> tag <span>{</span>
            _ <span>=&gt;</span> <span>Background</span>
        <span>}</span><span>;</span>
        sprite_type
    <span>}</span>
<span>}</span></code></pre><p>Next, we‚Äôll attach the background image to the game instance and instantiate the image as well as the containing sprite:</p><pre tabindex="0"><code>

<span>const</span> <span>SCREEN_WIDTH</span><span>:</span> <span>f32</span> <span>=</span> <span>400.0</span><span>;</span>
<span>const</span> <span>SCREEN_HEIGHT</span><span>:</span> <span>f32</span> <span>=</span> <span>240.0</span><span>;</span>

<span>struct</span> <span>HelloWorldGame</span> <span>{</span>
    background_image<span>:</span> <span>Bitmap</span>
<span>}</span>

<span>impl</span> <span>HelloWorldGame</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>new</span><span>(</span>_playdate<span>:</span> <span>&amp;</span><span>Playdate</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>,</span> <span>Error</span><span>&gt;</span> <span>{</span>
        <span>let</span> sprite_manager <span>=</span> <span>SpriteManager</span><span>::</span><span>get_mut</span><span>(</span><span>)</span><span>;</span>

        
        <span>let</span> background_image <span>=</span> <span>Graphics</span><span>::</span><span>get</span><span>(</span><span>)</span><span>.</span><span>load_bitmap</span><span>(</span><span>&#34;assets/background&#34;</span><span>)</span><span>?</span><span>;</span>
        <span>let</span> background <span>=</span> <span>Box</span><span>::</span><span>leak</span><span>(</span><span>Box</span><span>::</span><span>new</span><span>(</span>sprite_manager<span>.</span><span>new_sprite</span><span>(</span><span>)</span><span>?</span><span>)</span><span>)</span><span>;</span>
        background<span>.</span><span>set_bounds</span><span>(</span><span>&amp;</span><span>rect_make</span><span>(</span><span>0.0</span><span>,</span> <span>0.0</span><span>,</span> <span>SCREEN_WIDTH</span><span>,</span> <span>SCREEN_HEIGHT</span><span>)</span><span>)</span><span>?</span><span>;</span>
        background<span>.</span><span>set_use_custom_draw</span><span>(</span><span>)</span><span>?</span><span>;</span>
        background<span>.</span><span>set_z_index</span><span>(</span><span>0</span><span>)</span><span>?</span><span>;</span>
        background<span>.</span><span>set_tag</span><span>(</span><span>Background</span> <span>as</span> <span>u8</span><span>)</span><span>?</span><span>;</span>
        sprite_manager<span>.</span><span>add_sprite</span><span>(</span>background<span>)</span><span>?</span><span>;</span>

        <span>let</span> game <span>=</span> <span>HelloWorldGame</span> <span>{</span> background_image <span>}</span><span>;</span>
        <span>Ok</span><span>(</span><span>Box</span><span>::</span><span>new</span><span>(</span>game<span>)</span><span>)</span>
    <span>}</span>
<span>}</span></code></pre><p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak" target="_blank" rel="noopener">Box::leak</a> is a handy feature in Rust that lets the game keep a reference to the background sprite and prevents Rust from deallocating it. We set the background image to start from coordinates <code>(0, 0)</code> and span the <a href="https://sdk.play.date/2.6.2/#_playdate_specifications" target="_blank" rel="noopener">width and height</a> of the Playdate screen.</p><p>Lastly, we‚Äôll tell the Playdate to actually draw the background image on screen. We only want to draw the background image once since it won‚Äôt change during the game play in this specific game, so we‚Äôll use the <code>draw_sprite</code> trait function to do so:</p><pre tabindex="0"><code>

<span>impl</span> <span>Game</span> <span>for</span> <span>HelloWorldGame</span> <span>{</span>
    <span>fn</span> <span>update_sprite</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> sprite<span>:</span> <span>&amp;</span><span>mut</span> <span>Sprite</span><span>,</span> _playdate<span>:</span> <span>&amp;</span><span>mut</span> <span>Playdate</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>Error</span><span>&gt;</span> <span>{</span>
        <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>

    <span>fn</span> <span>draw_sprite</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> sprite<span>:</span> <span>&amp;</span><span>Sprite</span><span>,</span> _bounds<span>:</span> <span>&amp;</span><span>PDRect</span><span>,</span> _draw_rect<span>:</span> <span>&amp;</span><span>PDRect</span><span>,</span> _playdate<span>:</span> <span>&amp;</span><span>Playdate</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>Error</span><span>&gt;</span> <span>{</span>
        <span>let</span> tag <span>=</span> sprite<span>.</span><span>get_tag</span><span>(</span><span>)</span><span>?</span><span>.</span><span>into</span><span>(</span><span>)</span><span>;</span>
        <span>match</span> tag <span>{</span>
            <span>Background</span> <span>=&gt;</span> <span>self</span><span>.</span>background_image<span>.</span><span>draw</span><span>(</span><span>point2</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span><span>,</span> <span>LCDBitmapFlip</span><span>::</span>kBitmapUnflipped<span>)</span><span>?</span><span>,</span>
            _ <span>=&gt;</span> <span>{</span><span>}</span>
        <span>}</span>
        <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>

    <span>fn</span> <span>update</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> _playdate<span>:</span> <span>&amp;</span><span>mut</span> <span>Playdate</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>Error</span><span>&gt;</span> <span>{</span>
        <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>
<span>}</span></code></pre><p>Be sure to swap out the <code>todo!()</code> placeholders in the other 2 trait functions with <code>Ok(())</code>, otherwise Playdate will continue to crash when you try to launch the game. We‚Äôll add in the logic for these later.</p><p>Now re-run <code>crank run --release</code> ‚Äî you should now see the Playdate simulator launch with our background image loaded. Neat!</p><h3 id="adding-the-player" tabindex="-1">Adding the player</h3><p>Initializing the player sprite is very similar to how we initialized the background sprite:</p><pre tabindex="0"><code>

<span>#[repr(u8)]</span>
<span>enum</span> <span>SpriteType</span> <span>{</span>
    <span>Background</span> <span>=</span> <span>0</span><span>,</span>
    <span>Player</span> <span>=</span> <span>1</span>
<span>}</span>

<span>impl</span> <span>From</span><span>&lt;</span><span>u8</span><span>&gt;</span> <span>for</span> <span>SpriteType</span> <span>{</span>
    <span>fn</span> <span>from</span><span>(</span>tag<span>:</span> <span>u8</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>let</span> sprite_type <span>=</span> <span>match</span> tag <span>{</span>
            <span>0</span> <span>=&gt;</span> <span>Background</span><span>,</span>
            _ <span>=&gt;</span> <span>Player</span><span>,</span>
        <span>}</span><span>;</span>
        sprite_type
    <span>}</span>
<span>}</span>

<span>struct</span> <span>HelloWorldGame</span> <span>{</span>
    background_image<span>:</span> <span>Bitmap</span><span>,</span>
    player<span>:</span> <span>Sprite</span><span>,</span>
<span>}</span>

<span>impl</span> <span>HelloWorldGame</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>new</span><span>(</span>_playdate<span>:</span> <span>&amp;</span><span>Playdate</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>,</span> <span>Error</span><span>&gt;</span> <span>{</span>
        <span>let</span> sprite_manager <span>=</span> <span>SpriteManager</span><span>::</span><span>get_mut</span><span>(</span><span>)</span><span>;</span>

        
        <span>...</span>

        
        <span>let</span> player_image <span>=</span> <span>Graphics</span><span>::</span><span>get</span><span>(</span><span>)</span><span>.</span><span>load_bitmap</span><span>(</span><span>&#34;assets/player&#34;</span><span>)</span><span>?</span><span>;</span>
        <span>let</span> <span>mut</span> player <span>=</span> sprite_manager<span>.</span><span>new_sprite</span><span>(</span><span>)</span><span>?</span><span>;</span>
        player<span>.</span><span>set_image</span><span>(</span>player_image<span>,</span> <span>LCDBitmapFlip</span><span>::</span>kBitmapUnflipped<span>)</span><span>?</span><span>;</span>
        player<span>.</span><span>move_to</span><span>(</span><span>200.0</span><span>,</span> <span>120.0</span><span>)</span><span>?</span><span>;</span>
        player<span>.</span><span>set_z_index</span><span>(</span><span>10</span><span>)</span><span>?</span><span>;</span>
        player<span>.</span><span>set_opaque</span><span>(</span><span>true</span><span>)</span><span>?</span><span>;</span>
        player<span>.</span><span>set_tag</span><span>(</span><span>Player</span> <span>as</span> <span>u8</span><span>)</span><span>?</span><span>;</span>
        sprite_manager<span>.</span><span>add_sprite</span><span>(</span><span>&amp;</span>player<span>)</span><span>?</span><span>;</span>

        <span>let</span> game <span>=</span> <span>HelloWorldGame</span> <span>{</span> background_image<span>,</span> player <span>}</span><span>;</span>
        <span>Ok</span><span>(</span><span>Box</span><span>::</span><span>new</span><span>(</span>game<span>)</span><span>)</span>
    <span>}</span>
<span>}</span></code></pre><p>We add a new <code>Player</code> tag to the <code>SpriteType</code> enum, then initialize the player and position it in the center of the screen at the <code>(x, y, z)</code> coordinates: <code>(200.0, 120.0, 10)</code>. You can choose any value you want for the z-index as long as it‚Äôs greater than that of the background to ensure its positioned on top of the background. Instead of using custom draw, we attach the image to the player sprite directly since unlike our background, we expect to move the player around on the screen.</p><p>Notice here that we‚Äôre adding the <code>player</code> sprite to the game instance instead of using <code>Box::leak</code>. This is because we‚Äôll need to access the player‚Äôs coordinates in the <code>Game</code> trait later when we add dots to the screen.</p><p>Re-run <code>crank run --release</code> to see your player appear on the simulator!</p><h3 id="moving-the-player-around-the-screen" tabindex="-1">Moving the player around the screen</h3><p>To move the player around the screen, we‚Äôll detect keyboard presses on every frame and move the player to the corresponding location. This requires adding logic to the <code>update_sprite</code> function, which as you‚Äôll recall is triggered by Playdate at the game‚Äôs frame rate:</p><pre tabindex="0"><code>

<span>const</span> <span>MOVE</span><span>:</span> <span>f32</span> <span>=</span> <span>2.0</span><span>;</span>                    
<span>const</span> <span>PLAYER_SPRITE_WIDTH</span><span>:</span> <span>f32</span> <span>=</span> <span>32.0</span><span>;</span>    
<span>const</span> <span>PLAYER_SPRITE_HEIGHT</span><span>:</span> <span>f32</span> <span>=</span> <span>32.0</span><span>;</span>   

<span>impl</span> <span>Game</span> <span>for</span> <span>HelloWorldGame</span> <span>{</span>
    <span>fn</span> <span>update_sprite</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> sprite<span>:</span> <span>&amp;</span><span>mut</span> <span>Sprite</span><span>,</span> _playdate<span>:</span> <span>&amp;</span><span>mut</span> <span>Playdate</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>Error</span><span>&gt;</span> <span>{</span>
        <span>let</span> tag <span>=</span> sprite<span>.</span><span>get_tag</span><span>(</span><span>)</span><span>?</span><span>.</span><span>into</span><span>(</span><span>)</span><span>;</span>
        <span>match</span> tag <span>{</span>
            <span>Player</span> <span>=&gt;</span> <span>{</span>
                <span>let</span> <span>(</span>current<span>,</span> _pushed<span>,</span> _released<span>)</span> <span>=</span> <span>System</span><span>::</span><span>get</span><span>(</span><span>)</span><span>.</span><span>get_button_state</span><span>(</span><span>)</span><span>?</span><span>;</span>
                <span>let</span> current_position <span>=</span> sprite<span>.</span><span>get_position</span><span>(</span><span>)</span><span>?</span><span>;</span>
                <span>let</span> <span>mut</span> new_position <span>=</span> current_position<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>

                <span>if</span> <span>(</span>current <span>&amp;</span> <span>PDButtons</span><span>::</span>kButtonUp<span>)</span> <span>==</span> <span>PDButtons</span><span>::</span>kButtonUp <span>{</span>
                    new_position<span>.1</span> <span>-=</span> <span>MOVE</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>current <span>&amp;</span> <span>PDButtons</span><span>::</span>kButtonDown<span>)</span> <span>==</span> <span>PDButtons</span><span>::</span>kButtonDown <span>{</span>
                    new_position<span>.1</span> <span>+=</span> <span>MOVE</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>current <span>&amp;</span> <span>PDButtons</span><span>::</span>kButtonLeft<span>)</span> <span>==</span> <span>PDButtons</span><span>::</span>kButtonLeft <span>{</span>
                    new_position<span>.0</span> <span>-=</span> <span>MOVE</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>current <span>&amp;</span> <span>PDButtons</span><span>::</span>kButtonRight<span>)</span> <span>==</span> <span>PDButtons</span><span>::</span>kButtonRight <span>{</span>
                    new_position<span>.0</span> <span>+=</span> <span>MOVE</span><span>;</span>
                <span>}</span>

                new_position<span>.0</span> <span>=</span> new_position<span>.0</span><span>.</span><span>clamp</span><span>(</span><span>0.0</span><span>+</span><span>PLAYER_SPRITE_WIDTH</span><span>/</span><span>2.0</span><span>,</span> <span>SCREEN_WIDTH</span><span>-</span><span>PLAYER_SPRITE_WIDTH</span><span>/</span><span>2.0</span><span>)</span><span>;</span>
                new_position<span>.1</span> <span>=</span> new_position<span>.1</span><span>.</span><span>clamp</span><span>(</span><span>0.0</span><span>+</span><span>PLAYER_SPRITE_HEIGHT</span><span>/</span><span>2.0</span><span>,</span> <span>SCREEN_HEIGHT</span><span>-</span><span>PLAYER_SPRITE_HEIGHT</span><span>/</span><span>2.0</span><span>)</span><span>;</span>

                sprite<span>.</span><span>move_to</span><span>(</span>new_position<span>.0</span><span>,</span> new_position<span>.1</span><span>)</span><span>?</span><span>;</span>
            <span>}</span>
            _ <span>=&gt;</span> <span>{</span><span>}</span>
        <span>}</span>

        sprite<span>.</span><span>mark_dirty</span><span>(</span><span>)</span><span>?</span><span>;</span>
        <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>

    
<span>}</span></code></pre><p>Here, we detect what key the player is <em>currently</em> pressing and move the player around the screen 2 pixels at a time, clamping the player‚Äôs position so it doesn‚Äôt go offscreen. Note we halve the player‚Äôs dimensions when calculating its position relative to the screen bounds because Playdate anchors sprite positions at the center by default.</p><h3 id="adding-and-clearing-dots-on-the-screen" tabindex="-1">Adding and clearing dots on the screen</h3><p>The last thing we‚Äôll do is insert a dot on the screen when the Playdate‚Äôs <code>A</code> button is pressed and clear the entire screen of all dots when the <code>B</code> button is pressed. To do this, we‚Äôll initialize our final game asset: <code>dot.png</code> on game load, but only create and show a new dot sprite on screen when the <code>A</code> button is pressed:</p><pre tabindex="0"><code>

<span>#[repr(u8)]</span>
<span>enum</span> <span>SpriteType</span> <span>{</span>
    <span>Background</span> <span>=</span> <span>0</span><span>,</span>
    <span>Player</span> <span>=</span> <span>1</span><span>,</span>
    <span>Dot</span> <span>=</span> <span>2</span>
<span>}</span>

<span>impl</span> <span>From</span><span>&lt;</span><span>u8</span><span>&gt;</span> <span>for</span> <span>SpriteType</span> <span>{</span>
    <span>fn</span> <span>from</span><span>(</span>tag<span>:</span> <span>u8</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>let</span> sprite_type <span>=</span> <span>match</span> tag <span>{</span>
            <span>0</span> <span>=&gt;</span> <span>Background</span><span>,</span>
            <span>1</span> <span>=&gt;</span> <span>Player</span><span>,</span>
            _ <span>=&gt;</span> <span>Dot</span>
        <span>}</span><span>;</span>
        sprite_type
    <span>}</span>
<span>}</span>

<span>struct</span> <span>HelloWorldGame</span> <span>{</span>
    background_image<span>:</span> <span>Bitmap</span><span>,</span>
    player<span>:</span> <span>Sprite</span><span>,</span>
    dot_image<span>:</span> <span>Bitmap</span><span>,</span>
    dots<span>:</span> <span>Vec</span><span>&lt;</span><span>Sprite</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>impl</span> <span>HelloWorldGame</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>new</span><span>(</span>_playdate<span>:</span> <span>&amp;</span><span>Playdate</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>,</span> <span>Error</span><span>&gt;</span> <span>{</span>
        <span>let</span> sprite_manager <span>=</span> <span>SpriteManager</span><span>::</span><span>get_mut</span><span>(</span><span>)</span><span>;</span>

        
        <span>...</span>

        
        <span>let</span> dot_image <span>=</span> <span>Graphics</span><span>::</span><span>get</span><span>(</span><span>)</span><span>.</span><span>load_bitmap</span><span>(</span><span>&#34;assets/dot&#34;</span><span>)</span><span>?</span><span>;</span>
        <span>let</span> dots <span>=</span> <span>Vec</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>

        <span>let</span> game <span>=</span> <span>HelloWorldGame</span> <span>{</span>
            background_image<span>,</span>
            player<span>,</span>
            dot_image<span>,</span>
            dots<span>,</span>
        <span>}</span><span>;</span>
        <span>Ok</span><span>(</span><span>Box</span><span>::</span><span>new</span><span>(</span>game<span>)</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>impl</span> <span>Game</span> <span>for</span> <span>HelloWorldGame</span> <span>{</span>
    <span>fn</span> <span>update</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> _playdate<span>:</span> <span>&amp;</span><span>mut</span> <span>Playdate</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>Error</span><span>&gt;</span> <span>{</span>
        <span>let</span> <span>(</span>current<span>,</span> pushed<span>,</span> _<span>)</span> <span>=</span> <span>System</span><span>::</span><span>get</span><span>(</span><span>)</span><span>.</span><span>get_button_state</span><span>(</span><span>)</span><span>?</span><span>;</span>

        <span>if</span> <span>(</span>current <span>&amp;</span> <span>PDButtons</span><span>::</span>kButtonA<span>)</span> <span>==</span> <span>PDButtons</span><span>::</span>kButtonA <span>{</span>
            <span>let</span> sprite_manager <span>=</span> <span>SpriteManager</span><span>::</span><span>get_mut</span><span>(</span><span>)</span><span>;</span>
            <span>let</span> player_position <span>=</span> <span>self</span><span>.</span>player<span>.</span><span>get_position</span><span>(</span><span>)</span><span>?</span><span>;</span>
            <span>let</span> <span>mut</span> dot <span>=</span> sprite_manager<span>.</span><span>new_sprite</span><span>(</span><span>)</span><span>?</span><span>;</span>
            dot<span>.</span><span>set_image</span><span>(</span><span>self</span><span>.</span>dot_image<span>.</span><span>clone</span><span>(</span><span>)</span><span>,</span> <span>LCDBitmapFlip</span><span>::</span>kBitmapUnflipped<span>)</span><span>?</span><span>;</span>
            dot<span>.</span><span>move_to</span><span>(</span>player_position<span>.0</span><span>,</span> player_position<span>.1</span><span>-</span><span>PLAYER_SPRITE_HEIGHT</span><span>/</span><span>2.0</span><span>)</span><span>?</span><span>;</span>
            dot<span>.</span><span>set_z_index</span><span>(</span><span>5</span><span>)</span><span>?</span><span>;</span>
            dot<span>.</span><span>set_opaque</span><span>(</span><span>true</span><span>)</span><span>?</span><span>;</span>
            dot<span>.</span><span>set_tag</span><span>(</span><span>Dot</span> <span>as</span> <span>u8</span><span>)</span><span>?</span><span>;</span>
            sprite_manager<span>.</span><span>add_sprite</span><span>(</span><span>&amp;</span>dot<span>)</span><span>?</span><span>;</span>
            <span>self</span><span>.</span>dots<span>.</span><span>push</span><span>(</span>dot<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>pushed <span>&amp;</span> <span>PDButtons</span><span>::</span>kButtonB<span>)</span> <span>==</span> <span>PDButtons</span><span>::</span>kButtonB <span>{</span>
            <span>self</span><span>.</span>dots<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

        <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>

    
<span>}</span></code></pre><p>Re-run <code>crank run --release</code> to see your fully functioning game on the simulator!</p><p>And that‚Äôs it!</p><hr/><p>Naturally, this only covers a very small fraction of what‚Äôs actually possible with Playdate and the crankstart crate. Our game doesn‚Äôt even use the crank or do anything with music, so feel free to play around and expand it as you like. You‚Äôre also welcome to contribute enhancements to the crankstart library to enable other Rust developers to build Playdate games. If you do, feel free to <a href="https://news.ycombinator.com/about#say-hi">drop me a note</a> to let me know!</p><ul><li><a href="https://news.ycombinator.com/quick-tip-add-vscode-snippets/">Quick Tip: Add a Snippet to vs Code to Pre-fill Front Matter on Eleventy Sites</a></li></ul></section></div></div>
  </body>
</html>
