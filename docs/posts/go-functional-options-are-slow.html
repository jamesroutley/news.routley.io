<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evanjones.ca/go-functional-options-slow.html">Original</a>
    <h1>Go: Functional Options Are Slow</h1>
    
    <div id="readability-page-1" class="page"><div>

<h3>[ 2022-May-23 10:19 ]</h3>
<p>The Go &#34;functional options&#34; pattern is a way of passing options to a function. The function takes a variable number of arguments, which are themselves functions (a type like <code>...func(*config)</code>. I think it was first introduced by <a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">Rob Pike in a 2014 blog post</a>. It is now used by many APIs. For example, gRPC&#39;s <a href="https://pkg.go.dev/google.golang.org/grpc@v1.45.0#DialContext"><code>DialContext()</code></a>, AWS&#39;s <a href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/config#LoadDefaultConfig"><code>LoadDefaultConfig()</code></a>, and OpenTelemetry&#39;s <a href="https://pkg.go.dev/go.opentelemetry.io/otel/trace#Tracer.Start"><code>Tracer.Start()</code></a>. This style should be avoided when performance is critical. This article describes a microbenchmark that shows functional options are slower, require more instructions, are less likely to be inlined, and may require memory allocations. In the worst case, Go must allocate a slice for the <code>...</code> argument, and an additional object for each option in the slice. Often, the compiler&#39;s escape analysis can optimize these away, but not always. In particular, the compiler can never optimize an interface method call. The alternative is to pass a struct with the configuration values. This does not rely on the compiler to be efficient. In my opinion, performance-critical code should be efficient &#34;by design,&#34; and not rely on compiler optimizations that may or may not apply. This article presents a brief experiment to try and demonstrate the performance differences.</p>


<h2>Functional options versus configuration structs</h2>

<p>The alternative to functional options is passing a configuration struct, like the standard library&#39;s <a href="https://pkg.go.dev/net/http#Server"><code>http.Server</code></a> or <a href="https://pkg.go.dev/crypto/tls#Config"><code>tls.Config</code></a>. To make this concrete, let&#39;s consider a constructor function that creates a type <code>*Foo</code> with two options: a boolean (enabling a feature that is disabled by default), and an integer (taking a numeric value). With functional options, the code would look like the following:</p>

<h3>Functional options creating *Foo</h3>

<pre><code>
func NewFoo(options ...FooOption) *Foo {
  // ... implementation
}

func CallNewFoo() *Foo {
  return NewFoo(WithBoolOption(), WithIntOption(42))
}
</code></pre>

<p>The configuration struct version would look something like the following:</p>

<h3>Configuration struct creating *Foo</h3>

<pre><code>
func NewFooStruct(config FooConfig) *Foo {
  // ... implementation
}

func CallNewFooStruct() *Foo {
  return NewFooStruct(FooConfig{BoolOption: true, IntOption: 42})
}
</code></pre>

<p>While the syntax is different, these two versions do the same thing. I will focus on the performance differences. I wrote a microbenchmark to compare these implementations. The measurements show that functional options are at best around 3 nanoseconds/call slower. When calling through an interface, the functional options are about 5× slower, which increases with the number of parameters. Even worse, the compiler can inline the configuration struct version more aggressively, which makes it even more efficient in some cases. The <a href="https://github.com/evanj/gofuncoptslow">code is on Github</a>.</p>


<h2>Results</h2>

<p>I ran this benchmark on my laptop, with an old and slow Intel Core i7-7Y75 (Kaby Lake) CPU. The table below shows the execution time, number of allocations, and bytes allocated per call. For the configuration struct version, I had to annotate the function with the <code>//go:noinline</code> pragma, since otherwise the compiler inlined the function and basically eliminated the entire benchmark (making no allocations). This shows that while compiler optimizations can reduce the overhead for functional options, those same optimizations can reduce the overhead for configuration structs even more.</p>

<p>For the &#34;direct&#34; call, the overhead of functional options is low: a few extra nanoseconds per call. However, when calling via an interface, the compiler is required to heap allocate the slice argument, so the functional options version is about 5× slower. The difference gets even larger as more options are passed.</p>

<table>
<thead>
<tr><th>Implementation</th><th>ns</th><th>allocations</th><th>bytes allocated</th></tr>
</thead>
<tbody>
<tr><td>Functional options</td><td>38.59</td><td>1</td><td>8</td></tr>
<tr><td>Config struct (inlining disabled)</td><td>34.37</td><td>1</td><td>8</td></tr>
<tr><td>Functional options interface</td><td>159.60</td><td>3</td><td>40</td></tr>
<tr><td>Config struct interface</td><td>38.79</td><td>1</td><td>8</td></tr>
</tbody>
</table>


<h3>Code size in instructions</h3>

<p>To compare the code size, I compiled the two implementations of <code>CallNewFoo</code> and <code>CallNewFooStruct</code> using <code>go test -o out.bin</code>, then disassembled it with <code>go tool objdump -S out &gt; out.asm</code>. The number of instructions and code bytes below show that functional options require more than double the amount of code. This may be the cause for the small performance difference.</p>

<table>
<thead>
<tr><th>Implementation</th><th>Number of instructions</th><th>Code bytes</th></tr>
</thead>
<tbody>
<tr><td>Functional options (func + closure)</td><td>33 + 4 = 37</td><td>154 + 11 = 165</td></tr>
<tr><td>Config struct</td><td>15</td><td>61</td></tr>
</tbody>
</table>


<h2>Conlusion</h2>

<p>In conclusion, configuration structs should be preferred for performance-critical APIs. While the performance can be the same with functional options, it will depend on compiler optimizations (notably inlining and escape analysis). These optimizations cannot be applied when using interfaces. Configuration structs, on the other hand, are still efficient with an interface call.</p>

<p>In most circumstances, this does not matter. Options are most commonly passed in to constructors that are called once at startup, then reused many times. In this case, the performance differences won&#39;t matter, and you should use whatever style you think is best. However, if you are designing an API that will get called often, then these extra allocations and code can add up.</p>


<h2>Subjective reasons to avoid functional options</h2>

<p>Ignoring the performance differences, I think passing configuration structs is slightly better than functional options. For excellent arguments in favor of function options, I recommend Dave Cheney&#39;s <a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">article about why functional arguments make friendly APIs</a>. My stylistic arguments in favor of configuration structs are the following:</p>

<ul>
<li>Simplicity: Functional options requires more code (the <code>FooOption</code> type, and the <code>WithOption</code> functions). Often, the implemention creates a configuration struct anyway. In my opinion, it is simpler to remove this extra layer of indirection, and pass the configuration struct directly.</li>

<li>Documentation/Discoverability: A configuration struct&#39;s fields are a comprehensive list of all options. With functional options, you need to search the package for functions that implement the type. The pkg.go.dev site does a good job of collecting them, but only if you correctly define a custom option type. For example, <a href="https://pkg.go.dev/google.golang.org/grpc#ServerOption"><code>grpc.ServerOption</code></a> shows all the implementations together. However, some APIs do not. For example, AWS&#39;s <a href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/dynamodb#New"><code>dynamodb.New()</code></a> function does not use a custom type definition for its options, so it is not clear where to find the options.</li>

<li>Passing an argument multiple times: How this works with functional options depends on the implementation. It might be an error, the last one might win, or it might &#34;merge&#34; them. With a configuration struct, standard Go semantics for assigning values are used.</li>

<li>Order of evaluation: In rare cases, with functional arguments, the order of evaluation can matter. This happens when an option depends on the value of other options. This can&#39;t happen with configuration structs, where the struct is completely defined before the function is called.</li>

<li>Can&#39;t inspect or modify options outside the package: It is not usually possible for code outside the defining package to get the value inside the <code>WithOption</code> arguments. This can be considered an advantage, since it enforces that only code in the package can accessthe options. However, it also makes it much harder to implement &#34;wrappers&#34; that modify the configuration. For example, I wanted to build a wrapper to help configure gRPC clients. I needed to duplicate all the <code>WithOption</code> functions in my own package.</li>
</ul>

</div></div>
  </body>
</html>
