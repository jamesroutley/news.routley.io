<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.fb.com/2022/09/12/open-source/memlab/">Original</a>
    <h1>MemLab: An open source framework for finding JavaScript memory leaks</h1>
    
    <div id="readability-page-1" class="page"><div>

		<ul>
<li aria-level="1"><span>We’ve open-sourced</span> <span>MemLab</span><span>, a JavaScript memory testing framework that automates memory leak detection.</span></li>
<li aria-level="1"><span>F</span><span>inding and addressing the root cause of memory leaks is important for delivering a quality user experience on web applications.</span></li>
<li aria-level="1"><span>MemLab has helped engineers and developers at Meta improve user experience and make significant improvements in memory optimization. We hope it will do the same for the larger JavaScript community as well.</span></li>
</ul>
<p><span>In 2020, we</span><a href="https://engineering.fb.com/2020/05/08/web/facebook-redesign/" target="_blank" rel="noopener"> <span>redesigned Facebook.com</span></a><span> as a single-page application (SPA) that does most of its rendering and navigation using client-side JavaScript. We used a similar architecture to build most of Meta’s other popular web apps, including Instagram and Workplace. And while this architecture allows us to provide faster user interactions, a better developer experience, and a more app-like feel, maintaining the web app state on the client makes effectively managing client-side memory more complex.</span></p>
<p><span>People using our web apps will often notice performance and functional correctness issues immediately. A memory leak, however, is a different story. It isn’t immediately perceivable, because it eats up a chunk of memory at a time — affecting the entire web session and making subsequent interactions slower and less responsive.</span></p>
<p><span>To help our developers address this, we built</span><a href="https://facebookincubator.github.io/memlab/" target="_blank" rel="noopener"> <span>MemLab</span></a><span>, a JavaScript memory testing framework that automates leak detection and makes it easier to root-cause memory leaks. We’ve used MemLab at Meta to successfully contain unsustainable memory increases and identify memory leaks and memory optimization opportunities across our products and infra.</span></p>
<p><span>We’ve already</span><a href="https://github.com/facebookincubator/memlab" target="_blank" rel="noopener"> <span>open-sourced MemLab on GitHub</span></a><span>, and we’re excited to work with the JavaScript community and have developers start using MemLab today.</span></p>
<h2><span>Why we developed MemLab</span></h2>
<p><span>Historically, we spent a lot of time</span><a href="https://engineering.fb.com/2020/03/05/developer-tools/incident-tracker/"> <span>measuring, optimizing, and controlling page load and interaction time</span></a><span>, as well as JavaScript code size. We built automated systems that alerted us when there were regressions in these metrics — both before and after code landed in production — so that we could act quickly to fix these issues and prevent the changes from ever landing in production.</span></p>
<p><span>Comparatively, we hadn’t done much work for managing web in-browser memory. And when we analyzed the new Facebook.com’s memory usage, we found that both memory usage and the number of out-of-memory (OOM) crashes on the client side had been climbing.</span></p>
<p><span>High memory usage has a statistically significant and negative impact on:</span></p>
<ul>
<li aria-level="1"><span>Page load and interaction performance (how much time it takes to load a page or perform an interaction)</span></li>
<li aria-level="1"><span>User engagement metrics (active users, time spent on site, number of activities performed)</span></li>
</ul>
<h2><span>What causes high memory usage in web applications?</span></h2>
<p><span>Because memory leaks aren’t usually obvious, they seldom get caught in code review, are hard to spot during development, and are often difficult to root-cause in production. But mainstream JavaScript runtimes all have garbage collectors, so how is memory leaking in the first place?</span></p>
<p><span>JavaScript code can experience memory leaks by keeping hidden references to objects. Hidden references can cause memory leaks in many unexpected ways.</span></p>
<p><span>For example:</span></p>
<pre><code>var obj = {};
console.log(obj);
obj = null;
</code></pre>
<p><span>In Chrome, this code leaks </span><span>obj </span><span>even though we set the reference to </span><span>null</span><span>. This happens because Chrome needs to keep an internal reference to the printed object so that it can be inspected in the web console later (even if the web console is not opened).</span></p>
<p><span>There can also be cases where memory is not technically leaked but grows linearly and unbounded during a user session. The most common causes of this are client-side caches that don’t have any eviction logic built in and infinite scroll lists that don’t have any virtualization to remove earlier items from the list as new content is added.</span></p>
<p><span>We also didn’t have automated systems and processes in place to control memory, so the only defense against regressions was experts periodically digging into memory leaks via Chrome DevTools, which was not scalable considering we’re shipping a nontrivial number of changes every day.</span></p>
<h2><span>How MemLab works</span></h2>
<p><span>In a nutshell, MemLab finds memory leaks by running a headless browser through predefined test scenarios and diffing and analyzing the JavaScript heap snapshots.</span></p>
<p><span>This process happens in six steps:</span></p>
<h3><span>1. Browser interaction</span></h3>
<p><span>To find leaked objects on a target page (B). MemLab automates a browser using Puppeteer and visits the test pages in the following order:</span></p>
<ol>
<li aria-level="1"><span>Navigate to a different tab (A) and get heap SA.</span></li>
<li aria-level="1"><span>Navigate to the target page (B) and get heap SB.</span></li>
<li aria-level="1"><span>Come back to the previous page (A’) and get heap SA’.</span></li>
</ol>
<p><img src="https://engineering.fb.com/wp-content/uploads/2022/08/Figure-1-TEST.gif?w=1024" alt="" width="1024" height="495"/></p>
<h3><span>2. Diffing the heap </span></h3>
<p><span>When we navigate to a page and then navigate away from it, we would expect most of the memory allocated by that page to also be freed — if not, it is highly suggestive of a memory leak. MemLab finds potential memory leaks by diffing the JavaScript heap and recording the set of objects allocated on page B that weren’t allocated on Page A but are still present when Page A is reloaded. Or, more formally, the superset of objects leaked from the target page can be derived as</span><span> (SB \ SA) ∩ SA’ ).</span></p>
<h3><span>3. Refining the list of memory leaks</span></h3>
<p><span>The leak detector further incorporates framework-specific knowledge to refine the list of leaked objects. For example, Fiber nodes allocated by React (an inner data structure React uses for rendering the virtual DOM) should be released when we clean up after visiting multiple tabs.</span></p>
<h3><span>4. Generating retainer traces</span></h3>
<p><span>MemLab traverses the heap and generates retainer traces for each leaked object. A retainer trace is an object reference chain from the GC roots (the entry objects in a heap graph from which garbage collectors traverse the heap) to a leaked object. The trace shows why and how a leaked object is kept alive in memory. Breaking the reference chain means the leaked object will no longer be reachable from the GC root and therefore can be garbage collected. By following the retainer trace one step at a time, you can find the reference that should be set to null (but wasn’t, due to a bug).</span></p>
<h3><span>5. Clustering retainer traces</span></h3>
<p><span>Sometimes certain interactions can trigger thousands of leaked objects. It would be overwhelming to show all the retainer traces in this case. MemLab clusters all retainer traces and shows one trace for each cluster of leaked objects that share similar retainer traces. The trace also includes debug information, such as</span><a href="https://developer.chrome.com/docs/devtools/memory-problems/memory-101/" target="_blank" rel="noopener"> <span>dominator nodes and retained sizes</span></a><span>.</span></p>
<h3><span>6. Reporting the leaks</span></h3>
<p><span>We run MemLab at regular intervals throughout the day to get a continuous signal on memory regressions. Any new regressions are added to an internal dashboard, where clustered retainer traces of all memory leaks detected are gathered and categorized. Developers can then click and view the properties of objects on the retainer trace of each memory leak.</span></p>
<p><span>(Note: This dashboard is not part of the open source release of MemLab, but something similar could be added to any CI/CD pipeline.)</span></p>
<h2><span>MemLab’s features</span></h2>
<h3><span>Memory leak detection</span></h3>
<p><span>For in-browser memory leak detection, the only input MemLab requires from developers is</span><a href="https://facebookincubator.github.io/memlab/docs/api/interfaces/core_src.IScenario" target="_blank" rel="noopener"> <span>a test scenario file</span></a><span> that</span><a href="https://facebookincubator.github.io/memlab/docs/getting-started" target="_blank" rel="noopener"> <span>defines how to interact with the webpage by overriding three callbacks</span></a><span> with the Puppeteer API and CSS selectors. MemLab automatically diffs the JavaScript heap, refines memory leaks, and aggregates results.</span></p>
<p><img loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-figure-2-FINAL.gif?w=1024" alt="" width="1024" height="592"/></p>
<h3><span>Graph-view API of JavaScript heap</span></h3>
<p><span>MemLab supports a</span><a href="https://facebookincubator.github.io/memlab/docs/api/interfaces/core_src.ILeakFilter/" target="_blank" rel="noopener"> <span>self-defined leak detector as a filter callback</span></a><span> that is applied to each leak candidate object allocated by the target interaction but never released afterwards. The leak filter callback can traverse the heap and decide which objects are memory leaks. As an example, our built-in leak detector follows the return chain of a React Fiber node and checks if the Fiber node is detached from the React Fiber tree.</span></p>
<p><img loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-1.png?w=1024" alt="MemLab" width="1024" height="602" srcset="https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-1.png 1724w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-1.png?resize=916,539 916w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-1.png?resize=768,452 768w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-1.png?resize=1024,602 1024w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-1.png?resize=1536,903 1536w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-1.png?resize=96,56 96w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-1.png?resize=192,113 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>To allow the context of each candidate leak to be analyzed, MemLab provides a memory-efficient graph view of the JavaScript heap. This enables querying and traversing the JavaScript heap without having any domain knowledge about V8’s heap snapshot file structure.</span></p>
<p><span>In the graph view, each JavaScript object or native object in the heap is a graph node, and each JavaScript reference in the heap is a graph edge. The heap size of a real application is often large, so the graph view needs to be memory-efficient while providing an intuitive object-oriented heap-traversal API. Therefore, the graph nodes are designed to be virtual and not interconnected through JavaScript references. When the analysis code traverses the heap, the virtual graph view partially constructs the touched section of the graph just-in-time. Any part of the graph can be easily deallocated since those virtual nodes do not have JavaScript references to each other.</span></p>
<p><span>The heap graph view can be loaded from JavaScript heap snapshots taken from Chromium-based browsers, Node.js, Electron, and</span><a href="https://hermesengine.dev/"> <span>Hermes</span></a><span>. This allows for complex patterns to be analyzed and answers questions such as, “How many React Fiber nodes are alternate Fiber nodes, which are used in  incomplete concurrent renders?” or “What is the total retained size of unmounted react components?”.</span></p>
<pre><code>import {getHeapFromFile} from &#39;@memlab/heap-analysis&#39;;
const heapGraph = await getHeapFromFile(heapFile);
heapGraph.nodes.forEach(node =&gt; {
  // heap node traversal
  node.type
  node.references
);
</code></pre>
<h3><span>Memory assertions</span></h3>
<p><span>A Node.js program or</span><a href="https://jestjs.io/"> <span>Jest</span></a><span> test can also use the graph-view API to get a heap graph view of its own state, to do self-memory checking, and</span><a href="https://facebookincubator.github.io/memlab/docs/api/interfaces/core_src.IHeapSnapshot/#hasobjectwithtagtag" target="_blank" rel="noopener"> <span>write all kinds of memory assertions</span></a><span>.</span></p>
<pre><code>import type {IHeapSnapshot} from &#39;@memlab/core&#39;;
import {config, takeNodeMinimalHeap, tagObject} from &#39;@memlab/core&#39;;

test(&#39;memory test&#39;, async () =&gt; {
  config.muteConsole = true;
  const o1 = {};
  let o2 = {};

  // tag o1 with marker: &#34;memlab-mark-1&#34;, does not modify o1 in any way
  tagObject(o1, &#39;memlab-mark-1&#39;);
  // tag o2 with marker: &#34;memlab-mark-2&#34;, does not modify o2 in any way
  tagObject(o2, &#39;memlab-mark-2&#39;);

  o2 = null;

  const heap: IHeapSnapshot = await takeNodeMinimalHeap();

  // expect object with marker &#34;memlab-mark-1&#34; exists
  expect(heap.hasObjectWithTag(&#39;memlab-mark-1&#39;)).toBe(true);

  // expect object with marker &#34;memlab-mark-2&#34; can be GCed
  expect(heap.hasObjectWithTag(&#39;memlab-mark-2&#39;)).toBe(false);

}, 30000);
</code></pre>
<h3><span>Memory toolbox</span></h3>
<p><span>In addition to memory leak detection, MemLab includes a set of built-in</span><a href="https://facebookincubator.github.io/memlab/docs/cli/CLI-commands#memlab-analyze" target="_blank" rel="noopener"> <span>CLI commands</span></a><span> and</span><a href="https://facebookincubator.github.io/memlab/docs/api/classes/heap_analysis_src.BaseAnalysis" target="_blank" rel="noopener"><span> APIs</span></a><span> for finding memory optimization opportunities:</span></p>
<ul>
<li aria-level="1"><a href="https://facebookincubator.github.io/memlab/docs/cli/CLI-commands#memlab-analyze-shape" target="_blank" rel="noopener"><span>Break down heap by object shapes</span></a><span> (e.g., </span><i><span>{arguments, postRun, preRun, quite, thisProgram, …}</span></i><span>) instead of classifying objects based on constructor names (e.g., Object). This is useful to quickly detect and root-cause significant memory used by object literals.</span></li>
<li aria-level="1"><a href="https://facebookincubator.github.io/memlab/docs/cli/CLI-commands#memlab-analyze-unbound-object" target="_blank" rel="noopener"><span>Detect continuous individual object growth</span></a><span> or </span><a href="https://facebookincubator.github.io/memlab/docs/cli/CLI-commands#memlab-analyze-unbound-shape" target="_blank" rel="noopener"><span>object shape growth</span></a><span>. MemLab can take a series of heap snapshots as input and find which object or class of objects keeps growing in size over time.</span></li>
<li aria-level="1"><a href="https://facebookincubator.github.io/memlab/docs/cli/CLI-commands#memlab-analyze-string"><span>Find duplicate string instances</span></a><span>. V8 does not always do string interning optimization, which means two JavaScript string primitives with the same value could be represented by two different native objects in V8’s heap.</span></li>
</ul>
<figure id="attachment_19237" aria-describedby="caption-attachment-19237"><img loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-2.png?w=1024" alt="" width="1024" height="498" srcset="https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-2.png 1999w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-2.png?resize=916,445 916w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-2.png?resize=768,373 768w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-2.png?resize=1024,498 1024w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-2.png?resize=1536,747 1536w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-2.png?resize=96,47 96w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-2.png?resize=192,93 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19237">Internal UI for browsing memory leaks. (mockup, for illustration purposes only)</figcaption></figure>
<figure id="attachment_19238" aria-describedby="caption-attachment-19238"><img loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-3.png?w=1024" alt="MemLab" width="1024" height="540" srcset="https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-3.png 1999w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-3.png?resize=916,483 916w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-3.png?resize=768,405 768w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-3.png?resize=1024,540 1024w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-3.png?resize=1536,811 1536w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-3.png?resize=96,51 96w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-3.png?resize=192,101 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19238">Internal UI for diagnosing memory leak traces. (mockup, for illustration purposes only)</figcaption></figure>
<h2><span>Using MemLab at Meta: Case studies </span></h2>
<p><span>Over the past few years, we’ve used MemLab to detect and diagnose memory leaks and have gathered insights that have helped us optimize memory, significantly improve memory and reliability (reducing OOM crashes), and improve user experience.</span></p>
<figure id="attachment_19239" aria-describedby="caption-attachment-19239"><img loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-4.png?w=1024" alt="MemLab OOM crashes reduction" width="1024" height="484" srcset="https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-4.png 1618w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-4.png?resize=916,433 916w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-4.png?resize=768,363 768w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-4.png?resize=1024,484 1024w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-4.png?resize=1536,725 1536w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-4.png?resize=96,45 96w, https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-image-4.png?resize=192,91 192w" sizes="(max-width: 992px) 100vw, 62vw"/><figcaption id="caption-attachment-19239">We reduced OOM crashes on Facebook.com by 50 percent in the first half of 2021.</figcaption></figure>
<h3><span>React Fiber node cleanup</span></h3>
<p><span>For rendered components, React builds a Fiber tree — an inner data structure React uses for rendering the virtual DOM. Although the Fiber tree looks like a tree, it is a bidirectional graph that strongly connects all Fiber nodes, React component instances, and the associated HTML DOM elements. Ideally, React maintains references to the root of the component’s Fiber tree and keeps the Fiber tree from being garbage collected. When a component is unmounted, React breaks the connection between the host root of the component and the rest of the Fiber tree, which can then be garbage collected.</span></p>
<p><span>The downside of having a strongly connected graph is that if there is any outside reference pointing to any part of the graph, the whole graph cannot be garbage collected. For example, the following export statement caches React components at the module scope level, so the associated Fiber tree and detached DOM elements are never released.</span></p>
<pre><code><strong>export</strong> const Component = (( 
  &lt;List&gt; ... &lt;/List&gt; 
): React.Element&lt;typeof List&gt;);</code></pre>
<p>It’s also not just the React data structures that would be kept alive. Hooks and their closures can also keep alive all kinds of other objects. This means that a single React component leak could cause the leak of a significant part of a page’s objects, leading to huge memory leaks.</p>
<p><img loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/08/MemLab-figure-3-FINAL.gif?w=1024" alt="" width="1024" height="608"/></p>
<p><span>To prevent the cascading effect of memory leaks in the Fiber tree,</span><a href="https://github.com/facebook/react/pull/21039" target="_blank" rel="noopener"> <span>we added a full traversal of a tree that does aggressive cleanup</span></a><span> when a component is unmounted in React 18 (thanks to Benoit Girard and the React team). This allows the garbage collector to do a better job at cleaning up an unmounted tree. Any accidental memory leak is bounded to a smaller leak size. This fix reduced average memory usage on Facebook by almost 25 percent, and we saw large improvements across other sites using React when they upgraded. We were worried that this aggressive cleanup could slow down unmounting in React, but surprisingly, we saw a significant performance win because of memory reductions.</span></p>
<h3><span>Relay string interning</span></h3>
<p><span>By leveraging the heap analysis APIs in MemLab, we found that strings occupied 70 percent of the heap, and half of those strings had at least one duplicated instance. (V8 doesn’t always do string interning, which is an optimization that deduplicates string instances with the same value.)</span></p>
<p><span>When we further queried duplicated string patterns and clustering retainer traces we found that a significant portion of string memory is consumed by cached key strings in Relay. Relay generates cached keys for fragments by doing duplication, serialization, and concatenation. The string keys are further copied and concatenated for cached keys of other resources (e.g., fragments) in Relay. By collaborating with the Relay and React Apps teams, we optimized Relay cache key strings by interning and shortening overlong string keys on the client side.</span></p>
<p><span>This optimization enabled Relay to cache more data, allowing the site to show more content to users, especially when there is limited RAM on the client side. We observed a 20 percent reduction in memory p99 as well as OOM crashes, faster page rendering, improved user experience, and revenue wins.</span></p>
<h2><span>Try MemLab today</span></h2>
<p><span>We’re excited to open-source MemLab and have developers start using it. We are especially interested in seeing which use cases the community finds useful.</span></p>
<p><span>You can install MemLab through</span><a href="https://www.npmjs.com/package/memlab"> <span>npm</span></a><span> or build it from the</span><a href="https://github.com/facebookincubator/memlab" target="_blank" rel="noopener"> <span>GitHub repo</span></a><span>:</span></p>
<p><span>npm i -g memlab</span></p>
<p><span>We also have a </span><a href="https://facebookincubator.github.io/memlab/docs/getting-started" target="_blank" rel="noopener"><span>quick start guide</span></a><span> to help developers get started.</span></p>
<p><span>If you’ve tried MemLab out on your own project, please </span><a href="https://github.com/facebookincubator/memlab/issues" target="_blank" rel="noopener"><span>reach out</span></a><span> and let us know how it worked for you!</span></p>
<h2>Acknowledgements</h2>
<p><i><span>We’d like to thank Tulga Narmandakh and the rest of the Core Health Experience team for their contributions toward helping open-source MemLab.</span></i></p>

		
	</div></div>
  </body>
</html>
