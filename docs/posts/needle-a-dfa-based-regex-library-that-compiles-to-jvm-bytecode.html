<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justinblank.com/experiments/needle.html">Original</a>
    <h1>Needle: A DFA Based Regex Library That Compiles to JVM ByteCode</h1>
    
    <div id="readability-page-1" class="page"><article>
      
      <p>Many years ago, Kragen <a href="https://gist.github.com/kragen/bf0ad9ded9843082e7f8">complained
      about the implementation and performance of Java regexes</a>,
      and suggested that an implementation that emitted JVM
      bytecode could perform better. It&#39;s been a minute, but I&#39;m
      happy to report that complaining on the Internet has served
      its purpose.</p>
      <p>Today, I&#39;m releasing the 0.0.1 version of <a href="https://github.com/hyperpape/needle">needle</a>, a library
      that compiles regular expressions to JVM bytecode. It
      compiles each regular expression to a Deterministic Finite
      Automaton (DFA), which is then compiled to a Java class. The
      code analyzes the DFA to extract information that helps match
      more efficiently. It detects required prefixes, suffixes and
      infixes that can be found using <code>String.indexOf</code>,
      as well as cases where the first character can be easily
      tested in a while loop (e.g. <code>[Ss]</code>). This lets
      the class spend less time inside the DFA automaton, and more
      in a fast loop.</p>
      <h2 id="benchmarks">Benchmarks</h2>
      <p>Regex performance resists concise summarization, and the
      design of needle makes this even more true. For instance, one
      optimization computes the minimum and maximum length of a
      match, and uses that to bail out early when a match is not
      possible. This effect will show up when testing that an
      entire string matches a regex, or when searching in a
      sufficiently small string, but won&#39;t show up when finding
      substrings that match inside of a large string.</p>
      <p>I&#39;ve written a number of benchmarks, covering many
      different cases, but need to write code to repeatably report
      and compare results. In the meantime, I&#39;ve included the
      results for one specific benchmark (<a href="https://github.com/hyperpape/needle-benchmarks/blob/main/src/main/java/com/justinblank/strings/SherlockBenchmark.java">SherlockBenchmark</a>).</p>
      <p>For each regex, we search the Project Gutenberg edition of
      The Adventures of Sherlock Holmes, finding all matches for
      the pattern. For each regex, we compare the Java standard
      library, Needle, and the <a href="https://github.com/cs-au-dk/dk.brics.automaton">brics
      automaton library</a>, which is an efficient DFA
      implementation.</p>
      <p>There are three categories of patterns in the test:</p>
      <h3 id="literals">Literals</h3>
      <p>These patterns have no repetition or meta-characters, and
      could be found using <code>String.indexOf</code>. Needle
      recognizes the literal, and includes a call to
      <code>String.indexOf</code>. The standard library is still
      significantly slower, but does surprisingly well on
      these.</p>
      <p>Of course, doing well on these strings is not necessarily
      that interesting--unless there&#39;s a level of indirection, you
      could just replace the regex use with a
      <code>String.indexOf</code>.</p>
      <ol>
        <li><code>Sherlock</code></li>
        <li><code>Adler</code></li>
        <li><code>zqj</code></li>
        <li><code>aqj</code></li>
        <li><code>let us hear a true</code></li>
      </ol>
      <p>These results include the time it takes to use
      <code>String.indexOf</code> in a loop. Subsequent graphs
      don&#39;t, because it no longer makes sense as a comparison.</p>
      <p><img src="https://justinblank.com/static/literals.png"/></p>
      <h3 id="substringinitial-character-searches">
      Substring/Initial Character Searches</h3>
      <p>These patterns are not literals, but have literal
      components that let us narrow the search space by using
      <code>String.indexOf</code>.</p>
      <ol>
        <li><code>[Ss]herlock</code></li>
        <li><code>anywhere|somewhere</code></li>
        <li>
        <code>Holmes.{0,25}Watson|Watson.{0,25}Holmes</code></li>
        <li><code>the\s\w{1,20}\s\agency</code></li>
        <li><code>Sherlock\s\w{1,20}ed</code></li>
        <li><code>Sherlock|Street</code></li>
        <li><code>the\s+\w+</code></li>
        <li><code>[a-zA-Z]+ing</code></li>
        <li><code>\s[a-zA-Z]{0,12}ing\s</code></li>
        <li><code>[a-z][a-e]{6}z</code></li>
      </ol>
      <p><img src="https://justinblank.com/static/infixes.png"/></p>
      <h3 id="everything-else">Everything Else</h3>
      <p>These patterns have no substring to search for using
      <code>String.indexOf</code> so the matching is done entirely
      by the automaton.</p>
      <ol>
        <li><code>Sherlock|Holmes</code></li>
        <li>
        <code>Sherlock|Holmes|Watson|Irene|Adler|John|Baker</code></li>
        <li><code>([Ss]herlock)|([Hh]olmes)</code></li>
        <li><code>Adler|Watson</code></li>
      </ol>
      <p><img src="https://justinblank.com/static/standard.png"/></p>
      <p>Needle is slower than brics on these patterns, but still
      much faster than the standard library. This is because the
      core loop of the needle automaton is slower than the brics
      automaton. When we have a usable substring for searching, the
      performance of the regex is dominated by the speed of
      searching for that substring, and the automata speed is less
      important. But when there is no substring, brics wins.</p>
      <p>There are two things that I&#39;d like to do here. First, we
      can probably expand the cases where we do a fast loop
      searching for the initial character of our regex (or extend
      the search to non-initial characters). Looking at the cases
      above, we have various facts about the initial character (it
      must be uppercase, it&#39;s one of four characters, etc). Some of
      these predicates should allow us to emit a call that
      efficiently checks if they&#39;re true.</p>
      <p>Second, for the remaining regexes, that do not allow using
      a fast initial loop, I&#39;ll have to change the generated code
      to match or exceed the performance of brics. I don&#39;t have a
      plan, but structurally, it has to be possible. Since we can
      compile each regex to an independent set of code, we could in
      principle just output a loop with the same structure as the
      brics automaton. It&#39;s unlikely that&#39;s the best approach, but
      it implies that there&#39;s no structural reason needle couldn&#39;t
      match any competitor&#39;s performance. The only constraint is
      how much complexity we can handle in compiling different
      regexes.</p>
    </article></div>
  </body>
</html>
