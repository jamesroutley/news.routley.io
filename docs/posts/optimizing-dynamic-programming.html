<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.cyang.page/blog/optimized_dp">Original</a>
    <h1>Optimizing Dynamic Programming</h1>
    
    <div id="readability-page-1" class="page"><div lang="en">
    <header>
        
        <h3>oh stars, that was fast…</h3>
        
    </header>
    
<p>
If you are familiar with competitive programming, this is very likely <strong>NOT</strong> going be anything new to you.</p>

<p>
For DP problems asking for number of ways to accomplish something,</p>
<ol>
<li>do naive recursive approach first</li>
<li>add cache</li>
<li>make it bottom-up iterative</li>
<li>make it into state transition matrix</li>
<li>matrix mutiplication of state transition matrix to calculate num of possible paths</li>
<li>use matrix binary exponentiation for matrix mutiplication</li>
</ol>
<p>If you understand what the above steps mean, maybe <strong>NOT</strong> waste your time continue reading.</p>

<p>
Whenever I thought about Dynamic Programming, I always think of it as <code>Recursion + Memorization</code>, this is true, but I recently learned ways to make it much much better.</p>
<p>
With some good folks here in <a href="https://www.recurse.com/scout/click?t=20cccbfea0852a9738b0c4d200b1a091">Recurse Center</a>, we got together to looking into competitive programming problems for fun, specifically those from <a href="https://cses.fi/">CSES</a>. We often run into problems that requires using Dynamic Programming, asking for possible ways to get somewhere or do something. Usually naive approach just using recursion and memorization was always too slow and using too many function callstacks.</p>
<p>
It can be much further optimized, I am surprised I am only learning this now tbh, oh well… never too late.</p>

<p>
In DP (Dynamic Programming), we often come across the structure,</p>
<ul>
<li>The problem wants us to find some value (number of ways to get somewhere for example) at <code>P(n)</code>, where <code>n</code> can go from <code>0 to N</code></li>
<li>The program gives us a relation <code>Next</code> to describe how to construct <code>P(n)</code> from <code>P(n-1)</code> i.e. <code>P(n) := Next(P(n-1))</code></li>
<li>We know the values for the base levels, <code>P(0)</code> and <code>P(1)</code>, in most cases.</li>
</ul>
<p>It’s intuitive to write this recursively, In <strong>fantasy Golang</strong>, something like this,</p>
<div>
<div>
<pre><code><span><span>  <span>func</span> <span>Next</span><span>(</span><span>prevVal</span><span>:</span> <span>int</span><span>)</span> <span>int</span> <span>{</span>
</span></span><span><span>          <span>...</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>func</span> <span>P</span><span>(</span><span>n</span><span>:</span> <span>int</span><span>)</span> <span>int</span> <span>{</span>
</span></span><span><span>          <span>if</span> <span>n</span> <span>==</span> <span>0</span> <span>{</span>
</span></span><span><span>                  <span>return</span> <span>some_value_we_figure_out_by_hand</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>if</span> <span>n</span> <span>==</span> <span>1</span> <span>{</span>
</span></span><span><span>                  <span>return</span> <span>some_other_value_we_figure_out_by_hand</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>return</span> <span>Next</span><span>(</span><span>P</span><span>(</span><span>n</span><span>-</span><span>1</span><span>))</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>func</span> <span>main</span><span>()</span> <span>int</span> <span>{</span>
</span></span><span><span>          <span>return</span> <span>P</span><span>(</span><span>N</span><span>)</span>
</span></span><span><span>  <span>}</span></span></span></code></pre>
</div>
</div>
<p>
And if the problem requires the recursion callstack to be an <code>DAG</code> rather than linear, it’s possible that it goes thru the same <code>callstack path</code> multiple times, say if <code>Next</code> is defined as <code>P(n) := Next(P(n-1), P(n-2))</code>, <code>P(n-1)</code> and <code>P(n-2)</code> will share many duplicate calculations.</p>
<p>
In recusion, what we are doing is very much like repeatedly asking the computer to <strong>give us values from the previous levels that we need to build up to this level</strong>.</p>
<div>
<div>
<pre><code><span><span>  <span>func</span> <span>Next</span><span>(</span><span>prevVal</span><span>:</span> <span>int</span><span>,</span> <span>twoBefore</span><span>:</span> <span>int</span><span>)</span> <span>int</span> <span>{</span>
</span></span><span><span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>func</span> <span>P</span><span>(</span><span>n</span><span>:</span> <span>int</span><span>)</span> <span>int</span> <span>{</span>
</span></span><span><span>          <span>if</span> <span>n</span> <span>==</span> <span>0</span> <span>{</span>
</span></span><span><span>                  <span>return</span> <span>some_value_we_figure_out_by_hand</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>if</span> <span>n</span> <span>==</span> <span>1</span> <span>{</span>
</span></span><span><span>                  <span>return</span> <span>some_other_value_we_figure_out_by_hand</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>return</span> <span>Next</span><span>(</span><span>P</span><span>(</span><span>n</span><span>-</span><span>1</span><span>),</span> <span>P</span><span>(</span><span>n</span><span>-</span><span>2</span><span>))</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>func</span> <span>main</span><span>()</span> <span>int</span> <span>{</span>
</span></span><span><span>          <span>return</span> <span>P</span><span>(</span><span>N</span><span>)</span>
</span></span><span><span>  <span>}</span></span></span></code></pre>
</div>
</div>
<p>
We can/must avoid the duplicate computation via memorization, i.e. caching</p>
<div>
<div>
<pre><code><span><span>  <span>cache</span> <span>:=</span> <span>make</span><span>(</span><span>map</span><span>[</span><span>int</span><span>]</span><span>int</span><span>)</span>
</span></span><span><span>
</span></span><span><span>  <span>cache</span><span>[</span><span>0</span><span>]</span> <span>:=</span> <span>some_value_we_figure_out_by_hand</span>
</span></span><span><span>  <span>cache</span><span>[</span><span>1</span><span>]</span> <span>:=</span> <span>some_other_value_we_figure_out_by_hand</span>
</span></span><span><span>
</span></span><span><span>  <span>func</span> <span>Next</span><span>(</span><span>prevVal</span><span>:</span> <span>int</span><span>,</span> <span>twoBefore</span><span>:</span> <span>int</span><span>)</span> <span>int</span> <span>{</span>
</span></span><span><span>      <span>...</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>func</span> <span>P</span><span>(</span><span>n</span><span>:</span> <span>int</span><span>)</span> <span>int</span> <span>{</span>
</span></span><span><span>
</span></span><span><span>          <span>var</span> <span>v1</span> <span>int</span>
</span></span><span><span>          <span>if</span> <span>v1</span><span>,</span> <span>exists</span> <span>:=</span> <span>cache</span><span>[</span><span>n</span><span>-</span><span>1</span><span>];</span> <span>!</span><span>exist</span> <span>{</span>
</span></span><span><span>                  <span>v1</span> <span>:=</span> <span>P</span><span>(</span><span>n</span><span>-</span><span>1</span><span>)</span>
</span></span><span><span>                  <span>cache</span><span>[</span><span>n</span><span>-</span><span>1</span><span>]</span> <span>:=</span> <span>v1</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>var</span> <span>v2</span> <span>int</span>
</span></span><span><span>          <span>if</span> <span>v2</span><span>,</span> <span>exists</span> <span>:=</span> <span>cache</span><span>[</span><span>n</span><span>-</span><span>2</span><span>];</span> <span>!</span><span>exist</span> <span>{</span>
</span></span><span><span>                  <span>v2</span> <span>:=</span> <span>P</span><span>(</span><span>n</span><span>-</span><span>2</span><span>)</span>
</span></span><span><span>                  <span>cache</span><span>[</span><span>n</span><span>-</span><span>2</span><span>]</span> <span>:=</span> <span>v2</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>return</span> <span>Next</span><span>(</span><span>v1</span><span>,</span> <span>v2</span><span>)</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>func</span> <span>main</span><span>()</span> <span>int</span> <span>{</span>
</span></span><span><span>          <span>return</span> <span>P</span><span>(</span><span>N</span><span>)</span>
</span></span><span><span>  <span>}</span></span></span></code></pre>
</div>
</div>
<p>
<strong>This is the DP I knew.</strong></p>

<p>
First thing to optimize would be using too many recusive function callstack. When solving large problems, I find it often to be the first thing that breaks down when using naive approach. We can solve this by converting our recursive approach to iterative.</p>
<p>
<strong>Impotant: I find it always helpful for me to have the naive recursive approach first, it helps my lazy brain to passively get familiar with the incremental relations between n.</strong></p>
<p>
The mental reminder I use when doing this is: <strong>reverse top down from recursive approach bottom up, build what’s needed first</strong></p>
<p>
If we look at our recursive approach, what we are doing is repeatedly asking the computer to <strong>give us the previous levels we need to build up to this level</strong>. With that intuition to contruct each level, we can rephrase the description a bit by <strong>making the base levels first, and then build our solution bottom up.</strong></p>
<p>
Still with <code>P(n) := Next(P(n-1), P(n-2))</code>, instead of start by asking for <code>P(N)</code>, we start from <code>P(0)</code> and build up to <code>P(N)</code>, notice that we still want to <strong>keep our cache</strong>,</p>
<div>
<div>
<pre><code><span><span>  <span>cache</span> <span>:=</span> <span>make</span><span>(</span><span>map</span><span>[</span><span>int</span><span>]</span><span>int</span><span>)</span>
</span></span><span><span>
</span></span><span><span>  <span>cache</span><span>[</span><span>0</span><span>]</span> <span>:=</span> <span>some_value_we_figure_out_by_hand</span>
</span></span><span><span>  <span>cache</span><span>[</span><span>1</span><span>]</span> <span>:=</span> <span>some_other_value_we_figure_out_by_hand</span>
</span></span><span><span>
</span></span><span><span>  <span>func</span> <span>Next</span><span>(</span><span>prevVal</span><span>:</span> <span>int</span><span>,</span> <span>twoBefore</span><span>:</span> <span>int</span><span>)</span> <span>int</span> <span>{</span>
</span></span><span><span>      <span>...</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>func</span> <span>main</span><span>()</span> <span>int</span> <span>{</span>
</span></span><span><span>          <span>for</span> <span>i</span><span>:</span> <span>=</span> <span>2</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>N</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
</span></span><span><span>                  <span>cache</span><span>[</span><span>i</span><span>]</span> <span>:=</span> <span>Next</span><span>(</span><span>cache</span><span>[</span><span>n</span><span>-</span><span>1</span><span>],</span> <span>cache</span><span>[</span><span>n</span><span>-</span><span>2</span><span>])</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>return</span> <span>cache</span><span>[</span><span>N</span><span>]</span>
</span></span><span><span>  <span>}</span></span></span></code></pre>
</div>
</div>

<p>
Say if we have a problem wanting us to answer the number of ways to get from point A to point B, the transition matrix would be something like an <a href="https://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a>, describing our possible location given our current location.</p>
<p>
State transition matrix is a way to describe <strong>for every possible current state, its possible next state(s) after one step</strong>.</p>
<p>
Something like,</p>
<div>
<div>
<pre><code><span><span>    <span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>            <span>graph</span> <span>:=</span> <span>[][]</span><span>int</span><span>{</span>
</span></span><span><span>                    <span>{</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>},</span>
</span></span><span><span>                    <span>{</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>},</span>
</span></span><span><span>                    <span>{</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>},</span>
</span></span><span><span>                    <span>{</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>}</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>
</span></span><span><span>            <span>// graph[i][j] would be the possiblilty</span>
</span></span><span><span>            <span>// to go from point i to point j</span>
</span></span><span><span>
</span></span><span><span>            <span>start</span> <span>:=</span> <span>2</span>
</span></span><span><span>            <span>end</span> <span>:=</span> <span>3</span>
</span></span><span><span>    <span>}</span></span></span></code></pre>
</div>
</div>

<p>
If we were to check our possible locations after a single step, what we could do using the transition matrix is to just find the indices where the values that’s one at row[start].</p>
<div>
<div>
<pre><code><span><span>  <span>after_step_1_positions</span> <span>:=</span> <span>graph</span><span>[</span><span>start</span><span>]</span></span></span></code></pre>
</div>
</div>
<p>
In case we want to number of ways to get somewhere, we can have an 2d array tracking to number of ways to get from point i to point j.</p>
<div>
<div>
<pre><code><span><span>  <span>ways</span> <span>:=</span> <span>make</span><span>([][]</span><span>int</span><span>,</span> <span>len</span><span>(</span><span>graph</span><span>))</span>
</span></span><span><span>  <span>for</span> <span>i</span><span>:=</span> <span>range</span> <span>ways</span> <span>{</span>
</span></span><span><span>          <span>ways</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>make</span><span>([]</span><span>int</span><span>,</span> <span>len</span><span>(</span><span>graph</span><span>))</span>
</span></span><span><span>  <span>}</span></span></span></code></pre>
</div>
</div>
<p>
We then increment the number of ways to get to j if the transition graph at <code>graph[start][i]</code> is 1,</p>
<div>
<div>
<pre><code><span><span>  <span>for</span> <span>j</span><span>,</span> <span>val</span> <span>in</span> <span>range</span><span>(</span><span>after_step_1_positions</span><span>)</span> <span>{</span>
</span></span><span><span>          <span>if</span> <span>val</span> <span>==</span> <span>1</span> <span>{</span>
</span></span><span><span>                  <span>ways</span><span>[</span><span>start</span><span>][</span><span>j</span><span>]</span> <span>+=</span> <span>1</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>  <span>}</span></span></span></code></pre>
</div>
</div>
<p>
<strong>notice that looking at <code>ways</code>, what are are doing is actually summing all the values we have at graph[start].</strong></p>

<p>
Now that at step 2, we have mutiple starting positions, that’s taken from the first transition,</p>
<div>
<div>
<pre><code><span><span>    <span>step_2_starting_positions</span> <span>:=</span> <span>make</span><span>([]</span><span>int</span><span>,</span> <span>length</span><span>(</span><span>graph</span><span>))</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>j</span><span>,</span> <span>val</span> <span>in</span> <span>range</span><span>(</span><span>after_step_1_positions</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>if</span> <span>val</span> <span>==</span> <span>1</span> <span>{</span>
</span></span><span><span>                    <span>step_2_starting_positions</span> <span>=</span> <span>append</span><span>(</span>
</span></span><span><span>                            <span>step_2_starting_positions</span><span>,</span> <span>j</span><span>)</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>    <span>}</span></span></span></code></pre>
</div>
</div>
<p>
And how we obtain the results (ways and start position for step 3) will be the same as before, except we apply this to every starting position,</p>
<div>
<div>
<pre><code><span><span>    <span>step_3_starting_positions</span> <span>:=</span> <span>make</span><span>([]</span><span>int</span><span>,</span> <span>length</span><span>(</span><span>graph</span><span>))</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>_</span><span>,</span> <span>step_2_start_pos</span> <span>:=</span> <span>range</span><span>(</span><span>step_2_starting_positions</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>for</span> <span>j</span><span>,</span> <span>val</span> <span>in</span> <span>range</span><span>(</span><span>graph</span><span>[</span><span>step_2_start_pos</span><span>])</span> <span>{</span>
</span></span><span><span>                    <span>if</span> <span>val</span> <span>==</span> <span>1</span> <span>{</span>
</span></span><span><span>                            <span>step_3_starting_positions</span> <span>=</span> <span>append</span><span>(</span>
</span></span><span><span>                                    <span>step_3_starting_positions</span><span>,</span> <span>j</span><span>)</span>
</span></span><span><span>                            <span>ways</span><span>[</span><span>step_2_start_pos</span><span>][</span><span>j</span><span>]</span> <span>+=</span> <span>1</span>
</span></span><span><span>                    <span>}</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>    <span>}</span></span></span></code></pre>
</div>
</div>

<p>
If we look at <code>ways</code>, what its doing is actually <strong>for every starting position i, sum all the values, add the sum to the already counted ways</strong></p>
<p>
If we consider the original start point at step 1, from the perspective star point at step 1, step 2 starting points are midway points for getting to the some state further down.</p>
<p>
Like a tree,</p>
<div>
<div>
<pre><code><span><span>start_point_step_1 -&gt; midpoint 1 at step 2 -&gt; ...
</span></span><span><span>                                           -&gt; ...
</span></span><span><span>                   -&gt; midpoint 2 at step 2 -&gt; ...
</span></span><span><span>                                           -&gt; ...
</span></span><span><span>                   -&gt; ...</span></span></code></pre>
</div>
</div>
<p>
And if we count the number the nodes, that’s the number of ways to get there, i.e. <strong>sum up each row in the matrix</strong></p>
<p>
The actions we took were</p>
<ol>
<li>indexing the next possible position from current location (from start to mid point)</li>
<li>indexing every possible position for every midpoint (from midpoint to further)</li>
<li>summing up the number of nodes</li>
</ol>
<p>These are exactly what <a href="https://www.youtube.com/watch?v=XkY2DOUCWMU">matrix multiplication</a> is doing.</p>
<p>
So,</p>
<p>
To express what the number of ways to get to each position, we just take our transition matrix, i.e. our graph, and multiply it by itself, then we find the number of ways by just indexing.</p>
<div>
<div>
<pre><code><span><span>  <span>func</span> <span>NewMatrix</span><span>(</span><span>n</span> <span>int</span><span>)</span> <span>[][]</span><span>int</span> <span>{</span>
</span></span><span><span>          <span>m</span> <span>:=</span> <span>make</span><span>([][]</span><span>int</span><span>,</span> <span>n</span><span>)</span>
</span></span><span><span>          <span>for</span> <span>i</span> <span>:=</span> <span>range</span> <span>m</span> <span>{</span>
</span></span><span><span>                  <span>m</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>make</span><span>([]</span><span>int</span><span>,</span> <span>n</span><span>)</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>          <span>return</span> <span>m</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>  <span>func</span> <span>MultiplySelf</span><span>(</span><span>m</span> <span>[][]</span><span>int</span><span>)</span> <span>[][]</span><span>int</span> <span>{</span>
</span></span><span><span>          <span>n</span> <span>:=</span> <span>len</span><span>(</span><span>m</span><span>)</span>
</span></span><span><span>          <span>c</span> <span>:=</span> <span>NewMatrix</span><span>(</span><span>n</span><span>)</span>
</span></span><span><span>
</span></span><span><span>          <span>for</span> <span>i</span> <span>:=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
</span></span><span><span>                  <span>for</span> <span>j</span> <span>:=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>n</span><span>;</span> <span>j</span><span>++</span> <span>{</span>
</span></span><span><span>                          <span>sum</span> <span>:=</span> <span>0</span>
</span></span><span><span>                          <span>for</span> <span>k</span> <span>:=</span> <span>0</span><span>;</span> <span>k</span> <span>&lt;</span> <span>n</span><span>;</span> <span>k</span><span>++</span> <span>{</span>
</span></span><span><span>                                  <span>sum</span> <span>+=</span> <span>m</span><span>[</span><span>i</span><span>][</span><span>k</span><span>]</span> <span>*</span> <span>m</span><span>[</span><span>k</span><span>][</span><span>j</span><span>]</span>
</span></span><span><span>                          <span>}</span>
</span></span><span><span>                          <span>c</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>sum</span>
</span></span><span><span>                  <span>}</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>return</span> <span>c</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>graph</span> <span>:=</span> <span>[][]</span><span>int</span><span>{</span>
</span></span><span><span>          <span>{</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>},</span>
</span></span><span><span>          <span>{</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>},</span>
</span></span><span><span>          <span>{</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>},</span>
</span></span><span><span>          <span>{</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>}</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>ways</span> <span>:=</span> <span>NewMatrix</span><span>(</span><span>len</span><span>(</span><span>graph</span><span>))</span>
</span></span><span><span>
</span></span><span><span>  <span>ways</span> <span>=</span> <span>graph</span>
</span></span><span><span>
</span></span><span><span>  <span>steps</span> <span>:=</span> <span>num_of_steps_we_want_to_know_for_our_num_of_ways_calculation</span>
</span></span><span><span>
</span></span><span><span>  <span>for</span> <span>i</span> <span>:=</span> <span>0</span><span>;</span> <span>i</span> <span>&gt;</span> <span>steps</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
</span></span><span><span>          <span>ways</span> <span>=</span> <span>MultiplySelf</span><span>(</span><span>ways</span><span>)</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>result_for_ways_to_get_to_end_after_steps</span> <span>:=</span> <span>ways</span><span>[</span><span>start</span><span>][</span><span>end</span><span>]</span></span></span></code></pre>
</div>
</div>
<p>
Now this is a bit awkward, matrix mutiplication seems pretty expensive, we would not want to do it too many times, right now we are doing it as number of steps times, i.e. O(n)</p>

<blockquote>
<p>Think how binary search get from O(N) to O(logN), then you get the idea.</p>
</blockquote>
<p>
To solve this, the insight is that mutiplication is ways between 2 things, one multiply the other, doesn’t matter if these 2 things are the same or not.</p>
<p>
And we know that we can break down any number as powers of 2, “binary decomposition” or “binary expansion”, e.g. if we were to calcalute <code>M^8</code>, we do not multiply <code>M</code> 8 times, we can calculte <code>M^4 X M^4</code>, and for <code>M^4</code>, we can do <code>M^2 X M^2</code>, so on and so forth,</p>
<p>
this means we</p>
<blockquote>
<p>only need to calcuate matrix multiplication up to log(N) times and mutiple each by division of one remainder 1 if there’s any.</p>
</blockquote>
<div>
<div>
<pre><code><span><span>  <span>func</span> <span>(</span><span>a</span> <span>[][]</span><span>int</span><span>)</span> <span>Multiply</span><span>(</span><span>b</span> <span>[][]</span><span>int</span><span>)</span> <span>[][]</span><span>int</span> <span>{</span>
</span></span><span><span>          <span>n</span> <span>:=</span> <span>len</span><span>(</span><span>a</span><span>)</span>
</span></span><span><span>          <span>c</span> <span>:=</span> <span>NewMatrix</span><span>(</span><span>n</span><span>)</span>
</span></span><span><span>
</span></span><span><span>          <span>for</span> <span>i</span> <span>:=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
</span></span><span><span>                  <span>for</span> <span>j</span> <span>:=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>n</span><span>;</span> <span>j</span><span>++</span> <span>{</span>
</span></span><span><span>                          <span>sum</span> <span>:=</span> <span>0</span>
</span></span><span><span>                          <span>for</span> <span>k</span> <span>:=</span> <span>0</span><span>;</span> <span>k</span> <span>&lt;</span> <span>n</span><span>;</span> <span>k</span><span>++</span> <span>{</span>
</span></span><span><span>                                  <span>sum</span> <span>+=</span> <span>a</span><span>[</span><span>i</span><span>][</span><span>k</span><span>]</span> <span>*</span> <span>b</span><span>[</span><span>k</span><span>][</span><span>j</span><span>]</span>
</span></span><span><span>                          <span>}</span>
</span></span><span><span>                          <span>c</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>sum</span>
</span></span><span><span>                  <span>}</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>return</span> <span>c</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>func</span> <span>(</span><span>m</span> <span>[][]</span><span>int</span><span>)</span> <span>Power</span><span>(</span><span>exp</span> <span>int</span><span>)</span> <span>[][]</span><span>int</span> <span>{</span>
</span></span><span><span>          <span>n</span> <span>:=</span> <span>len</span><span>(</span><span>m</span><span>)</span>
</span></span><span><span>          <span>result</span> <span>:=</span> <span>NewMatrix</span><span>(</span><span>n</span><span>)</span>
</span></span><span><span>
</span></span><span><span>          <span>for</span> <span>i</span> <span>:=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
</span></span><span><span>                  <span>result</span><span>[</span><span>i</span><span>][</span><span>i</span><span>]</span> <span>=</span> <span>1</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>base</span> <span>:=</span> <span>m</span><span>.</span><span>Copy</span><span>()</span>
</span></span><span><span>          <span>for</span> <span>exp</span> <span>&gt;</span> <span>0</span> <span>{</span>
</span></span><span><span>                  <span>if</span> <span>exp</span> <span>%</span> <span>2</span> <span>==</span> <span>1</span> <span>{</span>
</span></span><span><span>                          <span>result</span> <span>=</span> <span>result</span><span>.</span><span>Multiply</span><span>(</span><span>base</span><span>)</span>
</span></span><span><span>                  <span>}</span>
</span></span><span><span>                  <span>base</span> <span>=</span> <span>base</span><span>.</span><span>Multiply</span><span>(</span><span>base</span><span>)</span>
</span></span><span><span>                  <span>exp</span> <span>=</span> <span>exp</span> <span>/</span> <span>2</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>return</span> <span>result</span>
</span></span><span><span>  <span>}</span></span></span></code></pre>
</div>
</div>
<p>
And it turns out, to get the number of ways to get from start to end after steps, given graph, what we do is,</p>
<div>
<div>
<pre><code><span><span>  <span>func</span> <span>CountPaths</span><span>(</span><span>graph</span> <span>[][]</span><span>int</span><span>,</span> <span>start</span><span>,</span> <span>end</span><span>,</span> <span>steps</span> <span>int</span><span>)</span> <span>int</span> <span>{</span>
</span></span><span><span>        <span>resultMatrix</span> <span>:=</span> <span>graph</span><span>.</span><span>Power</span><span>(</span><span>steps</span><span>)</span>
</span></span><span><span>
</span></span><span><span>        <span>return</span> <span>resultMatrix</span><span>[</span><span>start</span><span>][</span><span>end</span><span>]</span>
</span></span><span><span><span>}</span></span></span></code></pre>
</div>
</div>
<p>
And that is <code>O(steps * number_of_possible_locations ^ 3)</code>, usually number_of_possible_locations is fairly small comparing to steps if we frame our questions right.</p>

</div></div>
  </body>
</html>
