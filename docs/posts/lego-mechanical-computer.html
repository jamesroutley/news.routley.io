<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.drmoron.org/posts/mechanical-computer/">Original</a>
    <h1>Lego Mechanical Computer</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><div><div><article role="main"><p>Not long ago I was part of a discussion about using mechanical things to
demonstrate computing concepts (such as building a <a href="http://boingboing.net/2009/11/02/mechanical-computer.html">learning Tic-Tac-Toe
game out of matchboxes</a>). This got my head spinning on different ways to
use mechanical devices to compute things, whether or not such computation
is useful. I figured I had enough Legos lying around the house to make
something interesting.</p><p>I started by thinking of some of the more famous early computers, such as
<a href="http://en.wikipedia.org/wiki/Pascal&#39;s_calculator">Pascal’s calculator</a> and <a href="http://en.wikipedia.org/wiki/Difference_engine">Babbage’s difference engine</a>. However, I chose
not to implement these. Perhaps partially because they are mechanically
complex, but also because they are missing some of the fundamental
components we take for granted in computing. I wanted something that had a
form of memory that could hold a state and then perform an action based on
that state. I also wanted something that I could “program” by changing the
state transition logic.</p><p>I ended up gravitating toward a clever toy called <a href="http://en.wikipedia.org/wiki/Digi-Comp_I">Digi-Comp I</a>, which was
manufactured in the 1960’s. The Digi-Comp I is a simple 3 bit machine that
is programmed by adding or removing pegs in its side. As it happens, a
company named <a href="http://mindsontoys.com">Minds-On Toys</a> recently started selling <a href="http://mindsontoys.com/kits.htm?dc1_main.htm">replica Digi-Comp I
kits</a>. A rational person would have just bought and assembled one. But not
me.</p><p>I wanted to make my own device to prove to myself that I could. I borrowed
a lot from the Digi-Comp design and ended up with something that worked
fairly well. My computer only had two bits instead of three, and I didn’t
have a nice clocking mechanism, but it was compact and operated quite
nicely. Here is a video of it in operation.</p><p><iframe src="https://www.youtube.com/embed/LfFbX2GgPnE" allowfullscreen="" title="YouTube Video"></iframe></p><p>After posting this video, I was inundated with requests for more details on
the internal mechanisms. (Well, OK, I got a couple of comments.) Anyway,
this post is me finally getting around to providing more detail. I have
long ago dismantled the device, and I have no intention of providing
step-by-step instructions in any case. However, I am giving the high level
concepts that lead me to the final design. My implementation is far from
perfect anyway, so there is lots of room for improvement.</p><h3 id="basic-design">Basic Design</h3><p>There are two main components to the computer. The first is a memory
structure that holds some number of bits (in my case, two) to represent the
state of the machine. The second is a control circuit that takes as input
the memory bits and produces as output the signals that change the state of
the memory. Because there is this feedback loop between memory and control
logic, you need a fairly careful timing mechanism so that the output of the
control holds steady long enough to set the appropriate state of the
memory. That said, this control mechanism is basically missing from my
computer. Instead, it relies on the operator (me) performing several
different motions in the correct order to advance to the next state (as you
can see in the video with me flipping several controls).</p><p>Of these two components, the control mechanism is fairly straightforward.
There are several ways to build logic gates out of mechanical components
like Legos. One of the simplest to implement and most compact designs for
gates uses <a href="https://sites.google.com/site/santiagoontanonvillar/Home/lego-projects/lego-rod-logic">rod logic</a>. Memory, however, is generally more complicated than
simple logic. It was the creation of this memory that dominates most of
this computer’s design.</p><h3 id="the-flip-flop">The Flip-Flop</h3><p>Memory can be implemented using a special kind of digital circuit known as
a <a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>. The flip-flop is designed to change its state when it
receives a signal and then continue to hold that state after the signal is
released.</p><div><div><figure itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject"><p><img itemprop="thumbnail" src="https://www.drmoron.org/posts/mechanical-computer/animated-s-r-flip-flop.gif" alt="An SR flop-flop from NOR gates. "/></p><a href="https://www.drmoron.org/posts/mechanical-computer/animated-s-r-flip-flop.gif" itemprop="contentUrl"></a><figcaption><p>An SR flop-flop from NOR gates. © Napalm Llama, Creative Commons Attribution-Share Alike</p></figcaption></figure></div></div><p>A flip-flop can be constructed out of standard gates (at least, the
electronic variety) using a feedback loop that makes a circular loop from
the output of gates back to the input of the same gate. If constructed
carefully, this feedback can hold the output state of the gate. This image
here shows an animation of a set/reset (SR) flip-flop. When the set (S)
signal is raised, the output goes positive and stays that way even after S
is lowered again. When the reset (R) is raised, the output goes negative
and stays there.</p><p>This circuit is straightforward to build out of electronic logic circuits,
but problematic when the gates are mechanical. The real challenge is in
designing this feedback loop in a way that does not lock up the mechanism.
Added to this challenge is the fact that the overall mechanical computer
introduces a <em>second</em> feedback loop (memory to control back to memory)
that must also be managed.</p><p>Fortunately, there is a simple way around all these problems. The approach
bypasses all these problems by building the flip-flop without any gates at
all. A simple device is shown below.</p><div><figure itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject"><p><img itemprop="thumbnail" src="https://www.drmoron.org/posts/mechanical-computer/simple-flip-flop-0.jpg" alt="A mechanical SR flip-flop with output of 0."/></p><a href="https://www.drmoron.org/posts/mechanical-computer/simple-flip-flop-0.jpg" itemprop="contentUrl"></a><figcaption><p>A mechanical SR flip-flop with output of 0.</p></figcaption></figure></div> </article></div></div></div></div>
  </body>
</html>
