<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.thecodedmessage.com/posts/haskell-gripe/">Original</a>
    <h1>Haskell error messages: come on</h1>
    
    <div id="readability-page-1" class="page"><div><div>
        <p>I am a big fan of strongly typed languages, and my favorite GC’d language
is Haskell. And I want you, the reader, to keep that in mind today.
What I am writing is some commentary about a language I deeply love,
some loving criticism.</p>
<p>So here’s what happened: A few days ago, I was showing off some Haskell
for a friend who primarily programs in Python. The stakes were high
– could I demonstrate that this strange language was worth some
investigation?</p>
<p>My primary focus was on infinite lists, and defining <code>fibonacci</code> as a
<a href="https://wiki.haskell.org/The_Fibonacci_sequence#Using_the_infinite_list_of_Fibonacci_numbers">recursive data structure</a>
– all fun things to show off Haskell’s laziness.
But at some point, we wrote an expression by accident that had a type
error in it, and so we got to see how the compiler treated such things.
I don’t remember the exact expression – it was deep in context – but
the problem was I was trying to add an integer to an list. Something
analogous to <code>1+[2,3]</code>.</p>
<p>Now, in some <a href="https://en.wikipedia.org/wiki/JavaScript">“weakly typed” languages</a>,
<a href="https://xkcd.com/1537/">this sort of thing</a> is actually allowed, as
a colleague of mine recently pointed out:</p>
<pre><code>[jim@palatinate:~]$ node
&gt; 1+[2,3]
&#39;12,3&#39;
</code></pre><p>This is, of course, hilarious. But! We shouldn’t paint “weakly typed”
languages with such a broad brush.  In my friend’s native Python, it
would have been an error, as it should be. It is a run-time error, but
what does that matter when you’re working in an interpreted language,
writing ad hoc scripts. The important thing is that failure is
recognized as failure, and it doesn’t try to
<a href="https://en.wikipedia.org/wiki/Fail-fast">continue with nonsense</a>:</p>
<pre><code>[jim@palatinate:~]$ python3
Python 3.8.10 (default, Nov 26 2021, 20:14:08)
[GCC 9.3.0] on linux
Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.
&gt;&gt;&gt; 1+[2,3]
Traceback (most recent call last):
  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;list&#39;
</code></pre><p>This is an error message. It’s even a pretty decent error message.
There are many things you can pass to the <code>+</code> operator in Python,
but an <code>int</code> and a <code>list</code> together are not among them.</p>
<p>So now, what did Haskell do, this language that I’m trying to show off?
Well, unfortunately, my friend didn’t see the actual problem in the code,
but was first made aware of it from the compiler’s error message. And
if you’ve ever done this before in Haskell, you’re probably wincing right
now, because you know what this error message is:</p>
<pre><code>[jim@palatinate:~]$ ghci
GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
Prelude&gt; 1+[2,3]

&lt;interactive&gt;:1:1: error:
    • Non type-variable argument in the constraint: Num [a]
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. (Num a, Num [a]) =&gt; [a]
</code></pre><p>Now, my friend didn’t understand this error message at all.
Since I was in Demonstration Mode, my instinct was to explain it to him,
but after a few false starts, I realized that this would simply not
help, and pointed out that you couldn’t add integers to lists,
and showed him where this was happening (it was a little more
subtle than this example).</p>
<p>But since then, my colleagues and I were discussing error messages in
Slack, specifically how good Rust’s error messages are, specifically
how much better they are than Haskell’s. So I had an opportunity to
paste that very bad Haskell error message me and my friend discovered
into the Slack. There, it served as a case study, so we could discuss how
problematically incomprehensible it is, sparking a lot of discussion, from
which I shall try to extract the most interesting parts into this post.</p>
<p>For one, this error message has little to do with the concrete
problem. The problem is – and the error message should say this – that
you can’t add lists. Specifically, in Haskell, you can only add things that
implement the <code>Num</code> typeclass (which lists don’t), and so you’d think the
compiler would be smart enough to mention <em>anywhere</em> in this error message
something along the lines of “expecting <code>[a]</code> to have <code>Num</code> instance,
but it does not.” That’s the <em>actual</em> problem, even if not well-explained.</p>
<p>But instead, <code>ghc</code> tries to assume you meant what you wrote, and figure
out a way in which <code>[a]</code> <em>can</em> have the <code>Num</code> instance. This is where
it fails, and then it gives advice on how to make <em>that</em> succeed.
As my professor-colleague points out, this is dangerous advice, especially
for beginners, because there’s no way that using <code>FlexibleContexts</code>
will actually help in that situation. The problem isn’t that these
lists aren’t numbers in particular, and that you need to only accept
lists that are numbers in your function. The problem is that no lists
are (or at least should be) numbers! But a beginner might just follow
the advice, try to figure out what the hell <code>FlexibleContexts</code> are,
and find themselves in a world of pain, and no closer to solving the
actual problem.</p>
<p>Part of what causes this is the type of <code>1</code> itself. Haskell, unlike
Rust, allows literals like <code>1</code> to be interpreted in any number type.
Given that Haskell (like Rust) has return-type polymorphism, it can directly
express this in the type system:</p>
<pre><code>Prelude&gt; :type 1
1 :: Num p =&gt; p
</code></pre><p>In Rust, this would be something like <code>impl Num</code>. It means that <code>1</code> can
be any type that is <code>Num</code>. Combine that with the fact that <code>+</code> requires
its arguments to be <code>Num</code> and to match (<code>(+) :: Num a =&gt; a -&gt; a -&gt; a</code>),
and when we see <code>1+[2,3]</code>, we’re simply left trying to figure out how
<code>[2,3]</code> is <code>Num</code>.</p>
<p>If we did not have this <em>polymorphic literal</em>, this notion that the
meaning of <code>1</code> is flexible, we would have seen a much more comprehensible
error message. If <code>1</code> meant the same thing as <code>(1::Integer)</code> (or any
arbitrary choice), we’d have this beautiful explanation:</p>
<pre><code>Prelude&gt; (1::Integer) + [2,3]

&lt;interactive&gt;:4:16: error:
    • Couldn&#39;t match expected type ‘Integer’
                  with actual type ‘[Integer]’
    • In the second argument of ‘(+)’, namely ‘[2, 3]’
      In the expression: (1 :: Integer) + [2, 3]
      In an equation for ‘it’: it = (1 :: Integer) + [2, 3]
</code></pre><p>Or even if we just had non-numbers on both sides, we’d similarly
have a better error message:</p>
<pre><code>[jim@palatinate:~]$ ghci
GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
Prelude&gt; () + [1,2]

&lt;interactive&gt;:1:6: error:
    • Couldn&#39;t match expected type ‘()’ with actual type ‘[Integer]’
    • In the second argument of ‘(+)’, namely ‘[1, 2]’
      In the expression: () + [1, 2]
      In an equation for ‘it’: it = () + [1, 2]
Prelude&gt;
</code></pre><p>What is my take-away here? I don’t think the compiler has been sufficiently
tweaked when it comes to error messages, or that the Haskell community
cares sufficiently about beginners. Rust as a community
puts a lot of energy into good error messages, so that even though
Rust also has a trait you could add to arrays to make <code>+</code> work,
it still has a better error message:</p>
<pre><code>error[E0277]: cannot add `[{integer}; 2]` to `{integer}`
 --&gt; test.rs:2:7
  |
2 |     1 + [2,3];
  |       ^ no implementation for `{integer} + [{integer}; 2]`
  |
  = help: the trait `Add&lt;[{integer}; 2]&gt;` is not implemented for `{integer}`
</code></pre><p>But I also think the semantics of <code>1</code> are too liberal, leaving the compiler
in an awkward place. See, the weird thing is, you can declare <code>[2,3]</code>
a number, making <code>1+[2,3]</code> an expression that adds two lists:</p>
<pre><code>instance Num [a] where
    (+) = (&lt;&gt;)
    (-) = (&lt;&gt;) -- Eh, why not?
    (*) = (&lt;&gt;)
    negate = reverse
    abs = id
    signum = const []
    fromInteger i = take (fromInteger i) $ repeat undefined

main = do
    print $ signum $ 1 + [2,3]
</code></pre><p>Once you’ve defined lists as a number, <code>1</code> is suddenly a list if
it wants to be. And this contributes to the difficulty of finding
the right error message: what you asked for is possible after all.</p>
<p>And in the end, this leaves me with the feeling that Haskell has
this in common with Javascript, and that makes me sad. A polymorphic
enough strongly typed language is no longer strongly typed.</p>

      </div></div></div>
  </body>
</html>
