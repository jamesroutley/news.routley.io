<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.feldera.com/blog/the-pain-that-is-github-actions">Original</a>
    <h1>The Pain That Is GitHub Actions</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p id="04f7954960b1">For the past two weeks, I’ve been spending most of my time rewriting our CI scripts in GitHub Actions. This is the third time we’ve had to redo our CI setup—first GitHub Actions, then <a href="https://earthly.dev/">Earthly</a> (which we moved away from because it was discontinued), and now, reluctantly, back to GitHub Actions.</p><p id="07dc3a94dbeb">Our CI is complex: merge queues, multiple runners (self-hosted, <a href="https://blacksmith.sh/">blacksmith.sh</a>, GitHub-hosted), Rust builds, Docker images, and heavy integration tests. Every PR we merge burns through an hour of CI time, running across multiple parallel runners.</p><p id="8c6854fbbe43">There are a few things we&#39;d like to have (which we deem as &#34;good software practice&#34;) but it&#39;s nothing unheard of:</p><ol><li>Everything that goes into `main` must pass all tests.</li><li>Trivial mistakes (formatting, unused deps, lint issues) should be fixed automatically, not cause failures.</li><li>The artifacts we test with in CI should be the exact ones we release.</li><li>CI should complete quickly (to keep developers happy).</li></ol><p id="834216755732">GitHub Actions technically allows all of this—but setting it up is a frustrating mess, full of hidden gotchas, inconsistent behavior, and a debugging experience that makes me question my choices.</p><h3 id="56a4dbb8bf83">Strange Way to Enforce Status Checks with Merge Queue</h3><p id="fd16fccbbdb2">The key to enforcing a clean <code>main</code> branch is GitHub’s <a href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue">merge queue</a>, which rebases a PR onto <code>main</code> before running CI. Sounds great. But here’s the fun part:</p><ul><li>We need CI to run <em>before</em> entering the queue to auto-fix trivial issues.</li><li>We need CI to run <em>again</em> inside the queue to verify the final merge.</li><li>GitHub Actions makes it weirdly hard to require both runs to pass.</li></ul><p id="8e1619327bba">The solution? <strong>Name the jobs identically</strong> in both phases. That’s it. GitHub treats them as the same check, so they both need to succeed. Solved by reading this answer in a <a href="https://stackoverflow.com/questions/76655935/when-does-a-github-workflow-trigger-for-merge-group-and-is-it-restricted-by-bran/78030618#78030618">Stack Overflow post</a> after a few hours of debugging. Any other way you try to do this leads to either status checks being awaited before you put something in the queue (so it never starts the job) or worse, things just get merged even if the job you&#39;d like to pass in the merge queue fails.</p><h3 id="d7687fc57c00">A security nightmare?</h3><p id="e118b355141b">A few days ago, someone <a href="https://news.ycombinator.com/item?id=43368870">compromised a popular GitHub Action</a>. The response? &#34;Just pin your dependencies to a hash.&#34; Except as comments also pointed out, almost no one does.</p><p id="be904b86b98a">Even setting aside supply chain attacks, GitHub’s security model is a confusing maze to me: My point of view is that if I can&#39;t understand a security model easily it&#39;s probably doomed to fail or break at some point. Disclaimer: I&#39;m writing this as a github actions user with only a vague understanding of it so I&#39;d be delighted to hear that it is not just &#34;things piled on top of things until it&#39;s safe&#34;, which is my current impression. I do understand very well that the problem of having secure CI for distributed source control is complicated.</p><p id="57fa6b17ef27">In github, there is a &#34;default&#34; token called <code>GITHUB_TOKEN</code>. The way it works is that it gets initialized with some default permissions. You can set that default in the settings of your repository (under Actions -&gt; General -&gt; Workflow Permissions). Here is what the github documentation says about it:</p><blockquote><p>If the default permissions for the GITHUB_TOKEN are restrictive, you may have to elevate the permissions to allow some actions and commands to run successfully. If the default permissions are permissive, you can edit the workflow file to remove some permissions from the GITHUB_TOKEN.</p><span>- Github Documenation</span></blockquote><p id="34005ba8540c">Removing permission that aren&#39;t necessary sounds nice (though I do think a better &#34;default&#34; would be to start with <strong>no privileges</strong> and require the user to add whatever is needed). Unfortunately, there are <a href="https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#permissions">many of them</a> and it&#39;s hardly clear for all of them what they are protecting if you&#39;re not a github expert.</p><p id="39fa8482d7a0">Your workflow permissions also don’t really depend on the action itself. Here is an example of such an instance, I&#39;m using <code>softprops/action-gh-release</code> to automatically create a new release on github</p><div><div><pre><code><span>-</span><span> </span><span>name:</span><span> </span><span>Release</span><span> </span><span>on</span><span> </span><span>GitHub</span><span>
</span><span>  </span><span>if:</span><span> </span><span>env.version_exists</span><span> </span><span>==</span><span> </span><span>&#39;false&#39;</span><span>
</span><span>  </span><span>uses:</span><span> </span><span>softprops/action-gh-release@v2</span><span>
</span><span>  </span><span>with:</span><span>
</span><span>    </span><span>tag_name:</span><span> </span><span>v${{</span><span> </span><span>env.CURRENT_VERSION</span><span> </span><span>}}</span><span>
</span><span>    </span><span>generate_release_notes:</span><span> </span><span>true</span><span>
</span><span>    </span><span>make_latest:</span><span> </span><span>true</span><span>
</span><span>    </span><span>token:</span><span> </span><span>${{</span><span> </span><span>secrets.CI_RELEASE</span><span> </span><span>}}</span></code></pre></div></div><p id="1acd29788f81">Why do I need a custom token? Because without it, the release completes, but doesn’t trigger our post-release workflow. The sad part is that you don&#39;t get any indication about it until you eventually <a href="https://github.com/softprops/action-gh-release/issues/59">find an issue</a> where someone had the same problem and that leads you in the right direction.</p><p id="cfe2d1a4c40f">You can also elevate permissions in your workflow yaml file. That seems like a strange thing to do inside the code you&#39;re trying to protect. At least there are some limitations according to the github docs:</p><p id="daddc3d76619">You can use the <code>permissions</code> key to add and remove read permissions for forked repositories, but typically you can&#39;t grant write access. The exception to this behavior is where an admin user has selected the <strong>Send write tokens to workflows from pull requests</strong> option in the GitHub Actions settings. For more information, see <a href="https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#enabling-workflows-for-private-repository-forks">Managing GitHub Actions settings for a repository</a>.</p><p id="678e558d777b">This is just one of many instances which I believe is the root of what makes the github actions security model so obscure: there are too many pitfalls accompanied by exceptions that you have to account for. Clearly the system is very powerful and allows you to do many things but it also expands the attack surface for breaking things.</p><p id="e00abccbfba2">As far as I can tell I&#39;m not alone in this. Another instance of the same problem I ran into is when I read <a href="https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners">this paragraph</a> where they recommend that you don&#39;t use self-hosted runners in public repositories:</p><blockquote><p>We recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.</p><span>- Github Documentation</span></blockquote><p id="20e7090b06ce">However, github also has a setting for self-hosted runners where pull-requests from external collaborators need to be approved before running. A practical question that comes up for me is &#34;are self-hosted runners in combination with this setting safe&#34;? I do believe so, but github documentation doesn&#39;t say and there is no consensus in the rest of the internet about it. It&#39;s hard to be 100% confident given how much complexity there is. Even github documentation writers don&#39;t seem to understand their security model anymore.</p><h3 id="33b01436e240">Docker and Github Actions, an Unholy Combination</h3><p id="4ea29a97fd50">If you thought GitHub Actions was bad, try mixing in Docker.</p><p id="3cc29b3a3a20">GitHub lets you <a href="https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/running-jobs-in-a-container">run jobs inside a container</a>. This is great in theory—you can prepackage dependencies into a dev container instead of installing them every run. In practice:</p><ol><li>File permissions break constantly. A container builds files as one user, but GitHub runners may use another (different uid and gid) to run it. So it may be unable to either access the files in the container or in the github workspace and temporary host directories that get mounted.</li><li>The <code>$HOME</code> directory moves. Your dev container may install tools into <code>/home/ubuntu</code>, but inside GitHub Actions, it’s suddenly <code>/github/home</code>. Tools that rely on files in <code>$HOME</code> may no longer find them.</li><li>Any action that interacts with the host system might break now. For example, I use <a href="https://docs.blacksmith.sh/github-actions-runners/sticky-disks">blacksmith’s sticky disk action</a> to mount an NVMe drive for caching (since GitHub caches are limited to 10GB). It didn’t work inside a container until <a href="https://docs.blacksmith.sh/github-actions-runners/sticky-disks#using-sticky-disks-inside-a-container">they made a fix for me</a> (thanks to Aditya Jayaprakash from blacksmith.sh for the one day turn-around time on this!).</li></ol><p id="37c2cef1c9a2">Meanwhile, the <code>container</code> field itself has weird limitations. Want to override the entrypoint? Nope. Want to run <em>some</em> steps inside a container and others outside? Nope.</p><h3 id="15cb942fcdc2">Developing Workflows with YAML</h3><p id="8e060b2d72ac">All of this logic you end up writing in YAML can unfortunately get complicated pretty quickly and you&#39;re bound to make mistakes. I was using RustRover as my IDE when writing the YAML which had some linter checks for github YAML built-in and it helped a lot. I still found myself wishing for much better static checking for all of this. It doesn&#39;t help that you can&#39;t really try any of this locally (I know of <a href="https://github.com/nektos/act">act</a> but it only supports a small subset of the things you&#39;re trying to do in CI). I found that the best way to debug CI is to create an identical repo to the one you&#39;re trying to make changes for and do <code>git commit -a -m &#34;wip&#34; &amp;&amp; git push test-ci branch</code> until CI works as expected.</p><p id="d0bc10f501f0">Since I didn&#39;t want to run the whole CI pipeline every time I made a change, I tried to keep individual workflows small and have them push artifacts at the end of their steps, then subsequent workflows could download the artifacts and re-use them instead of rebuilding everything from scratch. This lets you test workflows in isolation because you can just download artifacts from a previous run until it works (of course when downloading from a previous run one needs to provide a token to the download-artifact action, but this can just be the default token. Why does it still need to be provided then is yet another unsolved mystery...).</p><p id="215acba7bd25">The main workflow file then becomes a chain of invoking other YAML files:</p><div><div><pre><code><span>jobs:</span><span>  
</span>  invoke-build-rust:  
<span></span><span>    name:</span><span> Build Rust  
</span><span></span><span>    uses:</span><span> ./.github</span><span>/workflows/</span><span>build-rust.yml  
</span>  
<!-- -->  invoke-build-java:  
<span></span><span>    name:</span><span> Build Java  
</span><span></span><span>    uses:</span><span> ./.github</span><span>/workflows/</span><span>build-java.yml  
</span>  
<!-- -->  invoke-tests-unit:  
<span></span><span>    name:</span><span> Unit Tests  
</span><span></span><span>    needs:</span><span> [invoke-build-rust, invoke-build-java]  
</span><span></span><span>    uses:</span><span> ./.github</span><span>/workflows/</span><span>test-unit.yml  
</span>  
<!-- -->  invoke-tests-adapter:  
<span></span><span>    name:</span><span> Adapter Tests  
</span><span></span><span>    needs:</span><span> [invoke-build-rust]  
</span><span></span><span>    uses:</span><span> ./.github</span><span>/workflows/</span><span>test-adapters.yml  
</span><span></span><span>    secrets:</span><span> inherit  
</span>  
<!-- -->  invoke-build-docker:  
<span></span><span>    name:</span><span> Build Docker  
</span><span></span><span>    needs:</span><span> [invoke-build-rust, invoke-build-java]  
</span><span></span><span>    uses:</span><span> ./.github</span><span>/workflows/</span><span>build-docker.yml  
</span>  
<!-- -->  invoke-tests-integration:  
<span></span><span>    name:</span><span> Integration Tests  
</span><span></span><span>    needs:</span><span> [invoke-build-docker]  
</span><span></span><span>    uses:</span><span> ./.github</span><span>/workflows/</span><span>test-integration.yml  
</span>  
<!-- -->  invoke-tests-java:  
<span></span><span>    name:</span><span> Java Tests  
</span><span></span><span>    needs:</span><span> [invoke-build-java]  
</span><span></span><span>    uses:</span><span> ./.github</span><span>/workflows/</span><span>test-java.yml</span></code></pre></div></div><p id="4af0c99d7aac">Notice the <code>secrets: inherit</code> added to some jobs. Another gotcha that took me too long to figure out. Every time when I ran the entire CI pipeline things wouldn&#39;t work but when I ran the steps individually they would work just fine (that&#39;s because when you call a workflow from another workflow secrets aren&#39;t shared by default).</p><p id="a9a473aa7f3d">There are many more gotchas I wanted to write about, but the post is already quite long. Overall, I&#39;m still happy with <a href="https://github.com/feldera/feldera/tree/main/.github/workflows">our new CI scripts</a> because it reduced the time to merge significantly for us. I just wish the process to get there would be less time-consuming and that it would be easier to debug when things go wrong. I guess, I&#39;m hoping for some innovation here.</p></div></div></div></div>
  </body>
</html>
