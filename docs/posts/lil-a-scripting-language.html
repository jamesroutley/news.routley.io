<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://beyondloom.com/decker/lil.html">Original</a>
    <h1>Lil: A Scripting Language</h1>
    
    <div id="readability-page-1" class="page">

<p>Lil is part of the technology that powers <em>Decker</em>, a multimedia creative tool inspired by <em>HyperCard</em>. Decker uses Lil for adding custom behavior to decks and the widgets within. Lil is designed to be learned in layers, but it is a richly multi-paradigm language which incorporates ideas from imperative, functional, declarative, and vector-oriented languages.</p>

<pre><code>on mode a do   # line comment
	r:()
	each x in a
		r[x]:1+r[x]
	end
	extract first key orderby value desc from r
end

mode[1,2,2,3,4,2,1]
</code></pre>

<figure>
<img src="https://words.filippo.io/dispatches/reciprocal/images/logo.png" alt=""/>
<figcaption></figcaption>
</figure>

<p>Lil’s implementation needs to be fairly small, as an interpreter is shipped with every standalone Decker document along with the rest of the runtime. At the same time, Lil should be prepared for the everyday needs of Decker users, with primitives to handle common use-cases and a minimum of boilerplate.</p>

<p>The language therefore tries to thread the needle between a design which is simple and a design which is ergonomically pleasant. There is a small number of datatypes, features and primitives, which compose in many useful ways. The query syntax generalizes to manipulation of dictionaries, lists, and strings, and replaces many individual primitive operations in other languages with a single algorithmic framework. Simple things are easy, and complex things are possible.</p>

<h2 id="typesandconversions">Types and Conversions</h2>

<p>There are 7 types of value in Lil: numbers, strings, lists, dictionaries, tables, functions, and interfaces.</p>

<ul>
<li><em>Numbers</em> are floating-point values, possibly with a sign: <code>42 37.5 -29999</code>.</li>
<li><em>Strings</em> are a sequence of characters, written enclosed in double-quotes. The special characters backslash, double-quote, and the newline character (<code>\n</code>) are preceded with a backslash escape: <code>&#34;apple&#34; &#34;foo\nbar&#34;</code>. The binary <code>fuse</code> and <code>format</code> operators can both be used for concatenating strings.</li>
<li><em>Lists</em> are ordered sequences of values which can be indexed by numbers. The empty list is written as <code>()</code>, and the unary operator <code>list</code> constructs a single-element list from any value. Lists can be joined with the <code>,</code> operator.</li>
<li><em>Dictionaries</em> are ordered sequences of pairings between <em>keys</em> and <em>values</em>, both of which can be any type. Dictionaries can be made by the binary operator <code>dict</code>, the <code>extract</code> statement, or a list can be promoted to a dictionary by assigning at non-numeric keys. Dictionaries can be unioned together with the <code>,</code> operator.</li>
<li><em>Tables</em> are a rectangular array of values for which every column has a string as its <em>key</em>. Tables can be made with the unary operator <code>table</code> or with the <code>insert</code> statement. The binary operators <code>,</code> (append), <code>join</code> (natural join), and <code>cross</code> (cartesian join) offer a selection of tabular joins.</li>
<li><em>Functions</em> have a name, take arguments, and return a result. They are declared with <code>on</code>, and may be freely passed around or stored in variables, but are otherwise totally opaque values.</li>
<li><em>Interfaces</em> are opaque dictionary-like values used to represent system resources or Input/Output devices. Accessing or writing to an interface may produce side-effects.</li>
</ul>

<p>Lil has a soft, spongy, dynamic type system in which values do their best to convert to a more relevant type as the need arises.</p>

<ul>
<li>When a number is required, strings are parsed, and lists or dictionaries attempt to convert their first <em>element</em>. Otherwise, the number 0 is used.</li>
<li>When a string is required, numbers are formatted, and lists are recursively converted to strings and joined. Otherwise, the empty string is used.</li>
<li>When a list is required, strings are treated as a list of their characters (each a length-1 string), dictionaries are treated as their value list, tables are treated as the list of their rows, each a dictionary, and anything else (number, function, interface) is enclosed in a length-1 list.</li>
<li>When a dictionary is required, strings and lists become dictionaries from their indices to their <em>elements</em>, tables become dictionaries of their columns, and otherwise an empty dictionary is used.</li>
<li>When a table is required, lists become a single-column “value” table, and dictionaries become two-column “key” and “value” tables. Anything else is interpreted as if it were a list.</li>
</ul>

<p>When indexing into values, we will uniformly refer to <em>elements</em>:</p>

<ul>
<li>An <em>element</em> of a number is itself.</li>
<li>An <em>element</em> of a string is a character, which itself is a length-1 string.</li>
<li>An <em>element</em> of a list is one of its items.</li>
<li>An <em>element</em> of a dictionary is one of its values.</li>
<li>An <em>element</em> of a table is one of its rows, as a dictionary.</li>
<li>An <em>element</em> of an <em>empty</em> string, list, dictionary, or table is the number 0.</li>
</ul>

<p>The number zero and the empty string, list, or dictionary are all <em>falsey</em>, and any other value (including <em>any</em> table, function, or interface) is <em>truthy</em>.</p>

<h2 id="liltheimperativelanguage">Lil, the Imperative Language</h2>

<p>Lil scripts are a sequence of expressions, including literal values, references or assignments to variables, conditionals (<code>if</code>), <code>each</code> and <code>while</code> loops, and function declarations (<code>on</code>).</p>

<p>Variable and function names may contain any alphanumeric characters (as well as <code>?</code> and <code>_</code>), but must not start with a number. Variable assignments use the symbol <code>:</code>, read as “gets” or “becomes”:</p>

<pre><code>a: 23
longer_name: &#34;a string&#34;
</code></pre>

<p>If a value has never been explicitly placed in a variable, it contains the number 0. You can access or assign to elements of a list or dictionary by subscripting with brackets:</p>

<pre><code>(11,22,33)[1]
&#34;String&#34;[2]
l[4]:2
d[&#34;fruit&#34;]:&#34;apple&#34;
</code></pre>

<p>For convenience, indexing may also be performed with “dot notation”, where a name after the dot is treated as a string index. These expressions are equivalent:</p>

<pre><code>d[&#34;fruit&#34;]:&#34;cherry&#34;
d.fruit:&#34;cherry&#34;
</code></pre>

<p>If you index a list with integers within range of its <code>count</code> it will act like a list. If you index a list like a dictionary- with keys that are <em>not</em> integers within range of its <code>count</code>- it will become a dictionary.</p>

<pre><code>b: 5              # b contains the number 5
b[0]: 5           # b becomes a length-1 list containing the number 5
c                 # c contains the number 0
c.fruit: &#34;yes&#34;    # c now contains a dictionary with the key &#34;fruit&#34; and the value &#34;yes&#34;
</code></pre>

<p>When the leftmost part of an assignment expression is an expression- not just a variable name- the value of that expression is <em>amended</em> and a new value with appropriate changes is returned:</p>

<pre><code>(11,22,33)[1]:44  # produces the list (11,44,33)
&#34;Cat&#34;[1]:&#34;ive&#34;    # produces the string &#34;Civet&#34;
().baz:99         # amend the empty list at index &#34;baz&#34; (promoting it to a dictionary) with the value 99,
                  # producing the single-element dictionary {&#34;baz&#34;:99}
(11,22).baz:33    # extend (11,22) into a dictionary, and bind &#34;baz&#34;, giving {0:11,1:22,&#34;baz&#34;:33}
</code></pre>

<p>Note the important distinctions between these similar-looking cases:</p>

<pre><code>foo:11,22,33

foo[1]:44     # get the value in &#34;foo&#34;, amend it at index 1, and store the amended list in &#34;foo&#34; again.

(foo)[1]:44   # the parenthesized portion is a subexpression which gets the value in &#34;foo&#34;.
              # amend it at index 1, and return the amended list, leaving &#34;foo&#34; unchanged.

(foo[1]):44   # this is not syntactically valid!
              # assignment to a subexpression must have a dotted or bracketed index.
</code></pre>

<p>If you index with a dot followed immediately by another dot or open-bracket it means “each element”. Use this for drilling into nested lists or dictionaries:</p>

<pre><code>t:(&#34;AB&#34;,&#34;CD&#34;,&#34;EFG&#34;)

t[1]        # &#34;CD&#34;             # the 1st element of t
t.[1]       # (&#34;B&#34;,&#34;D&#34;,&#34;F&#34;)    # the 1st element of each element of t

d.a.key:&#34;apple&#34;
d.b.key:&#34;pear&#34;

d           # {&#34;a&#34;:{&#34;key&#34;:&#34;apple&#34;},&#34;b&#34;:{&#34;key&#34;:&#34;pear&#34;}}
d.a         # {&#34;key&#34;:&#34;apple&#34;}
d.a.key     # &#34;apple&#34;
d..key      # {&#34;a&#34;:&#34;apple&#34;,&#34;b&#34;:&#34;pear&#34;}
</code></pre>

<hr/>

<p>Lil has a number of unary and binary operators- see appendix 1 and 2 for details. Many, like <code>+</code> and <code>*</code>, should be familiar from mathematics or other programming langugages. The most important thing to remember in Lil is that expressions have uniform operator precedence: expressions are always carried out right-to-left, unless explicitly parenthesized:</p>

<pre><code>3*2+5    # 21
3*(2+5)  # 21
(3*2)+5  # 11
</code></pre>

<p>You can make decisions with <code>if</code>. The keyword <code>if</code> is followed by a conditional expression, one or more statements, and finally the keyword <code>end</code>. The statements inside the <code>if ... end</code> will only be executed if the conditional expression has a truthy value. You can also optionally include an <code>else</code> keyword to divide the body of the <code>if</code> into a truthy half and a falsey half.</p>

<pre><code>if 1&gt;2
	&#34;narp&#34;  # this doesn&#39;t happen
end

if 5
	&#34;yarp&#34;  # 5 is truthy, so this does happen!
end

if 5
	&#34;also yarp&#34;  # this happens...
else
	&#34;also narp&#34;  # but this does not!
end
</code></pre>

<p>You can iterate over the elements of a value with an <code>each</code> loop. The keyword <code>each</code> is followed by zero or more variable names, the keyword <code>in</code>, an expression giving the <em>source</em> to iterate over, one or more statements forming the “body” of the loop, and finally the keyword <code>end</code>. The <em>source</em> is always treated as a dictionary, and for each iteration of the loop the variable names provided are assigned to the <em>value</em>, <em>key</em>, and <em>index</em> of the current pairing in that dictionary. For a list, <em>key</em> and <em>index</em> will naturally be identical. Here are a few examples of <code>each</code> loops:</p>

<pre><code>each x in 3,5,7
	x
end

each val key in d
	val,key
end

r:0
each x in range 10
	r:r+x
end
</code></pre>

<p>You can also repeat a body of code an indefinite number of times with a <code>while</code> loop. The keyword <code>while</code> is followed by a conditional expression, one or more statements forming the “body” of the loop, and finally the keyword <code>end</code>. The conditional expression is evaluated before each iteration of the loop, and the loop stops if this ever results in a falsey value. Here’s an example:</p>

<pre><code>a:5
while a&gt;3
	print[a]     # prints 5, then 4, then stops.
	a:a-1
end
</code></pre>

<p>To declare a function, use the keyword <code>on</code> followed by a name, zero or more argument names, the keyword <code>do</code>, one or more statements comprising the “body” of the function, and finally the keyword <code>end</code>. To call a function, use its name and a set of bracketed expressions corresponding to the arguments it takes. Extra arguments are ignored, and missing arguments are bound as 0:</p>

<pre><code>on pair x y do
	x,y
end

pair[3 5]    # returns a list of 3 and 5
pair[3]      # returns a list of 3 and 0
pair[3 5 7]  # returns a list of 3 and 5

pair[3,5]    # careful: &#39;,&#39; joins items into lists- it is not an argument separator!
pair 3 5     # wrong: this is three separate statements, not a function call!
</code></pre>

<h2 id="lilthefunctionallanguage">Lil, the Functional Language</h2>

<p>As we’ve seen above, thinking about Lil as an everyday garden-variety imperative language is perfectly sufficient for writing scripts. Some characteristics, though, make it well-suited to the <em>functional</em> style of programming, in which we aim to minimize mutation, compose our program from functions which do not have “side-effects”, and make use of so-called “higher-order” functions- functions which take functions as arguments.</p>

<p>Values in Lil are truly <em>values</em>. They have copy-on-write semantics: an assignment to part of a value creates an entirely new value, leaving any other references to the original value unchanged:</p>

<pre><code>a:1,2,3
b:a
b[1]:5
show[a]  # 1,2,3
show[b]  # 1,5,3
</code></pre>

<p>Statements in Lil are always <em>expressions</em>. That is, they always return a value and can be composed within larger expressions. Assignments evaluate to the value being assigned. <code>if</code> returns the value of the last statement in its taken half. (A missing <code>else</code> just means the falsey half evaluates to 0.) <code>while</code> likewise evaluates to the last statement on the last iteration of its body:</p>

<pre><code>x:y:z                       # assign both x and y the value of z
a: if x&gt;5 99 else 33 end    # assign a to either 99 or 33
c: while b&lt;100 b:b*2 end    # assign c to 128
</code></pre>

<p>The <code>each</code> loop collects together the results of <em>each</em> iteration of the loop and returns them. If the input was a dictionary, the output will be a dictionary with the same keys. Otherwise, the output will be a list. Some other languages call this operation <em>map</em>:</p>

<pre><code>each x in 3,5,7   # (300,500,700)
	x*100
end

t.foo:&#34;one&#34;
t.bar:&#34;three&#34;

each v in t       # {&#34;foo&#34;:3,&#34;bar&#34;:5}
	count v
end
</code></pre>

<p>You can pass functions to other functions by name:</p>

<pre><code>on apply func do
	func[&#34;two&#34;]
end
on twice x do
	x,x
end
apply[twice]    # (&#34;two&#34;,&#34;two&#34;)
</code></pre>

<p>Since <code>on...end</code> is an expression, you can also directly substitute it into the call, just as with “anonymous” or “lambda” functions in other languages.</p>

<pre><code>apply[on thrice x do x,x,x end]
</code></pre>

<p>One advantage of functions always having a bound name is that there’s no special combinator plumbing required for anonymous recursion. If the name never matters, consider using the name <code>_</code> to signal your intent.</p>

<p>Lil uses <em>lexical scope</em>: variables will resolve to the closest nested binding available, and the local variables of a caller to a function will not be visible or modified by the callee (unless the callee’s definition is nested in the caller):</p>

<pre><code>global:333
on quux x do
	local:99
	x[77]
	print[local]           # 99
end
on zami x do
	local:23
	print[global,local,x]  # 333,23,77
end
quux[zami]
</code></pre>

<p>Furthermore, functions close over variables in their lexical scope, allowing for encapsulated “objects” with their own mutable state:</p>

<pre><code>on counter x do
	on inc do
		x:x+1
	end
end
a:counter[100]
b:counter[200]
print[a[]]        # 101
print[a[]]        # 102
print[b[]]        # 201
print[a[]]        # 103
print[x  ]        # 0
</code></pre>

<p>Whenever an assignment is carried out, if the variable name in question has been assigned to in any surrounding lexical scope, the assignment will update the <em>closest</em> definition. If the name has never been assigned to before, a new local variable will be created at the current scope. The <code>on</code>, <code>each</code>, and query (<code>select</code>, <code>update</code>, <code>extract</code>) statements always create new local variables for their arguments, loop variables, or columns, and can thus <em>shadow</em> (take precedence over) outer local variables of the same name. When in doubt, use unique names; it’s much less confusing!</p>

<p>Finally, if you’re mentally wed to the idea of expressing algorithms recursively, you may be pleased to discover that Lil supports <em>tail-call elimination</em>. If a recursive function calls itself (or another function) as the final operation in the function, it will not consume extra stack space:</p>

<pre><code>on addrec x y do
	if x&gt;0
		1+addrec[x-1 y]  # addition happens after call returns. not tail-recursive!
	else
		y
	end
end

on addtail x y do
	if x&gt;0
		addtail[x-1 y+1]  # tail-recursive call.
	else
		y
	end
end
addtail[80000 5]  # this won&#39;t blow the stack.
</code></pre>

<h2 id="lilthequerylanguage">Lil, the Query Language</h2>

<p>So far, we haven’t looked much at tables. While one can operate on tables by indexing them or iterate over their contents with an <code>each</code> loop, the real power of tables comes from Lil’s query syntax, which resembles a simplified version of SQL. Unlike some of their SQL counterparts, <code>select</code>, <code>extract</code>, <code>update</code>, and <code>insert</code> are all pure operations which strictly return a <em>new</em> value as a result.</p>

<p><code>select</code> is used for querying a table, and obtaining a table of results. It is followed by a sequence of column expressions (possibly with names), optionally a <code>where</code>, <code>by</code>, and/or <code>orderby</code> clause, each of which should produce a list of results for each row, the keyword <code>from</code>, and then finally an expression giving the source table. In the context of these clauses- and when computing result columns- the columns of the table will be bound as variables.</p>

<p>In a <code>select</code>, <code>extract</code> or <code>update</code>, clauses are carried out in the following order:</p>

<ul>
<li>rows are filtered down to only those with a truthy result in the <code>where</code> clause. (The implicit <code>index</code> column represents their original row numbers.)</li>
<li>rows are grouped by the values in the <code>by</code> clause, in order of appearance. (The implicit <code>gindex</code> column represents each row’s original index within its group, and the implicit <code>group</code> column represents the index of the group each row belongs to.)</li>
<li>each group is sorted according to the values in the <code>orderby</code> clause, either ascending (<code>asc</code>) or descending (<code>desc</code>). As with <code>&lt;</code> and <code>&gt;</code>, numbers are sorted by value, and anything else is sorted lexicographically by its string equivalent.</li>
<li>for each group, result columns are computed.</li>
<li>for each group, result columns are <em>rectangularized</em>: the group will have as many result rows as the column of maximum <code>count</code>.</li>
<li>rows are ungrouped: result rows across all groups are concatenated, preserving their grouped order. (This may change the <em>overall</em> order- see <code>update</code> if you want to preserve it.)</li>
</ul>

<p>Given a simple table:</p>

<pre><code>people.name:&#34;Alice&#34;,&#34;Sam&#34;,&#34;Thomas&#34;,&#34;Sara&#34;,&#34;Walter&#34;
people.age:25,28,40,34,43
people.job:&#34;Developer&#34;,&#34;Sales&#34;,&#34;Developer&#34;,&#34;Developer&#34;,&#34;Accounting&#34;
people:table people
</code></pre>

<p>Let’s perform some selections:</p>

<pre><code>select from people       # select all columns, like &#34;select *&#34; in SQL
# +----------+-----+--------------+
# | name     | age | job          |
# +----------+-----+--------------+
# | &#34;Alice&#34;  | 25  | &#34;Developer&#34;  |
# | &#34;Sam&#34;    | 28  | &#34;Sales&#34;      |
# | &#34;Thomas&#34; | 40  | &#34;Developer&#34;  |
# | &#34;Sara&#34;   | 34  | &#34;Developer&#34;  |
# | &#34;Walter&#34; | 43  | &#34;Accounting&#34; |
# +----------+-----+--------------+

select name from people      # select a specific column
# +----------+
# | name     |
# +----------+
# | &#34;Alice&#34;  |
# | &#34;Sam&#34;    |
# | &#34;Thomas&#34; |
# | &#34;Sara&#34;   |
# | &#34;Walter&#34; |
# +----------+

select firstName:name dogYears:7*age from people     # compute and rename columns
# +-----------+----------+
# | firstName | dogYears |
# +-----------+----------+
# | &#34;Alice&#34;   | 175      |
# | &#34;Sam&#34;     | 196      |
# | &#34;Thomas&#34;  | 280      |
# | &#34;Sara&#34;    | 238      |
# | &#34;Walter&#34;  | 301      |
# +-----------+----------+

select name where (&#34;S%m&#34; parse name) from people     # where takes a boolean (0/1) column
# +--------+
# | name   |
# +--------+
# | &#34;Sam&#34;  |
# | &#34;Sara&#34; |
# +--------+

select name index orderby name asc from people     # orderby takes a column of values and &#34;asc&#34; or &#34;desc&#34;
# +----------+-------+
# | name     | index |
# +----------+-------+
# | &#34;Alice&#34;  | 0     |
# | &#34;Sam&#34;    | 1     |
# | &#34;Sara&#34;   | 3     |
# | &#34;Thomas&#34; | 2     |
# | &#34;Walter&#34; | 4     |
# +----------+-------+

select name job by job orderby name asc from people     # sort names within each group
# +----------+--------------+
# | name     | job          |
# +----------+--------------+
# | &#34;Alice&#34;  | &#34;Developer&#34;  |
# | &#34;Sara&#34;   | &#34;Developer&#34;  |
# | &#34;Thomas&#34; | &#34;Developer&#34;  |
# | &#34;Sam&#34;    | &#34;Sales&#34;      |
# | &#34;Walter&#34; | &#34;Accounting&#34; |
# +----------+--------------+
</code></pre>

<p>All result columns will be repeated to match the <code>count</code> of the longest result. Thus, if all the new columns yield a non-listy result, the group is effectively collapsed into a summary row:</p>

<pre><code>select employed:(count name) job by job from people
# +----------+--------------+
# | employed | job          |
# +----------+--------------+
# | 3        | &#34;Developer&#34;  |
# | 3        | &#34;Developer&#34;  |
# | 3        | &#34;Developer&#34;  |
# | 1        | &#34;Sales&#34;      |
# | 1        | &#34;Accounting&#34; |
# +----------+--------------+

select employed:(count name) job:(first job) by job from people
# +----------+--------------+
# | employed | job          |
# +----------+--------------+
# | 3        | &#34;Developer&#34;  |
# | 1        | &#34;Sales&#34;      |
# | 1        | &#34;Accounting&#34; |
# +----------+--------------+
</code></pre>

<p>When computing columns, you’re working with lists of elements, and taking advantage of the fact that primitives like <code>&lt;</code> and <code>+</code> automatically “spread” to lists. If you want to call your own functions- say, to average within a grouped column- write them to accept a list like so:</p>

<pre><code>on avg x do ((sum x) / count x) end

select job:(first job) avg_age:avg[age] by job from people
# +--------------+---------+
# | job          | avg_age |
# +--------------+---------+
# | &#34;Developer&#34;  | 33      |
# | &#34;Sales&#34;      | 28      |
# | &#34;Accounting&#34; | 43      |
# +--------------+---------+
</code></pre>

<p>The same applies to any functions called in a <code>where</code>, <code>by</code>, or <code>orderby</code> expression. The predefined aggregation functions <code>sum</code>, <code>raze</code>, <code>min</code>, and <code>max</code> may come in handy!</p>

<hr/>

<p>The <code>update</code> statement has the same syntax and clauses as <code>select</code>, but behaves differently: results are merged with the original table, and the original order of rows is preserved. <code>orderby</code> can be used with <code>update</code>, but will only impact the inputs to column expressions, not the order of the result rows.</p>

<pre><code>update job:&#34;Engineer&#34; where job=&#34;Developer&#34; from people
# +----------+-----+--------------+
# | name     | age | job          |
# +----------+-----+--------------+
# | &#34;Alice&#34;  | 35  | &#34;Engineer&#34;   |
# | &#34;Sam&#34;    | 28  | &#34;Sales&#34;      |
# | &#34;Thomas&#34; | 50  | &#34;Engineer&#34;   |
# | &#34;Sara&#34;   | 44  | &#34;Engineer&#34;   |
# | &#34;Walter&#34; | 43  | &#34;Accounting&#34; |
# +----------+-----+--------------+
</code></pre>

<p>As with <code>select</code> you can compute new named columns- values will be filled in with 0 for rows masked off by a <code>where</code> clause.</p>

<pre><code>update manager:random[name] where job=&#34;Developer&#34; from people
# +----------+-----+--------------+---------+
# | name     | age | job          | manager |
# +----------+-----+--------------+---------+
# | &#34;Alice&#34;  | 25  | &#34;Developer&#34;  | &#34;Sara&#34;  |
# | &#34;Sam&#34;    | 28  | &#34;Sales&#34;      | 0       |
# | &#34;Thomas&#34; | 40  | &#34;Developer&#34;  | &#34;Sara&#34;  |
# | &#34;Sara&#34;   | 34  | &#34;Developer&#34;  | &#34;Sara&#34;  |
# | &#34;Walter&#34; | 43  | &#34;Accounting&#34; | 0       |
# +----------+-----+--------------+---------+
</code></pre>

<hr/>

<p>When mixing queries with other types of code, it may be very useful to execute a query and get back simple lists, strings, or numbers. The <code>extract</code> statement is another variation on <code>select</code> which unpacks its result directly into a value, instead of a result column in a table:</p>

<pre><code>jobs:extract first job by job from people
# (&#34;Developer&#34;,&#34;Sales&#34;,&#34;Accounting&#34;)
</code></pre>

<p><code>extract</code> gives you access to a variety of useful operations for tables, dictionaries, or even lists:</p>

<pre><code>extract value orderby value asc from jobs              # sort a list
# (&#34;Accounting&#34;,&#34;Developer&#34;,&#34;Sales&#34;)

extract index orderby value asc from jobs              # grade a list
# (2,0,1)

extract value orderby index desc from jobs             # reverse a list
# (&#34;Accounting&#34;,&#34;Sales&#34;,&#34;Developer&#34;)

extract list index by value from &#34;ABBAAC&#34;              # group a list
# ((0,3,4),(1,2),(5))

extract list value by floor index/3 from &#34;ABCDEFGHI&#34;   # partition a list
# ((&#34;A&#34;,&#34;B&#34;,&#34;C&#34;),(&#34;D&#34;,&#34;E&#34;,&#34;F&#34;),(&#34;G&#34;,&#34;H&#34;,&#34;I&#34;))

extract first value by value from &#34;ABBAAC&#34;             # distinct items in a list
# (&#34;A&#34;,&#34;B&#34;,&#34;C&#34;)
</code></pre>

<p>If names are specified, all results are collected into a dictionary:</p>

<pre><code>extract a:first age b:last age orderby age asc from people 
# {&#34;a&#34;:25,&#34;b&#34;:43}
</code></pre>

<hr/>

<p>The <code>insert</code> statement adds new rows to a table. It is followed by a sequence of one or more column names followed by a colon and an expression, the <code>into</code> keyword, and an expression evaluating to a table.</p>

<pre><code>insert name:&#34;John&#34; job:&#34;Writer&#34; age:32 into people
# +----------+-----+--------------+
# | name     | age | job          |
# +----------+-----+--------------+
# | &#34;Alice&#34;  | 25  | &#34;Developer&#34;  |
# | &#34;Sam&#34;    | 28  | &#34;Sales&#34;      |
# | &#34;Thomas&#34; | 40  | &#34;Developer&#34;  |
# | &#34;Sara&#34;   | 34  | &#34;Developer&#34;  |
# | &#34;Walter&#34; | 43  | &#34;Accounting&#34; |
# | &#34;John&#34;   | 32  | &#34;Writer&#34;     |
# +----------+-----+--------------+
</code></pre>

<p>Missing columns will be filled in as 0. If any of the <code>insert</code>ed values are lists, the remaining columns will be spread to match:</p>

<pre><code>insert name:(&#34;John&#34;,&#34;Eric&#34;) age:32 zodiac:(&#34;Taurus&#34;,&#34;Virgo&#34;) into people
# +----------+-----+--------------+----------+
# | name     | age | job          | zodiac   |
# +----------+-----+--------------+----------+
# | &#34;Alice&#34;  | 25  | &#34;Developer&#34;  | 0        |
# | &#34;Sam&#34;    | 28  | &#34;Sales&#34;      | 0        |
# | &#34;Thomas&#34; | 40  | &#34;Developer&#34;  | 0        |
# | &#34;Sara&#34;   | 34  | &#34;Developer&#34;  | 0        |
# | &#34;Walter&#34; | 43  | &#34;Accounting&#34; | 0        |
# | &#34;John&#34;   | 32  | 0            | &#34;Taurus&#34; |
# | &#34;Eric&#34;   | 32  | 0            | &#34;Virgo&#34;  |
# +----------+-----+--------------+----------+
</code></pre>

<p>As a special case, if the value to insert into is a number, treat it as an empty table. This is a convenient way to make a table from scratch:</p>

<pre><code>insert name:(&#34;John&#34;,&#34;Eric&#34;) age:32 zodiac:(&#34;Taurus&#34;,&#34;Virgo&#34;) into 0
# +--------+-----+----------+
# | name   | age | zodiac   |
# +--------+-----+----------+
# | &#34;John&#34; | 32  | &#34;Taurus&#34; |
# | &#34;Eric&#34; | 32  | &#34;Virgo&#34;  |
# +--------+-----+----------+
</code></pre>

<hr/>

<p>Lil also offers two basic joining operations: <code>join</code> (natural join), and <code>cross</code> (cartesian/cross join):</p>

<pre><code>jobs:insert job:&#34;Sales&#34;,&#34;Developer&#34;,&#34;Accounting&#34;,&#34;Facilities&#34; salary:85000,75000,60000,50000 into 0
# +--------------+--------+
# | job          | salary |
# +--------------+--------+
# | &#34;Sales&#34;      | 85000  |
# | &#34;Developer&#34;  | 75000  |
# | &#34;Accounting&#34; | 60000  |
# | &#34;Facilities&#34; | 50000  |
# +--------------+--------+

people join jobs
# +----------+-----+--------------+--------+
# | name     | age | job          | salary |
# +----------+-----+--------------+--------+
# | &#34;Alice&#34;  | 25  | &#34;Developer&#34;  | 75000  |
# | &#34;Sam&#34;    | 28  | &#34;Sales&#34;      | 85000  |
# | &#34;Thomas&#34; | 40  | &#34;Developer&#34;  | 75000  |
# | &#34;Sara&#34;   | 34  | &#34;Developer&#34;  | 75000  |
# | &#34;Walter&#34; | 43  | &#34;Accounting&#34; | 60000  |
# +----------+-----+--------------+--------+

guests:insert name:&#34;Alice&#34;,&#34;Joan&#34;,&#34;Oscar&#34;,&#34;Thomas&#34; into 0
# +----------+
# | name     |
# +----------+
# | &#34;Alice&#34;  |
# | &#34;Joan&#34;   |
# | &#34;Oscar&#34;  |
# | &#34;Thomas&#34; |
# +----------+

select a:name b:name_ where name &lt; name_ from guests cross guests
# +---------+----------+
# | a       | b        |
# +---------+----------+
# | &#34;Alice&#34; | &#34;Joan&#34;   |
# | &#34;Alice&#34; | &#34;Oscar&#34;  |
# | &#34;Joan&#34;  | &#34;Oscar&#34;  |
# | &#34;Alice&#34; | &#34;Thomas&#34; |
# | &#34;Joan&#34;  | &#34;Thomas&#34; |
# | &#34;Oscar&#34; | &#34;Thomas&#34; |
# +---------+----------+
</code></pre>

<p>For a row-wise join- concatenating tables with the same columns- you can simply use <code>,</code>, which has the same padding/widening behavior as <code>insert</code>. You can likewise <code>take</code> or <code>drop</code> rows or columns from a table. If the left argument to <code>take</code> is a list of numbers, it picks out those rows very much like a generalization of <code>select</code>:</p>

<pre><code>&#34;name&#34; take people
# +----------+
# | name     |
# +----------+
# | &#34;Alice&#34;  |
# | &#34;Sam&#34;    |
# | &#34;Thomas&#34; |
# | &#34;Sara&#34;   |
# | &#34;Walter&#34; |
# +----------+

(&#34;age&#34;,&#34;job&#34;) take people
# +-----+--------------+
# | age | job          |
# +-----+--------------+
# | 25  | &#34;Developer&#34;  |
# | 28  | &#34;Sales&#34;      |
# | 40  | &#34;Developer&#34;  |
# | 34  | &#34;Developer&#34;  |
# | 43  | &#34;Accounting&#34; |
# +-----+--------------+

3 drop people
# +----------+-----+--------------+
# | name     | age | job          |
# +----------+-----+--------------+
# | &#34;Sara&#34;   | 34  | &#34;Developer&#34;  |
# | &#34;Walter&#34; | 43  | &#34;Accounting&#34; |
# +----------+-----+--------------+

(0,2,3) take people
# +----------+-----+-------------+
# | name     | age | job         |
# +----------+-----+-------------+
# | &#34;Alice&#34;  | 25  | &#34;Developer&#34; |
# | &#34;Thomas&#34; | 40  | &#34;Developer&#34; |
# | &#34;Sara&#34;   | 34  | &#34;Developer&#34; |
# +----------+-----+-------------+
</code></pre>

<p>The <code>flip</code> of a table transposes its data, promoting the first column (or, if it exists, a column named <code>key</code>) from the original table to column keys for the result:</p>

<pre><code>expenses: insert kind:&#34;tax&#34;,&#34;gas&#34;,&#34;power&#34;,&#34;food&#34; jan:11,22,33,44 feb:55,66,77,88 into 0
# +---------+-----+-----+
# | kind    | jan | feb |
# +---------+-----+-----+
# | &#34;tax&#34;   | 11  | 55  |
# | &#34;gas&#34;   | 22  | 66  |
# | &#34;power&#34; | 33  | 77  |
# | &#34;food&#34;  | 44  | 88  |
# +---------+-----+-----+

flip expenses
# +-------+-----+-----+-------+------+
# | key   | tax | gas | power | food |
# +-------+-----+-----+-------+------+
# | &#34;jan&#34; | 11  | 22  | 33    | 44   |
# | &#34;feb&#34; | 55  | 66  | 77    | 88   |
# +-------+-----+-----+-------+------+
</code></pre>

<p>The <code>key</code> column makes the <code>flip</code> of a table a reversible operation. If you don’t need the original keys, you can discard them with <code>drop</code>:</p>

<pre><code>&#34;key&#34; drop flip expenses
# +-----+-----+-------+------+
# | tax | gas | power | food |
# +-----+-----+-------+------+
# | 11  | 22  | 33    | 44   |
# | 55  | 66  | 77    | 88   |
# +-----+-----+-------+------+
</code></pre>

<hr/>

<p>In general, use <code>select</code> for narrowing down or summarizing tables, <code>update</code> for making changes to a table while preserving or extending its existing structure, <code>extract</code> for pulling data out of a table for use elsewhere, and <code>insert</code> to make new tables or append to existing ones.</p>

<p>It may also be helpful to think in terms of how the shape of output tables relates to input tables for various table operations:</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th> Query Statement </th>
	<th> Output Rows </th>
	<th> Output Columns </th>
</tr>
</thead>

<tbody>
<tr>
	<td> <code>select</code>  </td>
	<td> &lt;= input </td>
	<td> any number  </td>
</tr>
<tr>
	<td> <code>update</code>  </td>
	<td> = input </td>
	<td> &gt;= input  </td>
</tr>
<tr>
	<td> <code>insert</code>  </td>
	<td> &gt;= input </td>
	<td> = input  </td>
</tr>
<tr>
	<td> <code>extract</code>  </td>
	<td> &lt;= input </td>
	<td> n/a    </td>
</tr>
<tr>
	<td> <code>join</code>   </td>
	<td> &lt;= x * y </td>
	<td> &lt; x + y   </td>
</tr>
<tr>
	<td> <code>cross</code>   </td>
	<td> = x * y </td>
	<td> = x + y   </td>
</tr>
<tr>
	<td> <code>flip</code>   </td>
	<td> x columns </td>
	<td> x rows   </td>
</tr>
</tbody>
</table>

<h2 id="liltheformattinglanguage">Lil, the Formatting Language</h2>

<p>The <code>parse</code> and <code>format</code> primitives are used for breaking strings apart into Lil values, and formatting Lil values into a customizable string representation, respectively. Both take as their left argument a <em>format string</em> with a concise notation for controlling these processes. In many cases, these format strings are symmetrical: the <code>parse</code> of the <code>format</code> under the same Format string will be an identity operation, and vice versa:</p>

<pre><code>f: &#34;0x%04h&#34;       # a four-digit zero-padded lowercase hexadecimal number with an &#39;0x&#39; prefix
f format 123      # &#34;0x007b&#34;
f parse &#34;0x007b&#34;  # 123
</code></pre>

<p>Format strings consist of a sequence of <em>patterns</em> and <em>literals</em>. Patterns always begin with a <code>%</code> character, may contain several optional <em>flags</em>, and end in an alphabetic character. Pattern <em>flags</em> configure the details of how each pattern behaves, and may appear in the structure <code>%*-0N.DX</code>, where <code>N</code> and <code>D</code> may be 1 or more digits 0–9, and <code>X</code> is a pattern type. All flags are optional. If present, their meanings are as follows:</p>

<ul>
<li><code>*</code> this pattern will be validated, but will not produce output values. When formatting, instead of consuming an input value, these patterns will use the appropriate null value.</li>
<li><code>-</code> specifies left-justification for <code>N</code>, as decribed below. The default is right-justification. The <code>%r</code>/<code>%o</code> patterns use <code>-</code> to invert the set of valid characters.</li>
<li><code>0</code> specifies padding with <code>0</code> for <code>N</code>, as described below. The default is padding with spaces.</li>
<li><code>N</code> indicates that the value will be padded to at least <code>N</code> characters, using the justification and padding character selected with <code>-</code> and <code>0</code>.</li>
<li><code>.D</code> for <code>%f</code>/<code>%c</code>, the value should be formatted with exactly <code>D</code> decimal places. The <code>%r</code>/<code>%o</code> patterns use <code>D</code> to indicate a number of valid characters. For any other type, the formatted string will be truncated at <code>D</code> characters, respecting justification.</li>
</ul>

<p>Pattern types are as follows:</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th> Type </th>
	<th> Null </th>
	<th> Parsed               </th>
	<th> Formatted           </th>
</tr>
</thead>

<tbody>
<tr>
	<td> <code>%</code> </td>
	<td> n/a </td>
	<td> literal <code>%</code> character. <code>*</code> is implied.       </td>
	<td> <code>%</code>             </td>
</tr>
<tr>
	<td> <code>n</code> </td>
	<td> n/a </td>
	<td> number of chars that have been read.       </td>
	<td> nothing.            </td>
</tr>
<tr>
	<td> <code>m</code> </td>
	<td> n/a </td>
	<td> matched? value is <code>1</code> iff the format has matched so far.  </td>
	<td> nothing.            </td>
</tr>
<tr>
	<td> <code>z</code> </td>
	<td> n/a </td>
	<td> value is <code>1</code> iff the format matches and read the whole input. </td>
	<td> nothing.            </td>
</tr>
<tr>
	<td> <code>s</code> </td>
	<td> <code>&#34;&#34;</code> </td>
	<td> string. read N chars or until next literal.     </td>
	<td> any string, up to <code>D</code> chars.       </td>
</tr>
<tr>
	<td> <code>u</code> </td>
	<td> <code>&#34;&#34;</code> </td>
	<td> uppercase string. just like <code>s</code>, but converts to uppercase. </td>
	<td> any string, up to <code>D</code> chars, converted to uppercase. </td>
</tr>
<tr>
	<td> <code>l</code> </td>
	<td> <code>&#34;&#34;</code> </td>
	<td> lowercase string. just like <code>s</code>, but converts to lowercase. </td>
	<td> any string, up to <code>D</code> chars, converted to lowercase. </td>
</tr>
<tr>
	<td> <code>r</code> </td>
	<td> <code>&#34;&#34;</code> </td>
	<td> repeat. 0 or more (or <code>N</code>) characters within a valid set.  </td>
	<td> any string, exactly <code>N</code> chars if specified.   </td>
</tr>
<tr>
	<td> <code>o</code> </td>
	<td> <code>&#34;&#34;</code> </td>
	<td> optional. 0 or 1 (or <code>N</code>) characters within a valid set.  </td>
	<td> any string, exactly <code>N</code> chars if specified.   </td>
</tr>
<tr>
	<td> <code>a</code> </td>
	<td> <code>()</code> </td>
	<td> ASCII. reads like <code>s</code>; value is list of ASCII ordinals.  </td>
	<td> list of ASCII ordinals converted to a string.  </td>
</tr>
<tr>
	<td> <code>b</code> </td>
	<td> <code>0</code> </td>
	<td> reads like <code>s</code>; value is <code>1</code> iff first char is in <code>tTyYx1</code>. </td>
	<td> any value to <code>true</code> or <code>false</code> based on truthiness. </td>
</tr>
<tr>
	<td> <code>f</code> </td>
	<td> <code>0.0</code> </td>
	<td> Lil float. allows any number of decimals.      </td>
	<td> show <code>D</code> decimal places or however many are needed. </td>
</tr>
<tr>
	<td> <code>c</code> </td>
	<td> <code>0.0</code> </td>
	<td> currency. parses values like <code>-$1.23</code> to Lil floats.   </td>
	<td> show <code>D</code> or 2 decimal places, like <code>-$1.23</code>.   </td>
</tr>
<tr>
	<td> <code>i</code> </td>
	<td> <code>0</code> </td>
	<td> signed integer.            </td>
	<td> signed integer.          </td>
</tr>
<tr>
	<td> <code>h</code> </td>
	<td> <code>0</code> </td>
	<td> hexadecimal integer. parses lower- or uppercase.    </td>
	<td> format int as hexadecimal in lowercase.    </td>
</tr>
<tr>
	<td> <code>H</code> </td>
	<td> <code>0</code> </td>
	<td> hexadecimal integer. parses lower- or uppercase.    </td>
	<td> format int as hexadecimal in uppercase.    </td>
</tr>
<tr>
	<td> <code>j</code> </td>
	<td> <code>0</code> </td>
	<td> a <a href="https://www.json.org">JSON</a> value.       </td>
	<td> any value to a JSON string.       </td>
</tr>
<tr>
	<td> <code>e</code> </td>
	<td> <code>0</code> </td>
	<td> read ISO-8601 date-time into a unix epoch int.     </td>
	<td> format unix epoch int as ISO-8601 date-time.   </td>
</tr>
<tr>
	<td> <code>p</code> </td>
	<td> <code>()</code> </td>
	<td> read ISO-8601 date-time as a dictionary of time parts.   </td>
	<td> format dict as ISO-8601.        </td>
</tr>
</tbody>
</table>

<p>When parsing, each pattern will be matched against input in sequence, consuming some number of input characters and producing output values, and literals will be expected; if at any point a pattern or literal fails to match against input, parsing will cease, and any subsequent patterns in the format string will yield appropriate “null” values. Thus, a given format string will always yield a fixed number of results, no matter the input. In the case where there is <em>exactly one</em> value-yielding pattern in the format string, <code>parse</code> output will simply be that value instead of a list.</p>

<pre><code>&#34;%f %s %i&#34; parse &#34;12 apples&#34;                        # (12,&#34;apples&#34;,0)
&#34;%f %ss&#34; parse &#34;12 apples&#34;                          # (12,&#34;apple&#34;)
(&#34;amount&#34;,&#34;noun&#34;) dict &#34;%f %ss&#34; parse &#34;12 apples&#34;   # {&#34;amount&#34;:12,&#34;noun&#34;:&#34;apple&#34;}
&#34;[%s]&#34; parse &#34;[something]&#34;                          # &#34;something&#34;
</code></pre>

<p>The right argument to <code>parse</code> may be list of strings; in this case the output will be a list of <em>rows</em>, where each row contains the values from parsing one input string. The <code>flip</code> of this would give <em>columns</em> instead. Here’s an example of parsing a table of fixed-width records:</p>

<pre><code>form: &#34;%6s%6c%2i&#34;
data: &#34;apple  $1.00 1\ncherry $0.3515\nbanana $0.75 2&#34;

r: form parse &#34;\n&#34; split data
#((&#34;apple &#34;,1,1),(&#34;cherry&#34;,0.35,15),(&#34;banana&#34;,0.75,2))

table r
#+----------+------+----+
#| c0       | c1   | c2 |
#+----------+------+----+
#| &#34;apple &#34; | 1    | 1  |
#| &#34;cherry&#34; | 0.35 | 15 |
#| &#34;banana&#34; | 0.75 | 2  |
#+----------+------+----+

flip r
#((&#34;apple &#34;,&#34;cherry&#34;,&#34;banana&#34;),(1,0.35,0.75),(1,15,2))

t: table (&#34;name&#34;,&#34;price&#34;,&#34;amt&#34;) dict flip r
#+----------+-------+-----+
#| name     | price | amt |
#+----------+-------+-----+
#| &#34;apple &#34; | 1     | 1   |
#| &#34;cherry&#34; | 0.35  | 15  |
#| &#34;banana&#34; | 0.75  | 2   |
#+----------+-------+-----+

(&#34;\n&#34;,form) format t              # round-trip
#&#34;apple  $1.00 1\ncherry $0.3515\nbanana $0.75 2&#34;
</code></pre>

<p>When formatting, literals will be included in the output string and each pattern will control conversion of one value from the input list, with a few exceptions as explained below. Missing arguments will be interpreted as appropriate “null” values.</p>

<pre><code>&#34;%i,%a,%i&#34; format 1,(list 65,66,67)  # &#34;1,ABC,0&#34;
</code></pre>

<p>The left argument to <code>format</code> may be a list of strings; in this case it is a series of alternating delimiters and format strings, with the last item always being a format string. Each format string is “pushed” one layer deeper into the right argument of <code>format</code>, and (if present), the delimiter will be used to <code>fuse</code> these intermediate strings, allowing a simple statement to recursively format a complex structure:</p>

<pre><code>                    ()  format 11,22                   # (11,22)                # (identity)
                &#34;%03i&#34;  format 11,22                   # &#34;011&#34;                  # format the first item and discard unused(!)
          (list &#34;%03i&#34;) format 11,22                   # (&#34;011&#34;,&#34;022&#34;)          # format each
           (&#34;:&#34;,&#34;%03i&#34;) format 11,22                   # &#34;011:022&#34;              # fuse (format each)
    (&#34;&lt;%s&gt;&#34;,&#34;:&#34;,&#34;%03i&#34;) format (list 11,22),(list 33)  # (&#34;&lt;011:022&gt;&#34;,&#34;&lt;033&gt;&#34;)  # format each (fuse (format each))
(&#34;@&#34;,&#34;&lt;%s&gt;&#34;,&#34;:&#34;,&#34;%03i&#34;) format (list 11,22),(list 33)  # &#34;&lt;011:022&gt;@&lt;033&gt;&#34;      # fuse (format each (fuse (format each)))
</code></pre>

<p>Recursive formats will “explode” tables into lists of row-lists:</p>

<pre><code>t: insert alpha:&#34;one&#34;,&#34;two&#34; beta:11,22 into 0
#+-------+------+
#| alpha | beta |
#+-------+------+
#| &#34;one&#34; | 11   |
#| &#34;two&#34; | 22   |
#+-------+------+

(list &#34;%u - %i&#34;) format t
#(&#34;ONE - 11&#34;,&#34;TWO - 22&#34;)
</code></pre>

<p>If <code>N</code> is specified, the <code>%s</code>,<code>%a</code> and <code>%b</code> patterns will read up to <code>N</code> characters of input when parsing. Otherwise, the next character in the format string will be interpreted as a delimiter, and input characters will be read until that delimiter is encountered. (Note that if <code>%s</code>/<code>%a</code>/<code>%b</code> is immediately followed by a pattern, the delimiter will be <code>%</code>!) If <code>%s</code> appears at the end of the format string, it will simply read the remainder of the input string.</p>

<p>The <code>%p</code> pattern operates on a dictionary with numeric fields for <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code>:</p>

<pre><code>&#34;%p&#34; parse  &#34;2021-02-03T04:05:58Z&#34;  # {&#34;year&#34;:2021,&#34;month&#34;:2,&#34;day&#34;:3,&#34;hour&#34;:4,&#34;minute&#34;:5,&#34;second&#34;:58}
&#34;%p&#34; format ().year:1984            # &#34;1984-01-00T00:00:00Z&#34;
</code></pre>

<p>The <code>%n</code> pattern can be used for progressive parsing. It also offers a way of finding the first index of a given character in a string:</p>

<pre><code>data: &#34;one,two,three&#34;
&#34;%s,%n&#34; parse data         # (&#34;one&#34;,4)
&#34;%s,%n&#34; parse 4 drop data  # (&#34;two&#34;,4)

&#34;%*sA%n&#34; parse &#34;BBCABA&#34;    # the index of the first &#39;A&#39; is 4
</code></pre>

<p>The <code>%m</code> and <code>%z</code> patterns can be used to disambiguate between failing to match and successfully parsing a null-equivalent value. You can also do some kinds of pattern matching:</p>

<pre><code>&#34;%i%m&#34; parse &#34;23&#34;                      # (23,1) # successful parse
&#34;%i%m&#34; parse &#34;0&#34;                       # (0,1)  # successful parse of 0
&#34;%i%m&#34; parse &#34;orange&#34;                  # (0,0)  # mismatch, defaulted to 0

&#34;exe%m&#34; parse &#34;foo.exe&#34;,&#34;execute&#34;      # (0,1)  # prefix match
&#34;exe%z&#34; parse &#34;execute&#34;,&#34;exe&#34;          # (0,1)  # full match
</code></pre>

<p>The <code>%r</code> pattern is followed by one or more “valid” characters, the count given by <code>D</code> (or 1 by default). This pattern matches and collects input if and only if the input characters are within this set of valid characters. The <code>-</code> flag inverts this behavior, such that the pattern matches and collects only characters which are <em>not</em> in the valid set. If <code>N</code> is specified, exactly N characters must be matched; otherwise <code>%r</code> will accept zero or more valid characters. The <code>%o</code> pattern is exactly like <code>%r</code>, but if <code>N</code> is unspecified it will accept zero or <em>one</em> valid characters:</p>

<pre><code>&#34;%.2r01&#34;     parse &#34;01110201&#34;     # &#34;01110&#34;          # grab any leading number of binary digits
&#34;%*.2r01%z&#34;  parse &#34;010&#34;,&#34;012&#34;    # (1,0)            # string consists only of binary digits?
&#34;%r-%i&#34;      parse &#34;----45&#34;       # (&#34;----&#34;,45)      # grab any prefix of minus signs
&#34;%o-&#34;        parse &#34;A&#34;,&#34;-A&#34;,&#34;--A&#34; # (&#34;&#34;,&#34;-&#34;,&#34;-&#34;)     # grab at most one minus sign
&#34;%*o-%i&#34;     parse &#34;-45&#34;          # 45               # discard any sign, and read an unsigned int
&#34;#%-r\n\n%s&#34; parse &#34;# comment\nA&#34; # (&#34; comment&#34;,&#34;A&#34;) # read a Lil-style line comment until a newline
</code></pre>

<p>The <code>%j</code> pattern can be used to format or parse data as JSON. When formatting JSON, Lil dictionary keys will be cast to strings, and anything other than a number, string, list, or dictionary will become a JSON <code>null</code>:</p>

<pre><code>&#34;%j&#34; format (11,22) dict (33,44)    # &#34;{\&#34;11\&#34;:33,\&#34;22\&#34;:44}&#34;
&#34;%j&#34; format list 11,22              # &#34;[11,22]&#34;
&#34;%j&#34; format table 11,22             # &#34;null&#34;
</code></pre>

<p>When parsing JSON, the value <code>true</code> will become the number <code>1</code>, and <code>false</code> or <code>null</code> will become the number <code>0</code>. This JSON parser is highly tolerant and will among other things accept non-string JSON values as dictionary keys, missing <code>,</code> and <code>:</code> delimiters, and some missing trailing delimiters. <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel’s Law</a>, baby!</p>

<pre><code>&#34;%j&#34; parse &#34;[true,false,null,1]&#34;   # (1,0,0,1)
&#34;%j&#34; parse &#34;{11:22,33:44&#34;          # {11:22,33:44}
</code></pre>

<h2 id="lilthevectorlanguage">Lil, the Vector Language</h2>

<p>Lil has a number of features influenced by “Vector-oriented” languages like APL, J, K, and Q. The most obvious is <em>conforming</em>, in which a number of primitive operators like <code>+</code> and <code>-</code> can be applied either to single numbers or entire lists. This functionality is essential to how Lil manipulates columns within queries.</p>

<p>Let’s start with a unary operator. Applied to a list, <code>-</code> “penetrates” to each list element:</p>

<pre><code>-(5)                # -5
-(10,-35)           # (-10,35)
</code></pre>

<p>With a binary operator, a non-list item will “spread” and be paired with each element in a list. Given two lists, corresponding element from each list are “paired up”:</p>

<pre><code>100+10              # 110
100+(10,20)         # (110,120)
(100,200)+10        # (110,210)
(100,200)+(10,20)   # (110,220)
</code></pre>

<p>The same pattern is carried out recursively; you can operate on arbitrarily high-dimensional data this way. Sometimes you may still need an <code>each</code> or <code>flip</code> to get your operands to line up the way you want:</p>

<pre><code>2*(list 1,2,3),(list 3,4)
# ((2,4,6),(6,8))

2 cross 3
# ((0,0),(1,0),(0,1),(1,1),(0,2),(1,2))

each x in 2 cross 3 do (27,19)+x end
# ((27,19),(28,19),(27,20),(28,20),(27,21),(28,21))

flip(27,19)+flip 2 cross 3
# ((27,19),(28,19),(27,20),(28,20),(27,21),(28,21))
</code></pre>

<p>Conforming is why Lil has two different equality operators: <code>=</code> (equals) conforms, and <code>~</code> (match) does not. Consider these cases:</p>

<pre><code>22=11,22,33          # (0,1,0)
22~11,22,33          # 0

(11,22,33)=11,22,33  # (1,1,1)
(11,22,33)~11,22,33  # 1

()=11,22             # ()
()~11,22             # 0
</code></pre>

<p>In many situations, <code>=</code> and <code>~</code> are equivalent. Prefer <code>~</code> when you don’t <em>need</em> conforming behavior; it signals your intent more clearly to a reader, since it is easy to tell without context that the result will be a single number.</p>

<p>Combining conforming operators with reducing operators like <code>sum</code> and <code>raze</code> offers many elegant and direct solutions to problems. Compare each of these approaches to counting how many times a value <code>needle</code> can be found in a list <code>haystack</code>:</p>

<pre><code>needle:   &#34;apple&#34;
haystack: (&#34;frog&#34;,&#34;apple&#34;,&#34;chicken&#34;,&#34;toadstool&#34;,&#34;apple&#34;,&#34;rice&#34;,&#34;fish&#34;)

c:0 each x in haystack if x~needle c:c+1 end end c     # imperative

c:0 each x in haystack c:c+x~needle end c              # imperative, without a conditional

extract count value where value=needle from haystack   # query

count needle take haystack                             # functional (filter)

sum needle=haystack                                    # vector-oriented (spread-conforming =)
</code></pre>

<h2 id="lilthedeckerlanguage">Lil, the Decker Language</h2>

<p>Lil contains a number of language features and builtins specifically intended for interaction with the Decker environment.</p>

<p>The <code>send</code> statement is followed by the name of a function, and then a set of arguments in brackets, just as if the function were being called. Instead of calling the named function directly, <code>send</code> finds the <em>next closest</em> binding (or the most recently <em>shadowed</em> binding, if you like) for the name and calls <em>that</em> function. This is particularly useful for event handlers which need to “bubble” events up to a more general handler, like a card’s <code>link</code> definition deferring to the deck’s <code>link</code> definition.</p>

<p>The <code>send</code> statement can also be handy to <em>override</em> built-in functions like <code>go[]</code> with your own code, so that you have a chance to perform some work before, after, or instead of their default behavior. Defining these overrides in the deck’s script will make them apply for events triggered from any card or widget:</p>

<pre><code>on go x do
	# provide our own novel &#39;special name&#39;:
	if x~&#34;Random&#34;
		x:random[deck.cards]
	end

	# use &#39;send&#39; to call the original definition:
	send go[x]
end
</code></pre>

<p>An <em>interface</em> appears similar to a dictionary, but indexing or assignment through an interface may have side-effects, and the values in fields may change over time:</p>

<pre><code>  sys
&lt;system&gt;
  &#34;%e&#34; format sys.now
&#34;2021-11-12T02:00:59Z&#34;
  &#34;%e&#34; format sys.now
&#34;2021-11-12T02:01:07Z&#34;

  time:sys
&lt;system&gt;
  time.now
1636682495
</code></pre>

<p>Interfaces cannot be defined from Lil programs- they are furnished by a host application like Decker. Consult Decker’s manual for a description of the interfaces you can use in your scripts. It is also not possible to enumerate the keys of an interface; they may have infinitely many keys, populated on the fly. Thus, the <code>in</code> operator will always return <code>0</code> when an interface is its right argument.</p>

<p>Interfaces can be compared with <code>~</code> and <code>=</code> using <em>reference equality</em> and concatenated into lists using <code>,</code> like any other datatype:</p>

<pre><code>  sys~sys
1
  sys=(sys,sys,123)
(1,1,0)
</code></pre>

<p>All interfaces will accept the <code>&#34;type&#34;</code> index, which behaves like <code>typeof</code>. This is handy if you ever have a list, dictionary, or table containing interfaces:</p>

<pre><code>  sys.type
&#34;system&#34;
  (sys,sys,sys)..type
(&#34;system&#34;,&#34;system&#34;,&#34;system&#34;)
</code></pre>

<p>Accessing an invalid index will return <code>0</code>, and attempting to write to an invalid (or read-only) index will return the expression to the right, like any other indexed assignment:</p>

<pre><code>  sys.bogus
0
  sys.bogus:123
123
</code></pre>

<h2 id="appendix1:unaryprimitives">Appendix 1: Unary Primitives</h2>

<p>The unary arithmetic primitives <code>-</code> (negation), <code>!</code> (logical not), <code>floor</code>, <code>cos</code>, <code>sin</code>, <code>tan</code>, <code>exp</code> (the exponential function), <code>ln</code> (natural log), and <code>sqrt</code> (square root) <em>conform</em>, and generalize to both lists and numbers.</p>

<p>The unary aggregation primitives <code>sum</code>, <code>raze</code>, <code>min</code>, and <code>max</code> take a list and collapse it into a single result as if by combining every element of the list with the binary primitives <code>+</code>, <code>,</code>, <code>&amp;</code> and <code>|</code>, respectively.</p>

<p><code>typeof</code> gives the name of the type of the argument; one of the strings { <code>&#34;number&#34;</code>, <code>&#34;string&#34;</code>, <code>&#34;list&#34;</code>, <code>&#34;dict&#34;</code>, <code>&#34;table&#34;</code>, <code>&#34;function&#34;</code> }, or, in the case of an <em>interface</em>, the name of that interface type.</p>

<p><code>count</code> gives the number of elements in a value. The <code>count</code> of a number is always 1.</p>

<p><code>first</code> and <code>last</code> extract the first or last elements of a value.</p>

<p><code>range</code> of a number produces a list of the integers <code>[0,x)</code>. Applied to anything else, it will produce a list of the <em>keys</em> of its dictionary equivalent.</p>

<p><code>list</code> of anything produces a list of length 1 containing that value.</p>

<p><code>flip</code> will <em>transpose</em> the elements of a list of lists- swap the x and y axes. For example, <code>flip (list 1,2,3),(list 4,5,6)</code> is <code>((1,4),(2,5),(3,6))</code>. The result will always be rectangular: sublists that are too short will be padded with <code>0</code>, and any non-list values will be <em>spread</em> to take up an entire column in the result. Applied to a table <code>x</code>, <code>flip</code> will produce a new table using a column named <code>key</code> (or the first column) as new column keys, and all other columns will become rows. The original keys will become a column named <code>key</code> in the resulting table. This operation can be useful for “pivoting” categorical data.</p>

<p><code>rows</code> converts a table into a list of dictionaries, each representing a row of the table.</p>

<p><code>cols</code> converts a table into a dictionary of uniform-length lists, each representing a column of the table.</p>

<p><code>table</code> constructs a table. Given a list-of-dictionaries (as produced by <code>rows</code>) or a dictionary, it will reconstitute a table, taking the union of any dictionary keys as columns and extending any short columns as with <code>take</code>. A list of lists will be interpreted as a list of <em>rows</em>, padded to rectangularity with 0 if needed, using default column names {<code>c0</code>, <code>c1</code>… <code>cn</code>}. A list containing non-dictionary and non-list values will be converted into a table with a single <code>value</code> column.</p>

<p><code>mag</code> computes the magnitude of a vector, or the euclidean distance between a point and the origin. If its argument is anything except a number or list of numbers it will descend recursively through the argument before computing a magnitude, similar to how other unary primitives conform. For example, <code>mag ((list 9,0),(list 3,4),(list 0,7))</code> is <code>(9,5,7)</code>. The magnitude of a single number is its absolute value.</p>

<p><code>heading</code> computes the angle in radians from the origin toward a point. This is similar to the <code>atan2(y,x)</code> quandrant-disambiguating arctangent provided in many math libraries. Like <code>mag</code>, <code>heading</code> will descend recursively through any non list-of-number arguments, so it can be applied to points, lists of points, and so on.</p>

<p><code>unit</code> computes a unit vector (with <code>mag</code> of 1) pointing toward an angle in radians. This operation conforms. If the angle is between 0 and 2 pi and the original <code>mag</code> was 1, <code>unit</code> is the inverse of <code>heading</code>.</p>

<h2 id="appendix2:binaryprimitives">Appendix 2: Binary Primitives</h2>

<p>The binary arithmetic and comparison primitives <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (modulus), <code>^</code> (exponentiation), <code>&lt;</code>, <code>&gt;</code>, <code>=</code>, <code>&amp;</code> (minimum), and <code>|</code> (maximum) <em>conform</em>, and generalize to both lists and numbers.</p>

<p>The modulus operator <code>%</code> takes its arguments in the opposite order of common notation- the divisor is the left argument. Thus, <code>5 % 3,4,5,6,7</code> is <code>(3,4,0,1,2)</code>. In common usage, this order will require fewer parentheses given Lil’s right-to-left precedence rule.</p>

<p>The <code>&lt;</code>, <code>&gt;</code> and <code>=</code> comparison operators always produce the number 1 or 0 as a result. If both operands are a number, they are compared numerically. If either is an interface, they are equal only if both are identical. Otherwise, the arguments are treated as strings and compared lexicographically.</p>

<p>The <code>&amp;</code> and <code>|</code> operator calculate the minimum or maximum of their arguments. As a consequence, for the numbers 0 and 1 they are equivalent to logical “AND” and logical “OR”- thus their notation. Applied to strings, they compare values lexicographically in the same fashion as <code>&lt;</code> and <code>&gt;</code>.</p>

<p><code>x ~ y</code> is the match operator. It produces the number 1 if <code>x</code> and <code>y</code> are identical values. Unlike <code>=</code>, match does <em>not</em> convert arguments or automatically “spread” to list elements; <code>x</code> and <code>y</code> must have identical types to begin with. This is particularly important if you want to e.g. check whether an item is the empty list: <code>()=1,2</code> yields <code>()</code>, but <code>()~1,2</code> yields <code>0</code>.</p>

<p><code>x , y</code> is the concatenation operator. It is used for joining items together into lists. If <code>x</code> is a dictionary, <code>y</code> will be converted to a dictionary, and the operator will take the union of their key-value mappings, preferring any bindings in <code>y</code> over <code>x</code> when both are present. If applied to two tables, their rows will be concatenated, with any missing columns supplied as 0. Note that using <code>,</code> on two strings will result in a list of two strings, whereas using <code>+</code> will result in a single string!</p>

<p><code>x @ y</code> is spread-indexing: <code>x</code> is indexed with each element of <code>y</code>. For example, <code>(11,22,33) @ 0,1,0,1,0</code> is <code>(11,22,11,22,11)</code>. With an appropriate index <code>y</code>, this operator can be used to reorder, duplicate, or filter elements of a list <code>x</code>. The expression <code>x @ y</code> is essentially equivalent to <code>each v k i in y (x[v k i]) end</code>, and so it can also be used as shorthand for any <code>each</code> loop that would otherwise simply be applying a function to each element of its source.</p>

<p><code>x split y</code> breaks a string <code>y</code> apart on any instance of the string <code>x</code>, resulting in a list of strings.</p>

<p><code>x fuse y</code> conversely combines the strings in the list <code>y</code> with the string <code>x</code>, resulting in a string. Combining <code>split</code> and <code>fuse</code> can allow one to replace instances of one substring with another.</p>

<p><code>x dict y</code> constructs a dictionary from a list of keys <code>x</code> and a list of values <code>y</code>.</p>

<p><code>x take y</code> and <code>x drop y</code> are very general operators for filtering and reshaping data. Their behaviors depend on the type of the left and right arguments, as summarized in the table below. When <code>x</code> is a number, <code>take</code> will repeat elements from <code>y</code> if it isn’t long enough. For non-numeric <code>x</code> values, <code>take</code> can be thought of as <em>set intersection</em>, while <code>drop</code> can be thought of as <em>set difference</em>.</p>

<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>

<thead>
<tr>
	<th> <code>x</code>    </th>
	<th> <code>y</code> </th>
	<th> <code>take</code>       </th>
	<th> <code>drop</code>          </th>
</tr>
</thead>

<tbody>
<tr>
	<td> number   </td>
	<td> string </td>
	<td> first x characters from y   </td>
	<td> remove first x characters from y   </td>
</tr>
<tr>
	<td> number   </td>
	<td> list </td>
	<td> first x elements from y   </td>
	<td> remove first x elements from y    </td>
</tr>
<tr>
	<td> number   </td>
	<td> dict </td>
	<td> first x key/value pairs from y </td>
	<td> remove first x key/value pairs from y  </td>
</tr>
<tr>
	<td> number   </td>
	<td> table </td>
	<td> first x rows from y    </td>
	<td> remove first x rows from y     </td>
</tr>
<tr>
	<td> negative number </td>
	<td> string </td>
	<td> last x characters from y   </td>
	<td> remove last x characters from y   </td>
</tr>
<tr>
	<td> negative number </td>
	<td> list </td>
	<td> last x elements from y   </td>
	<td> remove last x elements from y    </td>
</tr>
<tr>
	<td> negative number </td>
	<td> dict </td>
	<td> last x key/value pairs from y </td>
	<td> remove last x key/value pairs from y  </td>
</tr>
<tr>
	<td> negative number </td>
	<td> table </td>
	<td> last x rows from y    </td>
	<td> remove last x rows from y     </td>
</tr>
<tr>
	<td> non-number/list </td>
	<td> string </td>
	<td> only characters in x of y   </td>
	<td> remove instances of characters in x from y </td>
</tr>
<tr>
	<td> non-number/list </td>
	<td> list </td>
	<td> only elements in x of y   </td>
	<td> remove instances of elements in x from y </td>
</tr>
<tr>
	<td> non-number/list </td>
	<td> dict </td>
	<td> only keys in x of y    </td>
	<td> remove keys in x from y      </td>
</tr>
<tr>
	<td> string   </td>
	<td> table </td>
	<td> only column x of y    </td>
	<td> remove column x from y      </td>
</tr>
<tr>
	<td> string list  </td>
	<td> table </td>
	<td> only columns in x of y   </td>
	<td> remove columns in x from y     </td>
</tr>
<tr>
	<td> number list  </td>
	<td> table </td>
	<td> only rows x of y, in order  </td>
	<td> remove rows in x from y      </td>
</tr>
</tbody>
</table>

<p><code>x limit y</code> returns up to <code>x</code> items from <code>y</code>. Equivalent to <code>if x&lt;count y x take y else y end</code>.</p>

<p><code>x in y</code> returns the number 1 or 0 depending upon whether <code>y</code> appears in <code>x</code>. If <code>y</code> is a string, look for the string <code>x</code> anywhere in <code>y</code>. If <code>y</code> is a list, look for <code>x</code> as an element of <code>y</code>. If <code>y</code> is a dictionary, <code>x</code> must be a <em>key</em> of that dictionary. If <code>y</code> is a table, it must likewise be a <em>key</em> (column name) of that table. In all other cases, <code>in</code> returns 0. If <code>x</code> is a list, consider each element of x and return a list of 1 or 0.</p>

<p><code>x unless y</code> returns <code>x</code> unless <code>y</code> is not the number 0; otherwise it returns <code>y</code>. This “null-coalescing operator” is handy for providing default values when indexing into dictionaries or lists. For example, <code>() unless foo[x]</code> will evaluate to the empty list if <code>foo</code> contains no value with the key <code>x</code>.</p>

<p><code>x join y</code> performs a <em>natural join</em> upon the tables <code>x</code> and <code>y</code>. The intersection between column names in <code>x</code> and <code>y</code> are used as the <em>matching key</em>. For any combination of rows in <code>x</code> and <code>y</code> where the matching key is identical, the result will contain a row containing the union of the values in that row. The resulting table’s column names will be the union of the names in <code>x</code> and <code>y</code>. Natural joins neatly capture foreign-key relationships between tables, provided that column names are consistent. If <code>join</code> is applied to non-table arguments, it produces a list by pairing adjacent elements from <code>x</code> and <code>y</code>. If either argument is a number, it is considered <code>range</code> of that argument, and otherwise it is interpreted as a list. For example, <code>&#34;ABC&#34; join 3</code> gives <code>((&#34;A&#34;,0),(&#34;B&#34;,1),(&#34;C&#34;,2))</code>.</p>

<p><code>x cross y</code> performs a <em>cartesian product</em> (or <em>cross join</em>) of the tables <code>x</code> and <code>y</code>. Every row from <code>x</code> is concatenated with every row in <code>y</code>, producing <code>(count x)*(count y)</code> resulting rows. The resulting table will contain all the columns of both <code>x</code> and <code>y</code>, with any collisions in <code>y</code> gaining an underscore (<code>_</code>) suffix to disambiguate. A cross product filtered by a query can be used to perform inner joins. If <code>cross</code> is applied to non-table arguments, it produces a list of all pairings of elements from <code>x</code> and <code>y</code>. If either argument is a number, it is considered <code>range</code> of that argument, and otherwise it is interpreted as a list. Thus, <code>2 cross &#34;ABC&#34;</code> gives <code>((0,&#34;A&#34;),(1,&#34;A&#34;),(0,&#34;B&#34;),(1,&#34;B&#34;),(0,&#34;C&#34;),(1,&#34;C&#34;))</code>.</p>

<p><code>x parse y</code> breaks apart a string or list of strings <code>y</code> based on a format string <code>x</code>. <code>x format y</code> constructs a formatted string from a value or list of values <code>y</code> based on a format string <code>y</code>. The <code>parse</code> and <code>format</code> primitives are generally (but not strictly) inverses, given the same format string.</p>

<h2 id="appendix3:languagegrammar">Appendix 3: Language Grammar</h2>

<p>The following is a slightly hand-waved EBNF description of Lil’s syntax. The production <code>ALPHA</code> is taken as any alphabetic character (upper- or lowercase), and the production <code>NON_ESC</code> is any ASCII character between 32 and 126 (except backslash). All whitespace is interchangeable in Lil, any amount of whitespace may appear between tokens, and line comments begin with <code>#</code>.</p>

<pre><code>MONAD   := &#39;-&#39;|&#39;!&#39;|&#39;floor&#39;|&#39;cos&#39;|&#39;sin&#39;|&#39;tan&#39;|&#39;exp&#39;|&#39;ln&#39;|&#39;sqrt&#39;|&#39;count&#39;|&#39;first&#39;|&#39;last&#39;
           &#39;sum&#39;|&#39;min&#39;|&#39;max&#39;|&#39;raze&#39;|&#39;range&#39;|&#39;list&#39;|&#39;rows&#39;|&#39;cols&#39;|&#39;table&#39;|&#39;typeof&#39;|&#39;flip&#39;|&#39;mag&#39;|&#39;unit&#39;|&#39;heading&#39;
DYAD    := &#39;+&#39;|&#39;-&#39;|&#39;*&#39;|&#39;/&#39;|&#39;%&#39;|&#39;^&#39;|&#39;&lt;&#39;|&#39;&gt;&#39;|&#39;=&#39;|&#39;&amp;&#39;|&#39;|&#39;|&#39;,&#39;|&#39;~&#39;|&#39;@&#39;|&#39;split&#39;|&#39;fuse&#39;|&#39;dict&#39;|&#39;take&#39;|&#39;drop&#39;|
           &#39;in&#39;|&#39;join&#39;|&#39;cross&#39;|&#39;parse&#39;|&#39;format&#39;|&#39;unless&#39;|&#39;limit&#39;
DIGIT   := &#39;0&#39;|&#39;1&#39;|&#39;2&#39;|&#39;3&#39;|&#39;4&#39;|&#39;5&#39;|&#39;6&#39;|&#39;7&#39;|&#39;8&#39;|&#39;9&#39;
NUMBER  := &#39;-&#39;? DIGIT+ &#39;.&#39;? | DIGIT* &#39;.&#39; DIGIT+
STRING  := &#39;&#34;&#39; (NON_ESC|&#39;\\&#39;|&#39;\&#34;&#39;|&#39;\n&#39;)* &#39;&#34;&#39;
LITERAL := NUMBER | STRING | &#39;(&#39; &#39;)&#39;
NAME    := (ALPHA|&#39;_&#39;|&#39;?&#39;) (ALPHA|&#39;_&#39;|&#39;?&#39;|DIGIT)*
ITER    := (( each&#39; NAME* &#39;in&#39; ) | &#39;while&#39;) EXPR* &#39;end&#39;
ON      := &#39;on&#39; NAME+ &#39;do&#39; EXPR* &#39;end&#39;
IF      := &#39;if&#39; EXPR* ( &#39;else&#39; EXPR* )? &#39;end&#39;
QUERY   := (&#39;select&#39;|&#39;extract&#39;|&#39;update&#39;)((NAME &#39;:&#39;)?EXPR)*(&#39;where&#39;EXPR)?(&#39;by&#39;EXPR)?(&#39;orderby&#39;EXPR(&#39;asc&#39;|&#39;desc&#39;))?&#39;from&#39; EXPR
INSERT  := &#39;insert&#39; (NAME &#39;:&#39; EXPR) &#39;into&#39; EXPR
SEND    := &#39;send&#39; NAME &#39;[&#39; EXPR* &#39;]&#39;
INDEX   := (&#39;.&#39; NAME? | &#39;[&#39; EXPR* &#39;]&#39;)*
ACCESS  := NAME INDEX ( &#39;:&#39; EXPR )?
TERM    := LITERAL | ITER | ON | IF | QUERY | INSERT | SEND | &#39;(&#39; EXPR &#39;)&#39; | MONAD EXPR | ACCESS
EXPR    := TERM ( INDEX ( &#39;:&#39; EXPR )? | DYAD EXPR )?
PROGRAM := EXPR*
</code></pre>
</div>
  </body>
</html>
