<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://eieio.games/nonsense/game-16-paccam-pacman-with-your-face/">Original</a>
    <h1>PacCam: Pacman controlled with your face</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
        <p>I made a game. It’s called <a href="https://eieio.games/paccam">PacCam</a>. It’s Pacman, but you control it with your face.</p>


<p>Looking very cool</p>

<p>You can play it <a href="https://eieio.games/paccam">here</a> (or see the code <a href="https://github.com/nolenroyalty/paccam">here</a>).</p>

<p>You chomp your mouth to move and turn your face to steer. You look…pretty dumb while playing it. At the end it tries to give you the dumbest possible gif of yourself (it tracks when your mouth is the <em>most</em> open, and builds the gif around that moment).</p>

<p><img src="http://eieio.games/assets/images/paccam/nolen-funny1.gif"/>
<img src="http://eieio.games/assets/images/paccam/nolen-funny3.gif"/>
</p>
<p>I could fill a book with dumb gifs of me after all the testing I did</p>

<p>I’m really pleased with how the game turned out, but making it was <em>way</em> more work than I expected. Let’s look at why.
<!-- excerpt-end --></p>

<h2 id="wait-how-does-this-work">Wait, how does this work</h2>

<p>Good question.</p>

<ul>
  <li>I use <a href="https://ai.google.dev/edge/mediapipe/solutions/vision/face_landmarker">MediaPipe’s Face Landmarker</a> for face tracking. MediaPipe<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> is a suite of ML tools from Google that come with good prebaked models for tracking humans.</li>
  <li>I use <a href="https://react.dev/">React</a> to display the UI, players, etc.</li>
  <li>The core game logic is a tiny (~3k lines of code) imperative game engine that I wrote and wired up to React.</li>
</ul>

<p>I use a couple of additional tools like <a href="https://framer.com/motion">Framer motion</a>, <a href="https://www.radix-ui.com/">radix</a>, <a href="https://github.com/jnordberg/gif.js/blob/master/README.md">GIF.js</a>, and <a href="https://styled-components.com/">styled-components</a>. But nothing crazy. The game is largely Just Code.</p>

<p>So the high-level answer to “how does this work” is mostly: MediaPipe is an easy way to do face tracking in the browser and otherwise this is just a website on the internet. We live in the future!</p>

<p>That said, there were some challenges gluing all this tech together. The biggest early challenge was getting React to play nice with MediaPipe.</p>

<h4 id="mediapipe-and-react">MediaPipe and React</h4>
<p>Here is a simple model of how you use MediaPipe:</p>
<ul>
  <li>You have a video element on a webpage hooked up to a webcam</li>
  <li>You point MediaPipe at that video element<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup></li>
  <li>MediaPipe gives you information about the faces in the video element on every frame</li>
</ul>

<p>“Information” means the location of “landmarks” (e.g. the tip of your nose) as well as the value of “blend shapes” (e.g. how open your mouth is). But the point is, MediaPipe sprays lots of data at you (think hundreds of floats tens of times a second).</p>

<p>Here is a simple model of how you use React:</p>
<ul>
  <li>You tell React how to compute your desired UI based on the current data that you have</li>
  <li>When that data changes, React automatically updates the UI</li>
</ul>

<p>So maybe you can see a potential problem here. Naively combining React and MediaPipe and stuffing all your MediaPipe state into React causes React to do <em>lots</em> of updates. This gets slow.</p>

<p>My <a href="http://eieio.games/nonsense/teleyegraph/">first React / MediaPipe</a> project solved this with a bunch of convulted React code that was <em>very careful</em> about when it updated React <em>state</em> (which triggers an update), and relied heavily on what React calls “refs” (values that can be updated imperatively without triggering an update). It was a huge mess, very hard to think about, and still pretty slow.</p>

<p>To solve this issue for PacCam I took a different approach: I put all my MediaPipe logic in a <a href="https://github.com/nolenroyalty/paccam/blob/d3e446c9612e89793e6b50819880945266093351/src/CoreGame.js#L985">plain javascript</a> file and had the relevant React components subscribe to updates - for example, the PacMan component listens for updates around which direction you’re looking and whether your mouth is open.</p>

<p>I originally thought binding React code to non-React code would be a challenge, but it ends up being pretty simple. A toy implementation looks like this:</p>

<div><div><pre><code><span>class</span> <span>MediaPipeEngine</span> <span>{</span>
  <span>doFaceLandmarkThings</span><span>()</span> <span>{</span>
    <span>// get facelandmarks somehow</span>
    <span>const</span> <span>faceLandmarks</span> <span>=</span> <span>this</span><span>.</span><span>getFaceLandmarks</span><span>();</span>
    <span>// This depends on your current jaw open state, because we</span>
    <span>// use different thresholds for opening and closing your mouth</span>
    <span>const</span> <span>jawOpen</span> <span>=</span> <span>this</span><span>.</span><span>calculateJawOpen</span><span>(</span><span>faceLandmarks</span><span>);</span>
    <span>this</span><span>.</span><span>notifyJawOpenSubscribers</span><span>(</span><span>jawOpen</span><span>);</span>
  <span>}</span>

  <span>subscribeToJawOpen</span><span>({</span> <span>id</span><span>,</span> <span>callback</span> <span>})</span> <span>{</span>
    <span>this</span><span>.</span><span>jawOpenSubscribers</span><span>.</span><span>push</span><span>({</span> <span>id</span><span>,</span> <span>callback</span> <span>});</span>
  <span>}</span>

  <span>notifyJawOpenSubscribers</span><span>(</span><span>jawOpen</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>jawOpenSubscribers</span><span>.</span><span>forEach</span><span>(({</span> <span>callback</span> <span>})</span> <span>=&gt;</span> <span>callback</span><span>(</span><span>jawOpen</span><span>));</span>
  <span>}</span>

  <span>unsubscribeFromJawOpen</span><span>({</span> <span>id</span> <span>})</span> <span>{</span>
    <span>this</span><span>.</span><span>jawOpenSubscribers</span> <span>=</span> <span>this</span><span>.</span><span>jawOpenSubscribers</span><span>.</span><span>filter</span><span>(</span>
      <span>(</span><span>subscriber</span><span>)</span> <span>=&gt;</span> <span>subscriber</span><span>.</span><span>id</span> <span>!==</span> <span>id</span>
    <span>);</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>Component</span><span>({</span> <span>mediaPipeEngine</span> <span>})</span> <span>{</span>
  <span>const</span> <span>[</span><span>jawOpen</span><span>,</span> <span>setJawOpen</span><span>]</span> <span>=</span> <span>React</span><span>.</span><span>useState</span><span>(</span><span>0</span><span>);</span>
  <span>const</span> <span>id</span> <span>=</span> <span>React</span><span>.</span><span>useId</span><span>();</span>
  <span>React</span><span>.</span><span>useEffect</span><span>(()</span> <span>=&gt;</span> <span>{</span>
    <span>mediaPipeEngine</span><span>.</span><span>subscribeToJawOpen</span><span>({</span> <span>id</span><span>,</span> <span>callback</span><span>:</span> <span>setJawOpen</span> <span>});</span>
    <span>return</span> <span>()</span> <span>=&gt;</span> <span>{</span>
      <span>mediaPipeEngine</span><span>.</span><span>unsubscribeFromJawOpen</span><span>({</span> <span>id</span> <span>});</span>
    <span>};</span>
  <span>},</span> <span>[</span><span>mediaPipeEngine</span><span>,</span> <span>id</span><span>]);</span>
  <span>// do something based on jaw being open</span>
<span>}</span>
</code></pre></div></div>

<p>I found this to be a much easier approach than forcing everything into React; it’s a very natural way to have inherently imperative logic update your UI.</p>

<h4 id="games-and-react">Games and React</h4>

<p>Here is a simple model of a game engine backend</p>
<ul>
  <li>You tell it where some stuff is and what that stuff does</li>
  <li>In a tight loop, the game engine updates where everything is and what its doing</li>
  <li>It gives you information about where all the stuff is on every frame</li>
</ul>

<p>Here is a simple model of how you use React</p>
<ul>
  <li>You tell React how to compute your desired UI based on the current data that you have</li>
  <li>When that data changes, React automatically updates the UI</li>
</ul>

<p>So maybe you can see a potential problem here. Maybe you can see that it’s very similar to the MediaPipe problem we just talked about.</p>

<p>So you might ask: can we solve the problem in the same way? Well - yes, we can! My gameloop notifies a pacman component of its position by doing something like this:</p>

<div><div><pre><code><span>class</span> <span>Engine</span> <span>{</span>
  <span>startGameLoop</span><span>()</span> <span>{</span>
    <span>const</span> <span>loop</span> <span>=</span> <span>()</span> <span>=&gt;</span> <span>{</span>
      <span>this</span><span>.</span><span>calculatePlayerPositions</span><span>();</span>
      <span>this</span><span>.</span><span>notifyPlayerPositionSubscribers</span><span>();</span>
      <span>requestAnimationFrame</span><span>(</span><span>loop</span><span>);</span>
    <span>};</span>

    <span>requestAnimationFrame</span><span>(</span><span>loop</span><span>);</span>
  <span>}</span>
  <span>subscribeToPlayerPosition</span><span>({</span> <span>id</span><span>,</span> <span>playerNumber</span><span>,</span> <span>callback</span> <span>})</span> <span>{</span>
    <span>this</span><span>.</span><span>playerPositionSubscribers</span><span>.</span><span>push</span><span>({</span> <span>id</span><span>,</span> <span>playerNumber</span><span>,</span> <span>callback</span> <span>});</span>
  <span>}</span>

  <span>notifyPlayerPositionSubscribers</span><span>()</span> <span>{</span>
    <span>this</span><span>.</span><span>positions</span><span>.</span><span>forEach</span><span>(({</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>playerNumber</span> <span>})</span> <span>=&gt;</span> <span>{</span>
      <span>this</span><span>.</span><span>playerPositionSubscribers</span>
        <span>.</span><span>filter</span><span>((</span><span>subscriber</span><span>)</span> <span>=&gt;</span> <span>subscriber</span><span>.</span><span>playerNumber</span> <span>===</span> <span>playerNumber</span><span>)</span>
        <span>.</span><span>forEach</span><span>(({</span> <span>callback</span> <span>})</span> <span>=&gt;</span> <span>callback</span><span>({</span> <span>x</span><span>,</span> <span>y</span> <span>}));</span>
    <span>});</span>
  <span>}</span>

  <span>unsubscribeFromPlayerPosition</span><span>({</span> <span>id</span> <span>})</span> <span>{</span>
    <span>this</span><span>.</span><span>playerPositionSubscribers</span> <span>=</span> <span>this</span><span>.</span><span>playerPositionSubscribers</span><span>.</span><span>filter</span><span>(</span>
      <span>(</span><span>subscriber</span><span>)</span> <span>=&gt;</span> <span>subscriber</span><span>.</span><span>id</span> <span>!==</span> <span>id</span>
    <span>);</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>Pacman</span><span>({</span> <span>engine</span><span>,</span> <span>playerNumber</span> <span>})</span> <span>{</span>
  <span>const</span> <span>[</span><span>position</span><span>,</span> <span>setPosition</span><span>]</span> <span>=</span> <span>React</span><span>.</span><span>useState</span><span>({</span> <span>x</span><span>:</span> <span>null</span><span>,</span> <span>y</span><span>:</span> <span>null</span> <span>});</span>
  <span>const</span> <span>id</span> <span>=</span> <span>React</span><span>.</span><span>useId</span><span>();</span>
  <span>React</span><span>.</span><span>useEffect</span><span>(()</span> <span>=&gt;</span> <span>{</span>
    <span>engine</span><span>.</span><span>subscribeToPlayerPosition</span><span>({</span>
      <span>id</span><span>,</span>
      <span>callback</span><span>:</span> <span>setPosition</span><span>,</span>
      <span>playerNumber</span><span>,</span>
    <span>});</span>
    <span>return</span> <span>()</span> <span>=&gt;</span> <span>{</span>
      <span>engine</span><span>.</span><span>unsubscribeFromPlayerPosition</span><span>({</span> <span>id</span> <span>});</span>
    <span>};</span>
  <span>},</span> <span>[</span><span>engine</span><span>,</span> <span>playerNumber</span><span>,</span> <span>id</span><span>]);</span>
  <span>// move based on position</span>
<span>}</span>
</code></pre></div></div>

<p>In addition to making it easier to control the state updates that React gets, this is a much easier way to run a game loop at all in React. One of the rules of React is that a function is redefined whenever the data that it references changes. This makes lots of sense for UI updates, but it’s a huge pain for a game loop. My game loop needs to reference lots of data that it’s also updating - but I don’t want to redefine the game loop on every frame. With this pattern I don’t have to.</p>

<h4 id="what-else-was-hard">What else was hard</h4>

<p>Well, I spent a lot of time writing my little engine and making the controls feel good and making a tutorial and all of the other things that go into making a game.</p>

<p>But to be honest, “making a website” was a whole lot more challenging for me than the imperative backend-y game engine stuff. I’ve been a backend software engineer for something like 12 years. I learned how to use Flexbox like 8 months ago. The web is hard! But I’m not sure how to turn my webdev challenges into a good blog post - I’m not sure you want to read about me learning that <code>backdrop-filter</code> needs a vendor prefix to work on Safari.</p>

<p>But let’s talk about some things that I found <em>interesting.</em></p>

<h3 id="what-did-i-find-interesting">What did I find interesting</h3>

<p>A lot! Too much! Too much to put in a blog post. But here are a few highlights that we can talk about:</p>
<ul>
  <li>Adding bots (which I did way too late)</li>
  <li>Making the game work on any display size</li>
  <li>Tweaking the game mechanics</li>
  <li>Figuring out how to teach people the controls</li>
</ul>

<h4 id="adding-bots">Adding bots</h4>
<p>I added bots to PacCam about a week before finishing it. I originally wasn’t planning to have bots at all.</p>

<p>Waiting to add bots was a mistake - and releasing without them would have been an awful idea.</p>

<p>I added bots to make it easier for some friends to test the game solo, and that gets at why having bots is so important: people often don’t have someone to play with! I was thinking of PacCam as a local multiplayer game (and that’s how I did all my early testing) but…local multiplayer games are not in a great place these days! There’s a reason games mostly do online play!</p>

<p>But in addition to improving the final product, bots made <em>testing</em> the game - looking for bugs and thinking about balance - easier. Before adding bots I did all my testing using a gamemode that let me control multiple players with a single face (ok for finding bugs, awful for balance testing).</p>


<p>4 bots going at it. My money&#39;s on pink.</p>

<p>So anyway. Bots are great. How do they work?</p>

<p><a href="https://github.com/nolenroyalty/paccam/blob/main/src/BotStateMachine.js">My bot logic</a> relies on composing a couple of handy primitives:</p>
<ul>
  <li>A <code>plan</code> - like hunting other players or eating dots (and corresponding logic for executing the plan)</li>
  <li>A function <code>f</code> that generates a random bounded timestamp in the near future</li>
  <li>A function <code>g</code> for making a weighted random choice from a list of choices</li>
</ul>

<p>Every game tick, bots check whether they’re allowed to update their plan (bounded by <code>f</code>) and potentially do so; for example, if a bot is now capable of eating other players, they will probably transition to the <code>hunting</code> plan.</p>

<p>When executing a plan, bots potentially update the target of their plan (e.g. the player to hunt, or flee from, the dot they want to eat) bounded by <code>f</code>. When they choose a target they do so using <code>g</code>. For example, when a bot is hunting other players, it computes its distance to all other players and turns that into a score that is <code>1/(distance**3)</code> (higher is better). And then it makes a weighted random choice from that list; if there are two players who are 1 and 2 units away from the bot, it will hunt the closer player 8 times out of 9.</p>

<details>
    <summary>In practice that looks something like this</summary>

<figure><pre><code data-lang="javascript"><span>class</span> <span>BotStateMachine</span> <span>{</span>
    <span>maybeUpdatePlan</span><span>({</span> <span>now</span><span>,</span> <span>superState</span> <span>})</span> <span>{</span>
        <span>if</span> <span>(</span><span>superState</span> <span>===</span> <span>&#34;</span><span>am-super</span><span>&#34;</span> <span>&amp;&amp;</span> <span>this</span><span>.</span><span>plan</span> <span>!==</span> <span>PLAN</span><span>.</span><span>HUNTING</span><span>)</span> <span>{</span>
            <span>// start hunting players after eating a power pellet </span>
            <span>// - but not immediately</span>
            <span>const</span> <span>shouldMoveToHunt</span> <span>=</span> <span>this</span><span>.</span><span>pastRandomNearFutureTimestamp</span><span>({</span>
                <span>currentTime</span><span>:</span> <span>now</span><span>,</span>
                <span>stateKey</span><span>:</span> <span>&#34;</span><span>movedToHunting</span><span>&#34;</span><span>,</span>
                <span>targetFrequency</span><span>:</span> <span>350</span><span>,</span>
                <span>});</span>
            <span>if</span> <span>(</span><span>shouldMoveToHunt</span><span>)</span> <span>{</span>
                <span>this</span><span>.</span><span>plan</span> <span>=</span> <span>PLAN</span><span>.</span><span>HUNTING</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>// other update logic</span>
    <span>}</span>

    <span>maybeExecutePlan</span><span>({</span> <span>now</span><span>,</span> <span>position</span><span>,</span> <span>playerPositions</span><span>})</span> <span>{</span>
       <span>if</span> <span>(</span><span>this</span><span>.</span><span>plan</span> <span>===</span> <span>PLAN</span><span>.</span><span>HUNTING</span><span>)</span> <span>{</span>
       <span>const</span> <span>canPickNewTarget</span> <span>=</span> <span>this</span><span>.</span><span>pastRandomNearFutureTimestamp</span><span>({</span>
          <span>currentTime</span><span>:</span> <span>now</span><span>,</span>
          <span>stateKey</span><span>:</span> <span>&#34;</span><span>lastHuntTargetChange</span><span>&#34;</span><span>,</span>
          <span>targetFrequency</span><span>:</span> <span>2250</span><span>,</span>
        <span>});</span>
        <span>if</span> <span>(</span><span>canPickNewTarget</span><span>)</span> <span>{</span>
          <span>// If the another player is close, we should be allowed to </span>
          <span>// chase them instead. But only sometimes</span>
          <span>const</span> <span>distanceToOtherPlayers</span> <span>=</span> <span>this</span><span>.</span><span>distanceToOtherPlayers</span><span>(</span>
            <span>position</span><span>,</span>
            <span>playerPositions</span><span>);</span>
          <span>this</span><span>.</span><span>target</span> <span>=</span> <span>this</span><span>.</span><span>weightedRandomChoiceFromList</span><span>({</span>
            <span>list</span><span>:</span> <span>distanceToOtherPlayers</span><span>,</span>
            <span>logKey</span><span>:</span> <span>&#34;</span><span>choose hunting target</span><span>&#34;</span><span>});</span>
        <span>}</span>
        
        <span>const</span> <span>canReorient</span> <span>=</span> <span>this</span><span>.</span><span>pastRandomNearFutureTimestamp</span><span>({</span>
          <span>currentTime</span><span>:</span> <span>now</span><span>,</span>
          <span>stateKey</span><span>:</span> <span>&#34;</span><span>lastHuntReorient</span><span>&#34;</span><span>,</span>
          <span>targetFrequency</span><span>:</span> <span>500</span><span>,</span>
        <span>});</span>

        <span>// By default, this moves in the current direction </span>
        <span>// until we overlap with the target in the relevant </span>
        <span>// axis (e.g. move up till we overlap horizontally).</span>
        <span>// `canReorient` lets us pick a new direction even </span>
        <span>// when that&#39;s not true, to keep things interesting</span>
        <span>this</span><span>.</span><span>orientTowardsTarget</span><span>({</span>
          <span>position</span><span>,</span>
          <span>target</span><span>:</span> <span>player</span><span>.</span><span>position</span><span>,</span>
          <span>distanceScaleFactor</span><span>:</span> <span>2.5</span><span>,</span>
          <span>targetState</span><span>:</span> <span>this</span><span>.</span><span>huntingState</span><span>,</span>
          <span>pickNewEvenIfAlreadyChoseDirection</span><span>:</span> <span>canReorient</span><span>,</span>
          <span>targetDirection</span><span>:</span> <span>player</span><span>.</span><span>direction</span><span>,</span>
        <span>});</span>
      <span>}</span>
      <span>// other execution logic</span>
    <span>}</span>
<span>}</span></code></pre></figure>

</details>

<details>
<summary>And here are the helper functions</summary>

<figure><pre><code data-lang="javascript"><span>// Weighted choice from `list` respecting score</span>
<span>function</span> <span>weightedRandomChoiceFromList</span><span>({</span> <span>list</span><span>,</span> <span>logKey</span><span>,</span> <span>scoreScaleFactor</span> <span>=</span> <span>1</span> <span>})</span> <span>{</span>
<span>if</span> <span>(</span><span>list</span><span>.</span><span>length</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
    <span>console</span><span>.</span><span>warn</span><span>(</span>
    <span>`Asked to choose a direction but no valid choices (key: </span><span>${</span><span>logKey</span><span>}</span><span>)`</span>
    <span>);</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
<span>const</span> <span>scaled</span> <span>=</span> <span>list</span><span>.</span><span>map</span><span>((</span><span>item</span><span>)</span> <span>=&gt;</span> <span>({</span>
    <span>...</span><span>item</span><span>,</span>
    <span>score</span><span>:</span> <span>item</span><span>.</span><span>score</span> <span>**</span> <span>scoreScaleFactor</span><span>,</span>
<span>}));</span>
<span>const</span> <span>total</span> <span>=</span> <span>scaled</span><span>.</span><span>reduce</span><span>((</span><span>acc</span><span>,</span> <span>item</span><span>)</span> <span>=&gt;</span> <span>acc</span> <span>+</span> <span>item</span><span>.</span><span>score</span><span>,</span> <span>0</span><span>);</span>
<span>const</span> <span>rand</span> <span>=</span> <span>Math</span><span>.</span><span>random</span><span>()</span> <span>*</span> <span>total</span><span>;</span>
<span>let</span> <span>runningTotal</span> <span>=</span> <span>0</span><span>;</span>
<span>for</span> <span>(</span><span>let</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>list</span><span>.</span><span>length</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>runningTotal</span> <span>+=</span> <span>scaled</span><span>[</span><span>i</span><span>].</span><span>score</span><span>;</span>
    <span>if</span> <span>(</span><span>rand</span> <span>&lt;</span> <span>runningTotal</span><span>)</span> <span>{</span>
    <span>return</span> <span>list</span><span>[</span><span>i</span><span>];</span>
    <span>}</span>
<span>}</span>
<span>}</span>

<span>// Pick a time in the near future at which something can occur</span>
<span>function</span> <span>pastRandomNearFutureTimestamp</span><span>({</span>
<span>currentTime</span><span>,</span>
<span>stateKey</span><span>,</span>
<span>targetFrequency</span><span>,</span>
<span>jitterFactor</span> <span>=</span> <span>0.25</span><span>,</span>
<span>runOnSuccess</span> <span>=</span> <span>()</span> <span>=&gt;</span> <span>{},</span>
<span>})</span> <span>{</span>
<span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span><span>smoothRandomState</span><span>[</span><span>stateKey</span><span>])</span> <span>{</span>
    <span>this</span><span>.</span><span>smoothRandomState</span><span>[</span><span>stateKey</span><span>]</span> <span>=</span> <span>{</span>
    <span>lastTimeSomethingHappened</span><span>:</span> <span>currentTime</span><span>,</span>
    <span>targetDelta</span><span>:</span> <span>null</span><span>,</span>
    <span>};</span>
<span>}</span>
<span>const</span> <span>lastTimeSomethingHappened</span> <span>=</span>
    <span>this</span><span>.</span><span>smoothRandomState</span><span>[</span><span>stateKey</span><span>].</span><span>lastTimeSomethingHappened</span><span>;</span>

<span>if</span> <span>(</span><span>this</span><span>.</span><span>smoothRandomState</span><span>[</span><span>stateKey</span><span>].</span><span>targetDelta</span> <span>===</span> <span>null</span><span>)</span> <span>{</span>
    <span>let</span> <span>threshold</span> <span>=</span> <span>targetFrequency</span><span>;</span>
    <span>const</span> <span>smoothVariation</span> <span>=</span> <span>Math</span><span>.</span><span>sin</span><span>(</span><span>currentTime</span> <span>/</span> <span>1000</span><span>)</span> <span>*</span> <span>jitterFactor</span><span>;</span>
    <span>const</span> <span>randomVariation</span> <span>=</span> <span>(</span><span>Math</span><span>.</span><span>random</span><span>()</span> <span>*</span> <span>2</span> <span>-</span> <span>1</span><span>)</span> <span>*</span> <span>jitterFactor</span><span>;</span>
    <span>threshold</span> <span>*=</span> <span>1</span> <span>+</span> <span>(</span><span>smoothVariation</span> <span>+</span> <span>randomVariation</span><span>)</span> <span>/</span> <span>2</span><span>;</span>
    <span>this</span><span>.</span><span>smoothRandomState</span><span>[</span><span>stateKey</span><span>].</span><span>targetDelta</span> <span>=</span> <span>threshold</span><span>;</span>
<span>}</span>

<span>const</span> <span>delta</span> <span>=</span> <span>currentTime</span> <span>-</span> <span>lastTimeSomethingHappened</span><span>;</span>
<span>if</span> <span>(</span><span>delta</span> <span>&gt;</span> <span>this</span><span>.</span><span>smoothRandomState</span><span>[</span><span>stateKey</span><span>].</span><span>targetDelta</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>smoothRandomState</span><span>[</span><span>stateKey</span><span>].</span><span>lastTimeSomethingHappened</span> <span>=</span> <span>currentTime</span><span>;</span>
    <span>this</span><span>.</span><span>smoothRandomState</span><span>[</span><span>stateKey</span><span>].</span><span>targetDelta</span> <span>=</span> <span>null</span><span>;</span>
    <span>runOnSuccess</span><span>();</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
<span>return</span> <span>false</span><span>;</span>
<span>}</span></code></pre></figure>

</details>

<p>I really enjoyed thinking in these terms. Separating “what are we doing” from “how do we do that” kept the logic simple, as did having a single answer to “how does the bot make a decision and when does it change its mind.”</p>

<p>I think adding this randomness also makes the bots feel more human - they make reasonable decisions most of the time, but sometimes they chase a player that’s far away or try to run across the screen to grab a dot that they saw.</p>

<p>This logic is also full separate from the game engine; all the bot state machine can do is tell the game which direction a bot is facing and whether its mouth is currently open. I never tried integrating the bot logic directly into the game engine, but I have to imagine it would have been a headache.</p>

<h4 id="working-on-any-display-size">Working on any display size</h4>
<p>Getting sites to work across display sizes stresses me out. This makes sense - it’s a hard problem and I’m pretty new to webdev.</p>

<p>The problem was particularly challenging for me with PacCam because it’s more of an application than a site. I wanted the game to run full screen, never require scrolling, and be played on top of a webcam that filled the entire screen.</p>

<p>“Make a video element fill the screen” turned out to not be that bad here, relative to some of my other MediaPipe work<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup> - the video element lives in a wrapper div with <code>width</code> and <code>height</code> both set to 100%<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">4</a></sup>. The video element also has <code>width</code> and <code>height</code> set to 100%, and <code>object-fit</code> set to <code>cover</code>. This expands the video element to fit its container without distorting it.</p>

<p>This approach cuts off some of the webcam if its dimensions don’t match the dimensions of the screen, but for PacCam I think that’s ok: your window is probably close-ish to your webcam dimension, and the game can still track you if you’re in the webcam frame but not visible on screen.</p>


<p>the game doesn&#39;t handle adjusting the window well, but the webcam looks ok!</p>

<p>The bigger challenge here was determining how big the game elements should be (and how many pellets should be in a row and column). The approach I took there was a little messy. When the game loads, I:</p>
<ul>
  <li>Check the width and height of the window</li>
  <li>Take the larger of the two dimensions as the “primary” dimension</li>
  <li>Have a hardcoded number (21) of “slots” in the primary dimension (this is arbitrary; I just thought it felt right)</li>
  <li>Divide the primary dimension size by that number to determine our “slot” size</li>
  <li>Determine the number of slots in the smaller dimension by dividing it by the slot size (and flooring it)<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">5</a></sup></li>
  <li>Compute the size of pellets, pacman, etc in terms of slot sizes</li>
  <li>Add spacing elements in the secondary dimension so account for any partial slots</li>
</ul>

<p>To make that concrete, lets say that our window is 2100x1450.</p>
<ul>
  <li>Width is &gt; height, so width is our primary dimension</li>
  <li>2100 / 21 = 100, so slots are 100x100 and we have 21 columns</li>
  <li><code>Math.floor(1450 / 100)</code> is 14, so we have 14 rows.</li>
  <li>Pacman is 2 slots large, so it is 200x200</li>
  <li>We add 25px tall spacing elements to the top and bottom of the grid</li>
</ul>

<p><img src="http://eieio.games/assets/images/paccam/screencropping.png"/>
</p>
<p>I&#39;ve made the spacing elements red here; they ensure our height has a round number of &#34;slots&#34;</p>

<p>Since these calculations are done at page load time, the game totally breaks if you resize the window while playing. Don’t do that! I wasn’t sure how to address this (since recalculating on window resize would change the number of pellets we should display).</p>

<p>This approach still feels a little awkward and messy to me, but it seems to work fine in practice and I really like having the game fill the screen regardless of dimensions.</p>

<h4 id="tweaking-game-mechanics">Tweaking game mechanics</h4>

<p>A big part of designing some games is <a href="https://www.literallyaking.com/blog/good-numbers-part1">picking good numbers</a>. And a thing I was surprised to learn last year is that I <em>hate</em> picking good numbers.</p>

<p>This is surprising to me because I like numbers! And I like playing games with good numbers! So I don’t really like doing this, and I struggle to find the energy to pick my numbers in principled ways.</p>

<p>I mostly dodge this problem by building games that don’t <em>need</em> good numbers: I’m much happier thinking about how to <a href="https://eieio.games/nonsense/game-14-one-million-checkboxes/">nudge humans to not be jerks</a>. But PacCam needed some numbers.</p>

<p>And I…did not pick my numbers in a principled way! Shocker! I found my numbers by picking something, playing a lot solo, adjusting, playing with friends, adjusting, and then playing some more. Numbers I picked this way include:</p>
<ul>
  <li>Player speeds (including the fact that you move faster after eating a power pellet)</li>
  <li>Scores for pellets, fruit, and eating other players</li>
  <li>The number of power pellets to have on screen at once</li>
  <li>The speed at which power pellets respawn</li>
  <li>Thresholds for whether a player overlaps with something they’re trying to eat</li>
  <li>Probably other things</li>
</ul>

<p>Sorry if you don’t like the numbers I picked. Feel free to <a href="https://github.com/nolenroyalty/paccam/tree/main">send me a pull or fork the code</a>.</p>

<h4 id="teaching-the-controls">Teaching the controls</h4>
<p>When I explain PacCam I ask people some simple questions - are they familiar with the videogame Pacman? Are they familiar with the human face?</p>

<p>They consistently say yes; most people are familiar with Pacman and know what the human face is. I explain that my game straightforwardly combines those things. They nod.</p>

<p>But it turns out that putting your knowledge of the human face into controlling Pacman is hard! That’s for a few reasons.</p>
<ul>
  <li>It is very hard to look at the screen while trying to turn your face</li>
  <li>It is tempting to turn your face so far that Mediapipe loses track of your face</li>
  <li>The game wants you to open your mouth pretty wide, but people tend to do small and fast chomps</li>
</ul>

<p>I quickly picked up on this during playtesting and learned how to give people the right intuitions for the controls. I’d stress that you only need to make small face movements and that you should try opening your mouth <em>more</em> but <em>slower</em> - and that worked pretty well.</p>

<p>But transmitting that information to strangers on the internet is harder. I tried to address this in a few ways:</p>
<ul>
  <li>Tweaking my face detection thresholds <em>constantly</em> - did you know that it’s harder to open your mouth when you’re looking down? The game accounts for that.</li>
  <li>Adding instructions that give a written version of my advice</li>
  <li>Adding a tutorial that nags you if you turn your head too far (I’m not sure how useful it is)</li>
  <li>Recording a video of my disembodied head controlling the game</li>
</ul>


<p>well, the game&#39;s not meant to make you look *flattering*</p>

<p>Recording the video was pretty fun. I originally recorded it with a white background, but that put an ugly white blob on the how to play screen. The white wasn’t quite consistent enough to trivially edit out, so I reshot the tutorial with a super jank greenscreen:</p>

<p><img src="http://eieio.games/assets/images/paccam/greenscreen.jpeg"/>
</p>

<p>This made it pretty easy to edit out the background to make a “transparent” video - until I realized that the Mp4 I exported it as didn’t support transparency. So to the video is actually played in a hidden video element and <a href="https://github.com/nolenroyalty/paccam/blob/353e6fb6fae08204f7637c08979f46ed85cb5d5c/src/components/HowToPlay/HowToPlay.js#L139">copied to a canvas that alphas-out the relevant pixels</a>.</p>

<p>After doing all of this I realized I could have just changed the game to have a green background instead of showing the webcam in the background, removing the need for a physical greenscreen. But this was more fun anyway.</p>

<h3 id="wrapping-up">Wrapping up</h3>

<p>So that’s it! That’s PacCam. It’s the most “normal” game I’ve made in like a year (that is, it’s a playable game that isn’t also a large scale experiment about human behavior). I hope you enjoy it!</p>

<p>To be honest, I’m a little nervous that I spent too long on the game relative to the number of people who will play it. I’m not sure that games like this are my strong suit. But I learned a whole lot about web development while making it and had fun along the way, so it’s hard to be too sad :)</p>

<p>If you’re interesting in mediapipe, I’ve got a bunch of <a href="https://mediapipe-playground.glitch.me/">undocumented examples</a> of how to use it on Glitch - I’m planning to turn those examples into a proper library / blog post.</p>

<p>And I’ll be back with more stuff soon!</p>



    </div></div>
  </body>
</html>
