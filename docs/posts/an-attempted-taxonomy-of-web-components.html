<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.zachleat.com/web/a-taxonomy-of-web-component-types/">Original</a>
    <h1>An attempted taxonomy of web components</h1>
    
    <div id="readability-page-1" class="page"><div>
	<p>As my experience with web components grows, my personal view of how to build a web component is also evolving. In some cases I’ve gone back and refactored older components with the new knowledge and experience I’ve gained. In other cases, these older components sit as evidence of the learning path I traveled.</p>
<p><em>For the record, I mean zero-dependency web components that do not use an upstream library—they inherit directly from <code>HTMLElement</code> or similar platform classes.</em></p>
<p>I thought it might be useful to catalog my journey of these open source web components as breadcrumbs for others.</p>
<h2 id="html-web-components" tabindex="-1">HTML Web Components <a href="#html-web-components" aria-hidden="true">#</a></h2>
<p>These components layer on interactivity and add behaviors in true progressive enhancement fashion. This is the bread and butter use case of web components. They work great as-is and are unlikely to be improved with additional leverage of server-side rendering. All of the client-side DOM modifications are in service of a particular client-side behavior.</p>


<div><table-saw type="container" breakpoint="(max-width: 30em)">
<table>
	<thead>
		<tr>
			<th>Tag</th>
			<th>Size</th>
			<th>CSS</th>
			<th>JavaScript</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><a href="https://github.com/zachleat/details-utils"><code>details-utils</code></a></td>
			<td><code>3.6 kB</code></td>
			<td><em>None</em></td>
			<td>Event Listeners only.</td>
		</tr>
		<tr>
			<td><a href="https://github.com/zachleat/video-radio-star"><code>video-radio-star</code></a></td>
			<td><code>2.4 kB</code></td>
			<td><em>None</em></td>
			<td>Event Listeners only.</td>
		</tr>
		<tr>
			<td><a href="https://github.com/zachleat/announcement-banner"><code>announcement-banner</code></a></td>
			<td><code>1.1 kB</code></td>
			<td><em>Manual.</em> Separate CSS styles are required to prevent layout shift.</td>
			<td>Event Listeners only.</td>
		</tr>
		<tr>
			<td><a href="https://github.com/11ty/is-land"><code>is-land</code></a></td>
			<td><code>3.1 kB</code></td>
			<td><em>None.</em></td>
			<td>Unknown custom elements are renamed for lazy initialization.</td>
		</tr>
		<tr>
			<td><a href="https://github.com/zachleat/squirminal"><code>squirm-inal</code></a></td>
			<td><code>3.0 kB</code></td>
			<td><em>JS injected.</em> CSS is global and only injected once. The CSS is only necessary for the JS enhanced experience.</td>
			<td>Child content is removed and re-added incrementally.</td>
		</tr>
		<tr>
			<td><a href="https://github.com/zachleat/resizeasaurus"><code>resize-asaurus</code></a></td>
			<td><code>1.4 kB</code></td>
			<td><em>JS injected, scoped to <strong>Shadow DOM</strong>.</em> CSS is only necessary for JS enhanced experience.</td>
			<td>Size element added as overlay, no layout shift.</td>
		</tr>
	</tbody>
</table>
</table-saw></div>
<p data-demo-label="Related">Obligatory nod to <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:defined"><code>:defined</code></a>—an incredibly useful tool for styling HTML Web Components.</p>
<p>The following components <em>augment/modify</em> nested HTML. These components could be improved with a tighter coupling to server rendering (e.g. <a href="https://www.11ty.dev/docs/languages/webc/">WebC</a>) but work great as-is in low-JavaScript environments.</p>
<div><table-saw type="container" breakpoint="(max-width: 30em)">
<table>
	<thead>
		<tr>
			<th>Tag</th>
			<th>Size</th>
			<th>CSS</th>
			<th>JavaScript</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><a href="https://github.com/zachleat/parity-purchasing-power-price"><code>ppp-price</code></a></td>
			<td><code>2.9 kB</code></td>
			<td><em>None.</em></td>
			<td>Updates text with adjusted price.</td>
		</tr>
		<tr>
			<td><a href="https://github.com/zachleat/seven-minute-tabs"><code>seven-minute-tabs</code></a></td>
			<td><code>3.0 kB</code></td>
			<td><em>None.</em></td>
			<td>Updates elements with accessibility mapping, hides non-active tabs.</td>
		</tr>
		<tr>
			<td><a href="https://github.com/zachleat/filter-container"><code>filter-container</code></a></td>
			<td><code>3.4 kB</code></td>
			<td><em>Optionally JS injected.</em> CSS content is specific to each instance of the component.</td>
			<td>Updates hidden, filtered elements (pairs nicely with server-rendering).</td>
		</tr>
		<tr>
			<td><a href="https://github.com/zachleat/table-saw"><code>table-saw</code></a></td>
			<td><code>2.2 kB</code></td>
			<td><em>JS injected.</em> CSS content is specific to media/container query breakpoint config.</td>
			<td>Updates table cells to add header text.</td>
		</tr>
		<tr>
			<td><a href="https://github.com/zachleat/browser-window"><code>browser-window</code></a></td>
			<td><code>2.9 kB</code></td>
			<td><em>JS injected, scoped to <strong>Shadow DOM</strong>.</em></td>
			<td>Adds browser chrome.</td>
		</tr>
	</tbody>
</table>
</table-saw></div>
<p>There is also a third category of HTML web component that augments the HTML in a way that is dynamic and specific to an individual user agent. A component like this wouldn’t be improved with a tighter coupling to a server (or cannot due to hosting limitations). I haven’t open sourced one of these yet.</p>
<p>As an example, an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat"><code>Intl.DateTimeFormat</code></a> wrapper web component that localize datetimes is floating around in one of my projects somewhere. This type of component <em>could</em> be server rendered in an edge function but this would limit the component’s hosting portability <em>(and many edge function implementations are teetering on venture capital <a href="https://en.wikipedia.org/wiki/Jenga">jenga towers</a> of funding)</em>.</p>
<p><strong>All of the components above use progressive enhancement</strong> and fallback to the nested HTML content before/without JavaScript—the crux of the humble HTML Web Component.</p>
<h3 id="the-very-short-and-recent-history-of-html-web-components" tabindex="-1">The Very Short and Recent History of HTML Web Components <a href="#the-very-short-and-recent-history-of-html-web-components" aria-hidden="true">#</a></h3>
<p><em>The community has settled on this name very quickly, ok.</em></p>

<h2 id="javascript-web-components" tabindex="-1">JavaScript Web Components <a href="#javascript-web-components" aria-hidden="true">#</a></h2>
<p>For the sake of completeness, I will sheepishly admit that I have created non-HTML Web Components too (and gotten value out of those). These are lower-priority optional use cases that pair with existing content and though it’s not ideal—for these use cases I’ve made the trade off.</p>
<div><table-saw type="container" breakpoint="(max-width: 30em)">
<table>
	<thead>
		<tr>
			<th>Tag</th>
			<th>Size</th>
			<th>CSS</th>
			<th>JavaScript Content</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><a href="https://github.com/zachleat/speedlify-score"><code>speedlify-score</code></a></td>
			<td><code>2.9 kB</code></td>
			<td><em>JS injected, scoped to <strong>Shadow DOM</strong>.</em></td>
			<td>Entirely JS generated content (no fallback).</td>
		</tr>
		<tr>
			<td><a href="https://github.com/zachleat/infinity-burger"><code>infinity-burger</code></a></td>
			<td><code>1.4 kB</code></td>
			<td><em>JS injected, scoped to <strong>Shadow DOM</strong>.</em></td>
			<td>Entirely JS generated content (no fallback).</td>
		</tr>
	</tbody>
</table>
</table-saw></div>
<p>For example, <code>&lt;speedlify-score&gt;</code> (used extensively on the <a href="https://www.11ty.dev/speedlify/">Eleventy Leaderboards</a>) is entirely JS-generated and has an empty fallback experience.</p>
<h2 id="lessons-learned" tabindex="-1">Lessons Learned <a href="#lessons-learned" aria-hidden="true">#</a></h2>
<p>I usually gauge the quality of a web component based on the amount of JavaScript DOM modifications that occur in that component. It’s no surprise to learn that I prefer HTML Web Components and typically try to avoid using and authoring JavaScript Web Components.</p>
<h3 id="injecting-css-with-javascript" tabindex="-1">Injecting CSS with Javascript <a href="#injecting-css-with-javascript" aria-hidden="true">#</a></h3>
<p>I was and am wary of this generally but there is additional nuance to keep in mind when comparing this to the much-maligned CSS-in-JS approach. The JavaScript injected CSS happening here is at the stylesheet level using the CSSStyleSheet API.</p>
<p>That is, one stylesheet is injected globally for all instances of the custom element (unless otherwise specified). <code>&lt;table-saw&gt;</code> is one exception to that, but the stylesheet is de-duplicated if more than one instance uses the same breakpoint and media/container query type.</p>
<p>The jury is still out on how expensive Shadow DOM constructable stylesheets are. The <a href="https://www.11ty.dev/speedlify/">Eleventy Leaderboards</a> are a pretty good stress test of that currently: <code>&lt;speedlify-score&gt;</code> uses Shadow DOM with a constructable stylesheet and currently has 918 component instances on the page (though lazy initialized via <code>&lt;is-land&gt;</code>).</p>
<p>The part I do like about injecting stylesheets is that I don’t need to worry about distributing my CSS separate from the JavaScript—it feels like a <em>web-platform single file component</em>. This is a fine tradeoff to make when the component’s CSS is tightly coupled and in service to the JavaScript of the component. <strong>Injecting CSS with JS will not get you anywhere if you need to style the before/without JavaScript (fallback) experience</strong>, so buyer beware!</p>
<h3 id="nuances-of-shadow-dom" tabindex="-1">Nuances of Shadow DOM <a href="#nuances-of-shadow-dom" aria-hidden="true">#</a></h3>
<p>If you generate content and markup with JavaScript—it may be okay to put it in Shadow DOM and get the benefits of scoped styles and devtools inspector-collapsed markup. Make sure you’re aware of the limitations of Shadow DOM (forms, deep hash links, accessibility mapping). Others have written extensively about this:</p>

<h3 id="some-components-can&#39;t-be-web-components-(for-now)" tabindex="-1">Some components can’t be web components (for now?) <a href="#some-components-can&#39;t-be-web-components-(for-now)" aria-hidden="true">#</a></h3>
<p>Some components <em>require</em> server rendering. You couldn’t do a <em>good enough</em> <code>&lt;img&gt;</code> or <code>&lt;picture&gt;</code> wrapper component (e.g. <a href="https://www.11ty.dev/docs/plugins/image/">Eleventy Image</a> or Next.js’ <code>&lt;Image&gt;</code>) using custom elements.</p>
<p>I suppose you might be able to <a href="https://is-land.11ty.dev/demo-image-loading">attempt such a thing</a> and limit it exclusively to <code>loading=&#34;lazy&#34;</code> images, but that seems a bit risky and fraught with peril. A custom element can’t beat the <a href="https://web.dev/articles/preload-scanner">preload scanner</a> and that markup is best served server-rendered.</p>
<p>It’s also worth noting that it isn’t possible to put a custom element into <code>&lt;head&gt;</code>—the HTML parser doesn’t allow it. You can <a href="https://astexplorer.net/#/1CHlCXc4n4">try this yourself</a>.</p>
<pre><code>
<span><span><span>&lt;</span>head</span><span>&gt;</span></span>
	<span><span><span>&lt;</span>custom-element</span><span>&gt;</span></span><span><span><span>&lt;/</span>custom-element</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>head</span><span>&gt;</span></span></code></pre>
<p>is parsed as:</p>
<pre><code><span><span><span>&lt;</span>body</span><span>&gt;</span></span>
	<span><span><span>&lt;</span>custom-element</span><span>&gt;</span></span><span><span><span>&lt;/</span>custom-element</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>body</span><span>&gt;</span></span></code></pre>
<h2 id="conclusions" tabindex="-1">Conclusions <a href="#conclusions" aria-hidden="true">#</a></h2>
<p>There is a lot of complexity in this space right now. But there is hope as the community refocuses on an approach with a good pit of success: the humble HTML Web Component. A very important takeaway here is that creating an HTML Web Component doesn’t require a hard stance of Light or Shadow DOM in your implementation (though Shadow DOM still has dragons). It is only concerned with the before/after JavaScript, with web performance and durability considerations in mind.</p>
<p>It will require discipline to avoid overindexing on JavaScript-injected CSS. I think <code>&lt;browser-window&gt;</code> may have jumped over the line here and I’m still a little uneasy about the tradeoffs I made there but the portability benefits are quite tempting!</p>
<p>Web components thrive in producing extremely portable and long-lasting code that can live and adapt to a huge variety of hosting and authoring environments. If you haven’t yet, give them a try!</p>

	</div></div>
  </body>
</html>
