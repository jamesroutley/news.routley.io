<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/">Original</a>
    <h1>Removing blur from images – deconvolution and using simple image filters</h1>
    
    <div id="readability-page-1" class="page"><div>
						<div>
<figure><img src="https://lh3.googleusercontent.com/ZSLN2SzFf2LE6lVWKzXiphVpg8VDfP_fiyfalr5prJc7LD9_y02h8ww5NrtS4iHhsjLTXsJX67QarKlmpHwBkofmUSpbGZzeAXciBxA0B4e76opbbeQMJjWnRj5caiD_hDLJjNutt7UzVwPBgA" alt=""/><figcaption><strong>Left:</strong> Original image. <strong>Center:</strong> Blurred through convolution. <strong>Right:</strong> Deconvolution of the blurred image.</figcaption></figure></div>


<p>In this post, we’ll have a look at the idea of <strong>removing blur from images</strong>, videos, or games through a process called <strong>“deconvolution”</strong>.</p>



<p>We will analyze what makes the process of deblurring an image (blurred with a known blur kernel) – deconvolution – possible in theory, what makes it impossible (at least to realize “perfectly”) in practice, and what a practical middle ground looks like.</p>



<p>Simple deconvolution is easy to understand, and it connects very nicely pure intuition, linear algebra, as well as <strong>frequency domain and spectral matrix analysis</strong>.</p>



<p>In the second part of the post we will look at how to apply <strong>efficient approximate deconvolution</strong> using only some very simple and basic image filters (gaussians) that work very well in practice for mild blurs.</p>



<h2>Linear image blur – convolution</h2>



<p>Before we dive into defining what is “deblurring” (or even going further into deconvolution), let’s first have a look at what is blur.</p>



<p>I had posts about various kinds of blurs, the most common being <a href="https://bartwronski.com/2021/10/31/practical-gaussian-filter-binomial-filter-and-small-sigma-gaussians/">Gaussian blur</a>.</p>



<p>Let’s stop for a second and look at the <strong>mathematical formulation of blur through convolution</strong>.</p>



<p><strong>Note:</strong> I will be analyzing mostly examples in 1D dimension, calling sequence entries “samples”, “elements”, and “pixels” interchangeably, while also demonstrating image convolutions as 2D (separable) filters. 2D is a direct extension of all the presented concepts in 1D – harder to visualize in algebraic form or frequency plots, but more natural for looking at the images. I hope examples in alternating 1D and 2D won’t be too confusing. Separable filters can be deconvolved separably as well (up to a limit), while non-separable ones not.</p>



<p><strong>“Blur” in “blurry images” can come from different sources</strong> – camera lens point spread function, motion blur from hand shake, excessive processing like denoising, or upsampling from lower resolution.</p>



<p>All of those have in common that come from a filter that either <strong>“spreads” some information like light rays across the pixels</strong>, or alternatively <strong>combines information from multiple source locations</strong> (whether physical circle of confusion, or nearby pixels). We typically call it a “blur” when all weights are positive (this is the case in physical light processes, but for electric or digital signals not necessarily), and it results in a low-pass filter.</p>



<p>There are two mentioned ways of looking at blurs – <strong>“scatter”</strong>, where a point contributes into multiple target output elements, and <strong>“gather”</strong>, where for each destination elements, we look at contributing source points. This is a topic for a longer post, but in our case – where we look at “fixed” blurs shared by all the locations in the image – they can be considered equivalent and transpose of one another (if a source pixel contributes to 3 output pixels, each output pixel also depends on 3 input pixels). </p>



<p>Let’s look at one of the simplest filters, <a href="https://bartwronski.com/2021/10/31/practical-gaussian-filter-binomial-filter-and-small-sigma-gaussians/">binomial convolution filter</a> [0.25, 0.5, 0.25].</p>



<p>This filter means that given five pixels, <img data-attachment-id="4696" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image47-2/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image47-1.png" data-orig-size="960,95" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image47" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image47-1.png?w=300" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image47-1.png?w=640" src="https://bartwronski.files.wordpress.com/2022/05/image47-1.png" alt=""/>, we have output pixels:</p>



<figure><a href="https://bartwronski.files.wordpress.com/2022/05/image32.png"><img loading="lazy" data-attachment-id="4693" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image32/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image32.png" data-orig-size="1185,992" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image32" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image32.png?w=300" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image32.png?w=640" src="https://bartwronski.files.wordpress.com/2022/05/image32.png?w=1024" alt="" width="104" height="87" srcset="https://bartwronski.files.wordpress.com/2022/05/image32.png?w=104 104w, https://bartwronski.files.wordpress.com/2022/05/image32.png?w=208 208w, https://bartwronski.files.wordpress.com/2022/05/image32.png?w=150 150w" sizes="(max-width: 104px) 100vw, 104px"/></a></figure>



<p>Note that for now we have omitted the output pixels <img data-attachment-id="4688" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image12/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image12.png" data-orig-size="313,96" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image12" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image12.png?w=300" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image12.png?w=313" src="https://bartwronski.files.wordpress.com/2022/05/image12.png" alt=""/> and it’s not immediately obvious how to treat them; where would we get the missing information from (reading beyond <img data-attachment-id="4695" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image41/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image41.png" data-orig-size="337,95" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image41" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image41.png?w=300" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image41.png?w=337" src="https://bartwronski.files.wordpress.com/2022/05/image41.png" alt=""/>)? This relates to “boundary conditions” which matter a lot for analysis and engineering implementation details, and we will come back to it later. Typical choices for <strong>“boundary conditions” are wrapping around, mirroring pixels, clamping to the last value, treating all missing ones as zeros, or even just throwing away partial pixels</strong> (this way a blurred image would be smaller than the input).</p>



<p>In physical modeling – for example when blur occurs in camera lens – we sample a limited “rectangle” of pixels from a physical process that happens outside, so it’s similar to throwing away some pixels.</p>



<p>Such a simple [0.25, 0.5, 0.25] filter and simple convolution when applied on an image in 2D (first in 1D in horizontal axis and then in 1D in the vertical one, results in a relatively mild, pleasant blur:</p>


<div>
<figure><img src="https://lh4.googleusercontent.com/Nxx98tPGFOEa6jEC9vViHeqEqPTf6zH50KWdqKGsShcrLR_Vp5QPC3wXt7aslrnrCssiNfzF0xaTDRXx4mdeIIvMRebR6rgwyGJXzdFnRmBCeV9aiSJrZmVGWXKkgcJQgxviNwbInPuUmLL0nw" alt=""/><figcaption><strong>Left:</strong> Original image crop. <strong>Right:</strong> Blurred.</figcaption></figure></div>


<p>But <strong>if we had such an image and we knew where the blur comes from and its characteristics… could we undo it</strong>?</p>


<div>
<figure><img src="https://lh4.googleusercontent.com/viU5oWEW4oU--rxjziNosDKVieLmSRUk80SpVHZmQerP_zZYfRqMznidDgK8UJ0-0nD3syYdSDB4H67x7FjeiDYpY36smSS5flykT6PdBKWeSUzNHX32gkNkAqKws65rtn_9ZxLQewo8ihILNw" alt="" width="426" height="239"/></figure></div>


<h2>Deblurring through deconvolution</h2>



<p>Process of inverting / undoing a known convolution is called simply deconvolution.</p>



<p>We apply a linear operator to the input… so, can we invert it?</p>



<p>But before that, I will clarify a common confusing topic.</p>



<h3>Is deconvolution the same as sharpening, super-resolution, upsampling?</h3>



<p>No, no, and no.</p>



<p><strong>Deconvolution</strong> – process of removing blur from an image.</p>



<p><strong>Sharpening</strong> – process of improving the perceived acuity and visual sharpness of an image, especially for viewing it on a screen or print.</p>



<p><strong>Super-resolution</strong> – process of reconstructing missing detail in an image.</p>



<p><strong>Upsampling</strong> – process of increasing the image resolution, with no relation to blur, sharpness, or detail – but aiming to at least not reduce it. Sadly ML literature calls upsampling “single frame super-resolution”.</p>



<p>Where does the confusion come from?</p>



<p>Other than the ML literature super-resolution confusion, there is overlap between those topics. Sharpening can be used to approximate deconvolution and often provides reasonable results (I will show this around the end of this post). If you did sharpening in Photoshop to save a blurry photo, you tried to approximate deconvolution this way!</p>



<p>Super-resolution is often combined with deconvolution in “CSI” style detail and acuity enhancement pipelines.</p>



<p>Upsampling is often considered “good” when it produces edges with sharper falloff than the original Nyquist and often has some non-linear and deconvolution-like elements.</p>



<p>But despite all that, deconvolution is simply undoing a physical process or pipeline processing of a convolution.</p>



<h3>Equations of deconvolution</h3>



<p>Let’s have a look at the equations that formed the basis of convolution again:</p>



<figure><a href="https://bartwronski.files.wordpress.com/2022/05/image32.png"><img loading="lazy" data-attachment-id="4693" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image32/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image32.png" data-orig-size="1185,992" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image32" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image32.png?w=300" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image32.png?w=640" src="https://bartwronski.files.wordpress.com/2022/05/image32.png?w=1024" alt="" width="116" height="97" srcset="https://bartwronski.files.wordpress.com/2022/05/image32.png?w=116 116w, https://bartwronski.files.wordpress.com/2022/05/image32.png?w=232 232w, https://bartwronski.files.wordpress.com/2022/05/image32.png?w=150 150w" sizes="(max-width: 116px) 100vw, 116px"/></a></figure>



<p>It should be obvious that we cannot directly solve for any of x variables – we have 3 equations and 5 unknowns… </p>



<p>But if we look at some simple manipulation:<br/></p>



<figure><a href="https://bartwronski.files.wordpress.com/2022/05/image39.png"><img loading="lazy" data-attachment-id="4694" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image39/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image39.png" data-orig-size="1999,201" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image39" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image39.png?w=300" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image39.png?w=640" src="https://bartwronski.files.wordpress.com/2022/05/image39.png?w=1024" alt="" width="236" height="24" srcset="https://bartwronski.files.wordpress.com/2022/05/image39.png?w=236 236w, https://bartwronski.files.wordpress.com/2022/05/image39.png?w=472 472w, https://bartwronski.files.wordpress.com/2022/05/image39.png?w=150 150w, https://bartwronski.files.wordpress.com/2022/05/image39.png?w=300 300w" sizes="(max-width: 236px) 100vw, 236px"/></a></figure>



<p>We can see that we get:</p>



<p>If we apply this filter to the blurred image from before we get… an ugly result:</p>



<figure><img src="https://lh5.googleusercontent.com/_8uA6EbKJZgbRUNYuEWW5rWUU8MA-OAoNID0AbyGkgPL6_cytIXkSPrLvSlUABVnyMsFxRWfY7olIuOQT0sqsgZN7kaVp7qq7A0qsp7xUfW0z74pPiY1Pt1QS3lxS_IxnygoWox4QHJ2gUK6WQ" alt=""/><figcaption><strong>Left:</strong> Original image. <strong>Center:</strong> Blurred through convolution. <strong>Right:</strong> Our first, failed attempt at deconvolution.</figcaption></figure>



<p>Yes, it is very “sharp”, but… ugh.</p>



<p>It’s clear that we need more “source” data. We need “something” to cancel out those error terms further away…</p>



<p>Note: I did this exercise, as this is important to build intuition and worth thinking about – <strong>for full cancellation we will need more and more terms, up to infinity</strong>. Anytime we include pixels further away, we can make the residual error smaller (as multiplying by the further weights and iterating this way shrinks them down).</p>



<p>But to solve an inverse of a linear system in general – we obviously need at least as many knowns as unknowns in our system of equations. At least, because linear dependence might make some of those equations cancel out.</p>



<p>This is where boundary conditions and handling of the border pixels comes into play.</p>



<p>One example is “wrap” mode, which corresponds to circulant convolution (we will see in a second why this is neat for mathematical analysis; not necessarily very relevant for practical application though 🙂 ).</p>



<figure><a href="https://bartwronski.files.wordpress.com/2022/05/image11.png"><img loading="lazy" data-attachment-id="4687" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image11/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image11.png" data-orig-size="1209,1735" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image11" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image11.png?w=209" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image11.png?w=640" src="https://bartwronski.files.wordpress.com/2022/05/image11.png?w=714" alt="" width="119" height="170" srcset="https://bartwronski.files.wordpress.com/2022/05/image11.png?w=119 119w, https://bartwronski.files.wordpress.com/2022/05/image11.png?w=238 238w, https://bartwronski.files.wordpress.com/2022/05/image11.png?w=105 105w, https://bartwronski.files.wordpress.com/2022/05/image11.png?w=209 209w" sizes="(max-width: 119px) 100vw, 119px"/></a></figure>



<p>Notice the bolded “wrapping” elements. I was too lazy to solve it by hand, so I plugged it into sympy and got:</p>



<figure><a href="https://bartwronski.files.wordpress.com/2022/05/image50.png"><img loading="lazy" data-attachment-id="4698" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image50/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image50.png" data-orig-size="1999,127" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image50" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image50.png?w=300" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image50.png?w=640" src="https://bartwronski.files.wordpress.com/2022/05/image50.png?w=1024" alt="" width="315" height="20" srcset="https://bartwronski.files.wordpress.com/2022/05/image50.png?w=315 315w, https://bartwronski.files.wordpress.com/2022/05/image50.png?w=630 630w, https://bartwronski.files.wordpress.com/2022/05/image50.png?w=150 150w, https://bartwronski.files.wordpress.com/2022/05/image50.png?w=300 300w" sizes="(max-width: 315px) 100vw, 315px"/></a></figure>



<p>This is a valid solution <strong>only for this specific, small circulant system of equations</strong>. In general, <strong>we could definitely end up with a non-invertible system</strong> – where we lose some degrees of freedom and again have too many unknowns as compared to known variables.</p>



<p>But in this case, if we increase the number of the pixels to 7, we’d get:</p>



<figure><a href="https://bartwronski.files.wordpress.com/2022/05/image29.gif"><img loading="lazy" data-attachment-id="4692" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image29/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image29.gif" data-orig-size="1999,90" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image29" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image29.gif?w=300" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image29.gif?w=640" src="https://bartwronski.files.wordpress.com/2022/05/image29.gif?w=1024" alt="" width="447" height="20"/></a></figure>



<p>There’s an interesting pattern happening… that pattern (sign flipping and adding plus two to a center term) will continue – to me this looked similar to a gradient (derivative) filter and it’s not a coincidence. If you’re curious about the connection, check out my past <a href="https://bartwronski.com/2021/02/28/computing-gradients-on-grids-forward-central-and-diagonal-differences/">post on image gradients and derivatives</a> and have it in mind once we start analyzing the frequency response and seeing the gain for the highest frequencies going towards infinity.</p>



<p>For the curious – if we apply such a filter to our image, we get absolutely horrible results:</p>


<div>
<figure><img src="https://lh6.googleusercontent.com/-Iz_ixQQ1vfpvTZSgLeht0y-_7I4En3ljNKBkoNpDgSrArXk_SHNFJWW78t13zo9APoOAA3pfeenIPJfhGFcXFRRPrumZYQf0UDdGjUPQkyhqWai8oSIAyqXgH4SHIUbsIMxsiuEn-S3sIaBFQ" alt=""/><figcaption><strong>Left:</strong> Original image. <strong>Center:</strong> Blurred through convolution. <strong>Right:</strong> Our second, even more failed attempt at deconvolution.</figcaption></figure></div>


<p>This got even worse than before.</p>



<p>Instead of toying with tiny systems of equations and wondering what’s going on, let’s solve it by getting a better understanding of the problem and going “bigger” and more general: looking at <strong>the matrix form of the system of equations</strong>.</p>



<h3>Convolution and deconvolution matrix linear algebra</h3>



<p>Any system of equations can be represented in a matrix form.</p>



<p>Circulant convolution of 128 pixels will look like this:</p>


<div>
<figure><img src="https://lh4.googleusercontent.com/EcI4aHg_soHwicviTrT5ruoS70odglCpaymzGTisJWBor0pvAvGWkTaeqsmp3i6_vbijy-PmOcu2C0tD-Je-9EnL7Q7gyAL1b_G7xw_G6T0Q3u9BogCLXG3egU8GwWx5iITYQisGlYTK0lpyRA" alt="" width="-201" height="-200"/><figcaption>1D signal [0.25 0.5 0.25] circulant convolution matrix.</figcaption></figure></div>


<p>Make sure you understand this picture. <strong>Horizontal rows are output elements, vertical columns are input elements</strong> (or vice versa; <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row major vs column major</a>, in our case it doesn’t matter, though I am sure some mathematicians would scream reading this). Each row has 3 elements contributing to it – in 1D each output element depends on 3 input elements.</p>



<p>This is a lovely structure – (almost) <a href="https://en.wikipedia.org/wiki/Block_matrix#Block_diagonal_matrices">block diagonal matrix</a>. Very sparse, very easy to analyze, very efficient to operate.</p>



<p>Then to get a solution, we can <strong>invert the matrix</strong> (this is not a great idea for many practical problems, but for our analysis will work just fine). Why? This linear system transforms from input elements / pixels to output elements pixels. We are interested in the <strong>inverse transformation – how to find the input, unblurred pixels, knowing the output pixels</strong>.</p>



<p>However, if we try to invert it numerically… we get an absolute mess:</p>


<div>
<figure><img src="https://lh3.googleusercontent.com/6rq_DW5vX7PM6fLveQBnlKEQR01SaLoCWOn0VlvsHFqUBgHEQc58-gv3qjsEm66r7I-Zn4GUL9Ne0kkFnUWtNOianwuB9ahI_iL95qVVhsDVxkspNZ-ffxs3bQQKot05HQMi23zo2T76xv_Zzg" alt="" width="355" height="313"/><figcaption>First attempt at inverting the convolution matrix.</figcaption></figure></div>


<p>Numpy produces this array: [[-4.50359963e+15,  4.50359963e+15, -4.50359963e+15, …,]]. When we look at the determinant of the matrix, it is close to zero, so we can’t really invert it. I am surprised I didn’t see any actual errors (numerical and linear algebra packages might or might not warn you about <a href="https://en.wikipedia.org/wiki/Condition_number">matrix conditioning</a>).</p>



<p>Luckily, <strong>we can regularize the matrix inverse by our favorite tool – <a href="https://bartwronski.com/2020/05/21/dimensionality-reduction-for-image-and-texture-set-compression/">singular value decomposition</a></strong>. In the SVD matrix inversion, we obtain an inverse matrix by inverting pointwise singular values and transposing and swapping the singular vector matrices.</p>



<p>Singular values look like this:</p>


<div>
<figure><img src="https://lh6.googleusercontent.com/7xdN30SBh5NBPGLLOLLsSTmz-hfI3Dew7GdO5R0yP5WP0Q4g46tWcy0PU5hNyxIBW94GEzcCNJLsrD7Itq0zD73X5GJdVjpCFdnbJR8lYa4RdAfbyrvM2i14vNF482R-8ICW3hobCro2z5PMVw" alt="" width="345" height="345"/><figcaption>Convolution matrix singular values.</figcaption></figure></div>


<p>If this reminds you of something… just wait for it. 🙂 </p>



<p>But we see that <strong>we can’t really invert those singular values that are close to 0.0</strong>. This will blow up numerically, up to infinity. If we regularize the inversion (instead of <img data-attachment-id="4683" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image1/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image1.png" data-orig-size="140,326" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image1" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image1.png?w=129" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image1.png?w=140" src="https://bartwronski.files.wordpress.com/2022/05/image1.png" alt=""/> do for example <img data-attachment-id="4686" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image9/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image9.png" data-orig-size="379,326" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image9" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image9.png?w=300" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image9.png?w=379" src="https://bartwronski.files.wordpress.com/2022/05/image9.png" alt=""/>), we can get a “clean” inverse matrix:</p>


<div>
<figure><img src="https://lh4.googleusercontent.com/3GfGnsFJfScMHEncl6rm7yoDj02JKe2BtNF2A6UAY4NHWp9VpwKXhPLCTCe5i8E46oUBPUe95jue_C9TY2zvzBr9S6RxThoiEa-vbr0341AsCmv3HeqVijJGHLO7xGuYkwRacFIgjoSjU0qHig" alt="" width="367" height="323"/><figcaption>Regularized inverse of the convolution matrix.</figcaption></figure></div>


<p>This looks much more reasonable. And if we apply a filter obtained this way (one of the rows) to the blurred image,we get a high quality “deblurred” image, almost perfectly close to the source:</p>


<div>
<figure><img src="https://lh3.googleusercontent.com/ZSLN2SzFf2LE6lVWKzXiphVpg8VDfP_fiyfalr5prJc7LD9_y02h8ww5NrtS4iHhsjLTXsJX67QarKlmpHwBkofmUSpbGZzeAXciBxA0B4e76opbbeQMJjWnRj5caiD_hDLJjNutt7UzVwPBgA" alt="" width="661" height="228"/><figcaption><strong>Left:</strong> Original image. <strong>Center:</strong> Blurred through convolution. <strong>Right:</strong> Proper deconvolution of the blurred image.</figcaption></figure></div>


<p>Worth noting: if we had <strong>a filter that does somewhat less blur, for example [0.2, 0.6, 0.2], we would get singular values</strong>:</p>


<div>
<figure><img src="https://lh5.googleusercontent.com/g4AHU3Wig4GU-N4KdPeWzqFmwDiH2ixSl3qgPzIx0eT2zwtCpbNeXz3nBu-UsJsAFHQNlGRSsVw4a4rUMywKdJQIDBkgRVV1oOXvUgps1EwURKQUAzZT2hfX2qZE6EevukzE0S9HvBhmcB8eoQ" alt=""/><figcaption>Singular values of a milder filter convolution matrix.</figcaption></figure></div>


<p>And the direct inversion would be also much better behaved (no need to regularize):</p>


<div>
<figure><img src="https://lh5.googleusercontent.com/aS-416nA7CWtW2SvOUnHdEKKvADWEnHvwrnPGq5okQ0WrXY3svNlUYmsdB988TjYd4K4aBNfT5Rv20dK5xK3CsGoYCNbhjU1fIeabbfcN6t3Nmi12J0paL26-KLhDmTPRf5buw7PBuf2Qf6ttg" alt="" width="369" height="319"/><figcaption>Direct, non regularized inverse of the milder blurring convolution matrix.</figcaption></figure></div>


<p>Time to connect some dots and move to a more “natural” (and my favorite) convolution domain – <strong>frequency analysis</strong>.</p>



<h3>Signal processing and frequency domain perspective </h3>



<p>Let’s have a look at the frequency response of the original filter. Why? Because we will use <a href="https://en.wikipedia.org/wiki/Fourier_transform">Fourier transform</a> and <a href="https://en.wikipedia.org/wiki/Convolution_theorem">convolution theorem</a>. It states that when performing (inverse or regular) Fourier transform (or its discrete equivalents) convolution in one space is multiplication in the other space.</p>



<p>So if we have a filter response like this:</p>


<div>
<figure><img src="https://lh3.googleusercontent.com/UV9fMNaSe0UvpGwe16GK77C3_xWwWgQVe9_T1N9u5BiMIb2RVkrFjbidKjmJROIlIUSSHp3tCu_Kovhd73gdVP7XRitN3uc82jeYjqqd4QcNO5y5D-fW1AnR89gCc_OwfFyghiNEgIX6UDopZw" alt=""/></figure></div>


<p>(Looks familiar?)</p>



<p>It will multiply the original frequency spectrum. We can combine linear transforms in any order, so if we want <strong>to “undo” the blurring convolution, we’d want to multiply by… simply its inverse</strong>.</p>



<p>Here we encounter again the difficulty of inversion of such a response – it goes towards zero. To invert it, we would need to have a filter with response going towards infinity:</p>


<div>
<figure><img src="https://lh3.googleusercontent.com/J30MZMwaBx_tkqNe9S_y5tha1GOnf-7XWPHqYHn8bh1yvFs_5GQGLjs7hYEgIQYOM68aRUkKi0bdJsFYa_Guy4GMNGqEUIRIget6u-tTg-DXdPj7_VbJVTmIdjVvZcM0a_qvxMSM-y6Jgrhltg" alt=""/></figure></div>


<p>This would be a bad idea for many practical reasons. But if we constrain it (more about the choice of constraint / regularization later), we can get a “reasonable” combined response:</p>


<div>
<figure><img src="https://lh3.googleusercontent.com/yVZhAs-B47a26Pcm9_6hi2pCGK7zURVhZIBI35E9LLQE6kfQ6MOgSWZ5nrBNHCo3LbqJfacH82GT44mzRuyIacgXAA46O_0Eesmp_tr3xY_KyEREYdfgOzTVQJxpZa-VvXMrM7KiWRaBtMxgLw" alt=""/><figcaption>Inverting frequency response of a [0.25 0.5 0.25] filter with regularization.</figcaption></figure></div>


<p>We would like the “combined response” to be a perfect flat unity, but this is not possible (need for an infinite gain) – so something like this looks great. In practice, when we deal with noise, maximum gains of 8 might already be too much, so we would need to reduce it even more.</p>



<p>But before we tackle the “practicalities” of deconvolution, it’s time for a reveal of <strong>the connection between the matrix form and frequency analysis</strong>.</p>


<div>
<figure><img src="https://lh3.googleusercontent.com/sGTcxQj5MC6u2-joBWjMQlfDQWTP-sIvnYstJu6N4b5cwWTc3Phb9gr3fx7S_6qf-hSlo7zwUFuvt2b79NL-Cm8oyWi5wVOTWfeTNM6gzCUelvfcc4vwkyg97n-db2Hv-XpivlbpPMvLlqI_cA" alt=""/></figure></div>


<p><strong>They are exactly the same.</strong></p>


<div>
<figure><img src="https://lh5.googleusercontent.com/xFo_FRuLqSGC0pdvqNKh1MGBOJWYOoVBi9qXTX6r8GqZlxyG-g2ljigyEu1NizIq5YoVFpn-NTC1KtRk8LzdODMhK62ntU0Hregf4QS004Zcjx_hKxVBoG0NrlziIomo93Y70p2SQcs6rkRDow" alt=""/></figure></div>


<p>This shouldn’t be surprising if you had some “advanced” linear algebra at college (I didn’t; and felt jealous watching <a href="https://www.youtube.com/watch?v=J7DzL2_Na80">Gilbert Strang’s MIT linear algebra course</a> – even if you think you know linear algebra, whole course series is amazing and totally worth watching) or played with <strong>spectral analysis / decomposition</strong> (I have a recent post on it in the context of <a href="https://bartwronski.com/2022/02/15/light-transport-matrices-svd-spectral-analysis-and-matrix-completion/">light transport matrices</a> if you’re interested).</p>



<p><a href="https://en.wikipedia.org/wiki/Circulant_matrix#Eigenvectors_and_eigenvalues">Circulant matrix, such as convolution matrix, diagonalizes as Discrete Fourier Transform</a>. This is an absolutely beautiful and profound idea and analyzing behaviors of this diagonalization was one of the prerequisites for the development of the <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform">Fast Fourier Transform</a>.</p>



<p>When I first read about it, I was mind blown. I shouldn’t be surprised – Fourier series and complex numbers appear everywhere. <strong>Singular values of a circulant (convolution) matrix are amplitude frequency buckets of the DFT.</strong></p>



<p>This is the reason I picked kind of “unnatural” (for graphics folks) wrapping boundary condition – Fourier transform is periodic and a wrapping cyclic convolution matrix is diagonalized through it. We could have picked some other boundary conditions and the result would be “similar”, but not exactly the same. In practice, it doesn’t matter outside of the borders (where “mirror” would be my practical recommendation for minimizing edge artifacts for blurs; and either “mirror” or “clamp” works well for deconvolution). </p>



<p>This is another way of looking at why some convolution matrices are impossible to invert – because we get frequency response at some frequency buckets equal to zero and therefore the singular values also equal to zero!</p>



<h2>Nonlinear, practical reality of deblurring</h2>



<p>I hope you love convolution matrices and singular values as much as I do, but if you don’t – don’t worry, time to switch to more practical and applicable information. How can we <strong>make simple linear deconvolution work in practice</strong>? To answer that, we need to analyze first why it can fail.</p>



<h3>Infinite gain</h3>



<p>We already discovered one of the challenges. We cannot have an “infinite” gain on any of the frequencies. <strong>If some information from singular values / frequencies truly goes to 0, we cannot recover it</strong>. Therefore, it’s important to not try to and not invert the frequencies close to zero and constrain the maximum gain to some value. But how and based on what? We will see how noise helps us answering this question.</p>



<h3>Noise</h3>



<p>The second problem is noise. In photography, we always deal with noisy images and noise is part of the image formation.</p>



<p>If we add noise with standard deviation of 0.005 to the blurry image (assuming signal strength of 1.0), we’re not going to notice it. But see what happens when deconvolving it:</p>



<figure><img src="https://lh4.googleusercontent.com/5nNXdGm7WuiXoLiUoDC30jupXqVaikej9wnZW2E0AG-zP1D_TFEVIpWEv-iSTsTwmZOv9IltiXwT-urqETXNjz926f2GB0qOODQdiy807cX3ubvEU-DGTr1oDNpITy850duHM-lOnKfAGtgkaw" alt=""/><figcaption><strong>Left:</strong> Original image. <strong>Center:</strong> Blurred through convolution. <strong>Right:</strong> Deconvolution of a slightly noisy image.</figcaption></figure>



<p>This relates to the gain point before – except that we are not concerned with just “infinite” gains, but <strong>any strong gain on any of the frequency buckets will amplify the noise at that frequency</strong>… This is a frequency space visualization of the problem:</p>


<div>
<figure><img src="https://lh3.googleusercontent.com/fRp3tForD8Zl4AZSuzEzM_kMQU07mam55i5osvJ1-vbcYN13NnJ2sP5iJLqgiChoGINskR0Ib2mczP65GnmBRMIS6L4k5Kzd_IxcWZ31iHJwOCUcqivr2KemAxvuGe_D8jc4GkAcNv7rK336tQ" alt="" width="326" height="310"/><figcaption>Amplification of noise happening because of the deconvolution.</figcaption></figure></div>


<p>Notice how the original white noise got transformed into some weird blue-noise (only the highest frequencies) – and we can see this actually on the image, with an extreme checkerboard-like pattern.</p>



<h3>Quantization, compression, and other processing</h3>



<p>Noise is not the only problem.</p>



<p>When processing signals in the digital domain, we always quantize them. While rendering folks might be working a lot with floats and tons of dynamic range (floats obviously also quantize, but it’s an often forgiving, dynamic quantization), unfortunately camera image signal processing chain, digital signal processors, and image processing algorithms mostly don’t. Instead they operate on fixed point, quantized integers. Which makes a lot of sense, but when we save an image in 8 bits (perfectly fine for most displays) and then try to deconvolve it, we get the following image:</p>



<figure><img src="https://lh3.googleusercontent.com/7COAzarcFc7451CCI5oI_8-4IquDa8za6MZMjg69WcT5r8ASiR6s8k_ULVBas1t-l34EOb7kT-4dz1h28kamftQ07hebWT2wHG_ULV4uygK98HeoBgocb4PrU1BpYCujdcqsj2897DPzJFY7MA" alt=""/><figcaption><strong>Left:</strong> Original image. <strong>Center:</strong> Blurred through convolution. <strong>Right:</strong> Deconvolution of an 8-bit image.</figcaption></figure>



<p>The noise itself is not huge; but in terms of structure, it definitely is similar to the noisy one above – this is not a coincidence.</p>



<p>Quantization can be thought of as <a href="https://en.wikipedia.org/wiki/Quantization_(signal_processing)#Noise_and_error_characteristics">adding quantization noise to the original signal</a>. If there is no dithering, this quantization noise is pretty nasty and correlated, with dithering it can be similar to white noise (with known standard deviation). In either case, we have to take it into account to not produce visual artifacts and one can use <strong>expected quantization noise standard deviation</strong> of <img data-attachment-id="4690" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image23/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image23.png" data-orig-size="271,345" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image23" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image23.png?w=236" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image23.png?w=271" src="https://bartwronski.files.wordpress.com/2022/05/image23.png" alt=""/>, where <img data-attachment-id="4699" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image51/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image51.png" data-orig-size="126,127" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image51" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image51.png?w=126" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image51.png?w=126" src="https://bartwronski.files.wordpress.com/2022/05/image51.png" alt=""/> is a difference between two closest elements due to quantization.</p>



<p>Significantly worse problems can arise from other image processing and storage techniques like compression. Typically a high quality deconvolution from compressed images is impossible using linear filters – but can be definitely achieved with non-linear techniques like optimization or machine learning.</p>



<h3>Aliasing</h3>



<p>And then, there’s aliasing. The ubiquitous signal processing and graphics problem. The reason it comes up here is that even if we model blur coming from a lens perfectly, then when we sample the signal by camera sensor and introduce aliasing, this aliasing corrupts the measurements of the higher (and sometimes mid or lower!) frequencies of the input signal.</p>



<p>This is beyond the scope of this post, but this is why one would want to do a <a href="https://arxiv.org/abs/1905.03277">proper super-resolution and multiframe reconstruction</a> of the signal first – that both removes aliasing, as well as reconstructing the higher frequencies – before any kind of deconvolution. Unfortunately any super-resolution reconstruction error might be amplified heavily this way, so worth watching out.</p>



<h3>Different signal space, gamma etc</h3>



<p>If blur happens in one space (e.g. photons, light intensity), then deblurring in another space (gamma corrected images) is a rather bad idea. It can work “somewhat”, but I’d recommend against doing so. Interestingly, my recommendation is at odds with the common practice of sharpening (for appearance) in the output space (“perceptual”) which tends to produce less over-brightening – while convolution happens in the linear light space. I will ignore this subtlety here, and simply recommend deconvolving in the same space as the convolution happened.</p>



<h3>Regularizing against noise and infinities</h3>



<p>What can we do about the above in practice? We can always bound the gain to some maximum value and find it by tuning. That can work ok, but feels inelegant and is not noise magnitude dependent.</p>



<p>An alternative is <a href="https://en.wikipedia.org/wiki/Wiener_deconvolution">Wiener deconvolution</a> which provides a <strong>least-squares optimal estimation of the inverse of a noisy system</strong>. Generally, <a href="https://en.wikipedia.org/wiki/Wiener_filter">Wiener filter</a> requires knowing the power spectral density distribution of the input signal. We could use the image / signal empirical PSD, or general, <a href="https://www.sciencedirect.com/science/article/pii/0042698996000028">expected distribution for natural images</a>. But I’ll simplify even further and assume a flat PSD of 1 (not correct for natural images that have a strong spectral decay!), getting a formula for a general setting with response of  <img data-attachment-id="4684" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image4/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image4.png" data-orig-size="591,372" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image4" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image4.png?w=300" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image4.png?w=591" src="https://bartwronski.files.wordpress.com/2022/05/image4.png" alt=""/> , where X is a convolution filter frequency response, and <img data-attachment-id="4697" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image49/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image49.png" data-orig-size="121,129" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image49" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image49.png?w=121" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image49.png?w=121" src="https://bartwronski.files.wordpress.com/2022/05/image49.png" alt=""/> is per frequency noise standard deviation. Wikipedia elegantly explains how this can be rephrased in terms of SNR:</p>



<figure><a href="https://bartwronski.files.wordpress.com/2022/05/image20.png"><img loading="lazy" data-attachment-id="4689" data-permalink="https://bartwronski.com/2022/05/26/removing-blur-from-images-deconvolution-and-using-optimized-simple-filters/image20/" data-orig-file="https://bartwronski.files.wordpress.com/2022/05/image20.png" data-orig-size="1410,359" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image20" data-image-description="" data-image-caption="" data-medium-file="https://bartwronski.files.wordpress.com/2022/05/image20.png?w=300" data-large-file="https://bartwronski.files.wordpress.com/2022/05/image20.png?w=640" src="https://bartwronski.files.wordpress.com/2022/05/image20.png?w=1024" alt="" width="137" height="35" srcset="https://bartwronski.files.wordpress.com/2022/05/image20.png?w=137 137w, https://bartwronski.files.wordpress.com/2022/05/image20.png?w=274 274w, https://bartwronski.files.wordpress.com/2022/05/image20.png?w=150 150w" sizes="(max-width: 137px) 100vw, 137px"/></a></figure>



<p>With infinite or large SNR, this goes towards direct inverse. With tiny SNR, we get cancellation of the inverse and asymptotically go towards zero. How does it look in terms of the frequency response? </p>


<div>
<figure><img src="https://lh4.googleusercontent.com/ie7nkKXvzq9_py7iMk_6nSlunBeu3gqDabDTsG906eSgKj2dwNYqqvhRkuCFmG_PBOpmTsBFcQhsEm3RRGRvgEgtniVJKDN5cyy6OUfacQhFS0hip76lSRLUqPHZwQ3LpRxZlNbw71TWG9MTUg" alt="" width="332" height="332"/><figcaption>Wiener shrinkage / regularization of the deconvolution – frequency response.</figcaption></figure></div>


<p>Notice how the inverse response is the same at the beginning of the curve with and without the regularization, but changes dramatically as the convolution attenuates more and more the highest frequencies. It goes to just zero at the Nyquist frequency – as we don’t have any information left there and it not just doesn’t amplify, but also removes noisy signal there. <strong>This can be thought of as actual combined deconvolution and denoising</strong>!</p>



<p>Here are two examples of the different noise levels and different deconvolution results:</p>


<div>
<figure><img src="https://lh4.googleusercontent.com/eQp7QHnu0NySjzURWb0pgBxUr5ZC-WBo4khL5Ys59FhtUJDNGONLh8Vc2UNUMZTbJuWvkVkhygQ1bhEAUdgKzZZFDShJL1Zm3FRC96tm9-lXIZ4Vxtz79TBRHMkIt0ElG_fLA3N5tOUpApFrYg" alt=""/><figcaption><strong>Left:</strong> Original image. <strong>Center:</strong> Blurred through convolution. <strong>Right:</strong> Regularized deconvolution of a blurry and noisy image.</figcaption></figure></div>


<p>Worth noting how <strong>deconvolved results are still noisy, and still not perfectly reconstructing the original image</strong> – Wiener deconvolution can give optimal results in the least squares sense (though we simplified it as compared to original Wiener deconvolution and don’t take signal strength into account), but it doesn’t mean it will be optimal perceptually – it doesn’t “understand” our concepts of noise or blur. And it doesn’t adapt in any way to structures present in data…</p>



<h2>Deconvolution in practice</h2>



<p>We went through the theory of deconvolution, as well as some practical caveats like regularization against noise, so it’s <strong>time to put this into practice</strong>. I will start with a more “traditional”, slower method, followed by a simplified one, designed for real time and/or GPU applications.</p>



<h3>Deconvolution by filter design</h3>



<p>The first way of deconvolving is as easy as it gets; use a signal processing package to optimize a linear-phase FIR filter for the desired response. Writing your own that is optimal in the least-squares sense is maybe a dozen lines of Python code – later in the post we will use for a similar purpose. For this section, I used the excellent scipy.signal package.</p>


<div><pre title="">convolution_filter = [0.25,0.5,0.25]
freq, response_to_invert = scipy.signal.freqz(convolution_filter)
noise_reg = 0.01
coeffs = 21
deconv_filter = scipy.signal.firls(coeffs , freq/np.pi, np.abs(response_to_invert)/(np.abs(response_to_invert)**2+(noise_reg)**2))
</pre></div>


<p>The earlier figures I generated this way:</p>


<div>
<figure><img src="https://lh4.googleusercontent.com/eQp7QHnu0NySjzURWb0pgBxUr5ZC-WBo4khL5Ys59FhtUJDNGONLh8Vc2UNUMZTbJuWvkVkhygQ1bhEAUdgKzZZFDShJL1Zm3FRC96tm9-lXIZ4Vxtz79TBRHMkIt0ElG_fLA3N5tOUpApFrYg" alt=""/></figure></div>


<p>If you’re curious, those are the plots of the generated filters:</p>


<div>
<figure><img src="https://lh3.googleusercontent.com/1D8eqf1mJ3CYhNs0-9duJJtwysK4q_whgDPzgMz3r2mXIRc6ElNj3koS_vq75Q87ayg_cqoXXCAR0KfkC1-6nqVXJB7cRi6RTAOQYsth2MTaNyCWxYmWQ7ZJgEbaWQMGLL7yJ1h5jiL9tlzW9w" alt=""/><figcaption>Filter weights for two of our result deconvolution filters. </figcaption></figure></div>


<p>They should match the intuition – <strong>a more regularized filter can be significantly smaller in spatial support</strong> (doesn’t require “infinite” sampling to reconstruct frequencies closer to Nyquist), and it has less strong gains and less negative weights, preventing oversharpening of the noise. For the stronger filter, we are clearly utilizing all the samples, and most likely a larger filter would work better. Here is a comparison of desired vs actual frequency responses:</p>


<div>
<figure><img src="https://lh5.googleusercontent.com/2X_8xu9-YrmzJXVVG8VcpKxHTYgHjz1Da5fiVPPgdX_HTLHH5OPGjisMka-qYRC3K6spfpLu9oB0UKUWRwEivh7Wf1OeUm8cir5JbFjHo8L42JNU81gFeaAO1D5hWhuw8qndTKSuvcJIf7BmqQ" alt=""/><figcaption>Frequency responses of two of our result deconvolution filters.</figcaption></figure></div>


<p>From here, one can go deeper into signal processing theory and practice of filter design – there are different filter design methods, different trade-offs, different results.</p>



<p>But I’d like to offer an alternative method that has a larger error, but is much better suited for real time applications.</p>



<h3>Deconvolution by simple filter combination</h3>



<p>Finding direct deconvolution filters through filter design works well, but it has one big disadvantage – resulting filters are huge, like 21 taps in the above example.</p>



<p>With separable filtering this might be generally ok – but if one was to implement a non-separable one, using 441 samples is prohibitive. Finding those 21 coefficients is also not instantaneous (require a pseudoinverse of a 21×21 matrix; or <strong>in case of non-separable filtering, solving a system involving a 441×441 matrix</strong>! Cost can be cut by half or quarter using symmetry of the problem, but it’s still not real-time instantaneous).</p>



<p>In computer graphics and image processing we tend to decompose images to pyramids for faster large spatial support processing. We can use this principle here.</p>



<p>A paper that highly inspired me a while ago was <a href="https://pages.cs.huji.ac.il/danix-lab/cglab/projects/convpyr/data/convpyr-small.pdf">“Convolution Pyramids”</a> – be sure to have a read. But this paper uses a complicated method with a non-linear optimization, which works great for their use-case, but here would be an overkill.</p>



<p>For a simple application like deconvolution, <strong>we can use simply a sum of Laplacians resulting from Gaussian filtering instead</strong>.</p>



<p>Imagine that we have a bunch of Gaussian filters with sigmas 0.3, 0.6, 0.9, 1.2, 1.5 (chosen arbitrarily) and their Laplacians (difference between levels) plus a “unity” filter that we will keep at 1.0. This way, we have 4 frequency responses to operate with and to try adding to reach the target response:</p>


<div>
<figure><img src="https://lh3.googleusercontent.com/MPdGGUpM13Nal-mdAxyLjGhAEej49FZgTRmhFm_TsCwstKgkJKT6KDIY25pQa0kOC-Y_jCmfcR72Io1Vn1tFnsxGFboZ4g6k1Nn0Vez0ucCn3hyEtrLfKu2RgqN-gBHBCiu4wcoIlxILA_0AUQ" alt=""/><figcaption>Different Laplacian levels frequency responses.</figcaption></figure></div>


<p>In numpy, this would be something like this:</p>


<div><pre title="">def gauss_small_sigma(x: np.ndarray, sigma: float):
  p1 = scipy.special.erf((x-0.5)/sigma*np.sqrt(0.5))
  p2 = scipy.special.erf((x+0.5)/sigma*np.sqrt(0.5))
  f = (p2-p1)/2.0
  return f / np.sum(f)

filters = [gauss_small_sigma(np.arange(-5, 5, 1), s) for s in (0.00001, 0.3, 0.6, 0.9, 1.2, 1.5)]
filters_laps = [np.abs(scipy.signal.freqz(a - b)[1]) for a,b in zip(filters[1:], filters)]
stacked_laps = np.transpose(np.stack(filters_laps))
target_resp = stacked_laps, target - np.ones_like(target)
regularize_lambda = 0.001
solution_coeffs = np.linalg.lstsq(stacked_laps.T.dot(stacked_laps) + regularize_lambda * np.eye(stacked_laps.shape[1]),
                                  stacked_laps.T.dot(target_resp))[0]
</pre></div>


<p>Here, solved coefficients are [-17.413, 54.656, -52.741, 20.025] and the resulting fit is very good:</p>


<div>
<figure><img src="https://lh5.googleusercontent.com/eNUk5J1yYn3wxXWtZWJYg5VQlzYh5lchUpEb_f0Pt0l_5BMfdQq9dCclgHb_svYIrkepVzEH2_4fWAODs2JpoTSjLOmWvE0VD_atWKFYzJ-HjUNPaS_xProckCZTAYNxeZRDaYdynMt5nWAjgQ" alt=""/></figure></div>


<p><strong>Edit</strong>: just right after publishing I realized I missed one Laplacian from plots and the next figure. Off by one error – sorry about that. Hopefully it doesn’t confuse the reader too much.</p>



<p>We can then convert the Laplacian coefficients to Gaussian coefficients if we want. But it’s also interesting to see how contributing Laplacians look like:</p>


<div>
<figure><img src="https://lh4.googleusercontent.com/5ZjVoOO35BVa2rIx2k1dO48y5Wibqn_i6CQIUmUtRm_O_BEG8gA-FZmlurlCsAw4tg2OG6qjO7nox4NH81JIYjwb8ncyz45dkfprXtxbXxmVcXqptrGk-szbHf2CfEm0wLyZOZDx0f1CKKvyfQ" alt="" width="579" height="378"/><figcaption>Source blurry image, different enhanced Laplacians, and the resulting deconvolved image.</figcaption></figure></div>


<p>As before, the results are not great because we have a relatively large blur and some noise. To improve it for such a combination, we would need to look at some non-linear methods. It’s also interesting that Laplacians seem to be huge in range and value (with my visualization clipping!), but their contributions mostly cancel each other out.</p>



<p>Note that this least squares solve requires operating only on a 5×5 matrix, so it’s super efficient to solve every frame (possibly even per pixel, but I don’t recommend that). It also uses separable, easily optimizable filters.</p>



<p>I chose used blurs arbitrarily, to get some coverage of small sigmas (which can be implemented efficiently). My ex-colleagues had a <a href="https://arxiv.org/abs/2012.09322">very interesting piece of work and paper</a> that shows that by iterating the original blur kernel (which can be done efficiently in the case of small blurs; but you pay the extra memory cost for storing the intermediates), you can get a closed form expression coming from a truncated <a href="https://en.wikipedia.org/wiki/Neumann_series">Neumann series</a>. I recommend checking out their work, while I propose a more efficient alternative for small blurs.</p>



<h3>Even simpler filter for small blurs</h3>



<p>The final trick will come from a practical project that I worked on, and where blurs we were dealing with were smaller in magnitude (sigmas of like 0.3-0.6). We also had a sharpening part of the pipeline with some interesting properties that was authored by my colleague <a href="http://www.dsharlet.com/">Dillon</a>. I will not dive here into the details of that pipeline.</p>



<p>The thing that I looked at was the use of the kernel used to generate Laplacians – which was extremely efficient on the CPU and DSP and used “famous” dilated a-trous filter. I recommend <a href="https://gfx.cs.princeton.edu/pubs/Fattal_2007_MSA/index.php">an older paper</a> that explains well the signal processing “magic” of a repeated comb filtering. Its application for denoising can leave characteristic repeated artifacts due to non-linear blurring, but it’s excellent for generating non-decimating wavelets or Laplacians.</p>



<p>Here is a diagram that +/- explains how it works if you don’t have time to read the referenced paper:</p>


<div>
<figure><img src="https://lh3.googleusercontent.com/ZiwWQF82kyC03IIHI2Vg5aX1BtShFfSwvSAGi3kmlfU_8uB-icgoa7UU1u-Ksdlqjkya6l2b3afLN9gY3TV_cuCr8ronmTbHDOZz3g3JgAXmiA0FU8t2GUeaS4q6lAm6W-jb4aAQ9yHereNZbA" alt=""/><figcaption>Different comb filters and how combining them forms a form of non-decimating Laplacian pyramid or a non-decimating wavelet pyramid.</figcaption></figure></div>


<p>Notice how each next comb filter combined with the previous one approximates full lowpass filter better and better. To get even better results, one would need a better lowpass filter with more than 3 (or 9 in 2D) taps. Those 3 comb filters form also 3 Laplacians (unity vs Comb1, Comb 1 vs combined Comb 1 and 2, combined Comb 2 and 3 vs combined Comb 1 and 2).</p>



<p><strong>I looked at using those to approximate small sigma deconvolution and for those small sigmas they fit perfectly</strong>:</p>


<div>
<figure><img src="https://lh3.googleusercontent.com/_lSobEFoDjn4hxEfNjERFKAUsmNDN9cVu7Tp5HOFZqkkg063hddUsdf9ZSahyUyK1CEaFAHDo9SyPaM1t87FBl1HQ-iv6aykMgy3RSYWllBW2G1IVUTn7MPmdxOId1B0W2xaNXkcVfc2h1nBIw" alt=""/></figure></div>

<div>
<figure><img src="https://lh4.googleusercontent.com/uYV9y7aaAGqnsqjLqtRbdvfCnNYbfIVqRHgAXc-5bWwfc98Acy2_DzkYLVahe1tE_sLFnDKz3YKMO0YAfb8yXvSG6aVUSt2-uUgJSPvIQCVgjKmlzVtF425c6Y4jGaDBOMvS-J3ozmcSGEhBFw" alt=""/></figure></div>

<div>
<figure><img src="https://lh3.googleusercontent.com/bebTEv9vbbvlH9CxRdvrnETw1nRERsVMgvJZw10JuV0si7yOfXijOtp9pDVfE6UYE5gdJl_dattRW55Y5k8v9QEfGltwhog-OsM57jyUYLuE7BuvbWa0S5e3PhNgZsIhBl7ItDzrgTvrCNt4OQ" alt=""/></figure></div>


<p>How well does it work in practice on images? Very well!</p>


<div>
<figure><img src="https://lh4.googleusercontent.com/7vi8tE5sEZqZekTbf_T2XqawdXMrjOkkPZo1qiSUgWrYNRP_oUR9mJVEYMAO5IwhbG_VTP4kgl24BzDbVf4yWDKSrPBS83eNFU4P6khdXXq2V9MfQhmk2Z1EWykQUZedq_aTnAWCzQJjja8Cvw" alt=""/><figcaption><strong>Top row</strong>: Source image, blurred image with a small sigma, deconvolved image.</figcaption></figure></div>


<p>This is for a larger sigma of 0.7. Note also the third coefficient is always close to 0.0, so we can actually use only 2 comb filters and have just 2 Laplacians.</p>



<p>This can be implemented extremely efficiently (two passes of 9 taps; or 4 passes of 3 taps!), requires inverting just a 2×2 matrix (closed formula) and this one could be done per pixel in a shader. <a href="https://getreuer.info/">My colleague Pascal</a> suggested solving this over a <a href="https://en.wikipedia.org/wiki/Gaussian_quadrature">quadrature</a> instead of uniformly sampling the frequency response and even the Gramm matrix accumulation can be accelerated by an order or two of magnitude with not much loss of the fit fidelity.</p>



<h3>Bonus – convolution in relationship to sharpening</h3>



<p>As a small bonus, an extreme case – how well can a silly and simple <strong>unsharp mask</strong> (yes, that thing where you just subtract a blurred version of the image and multiply it and add back) approximate deconvolution..?</p>


<div>
<figure><img src="https://lh5.googleusercontent.com/0w6EDydQwbPY4ICeFPjmqS1fEpukLByo4WsnHxRFkkA8lahR9G5WAFWW6hAX3QPQbXFbG_U8vD2poe4uQJQhY9INaaMndEwW2ODIuyJaqe4s7fnK6Vx8llnrj2YEiYU8I526WZjlo96cGN-S8Q" alt="" width="349" height="349"/><figcaption>Using unsharp masking for deconvolution / deblurring.</figcaption></figure></div>

<div>
<figure><img src="https://lh5.googleusercontent.com/L32eO5SSSiWaHYAW-Ry-rsSUFrzkzqxL50j6ph2t23KGBCrTzxSC-U90XhdU7wtYdgyYzCEjzmDdrAdHr0lVo6XeQRcOwQcRoRBqmy1JkoKOEwsXy5_z8JPQicZhQ0wRZimZ5QWuoSqp2f8QRA" alt=""/><figcaption>Using unsharp masking for deconvolution / deblurring.</figcaption></figure></div>


<p>There’s definitely some oversharpening and “fat edges”, but given an arbitrary, relatively large kernel and just a single operation it’s not too bad! For smaller sigmas it works even better. “Sharpening” is a reasonable approximation of mild deconvolution. I am always amazed how well some artists’ and photographers’ tricks work and have a relationship to more “principled” approaches.</p>



<h2>Limitations of linear deconvolution and conclusions</h2>



<p>My post described the most rudimentary basis of single image deconvolution – its theory, algebraic and frequency domain take on the problem, practical problems, and how to create filters for linear deconvolution.</p>



<p>The quality of linear filters deconvolving noisy signals is not great – still pretty noisy, while leaving images blurry. <strong>To address this, one needs to involve non-linearity – local data dependence in the deconvolution process</strong>.</p>



<p>Historically many algorithms used optimization / iteration combined with priors. One of the simplest and oldest algorithms worth checking out is <a href="https://en.wikipedia.org/wiki/Richardson%E2%80%93Lucy_deconvolution">Richardson-Lucy deconvolution</a> (<a href="https://www.strollswithmydog.com/richardson-lucy-algorithm/">pretty good intro and derivation</a>, <a href="https://www.mathworks.com/help/images/ref/deconvlucy.html">matlab results</a>), though I would definitely not use it in practice.</p>



<p>Large chunk of work in the 90s and 00s used iterative optimization with image space priors like <a href="https://en.wikipedia.org/wiki/Total_variation_denoising">total variation prior</a> or sparsity prior. Those took minutes to process, produced characteristic flat textures, but also super clean and sharp edges and improved text legibility a lot – and not surprisingly, were used in forensics and scientific or medical imaging. And as always, multi-frame methods that have significantly more information captured over time worked even better – see <a href="http://dev.ipol.im/~mdelbra/videoFA/">this work</a> from one of my ex-colleagues, which was later used in commercial video editing products.</p>



<p>Modern way to approach it in a single-frame (but also increasingly more for videos) setting is unsurprisingly through <strong>neural networks</strong> which are both faster, as well as give higher quality results than optimization based methods.</p>



<p><a href="https://arxiv.org/abs/2112.09318">In my recent tech report</a> I proposed to combine super small and cheap neural networks with “traditional” methods (NN operates at lower resolution and predicts kernel parameters for a non-ML algorithm) and got some decent results:</p>



<figure><img src="https://lh3.googleusercontent.com/6ben5GnnFJE0k2EbyC5p0H5KaH4TXB1P2U7d9ohWVxBUYeXTug1CPWkE-vxrcAdrWLoBlP5Dt35kItr-XY9IstiIOI05EXRZAbuS-1hrlRyHBI49I3dev1GYz1zpJGVINZzgP5z8nW-THJvowg" alt=""/><figcaption><strong>Left:</strong> Source image. <strong>Middle:</strong> Blurry and noisy image. <strong>Right:</strong> Deconvolution + denoising using a mix of a tiny neural network and a set of traditional kernels. While the noise is much stronger than in the examples above, we don’t see catastrophic magnification and wrong textures.</figcaption></figure>



<p>Any decent nonlinear deconvolution would detect and adapt to local features like edges or textures, and treat them differently from flat areas, trying to amplify blurred local structure, while ignoring the noise. This is a very fun topic, especially when reading about combinations of deconvolution and denoising, very often <a href="https://www.sciencedirect.com/science/article/pii/S0896627315010843">encountered in scientific and medical imaging</a>, where one physically cannot acquire better data due to physical limitations, costs, or for example to avoid exposing patients to radiation or inconvenience.</p>



<p>Hope you enjoyed my post, it inspired you to look more at the area of deconvolution, and that it demystified some of the “deblurring”, “sharpening”, and “super-resolution” circle of confusion. 🙂 </p>
											</div></div>
  </body>
</html>
