<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.wilcoxd.com/2022/02/21/Functional-Programming-Patterns-In-Smalltalk/">Original</a>
    <h1>Functional programming patterns in Smalltalk</h1>
    
    <div id="readability-page-1" class="page"><section>
<p>What is functional programming?, you may ask:</p>
<blockquote>
<p>In computer science, functional programming is a programming paradigm where programs are constructed by applying and composing functions</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Functional_programming">Source: Wikipedia</a></p>
<p>Wikipedia’s definition of functional programming is OK, although purists would argue that functional programming includes pure functions that don’t modify state, and likely offer immutable data structures (as popularized by Clojure). However, Wikipedia’s definition is mostly good enough. In the past couple of decades the idea of lightweight functions, applied by library algorithms to provide a composable - and hopefully more declarative way of coding - has gained traction.</p>
<p>While it had been around before that, I was first introduced to functional programming concepts through <a href="https://docs.microsoft.com/en-us/cpp/standard-library/function-objects-in-the-stl?view=msvc-170">C++‘s functional objects</a>: create a small class that implements the <code>()</code> operator, maybe hold some data applied at call time, it gets called by some library algorithm at the appropriate time.</p>
<p>For more information on this pattern in C++, <a href="https://homepages.ecs.vuw.ac.nz/~tk/publications/papers/function-object.pdf">see “The Function Object Pattern”, from in C++ Report, Vol 9 #9, pages 32–42, October 1997</a>.</p>
<p>Functional objects are great, and still a trick I sometimes use today: objects marry behavior with data, and functional objects were no different. Sometimes you need to seed some extra data into your lightweight function execution! This can be data <em>in addition to</em> whatever data you’re getting passed via an “for every element in this list, call this method passing as a parameter the current value” algorithm function.</p>
<p>Over the last decade I’ve seen functional paradigms become more and more accepted, and easier and easier to use as a developer. What once took you a whole C++ class and boilerplate <a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expression-syntax?view=msvc-170">is now a couple characters of syntax, for example</a>.</p>
<p>In modern languages, almost every standard library leans into the idea of anonymous user provided functions (called lambdas or closures) for standard iteration and algorithm methods.</p>
<p>What if we look at functional programming concepts not through a modern language, but through the eyes of a 50 year old one? Smalltalk, first created in 1972ish, then widely released as Smalltalk-80.</p>
<p>Let’s first start by examining Smalltalk a bit, then jump into common functional paradigms in languages, from most frequently seen (in mainstream multi-paradigm languages) to least. (Yes, I know about Scala).</p>

<p>Smalltalk is one of the very first object oriented languages. It’s also super neat because it doesn’t have any built-in control structures!</p>
<p><em>record scratch</em></p>
<p>“Ummm, does that mean it can’t do <code>if</code> statements?”</p>
<p>Gentle reader, here’s how you do an if statement in Smalltalk:</p>
<div data-language="smalltalk"><pre><code><span>true</span> ifTrue<span>:</span> <span>[</span> <span>&#39;I was true&#39;</span> <span>]</span><span>.</span></code></pre></div>
<p>Here we have <code>true</code> (an instance of the Smalltalk <code>True</code> class, a subclass of <code>Boolean</code>). We call the method <code>ifTrue:</code> on it, and pass it a small, composable function. As the instance is true, our function is executed.</p>
<p>The <code>False</code> class’s implementation simply does nothing, which is an elegant way to solve this bootstrap problem: by polymorphism, a sprinkling of inheritance, and a language where <em>everything</em> everything is an object.</p>
<p>Back to those small, composable, inline function things. Smalltalk calls these little functions “blocks” (I assume because the square brackets makes it look like your logic is inside a little rectangle), but other languages call them closures or lambdas. Theoretically there’s a difference, but practically everyone uses either one of these three names to mean the same kind of thing.</p>

<p>Functional programming is most often used when iterating over a list: selecting items from a list, transforming items in a list into a different kind of object, etc.</p>
<p>Done simply in Smalltalk. First, set <code>ourList</code> to a three array element, and we iterate on it</p>
<div data-language="smalltalk"><pre><code>ourList <span>:=</span> <span>{</span> <span>1</span><span>.</span> <span>2</span><span>.</span> <span>3</span> <span>}</span><span>.</span>

ourList collect<span>:</span> <span>[</span><span><span>:in</span> <span>|</span></span> in <span>+</span> <span>1</span> <span>]</span><span>.</span></code></pre></div>
<p>This returns a list: 2, 3, 4.</p>
<p>Sometimes you want to take a list, grab only certain elements out of it, then operate on those. Ideally you want to do this in an efficient way: only operating on elements you’re going to use: if a data element matches the select it is immediately processed by the collect, vs waiting for the entire list to be filtered.</p>
<div data-language="smalltalk"><pre><code>ourList select<span>:</span> <span>[</span> <span><span>:num</span> <span>|</span></span> <span>(</span>num <span>\\</span> <span>2</span><span>)</span> <span>=</span> <span>0</span>  <span>]</span> thenCollect<span>:</span> <span>[</span><span><span>:n</span> <span>|</span></span> n <span>+</span> <span>2</span><span>]</span></code></pre></div>
<p>Two points:</p>
<ol>
<li>Yes, the method’s actual name is <code>select:thenCollect:</code></li>
<li>Yes, the collect closure is only called for even numbers</li>
<li><code>\\</code> means mod / return the remainder</li>
</ol>
<p>Smalltalk offers an OK collection of these complex methods. But maybe I have a situation where I want to select the even numbers, add two to them, then ONLY keep the result if it’s &gt; 8.</p>

<p>In this view of functional programming - the composing of small functions and moving data through a chain of operations - it should be easy to <a href="https://en.wikipedia.org/wiki/Method_chaining">chain function calls together</a>. The Lisp people often call these threads, or thread macros, which is slightly confusing because of CPU threading or when in languages, like Smalltalk, that don’t have macros.</p>
<p>Back to our example, what if we wanted to perform an additional select at the end of our <code>select:thenCollect</code> workflow above? Let’s say <code>select:thenCollect:andCollectSomeMore:</code> ?</p>
<p>Using an <a href="https://gist.github.com/zeroflag/1634116227c3b811f0692db4f2889634">excellent 10 line chaining solution by Attila Magyar</a> we can get just that:</p>
<div data-language="smalltalk"><pre><code>ourList chain
  select<span>:</span>  <span>[</span> <span><span>:num</span> <span>|</span></span> <span>(</span>num <span>\\</span> <span>2</span><span>)</span> <span>=</span> <span>0</span>  <span>]</span><span>;</span>
  collect<span>:</span> <span>[</span><span><span>:n</span> <span>|</span></span> n <span>+</span> <span>2</span><span>]</span><span>;</span>
  collect<span>:</span> <span>[</span><span><span>:m</span> <span>|</span></span> m <span>+</span> <span>2</span><span>]</span><span>.</span></code></pre></div>
<p>This is a wonderful, lightweight example of what Smalltalk can do, the expressiveness in almost zero syntax. (In Smalltalk <code>;</code> means “send this message to the same receiver”. Which in this case is doing some state management an proxying those messages to the result of the last expression)</p>
<p>There is in fact nothing magical about this, we could write a similar thing by hand:</p>
<div data-language="smalltalk"><pre><code><span>(</span><span>(</span>ourList select<span>:</span> <span>[</span> <span><span>:num</span> <span>|</span></span> <span>(</span>num <span>\\</span> <span>2</span><span>)</span> <span>=</span> <span>0</span>  <span>]</span><span>)</span> collect<span>:</span> <span>[</span><span><span>:n</span> <span>|</span></span> n <span>+</span> <span>2</span><span>]</span><span>)</span> collect<span>:</span> <span>[</span><span><span>:m</span> <span>|</span></span> m <span>+</span> <span>2</span><span>]</span></code></pre></div>
<p>This doesn’t feel good: counting the <code>(</code>s was not fun, even in this trivial example.</p>
<p>It’s worth noting that, unlike the builtin <code>select:theCollect:</code> method, <code>chain</code> does not result in a lazy workflow. The entire collect is processed in a step, then the entire thing passed off to the next step.</p>

<p>In complicated APIs or programs, sometimes that data we want is deep inside a structure full of stuff we <em>don’t</em>. <a href="https://chrispenner.ca/posts/traversal-systems">Chris Penner calls how we access this data a traversal system</a>, where as <a href="https://web.cecs.pdx.edu/~antoy/homepage/publications/wflp11/paper.pdf">Sergio Antoy and Michael Hanus’ paper on new functional logic design patterns</a> (<a href="https://web.cecs.pdx.edu/~antoy/flp/patterns/">site</a>) would call it “deep selection” (then they present an implementation that can <em>only</em> be achieved by functional-logic languages, so they may disagree with <em>my</em> application of the term.)</p>
<p>Anyway, traversal systems allow a developer to get a single value(s) “over there, and deep inside”. The Haskell community created the idea of lenses on data structures, and this idea has been ported to other languages (I’ve played with the <a href="https://docs.racket-lang.org/lens/lens-intro.html#%28tech._lens%29">Racket implementation</a> and a Javascript one too).</p>
<p>So what does Smalltalk give us in these regards?</p>
<p>For Dictionaries, not lists like <code>ourList</code>, Smalltalk offers some object traversal methods.</p>
<p>First, we construct our objects to work with</p>
<div data-language="smalltalk"><pre><code>deepDatadictInner <span>:=</span> Dictionary newFrom<span>:</span> <span>{</span> <span>1</span> <span>-</span><span>&gt;</span> <span>2</span><span>.</span> <span>&#39;myKey&#39;</span> <span>-</span><span>&gt;</span> <span>4</span><span>.</span> <span>5</span> <span>-</span><span>&gt;</span> <span>6</span> <span>}</span><span>.</span>
outerDataDict <span>:=</span> Dictionary newFrom<span>:</span> <span>{</span> <span>&#39;outer&#39;</span> <span>-</span><span>&gt;</span> deepDatadictInner<span>.</span> <span>&#39;inner&#39;</span> <span>-</span><span>&gt;</span> <span>&#39;hi&#39;</span><span>}</span><span>.</span></code></pre></div>
<p>Smalltalk’s <code>Dictionary</code> objets have an <code>at:at:</code> method which let you select an element from the Dictionary, then call at on that. Much like the <code>select:thenCollect:</code> method, you could duplicate this with some parans, but that’s ugly</p>
<div data-language="smalltalk"><pre><code>outerDataDict at<span>:</span> <span>&#39;outer&#39;</span> at<span>:</span> <span>&#39;myKey&#39;</span><span>.</span></code></pre></div>
<p>returns 6.</p>
<p>Thats one of the basic, builtin methods from Smalltalk. Of course, it has limits as theres only <code>at:at:</code>, so for deeper objects you may need our <code>chain</code> method, above.</p>
<h2>When Deep Select gets you in a bind: or stealing concepts from Kotlin (scope methods)</h2>
<blockquote>
<p>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object.</p>
</blockquote>
<p>In Kotlin this is called <a href="https://kotlinlang.org/docs/scope-functions.html">scope methods</a></p>
<p>What does this really mean? If you’re in the middle of a functional workflow, but need to do something <em>not exactly</em> functional, you can execute a block of code, getting the message receiver passed in as a parameter. Then pass the result of <em>that</em> expression to the next item in the chain.</p>
<p>Smalltalk’s has the <code>in:</code> method that does just that. We’ll see it here, without <code>chain</code>:</p>
<div data-language="smalltalk"><pre><code><span>(</span><span>(</span>ourList collect<span>:</span> <span>[</span><span><span>:in</span> <span>|</span></span> in <span>+</span> <span>1</span> <span>]</span><span>)</span> in<span>:</span> <span>[</span><span><span>:newList</span> <span>|</span></span> newList compact<span>.</span> newList<span>.</span> <span>]</span><span>)</span> asArray<span>.</span></code></pre></div>
<p><code>compact</code> doesn’t return anything, so we use <code>in:</code> to call it, then return our object again to keep the workflow working. (In Smalltalk, the value returned from a block is the result of the last statement in the block.)</p>
<p>(We could also get fancy and phrase the block like <code>newList compact; yourself</code>, where <code>yourself</code> is a message that returns it’s receiver / instance.)</p>
<p>We could write this without a functional workflow, it would just take more lines:</p>
<div data-language="smalltalk"><pre><code><span><span>|</span><span>newList</span><span>|</span></span>

newList <span>:=</span> ourList collect<span>:</span> <span>[</span><span><span>:in</span> <span>|</span></span> in <span>+</span> <span>1</span> <span>]</span><span>.</span>
newList compact<span>.</span>
newList asArray<span>.</span></code></pre></div>
<p>One line is somewhat more elegant here.</p>
<h2>Traversal systems in Smalltalk when doing work with JSON</h2>
<p>In the modern world of APIs, developers will often be dealing with API responses in JSON, and in normal RESTful intefaces the desired information may be deeply buried in some structure (unlike <a href="https://www.apollographql.com/">GraphQL</a> where the client controls the shape of the object returned).</p>
<p>Smalltalk has the <a href="https://github.com/svenvc/NeoJSON">NeoJSON library</a> with one class for happy, fast and dirty hacking: <code>NeoJSONObject</code>.</p>
<p><code>NeoJSONObject</code> lets you access keys in a JSN structure as if they were messages in Smalltalk.</p>
<div data-language="smaltalk"><pre><code>json := NeoJSONObject readFromString: jsonStringVersionOfOuruterDataDict.
json outer myKey.</code></pre></div>
<p>I really like traversal systems that are easy to write for easy cases. And if there’s a more complicated structure, perhaps use <code>NeoJSONObject</code> as far as you can, then use more fine grained tools where you have to.</p>

<p>A more complex control statement in modern languages is the idea of a “pattern matching” control structure. Think of it as a very good <code>switch</code> statement or an if with multiple conditions or results.</p>
<p>Kotlin calls this a <a href="https://kotlinlang.org/docs/control-flow.html#when-expression">when expression</a> and it look like so:</p>
<div data-language="kotlin"><pre><code><span>when</span> <span>(</span>x<span>)</span> <span>{</span>
    <span>0</span><span>,</span> <span>1</span> <span>-&gt;</span> <span>print</span><span>(</span><span>&#34;x == 0 or x == 1&#34;</span><span>)</span> 
    name <span>==</span> <span>&#34;ryan&#34;</span> <span>-&gt;</span> <span>print</span><span>(</span><span>&#34;even unrelated things do work&#34;</span><span>)</span>
    <span>else</span> <span>-&gt;</span> <span>print</span><span>(</span><span>&#34;otherwise&#34;</span><span>)</span>        
<span>}</span></code></pre></div>
<p>Only one of these expressions will evaluate to true, and once matched no other branches are matched.</p>
<p>Since Smalltalk doesn’t even have <code>if</code> statements as syntax, can we add pattern matching to Smalltalk?</p>
<p>You betcha. I have, in <a href="https://github.com/rwilcox/PatternMatcher">rwilcox/PatternMatcher</a>!</p>
<div data-language="smalltalk"><pre><code>x patternMatchWithRules<span>:</span> <span>{</span>
  PMRule whenMatches<span>:</span> <span>[</span> <span><span>:o</span> <span>|</span></span> <span>(</span>o <span>=</span> <span>0</span><span>)</span> or<span>:</span> <span>(</span>o <span>=</span> <span>1</span><span>)</span> <span>]</span> execute<span>:</span> <span>[</span> <span>&#39;x == 0 or x == 1&#39;</span> <span>]</span><span>.</span><span>.</span>
  PMRule whenMatches<span>:</span> <span>[</span> name <span>=</span> <span>&#39;ryan&#39;</span> <span>]</span>  execute<span>:</span> <span>[</span> <span>&#39;hi, Ryan  ].
  PMRule whenMatches: [ true ] execute: [ &#39;</span>else&#39; <span>]</span><span>.</span>
<span>}</span></code></pre></div>
<p>In those <code>PMRule</code> lines, if the <code>whenMatches</code> block returns true the <code>execute</code> block is run. Else the next rule is evaluated.</p>

<p>Modern multi-paradigm languages allow for great functional patterns inside them. From languages almost nobody thinks of as functional (C++, Kotlin), to languages that are functional but impure (Racket), to pure functional languages (Haskell). These concepts can be cherry-picked into very unexpected places: the 50 year old very OO paradigm heavy Smalltalk. Smalltalk, which talks to providing almost nothing by the way of control structures lets bootstrapping and elegance happen by developers.</p></section></div>
  </body>
</html>
