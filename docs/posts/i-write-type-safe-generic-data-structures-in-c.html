<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danielchasehooper.com/posts/typechecked-generic-c-data-structures/">Original</a>
    <h1>I Write Type Safe Generic Data Structures in C</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>June 25, 2025・7 minute read</p><div><p>I write type safe generic data structures in C using a technique that I haven’t seen elsewhere<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. It uses unions to associate type information with a generic data structure, but we’ll get to that. My approach works for any type of data structure: maps, arrays, binary trees… but for this article I illustrate the ideas by implementing a basic linked list. Since many people aren’t aware you can do C generics <em>at all</em>, I figured I’d start simple and build up to this:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>int</span> <span>value</span><span>;</span>
</span></span><span><span><span>}</span> <span>Foo</span><span>;</span>
</span></span><span><span>    
</span></span><span><span><span>List</span><span>(</span><span>int</span><span>)</span> <span>int_list</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
</span></span><span><span><span>list_prepend</span><span>(</span><span>&amp;</span><span>int_list</span><span>,</span> <span>3</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>List</span><span>(</span><span>Foo</span><span>)</span> <span>foo_list</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
</span></span><span><span><span>list_prepend</span><span>(</span><span>&amp;</span><span>foo_list</span><span>,</span> <span>(</span><span>Foo</span><span>){</span> <span>5</span> <span>});</span>
</span></span><span><span><span>list_prepend</span><span>(</span><span>&amp;</span><span>foo_list</span><span>,</span> <span>(</span><span>Foo</span><span>){</span> <span>3</span> <span>});</span>
</span></span><span><span>
</span></span><span><span><span>// this won&#39;t compile, which is good!
</span></span></span><span><span><span>// list_prepend(&amp;foo_list, 7); 
</span></span></span><span><span><span></span>
</span></span><span><span><span>list_for</span><span>(</span><span>item</span><span>,</span> <span>&amp;</span><span>foo_list</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// `item` is of type `Foo *`
</span></span></span><span><span><span></span>    <span>printf</span><span>(</span><span>&#34;%i</span><span>\n</span><span>&#34;</span><span>,</span> <span>item</span><span>-&gt;</span><span>value</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>I hesitate to even mention this, because I do not like it<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>, but its worth comparing to the technique at the end of this article. It works like this: you write your data structure in a header, using macros for your types, and then <code>#include</code> the header multiple times; once for each type the data structure will be used with.</p><details><summary>Click to see the Code</summary><div><p><code>list.h</code></p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#ifndef T
</span></span></span><span><span><span>#error &#34;T must be defined before including this header&#34;
</span></span></span><span><span><span>#endif
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define _CONCAT(a, b) a##b
</span></span></span><span><span><span>#define CONCAT(a, b) _CONCAT(a, b)
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define NODE_TYPE CONCAT(T, ListNode)
</span></span></span><span><span><span>#define PREPEND_FUNC CONCAT(T, _list_prepend)
</span></span></span><span><span><span></span>
</span></span><span><span><span>typedef</span> <span>struct</span> <span>NODE_TYPE</span> <span>NODE_TYPE</span><span>;</span>
</span></span><span><span><span>struct</span> <span>NODE_TYPE</span> <span>{</span>
</span></span><span><span>    <span>NODE_TYPE</span> <span>*</span><span>next</span><span>;</span>
</span></span><span><span>    <span>T</span> <span>data</span><span>;</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>PREPEND_FUNC</span><span>(</span><span>NODE_TYPE</span> <span>**</span><span>head</span><span>,</span> <span>T</span> <span>data</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>NODE_TYPE</span> <span>*</span><span>node</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>*</span><span>node</span><span>));</span>
</span></span><span><span>    <span>node</span><span>-&gt;</span><span>data</span> <span>=</span> <span>data</span><span>;</span>
</span></span><span><span>    <span>node</span><span>-&gt;</span><span>next</span> <span>=</span> <span>*</span><span>head</span><span>;</span>
</span></span><span><span>    <span>*</span><span>head</span> <span>=</span> <span>node</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>#undef T
</span></span></span><span><span><span>#undef _CONCAT
</span></span></span><span><span><span>#undef CONCAT
</span></span></span><span><span><span>#undef NODE_TYPE
</span></span></span><span><span><span>#undef PREPEND_FUNC
</span></span></span></code></pre></div><p><code>main.c</code></p><div><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>int</span> <span>a</span><span>;</span>
</span></span><span><span><span>}</span> <span>Foo</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>typedef</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>char</span> <span>*</span><span>str</span><span>;</span>
</span></span><span><span>    <span>double</span> <span>num</span><span>;</span>
</span></span><span><span><span>}</span> <span>Bar</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>#define T Foo
</span></span></span><span><span><span>#include</span> <span>&#34;list.h&#34;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define T Bar
</span></span></span><span><span><span>#include</span> <span>&#34;list.h&#34;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>FooListNode</span> <span>*</span><span>foo_head</span> <span>=</span> <span>NULL</span><span>;</span>
</span></span><span><span><span>Foo_list_prepend</span><span>(</span><span>&amp;</span><span>foo_head</span><span>,</span> <span>(</span><span>Foo</span><span>){</span><span>1</span><span>})</span>
</span></span><span><span>
</span></span><span><span><span>BarListNode</span> <span>*</span><span>bar_head</span> <span>=</span> <span>NULL</span><span>;</span>
</span></span><span><span><span>Bar_list_prepend</span><span>(</span><span>&amp;</span><span>bar_head</span><span>,</span> <span>(</span><span>Bar</span><span>){</span><span>&#34;hello&#34;</span><span>,</span> <span>5.4</span><span>})</span>
</span></span></code></pre></div></div></details></div><p>❖</p><div><p>Get notified about my next article:</p></div></div></div></div>
  </body>
</html>
