<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lukeplant.me.uk/blog/posts/yagni-exceptions/">Original</a>
    <h1>Yagni Exceptions (2021)</h1>
    
    <div id="readability-page-1" class="page"><div id="contentinner">
  <article itemscope="" itemtype="http://schema.org/BlogPosting"><header>
      
      
    </header><section itemprop="articleBody"><div>
        <p>I&#39;m essentially a believer in <a href="https://martinfowler.com/bliki/Yagni.html">You Aren&#39;t Gonna Need It</a> — the principle that you should
add features to your software — including generality and abstraction — when it
becomes clear that you need them, and not before.</p>
<p>However, there are some things which really are easier to do earlier than later,
and where natural tendencies or a ruthless application of YAGNI might neglect
them. This is my collection so far:</p>
<ul>
<li><p>Applications of <a href="http://wiki.c2.com/?ZeroOneInfinityRule">Zero One Many</a>. If
the requirements go from saying “we need to be able to store an address for
each user”, to “we need to be able to store two addresses for each user”, 9
times out of 10 you should go straight to “we can store many addresses for
each user”, with a soft limit of two for the user interface only, because
there is a very high chance you will need more than two. You will almost
certainly win significantly by making that assumption, and even if you lose it
won&#39;t be by much.</p></li>
<li><p>Versioning. This can apply to protocols, APIs, file formats etc. It is good to
think about how, for example, a client/server system will detect and respond
to different versions ahead of time (i.e. even when there is only one
version), especially when you don&#39;t control both ends or can&#39;t change them
together, because it is too late to think about this when you find you need a
version 2 after all. This is really an application of <a href="http://wiki.c2.com/?EmbraceChange">Embrace Change</a>, which is a principle at the heart of
YAGNI.</p></li>
<li><p>Logging. Especially for after-the-fact debugging, and in non-deterministic or
hard to reproduce situations, where it is often too late to add it after you
become aware of a problem.</p></li>
<li>
<p>Timestamps.</p>
<p>For example, creation timestamps, as <a href="https://twitter.com/simonw/status/1384580075329179650">Simon Willison tweeted</a>:</p>
<blockquote>
<p>A lesson I re-learn on every project: always have an automatically
populated &#34;created_at&#34; column on every single database table. Any time you
think &#34;I won&#39;t need it here&#34; you&#39;re guaranteed to want to use it for
debugging something a few weeks later.</p>
</blockquote>
<p>More generally, instead of a boolean flag, e.g. <code>completed</code>, a nullable
timestamp of when the state was entered, <code>completed_at</code>, can be much
more useful.</p>
</li>
<li><p>Generalising from the “logging” and “timestamps” points, collecting a bit more
data than you need right now is usually not a problem (unless it is personal
or otherwise sensitive data), because you can always throw it away. But if you
never collected it, it&#39;s gone forever. I have won significantly when I&#39;ve
anticipated the need for auditing which wasn&#39;t completely explicit in the
requirements, and I&#39;ve lost significantly when I&#39;ve gone for data minimalism
which lost key information and limited what I could do with the data later.</p></li>
<li>
<p>A relational database.</p>
<p>By this I mean, if you need a database at all, you should jump to having a
relational one straight away, and default to a relational schema, even if your
earliest set of requirements could be served by a “document database” or some
basic flat-file system. Most data is relational by nature, and a
non-relational database is a very bad default for almost all applications.</p>
<p>If you choose a relational database like PostgreSQL, and it later turns out a
lot of your data is “document like”, you can use its <a href="https://www.postgresql.org/docs/current/datatype-json.html">excellent support for
JSON</a>.</p>
<p>However, if you choose a non-rel DB like MongoDB, even when it seems like
you&#39;ve got a perfect fit in terms of current schema needs, most likely a new,
“simple” requirement will cause you a lot of pain, and <a href="http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/">prompt a rewrite in
Postgres</a>
(see sections “How MongoDB Stores Data” and “Epilogue” in that article).</p>
<p>I thought <a href="https://lobste.rs/s/63eb9g/when_rewrite#c_7gwj71">a comment on Lobsters</a> I read the other day was
insightful here:</p>
<blockquote>
<p>I wonder if the reason that “don’t plan, don’t abstract, don’t engineer
for the future” is such good advice is that most people are already
building on top of highly-abstracted and featureful platforms, which don’t
need to be abstracted further?</p>
</blockquote>
<p>We can afford to do YAGNI only when the systems we are working with are
malleable and featureful. Relational databases are extremely flexible systems
that provide insurance against future requirements changes. For example, my
advice in the previous section implicitly depends on the fact that removing
data you don&#39;t need can be as simple as &#34;DROP COLUMN&#34;, which is <a href="https://stackoverflow.com/questions/15699989/dropping-column-in-postgres-on-a-large-dataset">almost free</a>
(well, sometimes…).</p>
</li>
</ul>
<p>That&#39;s my list so far, I&#39;ll probably add to it over time. Do you agree? What did
I miss?</p>
<section id="links"><h2>Links</h2>
<ul>
<li><p><a href="https://twitter.com/spookylukey/status/1409967250426281984">Discussion of this post on Twitter</a>.</p></li>
<li><p><a href="https://simonwillison.net/2021/Jul/1/pagnis/">Simon Willison&#39;s response post on PAGNIs</a> with <a href="https://twitter.com/simonw/status/1410678459756552198">Twitter discussion</a> and <a href="https://lobste.rs/s/nokjr0/pagnis_probably_are_gonna_need_its">Lobsters discussion</a>.</p></li>
<li><p><a href="https://jacobian.org/2021/jul/8/appsec-pagnis/">Jacob Kaplan-Moss&#39;s response post on security PAGNIs</a>, and <a href="https://twitter.com/jacobian/status/1413157068375302146">Twitter discussion</a>.</p></li>
</ul></section>
</div>
    </section></article>



</div></div>
  </body>
</html>
