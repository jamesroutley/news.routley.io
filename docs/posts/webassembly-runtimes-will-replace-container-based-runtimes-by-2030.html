<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://changelog.com/posts/webassembly-runtimes-will-replace-container-runtimes-by-2030">Original</a>
    <h1>â€œWebAssembly runtimes will replace container-based runtimes by 2030â€</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><em>This is a fancified excerpt of Jonathan Norrisâ€™ unpopular opinion on <a href="https://changelog.com/gotime/275">Go Time #275</a>. Jonathan is Co-Founder &amp; CTO @ <a href="https://devcycle.com">DevCycle</a> where theyâ€™re using WebAssembly in very interesting ways. To get the full experience you should listen while you read.</em></p>
<p>ğŸ§Â Â <a data-play="/gotime/275/play" data-t="46:38" href="https://cdn.changelog.com/uploads/gotime/275/go-time-275.mp3" role="button" title="Play Go Time #275 starting at 46:37">Click here to listen along while you read. It&#39;s better! </a>Â Â ğŸ§</p>
<hr/>
<p>The advantages of <a href="https://webassembly.org">WebAssembly</a>, with its:</p>
<ol>
<li>tight security model</li>
<li>very fast boot-up time</li>
<li>scalability at the edge</li>
<li>much smaller footprints</li>
<li>portability across environments</li>
</ol>
<p>will really drive a shift away from container-based runtimes for things Kubernetes and edge workloads by 2030. Thereâ€™s a ton of energy around making this happen within the WebAssembly community.</p>
<figure>
  <p>
    <iframe src="https://www.youtube.com/embed/MckD7c8-_SE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe>
  </p>
  <figcaption>Subscribe to <a href="https://youtube.com/changelog">Changelog&#39;s YouTube channel</a> for more clips like this, live show recordings &amp; more âœŒï¸</figcaption>
</figure>
<p><strong>Kris Brandow:</strong> <em>What do you think is the largest barrier to getting there now?</em></p>
<p>Thatâ€™s a good question I would say:</p>
<ol>
<li>language support</li>
<li>profiling</li>
<li>tooling</li>
</ol>
<p>And as weâ€™ve talked about today a lot, getting to a point where you can optimize and profile the WebAssembly a lot easier is a big thing. And the standardizationâ€¦</p>
<p>So thereâ€™s a lot of really exciting changes to WebAssembly that are coming along. I think weâ€™ve talked about a couple of them already, around multi-threading support and native garbage collection support.</p>
<p>One of the big changes thatâ€™s coming is called the component model, which is a way to standardize the communication across multiple WebAssembly components so they can talk to each other and really make your code a lot more componentized (and in smaller chunks).</p>
<p>So thatâ€™s a big effort that the community is working on to drive towards replacing  largercontainers in these Kubernetes and edge workloads.</p>
<p>So yeah, I think those are the big things; if the WebAssembly community can get sort of those big changes that are coming - the component model, multi-threading, garbage collection support and many other things down, then I think weâ€™ll be on that path, and weâ€™ll see some big companies start up around this space in the coming years.</p>
<p><strong>Brad Van Vugt:</strong> <em>I think itâ€™s funny, because weâ€™ve talked about this a lot, and I think my unpopular opinion would be the opposite of yours. Because I donâ€™t know â€“ maybe more on timeframe, sure, maybe possibly, but I think the lift required is so large. Do you think that something AssemblyScript is crucial for that, as sort of this core, native entry point?</em></p>
<p>I think a more approachable, higher-level language is important as an entry point. I think thatâ€™s one of the challenges with WebAssembly right now: the best environments are lower-level environments, things using Rust, or C++.</p>
<p>Thereâ€™s actually a good amount of momentum around running JavaScript or TypeScript in WebAssembly, but by bundling in SpiderMonkey (Firefoxâ€™s JavaScript engine) into your WebAssembly runtime, theyâ€™ve been able to get that working in a couple megabytes. So you basically have the full SpiderMonkey runtime running within WebAssembly, running your JavaScript or compiled TypeScript code in thatâ€¦</p>
<p>For a lot of these Wasm cloud/edge companiesâ€¦ thatâ€™s one of the big entry points that theyâ€™re talking about.</p>
<p>But yeah, I would say getting a higher-level language that executes really efficiently in Wasm is probably one of the biggest barriers to that.</p>
<p><strong>Kris Brandow:</strong> <em>Thereâ€™s a lot of pressure from the other side, of VMs and hypervisors becoming super-fast, like with Firecracker, and all of that. Do you see maybe a merging of those technologies, so you can get the security benefits of virtual machines with the speed and all the other benefits of Wasm?</em></p>
<p>Donâ€™t get me wrong, those VMs have gotten very good over many years, and weâ€™ve been relying on them for a lot of our high-scale systems. But yeah, I think thereâ€™s just an order of magnitude difference between the size of containers.</p>
<p>You can optimize the size of your containers to be pretty small, like tens of megabytesâ€¦ But WebAssembly is, at its core, designed to be more portable than that.</p>
<p>Youâ€™re talking about tens of kilobytes, instead of tens of megabytes. And the boot-up times can be measured in microseconds, instead of milliseconds, or tens of milliseconds, or even seconds (!) for containers.</p>
<p>So thereâ€™s just an order of magnitude change by using WebAssembly. I think itâ€™s gonna be really hard for a lot of containerized systems to match.</p>
<p>You can think about a big platform running at the edge (at scale) where â€“ for our use case, we have a lot of SDKs that hit our edge APIs. And we have certain customers, say our big mobile appsâ€¦ And they may send out a push notification and get hundreds of thousands of people, or even millions of people who all open their app at exactly the same time.</p>
<p>When that sports score, or that big news event lands on their phone; theyâ€™re opening their app at exactly the same time, and we see massive deluges of traffic (literally, a hundred times our steady state traffic) hit our edge endpoints in those points in time. And because weâ€™re using these edge platforms, theyâ€™re able to spin up thousands of runtimes of Wasm and edge runtimes in milliseconds to serve that traffic. And having to do that with VMs is possible, but thereâ€™s a lot more latency in that toolchain.</p>
<p>So thatâ€™s why I think the power of not only the really tight security model, but the boot-up times, the small size of the Wasm modules really can power that. And for certain use cases it makes a lot of sense.</p>
<p>Iâ€™m not gonna say itâ€™s gonna replace every use case; itâ€™s clearly not. But for certain high-performance latency-sensitive use cases like trying to deliver feature flags globally to mobile apps, or web apps around the world (that is our use case)â€¦ itâ€™s definitely very applicable to this problem.</p>
<p><strong>Jon Calhoun:</strong> <em>I feel the current setup with Docker containers (or whatever else) are a little bit slower, but they work for probably 90% of use cases; maybe not â€“ Iâ€™m just throwing that as a random number out, but they work for some big chunk of use cases. And the WebAssembly version that youâ€™re saying would replace it - essentially, the speed benefits and all those things, thereâ€™s going to be a huge chunk of people who wouldnâ€™t actually care as much about that, necessarily. So Iâ€™m assuming for that to happen, it would have to become just as easy to use the Wasm replacement for Docker. At least in my mind, thatâ€™s the only way I would see that working, is if it became just as easy. And I donâ€™t know, do you think itâ€™s just as easy now?</em></p>
<p>Oh, itâ€™s definitely not just as easy yet. I think thereâ€™s definitely a lot of developer tooling work to go to make it easy. Weâ€™ve been using Cloudflare Workers, and thereâ€™s lots of other people that (for edge runtimes) make it super-easy to deploy at runtimes; they make that pretty easy.</p>
<p>But I think the real benefits come from the security benefits.</p>
<p>So a WebAssembly module is way tighter in controlling what it has access to through the WASI interface than a VM is, right? And so for very security-conscious companies, I could see it having a lot of value there for certain mission-critical modules of their application.</p>
<p>And then thereâ€™s a lot of cost benefits.</p>
<p>One of the reasons why itâ€™s a lot cheaper to run your edge workloads in Cloudflare Workers (or Fastly, or Netlify, any of those edge runtimes) versus something like AWS Lambda, is because the boot-up and shutdown times and the sizes of the binaries that they have to manage are way smaller.</p>
<p>Those edge runtimes can start up your code and in milliseconds, if not faster, where Lambdas and other things like that are more containerized at the edge, take a lot longer to spin up, they have a lot higher memory footprints, things thatâ€¦ And so the cost differences there can be huge.</p>
<p>We saw huge cost savings ourselves by moving to these edge runtimes to run these workloads at scale. Not only do we build SDKs, but we run really high-scale sort of APIs at the edge.</p>
<p>Thereâ€™s huge cost advantages to having really small, portable, fast runtimes that I can execute all around the world.</p>

    </div></div>
  </body>
</html>
