<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://community.arm.com/arm-community-blogs/b/graphics-gaming-and-vr-blog/posts/introducing-arm-accuracy-super-resolution">Original</a>
    <h1>Arm Accuracy Super Resolution</h1>
    
    <div id="readability-page-1" class="page"><div id="fragment-22728" data-reflow="_p_content,_p_singlecolumn,1,1,13">
<div>





<div>
			<div><p>Today we are introducing “Arm Accuracy Super Resolution” (Arm ASR), which is a best-in-class open-source solution for upscaling on mobile devices. This article describes our approach and encourages you to join us on this journey.</p>
<p>Great games take the player on an emotional journey. There are many tools in the game developer kit that can be used to this end: evocative music, imaginative controls schemes, and graphical effects to name but a few. Focusing on graphics, it is breathtaking just how sophisticated they can be in mobile games. Games are rendered to screens that contain millions of pixels and refreshed at rates of 60Hz and higher. It is staggering.</p>
<p>Ambition is endless and modern mobile games push the envelope with complex lighting and shaders to deliver on the developer’s vision. It all comes at a cost, taxing GPUs and drawing larger amounts of power. Even on high-end PCs we recognize that something must give. That is where upscaling techniques come in.</p>
<h2 id="mcetoc_1i21mguf71">Arm ASR: Arm Accuracy Super Resolution</h2>
<p>Upscaling works by rendering some stages of the frame at lower resolution and then later applying the technique to scale from lower to higher resolution. It should not be used at every step in rendering a frame, as it can lead to unsightly defects when rendering full screen effects or user interfaces. However, earlier in the pipeline it can be used to great effect and provide anti-aliasing as a part of the process.</p>
<p><img alt="Integration of upscaling into the frame" src="https://community.arm.com/resized-image/__size/1000x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/Screenshot-2024_2D00_07_2D00_05-at-16.57.52.png"/></p>
<p><span>Integration of upscaling into the frame</span></p>
<h3 id="mcetoc_1i21mmv132"><span>Examples of post-processing techniques</span></h3>
<table>
<tbody>
<tr>
<td><span><strong><span>Lighting Based Post-processing</span></strong></span></td>
<td><span><strong><span>Image Based Post-processing</span></strong></span></td>
</tr>
<tr>
<td><span>Screenspace Reflections</span></td>
<td><span>Film grain</span></td>
</tr>
<tr>
<td><span>Screenspace ambient occlusion</span></td>
<td><span>Chromatic aberration</span></td>
</tr>
<tr>
<td><span>Denoisers (shadows, reflections)</span></td>
<td>Vignette</td>
</tr>
<tr>
<td><span>Exposure</span></td>
<td>Tonemapping</td>
</tr>
</tbody>
</table>
<p><span>Of the many solutions available, our attention was drawn to AMD’s FidelityFX  Super Resolution 2 (FSR2). It is an element of GPUOpen, an open-source project that began in 2016. Working with the permissive MIT license, the intention is to provide portable solutions that ease the burden of addressing the disparities that exist between PC and consoles. These values captured our attention and provoked us to ask ourselves what a good solution for mobile should look like.</span></p>
<h2 id="mcetoc_1i21mo0j23">The types of upscalers</h2>
<p>Upscalers come in two varieties: spatial and temporal. The former was the first to arrive and become available to developers.</p>
<p>Spatial upscalers work frame-by-frame to generate results, which make them simpler to understand as well as having lower requirements from the game engine that hosts them. Examples of spatial upscalers include FSR1 and Qualcomm’s Game Super Resolution (GSR). The drawback of this technique is that developers cannot be too ambitious in choosing the resolution to render at because this will lead to blurred final images. Conversely they are relatively cheap from a computational standpoint.</p>
<p>Temporal upscalers are more complex, as they combine information that is derived from multiple frames to generate the end result. However, they will, in general, produce higher quality images from lower resolution targets. This comes with additional input requirements from the engine. For example, depth and motion vector information must be provided. A reactive mask is desirable to deal with features that lack depth or motion information, such as particle effects.</p>
<h2 id="mcetoc_1i21mqpb84">Moving to temporal upscalers</h2>
<p>We decided to move directly to temporal upscaling to address common graphical performance challenges, while offering benefits to mobile game developers. Our starting point was AMD’s FSR2 upscaler, which produces fine results but with an implementation that is only affordable on PC and high-end consoles. We derived our solution from FSR2, which means that developers will benefit from the familiar API and configuration options.</p>
<p>As part of our investigation, we took the well-known bistro scene. We added more local, overlapping lights and attenuation of the main light to create a realistic computing challenge, which was rendering approximately 2.8 million triangles.</p>
<p><img alt="Bistro scene courtesy of NVIDIA and released under Creative Commons CC-BY-4.0 license." src="https://community.arm.com/resized-image/__size/1400x700/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/night_5F00_quarter_5F00_arm_5F00_asr_5F00_x2.png"/></p>
<p><span>Bistro scene courtesy of NVIDIA and released under Creative Commons CC-BY-4.0 license.</span></p>
<p>We analyzed results collected from a commercial mobile device that features an Arm Immortalis-G720 GPU and a display resolution of 2800x1260. We were able to demonstrate significant GPU performance improvements.</p>
<p><img alt="Framerate Analysis of Native Resolution and Upscaled Performance using Arm ASR, FSR2, FSR1, and GSR." src="https://community.arm.com/resized-image/__size/1632x962/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/image-_2800_7_2900_.png"/></p>
<p><span>Framerate Analysis of Native Resolution and Upscaled Performance using Arm ASR, FSR2, FSR1, and GSR.</span></p>
<p>Equally importantly, using this technique rendered high-quality results at a stable, low temperature. Rendering at a native resolution inevitably led to undesirable thermal throttling, which in games can ruin the user experience and shorten engagement.</p>
<h2 id="mcetoc_1i21mttvt5">Arm ASR performance</h2>
<p>The excellent performance of Arm ASR is a combination of highly efficient shader code which reduced both GPU load and bandwidth requirements.</p>
<p><img alt="GPU Performance Analysis of FSR2 and Arm ASR" src="https://community.arm.com/resized-image/__size/2044x882/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/ArmASR_2D00_GPU_5F00_ACTIVE.png" width="1022"/></p>
<p><span>GPU Performance Analysis of FSR2 and Arm ASR</span></p>
<p>These performance improvements translate into power savings, meaning that users can enjoy longer battery life which is a huge benefit in everyday life. As part of our collaboration with MediaTek, it validated this assertion and provided us with the following results using a Dimensity 9300 handset.</p>
<p><img alt="Power Consumption for native full resolution (1080p), Arm ASR quality, balanced and performance upscaling from 540p to 1080p, plus native half resolution (540p)" src="https://community.arm.com/resized-image/__size/1578x1102/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/asr_5F00_power.png" width="789"/></p>
<p>Power Consumption for native full resolution (1080p), Arm ASR quality, balanced and performance upscaling from 540p to 1080p, plus native half resolution (540p).</p>
<p>The Arm game content team have been hard at work producing an Unreal Engine demo that is intended to challenge future mobile GPUs. We could not resist the opportunity to apply Arm ASR to this content.</p>
<p><img alt="“Mori” demo, courtesy of the Arm Content Team" src="https://community.arm.com/resized-image/__size/1756x988/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/0064_5F00_ArmASR_5F00_x2_5F00_Q.png" width="878"/></p>
<p><span>“Mori” demo, courtesy of the Arm Content Team</span></p>
<p>As you can see, there are various fine details in this scene. Which is why we support Robust Contrast-Adaptive Sharpening (RCAS) in Arm ASR, just like AMD’s FSR1 and 2. The results speak for themselves:</p>
<p><img alt="Enlarged sections of the “Mori” scene" src="https://community.arm.com/resized-image/__size/2530x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/image-_2800_8_2900_.png"/></p>
<p><span>Enlarged sections of the “Mori” scene.</span></p>
<h2 id="mcetoc_1i21n1a5p6">Sharing the results in open-source</h2>
<p>We are very proud of the results of this work and want to share it with the developer community under an MIT open-source license. This will allow all developers to see the benefits of Arm ASR first-hand and experiment with their own projects. If you would like to become an early adopter, please contact us.</p>
<p><a title="Contact us" href="https://forms.office.com/e/fDFEpV75zX" rel="noopener noreferrer" target="_blank">Contact us</a></p></div>
				</div>
		</div>

</div></div>
  </body>
</html>
