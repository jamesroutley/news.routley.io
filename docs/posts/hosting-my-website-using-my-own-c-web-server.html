<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/cozis/blogtech">Original</a>
    <h1>Show HN: Hosting my website using my own C web server</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">This is a minimal web server designed to host my blog. It&#39;s built from scratch to be robust enough to face the public internet. No reverse proxies required! You can see it in action at <a href="http://playin.coz.is/index.html" rel="nofollow">http://playin.coz.is/index.html</a>.</p>
<p dir="auto">I asked <a href="https://www.reddit.com/r/C_Programming/comments/1falo3b/using_my_c_web_server_to_host_a_blog_you_cant/" rel="nofollow">Reddit</a> to <a href="https://www.reddit.com/r/hacking/comments/1fcc5hd/im_using_my_custom_c_webserver_to_host_my_blog_no/" rel="nofollow">hack</a> me, which resulted in gigabytes of hilarious and malicious request logs. I saved some in <code>attempts.txt</code>, and may dig out a few more for fun someday :^)</p>

<p dir="auto">I enjoy making my own tools and I&#39;m a bit tired of hearing that everything needs to be &#34;battle-tested.&#34; So what it will crash? Bugs can be fixed :^)</p>

<ul dir="auto">
<li>Linux only</li>
<li>Implements HTTP/1.1, pipelining, and keep-alive connections</li>
<li>HTTPS support (up to TLS 1.2 using BearSSL)</li>
<li>Minimal dependencies (libc and BearSSL when using HTTPS)</li>
<li>Configurable timeouts</li>
<li>Access logs, crash logs, log rotation, disk usage limits</li>
<li>No <code>Transfer-Encoding: Chunked</code> (responds with <code>411 Length Required</code>, prompting the client to resend with <code>Content-Length</code>)</li>
<li>Single core (This will probably change when I get a better VPS)</li>
<li>No static file caching (yet)</li>
</ul>

<p dir="auto">The focus of the project is robustness, but it&#39;s definitely not slow. Here&#39;s a quick comparison agains nginx (static endpoint, both single-threaded, 1K connection limit)</p>
<div data-snippet-clipboard-copy-content="(blogtech)
$ wrk -c 500 -d 5s http://127.0.0.1:80/hello
Running 5s test @ http://127.0.0.1:80/hello
  2 threads and 500 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     6.66ms    3.71ms  48.87ms   92.30%
    Req/Sec    39.59k     6.43k   50.60k    67.35%
  385975 requests in 5.01s, 30.55MB read
Requests/sec:  76974.24
Transfer/sec:      6.09MB

(nginx)
$ wrk -c 500 -d 5s http://127.0.0.1:8080/hello
Running 5s test @ http://127.0.0.1:8080/hello
  2 threads and 500 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   149.11ms  243.02ms 934.12ms   81.80%
    Req/Sec    24.97k    16.87k   57.73k    61.11%
  224790 requests in 5.08s, 42.01MB read
Requests/sec:  44227.78
Transfer/sec:      8.27MB"><pre><code>(blogtech)
$ wrk -c 500 -d 5s http://127.0.0.1:80/hello
Running 5s test @ http://127.0.0.1:80/hello
  2 threads and 500 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     6.66ms    3.71ms  48.87ms   92.30%
    Req/Sec    39.59k     6.43k   50.60k    67.35%
  385975 requests in 5.01s, 30.55MB read
Requests/sec:  76974.24
Transfer/sec:      6.09MB

(nginx)
$ wrk -c 500 -d 5s http://127.0.0.1:8080/hello
Running 5s test @ http://127.0.0.1:8080/hello
  2 threads and 500 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   149.11ms  243.02ms 934.12ms   81.80%
    Req/Sec    24.97k    16.87k   57.73k    61.11%
  224790 requests in 5.08s, 42.01MB read
Requests/sec:  44227.78
Transfer/sec:      8.27MB
</code></pre></div>
<p dir="auto">Nginx uses this configuration:</p>
<div data-snippet-clipboard-copy-content="worker_processes 1;

events {
	worker_connections 1024;
}

http {
	server {
		listen 8080;
		location /hello {
			add_header Content-Type text/plain;
			return 200 &#34;Hello, world!&#34;;
		}
	}
}"><pre><code>worker_processes 1;

events {
	worker_connections 1024;
}

http {
	server {
		listen 8080;
		location /hello {
			add_header Content-Type text/plain;
			return 200 &#34;Hello, world!&#34;;
		}
	}
}
</code></pre></div>

<p dir="auto">By default the server build is HTTP-only:</p>

<p dir="auto">this generates the executables: <code>serve</code> (release build), <code>serve_cov</code> (coverage build), and <code>serve_debug</code> (debug build). Release builds listen on port 80; debug builds on port 8080.</p>
<p dir="auto">To enable HTTPS, you&#39;ll need to clone BearSSL and build it. You can do so by running these commands from the root folder of this repository:</p>
<div data-snippet-clipboard-copy-content="$ mkdir 3p
$ cd 3p
$ git clone https://www.bearssl.org/git/BearSSL
$ cd BearSSL
$ make -j
$ cd ../../
$ make -B HTTPS=1"><pre><code>$ mkdir 3p
$ cd 3p
$ git clone https://www.bearssl.org/git/BearSSL
$ cd BearSSL
$ make -j
$ cd ../../
$ make -B HTTPS=1
</code></pre></div>
<p dir="auto">The same executables will be generated, but with secure connections on port 443 (release) or 8081 (debug).</p>
<p dir="auto">Place your <code>cert.pem</code> and <code>key.pem</code> files in the same directory as the executable. You can customiza names and locations by changing:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define HTTPS_KEY_FILE  &#34;key.pem&#34;
#define HTTPS_CERT_FILE &#34;cert.pem&#34;"><pre><span>#define</span> <span>HTTPS_KEY_FILE</span>  &#34;key.pem&#34;
<span>#define</span> <span>HTTPS_CERT_FILE</span> &#34;cert.pem&#34;</pre></div>
<p dir="auto">For testing locally with HTTPS, generate a self-signed certificate (and private key):</p>
<div data-snippet-clipboard-copy-content="openssl genpkey -algorithm RSA -out key.pem -pkeyopt rsa_keygen_bits:2048
openssl req -new -x509 -key key.pem -out cert.pem -days 365"><pre><code>openssl genpkey -algorithm RSA -out key.pem -pkeyopt rsa_keygen_bits:2048
openssl req -new -x509 -key key.pem -out cert.pem -days 365
</code></pre></div>

<p dir="auto">The server serves static content from the <code>docroot/</code> folder. You can change this by modifying the <code>respond</code> function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct {
	Method method;
	string path;
	int    major;
	int    minor;
	int    nheaders;
	Header headers[MAX_HEADERS];
	string content;
} Request;

void respond(Request request, ResponseBuilder *b)
{
	if (request.major != 1 || request.minor &gt; 1) {
		status_line(b, 505); // HTTP Version Not Supported
		return;
	}

	if (request.method != M_GET) {
		status_line(b, 405); // Method Not Allowed
		return;
	}

	if (string_match_case_insensitive(request.path, LIT(&#34;/hello&#34;))) {
		status_line(b, 200);
		append_content_s(b, LIT(&#34;Hello, world!&#34;));
		return;
	}

	if (serve_file_or_dir(b, LIT(&#34;/&#34;), LIT(&#34;docroot/&#34;), request.path, NULLSTR, false))
		return;

	status_line(b, 404);
	append_content_s(b, LIT(&#34;Nothing here :|&#34;));
}"><pre><span>typedef</span> <span>struct</span> {
	<span>Method</span> <span>method</span>;
	<span>string</span> <span>path</span>;
	<span>int</span>    <span>major</span>;
	<span>int</span>    <span>minor</span>;
	<span>int</span>    <span>nheaders</span>;
	<span>Header</span> <span>headers</span>[<span>MAX_HEADERS</span>];
	<span>string</span> <span>content</span>;
} <span>Request</span>;

<span>void</span> <span>respond</span>(<span>Request</span> <span>request</span>, <span>ResponseBuilder</span> <span>*</span><span>b</span>)
{
	<span>if</span> (<span>request</span>.<span>major</span> <span>!=</span> <span>1</span> <span>||</span> <span>request</span>.<span>minor</span> <span>&gt;</span> <span>1</span>) {
		<span>status_line</span>(<span>b</span>, <span>505</span>); <span>// HTTP Version Not Supported</span>
		<span>return</span>;
	}

	<span>if</span> (<span>request</span>.<span>method</span> <span>!=</span> <span>M_GET</span>) {
		<span>status_line</span>(<span>b</span>, <span>405</span>); <span>// Method Not Allowed</span>
		<span>return</span>;
	}

	<span>if</span> (<span>string_match_case_insensitive</span>(<span>request</span>.<span>path</span>, <span>LIT</span>(<span>&#34;/hello&#34;</span>))) {
		<span>status_line</span>(<span>b</span>, <span>200</span>);
		<span>append_content_s</span>(<span>b</span>, <span>LIT</span>(<span>&#34;Hello, world!&#34;</span>));
		<span>return</span>;
	}

	<span>if</span> (<span>serve_file_or_dir</span>(<span>b</span>, <span>LIT</span>(<span>&#34;/&#34;</span>), <span>LIT</span>(<span>&#34;docroot/&#34;</span>), <span>request</span>.<span>path</span>, <span>NULLSTR</span>, false))
		<span>return</span>;

	<span>status_line</span>(<span>b</span>, <span>404</span>);
	<span>append_content_s</span>(<span>b</span>, <span>LIT</span>(<span>&#34;Nothing here :|&#34;</span>));
}</pre></div>
<p dir="auto">you can add your endpoints here by switching on the <code>request.path</code> field. Note that the path is just a slice into the request buffer. URIs are not parsed.</p>

<p dir="auto">I routinely run the server under valgrind and sanitizers (address, undefined) and target it using <code>wrk</code>. I&#39;m also adding automatized tests to <code>tests/test.py</code> to check compliance with the HTTP/1.1 spec. I also use it to host my website and post it here and there to keep it under stress.Turns out, all of those bots scanning he internet for vulnerable websites make great fuzzers!</p>

<ul dir="auto">
<li>Server replies to HTTP/1.0 clients as HTTP/1.1</li>
</ul>
</article></div></div>
  </body>
</html>
