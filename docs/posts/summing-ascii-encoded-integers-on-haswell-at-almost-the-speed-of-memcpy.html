<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://blog.mattstuchlik.com/2024/07/12/summing-integers-fast.html">Original</a>
    <h1>Summing ASCII encoded integers on Haswell at almost the speed of memcpy</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    

<p>“Print the sum of 50 million ASCII-encoded integers uniformly sampled from [0, 2³¹−1], separated by a single new line and sent to standard input.”</p>

<p>On the surface, a trivial problem. But what if you wanted to go as fast as possible?</p>

<p>I’m currently one of the top ranked competitors in <a href="https://highload.fun/tasks/1">exactly that kind of challenge</a> and in this post I’ll show you a sketch of my best performing solution. I’ll leave out some of the µoptimizations and look-up table generation to keep this post short, easier to understand and to not completely obliterate the HighLoad leaderboard. Still, as far as I know nothing similar has been published yet, so I’m hoping you’ll find it interesting.</p>

<p>On the target system, my program runs about 320x faster than the following naive C++ solution (and is about 1,000,000x more fragile):</p>

<div><div><pre><code><span>uint64_t</span> <span>sum</span> <span>=</span> <span>0</span><span>;</span>
<span>while</span> <span>(</span><span>std</span><span>::</span><span>cin</span><span>)</span> <span>{</span>
    <span>uint64_t</span> <span>v</span> <span>=</span> <span>0</span><span>;</span>
    <span>std</span><span>::</span><span>cin</span> <span>&gt;&gt;</span> <span>v</span><span>;</span>
    <span>sum</span> <span>+=</span> <span>v</span><span>;</span>
<span>}</span>

<span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>sum</span> <span>&lt;&lt;</span> <span>std</span><span>::</span><span>endl</span><span>;</span>
</code></pre></div></div>

<p>I’ll write a companion post later on where I’ll describe one of the techniques used here in more detail: what I think is a fairly novel, though certainly very insane, way of initializing sparse, very-wide, zero-overhead lookup tables. The whole story of how I made it work is a little long to fit into this post.</p>

<h2 id="limitations">Limitations</h2>

<p>The program is over-fit to the input spec and the particular host it runs on (Intel Xeon E3-1271 v3 @ 3.60GHz, 512MB RAM, Ubuntu 20.04). Given the CPU, it only uses SIMD instructions up to AVX2, no AVX512. It assumes the input is exactly according to the spec and hence does zero error handling and even on such input will only produce correct results with probability &lt; 1, though very close to 1, depending on the parameters you choose.</p>

<h2 id="the-algorithm">The Algorithm</h2>

<p>Here’s the high-level overview: forget about parsing the input number-by-number and keeping a running sum! We’ll instead iterate over 32 byte chunks of the input using SIMD, from back to front, keeping track of the sum of the digits in each decimal place. In other words, if the input was “123\n45\n678”, we’ll remember that we’ve seen a total of 1 + 6 = 7 in the “hundreds”, 2 + 4 + 7 = 13 in the “tens” and 3 + 5 + 8 = 16 in the “ones” place. After we’re done processing the whole input, we get the final sum by multiplying these decimal place sums with powers of ten: 7*10² + 13*10¹ + 16*10⁰ = 846. Note that since the highest number we have to deal with is 2³¹−1, we have to track at most ⌈log₁₀(2³¹−1)⌉ = 10 decimal place sums.</p>

<p>How do we identify which byte of our input chunk is which decimal place? A look-up table. The mapping from the byte of an input chunk to its decimal place is determined by just two things: the location of newlines in the chunk and the length of the leftmost number in the previous chunk. In other words in a chunk like “???\n??\n???” that follows “???\n???\n???”, the first byte is always the 3rd decimal place, then the 2nd, etc., and the last byte is always the 4th decimal place, because it follows a number with 3 digits in the previous chunk.</p>

<p>That’s the high level, but of course the details of the implementation matter a lot too, so let’s look at the source code. This is the meat of the post, I’ve commented the code extensively to explain how it works and why it works that way. It might be hard to read on a phone, in which case I recommend bookmarking it and reading it on desktop later.</p>

<div><div><pre><code><span>// First, the variables and constants we&#39;ll need:</span>

<span>// Pointer to the beginning of our input.</span>
<span>char</span><span>*</span> <span>start</span> <span>=</span> <span>(...)</span>

<span>// Offset from `start` to the first byte of the current 32 byte chunk.</span>
<span>uint64_t</span> <span>offset</span> <span>=</span> <span>(...)</span>

<span>// SIMD vector full of ASCII &#39;\n&#39;.</span>
<span>const</span> <span>__m256i</span> <span>ascii_zero</span> <span>=</span> <span>_m256_set1_epi8</span><span>(</span><span>0x30</span><span>);</span>

<span>// The size of the leftmost number in the previous chunk (remember, we iterate</span>
<span>// input back-to-front), which partially determines the decimal places of the</span>
<span>// rightmost number in the current chunk. Since we iterate from the end of the</span>
<span>// input, we can initialize this to 0.</span>
<span>last_number_size</span> <span>=</span> <span>0</span><span>;</span>

<span>// The decimal place sums we use to reconstruct the final sum as described in</span>
<span>// the overview.</span>
<span>uint64_t</span> <span>decimal_sums</span><span>[</span><span>10</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>

<span>// For efficiency, we accumulate decimal place sums into this vector and dump</span>
<span>// them into the `decimal_sums` array every `BATCH_SIZE` iterations.</span>
<span>// The layout of this vector is below, where a number represents an exponent</span>
<span>// of the power of ten the byte represents:</span>
<span>// [5, 4, 3, 2, 1, 0, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 | 5, 4, 3, 2, 1, 0, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span>
<span>//                 ^ this byte accumulates 10^0 = &#34;ones&#34;      ^ this byte accumulates 10^2 = &#34;hundreds&#34;</span>
<span>// The somewhat unusual layout is motivated by the fact that AVX2 shuffle</span>
<span>// cannot move bytes across a lane boundary and because you expect to see</span>
<span>// more low decimal place digits.</span>
<span>__m256i</span> <span>sums_acc</span> <span>=</span> <span>_mm256_set1_epi8</span><span>(</span><span>0</span><span>)</span>

<span>// The decimal place sums accumulator can only accumulate so many chunks</span>
<span>// before overflowing. Worst case scenario is a &#39;9&#39; hitting the same</span>
<span>// accumulator slot twice per iteration of the main loop. Therefore the</span>
<span>// maximum safe accumulation batch size is 255 / (2 * 9) = 14. In practice</span>
<span>// you can increase it to almost twice that number without lowering the</span>
<span>// probability of correct output too much (at least for HighLoad).</span>
<span>const</span> <span>BATCH_SIZE</span> <span>=</span> <span>14</span><span>;</span>
<span>int</span> <span>batch</span> <span>=</span> <span>BATCH_SIZE</span><span>;</span>

<span>// The final sum!</span>
<span>uint64_t</span> <span>sum</span> <span>=</span> <span>0</span><span>;</span>

<span>// Next, we ensure our chunks are 64 byte aligned (`start` is already</span>
<span>// aligned) by processing input byte-by-byte with a simple</span>
<span>// scalar algorithm until we reach an aligned offset, keeping track</span>
<span>// of the running sum and the length of the last number encountered.</span>
<span>int</span> <span>exp</span> <span>=</span> <span>1</span><span>;</span>
<span>while</span> <span>((</span><span>offset</span> <span>&amp;</span> <span>0xFF</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
    <span>uint8_t</span> <span>byte</span> <span>=</span> <span>*</span><span>reinterpret_cast</span><span>&lt;</span><span>uint8_t</span><span>*&gt;</span><span>(</span><span>start</span> <span>+</span> <span>offset</span><span>);</span>
    <span>if</span> <span>(</span><span>byte</span> <span>==</span> <span>0x0A</span><span>)</span> <span>{</span>
        <span>exp</span> <span>=</span> <span>1</span><span>;</span>
        <span>last_number_size</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>sum</span> <span>+=</span> <span>exp</span> <span>*</span> <span>(</span><span>byte</span> <span>-</span> <span>0x30</span><span>);</span>
        <span>exp</span> <span>*=</span> <span>10</span><span>;</span>
        <span>last_number_size</span><span>++</span><span>;</span>
    <span>}</span>

    <span>offset</span> <span>-=</span> <span>1</span><span>;</span>
<span>}</span>

<span>(...)</span>

<span>// Now for the performance critical section!</span>
<span>while</span> <span>(</span><span>offset</span><span>)</span> <span>{</span>
    <span>// Prefetch input for future iterations, 11 cache lines forward.</span>
    <span>// 11 chosen empirically.</span>
    <span>_mm_prefetch</span><span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>const</span> <span>char</span><span>*&gt;</span><span>(</span><span>start</span> <span>+</span> <span>offset</span> <span>-</span> <span>11</span><span>*</span><span>64</span><span>),</span> <span>_MM_HINT_T0</span><span>);</span>

    <span>// Load a 32 byte chunk of input.</span>
    <span>__m256i</span> <span>input</span> <span>=</span> <span>_mm256_load_si256</span><span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>__m256i</span><span>*&gt;</span><span>(</span><span>start</span> <span>+</span> <span>offset</span><span>));</span>

    <span>// Subtract value of ASCII &#39;0&#39; (0x30) from each byte of the chunk.</span>
    <span>// This accomplishes two things:</span>
    <span>//  1) Bytes that represent digits will now hold the digit value instead</span>
    <span>//     of the ASCII code for the digit. i.e. &#39;0&#39; (value 0x30) will now be</span>
    <span>//     0x00, &#39;1&#39; (value 0x31) will now be 0x01, etc.</span>
    <span>//  2) Bytes that represent newlines will have their top bit set, because</span>
    <span>//     newlines are 0x0A, 0x0A - 0x30 = 0b11011010. This will become</span>
    <span>//     relevant in the next step.</span>
    <span>input</span> <span>=</span> <span>_mm256_sub_epi8</span><span>(</span><span>input</span><span>,</span> <span>ascii_zero</span><span>);</span>

    <span>// Create a bitmask of newlines in the input chunk, i.e. given a chunk</span>
    <span>// &#34;123\n456\n&#34; return 0b00010001.</span>
    <span>// The bitmask is 32 bits, since the input is 32 bytes and we&#39;ll store</span>
    <span>// it in a 64 bit variable with the top half zeroed since we&#39;ll need</span>
    <span>// it in a 64 bit context later on when calculating our look-up table</span>
    <span>// location (this generates better assembly).</span>
    <span>// This is where 2) from the comment above comes into play. You might</span>
    <span>// be tempted to say we need `cmpeq(input, 0x0A)` before this `movemask`,</span>
    <span>// but `movemask` only looks at the top bit of each byte to</span>
    <span>// decide the value of the bit in the bitmask, so the fact that the `sub`</span>
    <span>// sets the top bit for each newline, but not for digits, is sufficient.</span>
    <span>uint64_t</span> <span>mask</span> <span>=</span> <span>(</span><span>uint32_t</span><span>)</span><span>_mm256_movemask_epi8</span><span>(</span><span>input</span><span>);</span>

    <span>// The location of the mappings from input bytes to decimal places is</span>
    <span>// determined by the mask and the leftmost number in the previous chunk.</span>
    <span>// There are two mappings for each (mask, last_number_size) pair, 32 bytes</span>
    <span>// each, for one cache line in total and there are 11 of them per newline</span>
    <span>// mask, because last_number_size can be 0 to 10.</span>
    <span>// Here you might be tempted to say we should modify our look-up table</span>
    <span>// structure to let us compute the location as</span>
    <span>// !16! * 64 * mask + 64 * last_number_size.</span>
    <span>// Since we&#39;d only multiply by powers of two, this does result in nicer</span>
    <span>// assembly: `imul` (latency 3), `shl` (latency 1) turns into `shl`, `shl`,</span>
    <span>// but it&#39;s ultimately much slower due to cache associativity</span>
    <span>// issues (nice overview of the problem is for example here:</span>
    <span>// https://en.algorithmica.org/hpc/cpu-cache/associativity/)</span>
    <span>uint64_t</span> <span>lut_idx</span> <span>=</span> <span>11</span> <span>*</span> <span>64</span> <span>*</span> <span>mask</span> <span>+</span> <span>64</span> <span>*</span> <span>last_number_size</span>

    <span>// Now we dereference the location to get the two mappings.</span>
    <span>// This is a point where you should be a little confused:</span>
    <span>// 1) We&#39;re dereferencing the index by itself, not as an offset into an</span>
    <span>//    array base.</span>
    <span>// 2) The total range of the lut_index variable is very roughly 0 to 2^42,</span>
    <span>//   42 bits address space or some 4TB. That&#39;s more than the 500MB RAM we</span>
    <span>//   have available and more than you could create with a normal array</span>
    <span>//   literal.</span>
    <span>// On the positive side the lookup table is very sparse: thanks to the</span>
    <span>// specific input distribution, we only have O(1,000s) chunks of mappings</span>
    <span>// spread over the whole 42 bit address space.</span>
    <span>// This is the part that I&#39;ll explain in more detail in a follow up post,</span>
    <span>// but for now you can imagine as if we `mmap` and `memcpy` all the mappings</span>
    <span>// to the right addresses at the start of the program. Let me know if you</span>
    <span>// think you know how to do it ~zero-cost! :)</span>
    <span>// Before I came up with this approach I used a derived index based on the</span>
    <span>// size of the numbers in the chunk using chained `tzcnt`. This shrinks the</span>
    <span>// index space to (barely) fit in a normal look up table, but the index</span>
    <span>// computation was one long dependency chain with high latency instructions</span>
    <span>// and ended up being almost 50% of the runtime.</span>
    <span>__m256i</span> <span>shuffle_ctrl1</span> <span>=</span> <span>_mm256_loadu_si256</span><span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>__m256i</span><span>*&gt;</span><span>(</span><span>lut_idx</span><span>));</span>
    <span>__m256i</span> <span>shuffle_ctrl2</span> <span>=</span> <span>_mm256_loadu_si256</span><span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>__m256i</span><span>*&gt;</span><span>(</span><span>lut_idx</span> <span>+</span> <span>32</span><span>));</span>

    <span>// When I talked about a mapping from input bytes to decimal places, it&#39;s</span>
    <span>// really a shuffle control mask that moves input bytes into the same</span>
    <span>// layout that the `sums_acc` vector has.</span>
    <span>// This is another one of those places where the specific input distribution</span>
    <span>// really matters:</span>
    <span>// There are 4 spots for &#34;ones&#34; in `sums_acc`. If our input chunk consisted</span>
    <span>// of only 1 digit numbers, &#34;1\n2\n\3...&#34;, we&#39;d need to perform the following</span>
    <span>// `shuffle`, `add` procedure up to 32 / 2 / 4 = 4 times.</span>
    <span>// Fortunately for us, this turns out to be very unlikely and we are almost</span>
    <span>// guaranteed to be able to completely accumulate the chunk within</span>
    <span>// 2 `shuffles`, so that is what we do in exchange for occasionally</span>
    <span>// producing incorrect results.</span>
    <span>// One of my solutions had a neat compression scheme here:</span>
    <span>// AVX2 `shuffle` only shuffles within each 16 byte lane of the full 32 byte</span>
    <span>// register. It therefore only uses the lower 4 bits of the shuffle control</span>
    <span>// mask so you can trivially pack two of them into one 32 byte vector.</span>
    <span>// Sort of -- it also uses the top bit to let you zero out a byte, which</span>
    <span>// we use a fair bit, (as you can imagine, by the second shuffle we&#39;ve</span>
    <span>// accumulated most of the bytes of the input). Fortunately,</span>
    <span>// we are guaranteed to have at least one newline in each lane and since</span>
    <span>// we do not care about its value, we can zero it out at the start of each</span>
    <span>// iteration and point bytes that should to be zero to it, rather than</span>
    <span>// zeroing them out using the top bit.</span>
    <span>// I was very excited when I came up with this, but it turned out not</span>
    <span>// to do much performance-wise :) (Haswell can handle two loads per</span>
    <span>// cycle and the shuffle control maps are on a single cache line.)</span>
    <span>__m256i</span> <span>shuffled_input1</span> <span>=</span> <span>_mm256_shuffle_epi8</span><span>(</span><span>input</span><span>,</span> <span>shuffle_ctrl1</span><span>);</span>
    <span>__m256i</span> <span>shuffled_input2</span> <span>=</span> <span>_mm256_shuffle_epi8</span><span>(</span><span>input</span><span>,</span> <span>shuffle_ctrl2</span><span>);</span>

    <span>// Shuffled inputs 1 &amp; 2 are now in the correct layout for us to add them</span>
    <span>// directly to the decimal place sums accumulator.</span>
    <span>sums_acc</span> <span>=</span> <span>_m256_add_epi8</span><span>(</span><span>sums_acc</span><span>,</span> <span>shuffled_input1</span><span>);</span>
    <span>sums_acc</span> <span>=</span> <span>_m256_add_epi8</span><span>(</span><span>sums_acc</span><span>,</span> <span>shuffled_input2</span><span>);</span>

    <span>// This stores the size of the leftmost number for the next iteration.</span>
    <span>// Note that on Haswell this will generate `xor B, B` in addition to</span>
    <span>// `tzcnt A, B`. This is meant as a fix for a false dependency bug on</span>
    <span>// bunch of BMI instructions on this µarch.</span>
    <span>// In our case the fix is counterproductive because we&#39;re not bottlenecked</span>
    <span>// on the latency of this instruction. I don&#39;t know of any way to bypass</span>
    <span>// that `xor` other than using __asm__ directly.</span>
    <span>// (More on the bug:</span>
    <span>// https://stackoverflow.com/questions/25078285/replacing-a-32-bit-loop-counter-with-64-bit-introduces-crazy-performance-deviati)</span>
    <span>last_number_size</span> <span>=</span> <span>_tzcnt_u32</span><span>(</span><span>mask</span><span>);</span>

    <span>// Once we accumulate `BATCH_SIZE` chunks in `sums_acc`, dump them into</span>
    <span>// the sums array.</span>
    <span>batch</span><span>--</span><span>;</span>
    <span>if</span> <span>(</span><span>!</span><span>batch</span><span>)</span> <span>{</span>
        <span>batch</span> <span>=</span> <span>BATCH_SIZE</span><span>;</span>
        <span>// Extract all accumulated &#34;ones&#34;...</span>
        <span>decimal_sums</span><span>[</span><span>0</span><span>]</span> <span>+=</span> <span>_m256_extract_epi8</span><span>(</span><span>sums_acc</span><span>,</span> <span>5</span><span>);</span>
        <span>decimal_sums</span><span>[</span><span>0</span><span>]</span> <span>+=</span> <span>_m256_extract_epi8</span><span>(</span><span>sums_acc</span><span>,</span> <span>15</span><span>);</span>
        <span>decimal_sums</span><span>[</span><span>0</span><span>]</span> <span>+=</span> <span>_m256_extract_epi8</span><span>(</span><span>sums_acc</span><span>,</span> <span>21</span><span>);</span>
        <span>decimal_sums</span><span>[</span><span>0</span><span>]</span> <span>+=</span> <span>_m256_extract_epi8</span><span>(</span><span>sums_acc</span><span>,</span> <span>31</span><span>);</span>
        <span>(...)</span>
        <span>// ...and up to 10^9&#39;s.</span>
        <span>decimal_sums</span><span>[</span><span>9</span><span>]</span> <span>+=</span> <span>_m256_extract_epi8</span><span>(</span><span>sums_acc</span><span>,</span> <span>6</span><span>);</span>
        <span>decimal_sums</span><span>[</span><span>9</span><span>]</span> <span>+=</span> <span>_m256_extract_epi8</span><span>(</span><span>sums_acc</span><span>,</span> <span>22</span><span>);</span>
    <span>}</span>

    <span>// Move the offset to the next batch.</span>
    <span>offset</span> <span>-=</span> <span>32</span><span>;</span>
<span>}</span>

<span>(...)</span>

<span>// All that&#39;s left to do is to multiply our accumulated decimal place sums by</span>
<span>// the right power of ten and sum to get the final sum.</span>
<span>exp</span> <span>=</span> <span>1</span><span>;</span>
<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>10</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>sum</span> <span>+=</span> <span>decimal_sums</span><span>[</span><span>i</span><span>]</span> <span>*</span> <span>exp</span><span>;</span>
    <span>exp</span> <span>*=</span> <span>10</span><span>;</span>
<span>}</span>

<span>// And there it is!</span>
<span>print</span><span>(</span><span>sum</span><span>)</span>
</code></pre></div></div>


<p>Let me know if you have any feedback and thank you to the HighLoad community on Telegram, especially gracefu and Jack Frigaard.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
