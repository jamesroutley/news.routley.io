<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://peps.python.org/pep-0709/">Original</a>
    <h1>PEP 709 – Inlined Comprehensions</h1>
    
    <div id="readability-page-1" class="page"><section id="pep-content">

<dl>
<dt>Author<span>:</span></dt>
<dd>Carl Meyer &lt;carl at oddbird.net&gt;</dd>
<dt>Sponsor<span>:</span></dt>
<dd>Guido van Rossum &lt;guido at python.org&gt;</dd>
<dt>Discussions-To<span>:</span></dt>
<dd><a href="https://discuss.python.org/t/pep-709-inlined-comprehensions/24240">Discourse thread</a></dd>
<dt>Status<span>:</span></dt>
<dd><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt>Type<span>:</span></dt>
<dd><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt>Created<span>:</span></dt>
<dd>24-Feb-2023</dd>
<dt>Python-Version<span>:</span></dt>
<dd>3.12</dd>
<dt>Post-History<span>:</span></dt>
<dd><a href="https://discuss.python.org/t/pep-709-inlined-comprehensions/24240" title="Discourse thread">25-Feb-2023</a></dd>
</dl>
<hr/>
<section id="contents">
<details><summary>Table of Contents</summary><ul>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#rationale">Rationale</a></li>
<li><a href="#specification">Specification</a></li>
<li><a href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a href="#locals-includes-outer-variables">locals() includes outer variables</a></li>
<li><a href="#no-comprehension-frame-in-tracebacks">No comprehension frame in tracebacks</a></li>
</ul>
</li>
<li><a href="#impact-on-other-python-implementations">Impact on other Python implementations</a></li>
<li><a href="#how-to-teach-this">How to Teach This</a></li>
<li><a href="#security-implications">Security Implications</a></li>
<li><a href="#reference-implementation">Reference Implementation</a></li>
<li><a href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a href="#more-efficient-comprehension-calling-without-inlining">More efficient comprehension calling, without inlining</a></li>
<li><a href="#inlining-module-level-comprehensions">Inlining module-level comprehensions</a></li>
</ul>
</li>
<li><a href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>Comprehensions are currently compiled as nested functions, which provides
isolation of the comprehension’s iteration variable, but is inefficient at
runtime. This PEP proposes to inline list, dictionary, and set comprehensions
into the function where they are defined, and provide the expected isolation by
pushing/popping clashing locals on the stack. This change makes comprehensions
much faster: up to 2x faster for a microbenchmark of a comprehension alone,
translating to an 11% speedup for one sample benchmark derived from real-world
code that makes heavy use of comprehensions in the context of doing actual
work.</p>
</section>
<section id="motivation">
<h2><a href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>Comprehensions are a popular and widely-used feature of the Python language.
The nested-function compilation of comprehensions optimizes for compiler
simplicity at the expense of performance of user code. It is possible to
provide near-identical semantics (see <a href="#backwards-compatibility">Backwards Compatibility</a>) with much
better runtime performance for all users of comprehensions, with only a small
increase in compiler complexity.</p>
</section>
<section id="rationale">
<h2><a href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>Inlining is a common compiler optimization in many languages.  Generalized
inlining of function calls at compile time in Python is near-impossible, since
call targets may be patched at runtime. Comprehensions are a special case,
where we have a call target known statically in the compiler that can neither
be patched (barring undocumented and unsupported fiddling with bytecode
directly) nor escape.</p>
<p>Inlining also permits other compiler optimizations of bytecode to be more
effective, because they can now “see through” the comprehension bytecode,
instead of it being an opaque call.</p>
<p>Normally a performance improvement would not require a PEP. In this case, the
simplest and most efficient implementation results in some user-visible effects,
so this is not just a performance improvement, it is a (small) change to the
language.</p>
</section>
<section id="specification">
<h2><a href="#specification" role="doc-backlink">Specification</a></h2>
<p>Given a simple comprehension:</p>
<div><div><pre><span></span><span>def</span> <span>f</span><span>(</span><span>lst</span><span>):</span>
    <span>return</span> <span>[</span><span>x</span> <span>for</span> <span>x</span> <span>in</span> <span>lst</span><span>]</span>
</pre></div>
</div>
<p>The compiler currently emits the following bytecode for the function <code><span>f</span></code>:</p>
<div><div><pre><span></span>1           0 RESUME                   0

2           2 LOAD_CONST               1 (&lt;code object &lt;listcomp&gt; at 0x...)
            4 MAKE_FUNCTION            0
            6 LOAD_FAST                0 (lst)
            8 GET_ITER
           10 CALL                     0
           20 RETURN_VALUE

Disassembly of &lt;code object &lt;listcomp&gt; at 0x...&gt;:
2           0 RESUME                   0
            2 BUILD_LIST               0
            4 LOAD_FAST                0 (.0)
      &gt;&gt;    6 FOR_ITER                 4 (to 18)
           10 STORE_FAST               1 (x)
           12 LOAD_FAST                1 (x)
           14 LIST_APPEND              2
           16 JUMP_BACKWARD            6 (to 6)
      &gt;&gt;   18 END_FOR
           20 RETURN_VALUE
</pre></div>
</div>
<p>The bytecode for the comprehension is in a separate code object. Each time
<code><span>f()</span></code> is called, a new single-use function object is allocated (by
<code><span>MAKE_FUNCTION</span></code>), called (allocating and then destroying a new frame on the
Python stack), and then immediately thrown away.</p>
<p>Under this PEP, the compiler will emit the following bytecode for <code><span>f()</span></code>
instead:</p>
<div><div><pre><span></span>1           0 RESUME                   0

2           2 LOAD_FAST                0 (lst)
            4 GET_ITER
            6 LOAD_FAST_AND_CLEAR      1 (x)
            8 SWAP                     2
           10 BUILD_LIST               0
           12 SWAP                     2
      &gt;&gt;   14 FOR_ITER                 4 (to 26)
           18 STORE_FAST               1 (x)
           20 LOAD_FAST                1 (x)
           22 LIST_APPEND              2
           24 JUMP_BACKWARD            6 (to 14)
      &gt;&gt;   26 END_FOR
           28 SWAP                     2
           30 STORE_FAST               1 (x)
           32 RETURN_VALUE
</pre></div>
</div>
<p>There is no longer a separate code object, nor creation of a single-use function
object, nor any need to create and destroy a Python frame.</p>
<p>Isolation of the <code><span>x</span></code> iteration variable is achieved by the combination of the
new <code><span>LOAD_FAST_AND_CLEAR</span></code> opcode at offset <code><span>6</span></code>, which saves any outer value
of <code><span>x</span></code> on the stack before running the comprehension, and <code><span>30</span> <span>STORE_FAST</span></code>,
which restores the outer value of <code><span>x</span></code> (if any) after running the
comprehension.</p>
<p>If the comprehension accesses variables from the outer scope, inlining avoids
the need to place these variables in a cell, allowing the comprehension (and all
other code in the outer function) to access them as normal fast locals instead.
This provides further performance gains.</p>
<p>Only comprehensions occurring inside functions, where fast-locals
(<code><span>LOAD_FAST/STORE_FAST</span></code>) are used, will be inlined. Module-level
comprehensions will continue to create and call a function.</p>
<p>Generator expressions are currently never inlined in the reference
implementation of this PEP. In the future, some generator expressions may be
inlined, where the returned generator object does not leak.</p>
<p>In more complex cases, the comprehension iteration variable may be a global or
cellvar or freevar in the outer function scope. In these cases, the compiler
also internally pushes and pops the scope information for the variable when
entering/leaving the comprehension, so that semantics are maintained. For
example, if the variable is a global outside the comprehension, <code><span>LOAD_GLOBAL</span></code>
will still be used where it is referenced. If it is a cellvar/freevar outside
the comprehension, the <code><span>LOAD_FAST_AND_CLEAR</span></code> / <code><span>STORE_FAST</span></code> used to
save/restore it do not change (there is no <code><span>LOAD_DEREF_AND_CLEAR</span></code>), meaning
that the entire cell (not just the value within it) is saved/restored, so the
comprehension does not write to the cell.</p>
<p>In effect, comprehensions introduce a sub-function scope where local variables
are fully isolated, but without the performance cost or stack frame entry of a
call.</p>
</section>
<section id="backwards-compatibility">
<h2><a href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>Comprehension inlining will cause the following visible behavior changes. No
changes in the standard library or test suite were necessary to adapt to these
changes in the implementation, suggesting the impact in user code is likely to
be minimal.</p>
<p>Specialized tools depending on undocumented details of compiler bytecode output
may of course be affected in ways beyond the below, but these tools already must
adapt to bytecode changes in each Python version.</p>
<section id="locals-includes-outer-variables">
<h3><a href="#locals-includes-outer-variables" role="doc-backlink">locals() includes outer variables</a></h3>
<p>Calling <code><span>locals()</span></code> within a comprehension will include all locals of the
function containing the comprehension. E.g. given the following function:</p>
<div><div><pre><span></span><span>def</span> <span>f</span><span>(</span><span>lst</span><span>):</span>
    <span>return</span> <span>[</span><span>locals</span><span>()</span> <span>for</span> <span>x</span> <span>in</span> <span>lst</span><span>]</span>
</pre></div>
</div>
<p>Calling <code><span>f([1])</span></code> in current Python will return:</p>
<div><div><pre><span></span><span>[{</span><span>&#39;.0&#39;</span><span>:</span> <span>&lt;</span><span>list_iterator</span> <span>object</span> <span>at</span> <span>0x7f8d37170460</span><span>&gt;</span><span>,</span> <span>&#39;x&#39;</span><span>:</span> <span>1</span><span>}]</span>
</pre></div>
</div>
<p>where <code><span>.0</span></code> is an internal implementation detail: the synthetic sole argument
to the comprehension “function”.</p>
<p>Under this PEP, it will instead return:</p>

<p>This now includes the outer <code><span>lst</span></code> variable as a local, and eliminates the
synthetic <code><span>.0</span></code>.</p>
</section>
<section id="no-comprehension-frame-in-tracebacks">
<h3><a href="#no-comprehension-frame-in-tracebacks" role="doc-backlink">No comprehension frame in tracebacks</a></h3>
<p>Under this PEP, a comprehension will no longer have its own dedicated frame in
a stack trace. For example, given this function:</p>
<div><div><pre><span></span><span>def</span> <span>g</span><span>():</span>
    <span>raise</span> <span>RuntimeError</span><span>(</span><span>&#34;boom&#34;</span><span>)</span>

<span>def</span> <span>f</span><span>():</span>
    <span>return</span> <span>[</span><span>g</span><span>()</span> <span>for</span> <span>x</span> <span>in</span> <span>[</span><span>1</span><span>]]</span>
</pre></div>
</div>
<p>Currently, calling <code><span>f()</span></code> results in the following traceback:</p>
<div><div><pre><span></span>Traceback (most recent call last):
  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
  File &#34;&lt;stdin&gt;&#34;, line 5, in f
  File &#34;&lt;stdin&gt;&#34;, line 5, in &lt;listcomp&gt;
  File &#34;&lt;stdin&gt;&#34;, line 2, in g
RuntimeError: boom
</pre></div>
</div>
<p>Note the dedicated frame for <code><span>&lt;listcomp&gt;</span></code>.</p>
<p>Under this PEP, the traceback looks like this instead:</p>
<div><div><pre><span></span>Traceback (most recent call last):
  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
  File &#34;&lt;stdin&gt;&#34;, line 5, in f
  File &#34;&lt;stdin&gt;&#34;, line 2, in g
RuntimeError: boom
</pre></div>
</div>
<p>There is no longer an extra frame for the list comprehension. The frame for the
<code><span>f</span></code> function has the correct line number for the comprehension, however, so
this simply makes the traceback more compact without losing any useful
information.</p>
<p>It is theoretically possible that code using warnings with the <code><span>stacklevel</span></code>
argument could observe a behavior change due to the frame stack change. In
practice, however, this seems unlikely. It would require a warning raised in
library code that is always called through a comprehension in that same
library, where the warning is using a <code><span>stacklevel</span></code> of 3+ to bypass the
comprehension and its containing function and point to a calling frame outside
the library. In such a scenario it would usually be simpler and more reliable
to raise the warning closer to the calling code and bypass fewer frames.</p>
</section>
</section>
<section id="impact-on-other-python-implementations">
<h2><a href="#impact-on-other-python-implementations" role="doc-backlink">Impact on other Python implementations</a></h2>
<p>Per comments from representatives of <a href="https://discuss.python.org/t/pep-709-inlined-comprehensions/24240/20">GraalPython</a> and
<a href="https://discuss.python.org/t/pep-709-inlined-comprehensions/24240/22">PyPy</a>,
they would likely feel the need to adapt to the observable behavior changes
here, given the likelihood that someone, at some point, will depend on them.
Thus, all else equal, fewer observable changes would be less work. But these
changes (at least in the case of GraalPython) should be manageable “without much
headache”.</p>
</section>
<section id="how-to-teach-this">
<h2><a href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>It is not intuitively obvious that comprehension syntax will or should result
in creation and call of a nested function. For new users not already accustomed
to the prior behavior, I suspect the new behavior in this PEP will be more
intuitive and require less explanation. (“Why is there a <code><span>&lt;listcomp&gt;</span></code> line in
my traceback when I didn’t define any such function? What is this <code><span>.0</span></code>
variable I see in <code><span>locals()</span></code>?”)</p>
</section>
<section id="security-implications">
<h2><a href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>None known.</p>
</section>
<section id="reference-implementation">
<h2><a href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>This PEP has a reference implementation in the form of <a href="https://github.com/python/cpython/pull/101441">a PR against the CPython main
branch</a> which passes all tests.</p>
<p>The reference implementation performs the micro-benchmark <code><span>./python</span> <span>-m</span> <span>pyperf</span>
<span>timeit</span> <span>-s</span> <span>&#39;l</span> <span>=</span> <span>[1]&#39;</span> <span>&#39;[x</span> <span>for</span> <span>x</span> <span>in</span> <span>l]&#39;</span></code> 1.96x faster than the <code><span>main</span></code> branch (in a
build compiled with <code><span>--enable-optimizations</span></code>.)</p>
<p>The reference implementation performs the <code><span>comprehensions</span></code> benchmark in the
<a href="https://github.com/python/pyperformance">pyperformance</a> benchmark suite
(which is not a micro-benchmark of comprehensions alone, but tests
real-world-derived code doing realistic work using comprehensions) 11% faster
than <code><span>main</span></code> branch (again in optimized builds). Other benchmarks in
pyperformance (none of which use comprehensions heavily) don’t show any impact
outside the noise.</p>
<p>The implementation has no impact on non-comprehension code.</p>
</section>
<section id="rejected-ideas">
<h2><a href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="more-efficient-comprehension-calling-without-inlining">
<h3><a href="#more-efficient-comprehension-calling-without-inlining" role="doc-backlink">More efficient comprehension calling, without inlining</a></h3>
<p>An <a href="https://github.com/python/cpython/pull/101310">alternate approach</a>
introduces a new opcode for “calling” a comprehension in streamlined fashion
without the need to create a throwaway function object, but still creating a new
Python frame. This avoids all of the visible effects listed under <a href="#backwards-compatibility">Backwards
Compatibility</a>, and provides roughly half of the performance benefit (1.5x
improvement on the microbenchmark, 4% improvement on <code><span>comprehensions</span></code>
benchmark in pyperformance.) It also requires adding a new pointer to the
<code><span>_PyInterpreterFrame</span></code> struct and a new <code><span>Py_INCREF</span></code> on each frame
construction, meaning (unlike this PEP) it has a (very small) performance cost
for all code. It also provides less scope for future optimizations.</p>
<p>This PEP takes the position that full inlining offers sufficient additional
performance to more than justify the behavior changes.</p>
</section>
<section id="inlining-module-level-comprehensions">
<h3><a href="#inlining-module-level-comprehensions" role="doc-backlink">Inlining module-level comprehensions</a></h3>
<p>Module-level comprehensions are generally called only once (when the module is
imported), so optimizing their performance is low priority. Inlining them would
require separate code paths in the compiler to handle a module global namespace
dictionary instead of fast-locals. It would be difficult or impossible to avoid
breaking semantics, since the comprehension iteration variable itself would be
a module global which might be referenced inside other functions that in turn
could be called within the comprehension.</p>
</section>
</section>
<section id="copyright">
<h2><a href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section></div>
  </body>
</html>
