<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bun.sh/blog/bun-macros">Original</a>
    <h1>JavaScript Macros in Bun</h1>
    
    <div id="readability-page-1" class="page"><article><p>Two weeks ago, we launched our new JavaScript <a href="https://the.scapegoat.dev/blog/bun-bundler">bundler</a> in Bun <a href="https://the.scapegoat.dev/blog/bun-v0.6.0">v0.6.0</a>. Today we&#39;re releasing a new feature that highlights the tight integration between Bun&#39;s bundler and runtime: Bun Macros.</p><p>Macros are a mechanism for running JavaScript functions <em>at bundle-time</em>. The value returned from these functions are directly inlined into your bundle.</p><p>As a toy example, consider this simple function that returns a random number.</p><div><div><div><pre><code><span><span>export</span><span> </span><span>function</span><span> </span><span>random</span><span>() {</span></span>
<span><span>  </span><span>return</span><span> </span><span>Math</span><span>.</span><span>random</span><span>();</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><p>Inside our source code, we can import this function as a macro using <a href="https://github.com/tc39/proposal-import-attributes"><em>import attribute</em></a> syntax. If you haven&#39;t seen this syntax before, it&#39;s a Stage 3 TC39 proposal that lets you attach additional metadata to <code>import</code> statements.</p><div><p>cli.tsx</p><div><div><pre><code><span><span>import</span><span> { random } </span><span>from</span><span> </span><span>&#39;</span><span>./random.ts</span><span>&#39;</span><span> with { type: &#39;macro&#39; };</span></span>
<span></span>
<span><span>console.</span><span>log</span><span>(</span><span>`Your random number is </span><span>${</span><span>random</span><span>()</span><span>}</span><span>`</span><span>);</span></span>
<span></span></code></pre></div></div></div><p>Now we&#39;ll bundle this file with <code>bun build</code>. The bundled file will be printed to stdout.</p><div><div><div><pre><code><span><span>console.log(`Your random number is ${0.6805550949689833}`);</span></span></code></pre></div></div></div><p>As you can see, the source code of the <code>random</code> function occurs nowhere in the bundle. Instead, it is executed <em>during bundling</em> and the function call (<code>random()</code>) is replaced with the result of the function. Since the source code will never be included in the bundle, macros can safely perform privileged operations like reading from a database.</p><h2 level="2" anchor-id="when-to-use-macros"><a name="when-to-use-macros"></a><a href="#when-to-use-macros">When to use macros</a></h2><p>For small things where you would otherwise have a one-off build script, bundle-time code execution can be easier to maintain. It lives with the rest of your code, it runs with the rest of the build, it is automatically paralellized, and if it fails, the build fails too.</p><p>If you find yourself running a lot of code at bundle-time though, consider running a server instead.</p><p>Let&#39;s look at some scenarios where macros might be useful.</p><h3 level="3" anchor-id="embed-latest-git-commit-hash"><a name="embed-latest-git-commit-hash"></a><a href="#embed-latest-git-commit-hash">Embed latest git commit hash</a></h3><div id="mpRZxlflrY"><div><div><p>in-the-browser.ts</p><div><div><pre><code><span><span>import</span><span> { getGitCommitHash } </span><span>from</span><span> </span><span>&#39;</span><span>./getGitCommitHash.ts</span><span>&#39;</span><span> with { type: &#39;macro&#39; };</span></span>
<span></span>
<span><span>console.</span><span>log</span><span>(</span><span>`The current Git commit hash is </span><span>${</span><span>getGitCommitHash</span><span>()</span><span>}</span><span>`</span><span>);</span></span>
<span></span></code></pre></div></div></div></div><div><div><p>getGitCommitHash.ts</p><div><div><pre><code><span><span>export</span><span> </span><span>function</span><span> </span><span>getGitCommitHash</span><span>() {</span></span>
<span><span>  </span><span>const</span><span> {stdout} </span><span>=</span><span> Bun.</span><span>spawnSync</span><span>({</span></span>
<span><span>    cmd</span><span>:</span><span> [</span><span>&#34;</span><span>git</span><span>&#34;</span><span>, </span><span>&#34;</span><span>rev-parse</span><span>&#34;</span><span>, </span><span>&#34;</span><span>HEAD</span><span>&#34;</span><span>],</span></span>
<span><span>    stdout</span><span>:</span><span> </span><span>&#34;</span><span>pipe</span><span>&#34;</span><span>,</span></span>
<span><span>  });</span></span>
<span></span>
<span><span>  </span><span>return</span><span> stdout.</span><span>toString</span><span>();</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div></div></div><p>When we build it, the <code>getGitCommitHash</code> is replaced with the result of calling the function:</p><div id="DnJRRTkfad"><div><div><p>output.js</p><div><div><pre><code><span><span>console.log(</span><span>`</span><span>The current Git commit </span><span>hash</span><span> is 3ee3259104f</span><span>`</span><span>)</span><span>;</span></span>
<span></span></code></pre></div></div></div></div><div><div><p>CLI</p><div><div><pre><code><span><span>bun build --target=browser ./in-the-browser.ts</span></span></code></pre></div></div></div></div></div><p>You&#39;re probably thinking &#34;Why not just use <code>process.env.GIT_COMMIT_HASH</code>?&#34; Well, you can do that too. But can you do this with an environment variable?</p><h3 level="3" anchor-id="make-fetch-requests-at-bundle-time"><a name="make-fetch-requests-at-bundle-time"></a><a href="#make-fetch-requests-at-bundle-time">Make <code>fetch()</code> requests at bundle-time</a></h3><p>In this example, we make an outgoing HTTP request using <code>fetch()</code>, parse the HTML response using <code>HTMLRewriter</code>, and return an object containing the title and meta tagsâ€“all at bundle-time.</p><div id="cvZKtjwBVx"><div><div><p>in-the-browser.tsx</p><div><div><pre><code><span><span>import</span><span> { extractMetaTags } </span><span>from</span><span> </span><span>&#39;</span><span>./meta.ts</span><span>&#39;</span><span> with { type: &#39;macro&#39; };</span></span>
<span></span>
<span><span>export</span><span> </span><span>const</span><span> </span><span>Head</span><span> </span><span>=</span><span> () </span><span>=&gt;</span><span> {</span></span>
<span><span>  </span><span>const</span><span> headTags </span><span>=</span><span> </span><span>extractMetaTags</span><span>(</span><span>&#34;</span><span>https://example.com</span><span>&#34;</span><span>);</span></span>
<span></span>
<span><span>  </span><span>if</span><span> (headTags.title </span><span>!==</span><span> </span><span>&#34;</span><span>Example Domain</span><span>&#34;</span><span>) {</span></span>
<span><span>    </span><span>throw</span><span> </span><span>new</span><span> </span><span>Error</span><span>(</span><span>&#34;</span><span>Expected title to be &#39;Example Domain&#39;</span><span>&#34;</span><span>);</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>return</span><span> &lt;</span><span>head</span><span>&gt;</span></span>
<span><span>    &lt;</span><span>title</span><span>&gt;{headTags.title}&lt;/</span><span>title</span><span>&gt;</span></span>
<span><span>    &lt;</span><span>meta</span><span> </span><span>name</span><span>=</span><span>&#34;</span><span>viewport</span><span>&#34;</span><span> </span><span>content</span><span>=</span><span>{headTags.viewport} /&gt;</span></span>
<span><span>  &lt;/</span><span>head</span><span>&gt;;</span></span>
<span><span>};</span></span>
<span></span></code></pre></div></div></div></div><div><div><p>meta.ts</p><div><div><pre><code><span><span>export</span><span> </span><span>async</span><span> </span><span>function</span><span> </span><span>extractMetaTags</span><span>(</span><span>url</span><span>:</span><span> </span><span>string</span><span>) {</span></span>
<span><span>  </span><span>const</span><span> response </span><span>=</span><span> </span><span>await</span><span> </span><span>fetch</span><span>(url);</span></span>
<span><span>  </span><span>const</span><span> meta </span><span>=</span><span> {</span></span>
<span><span>    title</span><span>:</span><span> </span><span>&#34;&#34;</span><span>,</span></span>
<span><span>  };</span></span>
<span><span>  </span><span>new</span><span> </span><span>HTMLRewriter</span><span>()</span></span>
<span><span>    .</span><span>on</span><span>(</span><span>&#34;</span><span>title</span><span>&#34;</span><span>, {</span></span>
<span><span>      </span><span>text</span><span>(</span><span>element</span><span>) {</span></span>
<span><span>        meta.title </span><span>+=</span><span> element.text;</span></span>
<span><span>      },</span></span>
<span><span>    })</span></span>
<span><span>    .</span><span>on</span><span>(</span><span>&#34;</span><span>meta</span><span>&#34;</span><span>, {</span></span>
<span><span>      </span><span>element</span><span>(</span><span>element</span><span>) {</span></span>
<span><span>        </span><span>const</span><span> name </span><span>=</span></span>
<span><span>          element.</span><span>getAttribute</span><span>(</span><span>&#34;</span><span>name</span><span>&#34;</span><span>) </span><span>||</span></span>
<span><span>          element.</span><span>getAttribute</span><span>(</span><span>&#34;</span><span>property</span><span>&#34;</span><span>) </span><span>||</span></span>
<span><span>          element.</span><span>getAttribute</span><span>(</span><span>&#34;</span><span>itemprop</span><span>&#34;</span><span>);</span></span>
<span></span>
<span><span>        </span><span>if</span><span> (name) meta[name] </span><span>=</span><span> element.</span><span>getAttribute</span><span>(</span><span>&#34;</span><span>content</span><span>&#34;</span><span>);</span></span>
<span><span>      },</span></span>
<span><span>    })</span></span>
<span><span>    .</span><span>transform</span><span>(response);</span></span>
<span></span>
<span><span>  </span><span>return</span><span> meta;</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div></div></div><p>The <code>extractMetaTags</code> function is erased at bundle-time and replaced with the result of the function call. This means that the <code>fetch</code> request happens at bundle-time, and the result is embedded in the bundle. Also, the branch throwing the error is eliminated since it&#39;s unreachable.</p><div id="ymYiJsxANC"><div><div><p>output.js</p><div><div><pre><code><span><span>import</span><span> { jsx, jsxs } </span><span>from</span><span> </span><span>&#34;</span><span>react/jsx-runtime</span><span>&#34;</span><span>;</span></span>
<span><span>export</span><span> </span><span>const</span><span> </span><span>Head</span><span> </span><span>=</span><span> () </span><span>=&gt;</span><span> {</span></span>
<span><span>  </span><span>jsxs</span><span>(</span><span>&#34;</span><span>head</span><span>&#34;</span><span>, {</span></span>
<span><span>    children</span><span>:</span><span> [</span></span>
<span><span>      </span><span>jsx</span><span>(</span><span>&#34;</span><span>title</span><span>&#34;</span><span>, {</span></span>
<span><span>        children</span><span>:</span><span> </span><span>&#34;</span><span>Example Domain</span><span>&#34;</span><span>,</span></span>
<span><span>      }),</span></span>
<span><span>      </span><span>jsx</span><span>(</span><span>&#34;</span><span>meta</span><span>&#34;</span><span>, {</span></span>
<span><span>        name</span><span>:</span><span> </span><span>&#34;</span><span>viewport</span><span>&#34;</span><span>,</span></span>
<span><span>        content</span><span>:</span><span> </span><span>&#34;</span><span>width=device-width, initial-scale=1</span><span>&#34;</span><span>,</span></span>
<span><span>      }),</span></span>
<span><span>    ],</span></span>
<span><span>  });</span></span>
<span><span>};</span></span>
<span></span>
<span><span>export</span><span> { Head };</span></span>
<span></span></code></pre></div></div></div></div><div><div><p>CLI</p><div><div><pre><code><span><span>bun build --target=browser --minify-syntax ./in-the-browser.ts</span></span></code></pre></div></div></div></div></div><h2 level="2" anchor-id="how-it-works"><a name="how-it-works"></a><a href="#how-it-works">How it works</a></h2><p>Bun Macros are import statements annotated the <code>{type: &#39;macro&#39;}</code> <a href="https://github.com/tc39/proposal-import-attributes">import attribute</a>.</p><div><div><div><pre><code><span><span>import</span><span> { myMacro } </span><span>from</span><span> </span><span>&#39;</span><span>./macro.ts</span><span>&#39;</span><span> with { type: &#39;macro&#39; }</span></span>
<span></span></code></pre></div></div></div><p>Import attributes are a Stage 3 ECMAScript proposal, which means it is overwhelmingly likely they will be added as an official part of the JavaScript language.</p><div><p>Bun also supports <em>import assertion</em> syntax. Import assertions were an earlier incarnation of import attributes that has now been abandoned (but is <a href="https://caniuse.com/mdn-javascript_statements_import_import_assertions">already supported</a> by a number of browsers and runtimes).</p><div><div><div><pre><code><span><span>import</span><span> { myMacro } </span><span>from</span><span> </span><span>&#34;</span><span>./macro.ts</span><span>&#34;</span><span> assert { type: &#34;macro&#34; };</span></span>
<span></span></code></pre></div></div></div></div><p>When Bun&#39;s transpiler sees one of these special imports, it calls the function inside the transpiler using Bun&#39;s JavaScript runtime and converts the return value from JavaScript into an AST node. These JavaScript functions are called at bundle-time, not runtime.</p><h3 level="3" anchor-id="execution-order"><a name="execution-order"></a><a href="#execution-order">Execution order</a></h3><p>Bun Macros are executed synchronously in the transpiler during the visiting phaseâ€”before plugins and before the transpiler generates the AST. They are executed in the order they are called. The transpiler will wait for the macro to finish executing before continuing. The transpiler will also <code>await</code> any <code>Promise</code> returned by a macro.</p><p>Bun&#39;s bundler is multi-threaded. As such, macros execute in parallel inside of multiple spawned JavaScript &#34;workers&#34;.</p><h3 level="3" anchor-id="dead-code-elimination"><a name="dead-code-elimination"></a><a href="#dead-code-elimination">Dead code elimination</a></h3><p>The bundler performs dead code elimination <em>after</em> running and inlining macros. So given the following macro:</p><div><p>returnFalse.ts</p><div><div><pre><code><span><span>export</span><span> </span><span>function</span><span> </span><span>returnFalse</span><span>() {</span></span>
<span><span>  </span><span>return</span><span> </span><span>false</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><p>...then bundling the following file will produce an empty bundle.</p><div><div><div><pre><code><span><span>import</span><span> {returnFalse} </span><span>from</span><span> </span><span>&#39;</span><span>./returnFalse.ts</span><span>&#39;</span><span> with { type: &#39;macro&#39; };</span></span>
<span></span>
<span><span>if</span><span> (</span><span>returnFalse</span><span>()) {</span></span>
<span><span>  console.</span><span>log</span><span>(</span><span>&#34;</span><span>This code is eliminated</span><span>&#34;</span><span>);</span></span>
<span><span>}</span></span>
<span></span>
<span></span></code></pre></div></div></div><h2 level="2" anchor-id="security-considerations"><a name="security-considerations"></a><a href="#security-considerations">Security considerations</a></h2><p>Macros must explicitly be imported with <code>{ type: &#34;macro&#34; }</code> in order to be executed at bundle-time. These imports have no effect if they are not called, unlike regular JavaScript imports which may have side effects.</p><p>You can disable macros entirely by passing the <code>--no-macros</code> flag to Bun. It produces a build error like this:</p><div><div><div><pre><code><span><span>error: Macros are disabled</span></span>
<span></span>
<span><span>foo</span><span>();</span></span>
<span><span>^</span></span>
<span><span>.</span><span>/</span><span>hello.js:</span><span>3</span><span>:</span><span>1</span><span> </span><span>53</span></span>
<span></span></code></pre></div></div></div><h3 level="3" anchor-id="macros-are-disabled-in-node-modules"><a name="macros-are-disabled-in-node-modules"></a><a href="#macros-are-disabled-in-node-modules"><em>Macros are disabled in node_modules</em></a></h3><p>To reduce the potential attack surface for malicious packages, macros cannot be <em>invoked</em> from inside <code>node_modules/**/*</code>. If a package attempts to invoke a macro, you&#39;ll see an error like this:</p><div><div><div><pre><code><span><span>error: For security reasons, macros cannot be run from node_modules.</span></span>
<span></span>
<span><span>beEvil</span><span>();</span></span>
<span><span>^</span></span>
<span><span>node_modules</span><span>/</span><span>evil</span><span>/</span><span>index.js:</span><span>3</span><span>:</span><span>1</span><span> </span><span>50</span></span>
<span></span></code></pre></div></div></div><p>Your application code can still import macros from <code>node_modules</code> and invoke them.</p><div><div><div><pre><code><span><span>import</span><span> {macro} </span><span>from</span><span> </span><span>&#34;</span><span>some-package</span><span>&#34;</span><span> with { type: &#34;macro&#34; };</span></span>
<span></span>
<span><span>macro</span><span>();</span></span>
<span></span></code></pre></div></div></div><h2 level="2" anchor-id="limitations"><a name="limitations"></a><a href="#limitations">Limitations</a></h2><p>Some things to know.</p><h3 level="3" anchor-id="the-result-of-the-macro-must-be-serializable"><a name="the-result-of-the-macro-must-be-serializable"></a><a href="#the-result-of-the-macro-must-be-serializable"><em>The result of the macro must be serializable!</em></a></h3><p>Bun&#39;s transpiler needs to be able to serialize the result of the macro so it can be inlined into the AST. All JSON-compatible data structures are supported:</p><div><p>macro.ts</p><div><div><pre><code><span><span>export</span><span> </span><span>function</span><span> </span><span>getObject</span><span>() {</span></span>
<span><span>  </span><span>return</span><span> {</span></span>
<span><span>    foo</span><span>:</span><span> </span><span>&#34;</span><span>bar</span><span>&#34;</span><span>,</span></span>
<span><span>    baz</span><span>:</span><span> </span><span>123</span><span>,</span></span>
<span><span>    array</span><span>:</span><span> [ </span><span>1</span><span>, </span><span>2</span><span>, { nested</span><span>:</span><span> </span><span>&#34;</span><span>value</span><span>&#34;</span><span> }],</span></span>
<span><span>  };</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><p>Macros can be async, or return <code>Promise</code> instances. Bun&#39;s transpiler will automatically <code>await</code> the <code>Promise</code> and inline the result.</p><div><p>macro.ts</p><div><div><pre><code><span><span>export</span><span> </span><span>async</span><span> </span><span>function</span><span> </span><span>getText</span><span>() {</span></span>
<span><span>  </span><span>return</span><span> </span><span>&#34;</span><span>async value</span><span>&#34;</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><p>The transpiler implements specicial logic for serializing common data formats like <code>Response</code>, <code>Blob</code>, <code>TypedArray</code>.</p><ul><li><code>TypedArray</code>: Resolves to a base64-encoded string.</li><li><code>Response</code>: Where relevant, Bun will read the <code>Content-Type</code> and serialize accordingly; for instance, a <code>Response</code> with type <code>application/json</code> will be automatically parsed into an object and <code>text/plain</code> will be inlined as a string. Responses with an unknown or undefined <code>type</code> will be base-64 encoded.</li><li><code>Blob</code>: As with <code>Response</code>, the serialization depends on the <code>type</code> property.</li></ul><p>The result of <code>fetch</code> is <code>Promise&lt;Response&gt;</code>, so it can be directly returned.</p><div><p>macro.ts</p><div><div><pre><code><span><span>export</span><span> </span><span>function</span><span> </span><span>getObject</span><span>() {</span></span>
<span><span>  </span><span>return</span><span> </span><span>fetch</span><span>(</span><span>&#34;</span><span>https://bun.sh</span><span>&#34;</span><span>)</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><p>Functions and instances of most classes (except those mentioned above) are not serializable.</p><div><div><div><pre><code><span><span>export</span><span> </span><span>function</span><span> </span><span>getText</span><span>(</span><span>url</span><span>:</span><span> </span><span>string</span><span>) {</span></span>
<span><span>  </span><span>// this doesn&#39;t work!</span></span>
<span><span>  </span><span>return</span><span> () </span><span>=&gt;</span><span> {};</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><h3 level="3" anchor-id="the-input-arguments-must-be-statically-analyzable"><a name="the-input-arguments-must-be-statically-analyzable"></a><a href="#the-input-arguments-must-be-statically-analyzable"><em>The input arguments must be statically analyzable.</em></a></h3><p>Macros can accept inputs, but only in limited cases. The value must be statically known. For example, the following is not allowed:</p><div><div><div><pre><code><span><span>import</span><span> {getText} </span><span>from</span><span> </span><span>&#39;</span><span>./getText.ts</span><span>&#39;</span><span> with { type: &#39;macro&#39; };</span></span>
<span></span>
<span><span>export</span><span> </span><span>function</span><span> </span><span>howLong</span><span>() {</span></span>
<span><span>  </span><span>// the value of `foo` cannot be statically known</span></span>
<span><span>  </span><span>const</span><span> foo </span><span>=</span><span> </span><span>Math</span><span>.</span><span>random</span><span>() </span><span>?</span><span> </span><span>&#34;</span><span>foo</span><span>&#34;</span><span> </span><span>:</span><span> </span><span>&#34;</span><span>bar</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>  </span><span>const</span><span> text </span><span>=</span><span> </span><span>getText</span><span>(</span><span>`https://example.com/</span><span>${</span><span>foo</span><span>}</span><span>`</span><span>);</span></span>
<span><span>  console.</span><span>log</span><span>(</span><span>&#34;</span><span>The page is </span><span>&#34;</span><span>, text.length, </span><span>&#34;</span><span> characters long</span><span>&#34;</span><span>);</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><p>However, if the value of <code>foo</code> is known at bundle-time (say, if it&#39;s a constant or the result of another macro) then it&#39;s allowed:</p><div><div><div><pre><code><span><span>import</span><span> {getText} </span><span>from</span><span> </span><span>&#39;</span><span>./getText.ts</span><span>&#39;</span><span> with { type: &#39;macro&#39; };</span></span>
<span><span>import</span><span> {getFoo} </span><span>from</span><span> </span><span>&#39;</span><span>./getFoo.ts</span><span>&#39;</span><span> with { type: &#39;macro&#39; };</span></span>
<span></span>
<span><span>export</span><span> </span><span>function</span><span> </span><span>howLong</span><span>() {</span></span>
<span><span>  </span><span>// this works because getFoo() is statically known</span></span>
<span><span>  </span><span>const</span><span> foo </span><span>=</span><span> </span><span>getFoo</span><span>();</span></span>
<span><span>  </span><span>const</span><span> text </span><span>=</span><span> </span><span>getText</span><span>(</span><span>`https://example.com/</span><span>${</span><span>foo</span><span>}</span><span>`</span><span>);</span></span>
<span><span>  console.</span><span>log</span><span>(</span><span>&#34;</span><span>The page is</span><span>&#34;</span><span>, text.length, </span><span>&#34;</span><span>characters long</span><span>&#34;</span><span>);</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><p>This outputs:</p><div><div><div><pre><code><span><span>function</span><span> </span><span>howLong</span><span>() {</span></span>
<span><span>  console.</span><span>log</span><span>(</span><span>&#34;</span><span>The page is</span><span>&#34;</span><span>, </span><span>1322</span><span>, </span><span>&#34;</span><span>characters long</span><span>&#34;</span><span>);</span></span>
<span><span>}</span></span>
<span><span>export</span><span> { howLong };</span></span>
<span></span></code></pre></div></div></div></article></div>
  </body>
</html>
