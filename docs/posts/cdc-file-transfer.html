<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/google/cdc-file-transfer">Original</a>
    <h1>CDC File Transfer</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Born from the ashes of Stadia, this repository contains tools for syncing and
streaming files from Windows to Windows or Linux. The tools are based on Content
Defined Chunking (CDC), in particular
<a href="https://www.usenix.org/conference/atc16/technical-sessions/presentation/xia" rel="nofollow">FastCDC</a>,
to split up files into chunks.</p>

<p dir="auto">At Stadia, game developers had access to Linux cloud instances to run games.
Most developers wrote their games on Windows, though. Therefore, they needed a
way to make them available on the remote Linux instance.</p>
<p dir="auto">As developers had SSH access to those instances, they could use <code>scp</code> to copy
the game content. However, this was impractical, especially with the shift to
working from home during the pandemic with sub-par internet connections. <code>scp</code>
always copies full files, there is no &#34;delta mode&#34; to copy only the things that
changed, it is slow for many small files, and there is no fast compression.</p>
<p dir="auto">To help this situation, we developed two tools, <code>cdc_rsync</code> and <code>cdc_stream</code>,
which enable developers to quickly iterate on their games without repeatedly
incurring the cost of transmitting dozens of GBs.</p>

<p dir="auto"><code>cdc_rsync</code> is a tool to sync files from a Windows machine to a Linux device,
similar to the standard Linux <a href="https://linux.die.net/man/1/rsync" rel="nofollow">rsync</a>. It is
basically a copy tool, but optimized for the case where there is already an old
version of the files available in the target directory.</p>
<ul dir="auto">
<li>It quickly skips files if timestamp and file size match.</li>
<li>It uses fast compression for all data transfer.</li>
<li>If a file changed, it determines which parts changed and only transfers the
differences.</li>
</ul>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://liquidbrain.net/google/cdc-file-transfer/blob/main/docs/cdc_rsync_recursive_upload_demo.gif"><img src="https://liquidbrain.net/google/cdc-file-transfer/raw/main/docs/cdc_rsync_recursive_upload_demo.gif" alt="cdc_rsync demo" width="688" data-animated-image=""/></a>
</p>
<p dir="auto">The remote diffing algorithm is based on CDC. In our tests, it is up to 30x
faster than the one used in <code>rsync</code> (1500 MB/s vs 50 MB/s).</p>
<p dir="auto">The following chart shows a comparison of <code>cdc_rsync</code> and Linux <code>rsync</code> running
under Cygwin on Windows. The test data consists of 58 development builds
of some game provided to us for evaluation purposes. The builds are 40-45 GB
large. For this experiment, we uploaded the first build, then synced the second
build with each of the two tools and measured the time. For example, syncing
from build 1 to build 2 took 210 seconds with the Cygwin <code>rsync</code>, but only 75
seconds with <code>cdc_rsync</code>. The three outliers are probably feature drops from
another development branch, where the delta was much higher. Overall,
<code>cdc_rsync</code> syncs files about <strong>3 times faster</strong> than Cygwin <code>rsync</code>.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://liquidbrain.net/google/cdc-file-transfer/blob/main/docs/cdc_rsync_vs_cygwin_rsync.png"><img src="https://liquidbrain.net/google/cdc-file-transfer/raw/main/docs/cdc_rsync_vs_cygwin_rsync.png" alt="Comparison of cdc_rsync and Linux rsync running in Cygwin" width="753"/></a>
</p>
<p dir="auto">We also ran the experiment with the native Linux <code>rsync</code>, i.e syncing Linux to
Linux, to rule out issues with Cygwin. Linux <code>rsync</code> performed on average 35%
worse than Cygwin <code>rsync</code>, which can be attributed to CPU differences. We did
not include it in the figure because of this, but you can find it
<a href="https://liquidbrain.net/google/cdc-file-transfer/blob/main/docs/cdc_rsync_vs_cygwin_rsync_vs_linux_rsync.png">here</a>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">How does it work and why is it faster?</h3><a id="user-content-how-does-it-work-and-why-is-it-faster" aria-label="Permalink: How does it work and why is it faster?" href="#how-does-it-work-and-why-is-it-faster"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The standard Linux <code>rsync</code> splits a file into fixed-size chunks of typically
several KB.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://liquidbrain.net/google/cdc-file-transfer/blob/main/docs/fixed_size_chunks.png"><img src="https://liquidbrain.net/google/cdc-file-transfer/raw/main/docs/fixed_size_chunks.png" alt="Linux rsync uses fixed size chunks" width="258"/></a>
</p>
<p dir="auto">If the file is modified in the middle, e.g. by inserting <code>xxxx</code> after <code>567</code>,
this usually means that <span>the modified chunks as well as
all subsequent chunks</span> change.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://liquidbrain.net/google/cdc-file-transfer/blob/main/docs/fixed_size_chunks_inserted.png"><img src="https://liquidbrain.net/google/cdc-file-transfer/raw/main/docs/fixed_size_chunks_inserted.png" alt="Fixed size chunks after inserting data" width="301"/></a>
</p>
<p dir="auto">The standard <code>rsync</code> algorithm hashes the chunks of the remote &#34;old&#34; file
and sends the hashes to the local device. The local device then figures out
which parts of the &#34;new&#34; file matches known chunks.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://liquidbrain.net/google/cdc-file-transfer/blob/main/docs/linux_rsync_animation.gif"><img src="https://liquidbrain.net/google/cdc-file-transfer/raw/main/docs/linux_rsync_animation.gif" alt="Syncing a file with the standard Linux rsync" width="855" data-animated-image=""/></a>
  </p>
<p dir="auto">This is a simplification. The actual algorithm is more complicated and uses
two hashes, a weak rolling hash and a strong hash, see
<a href="https://rsync.samba.org/tech_report/" rel="nofollow">here</a> for a great overview. What makes
<code>rsync</code> relatively slow is the &#34;no match&#34; situation where the rolling hash does
not match any remote hash, and the algorithm has to roll the hash forward and
perform a hash map lookup for each byte. <code>rsync</code> goes to
<a href="https://github.com/librsync/librsync/blob/master/src/hashtable.h">great lengths</a>
optimizing lookups.</p>
<p dir="auto"><code>cdc_rsync</code> does not use fixed-size chunks, but instead variable-size,
content-defined chunks. That means, chunk boundaries are determined by the
<em>local content</em> of the file, in practice a 64 byte sliding window. For more
details, see
<a href="https://www.usenix.org/conference/atc16/technical-sessions/presentation/xia" rel="nofollow">the FastCDC paper</a>
or take a look at <a href="https://liquidbrain.net/google/cdc-file-transfer/blob/main/fastcdc/fastcdc.h">our implementation</a>.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://liquidbrain.net/google/cdc-file-transfer/blob/main/docs/variable_size_chunks.png"><img src="https://liquidbrain.net/google/cdc-file-transfer/raw/main/docs/variable_size_chunks.png" alt="cdc_rsync uses variable, content-defined size chunks" width="260"/></a>
</p>
<p dir="auto">If the file is modified in the middle, only <span>the modified
chunks</span>, but not <span>subsequent chunks</span>
change (unless they are less than 64 bytes away from the modifications).</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://liquidbrain.net/google/cdc-file-transfer/blob/main/docs/variable_size_chunks_inserted.png"><img src="https://liquidbrain.net/google/cdc-file-transfer/raw/main/docs/variable_size_chunks_inserted.png" alt="Content-defined chunks after inserting data" width="314"/></a>
</p>
<p dir="auto">Computing the chunk boundaries is cheap and involves only a left-shift, a memory
lookup, an <code>add</code> and an <code>and</code> operation for each input byte. This is cheaper
than the hash map lookup for the standard <code>rsync</code> algorithm.</p>
<p dir="auto">Because of this, the <code>cdc_rsync</code> algorithm is faster than the standard
<code>rsync</code>. It is also simpler. Since chunk boundaries move along with insertions
or deletions, the task to match local and remote hashes is a trivial set
difference operation. It does not involve a per-byte hash map lookup.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://liquidbrain.net/google/cdc-file-transfer/blob/main/docs/cdc_rsync_animation.gif"><img src="https://liquidbrain.net/google/cdc-file-transfer/raw/main/docs/cdc_rsync_animation.gif" alt="Syncing a file with cdc_rsync" width="857" data-animated-image=""/></a>
  </p>

<p dir="auto"><code>cdc_stream</code> is a tool to stream files and directories from a Windows machine to
a Linux device. Conceptually, it is similar to
<a href="https://github.com/libfuse/sshfs">sshfs</a>, but it is optimized for read speed.</p>
<ul dir="auto">
<li>It caches streamed data on the Linux device.</li>
<li>If a file is re-read on Linux after it changed on Windows, only the
differences are streamed again. The rest is read from the cache.</li>
<li>Stat operations are very fast since the directory metadata (filenames,
permissions etc.) is provided in a streaming-friendly way.</li>
</ul>
<p dir="auto">To efficiently determine which parts of a file changed, the tool uses the same
CDC-based diffing algorithm as <code>cdc_rsync</code>. Changes to Windows files are almost
immediately reflected on Linux, with a delay of roughly (0.5s + 0.7s x total
size of changed files in GB).</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://liquidbrain.net/google/cdc-file-transfer/blob/main/docs/cdc_stream_demo.gif"><img src="https://liquidbrain.net/google/cdc-file-transfer/raw/main/docs/cdc_stream_demo.gif" alt="cdc_stream demo" width="688" data-animated-image=""/></a>
</p>
<p dir="auto">The tool does not support writing files back from Linux to Windows; the Linux
directory is readonly.</p>
<p dir="auto">The following chart compares times from starting a game to reaching the menu.
In one case, the game is streamed via <code>sshfs</code>, in the other case we use
<code>cdc_stream</code>. Overall, we see a <strong>2x to 5x speedup</strong>.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://liquidbrain.net/google/cdc-file-transfer/blob/main/docs/cdc_stream_vs_sshfs.png"><img src="https://liquidbrain.net/google/cdc-file-transfer/raw/main/docs/cdc_stream_vs_sshfs.png" alt="Comparison of cdc_stream and sshfs" width="752"/></a>
</p>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th><code>cdc_rsync</code></th>
<th>From</th>
<th>To</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows x86_64</td>
<td>✓</td>
<td>✓ <sup>1</sup></td>
</tr>
<tr>
<td>Ubuntu 22.04 x86_64</td>
<td>✗ <sup>2</sup></td>
<td>✓</td>
</tr>
<tr>
<td>Ubuntu 22.04 aarch64</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>macOS 13 x86_64 <sup>3</sup></td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>macOS 13 aarch64 <sup>3</sup></td>
<td>✗</td>
<td>✗</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th><code>cdc_stream</code></th>
<th>From</th>
<th>To</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows x86_64</td>
<td>✓</td>
<td>✗</td>
</tr>
<tr>
<td>Ubuntu 22.04 x86_64</td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td>Ubuntu 22.04 aarch64</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>macOS 13 x86_64 <sup>3</sup></td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>macOS 13 aarch64 <sup>3</sup></td>
<td>✗</td>
<td>✗</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<span>
<p dir="auto"><sup>1</sup> Only local syncs, e.g. <code>cdc_rsync C:\src\* C:\dst</code>. Support for
remote syncs is being added, see
<a href="https://github.com/google/cdc-file-transfer/issues/61" data-hovercard-type="issue" data-hovercard-url="/google/cdc-file-transfer/issues/61/hovercard">#61</a>.</p>
</span>

<p dir="auto">Download the precompiled binaries from the
<a href="https://github.com/google/cdc-file-transfer/releases">latest release</a> to a
Windows device and unzip them. The Linux binaries are automatically deployed
to <code>~/.cache/cdc-file-transfer</code> by the Windows tools. There is no need to manually
deploy them. We currently provide Linux binaries compiled on
<a href="https://github.com/actions/runner-images">Github&#39;s latest Ubuntu</a> version.
If the binaries work for you, you can skip the following two sections.</p>
<p dir="auto">Alternatively, the project can be built from source. Some binaries have to be
built on Windows, some on Linux.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Prerequisites for Building</h2><a id="user-content-prerequisites-for-building" aria-label="Permalink: Prerequisites for Building" href="#prerequisites-for-building"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To build the tools from source, the following steps have to be executed on
<strong>both Windows and Linux</strong>.</p>
<ul dir="auto">
<li>Download and install Bazel from <a href="https://bazel.build/install" rel="nofollow">here</a>. See
<a href="https://github.com/google/cdc-file-transfer/actions">workflow logs</a> for the
currently used version.</li>
<li>Clone the repository.
<div data-snippet-clipboard-copy-content="git clone https://github.com/google/cdc-file-transfer"><pre><code>git clone https://github.com/google/cdc-file-transfer
</code></pre></div>
</li>
<li>Initialize submodules.
<div data-snippet-clipboard-copy-content="cd cdc-file-transfer
git submodule update --init --recursive"><pre><code>cd cdc-file-transfer
git submodule update --init --recursive
</code></pre></div>
</li>
</ul>
<p dir="auto">Finally, install an SSH client on the Windows machine if not present.
The file transfer tools require <code>ssh.exe</code> and <code>sftp.exe</code>.</p>

<p dir="auto">The two tools CDC RSync and CDC Stream can be built and used independently.</p>

<ul dir="auto">
<li>On a Linux device, build the Linux components
<div data-snippet-clipboard-copy-content="bazel build --config linux --compilation_mode=opt --linkopt=-Wl,--strip-all --copt=-fdata-sections --copt=-ffunction-sections --linkopt=-Wl,--gc-sections //cdc_rsync_server"><pre><code>bazel build --config linux --compilation_mode=opt --linkopt=-Wl,--strip-all --copt=-fdata-sections --copt=-ffunction-sections --linkopt=-Wl,--gc-sections //cdc_rsync_server
</code></pre></div>
</li>
<li>On a Windows device, build the Windows components
<div data-snippet-clipboard-copy-content="bazel build --config windows --compilation_mode=opt --copt=/GL //cdc_rsync"><pre><code>bazel build --config windows --compilation_mode=opt --copt=/GL //cdc_rsync
</code></pre></div>
</li>
<li>Copy the Linux build output file <code>cdc_rsync_server</code> from
<code>bazel-bin/cdc_rsync_server</code> to <code>bazel-bin\cdc_rsync</code> on the Windows machine.</li>
</ul>

<ul dir="auto">
<li>On a Linux device, build the Linux components
<div data-snippet-clipboard-copy-content="bazel build --config linux --compilation_mode=opt --linkopt=-Wl,--strip-all --copt=-fdata-sections --copt=-ffunction-sections --linkopt=-Wl,--gc-sections //cdc_fuse_fs"><pre><code>bazel build --config linux --compilation_mode=opt --linkopt=-Wl,--strip-all --copt=-fdata-sections --copt=-ffunction-sections --linkopt=-Wl,--gc-sections //cdc_fuse_fs
</code></pre></div>
</li>
<li>On a Windows device, build the Windows components
<div data-snippet-clipboard-copy-content="bazel build --config windows --compilation_mode=opt --copt=/GL //cdc_stream"><pre><code>bazel build --config windows --compilation_mode=opt --copt=/GL //cdc_stream
</code></pre></div>
</li>
<li>Copy the Linux build output files <code>cdc_fuse_fs</code> and <code>libfuse.so</code> from
<code>bazel-bin/cdc_fuse_fs</code> to <code>bazel-bin\cdc_stream</code> on the Windows machine.</li>
</ul>

<p dir="auto">The tools require a setup where you can use SSH and SFTP from the Windows
machine to the Linux device without entering a password, e.g. by using key-based
authentication.</p>

<p dir="auto">By default, the tools search <code>ssh.exe</code> and <code>sftp.exe</code> from the path environment
variable. If you can run the following commands in a Windows cmd without
entering your password, you are all set:</p>
<div data-snippet-clipboard-copy-content="ssh user@linux.device.com
sftp user@linux.device.com"><pre><code>ssh user@linux.device.com
sftp user@linux.device.com
</code></pre></div>
<p dir="auto">Here, <code>user</code> is the Linux user and <code>linux.device.com</code> is the Linux host to
SSH into or copy the file to.</p>
<p dir="auto">If additional arguments are required, it is recommended to provide an SSH config
file. By default, both <code>ssh.exe</code> and <code>sftp.exe</code> use the file at
<code>%USERPROFILE%\.ssh\config</code> on Windows, if it exists. A possible config file
that sets a username, a port, an identity file and a known host file could look
as follows:</p>
<div data-snippet-clipboard-copy-content="Host linux_device
	HostName linux.device.com
	User user
	Port 12345
	IdentityFile C:\path\to\id_rsa
	UserKnownHostsFile C:\path\to\known_hosts"><pre><code>Host linux_device
	HostName linux.device.com
	User user
	Port 12345
	IdentityFile C:\path\to\id_rsa
	UserKnownHostsFile C:\path\to\known_hosts
</code></pre></div>
<p dir="auto">If <code>ssh.exe</code> or <code>sftp.exe</code> cannot be found, you can specify the full paths via
the command line arguments <code>--ssh-command</code> and <code>--sftp-command</code> for <code>cdc_rsync</code>
and <code>cdc_stream start</code> (see below), or set the environment variables
<code>CDC_SSH_COMMAND</code> and <code>CDC_SFTP_COMMAND</code>, e.g.</p>
<div data-snippet-clipboard-copy-content="set CDC_SSH_COMMAND=&#34;C:\path with space\to\ssh.exe&#34;
set CDC_SFTP_COMMAND=&#34;C:\path with space\to\sftp.exe&#34;"><pre><code>set CDC_SSH_COMMAND=&#34;C:\path with space\to\ssh.exe&#34;
set CDC_SFTP_COMMAND=&#34;C:\path with space\to\sftp.exe&#34;
</code></pre></div>
<p dir="auto">Note that you can also specify SSH configuration via the environment variables
instead of using a config file:</p>
<div data-snippet-clipboard-copy-content="set CDC_SSH_COMMAND=C:\path\to\ssh.exe -p 12345 -i C:\path\to\id_rsa -oUserKnownHostsFile=C:\path\to\known_hosts
set CDC_SFTP_COMMAND=C:\path\to\sftp.exe -P 12345 -i C:\path\to\id_rsa -oUserKnownHostsFile=C:\path\to\known_hosts"><pre><code>set CDC_SSH_COMMAND=C:\path\to\ssh.exe -p 12345 -i C:\path\to\id_rsa -oUserKnownHostsFile=C:\path\to\known_hosts
set CDC_SFTP_COMMAND=C:\path\to\sftp.exe -P 12345 -i C:\path\to\id_rsa -oUserKnownHostsFile=C:\path\to\known_hosts
</code></pre></div>
<p dir="auto">Note the small <code>-p</code> for <code>ssh.exe</code> and the capital <code>-P</code> for <code>sftp.exe</code>.</p>

<p dir="auto">For Google internal usage, set the following environment variables to enable SSH
authentication using a Google security key:</p>
<div data-snippet-clipboard-copy-content="set CDC_SSH_COMMAND=C:\gnubby\bin\ssh.exe
set CDC_SFTP_COMMAND=C:\gnubby\bin\sftp.exe"><pre><code>set CDC_SSH_COMMAND=C:\gnubby\bin\ssh.exe
set CDC_SFTP_COMMAND=C:\gnubby\bin\sftp.exe
</code></pre></div>
<p dir="auto">Note that you will have to touch the security key multiple times during the
first run. Subsequent runs only require a single touch.</p>

<p dir="auto"><code>cdc_rsync</code> is used similar to <code>scp</code> or the Linux <code>rsync</code> command. To sync a
single Windows file <code>C:\path\to\file.txt</code> to the home directory <code>~</code> on the Linux
device <code>linux.device.com</code>, run</p>
<div data-snippet-clipboard-copy-content="cdc_rsync C:\path\to\file.txt user@linux.device.com:~"><pre><code>cdc_rsync C:\path\to\file.txt user@linux.device.com:~
</code></pre></div>
<p dir="auto"><code>cdc_rsync</code> understands the usual Windows wildcards <code>*</code> and <code>?</code>.</p>
<div data-snippet-clipboard-copy-content="cdc_rsync C:\path\to\*.txt user@linux.device.com:~"><pre><code>cdc_rsync C:\path\to\*.txt user@linux.device.com:~
</code></pre></div>
<p dir="auto">To sync the contents of the Windows directory <code>C:\path\to\assets</code> recursively to
<code>~/assets</code> on the Linux device, run</p>
<div data-snippet-clipboard-copy-content="cdc_rsync C:\path\to\assets\* user@linux.device.com:~/assets -r"><pre><code>cdc_rsync C:\path\to\assets\* user@linux.device.com:~/assets -r
</code></pre></div>
<p dir="auto">To get per file progress, add <code>-v</code>:</p>
<div data-snippet-clipboard-copy-content="cdc_rsync C:\path\to\assets\* user@linux.device.com:~/assets -vr"><pre><code>cdc_rsync C:\path\to\assets\* user@linux.device.com:~/assets -vr
</code></pre></div>
<p dir="auto">The tool also supports local syncs:</p>
<div data-snippet-clipboard-copy-content="cdc_rsync C:\path\to\assets\* C:\path\to\destination -vr"><pre><code>cdc_rsync C:\path\to\assets\* C:\path\to\destination -vr
</code></pre></div>

<p dir="auto">To stream the Windows directory <code>C:\path\to\assets</code> to <code>~/assets</code> on the Linux
device, run</p>
<div data-snippet-clipboard-copy-content="cdc_stream start C:\path\to\assets user@linux.device.com:~/assets"><pre><code>cdc_stream start C:\path\to\assets user@linux.device.com:~/assets
</code></pre></div>
<p dir="auto">This makes all files and directories in <code>C:\path\to\assets</code> available on
<code>~/assets</code> immediately, as if it were a local copy. However, data is streamed
from Windows to Linux as files are accessed.</p>
<p dir="auto">To stop the streaming session, enter</p>
<div data-snippet-clipboard-copy-content="cdc_stream stop user@linux.device.com:~/assets"><pre><code>cdc_stream stop user@linux.device.com:~/assets
</code></pre></div>
<p dir="auto">The command also accepts wildcards. For instance,</p>

<p dir="auto">stops all existing streaming sessions for the given user.</p>

<p dir="auto">On first run, <code>cdc_stream</code> starts a background service, which does all the work.
The <code>cdc_stream start</code> and <code>cdc_stream stop</code> commands are just RPC clients that
talk to the service.</p>
<p dir="auto">The service logs to <code>%APPDATA%\cdc-file-transfer\logs</code> by default. The logs are
useful to investigate issues with asset streaming. To pass custom arguments, or
to debug the service, create a JSON config file at
<code>%APPDATA%\cdc-file-transfer\cdc_stream.json</code> with command line flags.
For instance,</p>

<p dir="auto">instructs the service to log debug messages. Try <code>cdc_stream start-service -h</code>
for a list of available flags. Alternatively, run the service manually with</p>

<p dir="auto">and pass the flags as command line arguments. When you run the service manually,
the flag <code>--log-to-stdout</code> is particularly useful as it logs to the console
instead of to the file.</p>
<p dir="auto"><code>cdc_rsync</code> always logs to the console. To increase log verbosity, pass <code>-vvv</code>
for debug logs or <code>-vvvv</code> for verbose logs.</p>
<p dir="auto">For both sync and stream, the debug logs contain all SSH and SFTP commands that
are attempted to run, which is very useful for troubleshooting. If a command
fails unexpectedly, copy it and run it in isolation. Pass <code>-vv</code> or <code>-vvv</code> for
additional debug output.</p>
</article></div></div>
  </body>
</html>
