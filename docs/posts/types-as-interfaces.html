<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://two-wrongs.com/types-as-interfaces">Original</a>
    <h1>Types as Interfaces</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>
For the past few days, I have been toying with an idea for a board game. To test
it out, I wanted to write a simple implementation of it. Here’s an example of a
type we might need in a critical phase of the game.
</p>

<div>
<pre><span>-- | A quote for a proposal.</span>
<span>data</span> <span>Quote</span> <span>=</span> <span>Quote</span>
  { _proposal <span>::</span> <span>Proposal</span>
  , _premium <span>::</span> <span>Int</span>
  , _share <span>::</span> <span>Int</span>
  }
</pre>
</div>

<p>
In that phase, values of this type need to be communicated back and forth
between players in a unicast fashion, so we might want to add fields to indicate
who sent it and who received it.
</p>

<div>
<pre><span>-- | A quote that has both owner and offering player.</span>
<span>data</span> <span>QuoteEtc</span> <span>=</span> <span>QuoteEtc</span>
  { _proposal <span>::</span> <span>Proposal</span>
  , _premium <span>::</span> <span>Int</span>
  , _share <span>::</span> <span>Int</span>
  , _owner <span>::</span> <span>PlayerId</span> <span>-- ^ Player that owns the process.</span>
  , _offering <span>::</span> <span>PlayerId</span> <span>-- ^ Player that offers this quote.</span>
  }
</pre>
</div>

<p>
But then I realised there are quite a lot of these types where source-and-target
fields are required, and that we could annotate them without modifying the
underlying type, by creating another type to hold that data:
</p>

<div>
<pre><span>-- | Create a unicast message from any type a.</span>
<span>data</span> <span>Msg</span> a <span>=</span> <span>Msg</span>
  { _sender <span>::</span> <span>PlayerId</span>
  , _recipient <span>::</span> <span>PlayerId</span>
  , _payload <span>::</span> a
  }
</pre>
</div>

<p>
With this, we can construct a value of type <code>Msg Quote</code> which represents the
<code>Quote</code> annotated by sender and recipient.
</p>

<div>
<pre><span>Msg</span>
  { _sender <span>=</span> <span>PlayerId</span> 2
  , _recipient <span>=</span> <span>PlayerId</span> 0
  , _payload <span>=</span> <span>Quote</span>
      { _proposal <span>=</span> undefined
      , _premium <span>=</span> 5
      , _share <span>=</span> 3
      }
  }
</pre>
</div>

<p>
Functions that only operate on the <code>_sender</code> and <code>_recipient</code> fields can be
written with the appropriate type signature and be generic over
payload.<span><sup>1</sup> This example uses object oriented style getters. If you’re
unfamiliar with optics/lenses, think of the operator <code>^.</code> as you would a regular
<code>.</code> to get a property from a value in a language like Python or C#.</span>
</p>

<div>
<pre><span>-- | Determines if a message is intended for player.</span>
<span>msg_for</span> <span>::</span> <span>Player</span> <span>-&gt;</span> <span>Msg</span> a <span>-&gt;</span> <span>Bool</span>
<span>msg_for</span> player msg <span>=</span>
  player<span>^.</span>name <span>==</span> msg<span>^.</span>recipient
</pre>
</div>

<p>
This function does not care what the payload of the message is; it can be used
on any list of messages, like
</p>

<div>
<pre>filter (msg_for broker) messages
</pre>
</div>

<p>
to extract a list of messages intended for that player, regardless of whether
the payload is <code>Quote</code> or anything else.<span><sup>2</sup> Though beginners with Haskell
beware: whenever we pass a list of messages into this funcion, it still needs to
be a homogeneous list of just one concrete type. We cannot mix both <code>Msg
Proposal</code> and <code>Msg Quote</code> in the same list.</span>
</p>

<p>
Even though <code>Msg</code> is a plain type constructor, it acts an awful lot like an
interface. That is the main point of this article; that’s a pattern that can be
used to design simple code.
</p>

<hr/>

<p>
There is a common complaint against what we just did above. People say that
types-as-interfaces are not <i>composable</i>. Let’s find out what they mean. Imagine
we wanted some messages to be timestamped. We could add an optional <code>_timestamp</code>
field to the message type:
</p>

<div>
<pre><span>-- | Create a message from any type a, with optional timestamp.</span>
<span>data</span> <span>MsgEtc</span> a <span>=</span> <span>MsgEtc</span>
  { _sender <span>::</span> <span>PlayerId</span>
  , _recipient <span>::</span> <span>PlayerId</span>
  , _timestamp <span>::</span> <span>Maybe</span> <span>UTCTime</span>
  , _payload <span>::</span> a
  }
</pre>
</div>

<p>
but what if we also wanted to timestamp some of the other objects we have, like
<code>Quote</code>? Aha! We just learned how to do this! We create a new wrapper type:
</p>

<div>
<pre><span>-- | Annotate any value with a timestamp.</span>
<span>data</span> <span>Timestamped</span> a <span>=</span> <span>Timestamped</span>
  { _timestamp <span>::</span> <span>UTCTime</span>
  , _contents <span>::</span> a
  }
</pre>
</div>

<p>
Just as we before we can now tack on another layer of data and make a
<code>Timestamped (Msg Quote)</code>.
</p>

<div>
<pre><span>Timestamped</span>
  { _timestamp <span>=</span> now
  , _contents <span>=</span> <span>Msg</span>
      { _sender <span>=</span> <span>PlayerId</span> 2
      , _recipient <span>=</span> <span>PlayerId</span> 0
      , _payload <span>=</span> <span>Quote</span>
          { _proposal <span>=</span> undefined
          , _premium <span>=</span> 5
          , _share <span>=</span> 3
          }
      }
  }
</pre>
</div>

<p>
Clearly, this approach <i>does</i> compose, because we just composed both
<code>Timestamped a</code> and <code>Msg a</code>. But remember the <code>msg_for</code> function we had that
determined whether a message was intended for a particular recipient? It had the
signature
</p>

<div>
<pre><span>msg_for</span> <span>::</span> <span>Player</span> <span>-&gt;</span> <span>Msg</span> a <span>-&gt;</span> <span>Bool</span>
</pre>
</div>

<p>
meaning it takes any <code>Msg a</code> but it will not be possible to give it a
<code>Timestamped (Msg a)</code>; we have to unwrap the message from the timestamp first.
However, if we gave it an <code>Msg (Timestamped Quote)</code>, it would have worked,
perhaps counter-intuitively.
</p>

<p>
The complaint here is not that the approach does not compose at all (clearly it
does), but that it does not compose <i>well</i>: the order in which we choose to
annotate our data with extra fields affects whether or not we can pass them into
existing functions.
</p>

<p>
I think that’s basically fine. If we think about it, isn’t <code>Timestamped (Msg
Quote)</code> a different-feeling <i>thing</i> from a <code>Msg (Timestamped Quote)</code>? But let’s
assume we wanted to fix it. What is near at hand?
</p>

<hr/>

<p>
We could make a typeclass
</p>

<div>
<pre><span>class</span> <span>HasRecipient</span> a <span>where</span>
  get_receiver <span>::</span> a <span>-&gt;</span> <span>PlayerId</span>
</pre>
</div>

<p>
This is more like a real interface, which can be implemented by any type that
has a receiver. Here are two implementations we would want:
</p>

<div>
<pre><span>instance</span> <span>HasRecipient</span> (<span>Msg</span> a) <span>where</span>
  get_receiver msg <span>=</span> msg<span>^.</span>receiver

<span>instance</span> <span>HasRecipient</span> (<span>Timestamped</span> (<span>Msg</span> a)) <span>where</span>
  get_receiver tsd <span>=</span> tsd<span>^.</span>contents<span>.</span>receiver
</pre>
</div>

<p>
We could then rewrite <code>msg_for</code> in terms of this typeclass instead.
</p>

<div>
<pre><span>msg_for</span> <span>::</span> <span>HasRecipient</span> msg <span>=&gt;</span> <span>Player</span> <span>-&gt;</span> msg <span>-&gt;</span> <span>Bool</span>
<span>msg_for</span> player msg <span>=</span>
  player<span>^.</span>name <span>==</span> get_receiver msg
</pre>
</div>

<p>
and this will work for any value of a type that implements <code>HasRecipient</code>,
including <code>Msg a</code> and <code>Timestamped (Msg a)</code>.
</p>

<p>
Okay, so let’s roll down this slippery slope. Maybe we have a function
</p>

<div>
<pre><span>logger</span> <span>::</span> <span>Show</span> a <span>=&gt;</span> [<span>Timestamped</span> a] <span>-&gt;</span> <span>IO</span> <span>()</span>
</pre>
</div>

<p>
which logs things in order of timestamp. This function will not take a list of
<code>Msg (Timestamped Quote)</code> because there the outer value is not timestamped but
the <code>Quote</code> inside.
</p>

<p>
We could apply our newly discovered hammer and create a similar <code>HasTimestamp</code> typeclass.
</p>

<div>
<pre><span>class</span> <span>HasTimestamp</span> a <span>where</span>
  get_timestamp <span>::</span> a <span>-&gt;</span> <span>UTCTime</span>

<span>instance</span> <span>HasTimestamp</span> (<span>Timestamped</span> a) <span>where</span>
  get_timestamp tsd <span>=</span> tsd<span>^.</span>timestamp

<span>instance</span> <span>HasRecipient</span> (<span>Msg</span> (<span>Timestamped</span> a)) <span>where</span>
  get_timestamp msg <span>=</span> msg<span>^.</span>payload<span>.</span>timestamp
</pre>
</div>

<p>
But at this point it gets a little confusing for this author’s brain – at least
if long-term maintenance is desired. What would be the best instance for
<code>Timestamped (Msg (Timestamped Quote))</code>, for example?
</p>

<p>
And as we said before, aren’t <code>Timestamped (Msg Quote)</code> and <code>Msg (Timestamped
Quote)</code> slightly different kinds of things? Do we <i>really</i> need to be able to
pass both unaltered into that logging function?
</p>

<hr/>

<p>
What we really should do is take a cue from network protocol design. These are
robust things that have stood the test of time.
</p>

<p>
Image data might be stored in a <abbr>tga</abbr> file with headers giving information on
how to interpret it. It will be placed into a <abbr>http</abbr> request with its own headers.
This gets stuffed inside a <abbr>tcp</abbr> packet with further headers. That in turn is
enveloped in an <abbr>ip</abbr> datagram with headers. Which might then run along a wire
inside an ethernet frame, carrying – you guessed it – its own headers.
</p>

<p>
At no point during transmission<span><sup>3</sup> To be fair, I would not be surprised if it
was possible to find network switches in the wild that inspect <abbr>ip</abbr> headers, or
routers that look at <abbr>http</abbr> headers. So maybe that whole layered protocol thing
was a mistake and I’m full of crap!</span> does a switch hold up an ethernet frame to
the light and ask, “So what <abbr>http</abbr> content type are you transmitting?” We have
designed these protocols to be layered with meaningful structure from
outside to in. Maybe we can do that in our code as well.
</p>

<p>
Maybe we don’t need both <code>Timestamped (Msg Quote)</code> and <code>Msg (Timestamped Quote)</code>
in our application, and just one of them is enough. A mathematician creates
generalisations that work with everything. An engineer strips away the variants
that are less important and adapts the code to the big demands at hand. This
makes things simpler along the way.
</p>

<p>
If we do need both, maybe it’s fine to treat them as two different types (they
are!) and not try to make functions generic over them.
</p>

            </div></div>
  </body>
</html>
