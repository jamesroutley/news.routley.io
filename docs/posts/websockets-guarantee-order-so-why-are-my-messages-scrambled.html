<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sitongpeng.com/writing/websockets-guarantee-order-so-why-are-my-messages-scrambled">Original</a>
    <h1>WebSockets guarantee order - so why are my messages scrambled?</h1>
    
    <div id="readability-page-1" class="page"><div>  <p>You might know that WebSocket has message ordering and message delivery guarantees. But why is that the case? And under what conditions do those guarantees hold? I was recently discussing WebSocket behavior with another engineer and realized I didn’t have a solid foundation here, so I did some digging to understand it better…</p>
<h2 id="arent-websockets-on-tcp">Aren’t WebSockets on TCP?</h2>
<p>Yes, WebSocket is an application level protocol (<a href="https://en.wikipedia.org/wiki/Application_layer">layer 7 on the OSI model</a>, a la HTTP) using TCP on the transport level (layer 4). So you get all the guarantees of TCP, namely: reliable delivery and reliable ordering of messages.</p>
<h3 id="how-does-tcp-guarantee-order">How does TCP guarantee order?</h3>
<p>Each TCP segment has a sequence number header, ordering each segment monotonically. Clients <code>ACK</code> segment offsets back to hosts. If the client doesn’t <code>ACK</code> in time, the host will automatically resend unacknowledged segments - or the client can request the additional segments.</p>
<h3 id="how-does-tcp-guarantee-delivery">How does TCP guarantee delivery?</h3>
<p>In the case of corrupted segments, there is a checksum header that lets a client know to re-request a segment. Otherwise, clients send <code>ACK</code>s to confirm receipt of segments, allowing the host to track successful delivery.</p>
<h2 id="but-my-messages-are-coming-out-of-order">But my messages are coming out of order</h2>
<p>We know WebSocket message order is <a href="https://github.com/websockets/ws/issues/542#issuecomment-128714956">guaranteed through TCP</a>, but things can get out of order quite easily. Let’s go through a case.</p>
<p><img src="https://sitongpeng.com/media/primeagen-websocket.png" alt="Primeagen WebSocket"/>
<em><span><a href="https://x.com/ThePrimeagen/status/1796263874091749754">Primeagen</a> is a popular programming creator (I follow him!)</span></em></p>
<p>Here’s the code that Primeagen is referring to (<em>simplified for clarity</em>):</p>
<pre tabindex="0" data-language="javascript"><code><span><span>ws.</span><span>onmessage</span><span> =</span><span> async</span><span> (</span><span>message</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> blob</span><span> =</span><span> message.data</span></span>
<span><span>  const</span><span> arrBuff</span><span> =</span><span> await</span><span> blob.</span><span>arrayBuffer</span><span>()</span></span>
<span><span>  console.</span><span>log</span><span>(arrBuff) </span><span>// messages are logged out of order</span></span>
<span><span>}</span></span></code></pre>
<p>Primagen knows WebSocket is on TCP and has ordering guarantees. He noticed that the messages were logging out of order and initially suspected a JavaScript bug — perhaps something wrong with how the engine handled binary WebSocket frames.</p>
<p>So what’s actually going wrong here?</p>
<pre tabindex="0" data-language="javascript"><code><span><span>ws.</span><span>onmessage</span><span> =</span><span> async</span><span> (</span><span>message</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> blob</span><span> =</span><span> message.data</span></span>
<span><span>  const</span><span> arrBuff</span><span> =</span><span> await</span><span> blob.</span><span>arrayBuffer</span><span>() </span><span>// we&#39;re async now folks</span></span>
<span><span>  console.</span><span>log</span><span>(arrBuff)</span></span>
<span><span>}</span></span></code></pre>
<p>The <code>await</code> pauses execution of the message handler, returning to the next task in the call stack. <code>.arrayBuffer()</code> will take variable time depending on the size of the message blob. So this isn’t a JavaScript engine bug - it’s an application level issue that reorders each WebSocket message based on how long it takes to resolve <code>.arrayBuffer()</code>.</p>
<h3 id="how-would-you-preserve-order-here">How would you preserve order here?</h3>
<p>I wrote up two options. In my implementation, my WebSocket server will send clients 10 messages with a randomized processing time of 1-5 seconds. I have a simple timeout promise on the client side to approximate processing time.</p>
<pre tabindex="0" data-language="typescript"><code><span><span>async</span><span> function</span><span> resolveIn</span><span>(</span><span>ms</span><span>:</span><span> number</span><span>)</span><span>:</span><span> Promise</span><span>&lt;</span><span>number</span><span>&gt; {</span></span>
<span><span>  return</span><span> new</span><span> Promise</span><span>&lt;</span><span>number</span><span>&gt;(</span><span>resolve</span><span> =&gt;</span><span> {</span></span>
<span><span>    setTimeout</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>      resolve</span><span>(ms)</span></span>
<span><span>    }, ms </span><span>*</span><span> 1000</span><span>)</span></span>
<span><span>  })</span></span>
<span><span>}</span></span></code></pre>
<h4 id="processing-messages-async-using-a-queue">Processing messages async using a queue</h4>
<p>This design has a message queue with a simple processing flag (don’t need a proper mutex for single threaded JS).</p>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> messageQueue</span><span>:</span><span> Message</span><span>[] </span><span>=</span><span> []</span></span>
<span><span>let</span><span> processingQueue </span><span>=</span><span> false</span></span>
<span></span>
<span><span>async</span><span> function</span><span> processQueue</span><span>() {</span></span>
<span><span>  if</span><span> (processingQueue) {</span></span>
<span><span>    setTimeout</span><span>(() </span><span>=&gt;</span><span> processQueue</span><span>(), </span><span>0</span><span>)</span></span>
<span><span>    return</span></span>
<span><span>  }</span></span>
<span><span>  processingQueue </span><span>=</span><span> true</span></span>
<span><span>  const</span><span> toProcess</span><span> =</span><span> messageQueue.</span><span>splice</span><span>(</span><span>0</span><span>, </span><span>5</span><span>)</span></span>
<span><span>  const</span><span> messages</span><span> =</span><span> await</span><span> Promise</span><span>.</span><span>all</span><span>(toProcess.</span><span>map</span><span>(</span><span>async</span><span> (</span><span>message</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    return</span><span> {</span></span>
<span><span>      id: message.id,</span></span>
<span><span>      number: </span><span>await</span><span> resolveIn</span><span>(message.number)</span></span>
<span><span>    }</span></span>
<span><span>  }))</span></span>
<span><span>  for</span><span> (</span><span>let</span><span> message </span><span>of</span><span> messages) {</span></span>
<span><span>    console.</span><span>log</span><span>(</span><span>`Handled message ${</span><span>message</span><span>.</span><span>id</span><span>} with ${</span><span>message</span><span>.</span><span>number</span><span>}s client processing`</span><span>)</span></span>
<span><span>  }</span></span>
<span><span>  processingQueue </span><span>=</span><span> false</span></span>
<span><span>}</span></span>
<span></span>
<span><span>socket.</span><span>onmessage</span><span> =</span><span> (</span><span>message</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> data</span><span> =</span><span> JSON</span><span>.</span><span>parse</span><span>(message.data)</span></span>
<span><span>  messageQueue.</span><span>push</span><span>(data)</span></span>
<span><span>  processQueue</span><span>()</span></span>
<span><span>}</span></span></code></pre>
<p>This implementation puts messages on an queue. Then messages are batch processed 5 at a time, using <code>Promise.all</code> to preserve result ordering. This design allows for parallel processing, but ensures the final results are handled in the correct order.</p>
<h4 id="processing-messages-synchronously">Processing messages synchronously</h4>
<pre tabindex="0" data-language="typescript"><code><span><span>const</span><span> generator</span><span> =</span><span> messageGenerator</span><span>()</span></span>
<span><span>await</span><span> generator.</span><span>next</span><span>()</span></span>
<span></span>
<span><span>async</span><span> function*</span><span> messageGenerator</span><span>()</span><span>:</span><span> AsyncGenerator</span><span>&lt;</span><span>void</span><span>, </span><span>void</span><span>, </span><span>Message</span><span>&gt; {</span></span>
<span><span>  while</span><span> (</span><span>true</span><span>) {</span></span>
<span><span>    const</span><span> message</span><span> =</span><span> yield</span></span>
<span><span>    if</span><span> (message) {</span></span>
<span><span>      const</span><span> number</span><span> =</span><span> await</span><span> resolveIn</span><span>(message.number)</span></span>
<span><span>      console.</span><span>log</span><span>(</span><span>`Handled message ${</span><span>message</span><span>.</span><span>id</span><span>} with ${</span><span>number</span><span>}s client processing`</span><span>)</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>socket.</span><span>onmessage</span><span> =</span><span> async</span><span> (</span><span>message</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> data</span><span> =</span><span> JSON</span><span>.</span><span>parse</span><span>(message.data)</span></span>
<span><span>  await</span><span> generator.</span><span>next</span><span>(data)</span></span>
<span><span>}</span></span></code></pre>
<p>We can also use a generator to process messages one at a time. This is slower than batching since we are not doing anything in parallel, but this might be required in some cases where processing order is important.</p>

<p>Debugging complex systems is hard, especially when you’re dealing with layered abstractions like WebSocket over TCP. It’s easy to blame the protocol, the network, or the language compiler, when the real issue is how your application code handles concurrency. Always go one level deeper. In this case, even with TCP’s ordering guarantees, it’s still possible to break that order yourself.</p>
<p>In an upcoming post, I’ll talk about how to handle unreliable connections and state resync with WebSockets — stay tuned!</p>  </div></div>
  </body>
</html>
