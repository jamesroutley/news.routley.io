<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://experimentalworks.net/posts/2024-03-18-a-history-of-vcs-part1/">Original</a>
    <h1>A History of Source Control Systems: SCCS and RCS</h1>
    
    <div id="readability-page-1" class="page"><div><p><em><a href="https://news.ycombinator.com/item?id=39950712">HN Thread</a> and <a href="https://lobste.rs/s/i3eg8u/history_source_control_systems_sccs_rcs">lobste.rs thread</a>.</em></p><p>Source Control Management (SCM) Systems, have a long and rich history. As the systems evolved, so have their concepts, use cases and adoption over time. While SCMs are ubiquitous in modern software development, they have been fairly novel in the 80s and 90s, and arguable it took the rise of Git and Github for them to be used nearly everywhere.</p><p>I want to provide an overview of what I consider the most important and influential systems over time. This list does not attempt to be complete. There are many systems that aren’t covered and details that I will be missing. The history of some of these systems are difficult to trace back. There is little write up on the origins of early software, and so my primary sources of many of these are Wikipedia. More recent systems such as SVN, Mercurial and Git are easier to find sources on and I often recall some of the details from memory.</p><p>Note that this posts focuses on source control systems, meaning systems meant for storing versions of source code. Other version control systems that focus primarily binary data will not be covered. For the purpose of this blog post, I will use the terms <em>source control system</em> and <em>version control system</em> interchangeable. I recognize that source control systems are a subcategory of version control systems.</p><p>I have used most of the systems on this list myself at some point in time. For systems that I haven’t used myself, such as SourceSafe and ClearCase, I would love to hear from you about your experience with them.</p><h2 id="overview">Overview</h2><p>The blog post is ordered chronological. The initial post, Part 1, will cover SCCS and RCS, two hugely influential version control systems of the 70s and 80s. The systems are generally local only and version single files at a time.</p><p>Part 2 (TBD) will cover the rise of centralised version control systems, such as CVS, SourceSafe, ClearCase, that allow users for the first time concurrent access to the same files from different machines.</p><p>In the third part (TBD), we will focus on the evolution of centralised version control systems and touch on SVN and Perforce, two very successful and until this day, widely used version control systems.</p><p>Part 4 (TBD) will put the spotlight on the next leap in version control systems: Decentralised version control. We will take a look at the origins of decentralised version control systems at Sun Microsystems, and their spiritual descendant Bitkeeper, and take a look at early open source systems such as has GNU Arch, Monotone and the very unique Darcs.</p><p>With the origins of decentralised version control systems behind us, we will focus in Part 5 (TBD), on the version control systems wars between 2005 to 2015, where three main systems, Git, Mercurial and Bazaar were simultaneously developed.</p><p>In the last two parts (TBD), we will take a quick look at the current landscape of version control systems, as well as some interesting ideas that are developed as part of Fossil and Pijul, before I will talk about, what I consider the missing version control system.</p><p>I would very much appreciate feedback on this series of blog posts. Please reach out to me at blog at (this domain), <a href="https://lobste.rs/s/i3eg8u/history_source_control_systems_sccs_rcs">Lobste.rs</a> or <a href="https://news.ycombinator.com/item?id=39950712">Hacker News</a>.</p><h2 id="part-1-sccs-and-rcs">Part 1: SCCS and RCS</h2><h3 id="1973-sccs">1973: SCCS</h3><p>It might surprise you to learn that the first version control system emerged relatively late in the history of computing. UNIX had been in development for three years by the time SCCS, the first version control system, was created in 1972. However, in the context of the time, it makes sense:</p><p>Before the late 1960s, most programs were written using <a href="https://en.wikipedia.org/wiki/Punched_card">punched cards</a>. A program’s version was its physical set of punched cards. Versioning a program involved the physical labor of organizing and storing these cards in boxes. Terminals and disks existed but were expensive. Programmers used them for input and output to the system rather than for development.</p><p>In the 1970s, <a href="https://en.wikipedia.org/wiki/Computer_terminal">video terminals</a> like the <a href="https://en.wikipedia.org/wiki/VT100">VT100</a> and <a href="https://en.wikipedia.org/wiki/Time-sharing">time-sharing operating systems</a>, such as <a href="https://en.wikipedia.org/wiki/History_of_Unix">UNIX</a> and <a href="https://en.wikipedia.org/wiki/OpenVMS">DEC TSS/8</a> became cheaper and more widespread. As multiple users began working on a central, time-shared computer, programmers moved from punched cards to files on disks. But this posed a new question: How do you version these files? What is the digital equivalent of organizing punched cards?</p><h4 id="the-creation-of-sccs">The creation of SCCS</h4><p>In 1972 <a href="https://en.wikipedia.org/wiki/Marc_Rochkind">Marc Rochkind</a> developed a version control system for IBM System/370 in <a href="https://en.wikipedia.org/wiki/SNOBOL">SNOBOL</a>. He rewrote it in C for UNIX a year later in 1973: <em>Thus, the first version control system, SCCS, was born.</em></p><p>SCCS could manage multiple versions of a file. Unlike modern source control systems, it lacked concepts like a repository or tracked files.</p><p>To conserve disk space, SCCS stored each version’s delta along with metadata like a change comment (now known as a commit message) and the change date. To store and retrieve new versions, programmers would ask SCCS to create a new <code>delta</code>, <code>get</code> a version or a combination of such as <code>delget</code><sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p><p>This sounds familiar? In principle, it is how most version control systems work today. However, SCCS has some very notable limitations.</p><h4 id="limitations">Limitations</h4><p>Firstly, it is <em>local-only</em>, meaning that SCCS does not include any way to exchange deltas between users. In an era of large, time-shared machines, this wasn’t necessary. Developers had accounts on central machines (like a <a href="https://en.wikipedia.org/wiki/PDP-11">PDP-11</a>) and worked independently or simply shared work folders with colleagues.</p><p>Secondly, SCCS was <em>single-file</em> only <sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. It tracked changes for one file at a time. Concepts like a repository of tracked files or atomic commits across multiple files didn’t exist yet.</p><p>Thirdly, to ensure single-writer access, SCCS used locking. A file under SCCS control was read-only on the disk until a user retrieved it for editing. If another user had the file checked out, SCCS would abort the operation. If no other user currently marked the file for editing, the file would become writable on disk and the user could modify it. Merging did not yet exist.</p><p>SCCS exposed the storage terminology such as <code>delta</code> directly to the user. For instance, to create a new version of a file, one would use the command <code>sccs delta</code>. Modern terms like repository, commit, and checkout didn’t exist then.</p><h4 id="a-quick-example">A quick example</h4><p>Let’s take a quick look how one would use SCCS. In the following example, we put the file <code>main.c</code> into SCCS control and retrieve it for editing.</p><div><pre tabindex="0"><code data-lang="sh"><span><span>$ mkdir SCCS <span># Create the file in SCCS</span>
</span></span><span><span>$ sccs create main.c <span># Get the file and mark it for edit</span>
</span></span><span><span>$ sccs get -e main.c <span># Checking the delta</span>
</span></span><span><span>$ vi main.c
</span></span><span><span>$ sccs delta main.c
</span></span><span><span>comments? ...
</span></span></code></pre></div><h4 id="storage">Storage</h4><p>The file format for storing deltas is one of the most fascinating bits of SCCS.</p><p>It uses <a href="https://en.wikipedia.org/wiki/Interleaved_deltas">Interleaved Deltas</a> (or weaves), storing changed lines and their information next to the original lines in plain text. Hence, the deltas are <strong>weaved</strong> into the file. For example, let’s take a file</p><pre tabindex="0"><code>foo
bar
</code></pre><p>And modify it to</p><pre tabindex="0"><code>bar
baz
</code></pre><p>In modern diff terms:</p><div><pre tabindex="0"><code data-lang="diff"><span><span><span>--- a/test
</span></span></span><span><span><span></span><span>+++ b/test
</span></span></span><span><span><span></span><span>@@ -1,2 +1,2 @@
</span></span></span><span><span><span></span><span>-foo
</span></span></span><span><span><span></span> bar
</span></span><span><span><span>+baz
</span></span></span></code></pre></div><p>The SCCS file containing the weaved deltas for this might look something along the lines of <sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>:</p><pre tabindex="0"><code> ^AI 1
 ^AD 2
 foo
 ^AE 2
 bar
 ^AI 2
 baz
 ^AE 2
 ^AE 1
</code></pre><p>So the first line <code>^AI 1</code>, <code>^AD 2</code> means at version 1 the line was inserted and version 2 it was deleted. The line content is <code>foo</code>.</p><p>This has distinct advantages for attributing lines to changes, as well as uniform retrieval time for any revision. The disadvantage is fairly inefficient storage and as well as potentially fairly poor performance in practice, as you will have to read all revisions of a file to checkout a revision. While most SCMs later on use different storage algorithms, we will see interleaved deltas being used again in modern version control systems.</p><h4 id="implementations">Implementations</h4><p>The original SCCS would go on to become widely spread across UNIX systems, but its original version stayed proprietary throughout.</p><p>Eric Allman reimplemented SCCS in 1980 at the University of California Berkley. This versions made was later maintained by AT&amp;T and Sun Microsystems before it made it’s way to <a href="https://codeberg.org/schilytools/schilytools/src/branch/master/sccs">shilytools</a> where it resides today under the CDDL license. Most modern UNIX and UNIX-like distributions such as Solaris and FreeBSD, still offer this version as a package.</p><p>The GNU projects maintains a reimplementation of SCCS as <a href="https://www.gnu.org/software/cssc/">CSSC</a> under the GPL.</p><h4 id="legacy">Legacy</h4><p>While very few people use SCCS nowadays, it influence on modern version control systems can’t be denied. Ideas such as storing deltas, adding comments to commits, specific folders for storing versions (<code>SCCS/</code>) and expanding version IDs during checkout will remain used in many version control systems.</p><h3 id="1982-rcs">1982: RCS</h3><p>SCCS was the sole version control system for the first nine years after its creation. In 1982, <a href="https://en.wikipedia.org/wiki/Walter_F._Tichy">Walter Tichy</a> developed <a href="https://en.wikipedia.org/wiki/Revision_Control_System">RCS</a> at the Purdue University. It’s design was published as a paper <a href="https://dl.acm.org/doi/10.5555/800254.807748">“Design, Implementation, and Evolution of a Revision Control System”</a> in the Proceedings of the 6th International Conference on Software Engineering (ICSE’82).</p><p>In many ways it is similar to SCCS. It operates on one file at a time, with <a href="#Limitations">similar limitations</a>. However, it had one trick up his sleeves: <strong>Reversed Deltas</strong>.</p><h4 id="reversed-separated-deltas">Reversed, Separated Deltas</h4><p>The first difference of RCS to SCCS, is that RCS stored <strong>separate deltas</strong>. Instead of interweaving the deltas into the file like SCCS did, RCS would store the full file for one revision, and deltas as generated by <a href="https://man7.org/linux/man-pages/man1/diff.1.html"><code>diff</code></a> (notable diff didn’t exist when SCCS was written) for following revisions.</p><p>The second difference, was to store <strong>deltas in reverse order</strong>. The most recent stored revision consists of the full file format. Other revisions store the delta going from the next version to the current version, forming a delta-chain from the newest revision to the older revision.</p><p>This has distinct advantages. In the most common case, of checking out the most recent version, RCS requires only to read the last version and stream the content directly to a file, making checkout much faster. When writing a new revision, RCS must only calculate the difference between the new version and the most recently stored version and overwrite the last stored version with the delta and then append the new full file. In contrast, SCCS needs to always rewrite the whole file when a new version is inserted, and needs to read the whole file if any version is retrieved. On the flip side, retrieving older versions can be slower in RCS than in SCCS, where restoring any version takes always the same time.</p><p>Let’s take a look at a RCS file. Note that all RCS files are usually stored as the filename with an appended suffix <code>,v</code>. Binary data is generally stored with each version being gzipped:</p><p>An example:</p><pre tabindex="0"><code data-lang="rcs">1.2
log
@Hello world.
@
text
@#include &lt;stdio.h&gt;

int main(void) {
    printf(&#34;hello world\n&#34;);
    return 0;
}

@


1.1
log
@Initial revision
@
text
@d1 4
a4 1
int main() {
@
</code></pre><p>We can see that the most recent version <code>1.2</code> contains the full text. Version <code>1.1</code> contains the reversed delta information to go from <code>1.2</code> to <code>1.1</code>. Delta information is <em>line based</em>. The string <code>d1 4</code> means starting at line 1 delete 4 lines. <code>a4 1 ...</code>, means starting at line 4, add the following line. If we follow these commands, we get the original version<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>:</p><h4 id="claimed-improvements-over-sccs">Claimed improvements over SCCS</h4><p>Tichy’s original paper from 1982 claimed a few improvements over SCCS:</p><p>Firstly, the results in checkout and checking operations were much faster for the common case (e.g. most recent revision), but showed slowness checking out older revisions (as expected).</p><p>Secondly, it claimed that the UX of SCCS at the time, where one has to operate on the version files, rather than the checked out files (e.g. <code>sccs delta s.main.c</code>), was a common pinpoint among programmers. Hence RCS supported specifying either the checked out file or the version file.</p><p>Thirdly, RCS improved on the lock mechanism employed by both SCCS and RCS to ensure a single writer at a time, by allowing unprivileged users to overwrite a lock, and sending a local email the the holder of the lock, when a lock was broken. SCCS in contrast required privileged users to break the lock, and did not leave any paper trail.</p><p>Notable, the initial version of RCS did not include checksumming, branching or tagging, which SCCS at the time already supported. Tichy felt that some of these features were unnecessary, but already foresaw that RCS will eventually gain these features (which of course it did).</p><blockquote><p><em>In all fairness, we need to point out that SCCS offers
many features that are missing from RCS. For example,
SCCS performs complete checksumming, and provides
flags that control the creation of branches and the
range of revision numbers. We feel that many of these
features are unnecessary and contribute to the bulkiness of SCCS. We realize, however, that some of these
features may creep into RCS eventually.</em></p><p>– Design, Implementation, and Evolution of a Revision Control System</p></blockquote><h4 id="example">Example</h4><p>Now let’s take a look at a common usage. We checkout our <code>main.c</code> from an existing RCS file. We lock it during checkout so we can write it (without, RCS would check it out read-only). We edit it and check in a new version. Lastly, we are done and unlock the file.</p><pre tabindex="0"><code>$ co -l main.c
main.c,v  --&gt;  main.c
revision 1.1 (locked)
done
$ ci -l main.c
main.c,v  &lt;--  main.c
new revision: 1.2; previous revision: 1.1
enter log message, terminated with single &#39;.&#39; or end of file:
&gt;&gt; update.
&gt;&gt; ^D
done
$ co -u main.c 
main.c,v  --&gt;  main.c
revision 1.2 (unlocked)
writable main.c exists; remove it? [ny](n): y
done
</code></pre><h4 id="implementations-1">Implementations</h4><p>The original implementation of RCS was distributed as 4.3 BSD but the license <a href="https://en.wikipedia.org/wiki/Revision_Control_System#cite_note-11">prohibited redistribution without written permission from Tichy</a>. <a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution#4.3BSD">4.3BSD-Reno</a> would contain RCS with a permissive license, BSD like license. In the running up to RCS 4.3, Tichy moved the project to GNU, changing the license to GPL <sup id="fnref1:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p><p>The <a href="https://git.savannah.gnu.org/cgit/rcs.git/commit/?h=p&amp;id=2a07671f9ce40cfab440c40c465357945f06aef2">first commit</a> from November 18th, 1989 reads:</p><blockquote><p>Import RCS 4.3 from <a href="ftp://ftp.cs.purdue.edu/pub/RCS/">ftp://ftp.cs.purdue.edu/pub/RCS/</a></p></blockquote><p>GNU RCS tracks it history all the way back to the original RCS from 1982. GNU RCS was actively maintained by <a href="https://savannah.gnu.org/users/ttn">Thien-Thi Nguyen</a>, until his <a href="https://lists.gnu.org/archive/html/emacs-devel/2023-09/msg00713.html">death</a> in October 2022. The project is unmaintained at the moment.</p><p>OpenRCS maintains a <a href="https://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.bin/rcs/">reimplementation of RCS</a> under the MIT license. It is distributed as part of OpenBSD since version 4.0. FreeBSD and NetBSD ship GNU RCS as part of their packages/ports.</p><h4 id="legacy-1">Legacy</h4><p>RCS is one of the most influential source control systems to this day. Systems like CVS and Perforce use RCS file formats to this day. Terminology such as commit, checkout, log are common source control terminology. RCS’s keyword expansion syntax ($Id$, $Date$) will find widespread adoption in other version control systems. Most modern source control system such as Git or Mercurial use similar separated-delta techniques.</p><h3 id="conclusion">Conclusion</h3><p>I hope you enjoyed this little overview of SCCS and RCS. In the next blog post we will take a look at the 1990s where the first centralized source control systems appear. They will allow multiple users to work on source code concurrently and exchange commits via the network.</p><p>If you have corrections, suggestions or just want to say thanks, please send a mail to blog at (this domain).</p></div></div>
  </body>
</html>
