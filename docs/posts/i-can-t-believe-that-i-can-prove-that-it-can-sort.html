<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.adacore.com/i-cant-believe-that-i-can-prove-that-it-can-sort">Original</a>
    <h1>I can‚Äôt believe that I can prove that it can sort</h1>
    
    <div id="readability-page-1" class="page"><div><div><p dir="ltr">Sorting algorithms are to computer science what ‚ÄúHello World!‚Äù is to programming. A way for beginners to get their hands dirty. Which also means that most programmers don‚Äôt write ‚ÄúHello World!‚Äù programs past their studies, and computer scientists don‚Äôt look at sorting algorithms past their PhD.</p><p dir="ltr">Which made it surprising that a new ‚Äúinteresting‚Äù sorting algorithm was published at the end of 2021, whose appeal drew attention from both computer scientists and programmers. Here is the algorithm in full details:</p></div><figure>
<a href="https://blog.adacore.com/uploads/photos/Screenshot-from-2022-06-22-11-25-54.png">
<img src="https://blog.adacore.com/uploads/photos/_1800xAUTO_crop_center-center_none/Screenshot-from-2022-06-22-11-25-54.png" alt="" width="1800" height="805"/>
</a></figure><div><p dir="ltr">As an expert user of Ada, and an anecdotal user of SPARK, one of us (Lionel) took it as a challenge to try some functional proof with SPARK. Despite a hopeful start, this ended up badly. As a SPARK expert thus contacted to help with the challenge, one of us (Yannick) took it as a way to show how functional proof should be approached in SPARK. Including some false starts, this ended up well (and under an hour). This is the story of this challenge, and the tips we think are important to share with those who aim at functional proof with SPARK.</p><p dir="ltr"><em>I am Lionel, I‚Äôll start.</em></p><p dir="ltr">I recently stumbled upon a <a href="https://mobile.twitter.com/chordbug/status/1523016806348304385" target="_blank" rel="noreferrer noopener">tweet about a paper on an ‚Äúunbelievable‚Äù sorting algorithm</a>:</p></div><figure>
<a href="https://blog.adacore.com/uploads/photos/Screenshot-from-2022-06-22-11-31-26.png">
<img src="https://blog.adacore.com/uploads/photos/_1800xAUTO_crop_center-center_none/Screenshot-from-2022-06-22-11-31-26.png" alt="" width="1800" height="1424"/>
</a></figure><div><p dir="ltr">I read the paper intro, and couldn‚Äôt realize what was wrong with it instinctively, but quickly seeing all the replies to the tweet brought back memories of learning programming, writing cool (at the time) programs for years, and then later on getting some formal computer science education.</p><p dir="ltr">I dug up my first ever sorting algorithm. I‚Äôd used it in a silly 3D renderer that I‚Äôd implemented in 2000 on a Pentium 75, all implemented from scratch from what some might call nowadays ‚Äúfirst principles‚Äù (i.e. I had absolutely no clue what I was doing). In a 3D renderer, once you‚Äôve got your list of triangles to paint, and the direction of the camera set up, you want to z-sort the triangles so you can run the <a href="https://en.wikipedia.org/wiki/Painter%27s_algorithm" target="_blank" rel="noreferrer noopener">Painter algorithm</a> (Wikipedia here is very generous, and calls it ‚Äúdepth-sort algorithm‚Äù). I needed a sort algorithm and I had no books, just my C compiler, SDL headers and some old French magazines about setting up VESA‚Ä¶</p><p dir="ltr">So I built one. I mean I built this one, and to me it looked like it worked. If you look at <a href="https://t.co/FJ9mLFyO7X" target="_blank" rel="noreferrer noopener">this video</a>, it makes sense, somehow, especially for small array sizes, for a beginner that has no notion of smart sorting, big-O notation and no internet. My ‚Äúunit tests‚Äù (generous term again) from the time show how little I understood about testing because they seem to be chosen <em>for </em>this algorithm (to validate this implementation and not sorting in general).</p><p dir="ltr">I‚Äôd put it together without videos and all the <a href="https://mobile.twitter.com/Anka213/status/1446366108705902594" target="_blank" rel="noreferrer noopener">fancy</a> <a href="https://mobile.twitter.com/akivaw/status/1523267967517364227" target="_blank" rel="noreferrer noopener">visualizations</a> <a href="https://mobile.twitter.com/LisaDeBruine/status/1523597253042008066" target="_blank" rel="noreferrer noopener">one can use</a> when learning sorting algorithms, and I didn‚Äôt think about this code for years afterwards.</p><p dir="ltr">When I later learned Ada, first year of formal studies, I needed a sort function for a project and I just ported that algorithm and went with it (and I lived with it until I some month later I had to sort 2 millions entries and after a night at 100% CPU with almost no progress, I caved and cracked my copy of Sedgewick and started learning the science and not just the hacking-stuff-up).</p><p dir="ltr">Paraphrasing the old code, it looked very simple:</p></div><pre><code>procedure Stupid_Sort
is
   type A_Type is array (Natural range 1 .. 5) of Natural;

   procedure Sort (A : in out A_Type)
   is
   begin
      for I in A&#39;Range loop
         for J in A&#39;Range loop
            if A (I) &lt; A (J) then
               declare
                  Tmp : constant Natural := A (I);
               begin
                  A (I) := A (J);
                  A (J) := Tmp;
               end;
           end if;
         end loop;
      end loop;
   end Sort;

   A : A_Type;
begin
   for I in A&#39;Range loop 
     A (I) := A&#39;Last - I + 1;
   end loop;

   Sort (A);
end Stupid_Sort;</code></pre><div><p dir="ltr"><strong>Tip: Start small (simple small data types, a single subprogram)<br/></strong></p><p dir="ltr">When I read the tweet and all the replies, I admit I felt compassion for old me (well, young me), even though I saw other people admitting they‚Äôd come up with this sorting algorithm once upon a time. I wondered whether applying modern tech (other than having a sorting algorithm in the standard library and knowing about it‚Ä¶) blindly would comfort such a developer in his or her ‚Äúwrong‚Äù version. I decided to launch<em> myself </em>a challenge: proving the algorithm using SPARK, <em>without looking at the proof in the paper</em>. Should be easy enough, right (famous last words)?</p></div><figure>
<a href="https://blog.adacore.com/uploads/photos/gamechanger.png">
<img src="https://blog.adacore.com/uploads/photos/_1800xAUTO_crop_center-center_none/gamechanger.png" alt="" width="1800" height="728"/>
</a></figure><div><p dir="ltr">I fired up the ultimate Ada IDE (vim) and just copy-pasted the old code, compiled it (gnatmake -gnatA stupid_sort.adb) and ran it (through gdb to get the content of A after Sort returns). It works, for that input.</p><p dir="ltr"><strong>Tip: Start with a passing test</strong></p><p dir="ltr">Then I wanted to prove that Sort sorts all possible arrays so I added the SPARK pixie dust:</p></div><pre><code>procedure Stupid_Sort with SPARK_Mode =&gt; On</code></pre><p>and the necessary post-condition for Sort:</p><pre><code>procedure Sort (A : in out A_Type)
   with Post =&gt; (for all J in A&#39;First .. A&#39;Last - 1 =&gt; A (J) &lt;= A (J + 1))</code></pre><div><p dir="ltr">Which reads:</p><ul><li dir="ltr"><p dir="ltr">when the Sort procedure returns</p></li><li dir="ltr">for every element A(J) of the array (except the last one)<ul><li dir="ltr"><p dir="ltr">the element A(J) is smaller or equal to the next element A(J+1)</p></li></ul></li></ul><p dir="ltr">Then I created a GPR project to run GNATprove:</p></div><pre><code>project Stupid_Sort is

   for Main use (&#34;stupid_sort.adb&#34;);
   for Source_Files use (&#34;stupid_sort.adb&#34;);

   package Compiler is
      for Switches (&#34;Ada&#34;) use
           (&#34;-gnata&#34;,     -- enable assertions and runtime checks
            &#34;-gnat2022&#34;,  -- for newest forms of expressions in Ada 2022
            &#34;-g&#34;, &#34;-O0&#34;); -- for debugging
    end Compiler;

end Stupid_Sort;</code></pre><p dir="ltr">And on I went:</p><pre><code>&gt; gnatprove -Pstupid_sort.gpr -j0
Phase 1 of 2: generation of Global contracts ...
Phase 2 of 2: flow analysis and proof ...

stupid_sort.adb:6:58: medium: postcondition might fail, cannot prove A (J) &lt;= A (J + 1)
    6 |     with Post =&gt; (for all J in A&#39;First .. A&#39;Last - 1 =&gt; A (J) &lt;= A (J + 1))
      |                                                         ^~~~~~~~~~~~~~~~~</code></pre><p dir="ltr">Which was kind of expected, but there‚Äôs a --level knob, if you‚Äôre lazy like me you‚Äôll just try it whenever you find something GNATprove balks at (sadly it only goes to 4, you can‚Äôt <a href="https://en.wikipedia.org/wiki/Up_to_eleven">turn it to eleven</a>‚Ä¶ yet):</p><pre><code>&gt; gnatprove -Pstupid_sort.gpr -j0 --level=2
Phase 1 of 2: generation of Global contracts ...
Phase 2 of 2: flow analysis and proof ...</code></pre><div><p dir="ltr">And‚Ä¶ GNATprove managed to prove the functional correctness of that postcondition!</p><p dir="ltr"><strong>Tip: Use proof automation (and turn up the knob)</strong></p><p dir="ltr">Let‚Äôs check the synthesis of what GNATprove did (the gnatprove.out file):</p></div><pre><code>Summary of SPARK analysis
=========================

-------------------------------------------------------------------------------------------
SPARK Analysis results        Total       Flow   CodePeer    Provers   Justified   Unproved
-------------------------------------------------------------------------------------------
Data Dependencies                 .          .          .          .           .          .
Flow Dependencies                 .          .          .          .           .          .
Initialization                    1          1          .          .           .          .
Non-Aliasing                      .          .          .          .           .          .
Run-time Checks                   .          .          .          .           .          .
Assertions                        .          .          .          .           .          .
Functional Contracts              1          .          .     1 (Z3)           .          .
LSP Verification                  .          .          .          .           .          .
Termination                       .          .          .          .           .          .
Concurrency                       .          .          .          .           .          .
-------------------------------------------------------------------------------------------
Total                             2    1 (50%)          .    1 (50%)           .          .


max steps used for successful proof: 11967

Analyzed 1 unit
in unit stupid_sort, 2 subprograms and packages out of 2 analyzed
  Stupid_Sort at stupid_sort.adb:1 flow analyzed (0 errors, 0 checks, 0 warnings and 0 pragma Assume statements) and proved (0 checks)
  Stupid_Sort.Sort at stupid_sort.adb:5 flow analyzed (0 errors, 0 checks, 0 warnings and 0 pragma Assume statements) and proved (1 checks)</code></pre><div><p dir="ltr">Here GNATprove tells us it managed to prove our postcondition (a functional contract) with Z3. So it works! SPARK can prove the algorithm! Victory? Not so fast.</p><p dir="ltr">Let‚Äôs try to go for larger array sizes, e.g. 1 .. 10. Now after 16 seconds, GNATprove goes back to:</p></div><pre><code>stupid_sort.adb:6:58: medium: postcondition might fail, cannot prove A (J) &lt;= A (J + 1)
    6 |     with Post =&gt; (for all J in A&#39;First .. A&#39;Last - 1 =&gt; A (J) &lt;= A (J + 1))
      |                                                         ^~~~~~~~~~~~~~~~~</code></pre><div><p dir="ltr">Turning the level up to the max (--level=4) doesn‚Äôt get us better results, but takes more than 3 minutes, for the same result. So back to square one.</p><p dir="ltr">The first reflex I had (wrongly) ingrained was to try and state obvious things through assertions. Keep in mind I didn‚Äôt want to read the paper, with the many juicy proofs and insights it might contain. So there I went:</p><p dir="ltr">First I put the swap code in its own procedure:</p></div><pre><code>procedure Swap (A : in out A_Type; I : A_Index_Type; J : A_Index_Type)
  with Post =&gt; A (J) = A&#39;Old (I) and A (I) = A&#39;Old (J)
is
   Tmp : constant Natural := A (I);
begin
   A (I) := A (J);
   A (J) := Tmp;
end Swap;</code></pre><div><p dir="ltr">‚Ä¶ which (spoiler) wasn‚Äôt a very good idea (see ‚Äúframing conditions‚Äù, later). I didn‚Äôt get better results, so I went on adding assertions.</p><p dir="ltr">At some point I ended up with lots of tautological asserts, and it felt more and more like I <strong>really</strong> didn‚Äôt understand what the problem was.</p></div><pre><code>if A (I) &lt; A (J) then
   pragma Assert (A (I) &lt; A (J)); -- *that* should always be true, right?
   Swap (A, I, J);
   pragma Assert (A (I) &gt;= A (J)); -- *that* too, no?
end if;
pragma Assert (A (I) &gt;= A (J)); -- doubting everything‚Ä¶</code></pre><div><p dir="ltr">And still, no progress on the proof of the postcondition.</p><p dir="ltr"><strong>Tip: Avoid the Assertocalypse</strong></p><p dir="ltr">The message from GNATprove was hinting at a Loop_Invariant:</p></div><pre><code>stupid_sort.adb:22:14: medium: postcondition might fail
   22 |     Post =&gt; Sorted (A, A&#39;First, A&#39;Last)
      |               ^~~~~~~~~~~~~~~~~~~~~~~~~~
  possible fix: loop at line 25 should mention A in a loop invariant
   25 |      for I in A&#39;range loop
      |                       ^ here</code></pre><p>So I looked at the videos of the sort again, and came up with two (very wrong) loop invariants:</p><pre><code>pragma Loop_Invariant (if I &gt; A&#39;First then A (I) &gt;= A (A&#39;First));
pragma Loop_Invariant (for all K in A&#39;First .. I - 1 =&gt; A(I) &gt;= A(K));</code></pre><p dir="ltr">This made GNATprove very mad:</p><pre><code>stupid_sort.adb:16:59: medium: postcondition might fail, cannot prove A (J) &lt;= A (J + 1)
   16 |      with Post =&gt; (for all J in A&#39;First .. A&#39;Last - 1 =&gt; A (J) &lt;= A (J + 1))
      |                                                          ^~~~~~~~~~~~~~~~~

stupid_sort.adb:28:53: medium: loop invariant might not be preserved by an arbitrary iteration, cannot prove A (I) &gt;= A (A&#39;first)
   28 |         pragma Loop_Invariant (if I &gt; A&#39;First then A (I) &gt;= A (A&#39;First));
      |                                                    ^~~~~~~~~~~~~~~~~~~

stupid_sort.adb:29:66: medium: loop invariant might fail in first iteration, cannot prove A(I) &gt;= A(K)
   29 |         pragma Loop_Invariant (for all K in A&#39;First .. I - 1 =&gt; A(I) &gt;= A(K));
      |                                                                 ^~~~~~~~~~~

stupid_sort.adb:29:66: medium: loop invariant might not be preserved by an arbitrary iteration, cannot prove A(I) &gt;= A(K)
   29 |         pragma Loop_Invariant (for all K in A&#39;First .. I - 1 =&gt; A(I) &gt;= A(K));</code></pre><div><p dir="ltr"><strong>Tip: Understand tool messages</strong></p><p dir="ltr">That‚Äôs when I decided to call up my local SPARK friend Yannick, to teach me about loop invariants, and how you prove such an algorithm with SPARK.</p><p dir="ltr"><strong>Tip: Have an expert on call</strong></p><p dir="ltr"><em>I am Yannick, I‚Äôll jump in. </em></p><p dir="ltr">Let‚Äôs return first to the addition of the Swap procedure in Lionel‚Äôs code. Remember the postcondition he wrote for Swap:</p></div><pre><code>procedure Swap (A : in out A_Type; I : A_Index_Type; J : A_Index_Type)
   with Post =&gt; A (J) = A&#39;Old (I) and A (I) = A&#39;Old (J)</code></pre><div><p dir="ltr">That‚Äôs true, but not sufficient. Indeed, all the provers know about variable A after a call to Swap (since this parameter is modified in Swap) is what the postcondition of Swap says about it. And‚Ä¶ it says nothing about all the values of A outside of indexes I and J! So there is no chance that GNATprove will be able to prove our sorting code.</p><p dir="ltr">This need to identify what has changed during a call with enough precision is known as the <a href="https://docs.adacore.com/live/wave/spark2014/html/spark2014_ug/en/source/how_to_write_loop_invariants.html#automatically-generated-loop-invariants">frame condition</a>, and it‚Äôs a typical beginner‚Äôs mistake to forget it. Here, a suitable postcondition would be:</p></div><pre><code>procedure Swap (A : in out A_Type; I : A_Index_Type; J : A_Index_Type)
   with Post =&gt; A = (A‚ÄôOld with delta I =&gt; A(J)‚ÄôOld, J =&gt; A(I)‚ÄôOld)</code></pre><div><p dir="ltr">which states exactly the content of A after a call to Swap.</p><p dir="ltr"><strong>Tip: Beware the frame condition</strong></p><p dir="ltr">Ironically, you get the same result if you don‚Äôt specify a postcondition at all on Swap, because GNATprove will inline the call in that case! Inlining of calls and unrolling of loops are powerful techniques for automating the proof of programs, without the need for a user to specify contracts and loop invariants. But as usual with automation, the risk is that, when the situation gets more complex, automation fails and the user is left with a complex situation that she does not understand (a.k.a. the <em>curse of automation</em>). Loop unrolling explains why Lionel was initially &#34;feeling lucky!&#34; with Z3 proving the postcondition of Sort for small array sizes, without having to write loop invariants. But the curse of automation stroke back when increasing the array size, as the loops are not unrolled anymore, or the unrolling leads to unmanageable formulas for automatic provers.</p><p dir="ltr">One way to remain aware of the choices in terms of automation made by GNATprove is to use the switch --info which outputs such information:<strong><br/></strong></p></div><pre><code>stupid_sort.adb:11:14: info: local subprogram &#34;Sort&#34; only analyzed in the context of calls
  add a contract to analyze it separately from calling contexts
stupid_sort.adb:33:21: info: unrolling loop
stupid_sort.adb:39:04: info: analyzing call to &#34;Sort&#34; in context
stupid_sort.adb:39:04: info: in inlined body at line 18
  unrolling loop
stupid_sort.adb:38:04: info: in inlined body at line 17
  unrolling loop</code></pre><div><p dir="ltr"><strong><strong>Tip: Use the right tool configuration (and switches!) </strong></strong></p><p dir="ltr">Contrary to the heroic (masochistic?) Lionel, I did not aim at rediscovering how the algorithm worked by looking at the code. Instead, I took the time to read the short article, and to convince myself that I understood why it worked.</p><p dir="ltr"><strong>Tip: Understand the code that you want to prove</strong></p><p dir="ltr">Well, at least I thought I understood the algorithm. More on that later.</p><p dir="ltr">I started by defining suitable types for the index of the array, one being slightly larger than the other, in order to accommodate empty ranges of values (when we start the iteration):</p></div><pre><code>type I_Type_Base is new Integer range 0 .. 5;
subtype I_Type is I_Type_Base range 1 .. I_Type_Base&#39;Last;
type A_Type is array (I_Type) of Natural;</code></pre><div><p dir="ltr"><strong>Tip: Define suitable types with the tightest constraints</strong></p><p dir="ltr">Types are the best specifications, because you get their properties everywhere a value of the type is used, without having to repeat the properties in assertions, preconditions, etc.</p><p dir="ltr">Then, I defined expression functions for the important properties used in the article: that the array over a given range is sorted, and that the maximum of the array over a given range is at a given index.</p></div><pre><code>function Sorted (A : A_Type; From : I_Type; To : I_Type_Base) return Boolean 
is
   (for all I in From .. To =&gt;
      (for all J in I .. To =&gt;
         A(I) &lt;= A(J)));

function Is_Max (M : I_Type; A, From, To : I_Type) return Boolean 
is
  (for all I in From .. To =&gt; A (I) &lt;= A (M))
with
  Pre =&gt; M in From .. To;</code></pre><div><p dir="ltr"><strong>Tip: Define suitable expression functions for important properties</strong></p><p dir="ltr">In general, it‚Äôs better to give a name to important properties that will be used multiple times in specifications, assertions and ghost code, because it makes the specification and proof more readable, and because it can help automatic provers. Here, it‚Äôs all the more helpful for automatic provers because it isolates quantifiers ‚Äúfor all‚Äù.</p><p dir="ltr">The form of these properties is also quite important. Instead of using the natural expression of sortedness as ‚Äúevery element is less or equal to the next‚Äù, I have expressed it as the equivalent transitive closure of this property, that is, ‚Äúevery element is less or equal to every element that follows‚Äù. That makes a big difference for automatic provers, as establishing the latter from the former requires inductive reasoning, which automatic provers are poor at, while the former is immediately deduced from the latter.</p><p dir="ltr">Similarly, I could have defined Is_Max as a function that takes as input the maximum Max of the array over a given range, instead of the index M of the maximum, and computes the conjunction:</p></div><pre><code>(for all I in From .. To =&gt; A (I) &lt;= Max)
   and then
(for some M in From .. To =&gt; Max = A (M))</code></pre><div><p dir="ltr">But this uses an existential quantification ‚Äúfor some‚Äù which is hard to establish for automatic provers, as this requires exhibiting the ‚Äúwitness‚Äù index M here. So I went for the definition that did not require an existential quantification, by passing the index M as parameter instead.</p><p dir="ltr"><strong>Tip: Use idiomatic definitions of properties that help automatic provers</strong></p><p dir="ltr">With these definitions, the loop invariant of the external loop can be expressed very easily, based on the properties of that loop described in the article:</p></div><pre><code>pragma Loop_Invariant (Sorted (A, A&#39;First, I));
pragma Loop_Invariant (Is_Max (I, A, A&#39;First, A&#39;Last));</code></pre><p>It gets a bit trickier for the internal loop, as the explanations in the article in terms of values of K before and after I cannot be directly translated into loop invariants. Plus the article talks of going from index I to index I+1 while the code goes from index I-1 and index I (when expressing the loop invariant). That‚Äôs where I tried out various loop invariants in my head, with the support of pen-and-paper to understand how the algorithm really worked. And it went üí° the array stayed sorted at every iteration of the internal loop for all indexes lower than I!</p><pre><code>pragma Loop_Invariant (Sorted (A, A&#39;First, I));</code></pre><p dir="ltr">And during the internal loop, the maximum value over the whole array was either located at index I-1 (at the beginning of the iteration) or at index I (after getting to iteration J = I-1):</p><pre><code>pragma Loop_Invariant
   (declare
       M : constant I_Type := (if J &lt; I then I-1 else I);
    begin
       Is_Max (M, A, A&#39;First, A&#39;Last));</code></pre><div><p dir="ltr"><strong>Tip: Use pen-and-paper to really understand the code that you want to prove</strong></p><p dir="ltr">It‚Äôs all too easy to ‚Äúunderstand‚Äù that something works by going through the steps of an explanation/demonstration (like in the article), without being able to really understand why it works. Proof requires us to understand why it works.</p><p dir="ltr">As GNATprove could not prove the loop invariant of the inner loop, even at level 4 (all provers get called at that level, with a substantial timeout of 60 seconds per check), I tried running the program through its test with assertions enabled, and‚Ä¶ the loop invariant failed at runtime! No wonder GNATprove could not prove it.</p><p dir="ltr"><strong>Tip: Execute assertions during tests to help debug them</strong></p><p dir="ltr">Just looking at the failing loop invariant, I realized that it could not be true during the first iteration of the loop, where we have not yet identified the maximum value of the array. So I added a special case for I=A‚ÄôFirst:</p></div><pre><code>pragma Loop_Invariant
  (if I = A&#39;First then
     Is_Max (I, A, A&#39;First, J)
   else
      (declare
          M : constant I_Type := (if J &lt; I then I-1 else I);
       begin
          Is_Max (M, A, A&#39;First, A&#39;Last)));</code></pre><div><p dir="ltr">But the test was still failing at runtime! This time, I ran the test in the debugger (gdb inside GNAT Studio), to display values of all variables when hitting the failing loop invariant. That was a case of off-by-one error, the test ‚ÄúJ &lt; I‚Äù in the definition of constant M should be ‚ÄúJ &lt; I-1‚Äù. With that, the test was running without error.</p><p dir="ltr"><strong>Tip: Debug failing assertions by running tests with assertions in the debugger</strong></p><p dir="ltr">I reran GNATprove on the code. It reported cases of runtime errors when calling functions Sorted/Is_Max, which I fixed. But GNATprove could still not prove the loop invariant of the internal loop stating that A remained sorted from A‚ÄôFirst to I-1. I read again the explanations in the article, which confirmed that it was true. Yet it was not proved. So I looked at the code, to see how the loop invariant at iteration J can be deduced from the loop invariant at iteration J-1 and the execution of the current iteration. And it was not provable! Because we were missing the information that, up to value J=I-1, the value at index I is greater than all values seen so far:</p></div><pre><code>pragma Loop_Invariant
   (if J &lt; I then
      (for all K in A&#39;First .. J =&gt; A(K) &lt;= A(I)));</code></pre><div><p dir="ltr">Now, GNATprove proves the code easily (at level 2).</p><p dir="ltr"><strong>Tip: Debug failing loop invariants by reasoning inductively, from one iteration to the next</strong></p><p dir="ltr">All that remained was to generalize the array index type to range over all positive integers instead of the range 1..5, and to allow unconstrained arrays whose length is not known statically:</p></div><pre><code>type I_Type_Base is new Integer range 0 .. Integer&#39;Last;
subtype I_Type is I_Type_Base range 1 .. I_Type_Base&#39;Last;
type A_Type is array (I_Type range &lt;&gt;) of Natural;</code></pre><div><p dir="ltr">Because we‚Äôve used so far relative attributes A‚ÄôFirst/A‚ÄôLast instead of the equivalent magic numbers 0/5, the adjustments needed are minimal.</p><p dir="ltr"><strong>Tip: Use language features to facilitate the generalization of assertions and ghost code</strong></p><p dir="ltr">By reviewing the final code, I realized that the last loop invariant could be written without quantification, as we already get that the array is sorted up to index I-1:</p></div><pre><code>pragma Loop_Invariant (if J &lt; I then A(J) &lt;= A(I));</code></pre><div><p dir="ltr"><strong>Tip: Simplify ghost code once the program is proved </strong></p><p dir="ltr">That concludes with the functional proof of this program.</p><p dir="ltr">Or does it? We have not proved here that the result of sorting is a shuffling of the entry. This is <a href="https://docs.adacore.com/live/wave/spark2014/html/spark2014_ug/en/source/manual_proof.html#a-concrete-example-a-sort-algorithm">doable</a> with SPARK, but just‚Ä¶ not easy. In 99.9% of the cases, in practice you‚Äôd stop here because:</p><ul><li dir="ltr"><p dir="ltr">It is obvious from looking at the code to see that the result is a shuffling of the entry, as A is only modified by swapping two of its elements. So this can be verified by review easily.</p></li><li dir="ltr"><p dir="ltr">Doing it by proof brings not much more assurance than the review, but a high cost both for the initial proof and for maintenance of the contracts and lemmas as the code or the tools evolve.</p></li></ul><p dir="ltr"><strong>Tip: Don‚Äôt prove what you don‚Äôt need to prove</strong></p><p dir="ltr">To recap, we saw 18 tips that could greatly facilitate your use of proof with SPARK (or any similar program proof environment):</p><p dir="ltr"><strong>Tip: Start small (simple small data types, a single subprogram)<br/></strong><strong>Tip: Start with a passing test<br/></strong><strong>Tip: Use proof automation (and turn up the knob)<br/></strong><strong>Tip: Avoid the Assertocalypse<br/></strong><strong>Tip: Understand tool messages<br/></strong><strong>Tip: Have an expert on call<br/></strong><strong>Tip: Beware the frame condition<br/></strong><strong><strong>Tip: Use the right tool configuration (and switches!) </strong></strong><strong><br/></strong><strong>Tip: Understand the code that you want to prove<br/></strong><strong>Tip: Define suitable types with the tightest constraints<br/></strong><strong>Tip: Define suitable expression functions for important properties<br/></strong><strong>Tip: Use pen-and-paper to really understand the code that you want to prove<br/></strong><strong>Tip: Execute assertions during tests to help debug them<br/></strong><strong>Tip: Debug failing assertions by running tests with assertions in the debugger<br/></strong><strong>Tip: Debug failing loop invariants by reasoning inductively, from one iteration to the next<br/></strong><strong>Tip: Use language features to facilitate the generalization of assertions and ghost code<br/></strong><strong>Tip: Simplify ghost code once the program is proved <br/></strong><strong>Tip: Don‚Äôt prove what you don‚Äôt need to prove</strong></p><p dir="ltr">Here is the final code for our version of the Stupid Sort algorithm:<br/></p></div><pre><code>pragma Ada_2022;

procedure Stupid_Sort with SPARK_Mode =&gt; On
is
   type I_Type_Base is new Integer range 0 .. Integer&#39;Last;
   subtype I_Type is I_Type_Base range 1 .. I_Type_Base&#39;Last;
   type A_Type is array (I_Type range &lt;&gt;) of Natural;

   function Sorted (A : A_Type; From, To : I_Type_Base) return Boolean is
      (for all I in From .. To =&gt;
         (for all J in I .. To =&gt;
            A(I) &lt;= A(J)))
   with
     Pre =&gt; From in A&#39;Range
       and then To &lt;= A&#39;Last;

   function Is_Max (M : I_Type; A : A_Type; From, To : I_Type_Base) return Boolean is
     (for all I in From .. To =&gt; A (I) &lt;= A (M))
   with
     Pre =&gt; M in From .. To
       and then From in A&#39;Range
       and then To in A&#39;Range;

   procedure Sort (A : in out A_Type)
   with
     Post =&gt; (if A&#39;Length &gt; 0 then Sorted (A, A&#39;First, A&#39;Last))
   is
   begin
      for I in A&#39;range loop
         for J in A&#39;range loop
            if A(I) &lt; A(J) then
               declare
                  Tmp : constant Natural := A(I);
               begin
                  A (I) := A (J);
                  A (J) := Tmp;
               end;
            end if;

            pragma Loop_Invariant (if J &lt; I then A(J) &lt;= A(I));
            pragma Loop_Invariant (Sorted (A, A&#39;First, I-1));
            pragma Loop_Invariant
              (if I = A&#39;First then
                Is_Max (I, A, A&#39;First, J)
              else
                (declare
                   M : constant I_Type := (if J &lt; I-1 then I-1 else I);
                 begin
                   Is_Max (M, A, A&#39;First, A&#39;Last)));
         end loop;

         pragma Loop_Invariant (Sorted (A, A&#39;First, I));
         pragma Loop_Invariant (Is_Max (I, A, A&#39;First, A&#39;Last));
      end loop;
   end Sort;

   A : A_Type (1 .. 1000);
begin
   for I in A&#39;Range loop
     A (I) := Integer (A&#39;Last - I + 1);
   end loop;

   Sort (A);
end Stupid_Sort;</code></pre></div></div>
  </body>
</html>
