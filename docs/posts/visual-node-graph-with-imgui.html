<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gboisse.github.io/posts/node-graph/">Original</a>
    <h1>Visual Node Graph with ImGui</h1>
    
    <div id="readability-page-1" class="page"><article><div><div><p>I wanted my first post on this blog to be about the node graph system that I created for my personal graphics engine named ‚ÄúRogueEngine‚Äù.
I may talk about the engine itself in another post but for now I‚Äôd like to focus on its UI.</p><p>As a teaser, here‚Äôs a screenshot of the tool running our <a href="https://www.pouet.net/party.php?which=1550&amp;when=2023">Revision 2023</a> demo:</p><p><img src="https://gboisse.github.io/node-graph.jpg" alt="node-graph"/></p><h3 id="a-bit-of-background">A bit of background</h3><p>I started thinking about this project back in 2019 with the aim of releasing some PC demo productions.
I had heard of the <a href="https://en.wikipedia.org/wiki/Demoscene">demoscene</a> for the first time about four years earlier through some coworkers at Sony and it gradually grew on me to the point that I too wanted to participate.
I really wanted to be able to team up with artists and designers for making these rather than, say, other programmers or trying to complete a production on my own.
This seemed like a better way to reach a higher visual bar as well as being more entertaining overall. üôÇ</p><p>This translated in my mind to having an interface that anyone could use for interacting with and tweaking the content, although in retrospect, such a system comes in extremely handy for programmers too and I find myself increasingly using it for many purposes, such as research and experimentation.
Regardless, I started looking into interfaces for visual content creation, which were at the time both quite fascinating and mysterious to me having little to no experience with such systems.</p><p>I was initially not particularly fond of node graphs however, for mainly two reasons:</p><ul><li>Many of these systems seemed to be what I‚Äôd call ‚Äúcoding with nodes‚Äù; while it may be more visual, it isn‚Äôt fundamentally any simpler.</li><li>It can get real messy real fast.</li></ul><p><img src="https://gboisse.github.io/blueprint-from-hell.png" alt="blueprint-from-hell"/></p><p>So I started thinking about a node system that would <strong>not</strong> be ‚Äúcoding with nodes‚Äù.</p><h3 id="node-system">Node system</h3><p>Having little to no experience with node-based systems, I went ahead and looked at other software for inspiration.
Big sources of inspiration for me would be software such as <a href="https://www.blender.org/">Blender</a>, <a href="https://www.notch.one/">Notch</a>, and <a href="https://godotengine.org/">Godot</a>.
In particular, I was wondering how to create a system that‚Äôd be both easy to use and expressive enough to allow the creation of interesting and emergent effects rather than simply ticking available engine features on or off‚Ä¶</p><p>Towards the end of 2019, something somewhat cliked in my mind;
I‚Äôd design the system to have only two types of nodes (okay, three) and they‚Äôd work like this:</p><ul><li>The <strong>root node</strong> from which the graph traversal would start at runtime.</li><li>The <strong>data node</strong> representing a piece of data of a given type.</li><li>The <strong>component node</strong> that can be attached to a data node to modify it.</li></ul><p><img src="https://gboisse.github.io/node-types.png" alt="node-types"/></p><p>I could have some ‚Äúgeometry data node‚Äù being nothing more than an index and a vertex buffer (plus some bounding box and probably other things‚Ä¶) while a ‚Äúcomponent node‚Äù connected to it would act as some kind of vertex shader that could be used for displacement purposes.</p><p>Similarly, a ‚Äúshading data node‚Äù could represent a standard material while a ‚Äúcomponent node‚Äù would be some piece of code to be injected into the fragment shader for various per-pixel procedural shading effects.</p><p>This felt like a good solution; I could instantly see how most features could map to this setup and it most definitely wasn‚Äôt a visual programming system‚Ä¶
As an illustration, here‚Äôs a collection of the different node categories available in the engine at the time of writing:</p><p><img src="https://gboisse.github.io/node-categories.png" alt="node-categories"/></p><div><p><img src="https://gboisse.github.io/metaballs-nodes.png" width="49%"/>
<img src="https://gboisse.github.io/metaballs.jpg" width="49%"/></p></div><h3 id="data-model-vs-gui-code">Data model vs. GUI code</h3><p>Now that I knew how my node system would operate, I had to find how to implement it.
My plan was to use <a href="https://github.com/ocornut/imgui">Dear ImGui</a> for the UI because it‚Äôs a joy to use and, I have to admit, I had little intention of investigating other GUI solutions.
ImGui is actually a great fit I found to crafting such a creative UI system.</p><p>The main insight to take away in my opinion is the need to separate the data (what I‚Äôd call the <strong>data model</strong>) from the UI logic (often referred to as the <strong><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">view</a></strong>).
Having such a separation naturally implies creating an interface for iterating the data inside your ‚Äúproject‚Äù that can then be used both by the runtime, when playing back the demo content, and the ImGui code, when running the editor.</p><p>Our first step should therefore be to define that data model, so here goes:</p><p><img src="https://gboisse.github.io/data-model.png" alt="data-mode"/></p><ul><li><strong>Assets</strong>: A list of all your imported 3D models, textures, music files, etc.</li><li><strong>Layers</strong>: These allow to group nodes, mostly to facilitate multi-scene projects.</li><li><strong>Nodes</strong>: Nodes belong to their parent layer and can be executed by the runtime.</li></ul><p>Furthermore, <strong>Ranges</strong> represent the series of time segments for when a particular resource is active on the timeline, while <strong>Properties</strong> represent, as the name suggests, the properties of a given node, such as values and colors, links to assets and/or other nodes, etc.</p><p>Having such a clearly defined data model makes it easy to serialize and deserialize the content of a project (for saving and loading purposes respectively) as we can rely on a well identified distinction between what should be persisted vs. what‚Äôs engine specific.</p><p><img src="https://gboisse.github.io/timeline.jpg" alt="timeline"/></p><h3 id="animating-the-scene">Animating the scene</h3><p>Next stop on the road was to get things moving.</p><p>My plan here was to allow keyframing any property that‚Äôs either a <code>float</code> or a vector of floats (e.g., <code>vec2</code>, <code>vec3</code>, <code>vec4</code>).
For this task, I pretty much mimicked Blender and added a ‚ÄúK‚Äù button next to all keyframe-able properties.
Once enabled, the property field would turn green, while modifying it would insert a new keyframe at the current frame index, turning the field orange to highlight the change.
I also found I had to disable the editing of keyframed properties during playback (something that‚Äôs otherwise possible and a great way to tweak the rendering of a scene) so as to avoid inserting what‚Äôd be one keyframe per frame. üôÇ</p><p>Finally, I decided to have the timeline content be encoded for a 24Hz target frequency, meaning you could only ever store up to 24 keyframes inside a given second.
This is fine however, as we can simply turn our frame index into a floating-point number and interpolate between keyframes if the demo ends up running at higher framerates.</p><p><img src="https://gboisse.github.io/curve-editor.jpg" alt="curve-editor"/></p><p>This is a great tool for continuous, repeating, or random animation.
Things that would otherwise be a pain to do with editing a curve.
As it turns out, we ended up using this functionality way more than the curve editor itself!
This probably goes some way as to explaining why this view is the only part of the UI that hasn‚Äôt been completed yet‚Ä¶</p><h3 id="code-nodes">Code nodes</h3><p>I‚Äôve mentioned throughout this post that I was mostly trying to steer away from visual programming, but we may still want to allow the use of coding for these moments where built-in nodes aren‚Äôt quite flexible enough.
Instead of ‚Äúcoding with nodes‚Äù however, here you‚Äôd simply create a ‚Äúcode node‚Äù letting you write actual text inside a field (or copy/paste from <a href="https://www.shadertoy.com/">Shadertoy</a>!).
You can then add ‚Äúbindings‚Äù to create tweakable properties that can be accessed directly from the shader:</p><p><img src="https://gboisse.github.io/code-node.gif" alt="code-node"/></p><h3 id="conclusion">Conclusion</h3><p>I hope this overview was useful, don‚Äôt hesitate to <a href="https://twitter.com/guitio2002">reach out</a> or leave a comment!</p></div></div></article></div>
  </body>
</html>
