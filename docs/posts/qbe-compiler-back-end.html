<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://c9x.me/compile/">Original</a>
    <h1>QBE â€“ Compiler Back End</h1>
    
    <div id="readability-page-1" class="page"><div>



<nav>
<ul>
  <li><a href="https://kevingal.com/compile/">Intro</a>
  </li><li><a href="https://kevingal.com/compile/docs.html">Docs</a>
  </li><li><a href="https://kevingal.com/compile/users.html">Users</a>
  </li><li><a href="https://kevingal.com/compile/releases.html">Releases</a>
  </li><li><a href="https://kevingal.com/compile/code.html">Code</a>
</li></ul>
</nav>

<p>
QBE is a compiler backend that aims to provide 70% of the
performance of industrial optimizing compilers in 10% of the code.
QBE fosters language innovation by offering a compact user-friendly
and performant backend.
The size limit constrains QBE to focus on the essential and
prevents embarking on a never-ending path of diminishing returns.

</p><h3>Overview</h3>

<p>
The C codebase of QBE is intended to remain hobby-scale
and pleasant to hack on. Despite the small footprint, QBE provides
a number of optimizations with good impact/weight ratio. It also
facilitates integration with foreign systems by implementing the C
ABI in full. This means that programs compiled by QBE can
trivially call into C, and vice versa.
The current version of QBE can target
<em>amd64</em> (linux and osx),
<em>arm64</em>, and
<em>riscv64</em>.

</p><details>
<summary>More QBE features</summary>
<ul>
<li> Full support for the C ABI.
</li><li> IEEE 32 and 64 bits floating point numbers.
</li><li> Uniform and simple <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a>-based
     intermediate language (IL).
</li><li> Same IL used at all compilation stages.
</li><li> Copy elimination.
</li><li> Sparse conditional constant propagation.
</li><li> Dead instructions elimination.
</li><li> Registerization of small stack slots.
</li><li> Split spiller and register allocator thanks to SSA
     form.  (Simpler and faster than graph coloring.)
</li><li> Smart spilling heuristic based on loop analysis.
</li><li> Linear register allocator with hinting.
</li><li> Matching and use of amd64 addressing modes.
</li><li> Super quick compile times (2 seconds on a Core 2 Duo with <code>CFLAGS=-O2</code>).
</li></ul>
</details>

<h3>Get started</h3>

<p> 
The snippet below is a self-contained program written in
QBE intermediate language that shows how to define
simple functions, perform arithmetic on words, and call
into a variadic C function.

</p><pre>function w $add(w %a, w %b) {              # Define a function add
@start
	%c =w add %a, %b                   # Adds the 2 arguments
	ret %c                             # Return the result
}
export function w $main() {                # Main function
@start
	%r =w call $add(w 1, w 1)          # Call add(1, 1)
	call $printf(l $fmt, ..., w %r)    # Show the result
	ret 0
}
data $fmt = { b &#34;One and one make %d!\n&#34;, b 0 }
</pre>

<p> Copy the example in a file, then compile it with
<code>qbe -o out.s file.ssa &amp;&amp; cc out.s</code>.
The output binary should run smoothly, leaning on your
local libc to print its output to the terminal.

</p><p>
To learn more about the QBE intermediate language,
go read <a href="https://kevingal.com/compile/doc/il.html">the language documentation</a>.

</p><h3>Community</h3>

<ul>
<li> For patches and discussions subscribe to
     <a href="https://lists.sr.ht/~mpu/qbe/"><code>~mpu/qbe@lists.sr.ht</code></a>.
</li><li> Come talk to us on <code>irc.eigenstate.org</code> in the
     <code>#myrddin</code> channel.
</li></ul>

</div></div>
  </body>
</html>
