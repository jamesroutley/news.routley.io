<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.shuttle.rs/blog/2023/10/25/htmx-with-rust">Original</a>
    <h1>Htmx, Rust and Shuttle: A New Rapid Prototyping Stack</h1>
    
    <div id="readability-page-1" class="page"><article><p>When it comes to Rust, although it&#39;s lauded as a language that is memory-safe, blazing fast and efficient, it&#39;s also known for having a compiler that will complain at you for everything (hence terms like &#34;compiler-driven development&#34; becoming a thing) and complex trait bounds that can getting it just right take time. In this article, we&#39;ll talk about tools that you can use to speed up your workflow: htmx with a templating engine and the web framework Axum (and of course, Shuttle!).</p>
<p>htmx is a JavaScript library designed to help you ship faster by allowing you to call endpoints from HTML elements instead of being required to do it manually which when combined with a HTML templating engine makes prototyping extremely quick - and we don&#39;t need to set anything up to do it, only being required as a minimum to use the CDN script (although we can also use it as an npm package). Shuttle allows you to move quickly by declaratively provisioning infrastructure like databases, key-value stores and more as main function parameters using the Shuttle runtime, letting you prototype new projects extremely quickly when used with htmx.</p>
<h2 id="using-shuttle">Using Shuttle</h2>
<p>Shuttle is a service designed to make deployment as easy as possible, by provisioning a runtime that lets you add macros (or &#34;annotations&#34;) as function arguments to your entrypoint function. The runtime will then do static code analysis to figure out what needs provisioning and will then spin up the relevant infrastructure required - for example, if you need a Postgres instance, you can just declare it in your <code>fn main</code> arguments, use <code>cargo shuttle run</code> to run locally and then it&#39;ll spin up a container for you using Docker without any further input on your part!</p>
<video width="700" height="500" loop="" autoplay="" muted=""><source src="/videos/blog/htmx-with-rust.mp4" type="video/mp4"/><p>Your browser does not support the video tag.</p></video>
<p>By using Shuttle, we can turn this:</p>
<div><pre><code><span>#[tokio::main]</span>
<span>async</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
<!-- -->    <span>let</span> sqlx_connection <span>=</span> <span>PgPoolOptions</span><span>::</span><span>new</span><span>(</span><span>)</span><span>.</span><span>connect</span><span>(</span><span>&#34;your-addr-here&#34;</span><span>)</span><span>.</span><span>await</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
<!-- -->
<!-- -->    <span>let</span> router <span>=</span> <span>Router</span><span>::</span><span>new</span><span>(</span><span>)</span><span>.</span><span>route</span><span>(</span><span>&#34;/&#34;</span><span>,</span> <span>get</span><span>(</span>hello_world<span>)</span><span>)</span><span>.</span><span>layer</span><span>(</span><span>Extension</span><span>(</span><span>Arc</span><span>::</span><span>new</span><span>(</span>sqlx_connection<span>)</span><span>)</span><span>)</span><span>;</span>
<!-- -->
<!-- -->    <span>let</span> addr <span>=</span> <span>SocketAddr</span><span>::</span><span>from</span><span>(</span><span>(</span><span>[</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>]</span><span>,</span> <span>8000</span><span>)</span><span>)</span><span>;</span>
<!-- -->
<!-- -->    <span>axum<span>::</span></span><span>Server</span><span>::</span><span>bind</span><span>(</span><span>&amp;</span>addr<span>)</span><span>.</span><span>serve</span><span>(</span>router<span>.</span><span>into_make_service</span><span>(</span><span>)</span><span>)</span><span>.</span><span>await</span><span>.</span><span>unwrap</span><span>(</span><span>)</span>
<span>}</span>
</code></pre></div>
<p>to this:</p>
<div><pre><code><span>#[shuttle_runtime::main]</span>
<span>async</span> <span>fn</span> <span>main</span><span>(</span>
<!-- -->    <span>#[shuttle_shared_db::Postgres]</span> sqlx_connection<span>:</span> <span>PgPool</span>
<span>)</span> <span>-&gt;</span> <span>shuttle_axum<span>::</span></span><span>ShuttleAxum</span> <span>{</span>
<!-- -->    <span>let</span> router <span>=</span> <span>Router</span><span>::</span><span>new</span><span>(</span><span>)</span><span>.</span><span>route</span><span>(</span><span>&#34;/&#34;</span><span>,</span> <span>get</span><span>(</span>hello_world<span>)</span><span>)</span><span>.</span><span>layer</span><span>(</span><span>Extension</span><span>(</span><span>Arc</span><span>::</span><span>new</span><span>(</span>sqlx_connection<span>)</span><span>)</span><span>)</span><span>;</span>
<!-- -->
<!-- -->    <span>Ok</span><span>(</span>router<span>.</span><span>into</span><span>(</span><span>)</span><span>)</span>
<span>}</span>
</code></pre></div>
<p>Once you&#39;re done writing code, all you need to do is use <code>cargo shuttle deploy</code> (with the <code>--allow-dirty</code> flag if on a Git branch with uncommitted changes) and when it&#39;s done deploying, you should get a link to see your website! If you need to check your database connection string again, you can also use <code>cargo shuttle resource list</code> to quickly check it.</p>
<h2 id="using-htmx">Using HTMX</h2>
<p>To start off with, we want a <code>base.html</code> file that includes the head - which we&#39;ll add htmx to through the CDN.</p>
<div><pre><code>
<span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>&gt;</span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>&#34;</span>en<span>&#34;</span></span><span>&gt;</span></span>
<span><span><span>&lt;</span>head</span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>&#34;</span>https://unpkg.com/htmx.org@1.9.6<span>&#34;</span></span>
        <span>integrity</span><span><span>=</span><span>&#34;</span>sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni<span>&#34;</span></span>
        <span>crossorigin</span><span><span>=</span><span>&#34;</span>anonymous<span>&#34;</span></span><span>&gt;</span></span><span></span><span><span><span>&lt;/</span>script</span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>&#34;</span>stylesheet<span>&#34;</span></span> <span>href</span><span><span>=</span><span>&#34;</span>/styles.css<span>&#34;</span></span><span>/&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>title</span><span>&gt;</span></span>Index<span><span><span>&lt;/</span>title</span><span>&gt;</span></span>
<!-- -->    {% block head %}{% endblock %}<!-- -->
<span><span><span>&lt;/</span>head</span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>body</span><span>&gt;</span></span>
<!-- -->        <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>&#34;</span>content<span>&#34;</span></span><span>&gt;</span></span>
<!-- -->            {% block content %}<span><span><span>&lt;</span>p</span><span>&gt;</span></span>Placeholder content<span><span><span>&lt;/</span>p</span><span>&gt;</span></span>{% endblock %}<!-- -->
<!-- -->        <span><span><span>&lt;/</span>div</span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;/</span>body</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>html</span><span>&gt;</span></span>
</code></pre></div>
<p>We are also using Askama, which is a Rust HTML templating crate, with htmx. If you&#39;ve ever used Python before, you might notice the syntax is quite similar to Jinja2 templates. Jinja2 is a web templating engine that describes itself as a &#34;fast, expressive and extensible web templating engine&#34; that&#39;s been around for quite a while and is a well known format given how many copies there are of libraries, inside and outside of Rust, that emulate Jinja2 syntax. Interested in learning more about Askama? Our new recent Shuttle Launchpad issue talks about it <a href="https://www.shuttle.rs/launchpad/issues/2023-10-17-issue-10-Serving-HTML">here.</a></p>
<p>Now let&#39;s make our <code>index.html</code> file:</p>
<div><pre><code>
<!-- -->{% extends &#34;base.html&#34; %}<!-- -->
<!-- -->
<!-- -->{% block content %}<!-- -->
<span><span><span>&lt;</span>h1</span><span>&gt;</span></span>Shuttle Todos<span><span><span>&lt;/</span>h1</span><span>&gt;</span></span>
<span><span><span>&lt;</span>form</span> <span>id</span><span><span>=</span><span>&#34;</span>add-form<span>&#34;</span></span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>input</span> <span>placeholder</span><span><span>=</span><span>&#34;</span>Your todo description...<span>&#34;</span></span> <span>required</span> <span>type</span><span><span>=</span>text</span> <span>name</span><span><span>=</span><span>&#34;</span>description<span>&#34;</span></span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>button</span> <span>hx-post</span><span><span>=</span><span>&#34;</span>/todos<span>&#34;</span></span> <span>hx-trigger</span><span><span>=</span><span>&#34;</span>click<span>&#34;</span></span> <span>hx-target</span><span><span>=</span><span>&#34;</span>#todos-content<span>&#34;</span></span> <span>hx-swap</span><span><span>=</span><span>&#34;</span>beforeend<span>&#34;</span></span><span>&gt;</span></span>Add<span><span><span>&lt;/</span>button</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>form</span><span>&gt;</span></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>&#34;</span>list<span>&#34;</span></span> <span>hx-get</span><span><span>=</span><span>&#34;</span>/todos<span>&#34;</span></span> <span>hx-target</span><span><span>=</span><span>&#34;</span>this<span>&#34;</span></span> <span>hx-trigger</span><span><span>=</span><span>&#34;</span>load<span>&#34;</span></span> <span>hx-swap</span><span><span>=</span><span>&#34;</span>outerHTML<span>&#34;</span></span><span>&gt;</span></span>
<!-- -->    Loading...<!-- -->
<span><span><span>&lt;/</span>div</span><span>&gt;</span></span>
<!-- -->{% endblock %}<!-- -->
</code></pre></div>
<p>As you can see, we are extending the <code>base.html</code> file and then declaring a block called <code>content</code> - this is where we put our HTML that we want to add. As a simple example, we&#39;ve added a form to add a new todo, as well as a placeholder div with an ID of &#34;list&#34;.</p>
<p>For the next part, we&#39;ll want to have some of our HTML already written, so let&#39;s do that now:</p>
<div><pre><code>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>&#34;</span>todos<span>&#34;</span></span><span>&gt;</span></span>
<span><span><span>&lt;</span>table</span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>thead</span><span>&gt;</span></span>
<!-- -->        <span><span><span>&lt;</span>tr</span><span>&gt;</span></span>
<!-- -->            <span><span><span>&lt;</span>th</span><span>&gt;</span></span>ID<span><span><span>&lt;/</span>th</span><span>&gt;</span></span>
<!-- -->            <span><span><span>&lt;</span>th</span><span>&gt;</span></span>Description<span><span><span>&lt;/</span>th</span><span>&gt;</span></span>
<!-- -->            <span><span><span>&lt;</span>th</span><span>&gt;</span></span>Delete<span><span><span>&lt;/</span>th</span><span>&gt;</span></span>
<!-- -->        <span><span><span>&lt;/</span>tr</span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;/</span>thead</span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>tbody</span> <span>id</span><span><span>=</span><span>&#34;</span>todos-content<span>&#34;</span></span><span>&gt;</span></span>
<!-- -->        
<!-- -->        {% for todo in todos %}<!-- -->
<!-- -->            {% include &#34;todo.html&#34; %}<!-- -->
<!-- -->        {% endfor %}<!-- -->
<!-- -->    <span><span><span>&lt;/</span>tbody</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>table</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>div</span><span>&gt;</span></span>
</code></pre></div>
<div><pre><code>
<span><span><span>&lt;</span>tr</span> <span>id</span><span><span>=</span><span>&#34;</span>shuttle-todo-{{ todo.id }}<span>&#34;</span></span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>td</span><span>&gt;</span></span> {{ todo.id }} <span><span><span>&lt;/</span>td</span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>td</span> <span>id</span><span><span>=</span><span>&#34;</span>shuttle-todo-desc-{{todo.id}}<span>&#34;</span></span><span>&gt;</span></span> {{ todo.description }} <span><span><span>&lt;/</span>td</span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>td</span><span>&gt;</span></span>
<!-- -->        <span><span><span>&lt;</span>button</span>
            <span>hx-delete</span><span><span>=</span><span>&#34;</span>/todos/{{todo.id}}<span>&#34;</span></span>
            <span>hx-trigger</span><span><span>=</span><span>&#34;</span>click<span>&#34;</span></span>
            <span>hx-target</span><span><span>=</span><span>&#34;</span>#shuttle-todo-{{todo.id}}<span>&#34;</span></span>
            <span>hx-swap</span><span><span>=</span><span>&#34;</span>delete<span>&#34;</span></span>
        <span>&gt;</span></span>
<!-- -->            Delete<!-- -->
<!-- -->        <span><span><span>&lt;/</span>button</span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;/</span>td</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>tr</span><span>&gt;</span></span>
</code></pre></div>
<p>As you can see, we&#39;ve included a button with the <code>todo</code> component that makes a DELETE request to the <code>/todos/:id</code> route, but it targets the whole row and just deletes the row after the API call is done, which saves time having to manually delete the component from the DOM.</p>
<h2 id="making-api-calls">Making API calls</h2>
<p>htmx allows you to make an API call without explicitly writing JavaScript for it, by allowing you use HTML attributes instead. When you make an API call with htmx, the library requires you to return HTML as a response - which is great for us because we can combine it with Askama templating so that we don&#39;t have to go through the hassle of trying to create a whole new element through pure JavaScript and then appending it to whatever element we choose. Let&#39;s take the form from above as an example:</p>
<div><pre><code><span><span><span>&lt;</span>form</span> <span>id</span><span><span>=</span><span>&#34;</span>add-form<span>&#34;</span></span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>input</span> <span>placeholder</span><span><span>=</span><span>&#34;</span>Your todo description...<span>&#34;</span></span> <span>required</span> <span>type</span><span><span>=</span>text</span> <span>name</span><span><span>=</span><span>&#34;</span>description<span>&#34;</span></span><span>&gt;</span></span>
<!-- -->    <span><span><span>&lt;</span>button</span>
        <span>hx-post</span><span><span>=</span><span>&#34;</span>/todos<span>&#34;</span></span>
        <span>hx-trigger</span><span><span>=</span><span>&#34;</span>click<span>&#34;</span></span>
        <span>hx-target</span><span><span>=</span><span>&#34;</span>#todos-content<span>&#34;</span></span>
        <span>hx-swap</span><span><span>=</span><span>&#34;</span>beforeend<span>&#34;</span></span>
    <span>&gt;</span></span>
<!-- -->        Add<!-- -->
<!-- -->    <span><span><span>&lt;/</span>button</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>form</span><span>&gt;</span></span>
</code></pre></div>
<p>The button makes a POST request to <code>/todos</code>, triggered by clicking the button, targets the HTML element with an id of &#34;todos-content&#34; and places the resulting HTML as the last element within the target element.</p>
<p>As you can see, this speeds up development speed quite a lot! Not having to set up an opinionated framework and being able to quickly write things with a HTML templating engine makes things a lot quicker.</p>
<h2 id="streams-and-server-sent-events-with-htmx">Streams and Server Sent Events with htmx</h2>
<p>Being able to quickly mock up a CRUD app with htmx is great. However, Server Sent Events (SSE) and Websockets are also important functions for web applications and web services to work. Thankfully, htmx natively supports both. We can look at a basic mockup of receiving SSE with htmx by creating a new channel in our main function, then appending it as an Extension to our main function, as well as creating the necessary structs we need for the messages we&#39;re going to send through the channel:</p>
<div><pre><code>
<span>#[derive(Clone, Serialize, Debug)]</span>
<span>enum</span> <span>MutationKind</span> <span>{</span>
<!-- -->    <span>Create</span><span>,</span>
<!-- -->    <span>Delete</span><span>,</span>
<span>}</span>
<!-- -->
<span>#[derive(Clone, Serialize, Debug)]</span>
<span>pub</span> <span>struct</span> <span>TodoUpdate</span> <span>{</span>
<!-- -->    mutation_kind<span>:</span> <span>MutationKind</span><span>,</span>
<!-- -->    id<span>:</span> <span>i32</span><span>,</span>
<span>}</span>
<!-- -->
<span>#[shuttle_runtime::main]</span>
<span>async</span> <span>fn</span> <span>main</span><span>(</span><span>#[shuttle_shared_db::Postgres]</span> db<span>:</span> <span>PgPool</span><span>)</span> <span>-&gt;</span> <span>shuttle_axum<span>::</span></span><span>ShuttleAxum</span> <span>{</span>
<!-- -->    <span>sqlx<span>::</span></span><span>migrate!</span><span>(</span><span>)</span>
<!-- -->        <span>.</span><span>run</span><span>(</span><span>&amp;</span>db<span>)</span>
<!-- -->        <span>.</span><span>await</span>
<!-- -->        <span>.</span><span>expect</span><span>(</span><span>&#34;Looks like something went wrong with migrations :(&#34;</span><span>)</span><span>;</span>
<!-- -->
<!-- -->    <span>let</span> <span>(</span>tx<span>,</span> rx<span>)</span> <span>=</span> <span>channel</span><span>::</span><span>&lt;</span><span>TodoUpdate</span><span>&gt;</span><span>(</span><span>10</span><span>)</span><span>;</span>
<!-- -->    <span>let</span> state <span>=</span> <span>AppState</span> <span>{</span> db <span>}</span><span>;</span>
<!-- -->
<!-- -->    <span>let</span> router <span>=</span> <span>Router</span><span>::</span><span>new</span><span>(</span><span>)</span>
<!-- -->        <span>.</span><span>route</span><span>(</span><span>&#34;/&#34;</span><span>,</span> <span>get</span><span>(</span>home<span>)</span><span>)</span>
<!-- -->        <span>.</span><span>route</span><span>(</span><span>&#34;/stream&#34;</span><span>,</span> <span>get</span><span>(</span>stream<span>)</span><span>)</span>
<!-- -->        <span>.</span><span>route</span><span>(</span><span>&#34;/todos&#34;</span><span>,</span> <span>get</span><span>(</span>fetch_todos<span>)</span><span>.</span><span>post</span><span>(</span>create_todo<span>)</span><span>)</span>
<!-- -->        <span>.</span><span>route</span><span>(</span><span>&#34;/todos/:id&#34;</span><span>,</span> <span>delete</span><span>(</span>delete_todo<span>)</span><span>)</span>
<!-- -->        
<!-- -->        <span>.</span><span>route</span><span>(</span><span>&#34;/todos/stream&#34;</span><span>,</span> <span>get</span><span>(</span>handle_stream<span>)</span><span>)</span>
<!-- -->        <span>.</span><span>with_state</span><span>(</span>state<span>)</span>
<!-- -->        <span>.</span><span>layer</span><span>(</span><span>Extension</span><span>(</span>tx<span>)</span><span>)</span>
<!-- -->        <span>.</span><span>layer</span><span>(</span><span>Extension</span><span>(</span>rx<span>)</span><span>)</span><span>;</span>
<!-- -->
<!-- -->    <span>Ok</span><span>(</span>router<span>.</span><span>into</span><span>(</span><span>)</span><span>)</span>
<span>}</span>
</code></pre></div>
<p>Now we want to send a message from our <code>create_todo</code> and <code>delete_todo</code> handlers through our channel - we can add them by including our extension in the function signature, then after a successful SQL transaction we simply send a message to the channel:</p>
<div><pre><code>
<span>type</span> <span>TodosStream</span> <span>=</span> <span>Sender</span><span>&lt;</span><span>TodoUpdate</span><span>&gt;</span><span>;</span>
<!-- -->
<span>async</span> <span>fn</span> <span>create_todo</span><span>(</span>
<!-- -->    <span>State</span><span>(</span>state<span>)</span><span>:</span> <span>State</span><span>&lt;</span><span>AppState</span><span>&gt;</span><span>,</span>
<!-- -->    <span>Extension</span><span>(</span>tx<span>)</span><span>:</span> <span>Extension</span><span>&lt;</span><span>TodosStream</span><span>&gt;</span><span>,</span>
<!-- -->    <span>Form</span><span>(</span>form<span>)</span><span>:</span> <span>Form</span><span>&lt;</span><span>TodoNew</span><span>&gt;</span><span>,</span>
<span>)</span> <span>-&gt;</span> <span>impl</span> <span>IntoResponse</span> <span>{</span>
<!-- -->    <span>let</span> todo <span>=</span> <span>sqlx<span>::</span></span><span>query_as</span><span>::</span><span>&lt;</span>_<span>,</span> <span>Todo</span><span>&gt;</span><span>(</span>
<!-- -->        <span>&#34;INSERT INTO TODOS (description) VALUES ($1) RETURNING id, description&#34;</span><span>,</span>
<!-- -->    <span>)</span>
<!-- -->    <span>.</span><span>bind</span><span>(</span>form<span>.</span>description<span>)</span>
<!-- -->    <span>.</span><span>fetch_one</span><span>(</span><span>&amp;</span>state<span>.</span>db<span>)</span>
<!-- -->    <span>.</span><span>await</span>
<!-- -->    <span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
<!-- -->
<!-- -->    <span>if</span> <span>let</span> <span>Err</span><span>(</span>e<span>)</span> <span>=</span> tx<span>.</span><span>send</span><span>(</span><span>TodoUpdate</span> <span>{</span> mutation_kind<span>:</span> <span>MutationKind</span><span>::</span><span>Create</span><span>,</span> id<span>:</span> todo<span>.</span>id <span>}</span><span>)</span> <span>{</span>
<!-- -->      	<span>eprintln!</span><span>(</span><span>&#34;Tried to send log of record with ID {} created but something went wrong: {e}&#34;</span><span>,</span> todo<span>.</span>id<span>)</span><span>;</span>
<!-- -->    <span>}</span>
<!-- -->
<!-- -->    <span>TodoNewTemplate</span> <span>{</span> todo <span>}</span>
<span>}</span>
<!-- -->
<span>async</span> <span>fn</span> <span>delete_todo</span><span>(</span>
<!-- -->    <span>State</span><span>(</span>state<span>)</span><span>:</span> <span>State</span><span>&lt;</span><span>AppState</span><span>&gt;</span><span>,</span>
<!-- -->    <span>Path</span><span>(</span>id<span>)</span><span>:</span> <span>Path</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>,</span>
<!-- -->    <span>Extension</span><span>(</span>tx<span>)</span><span>:</span> <span>Extension</span><span>&lt;</span><span>TodosStream</span><span>&gt;</span><span>,</span>
<span>)</span> <span>-&gt;</span> <span>impl</span> <span>IntoResponse</span> <span>{</span>
<!-- -->    <span>sqlx<span>::</span></span><span>query</span><span>(</span><span>&#34;DELETE FROM TODOS WHERE ID = $1&#34;</span><span>)</span>
<!-- -->        <span>.</span><span>bind</span><span>(</span>id<span>)</span>
<!-- -->        <span>.</span><span>execute</span><span>(</span><span>&amp;</span>state<span>.</span>db<span>)</span>
<!-- -->        <span>.</span><span>await</span>
<!-- -->        <span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
<!-- -->
<!-- -->    <span>if</span> <span>let</span> <span>Err</span><span>(</span>e<span>)</span> <span>=</span> tx<span>.</span><span>send</span><span>(</span><span>TodoUpdate</span> <span>{</span> mutation_kind<span>:</span> <span>MutationKind</span><span>::</span><span>Delete</span><span>,</span> id <span>}</span><span>)</span> <span>{</span>
<!-- -->    	<span>eprintln!</span><span>(</span><span>&#34;Tried to send log of record with ID {id} created but something went wrong: {e}&#34;</span><span>)</span><span>;</span>
<!-- -->    <span>}</span>
<!-- -->
<!-- -->    <span>StatusCode</span><span>::</span><span>OK</span>
<span>}</span>
</code></pre></div>
<p>Now we need to implement the stream handler, which we can do by creating a <code>BroadcastStream</code> and then mapping our stream to Axum SSE events:</p>
<div><pre><code><span>use</span> <span>std<span>::</span>convert<span>::</span></span><span>Infallible</span><span>;</span>
<span>use</span> <span>tokio_stream<span>::</span></span><span>{</span><span>Stream</span><span>,</span> <span>StreamExt</span> <span>as</span> _<span>}</span><span>;</span>
<span>use</span> <span>std<span>::</span>time<span>::</span></span><span>Duration</span><span>;</span>
<span>use</span> <span>tokio<span>::</span>sync<span>::</span>broadcast<span>::</span></span><span>{</span>channel<span>,</span> <span>Sender</span><span>,</span> <span>Receiver</span><span>}</span><span>;</span>
<span>use</span> <span>axum<span>::</span></span><span>{</span>
<!-- -->    <span>http<span>::</span></span><span>StatusCode</span><span>,</span>
<!-- -->    <span>response<span>::</span></span><span>{</span><span>sse<span>::</span></span><span>Event</span><span>,</span> <span>IntoResponse</span><span>,</span> <span>Sse</span><span>,</span> <span>Response</span><span>}</span><span>,</span>
<!-- -->    <span>Extension</span>
<span>}</span><span>;</span>
<span>use</span> <span>serde_json<span>::</span></span>json<span>;</span>
<!-- -->
<span>pub</span> <span>async</span> <span>fn</span> <span>handle_stream</span><span>(</span>
<!-- -->    <span>Extension</span><span>(</span>tx<span>)</span><span>:</span> <span>Extension</span><span>&lt;</span><span>TodosStream</span><span>&gt;</span><span>,</span>
<!-- -->    <span>Extension</span><span>(</span>rx<span>)</span><span>:</span> <span>Extension</span><span>&lt;</span><span>Receiver</span><span>&lt;</span><span>TodoUpdate</span><span>&gt;&gt;</span>
<span>)</span> <span>-&gt;</span> <span>Sse</span><span>&lt;</span><span>impl</span> <span>Stream</span><span>&lt;</span><span>Item</span> <span>=</span> <span>Result</span><span>&lt;</span><span>Event</span><span>,</span> <span>Infallible</span><span>&gt;&gt;</span><span>&gt;</span> <span>{</span>
<!-- -->
<!-- -->    <span>let</span> stream <span>=</span> <span>BroadcastStream</span><span>::</span><span>new</span><span>(</span>rx<span>)</span><span>;</span>
<!-- -->
<!-- -->    
<!-- -->    <span>Sse</span><span>::</span><span>new</span><span>(</span>
<!-- -->        stream<!-- -->
<!-- -->            <span>.</span><span>map</span><span>(</span><span><span>|</span>msg<span>|</span></span> <span>{</span>
<!-- -->                <span>let</span> msg <span>=</span> msg<span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
<!-- -->                
<!-- -->                <span>let</span> json <span>=</span> <span>format!</span><span>(</span><span>&#34;&lt;div&gt;{}&lt;/div&gt;&#34;</span><span>,</span> <span>json!</span><span>(</span>msg<span>)</span><span>)</span><span>;</span>
<!-- -->                <span>Event</span><span>::</span><span>default</span><span>(</span><span>)</span><span>.</span><span>data</span><span>(</span>json<span>)</span>
<!-- -->            <span>}</span><span>)</span>
<!-- -->            <span>.</span><span>map</span><span>(</span><span>Ok</span><span>)</span><span>,</span>
<!-- -->    <span>)</span>
<!-- -->    <span>.</span><span>keep_alive</span><span>(</span>
<!-- -->        <span>axum<span>::</span>response<span>::</span>sse<span>::</span></span><span>KeepAlive</span><span>::</span><span>new</span><span>(</span><span>)</span>
<!-- -->            <span>.</span><span>interval</span><span>(</span><span>Duration</span><span>::</span><span>from_secs</span><span>(</span><span>600</span><span>)</span><span>)</span>
<!-- -->            <span>.</span><span>text</span><span>(</span><span>&#34;keep-alive-text&#34;</span><span>)</span><span>,</span>
<!-- -->    <span>)</span>
<span>}</span>
</code></pre></div>
<p>Then in our HTML, we will want to add an element that looks like this:</p>
<div><pre><code>
<!-- -->

<span><span><span>&lt;</span>div</span> <span>hx-sse</span><span><span>=</span><span>&#34;</span>connect:/todos/stream swap:message<span>&#34;</span></span> <span>hx-swap</span><span><span>=</span><span>&#34;</span>beforeend<span>&#34;</span></span><span>&gt;</span></span>
<!-- -->
<span><span><span>&lt;/</span>div</span><span>&gt;</span></span>
</code></pre></div>
<p>When you have the <code>hx-sse</code> HTML element and then add or delete an item from the main page, you will then see a log of what ID the record had and what the action was. The item will get appended to the inner div without any other input from our side!</p>
<h2 id="finishing-up">Finishing Up</h2>
<p>Thanks for reading! I hope this guide to using htmx with Rust has helped you get a better insight into why it&#39;s currently rising in popularity at the moment. htmx is a great library that can be taken to new heights by using it in conjunction with HTML templating in Rust.</p>
<p>Did this article help you? Feel free to <a href="https://www.github.com/shuttle-hq/shuttle">give us a star on GitHub!</a></p>
<p>You can find the article code <a href="https://github.com/joshua-mo-143/shuttle-axum-htmx-ex">here.</a></p></article></div>
  </body>
</html>
