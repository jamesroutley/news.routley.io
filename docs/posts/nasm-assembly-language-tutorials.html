<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://asmtutor.com/">Original</a>
    <h1>NASM Assembly Language Tutorials</h1>
    
    <div id="readability-page-1" class="page"><div>

                <div>
                    <h2>Learn Assembly Language</h2>
                    <p>This project was put together to teach myself NASM x86 assembly language on linux.</p>
                    <p><a href="https://github.com/DGivney/assemblytutorials" target="_blank">Github Project »</a></p>
                </div>

                

                

                

                

                

                

                

                

                

                

                

                

                <hr/>

                <div id="lesson1">
                    <article>
                        <header>
                            <h2>Lesson 1</h2>
                            <h4>Hello, world!</h4>
                        </header>

                            <h5>First, some background</h5>

                            <p>Assembly language is bare-bones. The only interface a programmer has above the actual hardware is the kernel itself. In order to build useful programs in assembly we need to use the linux system calls provided by the kernel. These system calls are a library built into the operating system to provide functions such as reading input from a keyboard and writing output to the screen.</p>

                            <p>When you invoke a system call the kernel will immediately suspend execution of your program.  It will then contact the necessary drivers needed to perform the task you requested on the hardware and then return control back to your program.</p>

                            <p>
                                <span>Note:</span>
                                Drivers are called <i>drivers</i> because the kernel literally uses them to drive the hardware.
                            </p>

                            <p>We can accomplish this all in assembly by loading EAX with the function number (operation code OPCODE) we want to execute and filling the remaining registers with the arguments we want to pass to the system call. A software interrupt is requested with the INT instruction and the kernel takes over and calls the function from the library with our arguments. Simple.</p>

                            <p>For example requesting an interrupt when EAX=1 will call sys_exit and requesting an interrupt when EAX=4 will call sys_write instead. EBX, ECX &amp; EDX will be passed as arguments if the function requires them. <a href="https://chromium.googlesource.com/chromiumos/docs/+/HEAD/constants/syscalls.md#x86-32_bit" target="_blank">Click here to view an example of a Linux System Call Table and its corresponding OPCODES.</a></p>

                            <h5>Writing our program</h5>

                            <p>Firstly we create a variable &#39;msg&#39; in our .data section and assign it the string we want to output in this case &#39;Hello, world!&#39;. In our .text section we tell the kernel where to begin execution by providing it with a global label _start: to denote the programs entry point.</p>

                            <p>We will be using the system call sys_write to output our message to the console window.  This function is assigned OPCODE 4 in the Linux System Call Table.  The function also takes 3 arguments which are sequentially loaded into EDX, ECX and EBX before requesting a software interrupt which will perform the task.</p>

                            <p>The arguments passed are as follows:
                                </p><ul>
                                    <li> EDX will be loaded with the length (in bytes) of the string.</li>
                                    <li> ECX will be loaded with the address of our variable created in the .data section.</li>
                                    <li> EBX will be loaded with the file we want to write to – in this case STDOUT.</li>
                                </ul>
                                The datatype and meaning of the arguments passed can be found in the function&#39;s definition.
                            

                            <p>We compile, link and run the program using the commands below.</p>

                        <div>
                            <p><span>helloworld.asm</span></p><pre>                            ; Hello World Program - asmtutor.com
                            ; Compile with: nasm -f elf helloworld.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld
                            ; Run with: ./helloworld

                            SECTION .data
                            msg     db      &#39;Hello World!&#39;, 0Ah     ; assign msg variable with your message string

                            SECTION .text
                            global  _start

                            _start:

                                mov     edx, 13     ; number of bytes to write - one for each letter plus 0Ah (line feed character)
                                mov     ecx, msg    ; move the memory address of our message string into ecx
                                mov     ebx, 1      ; write to the STDOUT file
                                mov     eax, 4      ; invoke SYS_WRITE (kernel opcode 4)
                                int     80h
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf helloworld.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld.o -o helloworld</span>
                                    <span>~$ ./helloworld</span>
                                    <span>Hello World!</span>
                                    <span>Segmentation fault</span>
                                </p>
                            </div>
                        </div>

                        <p>
                            <span>Error:</span>
                            Segmentation fault
                        </p>

                    </article>
                </div>

                <hr/>

                <div id="lesson2">
                    <article>
                        <header>
                            <h2>Lesson 2</h2>
                            <h4>Proper program exit</h4>
                        </header>

                        <h5>Some more background</h5>

                        <p>After successfully learning how to execute a system call in Lesson 1 we now need to learn about one of the most important system calls in the kernel, sys_exit.</p>

                        <p>Notice how after our &#39;Hello, world!&#39; program ran we got a Segmentation fault? Well, computer programs can be thought of as a long strip of instructions that are loaded into memory and divided up into sections (or segments). This general pool of memory is shared between all programs and can be used to store variables, instructions, other programs or anything really. Each segment is given an address so that information stored in that section can be found later.</p>

                        <p>To execute a program that is loaded in memory, we use the global label _start: to tell the operating system where in memory our program can be found and executed.  Memory is then accessed sequentially following the program logic which determines the next address to be accessed. The kernel jumps to that address in memory and executes it.</p>

                        <p>It&#39;s important to tell the operating system exactly where it should begin execution and where it should stop. In Lesson 1 we didn&#39;t tell the kernel where to stop execution. So, after we called sys_write the program continued sequentially executing the next address in memory, which could have been anything. We don&#39;t know what the kernel tried to execute but it caused it to choke and terminate the process for us instead - leaving us the error message of &#39;Segmentation fault&#39;.  Calling sys_exit at the end of all our programs will mean the kernel knows exactly when to terminate the process and return memory back to the general pool thus avoiding an error.</p>

                        <h5>Writing our program</h5>

                        <p>Sys_exit has a simple function definition.  In the Linux System Call Table it is allocated OPCODE 1 and is passed a single argument through EBX.</p>

                        <p>In order to execute this function all we need to do is:
                            </p><ul>
                                <li>Load EBX with 0 to pass zero to the function meaning &#39;zero errors&#39;.</li>
                                <li>Load EAX with 1 to call sys_exit.</li>
                                <li>Then request an interrupt on libc using INT 80h.</li>
                            </ul>
                        

                        <p>We then compile, link and run it again.</p>

                        <p>
                            <span>Note:</span>
                            Only new code added in each lesson will be commented.
                        </p>

                        <div>
                            <p><span>helloworld.asm</span></p><pre>                            ; Hello World Program - asmtutor.com
                            ; Compile with: nasm -f elf helloworld.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld
                            ; Run with: ./helloworld

                            SECTION .data
                            msg     db      &#39;Hello World!&#39;, 0Ah

                            SECTION .text
                            global  _start

                            _start:

                                mov     edx, 13
                                mov     ecx, msg
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h

                                mov     ebx, 0      ; return 0 status on exit - &#39;No Errors&#39;
                                mov     eax, 1      ; invoke SYS_EXIT (kernel opcode 1)
                                int     80h
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf helloworld.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld.o -o helloworld</span>
                                    <span>~$ ./helloworld</span>
                                    <span>Hello World!</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson3">
                    <article>
                        <header>
                            <h2>Lesson 3</h2>
                            <h4>Calculate string length</h4>
                        </header>

                        <h5>Firstly, some background</h5>

                        <p>Why do we need to calculate the length of a string?</p>

                        <p>Well sys_write requires that we pass it a pointer to the string we want to output in memory and the length in bytes we want to print out.  If we were to modify our message string we would have to update the length in bytes that we pass to sys_write as well, otherwise it will not print correctly. </p>

                        <p>You can see what I mean using the program in Lesson 2.  Modify the message string to say &#39;Hello, brave new world!&#39; then compile, link and run the new program.  The output will be &#39;Hello, brave &#39; (the first 13 characters) because we are still only passing 13 bytes to sys_write as its length.  It will be particularly necessary when we want to print out user input.  As we won&#39;t know the length of the data when we compile our program, we will need a way to calculate the length at runtime in order to successfully print it out.</p>

                        <h5>Writing our program</h5>

                        <p>To calculate the length of the string we will use a technique called pointer arithmetic.  Two registers are initialised pointing to the same address in memory.  One register (in this case EAX) will be incremented forward one byte for each character in the output string until we reach the end of the string.  The original pointer will then be subtracted from EAX.  This is effectively like subtraction between two arrays and the result yields the number of elements between the two addresses. This result is then passed to sys_write replacing our hard coded count.</p>

                        <p>The CMP instruction compares the left hand side against the right hand side and sets a number of flags that are used for program flow.  The flag we&#39;re checking is the ZF or Zero Flag.  When the byte that EAX points to is equal to zero the ZF flag is set.  We then use the JZ instruction to jump, if the ZF flag is set, to the point in our program labeled &#39;finished&#39;. This is to break out of the nextchar loop and continue executing the rest of the program.</p>

                        <div>
                            <p><span>helloworld-len.asm</span></p><pre>                            ; Hello World Program (Calculating string length)
                            ; Compile with: nasm -f elf helloworld-len.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-len.o -o helloworld-len
                            ; Run with: ./helloworld-len

                            SECTION .data
                            msg     db      &#39;Hello, brave new world!&#39;, 0Ah ; we can modify this now without having to update anywhere else in the program

                            SECTION .text
                            global  _start

                            _start:

                                mov     ebx, msg        ; move the address of our message string into EBX
                                mov     eax, ebx        ; move the address in EBX into EAX as well (Both now point to the same segment in memory)

                            nextchar:
                                cmp     byte [eax], 0   ; compare the byte pointed to by EAX at this address against zero (Zero is an end of string delimiter)
                                jz      finished        ; jump (if the zero flagged has been set) to the point in the code labeled &#39;finished&#39;
                                inc     eax             ; increment the address in EAX by one byte (if the zero flagged has NOT been set)
                                jmp     nextchar        ; jump to the point in the code labeled &#39;nextchar&#39;

                            finished:
                                sub     eax, ebx        ; subtract the address in EBX from the address in EAX
                                                        ; remember both registers started pointing to the same address (see line 15)
                                                        ; but EAX has been incremented one byte for each character in the message string
                                                        ; when you subtract one memory address from another of the same type
                                                        ; the result is number of segments between them - in this case the number of bytes

                                mov     edx, eax        ; EAX now equals the number of bytes in our string
                                mov     ecx, msg        ; the rest of the code should be familiar now
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h

                                mov     ebx, 0
                                mov     eax, 1
                                int     80h
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf helloworld-len.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-len.o -o helloworld-len</span>
                                    <span>~$ ./helloworld-len</span>
                                    <span>Hello, brave new world!</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson4">
                    <article>
                        <header>
                            <h2>Lesson 4</h2>
                            <h4>Subroutines</h4>
                        </header>

                        <h5>Introduction to subroutines</h5>

                        <p>Subroutines are functions.  They are reusable pieces of code that can be called by your program to perform various repeatable tasks.  Subroutines are declared using labels just like we&#39;ve used before (eg. _start:) however we don&#39;t use the JMP instruction to get to them - instead we use a new instruction <span>CALL</span>. We also don&#39;t use the JMP instruction to return to our program after we have run the function.  To return to our program from a subroutine we use the instruction RET instead.</p>

                        <h5>Why don&#39;t we JMP to subroutines?</h5>

                        <p>The great thing about writing a subroutine is that we can reuse it.  If we want to be able to use the subroutine from anywhere in the code we would have to write some logic to determine where in the code we had jumped from and where we should jump back to.  This would litter our code with unwanted labels.  If we use <span>CALL</span> and RET however, assembly handles this problem for us using something called the stack.</p>

                        <h5>Introduction to the stack</h5>

                        <p>The stack is a special type of memory.  It&#39;s the same type of memory that we&#39;ve used before however it&#39;s special in how it is used by our program.  The stack is what is call <strong>Last In First Out</strong> memory (LIFO).  You can think of the stack like a stack of plates in your kitchen.  The last plate you put on the stack is also the first plate you will take off the stack next time you use a plate.</p>

                        <p>The stack in assembly is not storing plates though, its storing values.  You can store a lot of things on the stack such as variables, addresses or other programs.  We need to use the stack when we call subroutines to temporarily store values that will be restored later.</p>

                        <p>Any register that your function needs to use should have it&#39;s current value put on the stack for safe keeping using the PUSH instruction.  Then after the function has finished it&#39;s logic, these registers can have their original values restored using the POP instruction.  This means that any values in the registers will be the same before and after you&#39;ve called your function.  If we take care of this in our subroutine we can call functions without worrying about what changes they&#39;re making to our registers.</p>

                        <p>The <span>CALL</span> and RET instructions also use the stack.  When you <span>CALL</span> a subroutine, the address you called it from in your program is pushed onto the stack.  This address is then popped off the stack by RET and the program jumps back to that place in your code.  This is why you should always JMP to labels but you should <span>CALL</span> functions.</p>

                        <div>
                            <p><span>helloworld-len.asm</span></p><pre>                            ; Hello World Program (Subroutines)
                            ; Compile with: nasm -f elf helloworld-len.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-len.o -o helloworld-len
                            ; Run with: ./helloworld-len

                            SECTION .data
                            msg     db      &#39;Hello, brave new world!&#39;, 0Ah

                            SECTION .text
                            global  _start

                            _start:

                                mov     eax, msg        ; move the address of our message string into EAX
                                call    strlen          ; call our function to calculate the length of the string

                                mov     edx, eax        ; our function leaves the result in EAX
                                mov     ecx, msg        ; this is all the same as before
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h

                                mov     ebx, 0
                                mov     eax, 1
                                int     80h

                            strlen:                     ; this is our first function declaration
                                push    ebx             ; push the value in EBX onto the stack to preserve it while we use EBX in this function
                                mov     ebx, eax        ; move the address in EAX into EBX (Both point to the same segment in memory)

                            nextchar:                   ; this is the same as lesson3
                                cmp     byte [eax], 0
                                jz      finished
                                inc     eax
                                jmp     nextchar

                            finished:
                                sub     eax, ebx
                                pop     ebx             ; pop the value on the stack back into EBX
                                ret                     ; return to where the function was called
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf helloworld-len.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-len.o -o helloworld-len</span>
                                    <span>~$ ./helloworld-len</span>
                                    <span>Hello, brave new world!</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson5">
                    <article>
                        <header>
                            <h2>Lesson 5</h2>
                            <h4>External include files</h4>
                        </header>

                        <p>External include files allow us to move code from our program and put it into separate files. This technique is useful for writing clean, easy to maintain programs. Reusable bits of code can be written as subroutines and stored in separate files called libraries. When you need a piece of logic you can include the file in your program and use it as if they are part of the same file.</p>

                        <p>In this lesson we will move our string length calculating subroutine into an external file.  We fill also make our string printing logic and program exit logic a subroutine and we will move them into this external file.  Once it&#39;s completed our actual program will be clean and easier to read.</p>

                        <p>We can then declare another message variable and call our print function twice in order to demonstrate how we can reuse code.</p>

                        <p>
                            <span>Note:</span>
                            I won&#39;t be showing the code in functions.asm after this lesson unless it changes. It will just be included if needed.
                        </p>

                        <div>
                            <p><span>functions.asm</span></p><pre>                            ;------------------------------------------
                            ; int slen(String message)
                            ; String length calculation function
                            slen:
                                push    ebx
                                mov     ebx, eax

                            nextchar:
                                cmp     byte [eax], 0
                                jz      finished
                                inc     eax
                                jmp     nextchar

                            finished:
                                sub     eax, ebx
                                pop     ebx
                                ret


                            ;------------------------------------------
                            ; void sprint(String message)
                            ; String printing function
                            sprint:
                                push    edx
                                push    ecx
                                push    ebx
                                push    eax
                                call    slen

                                mov     edx, eax
                                pop     eax

                                mov     ecx, eax
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h

                                pop     ebx
                                pop     ecx
                                pop     edx
                                ret


                            ;------------------------------------------
                            ; void exit()
                            ; Exit program and restore resources
                            quit:
                                mov     ebx, 0
                                mov     eax, 1
                                int     80h
                                ret


                            </pre>
                        </div>

                        <div>
                            <p><span>helloworld-inc.asm</span></p><pre>                            ; Hello World Program (External file include)
                            ; Compile with: nasm -f elf helloworld-inc.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-inc.o -o helloworld-inc
                            ; Run with: ./helloworld-inc

                            %include        &#39;functions.asm&#39;                             ; include our external file

                            SECTION .data
                            msg1    db      &#39;Hello, brave new world!&#39;, 0Ah              ; our first message string
                            msg2    db      &#39;This is how we recycle in NASM.&#39;, 0Ah      ; our second message string

                            SECTION .text
                            global  _start

                            _start:

                                mov     eax, msg1       ; move the address of our first message string into EAX
                                call    sprint          ; call our string printing function

                                mov     eax, msg2       ; move the address of our second message string into EAX
                                call    sprint          ; call our string printing function

                                call    quit            ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf helloworld-inc.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-inc.o -o helloworld-inc</span>
                                    <span>~$ ./helloworld-inc</span>
                                    <span>Hello, brave new world!</span>
                                    <span>This is how we recycle in NASM.</span>
                                    <span>This is how we recycle in NASM.</span>
                                </p>
                            </div>
                        </div>

                        <p>
                            <span>Error:</span>
                            Our second message is outputted twice.  This is fixed in the next lesson.
                        </p>

                    </article>
                </div>

                <hr/>

                <div id="lesson6">
                    <article>
                        <header>
                            <h2>Lesson 6</h2>
                            <h4>NULL terminating bytes</h4>
                        </header>

                        <p>Ok so why did our second message print twice when we only called our sprint function on msg2 once?  Well actually it did only print once.  You can see what I mean if you comment out our second call to sprint.  The output will be both of our message strings.</p>

                        <p>But how is this possible?</p>

                        <p>What is happening is we weren&#39;t properly terminating our strings.  In assembly, variables are stored one after another in memory so the last byte of our msg1 variable is right next to the first byte of our msg2 variable.  We know our string length calculation is looking for a zero byte so unless our msg2 variable starts with a zero byte it keeps counting as if it&#39;s the same string (and as far as assembly is concerned it is the same string).  So we need to put a zero byte or 0h after our strings to let assembly know where to stop counting.</p>

                        <p>
                            <span>Note:</span>
                            In programming 0h denotes a null byte and a null byte after a string tells assembly where it ends in memory.
                        </p>

                        <div>
                            <p><span>helloworld-inc.asm</span></p><pre>                            ; Hello World Program (NULL terminating bytes)
                            ; Compile with: nasm -f elf helloworld-inc.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-inc.o -o helloworld-inc
                            ; Run with: ./helloworld-inc

                            %include        &#39;functions.asm&#39;

                            SECTION .data
                            msg1    db      &#39;Hello, brave new world!&#39;, 0Ah, 0h          ; NOTE the null terminating byte
                            msg2    db      &#39;This is how we recycle in NASM.&#39;, 0Ah, 0h  ; NOTE the null terminating byte

                            SECTION .text
                            global  _start

                            _start:

                                mov     eax, msg1
                                call    sprint

                                mov     eax, msg2
                                call    sprint

                                call    quit
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf helloworld-inc.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-inc.o -o helloworld-inc</span>
                                    <span>~$ ./helloworld-inc</span>
                                    <span>Hello, brave new world!</span>
                                    <span>This is how we recycle in NASM.</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson7">
                    <article>
                        <header>
                            <h2>Lesson 7</h2>
                            <h4>Linefeeds</h4>
                        </header>

                        <p>Linefeeds are essential to console programs like our &#39;hello world&#39; program.  They become even more important once we start building programs that require user input. But linefeeds can be a pain to maintain.  Sometimes you will want to include them in your strings and sometimes you will want to remove them.  If we continue to hard code them in our variables by adding 0Ah after our declared message text, it will become a problem.  If there&#39;s a place in the code that we don&#39;t want to print out the linefeed for that variable we will need to write some extra logic remove it from the string at runtime.</p>

                        <p>It would be better for the maintainability of our program if we write a subroutine that will print out our message and then print a linefeed afterwards. That way we can just call this subroutine when we need the linefeed and call our current sprint subroutine when we don&#39;t.</p>

                        <p>A call to sys_write requires we pass a pointer to an address in memory of the string we want to print so we can&#39;t just pass a linefeed character (0Ah) to our print function.  We also don&#39;t want to create another variable just to hold a linefeed character so we will instead use the stack.</p>

                        <p>The way it works is by moving a linefeed character into EAX.  We then push EAX onto the stack and get the address pointed to by the Extended Stack Pointer.  ESP is another register.  When you push items onto the stack, ESP is decremented to point to the address in memory of the last item and so it can be used to access that item directly from the stack. Since ESP points to an address in memory of a character, sys_write will be able to use it to print.</p>

                        <p>
                            <span>Note:</span>
                            I&#39;ve highlighted the new code in functions.asm below.
                        </p>

                        <div>
                            <p><span>functions.asm</span></p><pre>                            ;------------------------------------------
                            ; int slen(String message)
                            ; String length calculation function
                            slen:
                                push    ebx
                                mov     ebx, eax

                            nextchar:
                                cmp     byte [eax], 0
                                jz      finished
                                inc     eax
                                jmp     nextchar

                            finished:
                                sub     eax, ebx
                                pop     ebx
                                ret


                            ;------------------------------------------
                            ; void sprint(String message)
                            ; String printing function
                            sprint:
                                push    edx
                                push    ecx
                                push    ebx
                                push    eax
                                call    slen

                                mov     edx, eax
                                pop     eax

                                mov     ecx, eax
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h

                                pop     ebx
                                pop     ecx
                                pop     edx
                                ret


                            ;------------------------------------------
                            ; void sprintLF(String message)
                            ; String printing with line feed function
                            sprintLF:
                                call    sprint

                                push    eax         ; push eax onto the stack to preserve it while we use the eax register in this function
                                mov     eax, 0Ah    ; move 0Ah into eax - 0Ah is the ascii character for a linefeed
                                push    eax         ; push the linefeed onto the stack so we can get the address
                                mov     eax, esp    ; move the address of the current stack pointer into eax for sprint
                                call    sprint      ; call our sprint function
                                pop     eax         ; remove our linefeed character from the stack
                                pop     eax         ; restore the original value of eax before our function was called
                                ret                 ; return to our program


                            ;------------------------------------------
                            ; void exit()
                            ; Exit program and restore resources
                            quit:
                                mov     ebx, 0
                                mov     eax, 1
                                int     80h
                                ret


                            </pre>
                        </div>

                        <div>
                            <p><span>helloworld-lf.asm</span></p><pre>                            ; Hello World Program (Print with line feed)
                            ; Compile with: nasm -f elf helloworld-lf.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-lf.o -o helloworld-lf
                            ; Run with: ./helloworld-lf

                            %include        &#39;functions.asm&#39;

                            SECTION .data
                            msg1    db      &#39;Hello, brave new world!&#39;, 0h          ; NOTE we have removed the line feed character 0Ah
                            msg2    db      &#39;This is how we recycle in NASM.&#39;, 0h  ; NOTE we have removed the line feed character 0Ah

                            SECTION .text
                            global  _start

                            _start:

                                mov     eax, msg1
                                call    sprintLF    ; NOTE we are calling our new print with linefeed function

                                mov     eax, msg2
                                call    sprintLF    ; NOTE we are calling our new print with linefeed function

                                call    quit
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf helloworld-lf.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-lf.o -o helloworld-lf</span>
                                    <span>~$ ./helloworld-lf</span>
                                    <span>Hello, brave new world!</span>
                                    <span>This is how we recycle in NASM.</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson8">
                    <article>
                        <header>
                            <h2>Lesson 8</h2>
                            <h4>Passing arguments</h4>
                        </header>

                        <p>Passing arguments to your program from the command line is as easy as popping them off the stack in NASM. When we run our program, any passed arguments are loaded onto the stack in reverse order.  The name of the program is then loaded onto the stack and lastly the total number of arguments is loaded onto the stack. The last two stack items for a NASM compiled program are always the name of the program and the number of passed arguments.</p>

                        <p>So all we have to do to use them is pop the number of arguments off the stack first, then iterate once for each argument and perform our logic. In our program that means calling our print function.</p>

                        <p>
                            <span>Note:</span>
                            We are using the ECX register as our counter for the loop. Although it&#39;s a general-purpose register it&#39;s original intention was to be used as a counter.
                        </p>

                        <div>
                            <p><span>helloworld-args.asm</span></p><pre>                            ; Hello World Program (Passing arguments from the command line)
                            ; Compile with: nasm -f elf helloworld-args.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-args.o -o helloworld-args
                            ; Run with: ./helloworld-args

                            %include        &#39;functions.asm&#39;

                            SECTION .text
                            global  _start

                            _start:

                                pop     ecx             ; first value on the stack is the number of arguments

                            nextArg:
                                cmp     ecx, 0h         ; check to see if we have any arguments left
                                jz      noMoreArgs      ; if zero flag is set jump to noMoreArgs label (jumping over the end of the loop)
                                pop     eax             ; pop the next argument off the stack
                                call    sprintLF        ; call our print with linefeed function
                                dec     ecx             ; decrease ecx (number of arguments left) by 1
                                jmp     nextArg         ; jump to nextArg label

                            noMoreArgs:
                                call    quit
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf helloworld-args.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-args.o -o helloworld-args</span>
                                    <span>~$ ./helloworld-args &#34;This is one argument&#34; &#34;This is another&#34; 101</span>
                                    <span>./helloworld-args</span>
                                    <span>This is one argument</span>
                                    <span>This is another</span>
                                    <span>101</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson9">
                    <article>
                        <header>
                            <h2>Lesson 9</h2>
                            <h4>User input</h4>
                        </header>

                        <h5>Introduction to the .bss section</h5>

                        <p>So far we&#39;ve used the .text and .data section so now it&#39;s time to introduce the .bss section. BSS stands for Block Started by Symbol.  It is an area in our program that is used to reserve space in memory for uninitialised variables. We will use it to reserve some space in memory to hold our user input since we don&#39;t know how many bytes we&#39;ll need to store.</p>

                        <p>The syntax to declare variables is as follows:</p>

                        <div>
                            <p><span>.bss section example</span></p><pre>                            SECTION .bss
                            variableName1:      RESB    1       ; reserve space for 1 byte
                            variableName2:      RESW    1       ; reserve space for 1 word
                            variableName3:      RESD    1       ; reserve space for 1 double word
                            variableName4:      RESQ    1       ; reserve space for 1 double precision float (quad word)
                            variableName5:      REST    1       ; reserve space for 1 extended precision float
                            </pre>
                        </div>

                        <h5>Writing our program</h5>

                        <p>We will be using the system call sys_read to receive and process input from the user. This function is assigned OPCODE 3 in the Linux System Call Table. Just like sys_write this function also takes 3 arguments which will be loaded into EDX, ECX and EBX before requesting a software interrupt that will call the function.</p>

                        <p>The arguments passed are as follows:
                            </p><ul>
                                <li> EDX will be loaded with the maximum length (in bytes) of the space in memory.</li>
                                <li> ECX will be loaded with the address of our variable created in the .bss section.</li>
                                <li> EBX will be loaded with the file we want to write to – in this case STDIN.</li>
                            </ul>
                            As always the datatype and meaning of the arguments passed can be found in the function&#39;s definition.
                        

                        <p>When sys_read detects a linefeed, control returns to the program and the users input is located at the memory address you passed in ECX.</p>

                        <div>
                            <p><span>helloworld-input.asm</span></p><pre>                            ; Hello World Program (Getting input)
                            ; Compile with: nasm -f elf helloworld-input.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-input.o -o helloworld-input
                            ; Run with: ./helloworld-input

                            %include        &#39;functions.asm&#39;

                            SECTION .data
                            msg1        db      &#39;Please enter your name: &#39;, 0h      ; message string asking user for input
                            msg2        db      &#39;Hello, &#39;, 0h                       ; message string to use after user has entered their name

                            SECTION .bss
                            sinput:     resb    255                                 ; reserve a 255 byte space in memory for the users input string

                            SECTION .text
                            global  _start

                            _start:

                                mov     eax, msg1
                                call    sprint

                                mov     edx, 255        ; number of bytes to read
                                mov     ecx, sinput     ; reserved space to store our input (known as a buffer)
                                mov     ebx, 0          ; write to the STDIN file
                                mov     eax, 3          ; invoke SYS_READ (kernel opcode 3)
                                int     80h

                                mov     eax, msg2
                                call    sprint

                                mov     eax, sinput     ; move our buffer into eax (Note: input contains a linefeed)
                                call    sprint          ; call our print function

                                call    quit
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf helloworld-input.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-input.o -o helloworld-input</span>
                                    <span>~$ ./helloworld-input</span>
                                    <span>Please enter your name: Daniel Givney</span>
                                    <span>Hello, Daniel Givney</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson10">
                    <article>
                        <header>
                            <h2>Lesson 10</h2>
                            <h4>Count to 10</h4>
                        </header>

                        <h5>Firstly, some background</h5>

                        <p>Counting by numbers is not as straight forward as you would think in assembly.  Firstly we need to pass sys_write an address in memory so we can&#39;t just load our register with a number and call our print function.  Secondly, numbers and strings are very different things in assembly.  Strings are represented by what are called ASCII values.  ASCII stands for <strong>American Standard Code for Information Interchange</strong>.  A good reference for ASCII <a href="http://www.asciitable.com/">can be found here</a>. ASCII was created as a way to standardise the representation of strings across all computers.</p>

                        <p>Remember, we can&#39;t print a number - we have to print a string. In order to count to 10 we will need to convert our numbers from standard integers to their ASCII string representations.  Have a look at the ASCII values table and notice that the string representation for the number &#39;1&#39; is actually &#39;49&#39; in ASCII. In fact, adding 48 to our numbers is all we have to do to convert them from integers to their ASCII string representations.</p>

                        <h5>Writing our program</h5>

                        <p>What we will do with our program is count from 1 to 10 using the ECX register.  We will then add 48 to our counter to convert it from a number to it&#39;s ASCII string representation.  We will then push this value to the stack and call our print function passing ESP as the memory address to print from.  Once we have finished counting to 10 we will exit our counting loop and call our quit function.</p>

                        <div>
                            <p><span>helloworld-10.asm</span></p><pre>                            ; Hello World Program (Count to 10)
                            ; Compile with: nasm -f elf helloworld-10.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-10.o -o helloworld-10
                            ; Run with: ./helloworld-10

                            %include        &#39;functions.asm&#39;

                            SECTION .text
                            global  _start

                            _start:

                                mov     ecx, 0          ; ecx is initalised to zero.

                            nextNumber:
                                inc     ecx             ; increment ecx

                                mov     eax, ecx        ; move the address of our integer into eax
                                add     eax, 48         ; add 48 to our number to convert from integer to ascii for printing
                                push    eax             ; push eax to the stack
                                mov     eax, esp        ; get the address of the character on the stack
                                call    sprintLF        ; call our print function

                                pop     eax             ; clean up the stack so we don&#39;t have unneeded bytes taking up space
                                cmp     ecx, 10         ; have we reached 10 yet? compare our counter with decimal 10
                                jne     nextNumber      ; jump if not equal and keep counting

                                call    quit
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf helloworld-10.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-10.o -o helloworld-10</span>
                                    <span>~$ ./helloworld-10</span>
                                    <span>1</span>
                                    <span>2</span>
                                    <span>3</span>
                                    <span>4</span>
                                    <span>5</span>
                                    <span>6</span>
                                    <span>7</span>
                                    <span>8</span>
                                    <span>9</span>
                                    <span>:</span>
                                </p>
                            </div>
                        </div>

                        <p>
                            <span>Error:</span>
                            Our number 10 prints a colon (:) character instead.  What&#39;s going on?
                        </p>

                    </article>
                </div>

                <hr/>

                <div id="lesson11">
                    <article>
                        <header>
                            <h2>Lesson 11</h2>
                            <h4>Count to 10 (itoa)</h4>
                        </header>

                        <p>So why did our program in Lesson 10 print out a colon character instead of the number 10?.  Well lets have a look at our ASCII table.  We can see that the colon character has a ASCII value of 58.  We were adding 48 to our integers to convert them to their ASCII string representations so instead of passing sys_write the value &#39;58&#39; to print ten we actually need to pass the ASCII value for the number 1 followed by the ASCII value for the number 0. Passing sys_write &#39;4948&#39; is the correct string representation for the number &#39;10&#39;. So we can&#39;t just simply add 48 to our numbers to convert them, we first have to divide them by 10 because each place value needs to be converted individually.</p>

                        <p>We will write 2 new subroutines in this lesson &#39;iprint&#39; and &#39;iprintLF&#39;.  These functions will be used when we want to print ASCII string representations of numbers.  We achieve this by passing the number in EAX.  We then initialise a counter in ECX.  We will repeatedly divide the number by 10 and each time convert the remainder to a string by adding 48.  We will then push this onto the stack for later use. Once we can no longer divide the number by 10 we will enter our second loop.  In this print loop we will print the now converted string representations from the stack and pop them off.  Popping them off the stack moves ESP forward to the next item on the stack. Each time we print a value we will decrease our counter ECX.  Once all numbers have been converted and printed we will return to our program.</p>

                        <h5>How does the divide instruction work?</h5>

                        <p>The DIV and IDIV instructions work by dividing whatever is in EAX by the value passed to the instruction.  The quotient part of the value is left in EAX and the remainder part is put into EDX (Originally called the data register).

                        </p><p>For example.</p>

                        <div>
                            <p><span>IDIV instruction example</span></p><pre>                            mov     eax, 10         ; move 10 into eax
                            mov     esi, 10         ; move 10 into esi
                            idiv    esi             ; divide eax by esi (eax will equal 1 and edx will equal 0)
                            idiv    esi             ; divide eax by esi again (eax will equal 0 and edx will equal 1)
                            </pre>
                        </div>

                        <h5>If we are only storing the remainder won&#39;t we have problems?</h5>

                        <p>No, because these are integers, when you divide a number by an even bigger number the quotient in EAX is 0 and the remainder is the number itself. This is because the number divides zero times leaving the original value as the remainder in EDX. How good is that?</p>

                        <p>
                            <span>Note:</span>
                            Only the new functions iprint and iprintLF have comments.
                        </p>

                        <div>
                            <p><span>functions.asm</span></p><pre>                            ;------------------------------------------
                            ; void iprint(Integer number)
                            ; Integer printing function (itoa)
                            iprint:
                                push    eax             ; preserve eax on the stack to be restored after function runs
                                push    ecx             ; preserve ecx on the stack to be restored after function runs
                                push    edx             ; preserve edx on the stack to be restored after function runs
                                push    esi             ; preserve esi on the stack to be restored after function runs
                                mov     ecx, 0          ; counter of how many bytes we need to print in the end

                            divideLoop:
                                inc     ecx             ; count each byte to print - number of characters
                                mov     edx, 0          ; empty edx
                                mov     esi, 10         ; mov 10 into esi
                                idiv    esi             ; divide eax by esi
                                add     edx, 48         ; convert edx to it&#39;s ascii representation - edx holds the remainder after a divide instruction
                                push    edx             ; push edx (string representation of an intger) onto the stack
                                cmp     eax, 0          ; can the integer be divided anymore?
                                jnz     divideLoop      ; jump if not zero to the label divideLoop

                            printLoop:
                                dec     ecx             ; count down each byte that we put on the stack
                                mov     eax, esp        ; mov the stack pointer into eax for printing
                                call    sprint          ; call our string print function
                                pop     eax             ; remove last character from the stack to move esp forward
                                cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?
                                jnz     printLoop       ; jump is not zero to the label printLoop

                                pop     esi             ; restore esi from the value we pushed onto the stack at the start
                                pop     edx             ; restore edx from the value we pushed onto the stack at the start
                                pop     ecx             ; restore ecx from the value we pushed onto the stack at the start
                                pop     eax             ; restore eax from the value we pushed onto the stack at the start
                                ret


                            ;------------------------------------------
                            ; void iprintLF(Integer number)
                            ; Integer printing function with linefeed (itoa)
                            iprintLF:
                                call    iprint          ; call our integer printing function

                                push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function
                                mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed
                                push    eax             ; push the linefeed onto the stack so we can get the address
                                mov     eax, esp        ; move the address of the current stack pointer into eax for sprint
                                call    sprint          ; call our sprint function
                                pop     eax             ; remove our linefeed character from the stack
                                pop     eax             ; restore the original value of eax before our function was called
                                ret


                            ;------------------------------------------
                            ; int slen(String message)
                            ; String length calculation function
                            slen:
                                push    ebx
                                mov     ebx, eax

                            nextchar:
                                cmp     byte [eax], 0
                                jz      finished
                                inc     eax
                                jmp     nextchar

                            finished:
                                sub     eax, ebx
                                pop     ebx
                                ret


                            ;------------------------------------------
                            ; void sprint(String message)
                            ; String printing function
                            sprint:
                                push    edx
                                push    ecx
                                push    ebx
                                push    eax
                                call    slen

                                mov     edx, eax
                                pop     eax

                                mov     ecx, eax
                                mov     ebx, 1
                                mov     eax, 4
                                int     80h

                                pop     ebx
                                pop     ecx
                                pop     edx
                                ret


                            ;------------------------------------------
                            ; void sprintLF(String message)
                            ; String printing with line feed function
                            sprintLF:
                                call    sprint

                                push    eax
                                mov     eax, 0AH
                                push    eax
                                mov     eax, esp
                                call    sprint
                                pop     eax
                                pop     eax
                                ret


                            ;------------------------------------------
                            ; void exit()
                            ; Exit program and restore resources
                            quit:
                                mov     ebx, 0
                                mov     eax, 1
                                int     80h
                                ret


                            </pre>
                        </div>

                        <div>
                            <p><span>helloworld-itoa.asm</span></p><pre>                            ; Hello World Program (Count to 10 itoa)
                            ; Compile with: nasm -f elf helloworld-itoa.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-itoa.o -o helloworld-itoa
                            ; Run with: ./helloworld-itoa

                            %include        &#39;functions.asm&#39;

                            SECTION .text
                            global  _start

                            _start:

                                mov     ecx, 0

                            nextNumber:
                                inc     ecx
                                mov     eax, ecx
                                call    iprintLF        ; NOTE call our new integer printing function (itoa)
                                cmp     ecx, 10
                                jne     nextNumber

                                call    quit
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf helloworld-itoa.asm</span>
                                    <span>~$ ld -m elf_i386 helloworld-itoa.o -o helloworld-itoa</span>
                                    <span>~$ ./helloworld-itoa</span>
                                    <span>1</span>
                                    <span>2</span>
                                    <span>3</span>
                                    <span>4</span>
                                    <span>5</span>
                                    <span>6</span>
                                    <span>7</span>
                                    <span>8</span>
                                    <span>9</span>
                                    <span>10</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson12">
                    <article>
                        <header>
                            <h2>Lesson 12</h2>
                            <h4>Calculator - addition</h4>
                        </header>

                        <p>In this program we will be adding the registers EAX and EBX together and we&#39;ll leave our answer in EAX. Firstly we use the MOV instruction to load EAX with an integer (in this case 90).  We then MOV an integer into EBX (in this case 9).  Now all we need to do is use the ADD instruction to perform our addition. EBX &amp; EAX will be added together leaving our answer in the left most register in this instruction (in our case EAX). Then all we need to do is call our integer printing function to complete the program.</p>

                        <div>
                            <p><span>calculator-addition.asm</span></p><pre>                            ; Calculator (Addition)
                            ; Compile with: nasm -f elf calculator-addition.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-addition.o -o calculator-addition
                            ; Run with: ./calculator-addition

                            %include        &#39;functions.asm&#39;

                            SECTION .text
                            global  _start

                            _start:

                                mov     eax, 90     ; move our first number into eax
                                mov     ebx, 9      ; move our second number into ebx
                                add     eax, ebx    ; add ebx to eax
                                call    iprintLF    ; call our integer print with linefeed function

                                call    quit
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf calculator-addition.asm</span>
                                    <span>~$ ld -m elf_i386 calculator-addition.o -o calculator-addition</span>
                                    <span>~$ ./calculator-addition</span>
                                    <span>99</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson13">
                    <article>
                        <header>
                            <h2>Lesson 13</h2>
                            <h4>Calculator - subtraction</h4>
                        </header>
                        <p>In this program we will be subtracting the value in the register EBX from the value in the register EAX.  Firstly we load EAX and EBX with integers in the same way as Lesson 12.  The only difference is we will be using the SUB instruction to perform our subtraction logic, leaving our answer in the left most register of this instruction (in our case EAX). Then all we need to do is call our integer printing function to complete the program.</p>
                        <div>
                            <p><span>calculator-subtraction.asm</span></p><pre>                            ; Calculator (Subtraction)
                            ; Compile with: nasm -f elf calculator-subtraction.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-subtraction.o -o calculator-subtraction
                            ; Run with: ./calculator-subtraction

                            %include        &#39;functions.asm&#39;

                            SECTION .text
                            global  _start

                            _start:

                                mov     eax, 90     ; move our first number into eax
                                mov     ebx, 9      ; move our second number into ebx
                                sub     eax, ebx    ; subtract ebx from eax
                                call    iprintLF    ; call our integer print with linefeed function

                                call    quit
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf calculator-subtraction.asm</span>
                                    <span>~$ ld -m elf_i386 calculator-subtraction.o -o calculator-subtraction</span>
                                    <span>~$ ./calculator-subtraction</span>
                                    <span>81</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson14">
                    <article>
                        <header>
                            <h2>Lesson 14</h2>
                            <h4>Calculator - multiplication</h4>
                        </header>

                        <p>In this program we will be multiplying the value in EBX by the value present in EAX.  Firstly we load EAX and EBX with integers in the same way as Lesson 12.  This time though we will be calling the MUL instruction to perform our multiplication logic.  The MUL instruction is different from many instructions in NASM, in that it only accepts one further argument.  The MUL instruction always multiples EAX by whatever value is passed after it.  The answer is left in EAX.</p>

                        <div>
                            <p><span>calculator-multiplication.asm</span></p><pre>                            ; Calculator (Multiplication)
                            ; Compile with: nasm -f elf calculator-multiplication.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-multiplication.o -o calculator-multiplication
                            ; Run with: ./calculator-multiplication

                            %include        &#39;functions.asm&#39;

                            SECTION .text
                            global  _start

                            _start:

                                mov     eax, 90     ; move our first number into eax
                                mov     ebx, 9      ; move our second number into ebx
                                mul     ebx         ; multiply eax by ebx
                                call    iprintLF    ; call our integer print with linefeed function

                                call    quit
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf calculator-multiplication.asm</span>
                                    <span>~$ ld -m elf_i386 calculator-multiplication.o -o calculator-multiplication</span>
                                    <span>~$ ./calculator-multiplication</span>
                                    <span>810</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson15">
                    <article>
                        <header>
                            <h2>Lesson 15</h2>
                            <h4>Calculator - division</h4>
                        </header>

                        <p>In this program we will be dividing the value in EBX by the value present in EAX.  We&#39;ve used division before in our integer print subroutine. Our program requires a few extra strings in order to print out the correct answer but otherwise there&#39;s nothing complicated going on.</p>

                        <p>Firstly we load EAX and EBX with integers in the same way as Lesson 12.  Division logic is performed using the DIV instruction.  The DIV instruction always divides EAX by the value passed after it.  It will leave the quotient part of the answer in EAX and put the remainder part in EDX (the original data register).  We then MOV and call our strings and integers to print out the correct answer.</p>

                        <div>
                            <p><span>calculator-division.asm</span></p><pre>                            ; Calculator (Division)
                            ; Compile with: nasm -f elf calculator-division.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-division.o -o calculator-division
                            ; Run with: ./calculator-division

                            %include        &#39;functions.asm&#39;

                            SECTION .data
                            msg1        db      &#39; remainder &#39;      ; a message string to correctly output result

                            SECTION .text
                            global  _start

                            _start:

                                mov     eax, 90     ; move our first number into eax
                                mov     ebx, 9      ; move our second number into ebx
                                div     ebx         ; divide eax by ebx
                                call    iprint      ; call our integer print function on the quotient
                                mov     eax, msg1   ; move our message string into eax
                                call    sprint      ; call our string print function
                                mov     eax, edx    ; move our remainder into eax
                                call    iprintLF    ; call our integer printing with linefeed function

                                call    quit
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf calculator-division.asm</span>
                                    <span>~$ ld -m elf_i386 calculator-division.o -o calculator-division</span>
                                    <span>~$ ./calculator-division</span>
                                    <span>10 remainder 0</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson16">
                    <article>
                        <header>
                            <h2>Lesson 16</h2>
                            <h4>Calculator (atoi)</h4>
                        </header>

                        <p>Our program will take several command line arguments and add them together printing out the result in the terminal.</p>

                        <h5>Writing our program</h5>

                        <p>Our program begins by using the POP instruction to get the number of passed arguments off the stack.  This value is stored in ECX (originally known as the counter register).  It will then POP the next value off the stack containing the program name and remove it from the number of arguments stored in ECX.  It will then loop through the rest of the arguments popping each one off the stack and performing our addition logic. As we know, arguments passed via the command line are received by our program as strings.  Before we can add the arguments together we will need to convert them to integers otherwise our result will not be correct. We do this by calling our Ascii to Integer function (atoi).  This function will convert the ascii value into an integer and place the result in EAX.  We can then add this value to EDX (originally known as the data register) where we will store the result of our additions. If the value passed to atoi is not an ascii representation of an integer our function will return zero instead. When all arguments have been converted and added together we will print out the result and call our quit function.</p>

                        <h5>How does the atoi function work</h5>

                        <p>Converting an ascii string into an integer value is not a trivial task.  We know how to convert an integer to an ascii string so the process should essentially work in reverse.  Firstly we take the address of the string and move it into ESI (originally known as the source register). We will then move along the string byte by byte (think of each byte as being a single digit or decimal placeholder).  For each digit we will check if it&#39;s value is between 48-57 (ascii values for the digits 0-9).</p>

                        <p>Once we have performed this check and determined that the byte can be converted to an integer we will perform the following logic.  We will subtract 48 from the value – converting the ascii value to it&#39;s decimal equivalent. We will then add this value to EAX (the general purpose register that will store our result). We will then multiple EAX by 10 as each byte represents a decimal placeholder and continue the loop.</p>

                        <p>When all bytes have been converted we need to do one last thing before we return the result.  The last digit of any number represents a single unit (not a multiple of 10) so we have multiplied our result one too many times.  We simple divide it by 10 once to correct this and then return. If no integer arguments were pass however, we skip this divide instruction.</p>

                        <h5>What is the BL register</h5>

                        <p>You may have noticed that the atoi function references the BL register.  So far in these tutorials we have been exclusively using 32bit registers.   These 32bit general purpose registers contain segments of memory that can also be referenced. These segments are available in 16bits and 8bits.  We wanted a single byte (8bits) because a byte is the size of memory that is required to store a single ascii character.  If we used a larger memory size we would have copied 8bits of data into 32bits of space leaving us with &#39;rubbish&#39; bits - because only the first 8bits would be meaningful for our calculation.</p>

                        <p>The EBX register is 32bits.  EBX&#39;s 16 bit segment is referenced as BX.  BX contains the 8bit segments BL and BH (Lower and Higher bits).  We wanted the first 8bits (lower bits) of EBX and so we referenced that storage area using BL.</p>

                        <p>Almost every assembly language tutorial begins with a history of the registers, their names and their sizes.  These tutorials however were written to provide a foundation in NASM by first writing code and then understanding the theory. The full story about the size of registers, their history and importance are beyond the scope of this tutorial but we will return to that story in later tutorials.</p>

                        <p>
                            <span>Note:</span>
                            Only the new function in this file &#39;atoi&#39; is shown below.
                        </p>

                        <div>
                            <p><span>functions.asm</span></p><pre>                                ;------------------------------------------
                                ; int atoi(Integer number)
                                ; Ascii to integer function (atoi)
                                atoi:
                                    push    ebx             ; preserve ebx on the stack to be restored after function runs
                                    push    ecx             ; preserve ecx on the stack to be restored after function runs
                                    push    edx             ; preserve edx on the stack to be restored after function runs
                                    push    esi             ; preserve esi on the stack to be restored after function runs
                                    mov     esi, eax        ; move pointer in eax into esi (our number to convert)
                                    mov     eax, 0          ; initialise eax with decimal value 0
                                    mov     ecx, 0          ; initialise ecx with decimal value 0

                                .multiplyLoop:
                                    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0
                                    mov     bl, [esi+ecx]   ; move a single byte into ebx register&#39;s lower half
                                    cmp     bl, 48          ; compare ebx register&#39;s lower half value against ascii value 48 (char value 0)
                                    jl      .finished       ; jump if less than to label finished
                                    cmp     bl, 57          ; compare ebx register&#39;s lower half value against ascii value 57 (char value 9)
                                    jg      .finished       ; jump if greater than to label finished

                                    sub     bl, 48          ; convert ebx register&#39;s lower half to decimal representation of ascii value
                                    add     eax, ebx        ; add ebx to our interger value in eax
                                    mov     ebx, 10         ; move decimal value 10 into ebx
                                    mul     ebx             ; multiply eax by ebx to get place value
                                    inc     ecx             ; increment ecx (our counter register)
                                    jmp     .multiplyLoop   ; continue multiply loop

                                .finished:
                                    cmp     ecx, 0          ; compare ecx register&#39;s value against decimal 0 (our counter register)
                                    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)
                                    mov     ebx, 10         ; move decimal value 10 into ebx
                                    div     ebx             ; divide eax by value in ebx (in this case 10)

                                .restore:
                                    pop     esi             ; restore esi from the value we pushed onto the stack at the start
                                    pop     edx             ; restore edx from the value we pushed onto the stack at the start
                                    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start
                                    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start
                                    ret
                            </pre>
                        </div>

                        <div>
                            <p><span>calculator-atoi.asm</span></p><pre>                            ; Calculator (ATOI)
                            ; Compile with: nasm -f elf calculator-atoi.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-atoi.o -o calculator-atoi
                            ; Run with: ./calculator-atoi 20 1000 317

                            %include        &#39;functions.asm&#39;

                            SECTION .text
                            global  _start

                            _start:

                                pop     ecx             ; first value on the stack is the number of arguments
                                pop     edx             ; second value on the stack is the program name (discarded when we initialise edx)
                                sub     ecx, 1          ; decrease ecx by 1 (number of arguments without program name)
                                mov     edx, 0          ; initialise our data register to store additions

                            nextArg:
                                cmp     ecx, 0h         ; check to see if we have any arguments left
                                jz      noMoreArgs      ; if zero flag is set jump to noMoreArgs label (jumping over the end of the loop)
                                pop     eax             ; pop the next argument off the stack
                                call    atoi            ; convert our ascii string to decimal integer
                                add     edx, eax        ; perform our addition logic
                                dec     ecx             ; decrease ecx (number of arguments left) by 1
                                jmp     nextArg         ; jump to nextArg label

                            noMoreArgs:
                                mov     eax, edx        ; move our data result into eax for printing
                                call    iprintLF        ; call our integer printing with linefeed function
                                call    quit            ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf calculator-atoi.asm</span>
                                    <span>~$ ld -m elf_i386 calculator-atoi.o -o calculator-atoi</span>
                                    <span>~$ ./calculator-atoi 20 1000 317</span>
                                    <span>1337</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson17">
                    <article>
                        <header>
                            <h2>Lesson 17</h2>
                            <h4>Namespace</h4>
                        </header>

                        <p>Namespace is a necessary construct in any software project that involves a codebase that is larger than a few simple functions.  Namespace provides scope to your identifiers and allows you to reuse naming conventions to make your code more readable and maintainable.  In assembly language where subroutines are identified by global labels, namespace can be achieved by using local labels.</p>

                        <p>Up until the last few tutorials we have been using global labels exclusively.  This means that blocks of logic that essentially perform the same task needed a label with a unique identifier.  A good example would be our &#34;finished&#34; labels.  These were global in scope meaning when we needed to break out of a loop in one function we could jump to a &#34;finished&#34; label.  But if we needed to break out of a loop in a different function we would need to name this same task something else maybe calling it &#34;done&#34; or &#34;continue&#34;. Being able to reuse the label &#34;finished&#34; would mean that someone reading the code would know that these blocks of logic perform almost the same task.</p>

                        <p>Local labels are prepended with a &#34;.&#34; at the beginning of their name for example &#34;.finished&#34;. You may have noticed them appearing as our code base in functions.asm grew.  A local label is given the namespace of the first global label above it. You can jump to a local label by using the JMP instruction and the compiler will calculate which local label you are referencing by determining in what scope (based on the above global labels) the instruction was called.</p>

                        <p>
                            <span>Note:</span>
                            The file <a href="https://github.com/DGivney/assemblytutorials/blob/master/code/lesson17/functions.asm" target="_blank">functions.asm</a> was modified adding namespaces in all the subroutines. This is particularly important in the &#34;slen&#34; subroutine which contains a &#34;finished&#34; global label.
                        </p>

                        <div>
                            <p><span>namespace.asm</span></p><pre>                            ; Namespace
                            ; Compile with: nasm -f elf namespace.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 namespace.o -o namespace
                            ; Run with: ./namespace

                            %include        &#39;functions.asm&#39;

                            SECTION .data
                            msg1        db      &#39;Jumping to finished label.&#39;, 0h        ; a message string
                            msg2        db      &#39;Inside subroutine number: &#39;, 0h        ; a message string
                            msg3        db      &#39;Inside subroutine &#34;finished&#34;.&#39;, 0h     ; a message string

                            SECTION .text
                            global  _start

                            _start:

                            subrountineOne:
                                mov     eax, msg1       ; move the address of msg1 into eax
                                call    sprintLF        ; call our string printing with linefeed function
                                jmp     .finished       ; jump to the local label under the subrountineOne scope

                            .finished:
                                mov     eax, msg2       ; move the address of msg2 into eax
                                call    sprint          ; call our string printing function
                                mov     eax, 1          ; move the value one into eax (for subroutine number one)
                                call    iprintLF        ; call our integer printing function with linefeed function

                            subrountineTwo:
                                mov     eax, msg1       ; move the address of msg1 into eax
                                call    sprintLF        ; call our string print with linefeed function
                                jmp     .finished       ; jump to the local label under the subrountineTwo scope

                            .finished:
                                mov     eax, msg2       ; move the address of msg2 into eax
                                call    sprint          ; call our string printing function
                                mov     eax, 2          ; move the value two into eax (for subroutine number two)
                                call    iprintLF        ; call our integer printing function with linefeed function

                                mov     eax, msg1       ; move the address of msg1 into eax
                                call    sprintLF        ; call our string printing with linefeed function
                                jmp     finished        ; jump to the global label finished

                            finished:
                                mov     eax, msg3       ; move the address of msg3 into eax
                                call    sprintLF        ; call our string printing with linefeed function
                                call    quit            ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf namespace.asm</span>
                                    <span>~$ ld -m elf_i386 namespace.o -o namespace</span>
                                    <span>~$ ./namespace</span>
                                    <span>Jumping to finished label.</span>
                                    <span>Inside subroutine number: 1</span>
                                    <span>Jumping to finished label.</span>
                                    <span>Inside subroutine number: 2</span>
                                    <span>Jumping to finished label.</span>
                                    <span>Inside subroutine &#34;finished&#34;.</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson18">
                    <article>
                        <header>
                            <h2>Lesson 18</h2>
                            <h4>Fizz Buzz</h4>
                        </header>

                        <h5>Firstly, some background</h5>

                        <p>FizzBuzz is group word game played in schools to teach children division.  Players take turns to count aloud integers from 1 to 100 replacing any number divisible by 3 with the word &#34;fizz&#34; and any number divisible by 5 with the word &#34;buzz&#34;.  Numbers that are both divisible by 3 and 5 are replaced by the word &#34;fizzbuzz&#34;.  This children&#39;s game has also become a defacto interview screening question for computer programming jobs as it&#39;s thought to easily discover candidates that can&#39;t construct a simple logic gate.</p>

                        <h5>Writing our program</h5>

                        <p>There are a number of code solutions to this simple game and some languages offer very trivial and elegant solutions.  Depending on how you choose to solve it, the solution almost always involves an if statement and possibly an else statement depending whether you choose to exploit the mathematical property that anything divisible by 5 &amp; 3 would also be divisible by 3 * 5.  Being that this is an assembly language tutorial we will provide a solution that involves a structure of two cascading if statements to print the words &#34;fizz&#34; and/or &#34;buzz&#34; and an else statement in case these fail, to print the integer as an ascii value.  Each iteration of our loop will then print a line feed. Once we reach 100 we call our program exit function.</p>

                        <div>
                            <p><span>fizzbuzz.asm</span></p><pre>                            ; Fizzbuzz
                            ; Compile with: nasm -f elf fizzbuzz.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 fizzbuzz.o -o fizzbuzz
                            ; Run with: ./fizzbuzz

                            %include        &#39;functions.asm&#39;

                            SECTION .data
                            fizz        db      &#39;Fizz&#39;, 0h     ; a message string
                            buzz        db      &#39;Buzz&#39;, 0h     ; a message string

                            SECTION .text
                            global  _start

                            _start:

                                mov     esi, 0          ; initialise our checkFizz boolean variable
                                mov     edi, 0          ; initialise our checkBuzz boolean variable
                                mov     ecx, 0          ; initialise our counter variable

                            nextNumber:
                                inc     ecx             ; increment our counter variable

                            .checkFizz:
                                mov     edx, 0          ; clear the edx register - this will hold our remainder after division
                                mov     eax, ecx        ; move the value of our counter into eax for division
                                mov     ebx, 3          ; move our number to divide by into ebx (in this case the value is 3)
                                div     ebx             ; divide eax by ebx
                                mov     edi, edx        ; move our remainder into edi (our checkFizz boolean variable)
                                cmp     edi, 0          ; compare if the remainder is zero (meaning the counter divides by 3)
                                jne     .checkBuzz      ; if the remainder is not equal to zero jump to local label checkBuzz
                                mov     eax, fizz       ; else move the address of our fizz string into eax for printing
                                call    sprint          ; call our string printing function

                            .checkBuzz:
                                mov     edx, 0          ; clear the edx register - this will hold our remainder after division
                                mov     eax, ecx        ; move the value of our counter into eax for division
                                mov     ebx, 5          ; move our number to divide by into ebx (in this case the value is 5)
                                div     ebx             ; divide eax by ebx
                                mov     esi, edx        ; move our remainder into edi (our checkBuzz boolean variable)
                                cmp     esi, 0          ; compare if the remainder is zero (meaning the counter divides by 5)
                                jne     .checkInt       ; if the remainder is not equal to zero jump to local label checkInt
                                mov     eax, buzz       ; else move the address of our buzz string into eax for printing
                                call    sprint          ; call our string printing function

                            .checkInt:
                                cmp     edi, 0          ; edi contains the remainder after the division in checkFizz
                                je     .continue        ; if equal (counter divides by 3) skip printing the integer
                                cmp     esi, 0          ; esi contains the remainder after the division in checkBuzz
                                je     .continue        ; if equal (counter divides by 5) skip printing the integer
                                mov     eax, ecx        ; else move the value in ecx (our counter) into eax for printing
                                call    iprint          ; call our integer printing function

                            .continue:
                                mov     eax, 0Ah        ; move an ascii linefeed character into eax
                                push    eax             ; push the address of eax onto the stack for printing
                                mov     eax, esp        ; get the stack pointer (address on the stack of our linefeed char)
                                call    sprint          ; call our string printing function to print a line feed
                                pop     eax             ; pop the stack so we don&#39;t waste resources
                                cmp     ecx, 100        ; compare if our counter is equal to 100
                                jne     nextNumber      ; if not equal jump to the start of the loop

                                call    quit            ; else call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf fizzbuzz.asm</span>
                                    <span>~$ ld -m elf_i386 fizzbuzz.o -o fizzbuzz</span>
                                    <span>~$ ./fizzbuzz</span>
                                    <span>1</span>
                                    <span>2</span>
                                    <span>Fizz</span>
                                    <span>4</span>
                                    <span>Buzz</span>
                                    <span>Fizz</span>
                                    <span>7</span>
                                    <span>8</span>
                                    <span>Fizz</span>
                                    <span>Buzz</span>
                                    <span>11</span>
                                    <span>Fizz</span>
                                    <span>13</span>
                                    <span>14</span>
                                    <span>FizzBuzz</span>
                                    <span>16</span>
                                    <span>...</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson19">
                    <article>
                        <header>
                            <h2>Lesson 19</h2>
                            <h4>Execute Command</h4>
                        </header>

                        <h5>Firstly, some background</h5>

                        <p>The EXEC family of functions replace the currently running process with a new process, that executes the command you specified when calling it.  We will be using the SYS_EXECVE function in this lesson to replace our program&#39;s running process with a new process that will execute the linux program /bin/echo to print out “Hello World!”.</p>

                        <h5>Naming convention</h5>

                        <p>The naming convention used for this family of functions is <strong>exec</strong> (execute) followed by one or more of the following letters.</p>

                        <ul>
                            <li><span>e</span> - An array of pointers to environment variables is explicitly passed to the new process image.</li>
                            <li><span>l</span> - Command-line arguments are passed individually to the function.</li>
                            <li><span>p</span> - Uses the PATH environment variable to find the file named in the path argument to be executed.</li>
                            <li><span>v</span> - Command-line arguments are passed to the function as an array of pointers.</li>
                        </ul>

                        <h5>Writing our program</h5>

                        <p>The <span>V</span> &amp; <span>E</span> at the end of our function name means we will need to pass our arguments in the following format:  The first argument is a string containing the command to execute, then an array of arguments to pass to that command and then another array of environment variables that the new process will use.  As we are calling a simple command we won&#39;t pass any special environment variables to the new process and instead will pass 0h (null).</p>

                        <p>Both the command arguments and the environment arguments need to be passed as an array of pointers (addresses to memory).  That&#39;s why we define our strings first and then define a simple null-terminated struct (array) of the variables names.  This is then passed to SYS_EXECVE. We call the function and the process is replaced by our command and output is returned to the terminal.</p>

                        <div>
                            <p><span>execute.asm</span></p><pre>                            ; Execute
                            ; Compile with: nasm -f elf execute.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 execute.o -o execute
                            ; Run with: ./execute

                            %include        &#39;functions.asm&#39;

                            SECTION .data
                            command         db      &#39;/bin/echo&#39;, 0h     ; command to execute
                            arg1            db      &#39;Hello World!&#39;, 0h
                            arguments       dd      command
                                            dd      arg1                ; arguments to pass to commandline (in this case just one)
                                            dd      0h                  ; end the struct
                            environment     dd      0h                  ; arguments to pass as environment variables (inthis case none) end the struct

                            SECTION .text
                            global  _start

                            _start:

                                mov     edx, environment    ; address of environment variables
                                mov     ecx, arguments      ; address of the arguments to pass to the commandline
                                mov     ebx, command        ; address of the file to execute
                                mov     eax, 11             ; invoke SYS_EXECVE (kernel opcode 11)
                                int     80h

                                call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf execute.asm</span>
                                    <span>~$ ld -m elf_i386 execute.o -o execute</span>
                                    <span>~$ ./execute</span>
                                    <span>Hello World!</span>
                                </p>
                            </div>
                        </div>

                        <p>
                            <span>Note:</span>
                            Here are a couple other commands to try.
                        </p>

                        <div>
                            <p><span>execute.asm</span></p><pre>                            SECTION .data
                            command         db      &#39;/bin/ls&#39;, 0h       ; command to execute
                            arg1            db      &#39;-l&#39;, 0h
                            </pre>
                        </div>

                        <div>
                            <p><span>execute.asm</span></p><pre>                            SECTION .data
                            command         db      &#39;/bin/sleep&#39;, 0h    ; command to execute
                            arg1            db      &#39;5&#39;, 0h
                            </pre>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson20">
                    <article>
                        <header>
                            <h2>Lesson 20</h2>
                            <h4>Process Forking</h4>
                        </header>

                        <h5>Firstly, some background</h5>

                        <p>In this lesson we will use SYS_FORK to create a new process that duplicates our current process.  SYS_FORK takes no arguments - you just call fork and the new process is created.  Both processes run concurrently. We can test the return value (in eax) to test whether we are currently in the parent or child process.  The parent process returns a non-negative, non-zero integer.  In the child process EAX is zero.  This can be used to branch your logic between the parent and child.</p>

                        <p>In our program we exploit this fact to print out different messages in each process.</p>

                        <p>
                            <span>Note:</span>
                            Each process is responsible for safely exiting.
                        </p>

                        <div>
                            <p><span>fork.asm</span></p><pre>                            ; Fork
                            ; Compile with: nasm -f elf fork.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 fork.o -o fork
                            ; Run with: ./fork

                            %include        &#39;functions.asm&#39;

                            SECTION .data
                            childMsg        db      &#39;This is the child process&#39;, 0h     ; a message string
                            parentMsg       db      &#39;This is the parent process&#39;, 0h    ; a message string

                            SECTION .text
                            global  _start

                            _start:

                                mov     eax, 2              ; invoke SYS_FORK (kernel opcode 2)
                                int     80h

                                cmp     eax, 0              ; if eax is zero we are in the child process
                                jz      child               ; jump if eax is zero to child label

                            parent:
                                mov     eax, parentMsg      ; inside our parent process move parentMsg into eax
                                call    sprintLF            ; call our string printing with linefeed function

                                call    quit                ; quit the parent process

                            child:
                                mov     eax, childMsg       ; inside our child process move childMsg into eax
                                call    sprintLF            ; call our string printing with linefeed function

                                call    quit                ; quit the child process
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf fork.asm</span>
                                    <span>~$ ld -m elf_i386 fork.o -o fork</span>
                                    <span>~$ ./fork</span>
                                    <span>This is the parent process</span>
                                    <span>This is the child process</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson21">
                    <article>
                        <header>
                            <h2>Lesson 21</h2>
                            <h4>Telling the time</h4>
                        </header>

                        <p>Generating a unix timestamp in NASM is easy with the SYS_TIME function of the linux kernel.  Simply pass OPCODE 13 to the kernel with no arguments and you are returned the <a href="https://en.wikipedia.org/wiki/Unix_epoch">Unix Epoch</a> in the EAX register.</p>

                        <p>That is the number of seconds that have elapsed since January 1st 1970 UTC.</p>

                        <div>
                            <p><span>time.asm</span></p><pre>                            ; Time
                            ; Compile with: nasm -f elf time.asm
                            ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 time.o -o time
                            ; Run with: ./time

                            %include        &#39;functions.asm&#39;

                            SECTION .data
                            msg        db      &#39;Seconds since Jan 01 1970: &#39;, 0h     ; a message string

                            SECTION .text
                            global  _start

                            _start:

                                mov     eax, msg        ; move our message string into eax for printing
                                call    sprint          ; call our string printing function

                                mov     eax, 13         ; invoke SYS_TIME (kernel opcode 13)
                                int     80h             ; call the kernel

                                call    iprintLF        ; call our integer printing function with linefeed
                                call    quit            ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf time.asm</span>
                                    <span>~$ ld -m elf_i386 time.o -o time</span>
                                    <span>~$ ./time</span>
                                    <span>Seconds since Jan 01 1970: 1374995660</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson22">
                    <article>
                        <header>
                            <h2>Lesson 22</h2>
                            <h4>File Handling - Create</h4>
                        </header>

                        <h5>Firstly, some background</h5>

                        <p>File Handling in Linux is achieved through a small number of system calls related to creating, updating and deleting files. These functions require a <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank">file descriptor</a> which is a unique, non-negative integer that identifies the file on the system.</p>

                        <h5>Writing our program</h5>

                        <p>We begin the tutorial by creating a file using sys_creat.  We will then build upon our program in each of the following file handling lessons, adding code as we go. Eventually we will have a full program that can create, update, open, close and delete files.</p>

                        <p>sys_creat expects 2 arguments - the file permissions in ECX and the filename in EBX.  The sys_creat opcode is then loaded into EAX and the kernel is called to create the file. The file descriptor of the created file is returned in EAX. This file descriptor can then be used for all other file handling functions.</p>

                        <div>
                            <p><span>create.asm</span></p><pre>                                ; Create
                                ; Compile with: nasm -f elf create.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 create.o -o create
                                ; Run with: ./create

                                %include    &#39;functions.asm&#39;

                                SECTION .data
                                filename db &#39;readme.txt&#39;, 0h    ; the filename to create

                                SECTION .text
                                global  _start

                                _start:

                                    mov     ecx, 0777o          ; set all permissions to read, write, execute
                                    mov     ebx, filename       ; filename we will create
                                    mov     eax, 8              ; invoke SYS_CREAT (kernel opcode 8)
                                    int     80h                 ; call the kernel

                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf create.asm</span>
                                    <span>~$ ld -m elf_i386 create.o -o create</span>
                                    <span>~$ ./create</span>
                                </p>
                            </div>
                        </div>

                        <p>
                            <span>Note:</span>
                            The file &#39;readme.txt&#39; will now have been created in the folder.
                        </p>

                    </article>
                </div>

                <hr/>

                <div id="lesson23">
                    <article>
                        <header>
                            <h2>Lesson 23</h2>
                            <h4>File Handling - Write</h4>
                        </header>

                        <p>Building upon the previous lesson we will now use sys_write to write content to a newly created file.</p>

                        <p>sys_write expects 3 arguments - the number of bytes to write in EDX, the contents string to write in ECX and the <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank">file descriptor</a> in EBX.  The sys_write opcode is then loaded into EAX and the kernel is called to write the content to the file. In this lesson we will first call sys_creat to get a file descriptor which we will then load into EBX.</p>

                        <div>
                            <p><span>write.asm</span></p><pre>                                ; Write
                                ; Compile with: nasm -f elf write.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 write.o -o write
                                ; Run with: ./write

                                %include    &#39;functions.asm&#39;

                                SECTION .data
                                filename db &#39;readme.txt&#39;, 0h    ; the filename to create
                                contents db &#39;Hello world!&#39;, 0h  ; the contents to write

                                SECTION .text
                                global  _start

                                _start:

                                    mov     ecx, 0777o          ; code continues from lesson 22
                                    mov     ebx, filename
                                    mov     eax, 8
                                    int     80h

                                    mov     edx, 12             ; number of bytes to write - one for each letter of our contents string
                                    mov     ecx, contents       ; move the memory address of our contents string into ecx
                                    mov     ebx, eax            ; move the file descriptor of the file we created into ebx
                                    mov     eax, 4              ; invoke SYS_WRITE (kernel opcode 4)
                                    int     80h                 ; call the kernel

                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf write.asm</span>
                                    <span>~$ ld -m elf_i386 write.o -o write</span>
                                    <span>~$ ./write</span>
                                </p>
                            </div>
                        </div>

                        <p>
                            <span>Note:</span>
                            Open the newly created file &#39;readme.txt&#39; in this folder and you will see the content &#39;Hello world!&#39;.
                        </p>

                    </article>
                </div>

                <hr/>

                <div id="lesson24">
                    <article>
                        <header>
                            <h2>Lesson 24</h2>
                            <h4>File Handling - Open</h4>
                        </header>

                        <p>Building upon the previous lesson we will now use sys_open to obtain the <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank">file descriptor</a> of the newly created file. This file descriptor can then be used for all other file handling functions.</p>

                        <p>sys_open expects 2 arguments - the access mode (table below) in ECX and the filename in EBX.  The sys_open opcode is then loaded into EAX and the kernel is called to open the file and return the file descriptor.</p>

                        <p>sys_open additionally accepts zero or more file creation flags and file status flags in EDX. <a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank">Click here for more information about the access mode, file creation flags and file status flags</a>.</p>

                        <div>
                            <div>
                                <table>
                                    <thead>
                                        <tr>
                                            <th></th>
                                            <th>Description</th>
                                            <th>Value</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td><b>O_RDONLY</b></td>
                                            <td>open file in read only mode</td>
                                            <td>0</td>
                                        </tr>
                                        <tr>
                                            <td><b>O_WRONLY</b></td>
                                            <td>open file in write only mode</td>
                                            <td>1</td>
                                        </tr>
                                        <tr>
                                            <td><b>O_RDWR</b></td>
                                            <td>open file in read and write mode</td>
                                            <td>2</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <p>
                            <span>Note:</span>
                            sys_open returns the file descriptor in EAX. On linux this will be a unique, non-negative integer which we will print using our integer printing function.
                        </p>

                        <div>
                            <p><span>open.asm</span></p><pre>                                ; Open
                                ; Compile with: nasm -f elf open.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 open.o -o open
                                ; Run with: ./open

                                %include    &#39;functions.asm&#39;

                                SECTION .data
                                filename db &#39;readme.txt&#39;, 0h    ; the filename to create
                                contents db &#39;Hello world!&#39;, 0h  ; the contents to write

                                SECTION .text
                                global  _start

                                _start:

                                    mov     ecx, 0777o          ; Create file from lesson 22
                                    mov     ebx, filename
                                    mov     eax, 8
                                    int     80h

                                    mov     edx, 12             ; Write contents to file from lesson 23
                                    mov     ecx, contents
                                    mov     ebx, eax
                                    mov     eax, 4
                                    int     80h

                                    mov     ecx, 0              ; flag for readonly access mode (O_RDONLY)
                                    mov     ebx, filename       ; filename we created above
                                    mov     eax, 5              ; invoke SYS_OPEN (kernel opcode 5)
                                    int     80h                 ; call the kernel

                                    call    iprintLF            ; call our integer printing function
                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf open.asm</span>
                                    <span>~$ ld -m elf_i386 open.o -o open</span>
                                    <span>~$ ./open</span>
                                    <span>4</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson25">
                    <article>
                        <header>
                            <h2>Lesson 25</h2>
                            <h4>File Handling - Read</h4>
                        </header>

                        <p>Building upon the previous lesson we will now use sys_read to read the content of a newly created and opened file. We will store this string in a variable.</p>

                        <p>sys_read expects 3 arguments - the number of bytes to read in EDX, the memory address of our variable in ECX and the <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank">file descriptor</a> in EBX.  We will use the previous lessons sys_open code to obtain the file descriptor which we will then load into EBX. The sys_read opcode is then loaded into EAX and the kernel is called to read the file contents into our variable and is then printed to the screen.</p>

                        <p>
                            <span>Note:</span>
                            We will reserve 255 bytes in the .bss section to store the contents of the file. <a href="#lesson9">See Lesson 9 for more information on the .bss section.</a>
                        </p>

                        <div>
                            <p><span>read.asm</span></p><pre>                                ; Read
                                ; Compile with: nasm -f elf read.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 read.o -o read
                                ; Run with: ./read

                                %include    &#39;functions.asm&#39;

                                SECTION .data
                                filename db &#39;readme.txt&#39;, 0h    ; the filename to create
                                contents db &#39;Hello world!&#39;, 0h  ; the contents to write

                                SECTION .bss
                                fileContents resb 255,          ; variable to store file contents

                                SECTION .text
                                global  _start

                                _start:

                                    mov     ecx, 0777o          ; Create file from lesson 22
                                    mov     ebx, filename
                                    mov     eax, 8
                                    int     80h

                                    mov     edx, 12             ; Write contents to file from lesson 23
                                    mov     ecx, contents
                                    mov     ebx, eax
                                    mov     eax, 4
                                    int     80h

                                    mov     ecx, 0              ; Open file from lesson 24
                                    mov     ebx, filename
                                    mov     eax, 5
                                    int     80h

                                    mov     edx, 12             ; number of bytes to read - one for each letter of the file contents
                                    mov     ecx, fileContents   ; move the memory address of our file contents variable into ecx
                                    mov     ebx, eax            ; move the opened file descriptor into EBX
                                    mov     eax, 3              ; invoke SYS_READ (kernel opcode 3)
                                    int     80h                 ; call the kernel

                                    mov     eax, fileContents   ; move the memory address of our file contents variable into eax for printing
                                    call    sprintLF            ; call our string printing function

                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf read.asm</span>
                                    <span>~$ ld -m elf_i386 read.o -o read</span>
                                    <span>~$ ./read</span>
                                    <span>Hello world!</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <hr/>

                <div id="lesson26">
                    <article>
                        <header>
                            <h2>Lesson 26</h2>
                            <h4>File Handling - Close</h4>
                        </header>

                        <p>Building upon the previous lesson we will now use sys_close to properly close an open file.</p>

                        <p>sys_close expects 1 argument - the <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank">file descriptor</a> in EBX.  We will use the previous lessons code to obtain the file descriptor which we will then load into EBX. The sys_close opcode is then loaded into EAX and the kernel is called to close the file and remove the active file descriptor.</p>

                        <div>
                            <p><span>close.asm</span></p><pre>                                ; Close
                                ; Compile with: nasm -f elf close.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 close.o -o close
                                ; Run with: ./close

                                %include    &#39;functions.asm&#39;

                                SECTION .data
                                filename db &#39;readme.txt&#39;, 0h    ; the filename to create
                                contents db &#39;Hello world!&#39;, 0h  ; the contents to write

                                SECTION .bss
                                fileContents resb 255,          ; variable to store file contents

                                SECTION .text
                                global  _start

                                _start:

                                    mov     ecx, 0777o          ; Create file from lesson 22
                                    mov     ebx, filename
                                    mov     eax, 8
                                    int     80h

                                    mov     edx, 12             ; Write contents to file from lesson 23
                                    mov     ecx, contents
                                    mov     ebx, eax
                                    mov     eax, 4
                                    int     80h

                                    mov     ecx, 0              ; Open file from lesson 24
                                    mov     ebx, filename
                                    mov     eax, 5
                                    int     80h

                                    mov     edx, 12             ; Read file from lesson 25
                                    mov     ecx, fileContents
                                    mov     ebx, eax
                                    mov     eax, 3
                                    int     80h

                                    mov     eax, fileContents
                                    call    sprintLF

                                    mov     ebx, ebx            ; not needed but used to demonstrate that SYS_CLOSE takes a file descriptor from EBX
                                    mov     eax, 6              ; invoke SYS_CLOSE (kernel opcode 6)
                                    int     80h                 ; call the kernel

                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf close.asm</span>
                                    <span>~$ ld -m elf_i386 close.o -o close</span>
                                    <span>~$ ./close</span>
                                    <span>Hello world!</span>
                                </p>
                            </div>
                        </div>

                        <p>
                            <span>Note:</span>
                            We have properly closed the file and removed the active file descriptor.
                        </p>

                    </article>
                </div>

                <hr/>

                <div id="lesson27">
                    <article>
                        <header>
                            <h2>Lesson 27</h2>
                            <h4>File Handling - Seek</h4>
                        </header>

                        <p>In this lesson we will open a file and update the file contents at the end of the file using sys_lseek.</p>

                        <p>Using sys_lseek you can move the cursor within the file by an offset in bytes.  The below example will move the cursor to the end of the file, then pass 0 bytes as the offset (so we append to the end of the file and not beyond) before writing a string in that position.  Try different values in ECX and EDX to write the content to different positions within the opened file.</p>

                        <p>sys_lseek expects 3 arguments - the whence argument (table below) in EDX, the offset in bytes in ECX, and the <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank">file descriptor</a> in EBX. The sys_lseek opcode is then loaded into EAX and we call the kernel to move the file pointer to the correct offset.  We then use sys_write to update the content at that position.</p>

                        <div>
                            <div>
                                <table>
                                    <thead>
                                        <tr>
                                            <th></th>
                                            <th>Description</th>
                                            <th>Value</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td><b>SEEK_SET</b></td>
                                            <td>beginning of the file</td>
                                            <td>0</td>
                                        </tr>
                                        <tr>
                                            <td><b>SEEK_CUR</b></td>
                                            <td>current file offset</td>
                                            <td>1</td>
                                        </tr>
                                        <tr>
                                            <td><b>SEEK_END</b></td>
                                            <td>end of the file</td>
                                            <td>2</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        </article>
                </div>

                <div id="lesson28">
                    <article>
                        <header>
                            <h2>Lesson 28</h2>
                            <h4>File Handling - Delete</h4>
                        </header>

                        <p>Deleting a file on linux is achieved by calling sys_unlink.</p>

                        <p>sys_unlink expects 1 argument - the filename in EBX.  The sys_unlink opcode is then loaded into EAX and the kernel is called to delete the file.</p>

                        <p>
                            <span>Note:</span>
                            A file &#39;readme.txt&#39; has been included in the code folder for this lesson. This file will be deleted after running the program.
                        </p>

                        <div>
                            <p><span>unlink.asm</span></p><pre>                                ; Unlink
                                ; Compile with: nasm -f elf unlink.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 unlink.o -o unlink
                                ; Run with: ./unlink

                                %include    &#39;functions.asm&#39;

                                SECTION .data
                                filename db &#39;readme.txt&#39;, 0h    ; the filename to delete

                                SECTION .text
                                global  _start

                                _start:

                                    mov     ebx, filename       ; filename we will delete
                                    mov     eax, 10             ; invoke SYS_UNLINK (kernel opcode 10)
                                    int     80h                 ; call the kernel

                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf unlink.asm</span>
                                    <span>~$ ld -m elf_i386 unlink.o -o unlink</span>
                                    <span>~$ ./unlink</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <div id="lesson29">
                    <article>
                        <header>
                            <h2>Lesson 29</h2>
                            <h4>Sockets - Create</h4>
                        </header>

                        <h5>Firstly, some background</h5>

                        <p>Socket Programming in Linux is achieved through the use of the SYS_SOCKETCALL kernel function. The SYS_SOCKETCALL function is somewhat unique in that it encapsulates a number of different subroutines, all related to socket operations, within the one function. By passing different integer values in EBX we can change the behaviour of this function to create, listen, send, receive, close and more. <a href="https://gist.github.com/DGivney/7196bd7a9f21a12c9397bdcf9ae040d2" target="_blank">Click here</a> to view the full commented source code of the completed program.</p>

                        <h5>Writing our program</h5>

                        <p>We begin the tutorial by first initalizing some of our registers which we will use later to store important values.  We will then create a socket using SYS_SOCKETCALL&#39;s first subroutine which is called &#39;socket&#39;.  We will then build upon our program in each of the following socket programming lessons, adding code as we go. Eventually we will have a full program that can create, bind, listen, accept, read, write and close sockets.</p>

                        <p>SYS_SOCKETCALL&#39;s subroutine &#39;socket&#39; expects 2 arguments - a pointer to an array of arguments in ECX and the integer value 1 in EBX.  The SYS_SOCKETCALL opcode is then loaded into EAX and the kernel is called to create the socket. Because everything in linux is a file, we recieve back the <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank">file descriptor</a> of the created socket in EAX. This file descriptor can then be used for performing other socket programming functions.</p>

                        <p>
                            <span>Note:</span>
                            XORing a register by itself is an efficent way of ensuring the register is initalised with the integer value zero and doesn&#39;t contain an unexpected value that could corrupt your program.
                        </p>

                        <div>
                            <p><span>socket.asm</span></p><pre>                                ; Socket
                                ; Compile with: nasm -f elf socket.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket
                                ; Run with: ./socket

                                %include    &#39;functions.asm&#39;

                                SECTION .text
                                global  _start

                                _start:

                                    xor     eax, eax            ; init eax 0
                                    xor     ebx, ebx            ; init ebx 0
                                    xor     edi, edi            ; init edi 0
                                    xor     esi, esi            ; init esi 0

                                _socket:

                                    push    byte 6              ; push 6 onto the stack (IPPROTO_TCP)
                                    push    byte 1              ; push 1 onto the stack (SOCK_STREAM)
                                    push    byte 2              ; push 2 onto the stack (PF_INET)
                                    mov     ecx, esp            ; move address of arguments into ecx
                                    mov     ebx, 1              ; invoke subroutine SOCKET (1)
                                    mov     eax, 102            ; invoke SYS_SOCKETCALL (kernel opcode 102)
                                    int     80h                 ; call the kernel

                                    call    iprintLF            ; call our integer printing function (print the file descriptor in EAX or -1 on error)

                                _exit:

                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf socket.asm</span>
                                    <span>~$ ld -m elf_i386 socket.o -o socket</span>
                                    <span>~$ ./socket</span>
                                    <span>3</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <div id="lesson30">
                    <article>
                        <header>
                            <h2>Lesson 30</h2>
                            <h4>Sockets - Bind</h4>
                        </header>

                        <p>Building on the previous lesson we will now associate the created socket with a local IP address and port which will allow us to connect to it.  We do this by calling the second subroutine of SYS_SOCKETCALL which is called &#39;bind&#39;.</p>

                        <p>We begin by storing the file descriptor we recieved in lesson 29 into EDI.  EDI was originally called the Destination Index and is traditionally used in copy routines to store the location of a target file.</p>

                        <p>SYS_SOCKETCALL&#39;s subroutine &#39;bind&#39; expects 2 arguments - a pointer to an array of arguments in ECX and the integer value 2 in EBX.  The SYS_SOCKETCALL opcode is then loaded into EAX and the kernel is called to bind the socket.</p>

                        <div>
                            <p><span>socket.asm</span></p><pre>                                ; Socket
                                ; Compile with: nasm -f elf socket.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket
                                ; Run with: ./socket

                                %include    &#39;functions.asm&#39;

                                SECTION .text
                                global  _start

                                _start:

                                    xor     eax, eax            ; initialize some registers
                                    xor     ebx, ebx
                                    xor     edi, edi
                                    xor     esi, esi

                                _socket:

                                    push    byte 6              ; create socket from lesson 29
                                    push    byte 1
                                    push    byte 2
                                    mov     ecx, esp
                                    mov     ebx, 1
                                    mov     eax, 102
                                    int     80h

                                _bind:

                                    mov     edi, eax            ; move return value of SYS_SOCKETCALL into edi (file descriptor for new socket, or -1 on error)
                                    push    dword 0x00000000    ; push 0 dec onto the stack IP ADDRESS (0.0.0.0)
                                    push    word 0x2923         ; push 9001 dec onto stack PORT (reverse byte order)
                                    push    word 2              ; push 2 dec onto stack AF_INET
                                    mov     ecx, esp            ; move address of stack pointer into ecx
                                    push    byte 16             ; push 16 dec onto stack (arguments length)
                                    push    ecx                 ; push the address of arguments onto stack
                                    push    edi                 ; push the file descriptor onto stack
                                    mov     ecx, esp            ; move address of arguments into ecx
                                    mov     ebx, 2              ; invoke subroutine BIND (2)
                                    mov     eax, 102            ; invoke SYS_SOCKETCALL (kernel opcode 102)
                                    int     80h                 ; call the kernel

                                _exit:

                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf socket.asm</span>
                                    <span>~$ ld -m elf_i386 socket.o -o socket</span>
                                    <span>~$ ./socket</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <div id="lesson31">
                    <article>
                        <header>
                            <h2>Lesson 31</h2>
                            <h4>Sockets - Listen</h4>
                        </header>

                        <p>In the previous lessons we created a socket and used the &#39;bind&#39; subroutine to associate it with a local IP address and port.  In this lesson we will use the &#39;listen&#39; subroutine of SYS_SOCKETCALL to tell our socket to listen for incoming TCP requests. This will allow us to read and write to anyone who connects to our socket.</p>

                        <p>SYS_SOCKETCALL&#39;s subroutine &#39;listen&#39; expects 2 arguments - a pointer to an array of arguments in ECX and the integer value 4 in EBX.  The SYS_SOCKETCALL opcode is then loaded into EAX and the kernel is called. If succesful the socket will begin listening for incoming requests.</p>

                        <div>
                            <p><span>socket.asm</span></p><pre>                                ; Socket
                                ; Compile with: nasm -f elf socket.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket
                                ; Run with: ./socket

                                %include    &#39;functions.asm&#39;

                                SECTION .text
                                global  _start

                                _start:

                                    xor     eax, eax            ; initialize some registers
                                    xor     ebx, ebx
                                    xor     edi, edi
                                    xor     esi, esi

                                _socket:

                                    push    byte 6              ; create socket from lesson 29
                                    push    byte 1
                                    push    byte 2
                                    mov     ecx, esp
                                    mov     ebx, 1
                                    mov     eax, 102
                                    int     80h

                                _bind:

                                    mov     edi, eax            ; bind socket from lesson 30
                                    push    dword 0x00000000
                                    push    word 0x2923
                                    push    word 2
                                    mov     ecx, esp
                                    push    byte 16
                                    push    ecx
                                    push    edi
                                    mov     ecx, esp
                                    mov     ebx, 2
                                    mov     eax, 102
                                    int     80h

                                _listen:

                                    push    byte 1              ; move 1 onto stack (max queue length argument)
                                    push    edi                 ; push the file descriptor onto stack
                                    mov     ecx, esp            ; move address of arguments into ecx
                                    mov     ebx, 4              ; invoke subroutine LISTEN (4)
                                    mov     eax, 102            ; invoke SYS_SOCKETCALL (kernel opcode 102)
                                    int     80h                 ; call the kernel

                                _exit:

                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf socket.asm</span>
                                    <span>~$ ld -m elf_i386 socket.o -o socket</span>
                                    <span>~$ ./socket</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <div id="lesson32">
                    <article>
                        <header>
                            <h2>Lesson 32</h2>
                            <h4>Sockets - Accept</h4>
                        </header>

                        <p>In the previous lessons we created a socket and used the &#39;bind&#39; subroutine to associate it with a local IP address and port.  We then used the &#39;listen&#39; subroutine of SYS_SOCKETCALL to tell our socket to listen for incoming TCP requests. Now we will use the &#39;accept&#39; subroutine of SYS_SOCKETCALL to tell our socket to accept those incoming requests. Our socket will then be ready to read and write to remote connections.</p>

                        <p>SYS_SOCKETCALL&#39;s subroutine &#39;accept&#39; expects 2 arguments - a pointer to an array of arguments in ECX and the integer value 4 in EBX.  The SYS_SOCKETCALL opcode is then loaded into EAX and the kernel is called. The &#39;accept&#39; subroutine will create another file descriptor, this time identifying the incoming socket connection. We will use this file descriptor to read and write to the incoming connection in later lessons.</p>

                        <p>
                            <span>Note:</span>
                            Run the program and use the command <kbd>sudo netstat -plnt</kbd> in another terminal to view the socket listening on port 9001.
                        </p>

                        <div>
                            <p><span>socket.asm</span></p><pre>                                ; Socket
                                ; Compile with: nasm -f elf socket.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket
                                ; Run with: ./socket

                                %include    &#39;functions.asm&#39;

                                SECTION .text
                                global  _start

                                _start:

                                    xor     eax, eax            ; initialize some registers
                                    xor     ebx, ebx
                                    xor     edi, edi
                                    xor     esi, esi

                                _socket:

                                    push    byte 6              ; create socket from lesson 29
                                    push    byte 1
                                    push    byte 2
                                    mov     ecx, esp
                                    mov     ebx, 1
                                    mov     eax, 102
                                    int     80h

                                _bind:

                                    mov     edi, eax            ; bind socket from lesson 30
                                    push    dword 0x00000000
                                    push    word 0x2923
                                    push    word 2
                                    mov     ecx, esp
                                    push    byte 16
                                    push    ecx
                                    push    edi
                                    mov     ecx, esp
                                    mov     ebx, 2
                                    mov     eax, 102
                                    int     80h

                                _listen:

                                    push    byte 1              ; listen socket from lesson 31
                                    push    edi
                                    mov     ecx, esp
                                    mov     ebx, 4
                                    mov     eax, 102
                                    int     80h

                                _accept:

                                    push    byte 0              ; push 0 dec onto stack (address length argument)
                                    push    byte 0              ; push 0 dec onto stack (address argument)
                                    push    edi                 ; push the file descriptor onto stack
                                    mov     ecx, esp            ; move address of arguments into ecx
                                    mov     ebx, 5              ; invoke subroutine ACCEPT (5)
                                    mov     eax, 102            ; invoke SYS_SOCKETCALL (kernel opcode 102)
                                    int     80h                 ; call the kernel

                                _exit:

                                    call    quit                ; call our quit function

                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf socket.asm</span>
                                    <span>~$ ld -m elf_i386 socket.o -o socket</span>
                                    <span>~$ ./socket</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <div id="lesson33">
                    <article>
                        <header>
                            <h2>Lesson 33</h2>
                            <h4>Sockets - Read</h4>
                        </header>

                        <p>When an incoming connection is accepted by our socket, a new file descriptor identifying the incoming socket connection is returned in EAX.  In this lesson we will use this file descriptor to read the incoming request headers from the connection.</p>

                        <p>We begin by storing the file descriptor we recieved in lesson 32 into ESI.  ESI was originally called the Source Index and is traditionally used in copy routines to store the location of a target file.</p>

                        <p>We will use the kernel function sys_read to read from the incoming socket connection.  As we have done in previous lessons, we will create a variable to store the contents being read from the file descriptor. Our socket will be using the HTTP protocol to communicate.  Parsing HTTP request headers to determine the length of the incoming message and accepted response formats is beyond the scope of this tutorial.  We will instead just read up to the first 255 bytes and print that to standardout.</p>

                        <p>Once the incoming connection has been accepted, it is very common for webservers to spawn a child process to manage the read/write communication. The parent process is then free to return to the listening/accept state and accept any new incoming requests in parallel. We will implement this design pattern below using SYS_FORK and the JMP instruction prior to reading the request headers in the child process.</p>

                        <p>To generate valid request headers we will use the commandline tool <kbd>curl</kbd> to connect to our listening socket. But you can also use a standard web browser to connect in the same way.</p>

                        <p>sys_read expects 3 arguments - the number of bytes to read in EDX, the memory address of our variable in ECX and the <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank">file descriptor</a> in EBX. The sys_read opcode is then loaded into EAX and the kernel is called to read the contents into our variable which is then printed to the screen.</p>

                        <p>
                            <span>Note:</span>
                            We will reserve 255 bytes in the .bss section to store the contents being read from the file descriptor. <a href="#lesson9">See Lesson 9 for more information on the .bss section.</a>
                        </p>

                        <p>
                            <span>Note:</span>
                            Run the program and use the command <kbd>curl http://localhost:9001</kbd> in another terminal to view the request headers being read by our program.
                        </p>

                        <div>
                            <p><span>socket.asm</span></p><pre>                                ; Socket
                                ; Compile with: nasm -f elf socket.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket
                                ; Run with: ./socket

                                %include    &#39;functions.asm&#39;

                                SECTION .bss
                                buffer resb 255,                ; variable to store request headers

                                SECTION .text
                                global  _start

                                _start:

                                    xor     eax, eax            ; initialize some registers
                                    xor     ebx, ebx
                                    xor     edi, edi
                                    xor     esi, esi

                                _socket:

                                    push    byte 6              ; create socket from lesson 29
                                    push    byte 1
                                    push    byte 2
                                    mov     ecx, esp
                                    mov     ebx, 1
                                    mov     eax, 102
                                    int     80h

                                _bind:

                                    mov     edi, eax            ; bind socket from lesson 30
                                    push    dword 0x00000000
                                    push    word 0x2923
                                    push    word 2
                                    mov     ecx, esp
                                    push    byte 16
                                    push    ecx
                                    push    edi
                                    mov     ecx, esp
                                    mov     ebx, 2
                                    mov     eax, 102
                                    int     80h

                                _listen:

                                    push    byte 1              ; listen socket from lesson 31
                                    push    edi
                                    mov     ecx, esp
                                    mov     ebx, 4
                                    mov     eax, 102
                                    int     80h

                                _accept:

                                    push    byte 0              ; accept socket from lesson 32
                                    push    byte 0
                                    push    edi
                                    mov     ecx, esp
                                    mov     ebx, 5
                                    mov     eax, 102
                                    int     80h

                                _fork:

                                    mov     esi, eax            ; move return value of SYS_SOCKETCALL into esi (file descriptor for accepted socket, or -1 on error)
                                    mov     eax, 2              ; invoke SYS_FORK (kernel opcode 2)
                                    int     80h                 ; call the kernel

                                    cmp     eax, 0              ; if return value of SYS_FORK in eax is zero we are in the child process
                                    jz      _read               ; jmp in child process to _read

                                    jmp     _accept             ; jmp in parent process to _accept

                                _read:

                                    mov     edx, 255            ; number of bytes to read (we will only read the first 255 bytes for simplicity)
                                    mov     ecx, buffer         ; move the memory address of our buffer variable into ecx
                                    mov     ebx, esi            ; move esi into ebx (accepted socket file descriptor)
                                    mov     eax, 3              ; invoke SYS_READ (kernel opcode 3)
                                    int     80h                 ; call the kernel

                                    mov     eax, buffer         ; move the memory address of our buffer variable into eax for printing
                                    call    sprintLF            ; call our string printing function

                                _exit:

                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf socket.asm</span>
                                    <span>~$ ld -m elf_i386 socket.o -o socket</span>
                                    <span>~$ ./socket</span>
                                    <span>GET / HTTP/1.1</span>
                                    <span>Host: localhost:9001</span>
                                    <span>User-Agent: curl/x.xx.x</span>
                                    <span>Accept: */*</span>
                                </p>
                            </div>
                        </div>

                    </article>
                </div>

                <div id="lesson34">
                    <article>
                        <header>
                            <h2>Lesson 34</h2>
                            <h4>Sockets - Write</h4>
                        </header>

                        <p>When an incoming connection is accepted by our socket, a new file descriptor identifying the incoming socket connection is returned in EAX.  In this lesson we will use this file descriptor to send our response to the connection.</p>

                        <p>We will use the kernel function sys_write to write to the incoming socket connection. As our socket will be communicating using the HTTP protocol, we will need to send some compulsory headers in order to allow HTTP speaking clients to connect.  We will send these following the formatting rules set out in the <a href="https://tools.ietf.org/html/rfc2616?spm=5176.doc32013.2.3.Aimyd7#section-4.2" target="_blank">RFC Standard</a>.</p>

                        <p>sys_write expects 3 arguments - the number of bytes to write in EDX, the response string to write in ECX and the <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank">file descriptor</a> in EBX.  The sys_write opcode is then loaded into EAX and the kernel is called to send our response back through our socket to the incoming connection.</p>

                        <p>
                            <span>Note:</span>
                            We will create a variable in the .data section to store the response we will write to the file descriptor. <a href="#lesson1">See Lesson 1 for more information on the .data section.</a>
                        </p>

                        <p>
                            <span>Note:</span>
                            Run the program and use the command <kbd>curl http://localhost:9001</kbd> in another terminal to view the response sent via our socket. Or connect to the same address using any standard web browser.
                        </p>

                        <div>
                            <p><span>socket.asm</span></p><pre>                                ; Socket
                                ; Compile with: nasm -f elf socket.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket
                                ; Run with: ./socket

                                %include    &#39;functions.asm&#39;

                                SECTION .data
                                ; our response string
                                response db &#39;HTTP/1.1 200 OK&#39;, 0Dh, 0Ah, &#39;Content-Type: text/html&#39;, 0Dh, 0Ah, &#39;Content-Length: 14&#39;, 0Dh, 0Ah, 0Dh, 0Ah, &#39;Hello World!&#39;, 0Dh, 0Ah, 0h

                                SECTION .bss
                                buffer resb 255,                ; variable to store request headers

                                SECTION .text
                                global  _start

                                _start:

                                    xor     eax, eax            ; initialize some registers
                                    xor     ebx, ebx
                                    xor     edi, edi
                                    xor     esi, esi

                                _socket:

                                    push    byte 6              ; create socket from lesson 29
                                    push    byte 1
                                    push    byte 2
                                    mov     ecx, esp
                                    mov     ebx, 1
                                    mov     eax, 102
                                    int     80h

                                _bind:

                                    mov     edi, eax            ; bind socket from lesson 30
                                    push    dword 0x00000000
                                    push    word 0x2923
                                    push    word 2
                                    mov     ecx, esp
                                    push    byte 16
                                    push    ecx
                                    push    edi
                                    mov     ecx, esp
                                    mov     ebx, 2
                                    mov     eax, 102
                                    int     80h

                                _listen:

                                    push    byte 1              ; listen socket from lesson 31
                                    push    edi
                                    mov     ecx, esp
                                    mov     ebx, 4
                                    mov     eax, 102
                                    int     80h

                                _accept:

                                    push    byte 0              ; accept socket from lesson 32
                                    push    byte 0
                                    push    edi
                                    mov     ecx, esp
                                    mov     ebx, 5
                                    mov     eax, 102
                                    int     80h

                                _fork:

                                    mov     esi, eax            ; fork socket from lesson 33
                                    mov     eax, 2
                                    int     80h

                                    cmp     eax, 0
                                    jz      _read

                                    jmp     _accept

                                _read:

                                    mov     edx, 255            ; read socket from lesson 33
                                    mov     ecx, buffer
                                    mov     ebx, esi
                                    mov     eax, 3
                                    int     80h

                                    mov     eax, buffer
                                    call    sprintLF

                                _write:

                                    mov     edx, 78             ; move 78 dec into edx (length in bytes to write)
                                    mov     ecx, response       ; move address of our response variable into ecx
                                    mov     ebx, esi            ; move file descriptor into ebx (accepted socket id)
                                    mov     eax, 4              ; invoke SYS_WRITE (kernel opcode 4)
                                    int     80h                 ; call the kernel

                                _exit:

                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf socket.asm</span>
                                    <span>~$ ld -m elf_i386 socket.o -o socket</span>
                                    <span>~$ ./socket</span>
                                </p>
                            </div>

                            </div>

                    </article>
                </div>

                <div id="lesson35">
                    <article>
                        <header>
                            <h2>Lesson 35</h2>
                            <h4>Sockets - Close</h4>
                        </header>

                        <p>In this lesson we will use sys_close to properly close the active socket connection in the child process after our response has been sent. This will free up some resources that can be used to accept new incoming connections.</p>

                        <p>sys_close expects 1 argument - the <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank">file descriptor</a> in EBX. The sys_close opcode is then loaded into EAX and the kernel is called to close the socket and remove the active file descriptor.</p>

                        <p>
                            <span>Note:</span>
                            Run the program and use the command <kbd>curl http://localhost:9001</kbd> in another terminal or connect to the same address using any standard web browser.
                        </p>

                        <div>
                            <p><span>socket.asm</span></p><pre>                                ; Socket
                                ; Compile with: nasm -f elf socket.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket
                                ; Run with: ./socket

                                %include    &#39;functions.asm&#39;

                                SECTION .data
                                ; our response string
                                response db &#39;HTTP/1.1 200 OK&#39;, 0Dh, 0Ah, &#39;Content-Type: text/html&#39;, 0Dh, 0Ah, &#39;Content-Length: 14&#39;, 0Dh, 0Ah, 0Dh, 0Ah, &#39;Hello World!&#39;, 0Dh, 0Ah, 0h

                                SECTION .bss
                                buffer resb 255,                ; variable to store request headers

                                SECTION .text
                                global  _start

                                _start:

                                    xor     eax, eax            ; initialize some registers
                                    xor     ebx, ebx
                                    xor     edi, edi
                                    xor     esi, esi

                                _socket:

                                    push    byte 6              ; create socket from lesson 29
                                    push    byte 1
                                    push    byte 2
                                    mov     ecx, esp
                                    mov     ebx, 1
                                    mov     eax, 102
                                    int     80h

                                _bind:

                                    mov     edi, eax            ; bind socket from lesson 30
                                    push    dword 0x00000000
                                    push    word 0x2923
                                    push    word 2
                                    mov     ecx, esp
                                    push    byte 16
                                    push    ecx
                                    push    edi
                                    mov     ecx, esp
                                    mov     ebx, 2
                                    mov     eax, 102
                                    int     80h

                                _listen:

                                    push    byte 1              ; listen socket from lesson 31
                                    push    edi
                                    mov     ecx, esp
                                    mov     ebx, 4
                                    mov     eax, 102
                                    int     80h

                                _accept:

                                    push    byte 0              ; accept socket from lesson 32
                                    push    byte 0
                                    push    edi
                                    mov     ecx, esp
                                    mov     ebx, 5
                                    mov     eax, 102
                                    int     80h

                                _fork:

                                    mov     esi, eax            ; fork socket from lesson 33
                                    mov     eax, 2
                                    int     80h

                                    cmp     eax, 0
                                    jz      _read

                                    jmp     _accept

                                _read:

                                    mov     edx, 255            ; read socket from lesson 33
                                    mov     ecx, buffer
                                    mov     ebx, esi
                                    mov     eax, 3
                                    int     80h

                                    mov     eax, buffer
                                    call    sprintLF

                                _write:

                                    mov     edx, 78             ; write socket from lesson 34
                                    mov     ecx, response
                                    mov     ebx, esi
                                    mov     eax, 4
                                    int     80h

                                _close:

                                    mov     ebx, esi            ; move esi into ebx (accepted socket file descriptor)
                                    mov     eax, 6              ; invoke SYS_CLOSE (kernel opcode 6)
                                    int     80h                 ; call the kernel

                                _exit:

                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf socket.asm</span>
                                    <span>~$ ld -m elf_i386 socket.o -o socket</span>
                                    <span>~$ ./socket</span>
                                </p>
                            </div>

                            </div>

                        <p>
                            <span>Note:</span>
                            We have properly closed the socket connections and removed their active file descriptors.
                        </p>

                    </article>
                </div>

                <div id="lesson36">
                    <article>
                        <header>
                            <h2>Lesson 36</h2>
                            <h4>Download a Webpage</h4>
                        </header>

                        <p>In the previous lessons we have been learning how to use the many subroutines of the SYS_SOCKETCALL kernel function to create, manage and transfer data through Linux sockets. We will continue that theme in this lesson by using the &#39;connect&#39; subroutine of SYS_SOCKETCALL to connect to a remote webserver and download a webpage.</p>

                        <p>These are the steps we need to follow to connect a socket to a remote server:
                            </p><ul>
                                <li> Call SYS_SOCKETCALL&#39;s subroutine &#39;socket&#39; to create an active socket that we will use to send outbound requests.</li>
                                <li> Call SYS_SOCKETCALL&#39;s subroutine &#39;connect&#39; to connect our socket with a socket on the remote webserver.</li>
                                <li> Use SYS_WRITE to send a HTTP formatted request through our socket to the remote webserver.</li>
                                <li> Use SYS_READ to recieve the HTTP formatted response from the webserver.</li>
                            </ul>
                            We will then use our string printing function to print the response to our terminal.
                        

                        <h5>What is a HTTP Request</h5>

                        <p>The HTTP specification has evolved through a number of standard versions including <a href="https://tools.ietf.org/html/rfc1945" target="_blank">1.0 in RFC1945</a>, <a href="https://tools.ietf.org/html/rfc2068" target="_blank">1.1 in RFC2068</a> and <a href="https://tools.ietf.org/html/rfc7540" target="_blank">2.0 in RFC7540</a>.  Version 1.1 is still the most common today.</p>

                        <p>A HTTP/1.1 request is comprised of 3 sections:
                            </p><ol>
                                <li> A line containing the <i>request method</i>, <i>request url</i>, and <i>http version</i></li>
                                <li> An optional section of <i><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">request headers</a></i></li>
                                <li> An <i>empty line</i> that tells the remote server you have finished sending the request and you will begin waiting for the response.</li>
                            </ol>
                        

                        <p>A typical HTTP request for the root document on this server would look like this:</p>

                        <div>
                            <pre>                                GET / HTTP/1.1                  ; A line containing the request method, url and version
                                Host: asmtutor.com              ; A section of request headers
                                                                ; A required empty line
                            </pre>
                        </div>

                        <h5>Writing our program</h5>

                        <p>This tutorial starts out like the previous ones by calling SYS_SOCKETCALL&#39;s subroutine &#39;socket&#39; to initially create our socket.  However, instead of calling &#39;bind&#39; on this socket we will call &#39;connect&#39; with an IP Address and Port Number to connect our socket to a remote webserver. We will then use the SYS_WRITE and SYS_READ kernel methods to transfer data between the two sockets by sending a HTTP request and reading the HTTP response.</p>

                        <p>SYS_SOCKETCALL&#39;s subroutine &#39;connect&#39; expects 2 arguments - a pointer to an array of arguments in ECX and the integer value 3 in EBX.  The SYS_SOCKETCALL opcode is then loaded into EAX and the kernel is called to connect to the socket.</p>

                        <p>
                            <span>Note:</span>
                            In Linux we can use the following command <kbd>./crawler &gt; index.html</kbd> to save the output of our program to a file instead.
                        </p>

                        <div>
                            <p><span>crawler.asm</span></p><pre>                                ; Crawler
                                ; Compile with: nasm -f elf crawler.asm
                                ; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 crawler.o -o crawler
                                ; Run with: ./crawler

                                %include    &#39;functions.asm&#39;

                                SECTION .data
                                ; our request string
                                request db &#39;GET / HTTP/1.1&#39;, 0Dh, 0Ah, &#39;Host: 139.162.39.66:80&#39;, 0Dh, 0Ah, 0Dh, 0Ah, 0h

                                SECTION .bss
                                buffer resb 1,                  ; variable to store response

                                SECTION .text
                                global  _start

                                _start:

                                    xor     eax, eax            ; init eax 0
                                    xor     ebx, ebx            ; init ebx 0
                                    xor     edi, edi            ; init edi 0

                                _socket:

                                    push    byte 6              ; push 6 onto the stack (IPPROTO_TCP)
                                    push    byte 1              ; push 1 onto the stack (SOCK_STREAM)
                                    push    byte 2              ; push 2 onto the stack (PF_INET)
                                    mov     ecx, esp            ; move address of arguments into ecx
                                    mov     ebx, 1              ; invoke subroutine SOCKET (1)
                                    mov     eax, 102            ; invoke SYS_SOCKETCALL (kernel opcode 102)
                                    int     80h                 ; call the kernel

                                _connect:

                                    mov     edi, eax            ; move return value of SYS_SOCKETCALL into edi (file descriptor for new socket, or -1 on error)
                                    push    dword 0x4227a28b    ; push 139.162.39.66 onto the stack IP ADDRESS (reverse byte order)
                                    push    word 0x5000         ; push 80 onto stack PORT (reverse byte order)
                                    push    word 2              ; push 2 dec onto stack AF_INET
                                    mov     ecx, esp            ; move address of stack pointer into ecx
                                    push    byte 16             ; push 16 dec onto stack (arguments length)
                                    push    ecx                 ; push the address of arguments onto stack
                                    push    edi                 ; push the file descriptor onto stack
                                    mov     ecx, esp            ; move address of arguments into ecx
                                    mov     ebx, 3              ; invoke subroutine CONNECT (3)
                                    mov     eax, 102            ; invoke SYS_SOCKETCALL (kernel opcode 102)
                                    int     80h                 ; call the kernel

                                _write:

                                    mov     edx, 43             ; move 43 dec into edx (length in bytes to write)
                                    mov     ecx, request        ; move address of our request variable into ecx
                                    mov     ebx, edi            ; move file descriptor into ebx (created socket file descriptor)
                                    mov     eax, 4              ; invoke SYS_WRITE (kernel opcode 4)
                                    int     80h                 ; call the kernel

                                _read:

                                    mov     edx, 1              ; number of bytes to read (we will read 1 byte at a time)
                                    mov     ecx, buffer         ; move the memory address of our buffer variable into ecx
                                    mov     ebx, edi            ; move edi into ebx (created socket file descriptor)
                                    mov     eax, 3              ; invoke SYS_READ (kernel opcode 3)
                                    int     80h                 ; call the kernel

                                    cmp     eax, 0              ; if return value of SYS_READ in eax is zero, we have reached the end of the file
                                    jz      _close              ; jmp to _close if we have reached the end of the file (zero flag set)

                                    mov     eax, buffer         ; move the memory address of our buffer variable into eax for printing
                                    call    sprint              ; call our string printing function
                                    jmp     _read               ; jmp to _read

                                _close:

                                    mov     ebx, edi            ; move edi into ebx (connected socket file descriptor)
                                    mov     eax, 6              ; invoke SYS_CLOSE (kernel opcode 6)
                                    int     80h                 ; call the kernel

                                _exit:

                                    call    quit                ; call our quit function
                            </pre>
                            <div>
                                <p><span>~$ nasm -f elf crawler.asm</span>
                                    <span>~$ ld -m elf_i386 crawler.o -o crawler</span>
                                    <span>~$ ./crawler</span>
                                    <span>HTTP/1.1 200 OK</span>
                                    <span>Content-Type: text/html</span>
                                    <span> </span>
                                    <span>&lt;!DOCTYPE html&gt;</span>
                                    <span>&lt;html lang=&#34;en&#34;&gt;</span>
                                    <span>...</span>
                                    <span>&lt;/html&gt;</span>
                                </p>
                            </div>
                        </div>
                    </article>
                </div>

                </div></div>
  </body>
</html>
