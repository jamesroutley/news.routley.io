<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/antimof/UxPlay">Original</a>
    <h1>UxPlay: AirPlay Unix mirroring server</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
          <article itemprop="text">
<p dir="auto">This project is a GPLv3 open source unix AirPlay2 Mirror server for Linux, macOS, and *BSD.
It is now hosted at the
github site <a href="https://github.com/FDH2/UxPlay">https://github.com/FDH2/UxPlay</a> (where development and user-assistance now takes place), although it initially was developed by
<a href="http://github.com/antimof/Uxplay">antimof</a> using code
from <a href="https://github.com/FD-/RPiPlay">RPiPlay</a>, which in turn derives from
<a href="https://github.com/KqsMea8/AirplayServer">AirplayServer</a>,
<a href="https://github.com/juhovh/shairplay">shairplay</a>, and <a href="https://github.com/EstebanKubata/playfair">playfair</a>.   (The antimof site is
mainly inactive, but periodically posts updates pulled from the <a href="https://github.com/FDH2/UxPlay">main UxPlay site</a>).</p>
<p dir="auto">Its main use is to act like an AppleTV for screen-mirroring (with audio) of iOS/iPadOS/macOS clients
(iPhones, iPads, MacBooks) in a window
on the server display (with the possibility of
sharing that window on screen-sharing applications such as Zoom)
on a host running Linux, macOS, or other unix.  UxPlay supports a &#34;legacy&#34; form of Apple&#39;s AirPlay Mirror protocol introduced
in iOS 12; client devices running iOS/iPadOS 12 or later are supported, as is a (nonfree) Windows-based
AirPlay-client software emulator, AirMyPC.  Older (32-bit) client devices that can only run iOS 9.3 or iOS 10.3 are
currently partially supported by UxPlay: reports indicate that
screen-mirroring video works, audio is a work in progess.
(Details of what is publically known about Apple&#39;s AirPlay2 protocol can be found
<a href="https://github.com/SteeBono/airplayreceiver/wiki/AirPlay2-Protocol">here</a> and
<a href="https://emanuelecozzi.net/docs/airplay2" rel="nofollow">here</a>).</p>
<p dir="auto">The UxPlay server and its client must be on the same local area network,
on which a <strong>Bonjour/Zeroconf mDNS/DNS-SD server</strong>  is also running
(only DNS-SD &#34;Service Discovery&#34; service is strictly necessary, it is not necessary that the local network also be of the &#34;.local&#34; mDNS-based type).
On Linux and BSD Unix servers, this is usually provided by <a href="https://www.avahi.org" rel="nofollow">Avahi</a>,
through the avahi-daemon service, and is included in  most Linux distributions (this
service can also be provided by macOS, iOS or Windows servers).</p>
<p dir="auto">Connections to the UxPlay server by
iOS/MacOS  clients can be initiated both in AirPlay Mirror mode (which streams
lossily-compressed AAC audio while mirroring the client screen,
or in the alternative AirPlay Audio mode which streams
Apple Lossless (ALAC) audio without screen mirroring (the accompanying metadata and cover art in
this mode is not displayed).  <em>Switching between these two modes during an active  connection is
possible: in Mirror mode, close the mirror window and start an Audio mode connection,
switch back by initiating a Mirror mode connection.</em>  <strong>Note that Apple DRM
(as in Apple TV app content on the client) cannot be decrypted by UxPlay,
and (unlike with a true AppleTV), the client cannot run a http connection on the server
instead of streaming content from one on the client.</strong></p>
<p dir="auto">UxPlay uses GStreamer Plugins for rendering audio and video,
and does not offer the  alternative Raspberry-Pi-specific
audio and video renderers available in <a href="https://github.com/FD-/RPiPlay">RPiPlay</a>.
It is tested on a number of systems, including (among others) Debian 11.2, Ubuntu 20.04 and 21.10, Linux Mint 20.2, OpenSUSE 15.3, macOS 10.15.7, FreeBSD 13.0.</p>
<p dir="auto">Using Gstreamer means that video and audio are supported &#34;out of the box&#34;, using a choice of plugins.
Gstreamer decoding is plugin agnostic, and uses accelerated decoders if
available. For Intel integrated graphics, the VAAPI plugin is preferable, (but don&#39;t use it  with nVidia).</p>
<h3 dir="auto"><a id="user-content-note-to-packagers-openssl-300-solves-gpl-v3-license-issues" aria-hidden="true" href="#note-to-packagers-openssl-300-solves-gpl-v3-license-issues"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Note to packagers: OpenSSL-3.0.0 solves GPL v3 license issues.</h3>
<p dir="auto">Some Linux distributions such as Debian do not allow distribution of compiled
GPL code linked to OpenSSL-1.1.1 because its &#34;dual OpenSSL/SSLeay&#34; license
has some incompatibilites with GPL, unless all code authors have explicitly given an &#34;exception&#34; to allow
such linking (the historical origins of UxPlay make this impossible to obtain).    Other distributions
treat OpenSSL as a &#34;System Library&#34; which the GPL allows linking to.</p>
<p dir="auto">For &#34;GPL-strict&#34; distributions, UxPlay can  be built using OpenSSL- 3.0.0, which has a
new <a href="https://www.openssl.org/blog/blog/2021/09/07/OpenSSL3.Final/" rel="nofollow">GPLv3-compatible license</a>.</p>

<p dir="auto">Either download and unzip <a href="https://github.com/FDH2/UxPlay/archive/refs/heads/master.zip">UxPlay-master.zip</a>,
or (if git is installed): &#34;git clone <a href="https://github.com/FDH2/UxPlay">https://github.com/FDH2/UxPlay</a>&#34;.</p>
<p dir="auto">*This is also a pull request on the
original site <a href="https://github.com/antimof/UxPlay">https://github.com/antimof/UxPlay</a> ; that original
project is  inactive, but the pull request with
changes up to 2021-12-10
were recently merged with the antimof tree (thank you antimof!).</p>
<h2 dir="auto"><a id="user-content-building-uxplay-on--linux-or-bsd" aria-hidden="true" href="#building-uxplay-on--linux-or-bsd"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Building UxPlay on  Linux (or *BSD):</h2>
<p dir="auto">(Instructions for Debian/Ubuntu; adapt these for other Linuxes; for macOS, see below).</p>
<p dir="auto">You need a C/C++ compiler (e.g. g++) with the standard development libraries installed.</p>
<p dir="auto">Make sure that cmake&gt;=3.4.1 and pkg-config are also installed: &#34;sudo apt-get install cmake pkg-config&#34;.
In a terminal window, change directories to the source directory of the
downloaded source code (&#34;UxPlay-master&#34; for zipfile downloads, &#34;UxPlay&#34; for &#34;git clone&#34; downloads), then do</p>
<ol dir="auto">
<li><code>sudo apt-get install libssl-dev libplist-dev libavahi-compat-libdnssd-dev libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev gstreamer1.0-libav gstreamer1.0-plugins-bad</code></li>
<li><code>sudo apt-get install gstreamer1.0-vaapi</code> (For hardware-accelerated Intel graphics, but not nVidia graphics)</li>
<li><code>sudo apt-get install libx11-dev</code>  (for the &#34;ZOOMFIX&#34; X11_display name fix for screen-sharing with e.g.,  ZOOM)</li>
<li><code>cmake .</code> (or &#34;<code>cmake -DZOOMFIX=ON .</code>&#34; to get a screen-sharing fix to
make X11 mirror display windows visible to screen-sharing applications such as
Zoom, see below).</li>
<li><code>make</code></li>
<li><code>sudo make install</code>    (you can afterwards uninstall with <code>sudo make uninstall</code> in the same directory in which this was run)</li>
</ol>
<p dir="auto"><em>If you intend to modify the code, use a separate &#34;build&#34; directory: replace</em>  &#34;<code>cmake  [ ] . </code>&#34; <em>by</em>  &#34;<code>mkdir build ; cd build ; cmake [ ] ..</code>&#34;; <em>you can then clean
the build directory with</em> &#34;<code>rm -rf build/* </code>&#34; <em>(run from within the UxPlay source directory) without affecting the source directories which contain your modifications</em>.</p>
<p dir="auto">The above script installs the executable file &#34;<code>uxplay</code>&#34; to <code>/usr/local/bin</code>, (and installs a manpage to somewhere like <code>/usr/local/share/man/man1</code> and README
files to somewhere like <code>/usr/local/share/doc/uxplay</code>).
It can also be found in the build directory after the build
processs. Run uxplay in a terminal window.</p>
<p dir="auto"><strong>Note libplist-dev (version 2.0 or greater) is a  new dependency (the original antimof version UxPlay-1.2 supplied it).  Older Linux
distributions may only supply libplist 1.x, which is too old.  [Installing libplist-dev (with libplist3) from ubuntu 18.04 solves this problem on ubuntu 16.04.]</strong>
If you  cannot find a libplist-2.x package that installs on your older distribution, you can get it at
<a href="https://github.com/libimobiledevice/libplist">https://github.com/libimobiledevice/libplist</a> and build it from source.
<em>(You will need build tools  autoconf, automake, libtool, and may need to also install some libpython*-dev package).
By default, libplist installs in /usr/local/lib. If this is not in the library path (as in ubuntu), create a
file /etc/ld.so.conf.d/libplist.conf containing  the text &#34;/usr/local/lib&#34;, and run &#34;sudo ldconfig&#34; to permanently add /usr/local/lib  to the library path.</em></p>
<p dir="auto"><strong>Red Hat, Fedora, CentOS:</strong>
(sudo yum install) openssl-devel libplist-devel avahi-compat-libdns_sd-devel (+libX11-devel for ZOOMFIX).   The required
GStreamer packages are:
gstreamer1-devel gstreamer1-plugins-base-devel gstreamer1-libav gstreamer1-plugins-bad-free ( + gstreamer1-vaapi for intel graphics).</p>
<p dir="auto"><strong>OpenSUSE:</strong>
(sudo zypper install) libopenssl-devel libplist-devel
avahi-compat-mDNSResponder-devel (+ libX11-devel for ZOOMFIX).  The required
GStreamer packages are:
gstreamer-devel gstreamer-plugins-base-devel gstreamer-plugins-libav gstreamer-plugins-bad (+ gstreamer-plugins-vaapi for Intel graphics).</p>
<p dir="auto"><strong>FreeBSD:</strong> (sudo pkg install) libplist gstreamer1, gstreamer1-libav, gstreamer1-plugins, gstreamer1-plugins-*
(* = core, good,  bad, x, gtk, gl, vulkan, pulse ...), (+ gstreamer1-vaapi for Intel graphics).
Either avahi-libdns or mDNSResponder must also be installed to provide the dns_sd library.
OpenSSL is already installed as a System Library.   &#34;ZOOMFIX&#34; is untested; don&#39;t try to use it on FreeBSD unless you need it.</p>
<h2 dir="auto"><a id="user-content-building-uxplay-on-macos--only-tested-on-intel-x86_64-macs" aria-hidden="true" href="#building-uxplay-on-macos--only-tested-on-intel-x86_64-macs"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Building UxPlay on macOS:  <strong>(Only tested on Intel X86_64 Macs)</strong></h2>
<p dir="auto"><em>Note: A native AirPlay Server feature is included in  macOS 12 Monterey, but is restricted to recent hardware.
UxPlay can run  on older macOS systems that will not be able to run Monterey, or can run Monterey  but not AirPlay.</em></p>
<p dir="auto">These instructions for macOS asssume that the Xcode command-line developer tools are installed (if Xcode is installed, open the Terminal, type &#34;sudo xcode-select --install&#34; and accept the conditions).</p>
<p dir="auto">It is also assumed that CMake &gt;= 3.13 is installed:
this can be done with package managers <a href="http://www.macports.org" rel="nofollow">MacPorts</a>,
<a href="http://finkproject.org" rel="nofollow">Fink</a> or <a href="http://brew.sh" rel="nofollow">Homebrew</a>, or by a download from
<a href="https://cmake.org/download/" rel="nofollow">https://cmake.org/download/</a>.</p>
<p dir="auto">First get the latest macOS release of GStreamer-1.0
from <a href="https://gstreamer.freedesktop.org/download/" rel="nofollow">https://gstreamer.freedesktop.org/download/</a>.
Install both the macOS runtime and development installer packages. Assuming that the latest release is 1.18.5
they are <code>gstreamer-1.0-1.18.5-x86_64.pkg</code> and <code>gstreamer-1.0-devel-1.18.5-x86_64.pkg</code>.
Click on them to install (they install to
/Library/FrameWorks/GStreamer.framework).
It is recommended you use GStreamer.framework rather than install Gstreamer with Homebrew or MacPorts (see later).</p>
<p dir="auto">Next install OpenSSL and libplist:  these can be built from source (see below) but it is easier to get them using
MacPorts &#34;sudo port install openssl libplist-devel&#34; or Homebrew &#34;brew install openssl libplist&#34;.   Only the
static forms of the two libraries will used for the macOS build, so they do not need to remain installed after you have built uxplay:
if you don&#39;t have MacPorts or Homebrew installed, you can just install
one of these package-managers before building  uxplay, and uninstall it afterwards if you do not want to keep it.
Unfortunately, Fink&#39;s openssl11-dev package currently doesn&#39;t supply the static (libcrypto.a) form of the
needed OpenSLL library libcrypto, and its libplist1 package is too old.</p>
<p dir="auto">Finally, build and install uxplay (without ZOOMFIX): open a terminal and change into the UxPlay source directory
(&#34;UxPlay-master&#34; for zipfile downloads, &#34;UxPlay&#34; for &#34;git clone&#34; downloads) and build/install with
&#34;cmake . ; make ; sudo make install &#34; (same as for Linux).</p>
<p dir="auto">On  the  macOS build, autovideosink  uses OpenGL, not X11, to create the mirror display window (equivalent to
&#34;-vs glimagesink&#34;; &#34;-vs osxvideosink&#34; can also be used).
The window title does not show  the Airplay server name, but it is visible to
screen-sharing apps (e.g., Zoom).   On macOS, The option -t <em>timeout</em>
cannot be used because if the GStreamer pipeline is destroyed while the mirror window is still open,
a segfault occurs (this is an issue with the GStreamer plugins, not UxPlay).
Also,  the resolution settings &#34;-s wxh&#34; do not affect
the (small) initial OpenGL  mirror window size, but the window can be expanded using the mouse or trackpad.
In contrast, a window created with &#34;-vs osxvideosink&#34; is initially big, but has the wrong aspect ratio (stretched image);
in this case the aspect ratio changes when the window width is changed by dragging its side.</p>
<p dir="auto"><em><strong>Building OpenSSL and libplist from source on macOS</strong></em></p>
<p dir="auto">If you have have the standard GNU toolset (autoconf, automake, libtool, etc.) installed,
you can also  download and compile the source code for these libraries from
<a href="https://www.openssl.org/source/" rel="nofollow">https://www.openssl.org/source/</a>,
<a href="https://github.com/libimobiledevice/libplist">https://github.com/libimobiledevice/libplist</a>.
Install the downloaded
openssl by opening a terminal in your Downloads directory, and  unpacking the source distribution openssl-3.0.0.tar.gz             ,
(&#34;tar -xvzf openssl-3.0.0.tar.gz ; cd openssl-3.0.0&#34;). Then build/install with
&#34;./config ; make ; sudo make install_dev&#34; and clean up after building uxplay  with &#34;sudo make uninstall&#34; in the same directory.
Similarly, for libplist, download the source as a zipfile from github as
<a href="https://github.com/libimobiledevice/libplist/archive/refs/heads/master.zip">libplist-master.zip</a>, then
unpack (&#34;unzip libplist-master.zip ; cd libplist-master&#34;), build/install
(&#34;./autogen.sh ; make ; sudo make install&#34;) and clean up after uxplay is built  with &#34;sudo make uninstall&#34;  in the same directory.</p>
<p dir="auto"><em><strong>Other ways (Homebrew, MacPorts) to install GStreamer on macOS (not recommended):</strong></em></p>
<p dir="auto">First make sure that pkgconfig is installed  (Homebrew: &#34;brew install pkgconfig&#34; ; MacPorts: &#34;sudo port install pkgconfig&#34; ).</p>
<p dir="auto">(a) with Homebrew: &#34;brew install gst-plugins-base gst-plugins-good gst-plugins-bad gst-libav&#34;.   This appears to be functionally equivalent
to using GStreamer.framework, but causes a large number of extra packages to be installed by Homebrew as dependencies.  (However, as of November 2021,
Homebrew offers a build of GStreamer for Apple Silicon, which then was not yet available on the offical GStreamer site.)</p>
<p dir="auto">(b) with MacPorts: &#34;sudo port install gstreamer1-gst-plugins-base gstreamer1-gst-plugins-good gstreamer1-gst-plugins-bad gstreamer1-gst-libav&#34;.
The MacPorts GStreamer is built to use X11, so must be run from an XQuartz terminal, can use ZOOMFIX, and needs
option &#34;-vs ximagesink&#34;.  On an older unibody MacBook Pro, the default resolution  wxh = 1920x1080 was too large  for
the non-retina display, but using option &#34;-s 800x600&#34; worked; However, the GStreamer pipeline is fragile against attempts to change
the X11 window size, or to rotations that switch a connected client between portrait and landscape mode while uxplay is running.
Using the MacPorts X11 GStreamer is only viable if the image size is left unchanged from the initial &#34;-s wxh&#34; setting
(also use the iPad/iPhone setting that locks the screen orientation against switching  between portrait and landscape mode
as the device is rotated).</p>

<p dir="auto">Note: <code>uxplay</code>  is run from a terminal command line, and informational messages are written to the terminal.</p>
<h3 dir="auto"><a id="user-content-1-uxplay-starts-but-stalls-after-initialized-server-sockets-appears-without-any-server-name-showing-on-the-client" aria-hidden="true" href="#1-uxplay-starts-but-stalls-after-initialized-server-sockets-appears-without-any-server-name-showing-on-the-client"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. uxplay starts, but stalls after &#34;Initialized server socket(s)&#34; appears, <em>without any server name showing on the client</em>.</h3>
<p dir="auto">Stalling this way, with <em>no</em>  server name showing  <em>on  the client</em> as available,
probably means that your network <strong>does not have a running Bonjour/zeroconf DNS-SD server.</strong>
On Linux, make sure Avahi is installed,
and start the avahi-daemon service on the system running uxplay (your distribution will document how to do  this).
Some  systems  may instead use the mdnsd daemon as an alternative to provide DNS-SD service.
<em>(FreeBSD offers both alternatives, but only Avahi was tested: one of the steps needed for
getting Avahi running on a FreeBSD system is to edit <code>/usr/local/etc/avahi/avahi-daemon.conf</code>  to
uncomment a line for airplay support.</em>)</p>
<h3 dir="auto"><a id="user-content-2-uxplay-starts-but-stalls-after-initialized-server-sockets-appears-with-the-server-name-showing-on-the-client-but-the-client-fails-to-connect-when-the-uxplay-server-is-selected" aria-hidden="true" href="#2-uxplay-starts-but-stalls-after-initialized-server-sockets-appears-with-the-server-name-showing-on-the-client-but-the-client-fails-to-connect-when-the-uxplay-server-is-selected"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. uxplay starts, but stalls after &#34;Initialized server socket(s)&#34; appears, <em>with the server name showing on the client</em> (but the client fails to connect when the UxPlay server is selected).</h3>
<p dir="auto">This shows that a <em>dns_sd</em> service  is working, but a firewall on the server is probably blocking the connection request from the client.
(One user who insisted that the firewall had been turned off turned out to have had <em>two</em> active firewalls (<em>firewalld</em> and <em>ufw</em>)
<em>both</em> running on the server!)  If possible, either turn off the firewall
to see if that is the problem, or get three consecutive network ports,
starting at port n, all three in the range 1024-65535, opened  for both tcp and udp, and use &#34;uxplay -p n&#34;
(or open UDP 6000, 6001, 6011 TCP 7000,7001,7100 and use &#34;uxplay -p&#34;).</p>
<h3 dir="auto"><a id="user-content-3-problems-after-the-client-server-connection-has-been-made" aria-hidden="true" href="#3-problems-after-the-client-server-connection-has-been-made"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. Problems <em>after</em> the client-server connection has been made:</h3>
<p dir="auto">For such  problems, use &#34;uxplay -d &#34; (debug log option)  to see what is happening: it will show how far the connection process gets before
the failure occurs.</p>
<p dir="auto"><strong>Most such problems are  due to a GStreamer plugin that doesn&#39;t work on your system</strong>: (by default,
GStreamer uses an algorithm to guess what is the &#34;best&#34;
plugin to use on your system).   A common case is that the GStreamer VAAPI plugin
(for hardware-accelerated intel graphics) is being used on a system with nVidia graphics,
If you use an
nVidia graphics card, make sure that the gstreamer1.0-vaapi
plugin for Intel graphics is <em>NOT</em> installed (<strong>uninstall it</strong> if it is installed!).
(You can test for this  by explicitly choosing the GStreamer videosink with option
&#34;-vs ximagesink&#34; or &#34;-vs xvimagesink&#34;, to see if this fixes the problem, or &#34;-vs vaapisink&#34; to see if this
reproduces the problem.)</p>
<p dir="auto">There are some reports of other GStreamer problems with hardware-accelerated Intel graphics.  One user
(on Debian) solved this with &#34;sudo apt install intel-media-va-driver-non-free&#34;.  This is a driver for 8&#39;th (or later) generation
&#34;*-lake&#34; Intel chips, that seems to be related to VAAPI accelerated graphics.</p>
<p dir="auto">You can try to fix audio problems by using the &#34;-as <em>audiosink</em>&#34;  option to choose the GStreamer audiosink , rather than
have autoaudiosink pick one for you.    The command &#34;gst_inspect-1.0 | grep Sink | grep Audio&#34; &#34; will show you which audiosinks are
available on your system.  (Replace  &#34;Audio&#34; by &#34;Video&#34; to see videosinks).   Some possible audiosinks are pulsesink, alsasink, osssink, oss4sink,
and osxaudiosink (macOS).</p>
<p dir="auto">If you ran cmake with &#34;-DZOOMFIX=ON&#34;, check if the problem is still there without ZOOMFIX.
ZOOMFIX is only applied to the default videosink choice (&#34;autovideosink&#34;) and the two X11 videosinks
&#34;ximagesink&#34; and &#34;xvimagesink&#34;.   ZOOMFIX is only designed for these last two; if
autovideosink chooses a different videosink, ZOOMFIX is now ignored.
If you are using the X11 windowing system (standard on Linux), and have trouble with screen-sharing on Zoom, use
ZOOMFIX and &#34;-vs xvimagesink&#34; (or &#34;-vs ximagesink&#34; if the previous choice doesn&#39;t work).</p>
<p dir="auto">As other  videosink choices are not affected by ZOOMFIX, they  may or may not be visible to screen-sharing apps.
Cairo-based windows created on Linux with &#34;-vs gtksink&#34; are visible to screen-sharing aps without ZOOMFIX; windows on macOS created by
&#34;-vs glimagesink&#34; (default choice) and &#34;-vs osximagesink&#34; are also visible.</p>
<p dir="auto">The &#34;OpenGL renderer&#34; window created on Linux by &#34;-vs glimagesink&#34; sometimes does not close properly when its &#34;close&#34; button is clicked.
(this is a GStreamer issue).  You may need to terminate uxplay with Ctrl-C to close a &#34;zombie&#34; OpenGl window.</p>
<h3 dir="auto"><a id="user-content-4-gstreamer-issues-missing-plugins-etc" aria-hidden="true" href="#4-gstreamer-issues-missing-plugins-etc"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4. GStreamer issues (missing plugins, etc.):</h3>
<p dir="auto">To troubleshoot GStreamer execute  &#34;export GST_DEBUG=2&#34;
to set the GStreamer debug-level environment-variable in the terminal
where you will run uxplay, so that you see warning and error messages;
(replace &#34;2&#34; by &#34;4&#34; to see much (much) more of what is happening inside
GStreamer).   Run &#34;gst-inspect-1.0&#34; to see which GStreamer plugins are
installed on your system.</p>
<p dir="auto">Some extra GStreamer packages for special plugins may need to be installed (or reinstalled: a user using a Wayland display system as an alternative to X11
reported that after reinstalling Lubuntu 18.4, UxPlay would not  work until gstreamer1.0-x was installed, presumably for Wayland&#39;s X11-compatibility mode).
Different distributions may break up GStreamer 1.x into packages in different ways; the packages listed above in the build instructions should bring in
other required GStreamer packages as dependencies, but will not install all possible plugins.</p>
<h3 dir="auto"><a id="user-content-5--failure-to-decrypt-all-video-and-audio-streams-from-a-particular-older-client" aria-hidden="true" href="#5--failure-to-decrypt-all-video-and-audio-streams-from-a-particular-older-client"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5.  Failure to decrypt ALL video and audio streams from a particular (older) client:</h3>
<p dir="auto">This triggers an error message, and will be due to use of an incorrect protocol for getting the AES decryption key from the client.</p>
<p dir="auto">Modern Apple clients use a more-encrypted protocol than older ones.
Which protocol is used by UxPlay depends on the client  <em>User-Agent</em> string (reported by the client and now shown in the terminal output).
iOS 9 and 10 clients only use iTunes FairPlay encryption on the AES decryption key they send to the server.
Somewhere around iOS sourceVersion 330 (part of the User-Agent string) Apple started to further encrypt it by a sha-512 hash with a &#34;shared secret&#34; created
during the Server-Client pairing process.   The sourceVersion 330 above which the extra decryption step is carried out is set in lib/global.h if you need to
change it.  (This applies only to audio decryption; the AES key used for video decryption has had this extra encryption since iOS 9).</p>
<p dir="auto">The third-party non-free Windows software  <em>AirMyPC</em> (a commercial AirPlay emulator) uses an  unhashed AES key for both audio and video encryption.  <em>AirMyPC</em> has a distinctive
<em>User-Agent</em> string, which is detected using two other settings in lib/global.h that can be adjusted if necessary. These settings might be useful if
other AirPlay-emulators need support.  Uxplay declares itself to be an AppleTV2,1 with sourceVersion 220.68; this can also be changed in global.h.</p>

<p dir="auto">Options:</p>
<p dir="auto"><strong>-n server_name</strong> (Default: UxPlay);  server_name@<em>hostname</em> will be the name that appears offering
AirPlay services to your iPad, iPhone etc, where <em>hostname</em> is the name of the server running uxplay.
This will also now be the name shown above the mirror display (X11)  window.</p>
<p dir="auto"><strong>-nh</strong> Do not append &#34;@<em>hostname</em>&#34; at the end of the AirPlay server name.</p>
<p dir="auto"><strong>-s wxh</strong> (e.g. -s 1920x1080 , which is the default ) sets the display resolution (width and height,
in pixels).   (This may be a
request made to the AirPlay client, and perhaps will not
be the final resolution you get.)   w and h are whole numbers with four
digits or less.   Note that the <strong>height</strong> pixel size is the controlling
one used by the client for determining the streaming format; the width is
dynamically adjusted to the shape of the image (portrait or landscape
format, depending on how an iPad is held, for example).</p>
<p dir="auto"><strong>-s wxh@r</strong>  As above, but also informs the AirPlay  client about the screen
refresh rate of the display. Default is r=60 (60 Hz); r is a whole number
with three digits or less.   Values greater than 255 are invalid.</p>
<p dir="auto"><strong>-fps n</strong> sets a maximum frame rate (in frames per second) for the AirPlay
client to stream video; n must be a whole number with 3 digits or less.
(The client may choose to serve video at any frame rate lower
than this;  default is 30 fps.)  A setting
below 30 fps might be useful to reduce latency if you are running more than
one instance of uxplay at the same time.   Values greater than 255 are
ignored.  This setting is only an advisory to the client device, so setting
a high value will not force a high framerate.
(You can test using &#34;-vs fpsdisplaysink&#34; to see what framerate is being
received.)</p>
<p dir="auto"><strong>-o</strong> turns on an &#34;overscanned&#34; option for the display window.    This
reduces the image resolution by using some of the pixels requested
by  option -s wxh (or their default values 1920x1080) by adding an empty
boundary frame of unused pixels (which would be lost in a full-screen
display that overscans, and is not displayed by gstreamer).
Recommendation: <strong>don&#39;t use this option</strong> unless there is some special
reason to use it.</p>
<p dir="auto"><strong>-p</strong>  allows you to select the network ports used by UxPlay (these need
to be opened if the server is behind a firewall).   By itself, -p sets
&#34;legacy&#34; ports TCP 7100, 7000, 7001, UDP 6000, 6001, 7011.   -p n (e.g. -p
35000)  sets TCP and UDP ports n, n+1, n+2.  -p n1,n2,n3 (comma-separated
values) sets each port separately; -p n1,n2 sets ports n1,n2,n2+1.  -p tcp n
or -p udp n sets just the TCP or UDP ports.  Ports must be in the range
[1024-65535].</p>
<p dir="auto">If the -p option is not used, the ports are chosen dynamically (randomly),
which will not work if a firewall is running.</p>
<p dir="auto"><strong>-m</strong>  generates a random MAC address to use instead of the true hardware MAC
number of the computer&#39;s network card.   (Different server_name,  MAC
addresses,  and network ports are needed for each running uxplay  if you
attempt to  run two instances of uxplay on the same computer.)
If UxPlay fails to find the true MAC address of a  network card, (more
specifically, the MAC address used by the first active network interface detected)
a random MAC address will be used even if option <strong>-m</strong> was not specifed.
(Note that a random MAC address will be different each time UxPlay is started).</p>
<p dir="auto">Also: image transforms that had been added to RPiPlay have been ported to UxPlay:</p>
<p dir="auto"><strong>-f {H|V|I}</strong>  implements &#34;videoflip&#34; image transforms: H = horizontal flip
(right-left flip, or mirror image); V = vertical flip ;  I =
180 degree rotation or inversion (which is the combination of H with V).</p>
<p dir="auto"><strong>-r {R|L}</strong>  90 degree Right (clockwise) or Left (counter-clockwise)
rotations; these are carried out after any <strong>-f</strong> transforms.</p>
<p dir="auto"><strong>-vs <em>videosink</em></strong> chooses the GStreamer videosink, instead of letting
autovideosink pick it for you.  Some videosink choices are:  ximagesink, xvimagesink,
vaapisink (for intel graphics), gtksink, glimagesink, waylandsink, osximagesink (for macOS),  or
fpsdisplaysink (which shows the streaming framerate in fps).   Using quotes
&#34;...&#34; might allow some parameters to be included with the videosink name.
(Some choices of videosink might not work on your system.)</p>
<p dir="auto"><strong>-vs 0</strong> suppresses display of streamed video, but plays  streamed audio.   (The client&#39;s screen
is still mirrored at a reduced rate of 1 frame per second,  but is not rendered or displayed.)  This
feature (which streams audio in AAC audio format) is now probably unneeded, as UxPlay can now
stream superior-quality Apple Lossless audio without video in Airplay non-mirror mode.</p>
<p dir="auto"><strong>-as <em>audiosink</em></strong> chooses the GStreamer audiosink, instead of letting
autoaudiosink pick it for you.  Some audiosink choices are:  pulsesink, alsasink,
osssink, oss4sink, and osxaudiosink (for macOS).  Using quotes
&#34;...&#34; might allow some parameters to be included with the audiosink name.
(Some choices of audiosink might not work on your system.)</p>
<p dir="auto"><strong>-as 0</strong>  (or just <strong>-a</strong>) suppresses playing of streamed audio, but displays streamed video.</p>
<p dir="auto"><strong>-t <em>timeout</em></strong>  will cause the server to relaunch (without stopping uxplay) if no connections
have been present during the previous <em>timeout</em> seconds.  You may wish to use this if the Server
is not visible to new Clients that were inactive when the Server was launched, and an idle Bonjour
registration  eventually becomes unavailable for new connections (this is a workaround for what
may be due to a problem with your dns-sd or Avahi setup).</p>

<p dir="auto">1.44 2021-12-13   Omit hash of aeskey with ecdh_secret if sourceVersion &lt;= 280.33 (this supports AirMyPC);
internal rearrangement  of where this hash is done.   Replace decodebin by h264-specific
elements in the GStreamer video pipeline.  Fully report initial communications between
client and server in -d debug mode.</p>
<p dir="auto">1.43 2021-12-07   Various internal changes, such as tests for successful decryption, uniform treatment
of informational/debug messages, etc., updated README.</p>
<p dir="auto">1.42 2021-11-20   Fix MAC detection to work with modern Linux interface naming practices, MacOS and *BSD.</p>
<p dir="auto">1.41 2021-11-11    Further cleanups of multiple audio format support (internal changes,
separated RAOP and GStreamer audio/video startup)</p>
<p dir="auto">1.40 2021-11-09    Cleanup segfault in ALAC support, manpage location fix, show request Plists in debug mode.</p>
<p dir="auto">1.39 2021-11-06    Added support for Apple Lossless (ALAC) audio streams.</p>
<p dir="auto">1.38 2021-10-8     Add -as <em>audiosink</em> option to allow user to choose the  GStreamer audiosink.</p>
<p dir="auto">1.37 2021-09-29    Append &#34;@hostname&#34; to AirPlay Server name, where &#34;hostname&#34; is the name of the
server running uxplay (reworked change in 1.36).</p>
<p dir="auto">1.36 2021-09-29    Implemented suggestion (by @mrbesen and @PetrusZ) to use hostname of machine
runing uxplay as the default server name</p>
<p dir="auto">1.35.1 2021-09-28  Added the -vs 0 option for streaming audio, but not displaying video.</p>
<p dir="auto">1.35  2021-09-10   now uses a GLib MainLoop, and builds on macOS (tested on Intel Mac, 10.15 ).
New option  -t <em>timeout</em> for relaunching server if no connections were active in
previous <em>timeout</em> seconds (to renew Bonjour registration).</p>
<p dir="auto">1.341 2021-09-04   fixed: render logger was not being destroyed by stop_server()</p>
<p dir="auto">1.34  2021-08-27   Fixed &#34;ZOOMFIX&#34;: the X11 window name fix was only being made the
first time the GStreamer window was created by uxplay, and
not if the server was relaunched after the GStreamer window
was closed, with uxplay still running.   Corrected in v. 1.34</p>

<ol dir="auto">
<li>
<p dir="auto">Updates of the RAOP (AirPlay protocol)  collection of codes  maintained
at  <a href="https://github.com/FD-/RPiPlay.git">https://github.com/FD-/RPiPlay.git</a> so it is current as of 2021-08-01,
adding all changes since the original release of UxPlay by antimof.
This involved crypto updates, replacement
of the included plist library by the system-installed version, and  a change
over to a library llhttp for http parsing.</p>
</li>
<li>
<p dir="auto">Added the -s, -o -p, -m, -r,  -f, -fps  -vs -as  and -t  options.</p>
</li>
<li>
<p dir="auto">If &#34;<code>cmake -DZOOMFIX=ON .</code>&#34;  is run before compiling,
the mirrored window is now visible to screen-sharing applications such as
Zoom. To compile with ZOOMFIX=ON, the X11 development libraries must be installed.
(ZOOMFIX will not be needed once the upcoming  gstreamer-1.20 is available,
since starting with that release, the GStreamer X11 mirror window will be natively
visible for screen-sharing.) Thanks to David Ventura
<a href="https://github.com/DavidVentura/UxPlay">https://github.com/DavidVentura/UxPlay</a> for the fix
and also for getting it into  gstreamer-1.20.
[If uxplay was compiled after
cmake was run without -DZOOMFIX=ON, and your gstreamer version is older than
1.20, you can still manually make the X11 window visible to screen-sharing apps with the X11 utility
xdotool, if it is installed, with: <code> xdotool selectwindow set_window --name &lt;name&gt;</code>
(where <code>&lt;name&gt;</code> is your choice of name), and then select the uxplay window
by clicking on it with the mouse.]</p>
</li>
<li>
<p dir="auto">The AirPlay server now terminates correctly when the gstreamer display window is
closed, and is relaunched with the same settings to wait for a new connection.
The program uxplay terminates when Ctrl-C is typed in the terminal window. The <strong>-t <em>timeout</em></strong>
option relaunches the server after <em>timeout</em> seconds  of inactivity to allow new connections to be made.</p>
</li>
<li>
<p dir="auto">In principle, multiple instances of uxplay can be run simultaneously
using the <strong>-m</strong> (generate random MAC address) option to give each a
different (&#34;local&#34; as opposed to &#34;universal&#34;)  MAC address.
If the <strong>-p [n]</strong> option is used, they also need separate network port choices.
(However, there may be a large latency, and running two instances of uxplay
simultaneously on the same computer may not be very useful; using the <strong>-fps</strong> option
to force streaming framerates below 30fps could be helpful.)</p>
</li>
<li>
<p dir="auto">Without the <strong>-p</strong> [n] option,  uxplay makes a random dynamic assignment of
network ports. This will not work if most ports are closed by a firewall.
With e.g., <strong>-p 45000</strong>   you should open both TCP and UDP on
ports 45000, 45001, 45002.   Minimum allowed port is 1024, maximum is 65535.
The option &#34;<strong>-p</strong>&#34; with no argument uses a &#34;legacy&#34; set of ports TCP 7100,
7000, 7001, and UDP  7011, 6000, 6001.  Finer control is also
possible: &#34;<strong>-p udp n1,n2,n3 -p tcp n4,n5,n6</strong>&#34; sets all six ports individually.</p>
</li>
<li>
<p dir="auto">The default resolution setting is 1920x1080 width x height pixels.
To change this, use &#34;<strong>-s wxh</strong>&#34;  where w and h are positive  decimals
with 4 or less digits.   It seems that the width and height may be negotiated
with the AirPlay client, so this may not be the actual screen geometry that
displays.</p>
</li>
<li>
<p dir="auto">The title on the GStreamer display window is now is the AirPlay server name.
(This works for X11 windows created
by gstreamer videosinks ximagesink, xvimagesink, but not OpenGL windows created by glimagesink.)</p>
</li>
<li>
<p dir="auto">The avahi_compat &#34;nag&#34; warning on startup is suppressed, by placing
&#34;AVAHI_COMPAT_NOWARN=1&#34; into the runtime environment when uxplay starts.
(This uses a call to putenv() in a form that is believed to be safe against
memory leaks, at least in modern Linux; if for any reason you don&#39;t want
this fix, comment out the line in CMakeLists.txt that activates it when uxplay
is compiled.) On macOS, Avahi is not used.</p>
</li>
<li>
<p dir="auto">UxPlay now builds on macOS.</p>
</li>
<li>
<p dir="auto">The hostname of the server running uxplay is now appended to the AirPlay server name,
which is now displayed as <em>name</em>@hostname, where <em>name</em> is &#34;UxPlay&#34;, (or whatever is set with the <strong>-n</strong> option).</p>
</li>
<li>
<p dir="auto">Added support for audio-only streaming with original (non-Mirror) AirPlay protocol, with Apple Lossless (ALAC) audio.</p>
</li>
<li>
<p dir="auto">Added suppport for the  older AirPlay protocol used by third-party Windows-based AirPlay mirror emulators such as AirMyPC.</p>
</li>
</ol>

<p dir="auto">All the resources in this repository are written using only freely available information from the internet. The code and related resources are meant for educational purposes only. It is the responsibility of the user to make sure all local laws are adhered to.</p>
<p dir="auto">This project makes use of a third-party GPL library for handling FairPlay. The legal status of that library is unclear. Should you be a representative of Apple and have any objections against the legality of the library and its use in this project, please contact me and I&#39;ll take the appropriate steps.</p>
<p dir="auto">Given the large number of third-party AirPlay receivers (mostly closed-source) available for purchase, it is my understanding that an open source implementation of the same functionality wouldn&#39;t violate any of Apple&#39;s rights either.</p>

<p dir="auto">(From the  <a href="https://github.com/FD-/RPiPlay.git">https://github.com/FD-/RPiPlay.git</a> repository.)</p>
<h2 dir="auto"><a id="user-content-rpiplay-authors" aria-hidden="true" href="#rpiplay-authors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>RPiPlay authors</h2>
<p dir="auto">The code in this repository accumulated from various sources over time. Here
is my (<strong>fdrachbacher</strong>) attempt at listing the various authors and the components they created:</p>
<ul dir="auto">
<li><strong>dsafa22</strong>: Created an <a href="https://github.com/dsafa22/AirplayServer">AirPlay 2 mirroring server</a> (seems gone now, <em>but code is preserved
<a href="https://github.com/FD-/RPiPlay/tree/d68110a7eaa63840c06fe2b187726cc640d76706">here</a>, and <a href="https://github.com/FDH2/UxPlay/wiki/AirPlay2">see here</a> for
dsafa22&#39;s description of the analysis of the AirPlay 2 mirror protocol that made RPiPlay possible</em>) for Android based on ShairPlay. This project is basically a port of dsafa22&#39;s code to the Raspberry Pi, utilizing OpenMAX and OpenSSL for better performance on the Pi. All code in <code>lib/</code> concerning mirroring is dsafa22&#39;s work. License: GNU LGPLv2.1+</li>
<li><strong>Juho Vähä-Herttua</strong> and contributors: Created an AirPlay audio server called <a href="https://github.com/juhovh/shairplay">ShairPlay</a>, including support for Fairplay based on PlayFair. Most of the code in <code>lib/</code> originally stems from this project. License: GNU LGPLv2.1+</li>
<li><strong>EstebanKubata</strong>: Created a FairPlay library called <a href="https://github.com/EstebanKubata/playfair">PlayFair</a>. Located in the <code>lib/playfair</code> folder. License: GNU GPL</li>
<li><strong>Joyent, Inc and contributors</strong>: Created an http library called <a href="https://github.com/nodejs/llhttp">llhttp</a>. Located at <code>lib/llhttp/</code>. License: MIT</li>
<li><strong>Team XBMC</strong>: Managed to show a black background for OpenMAX video rendering. This code is used in the video renderer. License: GNU GPL</li>
<li><strong>Alex Izvorski and contributors</strong>: Wrote <a href="https://github.com/aizvorski/h264bitstream">h264bitstream</a>, a library for manipulation h264 streams. Used for reducing delay in the Raspberry Pi video pipeline. Located in the <code>renderers/h264-bitstream</code> folder. License: GNU LGPLv2.1</li>
</ul>
<h2 dir="auto"><a id="user-content-airplay-protocol-versions" aria-hidden="true" href="#airplay-protocol-versions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>AirPlay protocol versions</h2>
<p dir="auto">For multiple reasons, it&#39;s very difficult to clearly define the protocol names and versions of the components that make up the AirPlay streaming system. In fact, it seems like the AirPlay version number used for marketing differs from that used in the actual implementation. In order to tidy up this whole mess a bit, I did a little research that I&#39;d like to summarize here:</p>
<p dir="auto">The very origin of the AirPlay protocol suite was launched as AirTunes sometime around 2004. It allowed to stream audio from iTunes to an AirPort Express station. Internally, the name of the protocol that was used was RAOP, or Remote Audio Output Protocol. It seems already back then, the protocol involved AES encryption. A public key was needed for encrypting the audio sent to an AirPort Express, and the private key was needed for receiving the protocol (ie used in the AirPort Express to decrypt the stream). Already in 2004, the public key was reverse-engineered, so that <a href="http://nanocr.eu/2004/08/11/reversing-airtunes/" rel="nofollow">third-party sender applications</a> were developed.</p>
<p dir="auto">Some time <a href="https://weblog.rogueamoeba.com/2008/01/10/a-tour-of-airfoil-3/" rel="nofollow">around 2008</a>, the protocol was revised and named AirTunes 2. It seems the changes primarily concerned timing. By 2009, the new protocol was <a href="https://git.zx2c4.com/Airtunes2/about/" rel="nofollow">reverse-engineered and documented</a>.</p>
<p dir="auto">When the Apple TV 2nd generation was introduced in 2010, it received support for the AirTunes protocol. However, because this device allowed playback of visual content, the protocol was extended and renamed AirPlay. It was now possible to stream photo slideshows and videos. Shortly after the release of the Apple TV 2nd generation, AirPlay support for iOS was included in the iOS 4.2 update. It seems like at that point, the audio stream was still actually using the same AirTunes 2 protocol as described above. The video and photo streams were added as a whole new protocol based on HTTP, pretty much independent from the audio stream. Soon, the first curious developers began to <a href="https://web.archive.org/web/20101211213705/http://www.tuaw.com/2010/12/08/dear-aunt-tuaw-can-i-airplay-to-my-mac/" rel="nofollow">investigate how it worked</a>. Their conclusion was that visual content is streamed unencrypted.</p>
<p dir="auto">In April 2011, a talented hacker <a href="http://www.macrumors.com/2011/04/11/apple-airplay-private-key-exposed-opening-door-to-airport-express-emulators/" rel="nofollow">extracted the AirPlay private key</a> from an AirPort Express. This meant that finally, third-party developers were able to also build AirPlay receiver (server) programs.</p>
<p dir="auto">For iOS 5, released in 2011, Apple added a new protocol to the AirPlay suite: AirPlay mirroring. <a href="https://www.aorensoftware.com/blog/2011/08/20/exploring-airplay-mirroring-internals/" rel="nofollow">Initial investigators</a> found this new protocol used encryption in order to protect the transferred video data.</p>
<p dir="auto">By 2012, most of AirPlay&#39;s protocols had been reverse-engineered and <a href="https://nto.github.io/AirPlay.html" rel="nofollow">documented</a> (see also <a href="https://openairplay.github.io/airplay-spec" rel="nofollow">updated version</a>). At this point, audio still used the AirTunes 2 protocol from around 2008, video, photos and mirroring still used their respective protocols in an unmodified form, so you could still speak of AirPlay 1 (building upon AirTunes 2). The Airplay server running on the Apple TV reported as version 130. The setup of AirPlay mirroring used the xml format, in particular a stream.xml file.
Additionally, it seems like the actual audio data is using the ALAC codec for audio-only (AirTunes 2) streaming and AAC for mirror audio. At least these different formats were used in <a href="https://github.com/espes/Slave-in-the-Magic-Mirror/issues/12#issuecomment-372380451">later iOS versions</a>.</p>
<p dir="auto">Sometime before iOS 9, the protocol for mirroring was slightly modified: Instead of the &#34;stream.xml&#34; API endpoint, the same information could also be querried in binary plist form, just by changing the API endpoint to &#34;stream&#34;, without any extension. I wasn&#39;t able to figure out which of these was actually used by what specific client / server versions.</p>
<p dir="auto">For iOS 9, Apple made <a href="https://9to5mac.com/2015/09/11/apple-ios-9-airplay-improvements-screen-mirroring/" rel="nofollow">considerable changes</a> to the AirPlay protocol in 2015, including audio and mirroring. Apparently, the audio protocol was only slightly modified, and a <a href="https://github.com/juhovh/shairplay/issues/43">minor change</a> restored compatibility. For mirroring, an <a href="https://github.com/juhovh/shairplay/issues/43#issuecomment-142115959">additional pairing phase</a> was added to the connection establishment procedure, consisting of pair-setup and pair-verify calls. Seemingly, these were added in order to simplify usage with devices that are connected frequently. Pair-setup is used only the first time an iOS device connects to an AirPlay receiver. The generated cryptographic binding can be used for pair-verify in later sessions. Additionally, the stream / stream.xml endpoint was replaced with the info endpoint (only available as binary plist AFAICT).
As of iOS 12, the protocol introduced with iOS 9 was still supported with only slight modifications, albeit as a legacy mode. While iOS 9 used two SETUP calls (one for general connection and mirroring video, and one for audio), iOS 12 legacy mode uses 3 SETUP calls (one for general connection (timing and events), one for mirroring video, one for audio).</p>
<p dir="auto">The release of tvOS 10.2 broke many third-party AirPlay sender (client) programs in 2017. The reason was that it was now mandatory to perform device verification via a pin in order to stream content to an Apple TV. The functionality had been in the protocol before, but was not mandatory. Some discussion about the new scheme can be found <a href="https://github.com/postlund/pyatv/issues/79">here</a>. A full specification of the pairing and authentication protocol was made available on <a href="https://htmlpreview.github.io/?https://github.com/philippe44/RAOP-Player/blob/master/doc/auth_protocol.html" rel="nofollow">GitHub</a>. At that point, tvOS 10.2 reported as AirTunes/320.20.</p>
<p dir="auto">In tvOS 11, the reported server version was <a href="https://github.com/ejurgensen/forked-daapd/issues/377#issuecomment-309213273">increased to 350.92.4</a>.</p>
<p dir="auto">iOS 11.4 added AirPlay 2 in 2018. Although extensively covered by the media, it&#39;s not entirely clear what changes specifically Apple has made protocol-wise.</p>
<p dir="auto">From captures of the traffic between an iOS device running iOS 12.2 and an AppleTV running tvOS 12.2.1, one can see that the communication on the main mirroring HTTP connection is encrypted after the initial handshake.
This could theoretically be part of the new AirPlay 2 protocol. The AppleTV running tvOS 12.2.1 identifies as AirTunes/380.20.1.
When connecting from the same iOS device to an AppleTV 3rd generation (reporting as AirTunes/220.68), the communication is still visible in plain. From the log messages that the iOS device produces when connected to an AppleTV 3rd generation, it becomes apparent that the iOS device is treating this plain protocol as the legacy protocol (as originally introduced with iOS 9). Further research showed that at the moment, all available third-party AirPlay mirroring receivers (servers) are using this legacy protocol, including the open source implementation of dsafa22, which is the base for RPiPlay. Given Apple considers this a legacy protocol, it can be expected to be removed entirely in the future. This means that all third-party AirPlay receivers will have to be updated to the new (fully encrypted) protocol at some point.</p>
<p dir="auto">More specifically, the encryption starts after the pair-verify handshake completed, so the fp-setup handshake is already happening encrypted. Judging from the encryption scheme for AirPlay video (aka HLS Relay), likely two AES GCM 128 ciphers are used on the socket communication (one for sending, one for receiving). However, I have no idea how the keys are derived from the handshake data.</p>
</article>
        </div></div>
  </body>
</html>
