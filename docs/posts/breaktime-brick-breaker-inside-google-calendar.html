<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://eieio.games/nonsense/game-13-breaktime/">Original</a>
    <h1>BreakTime: Brick Breaker inside Google Calendar</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
        <p>I made a game. It’s called BreakTime. It’s Breakout (aka Brick Breaker) running inside Google Calendar. Your meetings are bricks. It (optionally) declines the meetings you destroy.</p>



<p>It’s a chrome extension. You can install it <a href="https://chromewebstore.google.com/detail/breaktime/efajcgehdfpliglonbkjmifmibpphafk?hl=en&amp;authuser=0">here</a>. It has no external dependencies; it’s 1,500 lines of javascript including a little game engine I made for the project.</p>

<p>Making it was a ton of fun. Let me tell you about it.
<!-- excerpt-end --></p>


<p>BreakTime started as an iOS shortcut.</p>

<p>I’m <em>fascinated</em> with iOS shortcuts. I’m determined to build something using them. I like <a href="https://www.openculture.com/nonsense/game-11-flappy-bird-finder/">putting games in weird places</a> and using shortcuts to build a game deep inside the iOS walled garden is a goal of mine<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<p>I realized that the calendar shortcut API was pretty powerful - I could build animations by moving events around. I whipped up the bones of what I thought could be a pong demo and <a href="https://twitter.com/itseieio/status/1757415329783795786">tweeted about it</a>.</p>



<p>I floated Breakout as another potential game and my friend <a href="https://twitter.com/ianthehenry/status/1757464426616435093">Ian Henry</a> suggested actually declining calendar events.</p>

<div>
    
    <p><img src="https://www.openculture.com/assets/images/breaktime/iantweet.png" alt=""/></p><p> ian i am so grateful for this tweet </p>
    
</div>

<p>And so BreakTime was born.</p>



<p>Whipping up a janky prototype of BreakTime was pretty straightforward. The browser needs to know the coordinates of the elements on screen - it has to draw them all! - and you can ask it for those coordinates with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"><code>getBoundingClientRect</code></a>. This might not work well for elements that aren’t rectangles but in BreakTime almost everything is a rectangle!</p>

<p>So the prototype was basically:</p>
<ul>
  <li>Figure out a dom selector that gives me all the calendar events</li>
  <li>Figure out a dom selector that gives me a play area</li>
  <li>Add a div to represent the ball</li>
  <li>Write some javascript to make the ball bounce around, checking for collisions with the rectangles.</li>
  <li>Inject in some CSS to make the ball div round, fade out events that the ball hit, etc.</li>
</ul>

<p>It looked something like this:</p>

<div>
<div>
    
    
    <video playsinline="" controls="" muted="" poster=" /assets/images/breaktime/breaktime-prototype-1-firstframe.png ">
    
        <source src="/assets/images/breaktime/breaktime-prototype-1.mp4" type="video/mp4"/>
    </video>
    
    <p> why did i make the ball so big </p>
    
</div>

</div>

<p>I cut some pretty big corners to get this all working.</p>

<p>To make collision handling trivial I treated the ball as a square instead of as a circle; you can see that this causes some weird looking bounces.</p>

<p>To animate the ball’s position I set up a <code>setInterval</code> loop that moved the ball every 50 milliseconds, moved it’s position via the css <code>transform</code> property, and set the ball’s <code>transition</code> property to <code>linear 50ms</code> - so long as the <code>setInterval</code> loop runs <em>exactly</em> every 50ms this produces relatively smooth movement (which is to say the movement is not very smooth).</p>

<p>And at the time I figured this wouldn’t get approved as a chrome extension so I planned to make a bookmarklet. This is where the goal of “no external dependencies” came from. To run the prototype I’d just copy-paste the javascript directly into the browser console.</p>

<p>The whole thing came out to something like 300 lines including the CSS that I was injecting directly from javascript.</p>

<p>Those hacks made the game pretty gross. I waited far too long to unwind them which created some headaches later.</p>

<p>That said, this janky prototype was enough to <a href="https://www.tiktok.com/@itseieio/video/7335551871991418155">do pretty well on tiktok</a> and catch the Google social team’s attention, which was pretty exciting.</p>

<div>
    
    <p><img src="https://www.openculture.com/assets/images/breaktime/tiktok-screencap.png" alt=""/></p><p> never thought this would be a development highlight </p>
    
</div>



<p>The response from tiktok convinced me that this was worth pursuing, and I figured the first thing I needed to do was move to a proper system for collision handling.</p>

<p>It turns out that determining whether a circle collides with an (unrotated) rectangle is delightfully elegant! The process is:</p>
<ul>
  <li>Find the point P on the rectangle that is closest to the circle</li>
  <li>Measure the distance from P to the circle’s center</li>
  <li>If that distance is smaller than the circle’s radius you have a collision</li>
</ul>

<p>And finding P is even more elegant. To find the X coordinate of P:</p>
<ul>
  <li>If the circle’s center is to the left of the rectangle, it’s the left edge of the rectangle</li>
  <li>If the circle’s center is to the right of the rectangle, it’s the right edge of the rectangle</li>
  <li>Otherwise, it’s the X coordinate of the circle’s center</li>
</ul>

<p>You can repeat the same process for the Y coordinate. Easy!</p>

<div>
    
    <p><img src="https://www.openculture.com/assets/images/breaktime/chatgpt.png" alt=""/></p><p> chatgpt did a good job here </p>
    
</div>

<p>However, there’s also the problem of figuring out which <em>side</em> of the rectangle the circle bounced off of. And in my journey to solve this problem from first principles (why!) I went a little off the rails.</p>

<p>The approach I took is:</p>
<ul>
  <li>Take the circle’s current position</li>
  <li>Rewind time to the moment of collision</li>
  <li>Compare the center of the circle to the sides of the rectangle - if the circle is (for example) now above the rectangle, bounce off the top</li>
</ul>

<p>There are a ton of edge cases here. And when you get them wrong you get some <em>weird</em> results<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>.</p>

<div>
<div>
    
    
    <video playsinline="" controls="" muted="" poster=" /assets/images/breaktime/funnybounce-firstframe.png ">
    
        <source src="/assets/images/breaktime/funnybounce.mp4" type="video/mp4"/>
    </video>
    
    <p> that bounce didn&#39;t look right... </p>
    
</div>

</div>

<p>The big problems I ran into are:</p>
<ol>
  <li>The ball should only bounce off the left side of a rectangle when moving to the right (and vice-versa)</li>
  <li>The ball should only collide off a side if, after rewinding time, it’s center is <em>outside</em> of the rectangle</li>
</ol>

<p>These problems were particularly pernicious when handling corner bounces (where we invert both the X and Y direction of the ball). I eventually realized that you should only bounce off a corner when the ball intersects two sides of a rectangle in the same tick.</p>

<p>I feel kinda silly typing this out because it feels obvious now but man, this stuff is <em>finicky</em>. It probably didn’t help that I wrote most of this code over one late night (I was excited about the game and thought I could finish it in another day or two. I could not).</p>

<p>I’ve since learned that the typical approach here is about looking at the <em>angle</em> of collision instead. But it was a lot of fun to flail through my approach - and I learned a whole lot doing it.</p>



<p>Proper collision detection made the game feel a lot better but it didn’t <em>look</em> great. I saw two big problems.</p>

<ol>
  <li>The assets (the ball, paddle, and background) looked simplistic and bad</li>
  <li>There was no “juice”</li>
</ol>

<p>Game devs use “juice” to refer to all the stuff that makes a game feel <em>alive</em> - objects scaling up and down when they collide, particle effects, screenshake, color, good <a href="https://en.wikipedia.org/wiki/Inbetweening">tweening</a> - stuff that doesn’t change gameplay but instead enhances how the existing gameplay feels.</p>

<p>One of the best talks on juice is called <a href="https://www.youtube.com/watch?v=Fy0aCDmgnxg">“Juice it or lose it”</a>. The talk takes a barebones game and progressively adds more juice (but no gameplay changes) to show how much it changes the feel of the game. Conveniently the example game is a Breakout clone! I cribbed a lot of ideas directly from it.</p>

<p>To motivate myself to get some effects added quickly I signed up to give a 5 minute presentation at <a href="https://www.recurse.com/">Recurse Center’s</a> weekly presentations. I’m a Recurse alum and always find presenting there motivating.</p>

<p>I brought something like this:</p>
<div>
<div>
    
    
    <video playsinline="" controls="" muted="" poster=" /assets/images/breaktime/somewhat-juiced-firstframe.png ">
    
        <source src="/assets/images/breaktime/somewhat-juiced.mp4" type="video/mp4"/>
    </video>
    
    <p> the color of the ball here really irks me </p>
    
</div>

</div>

<p>That looks a lot better! But there’s still a lot to do. The full set of juice I added includes:</p>
<ul>
  <li>Scaling the ball up and down when it bounces</li>
  <li>Shrinking the paddle when the ball hits it</li>
  <li>Changing the ball’s color over time (more quickly when it bounces)</li>
  <li>Shaking the screen when an event is destroyed</li>
  <li>Particle effects that match an event’s color when it shatters</li>
  <li>No background (the background here is ugly)</li>
  <li>Sliding in the gameplay elements at the start</li>
  <li>Blurring the bottom of the screen since there’s no collision allowed there<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup></li>
  <li>Adding a trail to the ball that traces its path</li>
</ul>

<p>It’d take wayyy too much time to talk about how I approached each of these problems. Let’s talk about two.</p>

<h4 id="particle-effects">Particle effects</h4>

<p>Creating particles for event shattering was delightfully straightforward. I borrowed heavily from <a href="https://css-tricks.com/adding-particle-effects-to-dom-elements-with-canvas/">this CSS tricks post</a>.</p>

<p>The basic idea is:</p>
<ul>
  <li>Get the bounds of the event to shatter</li>
  <li>Get the background color of the computed style of the event</li>
  <li>Divide the bounds of the event into 30 equal-ish rectangles</li>
  <li>Create colored divs for each of those rectangles using the event’s <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle">computed style</a></li>
  <li>Animate their position, rotation, color, and opacity with some jitter</li>
</ul>

<p>Here’s approximately what that looks like.</p>
<div><div><pre><code><span>function</span> <span>addParticlesForEvent</span><span>(</span><span>bounds</span><span>,</span> <span>color</span><span>)</span> <span>{</span>
    <span>const</span> <span>width</span> <span>=</span> <span>bounds</span><span>.</span><span>width</span> <span>/</span> <span>numberOfRows</span><span>;</span>
    <span>const</span> <span>height</span> <span>=</span> <span>bounds</span><span>.</span><span>height</span> <span>/</span> <span>numberOfColumns</span><span>;</span>

    <span>for</span> <span>(</span><span>let</span> <span>y_</span> <span>=</span> <span>0</span><span>;</span> <span>y</span> <span>&lt;</span> <span>numberOfRows</span><span>;</span> <span>y</span><span>++</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> <span>x_</span> <span>=</span> <span>0</span><span>;</span> <span>x</span> <span>&lt;</span> <span>numberOfColumns</span><span>;</span> <span>x</span><span>++</span><span>)</span> <span>{</span>
        <span>const</span> <span>x</span> <span>=</span> <span>bounds</span><span>.</span><span>left</span> <span>+</span> <span>width</span> <span>*</span> <span>x_</span><span>;</span>
        <span>const</span> <span>y</span> <span>=</span> <span>bounds</span><span>.</span><span>top</span> <span>+</span> <span>height</span> <span>*</span> <span>y_</span><span>;</span>
        <span>// Explode out from the center</span>
        <span>const</span> <span>center</span> <span>=</span> <span>{</span> <span>x</span><span>:</span> <span>bounds</span><span>.</span><span>left</span> <span>+</span> <span>width</span> <span>/</span> <span>2</span><span>,</span> <span>y</span><span>:</span> <span>top</span> <span>+</span> <span>height</span> <span>/</span> <span>2</span> <span>};</span>
        <span>const</span> <span>vector</span> <span>=</span> <span>normalizeVector</span><span>(</span><span>subtractVectors</span><span>({</span> <span>x</span><span>,</span> <span>y</span> <span>},</span> <span>center</span><span>));</span>

        <span>const</span> <span>distance</span> <span>=</span> <span>Math</span><span>.</span><span>floor</span><span>(</span><span>Math</span><span>.</span><span>random</span><span>()</span> <span>*</span> <span>75</span> <span>+</span> <span>25</span><span>);</span>
        <span>const</span> <span>toX</span> <span>=</span> <span>vector</span><span>.</span><span>x</span> <span>*</span> <span>distance</span> <span>*</span> <span>makeJitter</span><span>();</span>
        <span>const</span> <span>toY</span> <span>=</span> <span>vector</span><span>.</span><span>y</span> <span>*</span> <span>distance</span> <span>*</span> <span>makeJitter</span><span>();</span>
        <span>const</span> <span>rotation</span> <span>=</span> <span>(</span><span>Math</span><span>.</span><span>random</span><span>()</span> <span>-</span> <span>0.5</span><span>)</span> <span>*</span> <span>720</span> <span>+</span> <span>&#34;</span><span>deg</span><span>&#34;</span><span>;</span>
        <span>const</span> <span>particle</span> <span>=</span> <span>makeParticle</span><span>(</span><span>width</span><span>,</span> <span>height</span><span>,</span> <span>color</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>);</span>

        <span>const</span> <span>startingAnimation</span> <span>=</span> <span>{</span> <span>opacity</span><span>:</span> <span>1</span> <span>};</span>
        <span>const</span> <span>endingAnimation</span> <span>=</span> <span>{</span>
          <span>opacity</span><span>:</span> <span>0</span><span>,</span>
          <span>transform</span><span>:</span> <span>`translate(</span><span>${</span><span>toX</span><span>}</span><span>px, </span><span>${</span><span>toY</span><span>}</span><span>px) rotate(</span><span>${</span><span>rotation</span><span>}</span><span>)`</span><span>,</span>
        <span>};</span>
        <span>const</span> <span>animation</span> <span>=</span> <span>particle</span><span>.</span><span>animate</span><span>(</span>
          <span>[</span><span>startingAnimation</span><span>,</span> <span>endingAnimation</span><span>],</span>
          <span>{</span>
            <span>duration</span><span>:</span> <span>250</span> <span>+</span> <span>Math</span><span>.</span><span>random</span> <span>*</span> <span>500</span><span>,</span>
            <span>delay</span><span>:</span> <span>Math</span><span>.</span><span>random</span><span>()</span> <span>*</span> <span>100</span><span>,</span>
            <span>easing</span><span>:</span> <span>&#34;</span><span>ease</span><span>&#34;</span><span>,</span>
          <span>}</span>
        <span>);</span>

        <span>animation</span><span>.</span><span>onfinish</span> <span>=</span> <span>()</span> <span>=&gt;</span> <span>{</span>
          <span>particle</span><span>.</span><span>remove</span><span>();</span>
        <span>};</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
</code></pre></div></div>

<p>I did something similar to create particles when the ball bounces against the paddle. And I ended up making a pool of 300 ready-to-use particles that I reused to avoid creating and removing tons of divs (this was probably unnecessary).</p>

<h4 id="screen-shake">Screen Shake</h4>

<p>Screen shake is controversial<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">4</a></sup> - too much of it can be nauseating and disorienting. But I’ve found that sprinkling a bit in can really make you feel the impact of a collision. And it turns out that it’s super easy to add!</p>

<p>My entire implementation is:</p>
<div><div><pre><code><span>function</span> <span>makeScreenShake</span><span>()</span> <span>{</span>
    <span>const</span> <span>duration</span> <span>=</span> <span>250</span><span>;</span>
    <span>let</span> <span>magnitude</span> <span>=</span> <span>7.5</span><span>;</span>
    <span>let</span> <span>startTime</span> <span>=</span> <span>null</span><span>;</span>
    <span>let</span> <span>isShaking</span> <span>=</span> <span>false</span><span>;</span>

    <span>function</span> <span>shake</span><span>(</span><span>currentTime</span><span>)</span> <span>{</span>
        <span>const</span> <span>elapsedTime</span> <span>=</span> <span>currentTime</span> <span>-</span> <span>startTime</span><span>;</span>
        <span>const</span> <span>remainingTime</span> <span>=</span> <span>duration</span> <span>-</span> <span>elapsedTime</span><span>;</span>
        <span>if</span> <span>(</span><span>remainingTime</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>const</span> <span>randomX</span> <span>=</span> <span>(</span><span>Math</span><span>.</span><span>random</span><span>()</span> <span>-</span> <span>0.5</span><span>)</span> <span>*</span> <span>magnitude</span><span>;</span>
            <span>const</span> <span>randomY</span> <span>=</span> <span>(</span><span>Math</span><span>.</span><span>random</span><span>()</span> <span>-</span> <span>0.5</span><span>)</span> <span>*</span> <span>magnitude</span><span>;</span>
            <span>mainElt</span><span>.</span><span>style</span><span>.</span><span>transform</span> <span>=</span> <span>`translate(</span><span>${</span><span>randomX</span><span>}</span><span>px, </span><span>${</span><span>randomY</span><span>}</span><span>px)`</span><span>;</span>
            <span>requestAnimationFrame</span><span>(</span><span>shake</span><span>);</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>mainElt</span><span>.</span><span>style</span><span>.</span><span>transform</span> <span>=</span> <span>&#34;</span><span>translate(0px, 0px)</span><span>&#34;</span><span>;</span>
            <span>magnitude</span> <span>=</span> <span>5</span><span>;</span>
            <span>isShaking</span> <span>=</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>function</span> <span>startOrContinueShaking</span><span>()</span> <span>{</span>
        <span>startTime</span> <span>=</span> <span>performance</span><span>.</span><span>now</span><span>();</span>
        <span>if</span> <span>(</span><span>isShaking</span><span>)</span> <span>{</span>
            <span>magnitude</span> <span>+=</span> <span>5</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>requestAnimationFrame</span><span>(</span><span>shake</span><span>);</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>startOrContinueShaking</span><span>;</span>
<span>}</span>
<span>const</span> <span>screenShake</span> <span>=</span> <span>makeScreenShake</span><span>();</span>
</code></pre></div></div>

<p>And I think it makes a huge difference. Here I’ve changed the game to only start the screenshake after a few collisions:</p>
<div>
<div>
    
    
    <video playsinline="" controls="" muted="" poster=" /assets/images/breaktime/noscreenshake-firstframe.png ">
    
        <source src="/assets/images/breaktime/noscreenshake.mp4" type="video/mp4"/>
    </video>
    
    <p> screenshake starts on the 6th collision </p>
    
</div>

</div>

<p>One improvement I could have made here is to have each frame of screenshake depend on the prior frame using a noise generation algorithm (instead of just generating random values). <a href="https://kidscancode.org/godot_recipes/3.x/2d/screen_shake/index.html">This article</a> describes an approach I’ve taken in previous games.</p>

<h4 id="other-stuff">Other stuff</h4>
<p>There’s so much more stuff that I implemented here! I added <a href="https://github.com/nolenroyalty/breaktime/blob/856cdb2ad6f161837023b66d233e59958a674422/code/main.js#L1184">custom tweening logic</a> for ball/paddle scaling because using CSS tweening would interfere with moving the objects around smoothly. The <a href="https://github.com/nolenroyalty/breaktime/blob/856cdb2ad6f161837023b66d233e59958a674422/code/main.js#L1010">ball trail</a> adds elements that track the position of the ball over time while slowly fading out. The <a href="https://github.com/nolenroyalty/breaktime/blob/856cdb2ad6f161837023b66d233e59958a674422/code/main.js#L973">color changing</a> relies on the lovely CSS <code>hue-rotation</code> property.</p>

<p>But this post is super long and there’s still more to cover. Let’s keep going!</p>



<p>Remember, my original approach to moving the ball was “every 50ms, move it a fixed amount and rely on the CSS <code>transition</code> property to ensure that that movement is linear.”</p>

<p>This works ok, but produces unnatural movement if that loop doesn’t run <em>exactly</em> every 50ms.</p>

<div>
<div>
    
    
    <video playsinline="" controls="" muted="" poster=" /assets/images/breaktime/notsmooth-firstframe.png ">
    
        <source src="/assets/images/breaktime/notsmooth.mp4" type="video/mp4"/>
    </video>
    
    <p> ignore that bounce off the floor there... </p>
    
</div>

</div>

<p>Most of the time this would result in movement that felt just a little bit off, but occasionally you’d get <em>huge</em> leaps.</p>

<p>To fix this I moved my game loop to rely on <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"><code>requestAnimationFrame</code></a>.</p>

<p>The idea is that you give <code>requestAnimationFrame</code> a function that you want to run immediately before the browser repaints the screen. That callback gets a timestamp representing the amount of time that’s passed since the previous frame. So if it’s only been 25ms since the last frame, you only move the ball half as long as if it’s been 50ms. You end up with a variable frame rate but much smoother animations - especially since the browser will try to sync things up with your monitor’s refresh rate<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">5</a></sup>.</p>

<p>Moving things based on <code>deltaTime</code> is standard practice in games. <a href="https://www.youtube.com/watch?v=yGhfUcPjXuE">This video</a> provides a nice overview.</p>


<p>I wanted BreakTime to actually be able to decline your events. I think a lot of the joy of a project like this is fully committing to the bit, and the bit here definitely includes “not going to the meetings I destroy.”</p>

<p>This was a challenge because I didn’t want any dependencies so I couldn’t use the calendar API. Instead I needed to script the process of declining the events.</p>

<p>The approach I took relied on <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver"><code>MutationObservers</code></a> - an object that watches for changes in the DOM. My observer watches for anything that looks like a calendar dialog, searches that dialog for a “decline” button, and clicks it.</p>

<p>This was tricky and a little fragile. A few things to highlight:</p>
<ul>
  <li>It’s important to decline events one at a time<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" rel="footnote">6</a></sup>. To handle this I <a href="https://github.com/nolenroyalty/breaktime/blob/856cdb2ad6f161837023b66d233e59958a674422/code/main.js#L152">use a second observer to wait for all dialogs tied to the current event to clear</a></li>
  <li>Some events don’t have a decline option (e.g. if they have no guests); the code must handle that gracefully</li>
  <li>Some events are recurring, which means they spawn a second modal on decline (the modal asks whether you want to decline one or all of the events)</li>
</ul>

<p>But the most fragile bit of logic is that I search for buttons based on their text. This means that event declining only works if Google Calendar is in English. The only other approach I could think of was to hardcode the location in the DOM of the buttons which seemed even worse. But I’m sure there’s something smarter I could do here.</p>

<p>The final result is a flurry of events popping up and disappearing, which I think is pretty fun.</p>





<p>For some reason I thought there was no chance that I could get this into the Chrome Webstore<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" rel="footnote">7</a></sup>. But my friend <a href="https://www.carolynzhang.com/">Kelin</a> convinced me that I totally could, and I was encouraged by Google’s social accounts <a href="https://twitter.com/googlecalendar/status/1764769037156843555">tweeting about my stuff</a>.</p>

<p>I was also pretty sick of copy-pasting what had become almost 2,000 lines of javascript and CSS into the browser console every time I wanted to run the game.</p>

<p>It turns out that making an extension is pretty easy! The <a href="https://developer.chrome.com/docs/extensions/get-started/tutorial/hello-world">intro docs</a> are pretty good and I didn’t need to do anything fancy. Moving to an extension also made me teach me code to run multiple times without refreshing a tab, which I doubt I would have done with a bookmarklet.</p>

<p>Getting the extension approved took under a day - it probably helps that the extension only runs when invoked so its permissions are pretty simple.</p>



<p>This was one of my favorite projects. I’m particularly happy that, while it involves embedding a game somewhere it doesn’t belong, the game makes sense for the medium. I’m very proud of <a href="https://www.openculture.com/nonsense/game-11-flappy-bird-finder/">Flappy Dird</a> and <a href="https://www.openculture.com/nonsense/implementing-wordle-in-the-firefox-address-bar/">Wordle in the Firefox address bar</a> but both of those games are totally unrelated to their constraints - they’re just the best ideas I had for how to build a game given the constraints I had chosen. This feels different.</p>

<p>Building a little engine for this project was <em>great</em>. It definitely took more time but I learned a ton - there’s simply no way I’d understand collisions in the same way if I hadn’t written the logic myself. And I’m much handier with the DOM after adding my own particles and scripting event declines.</p>

<p>I also have a ton of people to thank for this project. Thank you to <a href="https://twitter.com/ianthehenry/status/1757464426616435093">Ian Henry</a> for the initial inspiration, <a href="https://twitter.com/ChanaMessinger/status/1757941634975859132">Chana Messinger</a> for naming the game, <a href="https://kelin.online">Kelin</a> for convincing me to make a chrome extension, <a href="https://recurse.com">Recurse Center</a> for the encouragement, and <a href="https://www.joshwcomeau.com/">Josh W Comeau</a> for teaching me all of the CSS and Javascript that I know (I knew basically nothing at the start of this year!).</p>

<p>If you enjoyed this post I’d encourage you to apply to <a href="https://www.recurse.com/">Recurse</a>, which is the best place in the world to build stuff like this in a supportive environment. And if you want to hear about my future nonsense you should sign up for my <a href="https://eieio.substack.com/">mailing list</a> or follow me <a href="https://twitter.com/itseieio">on twitter</a>.</p>

<p>I’m going to be at <a href="https://gdconf.com/">GDC</a> next week to present on <a href="https://eieio.games/nonsense/game-12-stranger-video/">stranger video</a> at the Experimental Games Workshop and to meet people - if you’re going to be there I’d love to meet up :)</p>

<p>I’ll be back in April with something new and horrifying.</p>



    </div></div>
  </body>
</html>
