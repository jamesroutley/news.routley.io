<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.anyleaf.org/blog/quaternions:-a-practical-guide">Original</a>
    <h1>Quaternions: A Practical Guide</h1>
    
    <div id="readability-page-1" class="page"><p>


            <h5>Written on Aug. 6, 2022, 7:53 a.m.</h5>

            
                <h5>Updated Aug. 14, 2022, 4:41 a.m.</h5>
            
        </p><div><h2>Overview</h2>

<p>This article demonstrates how to use quaternions for practical applications. In it, we build intuition about how to use quaternions as building blocks to solve engineering and geometry problems. Applications include computer graphics, attitude systems for air and spacecraft, and structural chemistry models. You may have read that quaternions have advantages over Euler angles to represent orientations, including preventing gimbal lock, and advantages over rotation matrices, such as more efficient computation, and compact form. This is true. You may have also read that they&#39;re complicated, difficult to use, or counter-intuitive. This isn&#39;t! </p>

<p>This article outlines several operations between quaternions and vectors, and describes how to perform them. It doesn&#39;t describe <em>why</em> they work.  There are many articles and videos online where you can learn about this, including perspectives from numerical algorithms, visualizations (including stereographic projections of 4d space!), and symbolic operations. These sources are important for achieving a deep understanding - some examples are included in the <em>References</em> section at the bottom. This article, in contrast, contains concise information that will make you effective at using quaternions as an engineering tool.</p>

<p>Why are we taking this approach instead of building deeper knowledge? I&#39;m aiming for a specific level of detail that&#39;s suitable for engineering purposes. <strong>We&#39;re building intuition so you&#39;ll be able to learn a few general tools, then be able to apply them to a broad range of applications.</strong> You should be able to recognize when they&#39;re appropriate, how to combine them, and how to apply them to physical systems and models. A deeper approach might describe why the arithmetic we define them with works. A shallower approach might provide complete orientation and rotation systems, like in a computer graphics library. Hopefully we&#39;ve hit a sweet spot.</p>

<p>This article uses mathematical notation, in a format that can easily be translated to any procedural programming language. It includes the information you need to turn these operations into code, in a language-agnostic format. It uses some mathematical conventions, with limited abstractness.</p>

<p>The key takeaway is that <strong>quaternions are a powerful, elegant tool that can be used whenever modelling rotations or orientations in 3D. When viewed this way, they&#39;re neither complicated to use, nor to understand.</strong></p>

<p>If you&#39;d like an interactive description, check out <a href="https://eater.net/quaternions">this 3Blue1Brown + Ben Eater collaboration</a>. It&#39;s a page containing a number of interactive videos that explain and visualize the significance of quaternions, including for rotations. It lets you pause the videos, then interact with the visualizations. Further, this article doesn&#39;t describe the algebra of quaternions; if you&#39;re curious, <a href="https://www.weizmann.ac.il/sci-tea/benari/sites/sci-tea.benari/files/uploads/softwareAndLearningMaterials/quaternion-tutorial-2-0-1.pdf">this article</a> goes into detail.</p>

<hr/>

<h2>Basics</h2>

<p>A quaternion is described by a set of 4 numbers, labeled \(w\),  \(x\),  \(y\), and  \(z\). In code, this may be represented by a struct (or class) with 4 floating-point fields, and functions (eg methods) that perform various operations, and overload arithmetic operators.</p>

<p><strong>All quaternions used in this article are unit quaternions; they have a magnitude of 1.</strong> These are also known as <em>versors</em>. <em>Magnitude</em> in this context is defined in a similar way as with vectors: The square root of the sum of squares of each component:</p>

<p>$$ || Q || = \sqrt{Q_w^2 + Q_x^2 + Q_y^2 + Q_z^2} $$</p>

<p><strong>All vectors in this article are unit vectors in 3 dimensions.</strong> Many of the operations involve vectors; some knowledge of vectors and linear algebra is required.</p>

<p>Note that unit quaternions double-cover the set of all possible 3d rotations; every rotation can be represented by either of 2 unique quaternions. For details on this, check out <a href="https://www.gathering4gardner.org/g4g13gift/math/BickfordNeil-GiftExchange-WhyDoTheUnitQuaternionsDoubleCoverTheSpaceOfRotations-G4G13.pdf">this paper by Neil Bickford</a>.</p>

<hr/>

<h2>Rotation and orientation</h2>

<p><strong>Orientation and rotation quaternions are equivalent: The distinction is that ones used for orientation describe the operation that rotates the <em>identity quaternion</em> to the orientation.</strong> The identity quaternion is defined as having a \(w\) component equal to 1, and all others equal to 0. The distinction is how you use them; it&#39;s important to keep track of which quaternions you use for orientation vice rotations, even though the mathematics is the same.</p>

<p>As a convention, we&#39;ll use \( O \) for quaternions that represent orientations, and \( R \) for ones that represent rotations.</p>

<p>Quaternions are sometimes compared with matrices as ways to transform space. We&#39;ll go over this with more detail below; the key takeaway is that <strong>matrices represent linear transforms; quaternions represent a special case of linear transform: rotations in 3 dimensions.</strong></p>

<p>An important distinction: Quaternions directly describe rotations, and aren&#39;t tied to any coordinate system or absolute orientation. Conversely, most computations need a result tied to absolute orientation; a coordinate system. Examples: An aircraft&#39;s upright attitude; a 3D model&#39;s up orientation; a vector defined by global coordinates. </p>

<hr/>

<h2>Anchoring quaternions to coordinates and directions</h2>

<p>Let&#39;s examine a 3d model of a boat. Its orientation is stored as a quaternion; one that represents the result of its rotation on the unit quaternion. How do we orient it so that its hull is pointed down? The key in how the model is defined, and how the graphics engine is set up. If you&#39;d like the unit quaternion to represent an upright and level orientation, the boat&#39;s model should be defined using an <em>up</em> direction that&#39;s the same as the graphics engine expects. If not, you can use a different quaternion to represent up. </p>

<p>In an aircraft&#39;s attitude system, something similar applies: We move from relative quaternions to absolute orientation by anchoring the system&#39;s inputs to, for example, the earth&#39;s gravitational field. We could define the <em>up</em> orientation as a unit quaternion where an accelerometer&#39;s <em>z</em> axis reads +1G. With this in mind, how the accelerometer is oriented within the aircraft provides the anchor.</p>

<p>As you read through the operations below, you&#39;ll notice quaternions can be used to define a rotation between vectors, or rotate a vector to a new position. The theme is that quaternions represent transitions between 2 or more vectors. You may have seen functions in graphics libraries that construct quaternions that point in a direction - note how they always include one or more reference vectors as arguments - eg <em>up</em> or <em>forward</em>.</p>

<p>What about quaternions operating on other unanchored quaternions? These aren&#39;t yet anchored, and in most systems, will ultimately act on something else, directly or indirectly. A common example is describing rotations relative to an anchored orientation, or a vector.</p>

<hr/>

<h2>Rotating a vector using a quaternion</h2>

<p>Rotating a vector is one of the most common applications of quaternions, and is a building block for other operations. Here&#39;s how it&#39;s done, assuming a unit quaternion and unit vector:</p>

<p>$$ \vec{v}&#39; =  Q \vec{v} Q^{-1} $$</p>

<p>Where  \(  \vec{v}  \) is the original vector, \(  \vec{v}&#39;  \) is the rotated vector,  \(  Q  \) is the quaternion that defines the rotation, and \(  Q^{-1}  \) is its inverse. The inverse of a quaternion is that quaternion with the same <em>w</em> component, and the negation of the others: </p>

<p>$$ Q^{-1} = [Q_w, -Q_x, -Q_y, -Q_z] $$</p>

<p>This is also known as the quaternion&#39;s <em>conjugate</em>, written as \( Q^* \). For unit quaternions, the conjugate and inverse is the same. An example: if \(Q = [1, 2, 0, -1] \),  \(Q^{-1} = [1, -2, 0, 1] \).</p>

<p>Quaternion multiplication, used above, is defined as follows. Note that to multiply a quaternion by a vector, convert the vector to a quaternion with \(w=0\), and with \(x\), \(y\), and \(z\) as the vector&#39;s respective components.</p>

<p>$$ w = L_w  R_w - L_x  R_x - L_y R_y - L_z R_z $$
$$ x = L_w  R_x + L_x  R_w + L_y  R_z - L_z  R_y $$
$$ y = L_w  R_y - L_x  R_z + L_y  R_w + L_z  R_x $$
$$ z = L_w  R_z + L_x  R_y - L_y  R_x + L_z  R_w $$</p>

<p>$$ Q_{LR} = L R = [w, x, y, z] $$</p>

<hr/>

<h2>Specifying a quaternion that describes the rotation from one vector to another</h2>

<p>There are multiple rotations that can describe this; the equation above describes the shortest rotation. \( R \) is the quaternion that rotates unit vector \( \vec{v1} \) to unit vector  \( \vec{v2} \). </p>

<p>$$ w = 1 + \vec{v1} \cdot \vec{v2} $$
$$ [x, y, z] = \vec{v1} \times \vec{v2} $$
$$ R = \frac{ [w, x, y, z] }{ ||[w, x, y, z]|| } $$</p>

<p>Note: The above approach will fail if the vectors are parallel; to correct this in code, check that the dot product is equal to 1 or -1. If equal to 1, return the identity quaternion. If equal to -1, return the identity quaternion rotated by π radians. To do this, construct a rotation-around-axis (described below), using a vector orthonormal to either input vector as the axis, and π as the angle. You can construct the orthonormal vector by taking the cross product between our first bond, and an arbitrary unit vector.</p>

<p>This is a versatile operation! Earlier, we mentioned how quaternions aren&#39;t anchored to coordinates or directions. Let&#39;s say we&#39;d like a 3d model to align with a certain directional vector. To do this, we use the operation above, with \( \vec{v1} \) as the <em>up</em> vector the model uses, and \( \vec{v2} \) as the vector defining the direction.</p>

<hr/>

<h2>Specifying a quaternion that describes rotation around an axis</h2>

<p>To create a quaternion \( R \) that describes the rotation of amount \( \theta \) around axis \( \vec{v} \), use this equation:</p>

<p>$$ w = \cos{\frac{\theta}{2}} $$
$$ x =  \sin{\frac{\theta}{2}} \vec{v} _x $$
$$ y =  \sin{\frac{\theta}{2}} \vec{v} _y $$
$$ z =  \sin{\frac{\theta}{2}} \vec{v} _z $$</p>

<p>$$ R = [w, x, y, z] $$</p>

<p>One example of this use is changing the orientation of computer-graphics objects in response to user input. For example, modifying camera orientation in response to mouse movements. You could create a rotation around the X axis ( \(\vec{1, 0, 0} \) ) with one around the y axis  ( \(\vec{1, 0, 0} \) ), then apply both of these to the current orientation: \( O_{new} = R_x R_y O \) The rotation amount would be the degree of input in the given directions.</p>

<hr/>

<h2>Rotating an orientation, and composing rotations</h2>

<p>To rotate a quaternion representing an orientation, perform quaternion multiplication with the rotation quaternion on the left:</p>

<p>$$ O&#39; = R O $$</p>

<p>To compose multiple rotations, perform quaternion multiplication with the first rotation to apply on the right, and the last on the left. When multiple rotations are composed in this way, they are applied right to left. For example, this is how you would apply 2 rotations to an orientation:</p>

<p>$$ R_{12} = R_2 R_1 $$</p>

<p>Here&#39;s an example applying both of those techniques;  \( O&#39; \) is the orientation as if \( R_1 \), were applied to \( O \), then \( R_2 \), then \( R_3 \).</p>

<p>$$ O&#39; = R_3 R_2 R_1 O $$</p>

<p>Where \( O \) is the initial orientation, and \( O&#39; \) is the orientation after applying \(R_{r1} \) followed by \( R_{r2} \). Note that equivalently, you could compose the rotations first, then apply them. (eg by storing as a variable, or using parentheses to group the rotations)</p>

<p><strong>Quaternion multiplication is non-commutative, meaning order matters.</strong></p>

<hr/>

<h2>Quaternions for change of basis</h2>

<p>Matrices are the most common way to describe <a href="https://en.wikipedia.org/wiki/Change_of_basis">change-of-basis</a> operations in linear algebra. For change of basis operations that are purely rotational (don&#39;t stretch or skew the space), quaternions are a more efficient (an arguably more intuitive) approach.</p>

<p>To do this, create a rotation quaternion that rotates between 2 vectors, as described above. Set the first vector to the starting basis vector you wish  wish to change, and the second vector to its equivalent in the new basis. </p>

<hr/>

<h2>Construction from Euler angles</h2>

<p>Creating an orientation quaternion from Euler angles follows from 2 points above: #1: Orientation quaternions are rotations of the identity quaternion. #2: We can construct a rotation around an axis using an axis vector and rotation angle. So, to construct an orientation from angles, we can combine rotations from each basis vector. The \( fromAxisAngle \) function below is the procedure described in the <em>Specifying a quaternion that describes rotation around an axis</em> section above.</p>

<p>$$ O_x = fromAxisAngle([1, 0, 0], \phi) $$
$$ O_y = fromAxisAngle([0, 1, 0], \psi) $$
$$ O_z = fromAxisAngle([0, 0, 1], \theta) $$
$$ O = O_x O_y O_z $$</p>

<p>Where \( \phi \), \( \psi \), and \( \theta \) are Euler angles around \(x\), \(y\), and \(z\) axes respectively.</p>

<p>Alternatively, we can combine some operations with the following approach:</p>

<p>$$ cy = \cos(\frac{\theta}{2}) $$
$$ sy = \sin(\frac{\theta}{2}) $$
$$ cp = \cos(\frac{\psi}{2}) $$
$$ sp = \sin(\frac{\psi}{2}) $$
$$ cr = \cos(\frac{\phi}{2}) $$
$$ sr = \sin(\frac{\phi}{2}) $$</p>

<p>$$ w = cr \cdot cp \cdot cy + sr \cdot sp \cdot sy $$
$$ x = sr \cdot cp \cdot cy - cr \cdot sp \cdot sy $$
$$ y = cr \cdot sp \cdot cy + sr \cdot cp \cdot sy $$
$$ z = cr \cdot cp \cdot sy - sr \cdot sp \cdot cy $$</p>

<p>$$ O = [w, x, y, z] $$</p>

<hr/>

<h2>Conversion to Euler angles</h2>

<p>( todo)</p>

<hr/>

<h2>Spherical linear interpretation (SLERP)</h2>

<p>Given two quaternions that represent orientation, this is how you calculate an intermediate orientation a given portion between the two:</p>

<p>$$ (Q_2 Q_1^{-1})^t Q_1 $$</p>

<p>Where t is the portion between the two quaternions, on a scale between 0 and 1. Of note, the inverse of a quaternion, as described earlier, is itself with its x, y, and k components negated.  To take the exponent of a quaternion with a number, (to be continued!)</p>

<p>Interpolation is useful when creating animations., since it lets you determine the orientation at arbitrary steps between starting and ending orientations.</p>

<hr/>

<h2>An example using several of the above techniques</h2>

<p>We&#39;ll now go over an example of applying the techniques above  to a practical problem. Note how we use a few tools to do a variety of manipulations on 3d objects. Let&#39;s consider the case where we are modelling a chain of atoms connected to each other by chemical bonds. We&#39;ll focus on a single bond; we can iterate this procedure to make additional bonds. We&#39;ll ignore physical subtleties, and model the situation like this:</p>

<ul>
<li><p>\( O_{prev} \): An atom of known orientation, with its orientation represented by a quaternion, and its position represented by a vector. Its orientation is the output of the previous iteration of our process (and perhaps a known anchor point for the first atom, like a unit quaternion)</p></li>
<li><p>\(\theta \): The rotation amount around the bond axis. This is called the dihedral (or torsion) angle, and defines the protein&#39;s degrees of freedom when folding. (These are conventionally called \( \phi \), \( \psi \), and \( \omega \) depending on their location within an amino acid. These angles are anchored in terms of the neighboring 4 atom around a bond, but we&#39;ll skip this for simplicity.)</p></li>
</ul>

<p>We can break this problem down into determining the orientation and position of each individual atom, using the previous atom&#39;s orientation and position, and the bond geometry.</p>

<p>We will define 2 unit vectors that represent the bonds to, and from this atom; these are called bond angles.  These will be defined in relation to an atom; these are in local space, not global coordinates (worldspace). Their relative positions are what&#39;s important, so we&#39;ll pick an arbitrary unit vector for the first: </p>

<p>$$ \vec{bondToNext} = [1, 0, 0]  $$</p>

<p>To find the other angle, we can construct a quaternion from the angle between the bonds, and an arbitrary axis orthonormal to the first bond. Note that we can use an arbitrary orthnormal axis because we only care about the relative bond positions. We create it by taking the cross product between our first bond, and an arbitrary unit vector. </p>

<p>$$ \vec{axis} = \vec{bondToNext} \times  \vec{anyUnitVec} $$
$$ Q_{bonds} = fromAxisAngle( \vec{axis}, \theta_{bonds} )  $$</p>

<p>Then, we create the other bond vector (The one defined as being at a given angle from the other) by rotating the first using the rotation we created:</p>

<p>$$ \vec{bondToPrev} = Q_{bonds} \vec{bondToNext} Q_{bonds}^{-1} $$</p>

<p>The result is 2 vectors that are aligned relative to each other at the specified bond angle, \( \theta_{bonds} \) We will use these local vectors for all atoms in the chain.</p>

<p>We then align the local bond vector of the previous atom to worldspace based on the prev atom&#39;s orientation. We do this by aligning the \( toNext \) local bond from the previous atom to worldspace, then aligning the  \( toPrev \) local bond of this atom to it. </p>

<p>$$ bondToThisWorldspace = O_{prev} \vec{bondToNext} O_{prev}^{-1} $$</p>

<p>We apply the rotation quaternion that aligns the (inverse of) the local-space bond to the prev atom with the world-space &#34;to&#34; bond of the previous atom. This is also the orientation of our atom, without applying the dihedral angle (rotation around the bond).</p>

<p>$$ R_{bondAlignment}= fromUnitVecs(- \vec{bondFromThis}, \vec{bondToThisWorldspace}) $$</p>

<p>Now, we rotate the orientation along the dihedral angle, which is a rotation along the bond axis to a specified angle:</p>

<p>$$ R_{aroundAxis} = fromAxisAngle(\vec{bondToThisWorldspace}, \theta) $$</p>

<p>We find our orientation for this atom by applying the 2 rotations sequentially to create our orientation using quaternion multiplication. As we mentioned earlier, order matters here, and operations are ordered right-to-left. So, we apply the bond alignment rotation before the around-axis one.</p>

<p>$$ O = R_{aroundAxis} R_{bondAlignment}  O_{prev}  $$</p>

<p>To continue the chain, we repeat the process, using this new orientation as \( O_{prev} \) in the next iteration. The next atom&#39;s position is \( \vec{bondToNext} \) rotated by this atom&#39;s orientation \( O \), multiplied by the bond&#39;s length.</p>

<hr/>

<h2>On information content</h2>

<p>Let&#39;s compare quaternions, rotation matrices, and Euler angles from the perspective of information. You might notice that a 3D rotation matrix has 9 numerical values, while a quaternion, which can represent the same rotation, has only 4. This begs the question: <em>given that a quaternion with 4 values can represent any 3d rotation, why do rotation matrices have 5 extra values?</em> The answer is that matrices can be used to represent more than rotations: They can represent any linear transformation, of which rotations are a subset. </p>

<p>Matrices can be used to stretch, skew, sheer, and rotate, in any combination, making them more flexible. If we are only rotating, matrices encode extra information - this results in more values to store, and less-efficient computation. It also means they&#39;re an under-constrained system. With this in mind: <strong>Use Quaternions if only modeling rotation. Use matrices if modelling other linear transforms.</strong></p>

<p>Note that compared to Euler angles, quaternions store an extra value. (4 value in a quaternion, vs 3 in Euler angles) This extra value is due to the constraint that the ones we&#39;re using are strictly <em>unit quaternions</em>; this explains the extra degree of freedom.</p>

<hr/>

<h2>A note on rotors and bivectors</h2>

<p><a href="https://marctenbosch.com/quaternions/">A recent article by Marc Ten Bosch</a> makes a case that quaternions are an obfuscated, unintuitive, specialized case of Rotors. This line from that article highlights one of its main points: &#34;<em>I have always found it important to actually understand the things I am using</em>&#34;. In our article, we&#39;ve explicitly avoided the deeper understanding Mr. Bosch alludes to; this is partly due to his point - it&#39;s difficult to understand why quaternion operations work. In his article and accompanying video, Mr. Bosch describes how it&#39;s notoriously difficult to achieve this deeper geometric understanding using quaternions, and is easier with rotors.</p>

<p>Rotors can be used for everything quaternions can. For the practical approach we&#39;ve taken here, rotors don&#39;t have a tangible advantage; their operations are equivalent. Quaternions have the distinct advantage of being standardized on domains like computer graphics and attitude determination. With this in mind, I don&#39;t agree with the article&#39;s title of <em>Let&#39;s remove Quaternions from every 3D Engine</em>, but agree that rotors are a worthwhile alternative to explore and implement. </p>

<p>From the article: &#34;<em>We can notice that 3D Rotors look a lot like Quaternions... In fact the code/math is basically the same! The main difference is that \( i \), \( j\) and \( k \) get replaced by \( y∧z \), \( x∧z \) and \( x∧y \), but they work mostly the same way... However, as we have seen, 3D Rotors are a 3D concept that does not require the use of &#39;4D double rotations&#39; or &#39;stereographic projection&#39; to visualize.</em>&#34;</p>

<hr/>

<h2>An exercise: Eigenvalues and eigenvectors</h2>

<p>For a given linear transform, <a href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors">eigenvectors</a> are vectors that don&#39;t change direction when the transform is applied. Eigenvalues are the scale factor the length of these vectors. These are usually discussed in contexts of matrices, but apply to quaternions as well.</p>

<ul>
<li><p>1: For a unit quaternion, how many eigenvectors are there? What do they represent? What are the associated eigenvalues?</p></li>
<li><p>2: How would you answer differ for a non-unit quaternion? To solve this, you need information outside the scope of this article, but it may give you insight into why we&#39;re using unit quaternions only.</p></li>
</ul>

<p><a href="https://www.3blue1brown.com/lessons/eigenvalues">This 3Blue1Brown video</a> has information that might help. It has info on the significance of eigenvectors on rotations. It also includes an alternative way of defining linear transforms using them, that maps directly to one of the techniques we described above.</p>

<hr/>

<h2>Conclusion</h2>

<p>If you&#39;re modeling something that uses 3D rotations or orientation, quaternions should be in your toolkit. You should know what operations they can be used for, and be able to look up how to apply them.</p>

<hr/>

<h3>References</h3>

<ul>
<li><a href="https://eater.net/quaternions">Grant Sanderson (3Blue1Brown) and Ben Eater: Visualizing Quaternions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">Wikipedia: Quaternions and Spacial Rotations</a></li>
<li><a href="https://ahrs.readthedocs.io/en/latest/filters/aqua.html">AHRS: Algebraic Quaternion Algorithm</a></li>
<li><a href="https://marctenbosch.com/quaternions/">Marcten Bosch: Quaternions</a></li>
<li><a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/">Opengl Tutorial: Quaternions</a></li>
<li><a href="https://www.xarg.org/proof/quaternion-from-two-vectors/">Robert Eisele: Proof: Quaternion from two vectors</a></li>
<li><a href="https://www.allaboutcircuits.com/technical-articles/dont-get-lost-in-deep-space-understanding-quaternions/">All about Circuits: Don&#39;t Get Lost in Deep Space Understanding Quaternions</a></li>
<li><a href="https://www.3dgep.com/understanding-quaternions/">3D Game Engine Programming: Understanding Quaternions</a></li>
<li><a href="https://www.gathering4gardner.org/g4g13gift/math/BickfordNeil-GiftExchange-WhyDoTheUnitQuaternionsDoubleCoverTheSpaceOfRotations-G4G13.pdf">Neil Bickford: Why Do the Unit Quaternions Double-Cover
the Space of Rotations?</a></li>
</ul>
</div></div>
  </body>
</html>
