<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.akshaykhot.com/ruby-switch-statement/">Original</a>
    <h1>Ruby&#39;s Switch Statement Is More Flexible Than You Thought</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p><time datetime="2023-04-25">Apr 25, 2023</time>
        </p>

    

        <p>Ruby&#39;s switch statement is very versatile and flexible, especially due to the dynamic nature of Ruby. In this post, we&#39;ll see how you can use it in various ways. We&#39;ll also learn why it works the way it works. Hint: it uses the `===` operator (method) under the hood. </p>
</div><section>
    <p>Here&#39;s the standard version of the switch statement in Ruby. </p><pre><code>season = &#39;winter&#39;

case season
when &#39;summer&#39;
  puts &#39;it is warm&#39;
when &#39;winter&#39;
  puts &#39;it is cold&#39;
else
  puts &#39;it is raining&#39;
end

# output
# it is cold</code></pre><p>In typical Ruby style of developer happiness, it&#39;s called <code>case</code> and <code>when</code>, instead of <code>switch</code> and <code>case</code>. I find Ruby&#39;s version easier to read and understand.</p><p><em><strong>Note: There&#39;re no <code>break</code> statements at the end of each <code>when</code> clause. Unlike other languages, Ruby&#39;s <code>case</code> doesn&#39;t fall through.</strong></em> </p><p>In the standard form, we&#39;re just comparing the expression provided to <code>case</code> with the <code>when</code> expression and executing the code provided. When no matches are found, the <code>else</code> statement is executed.</p><p>In fact, what really happens is that Ruby compares the expression value provided in the <code>when</code> clause with the value in the <code>case</code> clause using the <code>===</code> operator. This lets you do fancy (but useful) stuff like this:</p><pre><code>puts &#39;enter a number&#39;
number = gets.to_i

case number
when 1..10
  puts &#39;between 1 and 10&#39;
when 11..20
  puts &#39;between 11 and 20&#39;
when 50
  puts &#39;exactly 50&#39;
when 60, 70
  puts &#39;either 60 or 70&#39;
else
  puts &#39;invalid number&#39;
end</code></pre><p><strong>Note: The order matters. We&#39;re comparing the expression provided to the <code>when</code> clause with the <code>case</code> expression, not the other way around (<code>when === case</code>, not <code>case === when</code>). This is because Ruby actually calls the </strong><code><strong>===</strong></code><strong> method on the left operand, passing the second operand as an argument. </strong></p><p>The following example shows the difference. </p><pre><code>(1..10) === 5 # true 

5 === (1..10) # false</code></pre><p>You can also shorten the code by returning on the same line as <code>when</code> clause, using the <code>then</code> clause. </p><pre><code>def can_drive(age)
  case age
  when 1..14 then &#39;no&#39;
  when 15..100 then &#39;yes&#39;
  end
end

puts can_drive(18) # yes</code></pre><p>Additionally, if you want to do comparisons on a variable, just leave out the <code>case</code> expression. This helps to simplify a long and complex if-else chain.</p><pre><code>def calculate(num)
  case
  when num &gt; 10
    puts &#39;greater than 10&#39;
  when num == 5
    puts &#39;exact 5&#39;
  end
end

calculate 12 # greater than 10</code></pre><p>Pretty useful. Now, let&#39;s learn how you can match data types of objects.</p><h2 id="matching-types">Matching Types</h2><p>The <code>===</code> operator lets you match the types of objects. For example,</p><pre><code>Integer === 1     # true
String === &#39;name&#39; # true</code></pre><p>That means you can pass an object in the <code>case</code> clause and match types in the <code>when</code> clause, as follows:</p><pre><code>def perform(obj)
  case obj
  when String
    puts &#39;a string&#39;
  when Integer
    puts &#39;an integer&#39;
  when Vehicle
    puts &#39;a vehicle&#39;
  else
    puts &#39;not a string, integer, or vehicle&#39;
  end
end

perform 5             # an integer
perform &#39;name&#39;        # a string

class Vehicle
end

perform Vehicle.new   # a vehicle</code></pre><p><em><strong>Note: Do not use <code>obj.class</code> in the <code>case</code> clause, as <code>Integer === Integer</code> returns false. This might seem strange at first, but remember that Ruby is actually calling the <code><a href="https://ruby-doc.org/3.2.0/Module.html?ref=akshaykhot.com#method-i-3D-3D-3D">===</a></code> method on <code>Integer</code>. This method checks if the second argument is an instance of this module. Hence it returns <code>false</code>.</strong></em></p><p>It&#39;s also possible to evaluate custom, complicated expressions via a lambda or even classes. Let&#39;s see how.</p><h2 id="custom-expressions">Custom Expressions</h2><blockquote>If it walks like a duck and quacks like a duck, it is a duck.</blockquote><p>So far, we have learned that Ruby will match the <code>when</code> clause with the <code>case</code> clause using the <code>===</code> operator. In fact, it&#39;s calling the <code>===</code> method on the value returned by the <code>when</code> clause. Because of the dynamic nature of Ruby, you can pass any object that has a <code>===</code> method.</p><p>For example, a lambda has a <code><a href="https://ruby-doc.org/3.2.0/Proc.html?ref=akshaykhot.com#method-i-3D-3D-3D">===</a></code> method which simply passes the second operand as an argument to the lambda. </p><pre><code>even = -&gt;(x) { x % 2 == 0 }

even === 4  # true
even === 5  # false</code></pre><p>This means that you can pass a lambda expression in the <code>when</code> clause.</p><pre><code>is_even = -&gt;(x) { x % 2 == 0 }
is_odd = -&gt;(x) { x % 2 == 1 }
num = 4

case num
when is_even then &#39;even&#39;
when is_odd then &#39;odd&#39;
end</code></pre><p>In fact, any object that has a <code>===</code> method can be used in a <code>when</code> statement.</p><pre><code>num = 5

class Even
  def ===(obj)
    (obj % 2) == 0
  end
end

class Odd
  def ===(obj)
    (obj % 2) == 1
  end
end

case num
when Even.new then puts &#39;even&#39;
when Odd.new then puts &#39;odd&#39;
end</code></pre><p>This example is not that useful as it&#39;s oversimplified. I can&#39;t think of a real-life scenario where I&#39;d use custom classes, but it&#39;s pretty useful to know that Ruby let&#39;s you do this. </p><p>Finally, let&#39;s see how you can match regular expressions inside <code>case</code> statement. </p><h2 id="match-regular-expressions">Match Regular Expressions</h2><p>You can use the <code>===</code> operator to match a string against a regular expression.</p><pre><code>pattern = /hello.+/ 

pattern === &#39;hello world&#39; # true
pattern === &#39;world&#39;       # false</code></pre><p>As a result, you can use regular expressions in the <code>when</code> clause in a <code>case</code> statement.</p><pre><code>case word
when /\d/
  puts &#39;digit&#39;
when /[aeiou]/
  puts &#39;a vowel&#39;
end</code></pre><p>Couldn&#39;t get simpler than this.</p><h2 id="pattern-matching">Pattern Matching</h2><p><a href="https://ruby-doc.org/3.2.0/syntax/pattern_matching_rdoc.html?ref=akshaykhot.com">Pattern Matching</a> is another powerful use case for the case statement in Ruby (<em><strong>Credits: </strong>Thanks to the commenter on Hackernews for pointing this out</em>). I recommend reading the official documentation, but here&#39;s a gist of it:</p><p>Pattern matching allows deep matching of structured values: <strong>checking the structure and binding the matched parts to local variables. </strong>It uses <code>case .. in</code> instead of <code>case .. when</code>. </p><pre><code>case &lt;expression&gt;
in &lt;pattern1&gt;
  ...
in &lt;pattern2&gt;
  ...
in &lt;pattern3&gt;
  ...
else
  ...
end</code></pre><p>For example,</p><pre><code>config = {db: {user: &#39;admin&#39;, password: &#39;abc123&#39;}}

case config
in db: {user:} # matches subhash and puts matched value in variable user
  puts &#34;Connect with user &#39;#{user}&#39;&#34;
in connection: {username: }
  puts &#34;Connect with user &#39;#{username}&#39;&#34;
else
  puts &#34;Unrecognized structure of config&#34;
end
# Prints: &#34;Connect with user &#39;admin&#39;&#34;</code></pre><p>It&#39;s fascinating and deserves a blog post on its own. Stay tuned!</p><p>That&#39;s a wrap. <strong>Did I miss anything? </strong>Please let me know in the comments below. </p><hr/><p>I hope you liked this article and you learned something new.</p><p>As always, if you have any questions or feedback, didn&#39;t understand something, or found a mistake, please leave a comment below or <a href="mailto:akshay.khot@hey.com?ref=akshays-blog" rel="noreferrer">send me an email</a>. I look forward to hearing from you.</p><p>If you&#39;d like to receive future articles directly in your email, please <a href="https://www.akshaykhot.com/#/portal/signup">subscribe to my blog</a>. If you&#39;re already a subscriber, thank you.</p>
</section></div>
  </body>
</html>
