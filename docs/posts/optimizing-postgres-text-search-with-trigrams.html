<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexklibisz.com/2022/02/18/optimizing-postgres-trigram-search.html">Original</a>
    <h1>Optimizing Postgres text search with trigrams</h1>
    
    <div id="readability-page-1" class="page"><div> <header>  <p> <span> <i aria-hidden="true"></i> <time datetime="2022-02-18T09:00:00-06:00">February 18, 2022</time> </span> <span></span> <span> <i aria-hidden="true"></i> 37 minute read </span> </p> </header> <section itemprop="text">   <p>In this post, we’ll implement and optimize a text search system based on <a href="https://www.postgresql.org/docs/14/pgtrgm.html">Postgres Trigrams</a>.</p> <p>We’ll start with some fundamental concepts, then define a test environment based on a dataset of 8.9 million Amazon reviews, then cover three possible optimizations.</p> <p>Our search will start very slow, about 360 seconds. With some thoughtful optimization we’ll end up at just over 100 milliseconds – a ~3600x speedup! These optimizations won’t apply perfectly to every text search use-case, but they should at the very least spark some ideas.</p> <h2 id="defining-text-search">Defining “text search”</h2> <p>For our purposes, “text search” is defined as follows:</p> <ol> <li>We have a database table with multiple text columns.</li> <li>A user provides one input: a query string (think Google or Amazon search box).</li> <li>We search for ten rows in our table for which at least one of the columns matches the query string. A match can be either exact or fuzzy. For example, the query string “foobar” is an exact match for the value “foobarbaz” and a fuzzy match for the value “foo bar”.</li> <li>Once we’ve found ten such rows, we score them, re-rank them by their scores, and return them to the user.</li> </ol> <h2 id="why-postgres">Why Postgres?</h2> <p>Postgres is a ubiquitous relational database, but dedicated search systems like Solr, Elasticsearch, and Opensearch are far better-known for text search.</p> <p>Still, Postgres offers some competent text search functionality, with several benefits over a dedicated search system:</p> <ol> <li>We avoid operating additional infrastructure (e.g., an Elasticsearch cluster).</li> <li>We avoid syncing data between systems (e.g., Postgres to Elasticsearch).</li> <li>We avoid re-implementing non-trivial features (e.g., multi-tenant authorization).</li> </ol> <p>Having implemented and operated search functionality on both Postgres and Elasticsearch, my current heuristics for choosing between them are:</p> <ul> <li>If search is our core offering, or we can’t afford to fit our searchable text in Postgres’ shared memory buffer, use Elasticsearch and earmark one engineer for operations and tuning.</li> <li>Otherwise, Postgres is probably good enough. At the very least, we’ll end up with a competent baseline for further improvement.</li> </ul> <p>As a case-study, Gitlab has publicly documented their journey in growing from Postgres trigram-based search to advanced search in Elasticsearch.<sup id="fnref:gitlab-elasticsearch" role="doc-noteref"><a href="#fn:gitlab-elasticsearch" rel="footnote">1</a></sup></p> <h2 id="what-are-trigrams">What are Trigrams?</h2> <p>A trigram is simply a three-character sequence from a string.</p> <p>For example, the trigrams in <code>&#34;hello&#34;</code> are <code>{&#34; h,&#34; he&#34;,&#34;hel&#34;,&#34;ell&#34;,&#34;llo&#34;,&#34;lo &#34;}</code>.</p> <p>Trigrams present a simple solution for string comparison: to compare two strings, we can count the number of trigrams they share.</p> <p>For example, “hello” and “helo” share 4 trigrams. “hello” and “bye” share 0. This isn’t fool-proof: “hello” shares more trigrams with “jello” than with “hi”. But it’s usually a strong baseline.</p> <h3 id="why-not-full-text-search">Why not Full Text Search?</h3> <p>Postgres also offers <a href="https://www.postgresql.org/docs/14/textsearch.html">Full Text Search</a>. I’m personally more familiar with trigram-based search, which is part of the reason we’ll use trigrams in this post.</p> <p>From some experimenting with Full Text Search, I’ve found the API focuses more narrowly on natural language text (i.e., words, spaces, punctuation), than on general-purpose text (i.e., natural language text <em>and</em> product SKUs <em>and</em> email addresses, …).<sup id="fnref:gitlab-full-text-search" role="doc-noteref"><a href="#fn:gitlab-full-text-search" rel="footnote">2</a></sup></p> <p>Still, some optimizations in this post might translate nicely to Full Text Search.</p>  <p>The full test environment is available <a href="https://github.com/alexklibisz/site-projects/tree/main/optimizing-postgres-text-search-with-trigrams">on Github</a>. Let’s have a look at some specific components.</p> <h2 id="host">Host</h2> <p>Everything is running on my Dell XPS-9570 Laptop with an Intel i7-8750H, 32GB of memory, an SSD, and Ubuntu 20.04. Exact timing will vary by the host environment, but the relative performance should be host-agnostic.</p> <h2 id="postgres">Postgres</h2> <p>We’ll use Postgres version 14.1.0, running the <a href="https://hub.docker.com/r/bitnami/postgresql/tags"><code>bitnami/postgresql:14.1.0</code></a> container. All examples should work on Postgres &gt;= 12.</p> <p>We’ll set two <a href="https://www.postgresql.org/docs/14/runtime-config.html">server configurations</a>:</p> <div><div><pre><code><span># Provide 4GB of memory for buffers.
# This lets us keep the full table and indexes in memory.
</span><span>shared_buffers</span> = <span>4096</span><span>MB</span>

<span># Set to true so that `explain (... buffers ...) will include IO timings.
</span><span>track_io_timing</span> = <span>true</span>
</code></pre></div></div> <p>We’ll also set two <a href="https://www.postgresql.org/docs/14/runtime-config-query.html">query planning configurations</a>:</p> <div><div><pre><code><span>-- This disables parallel gathers, as I&#39;ve found they produce highly</span>
<span>-- variable results depending on the host system.</span>
<span>set</span> <span>max_parallel_workers_per_gather</span> <span>=</span> <span>0</span><span>;</span>

<span>-- This makes it more likely that the query planner chooses an index scan</span>
<span>-- instead of another strategy. I&#39;ve found this will generally improve</span>
<span>-- performance on any system with an SSD.</span>
<span>set</span> <span>random_page_cost</span> <span>=</span> <span>0</span><span>.</span><span>9</span><span>;</span>
</code></pre></div></div> <h2 id="amazon-review-dataset">Amazon Review Dataset</h2> <p>We’ll use data from the <a href="http://jmcauley.ucsd.edu/data/amazon/links.html">Amazon Review Dataset</a> to demonstrate our optimizations.<sup id="fnref:jmacauley-citation" role="doc-noteref"><a href="#fn:jmacauley-citation" rel="footnote">3</a></sup></p> <p>Specifically, we’ll use text properties from the 5-core Book Reviews Subset, a dataset of 8.9 million reviews for books sold on Amazon. An example review shows the shape of our dataset:</p> <div><div><pre><code><span>{</span><span>
  </span><span>&#34;reviewerID&#34;</span><span>:</span><span> </span><span>&#34;A2SUAM1J3GNN3B&#34;</span><span>,</span><span>
  </span><span>&#34;asin&#34;</span><span>:</span><span> </span><span>&#34;0000013714&#34;</span><span>,</span><span>
  </span><span>&#34;reviewerName&#34;</span><span>:</span><span> </span><span>&#34;J. McDonald&#34;</span><span>,</span><span>
  </span><span>&#34;helpful&#34;</span><span>:</span><span> </span><span>[</span><span>2</span><span>,</span><span> </span><span>3</span><span>],</span><span>
  </span><span>&#34;reviewText&#34;</span><span>:</span><span> </span><span>&#34;I bought this for my husband who plays the piano. ...&#34;</span><span>,</span><span>
  </span><span>&#34;overall&#34;</span><span>:</span><span> </span><span>5.0</span><span>,</span><span>
  </span><span>&#34;summary&#34;</span><span>:</span><span> </span><span>&#34;Heavenly Highway Hymns&#34;</span><span>,</span><span>
  </span><span>&#34;unixReviewTime&#34;</span><span>:</span><span> </span><span>1252800000</span><span>,</span><span>
  </span><span>&#34;reviewTime&#34;</span><span>:</span><span> </span><span>&#34;09 13, 2009&#34;</span><span>
</span><span>}</span><span>
</span></code></pre></div></div> <p>Each of these reviews includes five text properties: <code>reviewerID, asin, reviewerName, reviewText, summary</code>. <code>reviewerID</code> and <code>asin</code> are machine-generated identifiers. <code>reviewerName, reviewText, summary</code> are free-form human-generated text.</p> <p>For simplicity, we’ll ignore <code>reviewText</code> and make a table with the remaining text properties:</p> <div><div><pre><code><span>create</span> <span>table</span> <span>reviews</span> <span>(</span>
  <span>review_id</span> <span>bigserial</span> <span>primary</span> <span>key</span><span>,</span>
  <span>reviewer_id</span> <span>varchar</span><span>(</span><span>50</span><span>),</span>
  <span>reviewer_name</span> <span>varchar</span><span>(</span><span>100</span><span>),</span>
  <span>asin</span> <span>varchar</span><span>(</span><span>50</span><span>),</span>
  <span>summary</span> <span>varchar</span><span>(</span><span>1000</span><span>)</span>
<span>);</span>
</code></pre></div></div> <p>I wouldn’t recommend this schema in a real application. For example, the reviewer name should be factored out to a <code>reviewer</code> table. But it’s good enough for a demo.</p> <p>It takes about 8 minutes to populate the table and the table size ends up at 926MB.</p> <h2 id="example-query-strings">Example Query Strings</h2> <p>We’ll use one of my favorite authors, Michael Lewis, as a test subject.<sup id="fnref:michael-lewis" role="doc-noteref"><a href="#fn:michael-lewis" rel="footnote">4</a></sup></p> <p>Specifically, we’ll search for two variations of his name:</p> <ol> <li>“Michael Lewis” – the correct spelling – to find exact matches</li> <li>“Michael L<u><i>ou</i></u>is” – a plausible misspeling – to find fuzzy matches</li> </ol> <p>To avoid confusion, let’s refer to these as the <em>exact name</em> and the <em>fuzzy name</em>.</p> <h2 id="explain-analyze-buffers">Explain (Analyze, Buffers)</h2> <p>We’ll use Postgres’ <a href="https://www.postgresql.org/docs/14/sql-explain.html"><code>explain (analyze, buffers)</code> command</a> to evaluate performance. This command takes a query, executes it, and returns the query plan and execution details.</p> <p>This is not a fool-proof solution. A better benchmarking harness would include realistic application request patterns, authentication, authorization, logging, serialization, etc. However, building such a harness would be pointlessly cumbersome, as it would need to be re-implemented for any other non-trivial application.</p> <p>The main thing we’re looking at is how the query plan, execution time, and I/O statistics<sup id="fnref:buffers" role="doc-noteref"><a href="#fn:buffers" rel="footnote">5</a></sup> react to optimizations. This is enough to conclude one approach is better than another.</p> <p>To make this a bit more aesthetically appealing, I cobbled together an embedded version of the excellent <a href="https://github.com/dalibo/pev2">PEV2 (Postgres Explain Visualizer 2) project</a>.<sup id="fnref:pev2" role="doc-noteref"><a href="#fn:pev2" rel="footnote">6</a></sup></p> <p>Let’s look at an example. I ran this query:</p> <div><div><pre><code><span>explain</span> <span>(</span><span>analyze</span><span>,</span> <span>buffers</span><span>)</span>
<span>select</span> <span>count</span><span>(</span><span>review_id</span><span>)</span> <span>from</span> <span>reviews</span><span>;</span>
</code></pre></div></div> <p>Which produced this output:</p> <div><div><pre><code>Aggregate  (cost=177675.25..177675.26 rows=1 width=8) (actual time=3282.696..3282.697 rows=1 loops=1)
  Buffers: shared hit=10 read=24314
  I/O Timings: read=121.636
  -&gt;  Index Only Scan using reviews_pkey on reviews  (cost=0.43..155430.15 rows=8898041 width=8) (actual time=1.341..1679.504 rows=8898041 loops=1)
    Heap Fetches: 0
    Buffers: shared hit=10 read=24314
    I/O Timings: read=121.636
Planning Time: 0.138 ms
Execution Time: 3282.768 ms
</code></pre></div></div> <p>The PEV2 viewer shows the query plan visualization, raw query plan, query, and some stats.</p> <div data-app-component="pev2"> <pre>select count(review_id) from reviews;
  </pre> <pre>Aggregate  (cost=177675.25..177675.26 rows=1 width=8) (actual time=3282.696..3282.697 rows=1 loops=1)
  Buffers: shared hit=10 read=24314
  I/O Timings: read=121.636
  -&gt;  Index Only Scan using reviews_pkey on reviews  (cost=0.43..155430.15 rows=8898041 width=8) (actual time=1.341..1679.504 rows=8898041 loops=1)
    Heap Fetches: 0
    Buffers: shared hit=10 read=24314
    I/O Timings: read=121.636
Planning Time: 0.138 ms
Execution Time: 3282.768 ms
  </pre> </div> <p>Clicking around a bit in the plan reveals three important results:</p> <ol> <li>Total planning and execution time: we spent 0.138ms planning and about 3.2s executing.</li> <li>Timing and types of execution: we spent 1.6s in an <code>Aggregate</code> and 1.6s in an <code>Index Only Scan</code>. The <code>Index Only Scan</code> tells us we were able to make use of an index in this query.</li> <li>Timing, amount, and types of I/O: if we expand the <code>Index Only Scan</code> and open the <code>IO and Buffers</code> tab, we see we spent 122ms on I/O, hit 10 blocks, and read 24,314 blocks. A hit means the block was in the shared buffer cache. A read means we went to the filesystem cache or SSD.</li> </ol>  <p>With our test environment explained, let’s build a relatively simple baseline query pattern based on the trigram <code>similarity</code> function and its corresponding operators: <code>%</code> and <code>&lt;-&gt;</code>.</p> <h2 id="trigram-operators">Trigram Operators</h2> <p>Those already familiar with trigram <code>similarity</code>, <code>%</code>, and <code>&lt;-&gt;</code> can safely skip this section.</p> <p>First, we need the function <code>similarity(text1, text2)</code>. This function breaks both texts into a set of trigrams, computes the intersection of sets, computes the union of sets, and divides the intersection size by the union size to produce a score between 0 and 1. In other words, this is the <a href="https://en.wikipedia.org/wiki/Jaccard_index">Jaccard Index</a> of the sets of trigrams.</p> <p>The query below give us some intuition about <code>similarity(&#39;abc&#39;, &#39;abb&#39;)</code>, <code>&#39;abc&#39; % &#39;abb&#39;</code> and <code>&#39;abc&#39; &lt;-&gt; &#39;abb&#39;</code>:</p> <div><div><pre><code><span>with</span> <span>input</span> <span>as</span> <span>(</span><span>select</span> <span>&#39;abc&#39;</span> <span>as</span> <span>text1</span><span>,</span> <span>&#39;abb&#39;</span> <span>as</span> <span>text2</span><span>)</span>
<span>select</span>
  <span>show_trgm</span><span>(</span><span>text1</span><span>)</span> <span>as</span> <span>&#34;text1 trigrams&#34;</span><span>,</span>
  <span>show_trgm</span><span>(</span><span>text2</span><span>)</span> <span>as</span> <span>&#34;text2 trigrams&#34;</span><span>,</span>
  <span>array</span><span>(</span><span>select</span> <span>t1</span><span>.</span><span>t1</span> 
        <span>from</span> <span>unnest</span><span>(</span><span>show_trgm</span><span>(</span><span>text1</span><span>))</span> <span>t1</span><span>,</span> 
             <span>unnest</span><span>(</span><span>show_trgm</span><span>(</span><span>text2</span><span>))</span> <span>t2</span> <span>where</span> <span>t1</span><span>.</span><span>t1</span> <span>=</span> <span>t2</span><span>.</span><span>t2</span><span>)</span> <span>as</span> <span>&#34;intersection&#34;</span><span>,</span>
  <span>array</span><span>(</span><span>select</span> <span>t1</span><span>.</span><span>t1</span> <span>from</span> <span>unnest</span><span>(</span><span>show_trgm</span><span>(</span><span>text1</span><span>))</span> <span>t1</span> 
        <span>union</span> 
        <span>select</span> <span>t2</span><span>.</span><span>t2</span> <span>from</span> <span>unnest</span><span>(</span><span>show_trgm</span><span>(</span><span>text2</span><span>))</span> <span>t2</span><span>)</span> <span>as</span> <span>&#34;union&#34;</span><span>,</span>
  <span>round</span><span>(</span><span>similarity</span><span>(</span><span>text1</span><span>,</span> <span>text2</span><span>)::</span><span>numeric</span><span>,</span> <span>3</span><span>)</span> <span>as</span> <span>&#34;similarity&#34;</span><span>,</span>
  <span>text1</span> <span>%</span> <span>text2</span> <span>as</span> <span>&#34;text1 % text2&#34;</span><span>,</span>
  <span>text1</span> <span>&lt;-&gt;</span> <span>text2</span> <span>as</span> <span>&#34;text1 &lt;-&gt; text2&#34;</span>
<span>from</span> <span>input</span><span>;</span>
</code></pre></div></div> <p>This produces:</p> <table> <thead> <tr> <th>text1 trigrams</th> <th>text2 trigrams</th> <th>intersection</th> <th>union</th> <th>similarity</th> <th>text1 % text2</th> <th>text1 &lt;-&gt; text2</th> </tr> </thead> <tbody> <tr> <td>{ a, ab,abc,bc }</td> <td>{ a, ab,abb,bb }</td> <td>{ a, ab}</td> <td>{bb ,abb, a, ab,bc ,abc}</td> <td>0.333</td> <td>true</td> <td>0.666</td> </tr> </tbody> </table> <p>For “abc” and “abb”, the intersection size is 2 and union size is 6, so 2/6 is a similarity of 1/3.</p> <p>The operator <code>text1 % text2</code> returns true if <code>similarity(text1, text2)</code> exceeds a pre-defined threshold setting, <code>pg_trgm.similarity_threshold</code>. The default threshold is 0.3, so <code>select &#39;abc&#39; % &#39;abc&#39;</code> returns <code>true</code>.</p> <p>The operator <code>text1 &lt;-&gt; text2</code> returns the distance between text1 and text2, which is just <code>1 - similarity(text1, text2)</code>, so <code>select &#39;abc&#39; &lt;-&gt; &#39;abb&#39;</code> returns 2/3.</p> <p>Why do we need these operators if they just alias the <code>similarity</code> function? At the risk of spoiling one of the optimizations, operators can leverage an index, and functions cannot.</p> <h2 id="trigram-search-query">Trigram Search Query</h2> <p>Let’s use these operators to search for reviews where <code>summary</code> matches the exact name.</p> <p>(We should compare the query string against all text columns, but we start with just <code>summary</code> for simplicity.)</p> <p>The query looks like this:</p> <div><div><pre><code><span>with</span> <span>input</span> <span>as</span> <span>(</span><span>select</span> <span>&#39;Michael Lewis&#39;</span> <span>as</span> <span>q</span><span>)</span> <span>-- (1)</span>
<span>select</span> <span>review_id</span><span>,</span>
       <span>1</span><span>.</span><span>0</span> <span>-</span> <span>(</span><span>summary</span> <span>&lt;-&gt;</span> <span>input</span><span>.</span><span>q</span><span>)</span> <span>as</span> <span>score</span> <span>-- (4)</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>input</span><span>.</span><span>q</span> <span>%</span> <span>summary</span> <span>-- (2)</span>
<span>order</span> <span>by</span> <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>summary</span> <span>limit</span> <span>10</span><span>;</span> <span>-- (3)</span>
</code></pre></div></div> <p>Let’s break the query into components, numbered in correspondence to the comments above:</p> <ol> <li>This is a Common Table Expression (CTE). It gives us a way to reference the query string as a variable, <code>input.q</code>.</li> <li>We use <code>input.q % summary</code> to filter the table down to a set of candidate rows. For each of these rows, <code>input.q</code> and <code>summary</code> have a trigram similarity greater than or equal to 0.3.</li> <li>Once we’ve found candidate rows, we sort them by the trigram distance between <code>input.q</code> and <code>summary</code> and keep the top 10. We want the rows with highest similarity, which is equivalent to lowest distance. So we sort by the distance operator in ascending order.</li> <li>In order to return the score to the user, we just subtract the trigram distance from 1.0.</li> </ol> <p>Let’s look at the results and performance for the exact name:</p> <table> <thead> <tr> <th>review_id</th> <th>summary</th> <th>score</th> </tr> </thead> <tbody> <tr> <td>589771</td> <td>Michael Lewis Fan</td> <td>0.7777</td> </tr> <tr> <td>2113780</td> <td>Michael Lewis Fan</td> <td>0.7777</td> </tr> <tr> <td>2111282</td> <td>Michael Lewis bland?</td> <td>0.6999</td> </tr> <tr> <td>2114048</td> <td>MIchael Lewis is Good</td> <td>0.6666</td> </tr> <tr> <td>2100962</td> <td>Not Michael Lewis’ Best</td> <td>0.6086</td> </tr> <tr> <td>610753</td> <td>Not Michael Lewis’ Best</td> <td>0.6086</td> </tr> <tr> <td>2111364</td> <td>Boomerang, Michael Lewis</td> <td>0.5833</td> </tr> <tr> <td>2111212</td> <td>Michael Lewis is amazing</td> <td>0.5833</td> </tr> <tr> <td>2111190</td> <td>Michael Lewis on a Roll</td> <td>0.5833</td> </tr> <tr> <td>2108446</td> <td>Go Long on Michael Lewis</td> <td>0.5833</td> </tr> </tbody> </table> <div data-app-component="pev2"> <pre>with input as (select &#39;Michael Lewis&#39; as q)
select review_id,
       1.0 - (summary &lt;-&gt; input.q) as score
from reviews, input
where input.q % summary
order by input.q &lt;-&gt; summary limit 10;
</pre> <pre>Limit  (cost=229772.34..229772.37 rows=10 width=20) (actual time=94817.773..94817.777 rows=10 loops=1)
  Buffers: shared hit=118549
  -&gt;  Sort  (cost=229772.34..229774.39 rows=819 width=20) (actual time=94817.772..94817.773 rows=10 loops=1)
        Sort Key: ((&#39;Michael Lewis&#39;::text &lt;-&gt; (reviews.summary)::text))
        Sort Method: top-N heapsort  Memory: 26kB
        Buffers: shared hit=118549
        -&gt;  Seq Scan on reviews  (cost=0.00..229754.64 rows=819 width=20) (actual time=171.828..94816.588 rows=761 loops=1)
              Filter: (&#39;Michael Lewis&#39;::text % (summary)::text)
              Rows Removed by Filter: 8897280
              Buffers: shared hit=118549
Planning Time: 1.669 ms
Execution Time: 94817.814 ms
</pre> </div> <p>And again for the fuzzy name:</p> <table> <thead> <tr> <th>review_id</th> <th>summary</th> <th>score</th> </tr> </thead> <tbody> <tr> <td>4341036</td> <td>Lo Michael</td> <td>0.6666</td> </tr> <tr> <td>4341045</td> <td>Lo, Michael</td> <td>0.6666</td> </tr> <tr> <td>4341030</td> <td>Lo Michael!</td> <td>0.6666</td> </tr> <tr> <td>4341034</td> <td>Lo,Michael</td> <td>0.6666</td> </tr> <tr> <td>4341027</td> <td>Lo, Michael!</td> <td>0.6666</td> </tr> <tr> <td>4341043</td> <td>Lo,Michael</td> <td>0.6666</td> </tr> <tr> <td>4341025</td> <td>Lo, Michael!</td> <td>0.6666</td> </tr> <tr> <td>4341026</td> <td>Lo. Michael !</td> <td>0.6666</td> </tr> <tr> <td>4341029</td> <td>Lo, Michael!</td> <td>0.6666</td> </tr> <tr> <td>4341050</td> <td>Lo michael</td> <td>0.6666</td> </tr> </tbody> </table> <div data-app-component="pev2"> <pre>with input as (select &#39;Michael Louis&#39; as q)
select review_id,
       1.0 - (summary &lt;-&gt; input.q) as score
from reviews, input
where input.q % summary
order by input.q &lt;-&gt; summary limit 10;
</pre> <pre>Limit  (cost=229792.85..229792.87 rows=10 width=20) (actual time=94591.716..94591.720 rows=10 loops=1)
  Buffers: shared hit=118549
  -&gt;  Sort  (cost=229792.85..229794.90 rows=821 width=20) (actual time=94591.715..94591.716 rows=10 loops=1)
        Sort Key: ((&#39;Michael Louis&#39;::text &lt;-&gt; (reviews.summary)::text))
        Sort Method: top-N heapsort  Memory: 26kB
        Buffers: shared hit=118549
        -&gt;  Seq Scan on reviews  (cost=0.00..229775.11 rows=821 width=20) (actual time=176.054..94590.575 rows=729 loops=1)
              Filter: (&#39;Michael Louis&#39;::text % (summary)::text)
              Rows Removed by Filter: 8897312
              Buffers: shared hit=118549
Planning Time: 1.761 ms
Execution Time: 94591.758 ms
</pre> </div> <p>Qualitatively speaking, the results are reasonable. There are some exact matches for the exact name, and a few summaries containing “Lo” and “Michael” that match the fuzzy name.</p> <p>👎 <strong>But the performance is terrible: <em>over 94 seconds to find ten results!</em></strong></p> <p>If we extrapolate this to all four text columns, we can estimate a runtime of over 360 seconds.</p> <p>How are we spending this time? The query plans suggest the following:</p> <ol> <li>About 94s in <code>Seq Scan on reviews</code>. This is a sequential scan on the reviews table, which means Postgres iterates over all rows and keeps those that satisfy <code>input.q % summary</code>. This returns 761 and 729 matches for the exact and fuzzy names, respectively. The <code>IO &amp; Buffers</code> tabs indicate this also involved reading 926MB of data (i.e., the whole table) from the in-memory cache. It’s better than going to SSD, but it’s still non-negligible.</li> <li>About 1ms in <code>Sort</code>, which sorts the matches by <code>input.q &lt;-&gt; summary</code>.</li> <li>Less than 1ms in <code>Limit</code>, which takes the first ten of the sorted rows.</li> </ol> <h2 id="baseline-summary">Baseline Summary</h2> <p>Here’s what we know about our trigram search query so far:</p> <ol> <li>Qualitatively, it’s not Google, but the results are reasonable.</li> <li>The query is unusably slow (over 94s).</li> <li>It spends virtually all its time scanning the reviews table.</li> </ol>  <p>Let’s get into some optimizations to see if we can improve on the baseline.</p> <h2 id="indexing">Indexing</h2> <p>The first optimization should be unsurprising: we’ll create an index for the text field.</p> <p>Trigrams support both GIN and GiST index types. The main difference is that GiST supports filtering and sorting, whereas GIN only supports filtering. Since our search query involves sorting by trigram distance, we’ll use GiST.</p> <p>At a high level, the GiST index works by building a lookup table from each trigram to the list or rows containing the trigram. At query time, Postgres takes the trigrams from the query string and asks the index, “which rows contain these trigrams?” The trigrams are stored as a signature (i.e., a hash), and sometimes the signatures can collide.</p> <p>Since Postgres 12, the GiST index type includes a parameter called <code>siglen</code>, which lets us control the precision of the signature. Here’s how the docs describe it:</p> <blockquote> <p>gist_trgm_ops GiST opclass approximates a set of trigrams as a bitmap signature. Its optional integer parameter siglen determines the signature length in bytes. The default length is 12 bytes. Valid values of signature length are between 1 and 2024 bytes. Longer signatures lead to a more precise search (scanning a smaller fraction of the index and fewer heap pages), at the cost of a larger index.</p> </blockquote> <p>In short, higher siglen should translate to more precise search (i.e., fewer signature collisions), at the cost of a larger index.</p> <p>We’ll start with a GiST index with siglen=64, check performance, then repeat with siglen=256.</p> <h3 id="gist-with-siglen64">GiST with siglen=64</h3> <div><div><pre><code><span>create</span> <span>index</span> <span>reviews_summary_trgm_gist_idx</span> <span>on</span> <span>reviews</span> 
  <span>using</span> <span>gist</span><span>(</span><span>summary</span> <span>gist_trgm_ops</span><span>(</span><span>siglen</span><span>=</span><span>64</span><span>));</span>
<span>vacuum</span> <span>analyze</span> <span>reviews</span><span>;</span>
</code></pre></div></div> <p>This takes about 10 minutes to build and ends up using about 1000MB of storage.</p> <p>Does it make a difference for performance?</p> <p>For the exact name, we find:</p> <div data-app-component="pev2"> <pre>with input as (select &#39;Michael Lewis&#39; as q)
select review_id,
       1.0 - (summary &lt;-&gt; input.q) as score
from reviews, input
where input.q % summary
order by input.q &lt;-&gt; summary limit 10;
</pre> <pre>Limit  (cost=0.42..9.81 rows=10 width=20) (actual time=4181.401..4216.478 rows=10 loops=1)
  Buffers: shared hit=135684
  -&gt;  Index Scan using reviews_summary_trgm_gist_idx on reviews  (cost=0.42..771.80 rows=821 width=20) (actual time=4181.400..4216.474 rows=10 loops=1)
        Index Cond: ((summary)::text % &#39;Michael Lewis&#39;::text)
        Order By: ((summary)::text &lt;-&gt; &#39;Michael Lewis&#39;::text)
        Buffers: shared hit=135684
Planning Time: 1.933 ms
Execution Time: 4216.519 ms
</pre> </div> <p>And for the fuzzy name:</p> <div data-app-component="pev2"> <pre>with input as (select &#39;Michael Louis&#39; as q)
select review_id,
       1.0 - (summary &lt;-&gt; input.q) as score
from reviews, input
where input.q % summary
order by input.q &lt;-&gt; summary limit 10;
</pre> <pre>Limit  (cost=0.42..9.81 rows=10 width=20) (actual time=4330.713..4330.850 rows=10 loops=1)
  Buffers: shared hit=135447
  -&gt;  Index Scan using reviews_summary_trgm_gist_idx on reviews  (cost=0.42..771.80 rows=821 width=20) (actual time=4330.711..4330.845 rows=10 loops=1)
        Index Cond: ((summary)::text % &#39;Michael Louis&#39;::text)
        Order By: ((summary)::text &lt;-&gt; &#39;Michael Louis&#39;::text)
        Buffers: shared hit=135447
Planning Time: 1.829 ms
Execution Time: 4330.889 ms
</pre> </div>  <p>👍 <strong>This is a significant improvement: from over 94 seconds to under 4.5 seconds!</strong></p> <p>If we extrapolate this to all four text columns, we can estimate a runtime of under 20 seconds.</p> <p>The query plans tell us how we’re making better use of time:</p> <ol> <li>About 4.3s in an <code>Index Scan</code> on the new <code>reviews_summary_trgm_gist_idx</code> index. The <code>Misc</code> tab indicates Postgres uses the index for filtering (<code>Index Cond</code>) and sorting (<code>Order By</code>). The <code>IO &amp; Buffers</code> tab indicates we’re accessing 1.03GB of data from the cache. We don’t know precisely, but this data is some combination of the index and the rows.</li> <li>Less than 40ms in <code>Limit</code>. As far as I can tell, this is a trivial pass-through, as the index scan has already returned exactly ten rows.</li> </ol> <h3 id="gist-with-siglen256">GiST with siglen=256</h3> <p>Let’s try again with siglen=256:</p> <div><div><pre><code><span>drop</span> <span>index</span> <span>reviews_summary_trgm_gist_idx</span><span>;</span>
<span>create</span> <span>index</span> <span>reviews_summary_trgm_gist_idx</span> <span>on</span> <span>reviews</span>
  <span>using</span> <span>gist</span><span>(</span><span>summary</span> <span>gist_trgm_ops</span><span>(</span><span>siglen</span><span>=</span><span>256</span><span>));</span>
<span>vacuum</span> <span>analyze</span> <span>reviews</span><span>;</span>
</code></pre></div></div> <p>This takes about 15 minutes to build and uses 1036MB of storage.</p> <p>For the exact name, we find:</p> <div data-app-component="pev2"> <pre>with input as (select &#39;Michael Lewis&#39; as q)
select review_id,
       1.0 - (summary &lt;-&gt; input.q) as score
from reviews, input
where input.q % summary
order by input.q &lt;-&gt; summary limit 10;
</pre> <pre>Limit  (cost=0.42..9.81 rows=10 width=20) (actual time=503.082..1996.835 rows=10 loops=1)
  Buffers: shared hit=62167
  -&gt;  Index Scan using reviews_summary_trgm_gist_idx on reviews  (cost=0.42..771.80 rows=821 width=20) (actual time=503.079..1996.828 rows=10 loops=1)
        Index Cond: ((summary)::text % &#39;Michael Lewis&#39;::text)
        Order By: ((summary)::text &lt;-&gt; &#39;Michael Lewis&#39;::text)
        Buffers: shared hit=62167
Planning Time: 5.283 ms
Execution Time: 1997.397 ms
</pre> </div> <p>And for the fuzzy name:</p> <div data-app-component="pev2"> <pre>with input as (select &#39;Michael Louis&#39; as q)
select review_id,
       1.0 - (summary &lt;-&gt; input.q) as score
from reviews, input
where input.q % summary
order by input.q &lt;-&gt; summary limit 10;
</pre> <pre>Limit  (cost=0.42..9.81 rows=10 width=20) (actual time=707.952..708.081 rows=10 loops=1)
  Buffers: shared hit=22639
  -&gt;  Index Scan using reviews_summary_trgm_gist_idx on reviews  (cost=0.42..771.80 rows=821 width=20) (actual time=707.951..708.078 rows=10 loops=1)
        Index Cond: ((summary)::text % &#39;Michael Louis&#39;::text)
        Order By: ((summary)::text &lt;-&gt; &#39;Michael Louis&#39;::text)
        Buffers: shared hit=22639
Planning Time: 1.654 ms
Execution Time: 708.577 ms
</pre> </div>  <p>👍 <strong>Another improvement: from 4.5 seconds to under 2 seconds!</strong></p> <p>If we extrapolate this to all four text columns, we can estimate a runtime of about 8 seconds.</p> <h3 id="why-does-siglen-matter">Why does Siglen Matter?</h3> <p>Inspection of these results leads to two questions:</p> <ol> <li>Why is siglen=256 over 2x faster than siglen=64?</li> <li>For siglen=256, why is the exact name over 2x faster than the fuzzy name?</li> </ol> <p>We can begin to answer these by looking at the <code>IO &amp; Buffers</code> tabs, which tell us how much data was accessed. The numbers work out like this:</p> <table> <thead> <tr> <th>Siglen</th> <th>Query String</th> <th>Data Accessed</th> <th>Access Type</th> </tr> </thead> <tbody> <tr> <td>64</td> <td>exact name</td> <td>1.04GB</td> <td>hit (from in-memory cache)</td> </tr> <tr> <td>64</td> <td>fuzzy name</td> <td>1.03GB</td> <td>hit (from in-memory cache)</td> </tr> <tr> <td>256</td> <td>exact name</td> <td>486MB</td> <td>hit (from in-memory cache)</td> </tr> <tr> <td>256</td> <td>fuzzy name</td> <td>177MB</td> <td>hit (from in-memory cache)</td> </tr> </tbody> </table> <p>Even though this data is in memory, decreasing the amount accessed makes a difference.</p> <p>I’m still working on an intuitive understanding of why these two specific values of siglen work out to these specific differences, but that’s likely a topic for another post.<sup id="fnref:buffers:1" role="doc-noteref"><a href="#fn:buffers" rel="footnote">5</a></sup></p> <h3 id="indexing-summary">Indexing Summary</h3> <p>Here’s what we know about indexing:</p> <ol> <li>Adding a GiST index yields a significant speedup: 94s → 4.5s.</li> <li>Increasing the siglen parameter from 64 to 256 yields another speedup: 4.5s → 2s.</li> <li>The siglen parameter affects the number of buffers read to execute the index scan: greater siglen → fewer buffers → faster query.</li> </ol> <h2 id="separate-exact-and-trigram-search-queries">Separate Exact and Trigram Search Queries</h2> <p>Recall that we’re interested in both exact and fuzzy matches. So far, we’ve used a single trigram search query to satisfy both match types. Trigrams are useful for fuzzy matches, but are they really necessary for exact matches?</p> <p>Let’s take a step back, compose an exact-only search query, and see what we can do with it.</p> <h3 id="the-ilike-operator">The <code>ilike</code> operator</h3> <p>The boolean operator <code>text1 ilike &#39;%&#39; || text2 || &#39;%&#39;</code> will return true if <code>text1</code> contains <code>text2</code>, ignoring capitalization.</p> <p>Here are some examples:</p> <div><div><pre><code><span>select</span>
   <span>&#39;abc&#39;</span> <span>ilike</span> <span>&#39;%&#39;</span> <span>||</span> <span>&#39;ab&#39;</span> <span>||</span> <span>&#39;%&#39;</span> <span>as</span> <span>&#34;abc contains ab&#34;</span><span>,</span>
   <span>&#39;abc&#39;</span> <span>ilike</span> <span>&#39;%&#39;</span> <span>||</span> <span>&#39;AB&#39;</span> <span>||</span> <span>&#39;%&#39;</span> <span>as</span> <span>&#34;abc contains AB&#34;</span><span>,</span>
   <span>&#39;abc&#39;</span> <span>ilike</span> <span>&#39;%&#39;</span> <span>||</span> <span>&#39;abc&#39;</span> <span>||</span> <span>&#39;%&#39;</span> <span>as</span> <span>&#34;abc contains abc&#34;</span><span>,</span>
   <span>&#39;abc&#39;</span> <span>ilike</span> <span>&#39;%&#39;</span> <span>||</span> <span>&#39;abb&#39;</span> <span>||</span> <span>&#39;%&#39;</span> <span>as</span> <span>&#34;abc contains abb&#34;</span>
</code></pre></div></div> <p>This produces:</p> <table> <thead> <tr> <th>abc contains ab</th> <th>abc contains AB</th> <th>abc contains abc</th> <th>abc contains abb</th> </tr> </thead> <tbody> <tr> <td>true</td> <td>true</td> <td>true</td> <td>false</td> </tr> </tbody> </table> <h3 id="exact-only-search-query">Exact-Only Search Query</h3> <p>We can use the <code>ilike</code> operator compose an exact-only search query:</p> <div><div><pre><code><span>with</span> <span>input</span> <span>as</span> <span>(</span><span>select</span> <span>&#39;Michael Lewis&#39;</span> <span>as</span> <span>q</span><span>)</span>
<span>select</span> <span>review_id</span><span>,</span>
       <span>1</span><span>.</span><span>0</span> <span>as</span> <span>score</span> <span>-- (2)</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>summary</span> <span>ilike</span> <span>&#39;%&#39;</span> <span>||</span> <span>input</span><span>.</span><span>q</span> <span>||</span> <span>&#39;%&#39;</span> <span>-- (1)</span>
<span>limit</span> <span>10</span><span>;</span> <span>-- (3)</span>
</code></pre></div></div> <ol> <li>We use the <code>ilike</code> operator to filter for rows where <code>summary</code> contains the query string.</li> <li>Since each <code>summary</code> contains the query string, we simply assign a score of 1.0.</li> <li>We just want ten of them. They all have the same score, so no need to sort.</li> </ol> <p>How does it perform on our query strings?</p> <p>For the exact name, we find:</p> <div data-app-component="pev2"> <pre>with input as (select &#39;Michael Lewis&#39; as q)
select review_id,
       1.0 as score
from reviews, input
where summary ilike &#39;%&#39; || input.q || &#39;%&#39;
limit 10;
</pre> <pre>Limit  (cost=0.42..9.71 rows=10 width=40) (actual time=2.955..6.431 rows=10 loops=1)
  Buffers: shared hit=865
  -&gt;  Index Scan using reviews_summary_trgm_gist_idx on reviews  (cost=0.42..763.59 rows=821 width=40) (actual time=2.952..6.425 rows=10 loops=1)
        Index Cond: ((summary)::text ~~* &#39;%Michael Lewis%&#39;::text)
        Buffers: shared hit=865
Planning Time: 0.413 ms
Execution Time: 6.456 ms
</pre> </div> <p>And for the fuzzy name:</p> <div data-app-component="pev2"> <pre>with input as (select &#39;Michael Louis&#39; as q)
select review_id,
       1.0 as score
from reviews, input
where summary ilike &#39;%&#39; || input.q || &#39;%&#39;
limit 10;
</pre> <pre>Limit  (cost=0.42..9.71 rows=10 width=40) (actual time=10.582..10.583 rows=0 loops=1)
  Buffers: shared hit=1429
  -&gt;  Index Scan using reviews_summary_trgm_gist_idx on reviews  (cost=0.42..763.59 rows=821 width=40) (actual time=10.581..10.581 rows=0 loops=1)
    Index Cond: ((summary)::text ~~* &#39;%Michael Louis%&#39;::text)
    Rows Removed by Index Recheck: 1
    Buffers: shared hit=1429
Planning Time: 0.340 ms
Execution Time: 10.007 ms
</pre> </div> <p>👍 <strong>A significant improvement: from 2s to 10ms!</strong></p> <p>If we extrapolate to all four text columns, we’re down to potentially 40ms.</p> <p>This tells us that finding exact matches with an exact-only query is significantly faster than finding them with a trigram search query.</p> <p>The query plan is roughly the same as our trigram search query, basically just an <code>Index Scan on reviews</code>, but the amount of data accessed is significantly lower: under 12MB.</p> <p>Crucially, this presents an opportunity for optimization: given a query string and a desired number of results, we first attempt to very quickly search for exact matches. If we find the desired number of results, we can skip the fuzzy search entirely. If we don’t find all the results, we run the fuzzy query. If we want to get fancy, we can even run the two searches in parallel and cancel the fuzzy search if our exact search is sufficient.</p> <h3 id="separate-queries-summary">Separate Queries Summary</h3> <p>Here’s what we know about separating exact and trigram search queries:</p> <ol> <li>An exact-only query accesses significantly less data than a trigram query: 177MB → 11MB</li> <li>An exact-only query is significantly faster than a trigram query: 2s → 10ms</li> <li>If the exact-only query finds enough results, we can skip the fuzzy query.</li> <li>In the best case, we turn a 2s search into a 10ms search.</li> <li>In the worst case, we turn a 2s search into a 2.01s search.</li> </ol> <h2 id="single-query-for-all-text-columns">Single Query for All Text Columns</h2> <p>So far our search queries have only checked for matches in the <code>summary</code> column, and we’ve been extrapolating the timing.</p> <p>Now is the time to stop extrapolating and compose a query that actually checks all four text columns. Let’s look at three ways we can make this happen.</p> <h3 id="four-single-column-queries">Four Single-Column Queries</h3> <p>The simplest method to check each of the columns is to simply search for every column separately. Then we would deduplicate and re-rank the results in application code.</p> <p>To do this, we start by building indexes on the three remaining columns:</p> <div><div><pre><code><span>create</span> <span>index</span> <span>reviews_reviewer_id_trgm_gist_idx</span> <span>on</span> <span>reviews</span>
  <span>using</span> <span>gist</span><span>(</span><span>reviewer_id</span> <span>gist_trgm_ops</span><span>(</span><span>siglen</span><span>=</span><span>256</span><span>));</span>
<span>create</span> <span>index</span> <span>reviews_reviewer_name_trgm_gist_idx</span> <span>on</span> <span>reviews</span>
  <span>using</span> <span>gist</span><span>(</span><span>reviewer_name</span> <span>gist_trgm_ops</span><span>(</span><span>siglen</span><span>=</span><span>256</span><span>));</span>
<span>create</span> <span>index</span> <span>reviews_asin_trgm_gist_idx</span> <span>on</span> <span>reviews</span>
  <span>using</span> <span>gist</span><span>(</span><span>asin</span> <span>gist_trgm_ops</span><span>(</span><span>siglen</span><span>=</span><span>256</span><span>));</span>
<span>vacuum</span> <span>analyze</span> <span>reviews</span><span>;</span>
</code></pre></div></div> <p>Each of these takes about fifteen minutes to build and uses about 690MB of storage.</p> <p>The trigram search query is just a union of the original trigram search query on each column:</p> <div><div><pre><code><span>with</span> <span>input</span> <span>as</span> <span>(</span><span>select</span> <span>&#39;Michael Lewis&#39;</span> <span>as</span> <span>q</span><span>)</span>
<span>(</span><span>select</span> <span>review_id</span><span>,</span> <span>1</span><span>.</span><span>0</span> <span>-</span> <span>(</span><span>reviewer_id</span> <span>&lt;-&gt;</span> <span>input</span><span>.</span><span>q</span><span>)</span> <span>as</span> <span>score</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>input</span><span>.</span><span>q</span> <span>%</span> <span>reviewer_id</span>
<span>order</span> <span>by</span> <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>reviewer_id</span> <span>limit</span> <span>10</span><span>)</span>
<span>union</span> <span>all</span>
<span>(</span><span>select</span> <span>review_id</span><span>,</span> <span>1</span><span>.</span><span>0</span> <span>-</span> <span>(</span><span>reviewer_name</span> <span>&lt;-&gt;</span> <span>input</span><span>.</span><span>q</span><span>)</span> <span>as</span> <span>score</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>input</span><span>.</span><span>q</span> <span>%</span> <span>reviewer_name</span>
<span>order</span> <span>by</span> <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>reviewer_name</span> <span>limit</span> <span>10</span><span>)</span>
<span>union</span> <span>all</span>
<span>(</span><span>select</span> <span>review_id</span><span>,</span> <span>1</span><span>.</span><span>0</span> <span>-</span> <span>(</span><span>summary</span> <span>&lt;-&gt;</span> <span>input</span><span>.</span><span>q</span><span>)</span> <span>as</span> <span>score</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>input</span><span>.</span><span>q</span> <span>%</span> <span>summary</span>
<span>order</span> <span>by</span> <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>summary</span> <span>limit</span> <span>10</span><span>)</span>
<span>union</span> <span>all</span>
<span>(</span><span>select</span> <span>review_id</span><span>,</span> <span>1</span><span>.</span><span>0</span> <span>-</span> <span>(</span><span>asin</span> <span>&lt;-&gt;</span> <span>input</span><span>.</span><span>q</span><span>)</span> <span>as</span> <span>score</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>input</span><span>.</span><span>q</span> <span>%</span> <span>asin</span>
<span>order</span> <span>by</span> <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>asin</span> <span>limit</span> <span>10</span><span>);</span>
</code></pre></div></div> <p>The exact-only query follows the same pattern:</p> <div><div><pre><code><span>explain</span> <span>(</span><span>analyze</span><span>,</span> <span>buffers</span><span>)</span>
<span>with</span> <span>input</span> <span>as</span> <span>(</span><span>select</span> <span>&#39;Michael Lewis&#39;</span> <span>as</span> <span>q</span><span>)</span>
<span>(</span><span>select</span> <span>review_id</span><span>,</span> <span>1</span><span>.</span><span>0</span> <span>as</span> <span>score</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>reviewer_id</span> <span>ilike</span> <span>&#39;%&#39;</span> <span>||</span> <span>input</span><span>.</span><span>q</span> <span>||</span> <span>&#39;%&#39;</span>
<span>limit</span> <span>10</span><span>)</span>
<span>union</span> <span>all</span>
<span>(</span><span>select</span> <span>review_id</span><span>,</span> <span>1</span><span>.</span><span>0</span> <span>as</span> <span>score</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>reviewer_name</span> <span>ilike</span> <span>&#39;%&#39;</span> <span>||</span> <span>input</span><span>.</span><span>q</span> <span>||</span> <span>&#39;%&#39;</span>
<span>limit</span> <span>10</span><span>)</span>
<span>union</span> <span>all</span>
<span>(</span><span>select</span> <span>review_id</span><span>,</span> <span>1</span><span>.</span><span>0</span> <span>as</span> <span>score</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>summary</span> <span>ilike</span> <span>&#39;%&#39;</span> <span>||</span> <span>input</span><span>.</span><span>q</span> <span>||</span> <span>&#39;%&#39;</span>
<span>limit</span> <span>10</span><span>)</span>
<span>union</span> <span>all</span>
<span>(</span><span>select</span> <span>review_id</span><span>,</span> <span>1</span><span>.</span><span>0</span> <span>as</span> <span>score</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>asin</span> <span>ilike</span> <span>&#39;%&#39;</span> <span>||</span> <span>input</span><span>.</span><span>q</span> <span>||</span> <span>&#39;%&#39;</span>
<span>limit</span> <span>10</span><span>);</span>
</code></pre></div></div> <p>Before analyzing the query execution, let’s review our thinking on how long this <em>should</em> take.</p> <p>Our latest queries looked at the <code>summary</code> column and took about 10ms for exact-only search and 2s for trigram search. We have four text columns, so it’s not crazy to estimate somewhere between 40ms and 8s for four one-column queries.</p> <p>The actual performance works out like this:</p> <table> <thead> <tr> <th>Query</th> <th>Query String</th> <th>Execution Time</th> <th>Buffer Hits</th> </tr> </thead> <tbody> <tr> <td>Trigram</td> <td>exact name</td> <td>10.7s</td> <td>336986</td> </tr> <tr> <td>Trigram</td> <td>fuzzy name</td> <td>11.2s</td> <td>336998</td> </tr> <tr> <td>Exact-Only</td> <td>exact name</td> <td>144ms</td> <td>12684</td> </tr> <tr> <td>Exact-Only</td> <td>fuzzy name</td> <td>94ms</td> <td>9263</td> </tr> </tbody> </table> <p>👎 <strong>The performance is pretty bad: about 11s to find ten matches.</strong></p> <p>All four plans are roughly identical, so let’s look at the trigram query for the exact name:</p> <div data-app-component="pev2"> <pre>with input as (select &#39;Michael Lewis&#39; as q)
(select review_id, 1.0 - (reviewer_id &lt;-&gt; input.q) as score
from reviews, input
where input.q % reviewer_id
order by input.q &lt;-&gt; reviewer_id limit 10)
union all
(select review_id, 1.0 - (reviewer_name &lt;-&gt; input.q) as score
from reviews, input
where input.q % reviewer_name
order by input.q &lt;-&gt; reviewer_name limit 10)
union all
(select review_id, 1.0 - (summary &lt;-&gt; input.q) as score
from reviews, input
where input.q % summary
order by input.q &lt;-&gt; summary limit 10)
union all
(select review_id, 1.0 - (asin &lt;-&gt; input.q) as score
from reviews, input
where input.q % asin
order by input.q &lt;-&gt; asin limit 10);
</pre> <pre>Append  (cost=64064.97..256647.56 rows=40 width=16) (actual time=6764.697..10795.095 rows=20 loops=1)
  Buffers: shared hit=336986
  CTE input
    -&gt;  Result  (cost=0.00..0.01 rows=1 width=32) (actual time=0.001..0.002 rows=1 loops=1)
&#34;  -&gt;  Subquery Scan on &#34;&#34;*SELECT* 1_1&#34;&#34;  (cost=64064.96..64065.09 rows=10 width=16) (actual time=2506.643..2506.645 rows=0 loops=1)&#34;
        Buffers: shared hit=69700
        -&gt;  Limit  (cost=64064.96..64064.99 rows=10 width=20) (actual time=2506.642..2506.643 rows=0 loops=1)
              Buffers: shared hit=69700
              -&gt;  Sort  (cost=64064.96..64287.41 rows=88980 width=20) (actual time=2506.641..2506.642 rows=0 loops=1)
                    Sort Key: ((input.q &lt;-&gt; (reviews.reviewer_id)::text))
                    Sort Method: quicksort  Memory: 25kB
                    Buffers: shared hit=69700
                    -&gt;  Nested Loop  (cost=0.42..62142.14 rows=88980 width=20) (actual time=2506.636..2506.636 rows=0 loops=1)
                          Buffers: shared hit=69700
                          -&gt;  CTE Scan on input  (cost=0.00..0.02 rows=1 width=32) (actual time=0.003..0.005 rows=1 loops=1)
                          -&gt;  Index Scan using reviews_reviewer_id_trgm_gist_idx on reviews  (cost=0.42..60584.97 rows=88980 width=22) (actual time=2506.628..2506.628 rows=0 loops=1)
                                Index Cond: ((reviewer_id)::text % input.q)
                                Buffers: shared hit=69700
&#34;  -&gt;  Subquery Scan on &#34;&#34;*SELECT* 2&#34;&#34;  (cost=64056.86..64056.99 rows=10 width=16) (actual time=4258.051..4258.058 rows=10 loops=1)&#34;
        Buffers: shared hit=133720
        -&gt;  Limit  (cost=64056.86..64056.89 rows=10 width=20) (actual time=4258.048..4258.052 rows=10 loops=1)
              Buffers: shared hit=133720
              -&gt;  Sort  (cost=64056.86..64279.31 rows=88980 width=20) (actual time=4258.047..4258.049 rows=10 loops=1)
                    Sort Key: ((input_1.q &lt;-&gt; (reviews_1.reviewer_name)::text))
                    Sort Method: top-N heapsort  Memory: 26kB
                    Buffers: shared hit=133720
                    -&gt;  Nested Loop  (cost=0.42..62134.04 rows=88980 width=20) (actual time=0.750..4239.400 rows=50214 loops=1)
                          Buffers: shared hit=133720
                          -&gt;  CTE Scan on input input_1  (cost=0.00..0.02 rows=1 width=32) (actual time=0.001..0.002 rows=1 loops=1)
                          -&gt;  Index Scan using reviews_reviewer_name_trgm_gist_idx on reviews reviews_1  (cost=0.42..60576.87 rows=88980 width=24) (actual time=0.722..3483.767 rows=50214 loops=1)
                                Index Cond: ((reviewer_name)::text % input_1.q)
                                Buffers: shared hit=133720
&#34;  -&gt;  Subquery Scan on &#34;&#34;*SELECT* 3&#34;&#34;  (cost=64460.96..64461.09 rows=10 width=16) (actual time=4022.956..4022.963 rows=10 loops=1)&#34;
        Buffers: shared hit=132744
        -&gt;  Limit  (cost=64460.96..64460.99 rows=10 width=20) (actual time=4022.954..4022.957 rows=10 loops=1)
              Buffers: shared hit=132744
              -&gt;  Sort  (cost=64460.96..64683.41 rows=88980 width=20) (actual time=4022.953..4022.954 rows=10 loops=1)
                    Sort Key: ((input_2.q &lt;-&gt; (reviews_2.summary)::text))
                    Sort Method: top-N heapsort  Memory: 26kB
                    Buffers: shared hit=132744
                    -&gt;  Nested Loop  (cost=0.42..62538.14 rows=88980 width=20) (actual time=8.015..4022.513 rows=761 loops=1)
                          Buffers: shared hit=132744
                          -&gt;  CTE Scan on input input_2  (cost=0.00..0.02 rows=1 width=32) (actual time=0.000..0.002 rows=1 loops=1)
                          -&gt;  Index Scan using reviews_summary_trgm_gist_idx on reviews reviews_2  (cost=0.42..60980.97 rows=88980 width=34) (actual time=7.986..4009.293 rows=761 loops=1)
                                Index Cond: ((summary)::text % input_2.q)
                                Buffers: shared hit=132744
&#34;  -&gt;  Subquery Scan on &#34;&#34;*SELECT* 4&#34;&#34;  (cost=64064.06..64064.19 rows=10 width=16) (actual time=7.418..7.419 rows=0 loops=1)&#34;
        Buffers: shared hit=822
        -&gt;  Limit  (cost=64064.06..64064.09 rows=10 width=20) (actual time=7.417..7.418 rows=0 loops=1)
              Buffers: shared hit=822
              -&gt;  Sort  (cost=64064.06..64286.51 rows=88980 width=20) (actual time=7.416..7.417 rows=0 loops=1)
                    Sort Key: ((input_3.q &lt;-&gt; (reviews_3.asin)::text))
                    Sort Method: quicksort  Memory: 25kB
                    Buffers: shared hit=822
                    -&gt;  Nested Loop  (cost=0.42..62141.24 rows=88980 width=20) (actual time=7.410..7.411 rows=0 loops=1)
                          Buffers: shared hit=822
                          -&gt;  CTE Scan on input input_3  (cost=0.00..0.02 rows=1 width=32) (actual time=0.000..0.001 rows=1 loops=1)
                          -&gt;  Index Scan using reviews_asin_trgm_gist_idx on reviews reviews_3  (cost=0.42..60584.07 rows=88980 width=19) (actual time=7.406..7.406 rows=0 loops=1)
                                Index Cond: ((asin)::text % input_3.q)
                                Buffers: shared hit=822
Planning Time: 0.433 ms
Execution Time: 10795.196 ms
</pre> </div> <p>Here’s how we spend this time:</p> <ol> <li>Just over 10s in four <code>Index Scan</code> blocks (one per column). These scans return 50,214 rows for <code>reviewer_name</code>, 761 rows for <code>summary</code> and 0 rows for <code>asin</code> and <code>reviewer_id</code>. In total, they access about 2.59GB of data from the shared buffer cache.</li> <li>769ms in <code>Nested Loop</code> blocks. These loops combine the input with the <code>Index Scan</code> results. It’s rather surprising that we spend any significant time here, but we could easily optimize this out by getting rid of the <code>input</code> CTE.</li> </ol> <p>If we want to search all four text columns, we’ll need to think a bit harder!</p> <h3 id="one-four-column-query-with-disjunctions">One Four-Column Query with Disjunctions</h3> <p>As a second pass, what if we flatten the four unioned queries into a single disjunctive query?</p> <div><div><pre><code><span>select</span> <span>review_id</span><span>,</span>
       <span>(</span><span>1</span> <span>-</span> <span>least</span><span>(</span>
        <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>reviewer_id</span><span>,</span>
        <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>reviewer_name</span><span>,</span>
        <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>summary</span><span>,</span>
        <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>asin</span><span>))</span> <span>as</span> <span>score</span> <span>-- (3)</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>input</span><span>.</span><span>q</span> <span>%</span> <span>reviewer_id</span>
   <span>or</span> <span>input</span><span>.</span><span>q</span> <span>%</span> <span>reviewer_name</span>
   <span>or</span> <span>input</span><span>.</span><span>q</span> <span>%</span> <span>summary</span>
   <span>or</span> <span>input</span><span>.</span><span>q</span> <span>%</span> <span>asin</span> <span>-- (1)</span>
<span>order</span> <span>by</span> <span>least</span><span>(</span>
    <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>reviewer_id</span><span>,</span>
    <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>reviewer_name</span><span>,</span>
    <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>summary</span><span>,</span>
    <span>input</span><span>.</span><span>q</span> <span>&lt;-&gt;</span> <span>asin</span><span>)</span> <span>limit</span> <span>10</span><span>;</span> <span>-- (2)</span>
</code></pre></div></div> <p>Explaining the numbered components:</p> <ol> <li>We keep the row as a candidate if it’s a trigram match for any of the four columns.</li> <li>We sort the candidates by the lowest trigram distance to any of the four queries.</li> <li>We score the candidates by one minus the lowest trigram distance to any of the four queries. This is equivalent to the greatest trigram similarity.</li> </ol> <p>The performance works out like this:</p> <table> <thead> <tr> <th>Query</th> <th>Query String</th> <th>Execution Time</th> <th>Buffer Hits</th> </tr> </thead> <tbody> <tr> <td>Trigram</td> <td>exact name</td> <td>13.8s</td> <td>323953</td> </tr> <tr> <td>Trigram</td> <td>fuzzy name</td> <td>13.9s</td> <td>324728</td> </tr> <tr> <td>Exact-Only</td> <td>exact name</td> <td>162ms</td> <td>14705</td> </tr> <tr> <td>Exact-Only</td> <td>fuzzy name</td> <td>153ms</td> <td>12987</td> </tr> </tbody> </table> <p>👎 <strong>The performance is even worse: about 14s to find ten matches.</strong></p> <div data-app-component="pev2"> <pre>explain (analyze, buffers)
with input as (select &#39;Michael Lewis&#39; as q)
select review_id,
       (1 - least(
        input.q &lt;-&gt; reviewer_id,
        input.q &lt;-&gt; reviewer_name,
        input.q &lt;-&gt; summary,
        input.q &lt;-&gt; asin)) as score -- (3)
from reviews, input
where input.q % reviewer_id
   or input.q % reviewer_name
   or input.q % summary
   or input.q % asin -- (1)
order by least(
    input.q &lt;-&gt; reviewer_id,
    input.q &lt;-&gt; reviewer_name,
    input.q &lt;-&gt; summary,
    input.q &lt;-&gt; asin) limit 10; -- (2)
</pre> <pre>Limit  (cost=5389.77..5389.79 rows=10 width=20) (actual time=13856.366..13856.370 rows=10 loops=1)
  Buffers: shared hit=323953
  -&gt;  Sort  (cost=5389.77..5403.40 rows=5452 width=20) (actual time=13856.364..13856.367 rows=10 loops=1)
&#34;        Sort Key: (LEAST((&#39;Michael Lewis&#39;::text &lt;-&gt; (reviews.reviewer_id)::text), (&#39;Michael Lewis&#39;::text &lt;-&gt; (reviews.reviewer_name)::text), (&#39;Michael Lewis&#39;::text &lt;-&gt; (reviews.summary)::text), (&#39;Michael Lewis&#39;::text &lt;-&gt; (reviews.asin)::text)))&#34;
        Sort Method: top-N heapsort  Memory: 26kB
        Buffers: shared hit=323953
        -&gt;  Bitmap Heap Scan on reviews  (cost=102.01..5271.95 rows=5452 width=20) (actual time=10013.108..13837.707 rows=50929 loops=1)
              Recheck Cond: ((&#39;Michael Lewis&#39;::text % (reviewer_id)::text) OR (&#39;Michael Lewis&#39;::text % (reviewer_name)::text) OR (&#39;Michael Lewis&#39;::text % (summary)::text) OR (&#39;Michael Lewis&#39;::text % (asin)::text))
              Filter: ((&#39;Michael Lewis&#39;::text % (reviewer_id)::text) OR (&#39;Michael Lewis&#39;::text % (reviewer_name)::text) OR (&#39;Michael Lewis&#39;::text % (summary)::text) OR (&#39;Michael Lewis&#39;::text % (asin)::text))
              Heap Blocks: exact=34021
              Buffers: shared hit=323953
              -&gt;  BitmapOr  (cost=102.01..102.01 rows=5453 width=0) (actual time=9995.890..9995.892 rows=0 loops=1)
                    Buffers: shared hit=289932
                    -&gt;  Bitmap Index Scan on reviews_reviewer_id_trgm_gist_idx  (cost=0.00..15.07 rows=874 width=0) (actual time=2488.516..2488.517 rows=0 loops=1)
                          Index Cond: ((reviewer_id)::text % &#39;Michael Lewis&#39;::text)
                          Buffers: shared hit=69700
                    -&gt;  Bitmap Index Scan on reviews_reviewer_name_trgm_gist_idx  (cost=0.00..48.25 rows=2898 width=0) (actual time=3429.824..3429.824 rows=50214 loops=1)
                          Index Cond: ((reviewer_name)::text % &#39;Michael Lewis&#39;::text)
                          Buffers: shared hit=87344
                    -&gt;  Bitmap Index Scan on reviews_summary_trgm_gist_idx  (cost=0.00..18.28 rows=821 width=0) (actual time=4070.030..4070.030 rows=761 loops=1)
                          Index Cond: ((summary)::text % &#39;Michael Lewis&#39;::text)
                          Buffers: shared hit=132066
                    -&gt;  Bitmap Index Scan on reviews_asin_trgm_gist_idx  (cost=0.00..14.96 rows=859 width=0) (actual time=7.515..7.515 rows=0 loops=1)
                          Index Cond: ((asin)::text % &#39;Michael Lewis&#39;::text)
                          Buffers: shared hit=822
Planning Time: 5.831 ms
Execution Time: 13856.489 ms
</pre> </div> <p>Here’s how we spend this time:</p> <ol> <li>About 10s in four <code>Bitmap Index Scan</code> blocks, one per text column. Just like the previous iteration, these scans return 50,214 and 761 rows for <code>reviewer_name</code> and <code>summary</code>, respectively. In total, they access about 2.24GB of data from the shared buffer cache.</li> <li>About 3s in a <code>Bitmap Heap Scan</code>. This step deduplicates the data returned from the <code>Bitmap Index Scan</code> blocks. Unfortunately, it only removes 46 of the 50975 rows returned from the scans, and it accesses another 266MB of data from the shared buffer cache.</li> <li>About 20ms in a <code>Sort</code> block that sorts the 50,929 rows returned from the previous blocks.</li> </ol> <p>Alas, the query is a bit more compact, but it doesn’t make very good use of time.</p> <h3 id="one-four-column-query-with-an-expression-index">One Four-Column Query with an Expression Index</h3> <p>Let’s give this one more try. For this final pass, we’ll need to introduce two new concepts: <a href="https://www.postgresql.org/docs/14/indexes-expressional.html">expression indexes</a> and <a href="https://www.postgresql.org/docs/14/pgtrgm.html#id-1.11.7.42.6">trigram word_similarity</a>.</p> <h4 id="expression-indexes">Expression Indexes</h4> <p>An Expression Index lets us apply some function to a set of columns (all on the same table) and index the resulting values.</p> <p>The canonical example is a query for a full name against a table with <code>first_name</code> and <code>last_name</code> columns:</p> <div><div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> <span>people</span> <span>WHERE</span> <span>(</span><span>first_name</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span> <span>last_name</span><span>)</span> <span>=</span> <span>&#39;John Smith&#39;</span><span>;</span>
</code></pre></div></div> <p>We don’t want to store a <code>full_name</code> column, as that would duplicate data and probably drift. Instead, we can create an index on the same name concatenation:</p> <div><div><pre><code><span>CREATE</span> <span>INDEX</span> <span>people_names</span> <span>ON</span> <span>people</span> <span>((</span><span>first_name</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span> <span>last_name</span><span>));</span>
</code></pre></div></div> <p>Then, any query with the same expression can leverage the index – pretty cool if you ask me.</p> <h4 id="word_similarity"><code>word_similarity</code></h4> <p>The trigram <code>word_similarity(text1, text2)</code> function is a variation on the <code>similarity(text1, text2)</code> function.</p> <p>As a reminder, <code>similarity(text1, text2)</code> computes the intersection-over-union of the two trigram sets. In contrast, <code>word_similarity(text1, text2)</code> computes the <em>greatest similarity between the set of trigrams in the first string and any continuous extent of an ordered set of trigrams in the second string</em>.</p> <p>That is quite a mouthful. For our purposes, the point is this: <code>similarity</code> is sensitive to the length of the two strings, whereas <code>word_similarity</code> is not!</p> <p>Let’s look at an example that demonstrates the sensitivity to string length:</p> <div><div><pre><code><span>select</span> <span>text1</span><span>,</span> <span>text2</span><span>,</span> <span>similarity</span><span>(</span><span>text1</span><span>,</span> <span>text2</span><span>),</span> <span>word_similarity</span><span>(</span><span>text1</span><span>,</span> <span>text2</span><span>)</span>
<span>from</span>
<span>(</span><span>values</span> <span>(</span><span>&#39;louis&#39;</span><span>,</span> <span>&#39;lewis&#39;</span><span>),</span>
        <span>(</span><span>&#39;louis&#39;</span><span>,</span> <span>&#39;a lewis c&#39;</span><span>),</span>
        <span>(</span><span>&#39;louis&#39;</span><span>,</span> <span>&#39;aa lewis cc&#39;</span><span>),</span>
        <span>(</span><span>&#39;louis&#39;</span><span>,</span> <span>&#39;aaa lewis ccc&#39;</span><span>))</span> <span>v</span><span>(</span><span>text1</span><span>,</span> <span>text2</span><span>);</span>
</code></pre></div></div> <p>Note how the <code>similarity</code> decreases as the length of <code>text2</code> increases, whereas <code>word_similarity</code> remains constant.</p> <table> <thead> <tr> <th>text1</th> <th>text2</th> <th>similarity</th> <th>word_similarity</th> </tr> </thead> <tbody> <tr> <td>louis</td> <td>lewis</td> <td>0.2</td> <td>0.2</td> </tr> <tr> <td>louis</td> <td>a lewis c</td> <td>0.14285715</td> <td>0.2</td> </tr> <tr> <td>louis</td> <td>aa lewis cc</td> <td>0.125</td> <td>0.2</td> </tr> <tr> <td>louis</td> <td>aaa lewis ccc</td> <td>0.11111111</td> <td>0.2</td> </tr> </tbody> </table> <p>Why does this property matter? I don’t want to give too much away, but we just described an indexing technique that leverages concatenated text columns. Concatenated text columns are, by definition, longer than individual text columns.</p> <p>Some final details, for sake of completeness:</p> <ol> <li>The order of arguments matters. <code>word_similarity(text1, text2)</code> will only equal <code>word_similarity(text2, text1)</code> if <code>text1 = text2</code>.</li> <li>The <code>text1 &lt;&lt;-&gt; text2</code> operator is used to compute word_similarity distance, i.e., <code>1 - word_similarity(text1, text2)</code>. This is analogous to <code>text1 &lt;-&gt; text2</code> and <code>1 - similarity(text1, text2)</code>.</li> <li>The <code>text1 &lt;&lt;% text2</code> operator is used to filter for <code>word_similarity(text1, text2)</code> exceeding a fixed threshold. The default threshold is 0.6.</li> </ol> <h4 id="a-blazing-fast-search-query">A Blazing Fast Search Query</h4> <p>Let’s put our knowledge of expression indexes and <code>word_similarity</code> to use.</p> <p>We’ll start by building an index on the concatenation expression of all four text columns. We have to coalesce the columns to empty strings, as they are all nullable.</p> <div><div><pre><code><span>create</span> <span>index</span> <span>reviews_searchable_text_trgm_gist_idx</span> <span>on</span> <span>reviews</span>
  <span>using</span> <span>gist</span><span>((</span>
      <span>coalesce</span><span>(</span><span>asin</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>reviewer_id</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>reviewer_name</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>summary</span><span>,</span> <span>&#39;&#39;</span><span>))</span>  <span>gist_trgm_ops</span><span>(</span><span>siglen</span><span>=</span><span>256</span><span>));</span>
</code></pre></div></div> <p>This takes about 16 minutes to build and ends up using about 2.2GB of storage.</p> <p>Now we need a search query that can leverage this index. Behold, our new trigram search query:</p> <div><div><pre><code><span>with</span> <span>input</span> <span>as</span> <span>(</span><span>select</span> <span>&#39;Michael Louis&#39;</span> <span>as</span> <span>q</span><span>)</span>
<span>select</span> <span>review_id</span><span>,</span>
      <span>1</span> <span>-</span> <span>(</span><span>input</span><span>.</span><span>q</span> <span>&lt;&lt;-&gt;</span> <span>(</span><span>coalesce</span><span>(</span><span>asin</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span> 
      <span>coalesce</span><span>(</span><span>reviewer_id</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>reviewer_name</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>summary</span><span>,</span> <span>&#39;&#39;</span><span>)))</span> <span>as</span> <span>score</span>                    <span>-- (3)</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>input</span><span>.</span><span>q</span> <span>&lt;%</span> <span>(</span><span>coalesce</span><span>(</span><span>asin</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>reviewer_id</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>reviewer_name</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>summary</span><span>,</span> <span>&#39;&#39;</span><span>))</span>                              <span>-- (1)</span>
<span>order</span> <span>by</span> <span>input</span><span>.</span><span>q</span> <span>&lt;&lt;-&gt;</span> <span>(</span><span>coalesce</span><span>(</span><span>asin</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>reviewer_id</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>reviewer_name</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>summary</span><span>,</span> <span>&#39;&#39;</span><span>))</span> <span>limit</span> <span>10</span><span>;</span>                    <span>-- (2)</span>
</code></pre></div></div> <p>The numbered components should help cut through the concatenations:</p> <ol> <li>We use <code>input.q &lt;% concatenated_columns</code> to filter the table down to a set of candidate rows. For each of these rows, <code>input.q</code> and the concatenated columns have a trigram word similarity greater than or equal to 0.6.</li> <li>Once we have candidate rows, we compute and sort by the trigram word distance between <code>input.q</code> and the concatenated columns.</li> <li>In order to return the score, we just subtract the trigram word distance from 1.0.</li> </ol> <p>The corresponding exact-only search query looks similar:</p> <div><div><pre><code><span>explain</span> <span>(</span><span>analyze</span><span>,</span> <span>buffers</span><span>)</span>
<span>with</span> <span>input</span> <span>as</span> <span>(</span><span>select</span> <span>&#39;Michael Lewis&#39;</span> <span>as</span> <span>q</span><span>)</span>
<span>select</span> <span>review_id</span><span>,</span>
      <span>1</span><span>.</span><span>0</span> <span>as</span> <span>score</span>
<span>from</span> <span>reviews</span><span>,</span> <span>input</span>
<span>where</span> <span>(</span><span>coalesce</span><span>(</span><span>asin</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>reviewer_id</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>reviewer_name</span><span>,</span> <span>&#39;&#39;</span><span>)</span> <span>||</span> <span>&#39; &#39;</span> <span>||</span>
      <span>coalesce</span><span>(</span><span>summary</span><span>,</span> <span>&#39;&#39;</span><span>))</span> <span>ilike</span> <span>&#39;%&#39;</span> <span>||</span> <span>input</span><span>.</span><span>q</span> <span>||</span> <span>&#39;%&#39;</span>
<span>limit</span> <span>10</span><span>;</span>
</code></pre></div></div> <p>The results for the trigram search query on the exact name look like this:</p> <table> <thead> <tr> <th>review_id</th> <th>asin</th> <th>reviewer_id</th> <th>reviewer_name</th> <th>summary</th> <th>score</th> </tr> </thead> <tbody> <tr> <td>2108562</td> <td>0393072231</td> <td>A22GLZ0P4MGO0W</td> <td>Thom Mitchell</td> <td>Another Michael Lewis Must Read</td> <td>1</td> </tr> <tr> <td>2111265</td> <td>0393081818</td> <td>A1VJF95Y8HMXW9</td> <td>Louis Kokernak</td> <td>Another fun and informative read from Michael Lewis</td> <td>1</td> </tr> <tr> <td>2114047</td> <td>0393244660</td> <td>A13U0KMO103QJP</td> <td>Larry L. Roberts</td> <td>Another great book by Michael Lewis. A must read for the small investor.</td> <td>1</td> </tr> <tr> <td>2108273</td> <td>0393072231</td> <td>A1P1WJTZGC955H</td> <td>ITS</td> <td>Another Michael Lewis Masterpiece</td> <td>1</td> </tr> <tr> <td>2097231</td> <td>0393057658</td> <td>A3MYOI5BL91KKA</td> <td>Joseph M. Powers</td> <td>Standard, high quality, Michael Lewis offering</td> <td>1</td> </tr> <tr> <td>2097049</td> <td>0393057658</td> <td>A2QHM5HBSIXRL4</td> <td>Andy Orrock</td> <td>Another good work from Michael Lewis</td> <td>1</td> </tr> <tr> <td>2113780</td> <td>0393244660</td> <td>APM2KUPZYHB94</td> <td>Alice</td> <td>Michael Lewis Fan</td> <td>1</td> </tr> <tr> <td>2108394</td> <td>0393072231</td> <td>A2JOZET739XZT7</td> <td>Mark Haslett</td> <td>Big Fan of Michael Lewis</td> <td>1</td> </tr> <tr> <td>2108244</td> <td>0393072231</td> <td>A27NDIDE8W9YQC</td> <td>Gderf</td> <td>The Big Short by Michael Lewis</td> <td>1</td> </tr> <tr> <td>2111212</td> <td>0393081818</td> <td>A2X1XC7SQQGXFH</td> <td>Ian C Freund</td> <td>Michael Lewis is amazing</td> <td>1</td> </tr> </tbody> </table> <p>And the trigram search query on the fuzzy name:</p> <table> <thead> <tr> <th>review_id</th> <th>asin</th> <th>reviewer_id</th> <th>reviewer_name</th> <th>summary</th> <th>score</th> </tr> </thead> <tbody> <tr> <td>1368320</td> <td>0316013684</td> <td>A106393MZH9T4M</td> <td>Michael Louis Minns</td> <td>Fun and enlightening</td> <td>1</td> </tr> <tr> <td>1683931</td> <td>0345536592</td> <td>A106393MZH9T4M</td> <td>Michael Louis Minns</td> <td>Odd Thomas Collection</td> <td>1</td> </tr> <tr> <td>3803521</td> <td>077831233X</td> <td>A106393MZH9T4M</td> <td>Michael Louis Minns</td> <td>Real law by a real lawyer</td> <td>1</td> </tr> <tr> <td>2990026</td> <td>0553808036</td> <td>A106393MZH9T4M</td> <td>Michael Louis Minns</td> <td>Koontz Remains the Master</td> <td>1</td> </tr> <tr> <td>5497049</td> <td>1455546143</td> <td>A106393MZH9T4M</td> <td>Michael Louis Minns</td> <td>Could not put this down…</td> <td>1</td> </tr> <tr> <td>1856766</td> <td>0375411089</td> <td>A106393MZH9T4M</td> <td>Michael Louis Minns</td> <td>skinny dip</td> <td>1</td> </tr> <tr> <td>2000799</td> <td>0385343078</td> <td>A106393MZH9T4M</td> <td>Michael Louis Minns</td> <td>Great Historical Fiction</td> <td>1</td> </tr> <tr> <td>3836540</td> <td>0778327760</td> <td>A106393MZH9T4M</td> <td>Michael Louis Minns</td> <td>Teller Rocks</td> <td>1</td> </tr> <tr> <td>5536658</td> <td>1460201051</td> <td>A106393MZH9T4M</td> <td>Michael Louis Minns</td> <td>The Cat Didn’t really do it</td> <td>1</td> </tr> <tr> <td>3478374</td> <td>074326875X</td> <td>A106393MZH9T4M</td> <td>Michael Louis Minns</td> <td>Pretty good read</td> <td>1</td> </tr> </tbody> </table> <p>It turns out there was an avid reviewer named Michael Louis. Go figure!</p> <p>Performance works out like this:</p> <table> <thead> <tr> <th>Query</th> <th>Query String</th> <th>Execution Time</th> <th>Buffer Hits</th> </tr> </thead> <tbody> <tr> <td>Trigram</td> <td>exact name</td> <td>39ms</td> <td>1685</td> </tr> <tr> <td>Trigram</td> <td>fuzzy name</td> <td>113ms</td> <td>5094</td> </tr> <tr> <td>Exact-Only</td> <td>exact name</td> <td>37ms</td> <td>4345</td> </tr> <tr> <td>Exact-Only</td> <td>fuzzy name</td> <td>87ms</td> <td>10633</td> </tr> </tbody> </table> <p>👍 <strong>A significant improvement: from over 10s to just over 100ms!</strong></p> <p>Let’s look at the plan for trigram search with the exact name to understand why this is faster:</p> <div data-app-component="pev2"> <pre>with input as (select &#39;Michael Lewis&#39; as q)
select review_id,
      1 - (input.q &lt;&lt;-&gt; (coalesce(asin, &#39;&#39;) || &#39; &#39; ||
      coalesce(reviewer_id, &#39;&#39;) || &#39; &#39; ||
      coalesce(reviewer_name, &#39;&#39;) || &#39; &#39; ||
      coalesce(summary, &#39;&#39;))) as score                    -- (3)
from reviews, input
where input.q &lt;% (coalesce(asin, &#39;&#39;) || &#39; &#39; ||
      coalesce(reviewer_id, &#39;&#39;) || &#39; &#39; ||
      coalesce(reviewer_name, &#39;&#39;) || &#39; &#39; ||
      coalesce(summary, &#39;&#39;))                              -- (1)
order by input.q &lt;&lt;-&gt; (coalesce(asin, &#39;&#39;) || &#39; &#39; ||
      coalesce(reviewer_id, &#39;&#39;) || &#39; &#39; ||
      coalesce(reviewer_name, &#39;&#39;) || &#39; &#39; ||
      coalesce(summary, &#39;&#39;)) limit 10;                    -- (2)
</pre> <pre>Limit  (cost=0.42..7.82 rows=10 width=20) (actual time=8.202..38.716 rows=10 loops=1)
  Buffers: shared hit=1685
  -&gt;  Index Scan using reviews_searchable_text_trgm_gist_idx on reviews  (cost=0.42..65909.97 rows=88980 width=20) (actual time=8.200..38.709 rows=10 loops=1)
&#34;        Index Cond: ((((((((COALESCE(asin, &#39;&#39;::character varying))::text || &#39; &#39;::text) || (COALESCE(reviewer_id, &#39;&#39;::character varying))::text) || &#39; &#39;::text) || (COALESCE(reviewer_name, &#39;&#39;::character varying))::text) || &#39; &#39;::text) || (COALESCE(summary, &#39;&#39;::character varying))::text) %&gt; &#39;Michael Lewis&#39;::text)&#34;
        Rows Removed by Index Recheck: 3
&#34;        Order By: ((((((((COALESCE(asin, &#39;&#39;::character varying))::text || &#39; &#39;::text) || (COALESCE(reviewer_id, &#39;&#39;::character varying))::text) || &#39; &#39;::text) || (COALESCE(reviewer_name, &#39;&#39;::character varying))::text) || &#39; &#39;::text) || (COALESCE(summary, &#39;&#39;::character varying))::text) &lt;-&gt;&gt; &#39;Michael Lewis&#39;::text)&#34;
        Buffers: shared hit=1685
Planning Time: 0.176 ms
Execution Time: 38.772 ms
</pre> </div> <p>One last time, here’s how we spend our time:</p> <ol> <li>About 40ms in an <code>Index Scan</code> block. This uses the new <code>reviews_searchable_text_trgm_gist_idx</code> index for filtering and sorting and returns exactly 10 rows. It accesses just over 13MB of data from the shared buffer cache.</li> </ol> <h3 id="single-query-summary">Single Query Summary</h3> <p>Here’s what we know about combining four columns in a single query:</p> <ol> <li>Unioning four queries was more than a 4x slowdown: 2s for one column → 10s for four.</li> <li>Introducing a clever disjunction made it even slower: 10s → 14s.</li> <li>Leveraging an expression index and a new trigram operator is our winner: 10s → 113ms.</li> </ol>  <p>Through some effort and iteration, we’ve arrived at a very performant query.</p> <p><em>We started at 90 seconds to search one text column and ended at 113ms for four columns.</em></p> <p>Our implementation consisted primarily of Postgres trigram and string matching operators, and our optimizations used three main techniques:</p> <ol> <li>Indexing the text columns</li> <li>Separating exact search queries from trigram search queries</li> <li>Cleverly combining all four text columns into a single index and single query</li> </ol> <p>Throughout the iterations, we leveraged <code>explain (analyze, buffers)</code> with the PEV2 visualizer to understand how we were spending our time on execution and I/O.</p> <p>As always, I hope this post will save someone a bit of time learning, debugging, and optimizing!</p> <hr/>  </section>    </div></div>
  </body>
</html>
