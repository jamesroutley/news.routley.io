<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pganalyze.com/blog/automatic-indexing-system-postgres-pganalyze-indexing-engine">Original</a>
    <h1>An automatic indexing system for Postgres</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Indexing is hard. Most people who have worked with databases will agree that regardless of how you do it, creating the right indexes on your database requires thought and detailed analysis. It&#39;s not something to be taken lightly. If you don&#39;t create the right indexes, your queries will be slow, and if you create too many indexes, your writes on busy tables will be slowed down significantly.</p>
<p>But even if you know how to do it, indexing takes a lot of effort. And this has gotten more complex with the use of microservices (no longer a single place to look for queries), and the continued use of ORMs to generate queries from application logic, hiding the exact details of what kind of queries are running on production.</p>
<p><strong>Over a year ago</strong> we set out to challenge the status quo. Our guiding principle was to build a better indexing system that is <strong>AI-assisted, but developer-driven.</strong> And today we are introducing the first leap forward to help address the complexity of indexing modern query workloads.</p>
<p>In this blog post, we will walk you through the <strong>new pganalyze Indexing Engine</strong> that gives developers a better way to index their database through automatic index selection. This intelligent system can be explained, understood and (in future iterations) tuned to individual indexing preferences.</p>
<p>Continue reading to take a closer look at what the pganalyze Indexing Engine is, and how we built it. If you are interested in how to use the new functionality in pganalyze, check out our companion blog post about the <a href="https://pganalyze.com/blog/automatic-postgres-indexing-balanced-approach">new version of the pganalyze Index Advisor</a>.</p>
<p>
<span>
      <span></span>
  <img alt="Diagram illustrating the two phases of the pganalyze Indexing Engine" title="Diagram illustrating the two phases of the pganalyze Indexing Engine" src="https://pganalyze.com/static/e901c916d712eb4e9053b87e78d9fcfd/1d69c/pganalyze-indexing-engine.png" srcset="/static/e901c916d712eb4e9053b87e78d9fcfd/4dcb9/pganalyze-indexing-engine.png 188w, /static/e901c916d712eb4e9053b87e78d9fcfd/5ff7e/pganalyze-indexing-engine.png 375w, /static/e901c916d712eb4e9053b87e78d9fcfd/1d69c/pganalyze-indexing-engine.png 750w, /static/e901c916d712eb4e9053b87e78d9fcfd/78797/pganalyze-indexing-engine.png 1125w, /static/e901c916d712eb4e9053b87e78d9fcfd/aa440/pganalyze-indexing-engine.png 1500w, /static/e901c916d712eb4e9053b87e78d9fcfd/bf286/pganalyze-indexing-engine.png 1688w" sizes="(max-width: 750px) 100vw, 750px" loading="lazy" decoding="async"/>
    </span>
</p>

<h2 id="a-structured-approach-for-database-indexing"><a href="#a-structured-approach-for-database-indexing" aria-label="a structured approach for database indexing permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A structured approach for database indexing</h2>
<p>Best practices for creating the right indexes haven&#39;t changed much over the years, but the knowledge on how to do it isn&#39;t evenly distributed. If you ask a Postgres expert, they will give you a variant of the advice contained in the Postgres documentation, or excellent third-party resources such as Markus Winand&#39;s <a href="https://use-the-index-luke.com/">&#34;Use The Index, Luke&#34;</a>. If you are a typical application developer, you probably know how to handle single and multi-column B-tree indexes, but find it challenging to reason about other Postgres index types such as GIST and GIN.</p>
<p>To start with, let&#39;s take a look at how we can think about indexes at the high level. Fundamentally, indexes are a variant of a cache. We create an additional data structure within our database to help make queries faster - either by <strong>answering the query&#39;s question directly from the index</strong>, or by <strong>optimizing where to look for in the actual table</strong>. The tradeoff is that each added index slows down the writes to the database, as the database has to continue to maintain the index data structure.</p>
<p>Compared to other kinds of caches, with indexes we don&#39;t have to worry about cache consistency - the database takes care of that for us - but that&#39;s exactly what makes index writes expensive: they are guaranteed to be consistent with our regular table writes.</p>
<p>In the pganalyze Indexing Engine we represent this fundamental tradeoff of performance improvement with write overhead with two metrics:</p>
<ol>
<li><strong>Cost improvement:</strong> How much a potential index would improve query performance, based on the Postgres cost model</li>
<li><strong>Index Write Overhead:</strong> How many additional bytes are written to indexes, compared to the bytes written to the table itself</li>
</ol>
<p>But before we can decide about this tradeoff, how do we even know which indexes we could create? Typically, you start by looking at the queries you are running. For simple queries this is straightforward, but with complex queries that becomes hard to reason about quickly.</p>
<h2 id="the-first-phase-of-the-pganalyze-indexing-engine-query-analysis"><a href="#the-first-phase-of-the-pganalyze-indexing-engine-query-analysis" aria-label="the first phase of the pganalyze indexing engine query analysis permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The first phase of the pganalyze Indexing Engine: Query Analysis</h2>
<p>The first phase of the Indexing Engine runs at least once for each query (possibly multiple times if the schema changes), and is responsible for making sense of both simple and complex queries.</p>
<p>This phase structures queries into a simpler format for processing by the second phase, and makes it easier to introspect the actual inputs to the index recommendation logic.</p>
<p>
<span>
      <span></span>
  <img alt="Diagram showing multiple queries broken down into many scans on different tables" title="Diagram showing multiple queries broken down into many scans on different tables" src="https://pganalyze.com/static/7e5f867dc28c1730ed13c7d2ffec24cb/1d69c/query-scan-breakdown.png" srcset="/static/7e5f867dc28c1730ed13c7d2ffec24cb/4dcb9/query-scan-breakdown.png 188w, /static/7e5f867dc28c1730ed13c7d2ffec24cb/5ff7e/query-scan-breakdown.png 375w, /static/7e5f867dc28c1730ed13c7d2ffec24cb/1d69c/query-scan-breakdown.png 750w, /static/7e5f867dc28c1730ed13c7d2ffec24cb/78797/query-scan-breakdown.png 1125w, /static/7e5f867dc28c1730ed13c7d2ffec24cb/aa440/query-scan-breakdown.png 1500w, /static/7e5f867dc28c1730ed13c7d2ffec24cb/569c6/query-scan-breakdown.png 1674w" sizes="(max-width: 750px) 100vw, 750px" loading="lazy" decoding="async"/>
    </span>
</p>
<h3 id="breaking-down-postgres-queries-into-scans"><a href="#breaking-down-postgres-queries-into-scans" aria-label="breaking down postgres queries into scans permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Breaking down Postgres queries into scans</h3>
<p>A fundamental decision we&#39;ve made for the pganalyze Indexing Engine is that we break down queries into smaller parts we call &#34;scans&#34;. Scans are always on a single table, and you may be familiar with this concept from reading an EXPLAIN plan. For example, in an EXPLAIN plan you could see a Sequential Scan or Index Scan, both representing a different scan method for the same scan on a given table.</p>
<p>Let&#39;s take a look at an example, that tries to find the top 10 inventory items tagged &#34;milk&#34; that expire next in our California-based warehouses:</p>
<div data-language="sql"><pre><code><span>SELECT</span> inventory_items<span>.</span>id
  <span>FROM</span> warehouses
  <span>JOIN</span> inventory_items <span>USING</span> <span>(</span>warehouse_id<span>)</span>
 <span>WHERE</span> warehouse<span>.</span>location_state <span>=</span> <span>&#39;CA&#39;</span>
       <span>AND</span> inventory_items<span>.</span>tags @<span>&gt;</span> ARRAY<span>[</span><span>&#39;milk&#39;</span><span>]</span>
<span>ORDER</span> <span>BY</span> inventory_items<span>.</span>expires_at <span>ASC</span>
<span>LIMIT</span> <span>10</span></code></pre></div>
<p>If we separated this into scans, it would look like this:</p>
<div data-language="sql"><pre><code>
<span>SELECT</span> id
  <span>FROM</span> inventory_items
 <span>WHERE</span> warehouse_id <span>=</span> $n
       <span>AND</span> inventory_items<span>.</span>tags @<span>&gt;</span> ARRAY<span>[</span><span>&#39;milk&#39;</span><span>]</span>
<span>ORDER</span> <span>BY</span> inventory_items<span>.</span>expires_at <span>ASC</span>
<span>LIMIT</span> <span>10</span><span>;</span>


<span>SELECT</span> warehouse_id
  <span>FROM</span> warehouses
 <span>WHERE</span> warehouse_id <span>=</span> $n
       <span>AND</span> location_state <span>=</span> <span>&#39;CA&#39;</span></code></pre></div>
<p>You&#39;ll note that <code>warehouse_id = $n</code> shows up in both scans. In practice, Postgres will load the data with one of two options:</p>
<ol>
<li>Load the data for both tables <strong>separately</strong>, and then join the data together using a Hash or Merge Join operation (using &#34;warehouse_id&#34; to match up rows)</li>
<li>Use a <strong>Nested Loop</strong>, and e.g. load warehouses first, and then run the inventory items scan once for each warehouse, and include the &#34;warehouse_id = $n&#34; filter when loading data</li>
</ol>
<h3 id="creating-generic-query-plans-from-pg_stat_statements-queries"><a href="#creating-generic-query-plans-from-pg_stat_statements-queries" aria-label="creating generic query plans from pg_stat_statements queries permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating generic query plans from pg_stat_statements queries</h3>
<p>Now, how can we go about automating this? In general, we need to look at EXPLAIN plans. But you may not always have an EXPLAIN plan available. Which is why, in the current version of the pganalyze Indexing Engine, we run what&#39;s called a &#34;generic&#34; query plan, and use that to determine whether a JOIN clause is likely to be indexable.</p>
<p>This is powered by a modified version of the Postgres planner that runs as part of the pganalyze app. This modified planner can generate EXPLAIN-like data from just a query and schema information - and most importantly, that means we can take query statistics data from pg_stat_statements and generate a generic query plan from it. You can read more about that in our blog post <a href="https://pganalyze.com/blog/deconstructing-the-postgres-planner">&#34;How we deconstructed the Postgres planner&#34;</a>.</p>
<p>Let&#39;s take a look at what&#39;s possible with this scan data in the second phase of the Indexing Engine:</p>
<h2 id="the-second-phase-of-the-indexing-engine-index-selection"><a href="#the-second-phase-of-the-indexing-engine-index-selection" aria-label="the second phase of the indexing engine index selection permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The second phase of the Indexing Engine: Index Selection</h2>
<p>Once we have broken queries into individual scans for each table, we can now review existing indexes, and come up with index recommendations.</p>
<p>The input into the second phase looks like this, for each table present in the system:</p>
<div data-language="json"><pre><code><span>{</span>
    <span>&#34;Relation Name&#34;</span><span>:</span> <span>&#34;queries&#34;</span><span>,</span>
    <span>&#34;Namespace Name&#34;</span><span>:</span> <span>&#34;public&#34;</span><span>,</span>
    <span>&#34;Scans&#34;</span><span>:</span> <span>[</span>
        <span>{</span>
            <span>&#34;Scan ID&#34;</span><span>:</span> <span>&#34;00000000-0000-0000-0000-000000000001&#34;</span><span>,</span>
            <span>&#34;Where Clauses&#34;</span><span>:</span> <span>[</span>
                <span>&#34;(queries.database_id = $1)&#34;</span>
            <span>]</span><span>,</span>
            <span>&#34;Join Clauses&#34;</span><span>:</span> <span>[</span>
                <span>&#34;(queries.id = $1)&#34;</span>
            <span>]</span><span>,</span>
            <span>&#34;Estimated Scans Per Minute&#34;</span><span>:</span> <span>0.68</span>
        <span>}</span><span>,</span>
        <span>{</span>
            <span>&#34;Scan ID&#34;</span><span>:</span> <span>&#34;00000000-0000-0000-0000-000000000002&#34;</span><span>,</span>
            <span>&#34;Where Clauses&#34;</span><span>:</span> <span>[</span>
                <span>&#34;(queries.id = $1)&#34;</span>
            <span>]</span><span>,</span>
            <span>&#34;Join Clauses&#34;</span><span>:</span> <span>[</span>
            <span>]</span><span>,</span>
            <span>&#34;Estimated Scans Per Minute&#34;</span><span>:</span> <span>12668.31</span>
        <span>}</span><span>,</span>
        <span>{</span>
            <span>&#34;Scan ID&#34;</span><span>:</span> <span>&#34;00000000-0000-0000-0000-000000000003&#34;</span><span>,</span>
            <span>&#34;Where Clauses&#34;</span><span>:</span> <span>[</span>
                <span>&#34;(queries.last_occurred_at &lt; CURRENT_DATE)&#34;</span>
            <span>]</span><span>,</span>
            <span>&#34;Join Clauses&#34;</span><span>:</span> <span>[</span>
            <span>]</span><span>,</span>
            <span>&#34;Estimated Scans Per Minute&#34;</span><span>:</span> <span>12248.96</span>
        <span>}</span><span>,</span></code></pre></div>
<p>The WHERE clauses in this input is what you would commonly see in the WHERE clause part of a query. JOIN Clauses on the other hand are conditions that are typically seen in the JOIN clause of a query. This set of clauses is already filtered to only contain clauses that are likely usable as part of a parameterized Index Scan (i.e. as the inner relation of a Nested Loop).  This separation between JOIN and WHERE was done as part of query analysis, to help the Indexing Engine decide which clauses are always usable, vs which may require further checks.</p>
<p>Additionally, schema information is provided like this, with special config variables to set the Postgres table statistics:</p>
<div data-language="sql"><pre><code><span>CREATE</span> EXTENSION <span>IF</span> <span>NOT</span> <span>EXISTS</span> btree_gist<span>;</span>

<span>CREATE</span> <span>SCHEMA</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> <span>public</span><span>;</span>
<span>CREATE</span> <span>TABLE</span> <span>public</span><span>.</span>queries <span>(</span>
id <span>bigint</span> <span>NOT</span> <span>NULL</span><span>,</span>
database_id <span>integer</span> <span>NOT</span> <span>NULL</span><span>,</span>
last_occurred_at <span>date</span><span>,</span>

<span>PRIMARY</span> <span>KEY</span> <span>(</span>id<span>)</span>
<span>)</span><span>;</span>
<span>CREATE</span> <span>INDEX</span> index_queries_on_database_id <span>ON</span> <span>public</span><span>.</span>queries <span>USING</span> <span>btree</span> <span>(</span>database_id<span>)</span><span>;</span>

<span>SET</span> pganalyze<span>.</span>curpages<span>.</span><span>public</span><span>.</span>queries <span>=</span> <span>1234</span><span>;</span>
<span>SET</span> pganalyze<span>.</span>relpages<span>.</span><span>public</span><span>.</span>queries <span>=</span> <span>1234</span><span>;</span>
<span>SET</span> pganalyze<span>.</span>reltuples<span>.</span><span>public</span><span>.</span>queries <span>=</span> <span>5678</span><span>;</span>

<span>SET</span> pganalyze<span>.</span>null_frac<span>.</span><span>public</span><span>.</span><span>databases</span><span>.</span>database_id <span>=</span> <span>0.0</span><span>;</span>
<span>SET</span> pganalyze<span>.</span>avg_width<span>.</span><span>public</span><span>.</span>schema_columns<span>.</span>database_id <span>=</span> <span>8</span><span>;</span>
<span>SET</span> pganalyze<span>.</span>n_distinct<span>.</span><span>public</span><span>.</span>schema_columns<span>.</span>database_id <span>=</span> <span>100.0</span><span>;</span>
<span>SET</span> pganalyze<span>.</span>correlation<span>.</span><span>public</span><span>.</span>schema_columns<span>.</span>database_id <span>=</span> <span>0.02</span><span>;</span>

</code></pre></div>
<p>You can see that column-level statistics are included as well, to help the Indexing Engine make decisions which columns to prioritize.</p>
<p>Future versions of the Indexing Engine will provide options to include additional input parameters, specifically to use typical bind parameter values to improve selectivity estimates for clauses, as well as provide details on extended statistics, if available.</p>
<h3 id="extracting-index-element-candidates"><a href="#extracting-index-element-candidates" aria-label="extracting index element candidates permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extracting index element candidates</h3>
<p>The next step involves turning the list of scans into potential candidates for index elements. Index elements are what you could also call the &#34;columns&#34; of an index, i.e., a list of table columns or expressions being indexed.</p>
<p>In this step we utilize the Postgres planner to tell us which operator classes are applicable for indexing a given clause. For example, the operators present in the above example (<code>&lt;</code> and <code>=</code>) are both indexable by B-Tree indexes in Postgres. You may also have clauses that use operators that are only indexable by other index types. For example, the query previously shown had a clause <code>inventory_items.tags @&gt; ARRAY[&#39;milk&#39;]</code>, and <code>@&gt;</code> is an operator that&#39;s <a href="https://www.postgresql.org/docs/current/gin-builtin-opclasses.html">only indexable with a GIN index</a>.</p>
<p>In addition to remembering the potential index element to be used in an index, we also remember whether the operator was an equality operator (important for B-Tree column ordering), as well as the clause selectivity and number of distinct values in the referenced column.</p>
<p>You could simply index all potential index element candidates as their own single column indexes. But that would not be effective - what we need is to make a decision on which multi-column combinations to generate.</p>
<h3 id="generating-multi-column-index-combinations"><a href="#generating-multi-column-index-combinations" aria-label="generating multi column index combinations permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generating multi-column index combinations</h3>
<p>When the Indexing Engine processes the scan list, it doesn&#39;t just extract the individual index elements. It also generates a list of potential combinations of these elements to allow consideration of multi-column index options. Multi-column indexes have two primary benefits:</p>
<ol>
<li>They allow a single index to provide a more selective answer, without having to resort to a BitmapAnd operation that combines multiple indexes</li>
<li>They allow use of the same index by multiple queries with different clauses (in some cases)</li>
</ol>
<p>Adding more columns to an index increases its Index Write Overhead, as more data needs to be stored in the index. (You can read more details about <a href="https://pganalyze.com/docs/indexing-engine/index-write-overhead">Index Write Overhead in our documentation</a>.) We avoid recommending a multi-column index when a single column index is good enough, but more about that in a bit.</p>
<p>To assess the best multi-column choice, we generate all different permutations of index elements for each index. We then sort the index elements based on a special set of rules, to make it most effective for each index type:</p>
<ul>
<li>
<p>B-Tree: Lead with index elements referenced in a clause through an equality operator (e.g. &#34;col = $1&#34;), followed by all other elements. Within that set of elements, sort by selectivity (more selective parameters are ordered first).</p>
</li>
<li>
<p>GIST: Sort elements by number of distinct values in the table (more distinct elements are ordered first).</p>
</li>
</ul>
<p>Note that we are still fine tuning the GIST recommendation logic, as well as other indexing types such as GIN (which are not yet available with the Indexing Engine).</p>
<p>Once we have the different combinations worth testing out, we go and try them.</p>
<h3 id="what-if-analysis"><a href="#what-if-analysis" aria-label="what if analysis permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>&#34;What If?&#34; Analysis</h3>
<p>When you read &#34;What If?&#34; you might be thinking we are referring to a certain animated superhero series - but we are in fact referencing an essential aspect of how the pganalyze Indexing Engine is built. &#34;What If?&#34; analysis is what you would typically consider an integral part of any algorithmic optimization logic. It&#39;s the part where the algorithm asks the system it&#39;s observing to tell it what happens if a certain condition is true. And in the case of index selection, it&#39;s where we ask the database how it thinks a particular index would perform.</p>
<p>This has historically been a big challenge for optimizing index selection, as described in a <a href="https://www.vldb.org/pvldb/vol13/p2382-kossmann.pdf">2020 paper by a team of researchers at Hasso Plattner Institute</a>:</p>
<blockquote>
<p>Most of the runtime of what-if based index selection algorithms is usually not spent on the algorithm logic, but on cost estimation calls to the what-if optimizer. Usually, algorithms request a cost estimate for a particular query and a given index combination from the (what-if) opti- mizer. These requests are expensive, …</p>
<p><small>Jan Kossmann, Stefan Halfpap, Marcel Jankrift, and Rainer Schlosser, &#34;Magic mirror in my hand, which is the best in the land? An Experimental Evaluation of Index Selection Algorithms&#34;</small></p>
</blockquote>
<p>The most popular option to do this for Postgres is <a href="https://github.com/HypoPG/hypopg">HypoPG</a>, created by Julien Rouhaud. HypoPG is an extension for Postgres that allows creating hypothetical indexes on your production system, and then lets you run EXPLAIN with the hypothetical index taken into account.</p>
<p>However, we found that in our specific context, a more purpose built solution is a better fit, that runs solely within the pganalyze system. Our solution for &#34;What if?&#34; analysis is built on the Postgres planner, and runs directly within the pganalyze app, requiring no extensions on the production database, and zero overhead for running &#34;What if?&#34; calls (as they are all run within the pganalyze app, separate from the database).</p>
<p>This approach also allows us to add extra instrumentation that allows the Indexing Engine to compare all possible indexes for a given scan, not just the best one.</p>
<p>The result of the &#34;What if?&#34; analysis is a set of cost improvement numbers - one number per scan and index combination.</p>
<h2 id="the-good-enough-index-selection-algorithm"><a href="#the-good-enough-index-selection-algorithm" aria-label="the good enough index selection algorithm permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The &#34;Good Enough&#34; index selection algorithm</h2>
<p>Finally, the most important decision: Which index should we pick?</p>
<p>Overall, the pganalyze Indexing Engine looks at index selection as a set covering problem, with the goal of covering all scans on the table with an index that is within 50% of the best possible index.</p>
<p>The &#34;Good Enough&#34; index selection algorithm takes the set of potential indexes, as well as the set of scans, and their potential cost improvements, and produces zero or more index recommendations for a given table.</p>
<h3 id="elimination-of-worst-candidates"><a href="#elimination-of-worst-candidates" aria-label="elimination of worst candidates permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Elimination of worst candidates</h3>
<p>Before we run through the set covering algorithm that selects the indexes to use, we first eliminate all indexes from consideration for a scan that are not within 50% of the best possible result.</p>
<p>This early reduction enables later stages of the algorithm to view this as a greedy set covering problem - any index that remains after this initial elimination would be acceptable and &#34;good enough&#34;.</p>
<h3 id="the-indexscan-matrix"><a href="#the-indexscan-matrix" aria-label="the indexscan matrix permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The index/scan matrix</h3>
<p>Let&#39;s take a slightly more complex example from a real world use case.</p>
<p>This matrix represents the results of the &#34;What If?&#34; analysis for a set of 4 existing indexes, 14 possible new indexes and 15 scans:</p>
<div>



























































































































































































































































































































































<table><thead><tr><th></th><th>S1</th><th>S2</th><th>S3</th><th>S4</th><th>S5</th><th>S6</th><th>S7</th><th>S8</th><th>S9</th><th>S10</th><th>S11</th><th>S12</th><th>S13</th><th>S14</th><th>S15</th></tr></thead><tbody><tr><td>X1</td><td></td><td></td><td>XXX</td><td></td><td></td><td></td><td>XXX</td><td></td><td></td><td></td><td></td><td></td><td>XXX</td><td></td><td></td></tr><tr><td>X2</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>X3</td><td></td><td></td><td></td><td>XXX</td><td></td><td></td><td></td><td></td><td>XXX</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>X4</td><td></td><td></td><td>(x)</td><td>(x)</td><td>XXX</td><td></td><td>(x)</td><td>(x)</td><td></td><td>(x)</td><td>XXX</td><td>XXX</td><td></td><td>XXX</td><td>(x)</td></tr><tr><td>I1  (0.11)</td><td><del>6.1</del></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>I2  (0.14)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>68.1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>I3  (0.15)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>68.1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>I4  (0.10)</td><td><del>7.2</del></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>I5  (0.08)</td><td><del>33.6</del></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>I6  (0.09)</td><td>43.3</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>I7  (0.13)</td><td>77.6</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>I8  (0.12)</td><td>77.6</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>I9  (0.14)</td><td></td><td></td><td></td><td></td><td>31.1</td><td>42.7</td><td></td><td></td><td></td><td></td><td>31.1</td><td>31.1</td><td></td><td>31.1</td><td></td></tr><tr><td>I10 (0.15)</td><td></td><td></td><td></td><td></td><td>46.1</td><td>44.3</td><td></td><td></td><td></td><td></td><td>46.1</td><td>46.1</td><td></td><td>46.1</td><td></td></tr><tr><td>I11 (0.08)</td><td></td><td>63.3</td><td></td><td></td><td>46.1</td><td></td><td></td><td></td><td></td><td>68.1</td><td>46.1</td><td></td><td></td><td></td><td>63.3</td></tr><tr><td>I12 (0.09)</td><td></td><td>63.3</td><td></td><td></td><td>46.1</td><td></td><td></td><td></td><td></td><td>68.1</td><td>46.1</td><td></td><td></td><td></td><td>63.3</td></tr><tr><td>I13 (0.16)</td><td></td><td>63.3</td><td></td><td></td><td>46.1</td><td></td><td></td><td></td><td></td><td>68.1</td><td>46.1</td><td></td><td></td><td></td><td>63.3</td></tr><tr><td>I14 (0.17)</td><td></td><td>63.3</td><td></td><td></td><td>46.1</td><td></td><td></td><td></td><td></td><td>68.1</td><td>46.1</td><td></td><td></td><td></td><td>63.3</td></tr></tbody></table>
</div>
<p>You can think of X.. and I.. being mapped to an index like <code>CREATE INDEX possible_index_1 ON table USING btree (some_column)</code>.</p>
<p>You can think of S.. being mapped to a scan like <code>SELECT * FROM table WHERE some_column = $1</code>.</p>
<p>Each cell for a potential index (I..) represents the cost improvement over the
current baseline (either a SeqScan or existing sub-optimal Index Scan).</p>
<p>Each cell for an existing index (X..) shows &#34;XXX&#34; for indexes that are the best overall,
and &#34;(x)&#34; for other existing indexes that match the scan.</p>
<p>Some columns have no cost improvements, typically you will see this when the
existing indexes are covering the scan sufficiently.</p>
<p>You can see the calculated <a href="https://pganalyze.com/docs/indexing-engine/index-write-overhead">Index Write Overhead</a>
for each potential index in parenthesis (e.g. I11 has 0.08 Index Write Overhead).</p>
<p>Note that cells that are not within 50% of the best possible improvement (e.g. S1/I2,
S1/I5 and I8/I6) have already been marked as not being &#34;good enough&#34; and are shown crossed out.</p>
<h3 id="set-covering-algorithm"><a href="#set-covering-algorithm" aria-label="set covering algorithm permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Set covering algorithm</h3>
<p>Based on this input, the Indexing Engine runs a greedy Set Covering Algorithm
to determine one or more &#34;good enough&#34; indexes.</p>
<p>It starts with the potential index that matches the most scans, and continues this until all scans are covered. If two indexes match the same number of scans, the index with the
lower Index Write Overhead is chosen.</p>
<p>In above example matrix, the algorithm picks as following:</p>
<ol>
<li>I11 (covers S2, S5, S10, S11, S15, and has lower write overhead compared to I9,I10,I12,I13,I14)</li>
<li>I9  (covers S6, S12, S14 -- note that S5 and S11 are no longer counted since I11 covers them)</li>
<li>I6  (covers S1)</li>
<li>I2  (covers S8)</li>
</ol>
<p>This result is deterministic. When the algorithm runs again with the same inputs, it would produce the same outcome.</p>
<p>These recommendations are then shown in the <a href="https://pganalyze.com/postgres-index-advisor">Index Advisor</a> for your assessment, benchmarking and, if they are a good fit, for applying them to production</p>
<p>Human review is encouraged. For example, you may choose not to create I2 and I6 in this example, if they represent infrequent queries where you find a sequential scan acceptable.</p>
<h2 id="conclusion"><a href="#conclusion" aria-label="conclusion permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>
<p>As you can see, the pganalyze Indexing Engine at its core is a purpose-built optimization system that processes your query workload in multiple steps to come up with a set of recommendations. It is not a machine learning based system, but rather a deterministic, repeatable process. Our goal with the pganalyze Indexing Engine is that you can understand the logic, introspect it, and trust its repeatability.</p>
<p>In our own testing, and in testing with early access customers, the pganalyze Indexing Engine represents a significant leap forward. No longer do we need to look at hundreds or even thousands of queries manually - instead we can let the Indexing Engine digest the information, and present us a recommendation to try out.</p>
<p>We believe that the pganalyze Indexing Engine will become the basis for implementing automation workflows for indexing your Postgres database. Indexing is not a problem that should be left to an AI system to do completely on its own, without interaction. Instead, <strong>indexing should be AI-assisted, but developer-driven</strong>.</p>
<p>To try out the pganalyze Indexing Engine, you can go into the pganalyze app and use the pganalyze Index Advisor - the recommendations in the new version of the Index Advisor are powered by the Indexing Engine.</p>
<p>Thinking of building something with the pganalyze Indexing Engine? We are working on an API for the Indexing Engine, and would love to hear from you.</p>
<p><strong>Share this article:</strong> If you want to share this article with you peers, you can <a href="https://twitter.com/intent/tweet?text=%E2%80%9DAn%20automatic%20indexing%20system%20for%20Postgres%E2%80%9D%3A%20A%20look%20behind%20the%20scenes%20on%20how%20%40pganalyze%20built%20the%20pganalyze%20Indexing%20Engine%3A%20https://pganalyze.com/blog/automatic-indexing-system-postgres-pganalyze-indexing-engine">tweet about it here</a></p>
<hr/>
<h3 id="see-a-behind-the-scences-on-the-indexing-engine-and-index-advisor-in-our-webinar-re-run"><a href="#see-a-behind-the-scences-on-the-indexing-engine-and-index-advisor-in-our-webinar-re-run" aria-label="see a behind the scences on the indexing engine and index advisor in our webinar re run permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>See a behind-the-scences on the Indexing Engine and Index Advisor in our webinar re-run</h3>
<p>
<a href="https://www.youtube.com/watch?v=o0HrXM1thYI"><span>
      <span></span>
  <img alt="Watch our Webinar on Indexing for Postgres and the new Indexing Engine" title="Watch our Webinar on Indexing for Postgres and the new Indexing Engine" src="https://pganalyze.com/static/ee5678252ea399d1f0c81e7264640c69/1d69c/pganalyze_webinar_how-to-reason-about-indexing-your-postgres-database.png" srcset="/static/ee5678252ea399d1f0c81e7264640c69/4dcb9/pganalyze_webinar_how-to-reason-about-indexing-your-postgres-database.png 188w, /static/ee5678252ea399d1f0c81e7264640c69/5ff7e/pganalyze_webinar_how-to-reason-about-indexing-your-postgres-database.png 375w, /static/ee5678252ea399d1f0c81e7264640c69/1d69c/pganalyze_webinar_how-to-reason-about-indexing-your-postgres-database.png 750w, /static/ee5678252ea399d1f0c81e7264640c69/78797/pganalyze_webinar_how-to-reason-about-indexing-your-postgres-database.png 1125w, /static/ee5678252ea399d1f0c81e7264640c69/21b4d/pganalyze_webinar_how-to-reason-about-indexing-your-postgres-database.png 1280w" sizes="(max-width: 750px) 100vw, 750px" loading="lazy" decoding="async"/>
    </span></a>
</p>
<p>On June 16th, 2022, we hosted a webinar and walked through our approach for creating the best Postgres indexes, and our thinking behind the new pganalyze Indexing Engine.</p>
<p>You can watch the webinar here: <a href="https://www.youtube.com/watch?v=o0HrXM1thYI">Webinar Re-Run: How to reason about indexing your Postgres database</a>.</p></div></div><div><h3>Sign up for the pganalyze newsletter</h3><p>Receive infrequent emails about interesting Postgres content around the web, new pganalyze feature releases, and new pganalyze ebooks. No spam, we promise.</p></div></div>
  </body>
</html>
