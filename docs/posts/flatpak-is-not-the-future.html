<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ludocode.com/blog/flatpak-is-not-the-future">Original</a>
    
    <div id="readability-page-1" class="page">

<a href="https://ludocode.com/">← ludocode.com</a>


<p>
Original date: 2021-11-18</p>
<p>Deploying apps for the Linux desktop is hard. A major problem has historically been library compatibility. Different Linux distributions, and even different versions of the same distribution, have had incompatible libraries. Unfortunately, there hasn’t always been a culture of backwards compatibility on the Linux desktop.</p>
<p>This is finally changing. The stability of the Linux desktop has dramatically improved in recent years. Core library developers are finally seeing the benefits of maintaining compatibility. Despite this, many developers are not interested in depending on a stable base of libraries for binary software. Instead, they have decided to ignore and override almost all libraries pre-installed on the user’s system.</p>
<p>The current solutions involve packaging entire alternate runtimes in containerized environments. <a href="https://www.flatpak.org/">Flatpak</a>, <a href="https://snapcraft.io/">Snap</a>, <a href="https://appimage.org/">AppImage</a>, <a href="https://www.docker.com/">Docker</a>, and <a href="https://store.steampowered.com/">Steam</a>: these all provide an app packaging mechanism that replaces most or all of the system’s runtime libraries, and they now all use containerization to accomplish this.</p>
<p>Flatpak calls itself “the future of application distribution”. I am not a fan. I’m going to outline here some of the technical, security and usability problems with Flatpak and others. I’ll try to avoid addressing “fixable” problems (like theming) and instead focus on fundamental problems inherent in their design. I aim to convince you that these are not the future of desktop Linux apps.</p>
<h2 id="size">Size</h2>
<p>Suppose you want to make a simple calculator app. How big should the download be?</p>
<p>At the time of this writing, the latest <a href="https://appimage.github.io/KCalc/">KCalc AppImage</a> (if you can even figure out <a href="https://github.com/AppImage/appimage.github.io/blob/master/data/KCalc">how to download it</a>) is 152 MB. For a <em>calculator</em>.</p>
<figure>
<img src="https://ludocode.com/assets/blog/flatpak-kcalc.png" alt="A screenshot of KCalc, a calculator app."/><figcaption aria-hidden="true">A screenshot of KCalc, a calculator app.</figcaption>
</figure>
<p>This is uncompetitive with Windows on its face. If I ship an app for Windows I don’t have to include the entire Win32 or .NET runtimes with my app. I just use what’s already on the user’s system.</p>
<p>Other solutions like Flatpak or Steam download the runtime separately. Your app metadata specifies what runtime it wants to use and a service downloads it and runs your app against it.</p>
<p>So how big are these runtimes? On a fresh machine, install <a href="https://flathub.org/apps/details/org.kde.kcalc">KCalc from Flathub</a>. You’re looking at a nearly 900 MB download to get your first runtime. <em>For a calculator</em>.</p>
<pre><code>        ID                                      Branch    Op   Remote    Download
 1.     org.freedesktop.Platform.GL.default     20.08     i    flathub   &lt; 106.4 MB
 2.     org.freedesktop.Platform.VAAPI.Intel    20.08     i    flathub    &lt; 11.6 MB
 3.     org.freedesktop.Platform.openh264       2.0       i    flathub     &lt; 1.5 MB
 4.     org.kde.KStyle.Adwaita                  5.15      i    flathub     &lt; 6.6 MB
 5.     org.kde.Platform.Locale                 5.15      i    flathub   &lt; 341.4 MB (partial)
 6.     org.kde.Platform                        5.15      i    flathub   &lt; 370.1 MB
 7.     org.kde.kcalc.Locale                    stable    i    flathub   &lt; 423.1 kB (partial)
 8.     org.kde.kcalc                           stable    i    flathub     &lt; 4.4 MB</code></pre>
<p>Note that the app package itself is only 4.4 MB. The rest is all redundant libraries that are already on my system. I just ran the <code>kcalc</code> binary straight out of its Flatpak install path unsandboxed and let it use my native libraries. It ran just fine, because all of the libraries it uses are backwards compatible.</p>
<p>Flatpak wants to download 3D drivers, patented video codecs, themes, locales, Qt 5, KDE 5, GTK 3, ICU, LLVM, ffmpeg, Python, and everything else in <code>org.kde.Platform</code>, all to run a calculator. Because unlike AppImage, the runtime isn’t stripped down to just what the app needs. It’s got every dependency for any app. It’s an entire general-purpose OS on top of your existing OS.</p>
<h4 id="sharing-runtimes">Sharing Runtimes?</h4>
<p>Flatpak says this is so that apps can share runtimes. But the whole point of their runtime system is to let apps use different runtimes. Each branch of a runtime (representing, say, a different base version of Ubuntu) is a completely independent runtime image.</p>
<p>They claim that they deduplicate runtimes. I question how much can really be shared between different branches when everything is recompiled. How much has <code>/usr</code> changed between releases of Ubuntu? I would guess just about all of it.</p>
<p>Steam at least fares somewhat better. The Soldier runtime is a 610 MB download, still large. But Steam only publishes a couple of official runtimes, so most games do actually share runtimes.</p>
<p>Flatpak allows anyone to define their own runtimes. <a href="https://docs.flatpak.org/en/latest/available-runtimes.html">freedesktop.org publishes some Flatpak runtimes</a> for common use, but these aren’t necessarily the ones apps are using. For example Fedora publishes apps with its own runtimes, and these are the ones available by default in its Software store.</p>
<p>If you install GIMP in Fedora 34’s Software store, it defaults to Fedora’s Flatpak of GIMP. This pulls in Fedora 35’s 650 MB runtime, not any freedesktop.org runtime. Nothing will be shared with our freedesktop runtime KCalc we installed from Flathub earlier. On my machine <code>/var/lib/flatpak</code> is using over 3 GB of disk space for just these two apps.</p>
<p>This is apparently working as intended. They want runtimes to be a free-for-all, filling your hard drive with gigabytes of custom junk for every app. I can’t imagine what system updates will be like in the future when you have a few dozen apps storing tens of gigabytes of runtimes that all want to be kept up to date.</p>
<h4 id="disk-space-is-cheap">“Disk space is cheap!”</h4>
<p>They say disk space is cheap. This is not true, not for the root devices of modern computers. Built-in storage has in fact been shrinking.</p>
<p>Software has gotten so much slower and more bloated that operating systems no longer run acceptably on spinning rust. Laptop manufacturers are switching to smaller flash drives to improve performance while preserving margins. Budget laptops circa 2015 shipped with 256 GB or larger mechanical drives. Now in 2021 they ship with 120 GB flash. NVMe drives are around $100/TB and laptop manufacturers inflate these prices 500% or more so upgrading a new laptop can be pricey.</p>
<p>Chromebooks are even smaller as they push everything onto cloud storage. Smartphones are starting to run full-fledged Linux distributions. The <a href="https://www.raspberrypi.com/products/raspberry-pi-4-model-b/">Raspberry Pi 4</a> and <a href="https://www.raspberrypi.com/products/raspberry-pi-400/">400</a> use an SD card as root device and have such fantastic performance that we’re on the verge of a revolution in low-cost computing. Surely Flatpak should be usable on these systems! There is no reason why a 16 GB root device shouldn’t fit every possible piece of non-game software we could want. Flatpak isn’t part of the revolution; it’s holding it back.</p>
<p>Why shouldn’t storage shrink anyway? <a href="https://tonsky.me/blog/disenchantment/">Software should be getting more efficient, not less.</a> Even if bandwidth were free and hard drives grew on trees, it would not excuse such drastic bloat. The waste involved in these app packaging solutions is downright offensive. Apollo landed on the moon with 4 kB of RAM and 72 kB of ROM, yet we can’t run a calculator with less than 150 MB. Any engineer worth his salt should be optimizing for efficiency, not dismissing it as irrelevant, especially when it so clearly impacts the user experience.</p>
<h4 id="memory-usage-startup-time">Memory Usage, Startup Time</h4>
<p>The penalties of huge alternate runtimes aren’t just in storage and bandwidth.</p>
<p>Each app with a new runtime adds another hundred megs or more of RAM usage. This adds up fast. Most computers don’t have enough RAM to run all their apps with alternate runtimes. The Raspberry Pi 400 has only 4 GB of RAM. Low-end Chromebooks have only 2 GB. Budget laptops tend to have 8 GB, mostly thanks to the bloat of Windows 10, but these app packaging solutions are catching up to it.</p>
<p>A bigger problem is that these apps can actually take several seconds to start up. They have to load all their own libraries from disk instead of using what’s already on the system, already in memory.</p>
<p>Snap is the slowest of all, largely because it stores all its data in squashfs images. Snap mounts all registered snaps at startup instead of just extracting the metadata they need beforehand, possibly in an effort to mitigate this slowness. They’re just moving part of the slow startup time to the boot time of your computer. All sorts of snap crap now shows up in <code>mount</code> and <code>fdisk -l</code>. The more snaps you have installed, the slower your computer will start, even if you don’t use them.</p>
<p>Today, on my machine, the KCalc Snap takes a full seven seconds to start up. Not just the first time after boot; every time, without fail. Seven seconds to start a calculator.</p>
<p>Canonical started converting their basic desktop apps like the GNOME Calculator to Snap in Ubuntu 18.04. The user experience was so terrible that they <a href="https://old.reddit.com/r/linux/comments/fa8ewy/ubuntu_2004_lts_to_revert_gnome_calculator_and/">quietly converted them back to normal apps</a> in Ubuntu 20.04. If these technologies are not even good enough for their own apps, those as basic as a calculator, why would they be good enough for yours?</p>
<h2 id="drivers">Drivers</h2>
<p>A major problem with alternate runtimes is drivers. New graphics hardware needs new graphics libraries which have a ton of dependencies. Mesa depends on LLVM for compiling shaders. The NVidia driver depends on a kernel module whose version must exactly match that of the library. All of these libraries have their own transitive dependencies like libdrm, libstdc++ and glibc. If you want new hardware to work, you need to be using new versions of all of these libraries.</p>
<p>Linux distributions, especially those with rolling releases or <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Ubuntu-20.04.3-LTS-Coming">hardware enablement packages</a>, do a great job of keeping these libraries up-to-date for new hardware. Bundled runtimes do not.</p>
<p>Take a look at <a href="https://www.youtube.com/watch?v=KrbWbBYAolo&amp;t=111s">the pain Steam has to go through to get drivers working</a> in the Steam Runtime. They use various heuristics to determine whether to override each library in the runtime with that of the host system, so each app is running on a Frankenstein hodge-podge of libraries. This is not the way to build stable software.</p>
<p>Flatpak recognizes that mixing libraries with the host system is a mess. Instead, they want to bundle their own graphics drivers in the runtimes, keeping them regularly updated for new hardware. But they can’t control the most important part, the kernel, so they can’t directly package drivers that depend on specific kernel versions or proprietary kernel modules. So the runtime is broken into <a href="https://blogs.gnome.org/alexl/2015/09/23/playing-games-with-runtime-extensions/">extensions</a>, and extensions can go the Steam route of pulling in the native driver or even download specific NVidia drivers on-the-fly to match the kernel module.</p>
<p><a href="https://github.com/AppImage/pkg2appimage/blob/master/excludelist">AppImage mixes host libraries with the runtime as well</a>, but not dynamically; they just decide what to exclude at packaging time so it’s even less reliable than Steam. <a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/overview.html">Docker has an NVidia toolkit</a> that must be installed on both the host system and the containerized runtime to get drivers working. <a href="https://discourse.ubuntu.com/t/the-graphics-core20-snap-interface/23000">Snap is doing who knows what.</a> None of these are proper solutions.</p>
<p>Drivers are supposed to be the responsibility of the operating system. This is what it’s good at. Why are we working so hard to get around what the operating system offers by default for native apps?</p>
<p>This isn’t an issue specific to video games by the way. Lots of modern apps are now directly using hardware accelerated graphics, even <a href="https://github.com/alacritty/alacritty#readme">terminals</a> and <a href="https://www.sublimetext.com/blog/articles/hardware-accelerated-rendering">text editors</a>. Many apps need the GPU for background computation. Productivity apps like video editors, apps that use machine learning, scientific tools like space/astronomy visualization, anything that does 3D like Google Earth… All of these need access to modern video hardware. This will only grow as apps get faster and provide more features and richer user interfaces.</p>
<h2 id="security">Security</h2>
<p>Flatpak allows apps to declare that they need full access to your filesystem or your home folder, yet graphical software stores still claim such apps are sandboxed. This has been <a href="https://flatkill.org/2020/">discussed before</a>. Here’s what happens when I search GIMP in the Software app on a fresh install of Fedora 34:</p>
<figure>
<img src="https://ludocode.com/assets/blog/flatpak-gimp-sandboxed.png" alt="Fedora claims GIMP is sandboxed. If you click “High” next to “Permissions”, you see a little exclamation mark saying it has “File system” permissions."/><figcaption aria-hidden="true">Fedora claims GIMP is sandboxed. If you click “High” next to “Permissions”, you see a little exclamation mark saying it has “File system” permissions.</figcaption>
</figure>
<p>Such an app can drop a malware executable anywhere in your home folder and add a line to your <code>~/.profile</code> or a desktop entry to <code>~/.config/autostart/</code> to have it auto-started on your next login. Not only will it run outside of any container, it will even persist after the app is uninstalled.</p>
<p>This is exactly what a nefarious app would do to break out of its sandbox. This is also what a virus would do that exploited a security vulnerability in a sandboxed app.</p>
<p>Suppose libjpeg has a zero-day remote code execution vulnerability. You open a seemingly innocuous JPEG in Flatpak GIMP and it drops its payload set to autostart in your home folder. How did the sandbox help here? The behaviour of this virus is identical regardless of whether GIMP is sandboxed. The only differences are that a) the libjpeg in the alternate runtime is likely to stay out-of-date longer than the one from your Linux distribution; and b) the virus is more likely to work against the sandboxed app because all installations will be using the exact same binary of libjpeg.</p>
<p>The Snap Store app, to its credit, displays a warning: “This application is unconfined. It can access all personal files and system resources.” Which apps display this warning, you ask? All of them. KCalc has it. All of the Editor’s Picks have it. In my testing for this blog post I could not find an app that does not display the warning.</p>
<h4 id="its-better-than-nothing">“It’s better than nothing!”</h4>
<p>Flatpak and Snap apologists claim that some security is better than nothing. This is not true. From a purely technical perspective, for apps with filesystem access the security is exactly equal to nothing. In reality it’s actually worse than nothing because it leads people to place more trust than they should in random apps they find on the internet.</p>
<p>Take a look at <a href="https://www.techrepublic.com/article/why-i-have-a-problem-with-appimages-on-linux/">this writer</a> complaining about the security of AppImages while praising Flatpak and Snap:</p>
<blockquote>
<p>I install applications via source, apt, Snap and Flatpak–I don’t discriminate. As long as an application will install and run as expected, I’ll install it, regardless of the package format.</p>
<p>With one exception: AppImages.</p>
<p>[…]</p>
<p>On the rare occasion I’m willing to use an AppImage, I will only do so when I absolutely trust the developer. Why? Remember, an AppImage is an application you simply download and run. Anyone can build an AppImage, proclaim it a must-have piece of software, roll something nefarious into it, and make it available for download.</p>
</blockquote>
<p>He expresses deep skepticism of AppImages, but not of Flatpaks or Snaps, because he believes their security measures keep him safe. This is the danger of lying about sandboxing.</p>
<h4 id="permissions-and-portals">Permissions and Portals</h4>
<p>Flatpak is working on a <a href="https://docs.flatpak.org/en/latest/sandbox-permissions.html">fine-grained permission system</a> to improve the security of its sandbox. Permissions are things like whether the app is allowed to access the microphone or the printer. Portals are things like a file open dialog that runs outside the sandbox, so the app in the sandbox gets only the file the user chose.</p>
<p>Flatpak documents these portals and provides <a href="https://github.com/flatpak/libportal">libportal</a>, a client library to access them. However this isn’t really intended for individual apps. It’s all meant to be integrated in the toolkits. From the <a href="https://docs.flatpak.org/en/latest/sandbox-permissions.html#portals">documentation</a>:</p>
<blockquote>
<p>Interface toolkits like GTK3 and Qt5 implement transparent support for portals, meaning that applications don’t need to do any additional work to use them (it is worth checking which portals each toolkit supports).</p>
</blockquote>
<p>Apparently, developing client APIs for apps themselves is antithetical to Flatpak’s mission. They want the apps running on Flatpak to be unaware of Flatpak. They would rather modify the core libraries like GTK to integrate with Flatpak. So for example if you want to open a file, you don’t call a Flatpak API function to get a file or request permissions. Instead, you call for an ordinary GTK file open dialog and your Flatpak runtime’s GTK internally does the portal interaction with the Flatpak service (using all sorts of hacks to let you access the file “normally” and pretend you’re not sandboxed.)</p>
<p>This is the most complicated and brittle way to implement this. It’s also not at all how other sandboxed platforms work. If I want file access permissions on Android, I don’t just try to open a file with the Java File API and expect it to magically prompt the user. I have to call <a href="https://developer.android.com/training/permissions/requesting">Android-specific APIs to request permissions first</a>. iOS is the same. So why shouldn’t I be able to just call <code>flatpak_request_permission(PERMISSION)</code> and get a callback when the user approves or declines?</p>
<p><a href="https://www.youtube.com/watch?v=faqQuJkqCIA&amp;t=1347s">This is why.</a> Fedora is auto-converting all of their rpm apps to Flatpak. In order for this to work, they need the Flatpak permission system and Flatpak in general to require no app changes whatsoever.</p>
<p>Why on Earth would they do a mass automatic conversion of apps? Your guess is as good as mine. The video claims that Fedora’s apps are higher quality than upstream, and Fedora makes their Flatpaks available on older distributions. I think it’s more likely they just want huge numbers of auto-converted apps to make it look like Flatpak is useful. Whatever the reason, it’s clear that this requirement has influenced many of their poor design decisions.</p>
<h4 id="identifier-clashes">Identifier Clashes</h4>
<p>So Fedora auto-converts all its apps to Flatpak. Does it at least namespace them to something specific to Fedora?</p>
<p>No, it doesn’t. Fedora publishes its Flatpak of GIMP as <code>org.gimp.GIMP</code>. This conflicts with the official <code>org.gimp.GIMP</code> published by the GIMP developers on Flathub. On a fresh install of Fedora 34, if you add the Flathub repository and type <code>flatpak install org.gimp.GIMP</code>, you get prompted for which one to install:</p>
<pre><code>[<a href="https://ludocode.com/cdn-cgi/l/email-protection" data-cfemail="bdd3d4ded6fddbd8d9d2cfdc">[email protected]</a> active]$ flatpak install org.gimp.GIMP
Looking for matches…
Remotes found with refs similar to ‘org.gimp.GIMP’:

   1) ‘fedora’ (system)
   2) ‘flathub’ (system)

Which do you want to use (0 to abort)? [0-2]:</code></pre>
<p>If you choose option 1, you get a build of GIMP with Fedora’s patches that uses the 650 MB Fedora 35 runtime. If you choose option 2, you get a different build of GIMP that uses the 1.8 GB freedesktop.org GNOME runtime.</p>
<p>Isn’t the whole point of <a href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation">reverse DNS</a> that the <code>org.gimp</code> prefix is reserved for people who actually own the <code>gimp.org</code> domain? How can Fedora justify publishing apps while masquerading as the upstream developers? If major Linux distributions won’t even respect DNS, who will?</p>
<p>Flathub doesn’t enforce DNS ownership either by the way. They let anyone publish anything; they merely <a href="https://github.com/flathub/flathub/wiki/App-Submission#someone-else-has-put-my-app-on-flathubwhat-do-i-do">prefer</a> that apps are controlled by their authors. A sane security strategy would be to require a DNS challenge to allow a publisher to use a specific app prefix.</p>
<h2 id="complexity">Complexity</h2>
<p>Endless articles have been written about the importance of simplicity in software design. <a href="https://www.dreamsongs.com/RiseOfWorseIsBetter.html">Worse is Better</a> is perhaps the earliest example. A modern refrain is “<a href="https://www.infoworld.com/article/3639050/complexity-is-killing-software-developers.html">software complexity is killing us</a>”. The state of software development is downright miserable in 2021.</p>
<p>You would think that these packaging mechanisms would embrace simplicity if they want to attract software developers. In fact they are doing the opposite. The driver, sandboxing, and permission/portal issues we’ve discussed barely scratch the surface of the complexity involved in making this all work. In “worse is better” terms, they’re not even “the right thing” anymore. At this point they’re just pushing complexity for its own sake.</p>
<p>Proponents of containerization believe it is the solution to every problem, the hammer for every nail. We now have multiple Linux distributions based on containerizing everything (e.g. <a href="https://getfedora.org/coreos">Fedora CoreOS</a>, <a href="https://www.mocaccino.org/">MocaccinoOS</a>.) We have a major movement to adopt Docker and Snap on embedded (e.g. <a href="https://www.balena.io/os/">balenaOS</a>, <a href="https://ubuntu.com/core">Ubuntu Core</a>.) Docker may soon be running on your fridge and in your car.</p>
<p>Keep watching <a href="https://www.youtube.com/watch?v=KrbWbBYAolo&amp;t=760s">the video linked earlier</a> to see the descent into madness: Steam nested in a Flatpak; the Scout runtime nested in the Soldier runtime pulling in drivers from the Freedesktop runtime; Steam making IPC calls to its Flatpak container to make parallel containers with yet more runtimes.</p>
<figure>
<img src="https://ludocode.com/assets/blog/flatpak-and-steam.jpg" alt="Various combinations of Steam and Flatpak containers and runtimes. Not pictured: Steam and the game running directly on the user’s native environment, like they do on every other OS."/><figcaption aria-hidden="true">Various combinations of Steam and Flatpak containers and runtimes. Not pictured: Steam and the game running directly on the user’s native environment, like they do on every other OS.</figcaption>
</figure>
<p>The complexity gets far worse than the above video even shows. Flatpak uses <a href="https://ostreedev.github.io/ostree/">libostree</a> to store all its data in a content-addressible deduplicated layer above the filesystem. Steam now uses <a href="https://www.youtube.com/watch?v=Koy71b_AjmU">libcapsule</a> which uses <code>dlmopen()</code> namespaces so that game executables and driver libraries can load different versions of libstdc++ into the same process. We haven’t even talked about Wine/Proton which is a whole other layer of crazyness.</p>
<p>This is a vivid example of software complexity taking us to the brink of <a href="https://www.youtube.com/watch?v=ZSRHeXYDLko">collapse</a>. This is the most complicated way imaginable to distribute software. What will happen when large numbers of apps have been shipped that depend on this scaffolding? How will this ever be maintained? How many people on Earth will truly understand how this all works?</p>
<h2 id="services">Services</h2>
<p>All of these app packaging systems require that the user have some service installed on their PC before any packages can be installed.</p>
<p>AppImage, to its credit, technically does not require a service to run apps, but it <a href="https://docs.appimage.org/user-guide/run-appimages.html#integrating-appimages-into-the-desktop">doesn’t integrate with the desktop without it</a>. I needed to use an AppImage app for a while and my solution was to just leave it in my <code>~/Downloads</code> folder and double click it from my file manager to run it. This is a terrible user experience.</p>
<p>All of the desktop integration (launcher entries, mimetypes, icons, updates) is provided by either <code>appimaged</code> or AppImageLauncher, one of which must be installed by the user for any of this to work. So in practice, AppImage is no different than any of our other solutions: it requires a service to be usable.</p>
<p>If a user doesn’t have the service, well that’s another hoop they have to jump through to install an app. A few distributions, notably Fedora, pre-install Flatpak. A few distributions, notably Ubuntu, pre-install Snap. SteamOS pre-installs Steam. Other than these special cases, users have to install the correct service before installing an app. Developers have to teach them to do so and lose all of the users who can’t figure it out or can’t be bothered.</p>
<h4 id="app-stores">App Stores</h4>
<p>A major goal of most of these technologies is to support an “app store” experience: <a href="https://hub.docker.com/">Docker Hub</a>, <a href="https://flathub.org/home">Flathub</a>, the <a href="https://store.steampowered.com/">Steam Store</a>, <a href="https://snapcraft.io/">Snapcraft</a>, and <a href="https://appimage.github.io/">AppImageHub</a> (but not <a href="https://www.appimagehub.com/">AppImageHub</a>?) These technologies are all designed around this model because the owners want a cut of sales revenue or fees for enterprise distribution. (Flathub only says they don’t process payments <a href="https://github.com/flathub/flathub/wiki/App-Submission"><em>at present</em></a>. It’s coming.)</p>
<p>This is the real reason Ubuntu wants everyone to use Snap instead of helping us build apps that run natively on Ubuntu. This is also why they keep the Snap server source code closed. They want it to be “open” the way Android is “open”, where there is only one official store and sideloading apps is as annoying as possible.</p>
<p>This is very far from the traditional Windows experience of just downloading an installer, clicking Next a few times, and having your app installed with complete desktop integration. This is true freedom. There are no requirements, no other steps, no hoops to jump through to install an app. This is why the Windows Store and to some extent even the macOS App Store are failing. They can’t compete with the freedom their own platforms provide.</p>
<p>I know free software and privacy people don’t want to allow proprietary apps this level of freedom on their PCs. But the vast majority of users and independent software vendors don’t care. What users want is easy (and efficient!) installation. What the biggest software vendors want is the freedom to ship software directly to customers, without the intervention of a service or hub.</p>
<p>This is indeed possible on the Linux desktop. Let’s talk about that in the next section.</p>
<h2 id="the-current-state-of-backwards-compatibility">The Current State of Backwards Compatibility</h2>
<p>There seems to be a collective trauma in the Linux community in depending on libraries to remain binary compatible across distributions and version upgrades. These alternate runtime tools are clearly built by people who refuse to consider using <em>anything</em> on the user’s system (in the case of Flatpak, not even driver libraries.) It’s true that in the past, open source library ABIs were flaky. I’m here to tell you that you no longer have to be afraid.</p>
<p>The backwards compatibility situation has gotten much better in recent years. The Linux kernel has been slowly exporting its legendary culture of backwards compatibility up the stack. Core libraries like glibc (since 2.1) and libstdc++ (since GCC 5) are intending to remain backwards compatible indefinitely. <a href="https://en.wikipedia.org/wiki/Freedesktop.org">freedesktop.org</a> has made huge progress standardizing runtime environments across distributions. Debian and others have mostly stopped making ABI-breaking customizations to their packages. Websites like <a href="https://abi-laboratory.pro/">ABI Laboratory</a> track ABI changes to provide early warnings of breaks. The Linux Standard Base (LSB), though now seemingly defunct, made significant progress in standardizing capabilities and preventing ABI breakage.</p>
<p>Just in the past week, I’ve used several Linux apps distributed as plain binary tarballs that run on my native environment. The generic Linux binary releases of <a href="https://github.com/diasurgical/devilutionX">DevilutionX</a> and <a href="https://cdn.openttd.org/openttd-releases/12.1/openttd-12.1-linux-generic-amd64.tar.xz">OpenTTD</a> use my native SDL for graphics, sound and input. <a href="https://code-industry.net/masterpdfeditor/">Master PDF Editor</a> uses a long list of native libraries including Qt 5. The <a href="https://blackberry.qnx.com/en/embedded-software/qnx-software-development-platform">QNX Software Center</a> was compiled for the LSB and uses my native GTK 3. These run perfectly, no alternate runtime needed. Why? Because most libraries today are actually decently backwards compatible.</p>
<p><a href="https://gog.com">GOG.com</a>’s strategy for Linux support is just about the opposite of Steam’s, and works just like traditional installers for Windows. Each game is built for a particular Ubuntu LTS release: 14.04, 16.04, 18.04. As long as your libraries are at least that new, the game will run. They ship self-extracting install wizards built with <a href="https://icculus.org/mojosetup/">mojosetup</a>, which is a bit like the Windows-based <a href="https://en.wikipedia.org/wiki/Wise_Solutions">WISE</a> or <a href="https://en.wikipedia.org/wiki/InstallShield">InstallShield</a> installers of old (except they don’t require root access.) You download and run the installer as your normal user, hit Next-&gt;Next-&gt;Next and your game is installed. Full desktop integration, no giant alternate runtimes, no root permissions, no service required. Any ISV can ship software this way: just a self-installing executable shipped directly to users.</p>
<p>It’s not perfect. In particular mojosetup doesn’t install missing dependencies (yet) and GOG doesn’t totally follow the XDG specs for install paths (yet). These are minor, fixable problems, nothing on the scale of Flatpak. This is <em>simple</em>, this is true freedom, and the contrast in user experience is striking. I would take a mojosetup installer over an AppImage or Flatpak or Steam any day of the week.</p>
<p>For developers, yes, this may be harder than making an AppImage. There will still be occasional bugs that crop up between library versions. There will still be occasional differences between distributions. These are things you can work around. It may be painful at first but it will be worth it: you will provide a much superior user experience by working around the issues with your users’ libraries rather than attempting to replace them.</p>
<h4 id="forcing-distributions-to-maintain-compatibility">Forcing Distributions to Maintain Compatibility</h4>
<p>The backwards compatibility situation will continue to get better with time. The more proprietary software is shipped for the native Linux desktop, the less likely major distributions will accept upstream breakage. Imagine if millions of office workers used Excel on Ubuntu. How loudly do you think businesses would complain if a distribution upgrade broke it?</p>
<p>In 2014, Linus Torvalds suggested that <a href="https://www.youtube.com/watch?v=5PmHRSeA2c8&amp;t=648s">Valve could save the Linux desktop</a>. He hoped they would publish a large volume of proprietary games that depended on the Linux desktop core libraries, finally forcing distributions to preserve their ABI. Unfortunately, as he predicted, that didn’t happen. Instead of relying on the native runtime libraries Steam replaced most of them with its own.</p>
<p>Steam needed to replace some libraries to make games work back in 2012. Today this is no longer necessary. So why are they still pushing their runtimes? How much progress could we make if Steam deprecated their runtimes, abandoned containerization for new games, and let all new games just use the native system libraries? How loudly do you think gamers would complain if a distribution upgrade broke their favourite game?</p>
<p>A few years ago Canonical decided to drop 32-bit libraries from Ubuntu 19.10. After much outrage, including <a href="https://itsfoss.com/ubuntu-19-10-drops-32-bit-support/">Wine and Steam threatening to drop support for Ubuntu</a>, they reversed their decision. Imagine how stable Ubuntu could be if Steam games depended on even more of the system libraries.</p>
<p>To any library developers reading this, it’s hard to over-emphasize how important backwards compatibility is to the popularity of a platform. Backwards compatibility is a major part of why Windows is still the dominant desktop OS. Microsoft has managed to keep the Win32 API stable for over 25 years. GUI apps built for Windows 95 still work out of the box on Windows 10. Businesses actually care about this! They use ancient proprietary software that is critical to their business whose source code has long been lost to the sands of time. A platform that breaks their software is no platform at all.</p>
<h4 id="the-gtk-problem">The GTK problem</h4>
<p>There is one glaring exception to my claims regarding Linux library stability. That exception is GTK. <a href="https://blogs.gnome.org/mortenw/2014/06/23/how-does-one-create-a-gtk-application/">GTK famously breaks their libraries</a> with reckless abandon. This has historically been one of the biggest problems with shipping a binary app for Linux.</p>
<p>I believe this is partly due to a militant position on free software. Some advocates believe so strongly that users should be able to recompile their software that they force them to do so. They break libraries seemingly on purpose just to say, “Recompile! Oh you can’t? That’ll teach you to use binary software!” Of course users don’t want to recompile their software, but what users actually want is usually lost on GNOME developers.</p>
<p>With the recent release of GTK 4, there is little reason to believe the situation will improve. At one point they proposed <a href="https://davmac.wordpress.com/2016/07/05/why-do-we-keep-building-rotten-foundations/">bumping the soname on all major <em>and minor</em> releases</a>. Thankfully they have <a href="https://blog.gtk.org/2016/09/01/versioning-and-long-term-stability-promise-in-gtk/">reversed course</a>, but their latest versioning scheme still indicates their desire to accelerate the pace of major releases, allowing them to more frequently make breaking changes and remove deprecated functions. They do at least intend to remain ABI stable within a major release series, but given their track record, by the time anyone trusts GTK 4 to remain stable it will be obsolete.</p>
<p>This sounds like bad news, but there is a silver lining here: while they’re mucking about with GTK 4, they <em>aren’t</em> breaking GTK 3.</p>
<p>The ongoing transition to GTK 4 gives us an opportunity here. The GTK 3 ABI is finally a stable target, and it’s still pre-installed in most distributions because lots of built-in apps haven’t upgraded yet. If we can get a sufficient number of binary apps depending on it, distributions will be forced to maintain it and even pre-install it “forever”, the same way Microsoft maintains the Win32 API “forever”.</p>
<p>I strongly recommend that all app developers (open source or otherwise) delay upgrading to GTK 4 as long as possible. The longer we can delay the switch, the more stable GTK 3 will be. If the GTK team want us to use GTK 4, they will need to prove its stability over many years, not simply replace it with GTK 5.</p>
<p>I’m not saying GTK 3 is good. All I’m saying is it exists. No other toolkit can claim to be practical for desktop apps <em>and</em> relatively stable <em>and</em> pre-installed on the vast majority of Linux desktops. We all hope something better will come along one day but in the meantime GTK 3 is what we’ve got.</p>
<p>There has never been a better time to ship a binary app that targets the Linux desktop. And I don’t mean targets its own bundled runtime; I mean truly targets the user’s runtime environment. The time is now.</p>
<h2 id="is-flatpak-fixable">Is Flatpak Fixable?</h2>
<p>Here’s the thing. I actually think <a href="https://github.com/containers/bubblewrap">Bubblewrap</a>, the sandboxing tool used by Flatpak (and now Steam), is pretty good. It’s the key technology to make app sandboxing good enough to compete with Android or iOS. If it was used to hide sensitive stuff like <code>/home</code> but otherwise just mounted the native <code>/usr</code> straight into the sandbox, it could be great. Unfortunately, Flatpak does the exact opposite.</p>
<p>If the Flatpak developers truly want an app distribution system that rivals Android and iOS, the sandbox, permissions and portal system should be the only focus.</p>
<p>They should:</p>
<ul>
<li>Abandon everything related to runtimes, and instead mount the native <code>/usr</code> (or a restricted set of core libraries from <code>/usr</code>) read-only into each container;</li>
<li>Add metadata to Flatpaks to declare library dependencies that the Flatpak service will install with the host distribution’s package manager (perhaps with generated <a href="https://help.ubuntu.com/community/MetaPackages">meta-packages</a> that can be cleanly removed);</li>
<li>Build a fine-grained user-interactive runtime permission system that requires the app to make Flatpak-specific API calls to activate permission dialogs; and</li>
<li>Deprecate install-time permissions (especially filesystem access) and remove all apps from Flathub that use them.</li>
</ul>
<p>Under this system, apps would be encouraged to statically link many of their dependencies, but use the system GTK/Qt/SDL, OpenGL/Vulkan, OpenSSL/curl, and other large or security-critical libraries. The community could maintain guidelines and wrappers to make apps that dynamically link against the system libraries cross-version and cross-distribution. Apps would be expected to make changes to run sandboxed and request permissions directly through a Flatpak client API.</p>
<p>This is much more akin to how iOS and Android work. But it means abandoning like 95% of Flatpak. It would be such a drastic change that they might as well start over under a different name. I don’t see it happening.</p>
<p>An app store based on a sandboxing technology for native apps is a reasonable idea. I certainly don’t think it should be used for everything though. I don’t think it’s at all necessary for software like Excel or Photoshop. Users do not care about sandboxing those sorts of apps and their vendors will refuse to be sandboxed anyway.</p>
<p>But for small apps and games from independent developers, a proper sandboxed app marketplace can in theory increase their reach. It can eliminate much of the trust that would otherwise be necessary to run them on your computer and can bring native apps closer to the ease of use of web apps.</p>
<p>It’s certainly not easier for developers, but good native apps still provide such a vastly better user experience than web apps that it’s possible a proper sandboxed app store can create a resurgence in native apps. Microsoft obviously failed with their attempt, but macOS kind of didn’t. Maybe there is a way Linux can succeed as well.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Snap and Flatpak in their current incarnations have been around for at least five years. AppImage, Steam and Docker have been around even longer. None of the above is new. The problems with alternate runtimes were known from the very beginning, yet little progress has been made in fixing them. I don’t believe these are growing pains of a new technology. These are fundamental problems that are mostly not fixable.</p>
<p>All of these technologies are essentially building an entire OS on top of another OS just to avoid the challenges of backwards compatibility. In doing so, they create far more problems than they solve. Problems of compatibility are best solved by the OS, the real one, not some containerized bastardization on top. We need to make apps that run natively, that use the system libraries as much as possible. We need to <a href="https://www.youtube.com/watch?v=ZSRHeXYDLko&amp;t=3176s">drastically simplify everything</a> if we have any hope of attracting proprietary software to Linux.</p>
<p>If you are a Linux distribution maintainer, please understand what all of these solutions are trying to accomplish. All your hard work in building your software repository, maintaining your libraries, testing countless system configurations, designing a consistent user experience… they are trying to throw all of that away. Every single one of these runtime packaging mechanisms is trying to subvert the operating system, replacing as much as they can with their own. Why would you support this?</p>
<p>I implore you, do not use these packaging tools. Don’t add their services to your Linux distributions, don’t use apps packaged this way, and don’t ship apps that use them. Mass containerization and alternate runtimes cannot possibly be the future of desktop apps on Linux. If this is really the direction it’s going, the future will be so shitty that we’ll all end up back on macOS or Windows.</p>
<p>Personally, I’m much more interested in how to get Excel and Photoshop on Linux rather than untrustworthy drive-by apps and games, so I don’t really care about sandboxing, permissions, portals, app stores, alternate runtimes or really any of the stuff Flatpak does. Those are all counter-productive to convincing Microsoft and Adobe to port their software suites to Linux. Attracting these vendors will only happen by empowering them with a stable platform, not locking them in a box.</p>
<p>In future posts I’ll be going over some of the problems with targeting desktop Linux directly, presenting some of the stuff I’m working on, and hopefully coming up with real solutions that don’t depend on alternate runtimes.</p>
<p><em>Updates: A link to libportal was added, a reference to AppImageLauncher was added, and the description of GTK 4’s versioning scheme was corrected.</em></p>




</div>
  </body>
</html>
