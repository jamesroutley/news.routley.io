<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.brimdata.io/blog/introducing-zq/">Original</a>
    <h1>Zq: An easier and faster alternative to jq</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    
    <p>If you’ve ever had the need to query or transform large amounts
of JSON data, you’ve undoubtedly turned to the phenomenal
and ubiquitous tool <a href="https://stedolan.github.io/jq/">jq</a>.</p>
<p>Yet your first experience trying out jq was probably a bit challenging.</p>
<p>Its syntax is powerful but also terse and arguably a little too clever.
It’s kind of like a Unix pipeline but not really.</p>
<p>Don’t get me wrong. jq is awesomely useful.
But overall, it just feels a bit too hard.</p>
<h2 id="deciphering-jq">Deciphering jq</h2>
<p>So, how about we bite the bullet and just RTFM?</p>
<p>Okay, fine. But if you can remember the first time you skimmed
the <a href="https://stedolan.github.io/jq/manual/">jq manual</a>,
it probably felt like you needed to already know how jq worked
in order to understand what the jq manual was saying.</p>
<p>“Everything is a filter” doesn’t quite do it for me.</p>
<h2 id="any-good-tutorials">Any Good Tutorials?</h2>
<p>We figured <em>someone out there</em> must have already cracked the code and
explained it all. And sure enough, there’s a ton of great content in various places on jq.</p>
<p>If you poke around and search <a href="https://news.ycombinator.com/">Hacker News</a>
you’ll quickly find Adam Gordon Bell’s masterfully written article
<a href="https://earthly.dev/blog/jq-select/">An Introduction to JQ</a>.
As Bell points out, the solution to your jq programming problem is usually
just a Google search away.</p>
<p>If you’re more of a visual learner, Szymon Stepniak has some excellent
introductory videos. Just search for
<a href="https://www.youtube.com/results?search_query=szymon+jq">“szymon jq” on YouTube</a>.</p>
<h2 id="learning-the-terse-syntax">Learning the Terse Syntax</h2>
<p>These tutorials do a great job explaining jq’s terse syntax and guiding
you through a number of useful query patterns.</p>
<p>They explain what <code>.</code> is. And how the selector-style syntax <code>.a.b.c</code>
can be used to dereference a path through a nested JSON object. And how <code>.</code>
isn’t just the dereference operator but also refers to the top-level value, e.g.,
when <code>.</code> is an array you can index it with <code>.[1]</code> and slice it with <code>.[1:2]</code>.</p>
<p>They also show how <code>[]</code> is a postfix
operator that iterates over the elements of an array or the values of an object:</p>
<pre tabindex="0"><code>$ echo &#39;{&#34;array&#34;:[1,2]}&#39; | jq &#39;.array[]&#39;
1
2
$ echo &#39;{&#34;object&#34;:{&#34;a&#34;:1,&#34;b&#34;:2}}&#39; | jq &#39;.object[]&#39;
1
2
</code></pre><p>They explain how you can construct arrays a little bit like JavaScript:</p>
<pre tabindex="0"><code>$ echo &#39;1 2&#39; | jq &#39;[0,.]&#39;
[
  0,
  1
]
[
  0,
  2
]
</code></pre><p>and how to construct objects also like Javascript:</p>
<pre tabindex="0"><code>$ echo &#39;1 2&#39; | jq &#39;{x:.,y:(2*.)}&#39;
{
  &#34;x&#34;: 1,
  &#34;y&#34;: 2
}
{
  &#34;x&#34;: 2,
  &#34;y&#34;: 4
}
</code></pre><h2 id="but-the-model">But the model…?</h2>
<p>After you put in a little time learning this ingeniously terse syntax,
jq gets quite a bit easier… <em>as long as your problem matches a cookie-cutter pattern</em>
that you can find with Google or copy from a cheat sheet.</p>
<p>But when you can’t find the pattern you’re looking for,
jq is still really hard.</p>
<p>For a long time, I thought it was <em>the syntax</em> that was hard. But after learning
the syntax and studying the jq manual quite a bit,
I realized it was still hard and that the difficulty must lie somwhere else.</p>
<h2 id="stateless-dataflow">Stateless Dataflow</h2>
<p>After thinking about it, I realized I didn’t understand at all what jq was
really doing under the covers. It’s one thing to see an example and blindly
copy a code pattern to get the desired result. It’s another to really understand
the underlying <em>computational model</em>.</p>
<p>After studying the manual and the tutorials and running copious experiments
with jq’s <code>debug</code> filter, I think I’ve learned enough
to describe jq’s computational model as: <em>stateless dataflow</em>.</p>
<p>The jq model embodies <em>dataflow</em> in the sense that you can feed jq a sequence of values,
have it operate on those values, and emit the sequence of results, e.g.,</p>
<pre tabindex="0"><code>$ echo &#39;1 2 3&#39; | jq .+1
2
3
4
</code></pre><p>but it’s <em>stateless</em> in the sense that you cannot combine those values
in a meaningful way; in other words, you cannot carry state across
the sequence of values.</p>
<p>Curiously, if you try to, say, add up the input with an intuitive move like
this you get some pretty cryptic error messages:</p>
<pre tabindex="0"><code>$ echo &#39;1 2 3&#39; | jq add
jq: error (at &lt;stdin&gt;:1): Cannot iterate over number (1)
jq: error (at &lt;stdin&gt;:1): Cannot iterate over number (2)
jq: error (at &lt;stdin&gt;:1): Cannot iterate over number (3)
</code></pre><h2 id="slurp-it">Slurp It</h2>
<p>A jq pro would say “Of course that doesn’t work. The <code>add</code>
filter takes an array and you need to slurp the input into an array.”</p>
<p>Okay, let’s try out that pattern by specifying <code>-s</code> to slurp.
Sure enough this gives the correct answer:</p>
<pre tabindex="0"><code>$ echo &#39;1 2 3&#39; | jq -s add
6
</code></pre><p>But this doesn’t actually make the computation stateful, right? Instead, it simply
transforms the input from a sequence of discrete values (numbers) into a single
composite value (an array of numbers).</p>
<p>Indeed, this slurping command mode simply transforms the three input values into a single
array value as can be seen here:</p>
<pre tabindex="0"><code>$ echo &#39;1 2 3&#39; | jq -s .
[
  1,
  2,
  3
]
</code></pre><p>In other words, the slurped form is equivalent to this non-slurped form
operating on an array:</p>
<pre tabindex="0"><code>echo &#39;[1,2,3]&#39; | jq add
</code></pre><p>So, it appears you can emulate stateful dataflow by wrapping each
filter’s result in a single but arbitrarily large array value.</p>
<h2 id="emulating-stateful-dataflow">Emulating Stateful Dataflow</h2>
<p>Okay, now it’s clear: jq is hard because
you often want to do stateful things with a bunch
of computed values <em>but the dataflow model is stateless</em>.</p>
<p>It’s not the syntax that’s hard to learn; it’s the computational model.</p>
<p>To work around this statelessness, you can wrap a sequence of independent values
into an array, iterate over the array, then wrap that result back up
into another array so you can pass the entire sequence as a single value
downstream to the “next filter”.</p>
<p>To make this all concrete, suppose the input is a sequence of arrays of numbers
and the problem is to add up all the numbers across all the arrays.</p>
<p>Your first stab at this might be:</p>
<pre tabindex="0"><code>$ echo &#39;[1,2,3] [4,5,6]&#39; | jq add
6
15
</code></pre><p>But because the model is stateless, you get a separate answer for each input array,
which isn’t our desired result.</p>
<p>Okay, no problem just wrap those results into an array <code>[6,15]</code> and apply
<code>add</code> to that array and we get:</p>
<pre tabindex="0"><code>$ echo &#39;[1,2,3] [4,5,6]&#39; | jq &#39;[add] | add&#39;
6
15
</code></pre><p>What the heck? That didn’t work. Let’s debug this by taking off the final <code>add</code>:</p>
<pre tabindex="0"><code>$ echo &#39;[1,2,3] [4,5,6]&#39; | jq &#39;[add]&#39;
[
  6
]
[
  15
]
</code></pre><p>Hmm, we get two singleton arrays.</p>
<p>But of course!  This is the stateless model at work.</p>
<p>jq is
running the entire computation for each input value separately, and we are
wrapping each scalar result in its own array.</p>
<p>To remedy this, let’s slurp this input into
an array giving us an array of arrays then we will iterate over each
array adding up the elements.</p>
<p>As a first step, this gives us the single array we desired:</p>
<pre tabindex="0"><code>$ echo &#39;[1,2,3] [4,5,6]&#39; | jq -s &#39;[.[] | add]&#39;
[
  6,
  15
]
</code></pre><p>And, now we can apply the <code>add</code> filter to this output, arriving at
the desired result:</p>
<pre tabindex="0"><code>$ echo &#39;[1,2,3] [4,5,6]&#39; | jq -s &#39;[.[] | add] | add&#39;
21
</code></pre><p>Who knew adding up numbers could be so hard?</p>
<h2 id="scaling-slurp">Scaling Slurp</h2>
<p>Okay, we can use slurp to emulate stateful dataflow but it has a problem:
jq must read <em>all of the input into memory</em> to construct the single input
array value.</p>
<p>Computers these days have a lot of memory and for many practical use cases,
this memory consumption is just fine, but when you want to apply stateful
operations to large collections of JSON,
e.g., stored as <a href="http://ndjson.org/">newline-delimited JSON</a>,
this approach can become problematic.</p>
<p>The good news is jq has yet another pattern to work around this.
This little gem solves our problem from above in a different way:</p>
<pre tabindex="0"><code>echo &#39;[1,2,3] [4,5,6]&#39; | jq -n &#39;reduce inputs as $array (0; .+($array|add))&#39;
</code></pre><p>which streams the input into the query and gives the the correct answer of <code>21</code>.</p>
<p>What’s going on here?!</p>
<p>We’ll leave it as an exercise for the reader as to why this query works and how a
<a href="https://stedolan.github.io/jq/manual/#Advancedfeatures">reduce filter</a>
and the <a href="https://stedolan.github.io/jq/manual/#IO">inputs filter</a>
(which incidentally requires the <a href="https://stedolan.github.io/jq/manual/#Invokingjq">-n option</a> here),
all work together to solve our problem.</p>
<p>But here’s the key point: this is still confusing and hard!</p>
<p>If you want to solve stateful problems,
you have to mix and match the right command-line options with pretty confusing
jq filters to emulate stateful dataflow.</p>
<p>Could there be a better way?</p>
<h2 id="enter-zq">Enter zq</h2>
<p>In the <a href="https://zed.brimdata.io/docs">Zed project</a>,
we’ve developed a command-line tool called
<a href="https://zed.brimdata.io/docs/commands/zq/">zq</a>
(and, yes, the name “zq” is a play on “jq”) that is based on an orthogonal
set of dataflow operators.</p>
<p>Zed operators are like jq filters but
they can be <em>stateful</em>. To make this work, we simply borrowed the aggregate function
concept from the 50 year-old SQL model, though unlike SQL,
<a href="https://zed.brimdata.io/docs/language/aggregates/">Zed aggregate functions</a> can
<a href="https://zed.brimdata.io/docs/language/overview/#610-aggregate-function-calls">stream their results incrementally</a>.</p>
<p>In short, zq is based on <em>stateful dataflow</em> while jq is based on <em>stateless dataflow</em>.</p>
<h2 id="installing-zq">Installing zq</h2>
<p>To demonstrate Zed’s stateful dataflow model,
we’ll run through a number of concepts using zq.
If you want to follow along here, feel free to <a href="https://zed.brimdata.io/docs/install/">install the zq command</a>.</p>
<p>While zq supports a number of data formats, in this article, we’ll just use JSON.
To this end, all the examples here run zq with the <code>-j</code> flag to indicate JSON.</p>
<h2 id="stateful-dataflow">Stateful Dataflow</h2>
<p>In a nutshell, <em>stateful dataflow</em> means you can carry state across input values.
So with zq, we can easily add up a sequence of numbers without putting them in
an array, e.g.,</p>
<pre tabindex="0"><code>$ echo &#39;1 2 3&#39; | zq -j &#39;sum(this)&#39; -
{&#34;sum&#34;:6}
</code></pre><p>Note that <code>this</code> is like <code>.</code> in jq.</p>
<p>This use of <code>sum</code> here is like the SQL aggregate function <code>sum</code> though SQL doesn’t have the concept
of <code>this</code> as you must instead explicitly reference columns in tables.
That is, if a column <code>x</code> has the values 1, 2, and 3,
and you say <code>SELECT SUM(x)</code> you would get the same answer as above.</p>
<p>With zq, this SQL pattern would appear as Zed record values
that are operated upon via the field <code>x</code> instead of top-level values:</p>
<pre tabindex="0"><code>$ echo &#39;{&#34;x&#34;:1}{&#34;x&#34;:2}{&#34;x&#34;:3}&#39; | zq -j &#39;sum(x)&#39; -
{&#34;sum&#34;:6}
</code></pre><p>To do this with jq, you have to slurp the input objets and emulate stateful dataflow:</p>
<pre tabindex="0"><code>$ echo &#39;{&#34;x&#34;:1}{&#34;x&#34;:2}{&#34;x&#34;:3}&#39; | jq -s &#39;[.[].x] | add | {sum:.}&#39;
{
  &#34;sum&#34;: 6
}
</code></pre><p>Would you rather say <code>sum(x)</code> or <code>[.[].x] | add | {sum:.}</code>?</p>
<p>Are you starting to get why the stateless model of jq is difficult?</p>
<h2 id="the-over-operator">The <code>over</code> Operator</h2>
<p>After working on the Zed language for a couple of years,
we recently realized there was an important piece missing:
the ability to flexibly navigate over complex nested values.</p>
<p>We looked at a number of related approaches but most of them felt pretty
awkward. Various SQL approaches to JSON involve easy-enough syntax extensions to extract
nested JSON, but when it comes to unrolling nested structure, the patterns
seemed quite confusing: lateral flattens and joins with magic
ways to reference the inter-related subquery components.</p>
<p>Instead, we turned to jq for inspiration. As described above, jq’s syntax can be terse and
the dataflow model hard to understand, but the core mechanisms for traversing
nested JSON values are brilliant.</p>
<p>Following jq’s lead, we adopted an iteration operator that could generate a
subsequence of values from any complex value.  That derived sequence could then be
operated upon by an arbitrary set of Zed dataflow operators. But unlike jq,
the Zed iterator streams its output continuously (like all other Zed operators)
so the input sequence need not be wrapped in arrays to produce stateful results.</p>
<p>The <code>over</code> operator is a bit like jq’s <code>[]</code> iterator, e.g., in jq, you might say:</p>
<pre tabindex="0"><code>echo &#39;[1,2,3]&#39; | jq .[]
</code></pre><p>while in zq you would say</p>
<pre tabindex="0"><code>echo &#39;[1,2,3]&#39; | zq &#39;over this&#39; -
</code></pre><p>And they both give:</p>
<pre tabindex="0"><code>1
2
3
</code></pre><p>The difference here, though, is that zq’s sequence of iterated numbers can be
operated upon in stateful ways, e.g.,</p>
<pre tabindex="0"><code>$ echo &#39;[1,2,3]&#39; | zq -j &#39;over this | sum(this)&#39; -
{&#34;sum&#34;:6}
</code></pre><p>Yet with jq, once you iterate over the array and send each number to a
downstream filter, you cannot carry state across values.</p>
<h2 id="generalizing-over">Generalizing <code>over</code></h2>
<p>The nice thing about <code>over</code> and zq is that any and all Zed operators can appear
downstream of the <code>over</code> expression. In other words, <em>any dataflow computation whatsoever</em>
can be performed upon the sequence of iterated values not just inputs that
fit into a memory-resident array.</p>
<p>Thus summing the numbers in the array of arrays from above can simply be
expressed as:</p>
<pre tabindex="0"><code>$ echo &#39;[1,2,3] [4,5,6]&#39; | zq -j &#39;over this | sum(this)&#39; -
{&#34;sum&#34;:21}
</code></pre><p>Here, the <code>over</code> operator turns the array sequences into the continuous sequence
<code>1,2,3,4,5,6</code> which is then summed up by the aggregate function.</p>
<h2 id="lateral-scopes">Lateral Scopes</h2>
<p>What if in the example above, we actually wanted to preserve the array boundaries
like jq’s default behavior? This is where dataflow gets tricky: you want to have
fine-grained control of how complex nested values are iterated over while also having
precise access to fixed values nested above the iterated components.</p>
<p>Instead of always transforming <code>[1,2,3][4,5,6]</code> into the flattened sequence <code>1,2,3,4,5,6</code> you
may want to create two subsequences <code>1,2,3</code> and <code>4,5,6</code> that are each operated upon
to completion like jq.</p>
<p>After experimenting with several different structures for this, we landed
upon the idea of “lateral scopes” that work in tandem with the <code>over</code> operator.
To create a lateral scope you use the syntax <code>=&gt; ( ... )</code> as in</p>
<pre tabindex="0"><code>$ echo &#39;[1,2,3] [4,5,6]&#39; | zq -j &#39;over this =&gt; (sum(this))&#39; -
{&#34;sum&#34;:6}
{&#34;sum&#34;:15}
</code></pre><p>You can put any set of dataflow operators in the lateral scope (not just array functions like jq)
and the scope’s output may be fed to any subsequent set of dataflow
operators, which in turn, may also be <em>stateful</em>.</p>
<p>For example, if we wanted to compute the average of the sums, we can simply tack
on a stateful <code>avg</code> aggregate function:</p>
<pre tabindex="0"><code>$ echo &#39;[1,2,3] [4,5,6]&#39; | zq -j &#39;over this =&gt; (sum(this)) | avg(sum)&#39; -
{&#34;avg&#34;:10.5}
</code></pre><p>Compare this with jq, where you have to slurp the entire input into an array
and wrap partial results in partial-result arrays to emulate stateful dataflow.</p>
<pre tabindex="0"><code>$ echo &#39;[1,2,3] [4,5,6]&#39; | jq -s &#39;[.[] | add] | {avg:(add/length)}&#39;
{
  &#34;avg&#34;: 10.5
}
</code></pre><h2 id="flattening-nested-values">Flattening Nested Values</h2>
<p>A common problem with managing JSON data in analytics systems is unwinding
or flattening nested arrays into flattened sets of “rows”. This is where
lateral scopes come in handy.</p>
<p>Consider this simple example JSON pattern:</p>
<pre tabindex="0"><code>{&#34;name&#34;:&#34;foo&#34;,&#34;vals&#34;:[1,2,3]}
</code></pre><p>and suppose we want to convert every input like this into a sequence of flattened
output values that looks like this:</p>
<pre tabindex="0"><code>{&#34;name&#34;:&#34;foo&#34;,&#34;val&#34;:1}
{&#34;name&#34;:&#34;foo&#34;,&#34;val&#34;:2}
{&#34;name&#34;:&#34;foo&#34;,&#34;val&#34;:3}
</code></pre><p>Using a lateral scope, we can traverse the <code>vals</code> array, import the <code>name</code>
value into the scope, then in that scope,
refer to each value as <code>this</code> and the imported value as <code>name</code>,
and thus produce a flattened output value with a record constructor from
inside the scope.</p>
<p>The zq query looks like this:</p>
<pre tabindex="0"><code>over vals with name =&gt; ({name,val:this})
</code></pre><p>The <em>with clause</em> is used to bring the <code>name</code> value into the lateral scope as
the value for <code>this</code> in the outer scope is different from iterated values of
<code>this</code> in inner scope.</p>
<p>Here is the idea in action:</p>
<pre tabindex="0"><code>$ echo &#39;{&#34;name&#34;:&#34;foo&#34;,&#34;vals&#34;:[1,2,3]} {&#34;name&#34;:&#34;bar&#34;,&#34;vals&#34;:[4,5]}&#39; | zq -j &#39;over vals with name =&gt; ({name,val:this})&#39; -
{&#34;name&#34;:&#34;foo&#34;,&#34;val&#34;:1}
{&#34;name&#34;:&#34;foo&#34;,&#34;val&#34;:2}
{&#34;name&#34;:&#34;foo&#34;,&#34;val&#34;:3}
{&#34;name&#34;:&#34;bar&#34;,&#34;val&#34;:4}
{&#34;name&#34;:&#34;bar&#34;,&#34;val&#34;:5}
</code></pre><p>In contrast, we might use this jq query pattern to solve this unflattening problem:</p>
<pre tabindex="0"><code>$ echo &#39;{&#34;name&#34;:&#34;foo&#34;,&#34;vals&#34;:[1,2,3]} {&#34;name&#34;:&#34;bar&#34;,&#34;vals&#34;:[4,5]}&#39; | jq &#39;to_entries | {name:.[0].value,val:.[1].value[]}&#39;
</code></pre><h2 id="so-you-like-chocolate-or-vanilla">So you like chocolate or vanilla?</h2>
<p>In this case, jq statelessness works pretty well but it comes down to a matter
of taste.</p>
<p>Do you like chocolate or vanilla?</p>
<p>Which query would you rather write?</p>
<pre tabindex="0"><code>to_entries | {name:.[0].value,val:.[1].value[]}
</code></pre><p>or</p>
<pre tabindex="0"><code>over vals with name =&gt; ({name,val:this})
</code></pre><p>We think the latter is more intutitive. Once you learn how lateral scopes
work with <code>over</code>, queries like this are easy to write. It’s fairly easy to commit
this programming pattern to muscle memory.</p>
<p>On the other hand, with jq, you need to figure out to use a
filter like <code>to_entries</code>, look in the manual to refresh your memory,
then you’ll probably need to run</p>
<pre tabindex="0"><code>echo &#39;{&#34;name&#34;:&#34;foo&#34;,&#34;vals&#34;:[1,2,3]} {&#34;name&#34;:&#34;bar&#34;,&#34;vals&#34;:[4,5,6]}&#39; | jq &#39;to_entries&#39;
</code></pre><p>to look out the resulting output structure of <code>to_entries</code> and finally,
you can craft your downstream filter.</p>
<h2 id="a-practical-example">A Practical Example</h2>
<p>The examples above are all a bit contrived, so let’s wrap up with some real-world data.</p>
<p>We’ll use the data and final query from
<a href="https://e.printstacktrace.blog/parsing-json-in-command-line-with-jq-basic-filters-and-functions-part-1/">Szymon Stepniak’s cookbook</a>, which in turn uses the public <a href="https://openlibrary.org/">OpenLibrary API</a>.</p>
<p>The data for his example is easy to grab with <code>curl</code>. Just run:</p>
<pre tabindex="0"><code>curl -s &#34;http://openlibrary.org/search.json?q=st%C4%99pniak&#34; &gt; openlibrary.json
</code></pre><p>Please have a look at Stepniak’s article if you’d like to see in detail how
he reasoned through the building blocks to create this non-trivial query:</p>
<pre tabindex="0"><code>[.docs[] | {title,author_name: .author_name[0], publish_year: .publish_year[0]} | select(.author_name!=null and .publish_year!=null)] | group_by(.author_name)| [.[] | {author_name: .[0].author_name, count: . | length}] | sort_by(.count) | reverse | limit(3;.[])
</code></pre><p>This query</p>
<ul>
<li>iterates over the field <code>docs</code>, which is an array, pulling out relevant fields,</li>
<li>filters null values out,</li>
<li>puts all these results in an array result to emulate stateful data flow,</li>
<li>performs a group-by arrangement of the array,</li>
<li>iterates over the group-by result to compute a count of the number of publications by author,
and puts this result into another array again emulating stateful data flow,</li>
<li>sorts this array by the count field,</li>
<li>reverses the array elements,</li>
<li>then limits the output to the first three elements given the top-publications by author.</li>
</ul>
<p>Running this (as of the data obtained on April 19, 2022)…</p>
<pre tabindex="0"><code>jq &#39;[.docs[] | {title,author_name: .author_name[0], publish_year: .publish_year[0]} | select(.author_name!=null and .publish_year!=null)] | group_by(.author_name)| [.[] | {author_name: .[0].author_name, count: . | length}] | sort_by(.count) | reverse | limit(3;.[])&#39; openlibrary.json
</code></pre><p>gives the following results:</p>
<pre tabindex="0"><code>{
  &#34;author_name&#34;: &#34;S. Stepniak&#34;,
  &#34;count&#34;: 38
}
{
  &#34;author_name&#34;: &#34;Władysław Stępniak&#34;,
  &#34;count&#34;: 7
}
{
  &#34;author_name&#34;: &#34;Władysław Stępniak&#34;,
  &#34;count&#34;: 4
}
</code></pre><p>This is a surprise! The answer here differs from the results in the cookbook article,
and oddly here, there are two line items for the same name “Władysław Stępniak”!</p>
<p>We will get back to this glitch in a second, but let’s have a look how
you would write this same query in zq. Here it is:</p>
<pre tabindex="0"><code>over docs
| {title, author_name: author_name[0], publish_year: publish_year[0]}
| has(author_name) and has(publish_year)
| count() by author_name | sort -r count | head 3
</code></pre><p>We use the <a href="https://zed.brimdata.io/docs/language/operators/over/">over</a> iterator,
<a href="https://zed.brimdata.io/docs/language/overview/#6112-record-expressions">a record constructor</a>,
the <a href="https://zed.brimdata.io/docs/language/functions/has/">has</a> function for missing fields/nulls,
the <a href="https://zed.brimdata.io/docs/language/aggregates/count/">count</a> aggregate function,
and the Unix-like <a href="https://zed.brimdata.io/docs/language/operators/sort/">sort</a>
and <a href="https://zed.brimdata.io/docs/language/operators/head/">head</a> operators.</p>
<p>If we put the above query in a file called <code>query.zed</code> and run this:</p>
<pre tabindex="0"><code>zq -j -I query.zed openlibrary.json
</code></pre><p>we get the following result:</p>
<pre tabindex="0"><code>{&#34;author_name&#34;:&#34;S. Stepniak&#34;,&#34;count&#34;:38}
{&#34;author_name&#34;:&#34;Władysław Stępniak&#34;,&#34;count&#34;:11}
{&#34;author_name&#34;:&#34;Andrzej Stępniak&#34;,&#34;count&#34;:4}
</code></pre><p>This time the answer looks a bit
more reasonable as there aren’t redundant <code>author_name</code> values from the group-by.</p>
<p>But why are the two answers different?</p>
<p>After a little sleuthing, we discovered that the problem in the jq query
arises from <a href="https://en.wikipedia.org/wiki/Unicode_equivalence">Unicode equivalence</a>,
i.e., there are two different ways to encode the <code>ł</code> character. As a result, jq
places the different Unicode strings into two different group-by buckets.</p>
<p>This surprising behavior can be reproduced with this simple jq command:</p>
<pre tabindex="0"><code>$ jq -n &#39;&#34;Władysław Stępniak&#34;==&#34;Władysław Stępniak&#34;&#39;
false
</code></pre><p>The strings appear the same but their equality test is false!</p>
<p>Welcome to the world of messy data.</p>
<h2 id="cleaning-up-the-unicode-strings">Cleaning up the Unicode strings</h2>
<p>So what should we do here?</p>
<p>To avoid such problems, zq uses <a href="https://en.wikipedia.org/wiki/Unicode_equivalence#Normalization">Unicode normalization</a>
so that the two variations of the same string are treated equally thus giving
the “correct answer”. In fact,</p>
<pre tabindex="0"><code>zq &#39;yield &#34;Władysław Stępniak&#34;==&#34;Władysław Stępniak&#34;&#39;
</code></pre><p>produces <code>true</code>, as it should.</p>
<p>It would be nice if jq could normalize Unicode strings at least
with a helper function, but after poking
around a bit, I couldn’t find any related support.</p>
<p>However, zq supports this just fine. So, let’s just pass the JSON data through
zq before processing it with jq, and voila, jq now gives the correct answer!</p>
<pre tabindex="0"><code>$ zq -j openlibrary.json | jq &#39;[.docs[] | {title,author_name: .author_name[0], publish_year: .publish_year[0]} | select(.author_name!=null and .publish_year!=null)] | group_by(.author_name)| [.[] | {author_name: .[0].author_name, count: . | length}] | sort_by(.count) | reverse | limit(3;.[])&#39;
{
  &#34;author_name&#34;: &#34;S. Stepniak&#34;,
  &#34;count&#34;: 38
}
{
  &#34;author_name&#34;: &#34;Władysław Stępniak&#34;,
  &#34;count&#34;: 11
}
{
  &#34;author_name&#34;: &#34;Andrzej Stępniak&#34;,
  &#34;count&#34;: 4
}
</code></pre><h2 id="but-is-it-really-faster">But is it Really Faster?</h2>
<p>The title of this article implies parenthetically that zq is faster
than jq but we haven’t addressed performance in the examples above.</p>
<p>We will cover zq’s performance in a future article,
but to cut to the chase here, zq is almost always at least a bit faster
than jq when processing JSON inputs, and it is remarkably faster (5-100X)
if you process data in Zed’s native format
<a href="https://zed.brimdata.io/docs/formats/zng/">ZNG</a>.</p>
<p>If you’d like to learn more, there are some
<a href="https://zed.brimdata.io/docs/commands/zq/#7-performance">performance comparisons</a>
in the <a href="https://zed.brimdata.io/docs/commands/zq/">zq documentation</a>.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>Okay, this is all a lot to digest, and we’ve just scratched the surface
of zq and the Zed project.  Given this short introduction, we hope you’ll
agree that we’ve tackled some of the harder-to-use aspects of jq.</p>
<p>The point here isn’t that zq is a cool and fun tool. Of course it is, but more broadly,
we have a very serious ambition: to make data 10X easier than it is today,
changing the way people approach data problems and meaningfully improving
the economics of data systems.</p>
<p>The dichotomy between schema-flexible JSON and schema-rigid relational
tables pervades the modern data stack and frankly makes things hard and brittle.
We’ll write about this in future articles but our view is that today’s solutions
for fitting JSON into tables or running SQL queries over JSON are like <em>putting a square
peg in a round hole</em>. There’s a ton of duct tape out there.</p>
<p>It’s hard to make things easy, and with zq and Zed, we’re trying to make exploring,
transforming, and managing data even easier than jq. If you could run jq-like
queries at cloud warehouse scales, wouldn’t that be powerful? No need to define
tables and schemas every time you want to look at a new and different set of data.</p>
<p>These topics and more will all be laid out in forthcoming articles over the comings
months. In the meantime, if you want to learn more about Zed:</p>
<ul>
<li><a href="https://zed.brimdata.io/docs/">check out our docs</a>,</li>
<li><a href="https://zed.brimdata.io/docs/install/">install the Zed software</a>, and/or</li>
<li><a href="https://www.brimdata.io/join-slack/">join our public Slack team</a>.</li>
</ul>
<p>We love working with all our users to help guide us to the best ways to solve
your real, everyday problems. Give us a holler and we look forward to chatting.</p>

  </article>
</div></div>
  </body>
</html>
