<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://holtwick.de/en/blog/localfirst-resilient-sync">Original</a>
    <h1>Resilient Sync for Local First</h1>
    
    <div id="readability-page-1" class="page"><div><p>When I started programming in the 80s, the situation was simple: data was written to a file on a local disk. If files needed to be exchanged, a floppy disk was simply inserted into another computer and edited.</p><p>Later, floppy disks and CD drives disappeared and files were either exchanged by e-mail or the data was stored directly on a server. Even Microsoft Word moved to the cloud at some point.</p><p>However, moving data from the local computer to the cloud created new problems. What if the provider closed its service? However, it was not only data loss, but also being trapped by the provider because the data could no longer be retrieved from the service that increasingly became a problem for some and a business model for others.</p><h2 id="local-first" tabindex="-1"><a href="#local-first">Local-First</a></h2><p>The <a href="https://localfirstweb.dev/" rel="noopener" target="_blank">local-first movement</a> wants to bring the data back to the user while retaining the advantages of the internet. A robust and widely accepted solution has been found for the simultaneous processing of data with <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type" rel="noopener" target="_blank">CRDT</a>, but not yet for the exchange of data. This is because it is not (yet) possible to do completely without services on a server. Even with peer-to-peer, where the devices mainly communicate directly with each other, the connection must be mediated by servers at the beginning.</p><p>In an ideal local-first world, the following criteria should be met with regard to the exchange of data:</p><ol><li>data is processed and stored locally (offline).</li><li>the sync can be interrupted for a longer period of time, but data can be processed locally during this time and still be identical everywhere after a new sync (CRDT).</li><li>data should not be visible on the move (E2EE).</li></ol><p>And I would also like to add:</p><ol start="4"><li>the whole thing should also work with the technology of the 80s.</li></ol><p>Why? For reasons of resilience, because there are many reasons why things could go offline.</p><h2 id="resilient-sync" tabindex="-1"><a href="#resilient-sync">Resilient Sync</a></h2><p>For this reason, I propose a data exchange format that works both in the file system and on the Internet. It should be so simple that the implementation can work on any underlying data carrier or service.</p><h3 id="log-of-changes" tabindex="-1"><a href="#log-of-changes">Log of changes</a></h3><p>To start with, each client writes a kind of simple, continuous log with the changes. We call the position of the changes <code>index</code> and it starts at <code>0</code> and continues in whole numbers: <code>0, 1, 2, 3, ...</code>. Usually these changes are CRDT compliant, but this is not significant for the protocol. This data can also be stored in encrypted form. Let’s call this <code>data</code>.</p><p>Each client is given a unique identifier, usually a unique ID (UUID), we call it <code>clientId</code>. The change logs are stored linked to the <code>clientId</code>. We will call a collection of such logs <code>workspace</code>.</p><p>We can enrich further data, such as a <code>timestamp</code>, which can be useful if we want to process the data changes historically or implement a kind of endless “undo”.</p><p>It is also conceivable that each new entry contains a hash of the previous entry in order to ensure data consistency in the style of a blockchain. Further refinements in the direction of the Merkle tree are also conceivable. However, a hash on the content of the current entry can also contribute to data security.</p><h3 id="assets%2C-blobs%2C-the-big-binary-chunks" tabindex="-1"><a href="#assets%2C-blobs%2C-the-big-binary-chunks">Assets, blobs, the big binary chunks</a></h3><p>The reality is that there is also larger data that rarely changes: Images, videos, audios, i.e. files. These are not part of the content changes and would quickly bring data synchronization to a standstill. In addition, they are not always needed immediately and could also be loaded “on demand”. I therefore suggest treating these files separately from the changes. Let’s call them <code>asset</code>.</p><p>But here, too, the data should be stored according to <code>clientId</code> and in ascending order with <code>index</code>. The data sets can thus refer to an asset, e.g. with a data entry in the form of a URL that contains all the necessary information:</p><h3 id="benefits" tabindex="-1"><a href="#benefits">Benefits</a></h3><p>The key advantage of this method is that we always know where the next data will appear. Because if a client has just written the index ‘123’, the next one will be ‘124’.</p><p>Why is this important? For the following reasons:</p><ol><li>we are not dependent on being notified of new data (“push”), but can also ask for it ourselves (“pull”).</li><li>we can load the individual entries even without knowing anything about their content. A sync can even take place without an intermediary having to “understand” the data.</li><li>we notice immediately if data is missing and can request it again.</li><li>the data can be replicated as often as required, there does not have to be just one sync source. It therefore makes sense to use it as a backup.</li><li>clients that do not have a direct connection to each other can use “stupid copying processes”.</li><li>data exchange can be easily and comprehensibly documented, which can be important when recognizing legally compliant stored data for tax and compliance purposes.</li><li>there are no conflicts when storing the data because it is only updated but never deleted (“append only”).</li></ol><h3 id="databases" tabindex="-1"><a href="#databases">Databases</a></h3><p>Let’s start with the implementation as a database. As described, a table with the following fields would be sufficient:</p><ul><li><code>index</code>: Integer</li><li><code>clientId</code>: String or integer</li><li><code>data</code>: String or binary</li><li><code>timestamp</code>: Integer (optional)</li><li><code>prevHash</code>: String or integer (optional)</li></ul><p>This would look similar for the assets.</p><p>Database can refer to both the local storage of the client, e.g. in the IndexedDB, and the storage on a synchronization server.</p><h3 id="filesystems" tabindex="-1"><a href="#filesystems">Filesystems</a></h3><p>The data is stored in a directory in a file system. Metadata, such as the <code>clientId</code> of the creator and details such as the encryption used, are stored in a JSON file called <code>index.json</code>.</p><p>These in turn each contain two directories:</p><ol><li><code>changes</code></li><li><code>assets</code></li></ol><p>The changes are recorded in <code>changes</code> and numbered consecutively. The same is done in <code>assets</code> with the binary data described.</p><p>Modern file systems have no significant restrictions on the number of files per directory, but it can’t hurt to limit the number anyway. The following algorithm in TypeScript ensures an even distribution:</p><pre tabindex="0"><code><span><span>/**</span></span>
<span><span> * Distribute file, named by natural numbers, in a way that each folder only</span></span>
<span><span> * contains `maxEntriesPerFolder` subfolders or files. Returns a list of</span></span>
<span><span> * names, where the last one is the file name, all others are folder names.</span></span>
<span><span> * </span></span>
<span><span> * Example: `distributedFilePath(1003)` results in `[&#39;2&#39;, &#39;1&#39;, &#39;3&#39;]` which </span></span>
<span><span> * could be translated to the file path `2/1/3.json`.</span></span>
<span><span> */</span></span>
<span><span>export</span><span> function</span><span> distributedFilePath</span><span>(</span><span>index</span><span>:</span><span> number</span><span>, </span><span>maxEntriesPerFolder</span><span>:</span><span> number</span><span> =</span><span> 1000</span><span>)</span><span>:</span><span> string</span><span>[] {</span></span>
<span><span>  if</span><span> (index </span><span>&lt;</span><span> 0</span><span>)</span></span>
<span><span>    throw</span><span> new</span><span> Error</span><span>(</span><span>&#39;Only numbers &gt;= 0 supported&#39;</span><span>)</span></span>
<span><span>  const</span><span> names</span><span>:</span><span> string</span><span>[] </span><span>=</span><span> []</span></span>
<span><span>  do</span><span> {</span></span>
<span><span>    names.</span><span>unshift</span><span>((index </span><span>%</span><span> maxEntriesPerFolder).</span><span>toString</span><span>())</span></span>
<span><span>    index </span><span>=</span><span> Math.</span><span>floor</span><span>(index </span><span>/</span><span> maxEntriesPerFolder)</span></span>
<span><span>  } </span><span>while</span><span> (index </span><span>&gt;</span><span> 0</span><span>)</span></span>
<span><span>  names.</span><span>unshift</span><span>(names.</span><span>length</span><span>.</span><span>toString</span><span>())</span></span>
<span><span>  return</span><span> names</span></span>
<span><span>}</span></span></code></pre><p>Source: <a href="https://github.com/holtwick/zeed/blob/master/src/common/data/distributed.ts" rel="noopener" target="_blank">zeed Framework</a></p><h3 id="online-services-and-peer-to-peer" tabindex="-1"><a href="#online-services-and-peer-to-peer">Online Services and Peer-To-Peer</a></h3><p>A suitable mix of the database or file system approach can be selected for online services, depending on which is better suited to the selected service. For Dropbox or WebDAV, for example, this would be the file system approach. For Apple CloudKit, the database approach.</p><p>But a simple service of your own is also conceivable, with a REST, WebSocket or other useful interfaces.</p><p>There is also no reason not to synchronize the data via peer-to-peer (P2P) or another local communication channel. After all, the data is identical and can therefore be synchronized with other clients via the fastest route. Redundancy is therefore an advantage and does not make things any more complicated. Theoretically, the sequence and multiple application of changes is also unproblematic with CRDT.</p><h2 id="refinements" tabindex="-1"><a href="#refinements">Refinements</a></h2><p>There is still potential for improvement in some areas:</p><ul><li>Control of data size per log entry. Collecting several changes for larger packages or splitting a change into several packages if the scope becomes too large.</li><li>Compression or summarization of data.</li><li>Announcement of new clients, e.g. through special log entries. Evaluation using cryptographic methods.</li><li>By adding a logical clock, such as the Lamport clock, entries can be sorted logically, thereby improving the chronology of an entry.</li><li>Writing the data in a single file per client for reasons of resource optimization.</li><li>Through the clever use of cryptographic means, it may even be possible to implement rights management (<a href="https://schmiste.github.io/srds06.pdf" rel="noopener" target="_blank">Cryptree</a>).</li></ul><h2 id="outlook" tabindex="-1"><a href="#outlook">Outlook</a></h2><p>I have been using this technique in my apps for several years, for example in the now completed project <a href="https://onepile.apperdeck.com/en/help/internal-file-format" rel="noopener" target="_blank">Onepile</a>. New projects using this approach will be published soon.</p><p>Simplicity and flexibility seem to me to be the biggest advantages of this approach. As a result, it should also be future-proof and be able to adapt quickly to new technical conditions.</p><p>The following diagram is an example of an ecosystem for a web app:</p><p><img src="https://avi.im/assets/R2v3-JcAT7JGs.png" alt="R2v3.png" width="2976" height="2536" loading="lazy"/></p><hr/><p>Related:</p><ul><li><a href="https://www.youtube.com/watch?v=NMq0vncHJvU&amp;t=2s" rel="noopener" target="_blank">Martin Kleppmann’s Talk on the Local-First Conference 2024 in Berlin</a></li><li><a href="https://elk.zone/mastodon.social/@martin@nondeterministic.computer/112639441984059657" rel="noopener" target="_blank">Matodon comment of Martin Kleppmann</a></li><li>A similar approach at <a href="https://github.com/MichaelMure/git-bug/blob/master/doc/model.md" rel="noopener" target="_blank">git-bug</a></li><li>This one came out the same day by tonsky:) <a href="https://tonsky.me/blog/crdt-filesync/" rel="noopener" target="_blank">“Local, first, forever”</a></li></ul></div></div>
  </body>
</html>
