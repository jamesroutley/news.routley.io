<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/vindarel/c1ef5e043773921e3b11d8f4fe1ca7ac">Original</a>
    <h1>Common Lisp vs Racket</h1>
    
    <div id="readability-page-1" class="page"><div id="file-common-lisp-vs-racket-testimonies-md-readme">
    <article itemprop="text"><h3 dir="auto"><a id="user-content-developer-experience-libraries-performance-202111" aria-hidden="true" href="#developer-experience-libraries-performance-202111"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Developer experience, libraries, performance… (2021/11)</h3>
<p dir="auto">I&#39;ll preface this with three things. 1. I prefer schemes over Common Lisps, and I prefer Racket of the Schemes. 2. There is more to it than the points I raise here. 3. I assume you have no previous experience with Lisp, and don&#39;t have a preference for Schemes over Common Lisp. With all that out of the way... I would say Common Lisp/SBCL. Let me explain</p>
<ol dir="auto">
<li>SBCL Is by far the most common of the CL implementations in 2021. It will be the easiest to find help for, easiest to find videos about, and many major open source CL projects are written using SBCL</li>
<li>Download a binary directly from the website <a href="http://www.sbcl.org/platform-table.html" rel="nofollow">http://www.sbcl.org/platform-table.html</a> (even for M1 macs) to get up and running (easy to get started)</li>
<li>Great video for setting up Emacs + Slime + Quick Lisp <a href="https://www.youtube.com/watch?v=VnWVu8VVDbI" rel="nofollow">https://www.youtube.com/watch?v=VnWVu8VVDbI</a></li>
</ol>
<p dir="auto">Now as to why Common Lisp over Scheme</p>
<ol dir="auto">
<li>A better developer experience. Emacs + Slime is way better development and debugging experience than either Emacs + Geiser, or Emacs + Racket-Mode or Drracket.</li>
<li>There are tons more libraries implementing hard things you don&#39;t want to reinvent yourself written in CL. (I run into this problem with Racket all the time)</li>
<li>The Performance of CL is much better than Scheme. One example is here <a href="https://github.com/luizsol/PrimesResult">https://github.com/luizsol/PrimesResult</a>. Lisp is 11, Chez scheme implementation is 40</li>
<li>Great books that deal with solving practical programming problems</li>
</ol>
<p dir="auto">I could go on, but I&#39;ll stop there. Now if you still want to use Scheme, Racket blows the other Schemes out of the water with what you get out of the box. […] But it is not without its problems.</p>
<p dir="auto"><a href="https://www.reddit.com/r/lisp/comments/qlcza4/best_lisp_dialect/hj22i7n/" rel="nofollow">https://www.reddit.com/r/lisp/comments/qlcza4/best_lisp_dialect/hj22i7n/</a></p>
<h3 dir="auto"><a id="user-content-horrible-interactive-experience-202111" aria-hidden="true" href="#horrible-interactive-experience-202111"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>&#34;horrible&#34; interactive experience (2021/11)</h3>
<p dir="auto">Except that Racket has horrible interactive development experience: authoritarian module system that prevents modification to the system, no condition/restart but just print you a trace, and little runtime inspector/debugger support (and it&#39;s probably impossible to add because modifying stack at runtime seems contradictory with its ideology). I find it unusable.</p>
<p dir="auto">Scheme itself is a nice language, and I find MIT/Scheme much more comfortable to use (for a traditional Lisper) overall, because of its inspectability, modifiability and a condition/restart system. And it has real first-class environment!</p>
<p dir="auto"><a href="https://www.reddit.com/r/lisp/comments/qlcza4/best_lisp_dialect/hj2kufx/" rel="nofollow">https://www.reddit.com/r/lisp/comments/qlcza4/best_lisp_dialect/hj2kufx/</a></p>
<hr/>
<blockquote>
<p dir="auto">Racket is a nice language with the batteries included and lots of polish aimed at attracting new developers. However, Common Lisp really is a superior language in almost every way. As mentioned, I am having mixed thoughts. I have been using Racket sparingly to get my feet wet for the past few months, and while it is nice, there is a lot to be missed from Common Lisp</p>
</blockquote>
<blockquote>
<p dir="auto">Deficiencies of Racket (compared to CL):</p>
<ul dir="auto">
<li>No built-in multi-methods and lots of super-specialized functions (the same functions but for lists, vectors, hashmaps etc; to be fair CL is not ideal here either).</li>
<li>No introspection compared to one with SLIME.</li>
<li>Debugger... well, essentially absent if you have to compare with CL</li>
<li>Module re-loading removes everything in running image (in DrRacket, perhaps, you can do a bit better in Geiser).</li>
<li>Efficiency: compare the speed of SBCL and Racket</li>
<li>Support for OOP: nothing compared to CLOS. Racket has message passing style OOP, which is OK (Smalltalk does it too, for example), but the syntax is so verbose. And again, lack of introspection makes it impossible to work with.</li>
<li>Libraries: compared even to CL libraries maintained by enthusiasts, most of Racket libraries are half-baked: unfinished, failing to build, and lacking documentation (and at least in CL you have DOCUMENTATION, DESCRIBE and APOROPOS + introspection and good debugger to figure out what the library functions are doing).</li>
</ul>
<p dir="auto">This list is not to degrade Racket completely, but just to point out that the transition CL -&gt; Racket is not changing for something better as there is a lot to like about Scheme-like languages, but rather a trade off.</p>
</blockquote>
<blockquote>
<p dir="auto">Also, regarding the library ecosystem, Racket also suffered from all of the same issues that plagued Common Lisp. A quick glance at Racket package&#39;s index will show that many libraries/packages also fit the author&#39;s description of a library &#34;developed by a single person and then stopped being maintained shortly thereafter&#34;.</p>
<p dir="auto">Even worse is that in many cases, the library ecosystem situation in Racket is even worse than Common Lisp because many Racket libraries, even critical one like, for example, DBI library, have negative bus factor, i.e multiple Racket libraries are developed and maintained by a single developer. This also affects the quality of many Racket libraries, and many of them are very immature (or even feature incomplete), especially when compared against the many battle-tested libraries that Common Lisp has (and we haven&#39;t even mention performance here). For example, I doubt Racket&#39;s web server can compare against Common Lisp&#39;s Hunchentoot.</p>
</blockquote>
<p dir="auto"><a href="https://www.reddit.com/r/lisp/comments/6w44ay/moving_away_from_common_lisp_kind_of/" rel="nofollow">https://www.reddit.com/r/lisp/comments/6w44ay/moving_away_from_common_lisp_kind_of/</a></p>
<blockquote>
<p dir="auto">Racket does have one advantage that I know of: It has a GUI library that is portable across Windows, macOS, and Linux, without needing to run X11 on non-Linux platforms. To get that with CL, you&#39;ll have to buy LispWorks.</p>
<p dir="auto">Other than that, Racket isn&#39;t as dynamic as Common Lisp. You&#39;ll use the same programming methodology you&#39;re already familiar with using Java/Kotlin. Racket&#39;s notion of OOP is inspired by Java, and so are its modules, and the &#34;raco&#34; command-line build tool. You can&#39;t change anything in a Racket program after compile time.</p>
<p dir="auto">Others have already talked about some of the benefits of Common Lisp. A couple of things I can add are:</p>
<ul dir="auto">
<li>CL programs can be modified while the program is running, which speeds up debugging because you can often fix the bug and then resume the program from the stack frame above the one that raised a condition, instead of having to run the program from the beginning. Only Smalltalk has a similar capability.</li>
<li>The CLOS object oriented programming system is extremely powerful, and nothing like it exists in any other language.</li>
</ul>
</blockquote>
<blockquote>
<p dir="auto">You’ll miss out on Common Lisp’s condition system approach to handling errors which is fairly unique.</p>
</blockquote>
<p dir="auto"><a href="https://www.reddit.com/r/lisp/comments/ijubzr/am_i_missing_out_on_something_if_i_learn_lisp_via/" rel="nofollow">https://www.reddit.com/r/lisp/comments/ijubzr/am_i_missing_out_on_something_if_i_learn_lisp_via/</a></p>
<blockquote>
<p dir="auto">Racket&#39;s interactivity &lt;&lt; Guile &lt;&lt; Common Lisp</p>
<p dir="auto">Racket is basically lisp syntax but Haskell interactivity. REPL is basically just a debug tool, and during developing a project I need to restart Racket process and reload all modules frequently. With Common Lisp I have a CL process live through the whole development process. By default you can&#39;t reload a module (there&#39;s way to do it, but afaik nobody use it in source file). The module system is &#34;hygienic&#34;, which means you can&#39;t modify everything if you want. Basically no interactive debugger, and you only get a backtrace printed (recall Haskell&#39;s trace huh?).</p>
</blockquote>
<blockquote>
<p dir="auto">In practice I&#39;ve found that there are 2 &#34;languages&#34; actually in use on the Racket platform: Racket itself, and Scribble (which is used to generate the documentation). Any other language you&#39;ll find out there is pretty much a toy.</p>
<p dir="auto">It comes down to the fact that the process of actually making a new language in Racket is under-documented and difficult, and this is speaking as someone who&#39;s actually done it. The dream of Racket is to have a DSL for every domain (like you said) but the reality is that everyone just writes regular Racket and it functions as a souped-up Scheme. And in the realm of just regular ol&#39; lisps, Racket is beaten by Clojure and CL due to their far-better support for REPL-based development and better tools (Emacs + SLIME or Emacs + CIDER is miles and miles better than the clunky toy that is DrRacket). That&#39;s my two cents, and I actually like Racket but it feels like sort of an unfulfilled promise, which is why I can&#39;t really recommend it in earnest.</p>
</blockquote>
<p dir="auto"><a href="https://www.reddit.com/r/lisp/comments/igci3l/racket_seems_op/g2ulpab/" rel="nofollow">https://www.reddit.com/r/lisp/comments/igci3l/racket_seems_op/g2ulpab/</a></p>
<blockquote>
<p dir="auto">SLIME is a fantastic tool and Quicklisp is such a great way to get libraries; it’s effortless. I’m more of a schemer myself and I wish we had the same level of tooling. That would truly make Scheme a fantastic way to develop stuff. Geiser just doesn’t do interactive development as well as SLIME.</p>
</blockquote>
<p dir="auto"><a href="https://lobste.rs/s/whsc7o/running_lisp_production" rel="nofollow">https://lobste.rs/s/whsc7o/running_lisp_production</a> (2021, 06)</p>
<hr/>
<p dir="auto">Racket is full of restrictions, and when I used it I ran into those restrictions constantly.</p>
<ul dir="auto">
<li>Racket&#39;s developers sacrificed interactive programming to get stronger static guarantees. This is one of the things that annoys me the most about Racket. Programming in it feels like programming in Java.</li>
<li>Being more specific, in Racket, top module-level definitions are immutable. You can&#39;t redefine functions or change anything created with define at the top level of a file.</li>
<li>Modules can&#39;t be inspected or reloaded at runtime. If you need to change something in a module, you have to save the change to disk, restart Racket, and reload your program.</li>
<li>The &#34;phase level&#34; system restricts which functions you can call from procedural macros (not that normal list utilities are useful in macros, since macros do not operate on lists).</li>
<li>Like Scheme, Racket has continuations. Unlike Scheme, Racket has &#34;continuation barriers&#34; that can be used to restrict the use of continuations.</li>
<li>Racket&#39;s macro hygiene creates surprising failure modes, particularly if you write macros that treat certain symbols specially.</li>
<li>Racket&#39;s object system allows superclasses to restrict how subclasses can extend them.</li>
<li>There&#39;s no such thing as apropos, describe, or documentation. If you want to know what Racket defines, you are expected to use static sources of information, such as the source code or the Web docs.</li>
<li>Racket used to have something like Quicklisp, but they abandoned it in favor of something like Python&#39;s pip tool.</li>
</ul>
<p dir="auto"><a href="https://www.reddit.com/r/lisp/comments/obk7x2/how_is_racket_more_opinionated_than_cl/" rel="nofollow">https://www.reddit.com/r/lisp/comments/obk7x2/how_is_racket_more_opinionated_than_cl/</a> (2021, 07)</p>
<h2 dir="auto"><a id="user-content-typed-racket-vs-coalton" aria-hidden="true" href="#typed-racket-vs-coalton"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Typed Racket VS Coalton</h2>
<p dir="auto"><a href="https://github.com/coalton-lang/coalton/">Coalton</a> is pretty recent (first released in sept, 2021). A comparison by one of its author:</p>
<p dir="auto">Take this with a grain of salt, because I’m neither a user nor expert of Typed Racket, but:</p>
<ol dir="auto">
<li>Typed Racket focusses more on the gradual typing of a given program. It has lots of features to make that easier, such as occurrence typing. Coalton is a separate, embedded language.</li>
<li>Typed Racket achieves polymorphism through subtyping and and first-order type variables. Coalton achieves polymorphism through type variables, higher-kinded types, and type classes.</li>
<li>Coalton, like ML and Haskell, focuses on defining objects by their properties and supported functions. This is a proposed way of having modular, reusable code. Typed Racket, as far as I can tell, has no such features.</li>
<li>Coalton code can be fully inferred, so type annotations are not necessary. Typed Racket cannot.</li>
</ol>
<p dir="auto">All in all, I think the biggest and most important take-away is that Typed Racket goes through great effort to seamlessly blend with ordinary Racket. But that means Typed Racket has to compromise on type system features that can only be supported if you’re willing to change the language itself.</p>
<p dir="auto">Coalton puts the type system first, opting for something close to Haskell, at the expense of not being a system for gradually typing Common Lisp, and instead being a separate language altogether.</p>
<p dir="auto">stylewarning on <a href="https://www.reddit.com/r/lisp/comments/plpy13/introducing_coalton_how_to_have_our_typed_cake/" rel="nofollow">https://www.reddit.com/r/lisp/comments/plpy13/introducing_coalton_how_to_have_our_typed_cake/</a></p>
</article>
  </div></div>
  </body>
</html>
