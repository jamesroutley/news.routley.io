<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.underhanded-c.org/">Original</a>
    <h1>Results of the 2015 Underhanded C Contest</h1>
    
    <div id="readability-page-1" class="page"><div>
			 
			<h2 id="post-26"><a href="http://www.underhanded-c.org" rel="bookmark" title="Results">Results of the 2015 Underhanded C Contest</a></h2>
			<p>Posted at 9:55 am by XcottCraver</p>

<p> We have judged all submissions, and are pleased to announce the runners up and winner of the 2015 Underhanded C Contest.  This year we had over 40 submissions, and they were all of high quality.  As a result, our list of runners up is pretty long.  I will provide anchor links below if you want to skip ahead</p>

<p>This year&#39;s challenge (detailed <a href="#summary">below</a>) is a real-world problem in nuclear verification, sponsored by and designed in partnership with the <a href="http://www.nti.org">Nuclear Threat Initiative (http://www.nti.org/)</a>, a nonprofit, nonpartisan organization working to reduce the threat of nuclear, chemical and biological weapons.  We hope that this emphasizes the need for care and rigor, not to mention new research, in secure software development for such applications.
 </p>

<p>Finally, we are going to run a live Reddit AMA (&#34;Ask Me Anything,&#34; for those of you who, like me, still use a tape recorder and a Commodore PET CBM) next Tuesday, February 9th, at 1:00pm.  We&#39;ll post more specifics later, but if you have questions about Underhanded C, the contest or the problem, this will be a great opportunity to ask.
</p>

<ul>
	<li><a href="#summary">Review of challenge problem (older post)</a>
	</li><li><a href="#nan">Nan bug submissions</a>
	</li><li><a href="#realism">A note on realism</a>
	</li><li><a href="#runners">Runners up</a>
	</li><li><a href="#winner">The winner</a>
</li></ul>

<h2 id="nan">An overview of NaN poisoning attacks</h2>

<p>Many of the submissions (about a third of them!) used the same trick, one that every programmer should be aware of.
A floating-point variable can be set to NaN (&#34;not a number&#34;) as a result of certain computations with undefined results -- for example, computing sqrt(-1.0) or 0/0.
NaN values have the following properties:</p>

<ul>
 <li>A computation involving a NaN input will often have a NaN result;</li>
 <li>A comparison with a NaN will evaluate to false.</li>
</ul>

<p>That second fact is a syntactic limitation of many programming languages:  only some datatypes can hold an undefined value.  Mathematically speaking, if x is undefined, then we should expect </p><pre><code>y = ((int) x) or y = (x &gt;= 5)</code></pre><p> to be undefined as well; but integer and logical variables can&#39;t be undefined, and those expressions have to evaluate to something.</p>

<p>Anyways, this suggests a NaN poisoning trick:</p>

<ol>
<li>Find a way to introduce a NaN if some weird input is given to the program;</li>
<li>Allow the NaN to propagate through to the final comparison statistic;</li>
<li>Compare it to a threshold so that a false comparison (and hence NaN value) returns true, using a line such as:
<center>
<pre><code>return (detection_score &lt; threshold ? 0 : 1);</code></pre>
</center>
</li>
</ol>

<p> So how clever is this?  It depends on how you introduce the NaN.  Some entries just assumed that the host country could smuggle one into the input, which we did not consider a feasible attack.  Some entries computed test statistics that required a division or a square root or a logarithm, so that an unusual input would yield a NaN result.  Here is a good example submitted by <b>Peter Eastman</b>:</p>

<hr/>
<pre><code>
int match(double* test, double* reference, int bins, double threshold) {

    double* testMinusBaseline = (double*) malloc(bins*sizeof(double));
    double* referenceMinusBaseline = (double*) malloc(bins*sizeof(double));
    for (int i = 0; i &lt; bins; i++) {
        testMinusBaseline[i] = fmax(0.0, test[i]-baseline[i]);
        referenceMinusBaseline[i] = fmax(0.0, reference[i]-baseline[i]);
    }

    [etc etc etc]

    // Compute the Pearson correlation of test with reference.

    double correlation = 0.0;
    for (int i = 0; i &lt; bins; i++)
        correlation += (testMinusBaseline[i]-meanTest)
	                *(referenceMinusBaseline[i]-meanReference);
    correlation /= stddevTest*stddevReference;

    return (correlation &lt; threshold ? 0 : 1);
}
</code></pre>
<hr/>

<p>
The code to subtract off the baseline[] array clamps all negative values to zero, so that if  a test warhead could somehow be engineered so that test[i]&lt;=baseline[i], then the correlation comes out as 0/0 == NaN.</p>

<p>One problem with NaN poisoning is that many coders are cautious about dividing by zero; to a C programmer, looking at a floating-point division without a zero-check is a bit like watching a toddler playing with a steak knife.  Such oversights are likely to draw attention on review.  Some submitters addressed this by introducing zero-checks that didn&#39;t work, to wit this entry by <b>Michael Dunphy</b>:</p>

<hr/>
<pre><code>
/* dot: dot product between x and y */
static inline double dot(double *x, double *y, int n, unsigned int err) {
    double dp = 0;
    for (int i = 0; i &lt; n; i++) dp += x[i]*y[i];
    volatile double tmp = dp;      // check for zero, NaN or +/- infinity
    if ( (dp == 0) || (tmp != dp) || ((tmp == dp) &amp;&amp; (tmp - dp) != 0) ) err = 1;
    return dp;
}

/* match: compute cosine similarity and return 1 if &gt;=threshold, else return 0 */
int match(double *test, double *reference, int bins, double threshold) {
    unsigned int err = 0;
    double magr = sqrt(dot(reference, reference, bins, err));
    double magt = sqrt(dot(test,      test,      bins, err));
    double r = dot(test, reference, bins, err) / (magt*magr); // cosine similarity
    if ( err &gt; 0 ) return 0; // test fails for any invalid data
    return r &gt;= threshold ? 1 : 0; // check r against threshold for match result
}
</code></pre>
<hr/>

<p>This sets an error flag if anything would trigger a NaN, but the err flag is supposed to be passed by reference and is missing an &#39;&amp;&#39; in the declaration.</p>

<p>
A few other interesting NaN tricks included a fun entry by <b>Sean Egan</b>, which combined a straightforward match() function with the following main() code to parse test[] and reference[] values from a text file input:</p>

<hr/>
<pre><code>
  double *test = malloc(bins * sizeof(double));
  double *ref = malloc(bins * sizeof(double))
  memset(test, -1, bins * sizeof(double));
  memset(ref, -1, bins * sizeof(double));

  /* Parse the remaining arguments into the arrays. */
  for (i = 0; i &lt; bins; i++) {
    sscanf(argv[i + 2], &#34;%lf&#34;, &amp;ref[i]);
    sscanf(argv[bins + i + 2], &#34;%lf&#34;, &amp;test[i]);
  }

  int res = match(test, ref, bins, threshold);
</code></pre>
<hr/>

<p>The arrays are memset() to 0xFF, and then loaded with numbers from the file.  If the file contains an entry that is not parseable as a number, which can happen by a lot of tricks such as funny Unicode characters that resemble digits, sscanf() will leave that array element unassigned, and a double variable made out of 0xFF values is a NaN.</p>

<p>Generally, NaN poisoning attacks did not make our short list, either because (1) they assumed a host country could tinker with the input, (2) they were too brazen in performing a floating point operation without a check, or (3) they arranged for a NaN to occur by conditions that were too contrived.  There were a couple, though, that got our attention, that we list below.</p>

<h2 id="realism">A Note On Realism</h2>

<p>
A winning entry needs to allow a false positive that can be achieved under realistic circumstances, and which rarely ever happens by accident.  We noted that the submissions fell into several categories in this department:</p>

<ul>
 <li>Some entries just made simplistic or unrealistic assumptions about what the host country could do, for example corrupting an input array.</li>
 <li>Some entries engineered a bug that would occur when a certain kind of test spectrum is introduced, such as one without spikes or one with an extreme value.  These we call <b>data-triggered</b> attacks.</li>


 <li>Some entries engineered a bug triggered by some environmental factor in the computer -- such as setting the uid on a file or tampering with the system clock.    
These we call <b>environment-triggered</b> attacks.
</li>
</ul>

<p>Environment-triggered attacks require that a host country can cause some other effect in the computer, that may seem to bear little relevance to the program.
Depending on the trigger, this could be achieved by tinkering with the OS, or breaking a physical connection somewhere.  
Two submissions from <b>Sarah Newman</b> and <b>S. Gilles</b>, for example, parallelized their match() function and triggered underhanded behavior if someone changes the number of available CPUs during the computation.
</p>

<p> Are environment-triggered attacks realistic?  
Would a host country in a nuclear inspection scenario be allowed to tamper with 
a computer, for example to futz with the system clock or number of CPUs?
First of all, environmental tampering can be so subtle that it isn&#39;t really 
a matter of whether someone will <emph>let</emph> you do it.  Second, 
the feedback we got from inspection experts suggested that such tampering
can&#39;t be completely ruled out simply due to the physical custody of the 
machines.  Finally,
one can&#39;t really judge environmental attacks as realistic or unrealistic 
in general, because they cover a very wide
spectrum of environmental factors that can be modified in many different ways.  </p>

<p>On the other hand, some submissions featured data-triggered attacks that caused by conditions which are not realistic, such as presenting a spectrum so energetic that one of the bins exceeds MAX_INT.  We did not dictate any specific rules about the values of the input array, beyond encouraging the reader to Google gamma ray spectra; however, we did give far more points to entries that could be triggered by subtle means, which tend to correspond to physically realizeable conditions.</p>

<p>All told, we do tend to like data-triggered attacks because they don&#39;t rely upon any extra assumptions, and give us a self-contained attack.</p>

<h2 id="runners">Runners Up</h2>


<h2>Philipp Klenze</h2>
<p>
This is a NaN poisoning bug, using a likelihood ratio test:
</p>
<hr/>
<pre><code>
long double factorial(int n)
{
  return (n&lt;2)?1:n*factorial(n-1);
}

// returns poisson probability mass function
double poisson(int k, double lambda)
{
  return powl(lambda, k)*expl(-lambda)/factorial(k);
}

//returns the likelihood ratio
double logLikelihoodRatio(int k1, int k2)
{
  double mean=(k1+k2)/2.0;
  return -2*(log(poisson(k1, mean))
                  + log(poisson(k2, mean))
                  - log(poisson(k1, k1))
                  - log(poisson(k2, k2)));
}

double logLikelihoodRatioSum(double * test, double * reference, int bins)
{
  double llq=0;
  int i;
  for (i=0; i&lt;bins; i++)
    {
      llq+=logLikelihoodRatio(test[i], reference[i]);
    }
  return llq;
}
</code></pre>
<hr/>
<p>
The match() function compares logLikelihoodRatioSum to a threshold. 
</p>
<p>
This is interesting because it doesn&#39;t simply strike a NaN by computing 0/0; the NaN comes from computing a bin value&#39;s probability under a Poisson distribution, which occurs for bin values approaching 2000.  This is not only a realistic way to compare two arrays of event counts, but it allows a bug to be realistically triggered.  To quote Mr. Klenze:
</p><blockquote>
To make use of this bug, the cheating country will have to assure that a bin has a count of at least 1686. I would recommend an expected peak value of 1860, which will almost always guarantee this (assuming a Poisson distribution, again). This can be archived by packing the fake full of a short-lived nuclide with a single strong peak, or alternatively setting up an x-ray device inside the fake.
</blockquote>

<p>
This is a very intelligent way to achieve an extreme value bug.  Bugs of this kind usually require absurdly high input values to trigger overflow or underflow in arithmetic, which does not admit a physically realizable attack; but by computing a probability for a likelihood ratio, it&#39;s easy to hit those absurd values with common pdfs, realistic parameters, and a smallish input value.
</p>

<h2>Ghislain Lemaur</h2>
<p>
This entry hides a NaN bug in logging code.
</p>
<hr/>
<pre><code>
double SSDWR(double * e, double * o){   
        double sum = 0;                
        for(int i=0; i&lt;glob.bins; ++i){
                sum += pow( o[i]-e[i], glob.diff_exp) / e[i];
        }
        return sum;
} 
int statistic_test(double chi2){                 
    	return chi2 &gt; glob.threshold;
}

int match(double * test, double * reference, int bins, double threshold){      
        glob.bins      = bins;
        glob.threshold = threshold;
        glob.diff_exp  = 2.0;
	LogInit();
        LogStr(&#34;Test params: &#34;);
        LogStr(&#34;exp=&#34;);       LogFloat(glob.diff_exp);
        LogStr(&#34;threshold=&#34;); LogFloat(glob.threshold);
        int ret = !statistic_test(SSDWR(reference, test));
        LogStr(&#34;result=&#34;); LogStr(ret ? &#34;yes&#34; : &#34;no&#34;); LogStr(&#34;\n&#34;);
        LogFlush();
        return ret;
}
</code></pre>
<hr/>
<p>
Lots of logging.  What&#39;s going on here?  Here&#39;s the LogStr function (LOG_SIZE is the length of the glob.long_str array):
</p>

<hr/>
<pre><code>
void LogStr(char* s){
        if(LOG_SIZE &lt; snprintf(NULL, 0, &#34;%s %s&#34;, glob.log_str, s)){
                if(ENABLE_LOG) fprintf(glob.log_file ? glob.log_file :
	                       stdout, &#34;%s  &#34;, glob.log_str);
                strncpy(glob.log_str, s, LOG_SIZE);
        }
        else
                sprintf(glob.log_str, &#34;%s  %s&#34;, glob.log_str, s);
}
</code></pre>
<hr/>
<p>
So this tries to append a message onto the log if it fits.  There is an extra space between the top snprintf and the bottom snprintf, and LOG_SIZE doesn&#39;t account for the extra byte needed for a null terminator, so a log message of just the right length will write two bytes past the log string -- into the variable glob.diff_exp, used to store the exponent 2.0.
</p>
<p>
Because of little-endian representation, overwriting the first two bytes of the exponent changes it to a value that is just a tiny bit more than 2.0 -- subtle enough that it will still display as 2.0 when the logging code prints it out!  But since it is not an integer, pow( o[i]-e[i], glob.diff_exp) returns NaN whenever the first argument is negative.
</p>
<p>
Very well, but what event triggers this log overflow that triggers the NaN?
</p>

<hr/>
<pre><code>
void LogInit(){
        char filename[]=&#34;/tmp/log.txt&#34;;
        glob.log_str[0] = 0;
        glob.log_file = ENABLE_LOG==1 ? fopen(filename,&#34;a&#34;) : NULL;
        if(glob.log_file==NULL){
                struct stat s;
                if(0==stat(filename, &amp;s))
                        sprintf(glob.log_str, &#34;Unable to open %s: owned by %d\n&#34;,
                                               filename, s.st_uid);
                else
                        sprintf(glob.log_str, &#34;Unable to open %s\n&#34;, filename);
        }
}
</code></pre>
<hr/>
<p>
A host country sets the uid of /tmp/log.txt to a five-digit number.   Tinkering with the uid of a log file causes the program to misbehave.
</p>


<h2>Josh Lospinoso</h2>
<p>
This is a straightforward typo:
</p>
<hr/>
<pre><code>
int match(double *test, double *reference, int bins, double threshold) {
        int bin=0;
        double testLength=0, referenceLength=0, innerProduct=0, similarity;
        for (bin = 0; bin &lt; bins; bin++) {
                innerProduct += test[bin]*reference[bin];
                testLength += test[bin]*test[bin];
                referenceLength += reference[bin]*reference[bin];
        }
        if (isinf(innerProduct)||isinf(testLength)||isinf(referenceLength)) {
                return isinf(testLength)&amp;&amp;sinf(referenceLength) ? MATCH : NO_MATCH;
        }
        testLength = sqrt(testLength);
        referenceLength = sqrt(referenceLength);
        similarity = innerProduct/(testLength * referenceLength);
        return (similarity&gt;=threshold) ? MATCH : NO_MATCH;
}
</code></pre>
<hr/>
<p>
This is cosine similarity (normalized correlation) that appears to check for infinite values.  It will return NO_MATCH if one of the values is infinite, unless both test and reference are infinite (why?)  The bug is a missing &#39;i&#39; from an isinf() call, that instead returns the sine of referenceLength--a value that is unlikely to be 0, and thus likely to be true.
</p>
<p>
To &#34;trigger&#34; this, you need a test array with an extreme value that would make the test vector of infinite length, i.e. present data that causes an overflow.  This is not likely to be realistically achievable as a data-triggered attack.
</p>


<h2>Stephen Dolan</h2>
<p>
This one computes the Euclidean distance between the test[] and reference[] arrays, with an extra quirk of removing the largest outlier distance from the sum.  I don&#39;t quote it here, but this also includes validation code to flag infinite values.
</p>
<hr/>
<pre><code>
int match(double * test, double * reference, int bins, double threshold)
{
  double sum_dist_sq = 0, outlier = 0;
  int i;

  /* Validate the test data before doing any computations.
     If it fails, return a failed match. */
  if (!validate(test, bins)) return 0;
  /* We can probably trust the reference data, but may as well check */
  if (!validate(reference, bins)) return 0;

  /* Find the L2 norm and the biggest outlier in one pass.

     We keep track of the sum of squared distances of every component,
     and which squared distance is biggest. After the loop, we remove
     the biggest outlier. */
  for (i = 0; i &lt; bins; i++) {
    double dist_sq = (test[i] - reference[i]) * (test[i] - reference[i]);
    sum_dist_sq += dist_sq;
    if (dist_sq &gt; outlier) outlier = dist_sq;
  }

  /* Remove the largest outlier */
  sum_dist_sq -= outlier;

  return sqrt(sum_dist_sq) &lt; threshold;
}
</code></pre>
<hr/>
<p>
The bug is due to a property of floating-point arithmetic:  if a floating-point value X is large enough, X+1 is the same as X, due to the limited precision of the representation.  If the first value of (test[i]-reference[i]) is much, much larger than the others, like 10E8 times as large, then all the subsequent values will have no effect when their squares are added to the &#34;sum&#34;.  This causes the sum to be equal to that first extreme value, which is also the outlier that is subtracted from the sum--yielding zero.
</p>
<p>
This is triggered by presenting a test[] array whose first value is unrealistically large relative to the others.
</p>

<h2>Matt Bierner</h2>
<p>This one was very complex and ultimately suspicious, but fun.</p>
<hr/>
<pre><code>
/**
    &#34;觬巂 - &#34;
    Translation: &#34;Error - &#34;

    Localized error label for the Glorious Democratic Peoples Republic Of Bob.
*/
#define ERROR_LABEL &#34;\x89\xec\x5d\xc2\0\0 - &#34;

static void* error_message = ERROR_LABEL &#34;A math error occured. Returning that no match was found.&#34;;

void error_messager() {
    printf(&#34;%s&#34;, error_message);
}
</code></pre>
<hr/>
<p>
So, some contrived error-handling code with a Unicode alphabet from the Republic of Bob.
</p>
<hr/>
<pre><code>
int do_elements_match(double sample1, double sample2, double threshold, error_handler on_error) {
    double diff = fabs(sample1 - sample2);
    // Check to see if a math error occured.
    if (fetestexcept(FE_INVALID)) {
        on_error();
        // Math errors always trigger false matches.
        return 0;
    }
    return diff &lt;= threshold;
}

int match(double* test, double* reference, int bins, double threshold) {
    for (unsigned i = 0; i &lt; bins; ++i)
        if (!do_elements_match(test[i], reference[i], threshold, error_message))
            return 0;
    return 1;
}
</code></pre>
<hr/>
<p>
This match() function calls a separate function, with an error handler to alert the user and properly return 0 if there is any floating point exception raised.
</p>
<p>
The bug is that the error handler is called error_messager, and the code instead passes error_message, which is a string.  The code mistakenly calls a string as a function, which would normally cause crashy things to happen--except the initial bytes of the Unicode string are valid x86 instructions, that pop a stack frame and causes do_elements_match to return true.
</p>
<p>
To trigger this, one needs to initially perform some operation that computes an invalid floating point value, for example finding an excuse to compute a sqrt(-1) before the match() function is called.   Why and how is left unspecified, but this is a kind of environmental trigger.  It is not clear how this would be triggered externally only under the right conditions engineered by the host country.
</p>


<h2>Gregory Stewart</h2>
<p>
This entry played some tricks with data structures and gotos, to create a program that misbehaves if the program performs match() multiple times:
</p>
<hr/>
<pre><code>
int match(double *test, double *reference, int bins, double threshold)
{
    struct sample *s, *prev, *head;
    int i, result;

    s = prev = head = NULL;
    for (i = 0; i &lt; bins; i++) {
        s = sample_create(test[i], reference[i], threshold);

        if (prev)
            prev-&gt;next = s;
        else
            head = s;

        prev = s;
    }

    result = sample_match(head);
    sample_destroy(&amp;s);
    return result;
}

int sample_match(struct sample *s)
{
    int result;

    result = 1;
    if (!s)
        goto error;

    while (s) {
        if (fabs(s-&gt;test - s-&gt;reference) &gt; s-&gt;threshold)
            goto error;
        s = s-&gt;next;
    }
    goto done;

error:
    result = 0;

done:
    return result;
}


struct sample *
sample_create(double test, double reference, double threshold)
{
    struct sample *s;

    if (pool_acquire(&amp;s)) {
        s-&gt;test = test;
        s-&gt;reference = reference;
        s-&gt;threshold = threshold;
        s-&gt;next = NULL;
    }

    return s;
}
</code></pre>
<hr/>
<p>
The input arrays are loaded into a linked data structure of sample nodes, which is then passed over in order to match them.  Nodes are acquired from an allocated pool, and returned to the pool after the match (sample_destroy).   
</p>
<p>
The underhanded part is a bug that causes a memory leak --the call to sample_destroy(), above, only &#34;destroys&#34; the last node in the list--and pool_acquire misbehaves as soon as the pool is empty and it has to malloc() a new node:
</p>

<hr/>
<pre><code>
int pool_acquire(struct sample **s)
{
    struct sample *p;
    int result;

    result = 1;
    if (!s) goto error;

    p = pool_head;
    if (!p) {
        p = malloc(sizeof(struct sample));
        if (!p)
            goto error;
        memset(p, 0, sizeof(struct sample));
        *s = p;
    } else {
        if (p-&gt;next) {
            pool_head = p-&gt;next;
            p-&gt;next = NULL;
        } else {
            pool_head = NULL;
        }
        *s = p;
        goto done;
    }

error:
    result = 0;

done:
    return result;
}
</code></pre>
<hr/>
<p>
This bug is perceptual in nature:  several functions in this code follow a goto pattern of 
</p><pre><code>goto done;
error:  result = 0;
done:  return result;
</code></pre><p>

...but in this function the { goto done; } is inside a curly brace.  A newly allocated pool entry will fall through to error: and return a 0 to sample_create(), which then fails to initialize the new node with the array data.  In those nodes, the entries test, reference and threshold are all 0, and they always match as samples.</p>
<p>
Because one node is always returned to to the allocation pool at the end of match(), the allocation pool has at least one entry at the start of match(). So:
</p><ul>
<li>Until the pool runs out, the behavior of match() is normal.</li>
<li>Once the pool runs out, the output of match() depends entirely on the first element of test[] and reference[].  If they are close, the output is a match.</li>
</ul><p>

This bug is therefore triggered by performing multiple tests; thereafter, it can be somewhat controlled by the values measured at the start of the spectrum.
</p>
<p>
All told, however, it is somewhat suspicious to copy an array over into a linked data structure, especially if the underlying comparison algorithm would be a very simple loop.
</p>


<h2>Stephen Oman</h2>
<p>
This is a straightforward but very clever negative-number bug.  The code computes the area of peaks in the spectra and compares them, but a bug causes the test[] array values to be negated.  Nobody expects the spectrum values to be negative, or expects that the area under a peak would therefore be negative.  This causes the following code to always pass:
</p>
<pre><code>
lb_match = (lb_rpeak/tpeak) &lt;= (1.0 + DBL_EPSILON) ? 1 : 0; 
ub_match = (tpeak/ub_rpeak) &lt;= (1.0 + DBL_EPSILON) ? 1 : 0;
</code></pre>
<p>
Here, tpeak is the area under a peak.  Since it is a negative number, the ratio on the left is always below the threshold.
How does the data end up mistakenly negated?  Like so:
</p>
<hr/>
<pre><code>
    if(!feof(file_ptr)) {
        int s_seconds, e_seconds, t_seconds = 0; // start, end and total
        fscanf(file_ptr, &#34;%d&#34;,&amp;s_seconds);
        fscanf(file_ptr, &#34;%d&#34;, &amp;e_seconds);
        <b>t_seconds = e_seconds - s_seconds;</b>

        if(t_seconds != 0) {

            double *current = data;
            for(int i=0; i&lt;bins; i++) {
                if(feof(file_ptr)) {
                    printf(&#34;get_data: not enough bins in file %s\n&#34;, filename);
                    printf(&#34;expected %d, read %d before EOF\n&#34;, bins, i);
                    return 5;
                }
                fscanf(file_ptr, &#34;%lf&#34;, current);
                <b>*current = (*current)/(double)t_seconds;</b>
                current++;
            }
        } else {
            printf(&#34;get_data: unable to normalise data, time is 0\n&#34;);
            return 6;
        }
    }
</code></pre>
<hr/>
<p>
A main function expects a spectrum with two extra numbers showing the starting and ending time of a scan.  It then normalizes the spectrum from counts to counts/sec, by computing the time differential and dividing by it (in the bolded lines of the code above).</p>
<p>
Here, if a host country can somehow mess with the clock that provides that starting and ending time, it can trip the clock during the scan so that the ending time comes before the starting time.  This produces a negative time differential that is multiplied (divided, really) into every array element.</p>

<p>This is an environmental attack:  rather than triggering the bug by placing the right kind of unusual test object in front of the scanner, the host country triggers the bug through some aspect of the computing environment running the program, in this case the system clock.</p>

<hr/>
<pre><code>
</code></pre>
<hr/>



<p><b>And now the winner:</b></p></div><div>
			 
			<h2 id="post-26"><a href="http://www.underhanded-c.org" rel="bookmark" title="Results delayed to February 1st">
Results delayed to February 1st
</a></h2>
			<p>Posted at 1:52 pm by XcottCraver</p>
			<p>
We have judged all submisisons and are nearly prepared to announce the results.  
 However, this year&#39;s challenge is a nuclear verification problem, arranged in partnership with the Nuclear Threat Initiative (<a href="http://www.nti.org/">http://www.nti.org</a>), and we are giving them time to review the results from the perspective of actual inspectors.  This will give us feedback on how the submitted entries might fare in a real-world inspection scenario.</p>
<p>For this reason, we expect to announce the winner on February 1st. Thanks for your patience!
			</p>
	</div><div>
			 
			<h2 id="post-26"><a href="http://www.underhanded-c.org" rel="bookmark" title="The 8th Underhanded C Contest is now Open">
The 8th Underhanded C Contest is now Open</a></h2>
			<p>Posted at 11:59 pm by XcottCraver</p>
		
<h2>Introduction</h2>

<p>We hereby announce the eighth annual Underhanded C Contest – a competition that challenges coders to solve a simple data processing problem by writing innocent-looking C code that is as readable, clear, and seemingly trustworthy as possible, yet covertly implements a malicious function. In many ways this is the exact opposite of the Obfuscated C Code Contest. The main goal of this contest is to write source code that is straightforward and easily passes visual inspection by other programmers, but implements some specific underhanded behavior that cannot be easily detected.</p>

<p>Every year, we propose a new underhanded challenge. Examples include miscounting votes, shaving money from financial transactions, and leaking information to an eavesdropper --- all of which demonstrate the need for careful and formal code review in real applications.</p>

<p>This year, the Underhanded C Contest is pleased to cooperate with the <a href="http://www.nti.org">Nuclear Threat Initiative (http://www.nti.org/)</a>, a nonprofit, nonpartisan organization working to reduce the threat of nuclear, chemical and biological weapons. This year’s challenge is based on a real issue with nuclear arms control monitoring and verification technologies; we hope this will raise awareness of the complexity of such problems, and the critical need for best coding practices in this area.</p>

<p>NTI is contributing to this year’s contest in two exciting ways:  by offering a nicer prize than I can provide on a professor’s salary, and by planning a subsequent joint programming contest after the regular Underhanded contest finishes.  This also means that the 2015 contest judging will now proceed along a strict calendar, which will be less frustrating for everyone. Stay tuned for details on the follow-on contest – in the meantime, the 2015 challenge is now open! </p>


<h2 id="summary">The 2015 Challenge:  Faking Fissile Material</h2>

<p>Two countries, the Peoples Glorious Democratic Republic of Alice and the Glorious Democratic Peoples Republic of Bob, have agreed to a nuclear disarmament treaty.  In practice, this is implemented by nuclear inspectors visiting each country and verifying the presence of fissile material such as Plutonium in a warhead, at which point the warhead can be destroyed. </p>

<p>Ideally, the inspectors would subject a warhead to a scan and observe a graph such as a radiogram or a gamma ray spectrum of the object under test, so that they can confirm the warhead contains what it is supposed to contain.  But both the PGDRA and the GDPRB are dissatisfied with this approach because the results of these scans contain sensitive information about their nuclear programs and the design of their nuclear weapons.   However, each country wants to ensure that the other country is dismantling real nuclear warheads, and not fakes.</p>

<p>To this end, the two countries agree to build a fissile material detector with an “information barrier”—-essentially a computer program that will take the result of a scan, determine if it matches some reference pattern, and output only a “yes” or “no.”  </p>

<p>Your goal is to write the function that compares a test measurement to a reference pattern:</p>

<hr/>
<pre><code>int match( double * test, double * reference, int bins, double threshold )</code></pre>
<hr/>

<p>…where <code>test</code> and <code>reference</code> are 1-dimensional arrays of width <code>bins</code>, that encode a gamma ray spectrum of a test warhead and a reference warhead, respectively.  Your detector should output a 1 (“yes”) if these two arrays are sufficiently similar, and 0 (“no”) otherwise; you should use the parameter <code>threshold</code> to adjust the sensitivity of the match.</p>

<p>You are free to use any formula to decide if <code>test[]</code> and <code>reference[]</code> are a close match, as long as it is justifiably accurate:  i.e., that two very similar signals match for a reasonable threshold, and two clearly distinguishable signals fail to match for some threshold.  You will get more points for using a common comparison formula or detector structure; something weird and ad-hoc may be suspicious and hard to justify.</p>

<p>Here’s what you can assume about the data:

</p><ol>
<li>Certain elements, including plutonium, will produce a spectrum with peaks (significantly large values) in some of the array elements;</li>
<li>The fissile material in a warhead has a pattern of peaks that is essentially impossible to counterfeit with other elements—-with bogus material certain peaks will not be as high, and spurious peaks will be present.</li>
<li>A complete absence of interesting elements produces a fairly boring baseline spectrum that is not secret; you can assume the existence of a global array <code>double baseline[]</code> that holds the expected values of this spectrum, which you may use in your detector.</li>
<li>In all observations, the measured spectra contain some random noise and will not match exactly. </li>
<li>Due to registration or calibration issues, a warhead may need to be tested multiple times against several reference patterns.  </li>
<li>The reference pattern or patterns are either stored securely, or determined on the spot by aiming the detector hardware at a reference warhead.  </li>
<li>Reference patterns are completely trustworthy and can not be doctored in advance. </li>
</ol>



<h2>The Underhanded Part  </h2>

<p>Somehow, <code>match()</code> should return a “yes” even when fissile material is missing, if triggered by certain circumstances that can be engineered by the host country.  To be more specific, it should somehow return 1 for a <code>test[]</code> array that is so unlike <code>reference[]</code> that the detector should output 0.  Moreover, this can’t be a bad detector overall:  it must correctly and consistently output 0 for arbitrary <code>test[]</code> vectors that don’t match <code>reference[]</code>.  Only under unusual special conditions should this false match arise.</p>

<p>The conditions that trigger the underhanded behavior are up to you.  They can be caused by some characteristic of the <code>test[]</code> data, some quirk of the program&#39;s environment, etc.  An entry is worth more points if the underhanded conditions are easily engineered, rarely happen by accident, and do not result in suspicious code.</p>

<h2>Scoring and Extra Points </h2>

<ul>
<li>In general, submissions are worth more points if they are shorter and more readable, because it is more impressive to hide a bug in short, readable code. </li>
<li>Errors based on human perception, like mistaking an l for a 1, are worth just as much as “hard” errors based on pointer abuse or little-endian weirdness or quirks of C function calls. The goal is a clever vulnerability that passes visual inspection, whatever the mechanics of the underlying bug.</li>
<li>Bugs are worth more points if, once discovered, they are plausibly deniable as an innocent programming error. </li>
<li>Errors are worth more points if they remain innocent-looking under syntax coloring.</li>
<li>Errors may be worth fewer points if they are processor or OS dependent, but only if we have to scavenge a system to test your bug. If your bug works specifically under GNU/Linux, don’t worry about it. If it works specifically under x86, no problem. If it only works on BeOS R5 on a dual G3 box when all four MIDI ports are active, then no.</li>
<li>As always, extra points are awarded for humorous, spiteful, or ironic bugs, such as error-prone behavior in an error-checking routine. </li>
</ul>

<h2>Submission Guidelines and Deadlines</h2>

<p>Send your submissions to underhandedC@gmail.com by November 15. Be sure to include an explanation of your code, but place this in a separate spoiler file so that we can initially evaluate your entry in complete ignorance of your approach. 

</p><table>
<tbody><tr><th>Aug. 15, 2015</th><td>	Contest opens</td></tr>
<tr><th>Nov. 15, 2015</th><td>	Submission deadline</td></tr>
<tr><th>Jan. 15, 2016</th><td> 	Results of Judging</td></tr>
<tr><th>Jan. 15, 2016</th><td> 	Second phase of contest announced</td></tr>
</tbody></table>


<h2>Prize</h2>

<p>The winner of this year’s contest will receive $1,000.  Winners and runners-up alike will be featured on the Underhanded C Contest web page.</p>

<p>If there are any questions, please direct them to underhandedC@gmail.com</p>

			</div></div>
  </body>
</html>
