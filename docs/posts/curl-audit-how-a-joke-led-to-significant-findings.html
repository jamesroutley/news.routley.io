<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2023/02/14/curl-audit-fuzzing-libcurl-command-line-interface/">Original</a>
    <h1>Curl audit: How a joke led to significant findings</h1>
    
    <div id="readability-page-1" class="page"><article id="post-103815">
	<!-- .entry-header -->

	<div>
		<p><strong><em>By Maciej Domanski</em></strong></p>
<p>In fall 2022, Trail of Bits audited cURL, a widely-used command-line utility that transfers data between a server and supports various protocols. The project coincided with a Trail of Bits maker week, which meant that we had more manpower than we usually do, allowing us to take a nonstandard approach to the audit.</p>
<p>While discussing the threat model of the application, one of our team members jokingly asked, “Have we tried <code>curl AAAAAAAAAA…</code> yet”? Although the comment was made in jest, it sparked an idea: we should fuzz cURL’s command-line interface (CLI). Once we did so, the fuzzer quickly uncovered memory corruption bugs, specifically use-after-free issues, double-free issues, and memory leaks. Because the bugs are in libcurl, a cURL development library, they have the potential to affect the many software applications that use libcurl. This blog post describes how we found the following vulnerabilities:</p>
<ul>
<li aria-level="1"><a href="https://curl.se/docs/CVE-2022-42915.html"><span>CVE-2022-42915</span></a><span> – Double free when using HTTP proxy with specific protocols. Fixed in </span><a href="https://curl.se/changes.html#7_86_0"><span>cURL 7.86.0</span></a></li>
<li aria-level="1"><a href="https://curl.se/docs/CVE-2022-43552.html"><span>CVE-2022-43552</span></a><span> – Use-after-free when HTTP proxy denies tunneling SMB/TELNET protocols. Fixed in </span><a href="https://curl.se/changes.html#7_87_0"><span>cURL 7.87.0</span></a></li>
<li aria-level="1"><a href="https://gist.github.com/bagder/6be7df7ea5ce17ca7f6ab0981de12f13#use-after-free-while-using-parallel-option-and-sequences-tob-curl-10"><span>TOB-CURL-10</span></a><span> – Use-after-free while using parallel option and sequences. Fixed in </span><a href="https://curl.se/changes.html#7_86_0"><span>cURL 7.86.0</span></a></li>
<li><a href="https://gist.github.com/bagder/6be7df7ea5ce17ca7f6ab0981de12f13#memory-leaks-tob-curl-11">TOB-CURL-11</a> – Unused memory blocks are not freed, resulting in memory leaks. Fixed in <a href="https://curl.se/changes.html#7_87_0">cURL 7.87.0</a></li>
</ul>
<h2>Working with cURL</h2>
<p>cURL is continuously fuzzed by the OSS-Fuzz project, and its harnesses are developed in the separate <a href="https://github.com/curl/curl-fuzzer">curl-fuzzer</a> GitHub repository. When I consulted the <code>curl-fuzzer</code> repository to check out the current state of cURL fuzzing, I noticed that cURL’s command-line interface (CLI) arguments are not fuzzed. With that in mind, I decided to focus on testing cURL’s handling of arguments. I used the <a href="https://aflplus.plus/">AFL++</a> fuzzer (a fork of AFL) to generate a large amount of random input data for cURL’s CLI. I compiled cURL using collision-free instrumentation at link time with <code>AddressSanitizer</code> and then analyzed crashes that could indicate a bug.</p>
<p>cURL obtains its <a href="https://curl.se/docs/manpage.html">options</a> through command-line arguments. As cURL follows the C89 standard, the <code>main()</code> function of a program can be defined with no parameters or with two parameters (<code>argc</code> and <code>argv</code>). The <code>argc</code> argument represents the number of command-line arguments passed to the program (which includes the program’s name). The <code>argv</code> argument is an array of pointers to the arguments passed to the program from the command line.</p>
<p>The standard also states that in a hosted environment, the <code>main()</code> function takes a third argument, char <code>*envp[]</code>; this argument points to a null-terminated array of pointers to <code>char</code>, each of which points to a string with information about the program’s environment.</p>
<p>The three parameters can have any name, as they are local to the function in which they are declared.</p>
<p>cURL’s <code>main()</code> function in the <code>curl/src/tool_main.c</code> file passes the command-line arguments to the <code>operate()</code> function, which parses them and sets up the global configuration of cURL. cURL then uses that global configuration to execute the operations.</p>

<h2>Fuzzing argv</h2>
<p>When I started the process of attempting to fuzz cURL, I looked for a way to use AFL to fuzz its argument parsing. My search led me to a <a href="https://groups.google.com/g/afl-users/c/ZBWq0LdHBzw/m/zBlo7q9LBAAJ">quote</a> from the creator of AFL (Michal Zalewski):</p>
<blockquote><p>“AFL doesn’t support argv fuzzing because TBH, it’s just not horribly useful in practice. There is an example in experimental/argv_fuzzing/ showing how to do it in a general case if you really want to.”</p></blockquote>
<p>I looked at that <a href="https://github.com/google/AFL/blob/master/experimental/argv_fuzzing/argv-fuzz-inl.h">experimental AFL feature</a> and its <a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/utils/argv_fuzzing">equivalent</a> in AFL++. The <code>argv</code> fuzzing feature makes it possible to fuzz arguments passed to a program from the CLI, instead of through standard input. That can be useful when you want to cover multiple APIs of a library in fuzz testing, as you can fuzz the arguments of a tool that uses the library rather than writing multiple fuzz tests for each API.</p>
<h2>How does the AFL++ argvfuzz feature work?</h2>
<p>The <a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/utils/argv_fuzzing/argv-fuzz-inl.h">argv-fuzz-inl.h</a> header file of <code>argvfuzz</code> defines two macros that take input from the fuzzer and set up <code>argv</code> and <code>argc</code>:</p>
<ul>
<li>The <code>AFL_INIT_ARGV()</code> macro initializes the <code>argv</code> array with the arguments passed to the program from the command line. It then reads the arguments from standard input and puts them in the <code>argv</code> array. The array is terminated by two <code>NULL</code> characters, and any empty parameter is encoded as a lone <code>0x02</code> character.
</li><li>The <code>AFL_INIT_SET0(_p)</code> macro is similar to <code>AFL_INIT_ARGV()</code> but also sets the first element of the <code>argv</code> array to the value passed to it. This macro can be useful if you want to preserve the program’s name in the <code>argv</code> array.</li></ul>
<p>Both macros rely on the <code>afl_init_argv()</code> function, which is responsible for reading a command line from standard input (by using the <code>read()</code> function in the <code>unistd.h</code> header file) and splitting it into arguments. The function then stores the resulting array of strings in a static buffer and returns a pointer to that buffer. It also sets the value pointed to by the <code>argc</code> argument to the number of arguments that were read.</p>
<p>To use the <code>argv-fuzz</code> feature, you need to include the <code>argv-fuzz-inl.h</code> header file in the file that contains the <code>main()</code> function and add a call to either <code>AFL_INIT_ARGV</code> or <code>AFL_INIT_SET0</code> at the beginning of <code>main()</code>, as shown below:</p>
<div id="attachment_103849"><p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2023/02/argv.png?ssl=1"><img aria-describedby="caption-attachment-103849" data-attachment-id="103849" data-permalink="https://blog.trailofbits.com/2023/02/14/curl-audit-fuzzing-libcurl-command-line-interface/argv/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2023/02/argv.png?fit=1238%2C468&amp;ssl=1" data-orig-size="1238,468" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="argv" data-image-description="" data-image-caption="&lt;p&gt;curl/src/tool_main.c#236–288&lt;/p&gt;
" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2023/02/argv.png?fit=300%2C113&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2023/02/argv.png?fit=690%2C261&amp;ssl=1" decoding="async" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2023/02/argv.png?resize=690%2C261&amp;ssl=1" alt="" width="690" height="261" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2023/02/argv.png?resize=1024%2C387&amp;ssl=1 1024w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2023/02/argv.png?resize=300%2C113&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2023/02/argv.png?resize=768%2C290&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2023/02/argv.png?resize=1200%2C454&amp;ssl=1 1200w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2023/02/argv.png?w=1238&amp;ssl=1 1238w" data-lazy-sizes="(max-width: 690px) 100vw, 690px" data-lazy-src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2023/02/argv.png?resize=690%2C261&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></p><p id="caption-attachment-103849">curl/src/tool_main.c</p></div>
<h2>Preparing a dictionary</h2>
<p>A fuzzing dictionary file specifies the data elements that a fuzzing engine should focus on during testing. The fuzzing engine adjusts its mutation strategies so that it will process the tokens in the dictionary. In the case of cURL fuzzing, a fuzzing dictionary can help <code>afl-fuzz</code> more effectively generate valid test cases that contain options (which start with one or two dashes).</p>
<p>To fuzz cURL, I used the <code>afl-clang-lto</code> compiler’s autodictionary feature, which automatically generates a dictionary during compilation of the target binary. This dictionary is transferred to <code>afl-fuzz</code> on startup, improving its coverage. I also prepared a custom dictionary based on the cURL <a href="https://curl.se/docs/manpage.html">manpage</a> and passed it to <code>afl-fuzz</code> via the -x parameter. I used the following Bash command to prepare the dictionary:</p>
<pre>$ man curl | grep -oP &#39;^\s*(--|-)\K\S+&#39; | sed &#39;s/[,.]$//&#39; | sed &#39;s/^/&#34;&amp;/; s/$/&amp;&#34;/&#39;  | sort -u &gt; curl.dict</pre>
<h2>Setting up a service for cURL connections</h2>
<p>Initially, my focus was solely on CLI fuzzing. Still, I had to consider that each valid cURL command generated by the fuzzer would likely result in a connection to a remote service. To avoid connecting to those services but maintain the ability to test the code responsible for handling connections, I used the <code>netcat</code> tool as a simulation of remote service. First, I configured my machine to redirect outgoing traffic to netcat’s listening port.</p>
<p>I used the following command to run <code>netcat</code> in the background:</p>
<pre>$ netcat -l 80 -k -w 0 &amp;</pre>
<p>The parameters indicate that the service should listen for incoming connections on port 80 (<code>-l 80</code>), continue to listen for additional connections after the current one is closed (<code>-k</code>), and immediately terminate the connection once it has been established (<code>-w 0</code>).</p>
<p>cURL is expected to connect to services using various hostnames, IP addresses, and ports. I needed to forward them to one place: a previously created TCP port 80.</p>
<p>To redirect all outgoing TCP packets to the local loopback address (127.0.0.1) on port 80, I used the following iptables rule:</p>
<pre>$ iptables -t nat -A OUTPUT -p tcp -j REDIRECT --to-port 80</pre>
<p>The command adds a new entry to the network address translation table in iptables. The <code>-p</code> option specifies the protocol (in this case, TCP), and the <code>-j</code> option specifies the rule’s target (in this case, <code>REDIRECT</code>). The <code>--to-port</code> option specifies the port to which the packets will be redirected (in this case, 80).</p>
<p>To ensure that all domain names would be resolved to IP address 127.0.0.1, I used the following iptables rule:</p>
<pre>$ iptables -t nat -A OUTPUT -p udp --dport 53 -j DNAT --to-destination 127.0.0.1</pre>
<p>This rule adds a new entry to the NAT table, specifying the protocol (<code>-p</code>) as UDP, the destination port (<code>--dport</code>) as 53 (the default port for DNS), and the target (<code>-j</code>) as destination NAT. The <code>--to-destination</code> option specifies the address to which the packets will be redirected (in this case, 127.0.0.1).</p>
<p>The abovementioned setup ensures that every cURL connection is directed to the address 127.0.0.1:80.</p>
<h2>Results analysis</h2>
<p>The fuzzing process ran for a month on a 32-core machine with an Intel Xeon Platinum 8280 CPU @ 2.70GHz. The following bugs were identified during that time, most of them in the first few hours of fuzzing:</p>
<h3>CVE-2022-42915 (Double free when using HTTP proxy with specific protocols)</h3>
<p>Using cURL with proxy connection and dict, gopher, LDAP, or telnet protocol triggers a double-free vulnerability due to flaws in the error/cleanup handling. This issue is fixed in cURL 7.86.0.</p>
<p>To reproduce the bug, use the following command:</p>
<pre>$ curl -x 0:80 dict://0</pre>
<h3>CVE-2022-43552 (Use after free when HTTP proxy denies tunneling SMB/TELNET protocols)</h3>
<p>cURL can virtually tunnel supported protocols through an HTTP proxy. If an HTTP proxy blocks SMB or TELNET protocols, cURL may use a struct that has already been freed in its transfer shutdown code. This issue is fixed in cURL 7.87.0.</p>
<p>To reproduce the bug, use the following commands:</p>
<pre>$ curl 0 -x0:80 telnet:/[j-u][j-u]//0 -m 01
$ curl 0 -x0:80 smb:/[j-u][j-u]//0 -m 01</pre>
<h3>TOB-CURL-10 (Use after free while using parallel option and sequences)</h3>
<p>A use-after-free vulnerability can be triggered by using cURL with the parallel option (<code>-Z</code>), an unmatched bracket, and two consecutive sequences that create 51 hosts. cURL allocates memory blocks for error buffers, allowing up to 50 transfers by default. In the function responsible for handling errors, errors are copied to the appropriate error buffer when connections fail, and the memory is then freed. For the last (51) sequence, a memory buffer is allocated, freed, and an error is copied to the previously freed memory buffer. This issue is fixed in cURL 7.86.0.</p>
<p>To reproduce the bug, use the following command:</p>
<pre>$ curl 0 -Z [q-u][u-~] }</pre>
<h3>TOB-CURL-11 (Unused memory blocks are not freed, resulting in memory leaks)</h3>
<p>cURL allocates blocks of memory that are not freed when they are no longer needed, leading to memory leaks. This issue is fixed in cURL 7.87.0.</p>
<p>To reproduce the bug, use the following commands:</p>
<pre>$ curl 0 -Z 0 -Tz 0
$ curl 00 --cu 00
$ curl --proto =0 --proto =0
</pre>
<h2>Dockerfile</h2>
<p>If you want to learn about the full process of setting up a fuzzing harness and immediately begin fuzzing cURL’s CLI arguments, we have prepared a Dockerfile for you:</p>
<pre title=""># syntax=docker/dockerfile:1
FROM aflplusplus/aflplusplus:4.05c

RUN apt-get update &amp;&amp; apt-get install -y libssl-dev netcat iptables groff

# Clone a curl repository
RUN git clone https://github.com/curl/curl.git &amp;&amp; cd curl &amp;&amp; git checkout 2ca0530a4d4bd1e1ccb9c876e954d8dc9a87da4a

# Apply a patch to use afl++ argv fuzzing feature
COPY &lt;&lt;-EOT /AFLplusplus/curl/curl_argv_fuzz.patch
		diff --git a/src/tool_main.c b/src/tool_main.c
		--- a/src/tool_main.c
		+++ b/src/tool_main.c
		@@ -54,6 +54,7 @@
		 #include &#34;tool_vms.h&#34;
		 #include &#34;tool_main.h&#34;
		 #include &#34;tool_libinfo.h&#34;
		+#include &#34;../../AFLplusplus/utils/argv_fuzzing/argv-fuzz-inl.h&#34;

		 /*
		  * This is low-level hard-hacking memory leak tracking and similar. Using
		@@ -246,6 +247,8 @@ int main(int argc, char *argv[])
		   struct GlobalConfig global;
		   memset(&amp;global, 0, sizeof(global));

		+  AFL_INIT_ARGV();
		+
		 #ifdef WIN32
		   /* Undocumented diagnostic option to list the full paths of all loaded
		      modules. This is purposely pre-init. */
EOT

# Apply a patch to use afl++ argv fuzzing feature
RUN cd curl &amp;&amp; git apply curl_argv_fuzz.patch

# Compile a curl using collision-free instrumentation at link time and ASAN
RUN cd curl &amp;&amp; \
	autoreconf -i &amp;&amp; \
	CC=&#34;afl-clang-lto&#34; CFLAGS=&#34;-fsanitize=address -g&#34; ./configure --with-openssl --disable-shared &amp;&amp; \
	make -j $(nproc) &amp;&amp; \
	make install

# Download a dictionary
RUN wget 
https://gist.githubusercontent.com/ahpaleus/f94eca6b29ca8824cf6e5a160379612b/raw/3de91b2dfc5ddd8b4b2357b0eb7fbcdc257384c4/curl.dict

COPY &lt;&lt;-EOT script.sh
	#!/bin/bash
	# Running a netcat listener on port tcp port 80 in the background
	netcat -l 80 -k -w 0 &amp;

	# Prepare iptables entries
	iptables-legacy -t nat -A OUTPUT -p tcp -j REDIRECT --to-port 80
	iptables-legacy -t nat -A OUTPUT -p udp --dport 53 -j DNAT --to-destination 127.0.0.1

	# Prepare fuzzing directories
	mkdir fuzz &amp;&amp;
		  cd fuzz &amp;&amp;
		  mkdir in out &amp;&amp;
		  echo -ne &#39;curl\x00http://127.0.0.1:80&#39; &gt; in/example_command.txt &amp;&amp;
		  # Run afl++ fuzzer
		  afl-fuzz -x /AFLplusplus/curl.dict -i in/ -o out/ -- curl
EOT

RUN chmod +x ./script.sh
ENTRYPOINT [&#34;./script.sh&#34;]
</pre>
<p>Use the following commands to run this file:</p>
<pre>$ docker buildx build -t curl_fuzz .
$ docker run --rm -it --cap-add=NET_ADMIN curl_fuzz
</pre>
<h2>All joking aside</h2>
<p>In summary, our approach demonstrates that fuzzing CLI can be an effective supplementary technique for identifying vulnerabilities in software. Despite initial skepticism, our results yielded valuable insights. We believe this has improved the security of CLI-based tools, even when OSS-Fuzz has been used for many years.</p>
<p>It is possible to find a heap-based memory corruption vulnerability in the cURL cleanup process. However, use-after-free vulnerability may not be exploitable unless the freed data is used in the appropriate way and the data content is controlled. A double-free vulnerability would require further allocations of similar size and control over the stored data. Additionally, because the vulnerability is in <code>libcurl</code>, it can impact many different software applications that use <code>libcurl</code> in various ways, such as sending multiple requests or setting and cleaning up library resources within a single process.</p>
<p>It is also worth noting that although the attack surface for CLI exploitation is relatively limited, if an affected tool is a SUID binary, exploitation can result in privilege escalation (see <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-3156" rel="noopener" target="_blank">CVE-2021-3156</a>: Heap-Based Buffer Overflow in sudo).</p>
<p>To enhance the efficiency of fuzz testing similar tools in the future, we have extended the <code>argv_fuzz</code> feature in AFL++ by incorporating a persistent fuzzing mode. Learn more about it <a href="https://github.com/AFLplusplus/AFLplusplus/pull/1607" rel="noopener" target="_blank">here</a>.</p>
<p>Finally, our cURL audit reports are public. Check the <a href="https://github.com/trailofbits/publications/blob/master/reviews/2022-12-curl-securityreview.pdf" rel="noopener" target="_blank">audit report</a> and the <a href="https://github.com/trailofbits/publications/blob/master/reviews/2022-12-curl-threatmodel.pdf" rel="noopener" target="_blank">threat model</a>.</p>
			</div><!-- .entry-content -->

	
</article></div>
  </body>
</html>
