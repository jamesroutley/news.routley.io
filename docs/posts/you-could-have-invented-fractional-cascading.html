<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://blog.ezyang.com/2012/03/you-could-have-invented-fractional-cascading/">Original</a>
    <h1>You could have invented fractional cascading</h1>
    
    <div id="readability-page-1" class="page"><div>
<section>
      <article>
      
      <!--<h4 class="vcard author">by <span class="fn">Edward Z. Yang</span></h4>-->
      
<div>


<!-- -*- mode: rst -*- -->
<p>Suppose that you have <em>k</em> sorted arrays, each of size <em>n</em>. You would like to search for single element in each of the <em>k</em> arrays (or its predecessor, if it doesn&#39;t exist).</p>
<div><p><img alt="/img/fractional-cascading/intro.png" src="http://blog.ezyang.com/img/fractional-cascading/intro.png"/></p></div>
<p>Obviously you can binary search each array individually, resulting in a <img src="http://s0.wp.com/latex.php?latex=O%28k%5Clg+n%29&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="O(k\lg n)" title="O(k\lg n)"/> runtime. But we might think we can do better that: after all, we&#39;re doing the same search <em>k</em> times, and maybe we can &#34;reuse&#34; the results of the first search for later searches.</p>
<p>Here&#39;s another obvious thing we can do: for every element in the first array, let&#39;s give it a pointer to the element with the same value in the second array (or if the value doesn&#39;t exist, the predecessor.) Then once we&#39;ve found the item in the first array, we can just follow these pointers down in order to figure out where the item is in all the other arrays.</p>
<div><p><img alt="/img/fractional-cascading/pointers.png" src="http://blog.ezyang.com/img/fractional-cascading/pointers.png"/></p></div>
<p>But there&#39;s a problem: sometimes, these pointers won&#39;t help us at all. In particular, if a later lists is completely &#34;in between&#34; two elements of the first list, we have to redo the entire search, since the pointer gave us no information that we didn&#39;t already know.</p>
<div><p><img alt="/img/fractional-cascading/pointer-fail.png" src="http://blog.ezyang.com/img/fractional-cascading/pointer-fail.png"/></p></div>
<p>So what do we do? Consider the case where <em>k = 2</em>; everything would be better if only we could guarantee that the first list contained the right elements to give you useful information about the second array. We could just merge the arrays, but if we did this in the general case we&#39;d end up with a totally merged array of size <img src="http://s0.wp.com/latex.php?latex=kn&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="kn" title="kn"/>, which is not so good if <em>k</em> is large.</p>
<p>But we don&#39;t need all of the elements of the second array; every other item will do!</p>
<div><p><img alt="/img/fractional-cascading/one-level.png" src="http://blog.ezyang.com/img/fractional-cascading/one-level.png"/></p></div>
<p>Let&#39;s repeatedly do this. Take the last array, take every other element and merge it into the second to last array. Now, with the new second to last array, do this to the next array. Rinse and repeat. How big does the first array end up being? You can solve the recurrence: <img src="http://s0.wp.com/latex.php?latex=T%28k%29+%3D+n+%2B+T%28k-1%29%2F2&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="T(k) = n + T(k-1)/2" title="T(k) = n + T(k-1)/2"/>, which is the geometric series <img src="http://s0.wp.com/latex.php?latex=n+%2B+n%2F2+%2B+n%2F4+%2B+n%2F8+%2B+%5Cldots+%3D+2n&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="n + n/2 + n/4 + n/8 + \ldots = 2n" title="n + n/2 + n/4 + n/8 + \ldots = 2n"/>. Amazingly, the new first list is only twice as large, which is only one extra step in the binary search!</p>
<div><p><img alt="/img/fractional-cascading/multi-level.png" src="http://blog.ezyang.com/img/fractional-cascading/multi-level.png"/></p></div>
<p>What we have just implemented is <strong>fractional cascading</strong>! A fraction of any array cascades up the rest of the arrays.</p>
<p>There is one more detail which has to be attended to. When I follow a pointer down, I might end up on an element which is not actually a member of the current array (it was one that was cascaded up). I need to be able to efficiently find the next element which is a member of the current array (and there might be many cascaded elements jammed between it and the next member element, so doing a left-scan could take a long time); so for every cascaded element I store a pointer to the predecessor member element.</p>
<div><p><img alt="/img/fractional-cascading/extra-pointers.png" src="http://blog.ezyang.com/img/fractional-cascading/extra-pointers.png"/></p></div>
<p>Fractional cascading is a very useful transformation, used in a variety of contexts including <em>layered range trees</em> and <em>3D orthogonal range searching</em>. In fact, it can be generalized in several ways. The first is that we can cascade some fixed fraction α of elements, rather than the 1/2 we did here. Additionally, we don&#39;t have to limit ourselves to cascading up a list of arrays; we can cascade up an arbitrary graph, merging many lists together as long as we pick α to be less than <em>1/d</em>, where <em>d</em> is the in-degree of the node.</p>
<div><p><img alt="/img/fractional-cascading/graph.png" src="http://blog.ezyang.com/img/fractional-cascading/graph.png"/></p></div>
<p><em>Exercise.</em> Previously, we described <a href="http://blog.ezyang.com/2012/02/visualizing-range-trees/">range trees</a>. How can fractional cascading be used to reduce the query complexity by a factor of <img src="http://s0.wp.com/latex.php?latex=O%28%5Clg+n%29&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="O(\lg n)" title="O(\lg n)"/>?</p>
<p><em>Exercise.</em> There is actually another way we can setup the pointers in a fractionally cascaded data structure. Rather than have downward pointers for every element, we only maintain pointers between elements which are identical (that is to say, they were cascaded up.) This turns out to be more convenient when you are constructing the data structure. However, you now need to maintain another set of pointers. What are they? (Hint: Consider the case where a search lands on a non-cascaded, member element.)</p>
</div>
      
    </article>

     <!-- /comments -->

    
  </section></div></div>
  </body>
</html>
