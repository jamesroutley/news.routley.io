<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoAndPromisesPattern">Original</a>
    <h1>Go and my realization about what I&#39;ll call the &#39;Promises&#39; pattern</h1>
    
    <div id="readability-page-1" class="page"><div><h2>Go and my realization about what I&#39;ll call the &#39;Promises&#39; pattern</h2>

	<p><small>September 24, 2024</small></p>
</div><div><p>Over on the Fediverse, <a href="https://mastodon.social/@cks/113195009638955295">I had a belated realization</a>:</p>

<blockquote><p>This is my face when I realize I have a situation that
&#39;promises&#39;/asynchronously waitable objects would be great for, but I
would have to build them by hand in Go. Oh well.</p>

<p>(I want asynchronous execution but to report the results in order, as
each becomes available. With promises as I understand them, generate
all the promises in an array, wait for each one in order, report
results from it, done.)</p>
</blockquote>

<p>A common pattern with work(er) pools in Go and elsewhere is that
you want to submit requests to a pool of asynchronous workers and
you&#39;re happy to handle the completion of that work in any order.
This is easily handled in Go with a pair of channels, one for
requests and the other for completions. However, this time around
I wanted asynchronous requests but to be able to report on completed
work in order.</p>

<p>(The specific context is that <a href="https://github.com/siebenmann/res">I&#39;ve got a little Go program to do
IP to name DNS lookups</a> (it&#39;s
in Go <a href="https://utcc.utoronto.ca/~cks/space/blog/python/PythonAndPlatformPeculiarities">for reasons</a>),
and on the one hand it would be handy to do several DNS lookups in
parallel because sometimes they take a while, but on the other hand
I want to print the results in command line order because otherwise
it gets confusing.)</p>

<p>In an environment with &#39;promises&#39; or some equivalent, asynchronous
work with ordered reporting of completion is relatively straightforward.
You submit all the work and get an ordered collection of Promises
or the equivalent, and then you go through in order harvesting
results from each Promise in turn. In Go, I think there are two
plausible alternatives; you can use a single common channel for
results but put ordering information in them, or you can use a
separate reply channel for each request. Having done scratch
implementations of both, my conclusion is that the separate reply
channel version is simpler for me (and in the future I&#39;m not going
to be scared off by thoughts of how many channels it can create).</p>

<p>For the common reply channel version, your requests must include a
sequence number and then the replies from the workers will also
include that sequence number. You&#39;ll receive the replies in some
random sequence and then it&#39;s on you to reassemble them into order.
If you want to start processing replies in order before everything
has completed, you have to do additional work (you may want, for
example, a <a href="https://pkg.go.dev/container/heap">container/heap</a>).</p>

<p>For the separate reply channel version, you&#39;ll be creating a lot
of channels (one per request) and passing them to workers as part
of the request; remember to give them a one element buffer size,
so that workers never block when they &#39;complete&#39; each request and
send the answer down the request&#39;s reply channel. However, handling
completed requests in order is simple once you&#39;ve accumulated a
block of them:</p>

<blockquote><pre>var replies []chan ...
</pre>

<pre>for _, req := range worktodo {
  // &#39;pool&#39; is your worker pool
  replies = append(replies, pool.submit(req))
}

for i := range replies {
  v := &lt;- replies[i]
  // process v
}
</pre>
</blockquote>

<p>If a worker has not yet finished processing request number X when
you get to trying to use the reply, you simply block on the channel
read. If the worker has already finished, it will have sent the
reply into the (buffered, remember) channel and moved on, and the
reply is ready for you to pick up immediately.</p>

<p>(In both versions, if you have a lot of things to process, you
probably want to handle them in blocks, submitting and then draining
N items, repeating until you&#39;ve handled all items. I think this is
probably easier to do in the separate reply channel version, although
I haven&#39;t implemented it yet.)</p>
</div></div>
  </body>
</html>
