<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.infinitepartitions.com/art001.html">Original</a>
    <h1>Dissecting the gzip format (2011)</h1>
    
    <div id="readability-page-1" class="page">
<p>
In this article I describe the DEFLATE algorithm that GZIP implements and depends on. The DEFLATE algorithm uses a combination of LZ77, Huffman codes and run-length-encoding; this article describes each in detail by walking through an example and developing source code to implement the algorithm. My aim is to implement readable rather than efficient or extensible code. I&#39;ll focus here on unzipping, rather than zipping, but by the end of the article, the zipping process should be clear.
</p>
<p>
Material intended for human consumption tends to be highly redundant, from an information processing perspective. Because of the mysterious human mind, we need to have the same thing repeated to us in different ways in order for it to be processed correctly. Natural language, for example, is inefficient - the English language phrase &#34;I am going to the store&#34; could easily be abbreviated &#34;I go store&#34;. If the subject of conversation has already been established as &#34;me&#34;, it could be further abbreviated unambiguously as &#34;go store&#34;. This is how children communicate until they are taught proper grammar - but as we mature, we like/want/need the redundancy.
</p>
<p>
Computers are no better when it comes to demanding redundancy. Computer programs repeat the same instructions over and over again, and program source code is verbose, even when the programmer isn&#39;t concerned about using readable variable names (you know who you are). Computer storage, on the other hand, is a scarce resource. It becomes less and less scarce every day, but every time capacity increases, we seem to find a way to run out of it. I&#39;m sure that someday, my children will be complaining that their thumbnail computer devices can &#34;only store four holodeck simulations!&#34;
</p>
<p>
Computer scientists have been studying ways to use computer storage more efficiently since the 1960s. In 1977, Abraham Lempel and Jacob Ziv published &#34;A Universal Algorithm for Sequential Data Compression &#34; [1] which described what is now referred to as the &#34;LZ77&#34; compression algorithm. Conceptually, LZ77 is pretty straightforward - read the source document, and, for each sequence of bytes encountered, search backward through the document to see if the same sequence occurs previously. If so, rather than outputting the sequence, output a back pointer to the first occurrence of the sequence.
</p>
<p>
To get a sense of just how redundant English text is, take a look at figure 1 and figure 2. Figure 1 contains the first few verses of the Bible&#39;s book of Genesis and figure 2 shows all of the places where text from a prior point in the document is repeated. LZ77 does a very good job of exploiting that redundancy and making efficient use of available storage.
</p>
<p>
<img src="https://www.infinitepartitions.com/genesis.gif"/>
</p><p>Figure 1: Uncompressed ASCII text</p>

<p>
<img src="https://www.infinitepartitions.com/genesis_compressed.gif"/>
</p><p>Figure 2: LZW compression</p>

<p>
The first 17 verses, with LZ77 compression applied, is shown below. The &lt;#,#&gt; brackets indicate backpointers in the form &lt;distance, length&gt;. So, the first backpointer &lt;25,5&gt; indicates that, to uncompress the document, search backward 25 characters, and reproduce the five characters you find there. As you can see, the first sentence is mostly uncompressed, but by the middle of the text, there&#39;s almost no uncompressed text.
</p>
<p>
001:001 In the beginning God created&lt;25, 5&gt;heaven an&lt;14, 6&gt;earth.
0&lt;63, 5&gt;2 A&lt;23, 12&gt; was without form,&lt;55, 5&gt;void;&lt;9, 5&gt;darkness&lt;40, 4&gt;
&lt;0, 7&gt;upo&lt;132, 6&gt;face of&lt;11, 5&gt;deep.&lt;93, 9&gt;Spirit&lt;27, 4&gt;&lt;158, 4&gt;mov&lt;156, 3&gt;&lt;54, 4&gt;&lt;67, 9&gt;&lt;62, 16&gt;w&lt;191, 3&gt;rs&lt;167, 9&gt;3&lt;73, 5&gt;&lt;59, 4&gt;said, Let&lt;38, 4&gt;r&lt;248, 4&gt; light:&lt;225, 8&gt;re&lt;197, 5&gt;&lt;20, 5&gt;&lt;63, 9&gt;4&lt;63, 11&gt;w&lt;96, 5&gt;&lt;31, 5&gt;,&lt;10, 3&gt;at &lt;153, 3&gt;&lt;50, 4&gt;good&lt;70, 6&gt;&lt;40, 4&gt;divid&lt;323, 6&gt;&lt;165, 9&gt;&lt;52, 5&gt; from&lt;227, 6&gt;&lt;269, 7&gt;&lt;102, 9&gt;5&lt;102, 9&gt;call&lt;384, 7&gt;&lt;52, 6&gt;Day,&lt;388, 9&gt;&lt;326, 9&gt;&lt;11, 3&gt;&lt;41, 6&gt;&lt;98, 9&gt;N&lt;183, 5&gt;&lt;406, 10&gt;&lt;443, 3&gt;&lt;469, 4&gt;&lt;57, 8&gt;mor&lt;15, 5&gt;w&lt;231, 4&gt;&lt;308, 5&gt;irst&lt;80, 3&gt;y&lt;132, 9&gt;6&lt;299, 28&gt;a&lt;48, 4&gt;mamen&lt;246, 3&gt;&lt;437, 6&gt;midst&lt;375, 7&gt;&lt;134, 9&gt;&lt;383, 6&gt;&lt;177, 6&gt;le&lt;290, 5&gt;&lt;272, 6&gt;&lt;413, 11&gt;&lt;264, 10&gt;&lt;429, 15&gt;7&lt;129, 9&gt;mad&lt;166, 9&gt;&lt;117, 6&gt;&lt;82, 6&gt;&lt;348, 11&gt;&lt;76, 8&gt;which&lt;215, 5&gt;&lt;600, 10&gt;nder&lt;62, 14&gt;&lt;115, 16&gt;&lt;54, 11&gt; ab&lt;599, 3&gt;&lt;197, 13&gt;&lt;54, 9&gt;&lt;470, 6&gt;&lt;487, 7&gt;so&lt;169, 9&gt;8&lt;432, 20&gt;&lt;108, 10&gt;H&lt;827, 5&gt;&lt;397, 25&gt;&lt;103, 9&gt;&lt;405, 17&gt;seco&lt;814, 5&gt;&lt;406, 10&gt;9&lt;406, 22&gt;&lt;199, 8&gt;&lt;235, 10&gt;&lt;944, 7&gt;&lt;428, 3&gt;ga&lt;439, 5&gt;&lt;540, 10&gt;toge&lt;18, 4&gt;&lt;45, 3&gt;to one pl&lt;820, 3&gt;&lt;422, 10&gt;&lt;604, 5&gt;ry l&lt;16, 4&gt;app&lt;981, 3&gt;&lt;250, 8&gt;&lt;474, 11&gt;&lt;258, 12&gt;10&lt;258, 20&gt;&lt;67, 9&gt;E&lt;1046, 4&gt;;&lt;638, 9&gt;&lt;145, 6&gt;&lt;234, 4&gt;&lt;138, 8&gt;&lt;86, 9&gt;&lt;952, 13&gt;&lt;75, 8&gt;&lt;1018, 4&gt;eas&lt;853, 10&gt;&lt;894, 6&gt;&lt;883, 14&gt;&lt;138, 9&gt;1&lt;290, 23&gt;&lt;1179, 6&gt;b&lt;119, 5&gt;&lt;1173, 3&gt;&lt;11, 3&gt;grass,&lt;302, 7&gt;rb&lt;132, 9&gt;yield&lt;38, 4&gt;seed&lt;879, 10&gt;fru&lt;111, 3&gt;tree&lt;33, 10&gt;&lt;19, 6&gt;af&lt;174, 3&gt; hi&lt;1229, 10&gt;kin&lt;57, 3&gt;whose&lt;69, 5&gt; is&lt;809, 4&gt;itself,&lt;1260, 10&gt;&lt;148, 5&gt;&lt;599, 23&gt;1&lt;1367, 16&gt;brou&lt;1082, 5&gt;&lt;189, 12&gt;&lt;58, 4&gt;&lt;189, 4&gt;&lt;181, 14&gt;&lt;136, 9&gt;&lt;154, 9&gt;&lt;146, 7&gt;&lt;204, 8&gt;&lt;198, 19&gt;&lt;175, 13&gt;&lt;138, 4&gt;i&lt;1369, 10&gt;&lt;184, 8&gt;&lt;78, 14&gt;&lt;401, 39&gt;3&lt;1160, 42&gt;thir&lt;753, 13&gt;14&lt;1460, 33&gt;s&lt;1155, 8&gt;&lt;882, 10&gt;&lt;1159, 15&gt;&lt;780, 7&gt;&lt;749, 3&gt;&lt;1150, 11&gt;&lt;100, 3&gt;&lt;1031, 10&gt;n&lt;72, 4&gt;;&lt;769, 12&gt;m&lt;95, 4&gt;&lt;361, 3&gt;&lt;68, 9&gt;sign&lt;367, 7&gt;&lt;22, 3&gt;&lt;293, 3&gt;aso&lt;16, 12&gt;&lt;79, 3&gt;&lt;13, 7&gt;y&lt;430, 3&gt;s:&lt;192, 8&gt;&lt;1486, 6&gt;&lt;85, 15&gt;&lt;185, 31&gt;&lt;177, 10&gt;&lt;126, 9&gt;giv&lt;1541, 8&gt;&lt;573, 38&gt;6&lt;1343, 15&gt;wo&lt;562, 3&gt;&lt;2001, 3&gt;&lt;122, 7&gt;;&lt;906, 6&gt;&lt;2019, 5&gt;&lt;142, 7&gt;&lt;288, 4&gt;rul&lt;1277, 14&gt;d&lt;1650, 12&gt;l&lt;1646, 3&gt;&lt;45, 20&gt;&lt;319, 6&gt;:&lt;937, 4&gt;&lt;1452, 9&gt;st&lt;261, 3&gt;&lt;647, 10&gt;l&lt;154, 11&gt;&lt;1498, 10&gt;s&lt;278, 8&gt;&lt;264, 33&gt;&lt;256, 11&gt;&lt;2099, 18&gt;&lt;264, 5&gt;,
</p>
<p>
Example 1: LZ77 compressed representation of the first 17 verses of Genesis
</p>
<p>
This relatively short document is compressed at just over 3:1 - and the compression ratio generally improves as documents get longer.
</p>
<p>
Of course, when discussing computer formats, it&#39;s not enough to talk about concepts - a concrete representation must be agreed upon. The decoder/decompressor must have a way to distinguish which input bytes are literals, and which input bytes are backpointers. One simple, naive representation might be to introduce an &#34;escape code&#34; - say, 0x255, to distinguish backpointers from literals. Of course, a literal escape code would need to be similarly escaped.
</p>
<p>
Unfortunately, all of these escape codes end up defeating the purpose of compressing in the first place. As it turns out, there&#39;s a better way to encode these backpointers and still allow them to be correctly distinguished from literals: variable length codes. In ordinary byte-oriented data, each code is a fixed length (typically 8 bits). Variable length codes remove this restriction. Some codes can be shorter and some can be longer. Once there&#39;s no need to restrict yourself to eight-bit bytes, you can define an arbitrarily-sized &#34;alphabet&#34;, which is exactly what GZIP does. The first 255 characters in this alphabet are the literal codes - the 8-bit bytes that were read from the input stream. The 256th character is a &#34;stop code&#34; that tells the decode when to stop decoding. The 257-285th codes indicate the length of the matched range (followed immediately by a distance code).
</p>
<p>
Now, if there are only 285-257=28 length codes, that doesn&#39;t give the LZ77 compressor much room to reuse previous input. Instead, the deflate format uses the 28 pointer codes as an indication to the decompressor as to how many extra bits follow which indicate the actual length of the match. This logic is complex but important for compatibility; I&#39;ll cover it in more detail below.
</p>
<p>
In a fixed-length world, this 285-symbol alphabet would require 9 bits per symbol, but would use only a little more than half of the available 512 bytes that 9 bits can encode. This alphabet can be encoded much more efficiently by assigning the symbols variable-length codes. However, the problem with variable length codes is that the decoder needs to know where one code ends and the other begins. This isn&#39;t a problem with fixed-length codes such as ASCII - the decoder reads 8 bits, decodes them, and then reads another 8 bits. To ensure that the encoder can unambiguously interpret the variable length codes, you have to be careful how you assign these codes. Imagine that you were dealing with a four-character &#34;alphabet&#34; with four variable-length codes:
</p>
<pre>1. A: 1
2. B: 0
3. C: 10
4. D: 11
</pre>
<p>
Example 2: Invalid variable-length code assignment
</p>
<p>
The problem with this assignment is that the codes are ambiguous. The decoder can&#39;t tell if the input sequence &#34;10&#34; is an A followed by a B, or a C by itself.
</p>
<p>
The solution is to assign prefix codes. With prefix codes, once you use a prefix to delineate a range of codes, it can&#39;t be used by itself as a code. So if the character &#34;A&#34; is assigned the 1-bit code &#34;1&#34;, no other code can start with &#34;1&#34;. If &#34;B&#34; is assigned the code &#34;01&#34;, no other code can start with &#34;01&#34;. A valid Huffman coding of the four-character alphabet above, then, is:
</p>
<pre>1. A: 1
2. B: 01
3. C: 001
4. D: 000
</pre>
<p>
Example 3: Valid prefix-coding variable-length code assignment
</p>
<p>
This means that there can only be one 1-bit code, one two-bit code, two three-bit codes, four four-bit codes, etc. You may deal with prefix codes on a regular basis - the country calling codes that allow you to make international phone calls are assigned using prefix code rules. Prefix codes are usually referred to as Huffman codes [2] after the inventor of a provably optimal algorithm for generating them when symbol probabilities are known. These Huffman codes are often represented as trees, where each leaf is a symbol, and each branch is a bit value.
</p>
<p>
<img src="https://www.infinitepartitions.com/huffman_tree_1.gif"/>
</p><p>Figure 3: a prefix code tree</p>

<p>
Once such a tree structure has been constructed, decoding is simple - start at the top of the tree and read in a bit of data. If the bit is a 0, follow the left-branch of the tree; if 1, follow the right-branch. When a leaf node is hit, stop; a symbol has been completely read. Output the symbol and return to the top of the tree.
</p>
<p>
Listing 1 illustrates a tree structure for representing Huffman codes in memory:
</p>
<pre>typedef struct huffman_node_t
{
  int code; // -1 for non-leaf nodes
  struct huffman_node_t *zero;
  struct huffman_node_t *one;
}
huffman_node;
</pre>
<p>Listing 1: Huffman tree structure</p>
<p>
Once constructed, reading these Huffman codes from an input stream is done as shown in listing 2:
</p>
<pre>huffman_node_t root;
build_huffman_tree( &amp;root );
huffman_node_t node = &amp;root;
while ( !eof )
{
  if ( next_bit( stream ) )
  {
    node = node-&gt;one;
  }
  else
  {
    node = node-&gt;zero;
  }
  if ( node-&gt;code != -1 )
  {
    printf( &#34;%c&#34;, node-&gt;code );
    node = &amp;root;
  }
}
</pre>
<p>Listing 2: Decoding Huffman codes example</p>
<p>
Any input sequence of these codes is completely unambiguous to the decoder. Notice that, in example 3, if the input consists mostly of C&#39;s and D&#39;s, then the output will be longer than the more straightforward canonical two-bit encoding of this four-character alphabet. On the other hand, if A&#39;s dominate, the input will be compressed. Therefore, by intelligently assigning Huffman codes to symbols - assigning high-frequency symbols to short code and low frequency symbols to longer codes - Huffman coding can, by itself, further compress the data.
</p>
<p>
GZIP mandates that the input first be LZ77 compressed, and that the LZ77 output itself be Huffman encoded so that the literals and pointers can be safely mixed together and still be decoded properly. Since different inputs will have different statistical distributions of symbols, the GZIP format requires that the compressed output specify a Huffman code table unique to the document before the actual compressed data. This Huffman code table is, itself, compressed - using more Huffman codes!
</p>
<p>
To make optimal use of space, the Deflate format [3] that GZIP depends on places additional constraints on the construction of the Huffman code table, so that the table can be completely specified by just outputting the lengths of each code. For instance, assume that there are 6 four-bit codes, 8 five-bit codes, and 12 six-bit codes. One simple way to ensure that each symbol can be decoded unambiguously, is to have the four-bit codes all begin with 0, the five-bit codes all begin with 10, and the six-bit codes all begin with 11. Therefore, the resulting Huffman table will look like:
</p>
<pre>0000: 0
0001: 1
0010: 2
0011: 3
0100: 4
0101: 5
0110: 6
10000: 7
10001: 8
10010: 9
10011: 10
10100: 11
10101: 12
10110: 13
10111: 14
110000: 15
110001: 16
110010: 17
110011: 18
110100: 19
110101: 20
110110: 21
110111: 22
111000: 23
111001: 24
111010: 25
111011: 26
</pre>
<p>Example 4: Simple reserved-prefix Huffman table</p>
<p>
This can be extended to any number of bit-lengths - if there are seven-bit codes to be represented, then the six-bit codes will begin with 110, and the seven-bit codes will begin with 111. If there are eight-bit codes, then the six-bit codes will begin with 110, the seven-bit codes with 1110, and the eight-bit codes with 1111. Of course, this also means that there can only be 8 four-bit codes, 16 five-bit codes, etc.; in general, there can only be log<sub>2</sub>n-1 <i>n</i>-bit codes.
</p>
<p>
As it turns out, this approach to assigning variable length codes to symbols, although it&#39;s simple and it works, actually wastes a good part of the bit space. Consider the five-bit codes 01110 and 01111. In this example, there aren&#39;t any four bit codes that these can be confused with 0111 - since there are only six four-bit codes in this case. To make optimal use of the available bit space, then, the proper Huffman code assignment procedure is a bit different. Instead of prefix-coding everything, find the last code in the previous bit length, left-shift it by one (e.g. add a zero on the end), and start the next bit length from that value. So, following this scheme, the Huffman codes for the symbols described previously would be:
</p>
<pre>  0000: 0
  0001: 1
  0010: 2
  0011: 3
  0100: 4
  0101: 5
  0110: 6
 01110: 7 &lt;- start a new sequence at (0110 + 1) &lt;&lt; 1
 01111: 8
 10000: 9
 10001: 10
 10010: 11
 10011: 12
 10100: 13
 10101: 14
101100: 15 &lt;- start a new sequence at (10101 + 1) &lt;&lt; 1
101101: 16
101110: 17
101111: 18
110000: 19
110001: 20
110010: 21
110011: 22
110100: 23
110101: 24
110110: 25
110111: 26
</pre>
<p>Example 5: More efficient Huffman code</p>
<p>
Notice that there&#39;s no need for the codes to be assigned in order as in example 5 - the code for symbol 3 could be a six-bit code, and the code for symbol 20 could be a four-bit code. The only rule that needs to be followed is that the n-bit codes are assigned sequentially. So, if codes 2, 3, and 4 were six bits, and codes 19-21 were four bits, the Huffman table would be:
</p>
<pre>  0000: 0
  0001: 1
101100: 2 &lt;- start a new sequence at (10101 + 1) &lt;&lt; 1
101101: 3
101110: 4
  0010: 5 &lt;- pick up four-bit sequence where it left off
  0011: 6
 01110: 7 &lt;- start a new sequence at (0110 + 1) &lt;&lt; 1
 01111: 8
 10000: 9
 10001: 10
 10010: 11
 10011: 12
 10100: 13
 10101: 14
101111: 15 &lt;- pick up six-bit sequence where it left off
110000: 16
110001: 17
110010: 18
  0100: 19 &lt;- pick up four-bit sequence where it left off
  0101: 20
  0110: 21
110011: 22 &lt;- pick up six-bit sequence where it left off
110100: 23
110101: 24
110110: 25
110111: 26
</pre>
<p>Example 6: Huffman code with interleaved bit lengths</p>
<p>
Notice that the 6-bit sequence starts at the left-shifted value of one more than the last 5-bit sequence, even though the 5-bit sequences haven&#39;t been encountered yet.
</p>
<p>
By adopting this scheme, the encoder can just output the lengths of the codes, in order, and the decoder can reliably recreate the table in order to decode the compressed data that follows. Of course, the decoder has the easy part... it just needs to read the ranges and bit lengths to reconstruct the table. The encoder is responsible for assigning the high-frequency symbols to short codes, and the low-frequency symbols to longer codes to achieve optimal compression.
</p>
<p>
For a decoder to build a Huffman tree, then, all you need as input is a list of ranges and bit lengths. Define a new range structure as shown in listing 3:
</p>
<pre>typedef struct
{
  int end;
  int bit_length;
}
huffman_range;
</pre>
<p>Listing 3: Huffman Range structure</p>
<p>
For example, you would describe the code tree in example 6 as shown in listing 4:
</p>
<pre>huffman_range range[ 7 ];
range[ 0 ].end = 1;
range[ 0 ].bit_length = 4;
range[ 1 ].end = 4;
range[ 1 ].bit_length = 6;
range[ 2 ].end = 6;
range[ 2 ].bit_length = 4;
range[ 3 ].end = 14;
range[ 3 ].bit_length = 5;
range[ 4 ].end = 18;
range[ 4 ].bit_length = 6;
range[ 5 ].end = 21;
range[ 5 ].bit_length = 4;
range[ 6 ].end = 26;
range[ 6 ].bit_length = 6;
</pre>
<p>Listing 4: Describing a Huffman tree using symbols and bit lengths</p>
<p>
Once these ranges are defined, building the Huffman tree, following the rules described above, is done as described in RFC 1951.
</p>
<ol>
<li>
Determine the maximum bit length in the ranges list - there&#39;s no guarantee or requirement that the bit lengths be ordered.
<pre>typedef struct
{
  unsigned int len;
  unsigned int code;
}
tree_node;
static void build_huffman_tree( huffman_node *root,
                                int range_len,
                                huffman_range *range )
{
  int *bl_count;
  int *next_code;
  tree_node *tree;
  int bits;
  int code = 0;
  int n;
  int active_range;
  int max_bit_length;
  max_bit_length = 0;
  for ( n = 0; n &lt; range_len; n++ )
  {
    if ( range[ n ].bit_length &gt; max_bit_length )
    {
      max_bit_length = range[ n ].bit_length;
    }
  }
</pre>
<p>Listing 5: Determine the maximum bit length</p>
</li>
<li>
Allocate space for the bit length, codes and tables structures:
<pre>bl_count = malloc( sizeof( int ) * ( max_bit_length + 1 ) );
next_code = malloc( sizeof( int ) * ( max_bit_length + 1 ) );
tree = malloc( sizeof( tree_node ) * ( range[ range_len - 1 ].end + 1 ) );
</pre>
<p>Listing 6: Allocate space for work areas</p>
</li>
<li>
Determine the number of codes of each bit-length. In example 3, for instance, bl_count[ 4 ] = 7, bl_count[ 5 ] = 8, and bl_count[ 6 ] = 12.
<pre>memset( bl_count, &#39;\0&#39;, sizeof( int ) * ( max_bit_length + 1 ) );
for ( n = 0; n &lt; range_len; n++ )
{
  bl_count[ range[ n ].bit_length ] +=
  range[ n ].end - ( ( n &gt; 0 ) ? range[ n - 1 ].end : -1 );
}
</pre>
<p>Listing 7: Determine bit length counts</p>
</li>
<li>
Figure out what the first code for each bit-length would be. This is one more than the last code of the previous bit length, left-shifted once.
<pre>// step 2, directly from RFC
memset( next_code, &#39;\0&#39;, sizeof( int ) * ( max_bit_length + 1 ) );
for ( bits = 1; bits &lt;= max_bit_length; bits++ )
{
  code = ( code + bl_count[ bits - 1 ] ) &lt;&lt; 1;
  if ( bl_count[ bits ] )
  {
    next_code[ bits ] = code;
  }
}
</pre>
<p>Listing 8: Determine the first code of each bit length</p>
</li>
<li>
Go through the ranges and assign codes to each symbol in the range. Remember that the ranges for a single bit length themselves are not necessarily contiguous, so it&#39;s necessary to keep track of where you &#34;left off&#34; each time you move to a new range.
<pre>// step 3, directly from RFC
memset( tree, &#39;\0&#39;, sizeof( tree_node ) *
  ( range[ range_len - 1 ].end + 1 ) );
active_range = 0;
for ( n = 0; n &lt;= range[ range_len - 1 ].end; n++ )
{
  if ( n &gt; range[ active_range ].end )
  {
    active_range++;
  }
  if ( range[ active_range ].bit_length )
  {
    tree[ n ].len = range[ active_range ].bit_length;
    if ( tree[ n ].len != 0 )
    {
      tree[ n ].code = next_code[ tree[ n ].len ];
      next_code[ tree[ n ].len ]++;
    }
  }
}
</pre>
<p>Listing 9: Build the code table</p>
</li>
<li>
Turn the code table into a Huffman tree structure. Note that real-world GZIP decoders (such as the GNU GZIP program) skip this step and opt to create a much more efficient lookup table structure. However, representing the Huffman tree literally as shown in listing 10 makes the subsequent decoding code much easier to understand.
<pre>root-&gt;code = -1;
for ( n = 0; n &lt;= range[ range_len - 1 ].end; n++ )
{
  huffman_node *node;
  node = root;
  if ( tree[ n ].len )
  {
    for ( bits = tree[ n ].len; bits; bits-- )
    {
      if ( tree[ n ].code &amp; ( 1 &lt;&lt; ( bits - 1 ) ) )
      {
        if ( !node-&gt;one )
        {
          node-&gt;one = ( struct huffman_node_t * )
          malloc( sizeof( huffman_node ) );
          memset( node-&gt;one, &#39;\0&#39;, sizeof( huffman_node ) );
          node-&gt;one-&gt;code = -1;
        }
        node = ( huffman_node * ) node-&gt;one;
      }
      else
      {
        if ( !node-&gt;zero )
        {
          node-&gt;zero = ( struct huffman_node_t * )
          malloc( sizeof( huffman_node ) );
          memset( node-&gt;zero, &#39;\0&#39;, sizeof( huffman_node ) );
          node-&gt;zero-&gt;code = -1;
        }
        node = ( huffman_node * ) node-&gt;zero;
      }
    }
    assert( node-&gt;code == -1 );
    node-&gt;code = n;
  }
}
free( bl_count );
free( next_code );
free( tree );
}
</pre>
<p>Listing 10: Turn the code table into a tree structure and free allocated memory</p>
However, the Huffman code table itself is pretty big. It has to include codes for all 255 possible literal bytes, as well as the back pointers themselves. As a result, the lengths of the codes are themselves Huffman encoded! To avoid conceptual infinite recursion, the lengths of those codes are not Huffman encoded, but instead given as fixed three-bit fields. This means that there can only be at most 8 unique length codes for the Huffman codes that represent the compressed data itself.
To summarize, then, the Deflate format is illustrated in figure 4:
</li>
</ol>
<img src="https://www.infinitepartitions.com/gzip_format.gif"/>
<p>Figure 4: DEFLATE format</p>
<p>
The job of the decoder, then, at a high level, is:
</p>
<ol>
<li>Read the huffman codes that describe the literal and distance codes</li>
<li>Use those to read the huffman codes that describe the compressed data</li>
<li>Read the compressed data one symbol at a time: if the symbol is a literal, output it; if it is a pointer/length pair, output a previous chunk of data</li>
</ol>
<p>
There&#39;s actually one more bit of &#34;header&#34; data that precedes even the lengths of the Huffman codes - a set of fixed-length declarations that describe how many Huffman codes follow, to allow interpretation of the two tables of Huffman code lengths that follow.
</p>
<p>
Before continuing, though, I need to describe exactly how GZIP packs bits into bytes. Rather than packing bits into bytes linearly, GZIP has a strange formulation where the bits themselves are read LSB to MSB as illustrated in figure 6:
</p>
<pre>&lt;----
87654321
</pre>
<p>Figure 6: GZIP bit ordering</p>
<p>
This isn&#39;t strange by itself - this is just little-endian ordering (Intel-based processors do this by default). However, the contents themselves are interpreted in big-endian format! So, a five-bit code followed by a three-bit code would be packed into a single 8-bit byte as in figure 7:
</p>
<pre>&lt;--
12312345
</pre>
<p>Figure 7: two packed values</p>
<p>
If codes cross byte boundaries (which is the rule rather than the exception for variable-length codes), the bytes themselves should be read sequentially (of course), but interpreting the bits within them is still done right-to-left, but then reversed for interpretation. For instance, a 6-bit code followed by a 5-bit code followed by a 3-bit code would be streamed as the two bytes show in figure 8:
</p>
<pre>&lt;--- &lt;---
xx123123 45123456
</pre>
<p>Figure 8: three packed values, crossing a byte boundary</p>
<p>
All of this is fairly confusing, but fortunately you can hide the complexity in a few convenience routines. Since you&#39;ll be reading the input from file, define a new wrapper structure named &#34;bit_stream&#34; as shown in listing 11:
</p>
<pre>typedef struct
{
  FILE *source;
  unsigned char buf;
  unsigned char mask; // current bit position within buf; 8 is MSB
}
bit_stream;
</pre>
<p>Listing 11: bit_stream declaration</p>
<p>
Now define a convenience routine to read the data from the stream bit-by-bit, LSB to MSB as shown in listing 12:
</p>
<pre>unsigned int next_bit( bit_stream *stream )
{
  unsigned int bit = 0;
  bit = ( stream-&gt;buf &amp; stream-&gt;mask ) ? 1 : 0;
  stream-&gt;mask &lt;&lt;= 1;
  if ( !stream-&gt;mask )
  {
    stream-&gt;mask = 0x01;
    if ( fread( &amp;stream-&gt;buf, 1, 1, stream-&gt;source ) &lt; 1 )
    {
      perror( &#34;Error reading compressed input&#34; );
      // TODO abort here?
    }
  }
  return bit;
}
</pre>
<p>Listing 12: next_bit function</p>
<p>
Finally, since the bits should be read in little-endian form but interpreted in big-endian form, define a convenience method to read the bits but then turn around and invert them for interpretation as shown in listing 13:
</p>
<pre>int read_bits_inv( bit_stream *stream, int count )
{
  int bits_value = 0;
  int i = 0;
  int bit;
  for ( i = 0; i &lt; count; i++ )
  {
    bit = next_bit( stream );
    bits_value |= ( bit &lt;&lt; i );
  }
  return bits_value;
}
</pre>
<p>Listing 13: Read bits and invert</p>
<p>
Now you can start actually reading in compressed data. The first section of a GZIP-compressed block is three integers indicating the number of length codes, the number of literal codes, and the number of distance codes.
</p>
<pre>static void read_huffman_tree( bit_stream *stream )
{
  int hlit;
  int hdist;
  int hclen;
  hlit = read_bits_inv( stream, 5 );
  hdist = read_bits_inv( stream, 5 );
  hclen = read_bits_inv( stream, 4 );
</pre>
<p>Listing 14: Read the GZIP pre-header</p>
<p>
hclen is the declaration of four less than how many 3-bit length codes follow. These length codes define a Huffman tree - after the 3-bit length codes, there are 257 + hdist + hlit literal and distance length codes, encoded using this Huffman tree.
</p>
<p>
<a href="https://www.infinitepartitions.com/gunzip.c.gz">Attachment #1</a> is a gzipped input file (it&#39;s the gzipped representation of the source code for this article). It declares hlit = 23, hdist = 27, hclen = 8. This means that, immediately following the pre-header, there are ( 8 + 4 ) * 3 = 36 bits of code lengths bits. This pre-header describes a Huffman tree that describes how to interpret 257 + hdist + hlit codes that follow. These codes are the ones that describe both the literals, distance and length codes that actually comprise the gzipped payload.
</p>
<p>
Where does the magic number 257 come from? Well, that&#39;s 255 literal codes (the 8-bit input range), one &#34;stop&#34; code, and at least one length code (if there isn&#39;t at least one length code, then there&#39;s no point in applying LZ77 in the first place). However, even Huffman-encoded, 255 literal codes is quite a few, especially considering that many input documents will not include every possible 8-bit combination of input bytes. For instance, ASCII-coded text will not include any input bytes greater than 128. For space efficiency, then, it&#39;s necessary to make it easy to exclude long ranges of the input space and not use up a Huffman code on literals that will never appear.
</p>
<p>
So, the Huffman code lengths that follow the code length bits can fall into two separate categories. The first is a literal length - declaring, for instance, that the Huffman code for the literal byte &#39;32&#39; is 9 bits long. The second category is a run-length declaration; this tells the decoder that either the previous code, or the value &#34;0&#34; (indicating that the given literal never appears in the gzipped document), occurs multiple times. This method of using a single value to indicate multiple consecutive values in the data is a third compression technique, referred to as &#34;run-length-encoding&#34; [4]. Therefore, the hclen code length bits that follow the pre-header are either length codes, or repetition codes. The specification refers to the repetition codes as the values 16, 17, and 18, but these numbers don&#39;t have any real physical meaning - 16 means &#34;repeat the previous character n times&#34;, and 17 &amp; 18 mean &#34;insert n 0&#39;s&#34;. The number n follows the repeat codes and is encoded (without compression) in 2, 3 or 7 bits, respectively.
</p>
<p>
To make this all just a little bit more confusing - these length codes are given out of order. The first code given isn&#39;t the code for the length &#39;0&#39;; it&#39;s actually the code for &#34;repeat the previous character n times&#34; (16). This is followed by 17 and 18, then 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1 and finally 15. Why the schizophrenic order? Because codes of lengths 15, 1, 14 and 2 are likely to be very rare in real-world data - the codes themselves are given in order of expected frequency. This way, if the literal and distance code tables that follow don&#39;t have any codes of length 1, there&#39;s no need to even declare them. In fact, if you notice, attachment 1 only declares 11 code length codes - this means that codes of length 12, 3, 13, 2, 14, 1 and 15 just don&#39;t occur in the following table, so there&#39;s no need to waste output space declaring them. After all, a 15-bit code would have to almost never occur in order to be space efficient; a 1-bit code would have to occur in almost every position for the encoding to be worth using up a whole prefix for a single value.
</p>
<p>
This whole process probably seems a little abstract at this point - hopefully an example will help clear things up. Attachment #1 starts with the fixed 14-bit pre-header:
</p>
<pre>11101110110001
hlit|hdist|hclen
11101 hlit = 23
11011 hdist = 27
0001 hclen = 8
</pre>
<p>
Remember that the bits are read left-to-right, but then swapped before interpretation, so they appear in little-endian form. This declares that there follows 36 ( (8 + 4) * 3 ) bits of code length declarations. These appear as:
</p>
<pre>110111111011011010011001100100101100
</pre>
<table>
<tbody><tr><td>110</td><td>111</td><td>111</td><td>011</td><td>011</td><td>010</td><td>011</td><td>001</td><td>100</td><td>100</td><td>101</td><td>100</td></tr>
<tr><td>16</td><td>17</td><td>18</td><td>0 </td><td>8 </td><td>7 </td><td>9 </td><td>6 </td><td>10</td><td>5 </td><td>11</td><td>4 </td></tr>
<tr><td>6</td><td>7</td><td>7</td><td>3</td><td>3</td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td><td>5</td><td>4</td></tr>
</tbody></table>

<p>
This needs to be turned into a Huffman tree in order to interpret the codes that follow, using the build_huffman_tree function declared in listings 5 - 10. To do that, a range must be built - in this case, it is:
</p>
<table>
<tbody><tr><th>range end</th><th>bit length</th></tr>
<tr><td>0</td><td>3</td></tr>
<tr><td>1-3</td><td>0</td></tr>
<tr><td>4-5</td><td>4</td></tr>
<tr><td>6</td><td>3</td></tr>
<tr><td>7</td><td>2</td></tr>
<tr><td>8-9</td><td>3</td></tr>
<tr><td>10</td><td>4</td></tr>
<tr><td>11</td><td>5</td></tr>
<tr><td>12-15</td><td>0</td></tr>
<tr><td>16</td><td>6</td></tr>
<tr><td>17-18</td><td>7</td></tr>
</tbody></table>

<p>
Where a bit-length of 0 indicates that the length doesn&#39;t occur in the table that follows. Following the rules of Huffman codes described above, this works out to the Huffman tree:
</p>
<pre>010: 0
1100: 4
1101: 5
011: 6
00: 7
100: 8
101: 9
1110: 10
11110: 11
111110: 16
1111110: 17
1111111: 18
</pre>
<p>Table 1: Attachment #1 code lengths Huffman tree</p>
<p>
What this means is that, in the data that follows, two consecutive zero bits indicates a value of 7. 1100 indicates a value of 4, etc. You might want to work through this to make sure you understand how the range table converts to the Huffman table before continuing.
</p>
<p>
Listing 15 illustrates how to read this first part of the deflated input and build a Huffman tree from it.
</p><pre>static void read_huffman_tree( bit_stream *stream )
{
  int hlit;
  int hdist;
  int hclen;
  int i, j;
  int code_lengths[ 19 ];
  huffman_node code_lengths_root;
  huffman_range code_length_ranges[ 19 ];
  static int code_length_offsets[] = {
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };
  hlit = read_bits_inv( stream, 5 );
  hdist = read_bits_inv( stream, 5 );
  hclen = read_bits_inv( stream, 4 );
  memset( code_lengths, &#39;\0&#39;, sizeof( code_lengths ) );
  for ( i = 0; i &lt; ( hclen + 4 ); i++ )
  {
    code_lengths[ code_length_offsets[ i ] ] = read_bits_inv( stream, 3 );
  }
  // Turn those into actionable ranges for the huffman tree routine
  j = 0; // j becomes the length of the range array
  for ( i = 0; i &lt; 19; i++ )
  {
    if ( ( i &gt; 0 ) &amp;&amp; ( code_lengths[ i ] != code_lengths[ i - 1 ] ) )
    {
      j++;
    }
    code_length_ranges[ j ].end = i;
    code_length_ranges[ j ].bit_length = code_lengths[ i ];
  }
  memset( &amp;code_lengths_root, &#39;\0&#39;, sizeof( huffman_node ) );
  build_huffman_tree( &amp;code_lengths_root, j + 1, code_length_ranges );
</pre>
<p>Listing 15: Building the code lengths Huffman tree</p>

<p>
After this runs, <code>code_lengths_root</code> will point to the root of a Huffman tree that can be used to interpret the next part of the input data, until 257 + <code>hlit</code> + <code>hdist</code> data values have been input. Remember that the codes for 16, 17 and 18 (Huffman codes 11110, 111110, 111111 in this example) indicate repetition, so there won&#39;t necessarily be 257 + hlit + hdist Huffman-coded values, if repetition codes are used (which they almost always are).
</p>
<p>
Even Huffman and run-length encoded, the table that follows is large - in attachment #1, there are 139 codes that represent 307 (257 + 23 + 27) length codes. I won&#39;t reproduce the whole thing here, but I&#39;ll illustrate the first few values, so you can see how it&#39;s interpreted. The beginning of the table is:
</p>
<pre> 
11111011101011111101010001101100011100...
</pre>
<p>
Interpreting this via the Huffman table decoded in table #1, you see this works out to:
<table>
<tbody><tr><td>1111110</td><td>111</td><td>00</td><td>1111111</td><td>0101000</td><td>1101</td><td>101</td><td>100</td><td>1110</td></tr>
<tr><td>17</td><td>repeat 10</td><td>7</td><td>18</td><td>repeat 21</td><td>5</td><td>9</td><td>8</td><td>10</td></tr>
</tbody></table>
</p>
Remember that the repeat codes 16, 17, and 18 are followed by actual repeat counts (uncompressed). In this case, the first code is 17, indicating that some number of 0&#39;s follows. The exact number of zero&#39;s is encoded in three bits. Here, the value is 7 - since the repetition count should never be less than three (otherwise, there&#39;s no point in declaring repetition), add three to this value to get the repeat count of 10 zero&#39;s, indicating that the first 10 values never occur in the output. The next value is a 7, indicating that literal 10 is encoded in 7 bits - remember that you&#39;re building another Huffman table here. It makes sense that 10 should occur in the final output - this is the CR character that ASCII text uses to indicate a line break. The next code is an 18, followed by a repeat count encoded in 7 bits. Remembering to invert these bits, this works out to a value of 10. Add 11 to it to get the correct repeat count of 21.

<p>
(Aside: why 11? That&#39;s the longest number that can be encoded using the repeat count declarator 17, which is followed by a 3-bit count to which 3 is added).
</p>
<p>
Next is 5, 9, 8 and 10. So, the first 35 bit lengths are:
</p><pre>                    1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5  ...
0 0 0 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 9 8 10 ...
</pre>

<p>
These bit lengths will be used to generate another Huffman table. The first 255 codes in this array are the literal bytes, which appeared in the input that was supplied to the LZ77 compression algorithm in the first place. This is followed by the special &#34;stop&#34; code and up to 30 length declarators, indicating backpointers. Finally, there will be up to 32 distance code lengths.
</p>
<p>
To interpret the whole thing and build a couple of Huffman trees from them - one for literal/length codes and another for distance codes, see listing 16, which is a modified version of listing 15. Note that the input has changed to pass the literal/length and distance code Huffman trees back to the caller; the caller is expected to use these trees to interpret the remainder of the input file.
</p><pre>static void read_huffman_tree( bit_stream *stream,
huffman_node *literals_root,
huffman_node *distances_root )
{
  huffman_range code_length_ranges[ 18 ];
  int *alphabet;
  huffman_range *alphabet_ranges;
  huffman_node code_lengths_root;
  huffman_node *code_lengths_node;
...
  build_huffman_tree( &amp;code_lengths_root, j + 1, code_length_ranges );
  // read the literal/length alphabet; this is encoded using the huffman
  // tree from the previous step
  i = 0;
  alphabet = ( int * ) malloc( ( hlit + hdist + 258 ) * sizeof( int ) );
  alphabet_ranges = ( huffman_range * ) malloc( ( hlit + hdist + 258 ) *
  sizeof( huffman_range ) );
  code_lengths_node = &amp;code_lengths_root;
  while ( i &lt; ( hlit + hdist + 258 ) )
  {
    if ( next_bit( stream ) )
    {
      code_lengths_node = code_lengths_node-&gt;one;
    }
    else
    {
      code_lengths_node = code_lengths_node-&gt;zero;
    }
    if ( code_lengths_node-&gt;code != -1 )
    {
      if ( code_lengths_node-&gt;code &gt; 15 )
      {
        int repeat_length;
        switch ( code_lengths_node-&gt;code )
        {
          case 16:
            repeat_length = read_bits_inv( stream, 2 ) + 3;
            break;
          case 17:
            repeat_length = read_bits_inv( stream, 3 ) + 3;
            break;
          case 18:
            repeat_length = read_bits_inv( stream, 7 ) + 11;
            break;
        }
        while ( repeat_length-- )
        {
          if ( code_lengths_node-&gt;code == 16 )
          {
            alphabet[ i ] = alphabet[ i - 1 ];
          }
          else
          {
            alphabet[ i ] = 0;
          }
          i++;
        }
      }
      else
      {
        alphabet[ i ] = code_lengths_node-&gt;code;
        i++;
      }
      code_lengths_node = &amp;code_lengths_root;
    }
  }
  // Ok, now the alphabet lengths have been read. Turn _those_
  // into a valid range declaration and build the final huffman
  // code from it.
  j = 0;
  for ( i = 0; i &lt;= ( hlit + 257 ); i++ )
  {
    if ( ( i &gt; 0 ) &amp;&amp; ( alphabet[ i ] != alphabet[ i - 1 ] ) )
    {
      j++;
    }
    alphabet_ranges[ j ].end = i;
    alphabet_ranges[ j ].bit_length = alphabet[ i ];
  }
  build_huffman_tree( literals_root, j, alphabet_ranges );

  i--;
  j = 0;
  for ( ; i &lt;= ( hdist + hlit + 258 ); i++ )
  {
    if ( ( i &gt; ( 257 + hlit ) ) &amp;&amp; ( alphabet[ i ] != alphabet[ i - 1 ] ) )
    {
      j++;
    }
    alphabet_ranges[ j ].end = i - ( 257 + hlit );
    alphabet_ranges[ j ].bit_length = alphabet[ i ];
  }
  build_huffman_tree( distances_root, j, alphabet_ranges );
  free( alphabet );
  free( alphabet_ranges );
}
</pre>
<p>Listing 16: Read the literal/length and distance code Huffman trees</p>
<p>
This is a bit dense, but implements the logic for using the code lengths Huffman tree to build two new Huffman trees which can then be used to decode the final LZ77-compressed data.
</p>
<p>
The process of actually reading the compressed data involves first interpreting a Huffman code according to the literal/length table. Check to see if it&#39;s a literal (e.g. &lt; 256) and if so, output it. If it&#39;s the stop code (e.g. = 256), stop. If it&#39;s a length code (e.g. &gt; 256), it&#39;s a backpointer.
</p>
<p>
Interpreting backpointers is the most complex part of inflating gzipped input. Similar to the &#34;sliding scales&#34; that were used by the code lengths Huffman tree, where a 17 was followed by three bits indicating the actual length and 18 was followed by 7 bits, different length codes are followed by variable numbers of extra bits. If the length code is between 257 and 264, subtract 254 from it - this is the length of the backpointed range, without any extra length bits. However, if the length code is in the range 265 to 285, it&#39;s followed by ( code - 261 ) / 4 bits of extra data which indicate a length. These bits are then added to another code (whose value depends on the length code itself) to get the actual length of the range. In this way, very large backpointers can be represented, but the common cases of short lengths can be coded efficiently.
</p>
<p>
A length code is always followed by a distance code, indicating how far back in the input buffer the matched range was found. Distance codes allow for extra bits just like length codes do - the distance code values 0-3 are literally matched, while the remaining 28 are followed by ( code - 2 ) / 2 bits of extra data, to which a variable number is added. The lengths codes can range from 3-258, but the distance codes can range from 1-32768 - which means that, while decompressing, it&#39;s necessary to keep track of at least the previous 32,768 input characters.
</p>
<p>
Listing 17 illustrates how to use the literal/length and distance Huffman trees to interpret and decompress LZ77-compressed data from a bit stream.
</p><pre>#define MAX_DISTANCE 32768
static int inflate_huffman_codes( bit_stream *stream,
                                  huffman_node *literals_root,
                                  huffman_node *distances_root )
{
  huffman_node *node;
  int stop_code = 0;
  unsigned char buf[ MAX_DISTANCE ];
  unsigned char *ptr = buf;
  int extra_length_addend[] = {
    11, 13, 15, 17, 19, 23, 27,
    31, 35, 43, 51, 59, 67, 83,
    99, 115, 131, 163, 195, 227
  };
  int extra_dist_addend[] = {
    4, 6, 8, 12, 16, 24, 32, 48,
    64, 96, 128, 192, 256, 384,
    512, 768, 1024, 1536, 2048,
    3072, 4096, 6144, 8192,
    12288, 16384, 24576
  };
  node = literals_root;
  while ( !stop_code )
  {
    if ( feof( stream-&gt;source ) )
    {
      fprintf( stderr, &#34;Premature end of file.\n&#34; );
      return 1;
    }
    if ( next_bit( stream ) )
    {
      node = node-&gt;one;
    }
    else
    {
      node = node-&gt;zero;
    }
    if ( node-&gt;code != -1 )
    {
      // Found a leaf in the tree; decode a symbol
      assert( node-&gt;code &lt; 286 ); // should never happen
      // leaf node; output it
      if ( node-&gt;code &lt; 256 )
      {
        *(ptr++) = node-&gt;code;
      }
      if ( node-&gt;code == 256 )
      {
        stop_code = 1;
        break;
      }
      if ( node-&gt;code &gt; 256 )
      {
        int length;
        int dist;
        int extra_bits;
        // This is a back-pointer to a position in the stream
        // Interpret the length here as specified in 3.2.5
        if ( node-&gt;code &lt; 265 )
        {
          length = node-&gt;code - 254;
        }
        else
        {
          if ( node-&gt;code &lt; 285 )
          {
            extra_bits = read_bits_inv( stream, ( node-&gt;code - 261 ) / 4 );
            length = extra_bits + extra_length_addend[ node-&gt;code - 265 ];
          }
          else
          {
            length = 258;
          }
        }
        // The length is followed by the distance.
        // The distance is coded in 5 bits, and may be
        // followed by extra bits as specified in 3.2.5
        node = distances_root;
        while ( node-&gt;code == -1 )
        {
          if ( next_bit( stream ) )
          {
            node = node-&gt;one;
          }
          else
          {
            node = node-&gt;zero;
          }
        }
        dist = node-&gt;code;
        if ( dist &gt; 3 )
        {
          int extra_dist = read_bits_inv( stream, ( dist - 2 ) / 2 );
          dist = extra_dist + extra_dist_addend[ dist - 4 ];
        }
        // TODO change buf into a circular array so that it
        // can handle files of size &gt; 32768 bytes
        {
          unsigned char *backptr = ptr - dist - 1;
          while ( length-- )
          {
            // Note that ptr &amp; backptr can overlap
            *(ptr++) = *(backptr++);
          }
        }
      }
      node = literals_root;
    }
  }
  *ptr = &#39;\0&#39;;
  printf( &#34;%s\n&#34;, buf );
  return 0;
}
</pre>
<p>Listing 17: Inflating Huffman-encoded LZ77-compressed input</p>
<p>
Listing 17 should be fairly straightforward to understand at this point - read Huffman codes, one after another, and interpret them as literals or backpointers as described previously. Note that this routine, as implemented, can&#39;t decode more than 32768 bytes of output, and that it assumes that the output is ASCII-formatted text. A more general-purpose gunzip routine would handle larger volumes of data and would return the result back to the caller for interpretation.
</p>
<p>
If you&#39;ve made it this far, you&#39;re through the hard parts. Everything else involved in unzipping a gzipped file is boilerplate. A gzipped file starts with a header that first declares it as a gzipped file and declares some metadata about the file itself. Describe a couple of structures to house this data as shown in listing 18:
</p><pre>typedef struct
{
  unsigned char id[ 2 ];
  unsigned char compression_method;
  unsigned char flags;
  unsigned char mtime[ 4 ];
  unsigned char extra_flags;
  unsigned char os;
}
gzip_header;
typedef struct
{
  gzip_header header;
  unsigned short xlen;
  unsigned char *extra;
  unsigned char *fname;
  unsigned char *fcomment;
  unsigned short crc16;
}
gzip_file;
</pre>
<p>Listing 18: The top-level gzip file structure</p>
<p>
Go ahead and declare a main routine as shown in listing 19 that expects to be passed in the name of a gzipped file, and will read the header and output some of its metadata.
</p><pre>#define FTEXT 0x01
#define FHCRC 0x02
#define FEXTRA 0x04
#define FNAME 0x08
#define FCOMMENT 0x10
int main( int argc, char *argv[ ] )
{
  FILE *in;
  gzip_file gzip;
  gzip.extra = NULL;
  gzip.fname = NULL;
  gzip.fcomment = NULL;
  if ( argc &lt; 2 )
  {
    fprintf( stderr, &#34;Usage: %s &lt;gzipped input file&gt;\n&#34;, argv[ 0 ] );
    exit( 1 );
  }
  in = fopen( argv[ 1 ], &#34;r&#34; );
  if ( !in )
  {
    fprintf( stderr, &#34;Unable to open file &#39;%s&#39; for reading.\n&#34;, argv[ 1 ] );
    exit( 1 );
  }
  if ( fread( &amp;gzip.header, sizeof( gzip_header ), 1, in ) &lt; 1 )
  {
    perror( &#34;Error reading header&#34; );
    goto done;
  }
  if ( ( gzip.header.id[ 0 ] != 0x1f ) || ( gzip.header.id[ 1 ] != 0x8b ) )
  {
    fprintf( stderr, &#34;Input not in gzip format.\n&#34; );
    goto done;
  }
  if ( gzip.header.compression_method != 8 )
  {
    fprintf( stderr, &#34;Unrecognized compression method.\n&#34; );
    goto done;
  }
  if ( gzip.header.flags &amp; FEXTRA )
  {
    // TODO spec seems to indicate that this is little-endian;
    // htons for big-endian machines?
    if ( fread( &amp;gzip.xlen, 2, 1, in ) &lt; 1 )
    {
      perror( &#34;Error reading extras length&#34; );
      goto done;
    }
    gzip.extra = ( unsigned char * ) malloc( gzip.xlen );
    if ( fread( gzip.extra, gzip.xlen, 1, in ) &lt; 1 )
    {
      perror( &#34;Error reading extras&#34; );
      goto done;
    }
    // TODO interpret the extra data
  }
  if ( gzip.header.flags &amp; FNAME )
  {
    if ( read_string( in, &amp;gzip.fname ) )
    {
      goto done;
    }
  }
  if ( gzip.header.flags &amp; FCOMMENT )
  {
    if ( read_string( in, &amp;gzip.fcomment ) )
    {
      goto done;
    }
  }
  if ( gzip.header.flags &amp; FHCRC )
  {
    if ( fread( &amp;gzip.crc16, 2, 1, in ) &lt; 1 )
    {
      perror( &#34;Error reading CRC16&#34; );
      goto done;
    }
  }
...
</pre>
<p>Listing 19: main routine to strip off the GZIP header</p>
<p>
I won&#39;t go over this in detail; refer to RFC 1952 [5] if you want more specifics. Note that a gzip file must begin with the magic bytes 1F8B, or it&#39;s not considered a valid gzipped file. Also note that a gzipped file can be prepended with an optional original filename and/or a comment - these are given in null-terminated ASCII form. Finally, the header can optionally be protected by a CRC16, although this is rare.
</p>
<p>
Once the header is read, the compressed data, as described by the routines above, follows. However, there&#39;s one extra layer of header metadata. A gzipped file actual consists of multiple blocks of deflated data (usually there&#39;s just one block, but the file format permits more than one). The blocks themselves can either be uncompressed or compressed according to the deflate specification described previously. Also, in a nod to space efficiency, very small inputs can use a boilerplate set of Huffman codes, and not declare their own Huffman tables at all. This way, if the compressed data is actually larger than the original input when the Huffman tables are included, the data can be reasonably compressed.
</p>
<p>
The GZIP file format, then, after the standard header, consists of a series of blocks. The block format is a single bit indicating whether or not this block is the last block (1 = yes, 0 = no), and two bits indicating the block type: 00 = uncompressed, 01 = compressed using fixed Huffman codes, 10 = compressed using declared dynamic Huffman codes (11 is an invalid block type). Listing 20 illustrates the final inflate routine that reads the block type and calls the appropriate inflation routine:
</p><pre>static int inflate( FILE *compressed_input )
{
  // bit 8 set indicates that this is the last block
  // bits 7 &amp; 6 indicate compression type
  unsigned char block_format;
  bit_stream stream;
  int last_block;
  huffman_node literals_root;
  huffman_node distances_root;
  stream.source = compressed_input;
  fread( &amp;stream.buf, 1, 1, compressed_input );
  stream.mask = 0x01;
  do
  {
    last_block = next_bit( &amp;stream );
    block_format = read_bits_inv( &amp;stream, 2 );
    switch ( block_format )
    {
      case 0x00:
        fprintf( stderr, &#34;uncompressed block type not supported.\n&#34; );
        return 1;
        break;
      case 0x01:
        memset( &amp;literals_root, &#39;\0&#39;, sizeof( huffman_node ) );
        build_fixed_huffman_tree( &amp;literals_root );
        inflate_huffman_codes( &amp;stream, &amp;literals_root, NULL );
        break;
      case 0x02:
        memset( &amp;literals_root, &#39;\0&#39;, sizeof( huffman_node ) );
        memset( &amp;distances_root, &#39;\0&#39;, sizeof( huffman_node ) );
        read_huffman_tree( &amp;stream, &amp;literals_root, &amp;distances_root );
        inflate_huffman_codes( &amp;stream, &amp;literals_root, &amp;distances_root );
        break;
      default:
        fprintf( stderr, &#34;Error, unsupported block type %x.\n&#34;, block_format );
        return 1;
    }
  }
  while ( !last_block );
  return 0;
}
</pre>
<p>Listing 20: inflating multiple blocks</p>
<p>
Notice that the bit stream declared in listing 11 is initialized here. The read_huffman_tree from listing 16 is called if the block type is 10, and inflate_huffman_codes from listing 17 is called in either case to actually deflate the data.
</p>
<p>
The only new routine here is build_fixed_huffman_tree, and is shown in listing 21:
</p><pre>static void build_fixed_huffman_tree( huffman_node *root )
{
  huffman_range range[ 4 ];
  range[ 0 ].end = 143;
  range[ 0 ].bit_length = 8;
  range[ 1 ].end = 255;
  range[ 1 ].bit_length = 9;
  range[ 2 ].end = 279;
  range[ 2 ].bit_length = 7;
  range[ 3 ].end = 287;
  range[ 3 ].bit_length = 8;
  build_huffman_tree( root, 4, range );
}
</pre>
<p>Listing 21: Build fixed Huffman tree</p>
<p>
As you can imagine, this fixed Huffman tree isn&#39;t optimal for any input data set, but if the input is small (less than a few hundred bytes), it&#39;s better to use this less efficient Huffman tree to encode the literals and lengths than to use up potentially a few hundred bytes declaring a more targeted Huffman tree. Notice also that there&#39;s no distance tree - when fixed Huffman trees are used, the distances are always specified in five bits, not coded. To support this, make the small change in listing 22 to the inflate_huffman_codes routine:
</p><pre>  else
  {
    length = 258;
  }
}
// The length is followed by the distance.
// The distance is coded in 5 bits.
<b>
if ( distances_root == NULL )
{
  // Hardcoded distances
  dist = read_bits_inv( stream, 5 );
}
else
{
  // dynamic distances
	</b>
  node = distances_root;
  while ( node-&gt;code == -1 )
  {
    if ( next_bit( stream ) )
    {
      node = node-&gt;one;
    }
    else
    {
      node = node-&gt;zero;
    }
  }
  dist = node-&gt;code;
	<b>
}
</b>
</pre>
<p>Listing 22: Supporting hardcoded distances in inflate_huffman_codes</p>
<p>
Notice that the hardcoded distances are still subject to &#34;extra bit&#34; interpretation just like the dynamic ones are.
</p>
<p>
That&#39;s almost it. Insert a call to &#34;inflate&#34; at the end of the main routine as shown in listing 23:
</p><pre>if ( gzip.header.flags &amp; FHCRC )
{
  if ( fread( &amp;gzip.crc16, 2, 1, in ) &lt; 1 )
  {
    perror( &#34;Error reading CRC16&#34; );
    goto done;
  }
}
<b>
if ( inflate( in ) )
{
  goto done;
}
</b>
</pre>
<p>Listing 23: call the inflate routine</p>

<p>
In fact, that could be it - except that there&#39;s a small problem with compressing data. With uncompressed data, one bit error affects at best one byte, and at worst a contiguous chunk of data - but a flipped bit in uncompressed data doesn&#39;t render the whole document unreadable. Compressed data, due to it&#39;s natural push to make the most efficient use of space down to the bit level, is highly susceptible to minor errors. A single bit flipped in transmission will change the meaning of the entire remainder of the document. Although bit-flipping errors are rarer and rarer on modern hardware, you still want some assurance that what you decompressed was what the author compressed in the first place. Whereas with ASCII text, it&#39;s obvious to a human reader that the data didn&#39;t decompress correctly if an error occurs, imagine a binary document that represents, for instance, weather meter readings. The readings can range from 0-255 and vary wildly; if the document uncompressed incorrectly, the reader would have no way to detect the error.
</p>
<p>
Therefore, GZIP mandates that each document end with a standard trailer that consists of a Cyclic Redundancy Check (CRC) and the length of the uncompressed data. The decompressor can compare both to the output and verify that they&#39;re correct before blessing the document as correctly inflated.
</p>
<p>
A CRC is sort of like a checksum, but a more reliable one. A checksum is a simple mechanism to give the receiver some assurance that what was sent is what was received - the concept is to sum all of the input bytes modulo an agreed-upon base (typically 2<sup>32</sup>) and transmit the resulting sum. This is simple for each side to quickly compute, and if either side disagrees on the result, something has gone wrong during transmission.
</p>
<p>
However, checksums aren&#39;t optimal when it comes to detecting bit errors. If a single bit is flipped, then the checksums won&#39;t match, as you would want. However, if two bits are flipped, it&#39;s possible that they can flip in such a way as to cancel each other out, and the checksum won&#39;t detect the error. The CRC, developed in W. Peterson in 1961 [6], is a more robust check mechanism which is less susceptible to this error cancellation.
</p>
<p>
In a future installment of this series, I&#39;ll cover the CRC32 value and add support for CRC32 validation to the gunzip routine presented here. However, I&#39;d encourage you to download the source code and use it to decompress a few small documents and step through the code to see if you can understand what&#39;s going on and how it all works. Of course, if you want to do any real decompression, use a real tool such as GNU Gunzip. However, I&#39;ve found the utility described here very helpful in understanding how the algorithm works and how GZIP compression goes about doing its job.
</p>
<p>
I believe that the code in this article is free from errors, but I haven&#39;t
tested it extensively - please, whatever you do, don&#39;t use it in a production
environment (use <a href="http://www.gzip.org">GNU gzip</a> instead!)  However,
if you do spot an error, please 
<a href="mailto:joshua.davies.tx@gmail.com">let me know</a> about it.
</p>
<p>
References:
</p><ol>
<li>Jacob Ziv and Abraham Lempel &#34;A Universal Algorithm for Sequential Data Compression&#34;, IEEE Transactions on Information Theory, 23(3), pp. 337-343, May 1977</li>
<li>D.A. Huffman, &#34;A Method for the Construction of Minimum-Redundancy Codes&#34;, Proceedings of the I.R.E., September 1952, pp 1098-1102</li>
<li>http://www.ietf.org/rfc/rfc1951.txt</li>
<li>http://www.fileformat.info/mirror/egff/ch09_03.htm</li>
<li>http://www.ietf.org/rfc/rfc1952.txt</li>
<li>&#34;Cyclic Codes for Error Detection&#34;, Proceedings of the IRE, 1961</li>
</ol>

</div>
  </body>
</html>
