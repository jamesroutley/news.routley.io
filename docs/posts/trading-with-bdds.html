<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://taeric.github.io/trading-with-bdds.html">Original</a>
    <h1>Trading with BDDs</h1>
    
    <div id="readability-page-1" class="page"><div id="content">



<div id="outline-container-orgd3dc523">
<h2 id="orgd3dc523">Introduction</h2>
<div id="text-orgd3dc523">
<p>
At work, we had a fun &#34;hackathon&#34; where we looked at finding the &#34;best&#34;
buy/sell strategy in a stock history.  Not shockingly, finding the single
best option was easy.  Extending to find the best \(N\) trades expectedly
slowed down everyone.  I know that I am terrible at dynamic programming
techniques, so I mostly sat that one out.  I did give it a try later, but
didn&#39;t come up with anything of note.  (And I was shown a leetcode writeup
on the normal methods for doing this.)
</p>

<p>
Someone else on the team, though, did this using a MIP formulation that
performed rather well.  More, an amusing aspect of the formulation made me
think about this in terms of another data structure I have yet to use.
</p>

<p>
Specifically, the thing I noticed was that the MIP formulation treated
buying and selling as two distinct things.  Whereas before, I lumped them
together and then had to deal with overlapping intervals, the MIP
formulation just put them together and then had another constraint that the
sum of buys was always greater than the sum of sells.
</p>

<p>
That got me thinking that maybe this would work in a Binary Decision
Diagram (BDD).  And since I&#39;ve never actually managed to use one of those,
I thought I would find out.  (It also helped that I was going in for a
medical procedure and could only think on the idea.)
</p>

<p>
Briefly, a binary decision diagram is a DAG that goes across yes/no
decision variables and either ends in True or False.  Where you can exit
early in the decisions at any time.  In general, the size of a BDD can get
silly large, such that there are variants that are mostly false that deal
with some common problems.
</p>

<p>
My first attempt to build a diagram for this was not promising, as over
just 4 days, I was looking to have 28 nodes in the diagram already.
However, playing with it for a bit, I realized that I would only need 15
total nodes for 4 days.  Even better, I realized this grew rather slowly
for each added day, such that I only need \(2.5N\) total nodes over \(N\) days
of possible trades.
</p>
</div>
</div>

<div id="outline-container-org7adebdc">
<h2 id="org7adebdc">Loading market data.</h2>
<div id="text-org7adebdc">
<p>
So, lets get to coding.  We&#39;ll need the market data loaded up.  Just
pulling that into a global.  For this experiment, I loaded up
<a href="https://www.wsj.com/market-data/quotes/index/DJIA/historical-prices">https://www.wsj.com/market-data/quotes/index/DJIA/historical-prices</a> back
to 1980.
</p>

<div>
<pre>(<span>defstruct</span> <span>market-info</span> date open high low close)

(<span>defvar</span> <span>*market-values*</span> (reverse
                         (<span>with-open-file</span> (in <span>&#34;~/Downloads/HistoricalPrices.csv&#34;</span>)
                          (read-line in) <span>;; </span><span>Just skipping the header</span>
                          <span>;; </span><span>And some shenanigans to read in the data.</span>
                          <span>;; </span><span>Clearly, don&#39;t do this anywhere other than</span>
                          <span>;; </span><span>toys...</span>
                          (<span>let</span> ((*readtable* (copy-readtable nil)))
                            (set-syntax-from-char #\, #\ )
                            (<span>loop</span> for date = (read in nil)
                                  for open = (read in nil)
                                  for high = (read in nil)
                                  for low = (read in nil)
                                  for close = (read in nil)

                                  while date collect (make-market-info <span>:date</span> (string date)
                                                                       <span>:open</span> open
                                                                       <span>:high</span> high
                                                                       <span>:low</span> low
                                                                       <span>:close</span> close))))))

(length *market-values*)
</pre>
</div>

<pre>10652
</pre>


<p>
Taking a brief look, we see the min/max of this dataset as:
</p>

<div>
<pre>(<span>loop</span> for market-value in *market-values*
      minimize (market-info-close market-value) into min
      maximize (market-info-close market-value) into max
      finally (<span>return</span> (list min max)))
</pre>
</div>

<table>


<colgroup>
<col/>

<col/>
</colgroup>
<tbody>
<tr>
<td>776.91</td>
<td>36799.65</td>
</tr>
</tbody>
</table>

<p>
With luck, we can force our algorithm to find these values later.
</p>
</div>
</div>

<div id="outline-container-org7e80b1b">
<h2 id="org7e80b1b">Building a BDD</h2>
<div id="text-org7e80b1b">
<p>
So, again, what is a BDD?  Simply stated, it is a graph of nodes
representing choice variables, where each choice is true/false, so the out
degree of each node is 2.  The out links are &#34;hi&#34; and &#34;lo&#34; branch where
&#34;hi&#34; would be what you do if the referenced variable is true, and &#34;lo&#34;
false.  (You may be asking why I&#39;m using hi/lo and a few other choices.
That is lifted straight from Knuth&#39;s Art of Computer Programming.  Lifting
a bit directly, as I have not built an intuition for any of this, yet.)
</p>

<div>
<pre>(<span>defstruct</span> <span>bdd-node</span> v lo hi aux)
</pre>
</div>

<p>
And then building our diagram of choices looks rather involved, but it is
somewhat easily stated.  I have a boolean variable for whether to buy and
sell on each day except the first and the last, as you can only buy or sell
on that day.  I order the variables such that the odd variables are to buy
on a given day, and even are to sell on a given day.
</p>

<p>
For example, if we wanted to look for the best strategy over 4 days, we
would have 6 variables.  Variable 1 is to buy on the first day, variable 2
is to sell on the next day, with variable 3 to buy on that day, etc.
</p>

<p>
With that, we have a decision diagram that looks roughly like:
</p>


<p><img src="https://taeric.github.io/example-bdd.png" alt="example-bdd.png"/>
</p>

<p>
To read this, nodes are named for the variable they represent.  I have them
arranged in 3 general columns, where the first column indicates that there
is not at open trade, the second column is that there is an open trade, and
the last is for when a cooldown to not allow a buy immediately after a
sell.  (This is needed so that you do not sell and buy on the same day.)
Following a route through this diagram is to start on the first variable,
and either take the solid path for &#34;true&#34; on that variable, or the dotted
for &#34;false.&#34;  If you ever hit the bottom node, you did something that is
not allowed.  (So, sell before you have bought, for example.)
</p>

<p>
The super nice thing about this formulation, is that every added day just
adds another two &#34;layers&#34; to this diagram.  We just have to make sure that
the last day hooks up to the &#34;true&#34; and &#34;false&#34; nodes in the diagram
correctly.  Easy peasy.
</p>

<p>
For reasons of &#34;I&#39;m going to naively follow some algorithms from the book,&#34;
I am going to store all of the decision nodes in an array where the links
are indexes into the array.  And the root of the BDD will be the high end
of the array.
</p>

<div>
<pre>(<span>defun</span> <span>make-trading-bdd</span> (num-days)
  <span>&#34;Will create and return an array of bdd-nodes for trading over a given</span>
<span>number of days.&#34;</span>

  (<span>let*</span> ((num-variables (+ (* 2 (- num-days 2)) 2))
         (num-nodes     (* 5/2 num-variables))
         (bdd-nodes     (make-array num-nodes <span>:element-type</span> &#39;bdd-node <span>:initial-element</span> (make-bdd-node))))

    <span>;;</span><span>Root of the bdd is the only &#34;level&#34; with a single node.</span>
    <span>;;</span><span>And the bottom are the two sinks</span>
    (<span>let</span> ((root (1- num-nodes)))
      (setf (elt bdd-nodes root) (make-bdd-node <span>:v</span> 1
                                                <span>:hi</span> (- root 2)
                                                <span>:lo</span> (- root 1))
            (elt bdd-nodes 1)    (make-bdd-node <span>:v</span> (1+ num-variables)
                                                <span>:lo</span> 1
                                                <span>:hi</span> 1)
            (elt bdd-nodes 0)    (make-bdd-node <span>:v</span> (1+ num-variables)
                                                <span>:lo</span> 0
                                                <span>:hi</span> 0)))

    (<span>loop</span> with i = (- (length bdd-nodes) 2)
          for v from 2 to num-variables

          if (evenp v)
            do (setf (elt bdd-nodes i)      (make-bdd-node <span>:v</span> v
                                                           <span>:lo</span> (max (- i 2) 1)
                                                           <span>:hi</span> 0)
                     (elt bdd-nodes (1- i)) (make-bdd-node <span>:v</span> v
                                                           <span>:lo</span> (- i 3)
                                                           <span>:hi</span> (max (- i 4) 1))
                     i                        (- i 2))
          else
            do (setf (elt bdd-nodes i)       (make-bdd-node <span>:v</span> v
                                                            <span>:lo</span> (- i 3)
                                                            <span>:hi</span> (- i 4))
                     (elt bdd-nodes (- i 1)) (make-bdd-node <span>:v</span> v
                                                            <span>:lo</span> (- i 4)
                                                            <span>:hi</span> 0)
                     (elt bdd-nodes (- i 2)) (make-bdd-node <span>:v</span> v
                                                            <span>:lo</span> (- i 3)
                                                            <span>:hi</span> 0)
                     i                         (- i 3)))

    <span>;; </span><span>With some fixup on the end.</span>
    (setf (bdd-node-hi (elt bdd-nodes 3)) 0)

    bdd-nodes))
</pre>
</div>

<pre>MAKE-TRADING-BDD
</pre>
</div>
</div>

<div id="outline-container-orgf1d2bfa">
<h2 id="orgf1d2bfa">How many solutions?</h2>
<div id="text-orgf1d2bfa">
<p>
So, that was far more dense than I&#39;d appreciate in production code.  Did it
work?
</p>

<p>
First, we need some algorithms this enables.  For the first of those, lets
see if we can annotate the tree with how many solutions there are to it.
(The book uses an extra array `c` for this, but I&#39;m just storing those
values attached to the instructions in `aux` for now.)
</p>

<div>
<pre>(<span>defun</span> <span>count-solutions</span> (bdd-nodes)
  (setf (bdd-node-aux (elt bdd-nodes 0)) 0
        (bdd-node-aux (elt bdd-nodes 1)) 1)

  (<span>loop</span> for k from 2 below (length bdd-nodes)
        do (<span>let</span> ((l (bdd-node-lo (elt bdd-nodes k)))
                 (h (bdd-node-hi (elt bdd-nodes k)))
                 (v (bdd-node-v  (elt bdd-nodes k))))
             (setf (bdd-node-aux (elt bdd-nodes k)) (+ (* (expt 2 (- (bdd-node-v (elt bdd-nodes l)) v 1)) (bdd-node-aux (elt bdd-nodes l)))
                                                       (* (expt 2 (- (bdd-node-v (elt bdd-nodes h)) v 1)) (bdd-node-aux (elt bdd-nodes h)))))))

  (* (expt 2 (1- (bdd-node-v (elt bdd-nodes (1- (length bdd-nodes)))))) (bdd-node-aux (elt bdd-nodes (1- (length bdd-nodes))))))

<span>;; </span><span>Lets look at the general growth of this.  (Is a very obvious pattern...)</span>
(list (list 2 (count-solutions (make-trading-bdd 2)))
      (list 3 (count-solutions (make-trading-bdd 3)))
      (list 4 (count-solutions (make-trading-bdd 4)))
      (list 5 (count-solutions (make-trading-bdd 5)))
      (list 6 (count-solutions (make-trading-bdd 6)))
      (list 7 (count-solutions (make-trading-bdd 7)))
      (list 8 (count-solutions (make-trading-bdd 8)))
      <span>;; </span><span>And for the last value, going to just look at size of the answer</span>
      (list (length *market-values*) (log (count-solutions (make-trading-bdd (length *market-values*))) 10)))
</pre>
</div>

<table>


<colgroup>
<col/>

<col/>
</colgroup>
<tbody>
<tr>
<td>2</td>
<td>2</td>
</tr>

<tr>
<td>3</td>
<td>4</td>
</tr>

<tr>
<td>4</td>
<td>8</td>
</tr>

<tr>
<td>5</td>
<td>16</td>
</tr>

<tr>
<td>6</td>
<td>32</td>
</tr>

<tr>
<td>7</td>
<td>64</td>
</tr>

<tr>
<td>8</td>
<td>128</td>
</tr>

<tr>
<td>10652</td>
<td>3206.2705</td>
</tr>
</tbody>
</table>

<p>
That last value is the size of the search space for optimal trading over
\(10,652\) days.  I didn&#39;t expect this to be a power of two, but I see no
reason not to trust it.  And, it is a heck of a number.
</p>
</div>
</div>

<div id="outline-container-org70f3a36">
<h2 id="org70f3a36">Finding the optimal solution</h2>
<div id="text-org70f3a36">
<p>
Ok, that is fun to consider.  But, can we find the optimal solution?  Not
shockingly, the answer is yes.  The book mentions that &#34;we can solve the
linear Boolean programming problem&#34; for this.  That being &#34;Find \(x\) such
that \(w_1x_1 + \ldots + w_nx_n\) is maximum, subject to \(f(x_1,\ldots,x_n)\).
</p>

<p>
And it goes to give the general algorithm for doing that as the following.
(Note that this is largely transcribed from source, and I haven&#39;t built the
understanding of the code that is needed to make it presentable, yet.)
</p>

<div>
<pre>(<span>defun</span> <span>maximal-cost-solution</span> (bdd-nodes weights)
  (<span>let*</span> ((s (length bdd-nodes))
       (n (1- (bdd-node-v (elt bdd-nodes 0)))) <span>;;</span><span>Taking advantage of the sentinel on the false sink to know &#34;n&#34;</span>
       (m (make-array (1+ s)))
       (x (make-array n))
       (at (make-array (1+ s)))
       (W (make-array (+ 2 n))))                 <span>;; </span><span>Something about 1 based indexing...</span>
  (setf (elt W 0) nil)
  (setf (elt W (1+ n)) 0)
  (<span>loop</span> for j from n downto 1
        do (setf (elt W j) (+ (elt W (1+ j)) (max (elt weights (1- j)) 0))))

  (setf (elt m 1) 0)
  (<span>loop</span> for k from 2 below s
        do (<span>let*</span> ((cur-node (elt bdd-nodes k))
                  (v (bdd-node-v cur-node))
                  (l (bdd-node-lo cur-node))
                  (h (bdd-node-hi cur-node))
                  (mt 0)) <span>;tmp m</span>
             (setf (elt at k) 0)

             (<span>unless</span> (= l 0)
               (setf (elt m k) (+ (elt m l)
                                  (elt W (1+ v))
                                  (- (elt W (bdd-node-v (elt bdd-nodes l)))))))
             (<span>unless</span> (= h 0)
               (setf mt (+ (elt m h)
                           (elt W (1+ v))
                           (- (elt W (bdd-node-v (elt bdd-nodes h))))
                           (elt weights (1- v))))

               (<span>when</span> (or (= l 0) (&gt; mt (elt m k)))
                         (setf (elt m k) mt
                               (elt at k) 1)))))

  (<span>loop</span> with j = 0
        with k = (1- s)

        if (= j n)
          return x

        if (&lt; j (- (bdd-node-v (elt bdd-nodes k)) 1))
          do (setf j              (1+ j)
                   (elt x (1- j)) (<span>if</span> (&gt; (elt weights (1- j)) 0) 1 0))

        if (&gt; k 1)
          do (setf j              (1+ j)
                   (elt x (1- j)) (elt at k)
                   k              (<span>if</span> (= (elt at k) 0) (bdd-node-lo (elt bdd-nodes k))
                                      (bdd-node-hi (elt bdd-nodes k)))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org8ed7bc4">
<h2 id="org8ed7bc4">Trying it on just 4 days, first</h2>
<div id="text-org8ed7bc4">
<p>
We will need a weight vector for how much we value a buy/sell.  For the
larger trading question, we will build up something big.  To build some
confidence that we can trust this algorithm, though, lets look at just the
4 day idea.
</p>

<div>
<pre>(<span>let*</span> ((bdd-nodes (make-trading-bdd 4))
       (weights   #(1 2 3 4 5 6))
       (solution  (maximal-cost-solution bdd-nodes weights)))

  (<span>loop</span> for p across weights
        for v across solution
        if (= v 1)
          sum p into profit
        sum v into trades
        finally (<span>return</span> (list (/ trades 2) profit))))
</pre>
</div>

<table>


<colgroup>
<col/>

<col/>
</colgroup>
<tbody>
<tr>
<td>2</td>
<td>14</td>
</tr>
</tbody>
</table>

<p>
Of course, would be nicer to have a better idea of why that picked 2 trades
and how it got to 14 profit.  So, lets look closer at the &#34;solution&#34; we are
creating.
</p>

<div>
<pre>(<span>let*</span> ((bdd-nodes (make-trading-bdd 4))
       (weights   #(1 2 3 4 5 6))
       (solution  (maximal-cost-solution bdd-nodes weights)))

  (<span>loop</span> for i from 1
        for p across weights
        for v across solution

        if (= v 1)
          do (format t <span>&#34;Day ~a, ~a for ~a.~&amp;&#34;</span> (<span>if</span> (evenp i) (1+ (/ i 2)) (/ (1+ i) 2)) (<span>if</span> (evenp i) <span>&#34;Sell&#34;</span> <span>&#34;Buy&#34;</span>) p)))
</pre>
</div>

<pre>Day 1, Buy for 1.
Day 2, Sell for 2.
Day 3, Buy for 5.
Day 4, Sell for 6.
</pre>


<p>
Ok, that is good.  And it makes it obvious that I should have negative
costs in there, as the days that you buy are not cash positive.  Oops.
</p>

<p>
So, let us consider what our options are across 4 days.  We can:
</p>

<ol>
<li>buy, pass, pass, sell</li>
<li>buy, pass, sell, pass</li>
<li>buy, sell, pass, pass</li>
<li>buy, sell, buy, sell</li>
<li>pass, buy, pass, sell</li>
<li>pass, buy, sell, pass</li>
<li>pass, pass, buy, sell</li>
<li>pass, pass, pass, pass</li>
</ol>

<p>
And this matches the count of possible solutions across 4 days that we
calculated earlier, so can we force each of these options?
</p>

<div>
<pre>(<span>loop</span> for weights in (list #(-1 0 -1 0 -1 0)
                           #(-1 0 -2 0 -2 2)
                           #(-1 0 -2 2 -2 0)
                           #(-1 2 -1 0 -1 0)
                           #(-1 2 -1 0 -1 2)
                           #(-1 0 -1 2 -1 0)
                           #(-2 0 -1 0 -2 2)
                           #(-1 0 -2 0 -1 2))

      do (format t <span>&#34;Looking at ~a: ~&amp;&#34;</span> weights)
      do (<span>let*</span> ((bdd-nodes (make-trading-bdd 4))
                (solution  (maximal-cost-solution bdd-nodes weights)))

           (<span>loop</span> for i from 1
                 for p across weights
                 for v across solution

                 if (= v 1)
                   do (format t <span>&#34;             Day ~a, ~a for ~a.~&amp;&#34;</span> (<span>if</span> (evenp i) (1+ (/ i 2)) (/ (1+ i) 2)) (<span>if</span> (evenp i) <span>&#34;Sell&#34;</span> <span>&#34;Buy&#34;</span>) p))))
</pre>
</div>

<pre id="org5043c82">Looking at #(-1 0 -1 0 -1 0):
Looking at #(-1 0 -2 0 -2 2):
             Day 1, Buy for -1.
             Day 4, Sell for 2.
Looking at #(-1 0 -2 2 -2 0):
             Day 1, Buy for -1.
             Day 3, Sell for 2.
Looking at #(-1 2 -1 0 -1 0):
             Day 1, Buy for -1.
             Day 2, Sell for 2.
Looking at #(-1 2 -1 0 -1 2):
             Day 1, Buy for -1.
             Day 2, Sell for 2.
             Day 3, Buy for -1.
             Day 4, Sell for 2.
Looking at #(-1 0 -1 2 -1 0):
             Day 2, Buy for -1.
             Day 3, Sell for 2.
Looking at #(-2 0 -1 0 -2 2):
             Day 2, Buy for -1.
             Day 4, Sell for 2.
Looking at #(-1 0 -2 0 -1 2):
             Day 3, Buy for -1.
             Day 4, Sell for 2.
</pre>

<p>
Rather dense reading there; but, matches expectations.  Yay!
</p>
</div>
</div>

<div id="outline-container-org7b546e0">
<h2 id="org7b546e0">Back to the full market data</h2>
<div id="text-org7b546e0">
<p>
Now, to build up the weights for the giant solution.  For the odd
variables, that is spending the money of the close for the relevant day.
For the even values, it is gaining the value for the close for the relevant
day.  (Minus transaction costs, that we default to 0 on all values.)
</p>

<div>
<pre>(<span>defun</span> <span>make-trade-weights</span> (market-values <span>&amp;optional</span> (transaction-cost 0))
  (<span>let*</span> ((num-variables     (+ (* 2 (- (length market-values) 2)) 2))
         (weights           (make-array num-variables)))
    <span>;;</span><span>First and last are alone, so setting them alone.</span>
    (setf (elt weights 0)                  (- (- (market-info-close (elt market-values 0))) transaction-cost))
    (setf (elt weights (1- num-variables)) (- (market-info-close (car (last market-values))) transaction-cost))

    <span>;;</span><span>Rest of the days are used for a buy and a sell</span>
    (<span>loop</span> for day in (cdr (butlast market-values))
          for i from 1 by 2
          do (setf (elt weights i)      (- (market-info-close day) transaction-cost)
                   (elt weights (1+ i)) (- (- (market-info-close day)) transaction-cost)))
    weights))
</pre>
</div>

<p>
So, now that we have all of this, what is our answer?
</p>

<div>
<pre>(<span>let*</span> ((bdd-nodes (make-trading-bdd (length *market-values*)))
       (weights   (make-trade-weights *market-values*))
       (solution  (maximal-cost-solution bdd-nodes weights)))

  (<span>loop</span> for p across weights
        for v across solution
        if (= v 1)
          sum p into profit
        sum v into trades
        finally (<span>return</span> (format nil <span>&#34;~:d trades for a profit of ~~~:d.&#34;</span> (/ trades 2) (truncate profit)))))
</pre>
</div>

<pre>2,714 trades for a profit of ~427,741.
</pre>


<p>
And, how long did that take?
</p>

<div>
<pre>(<span>let</span> ((*TRACE-OUTPUT* *STANDARD-OUTPUT*))
  (time (<span>let*</span> ((bdd-nodes (make-trading-bdd (length *market-values*)))
               (weights   (make-trade-weights *market-values*))
               (solution  (maximal-cost-solution bdd-nodes weights)))

          (<span>loop</span> for p across weights
                for v across solution
                if (= v 1)
                  sum p into profit
                sum v into trades
                finally (<span>return</span> (format nil <span>&#34;~:d trades for a profit of ~~~:d.&#34;</span> (/ trades 2) (truncate profit)))))))
</pre>
</div>

<pre>Evaluation took:
  0.004 seconds of real time
  0.005063 seconds of total run time (0.005002 user, 0.000061 system)
  125.00% CPU
  19,200,488 processor cycles
  4,506,768 bytes consed

</pre>


<p>
So, yeah, fast and only about 4 megs of data generated.  I personally feel
this is insane and I was not expecting it to work.  Is fast enough that I
confess I&#39;m not sure I trust it.
</p>
</div>
</div>

<div id="outline-container-org7aefb01">
<h2 id="org7aefb01">Looking at the solutions a bit more.</h2>
<div id="text-org7aefb01">
<p>
As we noted at the start, the min/max spread of this is roughly \(36000.00\).
Such that, if the transaction cost was near that, we should be able to
force a single buy/sell.  Lets see what we can do there.
</p>

<div>
<pre>(<span>let*</span> ((bdd-nodes (make-trading-bdd (length *market-values*)))
       (weights   (make-trade-weights *market-values* (/ 36000 2)))
       (solution  (maximal-cost-solution bdd-nodes weights)))

  (<span>loop</span> for p across weights
        for v across solution
        if (= v 1)
          sum p into profit
        sum v into trades
        finally (<span>return</span> (format nil <span>&#34;~:d trade for a profit of ~~~:d.&#34;</span> (/ trades 2) (truncate profit)))))
</pre>
</div>

<pre>1 trade for a profit of ~22.
</pre>


<p>
And what day does that have us buying/selling?
</p>

<div>
<pre>(<span>let*</span> ((transaction-cost (/ 36000 2))
       (bdd-nodes (make-trading-bdd (length *market-values*)))
       (weights   (make-trade-weights *market-values* transaction-cost))
       (solution  (maximal-cost-solution bdd-nodes weights)))

  (<span>loop</span> for i from 1
        for p across weights
        for v across solution

        if (= v 1)
          do (format t <span>&#34;Day ~a, ~a for ~a.~&amp;&#34;</span> (<span>if</span> (evenp i) (1+ (/ i 2)) (/ (1+ i) 2)) (<span>if</span> (evenp i) <span>&#34;Sell&#34;</span> <span>&#34;Buy&#34;</span>) (+ transaction-cost p))))
</pre>
</div>

<pre>Day 492, Buy for -776.91016.
Day 10425, Sell for 36799.65.
</pre>


<p>
And this matches what we saw for the min/max of the closing value.  So, I
am starting to trust this more.
</p>

<p>
How easy is it to manipulate the result we are getting to constrict the
number of trades?  Seems within reason that I could easily get ballpark
number of optimal trades with a growing transaction cost.  That is, I
almost certainly can&#39;t target a specific N, but I can treat the transaction
cost as a lever to dial up and down the number of trades.
</p>

<p>
At the small level, this looks like:
</p>

<div>
<pre>(<span>loop</span> for transaction-cost from 0 to 10 by 1
      collect (<span>let*</span> ((bdd-nodes (make-trading-bdd (length *market-values*)))
                     (weights   (make-trade-weights *market-values* transaction-cost))
                     (solution  (maximal-cost-solution bdd-nodes weights)))

                (<span>loop</span> for p across weights
                      for v across solution
                      if (= v 1)
                        sum p into profit
                      sum v into trades
                      finally (<span>return</span> (list (format nil <span>&#34;A transaction cost of ~:d results in ~:d trades for a profit of ~~~:d.&#34;</span>
                                                    (truncate transaction-cost)
                                                    (/ trades 2)
                                                    (truncate profit)))))))
</pre>
</div>

<table>


<colgroup>
<col/>
</colgroup>
<tbody>
<tr>
<td>A transaction cost of 0 results in 2,714 trades for a profit of ~427,741.</td>
</tr>

<tr>
<td>A transaction cost of 1 results in 2,564 trades for a profit of ~422,492.</td>
</tr>

<tr>
<td>A transaction cost of 2 results in 2,424 trades for a profit of ~417,521.</td>
</tr>

<tr>
<td>A transaction cost of 3 results in 2,296 trades for a profit of ~412,839.</td>
</tr>

<tr>
<td>A transaction cost of 4 results in 2,172 trades for a profit of ~408,372.</td>
</tr>

<tr>
<td>A transaction cost of 5 results in 2,085 trades for a profit of ~404,181.</td>
</tr>

<tr>
<td>A transaction cost of 6 results in 2,018 trades for a profit of ~400,096.</td>
</tr>

<tr>
<td>A transaction cost of 7 results in 1,954 trades for a profit of ~396,129.</td>
</tr>

<tr>
<td>A transaction cost of 8 results in 1,886 trades for a profit of ~392,340.</td>
</tr>

<tr>
<td>A transaction cost of 9 results in 1,817 trades for a profit of ~388,645.</td>
</tr>

<tr>
<td>A transaction cost of 10 results in 1,747 trades for a profit of ~385,091.</td>
</tr>
</tbody>
</table>

<p>
And to get an idea at the large level, it looks like:
</p>

<div>
<pre>(<span>loop</span> for transaction-cost from 0 to 5500 by 250
      collect (<span>let*</span> ((bdd-nodes (make-trading-bdd (length *market-values*)))
                     (weights   (make-trade-weights *market-values* transaction-cost))
                     (solution  (maximal-cost-solution bdd-nodes weights)))

                (<span>loop</span> for p across weights
                      for v across solution
                      if (= v 1)
                        sum p into profit
                      sum v into trades
                      finally (<span>return</span> (list (format nil <span>&#34;A transaction cost of ~:d results in ~:d trades for a profit of ~~~:d.&#34;</span>
                                                    (truncate transaction-cost)
                                                    (/ trades 2)
                                                    (truncate profit)))))))
</pre>
</div>

<table>


<colgroup>
<col/>
</colgroup>
<tbody>
<tr>
<td>A transaction cost of 0 results in 2,714 trades for a profit of ~427,741.</td>
</tr>

<tr>
<td>A transaction cost of 250 results in 168 trades for a profit of ~150,320.</td>
</tr>

<tr>
<td>A transaction cost of 500 results in 62 trades for a profit of ~99,116.</td>
</tr>

<tr>
<td>A transaction cost of 750 results in 32 trades for a profit of ~77,099.</td>
</tr>

<tr>
<td>A transaction cost of 1,000 results in 17 trades for a profit of ~64,798.</td>
</tr>

<tr>
<td>A transaction cost of 1,250 results in 12 trades for a profit of ~57,510.</td>
</tr>

<tr>
<td>A transaction cost of 1,500 results in 8 trades for a profit of ~53,038.</td>
</tr>

<tr>
<td>A transaction cost of 1,750 results in 7 trades for a profit of ~49,457.</td>
</tr>

<tr>
<td>A transaction cost of 2,000 results in 7 trades for a profit of ~45,957.</td>
</tr>

<tr>
<td>A transaction cost of 2,250 results in 5 trades for a profit of ~42,757.</td>
</tr>

<tr>
<td>A transaction cost of 2,500 results in 5 trades for a profit of ~40,255.</td>
</tr>

<tr>
<td>A transaction cost of 2,750 results in 4 trades for a profit of ~38,220.</td>
</tr>

<tr>
<td>A transaction cost of 3,000 results in 3 trades for a profit of ~36,599.</td>
</tr>

<tr>
<td>A transaction cost of 3,250 results in 3 trades for a profit of ~35,099.</td>
</tr>

<tr>
<td>A transaction cost of 3,500 results in 3 trades for a profit of ~33,597.</td>
</tr>

<tr>
<td>A transaction cost of 3,750 results in 3 trades for a profit of ~32,099.</td>
</tr>

<tr>
<td>A transaction cost of 4,000 results in 2 trades for a profit of ~30,982.</td>
</tr>

<tr>
<td>A transaction cost of 4,250 results in 2 trades for a profit of ~29,982.</td>
</tr>

<tr>
<td>A transaction cost of 4,500 results in 2 trades for a profit of ~28,979.</td>
</tr>

<tr>
<td>A transaction cost of 4,750 results in 2 trades for a profit of ~27,981.</td>
</tr>

<tr>
<td>A transaction cost of 5,000 results in 2 trades for a profit of ~26,982.</td>
</tr>

<tr>
<td>A transaction cost of 5,250 results in 2 trades for a profit of ~25,981.</td>
</tr>

<tr>
<td>A transaction cost of 5,500 results in 1 trades for a profit of ~25,022.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org03068e8">
<h2 id="org03068e8">Thanks for reading!</h2>
<div id="text-org03068e8">
<p>
For those that stuck with this, thanks for reading!  I had more than a
little fun actually using a BDD.  I&#39;m looking forward to finding out how or
what I did incorrectly in my first stab at it.
</p>

<p>
Finally, please don&#39;t let my abuse of either Common Lisp or Knuth&#39;s
algorithms turn you off from trying either.  Knuth&#39;s work, in particular,
has turned to the exploration of a lot of puzzles in fun ways that are much
more approachable than you probably think.
</p>
</div>
</div>
</div><div id="postamble">

<p>Created: 2022-12-21 Wed 15:15</p>
<p><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div></div>
  </body>
</html>
