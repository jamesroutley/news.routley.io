<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://davidamos.dev/why-cant-you-reverse-a-flag-emoji/">Original</a>
    <h1>Why can&#39;t you reverse a string with a flag emoji?</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
<article>
<div>
<section>
<p>What do you think is the output of the following Python code?</p><pre><code>&gt;&gt;&gt; flag = &#34;🇺🇸&#34;
&gt;&gt;&gt; reversed_flag = flag[::-1]
&gt;&gt;&gt; print(reversed_flag)
</code></pre><p>Questions like this make me want to immediately open a Python REPL and try the code out because I <em>think</em> I know what the answer is, but I&#39;m not very confident in that answer.</p><p>Here&#39;s my line of thinking when I first saw this question:</p><ul><li>The <code>flag</code> string contains a single character.</li><li>The <code>[::-1]</code> slice reverses the <code>flag</code> string.</li><li>The reversal of a string with a single character is the same as the original string.</li><li>Therefore, <code>reversed_flag</code> must be <code>&#34;🇺🇸&#34;</code>.</li></ul><p>That&#39;s a perfectly <a href="https://en.wikipedia.org/wiki/Validity_(logic)">valid argument</a>. But is the conclusion true? Take a look:</p><pre><code>&gt;&gt;&gt; flag = &#34;🇺🇸&#34;
&gt;&gt;&gt; reversed_flag = flag[::-1]
&gt;&gt;&gt; print(reversed_flag)
🇸🇺
</code></pre><p>What in the world is going on here?</p><h2 id="does-%F0%9F%87%BA%F0%9F%87%B8-really-contain-a-single-character">Does <code>&#34;🇺🇸&#34;</code> Really Contain a Single Character?</h2><p>When the conclusion of a valid argument is false, one of its premises <em>must</em> be false, too. Let&#39;s start from the top:</p><p><em>The <code>flag</code> string contains a single character.</em></p><p>Is that so? How can you tell how many characters a string has?</p><p>In Python, you can use the built-in <code>len()</code> function to get the total number of characters in a string:</p><pre><code>&gt;&gt;&gt; len(&#34;🇺🇸&#34;)
2
</code></pre><p>Oh.</p><p>That&#39;s weird. You can only <em>see</em> a single <em>thing</em> in the string <code>&#34;🇺🇸&#34;</code> — namely the US flag — but a length of <code>2</code> jives with the result of <code>flag[::-1]</code>. Since the reverse of <code>&#34;🇺🇸&#34;</code> is <code>&#34;🇸🇺&#34;</code>, this seems to imply that somehow <code>&#34;🇺🇸&#34; == &#34;🇺 🇸&#34;</code>.</p><h2 id="how-can-you-tell-what-characters-are-in-a-string">How Can You Tell What Characters Are In a String?</h2><p>There are a few different ways that you can see all of the characters in a string using Python:</p><pre><code>&gt;&gt;&gt; # Convert a string to a list
&gt;&gt;&gt; list(&#34;🇺🇸&#34;)
[&#39;🇺&#39;, &#39;🇸&#39;]

&gt;&gt;&gt; # Loop over each character and print
&gt;&gt;&gt; for character in &#34;🇺🇸&#34;:
...     print(character)
...
🇺
🇸
</code></pre><p>The US flag emoji isn’t the only flag emoji with two characters:</p><pre><code>&gt;&gt;&gt; list(&#34;🇿🇼&#34;)  # Zimbabwe
[&#39;🇿&#39;, &#39;🇼&#39;]

&gt;&gt;&gt; list(&#34;🇳🇴&#34;)  # Norway
[&#39;🇳&#39;, &#39;🇴&#39;]

&gt;&gt;&gt; list(&#34;🇨🇺&#34;)  # Cuba
[&#39;🇨&#39;, &#39;🇺&#39;]

&gt;&gt;&gt; # What do you notice?
</code></pre><p>And then there’s the Scottish flag:</p><pre><code>&gt;&gt;&gt; list(&#34;🏴󠁧󠁢󠁳󠁣󠁴󠁿&#34;)
[&#39;🏴&#39;, &#39;\U000e0067&#39;, &#39;\U000e0062&#39;, &#39;\U000e0073&#39;, &#39;\U000e0063&#39;,
 &#39;\U000e0074&#39;, &#39;\U000e007f&#39;]
</code></pre><p>OK, <em>what is that all about</em>?</p><div><p>💪🏻</p><p><strong>Challenge:</strong> Can you find any non-emoji strings that look like a single character but actually contain two or more characters?</p></div><p>The unnerving thing about these examples is that they imply that you can&#39;t tell what characters are in a string just by looking at your screen.</p><p>Or, perhaps more deeply, it makes you question your understanding of the term character.</p><h2 id="what-is-a-character-anyway">What Is a Character, Anyway?</h2><p>The term <strong>character</strong> in computer science can be confusing. It tends to get conflated with the word <strong>symbol</strong>, which, to be fair, is a synonym for the word <a href="https://en.wikipedia.org/wiki/Character_(symbol)">character as it&#39;s used in English vernacular</a>.</p><p>In fact, when I googled <code>character computer science</code>, the very first result I got was a link to a <a href="https://www.techopedia.com/definition/940/character-char">Technopedia article</a> that defines a character as:</p><blockquote>&#34;[A] display unit of information equivalent to one alphabetic letter or symbol.&#34;</blockquote><p>That definition seems off, especially in light of the US flag example that indicates that a single symbol may be comprised of at least two characters.</p><p>The second Google result I get is Wikipedia. <a href="https://en.wikipedia.org/wiki/Character_(computing)">In <em>that</em> article</a>, the definition of a character is a bit more liberal:</p><blockquote>&#34;[A] character is a unit of information that roughly corresponds to a <a href="https://en.wikipedia.org/wiki/Grapheme">grapheme</a>, grapheme-like unit, or symbol, such as in an alphabet or syllabary in the written form of a natural language.&#34;</blockquote><p>Hmm... using the word &#34;roughly&#34; in a definition makes the definition feel, shall I say, <em>non-definitive</em>.</p><p>But the Wikipedia article goes on to explain that the term character has been used historically to &#34;denote a specific number of contiguous bits.”</p><p>Then, a significant clue to the question about how a string with one symbol can contain two or more characters:</p><blockquote>&#34;A character is most commonly assumed to refer to 8 bits (one byte) today... <strong>All [symbols] can be represented with one or more 8-bit code units with UTF-8</strong>.&#34;</blockquote><p>OK! Maybe things are starting to make a little bit more sense. A <strong>character</strong> represents a unit of text and is often stored as one byte of information . The <strong>symbols</strong> that we see in a string can be made up of multiple 8-bit (1 byte) <em>UTF-8 code units</em>.</p><p><em>Characters</em> are not the same as <em>symbols.</em> It seems reasonable now that one symbol could be made up of multiple characters, just like flag emojis.</p><p>But what is a UTF-8 code unit?</p><p>A little further down the Wikipedia article on characters, there’s a section called <em>Encoding</em> that explains:</p><blockquote>&#34;Computers and communication equipment represent characters using a character encoding that assigns each character to something – an integer quantity represented by a sequence of digits, typically – that can be stored or transmitted through a network. Two examples of usual encodings are ASCII and the UTF-8 encoding for Unicode.&#34;</blockquote><p>There’s another mention of UTF-8! But now I need to know what a character encoding is.</p><h2 id="what-exactly-is-a-character-encoding">What Exactly Is a Character Encoding?</h2><p>According to Wikipedia, a <strong>character encoding</strong> assigns each character to a number. What does that mean?</p><p>Doesn’t it mean that you can pair each character with a number? So, you could do something like pair each uppercase letter in the English alphabet with an integer 0 through 25.</p><figure><img src="https://res.craft.do/user/full/cc162747-4512-fd4a-48b1-1f524040eab3/doc/7DADAF83-0B05-457B-8FCD-4F2DF84EE732/0A07A2A1-EDF3-4736-9B6B-17434994E8EB_2/SOh7iH5GWJzxuly3MOQc5KFr8edshmfT0xyjFYexJDsz/Pairing%20Uppercase%20Letters%20with%20Integers.png" alt="Pairing Uppercase Letters with Integers.png" loading="lazy"/></figure><p>You can represent this pairing using tuples in Python:</p><pre><code>&gt;&gt;&gt; pairs = [(0, &#34;A&#34;), (1, &#34;B&#34;), (2, &#34;C&#34;), ..., (25, &#34;Z&#34;)]
&gt;&gt;&gt; # I&#39;m omitting several pairs here -----^^^
</code></pre><p>Stop for a moment and ask yourself: <em>“Can I create a list of tuples like the one above without explicitly writing out each pair?&#34;</em></p><p>One way is to use <a href="https://docs.python.org/3/library/functions.html#enumerate">Python’s <code>enumerate()</code> function</a>. <code>enumerate()</code> takes an argument called <em>iterable</em> and returns a tuple containing a count that defaults to 0 and the values obtained from iterating over <em>iterable</em>.</p><p>Here’s a look at <code>enumerate()</code> in action:</p><pre><code>&gt;&gt;&gt; letters = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;
&gt;&gt;&gt; enumerated_letters = list(enumerate(letters))
&gt;&gt;&gt; enumerated_letters
[(0, &#39;A&#39;), (1, &#39;B&#39;), (2, &#39;C&#39;), (3, &#39;D&#39;), (4, &#39;E&#39;), (5, &#39;F&#39;), (6, &#39;G&#39;),
(7, &#39;H&#39;), (8, &#39;I&#39;), (9, &#39;J&#39;), (10, &#39;K&#39;), (11, &#39;L&#39;), (12, &#39;M&#39;), (13, &#39;N&#39;),
(14, &#39;O&#39;), (15, &#39;P&#39;), (16, &#39;Q&#39;), (17, &#39;R&#39;), (18, &#39;S&#39;), (19, &#39;T&#39;), (20, &#39;U&#39;),
(21, &#39;V&#39;), (22, &#39;W&#39;), (23, &#39;X&#39;), (24, &#39;Y&#39;), (25, &#39;Z&#39;)]
</code></pre><p>There’s an easier way to make all of the letters, too.</p><p>Python’s <a href="https://docs.python.org/3/library/string.html"><code>string</code> module</a> has a variable called <code>ascii_uppercase</code> that points to a string containing all of the uppercase letters in the English alphabet:</p><pre><code>&gt;&gt;&gt; import string
&gt;&gt;&gt; string.ascii_uppercase
&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;

&gt;&gt;&gt; enumerated_letters = list(enumerate(string.ascii_uppercase))
&gt;&gt;&gt; enumerated_letters
[(0, &#39;A&#39;), (1, &#39;B&#39;), (2, &#39;C&#39;), (3, &#39;D&#39;), (4, &#39;E&#39;), (5, &#39;F&#39;), (6, &#39;G&#39;),
 (7, &#39;H&#39;), (8, &#39;I&#39;), (9, &#39;J&#39;), (10, &#39;K&#39;), (11, &#39;L&#39;), (12, &#39;M&#39;), (13, &#39;N&#39;),
 (14, &#39;O&#39;), (15, &#39;P&#39;), (16, &#39;Q&#39;), (17, &#39;R&#39;), (18, &#39;S&#39;), (19, &#39;T&#39;),
 (20, &#39;U&#39;), (21, &#39;V&#39;), (22, &#39;W&#39;), (23, &#39;X&#39;), (24, &#39;Y&#39;), (25, &#39;Z&#39;)]
</code></pre><p>OK, so we’ve associated characters to integers. That means we’ve got a character encoding!</p><p>But, how do you use it?</p><p>To encode the string <code>”PYTHON”</code> as a sequence of integers, you need a way to look up the integer associated with each character. But, looking things up in a list of tuples is hard. It’s also really inefficient. (Why?)</p><p>Dictionaries are good for looking things up. If we convert <code>enumerated_letters</code> to a dictionary, we can quickly look up the letter associated with an integer:</p><pre><code>&gt;&gt;&gt; int_to_char = dict(enumerated_letters)

&gt;&gt;&gt; # Get the character paired with 1
&gt;&gt;&gt; int_to_char[1]
&#39;B&#39;

&gt;&gt;&gt; # Get the character paired with 15
&gt;&gt;&gt; int_to_char[15]
&#39;P&#39;
</code></pre><p>However, to encode the string <code>”PYTHON”</code> you need to be able to look up the integer associated with a character. You need the reverse of <code>int_to_char.</code></p><p>How do you swap keys and values in a Python dictionary?</p><p>One way is use the <code>reversed()</code> function to reverse key-value pairs from the <code>int_to_char</code> dictionary:</p><pre><code>&gt;&gt;&gt; # int_to_char.items() is a &#34;list&#34; of key-value pairs
&gt;&gt;&gt; int_to_char.items()
dict_items([(0, &#39;A&#39;), (1, &#39;B&#39;), (2, &#39;C&#39;), (3, &#39;D&#39;), (4, &#39;E&#39;), (5, &#39;F&#39;),
(6, &#39;G&#39;), (7, &#39;H&#39;), (8, &#39;I&#39;), (9, &#39;J&#39;), (10, &#39;K&#39;), (11, &#39;L&#39;), (12, &#39;M&#39;),
(13, &#39;N&#39;), (14, &#39;O&#39;), (15, &#39;P&#39;), (16, &#39;Q&#39;), (17, &#39;R&#39;), (18, &#39;S&#39;),
(19, &#39;T&#39;), (20, &#39;U&#39;), (21, &#39;V&#39;), (22, &#39;W&#39;), (23, &#39;X&#39;), (24, &#39;Y&#39;),
(25, &#39;Z&#39;)])

&gt;&gt;&gt; # The reversed() function can reverse a tuple
&gt;&gt;&gt; pair = (0, &#34;A&#34;)
&gt;&gt;&gt; tuple(reversed(pair))
(&#39;A&#39;, 0)
</code></pre><p>You can write a <a href="https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions">generator expression</a> that reverses all of the pairs in <code>int_to_char.items()</code> and use that generator expression to populate a dictionary:</p><pre><code>&gt;&gt;&gt; char_to_int = dict(reversed(pair) for pair in int_to_char.items())
&gt;&gt;&gt; # Reverse the pair-^^^^^^^^^^^^^^
&gt;&gt;&gt; # For every key-value pair--------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

&gt;&gt;&gt; # Get the integer associated with B
&gt;&gt;&gt; char_to_int[&#34;B&#34;]
1

&gt;&gt;&gt; # Get the integer associated with P
&gt;&gt;&gt; char_to_int[&#34;P&#34;]
15
</code></pre><p>It’s good that you paired each letter with a unique integer. Otherwise, this dictionary reversal wouldn’t have worked. (Why?)</p><p>Now you can encode strings as list of integers using the <code>char_to_int</code> dictionary and a <a href="https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions">list comprehension</a>:</p><pre><code>&gt;&gt;&gt; [char_to_int[char] for char in &#34;PYTHON&#34;]
[15, 24, 19, 7, 14, 13]
</code></pre><p>And you can convert a list of integers into a string of uppercase characters using <code>int_to_char</code> in a generator expression with Python&#39;s <a href="https://docs.python.org/3/library/stdtypes.html#str.join">string <code>.join()</code> method</a>:</p><pre><code>&gt;&gt;&gt; &#34;&#34;.join(int_to_char[num] for num in [7, 4, 11, 11, 14])
&#39;HELLO&#39;
</code></pre><p>But, there’s a problem.</p><p>Your encoding can’t handle strings with things like punctuation, lowercase letters, and whitespace:</p><pre><code>&gt;&gt;&gt; [char_to_int[char] for char in &#34;monty python!&#34;]
Traceback (most recent call last):
  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;listcomp&gt;
KeyError: &#39;m&#39;
&gt;&gt;&gt; # ^^^^^^^-----char_to_int has no &#34;m&#34; key
</code></pre><p>One way to fix this is to create an encoding using a string containing all of the lowercase letters, punctuation marks, and whitespace characters that you need.</p><p>But, in Python, there’s almost always a better way. Python’s <code>string</code> module contains a variable called <code>printable</code> that gives you a string containing a whole bunch of printable characters:</p><pre><code>&gt;&gt;&gt; string.printable
&#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&#34;#$%&amp;\&#39;()*+,-./:;&lt;=&gt;<a href="https://davidamos.dev/cdn-cgi/l/email-protection" data-cfemail="e4dba4">[email protected]</a>[\\]^_`{|}~ \t\n\r\x0b\x0c&#39;
</code></pre><p>Would you have included all of those characters if you were making your own string from scratch?</p><p>Now you can make new dictionaries for encoding and decoding the characters in <code>string.printable</code>:</p><pre><code>&gt;&gt;&gt; int_to_printable = dict(enumerate(string.printable))
&gt;&gt;&gt; printable_to_int = dict(reversed(item) for item in int_to_printable.items())
</code></pre><p>You can use these dictionaries to encode and decode more complicated strings:</p><pre><code>&gt;&gt;&gt; # Encode the string &#34;monty python!&#34;
&gt;&gt;&gt; encoded_string = [printable_to_int[char] for char in &#34;monty python!&#34;]
&gt;&gt;&gt; encoded_string
[22, 24, 23, 29, 34, 94, 25, 34, 29, 17, 24, 23, 62]

&gt;&gt;&gt; # Decode the encoded string
&gt;&gt;&gt; decoded_string = &#34;&#34;.join(int_to_printable[num] for num in encoded_string)
&gt;&gt;&gt; decoded_string
&#39;monty python!&#39;
</code></pre><p>You’ve now made two different character encodings! And they <em>really</em> are different. Just look at what happens when you decode the same list of integers using both encodings:</p><pre><code>&gt;&gt;&gt; encoded_string = [15, 24, 19, 7, 14, 13]

&gt;&gt;&gt; # Decode using int_to_char (string.ascii_uppercase)
&gt;&gt;&gt; &#34;&#34;.join(int_to_char[num] for num in encoded_string)
&#39;PYTHON&#39;

&gt;&gt;&gt; # Decode using int_to_printable(string.printable)
&gt;&gt;&gt; &#34;&#34;.join(int_to_printable[num] for num in encoded_string)
&#39;foj7ed&#39;
</code></pre><p>Not even close!</p><p>So, now we know a few things about character encodings:</p><ul><li>A character encoding pairs characters with unique integers.</li><li>Some character encodings exclude characters that are included in other character encodings.</li><li>Two different character encodings may decode the same integers into two different strings.</li></ul><p>What does any of this have to do with UTF-8?</p><h2 id="what-is-utf-8">What Is UTF-8?</h2><p>Wikipedia&#39;s article on characters mentions two different character encodings:</p><blockquote>&#34;Two examples of usual encodings are ASCII and the UTF-8 encoding for Unicode.&#34;</blockquote><p>OK, so ASCII and UTF-8 are specific kinds of character encoding.</p><p>According to the Wikipedia article on ASCII:</p><blockquote>&#34;ASCII was the most common character encoding on the World Wide Web until December 2007, when UTF-8 encoding surpassed it; UTF-8 is backward compatible with ASCII.&#34;</blockquote><p>UTF-8 isn’t just the dominant character encoding for the web. It’s also the primary character encoding for Linux and macOS operating systems and is even the <a href="https://docs.python.org/3/howto/unicode.html#python-s-unicode-support">default for Python code</a>.</p><p>In fact, you can see how UTF-8 encodes characters as integers using the <a href="https://docs.python.org/3/library/stdtypes.html#str.encode"><code>.encode()</code> method</a> on Python string objects. But <code>.encode()</code> doesn&#39;t return a list of integers. Instead, <code>encode()</code> returns a <a href="https://docs.python.org/3/library/stdtypes.html#bytes-objects"><code>bytes</code> object</a>:</p><pre><code>&gt;&gt;&gt; encoded_string = &#34;PYTHON&#34;.encode()

&gt;&gt;&gt; # The encoded string *looks* like a string still,
&gt;&gt;&gt; # but notice the b in front of the first quote
&gt;&gt;&gt; encoded_string
b&#39;PYTHON&#39;

&gt;&gt;&gt; # b stands for bytes, which is the type of
&gt;&gt;&gt; # object returned by .encode()
&gt;&gt;&gt; type(encoded_string)
&lt;class &#39;bytes&#39;&gt;
</code></pre><p>The Python docs describe a <code>bytes</code> object as “an immutable sequence of integers in the range <code>0 &lt;= x &lt; 256</code>.” That seems a little weird considering that the <code>encoded_string</code> object displays the characters in the string <code>“PYTHON”</code> and not a bunch of integers.</p><p>But let’s accept this and see if we can tease out the integers somehow.</p><p>The Python docs say that <code>bytes</code> is a &#34;sequence,&#34; and <a href="https://docs.python.org/3/glossary.html#term-sequence">Python&#39;s glossary</a> defines a sequence as “[a]n iterable which supports efficient element access using integer indices.”</p><p>So, it sounds like you can index a <code>bytes</code> object the same way that you can index a Python <code>list</code> object. Let&#39;s try it out:</p><pre><code>&gt;&gt;&gt; encoded_string[0]
80
</code></pre><p>Aha!</p><p>What happens when you convert <code>encoded_string</code> to a list?</p><pre><code>&gt;&gt;&gt; list(encoded_string)
[80, 89, 84, 72, 79, 78]
</code></pre><p>Bingo. It looks like UTF-8 assigns the letter <code>”P”</code>  to the integer <code>80</code>, <code>”Y”</code> to the integer <code>89</code>, <code>”T”</code> to the integer <code>84</code>, and so on.</p><p>Let’s see what happens when we encode the string <code>”🇺🇸”</code> using UTF-8:</p><pre><code>&gt;&gt;&gt; list(&#34;🇺🇸&#34;.encode())
[240, 159, 135, 186, 240, 159, 135, 184]
</code></pre><p>Huh. Did you expect <code>”🇺🇸”</code> to get encoded as eight integers?</p><p><code>”🇺🇸”</code> is made up of two characters, namely <code>“🇺”</code>  and <code>”🇸&#34;</code>. Let&#39;s see how those get encoded:</p><pre><code>&gt;&gt;&gt; list(&#34;🇺&#34;.encode())
[240, 159, 135, 186]

&gt;&gt;&gt; list(&#34;🇸&#34;.encode())
[240, 159, 135, 184]
</code></pre><p>OK, things are making more sense now. Both <code>“🇺”</code> and <code>”🇸&#34;</code> get encoded as four integers, and the four integers corresponding to <code>“🇺”</code> appear first in the list of integers corresponding to <code>”🇺🇸”</code>, while the four integers corresponding to <code>”🇸&#34;</code> appear second.</p><p>This raises a question, though.</p><h2 id="why-does-utf-8-encode-some-characters-as-four-integers-and-others-as-one-integer">Why Does UTF-8 Encode Some Characters As Four Integers and Others as One Integer?</h2><p>The character <code>“🇺”</code> is encoded as a sequence of four integers in UTF-8, while the character <code>”P”</code> gets encoded as a single integer. Why is that?</p><p>There’s a hint at the top of Wikipedia’s UTF-8 article:</p><blockquote>&#34;UTF-8 is capable of encoding all 1,112,064 valid character code points in Unicode using one to four one-byte (8-bit) code units. Code points with lower numerical values, which tend to occur more frequently, are encoded using fewer bytes.&#34;</blockquote><p>OK, so that makes it sound like UTF-8 isn’t encoding characters to integers, but instead to something called a Unicode code point. And each code unit can apparently be one to four bytes.</p><p>There are a couple of questions we need to answer now:</p><ol><li>What is a byte?</li><li>What is a Unicode code point?</li></ol><p>The word byte has been floating around a lot, so let’s go ahead and give it a proper definition.</p><p>A <strong>bit</strong> is the smallest unit of information. A bit has two states, on or off, that are usually represented by the integers <code>0</code> and <code>1</code>, respectively. A <strong>byte</strong> is a sequence of eight bits.</p><p>You can interpret bytes as integers by viewing their component bits as expressing a number in <a href="https://en.wikipedia.org/wiki/Binary_number">binary notation</a>.</p><p>Binary notation can look pretty exotic the first time you see it. It&#39;s a lot like the usual decimal representation you use to write numbers, though. The difference is that each digit can only be a 0 or a 1, and the value of each place in the number is a power of 2, not a power of 10:</p><figure><img src="https://res.craft.do/user/full/cc162747-4512-fd4a-48b1-1f524040eab3/doc/7DADAF83-0B05-457B-8FCD-4F2DF84EE732/E2915B46-082A-427F-A222-6D659F2A0FAA_2/zGvYNtHDYsEx7aAeGw7BODYpIy1xwoJuOhWA47zw9IMz/8-bit%20binary%20numbers-5.png" alt="8-bit binary numbers-5.png" loading="lazy"/></figure><p>Since a byte contains eight bits, the largest number you can represent with a single byte is <code>11111111</code> in binary or <code>255</code> in decimal notation.</p><figure><img src="https://res.craft.do/user/full/cc162747-4512-fd4a-48b1-1f524040eab3/doc/7DADAF83-0B05-457B-8FCD-4F2DF84EE732/06DA00C0-772E-44E5-8F23-F5C265157F81_2/CSXigPNATRbCPnxp0bP2CME1WFQbd3xZjfNikkCyjtIz/The%20largest%208-bit%20number-2.png" alt="The largest 8-bit number-2.png" loading="lazy"/></figure><p>A character encoding that uses one byte for each character can encode a maximum of 256 characters since the maximum 8-bit integer is <code>255</code> and possible values start at <code>0</code>.</p><p>256 characters might be enough to encode everything in the English language. Still, there’s no way that it can handle all of the characters and symbols used in written and electronic communication worldwide.</p><p>So what do you do? Allowing characters to be encoded as multiple bytes seems like a reasonable solution, and that’s exactly what UTF-8 does.</p><p>UTF-8 is an acronym for <em>Unicode Transformation Format — 8-bit</em>. There&#39;s that word Unicode again.</p><p>According to the Unicode website:</p><blockquote>&#34;Unicode provides a unique number for every character, no matter what the platform, no matter what the program, no matter what the language.&#34;</blockquote><p>Unicode is massive. The goal of Unicode is to provide a universal representation for all written language. Every character gets assigned to a <a href="https://en.wikipedia.org/wiki/Code_point"><strong>code point</strong></a> — a fancy word for “integer&#34; with some additional organization — and there are a total of 1,112,064 possible code points.</p><p>How Unicode code points actually get encoded depends, though. UTF-8 is just one character encoding implementing the Unicode standard. It divides code points into groups of one to four 8-bit integers.</p><p>There are other encodings for Unicode. UTF-16 divides Unicode code points into one or two 16-bit numbers and is the <a href="https://docs.microsoft.com/en-us/windows/win32/intl/unicode">default encoding used by Microsoft Windows</a>. UTF-32 can encode every Unicode code point as a single 32-bit integer.</p><p>But wait, UTF-8 encodes symbols as code points using one to four bytes. OK, so… why does the 🇺🇸 symbol get encoded with eight bytes?</p><pre><code>&gt;&gt;&gt; list(&#34;🇺🇸&#34;.encode())
[240, 159, 135, 186, 240, 159, 135, 184]

&gt;&gt;&gt; # There are eight integers in the list, a total of eight bytes!
</code></pre><p>Remember, two characters make up the US flag emoji: 🇺 and 🇸. These characters are called <strong>regional indicator symbols</strong>. There are twenty-six regional indicators in the Unicode standard representing A–Z English letters. They’re used to encode <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO 3166-1 two-letter country codes</a>.</p><p>Here’s what Wikipedia has to say about regional indicator symbols:</p><blockquote>&#34;These were defined in October 2010 as part of the Unicode 6.0 support for emoji, as an alternative to encoding separate characters for each country flag. Although they can be displayed as Roman letters, it is intended that implementations may choose to display them in other ways, such as by using national flags. The <a href="https://www.unicode.org/faq/emoji_dingbats.html">Unicode FAQ</a> indicates that this mechanism should be used and that symbols for national flags will not be directly encoded.&#34;</blockquote><p>In other words, the 🇺🇸 symbol — indeed, the symbol for <em>any</em> country&#39;s flag — is not directly supported by Unicode. Operating systems, web browsers, and other places where digital text is used, may <em>choose</em> to <em>render</em> pairs of regional indicators as flags.</p><p>Let’s take stock of what we know so far:</p><ul><li>Strings of symbols get converted to sequences of integers by a character encoding, usually UTF-8.</li><li>Some characters are encoded as a single 8-bit integer by UTF-8, and others require two, three, or four 8-bit integers.</li><li>Some symbols, such as flag emojis, are not directly encoded by Unicode. Instead, they are renders of sequences of Unicode characters and may or may not be supported by every platform.</li></ul><p>So, when you reverse a string, what gets reversed? Do you reverse the entire sequence of integers in the encoding, or do you reverse the order of the code points, or something different?</p><h2 id="how-do-you-actually-reverse-a-string">How Do You Actually Reverse A String?</h2><p>Can you think of a way to answer this question with a code experiment rather than trying to look up the answer?</p><p>You saw earlier that UTF-8 encodes the string <code>”PYTHON”</code> as a sequence of six integers:</p><pre><code>&gt;&gt;&gt; list(&#34;PYTHON&#34;.encode())
[80, 89, 84, 72, 79, 78]
</code></pre><p>What happens if you encode the reversal of the string <code>”PYTHON”</code>?</p><pre><code>&gt;&gt;&gt; list(&#34;PYTHON&#34;[::-1].encode())
[78, 79, 72, 84, 89, 80]
</code></pre><p>In this case, the order of the integers in the list was reversed. But what about other symbols?</p><p>Earlier, you saw that the <code>“🇺&#34;</code> symbol is encoded as a sequence of four integers. What happens when you encode its reversal?</p><pre><code>&gt;&gt;&gt; list(&#34;🇺&#34;.encode())
[240, 159, 135, 186]

&gt;&gt;&gt; list(&#34;🇺&#34;[::-1].encode())
[240, 159, 135, 186]
</code></pre><p>Huh. The order of the integers in both lists is the same!</p><p>Let’s try reversing the string with the US flag:</p><pre><code>&gt;&gt;&gt; list(&#34;🇺🇸&#34;.encode())
[240, 159, 135, 186, 240, 159, 135, 184]
&gt;&gt;&gt; # ^^^^^^^^^^^^^^---Code point for 🇺
&gt;&gt;&gt; #                ^^^^^^^^^^^^^^^^^^---Code point for 🇸

&gt;&gt;&gt; # The code points get swapped!
&gt;&gt;&gt; list(&#34;🇺🇸&#34;[::-1].encode())
[240, 159, 135, 184, 240, 159, 135, 186]
&gt;&gt;&gt; # ^^^^^^^^^^^^^^---Code point for 🇸
&gt;&gt;&gt; #                ^^^^^^^^^^^^^^^^^^---Code point for 🇺
</code></pre><p>The order of the integers isn’t reversed! Instead, the groups of four integers representing the Unicode code points for 🇺and 🇸get swapped. The orders of the integers in each code point stay the same.</p><h2 id="what-does-all-of-this-mean">What Does All Of This Mean?</h2><p>The title of this article is a lie! You <em>can</em> reverse a string with a flag emoji. But reversing symbols composed of multiple code points can have surprising results. Especially if you&#39;ve never heard of things like character encodings and code points before.</p><p>But, is reversing the order of the code points, like Python does, the right approach? Would it make more sense to keep symbols represented by multiple code points intact? The answer is: it depends. There isn&#39;t a canonical way to reverse a string, at least that I&#39;m aware of.</p><div><p>💪🏻</p><p><strong>Challenge: </strong>How would you go about writing a function that reverses a string while leaving symbols encoded as sequences of code points intact? Can you do it from scratch? Is there a package available in your language that can do it for you? How did that package solve the problem?</p></div><h2 id="why-is-any-of-this-important">Why Is Any Of This Important?</h2><p>There are a couple of important lessons to take away from this investigation.</p><p>First, if you don&#39;t know which character encoding was used to encode some text, you can&#39;t guarantee that the decoded text accurately represents the original text.</p><p>Second, although UTF-8 is widely adopted, there are still many systems that use different character encodings. Keep this in mind when reading text from a file, especially when shared from a different operating system or across international borders. Be explicit and always indicate which encoding is being used to encode or decode text.</p><p>For example, Python’s <code>open()</code> function <a href="https://docs.python.org/3/library/functions.html#open">has an <code>encoding</code> parameter</a> that specifies the character encoding to use when reading or writing text to a file. Make use of it.</p><h2 id="where-do-you-go-from-here">Where Do You Go From Here?</h2><p>We’ve covered a lot of ground, but there are still a lot of questions left unanswered. So write down some of the questions you still have and use the investigative techniques you saw in this article to try and answer them.</p><p><strong>Here are some questions you might want to explore:</strong></p><ul><li>When you convert <code>&#34;🏴󠁧󠁢󠁳󠁣󠁴󠁿&#34;</code> to a list, you end up with a bunch of strings that start with <code>&#34;\U&#34;</code>. What are those strings, and what do they represent?</li><li>The UTF-8 encoding for <code>&#34;🏴󠁧󠁢󠁳󠁣󠁴󠁿&#34;</code> contains a whopping 28 bytes of information. What makes 🏴󠁧󠁢󠁳󠁣󠁴󠁿 different from 🇺🇸? What other flags get encoded as 28 bytes?</li><li>What happens when you reverse 🇦🇬? Given what you&#39;ve learned about flag emojis, how can you explain the reversal? Are there any other flags that have a similar reversal?</li><li>Are there any flag emojis that get encoded as a single code point?</li><li>Many platforms support colored emojis, such as a thumbs-up emoji that can be rendered with different skin tones. How does the same symbol with different colors get encoded?</li><li>How can you check if a string containing emojis is a <a href="https://en.wikipedia.org/wiki/Palindrome">palindrome</a>?</li></ul><p>Thanks for reading! Stay curious out there!</p> <hr/><p><em>Join my free weekly newsletter <a href="https://davidamos.dev/curious-about-code-newsletter">&#34;Curious About Code&#34;</a> to get curiosity-inducing content in your inbox every Friday.</em></p>
</section>



</div>
</article>
</div></div>
  </body>
</html>
