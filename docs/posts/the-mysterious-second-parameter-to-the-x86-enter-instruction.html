<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20231211-00/?p=109126">Original</a>
    <h1>The mysterious second parameter to the x86 ENTER instruction</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            December 11th, 2023</p><!-- .entry-meta -->
        <p>The x86 instruction set has an <code>ENTER</code> instruction which builds a stack frame. It is almost always used with a zero as the second parameter.</p>
<pre>        enter   n, 0
</pre>
<p>This is functionally equivalent to</p>
<pre>        push    ebp
        mov     ebp, esp
        sub     esp, n
</pre>
<p>But what happens if you increase that second parameter beyond zero?</p>
<p>Values greater than zero for the second parameter are intended for languages like Pascal which support nested functions that can access the local variables of their lexical parents. <a title="What is a static chain pointer in the context of calling convention ABI?" href="https://devblogs.microsoft.com/oldnewthing/20231204-00/?p=109095"> We learned about these functions a short time ago</a>. But the designers of the x86 instruction set had a different design in mind for how a function can access the variables of its lexical parent: Instead of receiving a pointer to the start of a linked list of lexical parent frames, they receive an <i>array</i> of pointers to lexical parent frames.</p>
<p>In its full generality, the</p>
<pre>    enter n, k + 1
</pre>
<p>instruction goes like this:</p>

<pre>    push    ebp
    mov     internal_register, esp
   <span> sub     ebp, 4 </span> ⎱ <span><var>k</var> times</span>
   <span> push    [ebp]  </span> ⎰
    push    internal_register
    mov     ebp, internal_register
    sub     esp, n
</pre>
<p>If you ignore the order of operations and worry just about the final state, then you can reinterpret it like this, which I think captures the essence of the instruction better:</p>
<pre>    push    ebp
   <span> push    [ebp-4]   </span>
   <span> push    [ebp-8]   </span> <span><var>k</var> pushes</span>
   <span> :                 </span>
   <span> push    [ebp-4*<var>k</var>] </span>
    lea     ebp, [esp + 4*<var>k</var>]    ; where we pushed the previous ebp
    push    ebp		        ; add our own frame to the array
    sub     esp, n
</pre>
<p>Let’s look at our example function again.</p>
<pre>function Outer(n: integer) : integer;
    var i: integer;

    procedure Update(j: integer);
    begin
        i := i + j
    end;

    procedure Inner(m: integer);

        procedure MoreInner;
        begin
            Update(m)
        end;

    (* Inner body begins here *)
    begin
        MoreInner
    end;

(* Outer body begins here *)
begin
    i := 0;
    Inner(n);
    Outer := i
end;
</pre>
<p>On entry to <code>Outer</code>, the stack looks like this:</p>
<table>
<tbody>
<tr>
<td><code>n</code> parameter</td>
<td> </td>
</tr>
<tr>
<td>return address</td>
<td>← <var>esp</var></td>
</tr>
</tbody>
</table>
<p>The <code>Outer</code> function establishes its stack frame by performing an <code>enter 4, 1</code>. The extra <code>1</code> at the end means that this is the outermost of a chain of nested functions. In our cookbook, <var>k</var> is zero, so the functional equivalent is</p>
<pre>    push    ebp
                                ; no pointers copied from parent
    lea     ebp, [esp+0]        ; equivalently, &#34;mov ebp, esp&#34;
    push    ebp                 ; pointer to our own frame
    sub     esp, 4
</pre>
<p>and we wind up with this stack frame for <code>Outer</code>:</p>
<table>
<tbody>
<tr>
<td> </td>
<td> </td>
<td><code>Outer</code> frame</td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td><code>n</code> parameter</td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>return address</td>
<td> </td>
</tr>
<tr>
<td> </td>
<td rowspan="2">▶︎</td>
<td rowspan="2">previous <var>ebp</var></td>
<td rowspan="2">← <var>ebp</var></td>
</tr>
<tr>
<td> </td>
</tr>
<tr>
<td> </td>
<td rowspan="2"> </td>
<td rowspan="2"><code>Outer</code> frame pointer</td>
<td rowspan="2"> </td>
</tr>
<tr>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td><code>i</code></td>
<td>← <var>esp</var></td>
</tr>
<tr>
<td> </td>
</tr>
</tbody>
</table>
<p>That extra <code>,1</code> caused us to push the address of where we saved the previous <code>ebp</code>, which I’ve called the <code>Outer</code> frame pointer. That value isn’t really useful to us right now, since we already have that value in the <var>ebp</var> register. But it comes in handy when we call <code>Inner</code>.</p>
<p>On entry to <code>Inner</code>, the stack looks like this:</p>
<table>
<tbody>
<tr>
<td> </td>
<td> </td>
<td><code>m</code> parameter</td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>return address</td>
<td>← <var>esp</var></td>
</tr>
<tr>
<td> </td>
</tr>
</tbody>
</table>
<p>The <code>Inner</code> function performs an <code>enter 0, 2</code>. The 0 means that <code>Inner</code> has no local variables, and the <code>2</code> means that we are now the second level in a chain of nested functions.</p>
<p>The functional equivalent now has one extra memory push before we push a pointer to our own frame:</p>
<pre>    push    ebp
   <span> push    [ebp-4]  </span>           ; one pointer copied from parent
    lea     ebp, [esp+4]
    push    ebp                 ; pointer to our own frame
    sub     esp, 4
</pre>
<p>Before pushing the address of its own frame, the <code>enter</code> instruction also copies one pointer from the parent’s frame, namely the <code>Outer</code> frame pointer.</p>
<table>
<tbody>
<tr>
<td> </td>
<td> </td>
<td><code>Inner</code> frame</td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td><code>m</code> parameter</td>
<td> </td>
<td> </td>
<td> </td>
<td><code>Outer</code> frame</td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>return address</td>
<td> </td>
<td> </td>
<td> </td>
<td><code>n</code> parameter</td>
</tr>
<tr>
<td> </td>
<td rowspan="2">▶︎</td>
<td rowspan="2">previous <var>ebp</var></td>
<td rowspan="2">← <var>ebp</var></td>
<td rowspan="2"> </td>
<td rowspan="2"> </td>
<td rowspan="2">return address</td>
</tr>
<tr>
<td> </td>
</tr>
<tr>
<td> </td>
<td rowspan="2"> </td>
<td rowspan="2"><code>Outer</code> frame pointer</td>
<td> </td>
<td> </td>
<td rowspan="2">▶︎</td>
<td rowspan="2">previous <var>ebp</var></td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td rowspan="2"> </td>
<td rowspan="2"><code>Inner</code> frame pointer</td>
<td rowspan="2">← <var>esp</var></td>
<td> </td>
<td> </td>
<td rowspan="2"><code>Outer</code> frame pointer</td>
</tr>
<tr>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td><code>i</code></td>
</tr>
<tr>
<td> </td>
</tr>
</tbody>
</table>
<p>Now things are interesting.</p>
<p>The <code>Inner</code> function has access to its own frame, via the <var>ebp</var> register (and redundantly via the <code>Inner</code> frame pointer on its stack). It also has access to the <code>Outer</code> frame through its local copy of the <code>Outer</code> frame pointer.</p>
<p>The next thing that happens is that <code>Inner</code> calls <code>More­Inner</code> with no parameters. This time <code>More­Inner</code> uses <code>enter 0, 3</code> where the 0 means that <code>More­Inner</code> has no local variables, and the <code>3</code> means that it is a nested function three levels deep, so it should copy <i>two</i> frame pointers from its parent.</p>
<table>
<tbody>
<tr>
<td> </td>
<td> </td>
<td><code>MoreInner</code> frame</td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>return address</td>
<td> </td>
<td> </td>
<td> </td>
<td><code>Inner</code> frame</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td rowspan="2">▶︎</td>
<td rowspan="2">previous <var>ebp</var></td>
<td rowspan="2"> </td>
<td rowspan="2"> </td>
<td rowspan="2"> </td>
<td rowspan="2"><code>m</code> parameter</td>
<td rowspan="2"> </td>
<td rowspan="2"> </td>
<td rowspan="2"> </td>
<td rowspan="2"><code>Outer</code> frame</td>
</tr>
<tr>
<td> </td>
</tr>
<tr>
<td rowspan="2"> </td>
<td rowspan="2"> </td>
<td rowspan="2"><code>Outer</code> frame pointer</td>
<td> </td>
<td rowspan="2"> </td>
<td rowspan="2"> </td>
<td rowspan="2">return address</td>
<td rowspan="2"> </td>
<td rowspan="2"> </td>
<td rowspan="2"> </td>
<td rowspan="2"><code>n</code> parameter</td>
</tr>
<tr>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td rowspan="2"><code>Inner</code> frame pointer</td>
<td> </td>
<td> </td>
<td rowspan="2">▶︎</td>
<td rowspan="2">previous <var>ebp</var></td>
<td rowspan="2"> </td>
<td rowspan="2"> </td>
<td rowspan="2"> </td>
<td rowspan="2">return address</td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td rowspan="2"><code>MoreInner</code> frame pointer</td>
<td> </td>
<td> </td>
<td rowspan="2"> </td>
<td rowspan="2"><code>Outer</code> frame pointer</td>
<td> </td>
<td> </td>
<td rowspan="2">▶︎</td>
<td rowspan="2">previous <var>ebp</var></td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td rowspan="2"> </td>
<td rowspan="2"><code>Inner</code> frame pointer</td>
<td rowspan="2"> </td>
<td> </td>
<td> </td>
<td rowspan="2"><code>Outer</code> frame pointer</td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td><code>i</code></td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p>The frame for <code>MoreInner</code> contains its own parameters and local variables (nothing), plus pointers to both parent frames, plus a pointer to its own frame (which <code>More­Inner</code> doesn’t use, but which is ready for any nested function to use).</p>
<p>The code generation for <code>MoreInner</code> therefore reads the value of <code>m</code> by following the <code>Inner</code> frame pointer and then reading the <code>m</code> parameter from the <code>Inner</code> frame’s parameter space.</p>
<p>After <code>More­Inner</code> calls <code>Update</code>, the <code>Update</code> function starts with an <code>enter 0, 2</code> because it is a level-2 nested function. This copies only the <code>Outer</code> frame pointer to <code>Update</code>‘s frame, resulting in this:</p>
<table>
<tbody>
<tr>
<td> </td>
<td> </td>
<td><code>Update</code> frame</td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td><code>j</code> parameter</td>
<td> </td>
<td> </td>
<td> </td>
<td><code>Outer</code> frame</td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>return address</td>
<td> </td>
<td> </td>
<td> </td>
<td><code>n</code> parameter</td>
</tr>
<tr>
<td> </td>
<td rowspan="2">▶︎</td>
<td rowspan="2">previous <var>ebp</var></td>
<td rowspan="2">← <var>ebp</var></td>
<td rowspan="2"> </td>
<td rowspan="2"> </td>
<td rowspan="2">return address</td>
</tr>
<tr>
<td> </td>
</tr>
<tr>
<td> </td>
<td rowspan="2"> </td>
<td rowspan="2"><code>Outer</code> frame pointer</td>
<td> </td>
<td> </td>
<td rowspan="2">▶︎</td>
<td rowspan="2">previous <var>ebp</var></td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td rowspan="2"> </td>
<td rowspan="2"><code>Update</code> frame pointer</td>
<td rowspan="2">← <var>esp</var></td>
<td> </td>
<td> </td>
<td rowspan="2"><code>Outer</code> frame pointer</td>
</tr>
<tr>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td><code>i</code></td>
</tr>
<tr>
<td> </td>
</tr>
</tbody>
</table>
<p>I didn’t draw it, but the “previous <var>ebp</var>” in the <code>Update</code> frame points to the <code>More­Inner</code> frame.</p>
<p>The <code>Update</code> function reads <code>j</code> from its own parameter space and uses to update the <code>i</code> variable in <code>Outer</code>‘s frame by following the <code>Outer</code> frame pointer.</p>
<p>The result is the same as the <a title="What is a static chain pointer in the context of calling convention ABI?" href="https://devblogs.microsoft.com/oldnewthing/20231204-00/?p=109095"> System V Application Binary Interface static chain pointer</a>, but it’s done in a different way. Instead of passing the head of a linked list of frames, the <code>enter</code> instruction copies an entire array of pointers to frames. This reduces the number of instructions required in order to access faraway frames, but it increases the cost of a function call due to the extra copying.</p>
<p>I wonder if anybody uses the Intel design for nested functions. I suspect it’s silicon on the CPU that is completely wasted.</p>


        

        
		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
