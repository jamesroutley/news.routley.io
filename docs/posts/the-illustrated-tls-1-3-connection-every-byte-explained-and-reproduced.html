<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tls13.xargs.org">Original</a>
    <h1>The Illustrated TLS 1.3 Connection (Every byte explained and reproduced)</h1>
    
    <div id="readability-page-1" class="page"><div><p>
    The server now has the information to calculate the
    keys used to encrypt the rest of the handshake.  It uses the following
    information in this calculation:
    </p><ul>
    <li><a href="https://tls13.xargs.org/files/client-ephemeral-public.key">client public key</a> (from Client Hello)
    </li><li><a href="https://tls13.xargs.org/files/server-ephemeral-private.key">server private key</a> (from Server Key Exchange Generation)
    </li><li>SHA384 hash of ClientHello and ServerHello</li>
    </ul><p>
    First, the server finds the shared secret, which is the
    result of the key exchange that allows the client and server
    to agree on a number.  The server multiplies the client&#39;s
    public key by the server&#39;s private key using the curve25519()
    algorithm.  The 32-byte result is found to be:
    </p><pre><tt>df4a291baa1eb7cfa6934b29b474baad2697e29f1f920dcc77c8a0a088447624</tt></pre><p>

    I&#39;ve provided <a href="https://tls13.xargs.org/files/curve25519-mult.c" download="curve25519-mult.c">a tool</a>
    to perform this calculation:
    </p><codesample>
<pre><code>$ cc -o curve25519-mult curve25519-mult.c
$ ./curve25519-mult server-ephemeral-private.key \
                    client-ephemeral-public.key | hexdump

0000000 df 4a 29 1b aa 1e b7 cf a6 93 4b 29 b4 74 ba ad
0000010 26 97 e2 9f 1f 92 0d cc 77 c8 a0 a0 88 44 76 24
</code></pre>
    </codesample><p>

    We then calculate the SHA384 hash of all handshake messages
    to this point (ClientHello and ServerHello).  The hash does
    not include the 5-byte &#34;record&#34; headers.  This &#34;hello_hash&#34;
    is </p><tt>e05f64fcd082bdb0dce473adf669c2769f257a1c75a51b7887468b5e0e7a7de4f4d34555112077f16e079019d5a845bd</tt><p>:
    </p><codesample>
<pre><code>$ (tail -c +6 clienthello; tail -c +6 serverhello) | openssl sha384
e05f64fcd082bdb0dce473adf669c2769f257a1c75a51b7887468b5e0e7a7de4f4d34555112077f16e079019d5a845bd
</code></pre>
    </codesample><p>

    We then feed the hash and the shared secret into a set of
    key derivation operations, designed to ensure the integrity
    of the handshake process and to protect against known and
    possible attacks:

    </p><processblock>
<pre>early_secret = HKDF-Extract(salt: 00, key: 00...)
empty_hash = SHA384(&#34;&#34;)
derived_secret = HKDF-Expand-Label(key: early_secret, label: &#34;derived&#34;, ctx: empty_hash, len: 48)
handshake_secret = HKDF-Extract(salt: derived_secret, key: shared_secret)
client_secret = HKDF-Expand-Label(key: handshake_secret, label: &#34;c hs traffic&#34;, ctx: hello_hash, len: 48)
server_secret = HKDF-Expand-Label(key: handshake_secret, label: &#34;s hs traffic&#34;, ctx: hello_hash, len: 48)
client_handshake_key = HKDF-Expand-Label(key: client_secret, label: &#34;key&#34;, ctx: &#34;&#34;, len: 32)
server_handshake_key = HKDF-Expand-Label(key: server_secret, label: &#34;key&#34;, ctx: &#34;&#34;, len: 32)
client_handshake_iv = HKDF-Expand-Label(key: client_secret, label: &#34;iv&#34;, ctx: &#34;&#34;, len: 12)
server_handshake_iv = HKDF-Expand-Label(key: server_secret, label: &#34;iv&#34;, ctx: &#34;&#34;, len: 12)
</pre>
    </processblock><p>

    This has introduced two new cryptographic methods:
    </p><ul>
    <li><tt>HKDF-Extract</tt> - given a salt and some bytes of key material
    create 384 bits (48 bytes) of new key material, with the
    input key material&#39;s entropy evenly distributed in the
    output.
    </li><li><tt>HKDF-Expand-Label</tt> - given the inputs of key
    material, label, and context data, create a new key of the
    requested length.
    </li></ul><p>

    I&#39;ve created <a href="https://tls13.xargs.org/files/hkdf-384.sh" download="hkdf-384">an HKDF tool</a>
    to perform these operations on the command line.
    </p><codesample>
<pre><code>$ hello_hash=e05f64fcd082bdb0dce473adf669c2769f257a1c75a51b7887468b5e0e7a7de4f4d34555112077f16e079019d5a845bd
$ shared_secret=df4a291baa1eb7cfa6934b29b474baad2697e29f1f920dcc77c8a0a088447624
$ zero_key=000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
$ early_secret=$(./hkdf-384 extract 00 $zero_key)
$ empty_hash=$(openssl sha384 &lt; /dev/null | sed -e &#39;s/.* //&#39;)
$ derived_secret=$(./hkdf-384 expandlabel $early_secret &#34;derived&#34; $empty_hash 48)
$ handshake_secret=$(./hkdf-384 extract $derived_secret $shared_secret)
$ csecret=$(./hkdf-384 expandlabel $handshake_secret &#34;c hs traffic&#34; $hello_hash 48)
$ ssecret=$(./hkdf-384 expandlabel $handshake_secret &#34;s hs traffic&#34; $hello_hash 48)
$ client_handshake_key=$(./hkdf-384 expandlabel $csecret &#34;key&#34; &#34;&#34; 32)
$ server_handshake_key=$(./hkdf-384 expandlabel $ssecret &#34;key&#34; &#34;&#34; 32)
$ client_handshake_iv=$(./hkdf-384 expandlabel $csecret &#34;iv&#34; &#34;&#34; 12)
$ server_handshake_iv=$(./hkdf-384 expandlabel $ssecret &#34;iv&#34; &#34;&#34; 12)
$ echo hssec: $handshake_secret
$ echo ssec: $ssecret
$ echo csec: $csecret
$ echo skey: $server_handshake_key
$ echo siv: $server_handshake_iv
$ echo ckey: $client_handshake_key
$ echo civ: $client_handshake_iv

hssec: bdbbe8757494bef20de932598294ea65b5e6bf6dc5c02a960a2de2eaa9b07c929078d2caa0936231c38d1725f179d299
ssec: 23323da031634b241dd37d61032b62a4f450584d1f7f47983ba2f7cc0cdcc39a68f481f2b019f9403a3051908a5d1622
csec: db89d2d6df0e84fed74a2288f8fd4d0959f790ff23946cdf4c26d85e51bebd42ae184501972f8d30c4a3e4a3693d0ef0
skey: 9f13575ce3f8cfc1df64a77ceaffe89700b492ad31b4fab01c4792be1b266b7f
siv: 9563bc8b590f671f488d2da3
ckey: 1135b4826a9a70257e5a391ad93093dfd7c4214812f493b3e3daae1eb2b1ac69
civ: 4256d2e0e88babdd05eb2f27
</code></pre>
    </codesample><p>

    From this we get the following key data:
    </p><ul>
    <li>handshake secret: <tt>bdbbe8757494bef20de932598294ea65b5e6bf6dc5c02a960a2de2eaa9b07c929078d2caa0936231c38d1725f179d299</tt>
    </li><li>server handshake traffic secret: <tt>23323da031634b241dd37d61032b62a4f450584d1f7f47983ba2f7cc0cdcc39a68f481f2b019f9403a3051908a5d1622</tt>.
    </li><li>client handshake traffic secret: <tt>db89d2d6df0e84fed74a2288f8fd4d0959f790ff23946cdf4c26d85e51bebd42ae184501972f8d30c4a3e4a3693d0ef0</tt>.
    </li><li>server handshake key: <tt>9f13575ce3f8cfc1df64a77ceaffe89700b492ad31b4fab01c4792be1b266b7f</tt>
    </li><li>server handshake IV: <tt>9563bc8b590f671f488d2da3</tt>
    </li><li>client handshake key: <tt>1135b4826a9a70257e5a391ad93093dfd7c4214812f493b3e3daae1eb2b1ac69</tt>
    </li><li>client handshake IV: <tt>4256d2e0e88babdd05eb2f27</tt>
    </li></ul>
</div></div>
  </body>
</html>
