<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.os2museum.com/wp/undocumented-8086-opcodes-part-i/">Original</a>
    <h1>Undocumented 8086 Opcodes part 1</h1>
    
    <div id="readability-page-1" class="page"><div>
						<p><em>This is a guest post by Raúl Gutiérrez Sanz</em></p>
<p>This multi-part document is about undocumented 8086 processor opcodes and their behavior. Most of the document will likely apply to the 8088 processor as well, but this has not been verified. It doesn’t apply to any other processor/controller, like the 80186, 80286 or newer, as they use the undocumented 8086 opcodes to implement new instructions. For the same reason, it does not apply to NEC V20/V30 processors either. And even when 8086 opcodes remain undocumented on new processors, their behavior is unlikely to be the same (not least because starting with the 80186, undefined opcodes generally raise an invalid instruction exception).</p>
<p><a href="http://www.os2museum.com/wp/undocumented-8086-opcodes/olympus-digital-camera-44/" rel="attachment wp-att-2170"><img decoding="async" src="http://www.os2museum.com/wp/wp-content/uploads/2013/12/PB230238-640x480.jpg" alt="" width="640" height="480" srcset="http://www.os2museum.com/wp/wp-content/uploads/2013/12/PB230238-640x480.jpg 640w, http://www.os2museum.com/wp/wp-content/uploads/2013/12/PB230238-300x225.jpg 300w, http://www.os2museum.com/wp/wp-content/uploads/2013/12/PB230238.jpg 1024w" sizes="(max-width: 640px) 100vw, 640px"/></a></p>
<p>Sometimes it is not easy to determine which opcodes are documented and which ones are not, because some of them appeared or disappeared at some point from the official Intel documentation. So, while most opcodes listed in this document have never been officially documented, you may find some of them in certain Intel documents, or at least in some versions.</p>
<p>On the 8086, <em>all</em> undocumented opcodes do <em>something</em>, but typically not something very useful. After all, if they did something useful, they would have been documented.</p>
<p>This document will be split into three sections:</p>
<ul>
<li>Section I—Holes In the Opcode Map</li>
<li>Section II—Holes In the Addressing Scheme</li>
<li>Section III—”Nonsense” Instruction/Operand Combinations</li>
</ul>
<p>For some undocumented features, the categorization is admittedly arbitrary.</p>

<h3>The Motivation</h3>
<p>I always wondered why systems cloning the 8086 processor behavior (like emulators, FPGA implementations, and hypervisors) never claim 100% compatibility with such an old and simple (from a modern point of view) device. Then I discovered that there’s still a lot of undocumented behavior and assumed that’s one of the reasons. How to clone the behavior of something when you don’t know how it behaves? That’s one of the reasons I did the research and wrote this document, apart from personal challenge. Something, or even a lot, should have been written on this subject in the past, when 8086/8088 was the mainstream processor, but apart from a smidgen of information about several instructions (SALC and a few more) I couldn’t find any comprehensive information in books or on the Internet. If something had been written, it may not have survived.</p>
<p>I would like modern 8086 hardware or software implementations to make use of this document to get closer to the real processor behavior. Feel free to use my research, just include a reference to this document.</p>
<h3>The Approach</h3>
<p>First I made a list of all undocumented features of the 8086 CPU. When I considered it complete, I installed some very simple debuggers and an assembler in one of the newest 8086-based PCs: an Amstrad 5086 with a Siemens 8086 CPU. Then it was a matter of testing everything in the list and finding out what happened. That included much use of the debuggers, and writing some pieces of code. And a lot of switching off followed by switching on.</p>
<p>The problem with undocumented instructions is that you are never sure what the result depends on. Will the result be the same if I change a register, or a flag, or memory contents, or a combination of registers, flags and memory contents? You are never sure about the results either. You can notice a register changed after executing the instruction. But, did anything else change as well?</p>
<p>After many tries you can find that there is a logic about what you consider the input and the results. But even after testing the same instruction under hundreds of different conditions, there is much guesswork involved.</p>
<p>Especially difficult to analyze were instructions which jump to unexpected locations and also instructions affecting what seems to be an undocumented internal register. Debuggers obviously don’t preserve internal registers. There is no way to do it. There’s not even a way to see what it contains.</p>
<h3>References</h3>
<ul>
<li><em>MCS-86 Assembly Language Reference Guide</em>, October 1978 (Intel document number 9800749-1); especially the instruction set matrix in pages 20-21 which will be referred to as “The instruction matrix”</li>
<li>8086 16-BIT HMOS MICROPROCESSOR (Intel document number 231455-005)</li>
<li><em>ISA System Architecture</em>, Third Edition – Tom Shanley and Don Anderson – MindShare, Inc. (ISBN 0210409968)</li>
</ul>

<h2>Section I: Holes In the Opcode Map</h2>
<p>A recurring theme in this section is that the processor ignores certain bits when decoding instructions. That leads to the existence of aliases where an undocumented opcode exists as a duplicate of a documented one. This is likely a side effect of the fact that the 8086 has no concept of an invalid opcode; when decoding instructions, the CPU does not have anything better to do with undocumented opcodes, so it might as well save some effort and not decode certain bits at all.</p>
<p>Another common case occurs when an instruction logically exists in the opcode map but performs a function which is not useful (POP CS, various shifts).</p>
<h3>Opcode 0Fh</h3>
<p>Documented equivalent: None</p>
<h3>Opcode 6Xh (60h – 6Fh)</h3>
<p>Documented equivalent: 7Xh (70h – 7Fh)</p>
<h3>Opcode C0h</h3>
<p>Documented equivalent: C2h</p>
<h3>Opcode C1h</h3>
<p>Documented equivalent: C3h</p>
<h3>Opcode C8h</h3>
<p>Documented equivalent: CAh</p>
<h3>Opcode C9h</h3>
<p>Documented equivalent: CBh</p>
<h3>Opcode D0h xx110xxxb</h3>
<p>Documented equivalent: None</p>
<ul>
<li>8-bit operand &lt;— FFh (AL for D0F0h, CL for D0F1h…)</li>
<li>Clear CF (NC)</li>
<li>Set PF (PE)</li>
<li>Clear AF (NA)</li>
<li>Clear ZF (NZ)</li>
<li>Set SF (NG)</li>
<li>Clear OF (NV)</li>
</ul>
<p>Byte operand and flags (not sure about AF) are modified as if the following instruction was executed: OR AL, 0FFh</p>
<p>Unlike SALC:</p>
<ul>
<li>Result does not depend on CF</li>
<li>Destination register is not always AL</li>
<li>Instruction changes flags</li>
</ul>
<p><em>Notes</em>:</p>
<ul>
<li>“SETMO” stands for “SET Minus One”</li>
<li>D0h is the first byte of the byte-operand, 1-position shift instructions (in the instruction matrix: “Shift b”). The type of shift is specified in bits 3 to 5 of the second byte, but it is not documented when these bits are 110b.</li>
</ul>
<h3>Opcode D1h xx110xxxb</h3>
<p>Documented equivalent: None</p>
<ul>
<li>16-bit operand &lt;— FFFFh (AX for D1F0h, CX for D1F1h…)</li>
<li>Clear CF (NC)</li>
<li>Set PF (PE)</li>
<li>Clear AF (NA)</li>
<li>Clear ZF (NZ)</li>
<li>Set SF (NG)</li>
<li>Clear OF (NV)</li>
</ul>
<p>Word operand and flags (not sure about AF) are modified as if the following instruction was executed: OR AX, 0FFFFh</p>
<p><em>Notes</em>:</p>
<ul>
<li>“SETMO” stands for “SET Minus One”</li>
<li>D1h is the first byte of the word-operand, 1-position shift instructions (in the instruction matrix: “Shift w”). The type of shift is specified in bits 3 to 5 of the second byte, but it is not documented when these bits are 110b.</li>
</ul>
<h3>Opcode D2h xx110xxxb</h3>
<p>Documented equivalent: None</p>
<p><em>Notes</em>:</p>
<ul>
<li>“SETMOC” stands for “SET Minus One if CL != 0”</li>
<li>D2h is the first byte of the byte-operand, CL-positions shift instructions (in the instruction matrix: “Shift b,v”). The type of shift is specified in bits 3 to 5 of the second byte, but it is not documented when these bits are 110b.</li>
<li>The destination operand can be specified, but the zero-test is always performed on CL.</li>
</ul>
<h3>Opcode D3h xx110xxxb</h3>
<p>Documented equivalent: None</p>
<p><em>Notes</em>:</p>
<ul>
<li>“SETMOC” stands for “SET Minus One if CL != 0”</li>
<li>D3h is the first byte of the word-operand, CL-positions shift instructions (in the instruction matrix: “Shift w,v”). The type of shift is specified in bits 3 to 5 of the second byte, but it is not documented when these bits are 110b.</li>
<li>The destination operand can be specified, but the zero-test is always performed on CL.</li>
</ul>
<h3>Opcode D6h</h3>
<p>Documented equivalent: None</p>
<p><em>Notes</em>:</p>
<ul>
<li>“SALC” stands for “SET AL to Carry”</li>
<li>The destination operand is always AL.</li>
<li>SALC is documented in many 3rd party publications and exists in all Intel x86 CPUs</li>
<li>For years, Intel refused to document SALC even though it acknowledged that D6h is not an invalid opcode; SALC was mentioned by name for the first time in the October 2017 edition of the Intel SDM (yes, really!)</li>
</ul>
<h3>Opcode F1h</h3>
<p>Documented equivalent: F0h</p>
<h3>(Section I to be continued.)</h3>
<h4>About the Author</h4>
<p>Raúl Gutiérrez Sanz has a degree in Computer Science from the University of Valladolid (Spain). He has been working as an analyst for 20 years and playing with (mostly old) games and PC hardware.</p>
											</div></div>
  </body>
</html>
