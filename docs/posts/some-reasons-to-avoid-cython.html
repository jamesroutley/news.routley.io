<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pythonspeed.com/articles/cython-limitations/">Original</a>
    <h1>Some reasons to avoid Cython</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      <p>If you need to speed up Python, Cython is a very useful tool.
It lets you seamlessly merge Python syntax with calls into C or C++ code, making it easy to write high-performance extensions with rich Python interfaces.</p>

<p>That being said, Cython is not the best tool in all circumstances.
So in this article I’ll go over some of the limitations and problems with Cython, and suggest some alternatives.</p>

<blockquote>
  <p><strong>Note:</strong> Cython 3 improves the situation somewhat, but this article hasn’t yet been updated appropriately.
I’ll try to do that soon.</p>
</blockquote>

<!-- TEASER_END -->

<h2 id="a-quick-overview-of-cython">A quick overview of Cython</h2>

<p>In case you’re not familiar with Cython, here’s a quick example; technically Cython has pre-defined <code>malloc</code> and <code>free</code> but I included them explicitly for clarity:</p>

<div><div><pre><code><span>cdef</span> <span>extern</span> <span>from</span> <span>&#34;stdlib.h&#34;</span><span>:</span>
    <span>void</span> <span>*</span><span>malloc</span><span>(</span><span>size_t</span> <span>size</span><span>);</span>
    <span>void</span> <span>free</span><span>(</span><span>void</span> <span>*</span><span>ptr</span><span>);</span>

<span>cdef</span> <span>struct</span> <span>Point</span><span>:</span>
    <span>double</span> <span>x</span><span>,</span> <span>y</span>

<span>cdef</span> <span>class</span> <span>PointVec</span><span>:</span>
    <span>cdef</span> <span>Point</span><span>*</span> <span>vec</span>
    <span>cdef</span> <span>int</span> <span>length</span>

    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>points</span><span>:</span> <span>list</span><span>[</span><span>tuple</span><span>[</span><span>float</span><span>,</span> <span>float</span><span>]]):</span>
        <span>self</span><span>.</span><span>vec</span> <span>=</span> <span>&lt;</span><span>Point</span><span>*&gt;</span><span>malloc</span><span>(</span>
            <span>sizeof</span><span>(</span><span>Point</span><span>)</span> <span>*</span> <span>len</span><span>(</span><span>points</span><span>))</span>
        <span>self</span><span>.</span><span>length</span> <span>=</span> <span>len</span><span>(</span><span>points</span><span>)</span>

        <span>for</span> <span>i</span><span>,</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>in</span> <span>enumerate</span><span>(</span><span>points</span><span>):</span>
           <span>self</span><span>.</span><span>vec</span><span>[</span><span>i</span><span>].</span><span>x</span> <span>=</span> <span>x</span>
           <span>self</span><span>.</span><span>vec</span><span>[</span><span>i</span><span>].</span><span>y</span> <span>=</span> <span>y</span>

    <span>def</span> <span>__repr__</span><span>(</span><span>self</span><span>):</span>
        <span>result</span> <span>=</span> <span>[]</span>
        <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>self</span><span>.</span><span>length</span><span>):</span>
            <span>p</span> <span>=</span> <span>self</span><span>.</span><span>vec</span><span>[</span><span>i</span><span>]</span>
            <span>result</span><span>.</span><span>append</span><span>(</span><span>&#34;({}, {})&#34;</span><span>.</span><span>format</span><span>(</span><span>p</span><span>.</span><span>x</span><span>,</span> <span>p</span><span>.</span><span>y</span><span>))</span>
        <span>return</span> <span>&#34;PointVec([{}])&#34;</span><span>.</span><span>format</span><span>(</span><span>&#34;, &#34;</span><span>.</span><span>join</span><span>(</span><span>result</span><span>))</span>

    <span>def</span> <span>__setitem__</span><span>(</span>
        <span>self</span><span>,</span> <span>index</span><span>,</span> <span>point</span><span>:</span> <span>tuple</span><span>[</span><span>float</span><span>,</span> <span>float</span><span>]</span>
    <span>):</span>
        <span>x</span><span>,</span> <span>y</span> <span>=</span> <span>point</span>
        <span>if</span> <span>index</span> <span>&gt;</span> <span>self</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>:</span>
            <span>raise</span> <span>IndexError</span><span>(</span><span>&#34;Index too large&#34;</span><span>)</span>
        <span>self</span><span>.</span><span>vec</span><span>[</span><span>index</span><span>].</span><span>x</span> <span>=</span> <span>x</span>
        <span>self</span><span>.</span><span>vec</span><span>[</span><span>index</span><span>].</span><span>y</span> <span>=</span> <span>y</span>

    <span>def</span> <span>__getitem__</span><span>(</span><span>self</span><span>,</span> <span>index</span><span>):</span>
        <span>cdef</span> <span>Point</span> <span>p</span>
        <span>if</span> <span>index</span> <span>&gt;</span> <span>self</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>:</span>
            <span>raise</span> <span>IndexError</span><span>(</span><span>&#34;Index too large&#34;</span><span>)</span>
        <span>p</span> <span>=</span> <span>self</span><span>.</span><span>vec</span><span>[</span><span>index</span><span>]</span>
        <span>return</span> <span>(</span><span>p</span><span>.</span><span>x</span><span>,</span> <span>p</span><span>.</span><span>y</span><span>)</span>

    <span>def</span> <span>__dealloc__</span><span>(</span><span>self</span><span>):</span>
        <span>free</span><span>(</span><span>self</span><span>.</span><span>vec</span><span>)</span>
</code></pre></div></div>

<p>We’re writing Python—but any point we can just call into C code, and interact with C variables, C pointers, and other C features.
When you’re not interacting with Python objects, it’s straight C code, with all the corresponding speed.</p>

<p>Typically you’d add compilation to your <code>setup.py</code>, but for testing purposes we can just use the <code>cythonize</code> tool:</p>

<div><div><pre><code><span>$</span><span> </span>cythonize <span>-i</span> pointvec.pyx
<span>...
</span><span>$</span><span> </span>python
<span>&gt;</span><span>&gt;&gt;</span> from pointvec import PointVec
<span>&gt;</span><span>&gt;&gt;</span> pv <span>=</span> PointVec<span>([(</span>1, 2<span>)</span>, <span>(</span>3.5, 4<span>)])</span>
<span>&gt;</span><span>&gt;&gt;</span> pv
<span>PointVec([(1.0, 2.0), (3.5, 4.0)])
</span><span>&gt;</span><span>&gt;&gt;</span> pv[1] <span>=</span> <span>(</span>3, 5<span>)</span>
<span>&gt;</span><span>&gt;&gt;</span> pv[1]
<span>(3.0, 5.0)
</span><span>&gt;</span><span>&gt;&gt;</span> pv
<span>PointVec([(1.0, 2.0), (3.0, 5.0)])
</span></code></pre></div></div>

<h3 id="how-cython-works">How Cython works</h3>

<p>Cython compiles the <code>pyx</code> file to C, or C++, which then gets compiled normally to a Python extension.
In this case, it generates 197KB of C code!</p>

<p>As you can imagine, reading the resulting C code is not fun; here’s a tiny excerpt:</p>

<div><div><pre><code>  <span>/* &#34;pointvec.pyx&#34;:16
 *         self.length = len(points)
 * 
 *         for i, (x, y) in enumerate(points):             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
 *            self.vec[i].x = x
 *            self.vec[i].y = y
 */</span>
  <span>__Pyx_INCREF</span><span>(</span><span>__pyx_int_0</span><span>);</span>
  <span>__pyx_t_2</span> <span>=</span> <span>__pyx_int_0</span><span>;</span>
  <span>if</span> <span>(</span><span>likely</span><span>(</span><span>PyList_CheckExact</span><span>(</span><span>__pyx_v_points</span><span>))</span> <span>||</span> <span>PyTuple_CheckExact</span><span>(</span><span>__pyx_v_points</span><span>))</span> <span>{</span>
    <span>__pyx_t_3</span> <span>=</span> <span>__pyx_v_points</span><span>;</span> <span>__Pyx_INCREF</span><span>(</span><span>__pyx_t_3</span><span>);</span> <span>__pyx_t_1</span> <span>=</span> <span>0</span><span>;</span>
    <span>__pyx_t_4</span> <span>=</span> <span>NULL</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>__pyx_t_1</span> <span>=</span> <span>-</span><span>1</span><span>;</span> <span>__pyx_t_3</span> <span>=</span> <span>PyObject_GetIter</span><span>(</span><span>__pyx_v_points</span><span>);</span> <span>if</span> <span>(</span><span>unlikely</span><span>(</span><span>!</span><span>__pyx_t_3</span><span>))</span> <span>__PYX_ERR</span><span>(</span><span>0</span><span>,</span> <span>16</span><span>,</span> <span>__pyx_L1_error</span><span>)</span>
    <span>__Pyx_GOTREF</span><span>(</span><span>__pyx_t_3</span><span>);</span>
    <span>__pyx_t_4</span> <span>=</span> <span>Py_TYPE</span><span>(</span><span>__pyx_t_3</span><span>)</span><span>-&gt;</span><span>tp_iternext</span><span>;</span> <span>if</span> <span>(</span><span>unlikely</span><span>(</span><span>!</span><span>__pyx_t_4</span><span>))</span> <span>__PYX_ERR</span><span>(</span><span>0</span><span>,</span> <span>16</span><span>,</span> <span>__pyx_L1_error</span><span>)</span>
  <span>}</span>
</code></pre></div></div>

<p>This part isn’t too bad.
Later parts of the code are much harder to read.</p>

<h3 id="why-cython-is-so-attractive">Why Cython is so attractive</h3>

<p>As our example shows, creating a small extension for Python is very easy with Cython.
You get to use Python syntax to interact with Python, but you can also write code that compiles one-to-one with C or C++, so you can have fast code easily interoperating with Python.</p>

<h2 id="some-downsides-to-cython">Some downsides to Cython</h2>

<p>Unfortunately, since Cython is in the end just a thin layer over C or C++, it inherits all the problems that those languages suffer from.
And then it adds some more problems of its own.</p>

<h3 id="problem-1-memory-unsafety">Problem #1: Memory unsafety</h3>

<p>Go look over the <code>PointVec</code> example above.
Can you spot the memory safety bug?</p>



<details>
  <summary>Click here to see the answer</summary>
  

  <div><div><pre><code><span>&gt;&gt;&gt;</span> <span>pv</span><span>[</span><span>-</span><span>200000</span><span>]</span> <span>=</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span>
<span>Segmentation</span> <span>fault</span> <span>(</span><span>core</span> <span>dumped</span><span>)</span>
</code></pre></div>  </div>

  <p>This would likely allow an attacker to take over the process if they could feed in the right inputs.</p>
</details>


<p><strong>Bonus bug:</strong> The previous bug was intentional, but Alex Gaynor pointed out there’s another bug I introduced accidentally.
Can you spot it?</p>

<details>
  <summary>Click here to see the answer</summary>
  
</details>


<h3 id="problem-2-two-compiler-passes">Problem #2: Two compiler passes</h3>

<p>When you compile a Cython extension, it first gets compiled to C or C++, and then a second pass of compilation happens with a C or C++ compiler.
Some bugs will only get caught in the second compilation pass, <em>after</em> Cython has generated thousands of lines of hard-to-decipher code.
The resulting errors can be annoying:</p>

<p>Here’s <code>data.h</code>:</p>

<div><div><pre><code><span>#include &lt;stdio.h&gt;
</span>
<span>struct</span> <span>X</span> <span>{</span>
    <span>double</span><span>*</span> <span>myvalue</span><span>;</span>
<span>};</span>

<span>static</span> <span>inline</span> <span>void</span> <span>print_x</span><span>(</span><span>struct</span> <span>X</span> <span>x</span><span>)</span> <span>{</span>
    <span>printf</span><span>(</span><span>&#34;%f</span><span>\n</span><span>&#34;</span><span>,</span> <span>*</span><span>x</span><span>.</span><span>myvalue</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Here’s <code>typo.pyx</code>, which has a typo (can you spot it?):</p>

<div><div><pre><code><span>cdef</span> <span>extern</span> <span>from</span> <span>&#34;data.h&#34;</span><span>:</span>
    <span>cdef</span> <span>struct</span> <span>X</span><span>:</span>
        <span>double</span> <span>myvalue</span>
    <span>void</span> <span>print_x</span><span>(</span><span>X</span> <span>x</span><span>)</span>

<span>def</span> <span>go</span><span>():</span>
    <span>x</span> <span>=</span> <span>X</span><span>()</span>
    <span>x</span><span>.</span><span>myvalue</span> <span>=</span> <span>123</span>
    <span>print_x</span><span>(</span><span>x</span><span>)</span>
</code></pre></div></div>

<p>When I compile <code>typo.pyx</code>, I get the following error:</p>

<div><div><pre><code>typo.c -o typo.o
typo.c: In function ‘__pyx_convert__from_py_struct__X’:
typo.c:1517:28: error: incompatible types when assigning to type ‘double *’ from type ‘double’
 1517 |   __pyx_v_result.myvalue = __pyx_t_10;
      |                            ^~~~~~~~~~
</code></pre></div></div>

<p>Notice there’s no reference to the original location in the <code>.pyx</code> source code.
In this case it’s pretty clear what’s going on, since our example only has the one assignment.
With more complex code, you have to look at the generated C file, and find what Cython code it’s referring to from the comments.
With C++ this can get even more frustrating, since the language is more complex and therefore has more ways to fail.</p>

<p>For more experienced developers, this is less of an issue, but a significant benefit of good compiler errors is helping <em>new</em> developers.</p>

<h3 id="problem-3-no-standardized-package-or-build-system-for-dependencies">Problem #3: No standardized package or build system for dependencies</h3>

<p>Once your Cython code base gets big enough, you might want to add some functionality without having to write it yourself.
If you’re using C++, you have access to the C++ standard library, including its data structures.
Beyond that, you’re in the land of C and C++, which for practical purposes has no package manager for libraries.</p>

<p>With Python, you can <code>pip install</code> a dependency, or add it to your dependency file with <code>poetry</code> or <code>pipenv</code>.
With Rust, you can <code>cargo add</code> a dependency.
With C and C++ you’ve got no language-specific tooling.</p>

<p>That means on Linux you can get your Linux distribution’s version of popular libraries… but there’s <code>apt</code> and <code>dnf</code> and more.
macOS has Brew, Windows has its own, much smaller repositories like Choco.
But every platform is different, and many libraries simply won’t be packaged for you.
And then once you’ve gotten your C or C++ library downloaded, you might be dealing with a custom build system.</p>

<p>In short, unless you’re just wrapping an existing library, all the incentives push you to write everything from scratch in Cython, rather than reuse preexisting libraries.</p>

<h3 id="problem-4-lack-of-tooling">Problem #4: Lack of tooling</h3>

<p>Because of the small user base, and the complexity of how Cython works, it doesn’t have as much tooling as other languages.
For example, most editors these days can use LSP language servers to get syntax checking and other IDE functionality, but there is no such language server for Cython as far as I know.</p>

<p>Jump to definition? Can’t do that.</p>

<p>Auto-complete? Nope.</p>

<p>Highlight obvious typos?
Maybe: Emacs has a cython checker that essentially just compiles the code.
But it doesn’t bother with the second compiler pass.
Even if it did, you’d just know that the error existed unless the tool did rather more work to map to the Cython code.</p>

<p>To give another example, as far as I know there is no Cython equivalent of the <code>black</code> autoformatter.</p>

<h3 id="problem-5-python-only">Problem #5: Python-only</h3>

<p>Using Cython locks you in to a Python-only world: any code you write is only really helpful to someone writing Python.
This is a shame, because people in other ecosystems might benefit from this code as well.
For example, the <a href="https://www.pola.rs/">Polars</a> DataFrame library can be used from Python, but also from Rust (the language it’s written in), JavaScript, and work is in progress for R.</p>

<h2 id="alternatives-to-cython">Alternatives to Cython</h2>

<p>So what can you use instead of Cython?</p>

<ul>
  <li>If you’re wrapping an existing C library, Cython is still a good choice.
Mostly you just need to interface C to Python, exactly what Cython excels at—and you’re already dealing with a memory-unsafe language.</li>
  <li>If you’re wrapping an existing C++ library, a native C++/Python library like <a href="https://pybind11.readthedocs.io/en/stable/"><code>pybind11</code></a> or the faster <a href="https://github.com/wjakob/nanobind"><code>nanobind</code></a> may give a more pleasant development experience.</li>
  <li>If you are writing a small, standalone extension, and you are certain security will never a be a concern, Cython may still be a reasonable choice if you already know how to use it.</li>
</ul>

<p>If you expect you’ll be writing extensive amounts of code, you’ll want something better.
My suggestion: Rust.</p>

<blockquote>
  <p><strong>Note:</strong> Whether or not any particular tool or technique will speed things up depends on where the bottlenecks are in <em>your</em> software.</p>

  <p><strong>Need to identify the performance and memory bottlenecks in your own Python data processing code?</strong> Try the <a href="https://sciagraph.com/?mtm_campaign=best_practices">Sciagraph profiler</a>, with support for profiling both in development and production on <strong>macOS and Linux</strong>, and with built-in <strong>Jupyter support</strong>.</p>

  <p><a href="https://sciagraph.com/?mtm_campaign=best_practices"><img src="https://d33wubrfki0l68.cloudfront.net/e3170a4137617f0fb3b52bd393cce3dc114915bf/5d583/assets/sciagraph/timeline.webp" width="446" height="170" loading="lazy" alt="A performance timeline created by Sciagraph, showing both CPU and I/O as bottlenecks"/></a></p>
</blockquote>

<h3 id="rust-as-an-alternative">Rust as an alternative</h3>

<p>Rust is a memory-safe, high-performance language, and allows you to easily write Python extensions with <a href="https://pyo3.rs">PyO3</a>.
For simple cases, packaging is extra easy with <a href="https://www.maturin.rs/">Maturin</a>, otherwise you can use <a href="https://pypi.org/project/setuptools-rust/"><code>setuptools-rust</code></a>.
You can also easily <a href="https://github.com/PyO3/rust-numpy">work with NumPy arrays</a>.</p>

<p>Additionally, Rust overcomes all the other Cython problems mentioned above:</p>

<ul>
  <li><strong>Memory safety:</strong> Rust is designed to be memory-safe by default, while still having the same performance as C or C++.</li>
  <li><strong>One compiler pass:</strong> Unlike Cython, there’s just the one compiler.</li>
  <li><strong>Integrated package repository and build system:</strong> Rust has <a href="https://lib.rs/">a growing ecosystem of libraries</a>, and a package and build manager called Cargo.
Adding dependencies is quick, easy, and reproducible.</li>
  <li><strong>Lots of tooling:</strong> Rust has a linter called clippy, an excellent LSP server, an autoformatter, and so on.</li>
  <li><strong>Cross-language:</strong> A Rust library can be wrapped in Python, but you can also interoperate with other languages.</li>
</ul>

<p>The downsides, compared to Cython:</p>

<ul>
  <li>You can’t use Python syntax inline, so interfacing with Python is more work.</li>
  <li>It’s a <em>much</em> more complex language than C, so it takes much longer to learn, though it’s no worse than C++.</li>
</ul>

<h3 id="some-real-world-examples">Some real-world examples</h3>

<p><strong>Polars:</strong> We’ve already mentioned Polars is written in Rust; the Python version is just a wrapper around a generic Rust library.</p>

<p><strong>Py-Spy:</strong> The <a href="https://github.com/benfred/py-spy">py-spy</a> profiler is written in Rust, and by its nature is very Python-specific.
However, it shares some generic dependencies with the <a href="https://github.com/rbspy/rbspy">rb-spy</a> Ruby profiler, which uses the same operating-system mechanisms.
And beyond that it uses many other pre-existing Rust libraries—that’s the benefit of using a language with a package manager and an active open source ecosystem.</p>

<h3 id="reworking-our-example-in-rust">Reworking our example in Rust</h3>

<p>So what does Rust look like compared to Cython?</p>

<p>I rewrote the <code>PointVec</code> example in Rust, occasionally using slightly less idiomatic code for a bit more clarity.
When formatted with Rust’s autoformatter, the result is 55 lines of code, compared to 42 for Cython:</p>

<div><div><pre><code><span>use</span> <span>pyo3</span><span>::</span><span>exceptions</span><span>::</span><span>PyIndexError</span><span>;</span>
<span>use</span> <span>pyo3</span><span>::</span><span>prelude</span><span>::</span><span>*</span><span>;</span>

<span>struct</span> <span>Point</span> <span>{</span>
    <span>x</span><span>:</span> <span>f64</span><span>,</span>
    <span>y</span><span>:</span> <span>f64</span><span>,</span>
<span>}</span>

<span>#[pyclass]</span>
<span>struct</span> <span>PointVec</span> <span>{</span>
    <span>vec</span><span>:</span> <span>Vec</span><span>&lt;</span><span>Point</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>#[pymethods]</span>
<span>impl</span> <span>PointVec</span> <span>{</span>
    <span>#[new]</span>
    <span>fn</span> <span>new</span><span>(</span><span>points</span><span>:</span> <span>Vec</span><span>&lt;</span><span>(</span><span>f64</span><span>,</span> <span>f64</span><span>)</span><span>&gt;</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>Self</span> <span>{</span>
            <span>vec</span><span>:</span> <span>points</span><span>.into_iter</span><span>()</span><span>.map</span><span>(</span>
                <span>|(</span><span>x</span><span>,</span> <span>y</span><span>)|</span> <span>Point</span> <span>{</span> <span>x</span><span>,</span> <span>y</span> <span>})</span><span>.collect</span><span>(),</span>
        <span>}</span>
    <span>}</span>

    <span>fn</span> <span>__</span><span>getitem__</span><span>(</span>
        <span>&amp;</span><span>self</span><span>,</span> <span>index</span><span>:</span> <span>usize</span>
    <span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>(</span><span>f64</span><span>,</span> <span>f64</span><span>)</span><span>&gt;</span> <span>{</span>
        <span>if</span> <span>self</span><span>.vec</span><span>.len</span><span>()</span> <span>&lt;=</span> <span>index</span> <span>{</span>
            <span>return</span> <span>Err</span><span>(</span><span>PyIndexError</span><span>::</span><span>new_err</span><span>(</span>
                <span>&#34;Index out of bounds&#34;</span><span>));</span>
        <span>}</span>
        <span>return</span> <span>Ok</span><span>((</span><span>self</span><span>.vec</span><span>[</span><span>index</span><span>]</span><span>.x</span><span>,</span> <span>self</span><span>.vec</span><span>[</span><span>index</span><span>]</span><span>.y</span><span>));</span>
    <span>}</span>

    <span>fn</span> <span>__</span><span>setitem__</span><span>(</span>
        <span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>index</span><span>:</span> <span>usize</span><span>,</span> <span>t</span><span>:</span> <span>(</span><span>f64</span><span>,</span> <span>f64</span><span>)</span>
    <span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
        <span>let</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>=</span> <span>t</span><span>;</span>
        <span>if</span> <span>self</span><span>.vec</span><span>.len</span><span>()</span> <span>&lt;=</span> <span>index</span> <span>{</span>
            <span>return</span> <span>Err</span><span>(</span><span>PyIndexError</span><span>::</span><span>new_err</span><span>(</span>
                <span>&#34;Index out of bounds&#34;</span><span>));</span>
        <span>}</span>
        <span>self</span><span>.vec</span><span>[</span><span>index</span><span>]</span> <span>=</span> <span>Point</span> <span>{</span> <span>x</span><span>,</span> <span>y</span> <span>};</span>
        <span>return</span> <span>Ok</span><span>(());</span>
    <span>}</span>

    <span>fn</span> <span>__</span><span>repr__</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>String</span> <span>{</span>
        <span>return</span> <span>format!</span><span>(</span>
            <span>&#34;PointVec[{}]&#34;</span><span>,</span>
            <span>self</span><span>.vec</span>
                <span>.iter</span><span>()</span>
                <span>.map</span><span>(|</span><span>t</span><span>|</span> <span>format!</span><span>(</span><span>&#34;({}, {})&#34;</span><span>,</span> <span>t</span><span>.x</span><span>,</span> <span>t</span><span>.y</span><span>))</span>
                <span>.collect</span><span>::</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>String</span><span>&gt;&gt;</span><span>()</span>
                <span>.join</span><span>(</span><span>&#34;, &#34;</span><span>)</span>
        <span>);</span>
    <span>}</span>
<span>}</span>

<span>#[pymodule]</span>
<span>fn</span> <span>rust_pointvec</span><span>(</span><span>_</span><span>py</span><span>:</span> <span>Python</span><span>,</span> <span>m</span><span>:</span> <span>&amp;</span><span>PyModule</span><span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
    <span>m</span><span>.add_class</span><span>::</span><span>&lt;</span><span>PointVec</span><span>&gt;</span><span>()</span><span>?</span><span>;</span>
    <span>return</span> <span>Ok</span><span>(())</span>
<span>}</span>
</code></pre></div></div>

<p>Notice that Rust has a built-in vector class, as well as iterators.
We also don’t need to manually free the memory, Rust will do that automatically.</p>

<p>The new version has the same functionality as the Cython one, but without the memory safety bug; the requirement for explicit typing forces us to notice that positive integers are likely what we want.</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>from</span> <span>rust_pointvec</span> <span>import</span> <span>PointVec</span>
<span>&gt;&gt;&gt;</span> <span>pv</span> <span>=</span> <span>PointVec</span><span>([(</span><span>1</span><span>,</span> <span>2</span><span>),</span> <span>(</span><span>3.5</span><span>,</span> <span>4</span><span>)])</span>
<span>&gt;&gt;&gt;</span> <span>pv</span>
<span>PointVec</span><span>[(</span><span>1</span><span>,</span> <span>2</span><span>),</span> <span>(</span><span>3.5</span><span>,</span> <span>4</span><span>)]</span>
<span>&gt;&gt;&gt;</span> <span>pv</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>(</span><span>17</span><span>,</span> <span>18</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>pv</span><span>[</span><span>0</span><span>]</span>
<span>(</span><span>17.0</span><span>,</span> <span>18.0</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>pv</span>
<span>PointVec</span><span>[(</span><span>17</span><span>,</span> <span>18</span><span>),</span> <span>(</span><span>3.5</span><span>,</span> <span>4</span><span>)]</span>
<span>&gt;&gt;&gt;</span> <span>pv</span><span>[</span><span>-</span><span>200000</span><span>]</span> <span>=</span> <span>(</span><span>12</span><span>,</span> <span>15</span><span>)</span>
<span>Traceback</span> <span>(</span><span>most</span> <span>recent</span> <span>call</span> <span>last</span><span>):</span>
  <span>File</span> <span>&#34;&lt;stdin&gt;&#34;</span><span>,</span> <span>line</span> <span>1</span><span>,</span> <span>in</span> <span>&lt;</span><span>module</span><span>&gt;</span>
<span>OverflowError</span><span>:</span> <span>can</span><span>&#39;t convert negative int to unsigned
</span></code></pre></div></div>

<p>What happens if we omit the bounds check, like this?</p>

<div><div><pre><code>    <span>fn</span> <span>__</span><span>setitem__</span><span>(</span>
        <span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>index</span><span>:</span> <span>usize</span><span>,</span> <span>t</span><span>:</span> <span>(</span><span>f64</span><span>,</span> <span>f64</span><span>)</span>
    <span>)</span> <span>-&gt;</span> <span>PyResult</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
        <span>let</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>=</span> <span>t</span><span>;</span>
        <span>// if self.vec.len() &lt;= index {</span>
        <span>//     return Err(PyIndexError::new_err(</span>
        <span>//         &#34;Index out of bounds&#34;));</span>
        <span>// }</span>
        <span>self</span><span>.vec</span><span>[</span><span>index</span><span>]</span> <span>=</span> <span>Point</span> <span>{</span> <span>x</span><span>,</span> <span>y</span> <span>};</span>
        <span>return</span> <span>Ok</span><span>(());</span>
    <span>}</span>
</code></pre></div></div>

<p>Rust still protects us:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>from</span> <span>rust_pointvec</span> <span>import</span> <span>PointVec</span>
<span>&gt;&gt;&gt;</span> <span>pv</span> <span>=</span> <span>PointVec</span><span>([(</span><span>1</span><span>,</span> <span>2</span><span>),</span> <span>(</span><span>3.5</span><span>,</span> <span>4</span><span>)])</span>
<span>&gt;&gt;&gt;</span> <span>pv</span><span>[</span><span>200000</span><span>]</span> <span>=</span> <span>(</span><span>12</span><span>,</span> <span>15</span><span>)</span>
<span>thread</span> <span>&#39;&lt;unnamed&gt;&#39;</span> <span>panicked</span> <span>at</span> <span>&#39;index out of bounds: the len is 2 but the index is 200000&#39;</span><span>,</span> <span>src</span><span>/</span><span>lib</span><span>.</span><span>rs</span><span>:</span><span>35</span><span>:</span><span>9</span>
<span>note</span><span>:</span> <span>run</span> <span>with</span> <span>`RUST_BACKTRACE=1`</span> <span>environment</span> <span>variable</span> <span>to</span> <span>display</span> <span>a</span> <span>backtrace</span>
<span>Traceback</span> <span>(</span><span>most</span> <span>recent</span> <span>call</span> <span>last</span><span>):</span>
  <span>File</span> <span>&#34;&lt;stdin&gt;&#34;</span><span>,</span> <span>line</span> <span>1</span><span>,</span> <span>in</span> <span>&lt;</span><span>module</span><span>&gt;</span>
<span>pyo3_runtime</span><span>.</span><span>PanicException</span><span>:</span> <span>index</span> <span>out</span> <span>of</span> <span>bounds</span><span>:</span> <span>the</span> <span>len</span> <span>is</span> <span>2</span> <span>but</span> <span>the</span> <span>index</span> <span>is</span> <span>200000</span>
</code></pre></div></div>

<h2 id="dont-back-yourself-into-a-corner">Don’t back yourself into a corner</h2>

<p>If you’re writing a small extension and security is not a concern, Cython may be a fine choice.
Nonetheless, it’s worth looking ahead and thinking about the scope of your project.</p>

<p>If you expect your codebase to grow significantly, it’s probably worth the investment to start with a better language from the start.
You don’t want to start hitting the limits of Cython after you’ve written a whole pile of code.</p>

<p>Learning Rust will take more work.
But in return your code will be more maintainable, because you will have access to a wide variety of libraries, far better tooling, and far fewer security concerns.</p>

<p>Finally, it’s worth noting that the original author of Polars didn’t write the JavaScript bindings, someone else did.
If you’re writing an open source library, using a non-Python-specific language for the core implementation allows non-Python programmers access to the code, without necessarily adding extra work on your part.</p>


  </div></div>
  </body>
</html>
