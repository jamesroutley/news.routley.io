<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://keithfrost.github.io/2025-08-08-frac5.html">Original</a>
    <h1>Frac5: A new type of flame fractal</h1>
    
    <div id="readability-page-1" class="page">


<nav id="TOC" role="doc-toc">
<h2 id="toc-title">table of contents</h2>
<ul>
<li><a href="#iterated-function-systems" id="toc-iterated-function-systems">Iterated function systems</a></li>
<li><a href="#porting-to-numerical-elixir" id="toc-porting-to-numerical-elixir">Porting to Numerical
Elixir</a></li>
<li><a href="#welcome-to-the-5th-dimension" id="toc-welcome-to-the-5th-dimension">Welcome to the 5th
dimension</a></li>
<li><a href="#themes-and-variations" id="toc-themes-and-variations">Themes and variations</a></li>
<li><a href="#a-walk-through-the-code" id="toc-a-walk-through-the-code">A walk through the code</a>
<ul>
<li><a href="#frac5.affine" id="toc-frac5.affine"><code>Frac5.Affine</code></a></li>
<li><a href="#frac5.transforms" id="toc-frac5.transforms"><code>Frac5.Transforms</code></a></li>
<li><a href="#frac5.pixels" id="toc-frac5.pixels"><code>Frac5.Pixels</code></a></li>
</ul></li>
<li><a href="#future-plans" id="toc-future-plans">Future Plans</a></li>
</ul>
</nav>
<figure>
<img src="https://keithfrost.github.io/images/fractal255.png" alt="example frac5 fractal image"/>
<figcaption aria-hidden="true">example frac5 fractal image</figcaption>
</figure>
<p>This article describes my journey from generating flame fractals
using <a href="https://elixir-lang">Elixir</a>, to generating a new type
of (flame-ish?) fractal in <a href="https://github.com/elixir-nx">Numerical Elixir</a>. The code is
published as a GPL Elixir library at <a href="https://github.com/KeithFrost/frac5">github.com/KeithFrost/frac5</a>.</p>
<p>This summer I’ve been working on personal projects at the <a href="https://recurse.com">Recurse Center</a> (RC). Part of the RC
application process involves pitching at least one project that you plan
to work on. The <a href="https://github.com/KeithFrost/frac5">frac5</a>
project was inspired by the pitch I wrote for my RC application.</p>
<p>To give due credit, the work I describe here would not exist without
Danielle Navarro’s terrific article <a href="https://blog.djnavarro.net/posts/2024-12-22_art-from-code-5/">Art
from code V: Iterated function systems</a> (hereinafter referred to as
<em>AFC5</em>); I’m going to summarize only those parts of their article
which I used for my starting point, but I encourage you to read the
whole thing for edification and inspiration.</p>
<p>I had been using <a href="https://elixir-lang">Elixir</a> for
personal projects for a while, because I find programming with it
elegant and fun; I especially enjoy prototyping code using <a href="https://livebook.dev">Elixir Livebook</a> running locally. I had
read about <a href="https://github.com/elixir-nx">Numerical Elixir</a>,
which extends the language to make it possible to perform the kind of
efficient numerical programming often done with <a href="https://numpy.org">NumPy</a>, <a href="https://pytorch.org">PyTorch</a>, or similar libraries, but I had
not found a use case to motivate learning how to program it myself. I
came across <a href="https://blog.djnavarro.net/posts/2024-12-22_art-from-code-5/"><em>AFC5</em></a>,
enjoyed the beautiful images they were able to generate (especially
those at the end of the article), and was a little uncomfortable about
needing to resort to writing C++ to generate those detailed images
quickly. My initial plan was to retrace their steps using only Elixir,
and then explore if there was some way to use Numerical Elixir to
accelerate the image generation.</p>

<p>I will now briefly recap how the beautiful images at the end of
<em>AFC5</em> are generated, although if you want to reproduce all the
details from that article precisely, you should of course refer to it,
and the code it provides, directly.</p>
<p>Those images are generated by starting with a single point <span>\(p_0\)</span> in a three-dimensional space <span>\({p_0 \equiv (x_0, y_0, z_0)}\)</span>. In what
follows, we will refer to the coordinates of these points by a second
index, so we have <span>\[
p_0 \equiv (p_{0,0}, p_{0,1}, p_{0,2}) \equiv (x_0, y_0, z_0)
\]</span></p>
<p>The point <span>\(p_0\)</span> is then passed
through a series of transformations, alternating between linear and
non-linear steps, and after each non-linear step, the resulting point is
added into the collection of points to be rendered.</p>
<p>In effect, we generate a collection of points <span>\(\{p_k\}, k=0,1,2,...\)</span>, where <span>\[
p_{k} = f_k\left( \sum_j A_{k,i,j} \cdot p_{k-1,j} \right).
\]</span> The meaning of the linear transformation here should be clear:
<span>\[
q_{k,i} = \sum_{j=0}^2 A_{k,i,j} \cdot p_{k-1,j}, i = 0,1,2.
\]</span> defines a new 3-D vector <span>\(q_k\)</span> by multiplying the 3-D vector <span>\(p_{k-1}\)</span> by a <span>\(3 \times 3\)</span> matrix <span>\(A_k\)</span>. What we mean by <span>\(p_k = f_k(q_{k,i})\)</span> perhaps needs some
clarification. The general function <span>\(f_k\)</span> is understood to accept as arguments
<em>all three of the components</em> of the 3-D vector <span>\(q_k\)</span>, and return <em>all three of the
components</em> of the 3-D vector <span>\(p_k\)</span>.</p>
<p>In the iterated systems discussed at the end of <em>AFC5</em>, the
transformation matrix <span>\(A_k\)</span> at each
stage <span>\(k = 1,2,3,...\)</span> is randomly
chosen from a set of matrices <span>\(\{M_q\},
q=1,2,...m\)</span>, and the function <span>\(f_k(q_k)\)</span> is likewise randomly chosen from
a set of non-linear transformations <span>\(\{G_r(q)\}\)</span>, defined in <em>AFC5</em> as
<span>\[
\begin{align}
G_{0,i}(q) &amp;= q_i + \left( \sum_j q_j^2 \right)^{1/3} \\
G_{1,i}(q) &amp;= \sin(q_i) \\
G_{2,i}(q) &amp;= 2 \cdot \sin(q_i)
\end{align}
\]</span></p>
<p>I have taken the liberty here of eliding some manipulations performed
in the original <em>AFC5</em> article, which treat the <span>\(z\)</span> coordinate of the points specially, to
ensure that the <span>\(z\)</span> coordinate always
remains non-negative, and to average the new <span>\(z\)</span> coordinate <span>\(p_{k,2}\)</span> with its previous value <span>\(p_{k-1,2}\)</span> before finalizing its value.
These details might be important if you wish to reproduce the results of
that article in detail, but for understanding the extension of that work
to follow, it seems best to me to treat all dimensions of the vector
space symmetrically, until we are ready to render the pixel data of the
image.</p>
<p>Speaking of being ready to render pixel data, we have seen how we can
generate an arbitrarily large collection of points <span>\(\{p_k\},
k=0,1,2,...\)</span>, but how do we turn those points into an image? In
the algorithm described in <em>ACS5</em>, we transform the <span>\((x, y)\)</span> coordinates of the points into
indices of a two-dimensional pixel array, and then, if those indices
fall within the bounds of the array, set the color of the pixel
referenced by those indices to a value determined by some chosen palette
for converting <span>\(z\)</span> values to
colors.</p>
<p>I found I was able to reproduce, as closely as I wished, the work in
<em>ACS5</em>, by writing code in ordinary Elixir (without using
Numerical Elixir), and it performed well enough to generate some lovely
images within acceptable times. For example:</p>
<figure>
<img src="https://keithfrost.github.io/images/fractal002.png" alt="first fractal I made, using a palette"/>
<figcaption aria-hidden="true">first fractal I made, using a
palette</figcaption>
</figure>
<p>As soon as I was able to generate this image (and several others like
it), I became tremendously excited by the potential of the project. I
knew that there was much more work I could explore along these lines, by
investigating each of the choices that went into creating the images,
and finding ways to either optimize the implementation, or expand the
range of choices available for artistic purposes. But more than that, I
was supremely motivated by the surprising and spectacular beauty of the
generated pictures, especially when combined with the stark mathematical
simplicity of the means of generating them. To put it bluntly, I was
hooked.</p>

<p>While it is possible to generate interesting and beautiful images
using only a few million points using the scheme described in
<em>ACS5</em>, more subtle and complex textures become possible by
scaling the number of points up to hundreds of millions. And while it is
possible to process such large numbers of points on a CPU using a
language like Elixir, such “number-crunching” applications are not the
forte of the language, and it soon becomes tedious to wait for the image
generation process. The author of <em>ACS5</em> opted to port the
algorithm to C++ to achieve better speed; I wanted to find out if it
might be possible to do so using the features of Numerical Elixir,
especially with a backend programmed to use a GPU.</p>
<p>I quickly realized that there was a significant obstacle to achieving
a significant performance improvement of the fractal algorithm presented
above using <code>Nx</code>, particularly on the GPU. Many of the
performance benefits achieved by libraries like <code>Nx</code>, which
manipulate numbers in large, often multi-dimensional arrays, come from
being able to compute operations on many elements of these arrays <em>in
parallel</em>. This is <em>especially</em> true for the performance
enhancements provided by using the GPU. But recall the algorithm
presented above, in which we might wish to process hundreds of millions
of points <span>\(\{p_k\},
k=0,1,2...\)</span>, defined <em>in sequence</em> by some transformation
<span>\(p_{k-1}
\rightarrow p_k\)</span>. If the components of each point <span>\(p_k\)</span> depend on some random choices <em>and
the components of the preceding point</em> <span>\(p_{k-1}\)</span>, we cannot achieve any high
degree of parallelism of the processing of these points, since a
processor (either CPU or GPU) cannot process a point until the values
from the preceding point (and the random choices) are available.</p>
<p>One means of circumventing this difficulty would seem to be, to
replace the single starting point <span>\(p_0\)</span> with an ensemble of starting points,
and to achieve the efficiencies of parallelism by collecting ensembles
of points processed through the steps of the algorithm in parallel.
Unfortunately, my experiments with implementing this approach convinced
me that the results did not successfully reproduce the aesthetic
features of the beautiful images generated by the original
algorithm.</p>
<p>Instead, inspired by another variation on the algorithm I had
explored, I decided to try something else. Recall above that there were
two distinct random choices made for each transformation of the points:
first, a random matrix was chosen for the linear transformation, and
second, a random non-linear transformation was chosen. I had already
experimented with replacing the random choice of matrix with a simple
repeating sequence of matrices. To transform the point <span>\(p_k\)</span>, for example, we might use the matrix
<span>\(M_{k
\bmod m}\)</span>, where <span>\(m\)</span> is the
number of random matrices initially generated. This gave results which
were just as beautiful as the random choice algorithm.</p>
<p>So when I thought about how to make the algorithm more suitable to
parallel computation, I was already primed to consider modifying the
random choice rule. In particular, I opted to try, instead of randomly
choosing <em>one</em> of the non-linear transformations available, to
always perform <em>all</em> of the non-linear transformations, and to
add all of the points thus generated, both to the set of points used to
render the image, and to an ensemble of points to be passed to the next
stage of the algorithm. This means that the number of points in the
ensemble at each stage of the algorithm grows exponentially with each
such application of the non-linear transformations. When the ensemble of
points grows sufficiently large, I split it up into batches, in order to
avoid having any one block of memory need to be too large. Since blocks
of points can be discarded once they are accumulated into the grid used
to generate the image pixels, and Elixir allows me to generate a lazy
stream of blocks of points for accumulation into the grid, this helps to
keep memory usage of the program at any one time under control.</p>
<p>I found removing all of the random choices from the execution of the
algorithm in this way both aesthetically and intellectually pleasing. I
now had a <em>deterministic</em> algorithm for generating beautiful
images, given only a sequence of <span>\(3 \times
3\)</span> matrices, a set of arbitrary (usually non-linear) point
transformations to be applied, and a color palette for mapping <span>\(z\)</span> values to colors. Moreover, the
algorithm could be made to transform enormous numbers of points in
parallel, opening the door to making it possible to accelerate it by
running on GPU hardware. But I still wasn’t quite satisfied with the
generality of the mathematics. In particular, I wanted to use a wider
variety of color palettes than those I had yet defined, and I was
uncomfortable with the tedium and what seemed to me the arbitrariness of
the choices involved in creating new palettes.</p>

<p>One day I went for a walk, and reflected on how I might remove the
need to define a color palette for rendering. After a couple miles of
walking, I was struck with an idea. Instead of a three dimensional space
<span>\((x,y,z)\)</span>, I would process points in
a completely analogous way, but in a five dimensional space <span>\((x,y,r,g,b)\)</span>. When it came time to render
these points to pixel colors, all I would need is a single choice of
mapping function from color space coordinate to the corresponding range
of pixel values (<em>e.g.</em> <span>\([0,255]\)</span>). Below is the very first image I
generated using this new scheme.</p>
<figure>
<img src="https://keithfrost.github.io/images/fractal041.png" alt="my first 5-D fractal image"/>
<figcaption aria-hidden="true">my first 5-D fractal image</figcaption>
</figure>
<p>It didn’t take very long, after experimenting with generating these
5-D images, that I determined that, in some sense, three degrees of
freedom in color space was really a bit more than I wanted to have in
most of the final images I was generating. So I modified the rendering
algorithm that accumulated the pixel values, so that it accepted the
points from the 5-D space, but then subtracted from the color components
of each point the portion which was parallel to a chosen (random or
arbitrary) unit vector in the 3-D color space, thus flattening the color
space to a plane perpendicular to that unit vector.</p>
<p>It was around this time that I got a Mac mini to work with, so I
found the <a href="https://github.com/elixir-nx/emlx">EMLX</a> library,
which provides an optimized backend for Numerical Elixir which runs on
the Mac GPU, and I was quite pleased with the performance boost this
gave to the image generation process, allowing me to generate images by
processing roughly 300 million points in just a few seconds.</p>
<p>The effects of flattening the color space, and using as many points
as I wanted, can be seen in the next sample image.</p>
<figure>
<img src="https://keithfrost.github.io/images/fractal100.png" alt="interesting colors and lots of points"/>
<figcaption aria-hidden="true">interesting colors and lots of
points</figcaption>
</figure>

<p>If it’s not already clear, I should point out that I experimented
freely with as many aspects of the image generation process as I could
recognize as choices, to discover if I could produce effects that I
found pleasing. When it came time to publish a library of code for this
project, it was rather difficult to decide what choices should be hard
coded, as opposed to keeping the library as flexible as possible, to
support whatever I or other users of the library might want to do with
it in the future.</p>
<p>One of the features of the algorithm that I ended up experimenting
with, was the choice to select the points <em>right after the non-linear
operations</em>, as those to send to the rendering process, as opposed
to the points <em>right after the matrix multiplications</em>. By
performing the non-linear operations first, and sending points to
rendering after the matrix multiplication, the prominent “squares”
(projections of 5-D hypercubes) in the earlier images, which were
artifacts of the <span>\(C\cdot\sin(q_{k,i})\)</span> non-linear
transformations, could be removed, which was a feature I
<em>sometimes</em> wanted. I ended up compromising, by writing the
algorithm so that it sent the points to rendering after the sequential,
<em>usually</em> linear operations, but adding an optional argument to
the function which generates the stream of linear operations, which
allows the caller to specify some other operations (presumably
non-linear) to be interleaved between the linear transformations in the
sequence. The image which heads this article, was generated by simply
rendering points after each linear transformation.</p>

<p>The core of the library, as currently implemented, is divided into
three major modules: <code>Frac5.Affine</code>,
<code>Frac5.Transforms</code>, and <code>Frac5.Pixels</code>. There are
two other modules, <code>Frac5.Pnm</code> for reading and writing <a href="https://en.wikipedia.org/wiki/Netpbm">Netpbm</a> image files, and
<code>Frac5.Extract</code>, for computing a <code>zcolor</code> unit
vector from an input image, but we will not delve into those two modules
here.</p>
<h2 id="frac5.affine"><code>Frac5.Affine</code></h2>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>defmodule</span> <span>Frac5</span><span>.</span><span>Affine</span> <span>do</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span>import</span> <span>Nx</span><span>.</span><span>Defn</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span>defstruct</span> <span>matrix:</span> <span>nil</span>, <span>txform:</span> <span>nil</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span>@pi2</span> <span>2.0</span> <span>*</span> <span>:math</span><span>.</span>acos<span>(</span><span>-</span><span>1.0</span><span>)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span>@pi4</span> <span>2.0</span> <span>*</span> <span>@pi2</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span>@pi10</span> <span>5.0</span> <span>*</span> <span>@pi2</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  defn affine_tx<span>(</span>matrix, pts<span>)</span> <span>do</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span>Nx</span><span>.</span>remainder<span>(</span><span>Nx</span><span>.</span>dot<span>(</span>pts, matrix<span>)</span> <span>+</span> <span>@pi10</span>, <span>@pi4</span><span>)</span> <span>-</span> <span>@pi2</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span>def</span> generate<span>(</span>scale<span>)</span> <span>do</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    variance <span>=</span> scale <span>*</span> scale</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    matrix <span>=</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>      <span>for</span> _i <span>&lt;-</span> <span>0</span><span>..</span><span>4</span> <span>do</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span>for</span> _j <span>&lt;-</span> <span>0</span><span>..</span><span>4</span> <span>do</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>          <span>:rand</span><span>.</span>normal<span>(</span><span>0.0</span>, variance<span>)</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span>end</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>      <span>end</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>      <span>|&gt;</span> <span>Nx</span><span>.</span>tensor<span>()</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    %<span>Frac5</span><span>.</span><span>Affine</span><span>{</span><span>matrix:</span> matrix, <span>txform:</span> <span>fn</span> pts <span>-&gt;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>      affine_tx<span>(</span>matrix, pts<span>)</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span>end</span><span>}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>  <span>def</span> generate_stream_init<span>(</span>n, scale, txfms \\ <span>[]</span><span>)</span> <span>do</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    affs <span>=</span> <span>Enum</span><span>.</span>map<span>(</span><span>1</span><span>..</span>n, <span>fn</span> _i <span>-&gt;</span> generate<span>(</span>scale<span>)</span> <span>end</span><span>)</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    init_points <span>=</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>      <span>Enum</span><span>.</span>flat_map<span>(</span>affs, <span>fn</span> aff <span>-&gt;</span> <span>Nx</span><span>.</span>to_list<span>(</span>aff<span>.</span>matrix<span>)</span> <span>end</span><span>)</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>      <span>|&gt;</span> <span>Nx</span><span>.</span>tensor<span>()</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>      <span>|&gt;</span> <span>Nx</span><span>.</span>multiply<span>(</span><span>1.0</span> <span>/</span> scale<span>)</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    txforms <span>=</span> interleave<span>(</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>      <span>Enum</span><span>.</span>map<span>(</span>affs, <span>fn</span> aff <span>-&gt;</span> aff<span>.</span>txform <span>end</span><span>)</span>,</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>      txfms<span>)</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    stream <span>=</span> <span>Stream</span><span>.</span>cycle<span>(</span>txforms<span>)</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span>{</span>stream, init_points<span>}</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span>end</span></span></code></pre></div>
<p>Declaring <code>import Nx.Defn</code> allows us to use the Numerical
Elixir numerical function definition</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  defn affine_tx<span>(</span>matrix, pts<span>)</span> <span>do</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span>...</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span></code></pre></div>
<p>which is notably not equivalent to a standard Elixir function
definition. Instead, this form is meant to declare functions of
Numerical Elixir tensor objects, which can be compiled to run on
whatever backend is configured. The semantics of operations inside an
<code>Nx</code> numerical function are handled differently: for example,
notice that we use the <code>+</code> symbol to add a floating point
constant to a tensor, which would raise an error if it were attempted in
ordinary Elixir code.</p>
<p>You may also note that we define the affine transformation a little
differently than the simple formula provided in the earlier discussion.
This is because I chose to define the five-dimensional space in which
all our operations take place to be a hyper-toroid, with the space
wrapping around at fixed boundaries in each dimension. All coordinates
are constrained to fall in the range <span>\([-2\pi,
2\pi]\)</span>, and any coordinate which would fall outside that range,
is reinterpreted modulo <span>\(4\pi\)</span>, to
fall back inside the range.</p>
<p>The <code>generate_stream_init()</code> function will usually be the
main entry point for this module. It creates an infinite (lazy) stream
of linear transformations, repeating every <code>n</code> linear steps,
possibly interleaved with a likewise repeating list of other
transformations supplied by the programmer. It returns this infinite
stream, along with a set of initial points, which are constructed by
simply taking the rows of the generated matrices.</p>
<p>(Note that <code>interleave</code> is a private function to this
module, which does just what the name suggests: accepts two lists as
arguments, and generates a list by interleaving available values from
each of its two inputs until <em>both</em> inputs are exhausted.)</p>
<h2 id="frac5.transforms"><code>Frac5.Transforms</code></h2>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>defmodule</span> <span>Frac5</span><span>.</span><span>Transforms</span> <span>do</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span>import</span> <span>Nx</span><span>.</span><span>Defn</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span>@pi2</span> <span>2.0</span> <span>*</span> <span>:math</span><span>.</span>acos<span>(</span><span>-</span><span>1.0</span><span>)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span>@pi4</span> <span>2.0</span> <span>*</span> <span>@pi2</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span>@pi10</span> <span>5.0</span> <span>*</span> <span>@pi2</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  defn expand<span>(</span>pts<span>)</span> <span>do</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    s2 <span>=</span> <span>Nx</span><span>.</span>sum<span>(</span>pts <span>*</span> pts, <span>axes:</span> <span>[</span><span>-</span><span>1</span><span>]</span>, <span>keep_axes:</span> <span>true</span><span>)</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span>Nx</span><span>.</span>remainder<span>(</span>pts <span>+</span> <span>Nx</span><span>.</span>pow<span>(</span>s2, <span>0.25</span><span>)</span> <span>+</span> <span>@pi10</span>, <span>@pi4</span><span>)</span> <span>-</span> <span>@pi2</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  defn contract<span>(</span>pts<span>)</span> <span>do</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    s2 <span>=</span> <span>Nx</span><span>.</span>sum<span>(</span>pts <span>*</span> pts, <span>axes:</span> <span>[</span><span>-</span><span>1</span><span>]</span>, <span>keep_axes:</span> <span>true</span><span>)</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    pts <span>*</span> <span>Nx</span><span>.</span>pow<span>(</span>s2, <span>-</span><span>0.33</span><span>)</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  defn wmean<span>(</span>pts<span>)</span> <span>do</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span>Nx</span><span>.</span>window_mean<span>(</span>pts, <span>{</span><span>2</span>, <span>1</span><span>}</span>, <span>padding:</span> <span>:same</span><span>)</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>  defn sin2<span>(</span>pts<span>)</span> <span>do</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span>2.0</span> <span>*</span> <span>Nx</span><span>.</span>sin<span>(</span>pts<span>)</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>  <span>def</span> default_parallels<span>()</span> <span>do</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span>[</span><span>&amp;</span>expand<span>/</span><span>1</span>, <span>&amp;</span>contract<span>/</span><span>1</span>, <span>&amp;</span><span>Nx</span><span>.</span>cos<span>/</span><span>1</span><span>]</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>  <span>@chunk_limit</span> <span>100_000</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>  <span>def</span> points_stream<span>(</span>txform_stream, init_points, parallels<span>)</span> <span>do</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span>Stream</span><span>.</span>transform<span>(</span>txform_stream, <span>[</span>init_points<span>]</span>, <span>fn</span> txform, pts_stream <span>-&gt;</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>      next_stream <span>=</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        <span>Stream</span><span>.</span>flat_map<span>(</span>pts_stream, <span>fn</span> pts <span>-&gt;</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>          <span>{</span>n, _<span>}</span> <span>=</span> <span>Nx</span><span>.</span>shape<span>(</span>pts<span>)</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>          <span>if</span> n <span>&gt;=</span> <span>@chunk_limit</span> <span>do</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>            <span>Enum</span><span>.</span>map<span>(</span>parallels, <span>fn</span> par <span>-&gt;</span> txform<span>.</span><span>(</span>par<span>.</span><span>(</span>pts<span>))</span> <span>end</span><span>)</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>          <span>else</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>            ppts <span>=</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>              <span>Enum</span><span>.</span>map<span>(</span>parallels, <span>fn</span> par <span>-&gt;</span> par<span>.</span><span>(</span>pts<span>)</span> <span>end</span><span>)</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>              <span>|&gt;</span> <span>Nx</span><span>.</span>concatenate<span>()</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>            <span>[</span>txform<span>.</span><span>(</span>ppts<span>)</span><span>]</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>          <span>end</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>        <span>end</span><span>)</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>      <span>{</span>next_stream, next_stream<span>}</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>    <span>end</span><span>)</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a><span>end</span></span></code></pre></div>
<p>Note that the <code>expand</code> function is a bit different than
the transformation from <em>AFC5</em>: not only does it apply the
wrapping behavior to <span>\([-2\pi,2\pi]\)</span>,
but the power applied is <span>\(1/4\)</span>
instead of <span>\(1/3\)</span>. There are many such
detailed choices open to one generating these fascinating images: the
user of this library can easily supply their own function definitions.
There is also a <code>contract</code> function which I found
interesting, as well as the <code>wmean</code>, which simply averages
every two adjacent points in its input. Twice the <code>sin</code>
function still makes an appearance, but the defaults I wrote use
<code>cos</code> instead. Again, the point is not to repeat exactly the
same image generation techniques, but to experiment and find what is
most interesting in the moment.</p>
<p>The main utility function here is <code>points_stream()</code>, which
accepts as arguments a stream of transforms, a tensor of initial points,
and the (usually non-linear) list of functions to be applied to expand
the set of points exponentially. The first two arguments would usually
be expected to be generated by the
<code>Frac5.Affine.generate_stream_init()</code> function. The
<code>points_stream</code> function, as the name suggests, returns a
stream of tensors of points, where once there are more than
<code>@chunk_size 100_000</code> points in a tensor, they will no longer
be concatenated to make larger tensors, but streamed instead.</p>
<h2 id="frac5.pixels"><code>Frac5.Pixels</code></h2>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>defmodule</span> <span>Frac5</span><span>.</span><span>Pixels</span> <span>do</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span>import</span> <span>Nx</span><span>.</span><span>Defn</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span>def</span> rand_unit_vec<span>(</span>dim<span>)</span> <span>do</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    l <span>=</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>      <span>for</span> _i <span>&lt;-</span> <span>1</span><span>..</span>dim <span>do</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span>:rand</span><span>.</span>normal<span>(</span><span>0.0</span>, <span>1.0</span><span>)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>      <span>end</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    norm <span>=</span> <span>:math</span><span>.</span>sqrt<span>(</span><span>Enum</span><span>.</span>reduce<span>(</span>l, <span>0</span>, <span>fn</span> v, sum <span>-&gt;</span> sum <span>+</span> v <span>*</span> v <span>end</span><span>))</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span>Enum</span><span>.</span>map<span>(</span>l, <span>fn</span> v <span>-&gt;</span> v <span>/</span> norm <span>end</span><span>)</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span>|&gt;</span> <span>Nx</span><span>.</span>tensor<span>()</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span>@pi2</span> <span>2.0</span> <span>*</span> <span>:math</span><span>.</span>acos<span>(</span><span>-</span><span>1.0</span><span>)</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  <span>@pi4</span> <span>2.0</span> <span>*</span> <span>@pi2</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span>@resolution</span> <span>2048</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>  defn pixel_reducer<span>(</span>pts, <span>{</span>grid, count<span>}</span>, zcolor<span>)</span> <span>do</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    dim <span>=</span> <span>@resolution</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span>{</span>npts, <span>5</span><span>}</span> <span>=</span> <span>Nx</span><span>.</span>shape<span>(</span>pts<span>)</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    rgbs <span>=</span> pts<span>[[</span><span>..</span>, <span>2</span><span>..</span><span>4</span><span>]]</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    dots <span>=</span> <span>Nx</span><span>.</span>dot<span>(</span>rgbs, zcolor<span>)</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    rgbs <span>=</span> rgbs <span>-</span> <span>Nx</span><span>.</span>outer<span>(</span>dots, zcolor<span>)</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    xys <span>=</span> pts<span>[[</span><span>..</span>, <span>0</span><span>..</span><span>1</span><span>]]</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    indices <span>=</span> <span>Nx</span><span>.</span>as_type<span>(</span><span>Nx</span><span>.</span>floor<span>(</span>dim <span>*</span> <span>(</span>xys <span>+</span> <span>@pi2</span><span>)</span> <span>/</span> <span>@pi4</span><span>)</span>, <span>:s16</span><span>)</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    indices <span>=</span> <span>Nx</span><span>.</span>clip<span>(</span>indices, <span>0</span>, dim <span>-</span> <span>1</span><span>)</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    grid <span>=</span> <span>Nx</span><span>.</span>indexed_add<span>(</span>grid, indices, rgbs<span>)</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    count <span>=</span> <span>Nx</span><span>.</span>indexed_add<span>(</span>count, indices, <span>Nx</span><span>.</span>broadcast<span>(</span><span>1</span>, <span>{</span>npts, <span>1</span><span>}))</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span>{</span>grid, count<span>}</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>  defn color_bytes<span>(</span>grid, count<span>)</span> <span>do</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span>Nx</span><span>.</span>as_type<span>(</span><span>127.5</span> <span>*</span> <span>(</span><span>1.0</span> <span>-</span> <span>Nx</span><span>.</span>cos<span>(</span>grid <span>/</span> count<span>))</span>, <span>:u8</span><span>)</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>  <span>def</span> pixelate<span>(</span>points, zcolor, batches<span>)</span> <span>do</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    dim <span>=</span> <span>@resolution</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    grid0 <span>=</span> <span>Nx</span><span>.</span>broadcast<span>(</span><span>0.0</span>, <span>{</span>dim, dim, <span>3</span><span>})</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    count0 <span>=</span> <span>Nx</span><span>.</span>broadcast<span>(</span><span>0</span>, <span>{</span>dim, dim, <span>1</span><span>})</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    <span>{</span>grid, count<span>}</span> <span>=</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>      <span>Stream</span><span>.</span>take<span>(</span>points, batches<span>)</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>      <span>|&gt;</span> <span>Enum</span><span>.</span>reduce<span>({</span>grid0, count0<span>}</span>, <span>fn</span> pts, <span>{</span>grid, count<span>}</span> <span>-&gt;</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>        pixel_reducer<span>(</span>pts, <span>{</span>grid, count<span>}</span>, zcolor<span>)</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>      <span>end</span><span>)</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    <span>IO</span><span>.</span>inspect<span>(</span><span>Nx</span><span>.</span>to_number<span>(</span><span>Nx</span><span>.</span>sum<span>(</span>count<span>)))</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>    count <span>=</span> <span>Nx</span><span>.</span>clip<span>(</span>count, <span>1</span>, <span>2_000_000</span> <span>*</span> batches<span>)</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>    color_bytes<span>(</span>grid, count<span>)</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>  <span>end</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a><span>end</span></span></code></pre></div>
<p>The main entry point here is <code>pixelate</code>, which accepts a
stream of tensors of points, as may be generated by
<code>Frac5.Transforms.points_stream()</code>, a <code>zcolor</code>
3-vector to project out of the color space, and a number of
<code>batches</code> to collect from the input stream (which, after all,
may be infinite). It generates a pixel grid as a tensor of dimensions
<code>{2048, 2048, 3}</code>, chosen arbitrarily enough, maps the <span>\([-2\pi,2\pi]\)</span> range of the spatial
coordinates to <span>\([0,2047]\)</span>, and uses
the function <span>\(255(1 - \cos(c))/2\)</span> to
map the color coordinates to <span>\([0,
255]\)</span>. It takes the average of the color coordinates of all of
the points which fall in a pixel, to determine the color for the pixel.
Most of the numerical work here takes place in the
<code>pixel_reducer()</code> numerical function.</p>

<p>There are many interesting directions one could take this work. One
approach would be to look at the alternation of linear and non-linear
transformations as an unusual kind of neural net, and ask, how might we
train such a network, to generate especially interesting images? I have
briefly investigated this option, without identifying a loss function I
found useful. Another direction I hope to explore, is making the process
of creating these images more dynamic or interactive, perhaps by using
<code>WebGPU</code> in the browser. It may prove fruitful, having
identified a set of matrices which look quite exciting, to be able to
tune the values of those matrices to optimize the result. Most of all,
though, I hope to inspire others to go forth and write programs which
generate beauty!</p>
<figure>
<img src="https://keithfrost.github.io/images/fractal447.png" alt="closing fractal image"/>
<figcaption aria-hidden="true">closing fractal image</figcaption>
</figure>



</div>
  </body>
</html>
