<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thejpster.org.uk/blog/blog-2025-03-30/">Original</a>
    <h1>An AlphaStation&#39;s SROM</h1>
    
    <div id="readability-page-1" class="page"><div id="main" role="main">

      
      <header role="banner">
        <h3>
          <a href="https://thejpster.org.uk" title="Home">JP&#39;s Website</a>
          </h3>
      </header>
      <hr/>
      

      



<p>Posted on <strong>2025-03-30</strong></p>


    <h2>Contents</h2>
    <ul>
    
        <li>
            <a href="https://thejpster.org.uk/blog/blog-2025-03-30/#background">Background</a>
            
        </li>
    
        <li>
            <a href="https://thejpster.org.uk/blog/blog-2025-03-30/#the-alphastation-500">The AlphaStation 500</a>
            
        </li>
    
        <li>
            <a href="https://thejpster.org.uk/blog/blog-2025-03-30/#srom">SROM</a>
            
        </li>
    
        <li>
            <a href="https://thejpster.org.uk/blog/blog-2025-03-30/#srom-image-selection">SROM Image selection</a>
            
        </li>
    
        <li>
            <a href="https://thejpster.org.uk/blog/blog-2025-03-30/#splitting-the-srom">Splitting the SROM</a>
            
        </li>
    
        <li>
            <a href="https://thejpster.org.uk/blog/blog-2025-03-30/#decoding-the-images">Decoding the images</a>
            
        </li>
    
        <li>
            <a href="https://thejpster.org.uk/blog/blog-2025-03-30/#dissasmbling-the-decoded-images">Dissasmbling the decoded images</a>
            
        </li>
    
        <li>
            <a href="https://thejpster.org.uk/blog/blog-2025-03-30/#conclusions">Conclusions</a>
            
        </li>
    
        <li>
            <a href="https://thejpster.org.uk/blog/blog-2025-03-30/#links">Links</a>
            
        </li>
    
    </ul>


<h2 id="background">Background</h2>
<p>I have a thing for <a href="https://thejpster.org.uk/blog/blog-2024-11-22/">weird</a> <a href="https://thejpster.org.uk/blog/blog-2025-03-22/">90&#39;s</a> RISC workstations running UNIX. So when Rob said &#34;Hey, I have an AlphaStation in the boot of my car ...&#34; obviously it came home with me.</p>
<p>Unfortunately the AlphaStation is dead. The PSU runs (and stays running, unless the case are disconnected in which case it immediately stops running). The voltages look fine. But the two PCI cards in the machine (a 32-bit Matrox Millenium G200 graphics card and a 64-bit LSI Logic SCSI card) are both dead - neither is detected when inserted into my Pentium 3 PC. And half of the RAM in the first DIMM slot gets very hot. So, I suspect something catastrophic has happened somewhere in its lifetime. But, at least I got a 18GB 1.6&#34; SCSI Hard Drive out of it, and a working (ish) 12x SCSI CD-ROM.</p>
<p>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/162T5lqYqu4" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen="">
    </iframe>
</p>
<h2 id="the-alphastation-500">The AlphaStation 500</h2>
<p>This isn&#39;t a post about the AlphaStation 500. I&#39;ll save that for when (if) I get it working. This is a post about how an AlphaStation 500 boots. But here it is.</p>

<a href="https://thejpster.org.uk/blog/blog-2025-03-30/IMG_0471.JPEG">
  <img src="https://thejpster.org.uk/processed_images/IMG_0471.8380861c22633e97.jpg"/>
</a>
<p>The AlphaStation 500 is a workstation from Digital, circa 1996. Mine is a 500 MHz model and has an Alpha 21164A processor (aka EV56). And the way it boots is <em>weird</em>.</p>
<p>On your common-or-garden PC, there has always been some kind of ROM chip. It holds a piece of firmware known as the BIOS. This ROM chip is available at a well-known location in the processor&#39;s address space (remembering that any PC processor boots up in 16-bit, 8088 compatible mode, with a 1 MiB address space, just like an IBM PC 5150) and the processor just starts executing code in it after reset.</p>
<p>The Alpha (or at least this AlphaStation 500 - although I think they mostly worked like this) is different.</p>
<h2 id="srom">SROM</h2>
<p>There is a serial ROM (SROM) on the main board, and after reset, some logic internal to the CPU kicks in to generate a clock pulse. This drives an (external) counter, which provides consecutive addresses into the ROM. The 1-bit output of the ROM is sent into the processor, in sync with the clock pulse. The Alpha processor stores this data in its internal Instruction Cache. Once the code load is complete, the processor then executes the code, from its cache. The code is just enough to get the processor to configure its external memory bus, and find a memory-mapped parallel ROM, which it will then hand-over execution to.</p>
<p>But wait, how do you find a 1-bit wide ROM chip? Aren&#39;t most ROM chips at least 8 bits wide? Yes, they are.</p>
<h2 id="srom-image-selection">SROM Image selection</h2>
<p>The AlphaStation 500 mainboard has a series of eight jumper positions, and you are supposed to fit a jumper to exactly one of them. In fact, if you tried to fit more than one, the machine wouldn&#39;t boot.</p>
<p>The SROM chip actually contains eight images multiplexed together - each byte you load from the ROM contains one bit from each of eight images. The jumpers control which of the eight data bits on the ROM is actually connected to the serial input on the processor.</p>
<p>The SROM images on my machine are:</p>
<table><thead><tr><th>Jumper</th><th>Description</th></tr></thead><tbody>
<tr><td>J11</td><td>Power up</td></tr>
<tr><td>J12</td><td>Mini console</td></tr>
<tr><td>J13</td><td>Floppy loader</td></tr>
<tr><td>J14</td><td>Mem test</td></tr>
<tr><td>J15</td><td>N/A</td></tr>
<tr><td>J16</td><td>N/A</td></tr>
<tr><td>J17</td><td>MCHK Mini Console</td></tr>
<tr><td>J19</td><td>No init mini console</td></tr>
</tbody></table>
<p>So, given I apparently have RAM problems, I should <em>in theory</em> be able to move the jumper from J11 to J12, and see some kind of <a href="https://manx-docs.org/collections/mds-199909/cd1/alpha/amsmduga.pdf">&#39;Mini console&#39;</a> driven entirely by the processor running from internal I-Cache and its 32 internal registers, even with no RAM fitted.</p>
<p>But, I don&#39;t. Or at least, if there&#39;s a console, I can&#39;t find it. I read that it should be on the same pins that are used for loading the SROM into the chip, but I don&#39;t see any UART traffic there.</p>
<p>There is <em>some</em> SROM source code on The Internet, in a <a href="https://github.com/jramstedt/ebsdk">pack designed for manufacturers making Alpha-based computers</a> using the OEM AlphaPC mainboards that Digital used to sell. But I don&#39;t know if it is anything like what&#39;s on my AlphaStation.</p>
<p>Maybe there&#39;s a way to look at the SROM code and work out what it should be doing?</p>
<h2 id="splitting-the-srom">Splitting the SROM</h2>
<p>What is in my SROM chip? Well it&#39;s an Am27C010 in a PLCC socket, so I pulled it out, popped it into a TL866-II flash programmer and dumped it.</p>
<p>Download it <a href="https://thejpster.org.uk/blog/blog-2025-03-30/./am27c010_image_alphastation500.bin">here</a>.</p>
<p>Remember, this is eight streams multiplexed together, so we need to break them apart. This is non-trivial because, if each byte has one bit from the chosen image in it, is the first bit the most-significant bit in a byte, or the least significant bit in a byte?</p>
<p>Because I wasn&#39;t sure exactly how this worked, I hacked around in Python and I think I have it right.</p>
<pre data-lang="python"><code data-lang="python"><span>f = </span><span>open</span><span>(&#34;</span><span>am27c010_image_alphastation500.bin</span><span>&#34;, &#34;</span><span>rb</span><span>&#34;)
</span><span>contents = f.</span><span>read</span><span>()
</span><span>for </span><span>image </span><span>in </span><span>range</span><span>(</span><span>0</span><span>, </span><span>8</span><span>):
</span><span>    count = </span><span>0
</span><span>    acc = </span><span>0
</span><span>    data = []
</span><span>    </span><span>for </span><span>b </span><span>in </span><span>contents:
</span><span>        bit = (b &gt;&gt; image) &amp; </span><span>1
</span><span>        </span><span># Loading bits in from the top, so the first bit
</span><span>        </span><span># ends up as the LSB
</span><span>        acc &gt;&gt;= </span><span>1
</span><span>        acc |= (bit &lt;&lt; </span><span>7</span><span>)
</span><span>        count = count + </span><span>1
</span><span>        </span><span>if </span><span>count == </span><span>8</span><span>:
</span><span>            data.</span><span>append</span><span>(acc)
</span><span>            acc = </span><span>0
</span><span>            count = </span><span>0
</span><span>    o = </span><span>open</span><span>(</span><span>f</span><span>&#34;</span><span>srom_</span><span>{image}</span><span>.bin</span><span>&#34;, &#34;</span><span>wb</span><span>&#34;)
</span><span>    o.</span><span>truncate</span><span>()
</span><span>    o.</span><span>write</span><span>(</span><span>bytes</span><span>(data))
</span><span>    o.</span><span>close</span><span>()
</span></code></pre>
<p>But, now we have eight images and ... none of them contain any ASCII strings, and none of them look like Alpha machine code (as far as <code>alpha-linux-gnu-objdump</code> is concerned, anyway).</p>
<h2 id="decoding-the-images">Decoding the images</h2>
<p>So, I said the SROM data is loaded into I-Cache? Well, it&#39;s literally clocked into the cache lines, bit by bit. But not all the cache line is valid data! Some of the cache line bits are parity, and some are metadata recording which address the line is a cached copy of. It&#39;s complicated.</p>
<p>Digital actually put a tool in the Alpha PC SDK, called <a href="https://github.com/jramstedt/ebsdk/blob/main/ebtools/src/common/srom/srom.c"><code>srom.c</code></a>. This tool takes some Alpha machine code, and adds all the tag and parity information, giving you an SROM image you can load serially into the chip on start-up. It turns out that on the Alpha 21164 processor, each cache line is 200 bits long. So in this program, for every sixteen bytes (or, four 32-bit instructions) that go in, and 25 bytes (200 bits) come out.</p>
<p>So I just have to find which of the 16 bytes in every block of 25 bytes is the valid data, right?</p>
<p>No.</p>
<p>The cache line is <em>complicated</em> and it turns out the incoming 32-bit words are not stored sequentially. In fact, the <em>bits</em> don&#39;t even up next to each other - two words get bit-wise interleaved, for some reason. The <code>srom.c</code> tool has this handy table:</p>
<pre data-lang="c"><code data-lang="c"><span>int</span><span> dfillmap [</span><span>128</span><span>] = {                  </span><span>/* data 0:127 -- fillmap[0:127]*/
</span><span>    </span><span>42</span><span>,</span><span>44</span><span>,</span><span>46</span><span>,</span><span>48</span><span>,</span><span>50</span><span>,</span><span>52</span><span>,</span><span>54</span><span>,</span><span>56</span><span>,            </span><span>/* 0:7 */
</span><span>    </span><span>58</span><span>,</span><span>60</span><span>,</span><span>62</span><span>,</span><span>64</span><span>,</span><span>66</span><span>,</span><span>68</span><span>,</span><span>70</span><span>,</span><span>72</span><span>,            </span><span>/* 8:15 */
</span><span>    </span><span>74</span><span>,</span><span>76</span><span>,</span><span>78</span><span>,</span><span>80</span><span>,</span><span>82</span><span>,</span><span>84</span><span>,</span><span>86</span><span>,</span><span>88</span><span>,            </span><span>/* 16:23 */
</span><span>    </span><span>90</span><span>,</span><span>92</span><span>,</span><span>94</span><span>,</span><span>96</span><span>,</span><span>98</span><span>,</span><span>100</span><span>,</span><span>102</span><span>,</span><span>104</span><span>,         </span><span>/* 24:31 */
</span><span>    </span><span>43</span><span>,</span><span>45</span><span>,</span><span>47</span><span>,</span><span>49</span><span>,</span><span>51</span><span>,</span><span>53</span><span>,</span><span>55</span><span>,</span><span>57</span><span>,            </span><span>/* 32:39 */
</span><span>    </span><span>59</span><span>,</span><span>61</span><span>,</span><span>63</span><span>,</span><span>65</span><span>,</span><span>67</span><span>,</span><span>69</span><span>,</span><span>71</span><span>,</span><span>73</span><span>,            </span><span>/* 40:47 */
</span><span>    </span><span>75</span><span>,</span><span>77</span><span>,</span><span>79</span><span>,</span><span>81</span><span>,</span><span>83</span><span>,</span><span>85</span><span>,</span><span>87</span><span>,</span><span>89</span><span>,            </span><span>/* 48:55 */
</span><span>    </span><span>91</span><span>,</span><span>93</span><span>,</span><span>95</span><span>,</span><span>97</span><span>,</span><span>99</span><span>,</span><span>101</span><span>,</span><span>103</span><span>,</span><span>105</span><span>,         </span><span>/* 56:63 */
</span><span>    </span><span>128</span><span>,</span><span>130</span><span>,</span><span>132</span><span>,</span><span>134</span><span>,</span><span>136</span><span>,</span><span>138</span><span>,</span><span>140</span><span>,</span><span>142</span><span>,    </span><span>/* 64:71 */
</span><span>    </span><span>144</span><span>,</span><span>146</span><span>,</span><span>148</span><span>,</span><span>150</span><span>,</span><span>152</span><span>,</span><span>154</span><span>,</span><span>156</span><span>,</span><span>158</span><span>,    </span><span>/* 72:79 */
</span><span>    </span><span>160</span><span>,</span><span>162</span><span>,</span><span>164</span><span>,</span><span>166</span><span>,</span><span>168</span><span>,</span><span>170</span><span>,</span><span>172</span><span>,</span><span>174</span><span>,    </span><span>/* 80:87 */
</span><span>    </span><span>176</span><span>,</span><span>178</span><span>,</span><span>180</span><span>,</span><span>182</span><span>,</span><span>184</span><span>,</span><span>186</span><span>,</span><span>188</span><span>,</span><span>190</span><span>,    </span><span>/* 88:95 */
</span><span>    </span><span>129</span><span>,</span><span>131</span><span>,</span><span>133</span><span>,</span><span>135</span><span>,</span><span>137</span><span>,</span><span>139</span><span>,</span><span>141</span><span>,</span><span>143</span><span>,    </span><span>/* 96:103 */
</span><span>    </span><span>145</span><span>,</span><span>147</span><span>,</span><span>149</span><span>,</span><span>151</span><span>,</span><span>153</span><span>,</span><span>155</span><span>,</span><span>157</span><span>,</span><span>159</span><span>,    </span><span>/* 104:111 */
</span><span>    </span><span>161</span><span>,</span><span>163</span><span>,</span><span>165</span><span>,</span><span>167</span><span>,</span><span>169</span><span>,</span><span>171</span><span>,</span><span>173</span><span>,</span><span>175</span><span>,    </span><span>/* 112:119 */
</span><span>    </span><span>177</span><span>,</span><span>179</span><span>,</span><span>181</span><span>,</span><span>183</span><span>,</span><span>185</span><span>,</span><span>187</span><span>,</span><span>189</span><span>,</span><span>191     </span><span>/* 120:127 */
</span><span>};
</span></code></pre>
<p>The same table is included as <em>Appendix C: Serial Icache Load Predecode Values</em> in the <a href="https://www.cs.cmu.edu/afs/cs/academic/class/15740-f03/public/doc/alpha-21164-hw-ref-manual.pdf">Alpha 21164 Hardware Reference Manual</a>.</p>
<p>So ... what if I wrote a program to use that table to reverse the encoding, turning 25 byte cache lines back into four 32-bit instruction words. Would that work?</p>
<p>I used Rust this time.</p>
<pre data-lang="rust"><code data-lang="rust"><span>//! Alpha 21164 SROM decoder
</span><span>
</span><span>use </span><span>std::io::Write;
</span><span>
</span><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let mut</span><span> args = std::env::args_os();
</span><span>    </span><span>let </span><span>_ = args.</span><span>next</span><span>();
</span><span>    </span><span>let</span><span> infilename = args.</span><span>next</span><span>().</span><span>expect</span><span>(&#34;</span><span>Need input filename</span><span>&#34;);
</span><span>    </span><span>let</span><span> outfilename = args.</span><span>next</span><span>().</span><span>expect</span><span>(&#34;</span><span>Need output filename</span><span>&#34;);
</span><span>    println!(&#34;</span><span>Reading </span><span>{}</span><span>&#34;, infilename.</span><span>to_string_lossy</span><span>());
</span><span>    </span><span>let mut</span><span> data = std::fs::read(infilename).</span><span>expect</span><span>(&#34;</span><span>Failed to load file</span><span>&#34;);
</span><span>    println!(&#34;</span><span>Read </span><span>{}</span><span> bytes</span><span>&#34;, data.</span><span>len</span><span>());
</span><span>
</span><span>    </span><span>let mut</span><span> outfile = std::fs::File::create(outfilename).</span><span>expect</span><span>(&#34;</span><span>Can&#39;t open output file</span><span>&#34;);
</span><span>    outfile.</span><span>set_len</span><span>(</span><span>0</span><span>).</span><span>expect</span><span>(&#34;</span><span>Can&#39;t truncate file</span><span>&#34;);
</span><span>
</span><span>    </span><span>let</span><span> remainder = data.</span><span>len</span><span>() % </span><span>25</span><span>;
</span><span>    </span><span>if</span><span> remainder != </span><span>0 </span><span>{
</span><span>        eprintln!(&#34;</span><span>I want a multiple of 25 bytes for 21164 SROM</span><span>&#34;);
</span><span>    }
</span><span>
</span><span>    </span><span>let mut</span><span> lines = Vec::new();
</span><span>
</span><span>    </span><span>while</span><span> data.</span><span>len</span><span>() &gt;= </span><span>25 </span><span>{
</span><span>        </span><span>let</span><span> remainder = data.</span><span>split_off</span><span>(</span><span>25</span><span>);
</span><span>        </span><span>let mut</span><span> line = Vec::new();
</span><span>        </span><span>for</span><span> word_bytes in data.</span><span>chunks_exact</span><span>(</span><span>4</span><span>) {
</span><span>            </span><span>let</span><span> word_bytes: [</span><span>u8</span><span>; </span><span>4</span><span>] = word_bytes.</span><span>try_into</span><span>().</span><span>unwrap</span><span>();
</span><span>            </span><span>let</span><span> word: </span><span>u32 </span><span>= </span><span>u32</span><span>::from_le_bytes(word_bytes);
</span><span>            line.</span><span>push</span><span>(word);
</span><span>        }
</span><span>        data = remainder;
</span><span>        lines.</span><span>push</span><span>(line);
</span><span>    }
</span><span>
</span><span>    </span><span>for</span><span> line in lines {
</span><span>        </span><span>for</span><span> word in line.</span><span>iter</span><span>() {
</span><span>            print!(&#34;</span><span>0x</span><span>{:08x} </span><span>&#34;, word);
</span><span>        }
</span><span>        print!(&#34;</span><span> -- </span><span>&#34;);
</span><span>        </span><span>let</span><span> decoded = </span><span>process_line</span><span>(&amp;line);
</span><span>        </span><span>for</span><span> word in decoded.</span><span>iter</span><span>() {
</span><span>            print!(&#34;</span><span>0x</span><span>{:08x} </span><span>&#34;, word);
</span><span>            outfile.</span><span>write_all</span><span>(&amp;word.</span><span>to_le_bytes</span><span>()).</span><span>expect</span><span>(&#34;</span><span>Writing to output</span><span>&#34;);
</span><span>        }
</span><span>        println!();
</span><span>
</span><span>    }
</span><span>}
</span><span>
</span><span>static </span><span>DFILLMAP</span><span>: [</span><span>usize</span><span>; </span><span>128</span><span>] = [
</span><span>    </span><span>/* data 0:127 -- fillmap[0:127]*/
</span><span>    </span><span>42</span><span>,  </span><span>44</span><span>,  </span><span>46</span><span>,  </span><span>48</span><span>,  </span><span>50</span><span>,  </span><span>52</span><span>,  </span><span>54</span><span>,  </span><span>56</span><span>,  </span><span>/* 0:7 */
</span><span>    </span><span>58</span><span>,  </span><span>60</span><span>,  </span><span>62</span><span>,  </span><span>64</span><span>,  </span><span>66</span><span>,  </span><span>68</span><span>,  </span><span>70</span><span>,  </span><span>72</span><span>,  </span><span>/* 8:15 */
</span><span>    </span><span>74</span><span>,  </span><span>76</span><span>,  </span><span>78</span><span>,  </span><span>80</span><span>,  </span><span>82</span><span>,  </span><span>84</span><span>,  </span><span>86</span><span>,  </span><span>88</span><span>,  </span><span>/* 16:23 */
</span><span>    </span><span>90</span><span>,  </span><span>92</span><span>,  </span><span>94</span><span>,  </span><span>96</span><span>,  </span><span>98</span><span>,  </span><span>100</span><span>, </span><span>102</span><span>, </span><span>104</span><span>, </span><span>/* 24:31 */
</span><span>    </span><span>43</span><span>,  </span><span>45</span><span>,  </span><span>47</span><span>,  </span><span>49</span><span>,  </span><span>51</span><span>,  </span><span>53</span><span>,  </span><span>55</span><span>,  </span><span>57</span><span>,  </span><span>/* 32:39 */
</span><span>    </span><span>59</span><span>,  </span><span>61</span><span>,  </span><span>63</span><span>,  </span><span>65</span><span>,  </span><span>67</span><span>,  </span><span>69</span><span>,  </span><span>71</span><span>,  </span><span>73</span><span>,  </span><span>/* 40:47 */
</span><span>    </span><span>75</span><span>,  </span><span>77</span><span>,  </span><span>79</span><span>,  </span><span>81</span><span>,  </span><span>83</span><span>,  </span><span>85</span><span>,  </span><span>87</span><span>,  </span><span>89</span><span>,  </span><span>/* 48:55 */
</span><span>    </span><span>91</span><span>,  </span><span>93</span><span>,  </span><span>95</span><span>,  </span><span>97</span><span>,  </span><span>99</span><span>,  </span><span>101</span><span>, </span><span>103</span><span>, </span><span>105</span><span>, </span><span>/* 56:63 */
</span><span>    </span><span>128</span><span>, </span><span>130</span><span>, </span><span>132</span><span>, </span><span>134</span><span>, </span><span>136</span><span>, </span><span>138</span><span>, </span><span>140</span><span>, </span><span>142</span><span>, </span><span>/* 64:71 */
</span><span>    </span><span>144</span><span>, </span><span>146</span><span>, </span><span>148</span><span>, </span><span>150</span><span>, </span><span>152</span><span>, </span><span>154</span><span>, </span><span>156</span><span>, </span><span>158</span><span>, </span><span>/* 72:79 */
</span><span>    </span><span>160</span><span>, </span><span>162</span><span>, </span><span>164</span><span>, </span><span>166</span><span>, </span><span>168</span><span>, </span><span>170</span><span>, </span><span>172</span><span>, </span><span>174</span><span>, </span><span>/* 80:87 */
</span><span>    </span><span>176</span><span>, </span><span>178</span><span>, </span><span>180</span><span>, </span><span>182</span><span>, </span><span>184</span><span>, </span><span>186</span><span>, </span><span>188</span><span>, </span><span>190</span><span>, </span><span>/* 88:95 */
</span><span>    </span><span>129</span><span>, </span><span>131</span><span>, </span><span>133</span><span>, </span><span>135</span><span>, </span><span>137</span><span>, </span><span>139</span><span>, </span><span>141</span><span>, </span><span>143</span><span>, </span><span>/* 96:103 */
</span><span>    </span><span>145</span><span>, </span><span>147</span><span>, </span><span>149</span><span>, </span><span>151</span><span>, </span><span>153</span><span>, </span><span>155</span><span>, </span><span>157</span><span>, </span><span>159</span><span>, </span><span>/* 104:111 */
</span><span>    </span><span>161</span><span>, </span><span>163</span><span>, </span><span>165</span><span>, </span><span>167</span><span>, </span><span>169</span><span>, </span><span>171</span><span>, </span><span>173</span><span>, </span><span>175</span><span>, </span><span>/* 112:119 */
</span><span>    </span><span>177</span><span>, </span><span>179</span><span>, </span><span>181</span><span>, </span><span>183</span><span>, </span><span>185</span><span>, </span><span>187</span><span>, </span><span>189</span><span>, </span><span>191  </span><span>/* 120:127 */
</span><span>];
</span><span>
</span><span>fn </span><span>process_line</span><span>(</span><span>line</span><span>: &amp;[</span><span>u32</span><span>]) -&gt; [</span><span>u32</span><span>; </span><span>4</span><span>] {
</span><span>    </span><span>if</span><span> line.</span><span>len</span><span>() != </span><span>6 </span><span>{
</span><span>        panic!(&#34;</span><span>Only want 6 words per line</span><span>&#34;);
</span><span>    }
</span><span>    </span><span>let mut</span><span> output = [</span><span>0</span><span>u32</span><span>; </span><span>4</span><span>];
</span><span>    </span><span>for </span><span>(out_idx, &amp;in_idx) in </span><span>DFILLMAP</span><span>.</span><span>iter</span><span>().</span><span>enumerate</span><span>() {
</span><span>        </span><span>let</span><span> in_word = in_idx &gt;&gt; </span><span>5</span><span>;
</span><span>        </span><span>let</span><span> in_offset = in_idx &amp; </span><span>0x1F</span><span>;
</span><span>        </span><span>let</span><span> bit = (line[in_word] &gt;&gt; in_offset) &amp; </span><span>1</span><span>;
</span><span>        </span><span>if</span><span> bit != </span><span>0 </span><span>{
</span><span>            </span><span>let</span><span> out_word = out_idx &gt;&gt; </span><span>5</span><span>;
</span><span>            </span><span>let</span><span> out_offset = out_idx &amp; </span><span>0x1F</span><span>;
</span><span>            output[out_word] |= </span><span>1 </span><span>&lt;&lt; out_offset;
</span><span>        }
</span><span>    }
</span><span>    output
</span><span>}
</span></code></pre>
<p>It turns out the final byte of the 25 is of no use to us, so I load the file 25 bytes at a time, turn it into six 32-bit words, and process it to produce four 32-bit instructions.</p>
<p>Again, this took some trial and error. I had no idea whether the contents of my SROM chip were valid, or what they should look like. So I used the <code>srom.c</code> program to encode some random data, and then I used my program to decode it back again, and I verified that the input file and the output files matched. This took some trial and error, but I got something that was at least round-tripping my random example files correctly.</p>
<h2 id="dissasmbling-the-decoded-images">Dissasmbling the decoded images</h2>
<p>Well, let&#39;s just throw one of these files at <code>objdump</code> and see what happens.</p>
<pre data-lang="console"><code data-lang="console"><span>$ alpha-linux-gnu-objdump -b binary -m alpha -D /mnt/c/Users/msn/OneDrive/Shared/computers/digital/srom_0.decoded  | head -n 40
</span><span>
</span><span>/mnt/c/Users/msn/OneDrive/Shared/computers/digital/srom_0.decoded:     file format binary
</span><span>
</span><span>
</span><span>Disassembly of section .data:
</span><span>
</span><span>0000000000000000 &lt;.data&gt;:
</span><span>       0:        0f 01 ff 77    pal1d   0x3ff010f
</span><span>       4:        56 01 ff 77    pal1d   0x3ff0156
</span><span>       8:        57 01 ff 77    pal1d   0x3ff0157
</span><span>       c:        39 00 40 d3    bsr     ra,0xf4
</span><span>      10:        47 00 40 d3    bsr     ra,0x130
</span><span>      14:        2e 01 40 d3    bsr     ra,0x4d0
</span><span>      18:        56 01 21 64    pal19   0x210156
</span><span>...
</span></code></pre>
<p>OK, er ... is that right? Is that valid Alpha machine code? I think so!</p>
<p>Reading the <a href="https://www.cs.cmu.edu/afs/cs/academic/class/15740-f03/public/doc/alpha-21164-hw-ref-manual.pdf">Alpha 21164 Hardware Reference Manual</a> some more, I see that <code>pal1d</code> is a generic mnemonic for the Alpha 21164 specific instruction <code>HW_MTPR</code>. That is the instruction that store a value from a CPU register <em>to</em> an <em>Internal Processor Register</em>. The <code>pal19</code> instruction, on an Alpha 21164, is <code>HW_MFPR</code>, which means to load a value into a CPU register <em>from</em> an <em>Internal Processor Register</em>. Basically, I think these <em>IPRs</em> are like CP15 system registers on an Arm processor. And, one of them is called <code>SL_XMIT</code>, which sounds like something that does serial transmit - exactly what I would expect an SROM Mini Console to do.</p>
<p>But, <code>objdump</code> doesn&#39;t seem to know about these 21164 specifics, so I need to write a tool which takes an assembly file and re-writes the <code>pal1d</code> and <code>pal19</code> assembly language into something that helps us understand what&#39;s going on. I&#39;ll just jam the <code>alpha-linux-gnu-objdump</code> call into the SROM decoder above, and post-process the output.</p>
<p>I&#39;m also going to <a href="https://devblogs.microsoft.com/oldnewthing/20170807-00/?p=96766">read some Raymond Chen</a> to try and get a handle on this Alpha assembly code.</p>
<p>OK, here is that machine code again, but with some auto-generated annotations:</p>
<pre data-lang="text"><code data-lang="text"><span>0000000000000000 &lt;.data&gt;:
</span><span>       0:        0f 01 ff 77    pal1d   0x3ff010f ; HW_MTPR: write zero to ICM
</span><span>       4:        56 01 ff 77    pal1d   0x3ff0156 ; HW_MTPR: write zero to PALtemp22
</span><span>       8:        57 01 ff 77    pal1d   0x3ff0157 ; HW_MTPR: write zero to PALtemp23
</span><span>       c:        39 00 40 d3    bsr     ra,0xf4
</span><span>      10:        47 00 40 d3    bsr     ra,0x130
</span><span>      14:        2e 01 40 d3    bsr     ra,0x4d0
</span><span>      18:        56 01 21 64    pal19   0x210156 ; HW_MFPR: read PALtemp22 to t0
</span></code></pre>
<p>Right, but what about the serial stuff? Well I see an IPR called <code>SL_XMIT</code> which is for transmitting one bit of data, and another called <code>SL_RCV</code> for receiving. It seems the CPU basically has to bit-bash a UART using one output pin and one input pin and some delays to ensure the UART is running at the correct baud rate.</p>
<p>After some poking around, I found what looks like a <code>get_char</code> function, which I have tried to annotate (although I don&#39;t fully understand it):</p>
<pre data-lang="text"><code data-lang="text"><span>get_char:
</span><span>    191c:      05 14 e1 47      mov     0x8,t4 ; we want eight bits
</span><span>    1920:      04 04 ff 47      clr     t3
</span><span>    1924:      03 04 ff 47      clr     t2
</span><span>char_start:
</span><span>    1928:      17 01 42 64      pal19   0x420117   ; HW_MFPR: read SL_RCV to t1
</span><span>    192c:      fe ff 5f f4      bne     t1,0x1928 
</span><span>    1930:      27 00 60 d3      bsr     t12,0x19d0 ; wait for half bit time
</span><span>get_bit:
</span><span>    1934:      28 00 60 d3      bsr     t12,0x19d8 ; wait for bit time
</span><span>    1938:      17 01 42 64      pal19   0x420117   ; HW_MFPR: read SL_RCV to t1
</span><span>    193c:      82 d6 40 48      srl     t1,0x6,t1  ; put bit in t1&lt;0&gt;
</span><span>    1940:      22 07 44 48      sll     t1,t3,t1   ; move bit into correct position for byte
</span><span>    1944:      03 04 43 44      or      t1,t2,t2   ; OR bit into data byte in t2
</span><span>    1948:      04 34 80 40      addq    t3,0x1,t3  ; increment bit index
</span><span>    194c:      25 35 a0 40      subq    t4,0x1,t4  ; decrement loop count
</span><span>    1950:      f8 ff bf f4      bne     t4,0x1934  ; goto get_bit
</span><span>    1954:      20 00 60 d3      bsr     t12,0x19d8 ; wait for bit time
</span><span>    1958:      17 01 42 64      pal19   0x420117   ; HW_MFPR: read SL_RCV to t1
</span><span>    195c:      00 04 7f 44      or      t2,zero,v0 ; copy received byte to v0
</span><span>    1960:      02 10 10 45      and     t7,0x80,t1 ; 
</span><span>    1964:      07 00 40 e4      beq     t1,0x1984  ; goto clr_int_and_exit
</span><span>    1968:      02 18 0b 44      xor     v0,0x58,t1 ; Is it ASCII &#39;X&#39;?
</span><span>    196c:      05 00 40 f4      bne     t1,0x1984  ; goto clr_int_and_exit
</span><span>    1970:      56 01 42 64      pal19   0x420156   ; HW_MFPR: read PALtemp22 to t1
</span><span>    1974:      02 f6 41 48      zap     t1,0xf,t1  ; zero bottom four bytes of t1
</span><span>    1978:      08 11 10 45      andnot  t7,0x80,t7 ; ?
</span><span>    197c:      02 04 02 45      or      t7,t1,t1   ; ?
</span><span>    1980:      56 01 42 74      pal1d   0x420156   ; HW_MTPR: write t1 to PALtemp22
</span><span>clr_int_and_exit:
</span><span>    1984:      01 00 5f 20      lda     t1,1       ; clear interrupt 33
</span><span>    1988:      22 37 44 48      sll     t1,0x21,t1
</span><span>    198c:      15 01 42 74      pal1d   0x420115   ; HW_MTPR: write t1 to HWINT_CLR
</span><span>    1990:      01 80 fe 6b      ret     zero,(sp),0x1
</span></code></pre>
<p>So yeah, definitely looks like my SROM is valid, and it can receive stuff over a serial port by waiting for the start bit, then counting out the bit periods one by one.</p>
<h2 id="conclusions">Conclusions</h2>
<p>Going back to <a href="https://www.cs.cmu.edu/afs/cs/academic/class/15740-f03/public/doc/alpha-21164-hw-ref-manual.pdf">Alpha 21164 Hardware Reference Manual</a>, I now see the vital piece of information that was there all along if I&#39;d read the document carefully enough:
slonh</p>
<blockquote>
<p>The SROM load occurs at the internal cycle time of approximately 126 CPU cycles for <code>srom_clk_h</code>
...
<code>srom_data_h/Rx</code> - Receives SROM or serial terminal data
<code>srom_clk_h/Tx</code> - Supplies clock to SROMs or transmits serial terminal data</p>
</blockquote>
<p>So I should try and inject TTL UART signals on the same pin that carries the SROM data on start-up, and I should look for TTL UART output on the pin that carries the SROM data clock signal (and with a 500 MHz CPU I should expect a 4 MHz clock signal, and thus need to sample at at least 16 MHz, and ideally 24 MHz).</p>
<p>OK, what have we learned?</p>
<ul>
<li>Alpha CPUs boot from a Serial ROM (the SROM)</li>
<li>That SROM contains eight images packed together</li>
<li>Each image is encoded ready to be streamed directly into the I-Cache of the Alpha CPU</li>
<li>We can reverse that encoding and get the raw images back</li>
<li>Alpha CPUs have special <em>Internal Processor Registers</em> which let them do things like control a couple of GPIO pins (and much more)</li>
<li>The images in my SROM flash chip seem fine, indicating that the chip isn&#39;t corrupted</li>
<li>Sometimes you need to go on a long journey only to end up back where you started, but the knowledge you gained on the way lets you see a better route to take next time</li>
<li>We still don&#39;t know why my Alpha doesn&#39;t boot</li>
</ul>
<h2 id="links">Links</h2>
<ul>
<li>Github with the source code of the tools I wrote: <a href="https://github.com/thejpster/alpha-srom">https://github.com/thejpster/alpha-srom</a></li>
<li>Alpha Motherboard Software Developers Kit V4.0: <a href="https://github.com/jramstedt/ebsdk">https://github.com/jramstedt/ebsdk</a></li>
</ul>




      
      
      

    </div></div>
  </body>
</html>
