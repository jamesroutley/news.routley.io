<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simonwillison.net/2025/Oct/7/vibe-engineering/">Original</a>
    <h1>Vibe engineering</h1>
    
    <div id="readability-page-1" class="page"><div>


<div data-permalink-context="/2025/Oct/7/vibe-engineering/">

<p>7th October 2025</p>



<p>I feel like <strong>vibe coding</strong> is <a href="https://simonwillison.net/2025/Mar/19/vibe-coding/">pretty well established now</a> as covering the fast, loose and irresponsible way of building software with AI—entirely prompt-driven, and with no attention paid to how the code actually works. This leaves us with a terminology gap: what should we call the other end of the spectrum, where seasoned professionals accelerate their work with LLMs while staying proudly and confidently accountable for the software they produce?</p>
<p>I propose we call this <strong>vibe engineering</strong>, with my tongue only partially in my cheek.</p>
<p>One of the lesser spoken truths of working productively with LLMs as a software engineer on non-toy-projects is that it’s <em>difficult</em>. There’s a lot of depth to understanding how to use the tools, there are plenty of traps to avoid, and the pace at which they can churn out working code raises the bar for what the human participant can and should be contributing.</p>
<p>The rise of <strong>coding agents</strong>—tools like <a href="https://www.claude.com/product/claude-code">Claude Code</a> (released February 2025), OpenAI’s <a href="https://github.com/openai/codex">Codex CLI</a> (April) and <a href="https://github.com/google-gemini/gemini-cli">Gemini CLI</a> (June) that can iterate on code, actively testing and modifying it until it achieves a specified goal, has dramatically increased the usefulness of LLMs for real-world coding problems.</p>
<p>I’m increasingly hearing from experienced, credible software engineers who are running multiple copies of agents at once, tackling several problems in parallel and expanding the scope of what they can take on. I was skeptical of this at first but <a href="https://simonwillison.net/2025/Oct/5/parallel-coding-agents/">I’ve started running multiple agents myself now</a> and it’s surprisingly effective, if mentally exhausting!</p>
<p>This feels very different from classic vibe coding, where I outsource a simple, low-stakes task to an LLM and accept the result if it appears to work. Most of my <a href="https://simonwillison.net/">tools.simonwillison.net</a> collection (<a href="https://simonwillison.net/2025/Sep/4/highlighted-tools/">previously</a>) were built like that. Iterating with coding agents to produce production-quality code that I’m confident I can maintain in the future feels like a different process entirely.</p>
<p>It’s also become clear to me that LLMs actively reward existing top tier software engineering practices:</p>
<ul id="techniques">
<li>
<strong>Automated testing</strong>. If your project has a robust, comprehensive and stable test suite agentic coding tools can <em>fly</em> with it. Without tests? Your agent might claim something works without having actually tested it at all, plus any new change could break an unrelated feature without you realizing it. Test-first development is particularly effective with agents that can iterate in a loop.</li>
<li>
<strong>Planning in advance</strong>. Sitting down to hack something together goes much better if you start with a high level plan. Working with an agent makes this even more important—you can iterate on the plan first, then hand it off to the agent to write the code.</li>
<li>
<strong>Comprehensive documentation</strong>. Just like human programmers, an LLM can only keep a subset of the codebase in its context at once. Being able to feed in relevant documentation lets it use APIs from other areas without reading the code first. Write good documentation first and the model may be able to build the matching implementation from that input alone.</li>
<li>
<strong>Good version control habits</strong>. Being able to undo mistakes and understand when and how something was changed is even more important when a coding agent might have made the changes. LLMs are also fiercely competent at Git—they can navigate the history themselves to track down the origin of bugs, and they’re better than most developers at using <a href="https://til.simonwillison.net/git/git-bisect">git bisect</a>. Use that to your advantage.</li>
<li>Having <strong>effective automation</strong> in place. Continuous integration, automated formatting and linting, continuous deployment to a preview environment—all things that agentic coding tools can benefit from too. LLMs make writing quick automation scripts easier as well, which can help them then repeat tasks accurately and consistently next time.</li>
<li>A <strong>culture of code review</strong>. This one explains itself. If you’re fast and productive at code review you’re going to have a much better time working with LLMs than if you’d rather write code yourself than review the same thing written by someone (or something) else.</li>
<li>A <strong>very weird form of management</strong>. Getting good results out of a coding agent feels uncomfortably close to getting good results out of a human collaborator. You need to provide clear instructions, ensure they have the necessary context and provide actionable feedback on what they produce. It’s a <em>lot</em> easier than working with actual people because you don’t have to worry about offending or discouraging them—but any existing management experience you have will prove surprisingly useful.</li>
<li>Really good <strong>manual QA (quality assurance)</strong>. Beyond automated tests, you need to be really good at manually testing software, including predicting and digging into edge-cases.</li>
<li>Strong <strong>research skills</strong>. There are dozens of ways to solve any given coding problem. Figuring out the best options and proving an approach has always been important, and remains a blocker on unleashing an agent to write the actual code.</li>
<li>The ability to <strong>ship to a preview environment</strong>. If an agent builds a feature, having a way to safely preview that feature (without deploying it straight to production) makes reviews much more productive and greatly reduces the risk of shipping something broken.</li>
<li>An instinct for <strong>what can be outsourced</strong> to AI and what you need to manually handle yourself. This is constantly evolving as the models and tools become more effective. A big part of working effectively with LLMs is maintaining a strong intuition for when they can best be applied.</li>
<li>An updated <strong>sense of estimation</strong>. Estimating how long a project will take has always been one of the hardest but most important parts of being a senior engineer, especially in organizations where budget and strategy decisions are made based on those estimates. AI-assisted coding makes this <em>even harder</em>—things that used to take a long time are much faster, but estimations now depend on new factors which we’re all still trying to figure out.</li>
</ul>
<p>If you’re going to really exploit the capabilities of these new tools, you need to be operating <em>at the top of your game</em>. You’re not just responsible for writing the code—you’re researching approaches, deciding on high-level architecture, writing specifications, defining success criteria, <a href="https://simonwillison.net/2025/Sep/30/designing-agentic-loops/">designing agentic loops</a>, planning QA, managing a growing army of weird digital interns who will absolutely cheat if you give them a chance, and spending <em>so much time on code review</em>.</p>
<p>Almost all of these are characteristics of senior software engineers already!</p>
<p>AI tools <strong>amplify existing expertise</strong>. The more skills and experience you have as a software engineer the faster and better the results you can get from working with LLMs and coding agents.</p>
<h4 id="-vibe-engineering-really-">“Vibe engineering”, really?</h4>
<p>Is this a stupid name? Yeah, probably. “Vibes” as a concept in AI feels a little tired at this point. “Vibe coding” itself is used by a lot of developers in a dismissive way. I’m ready to reclaim vibes for something more constructive.</p>
<p>I’ve never really liked the artificial distinction between “coders” and “engineers”—that’s always smelled to me a bit like gatekeeping. But in this case a bit of gatekeeping is exactly what we need!</p>
<p><strong>Vibe engineering</strong> establishes a clear distinction from vibe coding. It signals that this is a different, harder and more sophisticated way of working with AI tools to build production software.</p>
<p>I like that this is cheeky and likely to be controversial. This whole space is still absurd in all sorts of different ways. We shouldn’t take ourselves too seriously while we figure out the most productive ways to apply these new tools.</p>
<p>I’ve tried in the past to get terms like <strong><a href="https://simonwillison.net/tags/ai-assisted-programming/">AI-assisted programming</a></strong> to stick, with approximately zero success. May as well try rubbing some vibes on it and see what happens.</p>
<p>I also really like the clear mismatch between “vibes” and “engineering”. It makes the combined term self-contradictory in a way that I find mischievous and (hopefully) sticky.</p>


</div>



</div></div>
  </body>
</html>
