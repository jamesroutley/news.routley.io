<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stevelosh.com/blog/2022/08/depending-in-common-lisp/">Original</a>
    <h1>Depending in Common Lisp</h1>
    
    <div id="readability-page-1" class="page"><div id="page-blog-entry"><article><p>Posted on August 26th, 2022.</p><p>A while ago I was working on a Common Lisp library that makes use of the
<a href="http://metamodular.com/CLOS-MOP/">Metaobject Protocol</a>.  I ran into a few edge
cases around dependencies between classes and it took a while for me to figure
out how to solve them, so I wanted to write down what I learned in case anyone
else might find it useful.  This post is an expanded version of <a href="https://www.reddit.com/r/Common_Lisp/comments/kljyg1/need_advice_on_how_to_handle_metaclass_option/">a Reddit
thread</a> I posted.</p>

<ol><li><a href="#s1-setting-the-stage">Setting the Stage</a><ol><li><a href="#s2-adding-more-flexibility">Adding More Flexibility</a></li><li><a href="#s3-toy-example-disclaimer">Toy Example Disclaimer</a></li></ol></li><li><a href="#s4-the-problem">The Problem</a></li><li><a href="#s5-the-dependent-maintenance-protocol">The Dependent Maintenance Protocol</a><ol><li><a href="#s6-dependency-wrappers">Dependency Wrappers</a></li><li><a href="#s7-defining-the-metaclass">Defining the Metaclass</a></li><li><a href="#s8-computing-slots">Computing Slots</a></li><li><a href="#s9-initialization">Initialization</a></li><li><a href="#s10-reinitialization">Reinitialization</a></li><li><a href="#s11-dependent-updates">Dependent Updates</a></li></ol></li><li><a href="#s12-the-result">The Result</a></li><li><a href="#s13-is-it-worth-it">Is It Worth It?</a></li></ol>

<h2 id="s1-setting-the-stage"><a href="#s1-setting-the-stage">Setting the Stage</a></h2>

<p>Before we can see the problem, we need a simple example.  We&#39;ll use the
<code>monitored-class</code> metaclass from <a href="https://en.wikipedia.org/wiki/The_Art_of_the_Metaobject_Protocol">The Art of the Metaobject Protocol</a>
(pages 96-97). Using this class as a metaclass will log all slot reads and
writes, which could be useful for auditing access to certain objects.</p>

<p>Before we get started we&#39;ll need <a href="https://github.com/pcostanza/closer-mop">Closer to MOP</a> as an
implementation compatibility layer:</p>

<pre><code><span><span>(<span>ql:quickload <span>:closer-mop</span></span>)</span></span></code></pre>

<p>First we define the metaclass:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> monitored-class <span>(<span>standard-class</span>)</span>
  <span>(<span></span>)</span></span>)</span></span></code></pre>

<p>Next we&#39;ll explicitly say that it&#39;s okay for a monitored class to have
superclasses that are standard classes:</p>

<pre><code><span><span>(<span><i><span>defmethod</span></i> c2mop:validate-superclass
    <span>(<span><span>(<span>class monitored-class</span>)</span> <span>(<span>superclass standard-class</span>)</span></span>)</span>
  t</span>)</span></span></code></pre>

<p>And now we can define the actual monitoring functionality.  We&#39;ll use <code>:before</code>
methods on <code>slot-value-using-class</code> and its <code>setf</code> version to log the reads and
writes of all slots:</p>

<pre><code><span><span>(<span><i><span>defmethod</span></i> c2mop:slot-value-using-class <span>:before</span>
    <span>(<span><span>(<span>class monitored-class</span>)</span> instance slot</span>)</span>
  <span>(<span>format t <span>&#34;Reading slot ~A of ~A at ~A.~%&#34;</span>
          <span>(<span>c2mop:slot-definition-name slot</span>)</span> instance <span>(<span>get-universal-time</span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defmethod</span></i> <span>(<span>setf c2mop:slot-value-using-class</span>)</span> <span>:before</span>
    <span>(<span>new-value <span>(<span>class monitored-class</span>)</span> instance slot</span>)</span>
  <span>(<span>format t <span>&#34;Setting slot ~A of ~A to ~S at ~A.~%&#34;</span>
          <span>(<span>c2mop:slot-definition-name slot</span>)</span> instance new-value <span>(<span>get-universal-time</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>With that complete, we can define a new monitored class:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> user <span>(<span></span>)</span>
  <span>(<span><span>(<span>id   <span>:initarg</span> <span>:id</span></span>)</span>
   <span>(<span>name <span>:initarg</span> <span>:name</span></span>)</span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span></span>)</span></span></code></pre>

<p>And now we can see it in action:</p>

<pre><code><span><span>(<span><i><span>defparameter</span></i> <span>*u*</span> <span>(<span>make-instance &#39;user <span>:id</span> 1 <span>:name</span> <span>&#34;sjl&#34;</span></span>)</span></span>)</span>

<span>(<span>slot-value <span>*u*</span> &#39;id</span>)</span>

<span>(<span>setf <span>(<span>slot-value <span>*u*</span> &#39;name</span>)</span> <span>&#34;Steve&#34;</span></span>)</span>
</span></code></pre>

<h3 id="s2-adding-more-flexibility"><a href="#s2-adding-more-flexibility">Adding More Flexibility</a></h3>

<p>Now that we have a toy example working, let&#39;s make it a little more flexible.
Instead of always generating a string and writing it to standard out, we&#39;ll
allow users to provide a <code>:monitoring-function</code> as a class option that will
receive the data and can do whatever it wants.  For example:</p>

<ul>
<li>Logging to syslog instead of standard out.</li>
<li>Inserting a row into a Postgres database as an audit log.</li>
<li>Tracking read/write counts in a hash table to find slots that are written more
  often than they&#39;re read and vice versa.</li>
</ul>

<p>A monitoring function will receive 2 arguments (the instance and slot name),
plus an optional third argument when a slot is written (the new value).  We can
make a default monitoring function that works the same way as before:</p>

<pre><code><span><span>(<span><i><span>defun</span></i> log-slot-access <span>(<span>instance slot-name &amp;optional <span>(<span>new-value nil new-value?</span>)</span></span>)</span>
  <span>(<span><i><span>if</span></i> new-value?
    <span>(<span>format t <span>&#34;Setting slot ~A of ~A to ~S at ~A.~%&#34;</span>
              slot-name instance new-value <span>(<span>get-universal-time</span>)</span></span>)</span>
    <span>(<span>format t <span>&#34;Reading slot ~A of ~A at ~A.~%&#34;</span>
              slot-name instance <span>(<span>get-universal-time</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>Note the use of the extended <code>&amp;optional</code> form with the
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_dab.htm"><code>supplied-p-parameter</code></a> used to check whether a value was given,
which ensures this works correctly even when setting a slot to <code>nil</code>.</p>

<p>Also note how we called it <code>new-value?</code> and not <code>new-value-p</code> as you&#39;ll
sometimes see people do.  The <code>-p</code> in <code>new-value-p</code> stands for &#34;predicate&#34;, and
a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_p.htm#predicate">predicate</a> is a <em>function</em> that returns a (generalized) boolean,
<em>not</em> a boolean itself.  Using a name that ends in <code>-p</code> for a boolean value
(rather than for a predicate) is a <code>-p</code>et <code>-p</code>eeve of mine.  Unfortunately it
happens in a couple of places (even in Common Lisp itself), so it&#39;s something to
watch out for.</p>

<p>Now we can update our <code>monitored-class</code> to add a slot to store the monitoring
function for each class, and update the <code>slot-value-using-class</code> methods to use
that instead of writing the string themselves:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> monitored-class <span>(<span>standard-class</span>)</span>
  <span>(<span><span>(<span>monitoring-function <span>:initarg</span> <span>:monitoring-function</span>
                        <span>:accessor</span> monitoring-function</span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defmethod</span></i> c2mop:slot-value-using-class <span>:before</span>
    <span>(<span><span>(<span>class monitored-class</span>)</span> instance slot</span>)</span>
  <span>(<span>funcall <span>(<span>monitoring-function class</span>)</span>
           instance
           <span>(<span>c2mop:slot-definition-name slot</span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defmethod</span></i> <span>(<span>setf c2mop:slot-value-using-class</span>)</span> <span>:before</span>
    <span>(<span>new-value <span>(<span>class monitored-class</span>)</span> instance slot</span>)</span>
  <span>(<span>funcall <span>(<span>monitoring-function class</span>)</span>
           instance
           <span>(<span>c2mop:slot-definition-name slot</span>)</span>
           new-value</span>)</span></span>)</span></span></code></pre>

<p>When a user creates a new <code>monitored-class</code>, we need to set the
<code>monitoring-function</code> slot appropriately.  We might initially consider doing
this by having an <code>initform</code> for the <code>monitoring-function</code> slot in the
metaclass, like this:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> monitored-class <span>(<span>standard-class</span>)</span>
  <span>(<span><span>(<span>monitoring-function <span>:initarg</span> <span>:monitoring-function</span>
                        <span>:accessor</span> monitoring-function
                        <span>:initform</span> #&#39;log-slot-access</span>)</span></span>)</span></span>)</span> </span></code></pre>

<p>But this won&#39;t work for a number of reasons we&#39;ll see shortly.  Instead we&#39;ll
need to handle the initialization ourselves.  We&#39;ll do it in <code>shared-initialize</code>
so it will happen both when a class is first created and when it&#39;s reinitialized
(e.g. after it&#39;s redefined):</p>

<pre><code><span><span>(<span><i><span>defun</span></i> parse-monitoring-function-class-option <span>(<span>arguments</span>)</span>
  <span>(<span>case <span>(<span>length arguments</span>)</span>
    <span>(<span>1 <span>(<span>eval <span>(<span>first arguments</span>)</span></span>)</span></span>)</span>
    <span>(<span>0 #&#39;log-slot-access</span>)</span>
    <span>(<span>t <span>(<span>error <span>&#34;Malformed monitoring-function option.&#34;</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defmethod</span></i> shared-initialize <span>:around</span>
    <span>(<span><span>(<span>class monitored-class</span>)</span> slot-names
     &amp;rest initargs
     &amp;key monitoring-function &amp;allow-other-keys</span>)</span>
  <span>(<span>apply #&#39;call-next-method class slot-names
         <span>:monitoring-function</span> <span>(<span>parse-monitoring-function-class-option
                                monitoring-function</span>)</span>
         initargs</span>)</span></span>)</span></span></code></pre>

<p>If the user provided a <code>(:monitoring-function …)</code> class option we evaluate and
use it, otherwise we default to our simple logging function.</p>

<p>There are a couple of things to note here.</p>

<p>First, when <code>defclass</code> gets a class option like <code>(:monitoring-function foo)</code>,
what it <em>actually</em> passes to the <code>(re)initialize-instance</code> methods is the list
<code>(foo)</code>.  This allows for class options with more than one argument.  In our
case we only ever want a single argument, so we ensure the <code>length</code> of the
argument is <code>0</code> or <code>1</code> and handle the cases individually.</p>

<p>Second, <code>defclass</code> does not evaluate the class option&#39;s arguments.  If we say
<code>(:monitoring-function (lambda (i s &amp;optional v) (print (list i s v))))</code> what we
get as the initarg will be <code>((lambda (i s &amp;optional v) (print (list i s v))))</code>.
That&#39;s a list of a list of three elements, <em>not</em> a list of an actual function
object.  If we want the arguments to be evaluated, we have to do it ourselves.
Unfortunately as far as I can tell there&#39;s no way to evaluate these arguments
from <code>defclass</code> in their lexical environment — we have to fall back to <code>eval</code>
and the null lexical environment.  That means that something like this will not
work:</p>

<pre><code><span><span>(<span><i><span>flet</span></i> <span>(<span><span>(<span>monitor <span>(<span>instance slot-name &amp;optional new-value</span>)</span>
          …</span>)</span></span>)</span>
  <span>(<span><i><span>defclass</span></i> foo <span>(<span></span>)</span>
    <span>(<span>…slots…</span>)</span>
    <span>(<span><span>:monitoring-function</span> #&#39;monitor</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>I haven&#39;t managed to find a way to make this work with <code>defclass</code>.  If anyone
knows of a solution, please let me know.</p>

<p>Third, you might notice that we&#39;re <code>apply</code>ing with the full <code>initargs</code> list,
which includes the original (unparsed) <code>monitoring-function</code>.  But that keyword
argument will be shadowed by the <code>:monitoring-function</code> we add at the beginning,
so there&#39;s no need to bother removing it from <code>initargs</code> before we apply (though
it wouldn&#39;t hurt to do so).  This is another Common Lisp idiom you&#39;ll see here
and there when someone wants to override a single keyword argument but preserve
all the rest.</p>

<p>Now we can talk about all the reasons why <code>:initform #&#39;log-slot-access</code> doesn&#39;t
magically solve all our problems.</p>

<p>First, the <code>:initform</code> <em>would</em> work properly when you first define a class, but
we still need all the code in <code>shared-initialize</code> to do the <code>eval</code>ing of the
forms the user provides when they <em>don&#39;t</em> use it.</p>

<p>Further, suppose a user runs:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> foo <span>(<span></span>)</span>
  <span>(<span><span>(<span>some-slot <span>:initarg</span> <span>:some-slot</span></span>)</span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span>
  <span>(<span><span>:monitoring-function</span> monitor-foo</span>)</span></span>)</span></span></code></pre>

<p>Then later they <em>remove</em> the <code>:monitoring-function</code> from the <code>defclass</code> and
reevaluate it:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> foo <span>(<span></span>)</span>
  <span>(<span><span>(<span>some-slot <span>:initarg</span> <span>:some-slot</span></span>)</span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span></span>)</span></span></code></pre>

<p>What the user (probably) expects here is for the class to have the default
monitoring function.  This is what will happen if they start a fresh Lisp image
and load the current code into it.  But if we had just used <code>:initform</code>, the
class would already have a value for the <code>monitoring-function</code> slot (the old
function) and since there&#39;s no <em>new</em> value being specified, the <code>:initform</code>
would never be used and nothing would get updated, so the class would continue
to use the old monitoring function.  The user would have to clean things up
manually by killing the class with <code>(setf (find-class &#39;foo) nil)</code> and
reevaluating the <code>defclass</code>, or fixing the slot value up manually, or some other
ugly alternative.</p>

<p>With all that out of the way, we can now use a custom <code>monitoring-function</code> to
do whatever we want:</p>

<pre><code><span><span>(<span><i><span>defparameter</span></i> <span>*user-slot-reads*</span> <span>(<span>make-hash-table</span>)</span></span>)</span>
<span>(<span><i><span>defparameter</span></i> <span>*user-slot-writes*</span> <span>(<span>make-hash-table</span>)</span></span>)</span>

<span>(<span><i><span>defun</span></i> track-user-slot-access
    <span>(<span>instance slot-name &amp;optional <span>(<span>new-value nil new-value?</span>)</span></span>)</span>
  <span>(<span>declare <span>(<span>ignore instance new-value</span>)</span></span>)</span>
  <span>(<span>incf <span>(<span>gethash slot-name
                 <span>(<span><i><span>if</span></i> new-value? <span>*user-slot-writes*</span> <span>*user-slot-reads*</span></span>)</span>
                 0</span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defclass</span></i> user <span>(<span></span>)</span>
  <span>(<span><span>(<span>id   <span>:initarg</span> <span>:id</span></span>)</span>
   <span>(<span>name <span>:initarg</span> <span>:name</span></span>)</span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span>
  <span>(<span><span>:monitoring-function</span> #&#39;track-user-slot-access</span>)</span></span>)</span>

<span>(<span><i><span>defparameter</span></i> <span>*u*</span> <span>(<span>make-instance &#39;user <span>:id</span> 1 <span>:name</span> <span>&#34;sjl&#34;</span></span>)</span></span>)</span>

<span>(<span>slot-value <span>*u*</span> &#39;id</span>)</span>

<span>(<span>setf <span>(<span>slot-value <span>*u*</span> &#39;name</span>)</span> <span>&#34;steve&#34;</span></span>)</span>
<span>(<span>setf <span>(<span>slot-value <span>*u*</span> &#39;name</span>)</span> <span>&#34;sjl&#34;</span></span>)</span>

<span>(<span>alexandria:hash-table-alist <span>*user-slot-reads*</span></span>)</span>

<span>(<span>alexandria:hash-table-alist <span>*user-slot-writes*</span></span>)</span>
</span></code></pre>

<h3 id="s3-toy-example-disclaimer"><a href="#s3-toy-example-disclaimer">Toy Example Disclaimer</a></h3>

<p>The <code>monitored-class</code> example we&#39;ve used so far is pretty small, and there are
a number of other ways we could accomplish the same thing, some of which might
not involve metaclasses at all.  This might make my example seem overly
complicated.</p>

<p>I wanted to keep the example small so I can focus on the actual problem I ran
into without getting bogged down in too many irrelevant details about a specific
implementation.  If you&#39;re bothered by how we&#39;re using metaclasses here when
there are other ways to implement this toy example, feel free to implement
a more extensive <code>monitored-class</code> variant as an exercise:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> user <span>(<span></span>)</span>
  <span>(<span><span>(<span>id …</span>)</span>
      <span>(<span>session-id … <span>:monitored</span> nil</span>)</span>
      <span>(<span>role … <span>:monitored/reads</span> nil</span>)</span>
      <span>(<span>name … <span>:monitored/redact-value</span> t</span>)</span>
      <span>(<span>email … <span>:monitored/redact-value</span> #&#39;scrub-email</span>)</span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span>
  <span>(<span><span>:monitoring-function</span> #&#39;log-to-syslog</span>)</span>
    <span>(<span><span>:monitor-when</span> #&#39;monitoring-enabled-p</span>)</span></span>)</span></span></code></pre>

<h2 id="s4-the-problem"><a href="#s4-the-problem">The Problem</a></h2>

<p>Let&#39;s return to a toy example that will help demonstrate the problem I ran into.
Suppose we have a <code>user</code> class and want to monitor that class to log a warning
if someone ever changes the <code>id</code> of an instance:</p>

<pre><code><span><span>(<span><i><span>defun</span></i> monitor-user <span>(<span>instance slot &amp;optional <span>(<span>new-value nil new-value?</span>)</span></span>)</span>
  <span>(<span>when <span>(<span>and <span>(<span>eql slot &#39;id</span>)</span> new-value?</span>)</span>
    <span>(<span>when <span>(<span>slot-boundp instance &#39;id</span>)</span>       <span>(<span>format t <span>&#34;WARNING: User ~A is getting a new ID ~A, this is concerning.&#34;</span>
              <span>(<span>slot-value instance &#39;id</span>)</span>
              new-value</span>)</span></span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defclass</span></i> user <span>(<span></span>)</span>
  <span>(<span><span>(<span>id    <span>:initarg</span> <span>:id</span></span>)</span>
   <span>(<span>name  <span>:initarg</span> <span>:name</span></span>)</span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span>
  <span>(<span><span>:monitoring-function</span> #&#39;monitor-user</span>)</span></span>)</span></span></code></pre>

<p>This works as expected:</p>

<pre><code><span><span>(<span><i><span>defparameter</span></i> <span>*u*</span> <span>(<span>make-instance &#39;user <span>:id</span> 1 <span>:name</span> <span>&#34;sjl&#34;</span></span>)</span></span>)</span>

<span>(<span>slot-value <span>*u*</span> &#39;id</span>)</span>

<span>(<span>setf <span>(<span>slot-value <span>*u*</span> &#39;id</span>)</span> 999</span>)</span>

<span>(<span>slot-value <span>*u*</span> &#39;id</span>)</span>
</span></code></pre>

<p>So far, so good.  But what happens if we add a subclass of user?</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> paid-user <span>(<span>user</span>)</span>
  <span>(<span><span>(<span>plan <span>:initarg</span> <span>:plan</span> <span>:type</span> <span>(<span>member <span>:bronze</span> <span>:silver</span> <span>:gold</span></span>)</span></span>)</span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span></span>)</span>

<span>(<span><i><span>defparameter</span></i> <span>*p*</span>
  <span>(<span>make-instance &#39;paid-user <span>:id</span> 2 <span>:name</span> <span>&#34;moneybags&#34;</span> <span>:plan</span> <span>:gold</span></span>)</span></span>)</span>
</span></code></pre>

<p>We can already see the problem: we didn&#39;t explicitly specify
<code>(:monitoring-function #&#39;monitor-user)</code> in the <code>defclass</code> options, so this class
used the default monitoring function instead of inheriting the monitoring
function from its superclass.  This may be what you want in some cases, but for
this case I&#39;d prefer subclasses to inherit their superclass&#39; monitoring function
if they don&#39;t explicitly specify one themselves.</p>

<p>When I saw this, my first instinct was to update
<code>parse-monitoring-function-class-option</code> to take the class as an extra option
and use that to look up a superclass monitoring function (if any) to use as the
default instead, which would look something like this:</p>

<pre><code><span><span>(<span><i><span>defun</span></i> monitored-class-p <span>(<span>class</span>)</span>
  <span>(<span>typep class &#39;monitored-class</span>)</span></span>)</span>

<span>(<span><i><span>defun</span></i> first-monitored-superclass <span>(<span>class</span>)</span>
  <span>(<span><i><span>let</span></i> <span>(<span><span>(<span>superclasses <span>(<span>rest <span>(<span>c2mop:class-precedence-list class</span>)</span></span>)</span></span>)</span></span>)</span>
    <span>(<span>first <span>(<span>remove-if-not #&#39;monitored-class-p superclasses</span>)</span></span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defun</span></i> parse-monitoring-function-class-option <span>(<span>class arguments</span>)</span>
  <span>(<span>case <span>(<span>length arguments</span>)</span>
    <span>(<span>1 <span>(<span>eval <span>(<span>first arguments</span>)</span></span>)</span></span>)</span>
    <span>(<span>0 <span>(<span><i><span>let</span></i> <span>(<span><span>(<span>super <span>(<span>first-monitored-superclass class</span>)</span></span>)</span></span>)</span>
                           <span>(<span><i><span>if</span></i> super
           <span>(<span>monitoring-function super</span>)</span>
           #&#39;log-slot-access</span>)</span></span>)</span></span>)</span>
    <span>(<span>t <span>(<span>error <span>&#34;Malformed monitoring-function option.&#34;</span></span>)</span></span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defmethod</span></i> shared-initialize <span>:around</span>
    <span>(<span><span>(<span>class monitored-class</span>)</span> slot-names
     &amp;rest initargs
     &amp;key monitoring-function &amp;allow-other-keys</span>)</span>
  <span>(<span>apply #&#39;call-next-method class slot-names
         <span>:monitoring-function</span> <span>(<span>parse-monitoring-function-class-option
                                class monitoring-function</span>)</span>
         initargs</span>)</span></span>)</span></span></code></pre>

<p>Unfortunately, if you try to actually run that code you&#39;ll discover a few
unpleasant things. First, the class precedence list isn&#39;t available the first
time the class is being initialized.  So we can&#39;t use it in <code>shared-initialize</code>
like this.</p>

<p>Second, I misled you earlier.  There&#39;s a line <a href="http://metamodular.com/CLOS-MOP/initialization-of-class-metaobjects2.html">deep in the bowels of the
Metaobject protocol</a> that says:</p>

<blockquote>
<p>Portable programs must not define methods on <code>shared-initialize</code>.</p>
</blockquote>

<p>So we can&#39;t use <code>shared-initialize</code> as a shortcut <em>at all</em>, and will need to
define separate methods for <code>initialize-instance</code> and <code>reinitialize-instance</code>
after all.</p>

<p>But even worse, if we think ahead a little bit (which I, of course, did not do
when I was figuring all this out), we can see this entire strategy is doomed to
failure from the start.  Consider the following series of actions by a user at
a REPL:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> user <span>(<span></span>)</span>
  <span>(<span><span>(<span>id    <span>:initarg</span> <span>:id</span></span>)</span>
   <span>(<span>name  <span>:initarg</span> <span>:name</span></span>)</span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span></span>)</span>

<span>(<span><i><span>defclass</span></i> paid-user <span>(<span>user</span>)</span>
  <span>(<span><span>(<span>plan <span>:initarg</span> <span>:plan</span> <span>:type</span> <span>(<span>member <span>:bronze</span> <span>:silver</span> <span>:gold</span></span>)</span></span>)</span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span></span>)</span>

<span>(<span><i><span>defclass</span></i> user <span>(<span></span>)</span>
  <span>(<span><span>(<span>id    <span>:initarg</span> <span>:id</span></span>)</span>
   <span>(<span>name  <span>:initarg</span> <span>:name</span></span>)</span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span>
  <span>(<span><span>:monitoring-function</span> #&#39;log-slots-to-postgres</span>)</span></span>)</span> </span></code></pre>

<p>Clearly what should happen here is that the <code>paid-user</code> class should now inherit
the <em>new</em> monitoring function.  But the strategy of trying to set the monitoring
function <em>once</em> when a class is initialized or reinitialized falls apart when
you want to support redefinition of superclasses and have their subclasses
inherit changes.</p>

<p>At this point, things are not looking good.  We need a new plan.</p>

<h2 id="s5-the-dependent-maintenance-protocol"><a href="#s5-the-dependent-maintenance-protocol">The Dependent Maintenance Protocol</a></h2>

<p>Fortunately, as often happens in Common Lisp, the creators of CLOS and the
Metaobject Protocol had a wonderful amount of foresight and provided a way out
of this problem in the form of the <a href="http://metamodular.com/CLOS-MOP/dependent-maintenance-protocol.html">CLOS Dependent Maintenance Protocol</a>.
From that page:</p>

<blockquote>
<p>It is convenient for portable metaobjects to be able to memoize information
about other metaobjects[…]. Because class […] metaobjects can be
reinitialized[…], a means must be provided to update this memoized
information.</p>
</blockquote>

<p>This is exactly what we need!  We want to memoize the monitoring function each
monitored class will use, and we need to keep that up to date when any of the
classes in the inheritance hierarchy are updated.</p>

<p>The full details are laid out in the protocol documentation, but let&#39;s step
through an example here to see it in action.</p>

<h3 id="s6-dependency-wrappers"><a href="#s6-dependency-wrappers">Dependency Wrappers</a></h3>

<p>The protocol states:</p>

<blockquote>
<p>To prevent conflicts between two portable programs, or between portable
programs and the implementation, portable code must not register metaobjects
themselves as dependents. Instead, portable programs which need to record
a metaobject as a dependent, should encapsulate that metaobject in some other
kind of object, and record that object as the dependent.</p>
</blockquote>

<p>With this in mind, we&#39;ll need to make a small wrapper we can use to store
dependents:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> dependency <span>(<span></span>)</span>
  <span>(<span><span>(<span>dependent <span>:accessor</span> dependent <span>:initarg</span> <span>:dep</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>And then we&#39;ll make some utility functions to add and remove dependencies
to/from classes, which we&#39;ll use shortly:</p>

<pre><code><span><span>(<span><i><span>defun</span></i> dependency= <span>(<span>d class</span>)</span>
  <span>&#34;Return whether `d` is a dependency on `class`.&#34;</span>
    <span>(<span>and <span>(<span>typep d &#39;dependency</span>)</span>
       <span>(<span>eql <span>(<span>dependent d</span>)</span> class</span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defun</span></i> ensure-dependency <span>(<span>superclass class</span>)</span>
  <span>&#34;Ensure that `class` is a dependent of `superclass`.&#34;</span>
  <span>(<span>c2mop:map-dependents superclass
                        <span>(<span><i><span>lambda</span></i> <span>(<span>d</span>)</span>
                          <span>(<span>when <span>(<span>dependency= d class</span>)</span>
                            <span>(<span><i><span>return-from</span></i> ensure-dependency</span>)</span></span>)</span></span>)</span></span>)</span>
  <span>(<span>c2mop:add-dependent superclass <span>(<span>make-instance &#39;dependency <span>:dep</span> class</span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defun</span></i> ensure-no-dependency <span>(<span>superclass class</span>)</span>
  <span>&#34;Ensure that `class` is NOT a dependent of `superclass`.&#34;</span>
  <span>(<span>c2mop:map-dependents superclass
                        <span>(<span><i><span>lambda</span></i> <span>(<span>d</span>)</span>
                          <span>(<span>when <span>(<span>dependency= d class</span>)</span>
                            <span>(<span>c2mop:remove-dependent superclass d</span>)</span>
                            <span>(<span><i><span>return-from</span></i> ensure-no-dependency</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>When we define a subclass on a monitored class, e.g. when we ran <code>(defclass
paid-user (user) …)</code> before, we&#39;ll need to <code>(ensure-dependency user paid-user)</code>
to tell CLOS that <code>paid-user</code> is dependent on <code>user</code>, and needs to be updated if
<code>user</code> is changed.  We also want to make sure to only add the dependency if it
doesn&#39;t already exist, to avoid useless work.</p>

<p>But things can get a little trickier than this, because if <code>paid-user</code> is then
redefined to <em>not</em> be a subclass of <code>user</code> any more (unlikely, but possible) we
want to <em>remove</em> that dependency.  So we&#39;ll need both utility functions for
managing the dependencies.</p>

<h3 id="s7-defining-the-metaclass"><a href="#s7-defining-the-metaclass">Defining the Metaclass</a></h3>

<p>We&#39;ll need to update our metaclass to not only store the monitoring function,
but also store what the user <em>specified</em> as the monitoring function, in case we
need to recompute it later.  We&#39;ll also tell Lisp it&#39;s okay for a monitored
class to be a subclass of a standard class, add our <code>slot-value-using-class</code>
methods from before, and define a helper type predicate while we&#39;re here:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> monitored-class <span>(<span>standard-class</span>)</span>
  <span>(<span><span>(<span>given-monitoring-function
     <span>:initarg</span> <span>:given-monitoring-function</span>
     <span>:accessor</span> given-monitoring-function</span>)</span>
   <span>(<span>computed-monitoring-function
     <span>:initarg</span> <span>:computed-monitoring-function</span>
     <span>:accessor</span> computed-monitoring-function</span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defmethod</span></i> c2mop:validate-superclass
    <span>(<span><span>(<span>class monitored-class</span>)</span> <span>(<span>superclass standard-class</span>)</span></span>)</span>
  t</span>)</span>

<span>(<span><i><span>defmethod</span></i> c2mop:slot-value-using-class <span>:before</span>
    <span>(<span><span>(<span>class monitored-class</span>)</span> instance slot</span>)</span>
  <span>(<span>funcall <span>(<span>computed-monitoring-function class</span>)</span>
           instance
           <span>(<span>c2mop:slot-definition-name slot</span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defmethod</span></i> <span>(<span>setf c2mop:slot-value-using-class</span>)</span> <span>:before</span>
    <span>(<span>new-value <span>(<span>class monitored-class</span>)</span> instance slot</span>)</span>
  <span>(<span>funcall <span>(<span>computed-monitoring-function class</span>)</span>
           instance
           <span>(<span>c2mop:slot-definition-name slot</span>)</span>
           new-value</span>)</span></span>)</span>

<span>(<span><i><span>defun</span></i> monitored-class-p <span>(<span>object</span>)</span>
  <span>(<span>typep object &#39;monitored-class</span>)</span></span>)</span></span></code></pre>

<h3 id="s8-computing-slots"><a href="#s8-computing-slots">Computing Slots</a></h3>

<p>We&#39;re going to need a function for computing the value of the slot.  It will
serve the same role <code>parse-monitoring-function-class-option</code> was serving before.</p>

<p>If we only have one class option like <code>:monitoring-function</code> we could hardcode
it into a function like this:</p>

<pre><code><span><span>(<span><i><span>defun</span></i> recompute-monitoring-function <span>(<span>&amp;key class superclasses value value?</span>)</span>
  <span>&#34;Set the metaclass&#39; monitoring-function slots to the appropriate value.

  If the user provides an explicit value it will be used, otherwise the value
  will be inherited from any superclass&#39; value, otherwise the default will be
  used.

  In any case, the computed value is stored in the `computed-…` slot, and the
  original user-given value (if any) is stored in the `given-…` slot so we can
  use it later if any superclasses change and we need to recompute this.

  &#34;</span>
    <span>(<span>setf superclasses <span>(<span>remove-if-not #&#39;monitored-class-p superclasses</span>)</span></span>)</span>
    <span>(<span><i><span>if</span></i> value?
    <span>(<span>setf <span>(<span>slot-value class &#39;given-monitoring-function</span>)</span> value</span>)</span>
    <span>(<span>slot-makunbound class &#39;given-monitoring-function</span>)</span></span>)</span>
    <span>(<span>setf <span>(<span>slot-value class &#39;computed-monitoring-function</span>)</span>
        <span>(<span><i><span>cond</span></i>
                    <span>(<span>value? <span>(<span><i><span>progn</span></i> <span>(<span>assert <span>(<span>= 1 <span>(<span>length value</span>)</span></span>)</span></span>)</span>
                         <span>(<span>eval <span>(<span>first value</span>)</span></span>)</span></span>)</span></span>)</span>
                              <span>(<span>superclasses <span>(<span>slot-value <span>(<span>first superclasses</span>)</span>
                                    &#39;computed-monitoring-function</span>)</span></span>)</span>
                    <span>(<span>t #&#39;log-slot-access</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>First we clean up the superclass list to only consider relevant superclasses.</p>

<p>Then we store the value the user gave, if any, in the
<code>given-monitoring-function</code> slot of the class.  If they <em>didn&#39;t</em> specify a value
(e.g. if they <em>removed</em> it and reevaluated the <code>defclass</code>), we make sure to
account for that by <code>slot-makunbound</code>ing the slot to clear out any possible old
value.</p>

<p>Then we compute what the real value should be.  If they gave us a value, we
<code>eval</code> it as we talked about earlier and use that.  Otherwise we use whatever we
computed for a superclass, if available, otherwise the default.</p>

<p>This is all we need if we&#39;ve only got one option to deal with, as in our toy
example.  In my <em>actual</em> project I have a bunch of these options, and so added
a slightly-tedious layer of abstraction to avoid the very-tedious copy/paste
approach:</p>

<pre><code><span><span>(<span><i><span>defun</span></i> recompute-slot
    <span>(<span>&amp;key class superclasses computed-slot given-slot value value? <i><span>default</span></i></span>)</span>
  <span>&#34;Set the metaclass&#39; slots to the appropriate value.

  For metaclass slots if the user provides an explicit value it will be used,
  otherwise the value will be inherited from any superclass&#39; value, otherwise
  the default will be used.

  In any case, the computed value is stored in the `computed-…` slot, and the
  original user-given value (if any) is stored in the `given-…` slot so we can
  use it later if any superclasses change and we need to recompute this.

  &#34;</span>
    <span>(<span>setf superclasses <span>(<span>remove-if-not #&#39;monitored-class-p superclasses</span>)</span></span>)</span>
    <span>(<span><i><span>if</span></i> value?
    <span>(<span>setf <span>(<span>slot-value class given-slot</span>)</span> value</span>)</span>
    <span>(<span>slot-makunbound class given-slot</span>)</span></span>)</span>
      <span>(<span>setf <span>(<span>slot-value class computed-slot</span>)</span>
        <span>(<span><i><span>cond</span></i>
          <span>(<span>value? <span>(<span><i><span>progn</span></i> <span>(<span>assert <span>(<span>= 1 <span>(<span>length value</span>)</span></span>)</span></span>)</span>
                         <span>(<span>eval <span>(<span>first value</span>)</span></span>)</span></span>)</span></span>)</span>
          <span>(<span>superclasses <span>(<span>slot-value <span>(<span>first superclasses</span>)</span> computed-slot</span>)</span></span>)</span>
          <span>(<span>t <i><span>default</span></i></span>)</span></span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defun</span></i> recompute-slots <span>(<span>class &amp;key
                        direct-superclasses
                        <span>(<span>monitoring-function nil monitoring-function?</span>)</span>
                        &amp;allow-other-keys</span>)</span>
  <span>(<span>recompute-slot <span>:class</span>        class
                  <span>:superclasses</span> direct-superclasses
                  <span>:computed-slot</span> &#39;computed-monitoring-function
                  <span>:given-slot</span>    &#39;given-monitoring-function
                  <span>:value</span>  monitoring-function
                  <span>:value?</span> monitoring-function?
                  <span>:default</span> #&#39;log-slot-access</span>)</span></span>)</span></span></code></pre>

<p>Supporting more options is just a matter of adding more calls inside of
<code>recompute-slots</code>.  It&#39;s not the most exciting code I&#39;ve ever written, but it
works.</p>

<h3 id="s9-initialization"><a href="#s9-initialization">Initialization</a></h3>

<p>Now we can finally define the <code>initialize-instance</code> and <code>reinitialize-instance</code>
methods on our class.  We&#39;ll start with <code>initialize-instance</code> (and a helper
function):</p>

<pre><code><span><span>(<span><i><span>defun</span></i> strip-initargs <span>(<span>initargs</span>)</span>
  <span>&#34;Remove any monitored-class initargs from `initargs`.

  We need to do this because we handle these ourselves before
  `call-next-method`, in `recompute-slots`, and if we leave them in
  the initarg list then `call-next-method` will explode.

  &#34;</span>
  <span>(<span><i><span>loop</span></i> <span>:for</span> <span>(<span>initarg value</span>)</span> <span>:on</span> initargs <span>:by</span> #&#39;cddr
        <span>:unless</span> <span>(<span>member initarg &#39;<span>(<span><span>:monitoring-function</span></span>)</span></span>)</span>
        <span>:append</span> <span>(<span>list initarg value</span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defmethod</span></i> initialize-instance <span>:around</span>
    <span>(<span><span>(<span>class monitored-class</span>)</span> &amp;rest initargs &amp;key &amp;allow-other-keys</span>)</span>
  <span>(<span>apply #&#39;recompute-slots class initargs</span>)</span>
  <span>(<span>apply #&#39;call-next-method class <span>(<span>strip-initargs initargs</span>)</span></span>)</span>
  <span>(<span>dolist <span>(<span>superclass <span>(<span>c2mop:class-direct-superclasses class</span>)</span></span>)</span>
    <span>(<span>ensure-dependency superclass class</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>We recompute our special slots, then delegate to <code>call-next-method</code> to handle
everything else, after stripping out our initargs because we&#39;ve already handled
them.</p>

<p>The only other thing we have to do is plug into the dependent maintenance
protocol, to ensure that this new class is a dependent of all its superclasses.</p>

<p>You might think I&#39;m being wasteful here and we should only add dependencies on
superclasses that are instances of our particular metaclass.  For example, if we
have:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> some-other-mixin <span>(<span></span>)</span> <span>(<span></span>)</span></span>)</span>

<span>(<span><i><span>defclass</span></i> user <span>(<span></span>)</span>
  <span>(<span>…slots…</span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span></span>)</span>

<span>(<span><i><span>defclass</span></i> paid-user <span>(<span>user some-other-mixin</span>)</span>
  <span>(<span>…slots…</span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span></span>)</span></span></code></pre>

<p>Then <code>paid-user</code> will be a dependent of both <code>user</code> <em>and</em> <code>some-other-mixin</code>.
This seems unnecessary, because changes in non-monitored superclasses won&#39;t have
any effect on our monitoring function computation.</p>

<p>Unfortunately, things are not so simple.  If we only add dependencies on
monitored superclasses, this will fall apart in the face of <a href="http://metamodular.com/CLOS-MOP/class-finalization-protocol.html">forward-referenced
superclasses</a>.  In case you weren&#39;t aware, Common Lisp allows you to define
a subclass before its superclass, as long as all the classes are in place before
you try to actually make an instance of the subclass:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> bar <span>(<span>foo</span>)</span>
  <span>(<span><span>(<span>b <span>:accessor</span> b <span>:initarg</span> <span>:b</span></span>)</span></span>)</span></span>)</span>

<span>(<span>make-instance &#39;bar <span>:a</span> 1 <span>:b</span> 2</span>)</span>

<span>(<span><i><span>defclass</span></i> foo <span>(<span></span>)</span>
  <span>(<span><span>(<span>a <span>:accessor</span> a <span>:initarg</span> <span>:a</span></span>)</span></span>)</span></span>)</span>

<span>(<span>make-instance &#39;bar <span>:a</span> 1 <span>:b</span> 2</span>)</span>
</span></code></pre>

<p>This complicates our lives when we&#39;re trying to manage dependents, because we
can&#39;t possibly know whether a forward-referenced superclass will eventually be
defined as a monitored class or not.  So we&#39;ll just take the safe route and add
a dependent to <em>all</em> superclasses.  This will result in a little extra work, but
it only happens when a class is being defined or redefined which will happen
relatively infrequently.</p>

<h3 id="s10-reinitialization"><a href="#s10-reinitialization">Reinitialization</a></h3>

<p>We&#39;ll also need to define a method on <code>reinitialize-instance</code>:</p>

<pre><code><span><span>(<span><i><span>defmethod</span></i> reinitialize-instance <span>:around</span>
    <span>(<span><span>(<span>class monitored-class</span>)</span> &amp;rest initargs
     &amp;key <span>(<span>direct-superclasses nil direct-superclasses?</span>)</span>
     &amp;allow-other-keys</span>)</span>
  <span>(<span>apply #&#39;recompute-slots class
         <span>:direct-superclasses</span> <span>(<span><i><span>if</span></i> direct-superclasses?
                                direct-superclasses
                                <span>(<span>c2mop:class-direct-superclasses class</span>)</span></span>)</span>
         initargs</span>)</span>
  <span>(<span><i><span>let</span></i> <span>(<span><span>(<span>before <span>(<span>c2mop:class-direct-superclasses class</span>)</span></span>)</span></span>)</span>
    <span>(<span>apply #&#39;call-next-method class <span>(<span>strip-initargs initargs</span>)</span></span>)</span>
    <span>(<span><i><span>let*</span></i> <span>(<span><span>(<span>after <span>(<span>c2mop:class-direct-superclasses class</span>)</span></span>)</span>
           <span>(<span>removed <span>(<span>set-difference before after</span>)</span></span>)</span>
           <span>(<span>added <span>(<span>set-difference after before</span>)</span></span>)</span></span>)</span>
      <span>(<span>dolist <span>(<span>superclass removed</span>)</span>
        <span>(<span>ensure-no-dependency superclass class</span>)</span></span>)</span>
      <span>(<span>dolist <span>(<span>superclass added</span>)</span>
        <span>(<span>ensure-dependency superclass class</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>The overall structure of this method is the same as <code>initialize-instance</code>:</p>

<ol>
<li>Recompute values of our special metaclass slot(s).</li>
<li><code>call-next-method</code> to finish the rest of the (re)initialization.</li>
<li>Ensure our dependencies are correct.</li>
</ol>

<p>But there are a couple of fiddly bits to note.</p>

<p>We may or may not get a new set of direct superclasses, depending on how the
reinitialization happened.  We <em>always</em> need that list when we call
<code>recompute-slots</code> though, so we&#39;ll grab it ourselves if we don&#39;t get it.</p>

<p>We also save the list of direct superclasses before and after we defer to
<code>call-next-method</code> to complete the reinitialization, and then compare the list
before and after to figure out which dependencies we need to add or remove.</p>

<p>With all that out of the way, we&#39;re almost done.</p>

<h3 id="s11-dependent-updates"><a href="#s11-dependent-updates">Dependent Updates</a></h3>

<p>Now we can finally tell CLOS to update dependents when a monitored class
changes:</p>

<pre><code><span><span>(<span><i><span>defun</span></i> given-to-initarg <span>(<span>class initarg given-slot</span>)</span>
  <span>(<span>when <span>(<span>slot-boundp class given-slot</span>)</span>
    <span>(<span>list initarg <span>(<span>slot-value class given-slot</span>)</span></span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defmethod</span></i> c2mop:update-dependent
    <span>(<span>updated-class <span>(<span>dep dependency</span>)</span> &amp;rest initargs</span>)</span>
  <span>(<span>declare <span>(<span>ignore initargs</span>)</span></span>)</span>
  <span>(<span>when <span>(<span>monitored-class-p updated-class</span>)</span>
    <span>(<span><i><span>let</span></i> <span>(<span><span>(<span>dependent-class <span>(<span>dependent dep</span>)</span></span>)</span></span>)</span>
      <span>(<span>apply #&#39;reinitialize-instance dependent-class
             <span>(<span>append
               <span>(<span>given-to-initarg dependent-class
                                 <span>:given-monitoring-function</span>
                                 &#39;given-monitoring-function</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p><code>update-dependent</code> is the key method here.  When a superclass with one of these
dependencies is updated, this method will be called.  When that happens, we know
we might need to update the subclasses.</p>

<p>First we check to make sure the class being updated really <em>is</em> a monitored
class (and not something that was forward-referenced but didn&#39;t turn out to be
monitored).</p>

<p>Assuming we really are updating a monitored class, we call
<code>reinitialize-instance</code> on the dependent class.  We set up the initargs to this
call as if the user had reran the <em>dependent&#39;s</em> <code>defclass</code> form (because we&#39;re
reinitializing the <em>dependent</em>, after the superclass has changed), to ensure
that the recalculation happens properly.  An example might make this clearer:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> user <span>(<span></span>)</span>
  <span>(<span>…slots…</span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span>
  <span>(<span><span>:monitoring-function</span> #&#39;log-slot</span>)</span></span>)</span>

<span>(<span><i><span>defclass</span></i> paid-user <span>(<span>user</span>)</span>
  <span>(<span>…slots…</span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span></span>)</span>

<span>(<span><i><span>defclass</span></i> audited-user <span>(<span>user</span>)</span>
  <span>(<span>…slots…</span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span>
  <span>(<span><span>:monitoring-function</span> #&#39;audit-slot-to-postgres</span>)</span></span>)</span></span></code></pre>

<p>If we now redefine <code>user</code>, both of its dependencies will be reinitialized.</p>

<p>For <code>paid-user</code> we call <code>(reinitialize-instance paid-user)</code> with no initargs,
because there&#39;s no <code>(:monitoring-function …)</code> in the <code>defclass</code> form and thus
its <code>given-monitoring-function</code> slot is unbound.</p>

<p>For <code>audited-user</code> we call <code>(reinitialize-instance audited-user
:monitoring-function &#39;(#&#39;audit-slot-to-postgres))</code>, because the <code>audited-user</code>
class <em>does</em> have a monitoring function that <code>recompute-slots</code> will need.</p>

<h2 id="s12-the-result"><a href="#s12-the-result">The Result</a></h2>

<p>With all that in place, our metaclass is ready for interactive use!  First we&#39;ll
review the default logging function and create two more:</p>

<pre><code><span><span>(<span><i><span>defun</span></i> log-slot-access <span>(<span>instance slot-name &amp;optional <span>(<span>new-value nil new-value?</span>)</span></span>)</span>
  <span>(<span><i><span>if</span></i> new-value?
    <span>(<span>format t <span>&#34;Setting slot ~A of ~A to ~S at ~A.~%&#34;</span>
              slot-name instance new-value <span>(<span>get-universal-time</span>)</span></span>)</span>
    <span>(<span>format t <span>&#34;Reading slot ~A of ~A at ~A.~%&#34;</span>
              slot-name instance <span>(<span>get-universal-time</span>)</span></span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defun</span></i> loud-slot-access <span>(<span>instance slot-name &amp;optional <span>(<span>new-value nil new-value?</span>)</span></span>)</span>
  <span>(<span><i><span>if</span></i> new-value?
    <span>(<span>format t <span>&#34;SETTING SLOT ~A OF ~A TO ~S AT ~A.~%&#34;</span>
              slot-name instance new-value <span>(<span>get-universal-time</span>)</span></span>)</span>
    <span>(<span>format t <span>&#34;READING SLOT ~A OF ~A AT ~A.~%&#34;</span>
              slot-name instance <span>(<span>get-universal-time</span>)</span></span>)</span></span>)</span></span>)</span>

<span>(<span><i><span>defun</span></i> quiet-slot-access <span>(<span>instance slot-name &amp;optional <span>(<span>new-value nil new-value?</span>)</span></span>)</span>
  <span>(<span><i><span>if</span></i> new-value?
    <span>(<span>format t <span>&#34;~A/~A &lt;- ~S~%&#34;</span> instance slot-name new-value</span>)</span>
    <span>(<span>format t <span>&#34;&lt;- ~A/~A~%&#34;</span> instance slot-name</span>)</span></span>)</span></span>)</span></span></code></pre>

<p>Now we can create a few classes:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> foo <span>(<span></span>)</span>
  <span>(<span><span>(<span>x <span>:initarg</span> <span>:x</span></span>)</span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span></span>)</span>

<span>(<span><i><span>defclass</span></i> bar <span>(<span>foo</span>)</span>
  <span>(<span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span>
  <span>(<span><span>:monitoring-function</span> #&#39;quiet-slot-access</span>)</span></span>)</span>

<span>(<span><i><span>defclass</span></i> baz <span>(<span>foo</span>)</span>
  <span>(<span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span></span>)</span></span></code></pre>

<ul>
<li><code>foo</code> is the superclass, with the default monitoring function.</li>
<li><code>bar</code> subclasses <code>foo</code> but changes the monitoring function.</li>
<li><code>baz</code> subclasses foo and inherits its monitoring function.</li>
</ul>

<p>And everything should work properly:</p>

<pre><code><span><span>(<span><i><span>defparameter</span></i> <span>*foo-object*</span> <span>(<span>make-instance &#39;foo <span>:x</span> 1</span>)</span></span>)</span>

<span>(<span>slot-value <span>*foo-object*</span> &#39;x</span>)</span>

<span>(<span>setf <span>(<span>slot-value <span>*foo-object*</span> &#39;x</span>)</span> 2</span>)</span>

<span>(<span><i><span>defparameter</span></i> <span>*bar-object*</span> <span>(<span>make-instance &#39;bar <span>:x</span> 1</span>)</span></span>)</span>

<span>(<span>slot-value <span>*bar-object*</span> &#39;x</span>)</span>

<span>(<span>setf <span>(<span>slot-value <span>*bar-object*</span> &#39;x</span>)</span> 2</span>)</span>

<span>(<span><i><span>defparameter</span></i> <span>*baz-object*</span> <span>(<span>make-instance &#39;baz <span>:x</span> 1</span>)</span></span>)</span>

<span>(<span>slot-value <span>*baz-object*</span> &#39;x</span>)</span>

<span>(<span>setf <span>(<span>slot-value <span>*baz-object*</span> &#39;x</span>)</span> 2</span>)</span>
</span></code></pre>

<p>And now for the <em>real</em> test.  We&#39;ll redefine <em>only <code>foo</code></em> to change its function:</p>

<pre><code><span><span>(<span><i><span>defclass</span></i> foo <span>(<span></span>)</span>
  <span>(<span><span>(<span>x <span>:initarg</span> <span>:x</span></span>)</span></span>)</span>
  <span>(<span><span>:metaclass</span> monitored-class</span>)</span>
  <span>(<span><span>:monitoring-function</span> #&#39;loud-slot-access</span>)</span></span>)</span></span></code></pre>

<p>Now <code>foo</code> slot access will be yelled at us:</p>

<pre><code><span><span>(<span><i><span>defparameter</span></i> <span>*foo-object*</span> <span>(<span>make-instance &#39;foo <span>:x</span> 1</span>)</span></span>)</span>
</span></code></pre>

<p><code>bar</code> hasn&#39;t changed, because it has its own explicit function defined:</p>

<pre><code><span><span>(<span><i><span>defparameter</span></i> <span>*bar-object*</span> <span>(<span>make-instance &#39;bar <span>:x</span> 1</span>)</span></span>)</span>
</span></code></pre>

<p>But, crucially, <code>baz</code> was automatically updated to use the new function it
inherits from <code>foo</code>:</p>

<pre><code><span><span>(<span><i><span>defparameter</span></i> <span>*baz-object*</span> <span>(<span>make-instance &#39;baz <span>:x</span> 1</span>)</span></span>)</span>
</span></code></pre>

<h2 id="s13-is-it-worth-it"><a href="#s13-is-it-worth-it">Is It Worth It?</a></h2>

<p>That was a lot of work.  Why did we bother doing it?</p>

<p>One of the strengths of Common Lisp programming is interactive development.
Lispers are used to redefining anything and everything at will and trusting that
their environments can keep up.  Interactivity is baked into the bones of the
language — if we want a metaclass to really feel at home, we need to take the
extra steps to make sure it works well in the face of redefinition.</p>

<p>The designers of Common Lisp and the Metaobject Protocol had a lot of foresight
and provided the tools needed to extend the language without destroying its
interactivity.  Unfortunately this is a hard problem, and the tools are not
simple to use.  It&#39;s almost always <em>possible</em> to do things right, but is often
not <em>easy</em>.</p>

<p>Was it worth doing?  For this toy example: probably not.  For the project I was
working on when I had to figure this all out: I think it was.  For your next
project: you&#39;ll need to decide that for yourself.  But I, at least, am thankful
that the designers of Common Lisp and CLOS made it <em>possible</em> to do things
right, even if it&#39;s not always easy.</p>
</article></div></div>
  </body>
</html>
