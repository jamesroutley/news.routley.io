<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://moyix.blogspot.com/2022/02/on-building-30k-debian-packages.html">Original</a>
    <h1>On building 30k Debian packages</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-653965455140137334" itemprop="description articleBody">
<p>As part of my ongoing attempts to create some nice datasets for training <a href="https://huggingface.co/moyix/csrc_774m">large code models for C/C++</a>, I&#39;ve recently been attempting to build every package in Debian Unstable from source using <a href="https://github.com/rizsotto/Bear">bear</a> to log the compilation and generate a <a href="https://clang.llvm.org/docs/JSONCompilationDatabase.html">compile_commands.json database</a> for each build. Since it&#39;s not possible, in general, to parse C/C++ code without knowing what flags were used (e.g., so you can find header files, know what preprocessor defines are in use, etc.), this will open up some nice possibilities like:</p><ul><li>Getting ASTs for each source file</li><li>Rebuilding each file and generating its LLVM IR (-emit-llvm) or assembly (-S)</li><li>Extracting comments associated with individual functions</li></ul><p>I&#39;ll probably have more to say about this dataset once I actually get around to doing something fun with it, but for now I wanted to just jot down some notes on stuff I wish I had known before trying to do this:</p><ul><li><b>Isolation</b>: Run the build for each package in some kind of isolated environment. You know how packages sometimes have install-time conflicts? It&#39;s 100x worse for build-time conflicts.</li><li><b>Use an SSD</b>: Make sure to build things somewhere with fast storage. A huge amount of compiling stuff is just reading it off disk and writing it back. Because my main Docker stores its images on spinning rust, I ran a separate Docker daemon for the SSD with a <a href="https://gist.github.com/moyix/8668f411c1dd87a07457b329e3008530">minimal config file</a>. Then you can just set DOCKER_HOST=unix:///var/run/docker-nvme.sock and build/run your images.</li><li><b>Log everything, especially exit codes</b>. I got through a whole pass before realizing I didn&#39;t have a reliable way to tell which packages had built successfully (dpkg-buildpackage emits an exciting array of inconsistent messages), and had to re-run everything.</li><li><b>Turn off stuff you don&#39;t want</b>. I don&#39;t care about running tests or building documentation, so I set DEB_BUILD_OPTIONS=&#34;nodoc notest nocheck&#34;. Unfortunately, not every package respects the build options, but it&#39;s worth a try.</li><li><b>Don&#39;t build as root</b>. A number of packages detect if you&#39;re trying to build stuff as root and will die (coreutils is one example). This is an easy mistake to make in Docker, where running as root is the default. Run as a normal user, and use &#34;dpkg-buildpackage -rfakeroot&#34; so that it can pretend to be root for packages that <i>do</i> want to be built as root.</li><li><b>Run non-interactively</b>. There are a few packages that, when installed, try to ask the user some questions and will hang forever unless DEBIAN_FRONTEND=noninteractive is set. So set it, and make sure it gets passed on child processes (a particularly annoying example is sudo, where you have to add -E to make it inherit the environment).</li><li><b>Use timeouts</b>. Particularly in an isolated environment like Docker, sometimes stuff will just hang during build (or maybe in some cases it&#39;s bear&#39;s fault, IDK). Some common culprits I&#39;ve found so far are xvfb-run and erl_child_setup, and (maybe) things that expect dbus to be present. Aside from setting a timeout, I also ran a script in the background to find and kill any of those processes that were hanging around longer than a few minutes. [Actually, rather than killing them, which will make them exit with a non-zero status and cause the build to error out, I used this <a href="https://twitter.com/moyix/status/1484342467205816325">nice trick from Kyle Huey</a> to <a href="https://gist.github.com/moyix/95ca9a7a26a639b2322c36c7411dc3be">attach to them with gdb and inject a call to exit(0)</a>]</li><li><b>Clean up</b>. Since you&#39;re using a nice fast SSD, it&#39;s probably not enormous (mine is a measly 2TB). Builds are big. You may want to remember to move your build artifacts to somewhere roomier so that you don&#39;t run out of space (this tends to make build systems very unhappy).</li><li><b>Stay up to date</b>. Initially I just parsed Sources.gz, grabbed all the source packages, and then tried to fetch their build-deps. But it turns out Debian moves too fast for this; by the time I got around to building some package a few days later, its build-deps had in some cases been updated and weren&#39;t available in apt any more. Now I instead start each build with an apt-get -y update, and then fetch the most recent sources package info and build dependencies right before attempting the build.</li><li><b>Avoid shell hackery</b>. This is probably controversial, and I&#39;m sure someone better and more careful at bash could do it, but trying to automate everything in a language where failures are silent and can do exciting things like call &#34;rm -rf /&#34; when you meant &#34;rm -rf ${foo}/${bar}&#34; is painful. Python has its own issues, but it was nice to at least get noisy errors as soon as things went wrong (example script: <a href="https://gist.github.com/moyix/f64f35a563f74d23293c4c17fb15c904">this one which uses python-apt to get source package info</a>, rather than &#34;parsing&#34; Sources.gz with grep/awk/sed).</li><li><b>Expect to be disappointed</b>. Even after all of this a lot of stuff is going to fail to build. Other things will be weird in ways you never dreamed software could be weird (hello, packages that spend 12 hours generating documentation using xsltproc!). You&#39;ll find fun stuff like packages that have clear security vulnerabilities, as revealed by compiler diagnostics like -Wformat-security (presumably these packages built fine under older, dumber compilers). Some of this can probably be mitigated by targeting Debian stable; unstable is, well, unstable, and brokenness is expected.</li></ul><p>No doubt I&#39;ve missed lots of things that make this a more pleasant and reliable experience! There are a number of other projects that are also attempting to build all (or large portions) of Debian, which I probably should have looked at in more detail before attempting to roll my own (my only excuse is that I wanted something I knew how to extend and modify to do weird stuff like tracing build commands and recompiling individual files with other flags):</p>

</div></div>
  </body>
</html>
