<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://m417z.com/Implementing-Global-Injection-and-Hooking-in-Windows/">Original</a>
    <h1>Implementing Global Injection and Hooking in Windows</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>A couple of weeks ago, <a href="https://windhawk.net/">Windhawk</a>, the customization marketplace for Windows programs, was released. You can read <a href="https://ramensoftware.com/windhawk">the announcement</a> for more details and for the motivation behind creating it. In this post, I’ll focus on my journey in implementing the technical aspects of Windhawk. If you prefer reading code to reading text, check out <a href="https://github.com/m417z/global-inject-demo">the demo implementation</a>.</p>

<p>Windhawk allows creating mods, which are C++ snippets that are compiled to DLLs and loaded in third party programs to customize them. The technical challenge is to be able to load these DLLs in the context of the required processes. For example, one can create a mod that hooks the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxw"><code>MessageBoxW</code></a> WinAPI function, and define that the mod should apply to all processes.</p>

<p><img src="https://m417z.com/images/Implementing-Global-Injection-and-Hooking-in-Windows/A-hooked-MessageBoxW-example.png" alt="A hooked MessageBoxW example"/></p>

<p>Windhawk implements a mod manager which is injected into all processes. Injecting a DLL into all processes is not a novel task, it has been done multiple times before by antiviruses, customization tools, and other programs. To the best of my knowledge, these are the most common approaches:</p>

<ul>
  <li><strong>Using a kernel driver</strong> - A nice proof-of-concept implementation can be found <a href="https://github.com/wbenny/injdrv">here</a>.</li>
  <li><strong>Using <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexw"><code>SetWindowsHookEx</code></a></strong> - Can be used to install a hook procedure to monitor the system for certain types of events. Only applies to processes that load <code>user32.dll</code>. Limited to processes in the same desktop. Has limitations regarding UWP apps.</li>
  <li><strong>Using <a href="https://docs.microsoft.com/en-us/windows/win32/dlls/secure-boot-and-appinit-dlls"><code>AppInit_Dlls</code></a></strong> - A legacy infrastructure that provides an easy way for custom DLLs to be loaded into the address space of every interactive application. Only applies to processes that load <code>user32.dll</code>. Starting in Windows 8, the <code>AppInit_DLLs</code> infrastructure is disabled when secure boot is enabled.</li>
  <li><strong>Using esoteric, undocumented hooks</strong> - You can see several examples for these in the <a href="https://www.youtube.com/watch?v=pHyWyH804xE">Hooking Nirvana</a> talk by Alex Ionescu.</li>
</ul>

<p>These were my goals for the global injection solution:</p>

<ul>
  <li><strong>Minimal privileges</strong> - I wanted Windhawk to be able to run even without administrator rights. And in general, I preferred to avoid installing a driver which is too intrusive to my taste and can affect the system’s stability.</li>
  <li><strong>Minimal intrusiveness</strong> - I preferred to avoid modifying system files or registry entries, doing all the work in memory, such that all changes are temporary and there’s no risk of causing permanent damage to the system.</li>
  <li><strong>Minimal limitations</strong> - I strived to allow customizing as many programs as possible. For example, I tried to find a solution that is not limited to processes that load <code>user32.dll</code>, and that has no limitations regarding UWP apps.</li>
  <li><strong>Universal solution</strong> - I looked for a solution that works on all or most Windows versions, and that is unlikely to stop working in the future.</li>
</ul>

<p>Also, it’s worth listing some of the non-goals for the solution:</p>

<ul>
  <li><strong>Stealth</strong> - DLL injection is often misused by malware, and one of their goals is staying undetected for as long as possible. To achieve that, malware authors try to find novel injection methods which are not known to security vendors and are not detected by security software. As my project has no malicious intentions, hiding the injection is not necessary. In fact, I preferred a standard solution that is as transparent as possible.</li>
  <li><strong>Security</strong> - DLL injection is often used by security software. An antivirus, for example, may decide to intercept all file access and limit access to sensitive files. In this case, it’s important to make sure that the limitation can’t be bypassed. My project has no security implications and doesn’t need to be protected from bypasses.</li>
</ul>

<h2 id="looking-for-the-best-approach">Looking for the best approach</h2>

<p>I started by looking for the approach that fits my goals best. Here’s a table which summarizes my findings (note that those are not yes/no criteria and the table is mostly a judgment call):</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Minimal privileges</th>
      <th>Minimal intrusiveness</th>
      <th>Minimal limitations</th>
      <th>Universal solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A kernel driver</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>✅</td>
    </tr>
    <tr>
      <td><code>SetWindowsHookEx</code></td>
      <td>✅</td>
      <td>✅</td>
      <td>❌</td>
      <td>✅</td>
    </tr>
    <tr>
      <td><code>AppInit_Dlls</code></td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>Esoteric hooks</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
  </tbody>
</table>

<p>Out of the four approaches, the <code>SetWindowsHookEx</code> approach seemed to be the best fit, but it has its limitations which I hoped to avoid. Also, using <code>SetWindowsHookEx</code> felt like a misuse of a tool designed for different purposes as I must choose an event to get notified about, even if I don’t need any.</p>

<p>After some thought, I decided to try another approach: Instead of using a dedicated global injection mechanism, implement injection for a single process. Then, use it to implement global injection as following:</p>

<ul>
  <li>Initially, enumerate all processes and inject into each of them.</li>
  <li>For each of the injected processes, intercept new process creation (e.g. by hooking the <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw"><code>CreateProcess</code></a> WinAPI function) and inject into each newly created process.</li>
</ul>

<p>This approach looks rather obvious and simple to implement, but in practice there are various tricky details that have to be taken care of. I’ll go through them in this post. I’m sure this approach was implemented and used before, but I didn’t find a fully working implementation which I could use as a reference.</p>

<h2 id="injecting-a-dll-into-a-process">Injecting a DLL into a process</h2>

<p>Typically, process injection follows these steps: Memory allocation, memory writing, code execution. I’ve used the classic and straightforward injection method:</p>

<ul>
  <li><code>VirtualAllocEx</code> for allocating memory in the target process.</li>
  <li><code>WriteProcessMemory</code> for writing the code into the allocated memory.</li>
  <li><code>CreateRemoteThread</code> for creating a new thread in the target process to run the code that was written.</li>
</ul>

<p>The injected code loads the DLL, achieving the required task.</p>

<p>This injection method is very old and well known, and there are many tutorials and examples for it on the internet, so I won’t elaborate further.</p>

<h2 id="injecting-a-dll-into-all-processes">Injecting a DLL into all processes</h2>

<p>As mentioned before, the idea is to enumerate all processes and inject the DLL into each of them. To make sure the DLL is also loaded in newly created processes, intercept new process creation and inject into each newly created process.</p>

<p><img src="https://m417z.com/images/Implementing-Global-Injection-and-Hooking-in-Windows/A-chart-showing-injection-into-all-processes.png" alt="A chart showing injection into all processes" width="601px"/></p>

<p>A simple implementation can be found <a href="https://github.com/m417z/global-inject-demo/tree/686b81b8ed70ababad350f4438eb10023c49443c">here</a>. A couple of notes about the implementation:</p>

<ul>
  <li>When launched as administrator, the program enables <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debug-privilege">debug privilege</a>. This allows injecting the DLL into system services. As a result, this enables injecting the DLL into newly created processes that are launched as administrator, since those processes are in fact created by the <code>AppInfo</code> service, and so hooking its <code>CreateProcessInternalW</code> function is required. For details, refer to the blog post <a href="https://scorpiosoftware.net/2021/01/10/parent-process-vs-creator-process/">Parent Process vs. Creator Process</a> by Pavel Yosifovich.</li>
  <li><code>CreateRemoteThread</code> <a href="https://stackoverflow.com/questions/494284/createremotethread-32-64-and-or-64-32">doesn’t allow</a> creating a thread in a remote 64-bit process from a 32-bit process. <a href="https://github.com/rwfpl/rewolf-wow64ext">The wow64ext library</a> is used to overcome this limitation.</li>
  <li>In Windows 7, <code>CreateRemoteThread</code> fails if the target process is in a different session than the calling process. A workaround is <a href="https://securityxploded.com/ntcreatethreadex.php">to use <code>NtCreateThreadEx</code> instead</a>.</li>
  <li>To intercept new process creation, <code>CreateProcessInternalW</code> is hooked. Looks like all documented process creation functions end up calling it:
    <ul>
      <li><code>CreateProcessA</code> → <code>CreateProcessInternalA</code> → <code>CreateProcessInternalW</code></li>
      <li><code>CreateProcessW</code> → <code>CreateProcessInternalW</code></li>
      <li><code>CreateProcessAsUserA</code> → <code>CreateProcessInternalA</code> → <code>CreateProcessInternalW</code></li>
      <li><code>CreateProcessAsUserW</code> → <code>CreateProcessInternalW</code></li>
    </ul>
  </li>
  <li><a href="https://github.com/TsudaKageyu/minhook">The MinHook library</a> is used for hooking the <code>CreateProcessInternalW</code>, <code>MessageBoxW</code> functions.</li>
  <li>After being injected, the DLL waits for an event to be signaled, then unloads itself.</li>
  <li>Refer to the repository’s README file for compiling and running instructions.</li>
</ul>

<p>At first glance, it seemed to be working nicely and looked pretty much complete. But upon a closer inspection and after some careful testing, I found that there are several limitations that have to be addressed.</p>

<h2 id="inaccessible-processes-and-broken-injection-chains">Inaccessible processes and broken injection chains</h2>

<p>Even when the injection program is running as administrator, and even when debug privilege is enabled, there are processes which are out of reach. Several core system processes in Windows are marked as Protected Processes, and as the name implies, they’re protected from tampering and the injection program can’t inject the DLL into them. That’s not a problem by itself, these processes are protected for a reason and I’m OK with not being able to fiddle with them. The real problem is that because they’re protected, <code>CreateProcessInternalW</code> is not hooked and there’s no opportunity to inject the DLL into processes created by protected processes, even if the created processes are not themselves protected.</p>

<p><img src="https://m417z.com/images/Implementing-Global-Injection-and-Hooking-in-Windows/A-chart-showing-a-protected-versus-a-non-protected-parent-process.png" alt="A chart showing a protected versus a non-protected parent process" width="401px"/></p>

<p>For example, you can see on the screenshot below that <code>services.exe</code> is a protected process. As a result, the DLL won’t be injected into child <code>svchost.exe</code> processes which are launched after the injection program. <code>svchost.exe</code> processes which were already running are handled by the process enumeration.</p>

<p><img src="https://m417z.com/images/Implementing-Global-Injection-and-Hooking-in-Windows/A-screenshot-of-a-process-list-with-services.exe.png" alt="A screenshot of a process list with services.exe"/></p>

<p>A similar problem exists when the injection program is not running as administrator - it can’t inject the DLL into elevated processes, which is a security limitation and that’s OK, but it also loses the opportunity to inject into unelevated processes created by elevated processes.</p>

<p>For example, in the screenshot below Windows Explorer was restarted via the Task Manager. The new <code>explorer.exe</code> process was created by <code>winlogon.exe</code>, which is elevated.</p>

<p><img src="https://m417z.com/images/Implementing-Global-Injection-and-Hooking-in-Windows/A-screenshot-of-a-process-list-with-explorer.exe.png" alt="A screenshot of a process list with explorer.exe"/></p>

<p>Another common example where an elevated process creates an unelevated process is when a process crashes. See the screenshot below from the presentation <a href="https://msrnd-cdn-stor.azureedge.net/bluehat/bluehatil/2019/assets/doc/Exploiting%20Errors%20in%20Windows%20Error%20Reporting.pdf">Exploiting Errors in Windows Error Reporting</a> by Gal De Leon. In this case, the injection program misses the opportunity to inject the DLL into <code>WerFault.exe</code> which is unelevated. <code>WerFault.exe</code> may in turn <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-registerapplicationrestart">restart the crashed program</a>, and it will be missed as well.</p>

<p><img src="https://m417z.com/images/Implementing-Global-Injection-and-Hooking-in-Windows/Presentation-screenshot---what-happens-when-a-process-crashes.png" alt="Presentation screenshot - what happens when a process crashes"/></p>

<p>The solution that I came up with is to make the injection program monitor for new process creation, and for each newly created process, try to inject into it from the injection program.</p>

<p>If the new process was created by an inaccessible process, the injection program injects the DLL, as depicted below.</p>

<p><img src="https://m417z.com/images/Implementing-Global-Injection-and-Hooking-in-Windows/A-chart-showing-the-DLL-being-injected-by-the-injection-program.png" alt="A chart showing the DLL being injected by the injection program" width="401px"/></p>

<p>If, on the other hand, the new process was created by a process with an injected DLL, there’s a race between the creating process and the injection program. I used a mutex to make sure only one of them injects the DLL, as depicted below.</p>

<p><img src="https://m417z.com/images/Implementing-Global-Injection-and-Hooking-in-Windows/A-chart-showing-the-DLL-being-injected-with-a-race.png" alt="A chart showing the DLL being injected with a race" width="401px"/></p>

<p>This approach works, but it has a serious drawback - if the new process is created by an inaccessible process, the DLL is injected asynchronously, possibly after the new process begins running, which might be too late depending on the customization use case. Unfortunately, I didn’t find a better solution, and because this problem is not very common (especially if the injection program is running as administrator), it’s not too bad.</p>

<p>Also, this solution created a new problem which is described below, which was happening when the injection program injected the DLL too early.</p>

<h2 id="too-early-injections-that-break-stuff">Too early injections that break stuff</h2>

<p>After implementing the solution above, I noticed that sometimes, new processes failed to start. After a bit of investigation, I saw that it only happened with console programs. And after more investigation, I found the root cause.</p>

<p>All user mode threads begin their execution in the <code>LdrInitializeThunk</code> function. The first thread that a process runs performs process initialization tasks before the execution is transferred to the user-supplied thread entry point. One of the process initialization tasks is creating the console window in case the process is a console process. For more details about the <code>LdrInitializeThunk</code> function, check out <a href="http://www.nynaeve.net/?p=205">this blog post</a> by Ken Johnson.</p>

<p>Normally, a new process starts with a single, suspended thread. Then, the Client/Server Runtime Subsystem (<code>csrss.exe</code>) gets notified about the new process that was just created, and does its own handling. Finally, the suspended thread is resumed, the <code>LdrInitializeThunk</code> function performs process initialization tasks and transfers the execution to the process entry point.</p>

<p>With the injection program injecting the DLL too early, the new process starts with a single, suspended thread, as usual. But before the Client/Server Runtime Subsystem (<code>csrss.exe</code>) gets notified about it, the injection program creates a new thread in the new process which starts executing right away (marked with red in the image below). As the first running thread, it performs the process initialization tasks. Only then, <code>csrss.exe</code> gets notified about the new process, but it doesn’t expect the process to have an initialized console, and returns an error.</p>

<p><img src="https://m417z.com/images/Implementing-Global-Injection-and-Hooking-in-Windows/A-chart-showing-the-flow-of-a-too-early-injection.png" alt="A chart showing the flow of a too early injection" width="633px"/></p>

<p>To overcome this and other potential problems caused by the early injected thread execution, I switched from creating a new thread with <code>CreateRemoteThread</code> to queuing an APC (Asynchronous Procedure Call) in cases when the process didn’t start executing yet. For a great technical blog post about APCs check out <a href="https://repnz.github.io/posts/apc/user-apc/">APC Series: User APC API</a> by Ori Damari. A couple of notes about the implementation:</p>

<ul>
  <li>The undocumented <code>NtQueueApcThread</code> function is used, since the documented <code>QueueUserAPC</code> function is not suited for inter-process APC queuing because of the activation context handling.</li>
  <li><code>NtQueueApcThread</code> doesn’t allow queuing an APC in a remote 64-bit process from a 32-bit process. <a href="https://github.com/rwfpl/rewolf-wow64ext">The wow64ext library</a> is used to overcome this limitation.</li>
  <li>For queuing an APC in a remote 32-bit process from a 64-bit process, the address parameter has to be encoded. I used the <a href="https://repnz.github.io/posts/apc/wow64-user-apc/">APC Series: KiUserApcDispatcher and Wow64</a> blog post by Ori Damari as a reference.</li>
</ul>

<p>But how does the injection program know whether the process started executing (and then <code>CreateRemoteThread</code> is used as before) or not (and then an APC is queued)? It checks whether there’s only a single thread, and if so, whether it’s suspended with the instruction pointer at <code>RtlUserThreadStart</code>. In that case it concludes that the process didn’t start executing and queues an APC instead of creating a remote thread.</p>

<h2 id="supporting-uwp-apps">Supporting UWP apps</h2>

<p>The next thing I noticed is that the DLL wasn’t getting injected into processes of UWP apps such as Windows Calculator. The code to load the DLL was being injected successfully, but the DLL failed to load with <code>ERROR_ACCESS_DENIED</code>. The problem was that UWP apps have limited access to the filesystem and they didn’t have permissions to load the DLL. Changing the DLL file permissions fixed this issue. For example, the following commands can be used to change the DLL file permissions such that UWP apps are able to load it:</p>

<div><div><pre><code>icacls global-inject-lib.dll /grant everyone:RX
icacls global-inject-lib.dll /grant *S-1-15-2-1:RX
icacls global-inject-lib.dll /grant *S-1-15-2-2:RX
</code></pre></div></div>

<p>Another problem was that a mutex can’t be shared between the injection program and UWP apps by using the same mutex name. UWP apps are sandboxed, and each UWP app has its own object directory. A UWP app can’t refer to objects outside of its object directory by name. I was able to overcome this limitation by using the little-known <a href="https://docs.microsoft.com/en-us/windows/win32/api/namespaceapi/nf-namespaceapi-createprivatenamespacew">private namespaces API</a>. For a great overview of named objects in Windows, including the UWP sandboxing and private namespaces, check out the blog post <a href="https://www.tiraniddo.dev/2019/02/a-brief-history-of-basenamedobjects-on.html">A Brief History of BaseNamedObjects on Windows NT</a> by James Forshaw.</p>

<h2 id="process-mitigation-policy-and-system-errors">Process mitigation policy and system errors</h2>

<p>Another case in which the DLL wasn’t getting injected into processes was for processes with a mitigation policy that restricts image loading to images that are signed. On my test Windows 10 machine there were two such processes: <code>fontdrvhost.exe</code> and <code>svchost.exe</code> which hosts the <code>DiagTrack</code> service (<code>diagtrack.dll</code>).</p>

<p><img src="https://m417z.com/images/Implementing-Global-Injection-and-Hooking-in-Windows/A-screenshot-of-fontdrvhost.exe-mitigation-policies.png" alt="A screenshot of fontdrvhost.exe mitigation policies"/></p>

<p>Similarly to the UWP case, the code to load the DLL was being injected successfully, but the DLL failed to load, this time with <code>ERROR_INVALID_IMAGE_HASH</code>. But unlike the UWP case, there’s no straightforward workaround. I could try and use <a href="https://github.com/stephenfewer/ReflectiveDLLInjection">reflective DLL injection</a> (manually loading the DLL from memory), but I didn’t bother since it complicates the solution and might have pitfalls for the little benefit of being able to customize programs which are not very interesting anyway.</p>

<p>I was OK with not being able to customize programs with this mitigation, but this limitation had an unpleasant side effect. In some cases, Windows was displaying a system error when the DLL loading failed:</p>

<p><img src="https://m417z.com/images/Implementing-Global-Injection-and-Hooking-in-Windows/A-screenshot-of-a-bad-image-system-error.png" alt="A screenshot of a bad image system error"/></p>

<p>The system error can be reproduced by running the following program and then running the injection program:</p>

<div><div><pre><code><span>#include &lt;windows.h&gt;
</span>
<span>int</span> <span>WINAPI</span> <span>WinMain</span><span>(</span>
    <span>HINSTANCE</span> <span>hInstance</span><span>,</span>
    <span>HINSTANCE</span> <span>hPrevInstance</span><span>,</span>
    <span>LPSTR</span>     <span>lpCmdLine</span><span>,</span>
    <span>int</span>       <span>nShowCmd</span>
<span>)</span>
<span>{</span>
    <span>PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY</span> <span>p</span> <span>=</span> <span>{</span> <span>0</span> <span>};</span>
    <span>p</span><span>.</span><span>MicrosoftSignedOnly</span> <span>=</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span><span>SetProcessMitigationPolicy</span><span>(</span><span>ProcessSignaturePolicy</span><span>,</span> <span>&amp;</span><span>p</span><span>,</span> <span>sizeof</span><span>(</span><span>p</span><span>)))</span> <span>{</span>
        <span>MessageBox</span><span>(</span><span>NULL</span><span>,</span> <span>L&#34;Mitigation applied, press OK to exit&#34;</span><span>,</span> <span>L&#34;&#34;</span><span>,</span> <span>MB_OK</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>After some investigation, I found that this behavior can be controlled with the <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-seterrormode"><code>SetErrorMode</code></a>, <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setthreaderrormode"><code>SetThreadErrorMode</code></a> WinAPI functions. I used <code>SetThreadErrorMode</code> to turn off the critical-error-handler message box while trying to load the DLL.</p>

<h2 id="hooking-performance">Hooking performance</h2>

<p>After handling all of the limitations above, the solution felt pretty solid and I didn’t encounter any other problems. But after using the computer with it for a while, I noticed that it takes noticeably longer for some programs to launch. The reason for this was that <a href="https://github.com/TsudaKageyu/minhook">MinHook</a>, the hooking library that I used, <a href="https://github.com/TsudaKageyu/minhook/blob/4a455528f61b5a375b1f9d44e7d296d47f18bb18/src/hook.c#L263-L324">enumerates all the threads on the system</a> and looks for threads that belong to the current process to suspend them. Enumerating all system threads can be very slow, on my system it took more than 300 milliseconds. I improved this by doing the following:</p>

<ul>
  <li>Instead of enumerating all threads on the system, I use the undocumented <code>NtGetNextThread</code> function to directly enumerate threads that belong to the current process. In addition to improving performance, it also improves stability by avoiding race conditions. For a comprehensive overview, check out the <a href="https://github.com/diversenok/Suspending-Techniques#snapshot--suspend-threads-not-covered">Suspending Techniques</a> research by diversenok.</li>
  <li>When injecting into a process which didn’t start executing yet, I skip the thread enumeration altogether, since there should be no other running threads anyway.</li>
</ul>

<p>You can find the code that enables this in my <a href="https://github.com/m417z/minhook/tree/multihook">MinHook multihook branch</a>. Among other changes the branch has is the ability for a function to be hooked more than once. In general, I found that reliable function hooking is more tricky than it might seem at first. For example, consider what happens if a DLL sets a hook and then needs to be unloaded. When is it safe to unload it? Can you be sure? But that’s a topic for another post.</p>

<h2 id="implementation-code-and-summary">Implementation code and summary</h2>

<p>An implementation that handles all the limitations mentioned in this post can be found <a href="https://github.com/m417z/global-inject-demo">here</a>. I’m pretty satisfied with the result. I’ve been using my computer with <a href="https://windhawk.net/">Windhawk</a>, which uses this global injection and hooking implementation, for several months, and I didn’t experience any stability, performance, or any other problems. I hope that Windhawk will prove itself as a reliable tool for customizing Windows programs, and I invite you to try it out.</p>

  </div></div>
  </body>
</html>
