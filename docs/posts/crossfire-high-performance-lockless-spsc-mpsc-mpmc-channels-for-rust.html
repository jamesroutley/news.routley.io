<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/frostyplanet/crossfire-rs">Original</a>
    <h1>Crossfire: High-performance lockless spsc/mpsc/mpmc channels for Rust</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a href="https://github.com/frostyplanet/crossfire-rs/actions"><img src="https://github.com/frostyplanet/crossfire-rs/workflows/Rust/badge.svg" alt="Build Status"/></a>
<a href="https://github.com/qignstor/crossfire-rs#license"><img src="https://camo.githubusercontent.com/45104af6ffc0a9d568fe2d3981931a1edbb53608cf190d86fc360a8b53c10310/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4d49542532304f522532304170616368652d2d322e302d626c75652e737667" alt="License" data-canonical-src="https://img.shields.io/badge/license-MIT%20OR%20Apache--2.0-blue.svg"/></a>
<a href="https://crates.io/crates/crossfire" rel="nofollow"><img src="https://camo.githubusercontent.com/221ae153ce6446ed4499ce7e24c0ef24cfc1b359048ea96108e652b9f73b8317/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f762f63726f7373666972652e737667" alt="Cargo" data-canonical-src="https://img.shields.io/crates/v/crossfire.svg"/></a>
<a href="https://docs.rs/crossfire" rel="nofollow"><img src="https://camo.githubusercontent.com/31356330539260c3751b1555afa45271f2da1a386929a91ad16313bd197f1485/68747470733a2f2f646f63732e72732f63726f7373666972652f62616467652e737667" alt="Documentation" data-canonical-src="https://docs.rs/crossfire/badge.svg"/></a>
<a href="https://www.rust-lang.org" rel="nofollow"><img src="https://camo.githubusercontent.com/eb64b9823a7586ad0b01bed21b13e7153183256f9bde45e1ae1ea78ccd08b3d2/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f727573742d312e33362b2d6c69676874677261792e737667" alt="Rust 1.36+" data-canonical-src="https://img.shields.io/badge/rust-1.36+-lightgray.svg"/></a></p>
<p dir="auto">High-performance lockless spsc/mpsc/mpmc channels.</p>
<p dir="auto">It supports async contexts, and communication between async and blocking contexts.</p>
<p dir="auto">The low level is based on crossbeam-queue.</p>
<p dir="auto">For the concept, please refer to the <a href="https://github.com/frostyplanet/crossfire-rs/wiki">wiki</a>.</p>

<ul dir="auto">
<li>
<p dir="auto">V1.0: Released in 2022.12 and used in production.</p>
</li>
<li>
<p dir="auto">V2.0: Released in 2025.6. Refactored the codebase and API
by removing generic types from the ChannelShared type, which made it easier to code with.</p>
</li>
<li>
<p dir="auto">v2.1: Released in 2025.9. Removed the dependency on crossbeam-channel and
implemented with a <a href="https://github.com/frostyplanet/crossfire-rs/wiki/crossbeam-related">modified version of crossbeam-queue</a>, which brings performance
improvements for both async and blocking contexts.</p>
</li>
</ul>

<p dir="auto">Being a lockless channel, crossfire outperforms other async-capable channels.
And thanks to a lighter notification mechanism, in a blocking context, some cases are even
better than the original crossbeam-channel,</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/frostyplanet/crossfire-rs/wiki/images/benchmark-2.1.0-2025-09-21/mpsc_size_100_sync.png"><img src="https://github.com/frostyplanet/crossfire-rs/wiki/images/benchmark-2.1.0-2025-09-21/mpsc_size_100_sync.png" alt="mpsc bounded size 100 blocking context"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/frostyplanet/crossfire-rs/wiki/images/benchmark-2.1.0-2025-09-21/mpmc_size_100_sync.png"><img src="https://github.com/frostyplanet/crossfire-rs/wiki/images/benchmark-2.1.0-2025-09-21/mpmc_size_100_sync.png" alt="mpmc bounded size 100 blocking context"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/frostyplanet/crossfire-rs/wiki/images/benchmark-2.1.0-2025-09-21/mpsc_size_100_tokio.png"><img src="https://github.com/frostyplanet/crossfire-rs/wiki/images/benchmark-2.1.0-2025-09-21/mpsc_size_100_tokio.png" alt="mpsc bounded size 100 async context"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/frostyplanet/crossfire-rs/wiki/images/benchmark-2.1.0-2025-09-21/mpmc_size_100_tokio.png"><img src="https://github.com/frostyplanet/crossfire-rs/wiki/images/benchmark-2.1.0-2025-09-21/mpmc_size_100_tokio.png" alt="mpmc bounded size 100 async context"/></a></p>
<p dir="auto">More benchmark data is posted on <a href="https://github.com/frostyplanet/crossfire-rs/wiki/benchmark-v2.1.0-vs-v2.0.26-2025%E2%80%9009%E2%80%9021">wiki</a>.</p>
<p dir="auto">Also, being a lockless channel, the algorithm relies on spinning and yielding. Spinning is good on
multi-core systems, but not friendly to single-core systems (like virtual machines).
So we provide a function <code>detect_backoff_cfg()</code> to detect the running platform.
Calling it within the initialization section of your code, will get a 2x performance boost on VPS.</p>
<p dir="auto">The benchmark is written in the criterion framework. You can run the benchmark by:</p>
<div data-snippet-clipboard-copy-content="cargo bench --bench crossfire"><pre><code>cargo bench --bench crossfire
</code></pre></div>

<p dir="auto"><strong>NOTE</strong>: Because v2.1 has push the speed to a level no one has gone before,
it can put a pure pressure to the async runtime.
Some hidden bug (especially atomic ops on weaker ordering platform) might occur:</p>
<markdown-accessiblity-table><table>
<tbody><tr><th>arch</th><th>runtime</th><th>workflow</th><th>status</th></tr>
<tr>
<td rowspan="4">x86_64</td>
<td>threaded</td>
<td><a href="https://github.com/frostyplanet/crossfire-rs/actions/workflows/cron_master_threaded_x86.yml">cron_master_threaded_x86</a> </td>
<td>STABLE</td>
</tr>
<tr><td>tokio 1.47.1</td>
<td><a href="https://github.com/frostyplanet/crossfire-rs/actions/workflows/cron_master_tokio_x86.yml">cron_master_tokio_x86</a></td>
<td>STABLE<br/>
</td>
</tr>
<tr><td>async-std</td>
<td><a href="https://github.com/frostyplanet/crossfire-rs/actions/workflows/cron_master_async_std_x86.yml">cron_master_async_std_x86</a></td>
<td>STABLE</td>
</tr>
<tr><td>smol</td>
<td><a href="https://github.com/frostyplanet/crossfire-rs/actions/workflows/cron_master_smol_x86.yml">cron_master_smol-x86</a></td>
<td>STABLE</td>
</tr><tr><td rowspan="4">arm</td>
<td>threaded</td>
<td>
<a href="https://github.com/frostyplanet/crossfire-rs/actions/workflows/cron_master_threaded_arm.yml">cron_master_threaded_arm</a><br/>
</td>
<td>STABLE</td>
</tr>
<tr>
<td>tokio &gt;= 1.48 (<a href="https://github.com/tokio-rs/tokio/pull/7622" data-hovercard-type="pull_request" data-hovercard-url="/tokio-rs/tokio/pull/7622/hovercard">tokio PR #7622</a>)
</td>
<td>
<a href="https://github.com/frostyplanet/crossfire-rs/actions/workflows/cron_master_tokio_arm.yml">cron_master_tokio_arm</a><br/>
</td>
<td> SHOULD UPGRADE tokio to 1.48</td>
</tr>
<tr>
<td>async-std</td>
<td><a href="https://github.com/frostyplanet/crossfire-rs/actions/workflows/cron_master_async_std_arm.yml">cron_master_async_std_arm</a></td>
<td>STABLE</td>
</tr>
<tr>
<td>smol</td>
<td><a href="https://github.com/frostyplanet/crossfire-rs/actions/workflows/cron_master_smol_arm.yml">cron_master_smol_arm</a> </td>
<td>STABLE</td>
</tr>
<tr>
<td rowspan="4">miri (emulation)</td>
<td>threaded</td>
<td rowspan="2"><a href="https://github.com/frostyplanet/crossfire-rs/actions/workflows/miri_tokio.yml">miri_tokio</a></td>
<td>STABLE</td>
</tr>
<tr><td>tokio</td><td>still verifying </td>
</tr>
<tr><td>async-std</td><td>-</td> <td> (timerfd_create) not supported by miri </td>
</tr>
<tr><td>smol</td><td>-</td> <td> (timerfd_create) not supported by miri </td>
</tr>
</tbody></table></markdown-accessiblity-table>
<p dir="auto">v2.0.26 (legacy):</p>
<markdown-accessiblity-table><table>
<tbody><tr><th>arch</th><th>runtime</th><th>workflow</th><th>status</th></tr>
<tr>
<td rowspan="3">x86_64</td>
<td>threaded</td>
<td rowspan="3">
<a href="https://github.com/frostyplanet/crossfire-rs/actions/workflows/cron_2.0_x86.yml">cron_2.0_x86</a></td>
<td rowspan="3">PASSED</td>
</tr>
<tr><td>tokio 1.47.1</td>
</tr>
<tr><td>async-std</td>
</tr>
<tr><td rowspan="3">arm</td>
<td>threaded</td>
<td rowspan="3">
<a href="https://github.com/frostyplanet/crossfire-rs/actions/workflows/cron_2.0_arm.yml">cron_2.0_arm</a>
</td>
<td rowspan="3">PASSED</td>
</tr><tr>
<td>tokio-1.47.1</td>
</tr>
<tr><td>async-std</td>
</tr>
</tbody></table></markdown-accessiblity-table>

<p dir="auto"><strong>Debug locally</strong>:</p>
<p dir="auto">Use <code>--features trace_log</code> to run the bench or test until it hangs, then press <code>ctrl+c</code> or send <code>SIGINT</code>,  there will be latest log dump to /tmp/crossfire_ring.log (refer to tests/common.rs <code>_setup_log()</code>)</p>
<p dir="auto"><strong>Debug with github workflow</strong>:  <a data-error-text="Failed to load title" data-id="3390877531" data-permission-text="Title is private" data-url="https://github.com/frostyplanet/crossfire-rs/issues/37" data-hovercard-type="issue" data-hovercard-url="/frostyplanet/crossfire-rs/issues/37/hovercard" href="https://github.com/frostyplanet/crossfire-rs/issues/37">#37</a></p>


<p dir="auto">There are 3 modules: <a href="https://docs.rs/crossfire/latest/crossfire/spsc/index.html" rel="nofollow">spsc</a>, <a href="https://docs.rs/crossfire/latest/crossfire/mpsc/index.html" rel="nofollow">mpsc</a>, <a href="https://docs.rs/crossfire/latest/crossfire/mpmc/index.html" rel="nofollow">mpmc</a>, providing functions to allocate different types of channels.</p>
<p dir="auto">The SP or SC interface is only for non-concurrent operation. It&#39;s more memory-efficient than MP or MC implementations, and sometimes slightly faster.</p>
<p dir="auto">The return types in these 3 modules are different:</p>
<ul dir="auto">
<li>
<p dir="auto">mpmc::bounded_blocking() : (tx blocking, rx blocking)</p>
</li>
<li>
<p dir="auto">mpmc::bounded_async() :  (tx async, rx async)</p>
</li>
<li>
<p dir="auto">mpmc::bounded_tx_async_rx_blocking() : (tx async, rx blocking)</p>
</li>
<li>
<p dir="auto">mpmc::bounded_tx_blocking_rx_async() : (tx blocking, rx async)</p>
</li>
<li>
<p dir="auto">mpmc::unbounded_blocking() : (tx non-blocking, rx blocking)</p>
</li>
<li>
<p dir="auto">mpmc::unbounded_async() : (tx non-blocking, rx async)</p>
</li>
</ul>
<blockquote>
<p dir="auto"><strong>NOTE</strong> :  For a bounded channel, a 0 size case is not supported yet. (Temporary rewrite as 1 size).</p>
</blockquote>

<markdown-accessiblity-table><table>
<tbody><tr> <th rowspan="2"> Context </th><th colspan="2"> Sender (Producer) </th> <th colspan="2"> Receiver (Consumer) </th> </tr>
<tr> <td> Single </td> <td> Multiple </td><td> Single </td><td> Multiple </td></tr>
<tr><td rowspan="2"> <b>Blocking</b> </td>
<td colspan="2"> BlockingTxTrait </td>
<td colspan="2"> BlockingRxTrait </td></tr>
<tr>
<td>Tx </td>
<td>MTx</td>
<td>Rx</td>
<td>MRx</td> </tr>
<tr><td rowspan="2"><b>Async</b></td>
<td colspan="2">AsyncTxTrait</td>
<td colspan="2">AsyncRxTrait</td></tr>
<tr>
<td>AsyncTx</td>
<td>MAsyncTx</td>
<td>AsyncRx</td>
<td>MAsyncRx</td></tr>
</tbody></table></markdown-accessiblity-table>
<p dir="auto">For the SP / SC version, <code>AsyncTx</code>, <code>AsyncRx</code>, <code>Tx</code>, and <code>Rx</code> are not <code>Clone</code> and without <code>Sync</code>.
Although can be moved to other threads, but not allowed to use send/recv while in an Arc.
(Refer to the compile_fail examples in the type document).</p>
<p dir="auto">The benefit of using the SP / SC API is completely lockless waker registration, in exchange for a performance boost.</p>
<p dir="auto">The sender/receiver can use the <code>From</code> trait to convert between blocking and async context
counterparts.</p>

<p dir="auto">Error types are the same as crossbeam-channel:  <code>TrySendError</code>, <code>SendError</code>, <code>TryRecvError</code>, <code>RecvError</code></p>

<ul dir="auto">
<li>
<p dir="auto"><code>tokio</code>: Enable send_timeout, recv_timeout API for async context, based on <code>tokio</code>. And will
detect the right backoff strategy for the type of runtime (multi-threaded / current-thread).</p>
</li>
<li>
<p dir="auto"><code>async_std</code>: Enable send_timeout, recv_timeout API for async context, based on <code>async-std</code>.</p>
</li>
</ul>

<p dir="auto">Tested on tokio-1.x and async-std-1.x, crossfire is runtime-agnostic.</p>
<p dir="auto">The following scenarios are considered:</p>
<ul dir="auto">
<li>
<p dir="auto">The <code>AsyncTx::send()</code> and <code>AsyncRx:recv()</code> operations are <strong>cancellation-safe</strong> in an async context.
You can safely use the select! macro and timeout() function in tokio/futures in combination with recv().
On cancellation, [SendFuture] and [RecvFuture] will trigger drop(), which will clean up the state of the waker,
making sure there is no mem-leak and deadlock.
But you cannot know the true result from SendFuture, since it&#39;s dropped
upon cancellation. Thus, we suggest using <code>AsyncTx::send_timeout()</code> instead.</p>
</li>
<li>
<p dir="auto">When the &#34;tokio&#34; or &#34;async_std&#34; feature is enabled, we also provide two additional functions:</p>
</li>
</ul>
<ul dir="auto">
<li>
<p dir="auto"><code>AsyncTx::send_timeout()</code>, which will return the message that failed to be sent in
[SendTimeoutError]. We guarantee the result is atomic.
Alternatively, you can use <code>AsyncTx::send_with_timer()</code>.</p>
</li>
<li>
<p dir="auto"><code>AsyncRx::recv_timeout()</code>, we guarantee the result is atomic.
Alternatively, you can use <code>crate::AsyncRx::recv_with_timer()</code>.</p>
</li>
</ul>
<ul dir="auto">
<li>
<p dir="auto">Between blocking context and async context, and between different async runtime instances.</p>
</li>
<li>
<p dir="auto">The async waker footprint.</p>
</li>
</ul>
<p dir="auto">When using a multi-producer and multi-consumer scenario, there&#39;s a small memory overhead to pass along a <code>Weak</code>
reference of wakers.
Because we aim to be lockless, when the sending/receiving futures are canceled (like tokio::time::timeout()),
it might trigger an immediate cleanup if the try-lock is successful, otherwise will rely on lazy cleanup.
(This won&#39;t be an issue because weak wakers will be consumed by actual message send and recv).
On an idle-select scenario, like a notification for close, the waker will be reused as much as possible
if poll() returns pending.</p>

<p dir="auto">Cargo.toml:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[dependencies]
crossfire = &#34;2.1&#34;"><pre>[<span>dependencies</span>]
<span>crossfire</span> = <span><span>&#34;</span>2.1<span>&#34;</span></span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="extern crate crossfire;
use crossfire::*;
#[macro_use]
extern crate tokio;
use tokio::time::{sleep, interval, Duration};

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::bounded_async::&lt;i32&gt;(100);
    for _ in 0..10 {
        let _tx = tx.clone();
        tokio::spawn(async move {
            for i in 0i32..10 {
                let _ = _tx.send(i).await;
                sleep(Duration::from_millis(100)).await;
                println!(&#34;sent {}&#34;, i);
            }
        });
    }
    drop(tx);
    let mut inv = tokio::time::interval(Duration::from_millis(500));
    loop {
        tokio::select! {
            _ = inv.tick() =&gt;{
                println!(&#34;tick&#34;);
            }
            r = rx.recv() =&gt; {
                if let Ok(_i) = r {
                    println!(&#34;recv {}&#34;, _i);
                } else {
                    println!(&#34;rx closed&#34;);
                    break;
                }
            }
        }
    }
}"><pre><span>extern</span> <span>crate</span> crossfire<span>;</span>
<span>use</span> crossfire<span>::</span><span>*</span><span>;</span>
<span>#<span>[</span>macro_use<span>]</span></span>
<span>extern</span> <span>crate</span> tokio<span>;</span>
<span>use</span> tokio<span>::</span>time<span>::</span><span>{</span>sleep<span>,</span> interval<span>,</span> <span>Duration</span><span>}</span><span>;</span>

<span>#<span>[</span>tokio<span>::</span>main<span>]</span></span>
<span>async</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> <span>(</span>tx<span>,</span> rx<span>)</span> = mpsc<span>::</span><span>bounded_async</span><span>::</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>(</span><span>100</span><span>)</span><span>;</span>
    <span>for</span> _ <span>in</span> <span>0</span>..<span>10</span> <span>{</span>
        <span>let</span> _tx = tx<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
        tokio<span>::</span><span>spawn</span><span>(</span><span>async</span> <span>move</span> <span>{</span>
            <span>for</span> i <span>in</span> <span>0i32</span>..<span>10</span> <span>{</span>
                <span>let</span> _ = _tx<span>.</span><span>send</span><span>(</span>i<span>)</span><span>.</span><span>await</span><span>;</span>
                <span>sleep</span><span>(</span><span>Duration</span><span>::</span><span>from_millis</span><span>(</span><span>100</span><span>)</span><span>)</span><span>.</span><span>await</span><span>;</span>
                <span>println</span><span>!</span><span>(</span><span>&#34;sent {}&#34;</span><span>,</span> i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    <span>drop</span><span>(</span>tx<span>)</span><span>;</span>
    <span>let</span> <span>mut</span> inv = tokio<span>::</span>time<span>::</span><span>interval</span><span>(</span><span>Duration</span><span>::</span><span>from_millis</span><span>(</span><span>500</span><span>)</span><span>)</span><span>;</span>
    <span>loop</span> <span>{</span>
        tokio<span>::</span>select! <span>{</span>
            _ = inv<span>.</span>tick<span>(</span><span>)</span> =&gt;<span>{</span>
                println!<span>(</span><span>&#34;tick&#34;</span><span>)</span><span>;</span>
            <span>}</span>
            r = rx<span>.</span>recv<span>(</span><span>)</span> =&gt; <span>{</span>
                <span>if</span> <span>let</span> <span>Ok</span><span>(</span>_i<span>)</span> = r <span>{</span>
                    println!<span>(</span><span>&#34;recv {}&#34;</span><span>,</span> _i<span>)</span><span>;</span>
                <span>}</span> else <span>{</span>
                    println!<span>(</span><span>&#34;rx closed&#34;</span><span>)</span><span>;</span>
                    <span>break</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span></pre></div>
</article></div></div>
  </body>
</html>
