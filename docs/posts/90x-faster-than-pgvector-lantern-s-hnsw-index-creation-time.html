<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lantern.dev/blog/hnsw-index-creation">Original</a>
    <h1>90x Faster Than Pgvector – Lantern&#39;s HNSW Index Creation Time</h1>
    
    <div id="readability-page-1" class="page"><div><p><a href="https://github.com/lanterndata/lantern">Lantern</a> is a Postgres extension to enable performant vector search using an index. Lantern is built using <a href="https://github.com/unum-cloud/usearch/">Usearch</a>, an optimized C++ implementation of the <a href="https://arxiv.org/abs/1603.09320">HNSW algorithm</a>, the most performant algorithm for vector search.</p>
<p>In this post we discuss the significance of index creation times and how Lantern enables 90x faster index creation times than <a href="https://github.com/pgvector/pgvector">pgvector</a>, another popular vector search Postgres extension, using external indexing. We also compare Lantern&#39;s performance against <a href="https://pinecone.io">Pinecone</a>, a popular, closed-source hosted vector database.</p>
<h2 id="h2--316512533" level="2" siblingcount="51">Why fast index creation matters</h2>
<p>Index creation time affects how quickly a developer can add vector search to their data. On a single core, generating an index on 1 billion vectors could take days or even weeks.</p>
<p>It also affects how quickly a developer can experiment with different parameters to optimize their index. HNSW relies on two parameters for index construction:</p>
<ul>
<li>The <code>M</code> parameter controls the number of neighbors that each node in the graph will maintain. Higher values lead to longer construction times, longer query times, and higher memory usage, but result in a higher-quality index.</li>
<li>The <code>ef_construction</code> parameter determines how many nodes will be traversed during index construction. Higher values lead to longer construction times but result in a higher-quality index.</li>
</ul>
<p>Generally, there is a tradeoff between recall and latency. The ideal set of parameters requires experimentation to find. It depends on the application&#39;s recall / latency needs and the data itself (what recall is possible given the data distribution). This experimentation could become untenable with slow index creation times.</p>
<h2 id="h2-130942622" level="2" siblingcount="51">How external index creation enables parallelism</h2>
<p>With Postgres, HNSW index creation is single-threaded. This prevents the utilization of multiple cores to speed up index creation. In addition, the index creation process is resource-intensive, which can slow down other database operations. The latter would pose a problem even if HNSW index creation were multi-threaded.</p>
<p>Lantern allows developers to create an index externally, and then import the index as a file into their database. With external index creation, the core database remains unburdened during index creation, and the index can be created using multiple cores. This enables significant performance improvements.</p>
<p>Below we show the results of two sets of experiments with Lantern: one with index creation occurring inside Postgres, and one with index creation occurring externally. We compare Lantern&#39;s performance against pgvector and Pinecone.</p>
<h2 id="h2-11442535" level="2" siblingcount="51">Lantern&#39;s single-core index creation performance</h2>
<h3 id="h3--1383936870" level="3" index="12" siblingcount="51">Experiment Setup</h3>
<p>We use the following datasets</p>
<ul>
<li><a href="http://corpus-texmex.irisa.fr">sift</a> - 1 million vectors of 128 dimensions, downloadable <a href="https://storage.googleapis.com/lanterndata/datasets/sift_base1m.csv">here</a></li>
<li><a href="https://huggingface.co/datasets/KShivendu/dbpedia-entities-openai-1M">wiki</a> - 1 million vectors of 1536 dimensions generated using the <code>text-embedding-ada-002</code> model</li>
</ul>
<p>The experiments were run on a Linode instance with 32 Cores and 64GB of RAM.</p>
<p>The SQL to create a table, copy the data, and create the index using Lantern follows</p>
<div><div><pre tabindex="0"><code><span><span>CREATE</span><span> TABLE</span><span> wiki1m</span><span> (id </span><span>SERIAL</span><span>, v </span><span>REAL</span><span>[]);</span></span>
<span><span>COPY</span><span> wiki1m (v) </span><span>FROM</span><span> &#39;/tmp/wiki1m.csv&#39;</span><span> WITH</span><span> CSV;</span></span>
<span><span>CREATE</span><span> INDEX</span><span> ON</span><span> wiki1m </span><span>USING</span><span> hnsw (v) </span><span>WITH</span><span> (dim</span><span>=</span><span>128</span><span>, m</span><span>=</span><span>8</span><span>, ef_construction</span><span>=</span><span>128</span><span>, ef</span><span>=</span><span>128</span><span>);</span></span>
<span></span></code></pre></div></div>
<h3 id="h3-1395271028" level="3" index="18" siblingcount="51">Table: Index Creation Times for Sift</h3>
<table><thead><tr><th><p>Vector Database</p></th><th><p>Time</p></th><th><p>Vec/s</p></th></tr></thead><tbody><tr><td><p>Lantern</p></td><td><p>8m 30s</p></td><td><p>~1960 vec/s</p></td></tr><tr><td><p>Pinecone (p2x2 - 1 pod)</p></td><td><p>9m</p></td><td><p>~1818 vec/s</p></td></tr><tr><td><p>Pgvector</p></td><td><p>46m</p></td><td><p>~361 vec/s</p></td></tr></tbody></table>
<h3 id="h3-1395390336" level="3" index="20" siblingcount="51">Table: Index Creation Times for Wiki</h3>
<table><thead><tr><th><p>Vector Database</p></th><th><p>Time</p></th><th><p>Vec/s</p></th></tr></thead><tbody><tr><td><p>Lantern</p></td><td><p>44m</p></td><td><p>~382 vec/s</p></td></tr><tr><td><p>Pinecone (p2x2 - 1 pod)</p></td><td><p>30m</p></td><td><p>~555 vec/s</p></td></tr><tr><td><p>Pgvector</p></td><td><p>2h</p></td><td><p>~140 vec/s</p></td></tr></tbody></table>
<h3 id="h3--1973001272" level="3" index="22" siblingcount="51">Graph: Index Creation Speed</h3>
<p><img src="https://storage.googleapis.com/lantern-blog/2/2.svg" alt="Index Creation Speed (Single Core)"/></p>
<h2 id="h2--69255453" level="2" siblingcount="51">Using external index creation, Lantern is 90x faster than pgvector</h2>
<h3 id="h3-1281314467" level="3" index="25" siblingcount="51">Results Overview</h3>
<ul>
<li><strong>17x</strong> performance improvement compared to creating the index on a single thread.</li>
<li><strong>90x</strong> performance improvement compared to pgvector, and a <strong>6x</strong> improvement over Pinecone for sift dataset</li>
<li><strong>48x</strong> performance improvement over pgvector, as well as a <strong>3x</strong> improvement over Pinecone with 32 pods</li>
<li>Pinecone index on 32 p2 pods costs <strong>$3,889.44 / month</strong>. 32 CPU Linode costs <strong>$576 / month</strong>. Lantern is over <strong>6x cheaper and 6x faster!</strong></li>
</ul>
<h3 id="h3-792589141" level="3" index="27" siblingcount="51">Graph: Index Creation Speed with 32 Cores</h3>
<p><img src="https://storage.googleapis.com/lantern-blog/2/3.svg" alt="Index Creation Speed (Multi Core)"/></p>
<h3 id="h3-1171237270" level="3" index="29" siblingcount="51">Graph: Index Creation Speed with 2 - 32 Cores</h3>
<p><img src="https://storage.googleapis.com/lantern-blog/2/4.svg" alt="Index creation speed with Lantern Multi-Core Index"/></p>
<p>Fine-tuning the recall using parameters <code>m=16</code>, <code>ef_construction=128</code>, and <code>ef=128</code> for Lantern, we can achieve a 99% recall@5 for sift dataset, with the index creation taking only <strong>50 seconds</strong>.</p>
<p>Notice that a 2 Core Linode Server running Lantern outperforms Pinecone’s 32 pod cluster - this means that Lantern can be <strong>60x cheaper than Pinecone for the same performance.</strong></p>
<h2 id="h2--1139598294" level="2" siblingcount="51">External index creation with Lantern</h2>
<h3 id="h3--124802092" level="3" index="34" siblingcount="51">Implementation Details</h3>
<p>Here is a brief overview of how Lantern&#39;s external index creation works under the hood.</p>
<p>We use the row&#39;s <a href="https://www.postgresql.org/docs/current/ddl-system-columns.html#DDL-SYSTEM-COLUMNS-CTID"><code>ctid</code></a> as a label for our nodes during index creation. Later, this label is used to retrieve the actual row from Postgres, as it represents the physical location of the row.</p>
<p>We use Postgres&#39;s <a href="https://www.postgresql.org/docs/current/largeobjects.html">large object</a> functionality for data transfer. We use the <a href="https://www.postgresql.org/docs/current/lo-funcs.html"><code>lo_export</code></a> function to export the indexable data to the file system. After generating the index using <a href="https://github.com/unum-cloud/usearch/">Usearch</a> on the file system, we then use the <a href="https://www.postgresql.org/docs/current/lo-funcs.html"><code>lo_import</code></a> function to transfer the index file to the database server.</p>
<h3 id="h3-1922878868" level="3" index="38" siblingcount="51">How to use external index creation</h3>
<ol>
<li>Install the <a href="https://github.com/lanterndata/lantern_extras/tree/main#lantern-index-builder">Lantern CLI</a></li>
<li>Create an index from a regular Postgres table via the <code>create-index</code> utility</li>
</ol>
<p>Here is a walk through:</p>
<p>First, install the Lantern CLI:</p>
<div><div><pre tabindex="0"><code><span><span>cargo</span><span> install</span><span> --git</span><span> https://github.com/lanterndata/lantern_extras</span><span> --bin</span><span> lantern-cli</span></span>
<span></span></code></pre></div></div>
<p>Next, use the <code>create-index</code> utility to externally create and import our index to Postgres:</p>
<blockquote>
<p><em><strong>Note</strong>: If you encounter ONNXRuntime, issues, set up onnx runtime manually using <a href="https://github.com/lanterndata/lantern_extras?tab=readme-ov-file#building-from-source">these steps</a> and export the required env variables.</em></p>
</blockquote>
<div><div><pre tabindex="0"><code><span><span>lantern-cli</span><span> create-index</span><span> \</span></span>
<span><span>    --uri</span><span> postgresql://postgres@localhost:5432/testlive</span><span> \</span></span>
<span><span>    --table</span><span> sift</span><span> \</span></span>
<span><span>    --column</span><span> v</span><span> \</span></span>
<span><span>    -m</span><span> 8</span><span> \</span></span>
<span><span>    --efc</span><span> 128</span><span> \</span></span>
<span><span>    --ef</span><span> 64</span><span> \</span></span>
<span><span>    -d</span><span> 128</span><span> \</span></span>
<span><span>    --metric-kind</span><span> cos</span><span> \</span></span>
<span><span>    --out</span><span> index.usearch</span><span> \</span></span>
<span><span>    --import</span></span>
<span></span></code></pre></div></div>
<p>The <code>--uri</code> parameter specifies the database connection URI, and the <code>--table</code> and <code>--column</code> parameters specify the table and column to index. The index parameters are <code>-m</code>, <code>--efc</code>, <code>--ef</code>, <code>-d</code> (dimension of column), and <code>--metric-kind</code> (<code>l2sq</code>, <code>cos</code>, or <code>hamming</code>). The <code>--out</code> parameter specifies the output file name. If <code>--import</code> is also specified, the externally created index will be automatically imported to Postgres after creation, and the temporary output file will be removed.</p>
<p>The table will be exclusively locked during the index creation process to avoid inconsistency. To reindex the data, use <code>select lantern_reindex_external_index(&#39;&lt;index_name&gt;&#39;)</code>; if you have <code>lantern_extras</code> extension installed in your database, or use the same CLI command as above and provide the <code>--index-name</code> argument. In the latter case, the existing index will be dropped and a new one will be created.</p>
<h2 id="h2-262204991" level="2" siblingcount="51">Conclusion</h2>
<p>In this post, we discussed the significance of index creation times, Lantern&#39;s external indexing process, and shared our benchmarking results against pgvector and Pinecone.</p>
<p>For a deeper dive into the code, you can check out our <a href="https://github.com/lanterndata/lantern">core repo</a> or the <a href="https://github.com/lanterndata/lantern_extras">Lantern Extras repo</a>. Our core repo enables vector search in Postgres, while Lantern Extras provides routines for external index generation and embedding management.</p></div></div>
  </body>
</html>
