<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://herbsutter.com/2022/09/25/something-i-implemented-today-is-void/">Original</a>
    <h1>Something I implemented today: “is void”</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p><em>[Edited to add pre-publication link to next draft of P2392, revision 2]</em></p>



<h2>Brief background</h2>



<p>As I presented at <a href="https://youtu.be/raB_289NxBk?t=675">CppCon 2021 starting at 11:15</a>, I’m proposing <code>is</code> (a general type or value query) and <code>as</code> (a general cast, for only the safe casts) for C++ evolution. The talk, and the ISO C++ evolution paper <a href="https://wg21.link/p2392">P2392</a> it’s based on, explained why I hope that <code>is</code> and <code>as</code> can provide a general mechanism to power pattern matching with <code>inspect</code>, while conversely also liberating the power of pattern matching beyond just <code>inspect</code> for use generally in the language (e.g., in <code>requires</code> clauses, in general code). Here’s the key slide from last year, that I cited again in this year’s talk:</p>



<figure><a href="https://herbsutter.files.wordpress.com/2022/09/image-6.png"><img data-attachment-id="4348" data-permalink="https://herbsutter.com/2022/09/25/something-i-implemented-today-is-void/image-6-2/" data-orig-file="https://herbsutter.files.wordpress.com/2022/09/image-6.png" data-orig-size="1993,1126" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-6" data-image-description="" data-image-caption="" data-medium-file="https://herbsutter.files.wordpress.com/2022/09/image-6.png?w=300" data-large-file="https://herbsutter.files.wordpress.com/2022/09/image-6.png?w=1024" src="https://herbsutter.files.wordpress.com/2022/09/image-6.png?w=1024" alt="" srcset="https://herbsutter.files.wordpress.com/2022/09/image-6.png?w=1024 1024w, https://herbsutter.files.wordpress.com/2022/09/image-6.png?w=150 150w, https://herbsutter.files.wordpress.com/2022/09/image-6.png?w=300 300w, https://herbsutter.files.wordpress.com/2022/09/image-6.png?w=768 768w, https://herbsutter.files.wordpress.com/2022/09/image-6.png 1993w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>Note this isn’t about “making it look pretty.” <code>is</code> and <code>as</code> do lead to simpler and prettier code, but whereas human programmers <em>love </em>clear and consistent spellings, generic code <em>demands</em> that consistency. Here’s the key 1-min clip from last year, summarizing the argument in a nutshell:</p>



<figure><p><span><iframe width="1100" height="619" src="https://www.youtube.com/embed/raB_289NxBk?clip=UgkxaYXMqvpY2R7douWA9Us7BD7gIuBj7Q6E&amp;clipt=ELbWfRiQkoAB&amp;version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation"></iframe></span>
</p></figure>



<h2>Today: Divergent emptiness</h2>



<p>In that vein, today I was catching up with some <a href="https://github.com/hsutter/cppfront">cppfront</a> PRs, and Drew Gross pointed out that as I’ve begun implementing <code>is</code> and <code>as</code> in Cpp2 syntax, one thing didn’t work as Drew expected:</p>



<blockquote>
<p><code>is std::nullopt_t</code> doesn’t appear to match an empty <code>optional</code></p>
<cite>Drew Gross in <a href="https://github.com/hsutter/cppfront/pull/5">cppfront PR #5</a></cite></blockquote>



<p>That got me thinking.</p>



<p>First, that this wasn’t supported in the current P2392 was intentional, because  <code>nullopt_t</code> isn’t a “real type”… it’s a signal for “empty / no value” which until now wasn’t covered in P2392. Recall that <code>is</code> and <code>as</code> are related, including that if <code>is T</code> succeeds it means that a dynamic <code>as T</code> cast to the same type will succeed. But that’s not true for <code>nullopt_t</code>, which is <code>optional</code>‘s way of signaling an empty state; you can’t cast to “no type.”</p>



<p>Still, this got me thinking that testing for “empty” could be useful. And if we do provide an <code>is</code> test for an empty <code>optional</code>, it makes sense for there not to be an <code>as</code> cast for that, which simplifies how we think about it. And it should be spelled generically in a way that works equally for other kind of empty things, so we wouldn’t want to spell it <code>is nullopt_t</code> because that “empty state” name is specific to <code>optional</code> only. It is one of many existing divergent ad-hoc spellings we’ve added for “empty state” (just like we had lots of divergent spellings of type queries and type casts):</p>



<ul>
<li><code>nullopt_t</code> is the empty state for <code>std::optional</code></li>



<li><code>nullptr_t</code> is the empty state for raw/smart pointers</li>



<li>More generally, the default-constructed state <code>T()</code> is the empty state for all Pointer-like things including iterators, and this is already the way the Lifetime profile handles it: a <code>Pointer</code> is any type that can be dereferenced, and a default-constructed <code>Pointer</code> is considered its null/empty value (including that an STL iterator is treated identically to a default-constructed (null) raw or smart pointer) and you can already see this in cppfront’s <code>cpp2util.h</code> null test (currently at <a href="https://github.com/hsutter/cppfront/blob/main/include/cpp2util.h#L298">line 298</a>).</li>



<li><code>monostate</code> (and arguably <code>valueless_by_exception</code>) is the empty state for <code>std::variant</code></li>



<li><code>!has_value</code> is the empty state for <code>std::any</code></li>



<li><code>!is_ready</code> (which has a longer spelling in today’s standard library) is the empty state for <code>std::*future</code></li>
</ul>



<p>And so we have an opportunity to unify these too, which goes beyond what I showed last year and in my previous revision of paper <a href="https://wg21.link/p2392">P2392</a>.</p>



<p>But wait, on top of all that, the language itself has already had a way to spell “no type” since the 1970s: <code>void</code>. And even though <code>void</code> is not a regular type (it doesn’t work as a type in some places in the C++ type system) it works in enough of the places we need to implement <code>is void</code> as the generic spelling of “is empty.”</p>



<h2>A possible convergence: <code>is void</code></h2>



<p>So today I implemented <code>is void</code> as a generic “empty state” test in Cpp2 syntax in cppfront. I also checked in the following Cpp2-syntax test case, which now works as self-documented — and I couldn’t resist the nod to William Tyndale:</p>


<div><pre title="">main: () -&gt; int = {
    p: std::unique_ptr&lt;int&gt; = ();
    i: std::vector&lt;int&gt;::iterator = ();
    v: std::variant&lt;std::monostate, int, std::string&gt; = ();
    a: std::any = ();
    o: std::optional&lt;std::string&gt; = ();

    std::cout &lt;&lt; &#34;\nAll these cases satisfy \&#34;VOYDE AND EMPTIE\&#34;\n&#34;;

    test_generic(p);
    test_generic(i);
    test_generic(v);
    test_generic(a);
    test_generic(o);
}

test_generic: ( x: _ ) = {
    std::cout
        &lt;&lt; &#34;\n&#34; &lt;&lt; typeid(x).name() &lt;&lt; &#34;\n    ...&#34;
        &lt;&lt; inspect x -&gt; std::string {
            is void = &#34; VOYDE AND EMPTIE&#34;;
            is _    = &#34; no match&#34;;
           }
        &lt;&lt; &#34;\n&#34;;
}
</pre></div>


<p>Note that this generic function would be impossible to write without some kind of <code>is void</code> unification to eliminate all of today’s non-generic divergent “empty state” queries.</p>



<p>Here’s the result on my machine in Ubuntu using GCC and libstdc++… I’m glad to show GCC here after having my machine’s WSL 2 subsystem quit on me on-stage so that I couldn’t show the GCC and Clang live demos in the CppCon 2022 talk (sigh!):</p>



<figure><a href="https://herbsutter.files.wordpress.com/2022/09/image-7.png"><img data-attachment-id="4353" data-permalink="https://herbsutter.com/2022/09/25/something-i-implemented-today-is-void/image-7/" data-orig-file="https://herbsutter.files.wordpress.com/2022/09/image-7.png" data-orig-size="1992,1457" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-7" data-image-description="" data-image-caption="" data-medium-file="https://herbsutter.files.wordpress.com/2022/09/image-7.png?w=300" data-large-file="https://herbsutter.files.wordpress.com/2022/09/image-7.png?w=1024" src="https://herbsutter.files.wordpress.com/2022/09/image-7.png?w=1024" alt="" srcset="https://herbsutter.files.wordpress.com/2022/09/image-7.png?w=1024 1024w, https://herbsutter.files.wordpress.com/2022/09/image-7.png?w=150 150w, https://herbsutter.files.wordpress.com/2022/09/image-7.png?w=300 300w, https://herbsutter.files.wordpress.com/2022/09/image-7.png?w=768 768w, https://herbsutter.files.wordpress.com/2022/09/image-7.png 1992w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>Implementing it ensured the implementation worked, including that it exposed where an <code>if constexpr</code> is needed for <code>std::variant</code>‘s <code>is void</code> test (see cpp2util.h, currently <a href="https://github.com/hsutter/cppfront/blob/main/include/cpp2util.h#L610">lines 610-614</a>; note that <code>empty</code> is an alias for <code>void</code>). Once I got it working in cppfront (prototypes matter! they help us debug our proposals) I added it to the <a href="https://isocpp.org/files/papers/P2392R2.pdf">next draft</a> of my ISO C++ proposal paper P2392 for <code>is</code>/<code>as</code>/<code>inspect</code> in today’s Cpp1 syntax, including the suggested implementation.</p>



<p>Thanks, Drew!</p>
	</div><div>
			<div>
				<p><img alt="" src="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=80&amp;d=identicon&amp;r=G" height="80" width="80"/>		</p><!-- .author-avatar -->
		
		<p>
			<h2>Published by <span>Herb Sutter</span></h2>
		</p><!-- .author-heading -->

		<p>
			Herb Sutter is an author and speaker, a software architect at Microsoft, and chair of the ISO C++ standards committee.			<a href="https://herbsutter.com/author/herbsutter/" rel="author">
				View all posts by Herb Sutter			</a>
		</p><!-- .author-bio -->
	</div><!-- .entry-auhtor -->
		<p><strong>Published</strong>
			<time datetime="2022-09-25T07:50:29-08:00">2022-09-25</time><time datetime="2022-09-25T11:10:18-08:00">2022-09-25</time>		</p><!-- .site-posted-on -->
	</div></div>
  </body>
</html>
