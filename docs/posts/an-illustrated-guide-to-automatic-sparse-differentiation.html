<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://iclr-blogposts.github.io/2025/blog/sparse-autodiff/">Original</a>
    <h1>An illustrated guide to automatic sparse differentiation</h1>
    
    <div id="readability-page-1" class="page"><div> <d-contents> <nav> <h3>Contents</h3>  <ul> <li><a href="#the-chain-rule">The chain rule</a></li> <li><a href="#ad-is-matrix-free">AD is matrix-free</a></li> <li><a href="#forward-mode-ad">Forward-mode AD</a></li> <li><a href="#reverse-mode-ad">Reverse-mode AD</a></li> <li><a href="#from-jacobian-operators-back-to-jacobian-matrices">From Jacobian operators back to Jacobian matrices</a></li> </ul>  <ul> <li><a href="#sparse-matrices">Sparse matrices</a></li> <li><a href="#leveraging-sparsity">Leveraging sparsity</a></li> <li><a href="#pattern-detection-and-coloring">Pattern detection and coloring</a></li> </ul>  <ul> <li><a href="#index-sets">Index sets</a></li> <li><a href="#efficient-propagation">Efficient propagation</a></li> <li><a href="#abstract-interpretation">Abstract interpretation</a></li> <li><a href="#local-and-global-patterns">Local and global patterns</a></li> </ul>  <ul> <li><a href="#graph-formulation">Graph formulation</a></li> <li><a href="#greedy-algorithm">Greedy algorithm</a></li> <li><a href="#bicoloring">Bicoloring</a></li> </ul>  <ul> <li><a href="#hessian-vector-products">Hessian-vector products</a></li> <li><a href="#second-order-pattern-detection">Second order pattern detection</a></li> <li><a href="#symmetric-coloring">Symmetric coloring</a></li> </ul>   <ul> <li><a href="#necessary-packages">Necessary packages</a></li> <li><a href="#test-function">Test function</a></li> <li><a href="#backend-switch">Backend switch</a></li> <li><a href="#jacobian-computation">Jacobian computation</a></li> <li><a href="#preparation">Preparation</a></li> <li><a href="#coloring-visualization">Coloring visualization</a></li> <li><a href="#performance-benefits">Performance benefits</a></li> </ul>  </nav> </d-contents>  <p>First-order optimization is ubiquitous in machine learning (ML) but second-order optimization is much less common. The intuitive reason is that high-dimensional vectors (gradients) are cheap, whereas high-dimensional matrices (Hessians) are expensive. Luckily, in numerous applications of ML to science or engineering, <strong>Hessians and Jacobians exhibit sparsity</strong>: most of their coefficients are known to be zero. Leveraging this sparsity can vastly <strong>accelerate automatic differentiation</strong> (AD) for Hessians and Jacobians, while decreasing its memory requirements <d-cite key="griewankEvaluatingDerivativesPrinciples2008"></d-cite>. Yet, while traditional AD is available in many high-level programming languages like Python <d-cite key="paszkePyTorchImperativeStyle2019"></d-cite> <d-cite key="bradburyJAXComposableTransformations2018"></d-cite> and Julia <d-cite key="sapienzaDifferentiableProgrammingDifferential2024"></d-cite>, <strong>automatic sparse differentiation (ASD) is not as widely used</strong>. One reason is that the underlying theory was developed in the AD community, outside of the ML research ecosystem.</p> <p>With this blog post, we aim to shed light on the inner workings of ASD, bridging the gap between the ML and AD communities by presenting well established techniques from the latter field. We start out with a short introduction to traditional AD, covering the computation of Jacobians in both forward and reverse mode. We then dive into the two primary components of ASD: <strong>sparsity pattern detection</strong> and <strong>matrix coloring</strong>. Having described the computation of sparse Jacobians, we move on to sparse Hessians.</p> <h2 id="automatic-differentiation">Automatic differentiation</h2> <p>Let us start by covering the fundamentals of traditional AD. The reader can find more details in the recent book by Blondel and Roulet <d-cite key="blondelElementsDifferentiableProgramming2024"></d-cite>, as well as Griewank and Walther <d-cite key="griewankEvaluatingDerivativesPrinciples2008"></d-cite>.</p> <p>AD makes use of the <strong>compositional structure</strong> of mathematical functions like deep neural networks. To make things simple, we will mainly look at a differentiable function $f$ composed of two differentiable functions $g: \mathbb{R}^{n} \rightarrow \mathbb{R}^{p}$ and $h: \mathbb{R}^{p} \rightarrow \mathbb{R}^{m}$, such that $f = h \circ g: \mathbb{R}^{n} \rightarrow \mathbb{R}^{m}$. The insights gained from this toy example should translate directly to more deeply composed functions $f = g^{(L)} \circ g^{(L-1)} \circ \cdots \circ g^{(1)}$, and even computational graphs with more complex branching.</p> <h3 id="the-chain-rule">The chain rule</h3> <p>For a function $f: \mathbb{R}^{n} \rightarrow \mathbb{R}^{m}$ and a point of linearization $\mathbf{x} \in \mathbb{R}^{n}$, the Jacobian matrix $J_f(\mathbf{x})$ is the $m \times n$ matrix of first-order partial derivatives, whose $(i,j)$-th entry is</p> \[\big( \Jf \big)_{i,j} = \dfdx{i}{j} \in \sR \, .\] <p>For a composed function</p> \[\colorf{f} = \colorh{h} \circ \colorg{g} \, ,\] <p>the <strong>multivariate chain rule</strong> tells us that we obtain the Jacobian matrix of $f$ by <strong>multiplying</strong> the Jacobian matrices of $h$ and $g$:</p> \[\Jfc = \Jhc \cdot \Jgc .\] <p>Figure 1 illustrates this for $n=5$, $m=4$ and $p=3$. We will keep using these dimensions in following illustrations, even though the real benefits of ASD only appear as the dimension grows.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/chainrule_num.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/chainrule_num.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/chainrule_num.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/chainrule_num.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 1: Visualization of the multivariate chain rule for $f = h \circ g$. </p> <h3 id="ad-is-matrix-free">AD is matrix-free</h3> <p>We have seen how the chain rule translates the compositional structure of a function into the product structure of its Jacobian matrix. In practice however, there is a problem: <strong>computing intermediate Jacobian matrices is inefficient and often intractable</strong>, especially with a dense matrix format. Examples of dense matrix formats include NumPy’s <code>ndarray</code>, PyTorch’s <code>Tensor</code>, JAX’s <code>Array</code> and Julia’s <code>Matrix</code>.</p> <p>As a motivating example, let us take a look at a tiny convolutional layer. We consider a convolutional filter of size $5 \times 5$, a single input channel and a single output channel. An input of size $28 \times 28 \times 1$ results in a $576$-dimensional output and therefore a $576 \times 784$ Jacobian matrix, the structure of which is shown in Figure 2. All the white coefficients are <strong>structural zeros</strong>.</p> <p>If we represent the Jacobian of each convolutional layer as a dense matrix, we waste time computing coefficients which are mostly zero, and we waste memory storing those zero coefficients.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/big_conv_jacobian-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/big_conv_jacobian-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/big_conv_jacobian-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/big_conv_jacobian.png" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 2: Structure of the Jacobian of a tiny convolutional layer. </p> <p>In modern neural network architectures, which can contain over one trillion parameters, computing intermediate Jacobian matrices is not only inefficient: it exceeds available memory.</p> <p>AD circumvents this limitation by using <strong>Jacobian operators</strong> that act exactly like Jacobian matrices but without explicitly storing every coefficient in memory. The Jacobian operator $Df: \mathbf{x} \longmapsto Df(\mathbf{x})$ is a linear map which provides the best linear approximation of $f$ around a given point $\mathbf{x}$. Jacobian matrices are the representation of Jacobian operators in the standard basis.</p> <p>We can now rephrase the chain rule as a <strong>composition of operators</strong> instead of a product of matrices:</p> \[\Dfc = \colorf{\D{(h \circ g)}{\vx}} = \Dhc \circ \Dgc \, .\] <p>Note that all terms in this formulation of the chain rule are Jacobian operators. A new visualization for our toy example can be found in Figure 3b. Our illustrations distinguish between matrices and operators by using solid and dashed lines respectively.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/chainrule_num.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/chainrule_num.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/chainrule_num.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/chainrule_num.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 3a: Chain rule using Jacobian matrices (solid outline). </p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/matrixfree.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/matrixfree.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/matrixfree.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/matrixfree.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 3b: Chain rule using matrix-free Jacobian operators (dashed outline). </p>  <h3 id="forward-mode-ad">Forward-mode AD</h3> <p>Now that we have translated the compositional structure of our function $f$ into a compositional structure of Jacobian operators, we can evaluate them by propagating vectors through them, one subfunction at a time.</p> <p>Figure 4 illustrates the propagation of a vector $\mathbf{v}_1 \in \mathbb{R}^n$ from the right-hand side. Since we propagate in the order of the original function evaluation ($g$ then $h$), this is called <strong>forward-mode AD</strong>.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode_eval.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode_eval.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode_eval.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode_eval.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 4: Evaluating Jacobian operators in forward mode. </p> <p>In the first step, we evaluate $Dg(\mathbf{x})(\mathbf{v}_1)$. Since this operation by definition corresponds to</p> \[\vvc{2} = \Dgc(\vvc{1}) = \Jgc \cdot \vvc{1} \;\in \sR^p \, ,\] <p>it is commonly called a <strong>Jacobian-vector product</strong> (JVP) or <strong>pushforward</strong>.</p>  <p>The resulting vector $\mathbf{v}_2$ is then used to compute the subsequent JVP</p> \[\vvc{3} = \Dhc(\vvc{2}) = \Jhc \cdot \vvc{2} \;\in \sR^m \, ,\] <p>which in accordance with the chain rule is equivalent to</p> \[\vvc{3} = \Dfc(\vvc{1}) = \Jfc \cdot \vvc{1} \, ,\] <p>the JVP of our composed function $f$.</p> <p>The computational cost of one JVP of $f$ is approximately the same as the cost of one evaluation of $f$. <strong>Note that we did not compute intermediate Jacobian matrices at any point – we only propagated vectors through Jacobian operators</strong>.</p> <h3 id="reverse-mode-ad">Reverse-mode AD</h3> <p>We can also propagate vectors through the Jacobian operators from the left-hand side, resulting in <strong>reverse-mode AD</strong>, shown in Figure 5.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/reverse_mode_eval.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/reverse_mode_eval.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/reverse_mode_eval.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/reverse_mode_eval.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 5: Evaluating Jacobian operators in reverse mode. </p> <p>This is commonly called a <strong>vector-Jacobian product</strong> (VJP) or <strong>pullback</strong>. Just like forward mode, the cost of one VJP of $f$ is approximately the same as the cost of one evaluation of $f$. However, the memory footprint is larger, as intermediate results of the computation of $f$ must be kept in memory (e.g. hidden activations between layers). Reverse mode is also matrix-free: <strong>no intermediate Jacobian matrices are computed at any point</strong>.</p>  <h3 id="from-jacobian-operators-back-to-jacobian-matrices">From Jacobian operators back to Jacobian matrices</h3> <p>In a computationally expensive process we call <strong>materialization</strong>, we can turn a composition of Jacobian operators into a dense Jacobian matrix. Counterintuitively, this process <strong>does not materialize any intermediate Jacobian matrices</strong>.</p> <p>Figure 6 demonstrates how to <strong>materialize Jacobian matrices column by column</strong> in forward mode. Evaluating the Jacobian operator $Df(\mathbf{x})$ on the $i$-th standard basis vector materializes the $i$-th column of the Jacobian matrix $J_{f}(\mathbf{x})$:</p> \[\Dfc(\vbc{i}) = \left( \Jfc \right)_\colorv{i,:}\] <p>Thus, recovering the full $m \times n$ Jacobian matrix requires one JVP with each of the $n$ standard basis vectors of the <strong>input space</strong>. Once again, we distinguish between Jacobian operators and materialized Jacobian matrices by using dashed and solid lines respectively. While we put numbers into the Jacobian operators for illustrative purposes, they are best thought of as black-box functions:</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 6: Forward-mode AD materializes Jacobian matrices column-by-column. </p> <p>As illustrated in Figure 7, we can also <strong>materialize Jacobian matrices row by row</strong> in reverse mode. Unlike forward mode in Figure 6, this requires one VJP with each of the $m$ standard basis vectors of the <strong>output space</strong>.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/reverse_mode.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/reverse_mode.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/reverse_mode.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/reverse_mode.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 7: Reverse-mode AD materializes Jacobian matrices row-by-row. </p> <p>These processes of materialization are computationally expensive due the fact that each JVP and VJP costs approximately as much as the evaluation of the function $f$ itself.</p>  <h2 id="automatic-sparse-differentiation">Automatic sparse differentiation</h2> <h3 id="sparse-matrices">Sparse matrices</h3> <p>Sparse matrices are matrices in which most elements are zero. As shown in Figure 8, we refer to Jacobian operators as “sparse operators” if they materialize to sparse matrices.</p>  <p> Figure 8: A sparse Jacobian matrix and its corresponding sparse Jacobian operator. </p> <p>When functions have many inputs and many outputs, a given output does not always depend on every single input. This endows the corresponding Jacobian matrix with a <strong>sparsity pattern</strong>, where <strong>zero coefficients denote an absence of (first-order) dependency</strong>. The previous case of a convolutional layer is a simple example. An even simpler example is an activation function applied element-wise, for which the Jacobian matrix is the identity matrix.</p> <h3 id="leveraging-sparsity">Leveraging sparsity</h3> <p>For now, we assume that the sparsity pattern of the Jacobian matrix is always the same, regardless of the input, and that we know it ahead of time. We say that two columns or rows of the Jacobian matrix are <strong>structurally orthogonal</strong> if, for every index, at most one of them has a nonzero coefficient. In other words, the sparsity patterns of the columns are non-overlapping vectors, whose dot product is always zero regardless of their actual values.</p> <p>The core idea of ASD is that <strong>we can materialize multiple structurally orthogonal columns (or rows) with a single JVP (or VJP).</strong> This trick was first suggested in 1974 by Curtis, Powell and Reid <d-cite key="curtisEstimationSparseJacobian1974"></d-cite>. Since Jacobian operators are linear maps and therefore additive, it always holds that for a set of basis vectors,</p> \[\Dfc(\vbc{i}+\ldots+\vbc{j}) = \underbrace{\Dfc(\vbc{i})}_{\left( \Jfc \right)_\colorv{i,:}} + \ldots + \underbrace{\Dfc(\vbc{j})}_{\left( \Jfc \right)_\colorv{j,:}} \, .\] <p>The components of the sum on the right-hand side each correspond to a column of the Jacobian matrix. If these columns are known to be structurally orthogonal, the sum can be uniquely decomposed into its components, a process known as <strong>decompression</strong>. Thus, a single JVP is enough to retrieve the nonzero coefficients of several columns at once.</p> <p>This specific example using JVPs corresponds to forward-mode ASD and is visualized in Figure 9, where all structurally orthogonal columns have been colored in matching hues. By computing a single JVP with the vector $\mathbf{e}_1 + \mathbf{e}_2 + \mathbf{e}_5$, we obtain the sum of the first, second and fifth column of our Jacobian matrix.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/sparse_ad.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/sparse_ad.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/sparse_ad.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/sparse_ad.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 9: Materializing structurally orthogonal columns of a Jacobian in forward mode. </p> <p>A second JVP with the vector $\mathbf{e}_3 + \mathbf{e}_4$ gives us the sum of the remaining columns. We then assign the values in the resulting vectors back to the appropriate entries of the Jacobian matrix. This final decompression step is shown in Figure 10.</p>  <p> Figure 10: Materializing a Jacobian with forward-mode ASD: (a) compressed evaluation of orthogonal columns (b) decompression to Jacobian matrix </p> <p>The same idea can also be applied to reverse-mode AD, as shown in Figure 11. Instead of leveraging orthogonal columns, we rely on orthogonal rows. We can then materialize multiple rows in a single VJP.</p>  <p> Figure 11: Materializing a Jacobian with reverse-mode ASD: (a) compressed evaluation of orthogonal rows (b) decompression to Jacobian matrix </p> <h3 id="pattern-detection-and-coloring">Pattern detection and coloring</h3> <p>Unfortunately, our initial assumption had a major flaw. Since AD only gives us a composition of Jacobian operators, which are black-box functions, the structure of the corresponding Jacobian matrix is completely unknown. In other words, <strong>we cannot tell which rows and columns form structurally orthogonal groups</strong> without first materializing a Jacobian matrix. But if we materialize this matrix via traditional AD, then ASD isn’t necessary anymore.</p> <p>The solution to this problem is shown in Figure 12 (a): in order to find structurally orthogonal columns (or rows), we don’t need to materialize the full Jacobian matrix. Instead, it is enough to <strong>detect the sparsity pattern</strong> of the matrix. This binary-valued pattern contains enough information to deduce structural orthogonality. From there, we use a <strong>coloring algorithm</strong> to group orthogonal columns (or rows) together. Such a coloring can be visualized on Figure 12 (b), where the yellow columns will be evaluated together (first JVP) and the light blue ones will be evaluated together (second JVP), for a total of 2 JVPs instead of 5.</p>  <p> Figure 12: The first two steps of ASD: (a) sparsity pattern detection, (b) coloring of the sparsity pattern. </p> <p>To sum up, ASD consists of four steps:</p> <ol> <li>Pattern detection</li> <li>Coloring</li> <li>Compressed AD</li> <li>Decompression</li> </ol> <p>This compression-based pipeline is described at length by Gebremedhin, Manne and Pothen <d-cite key="gebremedhinWhatColorYour2005"></d-cite> in their landmark survey, or in Chapter 8 of the book by Griewank and Walther <d-cite key="griewankEvaluatingDerivativesPrinciples2008"></d-cite>. An alternative, direct pipeline is presented in Chapter 7 of the same book.</p> <p>We now discuss the first two steps in more detail. These steps can be much slower than a single call to the function $f$, but they are usually much faster than a full computation of the Jacobian with AD. This makes the sparse procedure worth it even for moderately large matrices. Additionally, if we need to compute Jacobians multiple times (for different inputs) and are able to reuse the sparsity pattern and the coloring result, <strong>the cost of this prelude can be amortized</strong> over several subsequent evaluations.</p> <h2 id="pattern-detection">Pattern detection</h2> <p>Mirroring the diversity of AD systems, there are also many possible approaches to sparsity pattern detection, each with its own advantages and tradeoffs. The work of Dixon <d-cite key="dixonAutomaticDifferentiationLarge1990"></d-cite> in the 1990’s was among the first of many papers on this subject, most of which can be classified into operator overloading or source transformation techniques. There are also ways to detect a sparsity pattern by probing the Jacobian matrix coefficients with AD<d-cite key="griewankDetectingJacobianSparsity2002"></d-cite>, but we do not linger on them here.</p> <p>The method we present corresponds to a binary version of a forward-mode AD system, similar in spirit to <d-cite key="dixonAutomaticDifferentiationLarge1990"></d-cite> and <d-cite key="bischofEfficientComputationGradients1996"></d-cite>, in which performance is gained by representing matrix rows as index sets.</p> <h3 id="index-sets">Index sets</h3> <p>Our goal with sparsity pattern detection is to quickly compute the binary pattern of the Jacobian matrix. One way to achieve better performance than traditional AD is to encode row sparsity patterns as index sets. The $i$-th row of the Jacobian is given by</p> \[\big( \Jf \big)_{i,:} = \left[\dfdx{i}{j}\right]_{1 \le j \le n} = \begin{bmatrix} \dfdx{i}{1} &amp; \ldots &amp; \dfdx{i}{n} \end{bmatrix} \, .\] <p>However, since we are only interested in the binary pattern</p> \[\left[\dfdx{i}{j} \neq 0\right]_{1 \le j \le n} \, ,\] <p>we can instead represent the sparsity pattern of the $i$-th row of a Jacobian matrix by the corresponding <strong>index set of non-zero values</strong></p> \[\left\{j \;\Bigg|\; \dfdx{i}{j} \neq 0\right\} \, .\] <p>These equivalent sparsity pattern representations are illustrated in Figure 13. Each row index set tells us <strong>which inputs influenced a given output</strong>, at the first-order. For instance, output $i=2$ was influenced by inputs $j=4$ and $j=5$.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/sparsity_pattern_representations.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/sparsity_pattern_representations.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/sparsity_pattern_representations.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/sparsity_pattern_representations.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 13: Sparsity pattern representations: (a) original matrix, (b) binary pattern, (c) row index sets. </p> <h3 id="efficient-propagation">Efficient propagation</h3> <p>Figure 14 shows the traditional forward mode pass we want to avoid: propagating a full identity matrix through a Jacobian operator would not only materialize the Jacobian matrix of $f$, but also all intermediate Jacobian matrices. As previously discussed, this is not a viable option due to its inefficiency and high memory requirements.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode_naive.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode_naive.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode_naive.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode_naive.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 14: Propagating an identity matrix in forward mode to obtain the Jacobian matrix. </p> <p>Instead, we initialize an input vector with index sets corresponding to the identity matrix. An alternative view on this vector is that it corresponds to the index set representation of the Jacobian matrix of the input, since $\frac{\partial x_i}{\partial x_j} \neq 0$ only holds for $i=j$.</p> <p>Our goal is to propagate this index set such that we get an output vector of index sets that corresponds to the Jacobian sparsity pattern. This idea is visualized in Figure 15.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode_sparse.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode_sparse.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode_sparse.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/forward_mode_sparse.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 15: Propagating an index set through a Jacobian operator to obtain a sparsity pattern. </p> <h3 id="abstract-interpretation">Abstract interpretation</h3> <p>Instead of going into implementation details, we want to provide some intuition on the second key ingredient of this typical forward-mode sparsity detection system: <strong>abstract interpretation</strong>.</p> <p>We will demonstrate this on a second toy example, the function</p> \[f(\vx) = \begin{bmatrix} x_1 x_2 + \text{sgn}(x_3)\\ \text{sgn}(x_3) \frac{x_4}{2} \end{bmatrix} \, .\] <p>The corresponding computational graph is shown in Figure 16, where circular nodes correspond to primitive functions, in this case addition, multiplication, division and the sign function. Scalar inputs $x_i$ and outputs $y_j$ are shown in rectangular nodes. Instead of evaluating the original compute graph for a given input $\mathbf{x}$, all inputs are seeded with their respective input index sets. Figure 16 annotates these index sets on the edges of the computational graph.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/compute_graph-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/compute_graph-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/compute_graph-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/compute_graph.png" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 16: Computational graph of the function $ f(\mathbf{x}) = [x_1 x_2 + \text{sgn}(x_3),\, \text{sgn}(x_3) \frac{x_4}{2} ] $, annotated with corresponding index sets. </p> <p>Abstract interpretation means that we imbue the computational graph with a different meaning. Instead of computing its output value, each primitive function must accumulate the index sets of its inputs, then propagate these index sets to the output, but only if the corresponding derivative is non-zero anywhere in the input domain.</p> <p>Since addition, multiplication and division globally have non-zero derivatives with respect to both of their inputs, the index sets of their inputs are accumulated and propagated. The sign function has a zero derivative for any input value. It therefore doesn’t propagate the index set of its input and instead returns an empty set.</p> <p>Figure 16 shows the resulting output index sets $\{1, 2\}$ and $\{4\}$ for outputs 1 and 2 respectively. These match the analytic Jacobian matrix</p> \[J_f(\mathbf{x}) = \begin{bmatrix} x_2 &amp; x_1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; \frac{\text{sgn}(x_3)}{2} \end{bmatrix} \, .\] <h3 id="local-and-global-patterns">Local and global patterns</h3> <p>The type of abstract interpretation shown above corresponds to <em>global sparsity detection</em>, computing index sets</p> \[\left\{j \;\Bigg|\; \dfdx{i}{j} \neq 0 \, \text{for some} \, \mathbf{x} \in \sR^{n} \right\}\] <p>that are valid over the entire input domain. Another type of abstract interpretation can be implemented, in which the original <em>primal computation</em> is propagated alongside index sets, computing</p> \[\left\{j \;\Bigg|\; \dfdx{i}{j} \neq 0 \right\}\] <p>for a specific input $\mathbf{x}$. These <em>local sparsity patterns</em> are strict subsets of global sparsity patterns, and can therefore result in fewer colors. However, they need to be recomputed when changing the input.</p> <h2 id="coloring">Coloring</h2> <p>Once we have detected a sparsity pattern, our next goal is to decide <strong>how to group the columns (or rows)</strong> of the Jacobian matrix. The columns (or rows) in each group will be evaluated simultaneously using a single JVP (or VJP), with a linear combination of basis vectors called a <strong>seed</strong>. If the members of the group are structurally orthogonal, then this gives all the necessary information to retrieve every nonzero coefficient of the matrix.</p> <h3 id="graph-formulation">Graph formulation</h3> <p>Luckily, this grouping problem can be reformulated as graph coloring, which is very well studied. Let us build a graph $\mathcal{G} = (\mathcal{V}, \mathcal{E})$ with vertex set $\mathcal{V}$ and edge set $\mathcal{E}$, such that each column is a vertex of the graph, and two vertices are connected if and only if their respective columns share a non-zero index. Put differently, an edge between vertices $j_1$ and $j_2$ means that columns $j_1$ and $j_2$ are not structurally orthogonal. Note that there are more efficient graph representations, summed up in <d-cite key="gebremedhinWhatColorYour2005"></d-cite>.</p> <p>We want to assign to each vertex $j$ a color $c(j)$, such that any two adjacent vertices $(j_1, j_2) \in \mathcal{E}$ have different colors $c(j_1) \neq c(j_2)$. This constraint ensures that columns in the same color group are indeed structurally orthogonal. If we can find a coloring which uses the smallest possible number of distinct colors, it will minimize the number of groups, and thus the computational cost of the AD step.</p> <p>Figure 17 shows an optimal coloring using two colors, whereas Figure 18 uses a suboptimal third color, requiring an extra JVP to materialize the Jacobian and therefore increasing the computational cost of ASD. Figure 19 shows an infeasible coloring: vertices 2 and 4 on the graph are adjacent, but share a color. This results in overlapping columns.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/colored_graph.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/colored_graph.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/colored_graph.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/colored_graph.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 17: Optimal graph coloring. </p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/colored_graph_suboptimal.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/colored_graph_suboptimal.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/colored_graph_suboptimal.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/colored_graph_suboptimal.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 18: Suboptimal graph coloring (vertex 1 could be colored in yellow). </p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/colored_graph_infeasible.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/colored_graph_infeasible.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/colored_graph_infeasible.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/colored_graph_infeasible.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 19: Infeasible graph coloring (vertices 2 and 4 are adjacent on the graph, but share a color). </p> <p>If we perform column coloring, forward-mode AD is required, while reverse-mode AD is needed for row coloring.</p> <h3 id="greedy-algorithm">Greedy algorithm</h3> <p>Unfortunately, the graph coloring problem is NP-hard: there is currently no way to solve it in polynomial time for every instance. The optimal solution is known only for specific patterns, such as banded matrices. However, efficient heuristics exist which generate good enough solutions in reasonable time. The most widely used heuristic is the greedy algorithm, which processes vertices one after the other. This algorithm assigns to each vertex the smallest color that is not already present among its neighbors, and it never backtracks. A crucial hyperparameter is the choice of ordering, for which various criteria have been proposed <d-cite key="gebremedhinColPackSoftwareGraph2013"></d-cite>.</p> <h3 id="bicoloring">Bicoloring</h3> <p>A more advanced coloring technique called <strong>bicoloring</strong> allows combining forward and reverse modes, because the recovery of the Jacobian matrix leverages both columns (JVPs) and rows (VJPs) <d-cite key="hossainComputingSparseJacobian1998"></d-cite> <d-cite key="colemanEfficientComputationSparse1998"></d-cite>.</p> <p>Figure 20 shows bicoloring on a toy example in which no pair of columns or rows is structurally orthogonal. Even with ASD, materializing the Jacobian matrix would require $5$ JVPs in forward-mode or $4$ VJPs in reverse mode. However, if we use both modes simultaneously, we can materialize the full Jacobian matrix by computing only $1$ JVP and $1$ VJP.</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/bicoloring.svg-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/bicoloring.svg-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/bicoloring.svg-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/bicoloring.svg" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 20: Bicoloring on a toy example with a dense row and a dense column. </p> <h2 id="second-order">Second order</h2> <p>While first-order automatic differentiation AD focuses on computing the gradient or Jacobian matrix, second-order AD extends the same ideas to the <strong>Hessian</strong> matrix</p> \[\nabla^2 f (\mathbf{x}) = \left(\frac{\partial^2 f(\mathbf{x})}{\partial x_i ~ \partial x_j} \right)_{i,j} \, .\] <p>The Hessian contains second-order partial derivatives of a scalar function, essentially capturing the curvature of the function at a point. This is particularly relevant in <strong>optimization</strong>, where the Hessian provides crucial information about the function’s local behavior. Specifically, the Hessian allows us to distinguish between local minima, maxima, and saddle points. By incorporating second-order information, optimization algorithms converge more robustly where the gradient alone doesn’t provide enough information for effective search directions.</p> <h3 id="hessian-vector-products">Hessian-vector products</h3> <p>For second-order AD, the key subroutine is the <strong>Hessian-vector product (HVP)</strong>. The Hessian is the Jacobian matrix of the gradient function $\nabla f: \mathbf{x} \mapsto \nabla f(\mathbf{x})$, that is,</p> \[\nabla^2 f (\mathbf{x}) = J_{\nabla f}(\mathbf{x}) \, .\] <p>An HVP computes the product of the Hessian matrix with a vector, which can be viewed as the JVP of the gradient function.</p> \[\nabla^2 f(\mathbf{x}) \cdot \mathbf{v} = D[\nabla f](\mathbf{x})(\mathbf{v})\] <p>Note that the gradient function is itself computed via a VJP of $f$. Thus, the HVP approach we described computes the JVP of a VJP, giving it the name “forward over reverse”. In forward-over-reverse HVPs, the complexity of a single product scales roughly with the complexity of the function $f$ itself. This procedure was first considered by Pearlmutter <d-cite key="pearlmutterFastExactMultiplication1994"></d-cite> and recently revisited in a 2024 ICLR blog post <d-cite key="dagreouHowComputeHessianvector2024"></d-cite>. Note that other mode combinations are possible, like “forward over forward”, which has a higher complexity but is less expensive in terms of storage.</p> <p>The Hessian has a <strong>symmetric</strong> structure (equal to its transpose), which means that matrix-vector products and vector-matrix products coincide. This explains why we don’t need a VHP in addition to the HVP. This specificity can be exploited in the sparsity detection as well as in the coloring phase.</p> <h3 id="second-order-pattern-detection">Second order pattern detection</h3> <p>Detecting the sparsity pattern of the Hessian is more complicated than for the Jacobian. This is because, in addition to the usual linear dependencies, we now have to account for <strong>nonlinear interactions</strong> in the computational graph. The operator overloading method of Walther <d-cite key="waltherComputingSparseHessians2008"></d-cite> was a pioneering effort towards Hessian sparsity detection, although more efficient alternatives quickly emerged <d-cite key="gowerNewFrameworkComputation2012"></d-cite>.</p> <p>For instance, if $f(\mathbf{x})$ involves a term of the form $x_1 + x_2$, it will not directly affect the Hessian. However, we cannot ignore this term, since multiplying it with $x_3$ to obtain an output $f(\mathbf{x}) = (x_1 + x_2)\,x_3$ will yield non-zero coefficients at positions $(1, 3)$, $(3, 1)$, $(2, 3)$ and $(3, 2)$. Thus, the abstract interpretation system used for second-order pattern detection needs a finer classification of primitive functions. It must distinguish between locally constant, locally linear, and locally nonlinear behavior in each argument, and distinguish between zero and non-zero cross-derivatives.</p> <h3 id="symmetric-coloring">Symmetric coloring</h3> <p>When it comes to graph coloring for the Hessian, there are more options for decompression thanks to symmetry. Even if two columns in the Hessian are not structurally orthogonal, missing coefficients can be recovered by leveraging the corresponding rows instead of relying solely on the columns. In other words, if $H_{ij}$ is lost during compression because of colliding nonzero coefficients, there is still a chance to retrieve it through $H_{ji}$. This backup storage enables the use of <strong>fewer distinct colors</strong>, reducing the complexity of the AD part compared to traditional row or column coloring.</p> <p>Powell and Toint <d-cite key="powellEstimationSparseHessian1979"></d-cite> were the first to notice symmetry-related optimizations, before Coleman and Moré <d-cite key="colemanEstimationSparseHessian1984"></d-cite> made the connection to graph coloring explicit. While symmetric coloring and decompression are more computationally expensive than their nonsymmetric counterparts, this cost is typically negligible compared to the savings we get from fewer HVPs.</p> <h2 id="applications">Applications</h2> <p>ASD is useful in applications which involve the computation of full Jacobian or Hessian matrices with sparsity. Let us discuss one of the examples given in the 2024 ICLR blog post <em>How to compute Hessian-vector products?</em> <d-cite key="dagreouHowComputeHessianvector2024"></d-cite>: Newton’s method. This canonical algorithm for nonlinear optimization uses Hessians within local steps of the form $[\nabla^2 f(\mathbf{x})]^{-1} \nabla f(\mathbf{x})$. The inverse $[\nabla^2f(\mathbf{x})]^{-1}$ is never created explicitly, since it suffices to solve a linear system $\nabla^2f(\mathbf{x}) \cdot \mathbf{v} = \nabla f(\mathbf{x})$. As the blog post argues, for such systems, matrix-free iterative solvers combine well with Hessian operators because they only require successive evaluations of HVPs. The main advantage of iterative solvers is their small memory footprint and their ease of implementation.</p> <p>However, when it is possible to materialize the whole Hessian matrix, direct linear solvers can be used (e.g. based on matrix factorization). As we have seen, ASD unlocks this option whenever the Hessian matrix is sparse enough. In terms of performance, computing a sparse Hessian matrix might require fewer HVPs overall than applying an iterative solver like the conjugate gradient method. The exact performance depends on the number of colors in the sparsity pattern of the Hessian, as well as the numerical precision expected from the iterative solver (which influences the number of iterations, hence the number of HVPs). In terms of numerical accuracy, direct solvers are more robust than their iterative counterparts. Finally, in terms of compatibility, some prominent nonlinear optimization libraries only support Hessian matrices, and not Hessian operators.</p> <p>The same reasoning also applies to Jacobian matrices, which can appear in settings like Newton’s method for root-finding, implicit differentiation <d-cite key="blondel_efficient_2022"></d-cite>, or solvers for differential equations <d-cite key="sapienza_differentiable_2024"></d-cite>.</p> <h2 id="demonstration">Demonstration</h2> <p>We complement this tutorial with a demonstration of automatic sparse differentiation in a high-level programming language, namely the <a href="https://julialang.org/" rel="external nofollow noopener noopener noreferrer" target="_blank">Julia language</a> <d-cite key="bezansonJuliaFreshApproach2017"></d-cite>. While still at an early stage of development, we hope that such an example of unified pipeline for sparse Jacobians and Hessians can inspire developers in other languages to revisit ASD.</p>  <h3 id="necessary-packages">Necessary packages</h3> <p>Here are the packages we will use for this demonstration.</p> <ul> <li> <a href="https://github.com/adrhill/SparseConnectivityTracer.jl" rel="external nofollow noopener noopener noreferrer" target="_blank">SparseConnectivityTracer.jl</a> <d-cite key="hillSparseConnectivityTracerjl2024"></d-cite>: Sparsity pattern detection with operator overloading.</li> <li> <a href="https://github.com/gdalle/SparseMatrixColorings.jl" rel="external nofollow noopener noopener noreferrer" target="_blank">SparseMatrixColorings.jl</a> <d-cite key="dalleGdalleSparseMatrixColoringsjlV04102024"></d-cite>: Greedy algorithms for colorings, decompression utilities.</li> <li> <a href="https://github.com/JuliaDiff/ForwardDiff.jl" rel="external nofollow noopener noopener noreferrer" target="_blank">ForwardDiff.jl</a> <d-cite key="revelsForwardModeAutomaticDifferentiation2016"></d-cite>: Forward-mode AD and computation of JVPs.</li> <li> <a href="https://github.com/JuliaDiff/DifferentiationInterface.jl" rel="external nofollow noopener noopener noreferrer" target="_blank">DifferentiationInterface.jl</a> <d-cite key="dalleJuliaDiffDifferentiationInterfacejlDifferentiationInterfacev06232024"></d-cite>: High-level interface bringing all of these together, originally inspired by <d-cite key="schaferAbstractDifferentiationjlBackendAgnosticDifferentiable2022"></d-cite>.</li> </ul> <p>This modular pipeline comes as a replacement and extension of a previous ASD system in Julia <d-cite key="gowdaSparsityProgrammingAutomated2019"></d-cite>. We also use a few other packages for data manipulation <d-cite key="bouchet-valatDataFramesjlFlexibleFast2023"></d-cite> and visualization <d-cite key="danischMakiejlFlexibleHighperformance2021"></d-cite>.</p> <p>Like in any other language, the first step is importing the dependencies:</p> <div><div><pre><code><span>using</span> <span>DifferentiationInterface</span><span>,</span> <span>DifferentiationInterfaceTest</span>
<span>using</span> <span>SparseConnectivityTracer</span><span>,</span> <span>SparseMatrixColorings</span>
<span>import</span> <span>ForwardDiff</span>
</code></pre></div></div> <p>The syntax we showcase is accurate as of the following package versions:</p> <div><div><pre><code>[a0c0ee7d] DifferentiationInterface v0.6.48
[a82114a7] DifferentiationInterfaceTest v0.9.5
[f6369f11] ForwardDiff v0.10.38
[9f842d2f] SparseConnectivityTracer v0.6.15
[0a514795] SparseMatrixColorings v0.4.14
</code></pre></div></div> <h3 id="test-function">Test function</h3> <p>As our test function, we choose a very simple iterated difference operator. It takes a vector $\mathbf{x} \in \mathbb{R}^n$ and outputs a slightly shorter vector $y \in \mathbb{R}^{n-k}$ depending on the number of iterations $k$. In pure Julia, this is written as follows (using the built-in <code>diff</code> recursively):</p> <div><div><pre><code><span>function</span><span> iter_diff</span><span>(</span><span>x</span><span>,</span> <span>k</span><span>)</span>
    <span>if</span> <span>k</span> <span>==</span> <span>0</span>
        <span>return</span> <span>x</span>
    <span>else</span>
        <span>y</span> <span>=</span> <span>iter_diff</span><span>(</span><span>x</span><span>,</span> <span>k</span> <span>-</span> <span>1</span><span>)</span>
        <span>return</span> <span>diff</span><span>(</span><span>y</span><span>)</span>
    <span>end</span>
<span>end</span>
</code></pre></div></div> <p>Let us check that the function returns what we expect:</p> <div><div><pre><code><span>julia</span><span>&gt;</span> <span>iter_diff</span><span>([</span><span>1</span><span>,</span> <span>4</span><span>,</span> <span>9</span><span>,</span> <span>16</span><span>],</span> <span>1</span><span>)</span>
<span>3</span><span>-</span><span>element</span> <span>Vector</span><span>{</span><span>Int64</span><span>}</span><span>:</span>
 <span>3</span>
 <span>5</span>
 <span>7</span>

<span>julia</span><span>&gt;</span> <span>iter_diff</span><span>([</span><span>1</span><span>,</span> <span>4</span><span>,</span> <span>9</span><span>,</span> <span>16</span><span>],</span> <span>2</span><span>)</span>
<span>2</span><span>-</span><span>element</span> <span>Vector</span><span>{</span><span>Int64</span><span>}</span><span>:</span>
 <span>2</span>
 <span>2</span>
</code></pre></div></div> <h3 id="backend-switch">Backend switch</h3> <p>The key concept behind DifferentiationInterface.jl is that of <strong>backends</strong>. There are several AD systems in Julia, each with different features and tradeoff, that can be accessed through a common API. Here, we use ForwardDiff.jl as our AD backend:</p>  <p>To build an ASD backend, we bring together three ingredients corresponding to each step:</p> <div><div><pre><code><span>sparsity_detector</span> <span>=</span> <span>TracerSparsityDetector</span><span>()</span>  <span># from SparseConnectivityTracer</span>
<span>coloring_algorithm</span> <span>=</span> <span>GreedyColoringAlgorithm</span><span>()</span>  <span># from SparseMatrixColorings</span>
<span>asd</span> <span>=</span> <span>AutoSparse</span><span>(</span><span>ad</span><span>;</span> <span>sparsity_detector</span><span>,</span> <span>coloring_algorithm</span><span>)</span>
</code></pre></div></div> <h3 id="jacobian-computation">Jacobian computation</h3> <p>We can now compute the Jacobian of <code>iter_diff</code> (with respect to $\mathbf{x}$) using either backend, and compare the results. Just like AD, ASD is fully automatic. It doesn’t require the user to change any code besides specifying a backend:</p> <div><div><pre><code><span>julia</span><span>&gt;</span> <span>x</span><span>,</span> <span>k</span> <span>=</span> <span>rand</span><span>(</span><span>10</span><span>),</span> <span>3</span><span>;</span>

<span>julia</span><span>&gt;</span> <span>jacobian</span><span>(</span><span>iter_diff</span><span>,</span> <span>ad</span><span>,</span> <span>x</span><span>,</span> <span>Constant</span><span>(</span><span>k</span><span>))</span>
<span>7</span><span>×10</span> <span>Matrix</span><span>{</span><span>Float64</span><span>}</span><span>:</span>
 <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>   <span>1.0</span>   <span>0.0</span>   <span>0.0</span>   <span>0.0</span>   <span>0.0</span>   <span>0.0</span>  <span>0.0</span>
  <span>0.0</span>  <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>   <span>1.0</span>   <span>0.0</span>   <span>0.0</span>   <span>0.0</span>   <span>0.0</span>  <span>0.0</span>
  <span>0.0</span>   <span>0.0</span>  <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>   <span>1.0</span>   <span>0.0</span>   <span>0.0</span>   <span>0.0</span>  <span>0.0</span>
  <span>0.0</span>   <span>0.0</span>   <span>0.0</span>  <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>   <span>1.0</span>   <span>0.0</span>   <span>0.0</span>  <span>0.0</span>
  <span>0.0</span>   <span>0.0</span>   <span>0.0</span>   <span>0.0</span>  <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>   <span>1.0</span>   <span>0.0</span>  <span>0.0</span>
  <span>0.0</span>   <span>0.0</span>   <span>0.0</span>   <span>0.0</span>   <span>0.0</span>  <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>   <span>1.0</span>  <span>0.0</span>
  <span>0.0</span>   <span>0.0</span>   <span>0.0</span>   <span>0.0</span>   <span>0.0</span>   <span>0.0</span>  <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>  <span>1.0</span>

<span>julia</span><span>&gt;</span> <span>jacobian</span><span>(</span><span>iter_diff</span><span>,</span> <span>asd</span><span>,</span> <span>x</span><span>,</span> <span>Constant</span><span>(</span><span>k</span><span>))</span>
<span>7</span><span>×10</span> <span>SparseArrays</span><span>.</span><span>SparseMatrixCSC</span><span>{</span><span>Float64</span><span>,</span> <span>Int64</span><span>}</span> <span>with</span> <span>28</span> <span>stored</span> <span>entries</span><span>:</span>
 <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>   <span>1.0</span>    <span>⋅</span>     <span>⋅</span>     <span>⋅</span>     <span>⋅</span>     <span>⋅</span>    <span>⋅</span> 
   <span>⋅</span>   <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>   <span>1.0</span>    <span>⋅</span>     <span>⋅</span>     <span>⋅</span>     <span>⋅</span>    <span>⋅</span> 
   <span>⋅</span>     <span>⋅</span>   <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>   <span>1.0</span>    <span>⋅</span>     <span>⋅</span>     <span>⋅</span>    <span>⋅</span> 
   <span>⋅</span>     <span>⋅</span>     <span>⋅</span>   <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>   <span>1.0</span>    <span>⋅</span>     <span>⋅</span>    <span>⋅</span> 
   <span>⋅</span>     <span>⋅</span>     <span>⋅</span>     <span>⋅</span>   <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>   <span>1.0</span>    <span>⋅</span>    <span>⋅</span> 
   <span>⋅</span>     <span>⋅</span>     <span>⋅</span>     <span>⋅</span>     <span>⋅</span>   <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>   <span>1.0</span>   <span>⋅</span> 
   <span>⋅</span>     <span>⋅</span>     <span>⋅</span>     <span>⋅</span>     <span>⋅</span>     <span>⋅</span>   <span>-</span><span>1.0</span>   <span>3.0</span>  <span>-</span><span>3.0</span>  <span>1.0</span>
</code></pre></div></div> <p>In one case, we get a dense matrix, in the other it is sparse. Note that in Julia, linear algebra operations are optimized for sparse matrices, which means this format can be beneficial for downstream use. We now show that sparsity also unlocks faster computation of the Jacobian itself.</p> <h3 id="preparation">Preparation</h3> <p>Sparsity pattern detection and matrix coloring are performed in a so-called “preparation step”, whose output can be <strong>reused across several calls</strong> to <code>jacobian</code> (as long as the pattern stays the same).</p> <p>Thus, to extract more performance, we can create this object only once</p> <div><div><pre><code><span>prep</span> <span>=</span> <span>prepare_jacobian</span><span>(</span><span>iter_diff</span><span>,</span> <span>asd</span><span>,</span> <span>x</span><span>,</span> <span>Constant</span><span>(</span><span>k</span><span>))</span>
</code></pre></div></div> <p>and then reuse it as much as possible, for instance inside the loop of an iterative algorithm (note the additional <code>prep</code> argument):</p> <div><div><pre><code><span>jacobian</span><span>(</span><span>iter_diff</span><span>,</span> <span>prep</span><span>,</span> <span>asd</span><span>,</span> <span>x</span><span>,</span> <span>Constant</span><span>(</span><span>k</span><span>))</span>
</code></pre></div></div> <p>Inside the preparation result, we find the output of sparsity pattern detection</p> <div><div><pre><code><span>julia</span><span>&gt;</span> <span>sparsity_pattern</span><span>(</span><span>prep</span><span>)</span>
<span>7</span><span>×10</span> <span>SparseArrays</span><span>.</span><span>SparseMatrixCSC</span><span>{</span><span>Bool</span><span>,</span> <span>Int64</span><span>}</span> <span>with</span> <span>28</span> <span>stored</span> <span>entries</span><span>:</span>
 <span>1</span>  <span>1</span>  <span>1</span>  <span>1</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>
 <span>⋅</span>  <span>1</span>  <span>1</span>  <span>1</span>  <span>1</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>
 <span>⋅</span>  <span>⋅</span>  <span>1</span>  <span>1</span>  <span>1</span>  <span>1</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>
 <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>1</span>  <span>1</span>  <span>1</span>  <span>1</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>
 <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>1</span>  <span>1</span>  <span>1</span>  <span>1</span>  <span>⋅</span>  <span>⋅</span>
 <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>1</span>  <span>1</span>  <span>1</span>  <span>1</span>  <span>⋅</span>
 <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>⋅</span>  <span>1</span>  <span>1</span>  <span>1</span>  <span>1</span>
</code></pre></div></div> <p>and the coloring of the columns:</p> <div><div><pre><code><span>julia</span><span>&gt;</span> <span>column_colors</span><span>(</span><span>prep</span><span>)</span>
<span>10</span><span>-</span><span>element</span> <span>Vector</span><span>{</span><span>Int64</span><span>}</span><span>:</span>
 <span>1</span>
 <span>2</span>
 <span>3</span>
 <span>4</span>
 <span>1</span>
 <span>2</span>
 <span>3</span>
 <span>4</span>
 <span>1</span>
 <span>2</span>
</code></pre></div></div> <p>Note that it uses only $c = 4$ different colors, which means we need $4$ JVPs instead of the initial $n = 10$ to reconstruct the Jacobian.</p>  <h3 id="coloring-visualization">Coloring visualization</h3> <p>We just saw that there is a discrepancy between the number of different colors $c$ and the input size $n$. This ratio $n / c$ typically gets larger as the input grows, which makes sparse differentiation more and more competitive.</p> <p>We illustrate this with the Jacobians of <code>iter_diff</code> for several values of $n$ and $k$:</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/demo/banded-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/demo/banded-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/demo/banded-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/demo/banded.png" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 21: Coloring numbers are often agnostic to the input size. </p> <p>The main takeaway of Figure 21 is that in this case, <strong>the number of colors does not depend on the dimension</strong> $n$, only on the number of iterations $k$. In fact, <code>iter_diff</code> with $k$ iterations gives rise to a banded Jacobian with $k+1$ bands, for which we can easily verify that the optimal coloring uses as many colors as bands, i.e. $c = k+1$. For this particular case, the greedy coloring also happens to find the optimal solution.</p> <h3 id="performance-benefits">Performance benefits</h3> <p>Here we present a benchmark for the Jacobian of <code>iter_diff</code> with varying $n$ and fixed $k$. Our goal is to find out when sparse differentiation becomes relevant. Benchmark data can be generated with the following code:</p> <div><div><pre><code><span>scenarios</span> <span>=</span> <span>[</span>
    <span>Scenario</span><span>{</span><span>:</span><span>jacobian</span><span>,</span> <span>:</span><span>out</span><span>}(</span><span>iter_diff</span><span>,</span> <span>rand</span><span>(</span><span>n</span><span>);</span> <span>contexts</span><span>=</span><span>(</span><span>Constant</span><span>(</span><span>k</span><span>),))</span>
    <span>for</span> <span>n</span> <span>in</span> <span>round</span><span>.</span><span>(</span><span>Int</span><span>,</span> <span>10</span> <span>.^</span> <span>(</span><span>1</span><span>:</span><span>0.3</span><span>:</span><span>4</span><span>))</span>
<span>]</span>
<span>data</span> <span>=</span> <span>benchmark_differentiation</span><span>(</span>
    <span>[</span><span>ad</span><span>,</span> <span>asd</span><span>],</span> <span>scenarios</span><span>;</span> <span>benchmark</span><span>=:</span><span>full</span><span>,</span> <span>logging</span><span>=</span><span>true</span>
<span>)</span>
</code></pre></div></div> <p>It gives rise to the following performance curves (lower is better):</p> <figure> <picture> <source media="(max-width: 480px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/demo/benchmark-480.webp"/> <source media="(max-width: 800px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/demo/benchmark-800.webp"/> <source media="(max-width: 1400px)" srcset="/2025/assets/img/2025-04-28-sparse-autodiff/demo/benchmark-1400.webp"/> <img src="https://iclr-blogposts.github.io/2025/assets/img/2025-04-28-sparse-autodiff/demo/benchmark.png" width="auto" height="auto" onerror="this.onerror=null; $(&#39;.responsive-img-srcset&#39;).remove();"/> </picture> </figure> <p> Figure 22: Performance benefits of sparsity </p> <p>As we can see on Figure 22, there are three main regimes:</p> <ol> <li>For very small inputs, we gain nothing by leveraging sparsity.</li> <li>For medium-sized inputs, sparsity handling is only useful if we can amortize the cost of detection and coloring.</li> <li>For very large inputs, even the overhead of detection and coloring is worth paying as part of a sparse Jacobian computation.</li> </ol> <p>Importantly, ASD can yield an <strong>asymptotic speedup</strong> compared to AD, not just a constant one. In our test case, the cost of a JVP for <code>iter_diff</code> scales with $kn$. Sparse differentiation requires $c$ JVPs instead of $n$, so with $c = k+1$ here its total cost scales as $\Theta(k^2 n)$ instead of $\Theta(k n^2)$. Thus, on the log-log plot of Figure 22, the ASD curve (without detection) has a slope of $1$ while the AD curve has a slope of $2$.</p> <p>Although the specific thresholds between regimes are problem-dependent, our conclusions hold in general.</p> <h2 id="conclusion">Conclusion</h2> <p>By now, the reader should have a better understanding of how sparsity can be used for efficient differentiation.</p> <p>But should it always be used? Here are a list of criteria to consider when choosing between AD and ASD:</p> <ul> <li> <strong>Which derivative is needed?</strong> When computing gradients of scalar functions using reverse mode, sparsity can’t be leveraged, as only a single VJP is required. In practice, ASD only speeds up derivatives like the Jacobian and Hessian which have a matrix form.</li> <li> <strong>What operations will be performed on the derivative matrix?</strong> For a single matrix-vector product $J \mathbf{v}$, the Jacobian operator will always be faster. But if we want to solve linear systems $J \mathbf{v} = \mathbf{y}$, then it may be useful to compute the full Jacobian matrix first to leverage sparse factorization routines.</li> <li> <strong>How expensive is the function at hand?</strong> This directly impacts the cost of a JVP, VJP or HVP, which scales with the cost of one function evaluation.</li> <li> <strong>How sparse would the matrix be?</strong> This dictates the efficiency of sparsity detection and coloring, as well as the number of matrix-vector products necessary. While it may be hard to get an exact estimate, concepts like partial separability can help provide upper bounds <d-cite key="gowerComputingSparsityPattern2014"></d-cite>. In general, the relation between the number of colors $c$ and the dimension $n$ is among the most crucial quantities to analyze.</li> </ul> <p>In simple settings (like finite differences, which create banded Jacobians), the sparsity pattern and optimal coloring can be derived manually. But as soon as the function becomes more complex, <strong>automating this process becomes essential</strong> to ensure wide usability. We hope that the exposition above will motivate the implementation of user-friendly ASD in a variety of programming languages and AD frameworks.</p> </div></div>
  </body>
</html>
