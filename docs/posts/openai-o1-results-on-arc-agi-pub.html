<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arcprize.org/blog/openai-o1-results-arc-prize">Original</a>
    <h1>OpenAI o1 Results on ARC-AGI-Pub</h1>
    
    <div id="readability-page-1" class="page"><div>


<h3 id="arc-prize-testing-and-notes-on-openais-new-o1-model">ARC Prize testing and notes on OpenAI&#39;s new o1 model</h3>

<p>Over the past 24 hours, we got access to OpenAI&#39;s newly released <code>o1-preview</code> and <code>o1-mini</code> models specially trained to emulate reasoning. These models are given extra time to generate and refine reasoning tokens before giving a final answer.</p>

<p><a href="https://x.com/arcprize/status/1834348966663856577" target="_blank">Hundreds of people</a> have asked how o1 stacks up on ARC Prize. So we put it to test using the same baseline testing harness we&#39;ve used to assess Claude 3.5 Sonnet, GPT-4o, and Gemini 1.5. Here are the results:</p>

<p><img src="https://cdn.zappy.app/9b60c2cb230af28f29a5f2a0506dbff1.png" alt="ARC-AGI-Pub Leaderboard"/></p>

<p>Is o1 a new paradigm towards AGI? Will it scale up? What explains the massive difference between o1&#39;s performance on IOI, AIME, and many other <a href="https://openai.com/index/learning-to-reason-with-llms/" target="_blank">impressive benchmark scores</a> compared to only modest scores on ARC-AGI?</p>

<p>There&#39;s a lot to talk about.</p>

<hr/>

<h3 id="chain-of-thought">Chain-of-Thought</h3>

<p>o1 fully realizes the &#34;let&#39;s think step by step&#34; chain-of-thought (CoT) paradigm by applying it at both training time <em>and</em> test time inference.</p>

<figure>
  <img src="https://arcprize.org/media/images/blog/openai-o1-performance.png" alt="OpenAI o1 Performance Chart"/>
  <figcaption>Source: OpenAI &#34;<a href="https://openai.com/index/learning-to-reason-with-llms/" target="_blank">Learning to Reason with LLMs</a>&#34;.</figcaption>
</figure>

<p>In practice, o1 is significantly less likely to make mistakes when performing tasks where the sequence of intermediate steps is well-represented in the synthetic CoT training data.</p>

<p>At training time, OpenAI says they&#39;ve built a new reinforcement learning (RL) algorithm and a highly data-efficient process that leverages CoT.</p>

<p>The implication is that the foundational source of o1 training is still a fixed set of pre-training data. But OpenAI is also able to generate tons of synthetic CoTs that emulate human reasoning to further train the model via RL. An unanswered question is how OpenAI selects which generated CoTs to train on?</p>

<p>While we have few details, reward signals for RL were likely achieved using verification (over formal domains like math and code) and human labeling (over informal domains like task breakdown and planning.)</p>

<p>At inference time, OpenAI says they&#39;re using RL to enable o1 to hone its CoT and refine the strategies it uses. We can speculate the reward signal here is some kind of actor + critic system similar to ones OpenAI <a href="https://openai.com/index/finding-gpt4s-mistakes-with-gpt-4/" target="_blank">previously published</a>. And that they&#39;re applying search or backtracking over the generated reasoning tokens at inference time.</p>

<hr/>

<h3 id="test-time-compute">Test-Time Compute</h3>

<p>The most important aspect of o1 is that it shows a working example of applying CoT reasoning search to informal language as opposed to formal languages like math, code, or Lean.</p>

<p>While added train-time scaling using CoT is notable, the big new story is test-time scaling.</p>

<p>We believe iterated CoT genuinely unlocks greater generalization. Automatic iterative re-prompting enables the model to better adapt to novelty, in a way similar to test-time fine-tuning leveraged by the MindsAI team.</p>

<p>If we only do a single inference, we are limited to reapplying memorized programs. But by generating intermediate output CoTs, or programs, for each task, we unlock the ability to compose learned programs components, achieving adaption. This technique is one way to surmount the #1 issue of large language model generalization: the ability to adapt to novelty. Though like test-time fine-tuning it does ultimately remain limited.</p>

<p>When AI systems are allowed a variable amount of test-time compute (e.g., the amount of reasoning tokens or the time to search), there is no objective way to report a single benchmark score because it&#39;s relative to the allowed compute. That is what <a href="https://arcprize.org/media/images/blog/openai-o1-performance.png">this chart</a> shows.</p>

<p>More compute means more accuracy.</p>

<p>When OpenAI released o1 they could have allowed developers to specify the amount of compute or time allowed to refine CoT at test-time. Instead, they&#39;ve &#34;hard coded&#34; a point along the test-time compute continuum and hid that implementation detail from developers.</p>

<p>With varying test-time compute, we can no longer just compare the output between two different AI systems to assess relative intelligence. We need to also compare the compute <em>efficiency</em>.</p>

<p>While OpenAI&#39;s announcement did not share efficiency numbers, it&#39;s exciting we&#39;re now entering a period where efficiency will be a focus. Efficiency is critical to the <a href="https://arcprize.org/arc#agi-definition">definition of AGI</a> and this is why ARC Prize enforces an efficiency limit on winning solutions.</p>

<p><strong>Our prediction</strong>: expect to see way more benchmark charts comparing accuracy vs test-time compute going forward.</p>

<hr/>

<h3 id="arc-agi-pub-model-baselines">ARC-AGI-Pub Model Baselines</h3>

<p>OpenAI <code>o1-preview</code> and <code>o1-mini</code> both outperform <code>GPT-4o</code> on the ARC-AGI public evaluation dataset. <code>o1-preview</code> is about on par with Anthropic&#39;s Claude 3.5 Sonnet in terms of accuracy but takes about 10X longer to achieve similar results to Sonnet.</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Score <small>(public eval)</small></th>
      <th>Verification Score <small>(semi-private eval)</small></th>
      <th>Avg Time/Task <small>(mins)</small></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>o1-preview</td>
      <td>21.2%</td>
      <td>18%</td>
      <td>4.2</td>
    </tr>
    <tr>
      <td>Claude 3.5</td>
      <td>21%</td>
      <td>14%</td>
      <td>0.3</td>
    </tr>
    <tr>
      <td>o1-mini</td>
      <td>12.8%</td>
      <td>9.5%</td>
      <td>3.0</td>
    </tr>
    <tr>
      <td>GPT-4o</td>
      <td>9%</td>
      <td>5%</td>
      <td>0.3</td>
    </tr>
    <tr>
      <td>Gemini 1.5</td>
      <td>8%</td>
      <td>4.5%</td>
      <td>1.1</td>
    </tr>
  </tbody>
</table>

<p>To get the baseline model scores on the ARC-AGI-Pub leaderboard, we&#39;re using the <a href="https://www.kaggle.com/code/gregkamradt/using-frontier-models-on-arc-agi-via-langchain?scriptVersionId=184611945" target="_blank">same baseline prompt</a> we used to test <code>GPT-4o</code>. When we test and report results on pure models like o1, our intention is to get a measurement of base model performance, as much as that is possible, without layering on any optimization.</p>

<p>Others may discover better ways to prompt CoT-style models in the future, and we are happy to add those to the leaderboard if verified.</p>

<p>o1&#39;s performance increase did come with a time cost. It took 70 hours on the 400 public tasks compared to only 30 minutes for <code>GPT-4o</code> and Claude 3.5 Sonnet.</p>

<p>You can use our <a href="https://www.kaggle.com/code/gregkamradt/testing-o1-preview-on-arc-agi" target="_blank">open source Kaggle notebook</a> as a baseline testing harness or starting point for your own approach. The SOTA submission on the public leaderboard is the result of clever techniques in addition to cutting edge models.</p>

<p>Maybe you can figure out how to leverage o1 as a foundational component to achieve a higher score in a similar way!</p>



<hr/>

<h2 id="is-agi-here">Is AGI Here?</h2>

<p>On <a href="https://arcprize.org/media/images/blog/openai-o1-performance.png">this chart</a>, OpenAI shows a log-linear relationship between accuracy and test-time compute on AIME. In other words, with exponentially increasing compute, accuracy goes up linearly.</p>

<p>A new question many are asking: how far does this scale?</p>

<p>The only conceptual limit to the approach is the <a href="https://en.wikipedia.org/wiki/Decidability_(logic)" target="_blank">decidability</a> of the problem posed to the AI. So long as the search process has an external verifier which does contain the answer, you will see accuracy scale up logarithmically with compute.</p>

<p>In fact, the reported results are extremely similar to one of ARC Prize&#39;s <a href="https://redwoodresearch.substack.com/p/getting-50-sota-on-arc-agi-with-gpt" target="_blank">top approaches</a> by Ryan Greenblatt. He achieved a score of 43% by having <code>GPT-4o</code> generate k=2,048 solution programs per task and deterministically verifying them against the task demonstrations.</p>

<p>Then he assessed how accuracy varied for different values of k.</p>

<figure>
  <img src="https://arcprize.org/media/images/blog/o1-top-3-accuracy-vs-k.jpg" alt="Top 3 Accuracy vs k"/>
  <figcaption>Source: Ryan Greenblatt.</figcaption>
</figure>

<p>Ryan found an identical log-linear relationship between accuracy and test-time compute on ARC-AGI.</p>

<p>Does all this mean AGI is here if we just scale test-time compute? Not quite.</p>

<p>You can see similar exponential scaling curves by looking at any brute force search which is O(x^n). In fact, we know at least 50% of ARC-AGI can be solved via brute force and zero AI.</p>

<p>To beat ARC-AGI this way, you&#39;d need to generate over 100 million solution programs per task. Practicality alone rules out O(x^n) search for scaled up AI systems.</p>

<p>Moreover, we know this is not how humans beat ARC tasks. Humans do not generate thousands of potential solutions, instead we use the perception network in our brains to &#34;see&#34; a handful of potential solutions and determnistically check them with system 2-style thinking.</p>

<p>We can get smarter.</p>

<hr/>

<h2 id="new-ideas-are-needed">New Ideas Are Needed</h2>

<p>Intelligence can be measured by looking at how well a system converts information to action over a space of situations. It&#39;s a conversion ratio and thus approaches a limit. Once you have perfect intelligence, the only way to progress is to go collect new information.</p>

<p>There are a couple ways a less intelligent system could appear more intelligent without actually being more intelligent.</p>

<p>One way is a system that just memorizes the best action. This kind of system would be very brittle, appearing intelligent in one domain, but fall over easily in another.</p>

<p>Another way is through trial and error. A system might appear intelligent if it eventually gets the right answer, but not if it needs 100 guesses first.</p>

<p>We should expect future test-time compute research to look at how to scale search and refinement more efficiently, perhaps using deep learning to guide the search process.</p>

<p>That said, we don&#39;t believe this alone explains the big gap between o1&#39;s performance on ARC-AGI and other objectively difficult benchmarks like IOI or AIME.</p>

<p>A more sufficient way to explain this is that o1 still operates primarily within distribution of its pre-training data, but now inclusive of all the newly generated synthetic CoTs.</p>

<p>The additional synthetic CoT data increases focus on the distribution of CoTs as opposed to just the distribution of answers (more compute is spent on how to get the answer vs what is the answer). We expect to see systems like o1 do better on benchmarks that involve reusing well-known emulated reasoning templates (programs) but will still struggle to crack problems that require synthesizing brand new reasoning on the fly.</p>

<p>Test-time refinement on CoT can only correct reasoning mistakes so far. This also suggests why o1 is so impressive in certain domains. Test-time refinement on CoT gets an additional boost when the base model is pre-trained in a similar way.</p>

<p>Either approach alone would not get you the big leap.</p>

<p>In summary, o1 represents a paradigm shift from &#34;memorize the answers&#34; to &#34;memorize the reasoning&#34; but is not a departure from the broader paradigm of fitting a curve to a distribution in order to boost performance by making everything in-distribution.</p>

<p>We still need new ideas for AGI.</p>

<h3 id="take-action">Take Action</h3>

<p>Deep CoT itegration is an exciting, new direction and there&#39;s much more to be discovered. ARC Prize exists to bring this energy to open source so that all can benefit from open AGI in our lifetime.</p>

<p>Do you have ideas on how to push these new ideas further? What about CoT with multi-modal, CoT with code generation, or combining program search with CoT?</p>

<p>Now is the time to jump into the action by participating in ARC Prize. Win top score prizes and paper awards and the attention and respect of millions.</p>

<p>Great ideas can come from anywhere. Maybe you?</p>

<p>Try hacking on o1 yourself starting with our default <a href="https://www.kaggle.com/code/gregkamradt/testing-o1-preview-on-arc-agi" target="_blank">Kaggle notebook</a>.</p>

<p><a href="#" data-modal-id="newsletter">Sign up for ARC Prize</a> to get notified when new high scores hit the leaderboard.</p>

		</div></div>
  </body>
</html>
