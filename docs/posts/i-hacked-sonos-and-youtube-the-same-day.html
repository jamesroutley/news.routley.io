<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.deadf00d.com/post/how-i-hacked-sonos-and-youtube-the-same-day.html">Original</a>
    <h1>I hacked SONOS and YouTube the same day</h1>
    
    <div id="readability-page-1" class="page"><div> <p><strong>SONOS</strong> is a brand of connected speakers that allow users on the network listen to music that they can choose using the <strong>SONOS</strong> specific <strong>Android / iOS</strong> application, or 3d party services with monthly subscription like <strong>Deezer</strong> / <strong>Spotify</strong> / <strong>YouTube Music</strong> from their local network.</p> <p><strong>SONOS</strong> has been growing in popularity and user base last years and there is a high probability that you already used it. Parts of this success are that <strong>SONOS</strong> provide affordable, high quality, and easy to use products. You pull it out of the box, connect it to your network, setup it with your music provider and that&#39;s it !</p> <p>Problem of using <strong>SONOS</strong> products, is the &#34;music provider&#34; as a requirement. As you probably already know it, using a music provider with your <strong>SONOS</strong> speaker is big part of the product experience. You can technically use your <strong>SONOS</strong> to play local music from your device, I found the experience not satisfying at all.</p> <p>In old days you could also use your <strong>SONOS</strong> combined with an <strong>iOS</strong> device and their <strong>Airplay technology</strong>, that allowed you to stream whatever sound come from your device, <strong>YouTube</strong> videos included. Unfortunately, this is not available to <strong>Android / PC devices</strong>.</p> <p>So, that take us to the subject of playing <strong>YouTube</strong> videos. Even if <strong>YouTube</strong> videos are publicly available and their content are free, <strong>SONOS</strong> can&#39;t play them without the use of <strong>YouTube Music</strong> which is not cool. <strong>YouTube</strong> is a big place for finding music, especially old live concert, or forgotten songs.</p> <p><em>So, &#34;How do we play YouTube videos on a SONOS ?&#34;.</em></p> <p>In our path of digging into the <strong>SONOS</strong> system, we&#39;ll discover exotic audio format, interesting stream management techniques, and how we can abuse innocent features, &#34;for fun and profit&#34;.</p> <h2>Reverse Engineering of SONOS desktop application.</h2> <p><img src="https://admin.deadf00d.com/uploads/1_j_EO_Jf_Ztza_Hg_Bl_XN_Jl_UO_0v_A_a640bcbc94.jpeg" alt="1_jEOJfZtzaHgBlXNJlUO0vA.jpeg"/></p> <p>As a start, I choose to study the <strong>SONOS</strong> desktop application in order to better understand the involved protocol and specifications for music switching, new radio, volume up / down, etc.</p> <p>So I fire up <strong>Wireshark</strong> and filter by my <strong>SONOS</strong> ip address. First packets are pretty clear, <strong>SONOS</strong> is using SSDP for device discovery and UPNP for device control which are standard for these kind of device.</p> <p>After some digging, I find a really interesting request that is linked to the Web-Radio feature of the device.</p> <p>Indeed, part of the <strong>SONOS</strong> feature is that it can stream Web-Radios by choosing them on a list from the app, or <strong>add your own !</strong></p> <p>Here is the linked request:</p>  <p>This dump is a switch request to a previously added web-radio:</p> <pre><code>x-rincon-mp3radio://100radio-albi.ice.infomaniak.ch/100radio-albi-128.mp3
</code></pre> <p>Note the <strong>custom URL protocol</strong>, that indicate that it try to play a <strong>MP3 Radio</strong>. But later tests will show that it works not only for <strong>MP3</strong> but for quasi every supported encoding.</p> <p>After these discoveries I try to google this prefix, in the hope of finding other ones that could be useful in our case. And found this post (<a href="https://community.ezlo.com/t/sonos-plugin/169644/204">https://community.ezlo.com/t/sonos-plugin/169644/204</a>) from 2012 of someone who extracted supported prefix of <strong>Web-Radios</strong> from a <strong>DLL</strong> on a (very) old version of the <strong>SONOS</strong> Application, here is it:</p> <pre><code>http-get::audio/mp3:
x-file-cifs::audio/mp3:
http-get::audio/mp4:
x-file-cifs::audio/mp4:
http-get::audio/mpeg:
x-file-cifs::audio/mpeg:
http-get::audio/mpegurl:
x-file-cifs::audio/mpegurl:
real.com-rhapsody-http-1-0::audio/mpegurl:
file::audio/mpegurl:
http-get::audio/mpeg3:
x-file-cifs::audio/mpeg3:
http-get::audio/wav:
x-file-cifs::audio/wav:
http-get::audio/wma:
x-file-cifs::audio/wma:
http-get::audio/x-ms-wma:
x-file-cifs::audio/x-ms-wma:
http-get::audio/aiff:
x-file-cifs::audio/aiff:
http-get::audio/flac:
x-file-cifs::audio/flac:
http-get::application/ogg:
x-file-cifs::application/ogg:
http-get::audio/audible:
x-file-cifs::audio/audible:
real.com-rhapsody-http-1-0::audio/x-ms-wma:
real.com-rhapsody-direct::audio/mp3:
sonos.com-mms::audio/x-ms-wma:
sonos.com-http::audio/mpeg3:
sonos.com-http::audio/mpeg:
sonos.com-http::audio/wma:
sonos.com-http::audio/mp4:
sonos.com-spotify::audio/x-spotify:
sonos.com-rtrecent::audio/x-sonos-recent:
real.com-rhapsody-http-1-0::audio/x-rhap-radio:
real.com-rhapsody-direct::audio/x-rhap-radio:
pandora.com-pndrradio::audio/x-pandora-radio:
pandora.com-pndrradio-http::audio/mpeg3:
sirius.com-sirradio::audio/x-sirius-radio:
x-rincon:::*
x-rincon-mp3radio:::*
x-rincon-playlist:::*
x-rincon-queue:::*
x-rincon-stream:::*
x-sonosapi-stream:::*
x-sonosapi-radio::audio/x-sonosapi-radio:
x-rincon-cpcontainer:::*
last.fm-radio::audio/x-lastfm-radio:
last.fm-radio-http::audio/mpeg3:
</code></pre> <p>As we can see, <strong>SONOS</strong> is apparently able to play standard <strong>MP4</strong>. This should solve my problem as main encoder YouTube use is <strong>MP4</strong>. Unfortunatly, I wasn&#39;t able to make work any of them. Alright, rabbit hole, let&#39;s continue.</p> <h2>MP3 or not MP3, that is question.</h2> <p>From our discovery, we are able to stream arbitrary <strong>MP3</strong> files on the <strong>SONOS</strong>, so we could technically build our first POC on a <strong>MP4</strong> to <strong>MP3</strong> file.</p> <p><strong>YouTube</strong> <strong>MP4</strong> is <strong>stream oriented</strong>, which mean that part of the video and audio are sent over the time to build the cache (that&#39;s the white part of the video progress bar).</p> <p>Finally, <strong>MP4</strong> and <strong>MP3</strong> are really different encoding. And building a <strong>stream oriented</strong> <strong>MP4</strong> to <strong>MP3</strong> is pretty hard (if not impossible). So one step would be a local download of the <strong>MP4</strong> YouTube, then a conversion <strong>MP4</strong> to <strong>MP3</strong>.</p> <p>That&#39;s an incredibly slow and un-elegant solution, but hey ! It&#39;s a first step at least.</p> <h2>More discoveries on SONOS supported encoding.</h2> <p>After a lot more research I found this documentation page about supported encoding:</p> <p><img src="https://admin.deadf00d.com/uploads/1_Zdi_Oudq_Y3_Nhe_H8_Kua_PU_3g_734c8074dd.png" alt="1_-ZdiOudqY3NheH8KuaPU3g.png"/></p> <p>This table say that <strong>SONOS</strong> support <strong>AAC</strong>. This is a very good news. In fact <strong>AAC</strong> is used to encode audio in <strong>MP4</strong> video format. After a lot of tries, it seems that <strong>SONOS</strong> can&#39;t play raw <strong>AAC</strong> but need a streaming container protocol name <strong>ADTS</strong>.</p> <p>So we could extract <strong>AAC</strong> part of <strong>MP4</strong> convert it to <strong>ADTS</strong> and send it to the <strong>SONOS</strong>.</p> <p>Actually at this point I&#39;ve been able to play <strong>ADTS</strong> formatted <strong>AAC</strong> files on the <strong>SONOS</strong> using the previous discovered prefix &#34;x-rincon-mp3radio&#34;.</p> <h2>New plan !</h2> <p>My new plan is to build a web server that serve <strong>ADTS</strong> formatted <strong>YouTube</strong> video content.</p> <p>The <strong>SONOS</strong> ask a resource containing a <strong>YouTube</strong> video ID</p> <p>Then the server ask to YouTube the corresponding video.</p> <p>For each packet received:</p> <ul> <li>Parse <strong>MP4</strong>.</li> <li>Extract <strong>AAC</strong>.</li> <li>Format it to <strong>ADTS</strong>.</li> <li>Send it back to the <strong>SONOS</strong>.</li> </ul> <p>Here is a schematic:</p> <p><img src="https://admin.deadf00d.com/uploads/1_9g6_VA_0_JU_Fe_C_Ly6xh_ka_XBQ_954b46d68a.png" alt="1_9g6VA0JUFeCLy6xh_kaXBQ.png"/></p> <p>So in order, we first need a <strong>MP4</strong> parsing implementation.</p> <h2>MP4 parsing.</h2> <h3>But what is MP4 ?</h3> <p>This, is a hard question, cause you have to understand that the <strong>MP4</strong> is not a free format, it has been developed in big part by <strong>Apple</strong>, and is documented in (<a href="https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFPreface/qtffPreface.html">https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFPreface/qtffPreface.html</a>).</p> <p>Here is a quick resume:</p> <p><strong>MP4</strong> is a container format, that mean, it&#39;s like the bottle, but it don&#39;t care of the water in it. So you can store audio, video, metadata, copyrights, in the same format.</p> <p>It is divided in different chunks, called atoms. An atom can also contain atoms, so it is recursive. Every atom has a size, and a name, and a content, among these names: <strong>mdat</strong>, <strong>moov</strong>, <strong>moof</strong>, etc.. And each name define the content of the atom, for example <strong>moof</strong> and <strong>moov</strong> is for <strong>metadatas</strong> and <strong>mdat</strong> is for <strong>audio</strong>.</p> <p>I&#39;m going to call the order of these <strong>atoms</strong> the structure, for example, here is the structure of a <strong>YouTube</strong> video:</p> <p><img src="https://admin.deadf00d.com/uploads/1_IKXET_57_KW_C_Nl98c_BF_Oqaw_1ed312a965.png" alt="1_IKXET57KW_CNl98cBFOqaw.png"/></p> <p>This structure of <strong>MP4</strong> is typical of a streamed content, <strong>ftyp</strong> is mandatory as the first atom. And then each metadata atom (<strong>moov</strong>, <strong>moof</strong>), describe the next content atom. That&#39;s how the <strong>YouTube</strong> player doesn&#39;t have to wait for the video file to be downloaded entirely. After the first atom, he knows everything it need. And they it wait for atoms, and at each pairs of <strong>metadatas</strong>, content atoms and add them to the buffer.</p> <p>That&#39;s why our code will be <strong>stream oriented</strong>, we will use same technique as the YouTube player, our code will format <strong>AAC</strong> to <strong>ADTS</strong> by working with pair of atoms. This greatly reduce loading time, and calculation load on our server.</p> <p><strong>Stream oriented</strong> mean that it use read method to get each bytes we need.</p> <p>The interest of this it that we can provide in input a <strong>file stream</strong> instance or a <strong>socket stream</strong> and using the same function (very useful for tests).</p> <h3>MP4 header parsing:</h3> <p>To get general information about the file, we need to get the first atom called <strong>ftyp</strong>. In order to do this I created a class, his mean is to be created at the parsing to store result, and return it.</p>  <p>And a parsing function:</p>  <p>It get the length of the atom, then the body of n-length, get the two 4 bytes long strings, at [:4] and [4:8], store them then return.</p> <h3>MP4 atoms parsing:</h3> <p>So first we have to get all <strong>atoms</strong> separately. So to store them, I created an <strong>Atom</strong> class, and a parsing function.</p>  <p>Here is the parsing part:</p>  <p>First it get first 4 bytes, and cast them as <strong>32 bit integer</strong>, this is the <strong>atom size</strong>. Then it take the <strong>atom body</strong>. And in the <strong>atom body</strong> it take the first 4 bytes and decode them as a <strong>string</strong>. It&#39;s the <strong>atom type</strong>. Finally it return everything as a <strong>object</strong> storing the parsed <strong>atom</strong>.</p> <h3>Why two separate class and function to do roughly the same thing ?</h3> <p>It&#39;s just my way of ordering my code, it make it more understandable for the next. Like you have <strong>GetHeader</strong> first then a loop of <strong>GetNextAtomStream</strong>. I think it&#39;s clean.</p> <h3>Mdat &amp; trun atom parsing:</h3> <p>These atoms are containing audio frames for <strong>mdat</strong>, and <strong>trun atom</strong> is containing the <strong>AAC</strong> frame length (as 32 bit integer). Which is important to build an <strong>ADTS</strong> stream. Here is the implementation for <strong>trun</strong>:</p>  <p>And here is implementation for <strong>mdat</strong>, it take the <strong>TrunAtom</strong> object in parameter, to slice each frames independently.</p>  <h3>Main loop:</h3> <p>This is the first version of the main loop, it just parse the <strong>MP4</strong> atoms, then loop into <strong>AAC</strong> frames from <strong>mdat</strong> (built from <strong>trun</strong>, as explained before). That&#39;s here that we gonna put our <strong>ADTS</strong> packet building implementation. It also display some information about other atoms.</p>  <h3>ADTS formatting.</h3> <p>The <strong>ADTS</strong> (Audio Data Transport Stream) is a <strong>AAC</strong> streaming container format / protocol that is not so used nowadays. Documentation about it is pretty hard to find. File or source using it are using the extension .aac and the mime type audio/aac.</p> <p>It is pretty low-level because it is using a <strong>header</strong> - <strong>body</strong> structure. So it first send a <strong>header</strong> about 7–9 bytes long, which is using bit-packing (so very efficient and light), which provide information on the <strong>body</strong> like the size of the frame count. Then it send directly the <strong>body</strong>. And at the last <strong>body</strong> byte, the server is waiting again for a <strong>header</strong>, then a <strong>body</strong>, then a <strong>header</strong>, etc…</p> <p>Here is the <strong>header</strong> format (each letter is a bit, each letter group is a byte):</p> <pre><code>AAAAAAAA AAAABCCD EEFFFFGH HHIJKLMM MMMMMMMM MMMOOOOO OOOOOOPP (QQQQQQQQ QQQQQQQQ)
</code></pre> <p>Extracted from the only documentation I found: <a href="https://wiki.multimedia.cx/index.php/ADTS">https://wiki.multimedia.cx/index.php/ADTS</a></p> <p><img src="https://admin.deadf00d.com/uploads/Screenshot_20220129_145418_78cc00fc9e.png" alt="Screenshot_20220129_145418.png"/></p> <p>For example, here is an <strong>ADTS header</strong> in binary:</p> <pre><code>11111111 11110001 01010000 100000 0000100000000 11111 11111100
</code></pre> <p>A simple implementation of that would be to use the above <strong>header</strong> as a template, and just change the bits representing the size of the <strong>body</strong>.</p> <p>Let&#39;s add few lines to our <strong>main loop</strong> with a <strong>yield</strong> to make it usable as a <strong>generator</strong>.</p>  <p>I know, i know, the <strong>bitarray</strong> part is one of the ugliest piece of code you ever saw. (Must be a constant in Python…)</p> <p><strong>But it work !</strong> So it gonna do the job for few tests.</p> <p>So, now we have a running core, that parse streamed <strong>MP4</strong> parsed and convert it to <strong>ADTS</strong>.</p> <h2>SONOS Client &amp; Server implementation.</h2> <p>What we&#39;re going to do now, is to build the part that request the <strong>SONOS</strong> to play an <strong>AAC</strong> source from our server, and the server himself.</p> <p>My Implementation will use <strong>Python</strong> with <strong>Flask</strong>.</p> <p>We need now to implement a <strong>YouTube</strong> video request, to get the <strong>stream</strong> that we&#39;re going to provide to our <strong>main loop</strong>.</p> <h3>Get the YouTube stream</h3> <p>We&#39;re going to use a cool little <strong>package</strong> called <strong>pytube</strong> (<a href="https://pypi.org/project/pytube/6.4.2/">https://pypi.org/project/pytube/6.4.2/</a>).</p> <p>If you want to try it, please install the <strong>github</strong> version, it seems that a lot of releases are getting broke, I guess due to <strong>YouTube</strong> changes.</p> <p>This library can do neat stuff like listing available <strong>streams</strong> from a <strong>YouTube</strong> URL, getting the title, description, etc.</p> <p>What really interest us, is the feature to download a <strong>video</strong>. (<a href="https://python-pytube.readthedocs.io/en/latest/user/quickstart.html#downloading-a-video">https://python-pytube.readthedocs.io/en/latest/user/quickstart.html#downloading-a-video</a>)</p> <p>Unfortunately, it download the <strong>video</strong> to a location on the <strong>filesystem</strong>, instead of returning a <strong>stream</strong>. We just need to make few modifications from the original method (<a href="https://github.com/nficano/pytube/blob/master/pytube/streams.py#L202">https://github.com/nficano/pytube/blob/master/pytube/streams.py#L202</a>).</p> <p>With it, I&#39;m implementing <strong>GetStreams</strong> and <strong>GetYoutubeVideoInfos</strong> functions.</p>  <p>Really simple.</p> <p>So now, we can do a <strong>Flask</strong> program that get a <strong>YouTube</strong> video ID on a endpoint, get the stream from it then send the <strong>ADTS</strong> back.</p> <p>Here is it:</p>  <h3>Please Sonos, play my song.</h3> <p>So let&#39;s deal with this <strong>Sonos</strong>.</p> <p>As shown in the first part of this project, we have a request that play a <strong>AAC</strong> source, we just need to replace the <strong>x-rincon-mp3radio://100radio-albi.ice.infomaniak.ch/100radio-albi-128.mp3</strong> part with our server address, in my case <strong>192.168.1.16:5000</strong>, and then add our endpoint with the <strong>video ID</strong> we want to play.</p> <p>Save it to request.txt, then:</p> <pre><code>cat request.txt | nc 192.168.1.18 3000
</code></pre> <p>Enjoy your music !</p> <p>This poc will soon become a full featured a Android / iOS application. I&#39;ll keep you updated on this.</p> <p>Thanks, you very much for reading my article.</p> </div></div>
  </body>
</html>
