<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.elodin.systems/post/a-better-approach-to-gravity-how-we-made-egm2008-faster">Original</a>
    <h1>A better approach to gravity: how we made EGM2008 faster</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><div data-w-id="9ab7e733-2bd2-7d8c-9ee9-9e1cd6085149"><div><div><p>‍</p><p>For the last month we&#39;ve been hard at work adding a new feature to Elodin, an ultra-high-speed implementation of EGM2008. EGM2008 – or Earth Gravitational Model 2008 for those acronym phobic readers – a high precision model of Earth&#39;s gravitational field.. What once required significant computational resources can now run in milliseconds, unlocking new possibilities for satellite missions, constellation management, and more.</p><p>‍</p><p>You’d think we could stick to Newton’s classic gravity model (aka the Coulomb model) to explain everything about Earth’s gravitational field. It’d be great if it were that simple, but planetary gravity is far messier. Earth isn’t a perfectly smooth, uniformly dense sphere; it’s more like a slightly squished ball (an oblate spheroid) with bumps and dips from mountains, ocean trenches, and uneven internal mass distribution. So early on (before the space age), scientists began measuring Earth’s gravitational field - using ground-based techniques like pendulum experiments. Though pendulums provided more accuracy than the coulomb model, in order to get accurate enough data for something as simple as an orbit simulation, the pendulums would be unfathomably massive.</p><p>‍</p><p>That all started to change in 1957 with the launch of Sputnik I, the first satellite to reveal how gravity could be studied through its effects on orbits. Early missions like Vanguard and Transit laid the groundwork, giving scientists basic estimates of Earth’s gravity. But the technology of the time had its limits—data was sparse, and computers were primitive. Over the years, advanced satellites like Topex/Poseidon and Lageos brought more detailed and accurate measurements, transforming our understanding of Earth’s gravitational quirks.</p><p>‍</p><p>Fast forward to today, and EGM2008 is the cornerstone of high-precision gravity models. It accounts for every bump and dip, every subtle anomaly in Earth’s gravity field, capturing details earlier methods could never achieve. A big part of this leap forward came from GRACE (Gravity Recovery and Climate Experiment) satellites. Launched in 2002, GRACE used twin satellites to measure tiny variations in Earth’s gravity by tracking the distance between them as they orbited the planet. These variations revealed shifts in mass—whether from melting ice caps, ocean currents, or changes in groundwater. GRACE provided an unprecedented view of how gravity changes over time and space, feeding crucial data into the EGM2008 model. Combined with data from earlier missions like Topex/Poseidon and Lageos, GRACE helped create a model that doesn’t just map Earth’s gravity—it tells the story of its dynamic changes.</p><p>‍</p><p><strong>But how does EGM2008 actually work? </strong>‍</p><figure><p><img src="https://cdn.prod.website-files.com/65badeacc94ad9eb3ec9c27e/674e1781ee139d4424b58c24_674e177485b624c4997784d5_spherical%2520harmonics.jpeg" loading="lazy" alt=""/></p></figure><p>To avoid reinventing the wheel, I looked for a library that already implemented EGM2008, but unfortunately, none could support real-time simulation effectively.  So I set off on a journey to implement the EGM2008 gravity model into our simulation platform. Like any good expedition team preparing for uncharted waters, I stocked up on critical supplies: energy drinks (far too many), research papers, and modern sea shanties (nothing helps me focus like the Interstellar soundtrack). After poring over four different academic papers, I decided to try implementing the approach outlined in <a href="https://hanspeterschaub.info/conferences.html#:~:text=GPGPU%20Implementation%20Of%20Pines%E2%80%99%20Spherical%20Harmonic%20Gravity%20Model" target="_blank">one</a>.</p><p>‍</p><p><strong>My first attempt?</strong> </p><p>Determined to boost performance, I turned to some dark magic: <a href="https://github.com/jax-ml/jax" target="_blank">JAX</a>. I took another shot at implementing the paper’s math, this time “JAXified”. By replacing all the for loops with JAXs “fori” function, I hacked together a new implementation. The results? Marginal improvements—still far from acceptable. At this point, it seemed pointless to switch libraries or try another paper’s approach.</p><p>While marinating in defeat, I realized that the mathematical steps in the paper weren’t compatible with JAX’s optimizations, due to heavy use of conditionals and recursion (both big no-nos in JAX). The strength of JAX lies in its ability to perform vector computation, utilizing specialized instructions for simultaneous array operations. Recursion and conditional expressions, however, prevent the use of vectorization, resulting in slower execution. With this insight, I set out to reformulate the math to better align with JAX’s computation schemes. As I worked, I found even more areas to optimize. With a new mission plan, I dove in.</p><p>First, I reformulated all the math to use array operations (snippet of the reformulation is shown below). This way, I was able to swap out for-loops for combinations of JAX’s scan and vmap functions and compute the addend of these summation blocks by using traditional array operations rather than traversing through them and doing element by element scalar operations</p><figure><p><img src="https://cdn.prod.website-files.com/65badeacc94ad9eb3ec9c27e/674e1c257c3ebf9d7f53e546_AD_4nXcinqZAgKhs49nM9DxRepLjnUHvGI-TEh8VWjf_3gO8Xa3M5PQXJPEhGg_AHMonF_0bHkiUEE6B0lt19Ud_KetDYbVwH8XFCqMNcMc4I70eZ03hzSVzFl0cH5A-gors9AqEhimPWw.png" loading="lazy" alt=""/></p></figure><p>Finally, I replaced all conditional execution with precomputed steps or JAX-friendly conditional blocks. Sounds simple enough, right? (Hint: it wasn’t.) It took an entire weekend to reformulate the math and another week of 10- to 12-hour days to implement it. But in the end, I had a working model. Not just any model—my implementation wasn’t just a few milliseconds faster than others. <strong>It was orders of magnitude faster.</strong></p><p>Benchmarking revealed that we are the only available platform capable of simulating gravity using the EGM2008 model at full resolution in real time. That means our platform doesn’t just simulate satellite orbits in real time—it can simulate entire constellations on a laptop. Who’s the fastest kid on the block now, MATLAB? </p><figure><p><img src="https://cdn.prod.website-files.com/65badeacc94ad9eb3ec9c27e/674e1e85bfbe09ad5883c4c2_674e1e7cfe5b82a2b5a2b6dc_benchmark.png" loading="lazy" alt=""/></p></figure><p>‍</p><p>If being blazing fast wasn’t enough, our library is easy to use as well. Typically EGM models are very hard to use – they are embedded in proprietary software and hard to integrate with your existing software stack. Elodin has solved this by exposing our EGM model through a simple Python interface:</p><p>‍</p><pre contenteditable="false"><code><span>gravity_model = egm08.EGM08(defree = </span><span>2159</span><span>, use_j2= False)
</span>gravity_force_vector = gravity_model.compute_field(pos_x, pos_y, pos_z, mass)</code></pre><p>‍</p><p>This breakthrough opens up a whole new world for space simulations, enabling applications like constellation planning, space debris management, fuel budgeting, and control system design. The possibilities are endless, and we’re just getting started. We’re excited to see how people can use our platform&#39;s newest addition to tackle new challenges.</p></div></div></div></div></div></div></div></div>
  </body>
</html>
