<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://a16z.com/2023/04/14/the-modern-transactional-stack/">Original</a>
    <h1>Modern Transactional Stack</h1>
    
    <div id="readability-page-1" class="page"><div>
	                    <p><a href="https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2291-OLTP-Arch-Yoast-FB-1200x630-1.png?ssl=1"><img decoding="async" src="https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2291-OLTP-Arch-Yoast-FB-1200x630-1.png?resize=1024%2C538&amp;ssl=1" alt="" width="1024" height="538" srcset="https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2291-OLTP-Arch-Yoast-FB-1200x630-1.png?resize=1024%2C538&amp;ssl=1 1024w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2291-OLTP-Arch-Yoast-FB-1200x630-1.png?resize=300%2C158&amp;ssl=1 300w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2291-OLTP-Arch-Yoast-FB-1200x630-1.png?resize=768%2C404&amp;ssl=1 768w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2291-OLTP-Arch-Yoast-FB-1200x630-1.png?resize=125%2C66&amp;ssl=1 125w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2291-OLTP-Arch-Yoast-FB-1200x630-1.png?resize=590%2C310&amp;ssl=1 590w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2291-OLTP-Arch-Yoast-FB-1200x630-1.png?resize=1120%2C588&amp;ssl=1 1120w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2291-OLTP-Arch-Yoast-FB-1200x630-1.png?w=1201&amp;ssl=1 1201w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></a></p>
<p><span>Transactional databases have long been the most critical component of application design. Why? Because a steadfast database is generally the ultimate enforcement point for correctness in a messy, distributed world. Without them we’d overpay and undercharge. We’d lose riders trying to get home from the airport, and we’d lose items in our shopping carts. Our online accounts would get lost, duplicated, or corrupted, and become inoperable. </span></p>
<p><span>In fact, the transactional database (generally called OLTP — short for online transaction processing — database) has been so central to application development that, over time, it consumed more and more application functionality. However, microservices and other modern application architectures introduced new complexities into application design: Developers needed to manage data across different services and ensure consistency between them, which forced them to build complex data synchronization and processing mechanisms in-house. </span></p>
<p><span>And so, as an industry, we’re seeing increasing awareness that transactional guarantees are needed outside of the traditional model. We’re seeing the <strong>emergence of systems that extend strong transactional guarantees beyond the database, into the distributed apps themselves</strong>. </span></p>
<p><span>We’ve been tracking these solutions over the last few years. Generally, they strive to allow for transactional management of state in a large distributed app, without creating scaling challenges and while providing a modern programming environment. </span></p>
<p><span>We find these solutions roughly break down into two categories. One category is </span><i><span>workflow orchestration</span></i><span>. This basically guarantees that a block of code will run to completion, even in the face of failure. So it can be used for the purpose of managing a distributed state machine deterministically without getting wonky. The second category is </span><i><span>database + workflow</span></i><span>, which extends traditional OLTP database design, allowing for the execution of arbitrary code for the same purpose. </span></p>
<p><span>This is still a very nascent area, and there is a lot of confusion around nomenclature, how each tool is used in practice, and who should be using them. To help get a better understanding, we asked practitioners from leading engineering organizations about their transactional stack and how they’re thinking about three key concepts for transactional workloads: application state, business logic, and business data. </span></p>
<p><i><span>Before examining these new stacks, though, here’s a quick semi-technical digression to help understand how we got here.</span></i></p>
<h2><span>Transactions, guarantees, and modern apps </span></h2>
<p><span>The very rough version is this: There are a set of tasks — transactions — that you either want to do all of, or none of. Anything in between (having it partially done) will end in a corrupt state. It’s hard to guarantee </span><i><span>anything</span></i><span> in a distributed system, but databases do it well with transactions. Therefore, the easiest way to handle guarantees in many systems is to just make most things transactions and let the database handle them.</span></p>
<p><span>Modern apps are big distributed systems with lots of users doing lots of things. So even keeping the app state consistent (like tracking where different users are in a check-out flow) turns into a distributed transaction problem. In traditional monolithic architectures, managing transactions using SQL with an OLTP database was somewhat effective. But in the new, complex world of microservices interacting through higher-level APIs (e.g. REST or gRPC), transactional needs have become distributed in nature. </span></p>
<p><span>However, many companies going on the journey to microservices haven’t done much to extend strong transactional guarantees beyond the database. And, in practice, that’s </span><i><span>almost always</span></i><span> OK. But as applications scale, inconsistencies in data grow, as does the resulting bugginess and un-reconciled errors in business data. Which, of course, can be hugely problematic. This forces application developers to deal with a wide swath of failure scenarios and conflict resolution strategies, and to ensure state consistency by coming up with their own strategies through different architectural patterns.</span></p>
<div>
<h3><strong>Definitions</strong></h3>
<p><b>Business data (“data”) </b><span>refers to the business-critical data traditionally stored in an OLTP database for persistence and processing (e.g. user profile info such as name, address, credit score, etc.).</span></p>
<p><b>Application state</b><span> refers to the current state of the system; the application state is determined by a value stored in a data storage system and which step the program’s execution is on in a finite state machine (e.g. the state of an order, such as “order received,” “inventory checked,” “credit checked,” “shipped,” “returned”).</span></p>
<p><b>Business logic</b> <span>refers to the part of the program that deals with how the application actually works or what it does, instead of execution details (e.g. “If user_income &gt; $100K &amp; credit_score &gt;650 ⇒ mortgage_approved = TRUE”).</span></p></div>
<p><span>For the purposes of this discussion, it’s important to distinguish application state and business data. For example, knowing that a customer has entered their credit card but has not checked out is application state. The data for the credit card and the items in the application cart are the business data. </span></p>
<p><a href="https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/1.-Status-Quo-R4.png?ssl=1"><img decoding="async" loading="lazy" src="https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/1.-Status-Quo-R4.png?resize=1024%2C919&amp;ssl=1" alt="" width="1024" height="919" srcset="https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/1.-Status-Quo-R4.png?resize=1024%2C919&amp;ssl=1 1024w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/1.-Status-Quo-R4.png?resize=300%2C269&amp;ssl=1 300w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/1.-Status-Quo-R4.png?resize=768%2C689&amp;ssl=1 768w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/1.-Status-Quo-R4.png?resize=1536%2C1378&amp;ssl=1 1536w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/1.-Status-Quo-R4.png?resize=125%2C112&amp;ssl=1 125w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/1.-Status-Quo-R4.png?resize=279%2C250&amp;ssl=1 279w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/1.-Status-Quo-R4.png?resize=368%2C330&amp;ssl=1 368w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/1.-Status-Quo-R4.png?resize=702%2C630&amp;ssl=1 702w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/1.-Status-Quo-R4.png?w=2000&amp;ssl=1 2000w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></a></p>
<p><span>In a typical flow, a request comes from the front-end, is authenticated, and then gets routed via an API gateway or GraphQL to the relevant endpoint. </span></p>
<p><span>That single API endpoint now has to orchestrate tens, or hundreds, of microservices to deliver the business transaction to the end-customer. This is where developers typically lump everything into business logic blobs, and then use a combination of queues, caches, and hand-coded retry mechanisms to get the data to the database — hopefully committed as a full transaction.</span></p>
<p><span>As the scale of the application increases, so does the complexity of managing queues and caches, as well as the number of sharp edges in reconciliation logic when issues arise. </span></p>
<h2><span>The rise of workflow-centric and database-centric transactional stacks</span></h2>
<p><span>OK, so transactions are important. LAMP on a database wasn’t sufficient for scale. And a giant hairball of queues and retry logic is too brittle. To deal with this, we’ve seen, over the last few years, the emergence of new solutions that bring sanity back to transactional logic. They can be roughly categorized as either workflow-centric approaches or database-centric approaches.</span></p>
<p><span>To date, workflow engines work primarily on application state rather than the business data, and often require some complexity when integrating with traditional databases. Database-centric approaches add application logic alongside business data, but don’t yet have the same code- execution sophistication of workflow engines. </span></p>
<p><span>The diagram below provides a rough sketch of how workflow- and/or database-centric approaches are used in a Javascript/Typescript application, assuming both are in use. While they’re distinct pieces of this architecture today, we have seen early signs of a trend where databases are incorporating workflow features and workflows are starting to adopt durable storage. This merging of capabilities indicates that the lines between the two approaches are blurring and becoming less distinct in modern architectures. </span></p>
<p><a href="https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2.-Modern-Transactional-Stack-R4.png?ssl=1"><img decoding="async" loading="lazy" src="https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2.-Modern-Transactional-Stack-R4.png?resize=1024%2C727&amp;ssl=1" alt="" width="1024" height="727" srcset="https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2.-Modern-Transactional-Stack-R4.png?resize=1024%2C727&amp;ssl=1 1024w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2.-Modern-Transactional-Stack-R4.png?resize=300%2C213&amp;ssl=1 300w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2.-Modern-Transactional-Stack-R4.png?resize=768%2C545&amp;ssl=1 768w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2.-Modern-Transactional-Stack-R4.png?resize=1536%2C1090&amp;ssl=1 1536w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2.-Modern-Transactional-Stack-R4.png?resize=125%2C89&amp;ssl=1 125w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2.-Modern-Transactional-Stack-R4.png?resize=465%2C330&amp;ssl=1 465w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2.-Modern-Transactional-Stack-R4.png?resize=888%2C630&amp;ssl=1 888w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/2.-Modern-Transactional-Stack-R4.png?w=2000&amp;ssl=1 2000w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></a></p>
<h3><span>Workflow-centric approaches in detail </span></h3>
<p><span>A workflow is simply blocks of code that execute based on events, or timers, that evolve the application state machine. Transactional workflow ensures code execution with strong guarantees, preventing partial or unintended states in the application. Developers write the logic, and the workflow engine handles transactions, mutations and idempotency. Different workflow engines make different trade-offs in terms of how much of the transaction details are exposed to the developers. </span></p>
<p><span>As an example, below is a visual representation of a check-out workflow running on Orkes (Conductor): </span></p>
<p><a href="https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/image6.png?ssl=1"><img decoding="async" loading="lazy" src="https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/image6.png?resize=500%2C765&amp;ssl=1" alt="" width="500" height="765" srcset="https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/image6.png?resize=669%2C1024&amp;ssl=1 669w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/image6.png?resize=196%2C300&amp;ssl=1 196w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/image6.png?resize=768%2C1176&amp;ssl=1 768w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/image6.png?resize=1003%2C1536&amp;ssl=1 1003w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/image6.png?resize=82%2C125&amp;ssl=1 82w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/image6.png?resize=163%2C250&amp;ssl=1 163w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/image6.png?resize=216%2C330&amp;ssl=1 216w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/image6.png?resize=412%2C630&amp;ssl=1 412w, https://i1.wp.com/a16z.com/wp-content/uploads/2023/04/image6.png?w=1074&amp;ssl=1 1074w" sizes="(max-width: 500px) 100vw, 500px" data-recalc-dims="1"/></a></p>
<p><span>There are </span><b>two rough approaches</b><span> by which workflow engines gain traction. In one (typified by Temporal.io), developers write code using standard back-end programming languages (e.g. Go or Java) and the </span><b>system will ensure the code runs to completion</b><span>, even during a failure. In this model, the program-call stack is maintained even if the code is waiting for a blocking call to complete (e.g. read or write). To do this, the language runtime is modified to prevent partial code execution during failures. The upside to this approach is that developers can write in familiar languages and debug easily with a maintained call stack. We see this approach most popular with back-end teams dealing with large, sophisticated apps. </span></p>
<p><span>The downside is that it often requires a lot of integration work and wrapper code to expose useful and safe interfaces to application developers. Another downside is that it relies on a custom execution layer rather than the bare language, and there are edge cases where the execution will differ from the native language runtime. So, while developers can use languages they are familiar with, they still need to understand how the underlying system works.  </span></p>
<p><span>The other approach, which is more popular with application developers (particularly Typescript/Javascript) is for the workflow engine to </span><b>serve as an orchestrator of async functions</b><span> (e.g. Inngest, Defer, and Trigger). In this model, third-party events or functions are directed to the workflow engine, which will then dispatch logic registered by the application programmers, who must give control back once the need to block on another async function arises. The upside is that this is a far more lightweight method of integrating into a program. It also forces enough structure on the code that the team working on it can understand it more easily. However, this approach can be more difficult to debug without tooling support, so debugging tends to be platform-specific.</span></p>
<p><span>Workflow engines are particularly powerful in that they allow for gradual adoption by existing apps. They can be applied on a piecemeal basis to certain workflows with minimal footprint. That said, the two biggest shortcomings of workflow engines stem from the fact that they don’t extend into the database. As a result, there isn’t a single, queryable source of truth across application state and business data. Also, the transactional semantics are generally different from the database semantics, requiring application developers to handle edge conditions. </span></p>
<p><span>Although not the norm today, we want to illustrate the conceptual architectures of how workflows can in many cases be used as persistent data stores:</span></p>
<div><h4>Examples of Workflow-Only Architectures</h4></div>
<h3><span>Database-centric approaches in detail </span></h3>
<p><span>Database-centric approaches start with a database, but extend it to support arbitrary code execution to allow for workflows alongside data management. They do this by giving control to the programmers so they can make explicit decisions on mutations, transactions, and idempotency for regular code blocks — essentially by exposing OLTP semantics directly. The programmer is responsible for keeping business logic and business data separate from application state. </span></p>
<p><span>Indeed, the pure database view is that application state can always be derived from business data. This is usually done by storing application state as a set of transactions that modify business data in the database. It’s easiest to think of this as a database that can execute blocks of code with the same strong guarantees as the workflow systems described above. </span></p>
<p><span>Internally, we call this the </span><b>application logic transactional platform (ALTP)</b><span> approach because, ultimately, it extends OLTP transactions into the application. But what really characterizes ALTP is that, for greenfield apps, it can entirely obviate the need for the app developers to directly manage back-end infrastructure.  </span></p>
<p><span>From the ALTP lens, the most commonly used approach started with Firebase, which offers a </span><b>full-service “back-end experience,”</b><span> including auth, data store, databases, and more. Firebase and more recent entrants, like Supabase, remain very popular platforms for greenfield projects. And while they tend to stay faithful to their OLTP roots — and so don’t support arbitrary code execution for transactional back-end functions — Supabase is already starting to add support for workflows.</span></p>
<p><span>However, </span><b>next-generation ALTP offerings</b><span> like Convex do allow the execution of arbitrary code as a transaction alongside the database. These offerings allow for writing fully transactionally compliant code in a normal language (e.g. Javascript/Typescript), where a single block of code can read, write, and mutate data — both application state and business data. In a sense, it gives developers a single queryable source of truth, and provides workflow primitives like subscriptions. </span></p>
<p><span>ALTP solves the problem workflow engines have in being decoupled from the database, but, as a result, require the users to rely on their database offering rather than a standard OLTP in order to get the benefits. As a result, we primarily see teams adopt ALTP for greenfield apps, rather than integrating it into existing, complex backends.</span></p>
<p><a href="https://i2.wp.com/a16z.com/wp-content/uploads/2023/04/3.-ALTP-Only-Architecture-R4.png?ssl=1"><img decoding="async" loading="lazy" src="https://i2.wp.com/a16z.com/wp-content/uploads/2023/04/3.-ALTP-Only-Architecture-R4.png?resize=1024%2C727&amp;ssl=1" alt="" width="1024" height="727" srcset="https://i2.wp.com/a16z.com/wp-content/uploads/2023/04/3.-ALTP-Only-Architecture-R4.png?resize=1024%2C727&amp;ssl=1 1024w, https://i2.wp.com/a16z.com/wp-content/uploads/2023/04/3.-ALTP-Only-Architecture-R4.png?resize=300%2C213&amp;ssl=1 300w, https://i2.wp.com/a16z.com/wp-content/uploads/2023/04/3.-ALTP-Only-Architecture-R4.png?resize=768%2C545&amp;ssl=1 768w, https://i2.wp.com/a16z.com/wp-content/uploads/2023/04/3.-ALTP-Only-Architecture-R4.png?resize=1536%2C1090&amp;ssl=1 1536w, https://i2.wp.com/a16z.com/wp-content/uploads/2023/04/3.-ALTP-Only-Architecture-R4.png?resize=125%2C89&amp;ssl=1 125w, https://i2.wp.com/a16z.com/wp-content/uploads/2023/04/3.-ALTP-Only-Architecture-R4.png?resize=465%2C330&amp;ssl=1 465w, https://i2.wp.com/a16z.com/wp-content/uploads/2023/04/3.-ALTP-Only-Architecture-R4.png?resize=888%2C630&amp;ssl=1 888w, https://i2.wp.com/a16z.com/wp-content/uploads/2023/04/3.-ALTP-Only-Architecture-R4.png?w=2000&amp;ssl=1 2000w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></a></p>
<p><span>The diagram above is an amalgam of the many operators we spoke with. Some will just use a workflow engine. Some will just use a database-centric approach. But many will use both — especially when they are just starting to adopt workflows. Users of workflow engines today tend to be back-end teams dealing with large, complex applications, although we have also seen many full-stack teams adopting them. Back-end-as-a-service solutions tend to be more application-developer-friendly and are more commonly used when the app drives technology selection. </span></p>
<h2><span>The convergence</span></h2>
<p><span>It’s becoming clear that workflow-centric approaches and database-centric approaches are on a collision course. The primary reason for this is that while application state and database state are logically distinct, they are dependent on each other, and a system that doesn’t cover both is complex to get right and to debug.  </span></p>
<p><span>As an example, consider a workflow engine being used to track the state machine for a user’s checkout process, and that user is adding an item to a cart. Typically, workflow engines ensure that a code step will run even in the event of a failure. However, there may be instances where the engine needs to rerun a given step during a failure because it’s not entirely sure whether the step was fully completed. If that step involves writing business data to a traditional database (in this case, the item in the cart) and the database isn’t aware of the duplicate retry, it’ll end up with a duplicate entry. </span></p>
<p><span>There are two ways to deal with this. One way is to push the problem to the application developer, which will use a nonce provided by the workflow system to ensure only one item is written. But that assumes the developer understands idempotency, which is notoriously tricky to get right, and this obviates a lot of the magic of having a workflow system. The other way is to tie the workflow engine to a database that is aware of the workflow transactional semantics. This hasn’t quite happened yet, but it’s not hard to believe it will. </span></p>
<p><span>On the other hand, database-centric approaches realize that general workflow is really useful to application developers. And so we’re starting to see databases (like Convex) — which support traditional database functions like queries, mutations, indexes, etc. — implement functionality like scheduling and subscriptions. These allow them to be used as workflow engines. That is, they allow the execution of arbitrary code blocks with strong guarantees. </span></p>
<p><span>As Ian Livingstone (who provided feedback on this piece) put it, “</span><span>It’s the classic ‘Do you bring the application logic to the database, or the database to the application logic?’ playing out again … this time brought on by breaking up the monolith.” Having had that dichotomy for decades, it’s clear both models will persist in the short term. It’s far less clear that’ll remain the case in the long run. </span></p>
<p><i><span>Special thanks to Charly Poly (Defer), Dan Farrelly (Inngest), David Khourshid (Stately), Ian Livingstone (Cape Security), Enes Akar (Upstash), James Cowling (Convex), Jamie Turner (Convex), Paul Copplestone (Supabase), Sam Lambert (PlanetScale), Tony Holdstock-Brown (Inngest), Matt Aitken (Trigger) for reviewing this post and giving feedback. Additionally, thanks to Benjamin Hindman (Reboot), Fredrik Björk (Grafbase), Glauber Costa (Chiselstrike), Guillaume Salles (Liveblocks), Maxim Fateev (Temporal), Steven Fabre (Liveblocks), and Viren Baraiya (Orkes) for helping us with the research.</span></i></p>
<div>
<p>* * *</p>
<p><i>The views expressed here are those of the individual AH Capital Management, L.L.C. (“a16z”) personnel quoted and are not the views of a16z or its affiliates. Certain information contained in here has been obtained from third-party sources, including from portfolio companies of funds managed by a16z. While taken from sources believed to be reliable, a16z has not independently verified such information and makes no representations about the enduring accuracy of the information or its appropriateness for a given situation. In addition, this content may include third-party advertisements; a16z has not reviewed such advertisements and does not endorse any advertising content contained therein.</i></p>
<p><i>This content is provided for informational purposes only, and should not be relied upon as legal, business, investment, or tax advice. You should consult your own advisers as to those matters. References to any securities or digital assets are for illustrative purposes only, and do not constitute an investment recommendation or offer to provide investment advisory services. Furthermore, this content is not directed at nor intended for use by any investors or prospective investors, and may not under any circumstances be relied upon when making a decision to invest in any fund managed by a16z. (An offering to invest in an a16z fund will be made only by the private placement memorandum, subscription agreement, and other relevant documentation of any such fund and should be read in their entirety.) Any investments or portfolio companies mentioned, referred to, or described are not representative of all investments in vehicles managed by a16z, and there can be no assurance that the investments will be profitable or that other investments made in the future will have similar characteristics or results. A list of investments made by funds managed by Andreessen Horowitz (excluding investments for which the issuer has not provided permission for a16z to disclose publicly as well as unannounced investments in publicly traded digital assets) is available at https://a16z.com/investments/.</i></p>
<p><i>Charts and graphs provided within are for informational purposes solely and should not be relied upon when making any investment decision. Past performance is not indicative of future results. The content speaks only as of the date indicated. Any projections, estimates, forecasts, targets, prospects, and/or opinions expressed in these materials are subject to change without notice and may differ or be contrary to opinions expressed by others. Please see https://a16z.com/disclosures for additional important information.</i></p>
</div>
                    </div></div>
  </body>
</html>
