<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arxiv.org/abs/2012.00152">Original</a>
    <h1>Every model learned by gradient descent is approximately a kernel machine (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>  <p>In a <a href="https://hazure.neocities.org/articles/2h03.html">previous article</a>, we mentioned that mainstream programming languages do not
    have any concept of time. This article is the third in a series that examines three languages (first,
    a markup language, then two programing languages) that <em>focus</em> on timing and synchronization. In
    the first article, we saw how <a href="https://hazure.neocities.org/articles/2g04.html">SMIL</a> defines a powerful timing and synchronization model
    for presenting multimedia content. In the second article, we saw how <a href="https://hazure.neocities.org/articles/2i02.html">the ChucK
    programming language</a> provides a sample-accurate scheduler for the production of computer music, from
    digital signal processing algorithms to musical composition; and finally, in this article we look at
    the synchronous reactive programming model of the Esterel language.</p> <p><a href="https://www-sop.inria.fr/meije/esterel/esterel-eng.html">Esterel</a> is our pick from a group
    of synchronous languages that emerged from early 1980’s French academia, together with others such as
    Argos, Lustre and Signal (<em>cf.</em> the 1993 survey <a href="https://www-verimag.imag.fr/~halbwach/newbook.pdf">Synchronous Programming of Reactive Systems</a> by
    Nicolas Halbwachs), which emphasize <em>control</em> and target <em>reactive</em> systems; often, these
    are large industrial systems used in domains like aviation or nuclear power, where complex
    time-critical processes have serious safety requirements.</p> <p>Esterel grew from an earlier effort to design a language for controlling a robot car; the authors
    recognizing <span>the need for specific statements to deal with time, namely delays and preemption</span> in order to achieve their goal. The language grew by adopting more formal semantics and experimenting
    with various compilation techniques, first by using deterministic finite-state automata (which can
    grow exponentially in size for large programs), and then compiling to <em>electrical circuits</em>, with
    gates and registers, removing the need for determinization (it is also possible to compile to C, or
    simulate the generated circuits in software).</p> <p>In order to see what Esterel looks like, here is its “Hello world” example, from the <a href="https://www.researchgate.net/publication/242374294_The_Esterel_v5_Language_Primer_Version_v5_91">Esterel
    v5 Language Primer</a> by Gérard Berry (2004). This program implements the following specification: <span>Emit an output O as soon as two inputs A and B have occurred. Reset this behavior each time
    the input R occurs.</span></p> <figure><pre>module ABRO:
input A, B, R;
output O;
loop
  [ await A || await B ];
  emit O
each R
end module</pre> <figcaption>A sample Esterel program: ABRO (p. 15)</figcaption></figure> <p>Esterel deals with input and output <em>signals</em>, such as A, B, R, and O in this example. Signals
    can be either <em>present</em> or <em>absent</em>, similarly to how a bit can be set or unset, or how a
    voltage in a circuit can toggle between a low and a high value. Since Esterel can compile to a digital
    circuit, if follows a simple timing model where input or output events (based on the status, or
    presence or absence of a signal) are processed at every clock cycle; time is logical and corresponds
    to the sequence of <em>instants</em> corresponding to hardware clock cycle. Output events happen at the
    exact same logical time as inputs, in an (idealized) <em>perfectly synchronous</em> model. (Recall that
    this is the model also adopted by <a href="https://hazure.neocities.org/articles/2i02.html">ChucK</a>.)</p> <p>Esterel is an imperative language, where a statement starts at some instant <em>t</em> and remains
    active until it terminates at some instant <em>t’</em> such that <em>t’ ≥ t</em> (if <em>t = t’</em>, then
    the statement is <em>instantaneous</em>). The statement <code>await A</code> starts at some t and remains
    active until the signal <code>A</code> occurs at some time <em>t’ &gt; t</em>. In the statement <code>Await A
    || Await B</code>, the <code>||</code> operator indicates that the two child statements occur concurrently:
    both start immediately, and the whole statement terminates when both terminate. The <code>;</code> operator
    indicates that its two children happen in sequence, the second one starting exactly when the first one
    terminates. <code>[ await A || await B ]; emit O</code> therefore implements the first part of the
    specification (the square brackets are simply syntax to ensure the correct order of application of the <code>||</code> and <code>;</code> operators).</p> <p>This statement is itself embedded into a <code>loop</code> ... <code>each R</code> statement, which
    indicates that the inner behaviour repeats (<em>i.e.</em>, starts again) as soon as the signal <code>R</code> occurs. <code>loop</code> is an example of <em>preemption</em> in Esterel: if <code>R</code> occurs before
    either <code>A</code> or <code>B</code>, then <code>O</code> does not occur, and the system is reset. On the other
    hand, the system also waits for <code>R</code> to occur before restarting after <code>O</code> was emitted.</p> <p>Readers of the <a href="https://hazure.neocities.org/articles/2g04.html">previous article in this series on SMIL</a> will recognize <code>||</code> and <code>;</code> as the <code>par</code> and <code>seq</code> containers of SMIL; indeed, there are many other
    similarities between the two languages (<code>loop</code> and <code>await</code> also have SMIL equivalents
    in <a href="https://www.w3.org/TR/2008/REC-SMIL3-20081201/smil-timing.html#q28">repeat</a> and <a href="https://www.w3.org/TR/2008/REC-SMIL3-20081201/smil-timing.html#q27">event</a> values for timing
    attributes). But Esterel is a full-fledged programming language and also deals with <em>values</em> (in
    the form of valued signals and variables) and erros, which are outside of the realm of a presentation
    language like SMIL. Another big difference (which also sets Esterel apart from ChucK) is how mapping
    instants to actual time values is not always necessary; and indeed, there are no predefined time
    units like seconds or minutes.</p> <p>Another example from the primer illustrates this idea. Here, the speed of a vehicle is computed by
    using two input signals, <code>Centimeter</code> (emitted every time the vehicle has moved one centimeter),
    and <code>Second</code> (emitted every time a second elapses).</p> <figure><pre>loop
    var Distance := 0 : integer in
       abort
          every Centimeter do
             Distance := Distance+1
          end every
       when Second do
          emit Speed(Distance)
       end abort
    end var
end loop</pre> <figcaption>Centimeters and seconds (p. 24)</figcaption></figure> <p>A few new constructs are introduced but are easily understood. An inner loop increments a <code>Distance</code> variable for every <code>Centimeter</code>. This inner loop is embedded into an <code>abort</code> ... <code>when</code> statement, which is another form of preemption; an occurrence of <code>Second</code> terminates the count and emits a <code>Speed</code> signal. Notice here that <code>Speed</code> is a <em>valued signal</em> as it carries as its value the number of centimeters travelled within the last second
    (<em>i.e.</em>, the value of <code>Distance</code>). The loop then repeats instantly and resets <code>Distance</code> to zero; the <code>Speed</code> signal is therefore emitted every second with the current speed of the
    vehicle in cm/s. Esterel does not distinguish between something that happens every second, or every
    centimer, or every lap, or any other significant measurements implemented by the input signals of the
    program.</p> <p>It is possible to get the value of a signal with the <code>?</code> operator. But this can lead to <em>causality</em> issues, as in the following program that (attempts) to increment a counter every
    time an input is received:</p> <figure><pre>input I;
output COUNT := 0 : integer;
every I do
    emit COUNT(?COUNT+1)
end every</pre> <figcaption>A synchronous loop (p. 84)</figcaption></figure> <p>Because signals are broadcast through an Esterel program synchronously, <code>COUNT</code> must
    simultaneously have both the values <em>c</em> (its value before the input signal <code>I</code> occurred)
    and <em>c + 1</em>, which is impossible. A solution to this problem is to use the <code>pre</code> operator,
    which allows accessing the value of a signal at a previous tick, so <code>emit COUNT(pre(?COUNT)+1)</code> is a valid program. Esterel also has the equivalent of an <em>if</em> statement, so that a signal can be
    emitted depending on whether another signal is present or absent; and this is another way to introduce
    these cyclic dependencies if the author is not careful. It is still possible however, even desirable
    in some cases, to allow sound cyclic programs, so Esterel uses so-called <em>constructive semantics</em> to analyze whether a program is sound, by attempting to prove if the presence or absence of a signal
    can be determined deterministically.</p> <p>We started this series lamenting the absence of the very concept of time in most programming
    languages, then we highlighted three different ways to address this issue in the domain of multimedia
    presentations, computer music, and reactive systems. We saw that time can be abstracted and even
    suspended through the synchronous hypothesis; that new constructs like <code>par</code> and <code>seq</code> can introduce structure into handling events occurring at various points in time throughout the
    execution of a program, rather than relying on unmanaged event handlers or opaque promises. This is by
    no means an exhaustive survey, but suggests many fascinating threads to pull on in order to improve
    the future of programming interactive applications. ⚂⚀</p> </div></div>
  </body>
</html>
