<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mostlynerdless.de/blog/2023/03/27/writing-a-profiler-in-240-lines-of-pure-java/">Original</a>
    <h1>Writing a Profiler in 240 lines of pure Java</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>A few months back, I started writing a profiler from scratch, and the code since became the base of my profiler validation tools. The only problem with this project: I wanted to write a proper non-safepoint-biased profiler from scratch. This is a noble effort, but it requires lots C/C++/Unix programming which is finicky, and not everyone can read C/C++ code.</p>



<p><em>For people unfamiliar with safepoint bias: A safepoint is a point in time where the JVM has a known defined state, and all threads have stopped. The JVM itself needs safepoints to do major garbage collections, Class definitions, method deoptimizations, and more. Threads are regularly checking whether they should get into a safepoint, for example, at method entry, exit, or loop backjumps. A profiler that only profiles at a safepoint have an inherent bias because it only includes frames from the locations inside methods where Threads check for a safepoint. The only advantage is that the stack-walking at safepoints is slightly less error-prone, as there are fewer mutations of heap and stack.</em> <em>For more information, consider reading the excellent article <a href="https://seethawenner.medium.com/java-safepoint-and-async-profiling-cdce0818cd29">Java Safepoint and Async Profiling</a> by Seetha Wenner, the <a href="https://jpbempel.github.io/2022/06/22/debug-non-safepoints.html">more technical one by JP Bempel</a>, or the classic article <a href="http://psy-lob-saw.blogspot.com/2015/12/safepoints.html">Safepoints: Meaning, Side Effects and Overheads</a> by Nitsan Wakart. To conclude: Safepoint-biased profilers don’t give you a holistic view of your application, but can still be helpful to analyze major performance issues where you look at the bigger picture.</em></p>



<p>This blog post aims to develop a tiny Java profiler in pure Java code that everyone can understand. Profilers are not rocket science, and ignoring safepoint-bias, we can write a usable profiler that outputs a flame graph in just 240 lines of code.</p>



<p>You can find the whole project on <a href="https://github.com/parttimenerd/tiny-profiler">GitHub</a>. Feel free to use it as a base for your adventures (and if you do, feel free to write me on <a href="https://twitter.com/parttimen3rd">Twitter</a>, where I regularly post on profiling-related topics).</p>



<p>We implement the profiler in a daemon thread started by a Java agent. This allows us to start and run the profiler alongside the Java program we want to profile. The main parts of the profiler are:</p>



<ul>
<li>Main: Entry point of the Java agent and starter of the profiling thread</li>



<li>Options: Parses and stores the agent options</li>



<li>Profiler: Contains the profiling loop</li>



<li>Store: Stores and outputs the collected results</li>
</ul>



<h2>Main Class</h2>



<p>We start by implementing the agent entry points:</p>



<pre data-enlighter-language="java" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">public class Main {
    public static void agentmain(String agentArgs) {
        premain(agentArgs);
    }

    public static void premain(String agentArgs) {
        Main main = new Main();
        main.run(new Options(agentArgs));
    }

    private void run(Options options) {
        Thread t = new Thread(new Profiler(options));
        t.setDaemon(true);
        t.setName(&#34;Profiler&#34;);
        t.start();
    }
}</pre>



<p>The <code>premain</code> is called when the agent is attached to the JVM at the start. This is typical because the user passed the <code>-javagent</code> to the JVM. In our example, this means that the user runs Java with </p>



<pre data-enlighter-language="bash" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">java -javaagent:./target/tiny_profiler.jar=agentArgs ...</pre>



<p>But there is also the possibility that the user attaches the agent at runtime. In this case, the JVM calls the method <code>agentmain</code>. To learn more about Java agent, visit the <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.instrument/java/lang/instrument/package-summary.html">JDK documentation</a>.</p>



<p>Please be aware that we have to set the <code>Premain-Class</code> and the <code>Agent-Class</code> attributes in the MANIFEST file of our resulting JAR file.</p>



<p>Our Java agent parses the agent arguments to get the options. The options are modeled and parsed by the Options class:</p>



<pre data-enlighter-language="java" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">public class Options {
    /** interval option */
    private Duration interval = Duration.ofMillis(10);

    /** flamegraph option */
    private Optional&lt;Path&gt; flamePath;

    /** table option */
    private boolean printMethodTable = true;
    ...
}</pre>



<p>The exciting part of the Main class is its run method: The Profiler class implements the Runnable interface so that we can create a thread directly:</p>



<pre data-enlighter-language="java" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Thread t = new Thread(new Profiler(options));</pre>



<p>We then mark the profiler thread as a daemon thread; this means that the JVM does terminate at the end of the profiled application even when the profiler thread is running:</p>



<pre data-enlighter-language="java" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">t.setDaemon(true);</pre>



<p>No, we’re almost finished; we only have to start the thread. Before we do this, we name the thread, this is not required, but it makes debugging easier.</p>



<pre data-enlighter-language="java" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">t.setName(&#34;Profiler&#34;);
t.start();</pre>



<h2>Profiler Class</h2>



<p>The actual sampling takes place in the Profiler class:</p>



<pre data-enlighter-language="java" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">public class Profiler implements Runnable {
    private final Options options;
    private final Store store;

    public Profiler(Options options) {
        this.options = options;
        this.store = new Store(options.getFlamePath());
        Runtime.getRuntime().addShutdownHook(new Thread(this::onEnd));
    }

    private static void sleep(Duration duration) {
        // ...
    }

    @Override
    public void run() {
        while (true) {
            Duration start = Duration.ofNanos(System.nanoTime());
            sample();
            Duration duration = Duration.ofNanos(System.nanoTime())
                                        .minus(start);
            Duration sleep = options.getInterval().minus(duration);
            sleep(sleep);
        }
    }

    private void sample() {
        Thread.getAllStackTraces().forEach(
          (thread, stackTraceElements) -&gt; {
            if (!thread.isDaemon()) { 
                // exclude daemon threads
                store.addSample(stackTraceElements);
            }
        });
    }

    private void onEnd() {
        if (options.printMethodTable()) {
            store.printMethodTable();
        }
        store.storeFlameGraphIfNeeded();
    }
</pre>



<p>We start by looking at the constructor. The interesting part is</p>



<pre data-enlighter-language="java" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Runtime.getRuntime().addShutdownHook(new Thread(this::onEnd));</pre>



<p>which causes the JVM to call the <code>Profiler::onEnd</code> when it shuts down. This is important as the profiler thread is silently aborted, and we still want to print the captured results. You can read more on shutdown hooks in the <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Runtime.html#addShutdownHook(java.lang.Thread)">Java documentation</a>.</p>



<p>After this, we take a look at the profiling loop in the <code>run</code> method:</p>



<pre data-enlighter-language="java" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">while (true) {
    Duration start = Duration.ofNanos(System.nanoTime());
    sample();
    Duration duration = Duration.ofNanos(System.nanoTime())
                                .minus(start);
    Duration sleep = options.getInterval().minus(duration);
    sleep(sleep);
}</pre>



<p>This calls the <code>sample</code> method and sleeps the required time afterward, to ensure that the <code>sample</code> method is called every <code>interval</code> (typically 10 ms).</p>



<p>The core sampling takes place in this <code>sample</code> method:</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Thread.getAllStackTraces().forEach(
  (thread, stackTraceElements) -&gt; {
    if (!thread.isDaemon()) { 
        // exclude daemon threads
        store.addSample(stackTraceElements);
    }
});</pre>



<p>We use here the <code>Thread::getAllStackTraces</code> method to obtain the stack traces of all threads. This triggers a safepoint and is why this profiler is safepoint-biased. Taking the stack traces of a subset of threads would not make sense, as there is no method in the JDK for this. Calling Thread::getStackTrace on a subset of threads would trigger many safepoints, not just one, resulting in a more significant performance penalty than obtaining the traces for all threads.</p>



<p>The result of <code>Thread::getAllStackTraces</code> is filtered so that we don’t include daemon threads (like the Profiler thread or unused Fork-Join-Pool threads). We pass the appropriate traces to the Store, which deals with the post-processing.</p>



<h2>Store Class</h2>



<p>This is the last class of this profiler and also the by far most significant, post-processing, storing, and outputting of the collected information:</p>



<pre data-enlighter-language="java" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">package me.bechberger;

import java.io.BufferedOutputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Stream;

/**
 * store of the traces
 */
public class Store {

    /** too large and browsers can&#39;t display it anymore */
    private final int MAX_FLAMEGRAPH_DEPTH = 100;

    private static class Node {
        // ...
    }

    private final Optional&lt;Path&gt; flamePath;
    private final Map&lt;String, Long&gt; methodOnTopSampleCount = 
        new HashMap&lt;&gt;();
    private final Map&lt;String, Long&gt; methodSampleCount = 
        new HashMap&lt;&gt;();

    private long totalSampleCount = 0;

    /**
     * trace tree node, only populated if flamePath is present
     */
    private final Node rootNode = new Node(&#34;root&#34;);

    public Store(Optional&lt;Path&gt; flamePath) {
        this.flamePath = flamePath;
    }

    private String flattenStackTraceElement(
      StackTraceElement stackTraceElement) {
        // call intern to safe some memory
        return (stackTraceElement.getClassName() + &#34;.&#34; + 
            stackTraceElement.getMethodName()).intern();
    }

    private void updateMethodTables(String method, boolean onTop) {
        methodSampleCount.put(method, 
            methodSampleCount.getOrDefault(method, 0L) + 1);
        if (onTop) {
            methodOnTopSampleCount.put(method, 
                methodOnTopSampleCount.getOrDefault(method, 0L) + 1);
        }
    }

    private void updateMethodTables(List&lt;String&gt; trace) {
        for (int i = 0; i &lt; trace.size(); i++) {
            String method = trace.get(i);
            updateMethodTables(method, i == 0);
        }
    }

    public void addSample(StackTraceElement[] stackTraceElements) {
        List&lt;String&gt; trace = 
            Stream.of(stackTraceElements)
                   .map(this::flattenStackTraceElement)
                   .toList();
        updateMethodTables(trace);
        if (flamePath.isPresent()) {
            rootNode.addTrace(trace);
        }
        totalSampleCount++;
    }

    // the only reason this requires Java 17 :P
    private record MethodTableEntry(
        String method, 
        long sampleCount, 
        long onTopSampleCount) {
    }

    private void printMethodTable(PrintStream s, 
      List&lt;MethodTableEntry&gt; sortedEntries) {
        // ...
    }

    public void printMethodTable() {
        // sort methods by sample count
        // the print a table
        // ...
    }

    public void storeFlameGraphIfNeeded() {
        // ...
    }
}
</pre>



<p>The Profiler calls the <code>addSample</code> method which flattens the stack trace elements and stores them in the trace tree (for the flame graph) and counts the traces that any method is part of.</p>



<p>The interesting part is the trace tree modeled by the Node class. The idea is that every trace <code>A -&gt; B -&gt; C</code> (<code>A</code> calls <code>B</code>, <code>B</code> calls <code>C</code>, <code>[C, B, A]</code>) when returned by the JVM) can be represented as a root node with a child node <code>A</code> with child <code>B</code> with child <code>C</code>, so that every captured trace is a path from the root node to a leaf. We count how many times a node is part of the trace. This can then be used to output the tree data structure for <a href="https://github.com/spiermar/d3-flame-graph">d3-flame-graph</a> which we use to create nice flamegraphs like:</p>



<figure><img decoding="async" width="2000" height="1469" src="https://mostlynerdless.de/wp-content/uploads/2023/03/flame-2000x1469.png" alt="" srcset="https://mostlynerdless.de/wp-content/uploads/2023/03/flame-2000x1469.png 2000w, https://mostlynerdless.de/wp-content/uploads/2023/03/flame-300x220.png 300w, https://mostlynerdless.de/wp-content/uploads/2023/03/flame-768x564.png 768w, https://mostlynerdless.de/wp-content/uploads/2023/03/flame-1536x1128.png 1536w, https://mostlynerdless.de/wp-content/uploads/2023/03/flame-2048x1504.png 2048w, https://mostlynerdless.de/wp-content/uploads/2023/03/flame-409x300.png 409w" sizes="(max-width: 2000px) 100vw, 2000px"/><figcaption> Flame graph produced by the profiler for the renaissance dotty benchmark</figcaption></figure>



<p>Keep in my mind that the actual Node class is as follows:</p>



<pre data-enlighter-language="java" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">private static class Node {                                                                                                                                                                                              
    private final String method;                                                                                                                                                                                         
    private final Map&lt;String, Node&gt; children = new HashMap&lt;&gt;();                                                                                                                                                          
    private long samples = 0;                                                                                                                                                                                            
                                                                                                                                                                                                                         
    public Node(String method) {                                                                                                                                                                                         
        this.method = method;                                                                                                                                                                                            
    }                                                                                                                                                                                                                    
                                                                                                                                                                                                                         
    private Node getChild(String method) {                                                                                                                                                                               
        return children.computeIfAbsent(method, Node::new);                                                                                                                                                              
    }                                                                                                                                                                                                                    
                                                                                                                                                                                                                         
    private void addTrace(List&lt;String&gt; trace, int end) {                                                                                                                                                                 
        samples++;                                                                                                                                                                                                       
        if (end &gt; 0) {                                                                                                                                                                                      
            getChild(trace.get(end)).addTrace(trace, end - 1);                                                                                                                                                           
        }                                                                                                                                                                                                                
    }                                                                                                                                                                                                                    
                                                                                                                                                                                                                         
    public void addTrace(List&lt;String&gt; trace) {                                                                                                                                                                           
        addTrace(trace, trace.size() - 1);                                                                                                                                                                               
    }                                                                                                                                                                                                                    
                                                                                                                                                                                                                         
    /**                                                                                                                                                                                                                  
     * Write in d3-flamegraph format                                                                                                                                                                                     
     */                                                                                                                                                                                                                  
    private void writeAsJson(PrintStream s, int maxDepth) {                                                                                                                                                              
        s.printf(&#34;{ \&#34;name\&#34;: \&#34;%s\&#34;, \&#34;value\&#34;: %d, \&#34;children\&#34;: [&#34;, 
                 method, samples);                                                                                                                                 
        if (maxDepth &gt; 1) {                                                                                                                                                                                              
            for (Node child : children.values()) {                                                                                                                                                                       
                child.writeAsJson(s, maxDepth - 1);                                                                                                                                                                      
                s.print(&#34;,&#34;);                                                                                                                                                                                            
            }                                                                                                                                                                                                            
        }                                                                                                                                                                                                                
        s.print(&#34;]}&#34;);                                                                                                                                                                                                   
    }                                                                                                                                                                                                                    
                                                                                                                                                                                                                         
    public void writeAsHTML(PrintStream s, int maxDepth) {                                                                                                                                                               
        s.print(&#34;&#34;&#34;                                                                                                                                                                                                      
                &lt;head&gt;                                                                                                                                                                                                   
                  &lt;link rel=&#34;stylesheet&#34; 
                   type=&#34;text/css&#34; 
                   href=&#34;https://cdn.jsdelivr.net/npm/d3-flame-graph@4.1.3/dist/d3-flamegraph.css&#34;&gt;                                                                                
                &lt;/head&gt;                                                                                                                                                                                                  
                &lt;body&gt;                                                                                                                                                                                                   
                  &lt;div id=&#34;chart&#34;&gt;&lt;/div&gt;                                                                                                                                                                                 
                  &lt;script type=&#34;text/javascript&#34; 
                   src=&#34;https://d3js.org/d3.v7.js&#34;&gt;&lt;/script&gt;                                                                                                                               
                  &lt;script type=&#34;text/javascript&#34; 
                   src=&#34;https://cdn.jsdelivr.net/npm/d3-flame-graph@4.1.3/dist/d3-flamegraph.min.js&#34;&gt;&lt;/script&gt;                                                                             
                  &lt;script type=&#34;text/javascript&#34;&gt;                                                                                                                                                                        
                  var chart = flamegraph().width(window.innerWidth);                                                                                                                                                     
                  d3.select(&#34;#chart&#34;).datum(&#34;&#34;&#34;);                                                                                                                                                                        
        writeAsJson(s, maxDepth);                                                                                                                                                                                        
        s.print(&#34;&#34;&#34;                                                                                                                                                                                                      
                ).call(chart);                                                                                                                                                                                           
                  window.onresize = 
                      () =&gt; chart.width(window.innerWidth);                                                                                                                                                
                  &lt;/script&gt;                                                                                                                                                                                              
                &lt;/body&gt;                                                                                                                                                                                                  
                &#34;&#34;&#34;);                                                                                                                                                                                                    
    }                                                                                                                                                                                                                    
}                                                                                                                                                                                                                        
                                                                                                                                                                                                                         </pre>



<h2>Tiny-Profiler</h2>



<p>I named the final profiler tiny-profiler and its sources are on <a href="https://github.com/parttimenerd/tiny-profiler">GitHub</a> (MIT licensed). The profiler should work on any platform with a JDK 17 or newer. The usage is fairly simple:</p>



<pre data-enlighter-language="bash" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group=""># build it
mvn package

# run your program and print the table of methods sorted by their sample count
# and the flame graph, taking a sample every 10ms
java -javaagent:target/tiny-profiler.jar=flamegraph=flame.html ...</pre>



<p>You can easily run it on the renaissance benchmark and create the flame graph shown earlier:</p>



<pre data-enlighter-language="bash" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group=""># download a benchmark
&gt; test -e renaissance.jar || wget https://github.com/renaissance-benchmarks/renaissance/releases/download/v0.14.2/renaissance-gpl-0.14.2.jar -O renaissance.jar

&gt; java -javaagent:./target/tiny_profiler.jar=flamegraph=flame.html -jar renaissance.jar dotty
...
===== method table ======
Total samples: 11217
Method                                      Samples Percentage  On top Percentage
dotty.tools.dotc.typer.Typer.typed            59499     530.44       2       0.02
dotty.tools.dotc.typer.Typer.typedUnadapted   31050     276.81       7       0.06
scala.runtime.function.JProcedure1.apply      24283     216.48      13       0.12
dotty.tools.dotc.Driver.process               19012     169.49       0       0.00
dotty.tools.dotc.typer.Typer.typedUnnamed$1   18774     167.37       7       0.06
dotty.tools.dotc.typer.Typer.typedExpr        18072     161.11       0       0.00
scala.collection.immutable.List.foreach       16271     145.06       3       0.03
...                                                                              </pre>



<p>The overhead for this example is around 2% on my MacBook Pro 13″ for a 10ms interval, which makes the profiler usable when you ignore the safepoint-bias.</p>



<h2>Conclusion</h2>



<p>Writing a Java profiler in 240 lines of pure Java is possible and the resulting profiler could even be used to analyze performance problems. This profiler is not designed to replace real profilers like async-profiler, but it demystifies the inner workings of simple profilers.</p>



<p>I hope you enjoyed this code-heavy blog post. As always I’m happy for any feedback, issue, or PR. Come back next week for my next blog post on profiling.</p>



<p><em>This blog post is part of my work in the <a href="https://sapmachine.io/">SapMachine</a> team at <a href="https://sap.com/">SAP</a>, making profiling easier for everyone.</em> <em>Significant parts of this post have been written below the English channel…</em></p>
			</div></div>
  </body>
</html>
