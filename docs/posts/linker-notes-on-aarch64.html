<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maskray.me/blog/2023-03-05-linker-notes-on-aarch64">Original</a>
    <h1>Linker Notes on AArch64</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      
        <p>This article describes target-specific details about AArch64 in ELF
linkers. AArch64 is the 64-bit execution state for the Arm architecture.
The AArch64 execution state runs the A64 instruction set. The AArch32
and AArch64 execution states use very different instruction sets, so
many pieces of software use two ports for the two execution states of
the Arm architecture.</p>
<p>There were the &#34;ARM architecture&#34; and the &#34;ARM instruction set&#34;,
leading to many software projects using &#34;ARM&#34; or &#34;arm&#34; as their port
names. In 2011, ARMv8 introduced two execution states, AArch32 and
AArch64. The previous instruction sets &#34;ARM&#34; and &#34;Thumb&#34; were renamed to
&#34;A32&#34; and &#34;T32&#34;, respectively. In 2017, the architecture was renamed to
the &#34;Arm architecture&#34; to reflect the rebranding of the company name.
So, the &#34;ARMv8-A&#34; architecture profile is now named &#34;Armv8-A&#34;.</p>
<p>For the AArch64 execution state, while many projects use &#34;AArch64&#34; as
their port name, for legacy reasons, macOS, Windows, the Linux kernel,
and some BSD operating systems unfortunately use &#34;arm64&#34;. (Support for
AArch64 was added to the Linux kernel in version 3.7. Initially, the
patch set was named &#34;aarch64&#34;, but it was later changed at the <a target="_blank" rel="noopener" href="https://lkml.org/lkml/2012/7/6/624">request</a> of kernel
developers.)</p>
<h2 id="abi-documents">ABI documents</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ARM-software/abi-aa/blob/main/aaelf64/aaelf64.rst">ELF
for the Arm® 64-bit Architecture (AArch64)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ARM-software/abi-aa/blob/main/sysvabi64/sysvabi64.rst">System
V ABI for the Arm® 64-bit Architecture (AArch64)</a></li>
</ul>
<h2 id="global-offset-table">Global Offset Table</h2>
<p>The Global Offset Table consists of two sections:</p>
<ul>
<li><code>.got.plt</code> holds code addresses for PLT.</li>
<li><code>.got</code> holds other addresses and offsets.</li>
</ul>
<p>The symbol <code>_GLOBAL_OFFSET_TABLE_</code> is defined at the
beginning of the <code>.got</code> section. GNU ld reserves a single
entry for <code>.got</code> and <code>.got[0]</code> holds the link-time
address of <code>_DYNAMIC</code> for a legacy reason Versions of glibc
prior to 2.35 have the <code>_DYNAMIC</code> requirement. See <a href="https://maskray.me/blog/2021-08-29-all-about-global-offset-table#global_offset_table_0">All
about Global Offset Table</a>.</p>
<p><code>.got.plt[1]</code> and <code>.got.plt[2]</code> are for lazy
binding PLT. Linkers communicate the address of <code>.got.plt</code> to
rtld with the dynamic tag <code>DT_PLTGOT</code>.</p>
<h2 id="procedure-linkage-table">Procedure Linkage Table</h2>
<p>The registers <code>x16</code> (IP0) and <code>x17</code> (IP1) are
the first and second intra-procedure-call temporary registers. They may
be used by PLT entries and veneers.</p>
<p>The PLT header looks like: </p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>bti  c       // If BTI</span></pre></td></tr></tbody></table></figure>
<p>The Nth PLT entry looks like: </p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>bti  c       // If BTI</span></pre></td></tr></tbody></table></figure>
<p>When BTI is enabled for the output file, the code sequence starts
with <code>bti c</code>. When PAC-PLT is enabled, the code sequence
includes <code>autia1716</code> before <code>br x17</code>.</p>
<h2 id="relocation-optimization">Relocation optimization</h2>
<p>See <a href="https://maskray.me/blog/2021-08-29-all-about-global-offset-table#got-optimization">All
about Global Offset Table#GOT optimization</a> for GOT optimization.</p>
<p>There are a few optimization schemes beside GOT optimization,
e.g.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>add  x2, x2, 0  // R_&lt;CLS&gt;_ADD_ABS_LO12_NC</span></pre></td></tr></tbody></table></figure>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>adrp x0, symbol</span></pre></td></tr></tbody></table></figure>
<p><code>--no-relax</code> disables the optimization.</p>
<p>See <a target="_blank" rel="noopener" href="https://github.com/ARM-software/abi-aa/blob/main/aaelf64/aaelf64.rst#relocation-optimization">ELF
for the Arm® 64-bit Architecture (AArch64)#Relocation
optimization</a>.</p>
<h2 id="thread-local-storage">Thread Local Storage</h2>
<p>AArch64 uses a variant of TLS Variant I: the static TLS blocks are
placed above the thread pointer. The thread pointer points to the end of
the thread control block.</p>
<p>The linker performs TLS optimization.</p>
<p>See <a href="https://maskray.me/blog/2021-02-14-all-about-thread-local-storage">All
about thread-local storage</a>.</p>
<h2 id="program-property">Program Property</h2>
<p>A <code>.note.gnu.property</code> section contains program property
notes that describe special handling requirements for the linker and the
dynamic loader.</p>
<p>The linker parses input <code>.note.gnu.property</code> sections and
recognizes command line options <code>-z force-bti</code> and
<code>-z pac-plt</code> to compute the output
<code>.note.gnu.property</code> (type is <code>SHT_NOTE</code>) section.
Without these options, linkers only set the feature bit in the output
file if all the input relocatable object files have the corresponding
feature set.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>for</span> (ELFFileBase *f : ctx.objectFiles) {</span></pre></td></tr></tbody></table></figure>
<h2 id="range-extension-thunks">Range extension thunks</h2>
<p>Function calls typically use <code>B</code> and <code>BL</code>
instructions. The two instructions have a range of +/-128MiB and may use
2 relocation types: <code>R_AARCH64_CALL26</code> and
<code>R_AARCH64_JUMP26</code>. The range is larger than the branch range
for many other instruction sets. If the destination is not reachable by
a single <code>B</code>/<code>BL</code>, linkers may insert a veneer
(range extension thunk).</p>
<p><code>-no-pie</code> links may use a thunk with absolute addressing
targeting any location in the 64-bit address space. </p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>&lt;caller&gt;:</span></pre></td></tr></tbody></table></figure>
<p><code>-pie</code> and <code>-shared</code> links need to use a thunk
with PC-relative addressing targeting a range of +/-4GiB.
</p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>&lt;caller&gt;:</span></pre></td></tr></tbody></table></figure>
<p>The branch target of a thunk may be a PLT entry: </p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>&lt;caller&gt;:</span></pre></td></tr></tbody></table></figure>
<h2 id="fix-cortex-a53-843419"><code>--fix-cortex-a53-843419</code></h2>
<p>This option enables a linker workaround for Arm Cortex-A53 Errata
843419. Full details are available in the ARM-EPM-048406 document. In
ld.lld this additionally sets a <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/commit/20489ec5639e01c3c05ca5a39e6e43cac66c202f">workaround</a>
when relocating <code>R_AARCH64_JUMP26</code>.</p>
<h2 id="small-code-model">Small code model</h2>
<p>On x86-64, symbols in the small code model are required to be located
in the range <code>[0, 2**31 − 2**24)</code>.</p>
<p>The AArch64 small code model allows for a maximum text segment size
of 2GiB and a maximum combined span of text and data segments of 4GiB.
For small position-independent code (pic), there is an additional
restriction on the size of the Global Offset Table (GOT), which must be
smaller than 32KiB. The maximum combined span of text and data segments
is larger than that of x86-64.</p>
<p>Linked image sizes for AArch64 and x86-64 are comparable, but AArch64
linked images are more resistant to relocation overflows.</p>
<p>There are several types of relocation overflows that we need to pay
attention to:</p>
<ul>
<li><code>.text &lt;-&gt; .rodata</code></li>
<li><code>.text &lt;-&gt; .eh_frame</code> (<code>.eh_frame</code> has
32-bit offsets)</li>
<li><code>.text &lt;-&gt; .bss</code></li>
<li><code>.rodata &lt;-&gt; .bss</code></li>
</ul>
<p>In many programs, <code>.text &lt;-&gt; .data/.bss</code> relocations
have the tightest constraints. Overflows due to
<code>.text &lt;-&gt; .rodata</code> relocations are possible but rare
(I have seen such issues in the past). <code>.rodata</code> is usually
larger than <code>.data+.bss</code>.</p>
<p><code>.rodata &lt;-&gt; .bss</code> overflows usually do not occur,
but metadata needs to be careful using <code>.quad label-.</code>
instead of <code>.long label-.</code>. Such issues can be trivially
fixed on the compiler side.)</p>
<p>For <code>.text &lt;-&gt; .rodata</code> and
<code>.text &lt;-&gt; .bss</code> references, x86-64 uses
<code>R_X86_64_REX_GOTPCRELX</code>/<code>R_X86_64_PC32</code>
relocations, which have a small range <code>[-2**31,2**31)</code>. In
contrast, <code>R_AARCH64_ADR_PREL_PG_HI21</code> on AArch64 has a
doubled range <code>[-2**32,2**32)</code>, making it unlikely that
AArch64 will hit an issue before the binary becomes excessively
oversized for x86-64.</p>
<h2 id="android-memtag-modestackheap"><code>--android-memtag-{mode,stack,heap}</code></h2>
<p>The options instruct ld.lld to create
<code>DT_AARCH64_MEMTAG_*</code> dynamic tags. See <a target="_blank" rel="noopener" href="https://github.com/ARM-software/abi-aa/blob/main/memtagabielf64/memtagabielf64.rst">Memtag
ABI Extension to ELF for the Arm® 64-bit Architecture (AArch64)</a>.</p>

      
    </div></div>
  </body>
</html>
