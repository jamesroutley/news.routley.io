<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/trealla-prolog/trealla">Original</a>
    <h1>Trealla – A compact, efficient Prolog interpreter written in plain-old C</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">A compact, efficient Prolog interpreter with
<a href="https://trealla-prolog.github.io/trealla/" rel="nofollow">ISO compliant</a> aspirations.</p>
<div data-snippet-clipboard-copy-content="MIT licensed
Integers are unbounded
Atoms are UTF-8 of unlimited length
The default double-quoted representation is *chars* list
Dynamic atoms are automatically garbage collected
Unlimited arity (system resources constrained)
Uses 1st &amp; 2nd arg indexing
Atom garbage collection
DCGs
REPL with history
Compiles in &lt;1s with *tcc*, or ~5s with *gcc* and *clang*
Runs on Linux, FreeBSD and macOS
Foreign function interface (FFI) for calling out to user C code
Access SQLITE databases using builtin module (uses FFI)
Attributed variables with SICStus interface (*WIP*)
Rational trees aka. cyclic terms (*WIP*)
Logtalk compatible (*WIP*)"><pre><code>MIT licensed
Integers are unbounded
Atoms are UTF-8 of unlimited length
The default double-quoted representation is *chars* list
Dynamic atoms are automatically garbage collected
Unlimited arity (system resources constrained)
Uses 1st &amp; 2nd arg indexing
Atom garbage collection
DCGs
REPL with history
Compiles in &lt;1s with *tcc*, or ~5s with *gcc* and *clang*
Runs on Linux, FreeBSD and macOS
Foreign function interface (FFI) for calling out to user C code
Access SQLITE databases using builtin module (uses FFI)
Attributed variables with SICStus interface (*WIP*)
Rational trees aka. cyclic terms (*WIP*)
Logtalk compatible (*WIP*)
</code></pre></div>
<p dir="auto">Trealla is not WAM-based. It uses tree-walking, structure-sharing and
deep-binding. Source is compiled to an AST that is interpreted at
runtime.</p>
<p dir="auto">The name Trealla comes from the Liaden Universe books by Lee &amp; Miller.
It is also a nod to the Trealla region of Western Australia.</p>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/trealla-prolog/trealla/blob/main/trealla.png"><img src="https://github.com/trealla-prolog/trealla/raw/main/trealla.png" alt="Trealla Logo: Trealla"/></a></p>

<div data-snippet-clipboard-copy-content="tpl [options] [files] [-- args]"><pre><code>tpl [options] [files] [-- args]
</code></pre></div>
<p dir="auto">where options can be:</p>
<div data-snippet-clipboard-copy-content="-O0, --noopt       - no optimization
-f file            - load file (*~/.tplrc* not loaded)
-l file            - load file (*~/.tplrc* loaded)
file               - load file (*~/.tplrc* loaded)
-g goal            - query goal (only used once)
--library path     - alt to TPL_LIBRARY_PATH env variable
-t, --trace        - trace
-q, --quiet        - quiet mode (no banner)
-v, --version      - version
-h, --help         - help
-d, --daemonize    - daemonize
-w, --watchdog     - create watchdog
--consult          - consult from STDIN"><pre><code>-O0, --noopt       - no optimization
-f file            - load file (*~/.tplrc* not loaded)
-l file            - load file (*~/.tplrc* loaded)
file               - load file (*~/.tplrc* loaded)
-g goal            - query goal (only used once)
--library path     - alt to TPL_LIBRARY_PATH env variable
-t, --trace        - trace
-q, --quiet        - quiet mode (no banner)
-v, --version      - version
-h, --help         - help
-d, --daemonize    - daemonize
-w, --watchdog     - create watchdog
--consult          - consult from STDIN
</code></pre></div>
<p dir="auto">For example:</p>
<div data-snippet-clipboard-copy-content="tpl -g test2,halt samples/sieve"><pre><code>tpl -g test2,halt samples/sieve
</code></pre></div>
<p dir="auto">Invocation without any goal presents the REPL.</p>
<p dir="auto">The default path to the library is relative to the executable location.</p>
<p dir="auto">The file <em>~/.tplrc</em> is consulted on startup unless the <em>-f</em> option is present.</p>
<p dir="auto">When consulting, reconsulting and deconsulting files the <em>.pl</em> version
of the filename is always preferred (if not specified) when looking for a
file.</p>
<p dir="auto">To run the Pereira benchmark suite:</p>
<div data-snippet-clipboard-copy-content="tpl -g &#34;bench_peirera,halt&#34; -f samples/peirera.pl"><pre><code>tpl -g &#34;bench_peirera,halt&#34; -f samples/peirera.pl
</code></pre></div>

<p dir="auto">Trealla uses UTF-8 internally and this works well with modern operating
systems that are already [<a href="https://www.utf8everywhere.org/" rel="nofollow">1</a>], or moving to
[<a href="https://en.wikipedia.org/wiki/Unicode_in_Microsoft_Windows#UTF-8" rel="nofollow">2</a>],
native UTF-8.</p>
<p dir="auto">It aligns well with standard C as functions like strcmp/memcmp that
require no special handling to respect codepoint order. This also works
seamlessly with the implementation of double-quoted <em>strings</em> (ie.
chars-list), DCGs, and mmap&#39;d files. Any code-point specific
requirements, like <em>get_char</em>, <em>get_code</em>, <em>sub_atom</em>, <em>atom_length</em>,
<em>atom_codes</em>, <em>atom_chars</em> &amp; <em>_upper/</em>_lower are handled on the fly.</p>
<p dir="auto">Unicode atoms do not need to be quoted unless they contain breaking
characters...</p>
<div data-snippet-clipboard-copy-content="?- [user].
是.            % be: means, approximately, &#34;True&#34;.
不是 :- \+ 是.  % not be: means, approximately, &#34;False&#34;.
&lt;CTRL-D&gt;
   true.
?- 是.
   true.
?- 不是.
   false."><pre>?- [user].
是.            <span>% be: means, approximately, &#34;True&#34;.</span>
不是 :- <span>\+</span> 是<span>.</span>  <span>% not be: means, approximately, &#34;False&#34;.</span>
&lt;CTRL-D&gt;
   <span>true</span><span>.</span>
?- 是.
   <span>true</span><span>.</span>
?- 不是.
   <span>false</span><span>.</span></pre></div>
<p dir="auto">Trealla accepts as a variable any atom beginning with Unicode uppercase...</p>
<div data-snippet-clipboard-copy-content="?- atom_upper(δ,C).
   C = Δ.
?- Δ is 123456-123455.
   Δ = 1.
?-"><pre>?- atom_upper(δ,C).
   <span>C</span> = Δ<span>.</span>
?- Δ is 123456-123455.
   Δ = 1.
?-</pre></div>

<p dir="auto">Written in plain-old C.</p>
<div data-snippet-clipboard-copy-content="git clone https://github.com/infradig/trealla.git
cd trealla"><pre><code>git clone https://github.com/infradig/trealla.git
cd trealla
</code></pre></div>
<p dir="auto">On Debian+ systems you may need to install GNU readline, xxd &amp; libffi</p>
<div data-snippet-clipboard-copy-content="sudo apt install libreadline-dev xxd libffi-dev"><pre><code>sudo apt install libreadline-dev xxd libffi-dev
</code></pre></div>
<p dir="auto">Then...</p>

<p dir="auto">To build without libffi:</p>

<p dir="auto">Other systems may vary. On Debian+ systems you may need to install OpenSSL:</p>
<div data-snippet-clipboard-copy-content="sudo apt install libssl-dev"><pre><code>sudo apt install libssl-dev
</code></pre></div>
<p dir="auto">To build without OpenSSL:</p>

<p dir="auto">To build with the included ISOCLINE sources (default is to use GNU readline):</p>

<p dir="auto">Then...</p>

<p dir="auto">On <em>BSD</em> systems use <em>gmake</em> to build and do</p>

<p dir="auto">to get the <em>xxd</em> utility.</p>
<p dir="auto">For unbounded arithmetic Trealla uses a modified fork of the
<a href="https://github.com/infradig/imath">imath</a>
library, which is partially included in the source. Note, unbounded
integers (aka. bigints) are for arithmetic purposes only and will give a
type_error when used in places not expected. The <em>imath</em> library has a bug
whereby printing large numbers becomes exponentially slower (100K+ digits)
and will require a switch to <em>libtomath</em> at some point to remedy.</p>

<p dir="auto">Contributions are welcome. Trealla coding style is snake-case (like
original K&amp;R). I consider camelCase to be an anti-pattern, probably
because i&#39;m dyslexic and it takes me twice as long to read and 4 times
as long to write.</p>

<p dir="auto">To cross-compile on Linux and produce a Windows executable...</p>
<div data-snippet-clipboard-copy-content="sudo apt-get install mingw-w64
make CC=x86_64-w64-mingw32-gcc NOSSL=1 NOFFI=1 ISOCLINE=1"><pre><code>sudo apt-get install mingw-w64
make CC=x86_64-w64-mingw32-gcc NOSSL=1 NOFFI=1 ISOCLINE=1
</code></pre></div>
<div data-snippet-clipboard-copy-content="$ file tpl.exe
tpl.exe: PE32+ executable (console) x86-64, for MS Windows
$ wine tpl.exe -g test5,halt -f samples/sieve.pl"><pre>$ <span>file tpl.exe</span>
<span>tpl.exe: PE32+ executable (console) x86-64, for MS Windows</span>
$ <span>wine tpl.exe -g test5,halt -f samples/sieve.pl</span></pre></div>

<p dir="auto">This project started in March 2020 and it would not be where it is today
without help from these people:</p>
<p dir="auto">Special thanks to <a href="https://github.com/dram">Xin Wang</a> for providing the
testing framework, for the initial push to get serious and for being
the first to take this work (in it&#39;s nascent form) seriously.</p>
<p dir="auto">Special thanks to <a href="https://github.com/pmoura">Paulo Moura</a> for his patience
and sleuthing in the quest for Trealla to run his Logtalk project.</p>
<p dir="auto">Special thanks to <a href="https://github.com/triska">Markus Triska</a> for
driving the use of packed UTF-8 strings for character-lists. For the
idea of mmap()-ing files as strings. For his rigorous approach to types
and for bug-checking. Also for use of his format_//2 library.</p>
<p dir="auto">Special thanks to <a href="https://github.com/josd">Jos De Roo</a> for his testing
against some classic Prolog examples and his EYE project.</p>
<p dir="auto">Special thanks to <a href="https://github.com/cehteh">Christian Thaeter</a> for his
work with code cleanup and development ideas.</p>
<p dir="auto">Special thanks to <a href="https://github.com/uwn">Ulrich Neumerkel</a> for his
DCG reference library, for his drive towards ISO standardization and for
being himself.</p>

<p dir="auto">Double-quoted strings, when <em>set_prolog_flag(double_quotes,chars)</em> is set
(which is the default) are stored as packed UTF-8 byte arrays. This is
compact and efficient. Such strings emulate a list representation and
from the programmer point of view are very much indistinguishable from
lists.</p>
<p dir="auto">A good use of such strings is <em>open(filename,read,Str,[mmap(Ls))</em>
which gives a memory-mapped view of a file as a string <em>Ls</em>. List
operations on files are now essentially zero-overhead! DCG applications
will gain greatly (<em>phrase_from_file/[2-3]</em> uses this).</p>
<p dir="auto">Both strings and atoms make use of low-overhead reflist-counted byte slices
where appropriate.</p>

<div data-snippet-clipboard-copy-content="between/3
forall/2
samsort/2                   # same as msort/2
msort/2
merge/3
format/[1-3]
predicate_property/2
numbervars/[1,3-4]
e/0
name/2
tab/[1,2]

maplist/[2-8]               # auto-loaded from library(apply)
foldl/[4-7]                 # auto-loaded from library(apply)
include/3                   # auto-loaded from library(apply)
exclude/3                   # auto-loaded from library(apply)

get_unbuffered_code/1		# read a single unbuffered code
get_unbuffered_char/1		# read a single unbuffered character
read_term_from_atom/3       # read_term_from_atom(+atom,?term)
write_term_to_atom/3        # write_term_to_atom(?atom,?term,+list)
write_canonical_to_atom/3   # write_canonical_to_atom(?atom,?term,+list)
term_to_atom/2              # term_to_atom(?atom,?term)

setrand/1                   # set_seed(+integer) set random number seed
srandom/1                   # set_seed(+integer) set random number seed
set_seed/1                  # set_seed(+integer) set random number seed
get_seed/1                  # get_seed(-integer) get random number seed
rand/1                      # rand(-integer) integer [0,RAND_MAX]
random/1                    # random(-float) float [0.0,&lt;1.0]
random_between/3            # random_between(+int,+int,-int) integer [arg1,&lt;arg2]

random_float/0              # function returning float [0.0,&lt;1.0]
random_integer/0            # function returning integer [0,RAND_MAX]
rand/0                      # function returning integer [0,RAND_MAX]

bb_get/2                    # SICStus-compatible
bb_put/2                    # SICStus-compatible
bb_delete/2                 # SICStus-compatible
bb_update/3                 # SICStus-compatible
bb_del/1                    # SICStus-compatible

bb_b_put/2                  # SICStus-compatible
bb_b_del/1                  # SICStus-compatible

b_getval/2                  # SWI-compatible
b_setval/2                  # SWI-compatible
b_setval0/2                 # SWI-compatible
b_delete/1                  # SWI-compatible

put_atts/2                  # SICStus-compatible
get_atts/2                  # SICStus-compatible
del_atts/1                  # SICStus-compatible

put_attr/3                  # SWI-compatible
get_attr/3                  # SWI-compatible
del_attr/2                  # SWI-compatible

freeze/2                    # auto-loaded from library(freeze)
frozen/2                    # auto-loaded from library(freeze)
when/2						# auto-loaded from library(when)
dif/2						# auto-loaded from library(dif)

must_be/4                   # must_be(+term,+type,+goal,?arg)
can_be/4                    # can_be(+term,+type,+goal,?arg)
must_be/2                   # must_be(+type,+term)
can_be/2                    # can_be(+type,+term)
expand_term/2               # expand_term(+rule,-Term)
memberchk/2                 # memberchk(+rule,+list).
nonmember/2                 # \+ memberchk(+rule,+list)
atomic_concat/3             # atomic_concat(+atom,+list,-list)
atomic_list_concat/2	    # atomic_list_concat(L,Atom)
atomic_list_concat/3	    # atomic_list_concat(L,Sep,Atom)
read_term_from_chars/2	    # read_term_from_chars(+chars,?term)
read_term_from_chars/3	    # read_term_from_chars(+chars,?term,+list)
write_term_to_chars/3	    # write_term_to_chars(?chars,?term,+list)
write_canonical_to_chars/3  # write_canonical_to_chars(?chars,?term,+list)
chars_base64/3              # currently options are ignored
chars_urlenc/3              # currently options are ignored
hex_chars/2                 # as number_chars, but in hex
octal_chars/2               # as number_chars, but in octal
partial_string/2            # partial_string(+string,-String)
partial_string/3            # partial_string(+string,-String,-Var)
if/3, (*-&gt;)/2               # soft-cut
setup_call_cleanup/3        # setup_call_cleanup(+setup,+call,+cleanup)
call_cleanup/2              # call_cleanup(+call,+cleanup)
term_attvars/2              # term_attvars(+term,-Vs)
copy_term_nat/2             # doesn&#39;t copy attrs
copy_term/3                 # copy_term(+term1,-term2,-Goals)
unifiable/3                 # unifiable(+term1,+term2,-Goals)
?=/2                        # ?=(+term1,+term2)
term_expansion/2
goal_expansion/2
cyclic_term/1
term_singletons/2
findall/4
sort/4
var_number/2
ignore/1
is_list/1
is_partial_list/1
is_list_or_partial_list/1
is_stream/1
term_hash/2
term_hash/3					# ignores arg2 (options)
time/1
inf/0
nan/0
\uXXXX and \UXXXXXXXX 		# quoted character escapes
gcd/2
char_type/2
code_type/2
uuid/1                      # generates non-standard UUID
load_files/[1,2]
split_atom/4
plus/3
module/1
line_count/2
strip_module/3
atom_number/2

call_with_time_limit/2		# SWI-compatible
time_out/3					# SICStus-compatible

nb_setval(K,V)
nb_getval(K,V)
nb_delete(K)
nb_current(K,V)

b_setval(K,V)
b_getval(K,V)
b_delete(K)

&#39;$kv_set&#39;(+key,+value,[create(Bool)])	# use atomics only
&#39;$kv_get&#39;(+key,?value,[delete(Bool)])	# use atomics only

call_nth/2
offset/2
limit/2

getenv/2
setenv/2
unsetenv/1

directory_files/2
delete_file/1
exists_file/1               # also file_exists/1
rename_file/2
copy_file/2
time_file/2
size_file/2

exists_directory/1          # also directory_exists/1
make_directory/1
make_directory_path/1
working_directory/2

chdir/1
absolute_file_name/[2,3]    # expand(Bool) &amp; relative_to(file) options
access_file/2

current_key/1
recorda/2-3
recordz/2-3
recorded/2-3
instance/2
asserta/2
assertz/2
clause/3
erase/1

string_upper/2
string_lower/2
atom_upper/2
atom_lower/2

popcount/1                  # function returning number of 1 bits
lsb/1                       # function returning the least significant bit of a positive integer (count from zero)
msb/1                       # function returning the most significant bit of a positive integer (count from zero)
log10/1                     # function returning log10 of arg
now/0                       # function returning C-time in secs as integer
now/1                       # now (-integer) C-time in secs as integer
get_time/1                  # get_time(-Var) elapsed wall time in secs as float
cpu_time/1                  # cpu_time(-Var) elapsed CPU time in secs as float

sleep/1                     # sleep time in secs
delay/1                     # sleep time for ms
split/4                     # split(+string,+sep,?left,?right)
pid/1
shell/1
shell/2
wall_time/1
date_time/6
date_time/7
loadfile/2                  # loadfile(+filename,-string)
savefile/2                  # savefile(+filename,+string)
getfile/2                   # getfile(+filename,-strings)
getline/1                   # getline(-string)
getline/2                   # getline(+stream,-string)
getlines/1                  # getlines(-strings)
getlines/2                  # getlines(+stream,-strings)
read_line_to_codes/2	   	# removes terminator
read_line_to_string/2		# removes terminator
read_file_to_string/3
bread/3                     # bread(+stream,?len,-string)
bwrite/2                    # bwrite(+stream,+string)
replace/4                   # replace(+string,+old,+new,-string)
persist/1                   # directive &#39;persist funct/arity&#39;

open(stream(Str),...)       # with open/4 reopen a stream
open(F,M,S,[mmap(Ls)])      # with open/4 mmap() the file to Ls"><pre><code>between/3
forall/2
samsort/2                   # same as msort/2
msort/2
merge/3
format/[1-3]
predicate_property/2
numbervars/[1,3-4]
e/0
name/2
tab/[1,2]

maplist/[2-8]               # auto-loaded from library(apply)
foldl/[4-7]                 # auto-loaded from library(apply)
include/3                   # auto-loaded from library(apply)
exclude/3                   # auto-loaded from library(apply)

get_unbuffered_code/1		# read a single unbuffered code
get_unbuffered_char/1		# read a single unbuffered character
read_term_from_atom/3       # read_term_from_atom(+atom,?term)
write_term_to_atom/3        # write_term_to_atom(?atom,?term,+list)
write_canonical_to_atom/3   # write_canonical_to_atom(?atom,?term,+list)
term_to_atom/2              # term_to_atom(?atom,?term)

setrand/1                   # set_seed(+integer) set random number seed
srandom/1                   # set_seed(+integer) set random number seed
set_seed/1                  # set_seed(+integer) set random number seed
get_seed/1                  # get_seed(-integer) get random number seed
rand/1                      # rand(-integer) integer [0,RAND_MAX]
random/1                    # random(-float) float [0.0,&lt;1.0]
random_between/3            # random_between(+int,+int,-int) integer [arg1,&lt;arg2]

random_float/0              # function returning float [0.0,&lt;1.0]
random_integer/0            # function returning integer [0,RAND_MAX]
rand/0                      # function returning integer [0,RAND_MAX]

bb_get/2                    # SICStus-compatible
bb_put/2                    # SICStus-compatible
bb_delete/2                 # SICStus-compatible
bb_update/3                 # SICStus-compatible
bb_del/1                    # SICStus-compatible

bb_b_put/2                  # SICStus-compatible
bb_b_del/1                  # SICStus-compatible

b_getval/2                  # SWI-compatible
b_setval/2                  # SWI-compatible
b_setval0/2                 # SWI-compatible
b_delete/1                  # SWI-compatible

put_atts/2                  # SICStus-compatible
get_atts/2                  # SICStus-compatible
del_atts/1                  # SICStus-compatible

put_attr/3                  # SWI-compatible
get_attr/3                  # SWI-compatible
del_attr/2                  # SWI-compatible

freeze/2                    # auto-loaded from library(freeze)
frozen/2                    # auto-loaded from library(freeze)
when/2						# auto-loaded from library(when)
dif/2						# auto-loaded from library(dif)

must_be/4                   # must_be(+term,+type,+goal,?arg)
can_be/4                    # can_be(+term,+type,+goal,?arg)
must_be/2                   # must_be(+type,+term)
can_be/2                    # can_be(+type,+term)
expand_term/2               # expand_term(+rule,-Term)
memberchk/2                 # memberchk(+rule,+list).
nonmember/2                 # \+ memberchk(+rule,+list)
atomic_concat/3             # atomic_concat(+atom,+list,-list)
atomic_list_concat/2	    # atomic_list_concat(L,Atom)
atomic_list_concat/3	    # atomic_list_concat(L,Sep,Atom)
read_term_from_chars/2	    # read_term_from_chars(+chars,?term)
read_term_from_chars/3	    # read_term_from_chars(+chars,?term,+list)
write_term_to_chars/3	    # write_term_to_chars(?chars,?term,+list)
write_canonical_to_chars/3  # write_canonical_to_chars(?chars,?term,+list)
chars_base64/3              # currently options are ignored
chars_urlenc/3              # currently options are ignored
hex_chars/2                 # as number_chars, but in hex
octal_chars/2               # as number_chars, but in octal
partial_string/2            # partial_string(+string,-String)
partial_string/3            # partial_string(+string,-String,-Var)
if/3, (*-&gt;)/2               # soft-cut
setup_call_cleanup/3        # setup_call_cleanup(+setup,+call,+cleanup)
call_cleanup/2              # call_cleanup(+call,+cleanup)
term_attvars/2              # term_attvars(+term,-Vs)
copy_term_nat/2             # doesn&#39;t copy attrs
copy_term/3                 # copy_term(+term1,-term2,-Goals)
unifiable/3                 # unifiable(+term1,+term2,-Goals)
?=/2                        # ?=(+term1,+term2)
term_expansion/2
goal_expansion/2
cyclic_term/1
term_singletons/2
findall/4
sort/4
var_number/2
ignore/1
is_list/1
is_partial_list/1
is_list_or_partial_list/1
is_stream/1
term_hash/2
term_hash/3					# ignores arg2 (options)
time/1
inf/0
nan/0
\uXXXX and \UXXXXXXXX 		# quoted character escapes
gcd/2
char_type/2
code_type/2
uuid/1                      # generates non-standard UUID
load_files/[1,2]
split_atom/4
plus/3
module/1
line_count/2
strip_module/3
atom_number/2

call_with_time_limit/2		# SWI-compatible
time_out/3					# SICStus-compatible

nb_setval(K,V)
nb_getval(K,V)
nb_delete(K)
nb_current(K,V)

b_setval(K,V)
b_getval(K,V)
b_delete(K)

&#39;$kv_set&#39;(+key,+value,[create(Bool)])	# use atomics only
&#39;$kv_get&#39;(+key,?value,[delete(Bool)])	# use atomics only

call_nth/2
offset/2
limit/2

getenv/2
setenv/2
unsetenv/1

directory_files/2
delete_file/1
exists_file/1               # also file_exists/1
rename_file/2
copy_file/2
time_file/2
size_file/2

exists_directory/1          # also directory_exists/1
make_directory/1
make_directory_path/1
working_directory/2

chdir/1
absolute_file_name/[2,3]    # expand(Bool) &amp; relative_to(file) options
access_file/2

current_key/1
recorda/2-3
recordz/2-3
recorded/2-3
instance/2
asserta/2
assertz/2
clause/3
erase/1

string_upper/2
string_lower/2
atom_upper/2
atom_lower/2

popcount/1                  # function returning number of 1 bits
lsb/1                       # function returning the least significant bit of a positive integer (count from zero)
msb/1                       # function returning the most significant bit of a positive integer (count from zero)
log10/1                     # function returning log10 of arg
now/0                       # function returning C-time in secs as integer
now/1                       # now (-integer) C-time in secs as integer
get_time/1                  # get_time(-Var) elapsed wall time in secs as float
cpu_time/1                  # cpu_time(-Var) elapsed CPU time in secs as float

sleep/1                     # sleep time in secs
delay/1                     # sleep time for ms
split/4                     # split(+string,+sep,?left,?right)
pid/1
shell/1
shell/2
wall_time/1
date_time/6
date_time/7
loadfile/2                  # loadfile(+filename,-string)
savefile/2                  # savefile(+filename,+string)
getfile/2                   # getfile(+filename,-strings)
getline/1                   # getline(-string)
getline/2                   # getline(+stream,-string)
getlines/1                  # getlines(-strings)
getlines/2                  # getlines(+stream,-strings)
read_line_to_codes/2	   	# removes terminator
read_line_to_string/2		# removes terminator
read_file_to_string/3
bread/3                     # bread(+stream,?len,-string)
bwrite/2                    # bwrite(+stream,+string)
replace/4                   # replace(+string,+old,+new,-string)
persist/1                   # directive &#39;persist funct/arity&#39;

open(stream(Str),...)       # with open/4 reopen a stream
open(F,M,S,[mmap(Ls)])      # with open/4 mmap() the file to Ls
</code></pre></div>
<p dir="auto">Note: consult/1 and load_files/2 support lists of files as args. Also
support loading into modules eg. <em>consult(MOD:FILE-SPEC)</em>.</p>
<div data-snippet-clipboard-copy-content="popen/3                     # popen(+cmd,+mode,-stream)
popen/4                     # popen(+cmd,+mode,-stream,+opts)"><pre><code>popen/3                     # popen(+cmd,+mode,-stream)
popen/4                     # popen(+cmd,+mode,-stream,+opts)
</code></pre></div>
<p dir="auto">Note: popen/[3,4] use the Unix popen() system call:</p>
<div data-snippet-clipboard-copy-content="tpl -g &#34;use_module(library(apply)),popen(&#39;ps -a&#39;,read,S,[]),getlines(S,Ls),close(S),maplist(print,Ls),halt&#34;
	PID   TTY      TIME     CMD
	2806  tty2     00:00:00 gnome-session-b
	31645 pts/0    00:00:00 tpl
	31646 pts/0    00:00:00 sh
	31647 pts/0    00:00:00 ps"><pre><code>tpl -g &#34;use_module(library(apply)),popen(&#39;ps -a&#39;,read,S,[]),getlines(S,Ls),close(S),maplist(print,Ls),halt&#34;
	PID   TTY      TIME     CMD
	2806  tty2     00:00:00 gnome-session-b
	31645 pts/0    00:00:00 tpl
	31646 pts/0    00:00:00 sh
	31647 pts/0    00:00:00 ps
</code></pre></div>
<p dir="auto">Note: read_term/[2,3] supports the positions(Start,End) and the
line_counts(Start,End) property options to report file information.
This is analogous to stream_property/2 use of position(Pos) and
line_count(Line) options.</p>

<p dir="auto">Uses Ulrich Neumerkel&#39;s standard reference library. DCG rules are
translated automatically as this library is auto-included.</p>
<div data-snippet-clipboard-copy-content=":- use_module(library(dcgs))."><pre><code>:- use_module(library(dcgs)).
</code></pre></div>

<p dir="auto">Hash a plain-text data string to a hexadecimal byte string
representing the cryptographic strength hashed value. The options
are <em>algorithm(Name)</em> where <em>Name</em> can be <em>sha256</em>, <em>sha384</em> or <em>sha512</em>
at the moment. If it is a variable it will be unified with the default
<em>sha256</em> algorithm. This predicate is only available when compiled
with OpenSSL...</p>
<div data-snippet-clipboard-copy-content="crypto_data_hash/3          # crypto_data_hash(+data,-hash,+options)"><pre><code>crypto_data_hash/3          # crypto_data_hash(+data,-hash,+options)
</code></pre></div>
<p dir="auto">Convert a hexadecimal string to a byte-list. At least one arg must be
instantiated...</p>
<div data-snippet-clipboard-copy-content="hex_bytes/2                 # hex_bytes(?hash,?bytes)"><pre><code>hex_bytes/2                 # hex_bytes(?hash,?bytes)
</code></pre></div>

<div data-snippet-clipboard-copy-content=":- use_module(library(http)).

http_get/3				# http_get(Url, Data, Opts)
http_post/4				# http_post(Url, Data, Opts)
http_patch/4			# http_patch(Url, Data, Opts)
http_put/4				# http_put(Url, Data, Opts)
http_delete/3			# http_delete(Url, Data, Opts)

http_server/2			# http_server(Goal,Opts),

http_request/5			# http_request(S, Method, Path, Ver, Hdrs)"><pre><code>:- use_module(library(http)).

http_get/3				# http_get(Url, Data, Opts)
http_post/4				# http_post(Url, Data, Opts)
http_patch/4			# http_patch(Url, Data, Opts)
http_put/4				# http_put(Url, Data, Opts)
http_delete/3			# http_delete(Url, Data, Opts)

http_server/2			# http_server(Goal,Opts),

http_request/5			# http_request(S, Method, Path, Ver, Hdrs)
</code></pre></div>
<p dir="auto">A server <em>Goal</em> takes a single arg, the connection stream.</p>

<div data-snippet-clipboard-copy-content="server/2                # server(+host,-stream)
server/3                # server(+host,-stream,+list)
accept/2                # accept(+stream,-stream)
client/4                # client(+url,-host,-path,-stream)
client/5                # client(+url,-host,-path,-stream,+list)"><pre><code>server/2                # server(+host,-stream)
server/3                # server(+host,-stream,+list)
accept/2                # accept(+stream,-stream)
client/4                # client(+url,-host,-path,-stream)
client/5                # client(+url,-host,-path,-stream,+list)
</code></pre></div>
<p dir="auto">The options list can include <em>udp(bool)</em> (default is false),
<em>nodelay(bool)</em> (default is true), <em>ssl(bool)</em> (default is false)
and <em>certfile(filespec)</em>.</p>
<p dir="auto">The additional server options can include <em>keyfile(filespec)</em> and
<em>certfile(filespec)</em>. If just one concatenated file is supplied, use
<em>keyfile(filespec)</em> only.</p>
<p dir="auto">The optional schemes &#39;unix://&#39;, &#39;http://&#39; (the default) and &#39;https://&#39;
can be provided in the client URL.</p>
<p dir="auto">With <em>bread/3</em> the &#39;len&#39; arg can be an integer &gt; 0 meaning return that
many bytes, = 0 meaning return what is there (if non-blocking) or a variable
meaning return all bytes until end end of file,</p>

<p dir="auto">Allows the loading of dynamic libraries and calling of foreign functions
written in C from within Prolog...</p>
<div data-snippet-clipboard-copy-content="&#39;$dlopen&#39;/3 			# &#39;$dlopen(+name, +flag, -handle)"><pre><code>&#39;$dlopen&#39;/3 			# &#39;$dlopen(+name, +flag, -handle)
</code></pre></div>
<p dir="auto">These predicates register a foreign function as a builtin and use a
wrapper to validate arg types at call/runtime...</p>
<div data-snippet-clipboard-copy-content="&#39;$register_function&#39;/4		# &#39;$ffi_reg&#39;(+handle,+symbol,+types,+ret_type)
&#39;$register_predicate&#39;/4		# &#39;$ffi_reg&#39;(+handle,+symbol,+types,+ret_type)"><pre><code>&#39;$register_function&#39;/4		# &#39;$ffi_reg&#39;(+handle,+symbol,+types,+ret_type)
&#39;$register_predicate&#39;/4		# &#39;$ffi_reg&#39;(+handle,+symbol,+types,+ret_type)
</code></pre></div>
<p dir="auto">The allowed types are <em>int8</em>, <em>int16</em>, <em>int32</em>, <em>int64</em>, <em>uint8</em>,
<em>uint16</em>, <em>uint32</em>, <em>uint64</em>, <em>fp32</em>, <em>fp64</em>, <em>cstr</em>, <em>const_cstr</em>
and <em>ptr</em> (for arbitrary pointers/handles).</p>
<p dir="auto">Assuming the following C-code in <em>samples/foo.c</em>:</p>
<div data-snippet-clipboard-copy-content="	double foo(double x, int64_t y)
	{
		return pow(x, (double)y);
	}

	int bar(double x, int64_t y, double *result)
	{
		*result = pow(x, (double)y);
		return 0;
	}

	char *baz(const char *x, const char *y)
	{
		char *s = malloc(strlen(x) + strlen(y) + 1);
		strcpy(s, x);
		strcat(s, y);
		return s;
	}"><pre>	<span>double</span> <span>foo</span>(<span>double</span> x, <span>int64_t</span> y)
	{
		<span>return</span> <span>pow</span>(x, (<span>double</span>)y);
	}

	<span>int</span> <span>bar</span>(<span>double</span> x, <span>int64_t</span> y, <span>double</span> *result)
	{
		*result = <span>pow</span>(x, (<span>double</span>)y);
		<span>return</span> <span>0</span>;
	}

	<span>char</span> *<span>baz</span>(<span>const</span> <span>char</span> *x, <span>const</span> <span>char</span> *y)
	{
		<span>char</span> *s = <span>malloc</span>(<span>strlen</span>(x) + <span>strlen</span>(y) + <span>1</span>);
		<span>strcpy</span>(s, x);
		<span>strcat</span>(s, y);
		<span>return</span> s;
	}</pre></div>
<div data-snippet-clipboard-copy-content="	$ gcc -fPIC -c foo.c
	$ gcc -shared -o libfoo.so foo.o"><pre><span>	$ gcc -fPIC -c foo.c</span>
<span>	$ gcc -shared -o libfoo.so foo.o</span></pre></div>
<p dir="auto">Register a builtin function...</p>
<div data-snippet-clipboard-copy-content="	?- &#39;$dlopen&#39;(&#39;samples/libfoo.so&#39;, 0, H),
		&#39;$register_function&#39;(H, foo, [fp64, int64], fp64).
	   H = 94051868794416.
	?- R is foo(2.0, 3).
	   R = 8.0.
	?- R is foo(abc,3).
	   error(type_error(float,abc),foo/2)."><pre>	?- &#39;$dlopen&#39;(&#39;samples/libfoo.so&#39;, 0, H),
		&#39;$register_function&#39;(H, foo, [fp64, int64], fp64).
	   <span>H</span> = <span>94051868794416</span><span>.</span>
	?- R is foo(2.0, 3).
	   <span>R</span> = <span>8</span>.<span>0</span><span>.</span>
	?- R is foo(abc,3).
	   <span>error</span>(type_error(<span>float</span>,<span>abc</span>),<span>foo</span>/2)<span>.</span></pre></div>
<p dir="auto">Register a builtin predicate...</p>
<div data-snippet-clipboard-copy-content="	?- &#39;$dlopen&#39;(&#39;samples/libfoo.so&#39;, 0, H),
		&#39;$register_predicate&#39;(H, bar, [fp64, int64, -fp64], int64),
		&#39;$register_predicate&#39;(H, baz, [cstr, cstr], cstr),
	   H = 94051868794416.
	?- bar(2.0, 3, X, Return).
	   X = 8.0, Return = 0.
	?- baz(&#39;abc&#39;, &#39;123&#39;, Return).
	   Return = abc123."><pre>	?- &#39;$dlopen&#39;(&#39;samples/libfoo.so&#39;, 0, H),
		&#39;$register_predicate&#39;(H, bar, [fp64, int64, -fp64], int64),
		&#39;$register_predicate&#39;(H, baz, [cstr, cstr], cstr),
	   <span>H</span> = <span>94051868794416</span><span>.</span>
	?- bar(2.0, 3, X, Return).
	   <span>X</span> = <span>8</span>.<span>0</span>, <span>Return</span> = <span>0</span><span>.</span>
	?- baz(&#39;abc&#39;, &#39;123&#39;, Return).
	   <span>Return</span> = <span>abc123</span><span>.</span></pre></div>
<p dir="auto">Note: the foreign function return value is passed as an extra argument
to the predicate call.</p>
<p dir="auto">There is an example using SQLITE. First make sure SQLITE is installed
on your system, for example...</p>
<div data-snippet-clipboard-copy-content="	$ sudo apt install sqlite3"><pre><span>	$ sudo apt install sqlite3</span></pre></div>
<p dir="auto">Then, given the code in <em>samples/sqlite3.pl</em>...</p>
<div data-snippet-clipboard-copy-content="	:- use_module(library(sqlite3)).

	run :-
		test(&#39;samples/sqlite3.db&#39;, &#39;SELECT * FROM company&#39;).

	test(Database, Query) :-
		flag(&#39;SQLITE_OK&#39;, SQLITE_OK),
		sqlite3_open(Database, Connection, Ret), Ret =:= SQLITE_OK,
		bagof(Row, sqlite3_query(Connection, Query, Row, _), Results),
		writeq(Results), nl."><pre>	:- <span>use_module</span>(library(<span>sqlite3</span>))<span>.</span>

	<span>run</span> <span>:-</span>
		test(<span>&#39;samples/sqlite3.db&#39;</span>, <span>&#39;SELECT * FROM company&#39;</span>)<span>.</span>

	<span>test</span>(<span>Database</span>, <span>Query</span>) <span>:-</span>
		flag(<span>&#39;SQLITE_OK&#39;</span>, <span>SQLITE_OK</span>),
		sqlite3_open(<span>Database</span>, <span>Connection</span>, <span>Ret</span>), <span>Ret</span> <span>=:=</span> <span>SQLITE_OK</span>,
		bagof(<span>Row</span>, sqlite3_query(<span>Connection</span>, <span>Query</span>, <span>Row</span>, <span>_</span>), <span>Results</span>),
		writeq(<span>Results</span>), <span>nl</span><span>.</span></pre></div>
<p dir="auto">Run...</p>
<div data-snippet-clipboard-copy-content="	$ tpl -g run,halt samples/sqlite3.pl
[[1,&#39;Paul&#39;,32,&#39;California&#39;,20000.0],[2,&#39;Allen&#39;,25,&#39;Texas&#39;,15000.0],[3,&#39;Teddy&#39;,23,&#39;Norway&#39;,20000.0],[4,&#39;Mark&#39;,25,&#39;Rich-Mond &#39;,65000.0],[5,&#39;David&#39;,27,&#39;Texas&#39;,85000.0],[6,&#39;Kim&#39;,22,&#39;South-Hall&#39;,45000.0]]"><pre><span>	$ tpl -g run,halt samples/sqlite3.pl</span>
<span>[[1,&#39;Paul&#39;,32,&#39;California&#39;,20000.0],[2,&#39;Allen&#39;,25,&#39;Texas&#39;,15000.0],[3,&#39;Teddy&#39;,23,&#39;Norway&#39;,20000.0],[4,&#39;Mark&#39;,25,&#39;Rich-Mond &#39;,65000.0],[5,&#39;David&#39;,27,&#39;Texas&#39;,85000.0],[6,&#39;Kim&#39;,22,&#39;South-Hall&#39;,45000.0]]</span></pre></div>

<p dir="auto">Declaring something dynamic with the <em>persist</em> directive:</p>
<div data-snippet-clipboard-copy-content=":- persist :predindicator"><pre><code>:- persist :predindicator
</code></pre></div>
<p dir="auto">causes that clause to be saved to a per-module database on update
(asserta/assertz/retract). Maybe this should be an option to
<em>dynamic/2</em>?</p>

<p dir="auto">Trealla is single-threaded internally but cooperative multitasking is
available in the form of light-weight coroutines that run until they
yield control, either explicitly or implicitly (when waiting on input
or a timer)...</p>
<div data-snippet-clipboard-copy-content="task/[1-n]	            # concurrent form of call/1-n
tasklist/[2-8]          # concurrent form of maplist/1-n"><pre><code>task/[1-n]	            # concurrent form of call/1-n
tasklist/[2-8]          # concurrent form of maplist/1-n
</code></pre></div>
<p dir="auto">Note: <em>tasklist</em> limits the number of concurrent tasks to a small
pool (4?) of tasks active at one time. New tasks are scheduled as prior
ones complete.</p>
<p dir="auto">An example:</p>
<div data-snippet-clipboard-copy-content=":-use_module(library(http)).

geturl(Url) :-
	http_get(Url,_Data,[status_code(Code),final_url(Location)]),
	format(&#34;Job [~w] ~w ==&gt; ~w done~n&#34;,[Url,Code,Location]).

% Fetch each URL in list sequentially...

test54 :-
	L = [&#39;www.google.com&#39;,&#39;www.bing.com&#39;,&#39;www.duckduckgo.com&#39;],
	maplist(geturl,L),
	writeln(&#39;Finished&#39;).

```console
$ tpl samples/test -g &#34;time(test54),halt&#34;
Job [www.google.com] 200 ==&gt; www.google.com done
Job [www.bing.com] 200 ==&gt; www.bing.com done
Job [www.duckduckgo.com] 200 ==&gt; https://duckduckgo.com done
Finished
Time elapsed 0.663 secs

% Fetch each URL in list concurrently...

test56 :-
	L = [&#39;www.google.com&#39;,&#39;www.bing.com&#39;,&#39;www.duckduckgo.com&#39;],
	tasklist(geturl,L),
	writeln(&#39;Finished&#39;)."><pre>:-<span>use_module</span>(library(<span>http</span>))<span>.</span>

<span>geturl</span>(<span>Url</span>) <span>:-</span>
	http_get(<span>Url</span>,<span>_Data</span>,[status_code(<span>Code</span>),final_url(<span>Location</span>)]),
	format(<span>&#34;Job [~w] ~w ==&gt; ~w done~n&#34;</span>,[<span>Url</span>,<span>Code</span>,<span>Location</span>])<span>.</span>

<span>% Fetch each URL in list sequentially...</span>

<span>test54</span> <span>:-</span>
	<span>L</span> <span>=</span> [<span>&#39;www.google.com&#39;</span>,<span>&#39;www.bing.com&#39;</span>,<span>&#39;www.duckduckgo.com&#39;</span>],
	maplist(<span>geturl</span>,<span>L</span>),
	<span>writeln</span>(<span>&#39;Finished&#39;</span>)<span>.</span>

```console
$ tpl samples/test -g &#34;time(test54),halt&#34;
<span>Job</span> [<span>www</span><span>.</span>google.com] 200 ==&gt; www.google.com done
<span>Job</span> [<span>www</span><span>.</span>bing.com] 200 ==&gt; www.bing.com done
<span>Job</span> [<span>www</span><span>.</span>duckduckgo.com] 200 ==&gt; https://duckduckgo.com done
<span>Finished</span>
<span>Time</span> <span>elapsed</span> <span>0</span>.<span>663</span> <span>secs</span>

% <span>Fetch</span> <span>each</span> <span>URL</span> <span>in</span> <span>list</span> <span>concurrently</span><span>.</span>..

<span>test56</span> <span>:-</span>
	<span>L</span> <span>=</span> [<span>&#39;www.google.com&#39;</span>,<span>&#39;www.bing.com&#39;</span>,<span>&#39;www.duckduckgo.com&#39;</span>],
	tasklist(<span>geturl</span>,<span>L</span>),
	<span>writeln</span>(<span>&#39;Finished&#39;</span>)<span>.</span></pre></div>
<p dir="auto">$ tpl samples/test -g &#34;time(test56),halt&#34;
Job [<a href="http://www.duckduckgo.com" rel="nofollow">www.duckduckgo.com</a>] 200 ==&gt; <a href="https://duckduckgo.com" rel="nofollow">https://duckduckgo.com</a> done
Job [<a href="http://www.bing.com" rel="nofollow">www.bing.com</a>] 200 ==&gt; <a href="http://www.bing.com" rel="nofollow">www.bing.com</a> done
Job [<a href="http://www.google.com" rel="nofollow">www.google.com</a>] 200 ==&gt; <a href="http://www.google.com" rel="nofollow">www.google.com</a> done
Finished
Time elapsed 0.33 secs</p>
<div data-snippet-clipboard-copy-content="
Multiple* high level *prolog* objects can be created and assigned to
operating system threads in a C-wrapper program by calling

```c
	prolog *pl = pl_create()
	pl_consult(pl, filename)
	pl_eval(pl, expr)
	etc."><pre><code>
Multiple* high level *prolog* objects can be created and assigned to
operating system threads in a C-wrapper program by calling

```c
	prolog *pl = pl_create()
	pl_consult(pl, filename)
	pl_eval(pl, expr)
	etc.
</code></pre></div>
<p dir="auto">Each such <em>prolog</em> instance is thread-safe. Such instances could use
Unix domain sockets for IPC.</p>
</article>
          </div></div>
  </body>
</html>
