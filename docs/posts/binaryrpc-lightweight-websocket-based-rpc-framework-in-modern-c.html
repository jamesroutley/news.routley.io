<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/efecan0/binaryrpc-framework">Original</a>
    <h1>Show HN: BinaryRPC ‚Äì Lightweight WebSocket-based RPC framework in modern C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">

<p dir="auto">While working at my company, I had previously developed a WebSocket server prototype in Java. However, over time, we started to experience performance issues. This led me to turn to C++, a language that offers more speed and low-level system control. Through my research, I discovered that uWebSockets was one of the best options in terms of performance, so I began developing with this library.</p>
<p dir="auto">However, since uWebSockets is a very &#34;core&#34; library, I had to handle many details myself. Even adding a simple feature required a lot of infrastructure management. During this process, I explored other libraries in the C++ ecosystem, but most were either too heavy or did not prioritize developer experience.</p>
<p dir="auto">Having developed many projects with Node.js and Express.js in the past, I had this idea:
Why not have a modern RPC framework in C++ that supports middleware and session logic, just like Express.js?</p>
<p dir="auto">With this idea in mind, I started designing a system that includes session management, a middleware structure, and an RPC handler architecture. At first, it was just a dream, but over time I built the building blocks of that dream one by one. I laid the foundations of this framework before graduating, and after graduation, I decided to make it open source as both a gift to myself and a contribution to the developer community.</p>
<p dir="auto">Although I sometimes got lost in the vast control that C++ offers, I progressed step by step to bring it to its current state. I tried to include the essential things a developer might need. I hope you enjoy using it and encounter no issues, because this project is, in fact, a heartfelt contribution that a newly graduated engineer wanted to offer to the world.</p>
<p dir="auto">In the future, I aim to evolve this architecture into an actor-mailbox model. However, I believe the current structure needs to be further solidified first. If you have any suggestions or contributions regarding this process, please feel free to contact me.</p>
<hr/>
<blockquote>
<p dir="auto"><strong>BinaryRPC</strong> is a high‚Äëthroughput RPC framework built on top of <strong>uWebSockets</strong>.</p>
</blockquote>
<blockquote>
<p dir="auto">It is designed for latency-sensitive applications such as multiplayer games, financial tick streams, and IoT dashboards, delivering ultra-low latency and minimal overhead. With a modular architecture and efficient networking, BinaryRPC remains lightweight both in resource usage and developer experience.</p>
</blockquote>
<hr/>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Capability</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>‚ö° <strong>WebSocket transport</strong></td>
<td>Blazing‚Äëfast networking powered by uWebSockets and <code>epoll</code>/<code>kqueue</code>.</td>
</tr>
<tr>
<td>üîÑ <strong>Configurable reliability (QoS)</strong></td>
<td><code>None</code>, <code>AtLeastOnce</code>, <code>ExactlyOnce</code> with retries, ACKs &amp; two‚Äëphase commit, plus <strong>pluggable back‚Äëoff strategies</strong> &amp; <strong>per‚Äësession TTL</strong>.</td>
</tr>
<tr>
<td>üß© <strong>Pluggable layers</strong></td>
<td>Drop‚Äëin protocols (<code>SimpleText</code>, <strong>MsgPack</strong>, ‚Ä¶), transports, middleware &amp; plugins.</td>
</tr>
<tr>
<td>üßë‚Äçü§ù‚Äçüßë <strong>Stateful sessions</strong></td>
<td>Reconnect‚Äëfriendly <code>Session</code> objects with automatic expiry &amp; indexed fields.</td>
</tr>
<tr>
<td>üõ°Ô∏è <strong>Middleware chain</strong></td>
<td>JWT auth, token bucket rate‚Äëlimiter and any custom middleware you write.</td>
</tr>
<tr>
<td>üîå <strong>Header‚Äëonly core</strong></td>
<td>Almost all of BinaryRPC lives in headers ‚Äì <em>just add include path</em>.</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<hr/>
<p dir="auto">This project is a modern C++ RPC framework with several external dependencies. To use it, you should first install the required dependencies (see below), then build the project, and finally link it in your own project. The example_server directory demonstrates typical usage.</p>

<ul dir="auto">
<li><strong>CMake</strong>: Version 3.16 or higher.</li>
<li><strong>C++ Compiler</strong>: A compiler with C++20 support (e.g., MSVC, GCC, Clang).</li>
<li><strong>vcpkg</strong>: A C++ package manager from Microsoft, used for dependencies.</li>
<li><strong>Git</strong>: For cloning the repository.</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">2. Building and Installing the Library</h3><a id="user-content-2-building-and-installing-the-library" aria-label="Permalink: 2. Building and Installing the Library" href="#2-building-and-installing-the-library"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<blockquote>
<p dir="auto"><strong>Note:</strong>
Starting from version 0.1.0, BinaryRPC expects you to set the <code>VCPKG_ROOT</code> environment variable to your vcpkg installation path <strong>on Windows</strong>. This makes the build process portable and avoids hardcoding paths. If you do not set this variable on Windows, CMake will stop with an error.</p>
<p dir="auto"><strong>Linux/macOS users:</strong> You don&#39;t need to set VCPKG_ROOT as the project uses system package managers on these platforms.</p>
<p dir="auto"><strong>How to set VCPKG_ROOT (Windows only):</strong></p>
<ul dir="auto">
<li><strong>Windows (PowerShell):</strong>
<div dir="auto" data-snippet-clipboard-copy-content="$env:VCPKG_ROOT = &#34;C:/path/to/vcpkg&#34;"><pre><span>$<span>env:</span>VCPKG_ROOT</span> <span>=</span> <span><span>&#34;</span>C:/path/to/vcpkg<span>&#34;</span></span></pre></div>
</li>
<li><strong>Windows (CMD):</strong>
<div dir="auto" data-snippet-clipboard-copy-content="set VCPKG_ROOT=C:/path/to/vcpkg"><pre><span>set</span> <span>VCPKG_ROOT</span><span>=</span>C:/path/to/vcpkg</pre></div>
</li>
</ul>
<p dir="auto">Replace <code>/path/to/vcpkg</code> with the actual path where you cloned vcpkg.</p>
</blockquote>
<div dir="auto"><h4 tabindex="-1" dir="auto">Step 2.1: Install Dependencies with vcpkg</h4><a id="user-content-step-21-install-dependencies-with-vcpkg" aria-label="Permalink: Step 2.1: Install Dependencies with vcpkg" href="#step-21-install-dependencies-with-vcpkg"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">First, ensure you have <a href="https://github.com/microsoft/vcpkg">vcpkg</a> installed and bootstrapped. Then, install all required dependencies:</p>


<p dir="auto">These are required for building and running the core framework:</p>

<div dir="auto" data-snippet-clipboard-copy-content="./vcpkg install unofficial-uwebsockets zlib boost-thread folly glog gflags fmt double-conversion --triplet x64-windows"><pre>./vcpkg install unofficial-uwebsockets zlib boost-thread folly glog gflags fmt double-conversion --triplet x64-windows</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="sudo pacman -S uwebsockets zlib boost folly glog gflags fmt double-conversion openssl usockets"><pre>sudo pacman -S uwebsockets zlib boost folly glog gflags fmt double-conversion openssl usockets</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="sudo apt update
sudo apt install libuwebsockets-dev zlib1g-dev libboost-thread-dev libfolly-dev libgoogle-glog-dev libgflags-dev libfmt-dev libdouble-conversion-dev libssl-dev libusockets-dev"><pre>sudo apt update
sudo apt install libuwebsockets-dev zlib1g-dev libboost-thread-dev libfolly-dev libgoogle-glog-dev libgflags-dev libfmt-dev libdouble-conversion-dev libssl-dev libusockets-dev</pre></div>
<blockquote>
<p dir="auto"><strong>Note on folly and glog:</strong></p>
<ul dir="auto">
<li>On some distributions, the package names may differ or the packages may not be available in the default repositories. In that case, you may need to build <a href="https://github.com/facebook/folly">folly</a> and <a href="https://github.com/google/glog">glog</a> from source. Please refer to their official documentation for build instructions.</li>
<li><strong>Folly and glog can sometimes be incompatible on certain Linux systems.</strong> If you encounter build errors related to glog, you can try disabling glog or ensure you are using compatible versions. On Linux, BinaryRPC disables glog logging by default if there is a known incompatibility.</li>
<li>If you see an error like <code>folly library not found!</code>, make sure folly is installed and the library path is visible to the linker (e.g., <code>/usr/lib</code> or <code>/usr/local/lib</code>).</li>
<li>If you see an error like <code>glog library not found!</code>, make sure glog is installed and the library path is visible to the linker.</li>
</ul>
</blockquote>

<p dir="auto">Install these only if you need the corresponding features:</p>
<ul dir="auto">
<li><strong>JWT-based authentication middleware:</strong>
<ul dir="auto">
<li>Windows: <code>./vcpkg install jwt-cpp --triplet x64-windows</code></li>
<li>Linux: <code>sudo pacman -S jwt-cpp</code></li>
</ul>
</li>
<li><strong>JSON payload support (e.g., for nlohmann-json):</strong>
<ul dir="auto">
<li>Windows: <code>./vcpkg install nlohmann-json --triplet x64-windows</code></li>
<li>Linux: <code>sudo pacman -S nlohmann-json</code></li>
</ul>
</li>
</ul>
<blockquote>
<p dir="auto">You only need to install these optional dependencies if you plan to use JWT authentication or JSON-based payloads in your application or middleware.</p>
</blockquote>
<div dir="auto"><h4 tabindex="-1" dir="auto">Step 2.2: Configure, Build, and Install BinaryRPC</h4><a id="user-content-step-22-configure-build-and-install-binaryrpc" aria-label="Permalink: Step 2.2: Configure, Build, and Install BinaryRPC" href="#step-22-configure-build-and-install-binaryrpc"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This process will compile the library and install its headers and binaries into a standard system location, making it available for other projects.</p>
<div dir="auto" data-snippet-clipboard-copy-content="# 1. Clone the repository
git clone https://github.com/efecan0/binaryrpc-framework.git
cd binaryrpc

# 2. Create a build directory
cmake -E make_directory build
cd build

# 3. Configure the project with the vcpkg toolchain
#    Use the VCPKG_ROOT environment variable for portability
cmake .. -DCMAKE_TOOLCHAIN_FILE=${VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake

# 4. Build the library
cmake --build . --config Release

# 5. Install the library
#    On Linux/macOS, you may need to run this with sudo
cmake --install . --config Release"><pre><span><span>#</span> 1. Clone the repository</span>
git clone https://github.com/efecan0/binaryrpc-framework.git
<span>cd</span> binaryrpc

<span><span>#</span> 2. Create a build directory</span>
cmake -E make_directory build
<span>cd</span> build

<span><span>#</span> 3. Configure the project with the vcpkg toolchain</span>
<span><span>#</span>    Use the VCPKG_ROOT environment variable for portability</span>
cmake .. -DCMAKE_TOOLCHAIN_FILE=<span>${VCPKG_ROOT}</span>/scripts/buildsystems/vcpkg.cmake

<span><span>#</span> 4. Build the library</span>
cmake --build <span>.</span> --config Release

<span><span>#</span> 5. Install the library</span>
<span><span>#</span>    On Linux/macOS, you may need to run this with sudo</span>
cmake --install <span>.</span> --config Release</pre></div>
<p dir="auto"><strong>For Linux/macOS users:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="# 1. Clone the repository
git clone https://github.com/efecan0/binaryrpc-framework.git
cd binaryrpc

# 2. Create a build directory
cmake -E make_directory build
cd build

# 3. Configure the project (no toolchain file needed on Linux/macOS)
cmake ..

# 4. Build the library
cmake --build . --config Release

# 5. Install the library
#    You may need to run this with sudo
cmake --install . --config Release"><pre><span><span>#</span> 1. Clone the repository</span>
git clone https://github.com/efecan0/binaryrpc-framework.git
<span>cd</span> binaryrpc

<span><span>#</span> 2. Create a build directory</span>
cmake -E make_directory build
<span>cd</span> build

<span><span>#</span> 3. Configure the project (no toolchain file needed on Linux/macOS)</span>
cmake ..

<span><span>#</span> 4. Build the library</span>
cmake --build <span>.</span> --config Release

<span><span>#</span> 5. Install the library</span>
<span><span>#</span>    You may need to run this with sudo</span>
cmake --install <span>.</span> --config Release</pre></div>
<p dir="auto">After this step, BinaryRPC is installed on your system and can be found by any other CMake project using <code>find_package(binaryrpc)</code>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">3. Building and Running the Examples (Optional)</h3><a id="user-content-3-building-and-running-the-examples-optional" aria-label="Permalink: 3. Building and Running the Examples (Optional)" href="#3-building-and-running-the-examples-optional"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <code>examples</code> directory contains a separate project that demonstrates how to use the installed library.</p>
<div dir="auto" data-snippet-clipboard-copy-content="# From the root of the binaryrpc repository, navigate to the examples
cd examples

# Create a build directory
cmake -E make_directory build
cd build

# Configure the example project. CMake will find the installed library.
# No toolchain file needed on Linux/macOS.
cmake ..

# Build the examples
cmake --build . --config Release

# Run the basic server example
./basic_server"><pre><span><span>#</span> From the root of the binaryrpc repository, navigate to the examples</span>
<span>cd</span> examples

<span><span>#</span> Create a build directory</span>
cmake -E make_directory build
<span>cd</span> build

<span><span>#</span> Configure the example project. CMake will find the installed library.</span>
<span><span>#</span> No toolchain file needed on Linux/macOS.</span>
cmake ..

<span><span>#</span> Build the examples</span>
cmake --build <span>.</span> --config Release

<span><span>#</span> Run the basic server example</span>
./basic_server</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">4. Using BinaryRPC in Your Own Project</h3><a id="user-content-4-using-binaryrpc-in-your-own-project" aria-label="Permalink: 4. Using BinaryRPC in Your Own Project" href="#4-using-binaryrpc-in-your-own-project"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To use BinaryRPC in your own CMake project, simply add the following to your <code>CMakeLists.txt</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Find the installed binaryrpc package
find_package(binaryrpc 0.1.0 REQUIRED)

# ...

# Link your executable or library to binaryrpc
# The binaryrpc::core target will automatically bring in all necessary
# dependencies and include directories.
target_link_libraries(your_target_name PRIVATE binaryrpc::core)"><pre><span>#<span> Find the installed binaryrpc package</span></span>
<span>find_package</span>(<span>binaryrpc</span> <span>0.1.0</span> <span>REQUIRED</span>)

<span>#<span> ...</span></span>

<span>#<span> Link your executable or library to binaryrpc</span></span>
<span>#<span> The binaryrpc::core target will automatically bring in all necessary</span></span>
<span>#<span> dependencies and include directories.</span></span>
<span>target_link_libraries</span>(<span>your_target_name</span> <span>PRIVATE</span> <span>binaryrpc::core</span>)</pre></div>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">üö™ Custom handshake &amp; authentication (<code>IHandshakeInspector</code>)</h2><a id="user-content--custom-handshake--authentication-ihandshakeinspector" aria-label="Permalink: üö™ Custom handshake &amp; authentication (IHandshakeInspector)" href="#-custom-handshake--authentication-ihandshakeinspector"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <strong>first thing</strong> every WebSocket upgrade hits is an <code>IHandshakeInspector</code>. The default one simply accepts the socket and builds a trivial <code>ClientIdentity</code> from the URL query‚Äëstring. In production you almost always want to <strong>sub‚Äëclass</strong> it.</p>
<p dir="auto">Below is a condensed version of the <code>CustomHandshakeInspector</code> actually running in the reference <strong>chat server</strong>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="class CustomHandshakeInspector : public IHandshakeInspector {
public:
    std::optional&lt;ClientIdentity&gt; extract(uWS::HttpRequest&amp; req) override {
        // --- 1. Parse query‚Äëstring ------------------------------
        // Expected ‚Üí ws://host:9010/?clientId=123&amp;deviceId=456&amp;sessionToken=ABCD‚Ä¶

        std::string q{req.getQuery()};
        auto [clientId, deviceIdStr, tokenHex] = parseQuery(q);

        if (clientId.empty() || deviceIdStr.empty())
            return std::nullopt; // missing mandatory IDs

        // --- 2. Validate deviceId is numeric --------------------
        int deviceId;
        try {
            deviceId = std::stoi(deviceIdStr);
        } catch (...) {
            return std::nullopt;
        }

        // --- 3. Check persistent session file ------------------
        if (!sessionFileContains(clientId, deviceIdStr))
            return std::nullopt; // kick unknown combos

        // --- 4. Build / generate sessionToken ------------------
        std::array&lt;std::uint8_t, 16&gt; token{};

        if (tokenHex.size() == 32)
            hexStringToByteArray(tokenHex, token); // reuse supplied token
        else
            token = sha256_16(clientId + &#39;:&#39; + deviceIdStr + &#39;:&#39; + epochMs());

        // --- 5. Emit identity ----------------------------------
        ClientIdentity id;
        id.clientId = clientId;
        id.deviceId = deviceId;
        id.sessionToken = token;

        return id; // non‚Äënullopt ‚áí upgrade success
    }
};

// Inspector&#39;ƒ± WebSocket sunucusuna ata
ws-&gt;setHandshakeInspector(std::make_shared&lt;CustomHandshakeInspector&gt;());
"><pre><span>class</span> <span>CustomHandshakeInspector</span> : <span>public</span> <span>IHandshakeInspector</span> {
<span>public:</span>
    std::optional&lt;ClientIdentity&gt; <span>extract</span>(uWS::HttpRequest&amp; req) <span>override</span> {
        <span><span>//</span> --- 1. Parse query‚Äëstring ------------------------------</span>
        <span><span>//</span> Expected ‚Üí ws://host:9010/?clientId=123&amp;deviceId=456&amp;sessionToken=ABCD‚Ä¶</span>

        std::string q{req.<span>getQuery</span>()};
        <span>auto</span> [clientId, deviceIdStr, tokenHex] = <span>parseQuery</span>(q);

        <span>if</span> (clientId.<span>empty</span>() || deviceIdStr.<span>empty</span>())
            <span>return</span> std::nullopt; <span><span>//</span> missing mandatory IDs</span>

        <span><span>//</span> --- 2. Validate deviceId is numeric --------------------</span>
        <span>int</span> deviceId;
        <span>try</span> {
            deviceId = <span>std::stoi</span>(deviceIdStr);
        } <span>catch</span> (...) {
            <span>return</span> std::nullopt;
        }

        <span><span>//</span> --- 3. Check persistent session file ------------------</span>
        <span>if</span> (!<span>sessionFileContains</span>(clientId, deviceIdStr))
            <span>return</span> std::nullopt; <span><span>//</span> kick unknown combos</span>

        <span><span>//</span> --- 4. Build / generate sessionToken ------------------</span>
        std::array&lt;std::<span>uint8_t</span>, <span>16</span>&gt; token{};

        <span>if</span> (tokenHex.<span>size</span>() == <span>32</span>)
            <span>hexStringToByteArray</span>(tokenHex, token); <span><span>//</span> reuse supplied token</span>
        <span>else</span>
            token = <span>sha256_16</span>(clientId + <span><span>&#39;</span>:<span>&#39;</span></span> + deviceIdStr + <span><span>&#39;</span>:<span>&#39;</span></span> + <span>epochMs</span>());

        <span><span>//</span> --- 5. Emit identity ----------------------------------</span>
        ClientIdentity id;
        id.<span>clientId</span> = clientId;
        id.<span>deviceId</span> = deviceId;
        id.<span>sessionToken</span> = token;

        <span>return</span> id; <span><span>//</span> non‚Äënullopt ‚áí upgrade success</span>
    }
};

<span><span>//</span> Inspector&#39;ƒ± WebSocket sunucusuna ata</span>
ws-&gt;<span>setHandshakeInspector</span>(std::make_shared&lt;CustomHandshakeInspector&gt;());
</pre></div>

<p dir="auto">The sample inspector above expects the client to provide <strong>three</strong> query parameters on the WebSocket URL:</p>
<ul dir="auto">
<li><strong><code>clientId</code></strong>: An opaque user string (e.g., email or database ID).</li>
<li><strong><code>deviceId</code></strong>: An integer identifying the physical device.</li>
<li><strong><code>sessionToken</code></strong> (optional): A 32-character hex string to resume a previous session.</li>
</ul>
<p dir="auto">If <code>extract()</code> returns <code>std::nullopt</code>, the upgrade is rejected with a <strong>400 Bad Request</strong>. If the <code>sessionToken</code> is absent or invalid, a secure inspector should generate a new one and provide it to the client after a successful connection.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Alternative: JWT-based Handshake</h3><a id="user-content-alternative-jwt-based-handshake" aria-label="Permalink: Alternative: JWT-based Handshake" href="#alternative-jwt-based-handshake"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you prefer to use standards like JSON Web Tokens (JWT) for authentication, you can write an inspector that checks for an HTTP header instead of query parameters.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Forward declarations for your business logic
ClientIdentity makeClientFromJwt(const std::string&amp; token);
bool verifyJwt(const std::string&amp; token);

class JwtInspector : public IHandshakeInspector {
public:
    std::optional&lt;ClientIdentity&gt; extract(uWS::HttpRequest&amp; req) override {
        // This is illustrative. You would use req.getHeader(&#34;x-access-token&#34;).
        std::string_view token_sv = req.getHeader(&#34;x-access-token&#34;);

        if (token_sv.empty()) {
            return std::nullopt;
        }

        std::string token{token_sv};
        if (verifyJwt(token)) {
            return makeClientFromJwt(token);
        }

        return std::nullopt;
    }
};

// In your main setup:
// ws-&gt;setHandshakeInspector(std::make_shared&lt;JwtInspector&gt;());"><pre><span><span>//</span> Forward declarations for your business logic</span>
ClientIdentity <span>makeClientFromJwt</span>(<span>const</span> std::string&amp; token);
<span>bool</span> <span>verifyJwt</span>(<span>const</span> std::string&amp; token);

<span>class</span> <span>JwtInspector</span> : <span>public</span> <span>IHandshakeInspector</span> {
<span>public:</span>
    std::optional&lt;ClientIdentity&gt; <span>extract</span>(uWS::HttpRequest&amp; req) <span>override</span> {
        <span><span>//</span> This is illustrative. You would use req.getHeader(&#34;x-access-token&#34;).</span>
        std::string_view token_sv = req.<span>getHeader</span>(<span><span>&#34;</span>x-access-token<span>&#34;</span></span>);

        <span>if</span> (token_sv.<span>empty</span>()) {
            <span>return</span> std::nullopt;
        }

        std::string token{token_sv};
        <span>if</span> (<span>verifyJwt</span>(token)) {
            <span>return</span> <span>makeClientFromJwt</span>(token);
        }

        <span>return</span> std::nullopt;
    }
};

<span><span>//</span> In your main setup:</span>
<span><span>//</span> ws-&gt;setHandshakeInspector(std::make_shared&lt;JwtInspector&gt;());</span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Reusing an active session</h3><a id="user-content-reusing-an-active-session" aria-label="Permalink: Reusing an active session" href="#reusing-an-active-session"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If the inspector returns a <code>ClientIdentity</code> whose <code>sessionToken</code> matches a live session (i.e. inside <code>sessionTtlMs</code>) with the same <code>clientId</code> + <code>deviceId</code>, BinaryRPC will:</p>
<ol dir="auto">
<li>
<p dir="auto"><strong>Attach</strong> the new socket to that session.</p>
</li>
<li>
<p dir="auto"><strong>Replay</strong> all QoS‚Äë1/2 frames still waiting in its outbox, so the client sees every offline message.</p>
</li>
<li>
<p dir="auto">Retain all custom fields you stored via <code>FrameworkAPI</code> (e.g. inventories, lobby, XP) ‚Äì the client continues as if the connection had never dropped.</p>
</li>
</ol>
<p dir="auto">No extra code on your side ‚Äì just be sure your inspector passes back the <em>exact</em> 16‚Äëbyte token previously issued.</p>
<hr/>

<p dir="auto">BinaryRPC offers <strong>three delivery tiers</strong> inspired by MQTT but adapted for WebSockets:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Level</th>
<th>Guarantees</th>
<th>Frame flow</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QoSLevel::None</code></td>
<td><em>At‚Äëmost‚Äëonce.</em> Fire‚Äëand‚Äëforget ‚Äì lowest latency.</td>
<td><code>DATA</code> ‚Üí <strong>client</strong></td>
</tr>
<tr>
<td><code>QoSLevel::AtLeastOnce</code></td>
<td><em>At‚Äëleast‚Äëonce.</em> Server retries until client ACKs.</td>
<td><code>DATA</code> ‚Üî <code>ACK</code></td>
</tr>
<tr>
<td><code>QoSLevel::ExactlyOnce</code></td>
<td><em>Exactly‚Äëonce.</em> Two‚Äëphase commit eliminates duplicates.</td>
<td><code>PREPARE</code> ‚Üî <code>PREPARE_ACK</code> ‚Üî <code>COMMIT</code> ‚Üî <code>COMPLETE</code></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div dir="auto"><h3 tabindex="-1" dir="auto">Why <code>sessionTtlMs</code> matters ü§î</h3><a id="user-content-why-sessionttlms-matters-" aria-label="Permalink: Why sessionTtlMs matters ü§î" href="#why-sessionttlms-matters-"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>sessionTtlMs</code> defines <strong>how long BinaryRPC keeps a disconnected client&#39;s session alive in memory and on‚Äëdisk outbox</strong>:</p>
<ul dir="auto">
<li>
<p dir="auto"><strong>Seamless reconnects</strong> ‚Äì mobile/Wi‚ÄëFi users frequently drop for a few seconds. As long as they re‚Äëjoin within the TTL, the framework stitches the new socket onto the old <code>Session</code> so <em>no one re‚Äëlogs or re‚Äësyncs</em>.</p>
</li>
<li>
<p dir="auto"><strong>Reliable offline push</strong> ‚Äì any QoS‚Äë1/2 frames queued meanwhile are flushed the instant the user is back online, <strong>preserving order</strong>.</p>
</li>
<li>
<p dir="auto"><strong>Duplicate shielding</strong> ‚Äì ExactlyOnce&#39;s commit ledger is also retained, so retries from the old socket are recognised and ignored.</p>
</li>
</ul>
<p dir="auto">Set it small (e.g. 5 s) for kiosk/lan apps to free RAM aggressively; crank it up (minutes) for flaky mobile networks or game lobbies that reconnect on map load.</p>
<p dir="auto">With <strong>ExactlyOnce</strong> BinaryRPC persists outbound frames to the <strong>session outbox</strong>. If the socket drops but the <strong>session</strong> survives (<code>sessionTtlMs</code>), any queued frames are auto‚Äëreplayed on reconnect ‚Äì <em>offline messaging for free.</em></p>

<p dir="auto">Configure granular behaviour via <code>WebSocketTransport::setReliable(options)</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="
struct  ReliableOptions {

	QoSLevel level = QoSLevel::None; // delivery tier

	std::uint32_t baseRetryMs =  100; // initial retry delay

	std::uint32_t maxBackoffMs =  2&#39;000; // cap for delay

	std::uint16_t maxRetry =  5; // fail after N attempts (0 = infinite)

	std::uint32_t sessionTtlMs =  30&#39;000; // resilience window for reconnect &amp; offline push

	std::shared_ptr&lt;IBackoffStrategy&gt; backoffStrategy; // pluggable curve

};
"><pre><span>struct</span>  <span>ReliableOptions</span> {

	QoSLevel level = QoSLevel::None; <span><span>//</span> delivery tier</span>

	std::<span>uint32_t</span> baseRetryMs =  <span>100</span>; <span><span>//</span> initial retry delay</span>

	std::<span>uint32_t</span> maxBackoffMs =  <span>2&#39;000</span>; <span><span>//</span> cap for delay</span>

	std::<span>uint16_t</span> maxRetry =  <span>5</span>; <span><span>//</span> fail after N attempts (0 = infinite)</span>

	std::<span>uint32_t</span> sessionTtlMs =  <span>30&#39;000</span>; <span><span>//</span> resilience window for reconnect &amp; offline push</span>

	std::shared_ptr&lt;IBackoffStrategy&gt; backoffStrategy; <span><span>//</span> pluggable curve</span>

};
</pre></div>

<p dir="auto">Supply your own <code>IBackoffStrategy</code> implementation:</p>
<div dir="auto" data-snippet-clipboard-copy-content="
class  FibonacciBackoff : public  IBackoffStrategy {

	std::chrono::milliseconds  nextDelay(std::size_t  n) const  override {

	if(n &lt;  2) return  {100};

	std::size_t a=0,b=1;

	for(std::size_t i=0;i&lt;n;++i){ 
		std::size_t t=a+b; a=b; b=t;
	}

	return std::chrono::milliseconds(std::min(b*100UL,  5&#39;000UL));

}

};

  

ws-&gt;setReliable({

.level = QoSLevel::AtLeastOnce,

.baseRetryMs =  100,

.backoffStrategy = std::make_shared&lt;FibonacciBackoff&gt;()

});
"><pre><span>class</span>  <span>FibonacciBackoff</span> : <span>public</span>  <span>IBackoffStrategy</span> {

	std::chrono::milliseconds  <span>nextDelay</span>(std::<span>size_t</span>  n) <span>const</span>  <span>override</span> {

	<span>if</span>(n &lt;  <span>2</span>) <span>return</span>  {<span>100</span>};

	std::<span>size_t</span> a=<span>0</span>,b=<span>1</span>;

	<span>for</span>(std::<span>size_t</span> i=<span>0</span>;i&lt;n;++i){ 
		std::<span>size_t</span> t=a+b; a=b; b=t;
	}

	<span>return</span> <span>std::chrono::milliseconds</span>(<span>std::min</span>(b*<span>100UL</span>,  <span>5&#39;000UL</span>));

}

};

  

ws-&gt;<span>setReliable</span>({

.<span>level</span> = QoSLevel::AtLeastOnce,

.<span>baseRetryMs</span> =  <span>100</span>,

.<span>backoffStrategy</span> = std::make_shared&lt;FibonacciBackoff&gt;()

});
</pre></div>
<p dir="auto">Your strategy receives the <strong>attempt index</strong> (0‚Äëbased) and returns the delay before the next retry. It may be stateless or use RNG for jitter.</p>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">üóÑÔ∏è Session management via FrameworkAPI</h2><a id="user-content-Ô∏è-session-management-via-frameworkapi" aria-label="Permalink: üóÑÔ∏è Session management via FrameworkAPI" href="#Ô∏è-session-management-via-frameworkapi"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>FrameworkAPI</code> glues the transport and the lock‚Äëfree <code>SessionManager</code>.</p>
<p dir="auto">Use it to <strong>store</strong>, <strong>search</strong> and <strong>push</strong> data to any connected (or recently disconnected!) client.</p>
<div dir="auto" data-snippet-clipboard-copy-content="
using  namespace  binaryrpc;

// helper bound to current runtime

auto&amp; app = App::getInstance();

FrameworkAPI fw{  &amp;app.getSessionManager(),  app.getTransport() };
"><pre><span>using</span>  <span>namespace</span>  <span>binaryrpc</span><span>;</span>

<span><span>//</span> helper bound to current runtime</span>

<span>auto</span>&amp; app = App::getInstance();

FrameworkAPI fw{  &amp;app.<span>getSessionManager</span>(),  app.<span>getTransport</span>() };
</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Lifecycle notifications (planned)</h3><a id="user-content-lifecycle-notifications-planned" aria-label="Permalink: Lifecycle notifications (planned)" href="#lifecycle-notifications-planned"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>SessionManager</code> currently <strong>does not expose built‚Äëin onCreate/onDestroy callbacks</strong>. If you need presence or audit logging today, implement it via:</p>
<ol dir="auto">
<li>
<p dir="auto"><strong>Middleware</strong> ‚Äì add a global middleware; on first RPC from a session record &#34;online&#34;, and call <code>fw.disconnect()</code> after timeout to record &#34;offline&#34;.</p>
</li>
<li>
<p dir="auto"><strong>Custom plugin</strong> ‚Äì poll <code>app.getSessionManager().allSessions()</code> every few seconds and diff lists, then emit events.</p>
</li>
</ol>
<p dir="auto">Native hooks are on the roadmap; once merged you&#39;ll be able to register lambdas before <code>app.run()</code>. Follow issue #42 in the repo for progress.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto"><code>indexed</code> flag ‚Äì when to flip it</h3><a id="user-content-indexed-flag--when-to-flip-it" aria-label="Permalink: indexed flag ‚Äì when to flip it" href="#indexed-flag--when-to-flip-it"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th><code>indexed</code></th>
<th>Behaviour</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>false</code>  <em>(default)</em></td>
<td>Value kept only in session blob.</td>
<td>Look‚Äëup ‚áí <strong>O(N)</strong> scan.</td>
</tr>
<tr>
<td><code>true</code></td>
<td>Value also put into a global hash‚Äëmap.</td>
<td><code>fw.findBy()</code> ‚áí <strong>O(1)</strong>.</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Use <code>indexed=true</code> for identifiers you filter on (e.g. <code>userId</code>, <code>roomId</code>) and keep transient or high‚Äëcardinality data unindexed.</p>
<p dir="auto"><code>Session</code> objects live until you explicitly <code>disconnect()</code> them or the transport&#39;s <code>sessionTtlMs</code> expires. All QoS delivery guarantees survive reconnects within that TTL.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Example: Persist state and target users</h3><a id="user-content-example-persist-state-and-target-users" aria-label="Permalink: Example: Persist state and target users" href="#example-persist-state-and-target-users"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="
// 1Ô∏è‚É£ Persist state (optionally indexed)

fw.setField(ctx.sessionId(),  &#34;userId&#34;, userId, /*indexed=*/true);

fw.setField(ctx.sessionId(),  &#34;username&#34;, username); // not indexed

fw.setField(ctx.sessionId(),  &#34;xp&#34;,  0);

  

// 2Ô∏è‚É£ Target users later

for (auto&amp; s : fw.findBy(&#34;userId&#34;, std::to_string(userId))) {

fw.sendToSession(s,  app.getProtocol()-&gt;serialize(&#34;levelUp&#34;, {{&#34;lvl&#34;, newLvl}}));

}
"><pre><span><span>//</span> 1Ô∏è‚É£ Persist state (optionally indexed)</span>

fw.setField(ctx.sessionId(),  <span><span>&#34;</span>userId<span>&#34;</span></span>, userId, <span><span>/*</span>indexed=<span>*/</span></span><span>true</span>);

fw.setField(ctx.sessionId(),  <span><span>&#34;</span>username<span>&#34;</span></span>, username); <span><span>//</span> not indexed</span>

fw.setField(ctx.sessionId(),  <span><span>&#34;</span>xp<span>&#34;</span></span>,  <span>0</span>);

  

<span><span>//</span> 2Ô∏è‚É£ Target users later</span>

<span>for</span> (<span>auto</span>&amp; s : fw.findBy(<span><span>&#34;</span>userId<span>&#34;</span></span>, std::to_string(userId))) {

fw.<span>sendToSession</span>(s,  app.<span>getProtocol</span>()-&gt;<span>serialize</span>(<span><span>&#34;</span>levelUp<span>&#34;</span></span>, {{<span><span>&#34;</span>lvl<span>&#34;</span></span>, newLvl}}));

}
</pre></div>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">üó∫Ô∏è Architecture Overview</h2><a id="user-content-Ô∏è-architecture-overview" aria-label="Permalink: üó∫Ô∏è Architecture Overview" href="#Ô∏è-architecture-overview"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div data-snippet-clipboard-copy-content="+-----------------------------+
| raw bytes --&gt; IProtocol  	  |
|               (parse)       |
+--------------+--------------+
             |
             v
+--------------+--------------+
|        ParsedRequest        |
+--------------+--------------+
             |
             v
+--------------+--------------+
|     MiddlewareChain (*)     |
+--------------+--------------+
             |
             v
+--------------+--------------+
| RpcContext &amp; SessionManager |
+--------------+--------------+
             |
             v
+--------------+--------------+
|           RPCManager        |
+--------------+--------------+
             |
             v
+--------------+--------------+
|    ITransport (send)        |
|         &lt;--&gt; client         |
+-----------------------------+"><pre><code>+-----------------------------+
| raw bytes --&gt; IProtocol  	  |
|               (parse)       |
+--------------+--------------+
             |
             v
+--------------+--------------+
|        ParsedRequest        |
+--------------+--------------+
             |
             v
+--------------+--------------+
|     MiddlewareChain (*)     |
+--------------+--------------+
             |
             v
+--------------+--------------+
| RpcContext &amp; SessionManager |
+--------------+--------------+
             |
             v
+--------------+--------------+
|           RPCManager        |
+--------------+--------------+
             |
             v
+--------------+--------------+
|    ITransport (send)        |
|         &lt;--&gt; client         |
+-----------------------------+
</code></pre></div>
<p dir="auto"><em>All rectangles are replaceable: implement the interface and plug your own.</em></p>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">üõ†Ô∏è Customisation Cheat‚ÄëSheet</h2><a id="user-content-Ô∏è-customisation-cheatsheet" aria-label="Permalink: üõ†Ô∏è Customisation Cheat‚ÄëSheet" href="#Ô∏è-customisation-cheatsheet"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>What you want to change</th>
<th>How</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>QoS level / retries</strong></td>
<td><code>WebSocketTransport::setReliable(ReliableOptions)</code>. Fields: <code>level</code>, <code>baseRetryMs</code>, <code>maxRetry</code>, <code>maxBackoffMs</code>, <code>sessionTtlMs</code>, <code>backoffStrategy</code>.</td>
</tr>
<tr>
<td><strong>Back‚Äëoff curve</strong></td>
<td>Implement <code>IBackoffStrategy::nextDelay()</code> and pass via <code>ReliableOptions.backoffStrategy</code>.</td>
</tr>
<tr>
<td><strong>Serialisation</strong></td>
<td>Implement <code>IProtocol</code> ‚Äì just parse/serialise and throw <code>ErrorObj</code> on bad input.</td>
</tr>
<tr>
<td><strong>Transport</strong></td>
<td>Implement <code>ITransport</code> (start/stop/send callbacks). Ready‚Äëmade: <code>WebSocketTransport</code>.</td>
</tr>
<tr>
<td><strong>Middleware</strong></td>
<td><code>using Middleware = std::function&lt;void(RpcContext&amp;, Next)&gt;;</code> Attach via <code>App::use</code> / <code>useFor</code>.</td>
</tr>
<tr>
<td><strong>Plugins (lifecycle)</strong></td>
<td>Implement <code>IPlugin::initialize()</code>; register with <code>App::usePlugin</code>.</td>
</tr>
<tr>
<td><strong>Session fields</strong></td>
<td><code>fw.setField(sid, key, value, indexed)</code> / <code>fw.getField&lt;T&gt;(sid, key)</code> ‚Äì choose <code>indexed=true</code> for fast look‚Äëups</td>
</tr>
<tr>
<td><strong>Duplicate RPC guard</strong></td>
<td>Already built‚Äëin: <code>qos::DuplicateFilter</code> ‚Äì just call <code>accept(payload, ttl)</code>; no extra wiring needed.</td>
</tr>
<tr>
<td><strong>Logging sink</strong></td>
<td><code>Logger::inst().setSink([](LogLevel l, const std::string&amp; m){ ‚Ä¶ });</code> + <code>setLevel(LogLevel::Debug)</code>.</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div dir="auto"><h2 tabindex="-1" dir="auto">üîÑ Middleware Management</h2><a id="user-content--middleware-management" aria-label="Permalink: üîÑ Middleware Management" href="#-middleware-management"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">BinaryRPC provides three ways to attach middleware to your application:</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">1. Global Middleware (<code>use</code>)</h3><a id="user-content-1-global-middleware-use" aria-label="Permalink: 1. Global Middleware (use)" href="#1-global-middleware-use"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Attaches middleware to all RPC calls:</p>
<div dir="auto" data-snippet-clipboard-copy-content="app.use([](Session&amp; session, const std::string&amp; method, std::vector&lt;uint8_t&gt;&amp; payload, NextFunc next) {
    // Runs before every RPC
    LOG_DEBUG(&#34;Incoming request: &#34; + method);
    next();
    // Runs after every RPC
});"><pre>app.use([](Session&amp; session, <span>const</span> std::string&amp; method, std::vector&lt;<span>uint8_t</span>&gt;&amp; payload, NextFunc next) {
    <span><span>//</span> Runs before every RPC</span>
    <span>LOG_DEBUG</span>(<span><span>&#34;</span>Incoming request: <span>&#34;</span></span> + method);
    <span>next</span>();
    <span><span>//</span> Runs after every RPC</span>
});</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">2. Single Method Middleware (<code>useFor</code>)</h3><a id="user-content-2-single-method-middleware-usefor" aria-label="Permalink: 2. Single Method Middleware (useFor)" href="#2-single-method-middleware-usefor"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Attaches middleware to a specific RPC method:</p>
<div dir="auto" data-snippet-clipboard-copy-content="app.useFor(&#34;login&#34;, [](Session&amp; session, const std::string&amp; method, std::vector&lt;uint8_t&gt;&amp; payload, NextFunc next) {
    // Runs only before &#34;login&#34; RPC
    auto req = parseMsgPackPayload(payload);
    if (!validateCredentials(req)) {
        throw ErrorObj(&#34;Invalid credentials&#34;);
    }
    next();
    // Runs after &#34;login&#34; RPC
});"><pre>app.useFor(<span><span>&#34;</span>login<span>&#34;</span></span>, [](Session&amp; session, <span>const</span> std::string&amp; method, std::vector&lt;<span>uint8_t</span>&gt;&amp; payload, NextFunc next) {
    <span><span>//</span> Runs only before &#34;login&#34; RPC</span>
    <span>auto</span> req = <span>parseMsgPackPayload</span>(payload);
    <span>if</span> (!<span>validateCredentials</span>(req)) {
        <span>throw</span> <span>ErrorObj</span>(<span><span>&#34;</span>Invalid credentials<span>&#34;</span></span>);
    }
    <span>next</span>();
    <span><span>//</span> Runs after &#34;login&#34; RPC</span>
});</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">3. Multi-Method Middleware (<code>useForMulti</code>)</h3><a id="user-content-3-multi-method-middleware-useformulti" aria-label="Permalink: 3. Multi-Method Middleware (useForMulti)" href="#3-multi-method-middleware-useformulti"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Attaches middleware to multiple RPC methods:</p>
<div dir="auto" data-snippet-clipboard-copy-content="app.useForMulti({&#34;send_message&#34;, &#34;join_room&#34;}, [](Session&amp; session, const std::string&amp; method, std::vector&lt;uint8_t&gt;&amp; payload, NextFunc next) {
    // Runs before &#34;send_message&#34; and &#34;join_room&#34; RPCs
    if (!session.isAuthenticated()) {
        throw ErrorObj(&#34;Authentication required&#34;);
    }
    next();
    // Runs after these RPCs
});"><pre>app.useForMulti({<span><span>&#34;</span>send_message<span>&#34;</span></span>, <span><span>&#34;</span>join_room<span>&#34;</span></span>}, [](Session&amp; session, <span>const</span> std::string&amp; method, std::vector&lt;<span>uint8_t</span>&gt;&amp; payload, NextFunc next) {
    <span><span>//</span> Runs before &#34;send_message&#34; and &#34;join_room&#34; RPCs</span>
    <span>if</span> (!session.<span>isAuthenticated</span>()) {
        <span>throw</span> <span>ErrorObj</span>(<span><span>&#34;</span>Authentication required<span>&#34;</span></span>);
    }
    <span>next</span>();
    <span><span>//</span> Runs after these RPCs</span>
});</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Middleware Chain Execution</h3><a id="user-content-middleware-chain-execution" aria-label="Permalink: Middleware Chain Execution" href="#middleware-chain-execution"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ol dir="auto">
<li>Middleware executes in the order they are registered</li>
<li>Each middleware must call <code>next()</code> to continue the chain</li>
<li>If a middleware throws an exception, the chain stops and the error is sent to the client</li>
<li>Middleware can modify the <code>Session</code> and <code>payload</code> before and after the RPC execution</li>
</ol>

<ul dir="auto">
<li>Authentication/Authorization</li>
<li>Rate limiting</li>
<li>Request logging</li>
<li>Input validation</li>
<li>Session management</li>
<li>Error handling</li>
</ul>
<p dir="auto">Example of a complete middleware setup:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Global logging
app.use([](Session&amp; session, const std::string&amp; method, std::vector&lt;uint8_t&gt;&amp; payload, NextFunc next) {
    LOG_INFO(&#34;Request: &#34; + method);
    next();
    LOG_INFO(&#34;Response sent&#34;);
});

// Auth check for sensitive methods
app.useForMulti({&#34;send_message&#34;, &#34;join_room&#34;}, [](Session&amp; session, const std::string&amp; method, std::vector&lt;uint8_t&gt;&amp; payload, NextFunc next) {
    if (!session.isAuthenticated()) {
        throw ErrorObj(&#34;Please login first&#34;);
    }
    next();
});

// Rate limiting for specific method
app.useFor(&#34;login&#34;, [](Session&amp; session, const std::string&amp; method, std::vector&lt;uint8_t&gt;&amp; payload, NextFunc next) {
    if (isRateLimited(session.getClientId())) {
        throw ErrorObj(&#34;Too many attempts&#34;);
    }
    next();
});"><pre><span><span>//</span> Global logging</span>
app.use([](Session&amp; session, <span>const</span> std::string&amp; method, std::vector&lt;<span>uint8_t</span>&gt;&amp; payload, NextFunc next) {
    <span>LOG_INFO</span>(<span><span>&#34;</span>Request: <span>&#34;</span></span> + method);
    <span>next</span>();
    <span>LOG_INFO</span>(<span><span>&#34;</span>Response sent<span>&#34;</span></span>);
});

<span><span>//</span> Auth check for sensitive methods</span>
app.useForMulti({<span><span>&#34;</span>send_message<span>&#34;</span></span>, <span><span>&#34;</span>join_room<span>&#34;</span></span>}, [](Session&amp; session, <span>const</span> std::string&amp; method, std::vector&lt;<span>uint8_t</span>&gt;&amp; payload, NextFunc next) {
    <span>if</span> (!session.<span>isAuthenticated</span>()) {
        <span>throw</span> <span>ErrorObj</span>(<span><span>&#34;</span>Please login first<span>&#34;</span></span>);
    }
    <span>next</span>();
});

<span><span>//</span> Rate limiting for specific method</span>
app.useFor(<span><span>&#34;</span>login<span>&#34;</span></span>, [](Session&amp; session, <span>const</span> std::string&amp; method, std::vector&lt;<span>uint8_t</span>&gt;&amp; payload, NextFunc next) {
    <span>if</span> (<span>isRateLimited</span>(session.<span>getClientId</span>())) {
        <span>throw</span> <span>ErrorObj</span>(<span><span>&#34;</span>Too many attempts<span>&#34;</span></span>);
    }
    <span>next</span>();
});</pre></div>

<p dir="auto">In addition to writing your own logic, BinaryRPC provides pre-built modules for common scenarios.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Rate Limiter (<code>rate_limiter.hpp</code>)</h4><a id="user-content-rate-limiter-rate_limiterhpp" aria-label="Permalink: Rate Limiter (rate_limiter.hpp)" href="#rate-limiter-rate_limiterhpp"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Instead of implementing the logic manually as shown in the generic example, you can use the dedicated <code>RateLimiter</code> module which uses the Token Bucket algorithm.</p>
<p dir="auto"><strong>Example:</strong> Limit login attempts to 1 per 5 seconds.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;binaryrpc/middlewares/rate_limiter.hpp&gt;
#include &lt;binaryrpc/core/app.hpp&gt;

// Configure the RateLimiter: 1 request every 5 seconds (0.2 req/sec).
// The bucket capacity is 1, meaning no bursts are allowed.
auto loginLimiter = binaryrpc::middlewares::RateLimiter(0.2, 1);

// Attach the middleware to the &#34;login&#34; RPC
app.useFor(&#34;login&#34;, loginLimiter);"><pre>#<span>include</span> <span><span>&lt;</span>binaryrpc/middlewares/rate_limiter.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>binaryrpc/core/app.hpp<span>&gt;</span></span>

<span><span>//</span> Configure the RateLimiter: 1 request every 5 seconds (0.2 req/sec).</span>
<span><span>//</span> The bucket capacity is 1, meaning no bursts are allowed.</span>
<span>auto</span> loginLimiter = binaryrpc::middlewares::RateLimiter(<span>0.2</span>, <span>1</span>);

<span><span>//</span> Attach the middleware to the &#34;login&#34; RPC</span>
app.useFor(<span><span>&#34;</span>login<span>&#34;</span></span>, loginLimiter);</pre></div>
<p dir="auto">If a user exceeds the limit, the middleware throws an <code>ErrorObj</code>, and the client receives a &#34;Too many requests&#34; message.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">JWT Authentication (<code>jwt_auth.hpp</code>)</h4><a id="user-content-jwt-authentication-jwt_authhpp" aria-label="Permalink: JWT Authentication (jwt_auth.hpp)" href="#jwt-authentication-jwt_authhpp"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This middleware validates incoming RPCs using a JSON Web Token (JWT).</p>
<p dir="auto"><strong>Example:</strong> Secure the &#34;get_profile&#34; RPC by expecting a token in the payload.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;binaryrpc/middlewares/jwt_auth.hpp&gt;
#include &lt;binaryrpc/core/app.hpp&gt;
#include &lt;nlohmann/json.hpp&gt;

const std::string jwt_secret = &#34;your-very-secret-key&#34;;

// Configure the middleware to extract the token from a &#34;token&#34; field in the payload.
auto authMiddleware = binaryrpc::middlewares::JwtAuth(
    jwt_secret,
    [](const binaryrpc::Payload&amp; payload) -&gt; std::string {
        try {
            auto data = nlohmann::json::from_msgpack(payload);
            return data.value(&#34;token&#34;, &#34;&#34;);
        } catch (...) { return &#34;&#34;; }
    }
);

// Protect methods that require authentication
app.useForMulti({&#34;get_profile&#34;, &#34;update_settings&#34;}, authMiddleware);"><pre>#<span>include</span> <span><span>&lt;</span>binaryrpc/middlewares/jwt_auth.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>binaryrpc/core/app.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>nlohmann/json.hpp<span>&gt;</span></span>

<span>const</span> std::string jwt_secret = <span><span>&#34;</span>your-very-secret-key<span>&#34;</span></span>;

<span><span>//</span> Configure the middleware to extract the token from a &#34;token&#34; field in the payload.</span>
<span>auto</span> authMiddleware = binaryrpc::middlewares::JwtAuth(
    jwt_secret,
    [](<span>const</span> binaryrpc::Payload&amp; payload) -&gt; std::string {
        <span>try</span> {
            <span>auto</span> data = <span>nlohmann::json::from_msgpack</span>(payload);
            <span>return</span> data.<span>value</span>(<span><span>&#34;</span>token<span>&#34;</span></span>, <span><span>&#34;</span><span>&#34;</span></span>);
        } <span>catch</span> (...) { <span>return</span> <span><span>&#34;</span><span>&#34;</span></span>; }
    }
);

<span><span>//</span> Protect methods that require authentication</span>
app.useForMulti({<span><span>&#34;</span>get_profile<span>&#34;</span></span>, <span><span>&#34;</span>update_settings<span>&#34;</span></span>}, authMiddleware);</pre></div>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">üìû Registering RPCs &amp; Replying</h2><a id="user-content--registering-rpcs--replying" aria-label="Permalink: üìû Registering RPCs &amp; Replying" href="#-registering-rpcs--replying"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The core of your application is the set of RPC handlers that process client requests. You register them on the <code>App</code> instance.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto"><code>registerRPC(method, handler)</code></h3><a id="user-content-registerrpcmethod-handler" aria-label="Permalink: registerRPC(method, handler)" href="#registerrpcmethod-handler"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This method binds a handler to a specific method name. The handler is a function that receives the raw payload and an <code>RpcContext</code> object. The handler is responsible for parsing the incoming payload and serializing the outgoing payload before replying.</p>
<p dir="auto">The <code>IProtocol</code> interface (<code>MsgPackProtocol</code>, <code>SimpleTextProtocol</code>, etc.) is responsible for framing the data, not for serializing your application-specific data structures. It wraps your payload (<code>std::vector&lt;uint8_t&gt;</code>) with a method name.</p>
<p dir="auto">Here is a corrected example using <code>nlohmann/json</code> to handle the application-level data serialization.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// main.cpp
#include &#34;binaryrpc/core/app.hpp&#34;
#include &#34;binaryrpc/core/protocol/msgpack_protocol.hpp&#34;
#include &lt;nlohmann/json.hpp&gt; // You&#39;ll need a JSON library
#include &lt;iostream&gt;

int main() {
    auto&amp; app = binaryrpc::App::getInstance();
    
    // Use the MsgPack protocol for framing
    auto protocol = std::make_shared&lt;binaryrpc::MsgPackProtocol&gt;();
    app.setProtocol(protocol);

    // Create a FrameworkAPI instance to interact with sessions
    FrameworkAPI api(&amp;app.getSessionManager(), app.getTransport());

    // Register a &#34;login&#34; handler
    app.registerRPC(&#34;login&#34;, [&amp;](const std::vector&lt;uint8_t&gt;&amp; payload, binaryrpc::RpcContext&amp; ctx) {
        nlohmann::json response_data;
        try {
            // 1. Parse the incoming payload
            auto request = nlohmann::json::parse(payload);
            std::string username = request.value(&#34;username&#34;, &#34;&#34;);
            std::string password = request.value(&#34;password&#34;, &#34;&#34;);

            // 2. Authenticate the user
            if (username == &#34;admin&#34; &amp;&amp; password == &#34;password&#34;) {
                std::cout &lt;&lt; &#34;Login successful for: &#34; &lt;&lt; username &lt;&lt; std::endl;
                
                // 3. Store state using FrameworkAPI
                api.setField(ctx.session().id(), &#34;isAuthenticated&#34;, true, false);
                api.setField(ctx.session().id(), &#34;username&#34;, username, true); // indexed

                // 4. Prepare the response payload
                response_data[&#34;status&#34;] = &#34;success&#34;;
                response_data[&#34;ts&#34;] = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(
                        std::chrono::system_clock::now().time_since_epoch()).count();

            } else {
                response_data[&#34;status&#34;] = &#34;error&#34;;
                response_data[&#34;reason&#34;] = &#34;Invalid credentials&#34;;
            }

        } catch (const std::exception&amp; e) {
            std::cerr &lt;&lt; &#34;Error in login handler: &#34; &lt;&lt; e.what() &lt;&lt; std::endl;
            response_data[&#34;status&#34;] = &#34;error&#34;;
            response_data[&#34;reason&#34;] = &#34;Internal server error&#34;;
        }

        // 5. Serialize the response data and reply
        std::string response_str = response_data.dump();
        std::vector&lt;uint8_t&gt; response_bytes(response_str.begin(), response_str.end());
        
        // Use the protocol to frame the response
        ctx.reply(protocol-&gt;serialize(&#34;login_response&#34;, response_bytes));
    });

    // Add an authentication middleware for &#34;get_profile&#34;
    app.useFor(&#34;get_profile&#34;, [&amp;](Session&amp; session, const std::string&amp; method, std::vector&lt;uint8_t&gt;&amp; payload, NextFunc next) {
        auto isAuthenticated = api.getField&lt;bool&gt;(session.id(), &#34;isAuthenticated&#34;);

        if (!isAuthenticated.value_or(false)) {
            // User is not authenticated. Send an error response directly and stop the chain.
            nlohmann::json err_data = {
                {&#34;status&#34;, &#34;error&#34;},
                {&#34;reason&#34;, &#34;Authentication required&#34;}
            };
            std::string err_str = err_data.dump();
            std::vector&lt;uint8_t&gt; err_bytes(err_str.begin(), err_str.end());
            
            // Frame the error response
            auto framed_error = protocol-&gt;serialize(&#34;auth_error&#34;, err_bytes);
            
            // Send it directly to the session and DO NOT call next()
            // Note: This creates a shared_ptr copy of the session to pass to the API.
            api.sendToSession(std::make_shared&lt;Session&gt;(session), framed_error);
            return; 
        }
        
        // User is authenticated, proceed to the RPC handler
        next();
    });

    // Register another handler - now protected by middleware
    app.registerRPC(&#34;get_profile&#34;, [&amp;](const auto&amp; payload, auto&amp; ctx) {
        // Auth check is now in the middleware, we can proceed directly.
        auto username = api.getField&lt;std::string&gt;(ctx.session().id(), &#34;username&#34;);
        
        nlohmann::json profile_data;
        profile_data[&#34;username&#34;] = username.value_or(&#34;N/A&#34;);
        // ... other profile data

        std::string profile_str = profile_data.dump();
        std::vector&lt;uint8_t&gt; profile_bytes(profile_str.begin(), profile_str.end());
        
        ctx.reply(protocol-&gt;serialize(&#34;profile_data&#34;, profile_bytes));
    });

    app.run(9010);
    return 0;
}"><pre><span><span>//</span> main.cpp</span>
#<span>include</span> <span><span>&#34;</span>binaryrpc/core/app.hpp<span>&#34;</span></span>
#<span>include</span> <span><span>&#34;</span>binaryrpc/core/protocol/msgpack_protocol.hpp<span>&#34;</span></span>
#<span>include</span> <span><span>&lt;</span>nlohmann/json.hpp<span>&gt;</span></span> <span><span>//</span> You&#39;ll need a JSON library</span>
#<span>include</span> <span><span>&lt;</span>iostream<span>&gt;</span></span>

<span>int</span> <span>main</span>() {
    <span>auto</span>&amp; app = <span>binaryrpc::App::getInstance</span>();
    
    <span><span>//</span> Use the MsgPack protocol for framing</span>
    <span>auto</span> protocol = std::make_shared&lt;binaryrpc::MsgPackProtocol&gt;();
    app.<span>setProtocol</span>(protocol);

    <span><span>//</span> Create a FrameworkAPI instance to interact with sessions</span>
    FrameworkAPI <span>api</span>(&amp;app.<span>getSessionManager</span>(), app.<span>getTransport</span>());

    <span><span>//</span> Register a &#34;login&#34; handler</span>
    app.<span>registerRPC</span>(<span><span>&#34;</span>login<span>&#34;</span></span>, [&amp;](<span>const</span> std::vector&lt;<span>uint8_t</span>&gt;&amp; payload, binaryrpc::RpcContext&amp; ctx) {
        nlohmann::json response_data;
        <span>try</span> {
            <span><span>//</span> 1. Parse the incoming payload</span>
            <span>auto</span> request = <span>nlohmann::json::parse</span>(payload);
            std::string username = request.<span>value</span>(<span><span>&#34;</span>username<span>&#34;</span></span>, <span><span>&#34;</span><span>&#34;</span></span>);
            std::string password = request.<span>value</span>(<span><span>&#34;</span>password<span>&#34;</span></span>, <span><span>&#34;</span><span>&#34;</span></span>);

            <span><span>//</span> 2. Authenticate the user</span>
            <span>if</span> (username == <span><span>&#34;</span>admin<span>&#34;</span></span> &amp;&amp; password == <span><span>&#34;</span>password<span>&#34;</span></span>) {
                std::cout &lt;&lt; <span><span>&#34;</span>Login successful for: <span>&#34;</span></span> &lt;&lt; username &lt;&lt; std::endl;
                
                <span><span>//</span> 3. Store state using FrameworkAPI</span>
                api.<span>setField</span>(ctx.<span>session</span>().<span>id</span>(), <span><span>&#34;</span>isAuthenticated<span>&#34;</span></span>, <span>true</span>, <span>false</span>);
                api.<span>setField</span>(ctx.<span>session</span>().<span>id</span>(), <span><span>&#34;</span>username<span>&#34;</span></span>, username, <span>true</span>); <span><span>//</span> indexed</span>

                <span><span>//</span> 4. Prepare the response payload</span>
                response_data[<span><span>&#34;</span>status<span>&#34;</span></span>] = <span><span>&#34;</span>success<span>&#34;</span></span>;
                response_data[<span><span>&#34;</span>ts<span>&#34;</span></span>] = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(
                        <span>std::chrono::system_clock::now</span>().<span>time_since_epoch</span>()).<span>count</span>();

            } <span>else</span> {
                response_data[<span><span>&#34;</span>status<span>&#34;</span></span>] = <span><span>&#34;</span>error<span>&#34;</span></span>;
                response_data[<span><span>&#34;</span>reason<span>&#34;</span></span>] = <span><span>&#34;</span>Invalid credentials<span>&#34;</span></span>;
            }

        } <span>catch</span> (<span>const</span> std::exception&amp; e) {
            std::cerr &lt;&lt; <span><span>&#34;</span>Error in login handler: <span>&#34;</span></span> &lt;&lt; e.<span>what</span>() &lt;&lt; std::endl;
            response_data[<span><span>&#34;</span>status<span>&#34;</span></span>] = <span><span>&#34;</span>error<span>&#34;</span></span>;
            response_data[<span><span>&#34;</span>reason<span>&#34;</span></span>] = <span><span>&#34;</span>Internal server error<span>&#34;</span></span>;
        }

        <span><span>//</span> 5. Serialize the response data and reply</span>
        std::string response_str = response_data.<span>dump</span>();
        std::vector&lt;<span>uint8_t</span>&gt; <span>response_bytes</span>(response_str.<span>begin</span>(), response_str.<span>end</span>());
        
        <span><span>//</span> Use the protocol to frame the response</span>
        ctx.<span>reply</span>(protocol-&gt;<span>serialize</span>(<span><span>&#34;</span>login_response<span>&#34;</span></span>, response_bytes));
    });

    <span><span>//</span> Add an authentication middleware for &#34;get_profile&#34;</span>
    app.<span>useFor</span>(<span><span>&#34;</span>get_profile<span>&#34;</span></span>, [&amp;](Session&amp; session, <span>const</span> std::string&amp; method, std::vector&lt;<span>uint8_t</span>&gt;&amp; payload, NextFunc next) {
        <span>auto</span> isAuthenticated = api.<span>getField</span>&lt;<span>bool</span>&gt;(session.<span>id</span>(), <span><span>&#34;</span>isAuthenticated<span>&#34;</span></span>);

        <span>if</span> (!isAuthenticated.<span>value_or</span>(<span>false</span>)) {
            <span><span>//</span> User is not authenticated. Send an error response directly and stop the chain.</span>
            nlohmann::json err_data = {
                {<span><span>&#34;</span>status<span>&#34;</span></span>, <span><span>&#34;</span>error<span>&#34;</span></span>},
                {<span><span>&#34;</span>reason<span>&#34;</span></span>, <span><span>&#34;</span>Authentication required<span>&#34;</span></span>}
            };
            std::string err_str = err_data.<span>dump</span>();
            std::vector&lt;<span>uint8_t</span>&gt; <span>err_bytes</span>(err_str.<span>begin</span>(), err_str.<span>end</span>());
            
            <span><span>//</span> Frame the error response</span>
            <span>auto</span> framed_error = protocol-&gt;<span>serialize</span>(<span><span>&#34;</span>auth_error<span>&#34;</span></span>, err_bytes);
            
            <span><span>//</span> Send it directly to the session and DO NOT call next()</span>
            <span><span>//</span> Note: This creates a shared_ptr copy of the session to pass to the API.</span>
            api.<span>sendToSession</span>(std::make_shared&lt;Session&gt;(session), framed_error);
            <span>return</span>; 
        }
        
        <span><span>//</span> User is authenticated, proceed to the RPC handler</span>
        <span>next</span>();
    });

    <span><span>//</span> Register another handler - now protected by middleware</span>
    app.<span>registerRPC</span>(<span><span>&#34;</span>get_profile<span>&#34;</span></span>, [&amp;](<span>const</span> <span>auto</span>&amp; payload, <span>auto</span>&amp; ctx) {
        <span><span>//</span> Auth check is now in the middleware, we can proceed directly.</span>
        <span>auto</span> username = api.<span>getField</span>&lt;std::string&gt;(ctx.<span>session</span>().<span>id</span>(), <span><span>&#34;</span>username<span>&#34;</span></span>);
        
        nlohmann::json profile_data;
        profile_data[<span><span>&#34;</span>username<span>&#34;</span></span>] = username.<span>value_or</span>(<span><span>&#34;</span>N/A<span>&#34;</span></span>);
        <span><span>//</span> ... other profile data</span>

        std::string profile_str = profile_data.<span>dump</span>();
        std::vector&lt;<span>uint8_t</span>&gt; <span>profile_bytes</span>(profile_str.<span>begin</span>(), profile_str.<span>end</span>());
        
        ctx.<span>reply</span>(protocol-&gt;<span>serialize</span>(<span><span>&#34;</span>profile_data<span>&#34;</span></span>, profile_bytes));
    });

    app.<span>run</span>(<span>9010</span>);
    <span>return</span> <span>0</span>;
}</pre></div>

<p dir="auto">The <code>RpcContext</code> is your gateway to interacting with the client and their session:</p>
<ul dir="auto">
<li><code>ctx.reply(payload)</code>: Sends a message back to the originating client.</li>
<li><code>ctx.broadcast(payload)</code>: Sends a message to all connected clients.</li>
<li><code>ctx.session()</code>: Returns a reference to the <code>Session</code> object for the current client. You can use this to store and retrieve connection-specific state using <code>setField</code> and <code>getField</code>.</li>
<li><code>ctx.disconnect()</code>: Closes the connection.</li>
</ul>
<p dir="auto">Delivery of replies respects the QoS settings of the transport, just like <code>sendToSession()</code> does (including ACKs, retries, and the offline outbox).</p>
<hr/>

<div dir="auto"><h3 tabindex="-1" dir="auto">Server‚Äëside expectations</h3><a id="user-content-serverside-expectations" aria-label="Permalink: Server‚Äëside expectations" href="#serverside-expectations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The sample inspector above demands <strong>three</strong> query parameters:</p>
<div data-snippet-clipboard-copy-content="
clientId ‚áí opaque user string (e.g. email)

deviceId ‚áí integer; each physical device gets a stable ID

sessionToken (optional) ‚áí 32‚Äëhex chars to resume previous session
"><pre><code>
clientId ‚áí opaque user string (e.g. email)

deviceId ‚áí integer; each physical device gets a stable ID

sessionToken (optional) ‚áí 32‚Äëhex chars to resume previous session

</code></pre></div>
<p dir="auto">If the token is absent or invalid the server autogenerates a fresh one and returns it via a dedicated <code>get_token</code> RPC.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">JavaScript reference client</h3><a id="user-content-javascript-reference-client" aria-label="Permalink: JavaScript reference client" href="#javascript-reference-client"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The repository ships with a minimal reference client in <code>index.html</code>. It demonstrates:</p>
<div dir="auto" data-snippet-clipboard-copy-content="
import  &#34;./binaryrpc.js&#34;;

  

const  rpc  =  new  BinaryRPC(&#34;ws://localhost:9010&#34;, {

	onConnect() { rpc.call(&#34;join&#34;); },

	onError:  console.error

});

  

rpc.connect(&#34;user‚Äë42&#34;, &#34;web&#34;, /*session*/ null);

  

// later

rpc.call(&#34;broadcast&#34;, { message:  &#34;hello&#34; });
"><pre><span>import</span>  <span>&#34;./binaryrpc.js&#34;</span><span>;</span>

  

<span>const</span>  <span>rpc</span>  <span>=</span>  <span>new</span>  <span>BinaryRPC</span><span>(</span><span>&#34;ws://localhost:9010&#34;</span><span>,</span> <span>{</span>

	<span>onConnect</span><span>(</span><span>)</span> <span>{</span> <span>rpc</span><span>.</span><span>call</span><span>(</span><span>&#34;join&#34;</span><span>)</span><span>;</span> <span>}</span><span>,</span>

	<span>onError</span>:  <span>console</span><span>.</span><span>error</span>

<span>}</span><span>)</span><span>;</span>

  

<span>rpc</span><span>.</span><span>connect</span><span>(</span><span>&#34;user‚Äë42&#34;</span><span>,</span> <span>&#34;web&#34;</span><span>,</span> <span>/*session*/</span> <span>null</span><span>)</span><span>;</span>

  

<span>// later</span>

<span>rpc</span><span>.</span><span>call</span><span>(</span><span>&#34;broadcast&#34;</span><span>,</span> <span>{</span> <span>message</span>:  <span>&#34;hello&#34;</span> <span>}</span><span>)</span><span>;</span></pre></div>
<p dir="auto">Internally the helper wraps the QoS‚Äë2 handshake (<code>DATA ‚Üí ACK</code> etc.) and keeps an <strong>outbox</strong> so messages typed while offline flush once the socket is back (mirroring server‚Äëside <code>sessionTtlMs</code>). You can plug your own MessagePack/JSON codec by swapping <code>MessagePack.encode/decode</code>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Writing custom handshake/auth logic</h3><a id="user-content-writing-custom-handshakeauth-logic" aria-label="Permalink: Writing custom handshake/auth logic" href="#writing-custom-handshakeauth-logic"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you need headers, JWT, IP checks ‚Ä¶ attach an <code>IHandshakeInspector</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Forward declarations for your business logic
ClientIdentity makeClientFromJwt(const std::string&amp; token);
bool verifyJwt(const std::string&amp; token);

class JwtInspector : public IHandshakeInspector {
public:
    std::optional&lt;ClientIdentity&gt; extract(uWS::HttpRequest&amp; req) override {
        // Note: uWS::HttpRequest does not have getHeader in this form.
        // This is illustrative. You would use req.getHeader(&#34;x-access-token&#34;).
        std::string_view token_sv = req.getHeader(&#34;x-access-token&#34;);

        if (token_sv.empty()) {
            return std::nullopt;
        }

        std::string token{token_sv};
        if (verifyJwt(token)) {
            return makeClientFromJwt(token);
        }

        return std::nullopt;
    }
};

// In your main setup:
// ws-&gt;setHandshakeInspector(std::make_shared&lt;JwtInspector&gt;());"><pre><span><span>//</span> Forward declarations for your business logic</span>
ClientIdentity <span>makeClientFromJwt</span>(<span>const</span> std::string&amp; token);
<span>bool</span> <span>verifyJwt</span>(<span>const</span> std::string&amp; token);

<span>class</span> <span>JwtInspector</span> : <span>public</span> <span>IHandshakeInspector</span> {
<span>public:</span>
    std::optional&lt;ClientIdentity&gt; <span>extract</span>(uWS::HttpRequest&amp; req) <span>override</span> {
        <span><span>//</span> Note: uWS::HttpRequest does not have getHeader in this form.</span>
        <span><span>//</span> This is illustrative. You would use req.getHeader(&#34;x-access-token&#34;).</span>
        std::string_view token_sv = req.<span>getHeader</span>(<span><span>&#34;</span>x-access-token<span>&#34;</span></span>);

        <span>if</span> (token_sv.<span>empty</span>()) {
            <span>return</span> std::nullopt;
        }

        std::string token{token_sv};
        <span>if</span> (<span>verifyJwt</span>(token)) {
            <span>return</span> <span>makeClientFromJwt</span>(token);
        }

        <span>return</span> std::nullopt;
    }
};

<span><span>//</span> In your main setup:</span>
<span><span>//</span> ws-&gt;setHandshakeInspector(std::make_shared&lt;JwtInspector&gt;());</span></pre></div>
<p dir="auto">If <code>extract()</code> returns <code>std::nullopt</code> the upgrade is rejected with <strong>400 Bad Request</strong>.</p>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">üìö In-Depth Guides &amp; Examples</h2><a id="user-content--in-depth-guides--examples" aria-label="Permalink: üìö In-Depth Guides &amp; Examples" href="#-in-depth-guides--examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">While the cheat-sheet provides quick answers, this section explains how to use the ready-to-use components that ship with BinaryRPC.</p>

<p dir="auto">Plugins add complex, stateful capabilities to the framework.</p>

<p dir="auto">The <code>room_plugin.hpp</code> provides core functionality for chat rooms, game lobbies, or any group-based scenario.</p>
<p dir="auto"><strong>Example:</strong> Joining a room and broadcasting a message.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;binaryrpc/plugins/room_plugin.hpp&gt;
#include &lt;binaryrpc/core/app.hpp&gt;
#include &lt;binaryrpc/core/framework_api.hpp&gt;

// ... setup app and api ...

// Create and register the RoomPlugin
auto roomPlugin = std::make_unique&lt;binaryrpc::RoomPlugin&gt;(app.getSessionManager(), app.getTransport());
binaryrpc::RoomPlugin* room_ptr = roomPlugin.get();
app.usePlugin(std::move(roomPlugin));

// RPC for a client to join a room
app.registerRPC(&#34;join_room&#34;, [&amp;](const auto&amp; req, auto&amp; ctx) {
    std::string room_name(req.begin(), req.end()); // e.g., &#34;/gaming&#34;
    room_ptr-&gt;join(room_name, ctx.session().id());
    
    // Announce that the user has joined
    std::string join_msg = &#34;User &#34; + ctx.session().identity().clientId + &#34; joined.&#34;;
    std::vector&lt;uint8_t&gt; payload(join_msg.begin(), join_msg.end());
    room_ptr-&gt;broadcast(room_name, app.getProtocol()-&gt;serialize(&#34;room_event&#34;, payload));
});"><pre>#<span>include</span> <span><span>&lt;</span>binaryrpc/plugins/room_plugin.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>binaryrpc/core/app.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>binaryrpc/core/framework_api.hpp<span>&gt;</span></span>

<span><span>//</span> ... setup app and api ...</span>

<span><span>//</span> Create and register the RoomPlugin</span>
<span>auto</span> roomPlugin = std::make_unique&lt;binaryrpc::RoomPlugin&gt;(app.getSessionManager(), app.getTransport());
binaryrpc::RoomPlugin* room_ptr = roomPlugin.get();
app.usePlugin(std::move(roomPlugin));

<span><span>//</span> RPC for a client to join a room</span>
app.registerRPC(<span><span>&#34;</span>join_room<span>&#34;</span></span>, [&amp;](<span>const</span> <span>auto</span>&amp; req, <span>auto</span>&amp; ctx) {
    std::string <span>room_name</span>(req.<span>begin</span>(), req.<span>end</span>()); <span><span>//</span> e.g., &#34;/gaming&#34;</span>
    room_ptr-&gt;<span>join</span>(room_name, ctx.<span>session</span>().<span>id</span>());
    
    <span><span>//</span> Announce that the user has joined</span>
    std::string join_msg = <span><span>&#34;</span>User <span>&#34;</span></span> + ctx.<span>session</span>().<span>identity</span>().<span>clientId</span> + <span><span>&#34;</span> joined.<span>&#34;</span></span>;
    std::vector&lt;<span>uint8_t</span>&gt; <span>payload</span>(join_msg.<span>begin</span>(), join_msg.<span>end</span>());
    room_ptr-&gt;<span>broadcast</span>(room_name, app.<span>getProtocol</span>()-&gt;<span>serialize</span>(<span><span>&#34;</span>room_event<span>&#34;</span></span>, payload));
});</pre></div>

<p dir="auto">The transport layer is responsible for sending and receiving raw data over the network.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">WebSocket Transport Callbacks</h4><a id="user-content-websocket-transport-callbacks" aria-label="Permalink: WebSocket Transport Callbacks" href="#websocket-transport-callbacks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <code>WebSocketTransport</code> allows you to register a callback that is triggered when a client&#39;s connection is terminated or the session expires. This is powerful for tracking user presence or cleaning up resources.</p>
<p dir="auto"><strong>Example:</strong> Log disconnections and update user status.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;binaryrpc/transports/websocket/websocket_transport.hpp&gt;
// ... other includes ...

// Create the transport
auto ws = std::make_unique&lt;binaryrpc::WebSocketTransport&gt;(sm, /*idleTimeoutSec=*/60);

// Set the disconnect callback
ws-&gt;setDisconnectCallback([&amp;api](std::shared_ptr&lt;binaryrpc::Session&gt; session) {
    if (!session) return;
    
    const auto&amp; identity = session-&gt;identity();
    LOG_INFO(&#34;Client disconnected: &#34; + identity.clientId);
              
    // Update the user&#39;s status to &#34;offline&#34;
    api.setField(session-&gt;id(), &#34;onlineStatus&#34;, std::string(&#34;offline&#34;), /*indexed=*/true);
});

// Set the transport on the app
app.setTransport(std::move(ws));"><pre>#<span>include</span> <span><span>&lt;</span>binaryrpc/transports/websocket/websocket_transport.hpp<span>&gt;</span></span>
<span><span>//</span> ... other includes ...</span>

<span><span>//</span> Create the transport</span>
<span>auto</span> ws = std::make_unique&lt;binaryrpc::WebSocketTransport&gt;(sm, <span><span>/*</span>idleTimeoutSec=<span>*/</span></span><span>60</span>);

<span><span>//</span> Set the disconnect callback</span>
ws-&gt;<span>setDisconnectCallback</span>([&amp;api](std::shared_ptr&lt;binaryrpc::Session&gt; session) {
    <span>if</span> (!session) <span>return</span>;
    
    <span>const</span> <span>auto</span>&amp; identity = session-&gt;<span>identity</span>();
    <span>LOG_INFO</span>(<span><span>&#34;</span>Client disconnected: <span>&#34;</span></span> + identity.<span>clientId</span>);
              
    <span><span>//</span> Update the user&#39;s status to &#34;offline&#34;</span>
    api.<span>setField</span>(session-&gt;<span>id</span>(), <span><span>&#34;</span>onlineStatus<span>&#34;</span></span>, <span>std::string</span>(<span><span>&#34;</span>offline<span>&#34;</span></span>), <span><span>/*</span>indexed=<span>*/</span></span><span>true</span>);
});

<span><span>//</span> Set the transport on the app</span>
app.setTransport(std::move(ws));</pre></div>

<p dir="auto">The framework provides several utilities in the <code>binaryrpc/core/util/</code> directory.</p>

<p dir="auto">You can redirect the framework&#39;s logs to a file or a logging service.</p>
<p dir="auto"><strong>Example:</strong> Log to both console and a file.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;binaryrpc/core/util/logger.hpp&gt;
#include &lt;fstream&gt;

std::ofstream logFile(&#34;server.log&#34;, std::ios::app);

// Set a custom sink
binaryrpc::Logger::inst().setSink([&amp;logFile](binaryrpc::LogLevel lvl, const std::string&amp; msg) {
    static const char* names[]{&#34;TRACE&#34;, &#34;DEBUG&#34;, &#34;INFO&#34;, &#34;WARN&#34;, &#34;ERROR&#34;};
    std::string log_line = &#34;[&#34; + std::string(names[(int)lvl]) + &#34;] &#34; + msg;
    
    std::cout &lt;&lt; log_line &lt;&lt; std::endl;
    logFile &lt;&lt; log_line &lt;&lt; std::endl;
});

binaryrpc::Logger::inst().setLevel(binaryrpc::LogLevel::Debug);"><pre>#<span>include</span> <span><span>&lt;</span>binaryrpc/core/util/logger.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>fstream<span>&gt;</span></span>

std::ofstream <span>logFile</span>(<span><span>&#34;</span>server.log<span>&#34;</span></span>, std::ios::app);

<span><span>//</span> Set a custom sink</span>
<span>binaryrpc::Logger::inst</span>().setSink([&amp;logFile](binaryrpc::LogLevel lvl, <span>const</span> std::string&amp; msg) {
    <span>static</span> <span>const</span> <span>char</span>* names[]{<span><span>&#34;</span>TRACE<span>&#34;</span></span>, <span><span>&#34;</span>DEBUG<span>&#34;</span></span>, <span><span>&#34;</span>INFO<span>&#34;</span></span>, <span><span>&#34;</span>WARN<span>&#34;</span></span>, <span><span>&#34;</span>ERROR<span>&#34;</span></span>};
    std::string log_line = <span><span>&#34;</span>[<span>&#34;</span></span> + <span>std::string</span>(names[(<span>int</span>)lvl]) + <span><span>&#34;</span>] <span>&#34;</span></span> + msg;
    
    std::cout &lt;&lt; log_line &lt;&lt; std::endl;
    logFile &lt;&lt; log_line &lt;&lt; std::endl;
});

<span>binaryrpc::Logger::inst</span>().setLevel(binaryrpc::LogLevel::Debug);</pre></div>

<p dir="auto">Throw an <code>ErrorObj</code> in your RPC handlers to send a structured error to the client.</p>
<p dir="auto"><strong>Example:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;binaryrpc/core/util/error_types.hpp&gt;

app.registerRPC(&#34;place_bet&#34;, [&amp;](const auto&amp; req, auto&amp; ctx) {
    if (/* user has insufficient balance */) {
        throw binaryrpc::ErrorObj(&#34;Insufficient balance&#34;, 1001); // (message, custom_code)
    }
});"><pre>#<span>include</span> <span><span>&lt;</span>binaryrpc/core/util/error_types.hpp<span>&gt;</span></span>

app.registerRPC(<span><span>&#34;</span>place_bet<span>&#34;</span></span>, [&amp;](<span>const</span> <span>auto</span>&amp; req, <span>auto</span>&amp; ctx) {
    <span>if</span> (<span><span>/*</span> user has insufficient balance <span>*/</span></span>) {
        <span>throw</span> <span>binaryrpc::ErrorObj</span>(<span><span>&#34;</span>Insufficient balance<span>&#34;</span></span>, <span>1001</span>); <span><span>//</span> (message, custom_code)</span>
    }
});</pre></div>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">üíª Client-Side Usage (JavaScript)</h2><a id="user-content--client-side-usage-javascript" aria-label="Permalink: üíª Client-Side Usage (JavaScript)" href="#-client-side-usage-javascript"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">For a production‚Äëready browser/Node client, check binaryrpc‚Äëclient‚Äëjs ‚Üí <a href="https://github.com/efecan0/binaryrpc-client-js">https://github.com/efecan0/binaryrpc-client-js</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import  &#34;./binaryrpc.js&#34;;

const  rpc  =  new  BinaryRPC(&#34;ws://localhost:9010&#34;, {
	onConnect() { rpc.call(&#34;join&#34;); },
	onError:  console.error
});

// The client expects the server&#39;s IHandshakeInspector to understand these params.
rpc.connect(&#34;user‚Äë42&#34;, &#34;web&#34;, /*sessionToken*/ null);

// later
rpc.call(&#34;broadcast&#34;, { message:  &#34;hello&#34; });"><pre><span>import</span>  <span>&#34;./binaryrpc.js&#34;</span><span>;</span>

<span>const</span>  <span>rpc</span>  <span>=</span>  <span>new</span>  <span>BinaryRPC</span><span>(</span><span>&#34;ws://localhost:9010&#34;</span><span>,</span> <span>{</span>
	<span>onConnect</span><span>(</span><span>)</span> <span>{</span> <span>rpc</span><span>.</span><span>call</span><span>(</span><span>&#34;join&#34;</span><span>)</span><span>;</span> <span>}</span><span>,</span>
	<span>onError</span>:  <span>console</span><span>.</span><span>error</span>
<span>}</span><span>)</span><span>;</span>

<span>// The client expects the server&#39;s IHandshakeInspector to understand these params.</span>
<span>rpc</span><span>.</span><span>connect</span><span>(</span><span>&#34;user‚Äë42&#34;</span><span>,</span> <span>&#34;web&#34;</span><span>,</span> <span>/*sessionToken*/</span> <span>null</span><span>)</span><span>;</span>

<span>// later</span>
<span>rpc</span><span>.</span><span>call</span><span>(</span><span>&#34;broadcast&#34;</span><span>,</span> <span>{</span> <span>message</span>:  <span>&#34;hello&#34;</span> <span>}</span><span>)</span><span>;</span></pre></div>
<p dir="auto">The helper wraps the QoS handshake and queues outbound messages while offline. If you prefer another codec, simply replace MessagePack.encode/decode.</p>
<hr/>

<div dir="auto"><h3 tabindex="-1" dir="auto">1. Test Dependencies (Catch2)</h3><a id="user-content-1-test-dependencies-catch2" aria-label="Permalink: 1. Test Dependencies (Catch2)" href="#1-test-dependencies-catch2"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">BinaryRPC&#39;s C++ unit tests are written using the <a href="https://github.com/catchorg/Catch2">Catch2</a> framework. You need to install Catch2 before you can build and run the tests.</p>
<ul dir="auto">
<li><strong>Windows (vcpkg):</strong>
<div dir="auto" data-snippet-clipboard-copy-content="./vcpkg install catch2 --triplet x64-windows"><pre>./vcpkg install catch2 --triplet x64-windows</pre></div>
</li>
<li><strong>Linux (Arch/pacman):</strong>

</li>
<li><strong>Linux (Ubuntu/Debian):</strong>

</li>
</ul>
<blockquote>
<p dir="auto">Note: On some systems, Catch2&#39;s CMake config files (<code>Catch2Config.cmake</code>) may be missing. In that case, you can build and install Catch2 from source by following the instructions on the <a href="https://github.com/catchorg/Catch2">Catch2 GitHub page</a>.</p>
</blockquote>
<div dir="auto"><h3 tabindex="-1" dir="auto">2. Building and Running the Tests</h3><a id="user-content-2-building-and-running-the-tests" aria-label="Permalink: 2. Building and Running the Tests" href="#2-building-and-running-the-tests"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">By default, the <code>BINARYRPC_BUILD_TESTS</code> option in the main CMakeLists.txt is <strong>ON</strong>, so tests are built automatically.</p>
<ul dir="auto">
<li>To build the tests:
<div dir="auto" data-snippet-clipboard-copy-content="cmake .. -DBINARYRPC_BUILD_TESTS=ON
cmake --build . --config Release"><pre>cmake .. -DBINARYRPC_BUILD_TESTS=ON
cmake --build <span>.</span> --config Release</pre></div>
</li>
<li>To run all tests:
<div dir="auto" data-snippet-clipboard-copy-content="ctest --output-on-failure"><pre>ctest --output-on-failure</pre></div>
</li>
<li>Or you can run the test binaries directly:
<div dir="auto" data-snippet-clipboard-copy-content="./tests/binaryrpc_unit_tests
./tests/binaryrpc_qos_tests"><pre>./tests/binaryrpc_unit_tests
./tests/binaryrpc_qos_tests</pre></div>
</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">3. Integration and Memory Leak Tests (Python)</h3><a id="user-content-3-integration-and-memory-leak-tests-python" aria-label="Permalink: 3. Integration and Memory Leak Tests (Python)" href="#3-integration-and-memory-leak-tests-python"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Some integration and memory leak tests are written in Python. To run them:</p>
<ul dir="auto">
<li>Make sure you have Python 3 and the required packages installed. You can install dependencies with:
<div dir="auto" data-snippet-clipboard-copy-content="pip install -r tests/integration_tests_py/requirements.txt"><pre>pip install -r tests/integration_tests_py/requirements.txt</pre></div>
</li>
<li>To run the tests, simply execute the scripts directly:
<div dir="auto" data-snippet-clipboard-copy-content="# Example: Run a memory leak test
python tests/Memory_leak_stress_test_py/memory_leak_test.py

# Example: Run an integration test
python tests/integration_tests_py/session/app.py"><pre><span><span>#</span> Example: Run a memory leak test</span>
python tests/Memory_leak_stress_test_py/memory_leak_test.py

<span><span>#</span> Example: Run an integration test</span>
python tests/integration_tests_py/session/app.py</pre></div>
</li>
</ul>
</article></div></div>
  </body>
</html>
