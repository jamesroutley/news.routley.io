<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://comsec.ethz.ch/research/dram/zenhammer/">Original</a>
    <h1>ZenHammer: Rowhammer attacks on AMD Zen-based platforms</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
			<!-- If has sidebar start -->
	<main id="main">
		<div>
			<!-- If has sidebar end -->
							<article id="post-1249" class="page">
										<!-- .entry-header -->
					<div>
						
<p><a href="https://writing.natwelch.com/wp-content/files/zenhammer_sec24.pdf">Our work</a> shows that it is possible to <strong>trigger Rowhammer bit flips on DDR4 devices on AMD Zen 2 and Zen 3</strong> <strong>systems</strong> despite deployed TRR mitigations. This result proves that <strong>AMD systems are equally vulnerable to Rowhammer as Intel systems</strong>, which greatly increases the attack surface, considering today’s AMD market share of around 36% on x86 desktop CPUs. This poses a significant risk as DRAM devices in the wild cannot easily be fixed, and previous work showed that Rowhammer attacks are practical, for example, <a href="https://writing.natwelch.com/research/dram/smash/" target="_blank" rel="noreferrer noopener">in the browser</a>, <a href="https://writing.natwelch.com/wp-content/files/drammer.pdf" target="_blank" rel="noreferrer noopener">on smartphones</a>, <a href="https://writing.natwelch.com/wp-content/files/flip-feng-shui_sec16.pdf" target="_blank" rel="noreferrer noopener">across VMs</a>, and even <a href="https://writing.natwelch.com/wp-content/files/throwhammer_atc18.pdf" target="_blank" rel="noreferrer noopener">over the network</a>. Furthermore, we show that ZenHammer can trigger <strong>Rowhammer bit flips on a DDR5 device for the first time</strong>.</p>



<p>Our results show a high number of bit flips on Zen 2 and Zen 3 systems. Also, devices are more vulnerable on Zen 3 than Coffee Lake, simplifying exploitation. We can build the page table, RSA public key corruption, and sudo exploits from prior work on 7/6/4 of these devices, taking, on average, just 164/267/209 seconds.</p>



<h2>How did you do it?</h2>



<p>We reverse-engineered the <strong>secret DRAM address functions </strong>by adopting the <a href="https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_pessl.pdf">DRAMA</a> technique for AMD systems. We found that the timing routine must be changed for more reliable results. We make the key observation that a physical offset must be applied to physical addresses before recovering the DRAM address functions due to system address remapping (see <strong>Figure 1</strong>). This allows us to recover the address functions completely. However, using these address functions gives us very few bit flips on 5 and 0 of 10 devices on AMD Zen 2 and Zen 3, respectively, as we show in <strong>Table 1</strong>.</p>



<figure><table><tbody><tr><td><strong>Fig. 1:</strong> Remapping of higher address ranges to unused parts of physical memory on Intel and AMD CPUs. The Top of Memory (TOM) is the system’s highest addressable memory location.</td><td><strong>Table 1:</strong> Result of running Blacksmith on AMD Zen 2 and Zen 3 systems, compared to our Intel Coffee Lake baseline. We report for each device the number of patterns found (|P+|) and the number of bit flips over all patterns (|F_fuzz|). We omit devices without any bit flips.</td></tr><tr><td><img decoding="async" src="https://writing.natwelch.com/wp-content/uploads/2024/03/20240319_141734_ZenHammer-watermarked@2x-1024x495.png" alt=""/></td><td><img decoding="async" src="https://writing.natwelch.com/wp-content/uploads/2024/03/20240319_154517_paper@2x-1024x567.png" alt=""/></td></tr></tbody></table></figure>



<p>We started by looking at the <strong>refresh synchronization</strong>, which previous work (e.g., <a href="https://writing.natwelch.com/research/dram/smash/">SMASH</a>, <a href="https://writing.natwelch.com/research/dram/blacksmith/">Blacksmith</a>) showed to be important for triggering bit flips. We demonstrate that continuous timing measurements using non-repeating rows are effective for precise and reliable refresh synchronization on AMD. The result in<strong> Listing 1</strong> shows our improved refresh synchronization method.</p>



<figure><table><tbody><tr><td></td><td data-align="center"><strong>Listing 1</strong>. Our continuous, non-repeating refresh synchronization.</td></tr><tr><td></td><td data-align="center"><img decoding="async" src="https://writing.natwelch.com/wp-content/uploads/2024/03/20240319_160700_paper@2x-1024x463.png" alt=""/></td></tr></tbody></table></figure>



<p>We found out that the <strong>activation rate of non-uniform Rowhammer patterns </strong>on AMD Zen+/3 systems is significantly lower than on Intel Coffee Lake (see <strong>Figure 2</strong>). To investigate this, we conducted a series of experiments to find the optimal hammering <strong>instruction sequence</strong>. Our results showed that regular loads (<code>MOV</code>) with <code>CLFLUSHOPT</code> for flushing aggressors from the cache, issued immediately after accessing an aggressor (“scatter” style), is optimal. It further revealed that, unlike on Zen 2, explicit fencing after flushing is not required on Zen 3.</p>



<figure><table><tbody><tr><td data-align="center"><strong>Fig. 2:</strong> Distribution of the activation rates of non-uniform hammering patterns on Z+, Z3, and Intel Coffee Lake (CL). The whiskers indicate the minimum and maximum values.</td></tr><tr><td data-align="center"><img decoding="async" src="https://writing.natwelch.com/wp-content/uploads/2024/03/20240319_141813_ZenHammer-watermarked@2x-1024x341.png" alt=""/></td></tr></tbody></table></figure>



<p>We further investigated how different <strong>fence types and fence scheduling policies</strong> affect Rowhammer patterns on AMD Zen systems. For this, we came up with six different pattern-aware and cache-avoiding fence scheduling policies (see <strong>Table 2</strong>) and tested them on our devices for 6 hours each to determine the device’s optimal policy. We found that on most devices on Zen 2 the policy SP_none is optimal while SP_pair is in most cases better suited on Zen 3.</p>



<figure><table><tbody><tr><td data-align="center"><strong>Table 2:</strong> Overview of our proposed fence scheduling policies. We indicate which policies are pattern-aware by taking the pattern’s structure into account and which are cache-avoiding.</td></tr><tr><td data-align="center"><img decoding="async" src="https://writing.natwelch.com/wp-content/uploads/2024/03/20240319_164041_paper@2x-1024x666.png" alt=""/></td></tr></tbody></table></figure>



<h2>How bad is it?</h2>



<p>For our <strong>evaluation</strong>, we considered a test pool of 10x DDR4 DRAM devices covering the three major manufacturers (Samsung, Micron, SK Hynix). We let our ZenHammer fuzzer run for 3 hours with each fence type (mfence, sfence) and fence scheduling policy. After each run, the best pattern is determined by using a minisweep over 4 MiB with all found patterns. Thereafter, we <em>swept</em> the best pattern of the best policy over a contiguous memory area of 256 MB and reported the number of bit flips. The results in <strong>Table 3</strong> show that our ZenHammer fuzzer is able to trigger bit flips on 7 (Zen 2) and 6 (Zen 3) of 10 DDR4 DRAM devices.</p>



<figure><table><tbody><tr><td data-align="center"><strong>Table 3:</strong> ZenHammer results on AMD Zen 2 and Zen 3 as well as Intel Coffee Lake. For each of our devices, we report the best scheduling policy (SP_opt) and both the number of effective patterns (|P+|) and bit flips (|F_fuzz|) we found while fuzzing with the best policy. We also show the number of bit flips found when sweeping the best patterns over a 256 MiB range (|F_swp|).</td></tr><tr><td data-align="center"><img decoding="async" src="https://writing.natwelch.com/wp-content/uploads/2024/03/20240319_144633_paper@2x-1024x447.png" alt=""/></td></tr></tbody></table></figure>



<p>We evaluated the <strong>exploitability</strong> of these bit flips based on three attacks from <a href="https://writing.natwelch.com/wp-content/files/hammertime_raid18.pdf" target="_blank" rel="noreferrer noopener">previous work</a>: (i) an attack targeting the page frame number of a page table entry (PTE) to pivot it to an attacker-controlled page table page, (ii) an attack on the RSA-2048 public key that allows recovering the associated private key used to authenticate to an SSH host, (iii) and an attack on the password verification logic of the <code>sudoers.so</code> library that enables gaining root privileges. We report the results in <strong>Table 4</strong>. </p>



<figure><table><tbody><tr><td><strong>Table 4:</strong> Analysis of the bit flip exploitability found during the sweep over 256 MiB on AMD Zen 2, Zen 3, and Intel Coffee Lake. For each attack, we indicate the number of exploitable bit flips (#Ex.) and the average time to find an exploitable bit flip (Time). We mark DIMMs with a single exploitable bit flip by (*). We omit DIMMs without any exploitable bit flips.</td></tr><tr><td><img decoding="async" src="https://writing.natwelch.com/wp-content/uploads/2024/03/20240319_142711_paper@2x-1024x264.png" alt=""/></td></tr></tbody></table></figure>



<h2>What about DDR5?</h2>



<p>Finally, we tried ZenHammer on DDR5 by reverse engineering the DRAM functions on AMD Zen 4 and evaluating ten DDR5 devices. Out of these ten devices, ZenHammer could trigger ~42k flips on one device. <strong>This is the first public report of DDR5 bit flips on commodity systems in the wild</strong>. However, given that ZenHammer could not trigger flips on nine out of ten devices, we conclude that more research is necessary to find more effective patterns for DDR5 devices.</p>



<h2>Further Information</h2>



<p>For full details and more information about our work, please have a look at our <a href="https://writing.natwelch.com/wp-content/files/zenhammer_sec24.pdf">paper</a>, which is to appear at <a href="https://www.usenix.org/conference/usenixsecurity24/">USENIX Security 2024</a> in August 2024. Our ZenHammer fuzzer is available on <a href="https://github.com/comsec-group/zenhammer">Github</a>.</p>



<h2>FAQs</h2>



<p>Following, we provide answers to the most frequently asked questions about our work.</p>



<p><strong>Why has nobody paid any attention to AMD systems before?</strong></p>



<p><strong>Are there any DDR4 devices that are safe?</strong></p>



<p><strong>Why does your evaluation consider ten devices only?</strong></p>



<p><strong>How can I check whether my DRAM is vulnerable?</strong></p>



<p><strong>Why has JEDEC not fixed this issue yet?</strong></p>



<p><strong>What about DIMMs with Error Correction Codes (ECC)?</strong></p>



<p><strong>What if my system runs with a double refresh rate?</strong></p>



<h2>Responsible Disclosure</h2>



<p>Rowhammer is a known industry-wide issue, and we did not see a need to go through the typical disclosure process. Nonetheless, we informed AMD on February 26, 2024, and at their request, we did not publicly disclose the issue until March 25, 2024. This page was briefly online by mistake on March 21.</p>



<h2>Acknowledgments</h2>



<p>This research was supported by the Swiss National Science Foundation (SNSF) under NCCR Automation, grant agreement 51NF40_180545, by the Swiss State Secretariat for Education, Research and Innovation under contract number MB22.00057 (ERC-StG PROMISE), and by a Microsoft Swiss JRC grant.</p>



<figure><img fetchpriority="high" decoding="async" width="493" height="102" src="https://writing.natwelch.com/wp-content/uploads/2021/11/nccr-logo.png" alt="" srcset="/wp-content/uploads/2021/11/nccr-logo.png 493w, /wp-content/uploads/2021/11/nccr-logo-300x62.png 300w" sizes="(max-width: 493px) 100vw, 493px"/></figure>
					</div><!-- .entry-content -->
				</article><!-- #post -->
							<!-- If has sidebar start -->
		</div>
				<!-- If has sidebar end -->
		</main><!-- .site-main -->
	</div></div>
  </body>
</html>
