<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gwern.net/gwtar">Original</a>
    <h1>Gwtar: A static efficient single-file HTML format</h1>
    
    <div id="readability-page-1" class="page"><div id="page-metadata">
          
        <p>Gwtar is a new polyglot HTML archival format which provides a single, self-contained, HTML file which still can be efficiently lazy-loaded by a web browser. This is done by a header’s JavaScript making HTTP range requests. It is used on Gwern.net to serve large HTML archives.</p>
        
      </div><div id="markdownBody"><div>
<blockquote>
<p>Archiving HTML files faces a trilemma: it is easy to create an archival format which is any two of static (self-contained ie. all assets included, no special software or server support), a single file (when stored on disk), and efficient (lazy-loads assets only as necessary to display to a user), but no known format allows all 3 simultaneously.</p>
<p>We introduce a new format, <strong>Gwtar</strong> (<a href="https://gwern.net/doc/cs/algorithm/information/compression/2026-01-23-dbohdan-gpt5imagemini-gwtarlogo-guitar.svg" id="bohdan-2026" data-link-icon="image" data-link-icon-type="svg" data-link-icon-color="#ffb338" data-filesize-bytes="4219" data-filesize-percentage="1" data-image-height="1024" data-image-width="1024" data-aspect-ratio="1 / 1" title="Bohdan 2026">logo</a>; pronounced “guitar”, <span><code>.gw⁠tar.html</code></span> extension), which achieves all 3 properties simultaneously. A Gwtar is a classic fully-inlined HTML file, which is then processed into a self-extracting concatenated file of an HTML + JavaScript header followed by a tarball of the original HTML and assets. The HTML header’s JS stops web browsers from loading the rest of the file, loads just the original HTML, and then hooks requests and turns them into range requests into the tarball part of the file.</p>
<p>Thus, a regular web browser loads what seems to be a normal HTML file, and all assets download only when they need to. In this way, a static HTML page can inline anything—such as gigabyte-size media files—but those will not be downloaded until necessary, even while the server sees just a single large HTML file it serves as normal. And because it is self-contained in this way, it is forwards-compatible: no future user or host of a Gwtar file needs to treat it specially, as all functionality required is old standardized web browser/server functionality.</p>
<p>Gwtar allows us to easily and reliably archive even the largest HTML pages, while still being user-friendly to read.</p>
<p>Example pages: <a href="https://gwern.net/doc/philosophy/religion/2010-02-brianmoriarty-thesecretofpsalm46.gwtar.html" id="_SgLUK4lU" data-link-icon="internet-archive" data-link-icon-type="svg" data-filesize-bytes="282761763" data-filesize-percentage="100">“The Secret of Psalm 46”</a> (vs <a href="https://gwern.net/doc/philosophy/religion/2010-02-brianmoriarty-thesecretofpsalm46.html" id="moriarty-2010" data-link-icon="internet-archive" data-link-icon-type="svg" data-filesize-bytes="299579672" data-filesize-percentage="100" title="‘The Secret of Psalm 46’, Moriarty 2010">original SingleFile archive</a>—<strong>warning</strong>: 286MB download).</p>
</blockquote>
</div>
<section id="background">

<p><a href="https://en.wikipedia.org/wiki/Linkrot" id="_IBISXgfV" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Linkrot#bodyContent" title="Linkrot">Linkrot</a> is one of the biggest challenges for long-term websites. Gwern.net makes <a href="https://gwern.net/archiving" id="gwern-archiving" data-filesize-bytes="88086" data-filesize-percentage="56" title="‘Archiving URLs’, Gwern 2011">heavy use of web page archiving</a> to solve this; and due to quality problems and <a href="https://gwern.net/archiving#why-not-internet-archive" id="gwern-archiving--why-not-internet-archive" data-filesize-bytes="88086" data-filesize-percentage="56" title="‘Archiving URLs § Why Not Internet Archive?’, Gwern 2011">long-term reliability concerns</a>, simply linking to the <a href="https://en.wikipedia.org/wiki/Internet_Archive" id="_ECwLZp68" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Internet_Archive#bodyContent" title="Internet Archive">Internet Archive</a> is not enough, so I try to create &amp; host my own web page archives of everything I link.</p>
<p>There are 3 major properties we would like of an HTML archive format, beyond the basics of actually capturing a page in the first place: it should not depend in any way on the original web page, because then it is not an archive and will inevitably break; it should be easy to manage and store, so you can scalably create them and store them for the long run; and it should be efficient, which for HTML largely means that readers should be able to download only the parts they need in order to view the current page.</p>
</section>
<section id="html-trilemma">

<p>No current format achieves all 3. The built-in web browser save-as-HTML format achieves single and efficient, but not static; save-as-HTML-with-directory achieves static partially and efficient, but not single; <a href="https://en.wikipedia.org/wiki/MHTML" id="_8Rx7nvE2" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/MHTML#bodyContent" title="MHTML">MHTML</a>, <a href="https://en.wikipedia.org/wiki/Mozilla_Archive_Format" id="_h3f6Q310" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Mozilla_Archive_Format#bodyContent" title="Mozilla Archive Format">MAFF</a>, <a href="https://github.com/gildas-lormeau/SingleFile/" id="_FNxhcGu8" data-link-icon="github" data-link-icon-type="svg" title="&#39;SingleFile&#39;, Lormeau 2026">SingleFile</a>, &amp; <a href="https://gildas-lormeau.github.io/Polyglot-HTML-ZIP-PNG/SUMMARY.html" id="_tNscMW2u" title="How to Create HTML/ZIP/PNG Polyglot Files">SingleFileZ</a> (a <a href="https://en.wikipedia.org/wiki/ZIP" id="_iDT1Yece" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/ZIP#bodyContent" title="ZIP">ZIP</a>-compressed variant) achieve static, single, but not efficiency; <a href="https://en.wikipedia.org/wiki/WARC_(file_format)" id="_KNIpr4uJ" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/WARC_(file_format)#bodyContent" title="WARC (file format)">WARCs</a>/<a href="https://specs.webrecorder.net/wacz/1.1.1/" id="_N0ZMzJdn" title="Web Archive Collection Zipped (WACZ)">WACZs</a> achieve static and efficient, but not single (because while the WARC is a single file, it relies on a complex software installation like <a href="https://webrecorder.net/" id="_RR7E9aay" title="Webrecorder: Web Archiving for All">WebRecorder</a>/<a href="https://replayweb.page/" id="_3YUDvZ7-" title="ReplayWeb.page">Replay Webpage</a> to display).</p>
<p>An ordinary ‘save as page HTML’ browser command doesn’t work because “Web Page, HTML Only” leaves out most of a web page; even “Web Page, Complete” is inadequate because a lot of assets are dynamic and only appear when you interact with the page—especially images. If you want a <strong>static</strong> HTML archive, one which has no dependency on the original web page or domain, you have to use a tool specifically designed for this. I usually use SingleFile. SingleFile produces a static snapshot of the live web page, while making sure that <a href="https://en.wikipedia.org/wiki/Lazy_loading" id="_lLFyKyKn" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Lazy_loading#bodyContent" title="Lazy loading">lazy-loaded</a> images are first loaded, so they are included in the snapshot.</p>
<p>SingleFile often produces a useful static snapshot. It also achieves another nice property: the snapshot is a <strong>single file</strong>, just a simple single <code>.html</code> file, which makes life so much easier in terms of organizing and hosting. Want to mirror a web page? SingleFile it, and upload the resulting single file to a convenient directory somewhere, boom—done forever. Being a single file is important on Gwern.net, where I must host so many files, and I run so many lints and checks and automated tools and track metadata etc. and where other people may rehost my archives.</p>
<p>However, a user of SingleFile quickly runs into a nasty drawback: snapshots can be surprisingly large. In fact, some snapshots on Gwern.net are over half a gigabyte! For example, the homepage for the research project <a href="https://gwern.net/doc/www/lllyasviel.github.io/96def0bcd8813bb1389665c487366a2ac61eaf4e.html" id="_veFH5gdp" data-url-archive="/doc/www/lllyasviel.github.io/96def0bcd8813bb1389665c487366a2ac61eaf4e.html" data-url-original="https://lllyasviel.github.io/pages/paints_undo/" data-filesize-bytes="507833876" data-filesize-percentage="100" title="PaintsUndo: A Base Model of Drawing Behaviors in Digital Paintings">“PaintsUndo: A Base Model of Drawing Behaviors in Digital Paintings”</a> is 485MB <em>after</em> size optimization, while the raw HTML is 0.6MB. It is common for an ordinary somewhat-fancy Web 2.0 blog post like a <a href="https://en.wikipedia.org/wiki/Medium.com" id="_y6Oy1KZd" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Medium.com#bodyContent" title="Medium.com">Medium.com</a> post to be &gt;20MB once fully archived. This is because such web pages wind up importing a lot of <a href="https://en.wikipedia.org/wiki/Web_Fonts" id="_vSh6m4XR" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Web_Fonts#bodyContent" title="Web Fonts">fonts</a>, JS, widgets and icons etc., all of which assets must be saved to ensure it is fully static; and then there is additional wasted space overhead due to <a href="https://en.wikipedia.org/wiki/Binary-to-text_encoding" id="_9GIvObKx" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Binary-to-text_encoding#bodyContent" title="Binary-to-text encoding">converting</a> assets from their original binary encoding into <a href="https://en.wikipedia.org/wiki/Base64" id="_PviFHGIn" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Base64#bodyContent" title="Base64">Base64</a> text which can be <a href="https://en.wikipedia.org/wiki/Data_URI_scheme" id="_FzXDwgj4" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Data_URI_scheme#bodyContent" title="Data URI scheme">interleaved with the original HTML</a>.</p>
<p>This is especially bad because, unlike the original web page, anyone viewing a snapshot <em>must</em> download the <em>entire thing</em>. That 500MB web page is possibly OK because a reader only downloads the images that they are looking at; but the archived version must download everything. A web browser has to download the entire page, after all, to display it properly; and there is no lazy-loading or ability to optionally load ‘other’ files—there are no other files ‘elsewhere’, that was the whole point of using SingleFile!</p>
<p>Hence, a SingleFile archive is static, and a single file, but it is not <strong>efficient</strong>: viewing it requires downloading unnecessary assets.</p>
<p>So, for some archives, we ‘split’ or ‘deconstruct’ the static snapshot back into a normal HTML file and a directory of asset files, using <a href="https://gwern.net/static/build/deconstruct_singlefile.php" id="deconstruct_singlefile-1" data-link-icon="code" data-link-icon-type="svg" data-link-icon-color="#787cb4" data-filesize-bytes="19434" data-filesize-percentage="4"><code>deconstruct_singlefile.php</code></a> (which incidentally makes it easy to re-compress all the images, which produces large savings as many websites are surprisingly bad at basic stuff like PNG/JPG/GIF compression); then we are back to a static, efficient, but not single file, archive.</p>
<p>This is fine for our <a href="https://gwern.net/archiving#preemptive-local-archiving" id="gwern-archiving--preemptive-local-archiving" data-filesize-bytes="88086" data-filesize-percentage="56" title="‘Archiving URLs § Preemptive Local Archiving’, Gwern 2011">auto-generated local archives</a> because they are stored in their own directory tree which is off-limits to most Gwern.net infrastructure (and off-limits to search engines &amp; agents or off-site hotlinking), and it doesn’t matter too much if they litter tens of thousands of directories and files. It is not fine for HTML archives I would like to host as first-class citizens, and expose to Google, and hope people will rehost someday when Gwern.net inevitably dies.</p>
<p>So, we could either host a regular SingleFile archive, which is static, single, and inefficient; or a deconstructed archive, which is static, multiple, and efficient, but not all 3 properties.</p>
<p>This issue came to a head in January 2026 when I was archiving the Internet Archive snapshots of Brian Moriarty’s famous lectures <a href="https://gwern.net/doc/philosophy/religion/1999-03-17-brianmoriarty-whoburiedpaul.html" id="moriarty-1999" data-link-icon="internet-archive" data-link-icon-type="svg" data-filesize-bytes="6394956" data-filesize-percentage="93" title="&#39;Who Buried Paul?&#39;, Moriarty 1999">“Who Buried Paul?”</a> and <a href="https://gwern.net/doc/philosophy/religion/2010-02-brianmoriarty-thesecretofpsalm46.html" id="moriarty-2010" data-link-icon="internet-archive" data-link-icon-type="svg" data-filesize-bytes="299579672" data-filesize-percentage="100" title="‘The Secret of Psalm 46’, Moriarty 2010">“The Secret of Psalm 46”</a>, since I noticed while writing <a href="https://gwern.net/video-game-art" id="gwern-video-game-art" data-filesize-bytes="19787" data-filesize-percentage="27" title="‘Video Games as Art’, Gwern 2025">an essay drawing on them</a> that his whole website had sadly gone down. I admire them and wanted to host them properly so people could easily find my fast reliable mirrors (unlike the slow, hard-to-find, unreliable IA versions), but realized I was running into our long-standing dilemma: they would be efficient in the local archive system after being split, but unfindable; or if findable, inefficiently large and reader-unfriendly. Specifically, the video of “Who Buried Paul?” was not a problem because it had been linked as a separate file, so I simply <a href="https://gwern.net/doc/philosophy/religion/1999-03-17-brianmoriarty-whoburiedpaul-videolecture.mp4" id="_7x5-J_7K" data-link-icon="file-video" data-link-icon-type="svg" data-filesize-bytes="133173584" data-filesize-percentage="99" data-image-height="244" data-image-width="322" data-aspect-ratio="161 / 122">converted it to MP4</a> and edited the link; but “The Secret of Psalm 46” turned out to inline the OGG/MP3 recordings of the lecture and abruptly increased from &lt;1MB to <em>286MB</em>.</p>
<p>I discussed it with <a href="https://wiki.obormot.net/" id="_rEJYARlj" title="Welcome to OborWiki">Said Achmiz</a>, and he began developing a fix.</p>
</section>
<section id="trisecting">

<p>To achieve all 3, we need some way to download only part of a file, and selectively download the rest. This lets us have a single static archive of potentially arbitrarily large size, which can safely store every asset which might be required.</p>
<p>HTTP already easily supports selective downloading via the ancient <a href="https://en.wikipedia.org/wiki/Byte_serving" id="_Q7yEHY5s" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Byte_serving#bodyContent" title="Byte serving">HTTP Range query feature</a>, which allows one to query for a precise range of bytes inside a URL. This is mostly used to do things like resume downloads, but you can also <a href="https://gwern.net/design-graveyard#range-queries" id="gwern-design-graveyard--range-queries" data-filesize-bytes="200493" data-filesize-percentage="73">do interesting things</a> like run databases in reverse: a web browser client can run a database application locally which reads a database file stored on a server, because Range queries let the client download only the exact parts of the database file it needs at any given moment, as opposed to the entire thing (which might be terabytes in size).</p>
<p>This is how formats like WARC can render efficiently: host a WARC as a normal file, and then simply range-query the parts displayed at any moment.</p>
<p>The challenge is the first part: how do we download <em>only</em> the original HTML and subsequently only the displayed assets? If we have a single HTML file and then a separate giant archive file, we could easily just rewrite the HTML using JS to point to the equivalent ranges in the archive file (or do something server-side), but that would achieve only static and efficiency, not single file. If we combine them, like SingleFile, we are back to static and single file, but not efficiency.</p>
<p>The simplest solution here would be to decide to complicate the server itself and do the equivalent of <code>deconstruct_singlefile.php</code> on the fly. HTML requests, perhaps detecting some magic string in the URL like <code>.singlefile.html</code>, is handed to a <a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface" id="_AWCwdWE-" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Common_Gateway_Interface#bodyContent" title="Common Gateway Interface">CGI</a> proxy process, which splits the original single HTML file into a normal HTML file with lazy-loaded references. The client browser sees a normal multiple efficient HTML, while everything on server sees a static single inefficient HTML. (A possible example is <a href="https://gwern.net/doc/www/github.com/ff0072519026bd8a7f72adcf3f86a25a1932e14d.html" id="_xvHTwrax" data-link-icon="github" data-link-icon-type="svg" data-url-archive="/doc/www/github.com/ff0072519026bd8a7f72adcf3f86a25a1932e14d.html" data-url-original="https://github.com/oils-for-unix/wwz" data-filesize-bytes="4157805" data-filesize-percentage="79" title="oils-for-unix/wwz: A WSGI program that serves content out of a zip file (.wwz file). Deploy as CGI or FastCGI">WWZ</a>.)</p>
<p>While this solves the immediate Gwern.net problem, it does so at the permanent cost of server complexity, and does not do much to help anyone else. (It is unrealistic to expect more than a handful of people to modify their servers this invasively.) I also considered taking the WARC red pill and going full WebRecorder, but quailed.</p>
<section id="download-stopping-mechanisms">
<h2><a href="#download-stopping-mechanisms" title="Link to section: § &#39;Download Stopping Mechanisms&#39;">Download Stopping Mechanisms</a></h2>
<p>How can we trick an HTML file into acting like a <a href="https://en.wikipedia.org/wiki/Tar_(computing)" id="_yEGWAUO8" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Tar_(computing)#bodyContent" title="Tar (computing)">tarball</a> or ZIP file, with partial random access?</p>
<p>Our initial approach was to ship an HTML + JS header with an appended archive, where the JS would do HTTP Range queries into the appended binary archive; the challenge, however, was to <em>stop</em> the file from downloading past the header. To do this, we considered some approaches ‘outside’ the page, like encoding the archive index into the filename/URL itself (ie. <code>foo.gwtar-$N.html</code>) and requiring the server to parse <code>$N</code> out and slice the archive down to just the header, which then handled the range requests; this minimized how much special handling the server did, while being backwards/forwards-compatible with non-compliant servers (who would ignore the index and simply return the entire file, and be no worse than before). This worked in our prototypes, but required at least some server-side support and also required that the header be fixed-length (because any changes would in length would invalidate the index).</p>
<p>Eventually, Achmiz realized that you <em>can</em> stop downloading from <em>within</em> an HTML page, using the JS command <code><span>window</span><span>.</span><span>stop</span>()</code>! <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/stop" id="_U0evPgMI" data-link-icon="FF" data-link-icon-type="text,sans" data-link-icon-color="#e66000" title="&#39;Window: &lt;code&gt;stop()&lt;/code&gt; method—Web APIs&#39;, MDN 2026">MDN</a> (<a href="https://caniuse.com/mdn-api_window_stop" id="_GBGRASi_" data-link-icon="CanI" data-link-icon-type="text,sans,quad" data-link-icon-color="#c75000" title="Window API: &lt;code&gt;stop&lt;/code&gt;">&gt;96% support</a>, <a href="https://html.spec.whatwg.org/multipage/nav-history-apis.html#dom-window-stop" id="_-8zoVd3A" title="HTML Standard">spec</a>):</p>
<blockquote>
<p>The <code><span>window</span><span>.</span><span>stop</span>()</code> stops further resource loading in the current browsing context, equivalent to the stop button in the browser.</p>
<p>Because of how scripts are executed, this method cannot interrupt its parent document’s loading, but it will stop its images, new windows, and other still-loading objects.</p>
</blockquote>
<p>This is precisely what we need, and the design falls into place.</p>
</section>
</section>
<section id="concatenated-archive-design">

<p>A Gwtar is an HTML file with a HTML + JS + JSON header followed by a tarball and <a href="#optional-trailing-data">possibly further assets</a>. (A Gwtar could be seen as <em>almost</em> a <a href="https://en.wikipedia.org/wiki/Polyglot_(computing)" id="_XBuu2OcZ" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Polyglot_(computing)#bodyContent" title="Polyglot (computing)">polyglot file</a> is a file valid as more than one format—in this case, a <code>.html</code> file that is also a <code>.tar</code> archive, and possibly <code>.par2</code>. But strictly speaking, it is not.)</p>
<section id="creation">
<h2><a href="#creation" title="Link to section: § &#39;Creation&#39;">Creation</a></h2>
<p>We provide a reference PHP script, <a href="https://gwern.net/static/build/deconstruct_singlefile.php" id="deconstruct_singlefile-2" data-link-icon="code" data-link-icon-type="svg" data-link-icon-color="#787cb4" data-filesize-bytes="19434" data-filesize-percentage="4"><code>deconstruct_singlefile.php</code></a>, which creates Gwtars from SingleFile HTML snapshots.</p>
<p>It additionally tries to recompress JPG/PNG/GIFs before storing in the Gwtar, and then appends <a href="#fec">PAR2 FEC</a>.</p>
<p>Example command to replace the original <a href="https://gwern.net/doc/philosophy/religion/2010-02-brianmoriarty-thesecretofpsalm46.html" id="moriarty-2010" data-link-icon="internet-archive" data-link-icon-type="svg" data-filesize-bytes="299579672" data-filesize-percentage="100" title="‘The Secret of Psalm 46’, Moriarty 2010"><code>2010-02-brianmoriarty-thesecretofpsalm46.html</code></a> by <a href="https://gwern.net/doc/philosophy/religion/2010-02-brianmoriarty-thesecretofpsalm46.gwtar.html" id="_SgLUK4lU" data-link-icon="internet-archive" data-link-icon-type="svg" data-filesize-bytes="282761763" data-filesize-percentage="100"><code>2010-02-brianmoriarty-thesecretofpsalm46.gwtar.html</code></a> with PAR2 <a href="https://en.wikipedia.org/wiki/Error_correction_code" id="_aMl-PjVS" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Error_correction_code#bodyContent" title="Error correction code § Forward error correction">FEC</a>:</p>
<div id="cb1"><pre><code><span id="cb1-1"><span>php</span> ./static/build/deconstruct_singlefile.php <span>--create-gwtar</span> <span>--add-fec-data</span> <span>\</span></span>
<span id="cb1-2">    2010-02-brianmoriarty-thesecretofpsalm46.html</span></code></pre></div>
</section>
<section id="implementation">
<h2><a href="#implementation" title="Link to section: § &#39;Implementation&#39;">Implementation</a></h2>

<section id="details">
<h3><a href="#details" title="Link to section: § &#39;Details&#39;">Details</a></h3>
<p>The simple approach is to download the binary assets, encode them into Base64 text, and inject them into the HTML DOM. This is inefficient in both compute and RAM because the web browser must immediately reverse this to get a binary to work with. So we actually use the browser optimization of <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" id="_bTOmie_-" data-link-icon="FF" data-link-icon-type="text,sans" data-link-icon-color="#e66000" title="Blob—Web APIs">blobs</a> to just pass the binary asset straight to the browser.</p>
<p>A tricky bit is that inline JS can depend on “previously loaded” JS files, which may not have actually loaded <em>yet</em> because the first attempt failed (of course) and the real Range request is still racing. We currently solve this by just downloading all JS before rendering the HTML, at some cost to responsiveness.</p>
<p>So, a web browser will load a normal web page; the JS will halt its loading; a new page loads, and all of its requests initially fail but get repeated immediately and work the second time; the entire archive never gets downloaded unless required. All assets are provided, there is a single Gwtar file, it is efficient; it doesn’t require JS for archival integrity, as just the entire archive downloads if the JS is not executed; and it is cross-platform and standards-compliant, requires no server-side support or future users/hosts to do anything whatsoever, and is a transparent, self-documenting file format which can be easily converted back to a ‘normal’ multiple-file HTML (<code><span>cat</span> foo.gwtar.html <span>|</span> <span>perl</span> <span>-ne</span><span>&#39;print $_ if $x; $x=1 if /&lt;!-- GWTAR END/&#39;</span> <span>|</span> <span>tar</span> xf <span>-</span></code>) <em>or</em> a user can just re-archive it normally with tools like SingleFile.</p>
</section>
</section>
<section id="fallback">
<h2><a href="#fallback" title="Link to section: § &#39;Fallback&#39;">Fallback</a></h2>
<p>In the event of JS problems, <a href="https://gwern.net/static/build/gwtar_noscript.html" id="_iTr5kj0a" data-link-icon="code" data-link-icon-type="svg" data-filesize-bytes="1512" data-filesize-percentage="0">a <code><span>&lt;</span><span>noscript</span><span>&gt;</span></code> message</a> explains what the Gwtar format is and why it requires JS, and links to this page for more details.</p>
<p>It also detects whether range requests are supported or downgraded to requesting the entire file. If the latter, it will start rendering it.</p>
<p>This is not as slow as it seems because we can benefit from connection level compression like <a href="https://en.wikipedia.org/wiki/Gzip" id="_kNKlNLYu" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Gzip#bodyContent" title="Gzip">gzip</a> or <a href="https://en.wikipedia.org/wiki/Brotli_compression" id="_lbIjDp8n" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Brotli_compression#bodyContent" title="Brotli compression">Brotli compression</a>. And because our preprocessing linearize the assets in dependency order, we receive the bytes in order of page appearance, and so in this mode, the “above the fold” images and stuff will still load first and quickly. (This in comparison to the usual SingleFile, where you have to receive every single asset before you’re done, and which may be slower.)</p>
</section>
<section id="compression">
<h2><a href="#compression" title="Link to section: § &#39;Compression&#39;">Compression</a></h2>
<p>Gwtar does not directly support deduplication or compression.</p>
<p>Gwtars may overlap and have redundant copies of assets, but because they will be stored bit-identical inside the tarballs, a <a href="https://en.wikipedia.org/wiki/Data_deduplication" id="_vf23AhEL" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Data_deduplication#bodyContent" title="Data deduplication">de-duplicating</a> filesystem can transparently remove most of that redundancy.</p>
<p>Media assets like MP3 or JPEG are already compressed, and can be compressed during the build phase by a gwtar implementation.</p>
<p>The HTML text itself could be compressed; it is currently unclear to me how Gwtar’s range requests interact with transparent negotiated compression like Brotli compression (which for Gwern.net was as easy as enabling one option in <a href="https://en.wikipedia.org/wiki/Cloudflare" id="_kfdgrzn7" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Cloudflare#bodyContent" title="Cloudflare">Cloudflare</a>). <a href="https://datatracker.ietf.org/doc/html/rfc7233" id="_1a0qf39g" title="RFC 7233—Hypertext Transfer Protocol (HTTP/1.1): Range Requests">RFC 7233</a> doesn’t seem to give a clear answer about this, and the <a href="https://gwern.net/doc/www/github.com/65ab1543899bde87417bd885a63424a25af38b89.html" id="_VXOat9wZ" data-link-icon="github" data-link-icon-type="svg" data-url-archive="/doc/www/github.com/65ab1543899bde87417bd885a63424a25af38b89.html" data-url-original="https://github.com/httpwg/http-core/issues/11" data-filesize-bytes="10094125" data-filesize-percentage="92" title="Ranges and Content and Transfer Encoding · Issue #11 · httpwg/http-core">cursory and unhelpful discussion here</a> <em>seems</em> to indicate that the range requests would have to be interpreted relative to the compressed version rather than the original, which is useful for the core use-case of resuming downloads but not for our use-case. So I suspect that probably Cloudflare would either disable Brotli, or downgrade to sending the entire file instead. It is possible that <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Transfer-Encoding" id="_trLk5AtF" data-link-icon="FF" data-link-icon-type="text,sans" data-link-icon-color="#e66000" title="Transfer-Encoding header—HTTP">“transfer-encoding”</a> solves this, but <a href="https://stackoverflow.com/a/53135659" id="_dSssud9p" data-link-icon="stack-exchange" data-link-icon-type="svg" data-link-icon-color="#f48024" title="Is it possible to send HTTP response using GZIP and byte ranges at the same time?">as of 2018, Cloudflare didn’t support it</a>, making it useless for us and suggesting little support in the wild.</p>
<p>If this is a serious problem, it may be possible to compress the HTML during the Gwtar generation phase and adjust the JS.</p>
</section>
<section id="limitations">
<h2><a href="#limitations" title="Link to section: § &#39;Limitations&#39;">Limitations</a></h2>
<section id="local-viewing">
<h3><a href="#local-viewing" title="Link to section: § &#39;Local Viewing&#39;">Local Viewing</a></h3>
<p>Strangely, the biggest drawback of Gwtar turns out to be <em>local</em> viewing of HTML archives. SingleFileZ encounters the same issue: in the name of security (<a href="https://en.wikipedia.org/wiki/Same-origin_policy" id="_vY4ZqADs" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Same-origin_policy#bodyContent" title="Same-origin policy">origin</a>/<a href="https://en.wikipedia.org/wiki/CORS" id="_EBSnP5E9" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/CORS#bodyContent" title="CORS">CORS</a>/sandboxing), browsers will not execute certain requests in local HTML pages, so it will break, as it is no longer able to request from itself.</p>
<p>We regard this as unfortunate, but an acceptable tradeoff, as for local browsing, the file can be easily converted back to the non-JS dependent multiple/single-file HTML formats.</p>
</section>
<section id="range-request-support">
<h3><a href="#range-request-support" title="Link to section: § &#39;Range Request Support&#39;">Range Request Support</a></h3>
<p>Range requests are old, standardized, and important for resuming downloads or viewing large media files like video, and every web server should, in theory, support it by default. In practice, there may be glitches, and one should check.</p>
<p>An example <a href="https://en.wikipedia.org/wiki/CURL" id="_krzenu-j" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/CURL#bodyContent" title="CURL">curl</a> command which should return a HTTP 206 (not 200) request if range requests are correctly working:</p>
<div id="cb3"><pre><code><span id="cb3-1"><span>curl</span> <span>--head</span> <span>--header</span> <span>&#34;Range: bytes=0-99&#34;</span> <span>&#39;https://gwern.net/doc/philosophy/religion/1999-03-17-brianmoriarty-whoburiedpaul.gwtar.html&#39;</span></span>
<span id="cb3-2"><span># HTTP/2 206</span></span>
<span id="cb3-3"><span># date: Sun, 25 Jan 2026 22:20:57 GMT</span></span>
<span id="cb3-4"><span># content-type: x-gwtar</span></span>
<span id="cb3-5"><span># content-length: 100</span></span>
<span id="cb3-6"><span># server: cloudflare</span></span>
<span id="cb3-7"><span># last-modified: Sun, 25 Jan 2026 07:08:33 GMT</span></span>
<span id="cb3-8"><span># etag: &#34;6975c171-7aeb5c&#34;</span></span>
<span id="cb3-9"><span># age: 733</span></span>
<span id="cb3-10"><span># cache-control: max-age=77760000, public, immutable</span></span>
<span id="cb3-11"><span># content-disposition: inline</span></span>
<span id="cb3-12"><span># content-range: bytes 0-99/8055644</span></span>
<span id="cb3-13"><span># cf-cache-status: HIT</span></span>
<span id="cb3-14"><span># ...</span></span></code></pre></div>
<p>Servers <em>should</em> serve Gwtar files as <code>text/html</code> if possible. This may require some configuration (eg. <a href="https://blog.nginx.org/blog/smart-efficient-byte-range-caching-nginx" id="_IuUowmgg" title="Smart and Efficient Byte-Range Caching with NGINX">in nginx</a><a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>), but should be straightforward.</p>
<section id="cloudflare-is-broken">
<h4><a href="#cloudflare-is-broken" title="Link to section: § &#39;Cloudflare Is Broken&#39;">Cloudflare Is Broken</a></h4>
<p>However, Cloudflare has an undocumented, hardwired behavior: its proxy (not cache) will strip Range request headers for <code>text/html</code> responses regardless of cache settings. This does not break Gwtar rendering, of course, but it does break efficiency and defeats the point of Gwtar for Gwern.net</p>
<p>As a workaround, we serve Gwtars with the MIME type <code>x-gwtar</code>—web browsers like Firefox &amp; Chromium will content-sniff the opening <code><span>&lt;</span><span>html</span><span>&gt;</span></code> tag and render correctly, while Cloudflare passes Range requests through for unrecognized types. (This is not ideal, but a more conventional MIME type like <code>application/...</code> results in web browsers downloading the file without trying to render it at all; and using a MIME type trick is better than alternatives like trying to serve Gwtars as MP4s, using a special-case subdomain just to bypass Cloudflare completely, using complex tools like Service Workers to try to undo the removal, etc.)</p>
</section>
</section>
</section>
<section id="accessing-binary-assets">
<h2><a href="#accessing-binary-assets" title="Link to section: § &#39;Accessing Binary Assets&#39;">Accessing Binary Assets</a></h2>
<p>Because a Gwtar can store large binary assets without burdening the viewer and is an archive format, it may be useful for reproducible science/statistics: include datasets, such as <a href="https://sqlite.org/wasm/doc/trunk/index.md" id="_hXsQro6n" data-link-icon="txt" data-link-icon-type="svg" title="sqlite3 WebAssembly &amp;amp; JavaScript Documentation Index">Sqlite3 databases</a>, and do computation on them like visualization or analysis. The question is, how do we ensure that assets get referenced in a way that SingleFile can “see” them and include them inline (to be stored in the final Gwtar as split-out objects), and then addressed and loaded by simple user JS, in a way which still works <em>without</em> Gwtar?</p>
<p>A potential approach in Gwtar v1 would be to reference all such assets using the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/object" id="2026-02-08" data-link-icon="FF" data-link-icon-type="text,sans" data-link-icon-color="#e66000" title="&#39;&lt;object&gt;&#39;, element—HTML MDN"><code><span>&lt;</span><span>object</span><span>&gt;</span></code> tag</a><a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>, and then the user JS adds a simple listener hook to the <code>load</code> event, which will fire either when the browser loads the asset normally (multi-file) or when Gwtar completes its range-fetch rewrite, and then kicks off the actual userland work. This does not require any unusual or contorted user JS, appears to be backwards/forwards compatible, and to satisfy all our desiderata.</p>
<p>Untested pseudo-code:</p>
<div id="cb4"><pre><code><span id="cb4-1"><span>&lt;</span><span>object</span> <span>id</span><span>=</span><span>&#34;dataset&#34;</span> <span>data</span><span>=</span><span>&#34;dataset.sqlite3&#34;</span> <span>type</span><span>=</span><span>&#34;application/x-sqlite3&#34;</span> <span>width</span><span>=</span><span>&#34;0&#34;</span> <span>height</span><span>=</span><span>&#34;0&#34;</span><span>&gt;&lt;/</span><span>object</span><span>&gt;</span></span>
<span id="cb4-2"></span>
<span id="cb4-3"><span>&lt;</span><span>script</span><span>&gt;</span></span>
<span id="cb4-4"><span>document</span><span>.</span><span>getElementById</span>(<span>&#39;dataset&#39;</span>)<span>.</span><span>addEventListener</span>(<span>&#39;load&#39;</span><span>,</span> <span>function</span> () {</span>
<span id="cb4-5">    <span>fetch</span>(<span>this</span><span>.</span><span>data</span>)</span>
<span id="cb4-6">        <span>.</span><span>then</span>(<span>function</span> (r) { <span>return</span> r<span>.</span><span>arrayBuffer</span>()<span>;</span> })</span>
<span id="cb4-7">        <span>.</span><span>then</span>(<span>function</span> (buf) {</span>
<span id="cb4-8">            <span>// `buf` is the raw .sqlite3 bytes.</span></span>
<span id="cb4-9">            <span>// Hand off to whatever SQL-in-JS library you&#39;re using.</span></span>
<span id="cb4-10">        })<span>;</span></span>
<span id="cb4-11">})<span>;</span></span>
<span id="cb4-12"><span>&lt;/</span><span>script</span><span>&gt;</span></span></code></pre></div>
</section>
<section id="optional-trailing-data">
<h2><a href="#optional-trailing-data" title="Link to section: § &#39;Optional Trailing Data&#39;">Optional Trailing Data</a></h2>
<p>The appended tarball can itself be followed by additional arbitrary binary assets, which can be large since they will usually not be downloaded. (While the exact format of each appended file is up to the users, it’s a good idea to wrap them in tarballs if you can.)</p>
<p>This flexibility is intended primarily for allowing ad hoc metadata extensions like <a href="https://en.wikipedia.org/wiki/Cryptographic_signatures" id="_BhGBBdTk" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Cryptographic_signatures#bodyContent" title="Cryptographic signatures">cryptographic signatures</a> or forward error correction (<a href="https://en.wikipedia.org/wiki/Error_correction_code" id="_aMl-PjVS" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Error_correction_code#bodyContent" title="Error correction code § Forward error correction">FEC</a>).</p>
<section id="fec">
<h3><a href="#fec" title="Link to section: § &#39;FEC&#39;">FEC</a></h3>
<p>The Gwern.net generation script uses this feature to add <a href="https://en.wikipedia.org/wiki/Par2" id="_2SUozIf9" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Par2#bodyContent" title="Par2">par2</a> FEC in an additional tarball.<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a> This allows recovery of the original Gwtar if it has been partially corrupted or lost. (It cannot recover loss of the file as a whole, which is why FEC is ideally done over large corpuses, and not individual files, but this is better than nothing, and gives us free integrity checking as well.)</p>
<p>PAR2 can find its FEC data even in corrupted files by scanning for FEC data (“packets”) it recognizes, while tar ignores appended data; so adding, say, 25% par2 FEC is as simple as running <code><span>par2create</span> <span>-r25</span> <span>-n1</span> foo.gwtar.html <span>&amp;&amp;</span> <span>tar</span> cf. <span>-</span> foo.gwtar.html.par2 foo.gwtar.html.vol<span>*</span>.par2 <span>&gt;&gt;</span> foo.gwtar.html <span>&amp;&amp;</span> <span>rm</span> foo.gwtar.html<span>*</span>.par2</code>, and <span id="par2-repair">repairing a corrupted file is as simple as <code><span>ln</span> <span>--symbolic</span> broken.gwtar.html broken.gwtar.html.par2 <span>&amp;&amp;</span> <span>par2repair</span> broken.gwtar.html.par2 broken.gwtar.html</code></span>.<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>This yields the original <code>foo.gwtar.html</code> without any FEC. A repaired Gwtar file can then have fresh FEC added to be just like the old Gwtar + FEC archive, or be integrated in some broader system which achieves long-term protection some other way.</p>
</section>
<section id="signing">
<h3><a href="#signing" title="Link to section: § &#39;Signing&#39;">Signing</a></h3>
<p>A simple form of cryptographic signing would be to use GPG to sign it as a normal, separate, signature file (creates <code>foo.gwtar.html.sig</code>): <code><span>gpg</span> <span>--detach-sign</span> <span>--armor</span> foo.gwtar.html</code>.</p>
<p>And we could also append an ASCII ‘armored’ GPG signature, as it won’t confuse tar, like <code><span>gpg</span> <span>--detach-sign</span> <span>--armor</span> foo.gwtar.html <span>&gt;&gt;</span> foo.gwtar.html</code>. Since GPG won’t munge a file like PAR2 will, an adhoc format would be to wrap it in tar to assist extracting:</p>
<div id="cb6"><pre><code><span id="cb6-1"><span>gpg</span> <span>--detach-sign</span> <span>--armor</span> foo.gwtar.html</span>
<span id="cb6-2"><span>tar</span> cf. <span>-</span> foo.gwtar.html.sig <span>&gt;&gt;</span> foo.gwtar.html</span>
<span id="cb6-3"><span>rm</span> foo.gwtar.html.sig</span></code></pre></div>
<p>or in magic text, like a HTML comment:</p>
<div id="cb7"><pre><code><span id="cb7-1"><span># sign and append</span></span>
<span id="cb7-2"><span>FILE</span><span>=</span><span>&#34;foo.gwtar.html&#34;</span></span>
<span id="cb7-3"><span>gpg</span> <span>--detach-sign</span> <span>--armor</span> <span>-o</span> <span>&#34;</span><span>$FILE</span><span>&#34;</span>.asc <span>&#34;</span><span>$FILE</span><span>&#34;</span></span>
<span id="cb7-4"><span>echo</span> <span>&#39;&lt;!-- GWTAR-GPG-SIG&#39;</span> <span>&gt;&gt;</span> <span>&#34;</span><span>$FILE</span><span>&#34;</span></span>
<span id="cb7-5"><span>cat</span> <span>&#34;</span><span>$FILE</span><span>&#34;</span>.asc <span>&gt;&gt;</span> <span>&#34;</span><span>$FILE</span><span>&#34;</span></span>
<span id="cb7-6"><span>echo</span> <span>&#39;--&gt;&#39;</span> <span>&gt;&gt;</span> <span>&#34;</span><span>$FILE</span><span>&#34;</span></span>
<span id="cb7-7"><span>rm</span> <span>&#34;</span><span>$FILE</span><span>&#34;</span>.asc</span>
<span id="cb7-8"></span>
<span id="cb7-9"><span># Extract and verify:</span></span>
<span id="cb7-10"><span>SIG</span><span>=</span><span>$(</span><span>mktemp</span> XXXXXX.asc<span>)</span></span>
<span id="cb7-11"><span>CONTENT</span><span>=</span><span>$(</span><span>mktemp</span><span>)</span></span>
<span id="cb7-12"><span>sed</span> <span>--quiet</span> <span>&#39;/&lt;!-- GWTAR-GPG-SIG/,/--&gt;$/p&#39;</span> <span>&#34;</span><span>$FILE</span><span>&#34;</span> <span>|</span></span>
<span id="cb7-13">    <span>grep</span> <span>-Ev</span> <span>&#39;GWTAR-GPG-SIG|--&gt;&#39;</span> <span>&gt;</span> <span>&#34;</span><span>$SIG</span><span>&#34;</span></span>
<span id="cb7-14"><span>sed</span> <span>&#39;/&lt;!-- GWTAR-GPG-SIG/,$d&#39;</span> <span>&#34;</span><span>$FILE</span><span>&#34;</span> <span>&gt;</span> <span>&#34;</span><span>$CONTENT</span><span>&#34;</span></span>
<span id="cb7-15"><span>gpg</span> <span>--verify</span> <span>&#34;</span><span>$SIG</span><span>&#34;</span> <span>&#34;</span><span>$CONTENT</span><span>&#34;</span></span>
<span id="cb7-16"><span>rm</span> <span>&#34;</span><span>$SIG</span><span>&#34;</span> <span>&#34;</span><span>$CONTENT</span><span>&#34;</span></span></code></pre></div>
</section>
</section>
</section>
<section id="metadata">

<p>A Gwtar is served with a <code>text/html</code> mime-type. If necessary to <a href="#cloudflare-is-broken">work around broken services like Cloudflare</a>, its mime-type is <code>x-gwtar</code>.</p>
</section>
<section id="ip">

<p>This documentation and the Gwtar code is licensed under the <a href="https://creativecommons.org/public-domain/cc0/" id="commons-2002" data-link-icon="creative-commons" data-link-icon-type="svg" title="‘CC-0: Creative Commons public domain license’, Commons 2002">CC-0</a> <a href="https://en.wikipedia.org/wiki/Public_domain" id="_ZGU5aXKy" data-link-icon="wikipedia" data-link-icon-type="svg" data-url-iframe="https://en.m.wikipedia.org/wiki/Public_domain#bodyContent" title="Public domain">public domain</a> copyright license. We are unaware of any software patents.</p>
</section>
<section id="further-work">

<p>Gwtar v1 could be improved with:</p>
<ol>
<li><p>Validation tool</p></li>
<li><p>Checking of hashsums when rendering (possibly async or deferred)</p></li>
<li><p>More aggressive prefetching of assets</p></li>
<li><p>Integration into SingleFile (possibly as a “SingleFileZ2” forma?)</p></li>
<li><p>Testing: corpus of edge-case test files (inline SVG, <code>srcset</code>, CSS <code><span>@import</span></code> chains, web fonts, data URIs in CSS…)</p></li>
</ol>
<p>A Gwtar v2 could add breaking changes like:</p>
<ol>
<li><p>format provides more rigorous validation/checking of HTML &amp; assets; require HTML &amp; asset validity, assets all decode successfully, etc.</p></li>
<li><p>standardize appending formats</p></li>
<li><p>require FEC</p></li>
<li><p>built-in compression with Brotli/gzip for formats not already compressed</p></li>
<li><p>multi-page support</p>
<p>One would try to replace MAFF’s capability of creating sets of documents which are convenient to link/archive and can automatically share assets for de-duplication (eg. page selected by a built-in widget, or perhaps by a hash-anchor like <code>archive.gwtar.html#page=foo.html</code>? Can an initial web page open new tabs of all the other web pages in the archive?)</p></li>
<li><p>Better de-duplication, eg. content-addressed asset names (hash-based) enabling deduplication across multiple gwtars</p></li>
</ol>
</section>


      
      
      
      
      <section id="link-bibliography-section">
         <!-- NOTE: In theory, '.collapse' on a '<h1>' is redundant with the '<section>'; but added to parallel Pandoc-generated headers which set all attributes/classes on both. -->
        <a id="link-bibliography" href="https://gwern.net/metadata/annotation/link-bibliography/%252Fgwtar.html" title="Bibliography of links cited in this page (forward citations). Lazily-transcluded version at footer of page for easier scrolling." data-link-icon="bibliography" data-link-icon-type="svg">[Bibliography of links/references used in page]</a>
          </section>
      
      </div></div>
  </body>
</html>
