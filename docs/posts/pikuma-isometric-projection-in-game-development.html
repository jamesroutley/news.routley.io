<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pikuma.com/blog/isometric-projection-in-games">Original</a>
    <h1>Pikuma: Isometric Projection in Game Development</h1>
    
    <div id="readability-page-1" class="page"><p>Playing isometric games is super fun, but understanding the theory behind isometric projection is also extremely important for any <i>beginner</i> game developer. Programming isometric worlds is a huge topic, so I&#39;ll try to be as beginner-friendly as possible and cover the basics we need to learn how isometric projection is used in game development!</p><div>
                        <p>I was talking to one of my students during office hours last week, and we ended up touching the topic of <strong>isometric projection</strong>. Even though the discussion was about modern 3D computer graphics, most of the games that she mentioned were retro isometric games like <a href="https://en.wikipedia.org/wiki/Ultima_VIII:_Pagan" target="_blank">Ultima VIII</a>, <a href="https://en.wikipedia.org/wiki/SimCity_2000" target="_blank">SimCity 2000</a>, and <a href="https://www.rollercoastertycoon.com/rollercoaster-tycoon-classic/" target="_blank">RollerCoaster Tycoon</a>.</p>
                        <p>I believe most of my readers have a good gut-feeling of what isometric games are. Even if you never played an isometric game before, you&#39;d probably recognize a game that uses an isometric viewpoint.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/simcity-2000.jpg" alt="simcity 2000"/></p>
                        <p>SimCity 2000 was one of the most famous isometric games for the PC</p>
                        <p>Since many of the titles we know and love carry this isometric &#34;look&#34;, I&#39;ve decided to write a short article explaining how isometric projection really works. Once we are done with the basics, we can even go ahead and try to code something simple together. And if you have seen my content before, you know that I&#39;ll definitely try to add some super cool retro nerd history along the way!</p>
                        <p>Alright! Let&#39;s dive in.</p>
                        
                        <h3>3D Projections</h3>
                        <p>Let&#39;s start by understanding where this expression &#34;<strong>isometric</strong>&#34; comes from.</p>
                        <p>When we are programming 3D games, we have to choose how our game will display 3D objects in our 2D screen. This is what we call <i>projection</i>, and there are different types of projection that we can choose from.</p>
                        
                        <h5>Orthographic Projection</h5>
                        <div>
                            <p>I have a feeling that the easiest type of projection for us to understand is called <strong>orthographic projection</strong>. When we choose to use orthographic projection, we simply ignore the <strong>z</strong> components of our original 3D points and project them without considering depth.</p>
                            <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/isometric-cube.jpg" alt="isometric projection" width="150"/></p>
                        </div>
                        <p>In the <i>ortographic</i> projection, it does not matter how far or close the object&#39;s vertices are in 3D, we&#39;ll project them directly onto the 2D screen ignoring their depth. And you might think that this image looks similar to what an isometric tile looks like, but we are still missing some important details for an orthographic projection to be also isometric. But we&#39;ll get there!</p>
                        
                        <h5>Perspective Projection</h5>
                        <div>
                            <p>Another very popular type of projection is called <strong>perspective projection</strong>. Many 3D games use perspective projection because it&#39;s similar to how humans perceive the real world. In this type of projection, vertices that are close to us appear bigger and things that are far away appear smaller.</p>
                            <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/perspective-cube.jpg" alt="perspective projection" width="150"/></p>
                        </div>
                        <p>To achieve the perspective effect, it is common for programmers to use something called &#34;perspective divide&#34;, which is a fancy name for something super simple. In the context of perspective projection, the <i>perspective divide</i> simply means we must divide the original point&#39;s <strong>x</strong> and <strong>y</strong> by their <strong>z</strong> value.</p>
                        <div>
                            <div>
                                
                                
                                <p>\(x_{screen}=\frac{x}{z}\)</p>
                                <p>\(y_{screen}=\frac{y}{z}\)</p>
                            </div>
                        </div>
                        <p>The resulting projected <strong>x</strong> on the screen is equal to the original <strong>x</strong> value divided by the <strong>z</strong> value, and the final projected <strong>y</strong> is equal to the original <strong>y</strong> of the point divided by its <strong>z</strong> value.</p>
                        <div>
                            <p><strong>Inversely proportional relationship</strong>: Look at the <i>perspective divide</i> formula above. Does it make sense to you intuitively? The fraction creates an <i>inversely proportional</i> relationship between the projected screen values of <strong>x</strong> and <strong>y</strong> with the point&#39;s depth.</p>
                            <ul>
                                <li>The bigger the <strong>z</strong>, the <u>more</u> we divide, and the smaller the resulting <strong>x</strong>,<strong>y</strong> is.</li>
                                <li>The smaller the <strong>z</strong>, the <u>less</u> we divide, and the bigger the resulting <strong>x</strong>,<strong>y</strong> is.</li>
                            </ul>
                            <p>Things that are far away appear smaller, and things that are close appear bigger!</p>
                        </div>
                        <p>Right! So, now that we know what projection means and we briefly mentioned the two most popular types of projections in games. Let&#39;s talk about <i>isometric projection</i>.</p>
                        
                        <h5>Isometric Projection</h5>
                        <p>All this discussion about different projections is interesting, but what we really want is to discuss <strong>isometric projection</strong>. Isometric projection is, again, a method for visualizing 3D objects in two dimensions, but when we use proper isometric projection we make the angles between the <strong>x</strong>-axis, <strong>y</strong>-axis, and <strong>z</strong>-axis equal <strong>120</strong> degrees.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/isometric-angles.png" alt="isometric angles" width="600"/></p>
                        <p>In &#34;true&#34; isometric projection, we force a configuration where the angles between x, y, and z axes equal 120°.</p>
                        <p>This angle equality is the main reason for the name: <strong>iso</strong> (equal) <strong>metric</strong> (measurement).</p>
                        <p>As you probably noticed, <i>isometric</i> projection is just a special configuration of the <i>orthographic</i> projection (the one where depth is ignored). This style became super popular in video games, allowing pixel artists to create elaborate environments by placing simple isometric tiles in the scene.</p>
                        <p>Observe how we can have <strong>x</strong> and <strong>y</strong> running along the &#34;floor&#34; of our grid, while <strong>z</strong> usually points up.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/tiles.jpg" alt="isometric tiles" width="500"/></p>
                        
                        <h3>Game Development is a Lie</h3>
                        <p>I want to take a moment to mention something super important before we continue. Since are speaking about different 3D projections, most students naturally think of games with 3D polygons and 3D meshes. In reality, most of the retro isometric games that we played were not really &#34;true&#34; 3D games.</p>
                        <div>
                            <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/tiles-textures.png" alt="isometric tiles" width="250"/></p>
                            <p>Pixel artists would usually create a bunch of 2D tiles that look 3D, but contain <strong>no</strong> polygons or triangles. Our tiles are just a bunch of 2D textures positioned in a way to make our game look 3D, but there is no real-time polygons being processed and no 3D projection math needs to be done via code.</p>
                        </div>
                        <p>This simplification was super important in a time where most machines did not have the horsepower to process real-time 3D polygons and perform fast 3D math. And this was also true for non-isometric games as well. For example, the game <a href="https://en.wikipedia.org/wiki/Donkey_Kong_Country" target="_blank">Donkey Kong Country</a> might have a 3D &#34;feel&#34; to it, but the developers simply pre-rendered the 3D models and “baked” them into 2D sprites.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/donkey-kong-country.gif" alt="donkey kong country" width="150"/></p>
                        <p>Donkey Kong Contry for the SNES used pre-rendered 2D textures.</p>
                        <p>In the case of Donkey Kong Country, the artist used a Silicon Graphics station to create the 3D models, but what we see is only a pre-rendered baked 2D image of that 3D model.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/donkey-kong-sprite.jpg" alt="donkey kong country spritesheet"/></p>
                        <p>2D spritesheet for one of the animations of Donkey Kong Country.</p>
                        <p>And the lies don&#39;t stop here. What if I tell you that most games that we call isometric are not &#34;true&#34; isometric either!? These games are programmed using an angle between the axes that does not equal 120 degrees. Instead, they use 116.57 and 126.87 degrees.</p>
                        <p>This might seem funny at first, but this weird angle configuration gives us tiles with a perfect <strong>2:1</strong> pixel ratio. This makes some trig calculations easier, and also makes things easier for the artist drawing the tiles. All we have to do is ask the artist to create <strong>2:1</strong> tiles. Depending on the game, the tiles can be 100x50, 600x300, 64x32, etc.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/dimetric-angles.png" alt="dimetric projection" width="600"/></p>
                        <p>Remember that tangent is opposite over adjecent. A tangent value of 0.5 confirms that our tile has 2:1 ratio.</p>
                        <p>Look at that! Just a small adjustment in our angles was enough for us to guarantee that our tiles are always 2:1.</p>
                        <div>
                            <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/isometric-lines.png" alt="isometric lines" width="250"/></p>
                            <p>These &#34;pseudo&#34; isometric angles also makes things easier on the machine; especially older ones. A 2:1 ratio can help us render pixelated lines more precisely. Using this angle configuration, for every two pixels we move horizontally, we move exactly one pixel vertically. On the other hand, if we are using &#34;true&#34; isometric angles, for every two pixels we moved horizontally, we need to move 1.732 pixels vertically. Yikes! Ugly lines.</p>
                        </div>
                        <p>All these details might seem a bit pointless to modern developers, given that now we have powerful anti-aliasing algorithms and processors that can perform extremely fast math. But if you ever developed games for older CPUs, you know that integers are always preferred over floating-point numbers.</p>
                        <p>Speaking of older machines, if we choose a 2:1 pixel ratio, many of the computations could be achieved by simply multiplying or dividing things by 2. And if you ever took my course on <a href="https://pikuma.com/courses/bit-shifting-operator-tutorial" target="_blank">Bit-shifting Operations</a>, you know that older CPUs can achieve super fast multiplication or division by 2 using a single CPU instruction that shifts bits right or left.</p>
                        <p>There we go! Just by tilting our angles by a small amount, we end up with a nice 2:1 tile ratio, and that simplifies things a lot. Back then, it was all about finding simplifications to reduce the number of clock cycles per game frame.</p>
                        <div>
                            <p><strong>Fun fact</strong>: This projection that has a tile ratio of 2:1 and has two angles equal and one different is called <strong>dimetric</strong>. Following the same logic, a projection has three different angles is called <strong>trimetric</strong>. All these projections fall under the unbrella of something called <strong>axonometric projections</strong>.</p>
                            <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/axonometric.png" alt="axonometric projetion" width="600"/></p>
                        </div>
                        <p>I&#39;ll bet you will never need to use the terms <i>dimetric</i> or <i>trimetric</i> as a game programmer. That being said, I used to code CAD systems for architects and engineers and these projection names appeared a lot during our meetings.</p>
                        <blockquote>&#34;But Gustavo... does that mean all isometric games I ever played were just 2D textures positioned in a way that made them look 3D?&#34;</blockquote>
                        <p>No! Absolutely not. We can find modern &#34;isometric&#34; games that are <strong>true</strong> 3D games. They have real 3D polygons and real 3D animations. It just happens that the developers chose to position the camera in a way that gives them an isometric look.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/league-of-legends.jpg" alt="league of legends" width="600"/></p>
                        <p><a href="https://www.leagueoflegends.com/" target="_blank">League of Legends</a> is an example of a proper 3D game that some people call isometric.</p>
                        <p>If you are a beginner developer and you&#39;re using a game engine like <a href="https://unity.com/" target="_blank">Unity</a> or <a href="https://www.unrealengine.com/" target="_blank">Unreal</a>, you can achieve this effect by simply choosing an orthographic view and placing your camera in the exact position that makes your game look isometric. It might seem too easy, but many isometric games do just that.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/echochrome.gif" alt="echochrome" width="300"/></p>
                        <p><a href="https://en.wikipedia.org/wiki/Echochrome" target="_blank">Echochrome</a> is isometric, but every now and then the camera rotates with some interesting results.</p>
                        <p>Some examples of 3D games that use an isometric viewpoint are <a href="https://www.leagueoflegends.com/" target="_blank">League of Legends</a>, <a href="https://en.wikipedia.org/wiki/Diablo_II:_Resurrected" target="_blank">Diablo II: Resurrected</a>, <a href="https://en.wikipedia.org/wiki/The_Ascent_(video_game)" target="_blank">The Ascent</a>, <a href="https://en.wikipedia.org/wiki/Echochrome" target="_blank">Echochrome</a>, and <a href="https://en.wikipedia.org/wiki/Monument_Valley_(video_game)" target="_blank">Monument Valley</a>. Echrochrome and Monument Valley are worth mentioning because they explore the &#34;lack of depth&#34; of the orthographic projection to create some interesting puzzles.</p>

                        <h3>Coding an Isometric Grid of Tiles</h3>
                        <p>I think we covered some interesting ideas behind isometric-looking games. Let&#39;s see if we can code a very simple isometric map of tiles on our screen.</p>
                        <p>I&#39;ll use JavaScript and the P5js graphics library for this example, but everyting we&#39;ll learn should be agnostic to the technology you choose. You can use any other programming language or graphics framework to achieve similar results.</p>
                        <p><strong>Coding along</strong>: If you want to follow along, a great option is the <a href="https://editor.p5js.org/" target="_blank">P5js Web Editor</a>. This is an online coding environment that comes with P5js already configured. You can find the ZIP file with the initial code and images of our P5js project <a href="https://pikuma.com/files/blog/isometric-projection-in-games/isometric-project-p5js.zip" target="_blank">here</a>.</p>
                        <p>To start, let&#39;s define that the tiles in our isometric grid are 100 pixels by 50 pixels.</p>
<pre><code>const TILE_WIDTH = 100;
const TILE_HEIGHT = 50;</code></pre>
                        <p>The next step is to load an array with our tile images. I&#39;ll use a special P5js function to read three PNG files.</p>
                        <p>If you&#39;re using something other than JavaScript, here is where you&#39;ll need to use a graphics framework to load and render PNG files. Some examples are SDL for C, SFML for C++, and PyGame for Python.</p>
                        <p>It&#39;s incredibly easy to load PNG files with P5js:</p>
<pre><code>let tile_images = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  tile_images.push(loadImage(&#39;./tiles/grass.png&#39;));
  tile_images.push(loadImage(&#39;./tiles/sand.png&#39;));
  tile_images.push(loadImage(&#39;./tiles/water.png&#39;));
}</code></pre>
                        <p>The <strong>setup</strong>() function is the first thing to be executed by our P5js code. So, before we do anything, we create a blank canvas that fills the entire browser window and proceed to load three PNG files into an array of image objects to be used later.</p>
                        <p>Now that we have the array of tile images, let&#39;s start thinking about how we can draw our first tile on the screen.</p>
                        <p>Let&#39;s create a <strong>draw</strong>() function. This is a special P5js function that is executed several times per second and it&#39;s used to draw objects on the screen. For now, let&#39;s simply invoke the function <strong>image</strong>() from P5js to draw the first tile image that we have inside our array.</p>
<pre><code>function draw() {
  background(&#34;black&#34;);
  image(tile_images[0], width/2, 50);
}</code></pre>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/first-tile.png" alt="isometric tile" width="450"/></p>
                        <p>We can see that we have our first &#34;grass&#34; tile being displayed <i>somewhat</i> in the middle of the canvas. We used a special variable from P5js called <strong>width</strong> that has the width of the HTML canvas we are working with.</p>
                        <p>But that&#39;s not really the middle, is it? In our code, we told the function <strong>image</strong>() to display our tile image at position <strong>width/2</strong> pixels to the right and <strong>50</strong> pixels down. We&#39;ll probably need to account for the tile size and offset our <strong>x</strong> position to the left.</p>
                        <p>Let&#39;s subtract half of our tile width from the <strong>x</strong> position. We should now have a tile that is perfectly centered in the middle of our canvas width.</p>
<pre><code>image(tile_images[0], width/2 - TILE_WIDTH/2, 50);</code></pre>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/centered-tile.png" alt="isometric tile" width="450"/></p>
                        <p>That&#39;s more like it!</p>
                        <p>Great. So, now we have found a way of calculating the start position of our first top tile. This is super important because the position of every other tile in our grid will be based on this start <strong>x</strong> and <strong>y</strong> position. All we need now is to come up with a formula to find how much we need to offset horizontally and vertically to draw each one of the other tiles.</p>

                        <h3>Isometric Grid-Cell Units</h3>
                        <p>Now that we have a small project that knows how to load and display images on the screen, let&#39;s think about the math we need to correctly position our isometric tiles.</p>
                        <p>First, we need to define how we keep track of tile numbers. One common approach is to define tiles by <i>grid units</i>. This means we won&#39;t speak of tiles in pixels anymore, like 400 pixels or 160 pixels. Instead, we&#39;ll speak of tiles as positions on &#34;grid cells.&#34;</p>
                        <p>Most isometric games use <strong>x</strong> and <strong>y</strong> as cell-units running along the grid &#34;floor.&#34; In our implementation, we&#39;ll start at the top and increase <strong>x</strong> as we move to the right and increase <strong>y</strong> as we move down.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/map-cells.jpg" alt="isometric grid cells" width="600"/></p>
                        <p>Our goal here is to create a function called <strong>draw_tile</strong>() that receives the cell number <strong>x</strong> and the cell number <strong>y</strong> we want to render a tile. For example, the tiles above are rendered using the following <strong>x</strong> and <strong>y</strong> indices:</p>
<pre><code>draw_tile(4, 1);
draw_tile(5, 1);</code></pre>
                        <p>Let&#39;s go ahead and refactor our code to add a <strong>draw_tile</strong>() function that receives the image we want to render and the grid-cell values of <strong>x</strong> and <strong>y</strong>.</p>
<pre><code>function draw_tile(img, x, y) {
  let x_screen = /* todo: calculate x value in pixels */
  let y_screen = /* todo: calculate y value in pixels */
  image(img, x_screen, y_screen);
}

function draw() {
  background(&#34;black&#34;);
  draw_tile(tile_images[0], 0, 0);
  draw_tile(tile_images[0], 1, 0);
  draw_tile(tile_images[0], 2, 0);
}</code></pre>
                        
                        <h3>Calculating Tile Screen Coordinates</h3>
                        <p>Let&#39;s go ahead and find a formula to compute the correct <strong>x_screen</strong> and <strong>y_screen</strong> values based on the grid-cell values <strong>x</strong> and <strong>y</strong> that we received via parameter.</p>
                        <p>Let&#39;s assume we want to find the screen pixel value where we should draw the tile (<strong>2</strong>,<strong>0</strong>).</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/x-x-position.png" alt="isometric grid cells" width="550"/></p>
                        <p>As the values of <strong>x</strong> in the grid grow (1, 2, 3, etc.), we need to offset the <strong>x_screen</strong> to the right. Do you agree?</p>
                        <p>But <i>how much</i> to the right? If we look at the illustration above, we can see that for every tile unit we need to move <strong>TILE_WIDTH/2</strong> times to the right.</p>
                        <p>So, the formula that tells us the position <strong>x_screen</strong> in pixels as the value of <strong>x</strong> increases is:</p>
                        <p>\( x_{screen} = x_{start} + x\left( \frac{TILE\_WIDTH}{2} \right) \)</p>
                        <p><strong>Math notation</strong>: I want you to pause for a second and really look at the formula above. Make sure you understand where the variables are coming from and how the values change depending on the grid-cell <strong>x</strong> value that we pass as parameter. I want my students to feel comfortable reading this type of math notation. Many great books and articles use this notation, and we&#39;ll see other formulas like this one very soon.</p>
                        <p>Let&#39;s go ahead and also think about what happens to the value of <strong>y_screen</strong> as the cell values of <strong>x</strong> grow in the grid.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/x-y-position.png" alt="isometric grid cells" width="550"/></p>
                        <p>As the values of <strong>x</strong> grow in the grid (1, 2, 3, etc.), we need to move <strong>y_screen</strong> down. But in this case, we need to move down by <strong>TILE_HEIGHT/2</strong> pixels each time.</p>
                        <p>So, the formula that tells us the position <strong>y_screen</strong> in pixels as <strong>x</strong> grows is:</p>
                        <p>\( y_{screen} = y_{start} + x\left( \frac{TILE\_HEIGHT}{2} \right) \)</p>
                        <p>Let&#39;s put everything together and translate what we have so far into code.</p>
<pre><code>let x_start = width/2 - TILE_WIDTH/2;
let y_start = 50;
    
function draw_tile(img, x, y) {
  let x_screen = x_start + x * TILE_WIDTH/2;
  let y_screen = y_start + x * TILE_HEIGHT/2;
  image(img, x_screen, y_screen);
}

function draw() {
  background(&#34;black&#34;);
  draw_tile(tile_images[0], 0, 0);
  draw_tile(tile_images[0], 1, 0);
  draw_tile(tile_images[0], 2, 0);
}</code></pre>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/tiles-x-increase.png" alt="isometric tiles" width="450"/></p>
                        <p>Beautiful! That looks good. As our <strong>x</strong> values grow in the grid, we are correctly converting our tiles from isometric grid coordinates to screen coordinates.</p>
                        <p>But we are still not done! We still need to account for the values of <strong>y</strong> in the grid. So, let&#39;s look at the illustration and try to find out what happens to <strong>x_screen</strong> and <strong>y_screen</strong> as the grid-cell value of <strong>y</strong> grows.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/y-xy-position.png" alt="isometric grid cells" width="550"/></p>
                        <div>
                            <div>
                                <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/notebook.png" alt="gamedev math" width="150"/></p>
                                <p><strong>Over to you</strong>: Before I show you the solution, stop for a moment and try to come up with the final formula yourself. Trust me; it&#39;s a lot more satisfying when we find the pattern ourselves.</p>
                            </div>
                        </div>
                        <p>As we can see from the image above, when <strong>y</strong> cell values grow in the grid (1, 2, 3, etc.), we need to move <strong>left</strong> horizontally, and <strong>down</strong> vertically on the screen. Once again, the offset is done by <strong>TILE_WIDTH/2</strong> and <strong>TILE_HEIGHT/2</strong> each time.</p>
                        <p>So, let&#39;s think about this. If growing the values of <strong>y</strong> makes us move left in <strong>x_screen</strong>, we probably need to subtract it from what we had before.</p>
                        <p>\( x_{screen} = x_{start} + x\left( \frac{TILE\_WIDTH}{2} \right) - y\left( \frac{TILE\_WIDTH}{2} \right) \)</p>
                        <p>And, if growing the values of <strong>y</strong> makes us move down in <strong>y_screen</strong>, let&#39;s go ahead and add it to what we had in the previous formula.</p>
                        <p>\( y_{screen} = y_{start} + x\left( \frac{TILE\_HEIGHT}{2} \right) + y\left( \frac{TILE\_HEIGHT}{2} \right) \)</p>
                        <p>And that&#39;s it! These are the formulas to find the <strong>x_screen</strong> and <strong>y_screen</strong> position based on the isometric grid <strong>x</strong> and <strong>y</strong> cell values.</p>
                        <p>Hopefully, you also agree that we can rewrite these formulas to group <strong>x</strong> and <strong>y</strong> together:</p>
                        <div>
                            <p>\( x_{screen} = x_{start} + (x-y) \left( \frac{TILE\_WIDTH}{2} \right) \)</p>
                            <p>\( y_{screen} = y_{start} + (x+y) \left( \frac{TILE\_HEIGHT}{2} \right) \)</p>
                        </div>
                        <p>Let&#39;s translate this into code and see if our mapping is working.</p>
<pre><code>function draw_tile(img, x, y) {
  let x_screen = x_start + (x - y) * TILE_WIDTH/2;
  let y_screen = y_start + (x + y) * TILE_HEIGHT/2;
  image(img, x_screen, y_screen);
}

function draw() {
  background(&#34;black&#34;);
  draw_tile(tile_images[0], 0, 0);
  draw_tile(tile_images[0], 1, 0);
  draw_tile(tile_images[0], 2, 0);
  draw_tile(tile_images[0], 0, 1);
  draw_tile(tile_images[0], 1, 1);
  draw_tile(tile_images[0], 2, 1);
  draw_tile(tile_images[0], 0, 2);
  draw_tile(tile_images[0], 1, 2);
  draw_tile(tile_images[0], 2, 2);
}</code></pre>
                        <p>Fingers crossed...</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/tiles-xy-increase.png" alt="isometric grid cells" width="550"/></p>
                        <p>Look at that! A beautiful isometric grid of tiles being correctly mapped from grid-cell coordinates into screen-pixel coordinates.</p>
                        
                        <h3>Array of Tiles</h3>
                        <p>I think the hard part is done. Let&#39;s just go ahead and use a 10x10 array to store the tiles of our isometric grid in memory. I&#39;ll also go ahead and create a new function that loops and renders all the grid tiles.</p>
<pre><code>const GRID_SIZE = 10;

let grid = [
  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
  [2, 0, 0, 0, 0, 0, 0, 0, 0, 2],
  [2, 0, 0, 0, 0, 0, 0, 0, 0, 2],
  [2, 0, 0, 0, 0, 0, 0, 0, 0, 2],
  [2, 0, 0, 1, 0, 0, 0, 0, 0, 2],
  [2, 0, 0, 1, 0, 0, 0, 0, 0, 2],
  [2, 0, 0, 0, 0, 0, 0, 0, 0, 2],
  [2, 0, 0, 0, 0, 0, 0, 1, 0, 2],
  [2, 0, 0, 0, 0, 0, 0, 0, 0, 2],
  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
];

function setup() {
  createCanvas(windowWidth, windowHeight);
  tile_images.push(loadImage(&#39;./tiles/grass.png&#39;));
  tile_images.push(loadImage(&#39;./tiles/sand.png&#39;));
  tile_images.push(loadImage(&#39;./tiles/water.png&#39;));
}

function draw_tile(img, x, y) {
  let x_screen = x_start + (x - y) * TILE_WIDTH/2;
  let y_screen = y_start + (x + y) * TILE_HEIGHT/2;
  image(img, x_screen, y_screen);
}

function draw_grid() {
  x_start = width/2 - TILE_WIDTH/2;
  y_start = 50;
  
  for (let i = 0; i &lt; GRID_SIZE; i++) {
    for (let j = 0; j &lt; GRID_SIZE; j++) {
      draw_tile(tile_images[grid[j][i]], i, j);
    }
  }
}

function draw() {
  background(&#34;black&#34;);
  draw_grid();
}</code></pre>
                        <p>As you can see, the function <strong>draw_grid</strong>() defines the start position of the first top tile, and proceeds to loop all cells of our grid array.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/tiles-grid.png" alt="isometric grid cells"/></p>
                        <p>Perfect!</p>
                        <blockquote>&#34;Okay, but what about the order of the tiles? Do we need to do anything to prevent tiles from being rendered in front of others?&#34;</blockquote>
                        <p>That&#39;s a great question! The reason all our tiles are being displayed correctly is because of how we are looping our array. We draw all the tiles in the first row, then proceed to the second row, then third row, etc. The two nested <i>for-loops</i> we&#39;re using guarantee that all tiles will be rendered &#34;from back to front.&#34;</p>
<pre><code>/* Loop all tiles (from back to front) */
for (let i = 0; i &lt; GRID_SIZE; i++) {
  for (let j = 0; j &lt; GRID_SIZE; j++) {
    draw_tile(tile_images[grid[j][i]], i, j);
  }
}</code></pre>
                        <p>This was no accident. Most isometric games do just that!</p>
                        <div>
                            <div>
                                <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/painter.png" alt="painters algorithm" width="150"/></p>
                                <p>This is an example of the <strong>painter&#39;s algorithm</strong> in action. Our code loops all objects in the correct order, &#34;painting&#34; them from back to front. This makes sure objects that are in front are rendered after (and on top of) the ones that are in the back.</p>
                            </div>
                        </div>
                        
                        <h3>Exploring the Z-Axis</h3>
                        <p>The last thing I want to address is that isometric games can also explore the <strong>z</strong>-axis (up) to achieve interesting effects.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/isometric-sine.jpg" alt="isometric sine cosine"/></p>
                        <p>To create the image above we can use <strong>sin</strong>(y)+<strong>cos</strong>(x) to programatically offset the blocks up and down.</p>
                        <p>One of the great things we can do with this vertical offset is that we can now address tiles of different height.</p>
                        <p>The public-domain set of tile images that I got from <a href="https://www.kenney.nl/assets/3d-road-tiles" target="_blank">Kenney</a> has some tiles that are taller than others. We&#39;ll need to offset them accordinly.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/kenney-tiles.png" alt="kenney isometric tiles" width="550"/></p>
                        <p>You can download the ZIP file with all the PNG files I&#39;m using <a href="https://pikuma.com/files/blog/isometric-projection-in-games/tiles.zip" target="_blank"><strong>here</strong></a>.</p>
                        <p>Let&#39;s load all the new 34 tile images with a for loop.</p>
<pre><code>let grid = [
  [14, 23, 23, 23, 23, 23, 23, 23, 23, 13],
  [21, 32, 33, 33, 28, 33, 28, 33, 31, 20],
  [21, 34,  0,  0, 25, 33, 30,  1, 34, 20],
  [21, 34,  0,  0, 34,  1,  1, 10, 34, 20],
  [21, 25, 33, 33, 24, 33, 33, 33, 27, 20],
  [21, 34,  4,  7, 34, 18, 17, 10, 34, 20],
  [21, 34,  4,  7, 34, 16, 19, 10, 34, 20],
  [21, 34,  6,  8, 34, 10, 10, 10, 34, 20],
  [21, 29, 33, 33, 26, 33, 33, 33, 30, 20],
  [11, 22, 22, 22, 22, 22, 22, 22, 22, 12]
];

function setup() {
  createCanvas(windowWidth, windowHeight);
  for (let i = 0; i &lt;= 34; i++) {
    tile_images.push(loadImage(&#39;./tiles/tile-&#39;+i+&#34;.png&#34;));
  }
}</code></pre>
                        <p>Now it&#39;s just a matter of defining what is our maximum possible tile height we can have, and push the tiles up or down based on how tall each tile image really is:</p>
<pre><code>const MAX_TILE_HEIGHT = 80;

function draw_tile(img, x, y) {
  let x_screen = x_start + (x - y) * TILE_WIDTH/2;
  let y_screen = y_start + (x + y) * TILE_HEIGHT/2;

  let z_offset = MAX_TILE_HEIGHT - img.height;
  
  image(img, x_screen, y_screen + z_offset);
}</code></pre>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/tiles-height.png" alt="isometric grid cells"/></p>
                        <p>Well done! Let&#39;s call it a day.</p>
                        <p>If you want, you can find the final version of our code <a href="https://pikuma.com/files/blog/isometric-projection-in-games/isometric-project-p5js-final.zip" target="_blank">here</a>.</p>
                        
                        <h3>Isometric Coordinates as Linear Transformations</h3>
                        <p>As you can see, isometric games can be a great sandbox for us to play around with some very basic coding ideas, and the math behind converting grid coordinates into screen coordinates is relatively simple.</p>
                        <p>It&#39;s worth mentioning that I have seen books and articles describe isometric coordinates as <a href="https://youtu.be/04oQ2jOUjkU" target="_blank">linear transformations</a>. We can think of a transformation that distorts the original grid skewing the original rectangular grid into an isometric result.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/linear-transformation.png" alt="linear transformation isometric" width="500"/></p>
                        <p>We can distort the original coordinate system using linear transformations.</p>
                        <p>Such transformations can be represented using matrix multiplication, where we multiply <strong>x</strong> and <strong>y</strong> by the entries that perform the desired isometric distortion. In the example below, <strong>Tw</strong> and <strong>Th</strong> are the tile&#39;s width and height.</p>
                        <p>\( x \begin{pmatrix} 0.5 * T_w \\ 0.25 * T_h \end{pmatrix} + y \begin{pmatrix} -0.5 * T_w \\ 0.25 * T_h \end{pmatrix} \)</p>
                        <p><a href="https://twitter.com/jordwest" target="_blank">Jordan West</a> created an animation that helps us visualize this isometric transformation:</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/linear-transformation.gif" alt="linear transformation isometric"/></p>
                        <p>One of the advantages of thinking in terms of linear transformations is that we could use mathematical tools to find the inverse of a transformation. Let&#39;s say, for example, that we want to select the tile that is under our mouse cursor. We need to find a way of going the other way around (going from screen space to grid space). We can achieve this <strong>undo</strong> operation by computing the <a href="https://www.cuemath.com/algebra/inverse-of-a-matrix/" target="_blank">inverse matrix</a> of our last transformation.</p>
                        <p><strong>Seeing beyond the matrix</strong>: This is super great and all, but at the end of the day it&#39;s just a generalization of what we were already doing. I want my students to always see beyond the matrix! All these &#34;linear transformations&#34; are basically just a fancy way of representing the same multiplications and additions that we were doing before.</p>
                        <p>If you ever took a course with me, you know that I love math and I always encourage my students to get comfortable with math rigour. But, if there&#39;s one thing I learned from retro game programming is that sometimes the way math approaches problems goes against the way we should think of solving problems with a digital machine. At the end of the day, retro programming is about finding ways to cheat using code and finding simplifications that allow us to push fast pixels to the screen. Always keep things as simple as possible.</p>

                        <h3>Famous Isometric Games</h3>
                        <p>I&#39;ve spent many hours playing isometric games in the past and some of them are very dear to my heart. Games like <a href="https://en.wikipedia.org/wiki/Populous_(video_game)" target="_blank">Populous</a>, <a href="https://en.wikipedia.org/wiki/Marble_Madness" target="_blank">Marble Madness</a>, <a href="https://en.wikipedia.org/wiki/Age_of_Empires" target="_blank">Age of Empires</a>, <a href="https://en.wikipedia.org/wiki/SimCity_2000" target="_blank">SimCity 2000</a>, and <a href="https://en.wikipedia.org/wiki/Q*bert" target="_blank">Q*Bert</a> are just some examples of titles that I remember playing.</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/tanks-of-freedom.jpg" alt="tanks of freedom" width="500"/></p>
                        <p><a href="https://tof.p1x.in/" target="_blank">Tanks of Freedom</a> is open source and it&#39;s where the thumbnail of this blog post comes from.</p>
                        <p>One of my all time favorites is definitely <a href="https://en.wikipedia.org/wiki/RollerCoaster_Tycoon" target="_blank">RollerCoaster Tycoon</a>, written by <a href="http://www.chrissawyergames.com/" target="_blank">Chris Sawyer</a>. Chris is one of the most famous developers in the world of isometric games. He coded both <a href="https://en.wikipedia.org/wiki/Transport_Tycoon" target="_blank">Transport Tycoon</a> and <a href="https://en.wikipedia.org/wiki/RollerCoaster_Tycoon" target="_blank">RollerCoaster Tycoon</a> using x86 assembly language.</p>
                        <p>Chris Sawyer started programming 8-bit games for the <a href="https://en.wikipedia.org/wiki/Memotech_MTX" target="_blank">Memotech MTX computer</a>. He used raw Z80 assembly to get some performance out of Memotech&#39;s 4 MHz CPU. After many games developed for the Memotech, Chris managed to get an <a href="https://en.wikipedia.org/wiki/PC1512" target="_blank">Amstrad 1512</a>. This is the start of his journey programming assembly for the Intel x86 CPU.</p>
                        <p>While the PC market was targeting mostly business applications, competitors like the <a href="https://en.wikipedia.org/wiki/Amiga" target="_blank">Amiga</a> and the <a href="https://en.wikipedia.org/wiki/Atari_ST" target="_blank">Atari ST</a> ruled the gaming market with colorful palettes and dedicated graphics chips. As the PC became more powerful, Chris developed a reputation for being an <i>expert</i> in x86 assembly. He helped port many (many!) games for the PC, like <a href="https://en.wikipedia.org/wiki/Zarch" target="_blank">Virus</a>, <a href="https://en.wikipedia.org/wiki/Dino_Dini%27s_Goal" target="_blank">Dino Dini&#39;s Goal</a>, and <a href="https://en.wikipedia.org/wiki/Frontier:_Elite_II" target="_blank">Frontier Elite II</a>.</p>
                        <p>One of the big games developed by Chris Sawyer was, of course, RollerCoaster Tycoon. Roller coasters were always a personal passion for Chris, and the game added physics simulation on top of the existing Transport Tycoon experience. To understand the level of detail and speed that Chris managed to squeeze using assembly, one of the levels of RollerCoaster Tycoon 2 was able to handle 4,500 guests on a single park!</p>
                        <p><img src="https://pikuma.com/images/blog/isometric-projection-in-games/roller-coaster-tycoon.jpg" alt="roller coaster tycoon" width="500"/></p>
                        <p>RollerCoaster Tycoon 2 was written by Chris Sawyer and used x86 assembly to push fast pixels on the screen.</p>
                        <p>This was a time where most other developers were already programming their games using high-level languages like C and C++. Chris&#39; familiarity with assembly allowed him to push the limits of the 200 MHz CPUs of the time, as well as taking advantage of 640x480 VGA resolution by only changing the absolute minimum required per frame.</p>
                        <p>Chris was a monster x86 programmer, and what he achieved with these games is nothing short of amazing. I thought it was important to add a little bit of his history in an article about isometric games.</p>

                        <h3>Conclusion and Moving Forward</h3>
                        <p>Hopefully, you enjoyed this short trip into the world of isometric games. I always have fun discussing these topics.</p>
                        <p>I believe this article can be the starting point for more advanced isometric projects that you might have in mind. Of course, this is just the bare minimum for us to start entering the isometric mindset; things can get pretty hairy as we add more functionality to our isometric game (movement, physics, animation, etc.)</p>
                        <p>I wanted this to be a super beginner-friendly article, and I think we covered the absolute basics of how isometric projection works and even coded a very small isometric tilemap using a simple scripting language.</p>
                        <div>
                            <p>And since we are speaking of 3D games, I wanted to mention that I have an online course on <a href="https://pikuma.com/courses/learn-3d-computer-graphics-programming" target="_blank">3D Graphics Programming</a>. If you enjoy the topic of retro game programming, then I&#39;m positive you&#39;ll like the lectures. Many concepts that we just covered in this article have everything to do with the topics of this course. Check it out!</p>
                            <p><a href="https://pikuma.com/courses/learn-3d-computer-graphics-programming" target="_blank"><img src="https://pikuma.com/images/blog/isometric-projection-in-games/3d-box.jpg" alt="3d graphics programming" width="200"/></a></p>
                        </div>
                        
                        <p>If I forgot to mention your favorite game or if you have any suggestions for this article, you can follow me on <a href="https://twitter.com/PikumaLondon" target="_blank">Twitter</a> and send me an angry message. But if you learned at least one interesting thing reading this article, then I guess the whole journey was worth it.</p>
                        <p>See you soon!</p>
                        <hr/>   
                        
                    </div></div>
  </body>
</html>
