<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://westling.dev/b/extremely-linear-git">Original</a>
    <h1>Extremely Linear Git History</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div>



<p>One of the things that I like to do in my projects, is to make the git history as linear as
	possible.
</p>

<p>Usually this means to rebase commits onto the main branch, but it can also mean to only allow
	merges in one direction, from feature branches into main, never the other way around. It kind of depends on the project.
</p>

<p>Today I&#39;m taking this one step further, and I&#39;m introducing a new concept: <strong>extremely linear git history</strong>.
</p>
<p>With our extremely linear history, the first commit in a repo hash a hash that starts with <code>0000000</code>, the second commit is
	<code>0000001</code>, the third is <code>0000002</code>, and so on!
</p>

<p>Incremental version numbers makes it easy to talk about revisions. You immediately know that
	version 230 comes after 200, and if you create 10 new versions per day, it&#39;s easy to have an
	intuition for how old a commit is based on your current latest version.
</p>

<p><img src="https://westling.dev/_app/immutable/assets/github-d61ec626.png" alt="Extremely Linear Git History"/>
	<i>Extremely Linear Git History (<a href="https://github.com/sturdy-dev/marblezero/commits/main">on GitHub</a>)</i></p>

<h2>Backstory</h2>

<p>In git, commits are reffered to by the <code>SHA‑1</code> sum of the commit object itself. We can
	inspect a raw commit object using <code>git cat-file</code> and verify it&#39;s hash by reading it from
	disk (compressed with zlib), and testing the checksum. The resulting checksum should always the same as
	the file name.
</p>

<pre>$ git cat-file commit d9ef231178b5004c17fe4e4e1807728567a69b84
tree 2ccda48edc8ed3a96ac7576c57a5d645de2396f6
parent ad877a8e0240bdec6757781fdc3f2b45b8ced7a2
author Gustav Westling &lt;gustav@westling.dev&gt; 1669040942 +0100
committer Gustav Westling &lt;gustav@westling.dev&gt; 1669040995 +0100

blog: start working on a blogpost for extremely linear git history
</pre>

<pre>$ pigz -d &lt; .git/objects/d9/ef231178b5004c17fe4e4e1807728567a69b84 | sha1sum
d9ef231178b5004c17fe4e4e1807728567a69b84  -
</pre>

<p>The message of the commit comes last in the object, and is easily modifiable. To change the
	checksum of the object, we can append junk data to the commit message. We just don&#39;t know what the junk payload is.
</p>

<h2>Crunching the numbers</h2>

<p>There is no way to easily create content with the desired prefix (that would prevent the whole
	point of checksums). So we only have one option: testing many combinations of junk data until we
	can find one that passes our criteria. It&#39;s basically the same mechanism that powers Bitcoin and
	other proof-of-work systems. In this case I guess it could be called &#34;proof-of-work, for your
	work&#34;. Or &#34;proof-of-proof-of-work-work&#34;? Heh.
</p>

<p>I&#39;ve been doing the commit message crunching using <a href="https://github.com/Mattias-/githashcrash">githashcrash</a> by Mattias Appelgren.
</p>

<p>On my macbook, I&#39;m able to generate and test ~15 million hashes per second. Since we&#39;re looking
	for an input that creates an predefined 8 character prefix, I should get a hit every <code>16^8 =&gt; 4 294 967 296</code> iterations, about once every 5 minutes on average! You can make this process faster by using shorter
	prefixes, a 6 character prefix takes only 1 second to generate (but it doesn&#39;t look as nice in some
	Git UIs, and since this is a project that prioritizes form over function, I&#39;m willing to waste more CPU cycles).
</p>

<p>For the commit example above, we can use githashcrash to find junk data that changes the commit prefix
	to be whatever we want, like <code>00000000</code>. After a some crunching,
	githashcrash finds that we can append <code>magic: MTQIpN2AmwQA</code> to our commit message to create
	our desired hash! Aaaah, it&#39;s glorious!
</p>

<pre>2022/11/21 15:56:04 Time: 12m19.962437166s
2022/11/21 15:56:04 Tested: 1.0845869819e+10
2022/11/21 15:56:04 14.66 MH/s
2022/11/21 15:56:04 Found: <strong>00000000</strong>508749e5231fa5b43efcf7ac31385058
</pre>

<pre>$ git cat-file commit <strong>00000000</strong>508749e5231fa5b43efcf7ac31385058
tree 2ccda48edc8ed3a96ac7576c57a5d645de2396f6
parent ad877a8e0240bdec6757781fdc3f2b45b8ced7a2
author Gustav Westling &lt;gustav@westling.dev&gt; 1669040942 +0100
committer Gustav Westling &lt;gustav@westling.dev&gt; 1669041794 +0100

blog: start working on a blogpost for extremely linear git history

magic: MTQIpN2AmwQA
</pre>

<h2>Automating</h2>

<p>With some <a href="https://github.com/zegl/extremely-linear">bash-glue</a> we can automate this
	process, and <em>extremely</em>-linearize your branches in one single command. To test it out
	(please don&#39;t), install with <code>brew install zegl/tap/git-linearize</code> and in any
	repository run <code>git linearize</code> to <em>&#34;fix&#34;</em> it!
</p>

<p>I&#39;ve converted a recent <a href="https://github.com/sturdy-dev/marblezero">toy project</a> of mine to use this format of prefixes, and honestly, it looks really neat!
</p>

<h2>Appendinx: leet haxor prefixes</h2>

<ul><li>Prefix all commits with &#34;C0DE&#34; — <code>git linearize --format &#34;c0de&#34;</code></li>
    <li>Full collision (entire hash is zeros, then 000...1, etc.) — <code>git linearize --format &#34;%040d&#34;</code> (takes ~10<sup>33</sup> years to run per commit)</li></ul>

<h2>Update: GPU-powered invisible hash crashing</h2>

<p>git-linearize now uses <a href="https://github.com/not-an-aardvark/lucky-commit">lucky-commit</a> as it&#39;s hash generation backend.
	It&#39;s using your GPU for generating hashes, and is about 20x faster than the CPU based implementation. Wow!
	<code>lucky-commit</code> also cleverly uses only invisible whitespace characters for padding the commit messages. </p>

<hr/>

<p>By <a href="https://twitter.com/zegl">Gustav Westling</a>,</p></div></div></div></div></div>
  </body>
</html>
