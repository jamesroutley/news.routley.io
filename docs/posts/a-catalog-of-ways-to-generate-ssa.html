<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bernsteinbear.com/blog/ssa/?utm_source=rss">Original</a>
    <h1>A catalog of ways to generate SSA</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>Static Single Assignment is a program representation where each “variable”
(though this term can be misleading) is assigned exactly once. Mostly the
variables aren’t variables at all, but instead names for values—for
expressions. SSA is used a lot in compilers. I’m making this page to catalog
the papers I have found interesting and leave a couple of comments on them.</p>

<h2 id="a-brief-bit-of-background">A brief bit of background</h2>

<p>It comes from the 1980s. Wikipedia claims the first paper about it (though not
by the name SSA) was <a href="https://bernsteinbear.com/assets/img/zadeck-code-motion.pdf">Code
Motion of Control Structures in High Level
Languages</a> (PDF), which I had not seen
before today. There was also <a href="https://bernsteinbear.com/assets/img/zadeck-gvn.pdf">Global Value Numbers and Redundant
Computations</a> (PDF), which I had also not seen
before today.</p>

<p>If you’re confused about what a phi function is: they are annotations that join
dataflow edges from predecessor blocks into new variables. It’s not a real
function, it doesn’t (directly) generate any code, and it needs to be handled
differently than other instructions in your IR.</p>

<h2 id="lets-generate-some-variables">Let’s generate some variables</h2>

<p>Finally, in 1991, the same group produced the first SSA paper I was already
familiar with: <a href="https://bernsteinbear.com/assets/img/cytron-ssa.pdf">The Cytron Paper</a> (PDF). This
approach requires computing dominance frontiers for an existing control-flow
graph, which may or may not be useful or applicable in your situation. If you
have bytecode, this might be workable, but you’ll need to <a href="https://bernsteinbear.com/blog/discovering-basic-blocks/">“discover” the basic
blocks</a> hiding within. It’s also a notable
paper because it produces the minimal amount of phi instructions.</p>

<p>In 1994, Brandis and Mössenböck write <a href="https://bernsteinbear.com/assets/img/brandis-single-pass.pdf">Single-Pass Generation of Static
Single-Assignment Form for Structured
Languages</a> (PDF). This is a neat approach
because it shows that you don’t need to do Fancy Algorithms or Fancy Data
Structures to get SSA—you can build it as soon as during parsing, something I
have taken to doing recently. It turns out that if you don’t have <code>goto</code>,
things get easier for the compiler developer.</p>

<p>In 1995, Richard Kelsey writes about how CPS and SSA are similar in <a href="https://bernsteinbear.com/assets/img/kelsey-ssa-cps.pdf">A
Correspondence between Continuation Passing Style and Static Single Assignment
Form</a> (PDF). Part of the paper involves
converting CPS to SSA (and the reverse, too).</p>

<p>Also in 1995, Cliff Click and Michael Paleczny publish <a href="https://bernsteinbear.com/assets/img/click-ssa.pdf">A Simple Graph-Based
Intermediate Representation</a> (PDF), which has become
known as the Sea of Nodes IR. It’s like “normal” SSA except that instead of
just having blocks and data edges between instructions, all instructions are
“unscheduled” and have control edges between them. It means your graph looks
all funky but doesn’t implicitly have (kind of arbitrary) code linearization so
code motion is easier. Cliff and co are building <a href="https://github.com/SeaOfNodes/Simple">a working demo
compiler</a>. See also <a href="https://bernsteinbear.com/assets/img/click-gvn.pdf">Global Code Motion /
Global Value Numbering</a> (PDF) by Cliff Click.</p>

<p>In 1998, Appel (of functional language fame) describes briefly a correspondence
between functional languages and SSA in <a href="https://bernsteinbear.com/assets/img/appel-basic-block-arguments.pdf">SSA is Functional
Programming</a> (PDF). I think this
is the first paper that introduced a notion of “basic block arguments” (instead
of phi functions). He also suggests a “really crude” algorithm for generating
SSA that places phi nodes all over the place for every variable.</p>

<p>In 2000, Aycock and Horspool publish <a href="https://bernsteinbear.com/assets/img/aycock-horspool-ssa.pdf">Simple Generation of Static
Single-Assignment Form</a> (PDF). It starts
from Appel’s approach and then iteratively deletes phi nodes that don’t need to
exist. They find that for reducible control-flow graphs (the common case for
most compilers, I think), their approach also produces minimal SSA.</p>

<p>In 2009, Michael Bebenita writes <a href="https://bernsteinbear.com/assets/img/bebenita-ssa.pdf">Constructing SSA the Easy
Way</a> (PDF) which is “essentially a rehashing of
Aycock’s SSA construction algorithm but using forwarding pointers instead”. I
only found it the other day. It’s fantastic and I wish more people knew about
it. It uses one of my favorite data structures, union-find, though for some
reason it does not mention it by name.</p>

<p>In 2013, my former coworker Matthias Braun and his labmates write <a href="https://bernsteinbear.com/assets/img/braun13cc.pdf">Simple and
Efficient Construction of Static Single Assignment
Form</a> (PDF), which describes converting to SSA from
an AST and building the CFG on the fly. It’s fairly popular because it is
simpler than the Cytron paper. I find the phase transitions in the blocks
(filled/sealed/…) a little tricky to keep straight though.</p>

<p>In 2023, Matthieu Lemerre writes <a href="https://bernsteinbear.com/assets/img/lemerre-ssa.pdf">SSA Translation Is an Abstract
Interpretation</a> (PDF), which I would love to
understand one day.</p>

<h2 id="other-papers">Other papers</h2>

<p>I will eventually add some papers on extensions to SSA, analyses on SSA,
converting out of SSA (including register allocation). Just not this evening.</p>

<p>I am also probably missing or forgetting some big hit papers for converting
into SSA, so please drop me a line if you have favorites.</p>

<h2 id="other-resources">Other resources</h2>

<p>The <a href="https://bernsteinbear.com/assets/img/ssa-book.pdf">SSA book</a> (PDF; draft) is a huge tour de force
of SSA-based compiler design. That is even the new name of the book, which has
since been <a href="https://link.springer.com/book/10.1007/978-3-030-80515-9">published in
print</a>. It’s on my
shelf.</p>

<h2 id="a-keyword-dump">A keyword dump</h2>

<p>Here are some keywords which you may search for but mostly serve as notes to
self to write more about one day:</p>

<ul>
  <li>windmill, lost copy</li>
  <li>SCCP</li>
  <li>liveness</li>
  <li>DCE</li>
  <li>chordal</li>
  <li>https://arxiv.org/abs/2011.05608</li>
  <li>SSI and e-SSA and sparseness</li>
  <li>GVN and hash consing</li>
  <li>load/store forwarding</li>
  <li>mem2reg</li>
  <li>SROA and memory ssa</li>
  <li>eager constant folding / smart constructors</li>
  <li>points-to and CFA</li>
  <li>flattening tuples</li>
  <li>webs (see Muchnick’s 1997 Advanced compiler design and implementation)</li>
  <li>RVSDG and co</li>
  <li>e-graphs</li>
</ul>

        </div></div>
  </body>
</html>
