<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/923237/">Original</a>
    <h1>Rethinking Splice()</h1>
    
    <div id="readability-page-1" class="page"><div>
<center>
           <div><b>Benefits for LWN subscribers</b><p>The primary benefit from <a href="https://lwn.net/subscribe/">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!</p></div>
           </center>
           <p>
The </p><a href="https://man7.org/linux/man-pages/man2/splice.2.html"><tt>splice()</tt>
system call</a><p> is built on an appealing idea: connect two file descriptors
together so that data can be moved from one to the other without passing
through user space and, preferably, without being copied in the kernel.
</p><tt>splice()</tt><p> has enabled some significant performance optimizations
over the years, but it has also proved difficult to work with and
occasionally surprising.  A recent linux-kernel discussion showed how
</p><tt>splice()</tt><p> can cause trouble, to the point that some developers now
wonder if adding it was a good idea.
</p><p>
Stefan Metzmacher is a <a href="https://www.samba.org/">Samba</a> developer
who would like to use <tt>splice()</tt> to implement zero-copy I/O in the
Samba server.  He has <a href="https://lwn.net/ml/linux-kernel/0cfd9f02-dea7-90e2-e932-c8129b6013c7@samba.org/">run
into a problem</a>, though.  If a file is being sent to a remote client
over the network, <tt>splice()</tt> can be used to feed the file data into
a socket; the network layer will read that data directly out of the page
cache without needing to make a copy in the kernel — exactly the desired
result. But if the file is written before network transmission is
complete, the newly written data may be sent, even though that write
happened after the <tt>splice()</tt> call was made, perhaps even in the
same process.  That can lead to unpleasant surprises (and unhappy Samba
users) when the data received at the remote end is not what is expected.
</p><p>
The problem here is a bit more subtle than it might seem at a first glance.
To begin with, it is not possible to splice a file directly into a network
socket; <tt>splice()</tt> requires that at least one of the file
descriptors given to it is a pipe.  So the actual sequence of operations is
to splice the file into a pipe, then to connect the pipe to the socket with
a second <tt>splice()</tt> call.  Neither <tt>splice()</tt> call knows when
the data it passes through has reached its final destination; the network
layer may still be working with the file data even after both
<tt>splice()</tt> calls have completed.  There is no easy way to know that
the data has been transmitted and that it is safe to modify the file again.
</p><p>
In his initial email, Metzmacher asked whether it would be possible to
prevent this problem by marking file-cache pages as copy-on-write when they
are passed to <tt>splice()</tt>.  Then, if the file were written while the
transfer was underway, that transfer could continue to read from the older
data while the write to the file proceeded independently.  Linus Torvalds
quickly <a href="https://lwn.net/ml/linux-kernel/CAHk-=wj8rthcQ9gQbvkMzeFt0iymq+CuOzmidx3Pm29Lg+W0gg@mail.gmail.com/">rejected</a>
that idea, saying that the sharing of the buffers holding the data is
&#34;<q>the whole point of splice</q>&#34;.  Making those pages copy-on-write would
break sharing of data in general.  He later <a href="https://lwn.net/ml/linux-kernel/CAHk-=wj66F6CdJUAAjqigXMBy7gHquFMzPNAwKCgkrb2mF6U7w@mail.gmail.com/">added</a>
that a <tt>splice()</tt> call should be seen as a form of <a href="https://man7.org/linux/man-pages/man2/mmap.2.html"><tt>mmap()</tt></a>,
with similar semantics.
</p><p>
He also said: &#34;<q>You can say &#39;I don&#39;t like splice()&#39;. That&#39;s fine. I used
to think splice was a really cool concept, but I kind of hate it these
days.  Not liking splice() makes a ton of sense.</q>&#34; Like it or not,
though, the current behavior of <tt>splice()</tt> cannot change, since that
would break existing applications; even Torvalds&#39;s dislike cannot overcome
that.
</p><p>
Samba developer Jeremy Allison <a href="https://lwn.net/ml/linux-kernel/Y+aKuC1PuvX4STEI@jeremy-acer/">suggested</a> that
the solution to Metzmacher&#39;s problem could be for Samba to only attempt
zero-copy I/O when the client holds a lease on the file in question, thus
ensuring that there should be no concurrent access.  He later had to <a href="https://lwn.net/ml/linux-kernel/Y+aat8sggTtgff+A@jeremy-acer/">backtrack</a> on that
idea, though; since the Samba server cannot know when network transmission
is complete, the possibility for surprises still exists even in the
presence of a lease.  Thus, he concluded, &#34;<q><tt>splice()</tt> is unusable
for Samba even in the leased file case</q>&#34;.
</p><p>
Dave Chinner <a href="https://lwn.net/ml/linux-kernel/20230210040626.GB2825702@dread.disaster.area/">observed</a>
that this problem resembles those that have previously been solved in the
filesystem layer.  There are many cases, including RAID 5 or data
compressed by the filesystem, where data to be written must be held stable
for the duration of the operation; this is the whole <a href="https://lwn.net/Articles/442355/">stable-pages problem</a> that was confronted
almost twelve years ago.  Perhaps a similar solution could be implemented
here, he said, where attempts to write to pages currently being used in a
<tt>splice()</tt> chain would simply block until the operation has
completed.
</p><p>
Both <a href="https://lwn.net/ml/linux-kernel/CAHk-=wip9xx367bfCV8xaF9Oaw4DZ6edF9Ojv10XoxJ-iUBwhA@mail.gmail.com/">Torvalds</a>
and <a href="https://lwn.net/ml/linux-kernel/Y+XLuYh+kC+4wTRi@casper.infradead.org/">Matthew
Wilcox</a> pointed out the flaw with this idea: the <tt>splice()</tt>
operation can take an unbounded amount of time, so it could be used
(accidentally or otherwise) to block access to a file indefinitely.  That
idea did not go far.
</p><p>
Andy Lutomirski <a href="https://lwn.net/ml/linux-kernel/CALCETrU-9Wcb_zCsVWr24V=uCA0+c6x359UkJBOBgkbq+UHAMA@mail.gmail.com/">argued</a>
that <tt>splice()</tt> is the wrong interface for what applications want to
do; <tt>splice()</tt> has no way of usefully communicating status
information back to the caller.  Instead, he said, <a href="https://lwn.net/Articles/776703/">io_uring</a> might be a better way to implement
this functionality.  It allows multiple operations to be queued efficiently
and, crucially, it has the completion mechanism that can let user space
know when a given buffer is no longer in use.  Jens Axboe, the maintainer
of io_uring, was initially <a href="https://lwn.net/ml/linux-kernel/7a2e5b7f-c213-09ff-ef35-d6c2967b31a7@kernel.dk/">unsure</a>
about this idea, but <a href="https://lwn.net/ml/linux-kernel/b44783e6-3da2-85dd-a482-5d9aeb018e9c@kernel.dk/">warmed
to it</a> after Lutomirski <a href="https://lwn.net/ml/linux-kernel/CALCETrVx4cj7KrhaevtFN19rf=A6kauFTr7UPzQVage0MsBLrg@mail.gmail.com/">suggested</a>
that the problem could be simplified by taking the pipes out of the picture
and allowing one non-pipe file descriptor to be connected directly to
another.  The pipes, Axboe said, &#34;<q>do get in the way</q>&#34; sometimes.
</p><p>
Axboe thought that a new &#34;send file&#34; io_uring operation could be a good
solution to this problem; it could be designed from the beginning with
asynchronous operation in mind and without the use of pipes.  So that may
be the solution that comes out 
of this discussion — though somebody would, naturally, actually have to
implement it first.
</p><p>
There was some talk about whether <tt>splice()</tt> should be deprecated;
Torvalds <a href="https://lwn.net/ml/linux-kernel/CAHk-=wjQZWMeQ9OgXDNepf+TLijqj0Lm0dXWwWzDcbz6o7yy_g@mail.gmail.com/">
doesn&#39;t think</a> the system call has much value:
</p><blockquote>
	The same way &#34;everything is a pipeline of processes&#34; is very much
	historical Unix and very useful for shell scripting, but isn&#39;t
	actually then normally very useful for larger problems, splice()
	really never lived up to that conceptual issue, and it&#39;s just
	really really nasty in practice.
<p>
	But we&#39;re stuck with it.
</p></blockquote>
<p>
There is little point in discouraging use of <tt>splice()</tt>, though, if
the kernel lacks a better alternative; Torvalds expressed doubt that the
io_uring approach would turn out to be better in the end.  The only way to
find out is probably to try it and see how well it actually works.  Until
that happens, <tt>splice()</tt> will be the best that the kernel has to
offer, its faults notwithstanding.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#io_uring">io_uring</a></td></tr>
            <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#splice">splice()</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
