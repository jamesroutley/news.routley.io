<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/oldmoe/litestack">Original</a>
    <h1>Litestack: All your data infrastructure, in one Ruby gem</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/oldmoe/litestack/blob/master/assets/litestack_logo_teal_large.png?raw=true"><img src="https://github.com/oldmoe/litestack/raw/master/assets/litestack_logo_teal_large.png?raw=true" alt="litestack"/></a></p>
<p dir="auto"><a href="https://badge.fury.io/rb/litestack" rel="nofollow"><img height="21" src="https://camo.githubusercontent.com/799fb43754d9e4aae16af0ca0b65a088daca4e67af89ab5bd8707333509109c6/68747470733a2f2f62616467652e667572792e696f2f72622f6c697465737461636b2e737667" alt="Gem Version" data-canonical-src="https://badge.fury.io/rb/litestack.svg"/></a>
<a href="https://rubygems.org/gems/litestack" rel="nofollow"><img height="21" src="https://camo.githubusercontent.com/9315d4493fe6a8508be2ac3c7d25e51fbd4c3dacdb9358270538a90e42abbcf9/68747470733a2f2f696d672e736869656c64732e696f2f67656d2f64742f6c697465737461636b3f636f6c6f723d627269676874677265656e266c6162656c3d5275627967656d73253230446f776e6c6f616473" alt="RubyGems Downloads" data-canonical-src="https://img.shields.io/gem/dt/litestack?color=brightgreen&amp;label=Rubygems%20Downloads"/></a></p>
<p dir="auto">All your data infrastructure, in a gem!</p>
<p dir="auto">Litestack is a Ruby gem that provides both Ruby and  Ruby on Rails applications an all-in-one solution for web application data infrastructure. It exploits the power and embeddedness of SQLite to deliver a full-fledged SQL database, a fast cache , a robust job queue, a reliable message broker, a full text search engine and a metrics platform all in a single package.</p>
<p dir="auto">Compared to conventional approaches that require separate servers and databases, Litestack offers superior performance, efficiency, ease of use, and cost savings. Its embedded database and cache reduce memory and CPU usage, while its simple interface streamlines the development process. Overall, Litestack sets a new standard for web application development and is an excellent choice for those who demand speed, efficiency, and simplicity.</p>
<p dir="auto">You can read more about why litestack can be a good choice for your next web application <strong><a href="https://github.com/oldmoe/litestack/blob/master/WHYLITESTACK.md">here</a></strong>, you might also be interested in litestack <strong><a href="https://github.com/oldmoe/litestack/blob/master/BENCHMARKS.md">benchmarks</a></strong>.</p>
<p dir="auto">With litestack you only need to add a single gem to your app which would replace a host of other gems and services, for example, a typical Rails app using litestack will no longer need the following services:</p>
<ul dir="auto">
<li>Database Server (e.g. PostgreSQL, MySQL)</li>
<li>Cache Server (e.g. Redis, Memcached)</li>
<li>Job Processor (e.g. Sidekiq, Goodjob)</li>
<li>Pubsub Server (e.g. Redis, PostgreSQL)</li>
<li>Fulltext Search Server (e.g. Elasticsearch, Meilisearch)</li>
</ul>
<p dir="auto">To make it even more efficient, litestack will detect the presence of Fiber based IO frameworks like Async (e.g. when you use the Falcon web server) or Polyphony. It will then switch its background workers for caches and queues to fibers (using the semantics of the existing framework). This is done transparently and will generally lead to lower CPU and memory utilization.
<a target="_blank" rel="noopener noreferrer" href="https://github.com/oldmoe/litestack/blob/master/assets/litestack_advantage.png?raw=true"><img src="https://github.com/oldmoe/litestack/raw/master/assets/litestack_advantage.png?raw=true" alt="litestack"/></a></p>

<p dir="auto">Add the <code>litestack</code> gem line to your application&#39;s Gemfile:</p>

<p dir="auto">To configure a Rails application to run the full litestack, run:</p>
<div data-snippet-clipboard-copy-content="$ rails generate litestack:install"><pre><code>$ rails generate litestack:install
</code></pre></div>

<p dir="auto">litestack currently offers six main components</p>
<ul dir="auto">
<li>litedb</li>
<li>litecache</li>
<li>litejob</li>
<li>litecable</li>
<li>litesearch</li>
<li>litemetric</li>
</ul>
<blockquote>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/oldmoe/litestack/blob/master/assets/litedb_logo_teal.png?raw=true"><img src="https://github.com/oldmoe/litestack/raw/master/assets/litedb_logo_teal.png?raw=true" alt="litedb"/></a></p>
</blockquote>
<p dir="auto">litedb is a wrapper around SQLite3, offering a better default configuration that is tuned for concurrency and performance. Out of the box, litedb works seamlessly between multiple processes without database locking errors. litedb can be used in multiple ways, including:</p>

<p dir="auto">litedb can be used exactly as the SQLite3 gem, since litedb inherits from SQLite3</p>
<div dir="auto" data-snippet-clipboard-copy-content="require &#39;litestack&#39;
db = Litedb.new(path_to_db)
db.execute(&#34;create table users(id integer primary key, name text)&#34;)
db.execute(&#34;insert into users(name) values (?)&#34;, &#34;Hamada&#34;)
db.query(&#34;select count(*) from users&#34;) # =&gt; [[1]]"><pre><span>require</span> <span>&#39;litestack&#39;</span>
<span>db</span> <span>=</span> <span>Litedb</span><span>.</span><span>new</span><span>(</span><span>path_to_db</span><span>)</span>
<span>db</span><span>.</span><span>execute</span><span>(</span><span>&#34;create table users(id integer primary key, name text)&#34;</span><span>)</span>
<span>db</span><span>.</span><span>execute</span><span>(</span><span>&#34;insert into users(name) values (?)&#34;</span><span>,</span> <span>&#34;Hamada&#34;</span><span>)</span>
<span>db</span><span>.</span><span>query</span><span>(</span><span>&#34;select count(*) from users&#34;</span><span>)</span> <span># =&gt; [[1]]</span></pre></div>

<p dir="auto">litedb provides tight Rails/ActiveRecord integration and can be configured as follows</p>
<p dir="auto">In database.yml</p>
<div dir="auto" data-snippet-clipboard-copy-content="adapter: litedb
# normal sqlite3 configuration follows"><pre><span>adapter</span>: <span>litedb</span>
<span><span>#</span> normal sqlite3 configuration follows</span></pre></div>

<p dir="auto">litedb offers integration with the Sequel database toolkit and can be configured as follows</p>
<div dir="auto" data-snippet-clipboard-copy-content="DB = Sequel.connect(&#34;litedb://path_to_db_file&#34;)"><pre><span>DB</span> <span>=</span> <span>Sequel</span><span>.</span><span>connect</span><span>(</span><span>&#34;litedb://path_to_db_file&#34;</span><span>)</span></pre></div>
<blockquote>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/oldmoe/litestack/blob/master/assets/litecache_logo_teal.png?raw=true"><img src="https://github.com/oldmoe/litestack/raw/master/assets/litecache_logo_teal.png?raw=true" alt="litecache"/></a></p>
</blockquote>
<p dir="auto">litecache is a high speed, low overhead caching library that uses SQLite as its backend. litecache can be accessed from multiple processes on the same machine seamlessly. It also has features like key expiry, LRU based eviction and increment/decrement of integer values.</p>

<div dir="auto" data-snippet-clipboard-copy-content="require &#39;litestack&#39;
cache = Litecache.new(path: &#34;path_to_file&#34;)
cache.set(&#34;key&#34;, &#34;value&#34;)
cache.get(&#34;key&#34;) #=&gt; &#34;value&#34;"><pre><span>require</span> <span>&#39;litestack&#39;</span>
<span>cache</span> <span>=</span> <span>Litecache</span><span>.</span><span>new</span><span>(</span><span>path</span>: <span>&#34;path_to_file&#34;</span><span>)</span>
<span>cache</span><span>.</span><span>set</span><span>(</span><span>&#34;key&#34;</span><span>,</span> <span>&#34;value&#34;</span><span>)</span>
<span>cache</span><span>.</span><span>get</span><span>(</span><span>&#34;key&#34;</span><span>)</span> <span>#=&gt; &#34;value&#34;</span></pre></div>

<p dir="auto">In your desired environment file (e.g. production.rb)</p>
<div dir="auto" data-snippet-clipboard-copy-content="config.cache_store = :litecache, {path: &#39;./path/to/your/cache/file&#39;}"><pre><span>config</span><span>.</span><span>cache_store</span> <span>=</span> <span>:litecache</span><span>,</span> <span>{</span><span>path</span>: <span>&#39;./path/to/your/cache/file&#39;</span><span>}</span></pre></div>
<p dir="auto">This provides a transparent integration that uses the Rails caching interface</p>
<p dir="auto">litecache spawns a background thread for cleanup purposes. In case it detects that the current environment has <em>Fiber::Scheduler</em> or <em>Polyphony</em> loaded it will spawn a fiber instead, saving on both memory and CPU cycles.</p>
<blockquote>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/oldmoe/litestack/blob/master/assets/litejob_logo_teal.png?raw=true"><img src="https://github.com/oldmoe/litestack/raw/master/assets/litejob_logo_teal.png?raw=true" alt="litejob"/></a></p>
</blockquote>
<p dir="auto">More info about Litejob can be found in the <a href="https://github.com/oldmoe/litestack/wiki/Litejob-guide">litejob guide</a></p>
<p dir="auto">litejob is a fast and very efficient job queue processor for Ruby applications. It builds on top of SQLite as well, which provides transactional guarantees, persistence and exceptional performance.</p>

<div dir="auto" data-snippet-clipboard-copy-content="require &#39;litestack&#39;
# define your job class
class MyJob
  include ::Litejob
      
  queue = :default
      
  # must implement perform, with any number of params
  def perform(params)
    # do stuff
  end
end
    
#schedule a job asynchronusly
MyJob.perform_async(params)
    
#schedule a job at a certain time
MyJob.perform_at(time, params)
    
#schedule a job after a certain delay
MyJob.perform_after(delay, params)"><pre><span>require</span> <span>&#39;litestack&#39;</span>
<span># define your job class</span>
<span>class</span> <span>MyJob</span>
  <span>include</span> ::<span>Litejob</span>
      
  <span>queue</span> <span>=</span> <span>:default</span>
      
  <span># must implement perform, with any number of params</span>
  <span>def</span> <span>perform</span><span>(</span><span>params</span><span>)</span>
    <span># do stuff</span>
  <span>end</span>
<span>end</span>
    
<span>#schedule a job asynchronusly</span>
<span>MyJob</span><span>.</span><span>perform_async</span><span>(</span><span>params</span><span>)</span>
    
<span>#schedule a job at a certain time</span>
<span>MyJob</span><span>.</span><span>perform_at</span><span>(</span><span>time</span><span>,</span> <span>params</span><span>)</span>
    
<span>#schedule a job after a certain delay</span>
<span>MyJob</span><span>.</span><span>perform_after</span><span>(</span><span>delay</span><span>,</span> <span>params</span><span>)</span></pre></div>

<p dir="auto">In your desired environment file (e.g. production.rb)</p>
<div dir="auto" data-snippet-clipboard-copy-content="config.active_job.queue_adapter = :litejob"><pre><span>config</span><span>.</span><span>active_job</span><span>.</span><span>queue_adapter</span> <span>=</span> <span>:litejob</span></pre></div>

<p dir="auto">You can add more configuration in litejob.yml (or config/litejob.yml if you are integrating with Rails)</p>
<div dir="auto" data-snippet-clipboard-copy-content="queues:
    - [default, 1]
    - [urgent, 5]
    - [critical, 10, &#34;spawn&#34;]"><pre><span>queues</span>:
    - <span>[default, 1]</span>
    - <span>[urgent, 5]</span>
    - <span>[critical, 10, &#34;spawn&#34;]</span></pre></div>
<p dir="auto">The queues need to include a name and a priority (a number between 1 and 10) and can also optionally add the token &#34;spawn&#34;, which means every job will run it its own concurrency context (thread or fiber)</p>
<blockquote>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/oldmoe/litestack/blob/master/assets/litecable_logo_teal.png?raw=true"><img src="https://github.com/oldmoe/litestack/raw/master/assets/litecable_logo_teal.png?raw=true" alt="litecable"/></a></p>
</blockquote>

<p dir="auto">This is a drop in replacement adapter for actioncable that replaces <code>async</code> and other production adapters (e.g. PostgreSQL, Redis). This adapter is currently only tested in local (inline) mode.</p>
<p dir="auto">Getting up and running with litecable requires configuring your cable.yaml file under the config/ directory</p>
<p dir="auto">cable.yaml</p>
<div dir="auto" data-snippet-clipboard-copy-content="development:
  adapter: litecable

test:
  adapter: test

staging:
  adapter: litecable

production:
  adapter: litecable"><pre><span>development</span>:
  <span>adapter</span>: <span>litecable</span>

<span>test</span>:
  <span>adapter</span>: <span>test</span>

<span>staging</span>:
  <span>adapter</span>: <span>litecable</span>

<span>production</span>:
  <span>adapter</span>: <span>litecable</span></pre></div>
<blockquote>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/oldmoe/litestack/blob/master/assets/litesearch_logo_teal.png?raw=true"><img src="https://github.com/oldmoe/litestack/raw/master/assets/litesearch_logo_teal.png?raw=true" alt="litesearch"/></a></p>
</blockquote>

<p dir="auto">Litesearch adds full text search capabilities to Litedb, you can use it in standalone mode as follows:</p>
<div dir="auto" data-snippet-clipboard-copy-content="require &#39;litestack/litedb&#39;
db = Litedb.new(&#34;:memory:&#34;)
# create the index
idx = db.search_index(&#39;index_name&#39;) do |schema|
    schema.fields [:sender, :receiver, :body]
    schema.field :subject, weight: 10
    schema.tokenizer :trigram
end
# add documents
idx.add({sender: &#39;Kamal&#39;, receiver: &#39;Laila&#39;, subject: &#39;Are the girls awake?&#39;, body: &#39;I got them the new phones they asked for, are they awake?&#39;})
# search the index, all fields
idx.search(&#39;kamal&#39;)
# search the index, specific field, partial workd (trigram)
idx.search(&#39;subject: awa&#39;) "><pre><span>require</span> <span>&#39;litestack/litedb&#39;</span>
<span>db</span> <span>=</span> <span>Litedb</span><span>.</span><span>new</span><span>(</span><span>&#34;:memory:&#34;</span><span>)</span>
<span># create the index</span>
<span>idx</span> <span>=</span> <span>db</span><span>.</span><span>search_index</span><span>(</span><span>&#39;index_name&#39;</span><span>)</span> <span>do</span> |<span>schema</span>|
    <span>schema</span><span>.</span><span>fields</span> <span>[</span><span>:sender</span><span>,</span> <span>:receiver</span><span>,</span> <span>:body</span><span>]</span>
    <span>schema</span><span>.</span><span>field</span> <span>:subject</span><span>,</span> <span>weight</span>: <span>10</span>
    <span>schema</span><span>.</span><span>tokenizer</span> <span>:trigram</span>
<span>end</span>
<span># add documents</span>
<span>idx</span><span>.</span><span>add</span><span>(</span><span>{</span><span>sender</span>: <span>&#39;Kamal&#39;</span><span>,</span> <span>receiver</span>: <span>&#39;Laila&#39;</span><span>,</span> <span>subject</span>: <span>&#39;Are the girls awake?&#39;</span><span>,</span> <span>body</span>: <span>&#39;I got them the new phones they asked for, are they awake?&#39;</span><span>}</span><span>)</span>
<span># search the index, all fields</span>
<span>idx</span><span>.</span><span>search</span><span>(</span><span>&#39;kamal&#39;</span><span>)</span>
<span># search the index, specific field, partial workd (trigram)</span>
<span>idx</span><span>.</span><span>search</span><span>(</span><span>&#39;subject: awa&#39;</span><span>)</span> </pre></div>
<p dir="auto">Litesearch integrates tightly with ActiveRecord and Sequel, here are integration examples</p>

<div dir="auto" data-snippet-clipboard-copy-content="class Author &lt; ActiveRecord::Base
    has_many :books
end

class Book &lt; ActiveRecord::Base
    belongs_to :author

    include Litesearch::Model

    litesearch do |schema|
        schema.fields [:title, :description]
        schema.field :author, target: &#39;authors.name&#39;
        schema.tokenizer :porter
    end
end
# insert records
Author.create(name: &#39;Adam A. Writer&#39;) 
Book.create(title: &#39;The biggest stunt&#39;, author_id: 1, description: &#39;a description&#39;) 
# search the index, the search method integrates with AR&#39;s query interface
Book.search(&#39;author: writer&#39;).limit(1).all"><pre><span>class</span> <span>Author</span> &lt; <span>ActiveRecord</span>::<span>Base</span>
    <span>has_many</span> <span>:books</span>
<span>end</span>

<span>class</span> <span>Book</span> &lt; <span>ActiveRecord</span>::<span>Base</span>
    <span>belongs_to</span> <span>:author</span>

    <span>include</span> <span>Litesearch</span>::<span>Model</span>

    <span>litesearch</span> <span>do</span> |<span>schema</span>|
        <span>schema</span><span>.</span><span>fields</span> <span>[</span><span>:title</span><span>,</span> <span>:description</span><span>]</span>
        <span>schema</span><span>.</span><span>field</span> <span>:author</span><span>,</span> <span>target</span>: <span>&#39;authors.name&#39;</span>
        <span>schema</span><span>.</span><span>tokenizer</span> <span>:porter</span>
    <span>end</span>
<span>end</span>
<span># insert records</span>
<span>Author</span><span>.</span><span>create</span><span>(</span><span>name</span>: <span>&#39;Adam A. Writer&#39;</span><span>)</span> 
<span>Book</span><span>.</span><span>create</span><span>(</span><span>title</span>: <span>&#39;The biggest stunt&#39;</span><span>,</span> <span>author_id</span>: <span>1</span><span>,</span> <span>description</span>: <span>&#39;a description&#39;</span><span>)</span> 
<span># search the index, the search method integrates with AR&#39;s query interface</span>
<span>Book</span><span>.</span><span>search</span><span>(</span><span>&#39;author: writer&#39;</span><span>)</span><span>.</span><span>limit</span><span>(</span><span>1</span><span>)</span><span>.</span><span>all</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="class Author &lt; Sequel::Model
    one_to_many :books
end

class Book &lt; Sequel::Model
    many_to_one :author

    include Litesearch::Model
    litesearch do |schema|
        schema.fields [:title, :description]
        schema.field :author, target: &#39;authors.name&#39;
        schema.tokenizer :porter
    end
end
# insert records
Author.create(name: &#39;Adam A. Writer&#39;) 
Book.create(title: &#39;The biggest stunt&#39;, author_id: 1, description: &#39;a description&#39;) 
# search the index, the search method integrates with Sequel&#39;s query interface
Book.search(&#39;author: writer&#39;).limit(1).all"><pre><span>class</span> <span>Author</span> &lt; <span>Sequel</span>::<span>Model</span>
    <span>one_to_many</span> <span>:books</span>
<span>end</span>

<span>class</span> <span>Book</span> &lt; <span>Sequel</span>::<span>Model</span>
    <span>many_to_one</span> <span>:author</span>

    <span>include</span> <span>Litesearch</span>::<span>Model</span>
    <span>litesearch</span> <span>do</span> |<span>schema</span>|
        <span>schema</span><span>.</span><span>fields</span> <span>[</span><span>:title</span><span>,</span> <span>:description</span><span>]</span>
        <span>schema</span><span>.</span><span>field</span> <span>:author</span><span>,</span> <span>target</span>: <span>&#39;authors.name&#39;</span>
        <span>schema</span><span>.</span><span>tokenizer</span> <span>:porter</span>
    <span>end</span>
<span>end</span>
<span># insert records</span>
<span>Author</span><span>.</span><span>create</span><span>(</span><span>name</span>: <span>&#39;Adam A. Writer&#39;</span><span>)</span> 
<span>Book</span><span>.</span><span>create</span><span>(</span><span>title</span>: <span>&#39;The biggest stunt&#39;</span><span>,</span> <span>author_id</span>: <span>1</span><span>,</span> <span>description</span>: <span>&#39;a description&#39;</span><span>)</span> 
<span># search the index, the search method integrates with Sequel&#39;s query interface</span>
<span>Book</span><span>.</span><span>search</span><span>(</span><span>&#39;author: writer&#39;</span><span>)</span><span>.</span><span>limit</span><span>(</span><span>1</span><span>)</span><span>.</span><span>all</span></pre></div>
<blockquote>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/oldmoe/litestack/blob/master/assets/litemetric_logo_teal.png?raw=true"><img src="https://github.com/oldmoe/litestack/raw/master/assets/litemetric_logo_teal.png?raw=true" alt="litemetric"/></a></p>
</blockquote>

<p dir="auto">Litestack comes with a module that can collect useful metrics for its different components, in each component, you need to add the following to the respective .yml file (database.yml in case of Litedb)</p>
<div dir="auto" data-snippet-clipboard-copy-content="    metrics: true # default is false"><pre>    <span>metrics</span>: <span>true </span><span><span>#</span> default is false</span></pre></div>
<p dir="auto">If you have the metrics enabled, it will start collecting data from the various modules and will store them in a database file called metric.db located in the Litesupport.root folder</p>
<p dir="auto">Litemetric has an API that would enable collecting arbitrary metrics for non-litestack classes. The metrics will be in the database but currently the Liteboard is only able to show correct data for Litestack modules, displaying arbitrary metrics for other components will be included later.</p>

<p dir="auto">Liteboard is a simple web server that provides a web interface for the collected metrics, it should be available globally, for usage instructions type</p>

<p dir="auto">It allows you to point to a specific metrics database file or a config file and then it will display the data in that metrics database</p>
<p dir="auto">Example metrics views:</p>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/oldmoe/litestack/blob/master/assets/litedb_metrics.png?raw=true"><img src="https://github.com/oldmoe/litestack/raw/master/assets/litedb_metrics.png?raw=true" alt="litedb"/></a></p>
<ul dir="auto">
<li>Database size, number of tables &amp; indexes</li>
<li>Number of read/write queries</li>
<li>Read/Write query ratio over time</li>
<li>Read/Write query time over time</li>
<li>Slowest queries</li>
<li>Most expensive queries (total run time = frequency * cost)</li>
</ul>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/oldmoe/litestack/blob/master/assets/litecache_metrics.png?raw=true"><img src="https://github.com/oldmoe/litestack/raw/master/assets/litecache_metrics.png?raw=true" alt="litecache"/></a></p>
<ul dir="auto">
<li>Cache size, % of size limit</li>
<li>Number of entries</li>
<li>Reads/Writes over time</li>
<li>Read hits/misses over time</li>
<li>Most written entries</li>
<li>Most read entries</li>
</ul>

<p dir="auto">Bug reports and pull requests are welcome on GitHub at <a href="https://github.com/oldmoe/litestack">https://github.com/oldmoe/litestack</a>.</p>

<p dir="auto">The gem is available as open source under the terms of the <a href="https://opensource.org/licenses/MIT" rel="nofollow">MIT License</a>.</p>
</article></div></div>
  </body>
</html>
