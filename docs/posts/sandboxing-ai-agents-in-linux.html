<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.senko.net/sandboxing-ai-agents-in-linux">Original</a>
    <h1>Sandboxing AI Agents in Linux</h1>
    
    <div id="readability-page-1" class="page"><div><p>Like many developers, I find myself more and more using AI agents to help with software development.</p>

<p>I currently use Claude Code, the command line interface, together with Opus 4.5 (Anthropic&#39;s top model as of this writing). I use it to distill my rough task requirements into a detailed development plan, then implement the plan.</p>

<p>By default, Claude Code asks each time if it may read and write files and run software. This is sensible default configuration, but does get annoying after a time. Worse, it interrupts me often enough that I can&#39;t do much in parallel while babysitting it.</p>

<p>There&#39;s also a <code>--dangerously-skip-permissions</code> (a.k.a. “YOLO”) mode which will happily run anything without asking. This can be risky (although I know of some people that run it like that and still haven&#39;t destroyed their dev machines).</p>

<h2 id="sandboxing" id="sandboxing">Sandboxing</h2>

<p>The standard solution is to sandbox the agent – either on a remote machine (<a href="https://exe.dev" rel="nofollow">exe.dev</a>, <a href="https://sprites.dev" rel="nofollow">sprites.dev</a>, <a href="https://daytona.io" rel="nofollow">daytona.io</a>), or locally via Docker or other virtualization mechanism.</p>

<p>A lightweight alternative on Linux is <a href="https://github.com/containers/bubblewrap" rel="nofollow">bubblewrap</a>, which uses Linux kernel features like cgroups and user namespaces to limit (jail) a process.</p>

<p>As it turns out, bubblewrap is a good solution for lightweight sandboxing of AI agents. Here&#39;s what I personally need from such a solution:</p>
<ul><li>mimic my regular Linux dev machine setup (I don&#39;t want to manage multiple dev environment)</li>
<li>minimal/no access to information outside what&#39;s required for the current project</li>
<li>write access only to the current project</li>
<li>can directly operate on the files/folders of the project so I can easily inspect or modify the same files from my IDE or run the code myself</li>
<li>network access – both to connect to AI providers and search the internet, and to be able to start a server that I can connect to</li></ul>

<p>Bubblewrap and Docker are not hardened security isolation mechanisms, but that&#39;s okay with me. I&#39;m not really concerned about the following risks:</p>
<ul><li>escape via zero-day Linux kernel bug</li>
<li>covert side channel communications</li>
<li>exfiltration of data from current project (including project-specific access keys)</li>
<li>screwing up the codebase (the code is managed via <code>git</code> and backed up at GitHub or elsewhere)</li></ul>

<p>The last bit is tricky, but even full remote sandboxes can&#39;t protect against that. In theory, we could have transparent API proxies that would inject proper access keys without the AI agent ever being aware of it, but this is really non-trivial to set up right now.</p>

<p>An alternative is to contain potential damage by creating project-specific API keys so at least the blast area is minimal if those keys are leaked.</p>

<h2 id="in-practice" id="in-practice">In practice</h2>

<p>Here&#39;s how my bubblewrap sandbox script looks:</p>

<pre><code>#!/usr/bin/bash

exec 3&lt;$HOME/.claude.json

exec /usr/bin/bwrap \
    --tmpfs /tmp \
    --dev /dev \
    --proc /proc \
    --hostname bubblewrap --unshare-uts \
    --ro-bind /bin /bin \
    --ro-bind /lib /lib \
    --ro-bind /lib32 /lib32 \
    --ro-bind /lib64 /lib64 \
    --ro-bind /usr/bin /usr/bin \
    --ro-bind /usr/lib /usr/lib \
    --ro-bind /usr/local/bin /usr/local/bin \
    --ro-bind /usr/local/lib /usr/local/lib \
    --ro-bind /opt/node/node-v22.11.0-linux-x64/ /opt/node/node-v22.11.0-linux-x64/ \
    --ro-bind /etc/alternatives /etc/alternatives \
    --ro-bind /etc/resolv.conf /etc/resolv.conf \
    --ro-bind /etc/profile.d /etc/profile.d \
    --ro-bind /etc/bash_completion.d /etc/bash_completion.d \
    --ro-bind /etc/ssl/certs /etc/ssl/certs \
    --ro-bind /etc/ld.so.cache /etc/ld.so.cache \
    --ro-bind /etc/ld.so.conf /etc/ld.so.conf \
    --ro-bind /etc/ld.so.conf.d /etc/ld.so.conf.d \
    --ro-bind /etc/localtime /etc/localtime \
    --ro-bind /usr/share/terminfo /usr/share/terminfo \
    --ro-bind /usr/share/ca-certificates /usr/share/ca-certificates \
    --ro-bind /etc/nsswitch.conf /etc/nsswitch.conf \
    --ro-bind /etc/hosts /etc/hosts \
    --ro-bind /etc/ssl/openssl.cnf /etc/ssl/openssl.cnf \
    --ro-bind /usr/share/zoneinfo /usr/share/zoneinfo \
    --ro-bind $HOME/.bashrc $HOME/.bashrc \
    --ro-bind $HOME/.profile $HOME/.profile \
    --ro-bind $HOME/.gitconfig $HOME/.gitconfig \
    --ro-bind $HOME/.local $HOME/.local \
    --bind $HOME/.claude $HOME/.claude \
    --bind $HOME/.cache $HOME/.cache \
    --file 3 $HOME/.claude.json \
    --bind &#34;$PWD&#34; &#34;$PWD&#34; \
    claude --dangerously-skip-permissions $@
</code></pre>

<p>If this looks rather idiosyncratic, it&#39;s because it is. Rather than using some generic rules, I experimented with <code>bwrap</code> until I found minimal configuration that I need to set up for my system.</p>

<p>Some interesting stuff:</p>
<ul><li><code>/tmp</code>, <code>/proc</code> and <code>/dev</code> are automatically handled by <code>bwrap</code></li>
<li>I bind-mount (ie. expose) files and directories under the same path as local machine, so there&#39;s no difference in file locations, project paths, etc</li>
<li>I don&#39;t expose entire <code>/etc</code>, just the bare minimum</li>
<li>The content of <code>$HOME/.claude.json</code> is injected into the sandbox so any changes there won&#39;t get saved to the real one</li>
<li>The content of <code>$HOME/.claude/</code> directory <em>is</em> mapped read-write, so Claude can save and modify files there (such as session data)</li>
<li><code>/opt/node/node-v22.11.0-linux-x64/</code> is my custom <code>nodejs</code> install location</li>
<li>I change the hostname so it&#39;s easy to distinguish between the host and sandbox</li></ul>

<p>I will probably be tweaking the script as needed, but this is a pretty good starting point for me.</p>

<h2 id="how-to-customize" id="how-to-customize">How to customize</h2>

<p>If you want to adapt this to another AI agent or to your system, my suggestion is to tweak the script to run <code>bash</code> instead, then run your agent manually, see what breaks and tweak as appropriate.</p>

<p>A useful command for this is <code>strace</code>, which can trace file access system calls so you can see what&#39;s needed:</p>

<pre><code>strace -e trace=open,openat,stat,statx,access -o /tmp/strace.log codex
</code></pre>

<p>Inspecting the log you can spot which files are needed and bind them as needed.</p>
</div></div>
  </body>
</html>
