<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vector-of-bool.github.io/2022/05/11/char8-memset.html">Original</a>
    <h1>Mysterious Memset</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div vb-content="" id="smart-content-area" aria-label="Content">
      
      <div clipper="">
        
        <div content="">
          <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Consider this simple function <code>chop</code>:</p>

<div><div><pre><code><span>void</span> <span>chop</span><span>(</span><span>int</span><span>*</span> <span>count</span><span>,</span> <span>std</span><span>::</span><span>string</span><span>&amp;</span> <span>str</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>*</span><span>count</span><span>;</span> <span>++</span><span>i</span><span>)</span> <span>{</span>
        <span>str</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This sets the first <code>*count</code> leading characters in <code>str</code> to zero. Very simple.</p>

<p>If we feed this program to an optimizing compiler, the machine code generated by
the compiler is roughly equivalent to the following:</p>

<div><div><pre><code><span>void</span> <span>chop</span><span>(</span><span>int</span> <span>*</span><span>count</span><span>,</span> <span>std</span><span>::</span><span>string</span> <span>*</span><span>str</span><span>)</span>
<span>{</span>
  <span>if</span> <span>(</span><span>*</span><span>count</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
    <span>long</span> <span>idx</span> <span>=</span> <span>0</span><span>;</span>
    <span>do</span> <span>{</span>
      <span>str</span><span>-&gt;</span><span>__data</span><span>[</span><span>idx</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
      <span>idx</span> <span>+=</span> <span>1</span><span>;</span>
    <span>}</span> <span>while</span> <span>(</span><span>idx</span> <span>&lt;=</span> <span>*</span><span>count</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This is pretty much equivalent to the program we gave it as input, with an extra
jump in the case of <code>*count == 0</code>. This jump is the only “optimization” done by
the compiler.</p>

<h2 id="one-small-change">One Small Change…</h2>

<p>Let’s mix it up:</p>

<div><div><pre><code><span>void</span> <span>chop</span><span>(</span><span>int</span><span>*</span> <span>count</span><span>,</span> <span>std</span><span>::</span><span>u8string</span><span>&amp;</span> <span>str</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>*</span><span>count</span><span>;</span> <span>++</span><span>i</span><span>)</span> <span>{</span>
        <span>str</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The only change is that we are now using a <code>u8string</code> (a
<code>std::basic_string&lt;char8_t&gt;</code>). From the perspective of most actual machines, a
<code>char8_t</code> is indistinguishable from a <code>char</code> (they’re both just an octet), so it
should compile to identical code, right?</p>

<p>Not so! Feeding this program to an optimizing compiler produces the following
C++-code-equivalent:</p>

<div><div><pre><code><span>void</span> <span>chop</span><span>(</span><span>int</span> <span>*</span><span>count</span><span>,</span> <span>std</span><span>::</span><span>u8string</span> <span>*</span><span>str</span><span>)</span>
<span>{</span>
  <span>if</span> <span>(</span><span>*</span><span>count</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
    <span>std</span><span>::</span><span>memset</span><span>(</span><span>str</span><span>-&gt;</span><span>__data</span><span>,</span> <span>0</span><span>,</span> <span>(</span><span>size_t</span><span>)</span><span>*</span><span>count</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This code is radically different. The loop has entirely disappeared, and is
replaced with a call to <code>memset</code>. What’s going on?</p>

<p>Consider this puzzle for yourself, and scroll further for the answer.</p>







<p>The answer, unsurprisingly, comes from the guarantees afforded to us by
undefined behavior – or rather <em>the compiler’s assumption of its absence</em>.</p>

<p>The potential undefined behavior in question most strongly affects this line in
the second sample:</p>



<p>In the second sample, which used <code>std::u8string</code>:</p>

<ol>
  <li>The compiler may assume that the write through <code>str[idx]</code> <em>cannot</em> effect
the value in <code>*count</code>. This assumption holds because we are writing through a
pointer-to-<code>char8_t</code>, which cannot be used to alias an <code>int</code>.</li>
  <li>The compiler sees that no code within the loop can affect the value of
<code>*count</code>, making <code>*count</code> a loop-invariant value, thus the read of <code>*count</code>
can be lifted out of the loop and performed once before beginning the loop.</li>
  <li>Since we increment <code>idx</code> from zero to the (invariant) value of <code>*count</code>, we
can unroll the loop into <code>*count</code>-repeated evaluations of <code>str[idx]=0</code>.</li>
  <li>This is now just a sequence of assignments to a contiguous range of memory,
so we can convert this into a <code>memset</code>.</li>
</ol>

<p>But in the first example where we used <code>std::string</code>:</p>

<ol>
  <li>C and C++ allow pointer-to-<code>char</code> to be used to inspect and manipulate the
“object representation” of other objects of different types, so a <code>char*</code>
<em>can</em> point to an <code>int</code>.</li>
  <li>The compiler must assume that the <code>char*</code> and <code>count</code> <em>might</em> alias, and thus
any write through <code>str</code> can spuriously affect the value of <code>*count</code>.</li>
  <li>Because any iteration of the loop could potentially change the value of
<code>*count</code>, <code>*count</code> is <strong>not</strong> loop-invariant, and we cannot make any
assumptions about how many times this loop will execute.</li>
</ol>



<p>For the history of C++, we have had <code>std::string</code>, <code>std::string_view</code>, and
<code>char*</code>, all of which can potentially alias any other object, and only by
tracking the provenance of pointers could a C++ compiler prove otherwise.
Pointer provenance is a tricky subject, and it is likely the case that the
compiler has absolutely no idea where an object or pointer comes from (think a
<code>const std::string&amp;</code> function parameter, or an equivalent <code>std::string_view</code>
parameter).</p>

<p>With the addition of <code>char8_t</code>, <code>std::u8string</code>, and <code>std::u8string_view</code>, we
now have string and “character” types that are guaranteed not to alias objects
of different types.</p>

  </div>
</article>

          
        </div>
      </div>
    </div>
  </div></div>
  </body>
</html>
