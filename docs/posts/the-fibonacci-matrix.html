<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ianthehenry.com/posts/fibonacci/">Original</a>
    <h1>The Fibonacci Matrix</h1>
    
    <div id="readability-page-1" class="page"><article>

<div><p>When you think about the Fibonacci sequence, you probably imagine a swirling vortex of oscillating points stretching outwards to infinity:</p>
<p><canvas id="teaser" width="384" height="256"><a href="https://ianthehenry.com/posts/fibonacci/hero.f8f0320540a779c19ec927ada02ec9ecbfd90a6d6d418f8e71e99ac4e5d4deca.png"><picture>
<img src="https://ianthehenry.com/posts/fibonacci/hero.f8f0320540a779c19ec927ada02ec9ecbfd90a6d6d418f8e71e99ac4e5d4deca.png" width="768" height="512"/></picture></a>
</canvas></p>
<p>Okay, no, obviously you don’t. <em>Yet</em>.</p>
<p>When you think about the Fibonacci sequence, you probably flush with a latent rage when you remember that it is, more often than not, the way that we introduce the concept of “recursive functions” to new programmers, in some sort of cruel hazing intended to make it harder for them to ever appreciate how recursion can help them write better programs. Sometimes we even add memoization, and call it “dynamic programming,” in order to impress upon them that even the most trivial problems deserve complex, inefficient solutions.</p>
<p>Er, okay, you probably don’t think about the Fibonacci sequence much at all. It doesn’t, you know, come up very often.</p>
<p>But I hope that you will spend some time thinking about it with me today, because I think that the Fibonacci sequence – despite being a terrible showcase for recursion – is a really interesting vector for discussing some techniques from linear algebra.</p>
<div>
<table>
<thead><tr><th>how to fibonacci</th><th>space complexity</th><th>time complexity</th></tr></thead>
<tbody>
<tr><td>insane recursion</td><td>exponential</td><td>exponential</td></tr>
<tr><td>memoized insane recursion</td><td>linear</td><td>linear</td></tr>
<tr><td>trivial iteration</td><td>constant</td><td>linear</td></tr>
<tr><td>exponentiation-by-squaring</td><td>constant</td><td>logarithmic</td></tr>
<tr><td>eigendecomposition</td><td colspan="2">let&#39;s talk</td></tr>
</tbody>
</table>
</div>
<p>We will spend no time on the recursive Fibonaccis; I’m sure that you’ve seen them before. Instead, let’s skip right to the “obvious” way to calculate Fibonacci numbers:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>function</span> <span>fib</span><span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>n</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>return</span> <span>0</span><span>;</span>
  <span>}</span>
  <span>let</span> <span>current</span> <span>=</span> <span>1</span><span>;</span>
  <span>let</span> <span>previous</span> <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span> <span>-</span> <span>1</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>const</span> <span>next</span> <span>=</span> <span>current</span> <span>+</span> <span>previous</span><span>;</span>
    <span>previous</span> <span>=</span> <span>current</span><span>;</span>
    <span>current</span> <span>=</span> <span>next</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>current</span><span>;</span>
<span>}</span>
</code></pre></div><p>No recursion, no memoization. We have two pieces of state: the “current number” and the “previous” number, and at every step of the iteration we advance both of these to new values.</p>
<p>But there’s something very interesting about this function: the new values for our state are a <em>linear combination</em> of the old values.</p>
<pre><code>current&#39;  = current + previous
previous&#39; = current
</code></pre>
<p>Using <code>x&#39;</code> to mean “the next value for <code>x</code>.”</p>
<p>And you might recognize this as a “system of linear equations.” I think it’s more obvious when we write it like this:</p>
<pre><code>current&#39;  = 1 * current + 1 * previous
previous&#39; = 1 * current + 0 * previous
</code></pre>
<p>And you might remember that there’s another, more cryptic way to write down a system of linear equations:</p>

<p>This is exactly the same thing! This is just another way of writing the equation – it’s just a shorthand notation.</p>
<p>Here, let’s test it out to make sure of that:</p>
<div>


<p>=</p>
<div>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1 • 8 + 1 • 5</td>
</tr>
<tr>
<td>1 • 8 + 0 • 5</td>
</tr>
</tbody>
</table>
</div>
<p>=</p>

</div>
<p>Well that’s exactly what we expected – 13 is the next Fibonacci number in the sequence, and 8 was the previous one.</p>
<p>We can, of course, repeat this process, by applying the system of linear equations again:</p>

<p>Or, to put that another way:</p>

<p>And here’s why we care: matrix multiplication is associative, so we can actually think of that like this:</p>

<p>Or:</p>

<p>In other words: given a system of linear equations to find the <em>next</em> state of our iteration, we can square the matrix-of-coefficients of the system to find a new system of linear equations that represents “two states from now.”</p>
<p>Of course we don’t <em>need</em> matrices to do this. We can compute a formula for “two steps” of our iteration using term substitution:</p>
<pre><code>current&#39;  = current + previous
previous&#39; = current

current&#39;&#39;  = current&#39; + previous&#39;
previous&#39;&#39; = current&#39;

current&#39;&#39;  = (current + previous) + current
previous&#39;&#39; = (current + previous)

current&#39;&#39;  = 2 * current + previous
previous&#39;&#39; = current + previous
</code></pre>
<p>Which is a new system of linear equations – which we can represent as a matrix as well.</p>

<p>We got the same result, because of course we did: multiplying by this matrix really <em>means</em> “advance to the next state.” Multiplying twice means “advance to the next state and then advance to the next state after that.”</p>
<p>And we can keep going. What’s the state three steps from now?</p>

<p>Or, more concisely:</p>

<p>If we do this repeatedly, you might notice a familiar pattern start to emerge:</p>



<p>Which makes sense, doesn’t it? Because if we multiply this matrix with the matrix <code>[1 0]</code> – our starting values – then it’s going to advance forward through six steps of the Fibonacci sequence in a single leap. So naturally we have to be encoding <em>something</em> about the sequence itself in the matrix – otherwise we wouldn’t be able to advance by N steps in constant time.</p>
<p>Now, the insight that takes this from linear to logarithmic is that we don’t have to do this multiplication one step at a time. We can multiply in leaps and bounds.</p>
<p>Let’s call our original starting matrix F, for Fibonacci.</p>

<p>We’ve already calculated F<sup>2</sup>:</p>

<p>And now it’s only one more matrix multiplication to calculate F<sup>4</sup>:</p>

<p>We can use this fact to calculate arbitrary matrix powers, by breaking the problem up into sums of powers of two:</p>

<p>And by doing that, we can calculate the nth Fibonacci number in only log<sub>2</sub>(n) steps.</p>

<p>Okay, so that’s fun and all, but that’s not really what this blog post is about.</p>
<p>I don’t know about you, but if I came across this matrix in the wild, I would not think “Oh, that’s the Fibonacci sequence”:</p>

<p>I would probably think “huh, I dunno, it’s like, a reflection, sort of, or maybe a shear; what’s a shear again, hang on, I need to see a picture.”</p>
<p>That is, I am used to thinking of matrices as transformations of <em>points in space</em> – scales and rotations and things like that. I’m not really used to thinking of matrices as “state machines.”</p>
<p>But this duality is the beauty of linear algebra! Matrices are transformations of points in space and graphs and state machines all at the same time.</p>
<p>So let’s take a look at the Fibonacci <em>transformation</em>, applied to arbitrary points in R<sup>2</sup>:</p>

<p>That animation is progressively applying and removing the transformation, so we can get some intuition for how it deforms a square. But we’re really more interested in repeated applications of the transformation. So let’s start with the same points, but multiply by that same matrix over and over:</p>

<p>Interesting. Over time, they have a tendency to stretch out along the long diagonals of this rhombus. Let’s zoom out:</p>

<p>Every time a point reflects over that diagonal, it reflects at a slightly different angle, slowly converging towards this straight line.</p>
<p>You might already have an idea of what that straight line means. You might know that, if you look at the ratio between subsequent Fibonacci numbers, they approximate the <em>golden ratio</em>:<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p>
<pre><code>1  /  1 = 1
2  /  1 = 2
3  /  2 = 1.5
5  /  3 = 1.666...
8  /  5 = 1.6
13 /  8 = 1.625
21 / 13 = 1.61538462
34 / 21 = 1.61904762
</code></pre>
<p>The golden ratio is irrational, but every subsequent Fibonacci number is a better and better rational approximation. (The golden ratio is around 1.618033988749 – so we’re already pretty close.)</p>
<p>It’s interesting to see that these estimations don’t “sneak up” on the golden ratio. In fact they alternate between over- and under-estimating it. Which is exactly what we saw in our visualization!</p>
<p>If you return to the “state machine” interpretation of our matrix, remember that the value we’re plotting as <code>x</code> is really “the current Fibonacci number,” and the value we’re plotting as <code>y</code> is “the previous Fibonacci number.” So the ratio between successive numbers – <code>x/y</code> – is just the slope of the lines that our points are traveling along. And we could see points reflecting over that diagonal, over- and under-shooting it, slowly converging… towards the line whose slope is the golden ratio.</p>
<p>Which is, in fact, the “long diagonal” of our rhombus.</p>
<p>And this makes sense, I think – this isn’t some weird coincidence. The golden ratio is all about the ratio between parts and wholes being the same as ratio between parts. And the Fibonacci sequence is all about adding together parts to become wholes that become parts in the next number of the sequence.</p>
<p>Here, our two parts are the “current” and “previous” values, and the whole that they make is the “next” Fibonacci number. Even if we start with two numbers that are completely unrelated to the Fibonacci sequence – say, <code>8</code> and <code>41</code> – the simple way that we pick the next number will cause us to approximate the golden ratio after only a few iterations:</p>
<pre><code>8 / 41 = 0.1951219
(8 + 41 = 49) / 8 = 6.125
(49 + 8 = 57) / 49 = 1.16326531
(57 + 49 = 106) / 57 = 1.85964912
(106 + 57 = 163) / 106 = 1.53773585
</code></pre>
<p>Why is that? Well, because of the definition of the golden ratio.</p>

<p>This is <em>extremely</em> unrigorous, but I can try to sketch out a very informal argument for why this is:</p>
<p>Let’s say the ratio between <code>A</code> and <code>B</code> is some unknown quantity <code>S</code>. It’s not the golden ratio, it might not be anywhere near the golden ratio; we have no idea what it is. In my 8 and 41 example, it wasn’t even in the right ballpark.</p>
<div>
<p>A/B = S</p>
<p>(A + B) / A = (1 + B / A) = 1 + (1/S)</p>
</div>
<p>So the ratio between the next element in our series and A will be <code>(1 + (1/S))</code>.</p>
<p>We still don’t know what <code>S</code> is! But if we do this <em>again</em>…</p>
<div>
<p>A&#39; / B&#39; = 1 + (1/S)</p>
<p>(A&#39; + B&#39;) / A&#39; =</p>
<p>(1 + (B&#39; / A&#39;)) =</p>
<p>1 + (1 / (1 + (1 / S)))</p>
</div>
<p>After each iteration, the original <code>S</code> will become a smaller and smaller component in the final answer, until eventually we’ll just have an expression that looks like this:</p>
<div>
<p>1 + (1 / (1 + (1 / (1 + (1 / (1 + (1 / ...)))))))</p>
</div>
<p>Whatever our original <code>S</code> was, its contribution to the final result will eventually be negligible. Even after just a few iterations, we can see that the choice of <code>S</code> doesn’t make a huge difference in the outcome:</p>
<div>
<p>1 + (1 / (1 + (1 / (1 + (1 / (1 + (1 / -5000))))))) = 1.6667</p>
<p>1 + (1 / (1 + (1 / (1 + (1 / (1 + (1 / 0.001))))))) = 1.5002</p>
</div>
<p>And of course even that will fade away after a few more steps.</p>
<p>In fact the version of that expression with an infinite number of steps – where there is no <code>S</code> at all, but just an infinite sequence of divisions – is the “continued fraction” expression of the golden ratio.</p>
<p>Except, well, I’m lying here.</p>
<p>That residue will not fade away for <em>all</em> values of <code>S</code>. First of all, if <code>S</code> is zero, it doesn’t matter how small that term gets – you’re not going to squeeze a number out of it.</p>
<p>But there is another, more interesting value of <code>S</code> that breaks this rule. There is <em>one</em> other number that will not tend towards 1.618 when you repeatedly take its reciprocal and add one. It is the number that is already one plus its own reciprocal:</p>
<div>
<p>1 + (1 / 1.61803399) = 1.61803399</p>
</div>
<p>Oh, gosh, yes, the golden ratio is one plus its own reciprocal. But I was talking about the <em>other</em> number with that property:</p>
<div>
<p>1 + (1 / -0.61803399) = -0.61803399</p>
</div>
<p>This number is (1 - φ), and it is also -φ<sup>-1</sup>. The golden ratio is weird like that.</p>
<p>That number is a weird number, because if we have two numbers with that ratio – say, <code>-1.236</code> and <code>2</code> – and we applied our transformation, those points would not spread their wings towards the diagonal. What would they do instead?</p>

<p>Aha. Well, that makes sense.</p>
<p>Some points tend towards the top right, some points tend towards the bottom left, but some points get <em>stuck</em>. Sucked into the origin, cursed to forever travel along this one straight line.</p>
<p>Points along the long diagonal also travel in a straight line – they don’t bounce over the diagonal, because they’re already on it. Let’s just focus on these perfectly straight lines:</p>

<p>Not all matrices will produce straight lines like this when you apply them repeatedly. A rotation matrix, for example, will always change the direction of every single line each time you multiply a point by it.</p>
<p>These straight lines are called <em>eigenvectors</em>, which is German for something like “intrinsic vector” or “characteristic vector.&#34;<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p>
<p>Well, to be more precise, any particular point on those straight lines is an “eigenvector.” The vector <code>[φ 1]</code> is an eigenvector, and so is <code>[-2.1φ -2.1]</code>. And the vector <code>[-1/φ 1]</code> is an eigenvector, and so is <code>[-2/φ 2]</code>.</p>
<p>But all of the eigenvectors on each line are “similar,” so I’m just going to pick <code>[φ 1]</code> and <code>[(1-φ) 1]</code> as our two representative eigenvectors.</p>
<p>When you multiply an eigenvector of a matrix by the matrix itself, you get back a new eigenvector on “the same line.” That is to say, you get back another eigenvector that is just some scalar multiple of the original eigenvector.</p>
<p>For example, when we multiply our first eigenvector by the Fibonacci matrix:</p>

<p>Well… it’s not <em>obvious</em> that this is the case, but we actually just scaled the vector by φ. Because φ<sup>2</sup> = φ + 1. The golden ratio is weird.</p>
<p>Similarly:</p>

<p>We scaled it by (1 - φ), again somewhat cryptically:</p>
<div>
<p>(1 - φ)(1 - φ) =</p>
<p>(1 - 2φ + φ<sup>2</sup>) =</p>
<p>(1 - 2φ + φ + 1) =</p>
<p>(2 - φ)</p>
</div>
<p>So when we multiply our Fibonacci matrix with its eigenvectors, we scale those numbers by φ and (1 - φ). These scaling factors are called “eigenvalues,” and it’s <em>weird</em> that they look so much like the eigenvectors. That’s… that’s a weird Fibonacci coincidence, a weird golden ratio thing, and not a general pattern that holds for eigenvectors and eigenvalues in general.</p>
<p>Okay, so why do we care about this?</p>
<p>Well, once we know the eigenvectors and eigenvalues of the matrix, we can actually perform repeated matrix multiplication in <em>constant</em> time.</p>
<p><em>…Sort of</em>. You have to imagine a big asterisk after that sentence, which I will explain below.</p>
<p>To explain how, we’re going to need to do a little bit of linear algebra. But first, I just want to restate everything I’ve said so far in explicit notation:</p>
<p>Multiplying F with each eigenvector is the same as multiplying that eigenvector by its corresponding eigenvalue. So:</p>

<p>And:</p>

<p>Right. But there’s actually a way to write those two equalities as a single equality:</p>

<p>Instead of writing out each eigenvector as a separate column vector, I stuck them into a matrix. And instead of scaling each one by a scalar, I multiplied that matrix by a diagonal matrix.</p>
<p>This is the same statement, though: right-multiplication by a diagonal matrix just means “scale the columns of the left matrix by the corresponding diagonal value.” We can gut check this by performing the multiplcation, and seeing that we’re making the exact same statements as before:</p>


<p>But now we’re making these statement about both eigenvectors in parallel.</p>
<p>This equality – this statement about how multiplication by the Fibonacci matrix scales eigenvectors – is the secret to computing Fibonacci numbers in “constant time”:</p>

<p>The trick here is that we’re going to right-multiply both sides of the equation by the inverse of our eigenvector matrix. This will eliminate it from the left-hand side entirely:</p>

<p>And now we have a new way to calculate the “next Fibonacci number.” Previously we knew how to do it by multiplying with the matrix <code>F</code>. Now we can do it by multiplying with, uhh, this inverse eigenvector matrix thing, and then the diagonal matrix of eigenvalues, and then the non-inverse matrix-of-eigenvectors.</p>
<p>Much simpler, right?</p>
<p>This is getting really long and complicated and I’m going to run out of space soon, so let’s give these things names:</p>



<p>That’s an upper-case lambda, and look, it’s just the convention for the eigenvalue matrix. Eigenvalues are called <code>λ</code>, and when you put them in a diagonal matrix you call it <code>Λ</code>. I don’t make the rules here.</p>
<p>Now that we have some abbreviations, we can write that as the much more palatable:</p>

<p>Now, the whole reason that we’re doing this is to take advantage of another trick of associativity:</p>
<div>
<div>
<p>F<sup>2</sup> = (Q Λ Q<sup>-1</sup>)(Q Λ Q<sup>-1</sup>)</p>
</div>
</div>



<p>That was very abstract, so take a second to think about what this <em>means</em>. F<sup>2</sup> is the matrix that calculates two steps of our Fibonacci state machine. And we can use this same trick to calculate <em>any</em> power of F, just by calculating powers of Λ.</p>

<p>And this is good, because Λ is a <em>diagonal</em> matrix. And it’s really easy to exponentiate a diagonal matrix! You just exponentiate each element of its diagonal. We don’t even need to use repeated squaring.</p>
<p>This means that we can actually calculate arbitrary powers of F in <em>constant</em> time… if we pretend that exponentiation of a scalar is a constant time operation.</p>
<p>It’s not, though. I mean, yes, exponentiation of an IEEE 754 64-bit floating-point <em>is</em> constant time, but that’s not what we said. We’re talking about exponentiating an irrational number, and my computer can only represent approximations of that number, and that floating-point error adds up fast. So in order to actually use this to compute large Fibonacci numbers, we would need to use arbitrary-precision floating point, and exponentiating arbitrary precision values is <em>not</em> constant time. It’s… I don’t know, probably logarithmic? But like both to the exponent and the size of the result, and the size of the result is increasing exponentially, so it nets out to linear? I don’t actually know.<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></p>
<p>But I don’t want to spoil the fun. This is still a very interesting trick, and it’s worth understanding how it works, even if it doesn’t actually give us a way to compute arbitrarily large Fibonacci numbers in constant time.</p>
<p>So: what are we doing.</p>
<p>We moved a bunch of symbols around, and we wound up with this expression:</p>

<p>But I don’t really know what Q<sup>-1</sup> means, and it’s not really clear to me why I should care. Why is multiplying by these three weird matrices the same as multiplying by F? What, intuitively, are we doing here?</p>
<p>At a high level, we’re translating points into a different coordinate system, then doing something to it, and then translating them back into our original coordinate system.</p>
<p>You already know that we can write any point in space as a vector – X and Y coordinates. That’s what we’ve been doing this whole time.</p>
<p>But we can <em>also</em> write a point in space as the sum of two other vectors. Like, <code>[5 3]</code>. We could write that as <code>[1 2] + [4 1]</code> instead. Which, okay, sure. That’s not very interesting.</p>
<p>One “interesting” way to write <code>[5 3]</code> is as the sum of these two vectors: <code>[5 0] + [0 3]</code>. Or, to say that another way:</p>

<p>This is interesting because <code>[1 0]</code> and <code>[0 1]</code> are basically the “X axis” and “Y axis.” And we can think of the point <code>[5 3]</code> as a (trivial!) linear combination of these two axes.</p>
<p>But we could pick <em>different</em> axes. We can pick any vectors we want as our axes,<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> so let’s pretend for a moment that our axes are <code>[1 1]</code> and <code>[1 -1]</code> instead. Which means that we would write <code>[5 3]</code> as:</p>

<p>Or, to write that another way:</p>

<p>Alright. Why do we care?</p>
<p>Well, we can think of this vector-of-coefficients, <code>[4 1]</code>, as another way to identify the point in space <code>x=5 y=3</code> when we we’re pretending that our axes are <code>[1 1]</code> and <code>[1 -1]</code>. Except in linear algebra we’d call these “basis vectors” instead of “axes.”</p>
<p>But how did we find the coefficients <code>[4 1]</code>? Well, I just found that one by hand; it was pretty easy. But <em>in general</em>, if we want to express some other <em>point</em> using these basis vectors – let’s say <code>[63 -40]</code> – we’ll need to solve an equation that looks like this:</p>

<p>And we can do that by, you know, regular algebra. We “divide” both sides by our matrix-of-basis-vectors, by left-multiplying with the inverse matrix:</p>

<p>And after the inverses cancel, we’re left with the following formula:</p>

<p>And the problem reduces to matrix inversion.</p>
<p>Now, I don’t know about you, but I don’t remember how to invert a matrix. I know there’s a formula in two dimensions, but the only thing I remember about it is that it involves calculating the determinant, and I forgot how to do that too. So let’s just ask a computer to invert it for us:</p>

<p>Hmm. I feel like I probably could’ve worked that out myself.</p>
<p>But that lets us solve the equation, and figure out how to write the point <code>[63 -40]</code> as a combination of the vectors <code>[1 1]</code> and <code>[1 -1]</code>:</p>

<p>Great! We did it.</p>
<p>And <em>here’s why we care:</em></p>
<p>We can use this exact same trick to write down the points in our Fibonacci sequence as a linear combination of our two eigenvectors. Like this:</p>

<p>Click or tap to add points there, to see how we can write each point in space as a combination of the “short diagonal” and “long diagonal” eigenvectors of our matrix.</p>
<p>Normally to identify a point in space we would give its XY coordinates: go this far along the X-axis, then this far along the Y-axis. But here we’re representing points in “φ” and “1 - φ” coordinates: go this far along the short diagonal, then this far along the long diagonal.</p>
<p>But how do we know how far to go along these diagonals? Well, we “divide by” the eigenvectors. In other words, we have to compute the inverse of this matrix:</p>


<p>Now, matrix inversion is boring, so I’m just presenting the answer here. This inverse matrix is how we can convert from “XY coordinates” into “eigenvector coordinates.”</p>
<p>Let’s work through a concrete example to make sure this works.</p>
<p><code>[8 5]</code> is a point on the Fibonacci sequence. We can express that as a combination of eigenvectors instead:</p>

<p>4.96 and 0.04 are the coefficients we will pair with our eigenvectors: we have to travel 4.96 units down the long diagonal, and 0.04 units along the short diagonal to arrive at the point <code>[8 5]</code>.</p>

<p>Great. It worked!</p>
<p>But that wasn’t very interesting – we just converted our point into the eigenvector basis and then right back into the normal XY basis. It was kind of a pointless transformation.</p>
<p>But we don’t have to do the unconversion immediately. We can keep the point in this “eigenbasis” for a little while, and do stuff to the vector-of-coefficients, and <em>then</em> convert it back.</p>
<p>Specifically, we can scale the coefficients by the eigenvalues of our Fibonacci matrix. We can multiply the “long diagonal” component by Φ<sup>2</sup>, and multiply the short diagonal component by (1 - Φ)<sup>2</sup>, and we’ll have a new point: something close to <code>[12.985 0.015]</code>. And if we convert that back into XY coordinates:</p>

<p>We just advanced our point two more steps along the Fibonacci sequence, with nothing more than scalar exponentiation and a constant number of vector operations.</p>
<p>This is exactly the same as the expression:</p>

<p>But as someone with no background in linear algebra, I find it easy to get lost in the notation, so it’s easier for me to think about this as operations on separate column vectors rather than as operations on matrices. Even though they are the same thing.</p>
<p>Of course, calculating two steps of the Fibonacci sequence in constant time isn’t that impressive. But we can do the same with Φ<sup>1000</sup>, and use that to calculate the thousandth Fibonacci number in constant time.</p>
<p>…Assuming we could calculate Φ<sup>1000</sup> in constant time. Which we can’t, in real life.</p>
<hr/>
<p>Alright.</p>
<p>The post is over; you saw the trick. “Eigendecomposition,” this is called.</p>
<p>I glossed over a few steps – I spent absolutely no time explaining <em>how I knew</em> the eigenvalues and eigenvectors of this matrix, for example. I just asserted that they were related to the golden ratio. But in reality you can solve for them, or ask a computer to do it for you. It’s pretty mechanical, like matrix inversion – it seems linear algebra is best explored with a repl nearby.</p>
<p>In any case, I think that the <em>why</em> of eigendecomposition is more interesting than the <em>how</em>.</p>
<p>As for the Fibonacci sequence… well, this is a pretty terrible way to actually calculate Fibonacci numbers. Even if we pretend that we only care about numbers that can fit in IEEE 754 double-precision floats, we <em>still</em> can’t use this technique to calculate very many Fibonacci numbers, because the floating-point error adds up too quickly.</p>
<p>But if we only care about double-precision floats… well, there is one more Fibonacci implementation to consider. It’s an algorithm that that runs in constant time, and constant space, and covers the full gamut of floating-point numbers without accumulating any error at all…</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>const</span> <span>fibs</span> <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>8</span><span>,</span> <span>13</span><span>,</span> <span>21</span><span>,</span> <span>34</span><span>,</span> <span>55</span><span>,</span> <span>89</span><span>,</span> <span>144</span><span>,</span> <span>233</span><span>,</span> <span>377</span><span>,</span> <span>610</span><span>,</span> <span>987</span><span>,</span> <span>1597</span><span>,</span> <span>2584</span><span>,</span> <span>4181</span><span>,</span> <span>6765</span><span>,</span> <span>10946</span><span>,</span> <span>17711</span><span>,</span> <span>28657</span><span>,</span> <span>46368</span><span>,</span> <span>75025</span><span>,</span> <span>121393</span><span>,</span> <span>196418</span><span>,</span> <span>317811</span><span>,</span> <span>514229</span><span>,</span> <span>832040</span><span>,</span> <span>1346269</span><span>,</span> <span>2178309</span><span>,</span> <span>3524578</span><span>,</span> <span>5702887</span><span>,</span> <span>9227465</span><span>,</span> <span>14930352</span><span>,</span> <span>24157817</span><span>,</span> <span>39088169</span><span>,</span> <span>63245986</span><span>,</span> <span>102334155</span><span>,</span> <span>165580141</span><span>,</span> <span>267914296</span><span>,</span> <span>433494437</span><span>,</span> <span>701408733</span><span>,</span> <span>1134903170</span><span>,</span> <span>1836311903</span><span>,</span> <span>2971215073</span><span>,</span> <span>4807526976</span><span>,</span> <span>7778742049</span><span>,</span> <span>12586269025</span><span>,</span> <span>20365011074</span><span>,</span> <span>32951280099</span><span>,</span> <span>53316291173</span><span>,</span> <span>86267571272</span><span>,</span> <span>139583862445</span><span>,</span> <span>225851433717</span><span>,</span> <span>365435296162</span><span>,</span> <span>591286729879</span><span>,</span> <span>956722026041</span><span>,</span> <span>1548008755920</span><span>,</span> <span>2504730781961</span><span>,</span> <span>4052739537881</span><span>,</span> <span>6557470319842</span><span>,</span> <span>10610209857723</span><span>,</span> <span>17167680177565</span><span>,</span> <span>27777890035288</span><span>,</span> <span>44945570212853</span><span>,</span> <span>72723460248141</span><span>,</span> <span>117669030460994</span><span>,</span> <span>190392490709135</span><span>,</span> <span>308061521170129</span><span>,</span> <span>498454011879264</span><span>,</span> <span>806515533049393</span><span>,</span> <span>1304969544928657</span><span>,</span> <span>2111485077978050</span><span>,</span> <span>3416454622906707</span><span>,</span> <span>5527939700884757</span><span>,</span> <span>8944394323791464</span><span>];</span>

<span>const</span> <span>fib</span> <span>=</span> <span>(</span><span>n</span><span>)</span> <span>=&gt;</span> <span>fibs</span><span>[</span><span>n</span><span>];</span>
</code></pre></div><p>But it’s more fun to overthink it.</p>
</div>
</article></div>
  </body>
</html>
