<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joseph8th.github.io/posts/wow-writing-literate-api-documentation-in-emacs-org-mode/">Original</a>
    <h1>Writing Literate API Documentation in Emacs Org Mode</h1>
    
    <div id="readability-page-1" class="page">
    <a href="#page-content">Skip to main content</a>
    
    <section><div rel="main">
            
<article itemscope="itemscope" itemtype="http://schema.org/Article"><header>

        
    </header><div itemprop="articleBody text">
    <p>
On a scale of &#34;NFT&#34; to &#34;Integer&#34;, <a href="http://howardism.org/Technical/Emacs/literate-programming-tutorial.html">Literate Programming</a> usually rates a little below the bottom on the usefulness scale. Unfair! It&#39;s not entirely unearned, but there are some things that &#34;LitProg&#34; (kidding!) is very good for.
</p>

<p>
With <a href="https://github.com/pashky/restclient.el">restclient</a>, <a href="https://github.com/alf/ob-restclient.el">ob-restclient</a> and Emacs Org Mode, I&#39;ll show you how to write beautiful, useful, self-generating API documentation that easily renders to a static website, using a template forked off of <a href="https://readthedocs.org/">Read the Docs</a>.
</p>

<p>
Where&#39;s the <b>&#34;WOW!&#34;</b> you may ask? Using this technique, you can entirely get rid of <a href="https://postman.com">Postman</a> or whatever clunky proprietary REST API client you&#39;re using. The API documentation <b>IS</b> the program.
</p>


<p><img src="https://joseph8th.github.io/images/lit-api-ex-1.png" alt="nil"/></p>

<p>
The only other requisite is an API to talk to. For this tutorial, we&#39;ll be using the free, public <a href="https://jsonplaceholder.typicode.com/">JSON Placeholder</a> API.
</p>

<p>
<b><b>NOTE</b></b>: Since I wrote this blog post in Org Mode, the included examples of Org are exported as plain-text examples, without syntax-highlighting. Suffice it to say that Org text looks much prettier in Emacs.
</p>

<p>
<b><b>TL;DR</b></b>: <a href="https://gist.github.com/joseph8th/9a87c4f14b867c1abe8d2e81322f4eac#file-jsonplaceholder-org">Complete Example Org File</a>
</p>

<div id="outline-container-org2ba7aa1">
<h2 id="org2ba7aa1">Getting Started</h2>
<div id="text-org2ba7aa1">
<p>
First, install and configure <code>restclient</code> and <code>ob-restclient</code> in your Emacs.
</p>

<p>
Then, create a new file in Emacs, called <code>jsonplaceholder.org</code>. At the top of this file, include the following header information (obviously change the author and email):
</p>

<pre>#+title: JSON Placeholder API Documentation
#+author: Joseph Edwards VIII
#+email: foobar@example.com

#+startup: indent
#+export_file_name: index.html
#+options: num:nil ^:nil H:5 toc:2

#+setupfile: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
</pre>

<p>
Let&#39;s talk about this header a bit, since it&#39;s not immediately apparent what&#39;s going on.
</p>

<p>
The top section is self-explanatory. The second section just tells Emacs to display org-mode with indents, specifies the name of the file to export to, and controls the way that section headings and the table of contents will be displayed.
</p>

<p>
The final section loads the HTML template <code>setupfile</code> to use when exporting to HTML. In practice, I also add a number of <code>#+html_head:</code> items to customize the <a href="https://github.com/fniessen/org-html-themes">ReadTheOrg</a> theme CSS.
</p>
</div>

<div id="outline-container-orgb247e06">
<h3 id="orgb247e06">Initialize</h3>
<div id="text-orgb247e06">
<p>
The first section we&#39;ll add will serve a functional purpose, and initialize the document. In practice, this section can be quite detailed, allowing you to obtain a bearer token, read values from a database, or otherwise initialize elements that will be used later in the program. For our simple example, we only need one element: the URL to the API.
</p>

<p>
It may seem odd to parameterize the API URL. Don&#39;t we want it shown in our requests? Perhaps. But perhaps, like most software engineers, we have separate development, staging and production environments? We would have to find and replace each URL to change environment. This way, we can just change it in one place.
</p>

<p>
One small note: we don&#39;t want to export this section to HTML. We can tell Emacs this by adding the <code>:noexport:</code> tag to the section header.
</p>

<p>
In your <code>jsonplaceholder.org</code> file, add:
</p>

<pre>* Init :noexport:

#+name: api-url
: https://jsonplaceholder.typicode.com
</pre>

<p>
Setting the <code>#+name: api-url</code> means we can reference the scalar value <code>: https://jsonplaceholder.typicode.com</code> from other source blocks in our document. <b>We can take <code>api-url</code> as input.</b>
</p>
</div>
</div>

<div id="outline-container-orgcacae73">
<h3 id="orgcacae73">Introduce</h3>
<div id="text-orgcacae73">
<p>
While in practice, we&#39;re going to be <i>using</i> <code>jsonplaceholder.org</code> to make API requests, Emacs will <i>also</i> be making API requests when we export to HTML to generate the API documentation.
</p>

<p>
That reminds us that this is documentation. So write a nice introduction for your readers, as well.
</p>

<p>
In your <code>jsonplaceholder.org</code> file, add the following (copied from the actual API documentation for JSON Placeholder):
</p>

<pre>* Introduction

JSONPlaceholder is a free online REST API that you can use whenever you need some fake data. It can be in a README on GitHub, for a demo on CodeSandbox, in code examples on Stack Overflow, ...or simply to test things locally.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc5b2cae">
<h2 id="orgc5b2cae">Making Requests</h2>
<div id="text-orgc5b2cae">
<p>
Now let&#39;s document our first request and response. JSON Placeholder provides six resources, and routes for all HTTP methods. We&#39;ll start with the <code>/posts</code> resource.
</p>

<p>
In your <code>jsonplaceholder.org</code> file, add:
</p>

<pre>* Posts

The ~/posts~ resource allows us to create, read, update, and delete posts.

#+name: get-posts
#+begin_src restclient :var api=api-url
  GET :api/posts
#+end_src
</pre>

<p>
Notice in the source block header, we are directing Org to use <code>restclient</code> as the language.
</p>

<p>
We also set the variable <code>api</code> to the value stored in the scalar named <code>api-url</code>. When using Org variables inside a source block, you just use the variable as you normally would in that language. In <code>restclient</code>, we preface variables with a colon, so that&#39;s how we use it in the request, <code>GET :api/posts</code>.
</p>

<p>
Now, make the API call by typing <code>C-c C-c</code> with the cursor inside the source block. The response will be displayed below the request block, in all its gory glory!
</p>

<p>
And this illustrates the usefulness of literate API documentation. We aren&#39;t going to include example requests and example responses that have to be updated whenever changes are made to the API endpoints or responses.
</p>

<p>
We&#39;re only including <b>real</b> requests!
</p>
</div>
</div>

<div id="outline-container-org9a0b1a6">
<h2 id="org9a0b1a6">Exporting</h2>
<div id="text-org9a0b1a6">
<p>
We only have the one request, but it&#39;s enough to export. Let&#39;s try it!
</p>

<p>
In your <code>jsonplaceholder.org</code> file, type <code>C-c C-e h o</code> to export to <code>index.html</code> in the same directory as your org file, and then open that file in the browser. It should look like this:
</p>


<p><img src="https://joseph8th.github.io/images/lit-api-ex-2.png" alt="nil"/></p>

<p>
Ok, but where&#39;s the response? Emacs didn&#39;t make the API request and include the response like I promised! Oh no!
</p>

<p>
That&#39;s OK. By default, Emacs only exports the source block. To also export results, edit the header of the source block named <code>get-posts</code>. Add <code>:exports both</code> so that it looks like:
</p>

<pre>#+begin_src restclient :var api=api-url :exports both
</pre>

<p>
And export, again. Now you should see the response, as well!
</p>


<p><img src="https://joseph8th.github.io/images/lit-api-ex-3.png" alt="nil"/></p>

<p>
No more updating example responses and including embarrassing typos! This is real, live response data.
</p>
</div>
</div>

<div id="outline-container-orga00edc6">
<h2 id="orga00edc6">Appearance</h2>
<div id="text-orga00edc6">
<p>
Before we go any further with the &#34;programming&#34; part of &#34;literate programming&#34;, let&#39;s recall for a moment that we are writing API documentation, and we want it to be clean and readable. Let&#39;s spend a little time sprucing up the appearance.
</p>

<p>
Currently, our document is ugly in three ways:
</p>

<ol>
<li>The anchors to headings are ugly, and read like: <code>index.html#orga1b1b2d</code>
</li>
<li>The response is too big! We will have to scroll for pages to get to the next request.</li>
<li>The response headers are dumped out at the bottom of the response. It&#39;s not clean JSON.</li>
</ol>
</div>

<div id="outline-container-orgca8bd34">
<h3 id="orgca8bd34">Ugly Anchors</h3>
<div id="text-orgca8bd34">
<p>
The ugly anchors issue is easily solved. When Emacs exports to HTML, it generates random anchor tags for headings, but we can easily specify a custom ID.
</p>

<p>
In your <code>jsonplaceholder.org</code> file, place your cursor at the end of the <code>Introduction</code> heading, and then type <code>C-c C-x p</code> to add a property. Type in <code>CUSTOM_ID</code> for the property name, and <code>introduction</code> for the value.
</p>

<p>
Now do the same thing for the <code>Posts</code> heading, setting <code>CUSTOM_ID</code> to <code>resource-posts</code>.
</p>

<p>
It should now look like this:
</p>

<pre>* Posts
:PROPERTIES:
:CUSTOM_ID: resource-posts
:END:
</pre>
</div>
</div>

<div id="outline-container-orgbcc066c">
<h3 id="orgbcc066c">Enormous Response</h3>
<div id="text-orgbcc066c">
<p>
Inspecting <code>index.html</code> reveals that the size of the response block is determined by the tag and class <code>pre.src</code>. Some tinkering on my part results in the following snippet:
</p>

<div><pre><span></span>&lt;style&gt;pre.src{background:#343131;color:white;max-height:500px;overflow-y:auto;}&lt;/style&gt;
</pre></div>

<p>
We can add this to our exported <code>index.html</code> very easily in Org Mode using the <code>#+html_head:</code> header. After the line that starts with <code>#+setupfile:</code>, add:
</p>

<pre>#+html_head: &lt;style&gt;pre.src{background:#343131;color:white;max-height:500px;overflow-y:auto;} &lt;/style&gt;
</pre>

<p>
Also, nobody likes &#34;Light Mode,&#34; so I changed to &#34;Dark Mode&#34;.
</p>
</div>
</div>

<div id="outline-container-org6ff91a4">
<h3 id="org6ff91a4">Ugly Response</h3>
<div id="text-org6ff91a4">
<p>
The ugly response headers we see are coming from the <code>restclient</code> package, and there&#39;s no way to suppress them without hacking over <code>restclient</code> itself. That of course is do-able â€¦ this <i>is</i> Emacs, after all.
</p>

<p>
We will instead use a <i>literate</i> solution.
</p>

<p>
One of the more powerful features of Literate Programming is language-agnosticism. We run a SQL query from Org Mode, and pipe the data to a Python source block where we manipulate it, then pass it on to Bash, then to R, then to Elisp, then to Common Lisp, then back to Python and save it back to the database.
</p>

<p>
In our case, we&#39;re going to leverage <code>shell</code> and <a href="https://github.com/stedolan/jq/wiki/Installation">the &#39;jq&#39; command-line JSON processor</a>.
</p>

<p>
Go ahead and install <code>jq</code> now, and then change your <code>Posts</code> request so it looks like the following:
</p>

<pre>#+name: get-posts
#+begin_src restclient :var api=api-url :results value
  GET :api/posts
#+end_src

#+begin_src shell :var response=get-posts :results value raw :wrap src js :exports results
  echo $response | jq
#+end_src
</pre>

<p>
And now place your cursor in the bottom (<code>shell</code>) source block, and type <code>C-c C-c</code>.
</p>

<p>
The response block calls the <code>get-posts</code> request block, and then pipes <code>$response</code> into <code>jq</code>.
</p>

<p>
Wow! No more response headers! Just nice, clean JSON.
</p>
</div>

<div id="outline-container-org2cfe5e9">
<h4 id="org2cfe5e9">Black Magic Explained</h4>
<div id="text-org2cfe5e9">
<p>
&#34;But what is this black magic?!&#34; you may ask. Let&#39;s pop the hood.
</p>

<p>
The first big change was to the request. No longer are we saying, <code>:exports both</code>. Now we are instead saying, <code>:results value</code>. As mentioned, the default for <code>:exports</code> is <i>only the source block</i>. By deleting <code>:exports both</code>, we&#39;re going back to that default. This source block will not be evaluated, nor will the results be exported.
</p>

<p>
Instead, we now tell the request, <code>:results value</code>. What does that mean? <a href="https://orgmode.org/manual/Results-of-Evaluation.html">It&#39;s complicated</a>, but basically it just means that Org gets the value from the evaluated code, itself, rather than using an external process.
</p>

<p>
The second, more obvious change is that we&#39;ve added a second source block, just for results. Several important things are happening in the block header:
</p>

<ol>
<li>We call <code>shell</code> this time. That will be whatever shell (bash, cmd.exe, fish, etc.) you are using.</li>
<li>We set a new variable <code>:var response=get-posts</code>. Now this source block will call the request block named <code>get-posts</code> and put the results in the variable named <code>response</code>.</li>
<li>We set <code>:results value raw</code> because we don&#39;t want Org to wrap the results in <code>shell</code> type.</li>
<li>We set <code>:wrap src js</code> because we DO want Org to wrap the results in <code>js</code> type.</li>
<li>We set <code>:exports results</code> because we don&#39;t want to see the source code, only the results.</li>
</ol>
<p>
Finally, inside the <code>shell</code> block, we pipe the <code>$results</code> variable into <code>jq</code>, which strips out the response header comment lines and outputs nicely formatted, prettified JSON for our results block.
</p>
</div>
</div>
</div>

<div id="outline-container-orga9f3b09">
<h3 id="orga9f3b09">Putting It All Together</h3>
<div id="text-orga9f3b09">
<p>
Let&#39;s see how our tweaks to appearance worked out! Export your <code>jsonplaceholder.org</code> file again with <code>C-c C-e h o</code> and you should now see something like:
</p>


<p><img src="https://joseph8th.github.io/images/lit-api-ex-4.png" alt="nil"/></p>
</div>

<div id="outline-container-org38184c3">
<h4 id="org38184c3">Finishing Touches</h4>
<div id="text-org38184c3">
<p>
Looks much better, but there&#39;s a few more tweaks to make. Since it&#39;s just applying the same principles we already discussed, let&#39;s fast-forward to the end.
</p>

<p>
Change your <code>jsonplaceholder.org</code> file so it looks like this:
</p>

<pre>#+title: JSON Placeholder API Documentation
#+author: Joseph Edwards VIII
#+email: foobar@example.com

#+startup: indent
#+export_file_name: index.html
#+options: num:nil ^:nil H:5 toc:2

#+setupfile: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+html_head: &lt;style&gt;pre.src{background:#343131;color:white;max-height:500px;overflow-y:auto;} &lt;/style&gt;
#+html_head: &lt;style&gt;p{margin-bottom:1em;}&lt;/style&gt;
#+html_head: &lt;style&gt;h2{padding-top:1em;margin-top:2em;border-top:darkgray 2px solid;}&lt;/style&gt;
#+html_head: &lt;style&gt;h3{padding-top:1em;margin-top:2em;border-top:lightblue 1px dashed;}&lt;/style&gt;
#+html_head: &lt;style&gt;h4{padding-top:1em;margin-bottom:1em;}&lt;/style&gt;
#+html_head: &lt;style&gt;h5{color:black;font-size:1em;padding-top:1em;margin-bottom:1em;} &lt;/style&gt;
#+html_head: &lt;style&gt;div.response&gt;h5,div.request&gt;h5{padding-top:0;margin-bottom:0.5em;color:darkgray;font-size:0.8em;}&lt;/style&gt;
#+html_head: &lt;style&gt;h6{margin-bottom:1em;}&lt;/style&gt;

* Init :noexport:

#+name: api-url
: https://jsonplaceholder.typicode.com

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

JSONPlaceholder is a free online REST API that you can use whenever you need some fake data. It can be in a README on GitHub, for a demo on CodeSandbox, in code examples on Stack Overflow, ...or simply to test things locally.

* Posts
:PROPERTIES:
:CUSTOM_ID: resource-posts
:END:

The ~/posts~ resource allows us to create, read, update, and delete posts.

** ~GET /posts~
:PROPERTIES:
:CUSTOM_ID: method-get-posts
:END:

Obtain all posts.

**** Request
:PROPERTIES:
:HTML_CONTAINER_CLASS: request
:END:

#+name: get-posts
#+begin_src restclient :var api=api-url :results value
  GET :api/posts
#+end_src

**** Response
:PROPERTIES:
:HTML_CONTAINER_CLASS: response
:END:

#+begin_src shell :var response=get-posts :results value raw :wrap src js :exports results
  echo $response | jq
#+end_src
</pre>

<p>
Now our <code>index.html</code> should look like this:
</p>


<p><img src="https://joseph8th.github.io/images/lit-api-ex-5.png" alt="nil"/></p>
</div>
</div>

<div id="outline-container-orgc3d87fe">
<h4 id="orgc3d87fe">Discussion</h4>
<div id="text-orgc3d87fe">
<p>
Briefly let&#39;s highlight a couple items in the above changes.
</p>

<p>
First, note the use of a new property, <code>:HTML_CONTAINER_CLASS: request</code> and <code>:HTML_CONTAINER_CLASS: response</code>. Upon export, this property attaches the respective CSS class of <code>.request</code> or <code>.response</code> to the <code>div</code> element containing the heading. In this way, we can style <code>div.request&gt;h5</code> and <code>div.response&gt;h5</code> to make clear what each of these blocks is for.
</p>

<p>
Also, note that we have moved our request and response sections inside a new subheading of <code>Posts</code>, called <code>GET /posts</code>. Now, when we click on &#34;Posts&#34; in the sidebar menu, we see &#34;GET /posts&#34; as a submenu item. This is controlled at by the Org header directive <code>#+options: toc:2</code> included. If we set it to <code>toc:1</code> we would not see the submenu. If we set it to <code>toc:3</code> we would see &#34;Request&#34; and &#34;Response&#34; in the submenu below &#34;GET /posts&#34;. Try it and see!
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcc7d412">
<h2 id="orgcc7d412">Finish the Job</h2>
<div id="text-orgcc7d412">
<p>
Documenting the rest of the API now proceeds according to a set pattern. Indeed, a <code>yasnippet</code> could be constructed to insert a new method section, and speed the process along.
</p>

<p>
However, that doesn&#39;t reflect the utility of the Literate Programming approach to API documentation. Normally, I write this documentation <i>as I am building new API endpoints</i>, in order to test and perfect the endpoint. I use this method <i>instead of Postman</i>, and when I am done working on the API, it is <i>already documented</i> and under version control with the source code.
</p>

<p>
For example, I would have written what we have so far <i>at the same time I was writing</i> <code>GET :api/posts</code>, and I would have used that file extensively, making note of any parameters required.
</p>

<p>
When I pushed code, anyone on my team (who uses Emacs) could open the <code>README.org</code> and test the API for themselves.
</p>

<p>
As a last step before I push code, I can generate the <code>index.html</code> and pop it into a public static directory. Now when you browse to the base URL of my API, instead of getting an error message, you get API documentation.
</p>

<p>
Let&#39;s wrap up this post by documenting the rest of the <code>/posts</code> resource methods. This will also serve to illustrate how to use <code>restclient</code> to perform <code>POST</code>, <code>PUT</code> and <code>DELETE</code> HTTP methods.
</p>
</div>

<div id="outline-container-orga8e87bf">
<h3 id="orga8e87bf">Adding a POST Method</h3>
<div id="text-orga8e87bf">
<p>
Let&#39;s add a <code>POST /posts</code> header under <code>GET /posts</code>. You can copy and paste, and then change the following:
</p>

<ol>
<li>Change <code>:CUSTOM_ID:</code> from <code>method-get-posts</code> to <code>method-post-posts</code>
</li>
<li>Change the &#34;Request&#34; <code>#+name:</code> from <code>get-posts</code> to <code>post-posts</code>
</li>
<li>Change the &#34;Response&#34; <code>:var response</code> from <code>get-posts</code> to <code>post-posts</code>
</li>
</ol>
<p>
Now, add the variable <code>:var user-id=1</code> to the <code>post-posts</code> request source block header. With <code>requests</code>, we also need to specify the content type and JSON payload to deliver.
</p>

<p>
Notice that we can use Org variables <i>inside the JSON payload</i>. <b>WOW!</b>
</p>

<p>
The final POST request should look like:
</p>

<pre>#+name: post-posts
#+begin_src restclient :var api=api-url :var user-id=1 :results value
  POST :api/posts
  Content-Type: application/json

  {
    &#34;title&#34;: &#34;foo&#34;,
    &#34;body&#34;: &#34;bar&#34;,
    &#34;userId&#34;: :user-id
  }
#+end_src
</pre>

<p>
Now, when you put the cursor in the &#34;Response&#34; block and type <code>C-c C-c</code> you should get back the new post data you created in JSON Placeholder. It should look something like:
</p>

<div><pre><span></span><span>{</span>
  <span>&#34;title&#34;</span><span>:</span> <span>&#34;foo&#34;</span><span>,</span>
  <span>&#34;body&#34;</span><span>:</span> <span>&#34;bar&#34;</span><span>,</span>
  <span>&#34;userId&#34;</span><span>:</span> <span>1</span><span>,</span>
  <span>&#34;id&#34;</span><span>:</span> <span>101</span>
<span>}</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgd34f326">
<h3 id="orgd34f326">Adding a PUT Method</h3>
<div id="text-orgd34f326">
<p>
As you can imagine, the process proceeds similarly. Copy and paste <code>POST /posts</code> to <code>PUT /posts/:id</code>, and change the custom ID, request name, and response variable to <code>put-posts</code>.
</p>

<p>
Now our request should look similar to a POST request, except now we must specify the post&#39;s <code>id</code> in the URL, and the JSON we use will update an existing post, rather than creating a new one.
</p>

<p>
Our final PUT request should look like:
</p>

<pre>#+name: put-posts
#+begin_src restclient :var api=api-url :var id=1 :var user-id=1 :results value
  PUT :api/posts/:id
  Content-Type: application/json

  {
    &#34;title&#34;: &#34;foo&#34;,
    &#34;body&#34;: &#34;bar&#34;,
    &#34;userId&#34;: :user-id
  }
#+end_src
</pre>
</div>
</div>

<div id="outline-container-orgf0b7554">
<h3 id="orgf0b7554">Adding a DELETE Method</h3>
<div id="text-orgf0b7554">
<p>
Surprise, surprise! Same idea as before. Copy, paste, change, run, profit!
</p>

<pre>#+name: delete-posts
#+begin_src restclient :var api=api-url :var id=1 :results value
  DELETE :api/posts/:id
#+end_src
</pre>
</div>
</div>
</div>

<div id="outline-container-org5938bd6">
<h2 id="org5938bd6">Conclusion</h2>
<div id="text-org5938bd6">
<p>
Our final API documentation isn&#39;t very detailed (we only documented the <code>/posts</code> resource) but the rest is just a repetition of what we&#39;ve already discussed. Still, it&#39;s quite nice, and can easily be made nicer:
</p>


<p><img src="https://joseph8th.github.io/images/lit-api-ex-6.png" alt="nil"/></p>

<p>
Also, as discussed, it would be easy enough to write a <code>yasnippet</code> to automate create new method sections, then tab from field to field filling it out.
</p>

<p>
Also as discussed, that&#39;s not really the most useful approach to writing Literate API documentation. More useful is to write it as you go, using the document instead of Postman. Then not only is your documentation never wrong or out of sync with the API, but you don&#39;t have to go back and &#34;waste time&#34; documenting something you&#39;ve already completed!
</p>
</div>
</div>

<div id="outline-container-org2eec9e4">
<h2 id="org2eec9e4">Next Steps</h2>
<div id="text-org2eec9e4">
<p>
More advanced Literate Programming techniques may also prove useful when writing Literate API Documentation.
</p>

<p>
I have one such document I wrote for the <a href="https://wurkzen.com">Wurkzen API</a> which allows you to acquire and cache a bearer token used in later requests.
</p>

<p>
It then creates a number of objects using the API, and then uses them to construct an entire dummy client, customers, locations, and perform all the API actions against dummy data that was created by the document, and then deleted by the document.
</p>

<p>
And if there are errors in my API, then the API documentation displays the errors! It also acts as an integration test, as detailed as you want to make it.
</p>

<p>
AND every request made by Emacs as it exports to HTML is displayed in Emacs <code>minibuffer</code> and logged in Emacs <code>*Messages*</code> buffer, so you can find errors with an incremental search instead of reading the <code>index.html</code>.
</p>

<p>
Literate Programming: beautiful, elegant, powerful.
</p>

<p>
And useful!
</p>
</div>
</div>


    </div>
    </article>
</div>
    </section><!-- fancy dates --><!-- end fancy dates -->


</div>
  </body>
</html>
