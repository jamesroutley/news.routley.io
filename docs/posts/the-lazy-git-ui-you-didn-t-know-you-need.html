<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bwplotka.dev/2025/lazygit/">Original</a>
    <h1>The lazy Git UI you didn&#39;t know you need</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><p>When my son was born last April, I had ambitious learning plans for the upcoming 5w paternity leave. As you can imagine, with two kids, life quickly verified this plan üôÉ. I did eventually start <em>some</em> projects. One of the goals (sounding rebellious in the current AI hype cycle) was to learn and use <a href="https://neovim.io/" target="_blank" rel="noopener noreffer">neovim</a>
for coding. As a <a href="https://www.jetbrains.com/go" target="_blank" rel="noopener noreffer">Goland</a>
aficionado, I (and my wrist) have always been tempted by no-mouse, OSS, <a href="https://pkg.go.dev/golang.org/x/tools/gopls" target="_blank" rel="noopener noreffer">gopls</a>
based, highly configurable dev setups.</p>
<p>Long story short, I‚Äôd still stick to Goland for my professional coding (for now), but during the experiments with <code>nvim</code>, I accidentally stumbled upon <a href="https://github.com/jesseduffield/lazygit" target="_blank" rel="noopener noreffer">lazygit</a>
Git UI. I literally mistyped <code>&lt;space&gt;gg</code> instead of <code>gg</code>, which opened up the built-in <code>lazygit</code> overlay UI.</p>
<p>A week later, I have already switched all my <code>git</code> workflows to <code>lazygit</code> (also outside <code>nvim</code>), and I have been using it since then. In this post, I‚Äôd like to explain why it happened so quickly, so:</p>
<ul>
<li>What makes <code>lazygit</code> so special?</li>
<li>How can it make you more productive?</li>
<li>What we can all learn from <code>lazygit</code> around designing incredible software with seamless UX?</li>
</ul>
<p>Let‚Äôs jump in!</p>

<p>Likely every developer knows and (in some form) uses the <a href="https://git-scm.com/docs" target="_blank" rel="noopener noreffer">git CLI</a>
. It‚Äôs relatively simple, and it seems incredibly stable ‚Äì the only change I noticed in the last decade was the new <code>git switch</code> command, although I still haven‚Äôt ‚Äúswitched‚Äù to it from the lovely <code>git checkout</code>üôÉ .</p>
<p>As a result, it‚Äôs common to see developers memorize a few commands you typically use (e.g.<code>clone</code>, <code>fetch/pull</code>, <code>config/remote</code>, <code>add/rm</code>, <code>status</code>, <code>checkout</code>, <code>commit</code>, <code>push</code>, <code>cherry-pick</code>, <code>rebase</code>, <code>merge</code>, <code>log</code>) and stick to the CLI. In fact, in <a href="https://survey.stackoverflow.co/2022/#section-version-control-interacting-with-version-control-systems" target="_blank" rel="noopener noreffer">2022, 83% of the StackOverflow responders said they prefer CLI to other interfaces</a>
and that number is likely still quite high nowadays.</p>
<p>However, <a href="https://git-scm.com/downloads/guis" target="_blank" rel="noopener noreffer">graphical interfaces</a>
and generally other <code>git</code> compatible clients do exist:</p>
<ul>
<li>Some of them offer more or less the same <code>git</code> workflows as the original <code>git</code> CLI, just more visually appealing and with buttons/interactivity instead of remembering the CLI flags, e.g. <a href="https://git-scm.com/docs/git-gui" target="_blank" rel="noopener noreffer">git gui</a>
, <a href="https://github.com/apps/desktop" target="_blank" rel="noopener noreffer">GitHub Desktop</a>
or <code>lazygit</code> discussed here.</li>
<li>Other projects add more magic (e.g. AI), and potentially new light abstractions/workflows in an attempt to simplify or enhance <code>git</code> use e.g. <a href="https://www.gitkraken.com/" target="_blank" rel="noopener noreffer">GitKraken</a>
.</li>
<li>There are even projects like recently popular <a href="https://github.com/jj-vcs/jj" target="_blank" rel="noopener noreffer">jj</a>
tool that completely abstracts away <code>git</code> API and replace it with a new source control flows to ‚Äúsimplify‚Äù them or unify them across various <a href="https://en.wikipedia.org/wiki/Version_control" target="_blank" rel="noopener noreffer">VCS</a>
other than <code>git</code> (e.g. <code>mercurial</code>, Google <a href="https://www.youtube.com/watch?v=W71BTkUbdqE&amp;t=645s" target="_blank" rel="noopener noreffer">Piper</a>
and everything else you wished it was <code>git</code>, but it‚Äôs not üòõ).</li>
</ul>
<p>What you choose for your work is entirely up to you. Depending on what you are passionate about, how you work with <code>git</code> and what type of software you are touching (monorepo vs small repos, closed vs open source, GitHub vs other hosting solutions, where you deploy, etc.), different clients might be more or less productive for you.</p>
<blockquote>
<p>NOTE: If you‚Äôre new to software engineering, don‚Äôt skip learning the <code>git</code> CLI. Even if you use some higher-level interfaces later on, it will help you understand what they do in the background, plus sooner or later you will end up debugging some remote VM or container with no UI access (e.g. CI systems).</p>
<p>Also, as documented in the official <code>git</code> documentation, <a href="https://git-scm.com/book/en/v2/Appendix-A:-Git-in-Other-Environments-Graphical-Interfaces#:~:text=the%20command%2Dline%20is%20still%20where%20you%E2%80%99ll%20have%20the%20most%20power%20and%20control%20when%20working%20with%20your%20repositories." target="_blank" rel="noopener noreffer">‚Äúthe command-line is still where you‚Äôll have the most power and control when working with your repositories.&#34;</a>
</p>
</blockquote>
<p>For me, I need something:</p>
<ul>
<li>simple and fast to limit the context switch overhead.</li>
<li><code>git</code> CLI-native to have fewer things that can go wrong.</li>
<li>‚Äúdiscoverable‚Äù and interactive, as I am bad at remembering keybindings and commands (I need my brain memory for more fun bits).</li>
</ul>
<p>For those reasons, early in my career, I started depending on a hybrid workflow, with a few GUI tools:</p>
<ul>
<li><a href="https://git-scm.com/docs/git-gui" target="_blank" rel="noopener noreffer">git gui</a>
instead of <code>status</code>, <code>commit</code>, <code>config/remote</code>, <code>add/rm</code> and <code>push</code>.</li>
<li><a href="https://git-scm.com/docs/gitk" target="_blank" rel="noopener noreffer">gitk</a>
instead of <code>log</code>.</li>
<li><code>git</code> CLI for everything else (e.g. rebasing/complex merging).</li>
</ul>
<p>I don‚Äôt remember why specifically those (AFAIK, decade ago there wasn‚Äôt anything else), but I literally have been using them non-stop until this year!</p>
<p>A few years ago, because of the 1990-style look of those UIs, lack of active development and modern features, I looked around for some alternatives. I remember I was quickly demotivated when I accidentally lost all my local changes on a single mouse click on the wrong thing in one of the tools üôà (starts with <code>G</code> and ends with <code>N</code>). After that, I was sceptical I‚Äôd find some new tool anytime soon. The arguments to motivate me to make a switch would need to be strong.</p>
<p>Turns out, an open mind and a bit of curiosity in a random moment gave more fruit than tailored research. By accident, I noticed <code>lazygit</code> and after a short try, it became my main <code>git</code> tool.</p>

<p>Somehow, <a href="https://github.com/jesseduffield/lazygit" target="_blank" rel="noopener noreffer">lazygit</a>
ticked so many boxes for me:</p>
<ul>
<li>It‚Äôs easy to use; it makes you productive from day 1.</li>
<li>It enables you to do more (and faster), even teaching you along the way.</li>
<li>It‚Äôs a TUI (terminal user interface), making it incredibly fast, portable and visually consistent.</li>
</ul>
<p>Many of the tool‚Äôs benefits are also amazing learning on how to build brilliant devtools and software in general.</p>
<p><img src="https://www.bwplotka.dev/svg/loading.min.svg" data-src="./lazygit-intellij.png" data-srcset="./lazygit-intellij.png, ./lazygit-intellij.png 1.5x, ./lazygit-intellij.png 2x" data-sizes="auto" alt="./lazygit-intellij.png" title="lazygit"/></p>
<blockquote>
<p><code>lazygit</code> used via <a href="https://plugins.jetbrains.com/plugin/24917-lazygit-in-editor-terminal" target="_blank" rel="noopener noreffer">lazygit IntelliJ plugin</a>
on my <code>git</code> clone of Prometheus project.</p>
</blockquote>
<p>Personally, probably the best thing about the <code>lazygit</code> is its UX, notably how easy it is to use this tool, with just a basic understanding of the <code>git</code> CLI. Generally, it seems that a nice user experience is achieved due to deliberate choice of strong consistency, deliberate visualizations and interactive menus. Let me explain.</p>

<p><code>lazygit</code> is incredibly well organized and visually consistent. <code>lazygit</code> TUI consists of a set of boxes (‚Äúviews‚Äù) with consistent behaviour. Most views are generally visible, always, no matter what operation you are doing (unless you zoom in). You always have a focus on one box. It‚Äôs visibly clear that some boxes have ‚Äútabs‚Äù. When you interact with boxes on the left, the right box changes.</p>
<p>Then, <code>lazygit</code> generally sticks to native <code>git</code> terms and abstractions, which reduces the initial learning curve. In fact, this tool even teaches you about standard, yet a bit more advanced <code>git</code> operations (e.g. <code>bisect</code> which I used to do manually) and terms (e.g. TIL <a href="https://medium.com/@michotall95/hunk-in-git-f7b7855d47ae" target="_blank" rel="noopener noreffer"><code>hunk</code></a>
which is an official <code>git</code> term for a piece of relevant code).</p>
<p>Finally, by default, <code>lazygit</code> is pretty consistent with the feeling and keybindings of <code>vim</code>. This means that <code>q</code> will quit the tool, <code>h/j/k/l</code> (or arrows) are for navigation, <code>/</code> for filtering and <code>y</code> for copy. Then, similar to <code>vim</code> it attempts to follow the name of the command, e.g. <code>c</code> commits, <code>a</code> adds all, <code>A</code> amends, <code>f</code> fetches, <code>p</code> pulls, <code>P</code> pushes, <code>r</code> rebases.</p>
<p>This is incredibly important as your common workflows can be easily memorized and invoked in a quick set of a few keystrokes (see <a href="#enhanced-git-workflows" rel="">enhanced workflows</a>
). Now, as I mentioned before, that‚Äôs a double-edged sword, because if your brain is lazy like mine, you will end up staring at the <code>vim/nvim</code> view trying to remember what the command was to select and copy things (or <a href="https://cdn.sanity.io/images/jo7n4k8s/production/7a0bf96c6e3155ca56c74723cb0c0767517a4429-324x318.jpg?auto=format" target="_blank" rel="noopener noreffer">quit vim</a>
).</p>
<p><code>lazygit</code> solves the above with a limited set of commands (that‚Äôs a good thing: <a href="https://en.wikipedia.org/wiki/Unix_philosophy" target="_blank" rel="noopener noreffer">do one thing and do it well</a>
) and great ‚Äúdiscoverability‚Äù.</p>

<p><code>lazygit</code> strikes an amazing balance of showing data you need when you need it. When you open this tool, it‚Äôs obvious you want to do some <code>git</code> trickery, so it‚Äôs likely a good thing to give you all you need to know, in a pill:</p>
<ul>
<li>What repo is this.</li>
<li>All staged and unstaged files with changes (<code>git status</code>).</li>
<li>What branch are you on.</li>
<li>The top ~10 commits on this branch.</li>
<li>Top stash item.</li>
<li>Last git commands you performed.</li>
<li>Core actions/commands you can do with their keybindings.</li>
</ul>
<p>It‚Äôs a lot of data! Yet <code>lazygit</code> somehow manages to show you all of this without visually overwhelming you:</p>
<p><img src="https://www.bwplotka.dev/svg/loading.min.svg" data-src="./lazygit-discoverability.png" data-srcset="./lazygit-discoverability.png, ./lazygit-discoverability.png 1.5x, ./lazygit-discoverability.png 2x" data-sizes="auto" alt="./lazygit-discoverability.png" title="img"/></p>
<blockquote>
<p>Consistent and self-explanatory views with a flat action menu allow you to find the data you need when you need it quickly.</p>
</blockquote>
<p>This context is game-changing:</p>
<ul>
<li>If you never used this tool, or if you had spent one month doing meetings, reviews and design docs at work, and you return to coding finally, you immediately know <strong>where you are</strong> and <strong>where things are</strong>.</li>
<li>It reduces the risk of surprises and mistakes (<code>&#34;ups! I pushed to main directly sorry!&#34;</code>), saving you a solid amount of <code>SWEh</code> (software engineering hours) monthly.</li>
<li>Normally to double-check those things you would need to run multiple commands and check different windows. <code>lazygit</code> immediately removes that context switching.</li>
<li>Even if you forget important keybindings for actions, it‚Äôs quick to check them on the footer or with <code>?</code>.</li>
</ul>
<p>But there‚Äôs more, <code>lazygit</code> guides you on all operations with interactivity.</p>

<p>In other UI tools, you have hundreds of buttons, with multiple layers of nested menus. <code>lazygit</code> has a different approach. This tool teaches you on the way, what‚Äôs possible and when. For example:</p>
<ul>
<li>Push will give you a warning of divergence with upstream if any. Clicking <code>Enter</code> will do <code>--force</code> push, <code>Esc</code> will cancel.</li>
<li>Rebase will ask you, if you want the interactive one or not and double-check the branch.</li>
</ul>
<p><img src="https://www.bwplotka.dev/svg/loading.min.svg" data-src="/2025/lazygit/rebase-check.png" data-srcset="/2025/lazygit/rebase-check.png, /2025/lazygit/rebase-check.png 1.5x, /2025/lazygit/rebase-check.png 2x" data-sizes="auto" alt="/2025/lazygit/rebase-check.png" title="rebase-check.png" width="1167"/></p>
<ul>
<li>Interactive rebase is much more guided and interactive, than <code>git rebase --interactive</code>. No need to manually type and remember special words (e.g. <code>pick/drop/squash</code> or <code>p/d/s</code>). The <code>&lt;c-j&gt;</code>, <code>&lt;c-k&gt;</code> keys also quickly move commits up and down (reordering).</li>
</ul>
<p><img src="https://www.bwplotka.dev/svg/loading.min.svg" data-src="/2025/lazygit/rebase.png" data-srcset="/2025/lazygit/rebase.png, /2025/lazygit/rebase.png 1.5x, /2025/lazygit/rebase.png 2x" data-sizes="auto" alt="/2025/lazygit/rebase.png" title="rebase.png" width="1335"/></p>
<ul>
<li>Git conflicts after rebase will be highlighted. After you fix them <code>lazygit</code> automatically will ask you if you want to commit them and auto continue the rebase.</li>
<li>When switching branches with conflicting changes, <code>lazygit</code> will automatically ask you if you want to auto-stash those changes etc.</li>
</ul>
<p>Generally, <code>lazygit</code> guides you in your workflows with minimal distractions and guesswork. This builds trust very quickly, allowing adoption of faster workflows.</p>

<p>Eventually, <code>lazygit</code> boosted productivity around git workflows for me and for many other existing happy users.</p>
<p>What‚Äôs impressive is that <code>lazygit</code> does it without adding entirely new workflows. Instead, it makes what <code>git</code> CLI offers much more usable, safer, quicker and discoverable. It teaches you better patterns.</p>
<p>One example is highlighted with custom patching. Imagine you made some changes, committed them, but then you want to bring back a few lines (but not all) to what it was before, from an earlier commit. My previous flow used to be either:</p>
<ul>
<li>Local IDE history (slow-ish, too much granularity (every file save), not always available).</li>
<li><code>git gui</code> tool I clicked <code>amend</code> which would pull all changed files from that commit to <code>staged</code> area, then I find lines I want, manually copy them (with those git diff <code>+</code> and <code>-</code> chars!) and paste to IDE, then trim unwanted chars. Pretty horrible habit (:</li>
</ul>
<p>When using <code>lazygit</code>, I obviously tried to replicate my broken workflow. I couldn‚Äôt because <code>lazygit</code> diffs are not intuitively select+copy-able (it might be fixable over time; not the highest priority, but people want this e.g. <a href="https://github.com/jesseduffield/lazygit/issues/4511" target="_blank" rel="noopener noreffer">1</a>
, <a href="https://github.com/jesseduffield/lazygit/issues/4365" target="_blank" rel="noopener noreffer">2</a>
). I even <a href="https://github.com/jesseduffield/lazygit/issues/3967#issuecomment-3159742037" target="_blank" rel="noopener noreffer">+1 one some issue around it</a>
, and I‚Äôm glad I did, because the maintainer pointed me to‚Ä¶ 10x simpler workflow: native reset/patch per line/hunk flow!</p>
<p><img src="https://www.bwplotka.dev/svg/loading.min.svg" data-src="/2025/lazygit/patches.png" data-srcset="/2025/lazygit/patches.png, /2025/lazygit/patches.png 1.5x, /2025/lazygit/patches.png 2x" data-sizes="auto" alt="/2025/lazygit/patches.png" title="patching.png" width="993"/></p>
<blockquote>
<p>All git diffs in <code>lazygit</code> (no matter if unstaged/staged/stashed/committed changes) support per line or hunk selection and patching/selection.</p>
</blockquote>
<p>With this, my ‚Äúline reset from the last commit‚Äù workflow is:</p>
<ul>
<li>simpler</li>
<li>within a single place</li>
<li>works for any commit (not only the latest)</li>
</ul>
<p>Steps in <code>lazygit</code>: <em>focus on commits view &gt; select commit &gt; select file &gt; select lines to reset &gt; patch options &gt; ‚Äúremove patch from the original commit‚Äù</em>. All either mouse-assisted or <code>4 enter enter space &lt;c-p&gt; d</code> within seconds.</p>
<p>Those short key bindings are game changers in general. I‚Äôd recommend starting with a slower, but careful mouse-assisted flow, then naturally you memorize the needed keystrokes without noticing. For me, after some time, some quick flows became a habit, I was using shortcuts unconsciously.</p>
<p>As a result, my common <code>git</code> flows, with <code>lazygit</code>, were significantly improved:</p>
<h5 id="iterating-on-changes-and-updating-upstream"><a href="#iterating-on-changes-and-updating-upstream"></a>Iterating on changes and updating upstream:</h5>
<p>My typical flow to ensure clean commit log:</p>
<ul>
<li><em>select files to commit &gt; add to the last commit (amend) &gt; force push</em></li>
<li><code>2 space A P enter</code></li>
</ul>
<h5 id="iterating-on-changes-and-updating-upstream-with-a-new-commit"><a href="#iterating-on-changes-and-updating-upstream-with-a-new-commit"></a>Iterating on changes and updating upstream with a new commit:</h5>
<ul>
<li><em>select files to commit &gt; create new commit &gt; push</em></li>
<li><code>2 space c &lt;type commit title&gt; P</code></li>
</ul>

<p>I generally do an interactive rebase for this. I avoid merges, unless squashed.</p>
<ul>
<li><em>select branch &gt; rebase &gt; interactive rebase &gt; arrange commits &gt; rebase options &gt; continue</em></li>
<li><code>3 r i &lt;s/p/d/.. to arrange rebase&gt; m c</code></li>
</ul>

<p>Normally you would need to do full interactive rebase against <code>HEAD~4</code> or something, but now:</p>
<ul>
<li><em>select commit &gt; drop</em></li>
<li><code>4 d</code></li>
</ul>

<ul>
<li><em>select commit &gt; select file &gt; remove</em></li>
<li><code>4 enter d</code></li>
</ul>

<p>This is normally a bit painful, but now:</p>
<ul>
<li><em>select commit &gt; select file &gt; select lines or hunks &gt; patch options &gt; move patch into new commit after the original commit &gt; create new commit</em></li>
<li><code>4 enter enter &lt;c-p&gt; n &lt;type commit title&gt; enter</code></li>
</ul>
<p><img src="https://www.bwplotka.dev/svg/loading.min.svg" data-src="/2025/lazygit/split.png" data-srcset="/2025/lazygit/split.png, /2025/lazygit/split.png 1.5x, /2025/lazygit/split.png 2x" data-sizes="auto" alt="/2025/lazygit/split.png" title="split.png" width="1179"/></p>

<p>Typically, it meant copying commit SHAs around; prone to errors. Now:</p>
<ul>
<li><em>select branch &gt; select commit &gt; copy for cherry-pick (you can buffer many) &gt; select target branch &gt; go to commits &gt; paste</em></li>
<li><code>3 4 C 3 4 V</code></li>
</ul>
<p>‚Ä¶and many more!</p>

<p>To me, <code>lazygit</code> is not only an amazing tool for everyday use, but also an inspiration around devtools UX. The <a href="#whats-amazing-in-lazygit" rel="">simplicity, consistency, discoverability, sane defaults, shortcuts for common flows and interactivity</a>
should be on the radar for anyone who builds devtools. Not mentioning deep <a href="https://github.com/jesseduffield/lazygit/blob/master/docs/Config.md" target="_blank" rel="noopener noreffer">configurability</a>
, a healthy dose of <a href="https://github.com/jesseduffield/lazygit?tab=readme-ov-file#invoke-a-custom-command" target="_blank" rel="noopener noreffer">extensibility</a>
, being fully free (<a href="https://github.com/jesseduffield/lazygit?tab=readme-ov-file#sponsors" target="_blank" rel="noopener noreffer">donations possible!</a>
), a <a href="https://github.com/jesseduffield/lazygit/graphs/contributors" target="_blank" rel="noopener noreffer">healthy OSS situation</a>
and‚Ä¶ tool being written 100% in Go! (:</p>
<p>Imagine what other tools we could write, reusing similar patterns or even similar UX! <a href="https://github.com/jesseduffield/gocui" target="_blank" rel="noopener noreffer">TUI framework</a>
and <a href="https://github.com/jesseduffield/lazygit/" target="_blank" rel="noopener noreffer"><code>lazygit</code> code is fully OSS (MIT)</a>
, so anyone has a healthy base for building different tools. I do have ideas for a few tools, especially around some extremely manual release workflows in our ecosystems. Let‚Äôs collaborate! üí™</p>

<p>Hope this write-up was useful for you!</p>
<p>Even with the current advancement in GenAI, statistical aspect of LLMs makes them not a great fit for reliable and accurate version control changes that projects and systems have to rely on. Some <a href="https://github.com/jesseduffield/lazygit/issues/2579" target="_blank" rel="noopener noreffer">LLM assist (e.g. generating commit messages)</a>
will eventually come to <code>lazygit</code> and git tooling, but the core of <code>lazygit</code> is to remain incredibly relevant for the (increasingly AI-assisted) software development cycles.</p>
<p>Kudos to <a href="https://github.com/jesseduffield/lazygit?tab=readme-ov-file#sponsors" target="_blank" rel="noopener noreffer">all maintainers, contributors and sponsors</a>
of <code>lazygit</code> for an amazing work!</p>
<p>Feel free to comment, give feedback AND use and contribute to the <code>lazygit</code> project! Happy coding!</p>
</div></div>
  </body>
</html>
