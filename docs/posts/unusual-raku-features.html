<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.com/hillelwayne/archive/five-unusual-raku-features/">Original</a>
    <h1>Unusual Raku Features</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    <date>
                        
                            November 12, 2024
                        </date>
                
                
                
                    <h2>
                        Junctions, whatevers, hypers, and more!
                    </h2>
                

                

                
                    
                        <h3><a href="https://leanpub.com/logic/" target="_blank"><em>Logic for Programmers</em></a> is now in Beta!</h3>
<p><a href="https://leanpub.com/logic/" target="_blank">v0.5 marks the official end of alpha</a>! With the new version, all of the content I wanted to put in the book is now present, and all that&#39;s left is copyediting, proofreading, and formatting. Which will probably take as long as it took to actually write the book. You can see the release notes in the footnote.<sup id="fnref:release-notes"><a href="#fn:release-notes">1</a></sup></p>
<p>And I&#39;ve got a snazzy new cover:</p>
<p><img alt="The logic for programmers cover, a 40x zoom of a bird feather" src="https://assets.buttondown.email/images/26c75f1e-e60a-4328-96e5-9878d96d3e53.png?w=960&amp;fit=max"/></p>
<p>(I don&#39;t actually like the cover that much but it <em>looks</em> official enough until I can pay an actual cover designer.)</p>

<p>Last year I started learning Raku, and the sheer bizarreness of the language left me describing it as <a href="https://buttondown.com/hillelwayne/archive/raku-a-language-for-gremlins/" target="_blank">a language for gremlins</a>. Now that I&#39;ve used it in anger for over a year, I have a better way of describing it:</p>
<blockquote>
<p>Raku is a laboratory for language features.</p>
</blockquote>
<p>This is why it has <a href="https://docs.raku.org/language/concurrency" target="_blank">five different models of concurrency</a> and eighteen ways of doing anything else, because the point is to <em>see</em> what happens. It also explains why many of the features interact so strangely and why there&#39;s all that odd edge-case behavior. Getting 100 experiments polished and playing nicely with each other is much harder than running 100 experiments; we can sort out the polish <em>after</em> we figure out which ideas are good ones.</p>
<p>So here are &#34;five&#34; Raku experiments you could imagine seeing in another programming language. If you squint.</p>
<h3><a href="https://docs.raku.org/type/Junction" target="_blank">Junctions</a></h3>
<p>Junctions are &#34;superpositions of possible values&#34;. Applying an operation to a junction instead applies it to every value inside the junction.  </p>
<div><pre><span></span><code>&gt; <span>2</span><span>|</span><span>10</span>
<span>any</span>(<span>2</span>, <span>10</span>)

&gt; <span>2</span><span>&amp;10</span> + <span>3</span>
<span>all</span>(<span>5</span>, <span>13</span>)

&gt;(<span>1</span><span>&amp;2</span>) + (<span>10</span><span>^</span><span>20</span>)
<span>all</span>(<span>one</span>(<span>11</span>, <span>21</span>), <span>one</span>(<span>12</span>, <span>22</span>))
</code></pre></div>
<p>As you can probably tell from the <code>all</code>s and <code>any</code>s, junctions are a feature meant for representing boolean formula. There&#39;s no way to destructure a junction, and the only way to use it is to collapse it to a boolean first.</p>
<div><pre><span></span><code>&gt; (<span>1</span><span>&amp;2</span>) + (<span>10</span><span>^</span><span>20</span>) &lt; <span>15</span>
<span>all</span>(<span>one</span>(<span>True</span>, <span>False</span>), <span>one</span>(<span>True</span>, <span>False</span>))

<span># so coerces junctions to booleans</span>
&gt; <span>so</span> (<span>1</span><span>&amp;2</span>) + (<span>10</span><span>^</span><span>20</span>) &lt; <span>15</span>
<span>True</span>

&gt; <span>so</span> (<span>1</span><span>&amp;2</span>) + (<span>10</span><span>^</span><span>20</span>) &gt; <span>0</span>
<span>False</span>

&gt; <span>16</span> %% (<span>3</span><span>&amp;5</span>) ?? <span>&#34;fizzbuzz&#34;</span> !! *
*
</code></pre></div>
<p>The real interesting thing for me is how Raku elegantly uses junctions to represent quantifiers. In most languages, you either have the function <code>all(list[T], T -&gt; bool)</code> or the method <code>[T].all(T -&gt; bool)</code>, both of which apply the test to every element of the list. In Raku, though, <code>list.all</code> doesn&#39;t take <em>anything</em>, it&#39;s just a niladic method that turns the list into a junction. </p>
<div><pre><span></span><code>&gt; <span>my</span> <span>$x</span> = <span>&lt;1 2 3&gt;</span>.<span>all</span>
<span>all</span>(<span>1</span>, <span>2</span>, <span>3</span>)
&gt; <span>is-prime</span>(<span>$x</span>)
<span>all</span>(<span>False</span>, <span>True</span>, <span>True</span>)
</code></pre></div>
<p>This means we can combine junctions. If Raku didn&#39;t already have a <code>unique</code> method, we could build it by saying &#34;are all elements equal to exactly one element?&#34;</p>
<div><pre><span></span><code>&gt; <span>so</span> {.<span>all</span> == .<span>one</span>}(<span>&lt;1 2 3 7&gt;</span>)
<span>True</span>

&gt; <span>so</span> {.<span>all</span> == .<span>one</span>}(<span>&lt;1 2 3 7 2&gt;</span>)
<span>False</span>
</code></pre></div>
<h3><a href="https://docs.raku.org/type/Whatever" target="_blank">Whatevers</a></h3>
<p><code>*</code> is the &#34;whatever&#34; symbol and has a lot of different roles in Raku.<sup id="fnref:analogs"><a href="#fn:analogs">2</a></sup> Some functions and operators have special behavior when passed a <code>*</code>. In a range or sequence, <code>*</code> means &#34;unbound&#34;.</p>
<div><pre><span></span><code>&gt; <span>1</span>..*
<span>1</span><span>..</span><span>Inf</span>

&gt; (<span>2</span>,<span>4</span>,<span>8</span>...*)[<span>17</span>]
<span>262144</span>
</code></pre></div>
<p>The main built-in use, though, is that expressions with <code>*</code> are lifted into anonymous functions. This is called &#34;whatever-priming&#34; and produces a <code>WhateverCode</code>, which is indistinguishable from other functions except for the type.</p>
<div><pre><span></span><code>&gt; {<span>$_</span> + <span>10</span>}(<span>2</span>)
<span>12</span>

&gt; (* + <span>10</span>)(<span>2</span>)
<span>12</span>

&gt; (^<span>10</span>).<span>map</span>(* % <span>2</span>)
(<span>0</span> <span>1</span> <span>0</span> <span>1</span> <span>0</span> <span>1</span> <span>0</span> <span>1</span> <span>0</span> <span>1</span>)
</code></pre></div>
<p>There&#39;s actually a bit of weird behavior here: if <em>two</em> whatevers appear in the expression, they become separate positional variables. <code>(2, 30, 4, 50).map(* + *)</code> returns <code>(32, 54)</code>. This makes it easy to express <a href="https://docs.raku.org/language/operators#infix_..." target="_blank">a tricky Fibonacci definition</a> but otherwise I don&#39;t see how it&#39;s better than making each <code>*</code> the same value.</p>
<p>Regardless, priming is useful because <em>so many</em> Raku methods are overloaded to take functions. You get the last element of a list with <code>l[*-1]</code>. This <em>looks</em> like standard negative-index syntax, but what actually happens is that when <code>[]</code> is passed a function, it passes in list length and looks up the result. So if the list has 10 elements, <code>l[*-1] = l[10-1] = l[9]</code>, aka the last element. Similarly, <code>l.head(2)</code> is the first two elements of a list, <code>l.head(*-2)</code> is all-but-the-last-two.</p>
<p>We can pass other functions to <code>[]</code>, which e.g. makes implementing ring buffers easy.</p>
<div><pre><span></span><code>&gt; <span>my</span> <span>@x</span> = ^<span>10</span>
[<span>0</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span> <span>8</span> <span>9</span>]

&gt; <span>@x</span>[<span>95</span> % *]--; <span>@x</span>
[<span>0</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>4</span> <span>6</span> <span>7</span> <span>8</span> <span>9</span>]
</code></pre></div>
<h3><a href="https://docs.raku.org/language/regexes" target="_blank">Regular Expressions</a></h3>
<p>There are two basic standards for regexes: POSIX regexes and Perl-compatible regexes (PCRE). POSIX regexes are a terrible mess of backslashes and punctuation. PCRE is backwards compatible with POSIX and is a more terrible mess of backslashes and punctuation. Most languages follow the PCRE standard, but Perl 6 breaks backwards compatibility with an entirely new regex syntax. </p>
<p>The most obvious improvement: <a href="https://docs.raku.org/language/regexes#Subrules" target="_blank">composability</a>. In most languages  &#34;combine&#34; two regexes by concating their strings together, which is terrible for many, many reasons. Raku has the standard &#34;embed another regex&#34; syntax: <code>/&lt; foo &gt;+/</code> matches one-or-more of the <code>foo</code> regex without <code>foo</code> &#34;leaking&#34; into the top regex. </p>
<p>This already does a lot to make regexes more tractable: you can break a complicated regular expression down into simpler and more legible parts. And in fact this is how Raku supports <a href="https://docs.raku.org/language/grammars" target="_blank">parsing grammars</a> as a builtin language feature. I&#39;ve only used grammars once but it <a href="https://www.hillelwayne.com/post/picat/" target="_blank">was quite helpful</a>.</p>
<p>Since we&#39;re breaking backwards compatibility anyway, we can now add lots of small QOLs. There&#39;s a <a href="https://docs.raku.org/language/regexes#Modified_quantifier:_%,_%%" target="_blank">value separator</a> modifier: <code>\d+ % &#39;,&#39;</code> matches <code>1</code> / <code>1,2</code> / <code>1,1,4</code> but not <code>1,</code> or <code>12</code>. <a href="https://docs.raku.org/language/regexes#Lookaround_assertions" target="_blank">Lookaheads</a> and non-capturing groups aren&#39;t nonsense glyphs. <code>r1 &amp;&amp; r2</code> only matches strings that match <em>both</em> <code>r1</code> and <code>r2</code>. Backtracking can be stopped with <a href="https://docs.raku.org/language/regexes#Preventing_backtracking:_:" target="_blank">:</a>. Whitespace is ignored by default and has to be explicitly enabled in match patterns.</p>
<p>There&#39;s more stuff Raku does with actually <em>processing</em> regular expressions, but the regex notation is something that might actually appear in another language someday. </p>

<h3><a href="https://docs.raku.org/language/operators#Hyper_operators" target="_blank">Hyperoperators</a></h3>
<p>This is a small one compared to the other features, but it&#39;s also the thing I miss most often in other languages. The most basic form <code>l&gt;&gt;.method</code> is basically equivalent to <code>map</code>, except it also recursively descends into sublists.</p>
<div><pre><span></span><code>&gt; [<span>1</span>, [<span>2</span>, <span>3</span>], <span>4</span>]&gt;&gt;.<span>succ</span>
[<span>2</span> [<span>3</span> <span>4</span>] <span>5</span>]
</code></pre></div>
<p>This is more useful than it looks because any function call <code>f(list, *args)</code> can be rewritten in &#34;method form&#34; <code>list.&amp;f(*args)</code>, so <code>&gt;&gt;.</code> becomes the generalized mapping operator. You can use it with whatevers, too.</p>
<div><pre><span></span><code>&gt; [<span>1</span>, [<span>2</span>, <span>3</span>], <span>4</span>]&gt;&gt;.&amp;(*+<span>1</span>)
[<span>2</span> [<span>3</span> <span>4</span>] <span>5</span>]
</code></pre></div>
<p>Anyway, the more generalized <em>binary</em> hyperoperator <code>l1 &lt;&lt; op &gt;&gt; l2</code><sup id="fnref:spaces"><a href="#fn:spaces">3</a></sup> applies <code>op</code> elementwise to the two lists, looping the shorter list until the longer list is exhausted. <code>&gt;&gt;op&gt;&gt;</code> / <code>&lt;&lt; op&lt;&lt;</code> are the same except they instead loop until the lhs/rhs list is exhausted. Whew!</p>
<div><pre><span></span><code>&gt; [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>] <span>&lt;&lt;+&gt;</span>&gt; [<span>10</span>, <span>20</span>]
[<span>11</span> <span>22</span> <span>13</span> <span>24</span> <span>15</span>]

&gt; [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>] <span>&lt;&lt;+&lt;&lt; [10, 20]</span>
<span>[11 22]</span>

<span>&gt; [1, 2, 3, 4, 5] &gt;&gt;</span>+&gt;&gt; [<span>10</span>, <span>20</span>]
[<span>11</span> <span>22</span> <span>13</span> <span>24</span> <span>15</span>]

<span># Also works with single values</span>
&gt; [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>] <span>&lt;&lt;+&gt;</span>&gt; <span>10</span>
[<span>11</span> <span>12</span> <span>13</span> <span>14</span> <span>15</span>]

<span># Does weird things with nested lists too</span>
&gt; [<span>1</span>, [<span>2</span>, <span>3</span>], <span>4</span>, <span>5</span>] <span>&lt;&lt;+&gt;</span>&gt; [<span>10</span>, <span>20</span>]
[<span>11</span> [<span>22</span> <span>23</span>] <span>14</span> <span>25</span>]
</code></pre></div>
<p>Also for some reason the hyperoperators have separate behaviors on two hashes, either applying <code>op</code> to the union/intersection/hash difference. </p>
<p>Anyway it&#39;s a super weird (meta)operator but it&#39;s also quite useful! It&#39;s the closest thing I&#39;ve seen to <a href="https://hillelwayne.com/post/j-notation/" target="_blank">J verbs</a> outside an APL. I like using it to run the same formula on multiple possible inputs at once.</p>
<div><pre><span></span><code>(<span>20</span> * <span>10</span> <span>&lt;&lt;-&gt;</span>&gt; (<span>21</span>, <span>24</span>)) <span>&lt;&lt;*&gt;</span>&gt; (<span>10</span>, <span>100</span>)
(<span>1790</span> <span>17600</span>)
</code></pre></div>
<p>Incidentally, it&#39;s called the hyperoperator because it evaluates all of the operations in parallel. Explicit loops can be parallelized by prefixing them with <a href="https://docs.raku.org/language/statement-prefixes#hyper,_race" target="_blank"><code>hyper</code></a>.</p>
<h3><a href="https://docs.raku.org/type/Pair" target="_blank">Pair Syntax</a></h3>
<p>I&#39;ve talked about pairs a little in <a href="https://buttondown.com/hillelwayne/archive/unusual-basis-types-in-programming-languages/" target="_blank">this newsletter</a>, but the gist is that Raku hashes are composed of a set of pairs <code>key =&gt; value</code>. The pair is the basis type, the hash is the collection of pairs. There&#39;s also a <em>ton</em> of syntactic sugar for concisely specifying pairs via &#34;colon syntax&#34;:</p>
<div><pre><span></span><code>&gt; <span>my</span> <span>$x</span> = <span>3</span>; :<span>$x</span>
<span>x</span> =&gt; <span>3</span>

&gt; :<span>a</span><span>&lt;$x&gt;</span>
<span>a</span> =&gt; <span>&#34;$x&#34;</span>

&gt; :<span>a</span>(<span>$x</span>)
<span>a</span> =&gt; <span>3</span>

&gt; :<span>3</span><span>a</span>
<span>a</span> =&gt; <span>3</span>
</code></pre></div>
<p>The most important sugars are <code>:key</code> and <code>:!key</code>, which map to <code>key =&gt; True</code> and <code>key =&gt; False</code>. This is a really elegant way to add flags to a methods! Take the definition of <a href="https://docs.raku.org/type/Str#method_match" target="_blank">match</a>:</p>
<div><pre><span></span><code><span>method</span> <span>match</span>(<span>$pat</span>, 
    :<span>continue</span>(:<span>$c</span>), :<span>pos</span>(:<span>$p</span>), :<span>global</span>(:<span>$g</span>), 
    :<span>overlap</span>(:<span>$ov</span>), :<span>exhaustive</span>(:<span>$ex</span>), 
    :<span>st</span>(:<span>$nd</span>), :<span>rd</span>(:<span>$th</span>), :<span>$nth</span>, :<span>$x</span> --&gt; <span>Match</span>)
</code></pre></div>
<p>Probably should also mention that in a definition, <code>:f(:$foo)</code> defines the parameter <code>$foo</code> but <a href="https://docs.raku.org/language/signatures#Argument_aliases" target="_blank">also aliases it</a> to <code>:f</code>, so you can set the flag with <code>:f</code> or <code>:foo</code>. Colon-pairs defined in the signature can be passed in anywhere, or even stuck together:</p>
<div><pre><span></span><code>&gt; <span>&#34;abab&#34;</span>.<span>match</span>(<span>/../</span>)
｢<span>ab</span>｣
&gt; <span>&#34;abab&#34;</span>.<span>match</span>(<span>/../</span>, :<span>g</span>)
(｢<span>ab</span>｣ ｢<span>ab</span>｣)
&gt; <span>&#34;abab&#34;</span>.<span>match</span>(<span>/../</span>, :<span>g</span>, :<span>ov</span>)
(｢<span>ab</span>｣ ｢<span>ba</span>｣ ｢<span>ab</span>｣)

<span># Out of order stuck together</span>
&gt; <span>&#34;abab&#34;</span>.<span>match</span>(:<span>g:ov</span>,<span> /../</span>)
(｢<span>ab</span>｣ ｢<span>ba</span>｣ ｢<span>ab</span>｣)
</code></pre></div>
<p>So that leads to extremely concise method configuration. Definitely beats <code>match(global=True, overlap=True)</code>!</p>
<p>And for some reason you can place keyword arguments <em>after</em> the function call:</p>
<div><pre><span></span><code>&gt; <span>&#34;abab&#34;</span>.<span>match</span>(:<span>g</span>,<span> /../</span>):<span>ov:2nd</span>
｢<span>ba</span>｣
</code></pre></div>
<h2>The next-gen lab: Slangs and RakuAST</h2>
<p>These are features I have no experience in and <em>certainly</em> are not making their way into other languages, but they really expand the explorable space of new features. <a href="https://raku.land/zef:lizmat/Slangify" target="_blank">Slangs</a> are modifications to the Raku syntax. This can be used for things like <a href="https://raku.land/zef:elcaro/Slang::Otherwise" target="_blank">modifying loop syntax</a>, <a href="https://raku.land/zef:raku-community-modules/Slang::Piersing" target="_blank">changing identifiers</a>, or adding <a href="https://raku.land/zef:raku-community-modules/OO::Actors" target="_blank">actors</a> or <a href="https://raku.land/github:MattOates/BioInfo" target="_blank">DNA sequences</a> to the base language.</p>
<p>I <em>barely</em> understand <a href="https://dev.to/lizmat/rakuast-for-early-adopters-576n" target="_blank">RakuAST</a>. I <em>think</em> the idea is that all Raku expressions can be parsed as an AST from inside Raku itself.</p>
<div><pre><span></span><code>&gt; <span>Q/my $x; $x++/</span>.<span>AST</span>
<span>RakuAST::StatementList</span>.<span>new</span>(
  <span>RakuAST::Statement::Expression</span>.<span>new</span>(
    <span>expression</span> =&gt; <span>RakuAST::VarDeclaration::Simple</span>.<span>new</span>(
      <span>sigil</span>       =&gt; <span>&#34;\$&#34;</span>,
      <span>desigilname</span> =&gt; <span>RakuAST::Name</span>.<span>from-identifier</span>(<span>&#34;x&#34;</span>)
    )
  ),
  <span>RakuAST::Statement::Expression</span>.<span>new</span>(
    <span>expression</span> =&gt; <span>RakuAST::ApplyPostfix</span>.<span>new</span>(
      <span>operand</span> =&gt; <span>RakuAST::Var::Lexical</span>.<span>new</span>(<span>&#34;\$x&#34;</span>),
      <span>postfix</span> =&gt; <span>RakuAST::Postfix</span>.<span>new</span>(<span>&#34;++&#34;</span>)
    )
  )
)
</code></pre></div>
<p>This allows for things like writing Raku in different languages:</p>
<div><pre><span></span><code><span>say</span> <span>Q/my $x; put $x/</span>.<span>AST</span>.<span>DEPARSE</span>(<span>&#34;NL&#34;</span>)
<span>mijn</span> <span>$x</span>;
<span>zeg-het</span> <span>$x</span>
</code></pre></div>
<h3>Bonus experiment</h3>
<p>Raku comes with a &#34;<a href="https://rakudo.org/star" target="_blank">Rakudo Star</a>&#34; installation, which comes with a set of <a href="https://github.com/rakudo/star/blob/master/etc/modules.txt" target="_blank">blessed third party modules</a> preinstalled. I love this! It&#39;s a great compromise between the maintainer burdens of a large standard library and the user burdens of making everybody find the right packages in the ecosystem.</p>
<hr/>
<h2>Blog Rec</h2>
<p>Feel obligated to recommend some Raku blogs! Elizabeth Mattijsen posts <a href="https://dev.to/lizmat" target="_blank">a ton of stuff</a> to dev.to about Raku internals. <a href="https://www.codesections.com/blog/" target="_blank">Codesections</a> has a pretty good blog; he&#39;s the person who eventually got me to try out Raku. Finally, the <a href="https://raku-advent.blog/" target="_blank">Raku Advent Calendar</a> is a great dive into advanced Raku techniques. Bad news is it only updates once a year, good news is it&#39;s 25 updates that once a year.</p>

                    
                

                
                    <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.com/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
<p><em>My new book, </em>Logic for Programmers<em>, is now in early access! Get it <a href="https://leanpub.com/logic/" target="_blank">here</a>.</em></p>
                

            </div></div>
  </body>
</html>
