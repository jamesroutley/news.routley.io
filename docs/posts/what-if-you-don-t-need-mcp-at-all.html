<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mariozechner.at/posts/2025-11-02-what-if-you-dont-need-mcp/">Original</a>
    <h1>What if you don&#39;t need MCP at all?</h1>
    
    <div id="readability-page-1" class="page"><article>



<p>2025-11-02</p>

<figure>
<img src="https://hamy.xyz/blog/media/header.png"/>
<figcaption>One chonky MCP server</figcaption>
</figure>






<p>After months of agentic coding frenzy, Twitter is still ablaze with discussions about MCP servers. I previously did some <a href="https://hamy.xyz/posts/2025-08-15-mcp-vs-cli/">very light benchmarking</a> to see if Bash tools or MCP servers are better suited for a specific task. The TL;DR: both can be efficient if you take care.</p>
<p>Unfortunately, many of the most popular MCP servers are inefficient for a specific task. They need to cover all bases, which means they provide large numbers of tools with lengthy descriptions, consuming significant context.</p>
<p>It&#39;s also hard to extend an existing MCP server. You could check out the source and modify it, but then you&#39;d have to understand the codebase, together with your agent.</p>
<p>MCP servers also aren&#39;t composable. Results returned by an MCP server have to go through the agent&#39;s context to be persisted to disk or combined with other results.</p>
<p>I&#39;m a simple boy, so I like simple things. Agents can run Bash and write code well. Bash and code are composable. So what&#39;s simpler than having your agent just invoke CLI tools and write code? This is nothing new. We&#39;ve all been doing this since the beginning. I&#39;d just like to convince you that in many situations, you don&#39;t need or even want an MCP server.</p>
<p>Let me illustrate this with a common MCP server use case: browser dev tools.</p>
<h2 id="toc_0">My Browser DevTools Use Cases</h2>
<p>My use cases are working on web frontends together with my agent, or abusing my agent to become a scrapey little hacker boy so I can scrape all the data in the world. For these two use cases, I only need a minimal set of tools:</p>
<ul>
<li>Start the browser, optionally with my default profile so I&#39;m logged in</li>
<li>Navigate to a URL, either in the active tab or a new tab</li>
<li>Execute JavaScript in the active page context</li>
<li>Take a screenshot of the viewport</li>
</ul>
<p>And if my use case requires additional special tooling, I want to quickly have my agent generate that for me and slot it in with the other tools.</p>
<h2 id="toc_1">Problems with Common Browser DevTools for Your Agent</h2>
<p>People will recommend <a href="https://github.com/microsoft/playwright-mcp">Playwright MCP</a> or <a href="https://github.com/ChromeDevTools/chrome-devtools-mcp">Chrome DevTools MCP</a> for the use cases I illustrated above. Both are fine, but they need to cover all the bases. Playwright MCP has 21 tools using 13.7k tokens (6.8% of Claude&#39;s context). Chrome DevTools MCP has 26 tools using 18.0k tokens (9.0%). That many tools will confuse your agent, especially when combined with other MCP servers and built-in tools.</p>
<p>Using those tools also means you suffer from the composability issue: any output has to go through your agent&#39;s context. You can kind of fix this by using sub-agents, but then you rope in all the issues that sub-agents come with.</p>
<h2 id="toc_2">Embracing Bash (and Code)</h2>
<p>Here&#39;s my minimal set of tools, illustrated via the README.md:</p>
<pre><code><span># Browser Tools</span>

Minimal CDP tools for collaborative site exploration.

<span>## Start Chrome</span>

\<span>`\`</span>\`bash
./start.js              # Fresh profile
./start.js --profile    # Copy your profile (cookies, logins)
\<span>`\`</span>\`

Start Chrome on <span>`:9222`</span> with remote debugging.

<span>## Navigate</span>

\<span>`\`</span>\`bash
./nav.js https://example.com
./nav.js https://example.com --new
\<span>`\`</span>\`

Navigate current tab or open new tab.

<span>## Evaluate JavaScript</span>

\<span>`\`</span>\`bash
./eval.js &#39;document.title&#39;
./eval.js &#39;document.querySelectorAll(&#34;a&#34;).length&#39;
\<span>`\`</span>\`

Execute JavaScript in active tab (async context).

<span>## Screenshot</span>

\<span>`\`</span>\`bash
./screenshot.js
\<span>`\`</span>\`

Screenshot current viewport, returns temp file path.
</code></pre><p>This is all I feed to my agent. It&#39;s a handful of tools that cover all the bases for my use case. Each tool is a simple Node.js script that uses <a href="https://pptr.dev/">Puppeteer Core</a>. By reading that README, the agent knows the available tools, when to use them, and how to use them via Bash.</p>
<p>When I start a session where the agent needs to interact with a browser, I just tell it to read that file in full and that&#39;s all it needs to be effective. Let&#39;s walk through their implementations to see how little code this actually is.</p>
<h3 id="toc_3">The Start Tool</h3>
<p>The agent needs to be able to start a new browser session. For scraping tasks, I often want to use my actual Chrome profile so I&#39;m logged in everywhere. This script either rsyncs my Chrome profile to a temporary folder (Chrome doesn&#39;t allow debugging on the default profile), or starts fresh:</p>
<pre><code><span>#!/usr/bin/env node</span>

<span>import</span> { spawn, execSync } <span>from</span> <span>&#34;node:child_process&#34;</span>;
<span>import</span> puppeteer <span>from</span> <span>&#34;puppeteer-core&#34;</span>;

<span>const</span> useProfile = process.<span>argv</span>[<span>2</span>] === <span>&#34;--profile&#34;</span>;

<span>if</span> (process.<span>argv</span>[<span>2</span>] &amp;&amp; process.<span>argv</span>[<span>2</span>] !== <span>&#34;--profile&#34;</span>) {
    <span>console</span>.<span>log</span>(<span>&#34;Usage: start.ts [--profile]&#34;</span>);
    <span>console</span>.<span>log</span>(<span>&#34;\nOptions:&#34;</span>);
    <span>console</span>.<span>log</span>(<span>&#34;  --profile  Copy your default Chrome profile (cookies, logins)&#34;</span>);
    <span>console</span>.<span>log</span>(<span>&#34;\nExamples:&#34;</span>);
    <span>console</span>.<span>log</span>(<span>&#34;  start.ts            # Start with fresh profile&#34;</span>);
    <span>console</span>.<span>log</span>(<span>&#34;  start.ts --profile  # Start with your Chrome profile&#34;</span>);
    process.<span>exit</span>(<span>1</span>);
}


<span>try</span> {
    <span>execSync</span>(<span>&#34;killall &#39;Google Chrome&#39;&#34;</span>, { <span>stdio</span>: <span>&#34;ignore&#34;</span> });
} <span>catch</span> {}


<span>await</span> <span>new</span> <span>Promise</span>(<span>(<span>r</span>) =&gt;</span> <span>setTimeout</span>(r, <span>1000</span>));


<span>execSync</span>(<span>&#34;mkdir -p ~/.cache/scraping&#34;</span>, { <span>stdio</span>: <span>&#34;ignore&#34;</span> });

<span>if</span> (useProfile) {
    
    <span>execSync</span>(
        <span>&#39;rsync -a --delete &#34;/Users/badlogic/Library/Application Support/Google/Chrome/&#34; ~/.cache/scraping/&#39;</span>,
        { <span>stdio</span>: <span>&#34;pipe&#34;</span> },
    );
}


<span>spawn</span>(
    <span>&#34;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#34;</span>,
    [<span>&#34;--remote-debugging-port=9222&#34;</span>, <span>`--user-data-dir=<span>${process.env[<span>&#34;HOME&#34;</span>]}</span>/.cache/scraping`</span>],
    { <span>detached</span>: <span>true</span>, <span>stdio</span>: <span>&#34;ignore&#34;</span> },
).<span>unref</span>();


<span>let</span> connected = <span>false</span>;
<span>for</span> (<span>let</span> i = <span>0</span>; i &lt; <span>30</span>; i++) {
    <span>try</span> {
        <span>const</span> browser = <span>await</span> puppeteer.<span>connect</span>({
            <span>browserURL</span>: <span>&#34;http://localhost:9222&#34;</span>,
            <span>defaultViewport</span>: <span>null</span>,
        });
        <span>await</span> browser.<span>disconnect</span>();
        connected = <span>true</span>;
        <span>break</span>;
    } <span>catch</span> {
        <span>await</span> <span>new</span> <span>Promise</span>(<span>(<span>r</span>) =&gt;</span> <span>setTimeout</span>(r, <span>500</span>));
    }
}

<span>if</span> (!connected) {
    <span>console</span>.<span>error</span>(<span>&#34;✗ Failed to connect to Chrome&#34;</span>);
    process.<span>exit</span>(<span>1</span>);
}

<span>console</span>.<span>log</span>(<span>`✓ Chrome started on :9222<span>${useProfile ? <span>&#34; with your profile&#34;</span> : <span>&#34;&#34;</span>}</span>`</span>);
</code></pre><p>All the agent needs to know is to use Bash to run the start.js script, either with <code>--profile</code> or without.</p>
<h3 id="toc_4">The Navigate Tool</h3>
<p>Once the browser is running, the agent needs to navigate to URLs, either in a new tab or the active tab. That&#39;s exactly what the navigate tool provides:</p>
<pre><code><span>#!/usr/bin/env node</span>

<span>import</span> puppeteer <span>from</span> <span>&#34;puppeteer-core&#34;</span>;

<span>const</span> url = process.<span>argv</span>[<span>2</span>];
<span>const</span> newTab = process.<span>argv</span>[<span>3</span>] === <span>&#34;--new&#34;</span>;

<span>if</span> (!url) {
    <span>console</span>.<span>log</span>(<span>&#34;Usage: nav.js &lt;url&gt; [--new]&#34;</span>);
    <span>console</span>.<span>log</span>(<span>&#34;\nExamples:&#34;</span>);
    <span>console</span>.<span>log</span>(<span>&#34;  nav.js https://example.com       # Navigate current tab&#34;</span>);
    <span>console</span>.<span>log</span>(<span>&#34;  nav.js https://example.com --new # Open in new tab&#34;</span>);
    process.<span>exit</span>(<span>1</span>);
}

<span>const</span> b = <span>await</span> puppeteer.<span>connect</span>({
    <span>browserURL</span>: <span>&#34;http://localhost:9222&#34;</span>,
    <span>defaultViewport</span>: <span>null</span>,
});

<span>if</span> (newTab) {
    <span>const</span> p = <span>await</span> b.<span>newPage</span>();
    <span>await</span> p.<span>goto</span>(url, { <span>waitUntil</span>: <span>&#34;domcontentloaded&#34;</span> });
    <span>console</span>.<span>log</span>(<span>&#34;✓ Opened:&#34;</span>, url);
} <span>else</span> {
    <span>const</span> p = (<span>await</span> b.<span>pages</span>()).<span>at</span>(-<span>1</span>);
    <span>await</span> p.<span>goto</span>(url, { <span>waitUntil</span>: <span>&#34;domcontentloaded&#34;</span> });
    <span>console</span>.<span>log</span>(<span>&#34;✓ Navigated to:&#34;</span>, url);
}

<span>await</span> b.<span>disconnect</span>();
</code></pre><h3 id="toc_5">The Evaluate JavaScript Tool</h3>
<p>The agent needs to execute JavaScript to read and modify the DOM of the active tab. The JavaScript it writes runs in the page context, so it doesn&#39;t have to fuck around with Puppeteer itself. All it needs to know is how to write code using the DOM API, and it sure knows how to do that:</p>
<pre><code><span>#!/usr/bin/env node</span>

<span>import</span> puppeteer <span>from</span> <span>&#34;puppeteer-core&#34;</span>;

<span>const</span> code = process.<span>argv</span>.<span>slice</span>(<span>2</span>).<span>join</span>(<span>&#34; &#34;</span>);
<span>if</span> (!code) {
    <span>console</span>.<span>log</span>(<span>&#34;Usage: eval.js &#39;code&#39;&#34;</span>);
    <span>console</span>.<span>log</span>(<span>&#34;\nExamples:&#34;</span>);
    <span>console</span>.<span>log</span>(<span>&#39;  eval.js &#34;document.title&#34;&#39;</span>);
    <span>console</span>.<span>log</span>(<span>&#39;  eval.js &#34;document.querySelectorAll(\&#39;a\&#39;).length&#34;&#39;</span>);
    process.<span>exit</span>(<span>1</span>);
}

<span>const</span> b = <span>await</span> puppeteer.<span>connect</span>({
    <span>browserURL</span>: <span>&#34;http://localhost:9222&#34;</span>,
    <span>defaultViewport</span>: <span>null</span>,
});

<span>const</span> p = (<span>await</span> b.<span>pages</span>()).<span>at</span>(-<span>1</span>);

<span>if</span> (!p) {
    <span>console</span>.<span>error</span>(<span>&#34;✗ No active tab found&#34;</span>);
    process.<span>exit</span>(<span>1</span>);
}

<span>const</span> result = <span>await</span> p.<span>evaluate</span>(<span>(<span>c</span>) =&gt;</span> {
    <span>const</span> <span>AsyncFunction</span> = (<span>async</span> () =&gt; {}).<span>constructor</span>;
    <span>return</span> <span>new</span> <span>AsyncFunction</span>(<span>`return (<span>${c}</span>)`</span>)();
}, code);

<span>if</span> (<span>Array</span>.<span>isArray</span>(result)) {
    <span>for</span> (<span>let</span> i = <span>0</span>; i &lt; result.<span>length</span>; i++) {
        <span>if</span> (i &gt; <span>0</span>) <span>console</span>.<span>log</span>(<span>&#34;&#34;</span>);
        <span>for</span> (<span>const</span> [key, value] <span>of</span> <span>Object</span>.<span>entries</span>(result[i])) {
            <span>console</span>.<span>log</span>(<span>`<span>${key}</span>: <span>${value}</span>`</span>);
        }
    }
} <span>else</span> <span>if</span> (<span>typeof</span> result === <span>&#34;object&#34;</span> &amp;&amp; result !== <span>null</span>) {
    <span>for</span> (<span>const</span> [key, value] <span>of</span> <span>Object</span>.<span>entries</span>(result)) {
        <span>console</span>.<span>log</span>(<span>`<span>${key}</span>: <span>${value}</span>`</span>);
    }
} <span>else</span> {
    <span>console</span>.<span>log</span>(result);
}

<span>await</span> b.<span>disconnect</span>();
</code></pre><h3 id="toc_6">The Screenshot Tool</h3>
<p>Sometimes the agent needs to have a visual impression of a page, so naturally we want a screenshot tool:</p>
<pre><code><span>#!/usr/bin/env node</span>

<span>import</span> { tmpdir } <span>from</span> <span>&#34;node:os&#34;</span>;
<span>import</span> { join } <span>from</span> <span>&#34;node:path&#34;</span>;
<span>import</span> puppeteer <span>from</span> <span>&#34;puppeteer-core&#34;</span>;

<span>const</span> b = <span>await</span> puppeteer.<span>connect</span>({
    <span>browserURL</span>: <span>&#34;http://localhost:9222&#34;</span>,
    <span>defaultViewport</span>: <span>null</span>,
});

<span>const</span> p = (<span>await</span> b.<span>pages</span>()).<span>at</span>(-<span>1</span>);

<span>if</span> (!p) {
    <span>console</span>.<span>error</span>(<span>&#34;✗ No active tab found&#34;</span>);
    process.<span>exit</span>(<span>1</span>);
}

<span>const</span> timestamp = <span>new</span> <span>Date</span>().<span>toISOString</span>().<span>replace</span>(<span>/[:.]/g</span>, <span>&#34;-&#34;</span>);
<span>const</span> filename = <span>`screenshot-<span>${timestamp}</span>.png`</span>;
<span>const</span> filepath = <span>join</span>(<span>tmpdir</span>(), filename);

<span>await</span> p.<span>screenshot</span>({ <span>path</span>: filepath });

<span>console</span>.<span>log</span>(filepath);

<span>await</span> b.<span>disconnect</span>();
</code></pre><p>This will take a screenshot of the current viewport of the active tab, write it to a .png file in a temporary directory, and output the file path to the agent, which can then turn around and read it in and use its vision capabilities to &#34;see&#34; the image.</p>
<h2 id="toc_7">The Benefits</h2>
<p>So how does this compare to the MCP servers I mentioned above? Well, to start, I can pull in the README whenever I need it and don&#39;t pay for it in every session. This is very similar to Anthropic&#39;s recently introduced skills capabilities. Except it&#39;s even more ad hoc and works with any coding agent. All I need to do is instruct my agent to read the README file.</p>
<p>Side note: many folks including myself have used this kind of setup before Anthropic released their skills system. You can see something similar in my <a href="https://hamy.xyz/posts/2025-06-02-prompts-are-code/">&#34;Prompts are Code&#34; blog post</a> or my little <a href="https://sitegeist.ai">sitegeist.ai</a>. <a href="https://lucumr.pocoo.org/2025/8/18/code-mcps/">Armin</a> has also touched on the power of Bash and code compared to MCPs previously. Anthropic&#39;s skills add progressive disclosure (love it) and they make them available to a non-technical audience across almost all their products (also love it).</p>
<p>Speaking of the README, instead of pulling in 13,000 to 18,000 tokens like the MCP servers mentioned above, this README has a whopping 225 tokens. This efficiency comes from the fact that models know how to write code and use Bash. I&#39;m conserving context space by relying heavily on their existing knowledge.</p>
<p>These simple tools are also composable. Instead of reading the outputs of an invocation into the context, the agent can decide to save them to a file for later processing, either by itself or by code. The agent can also easily chain multiple invocations in a single Bash command.</p>
<p>If I find that the output of a tool is not token efficient, I can just change the output format. Something that&#39;s hard or impossible to do depending on what MCP server you use.</p>
<p>And it&#39;s ridiculously easy to add a new tool or modify an existing tool for my needs. Let me illustrate.</p>
<h2 id="toc_8">Adding the Pick Tool</h2>
<p>When the agent and I try to come up with a scraping method for a specific site, it&#39;s often more efficient if I&#39;m able to point out DOM elements to it directly by just clicking on them. To make this super easy, I can just build a picker. Here&#39;s what I add to the README:</p>
<pre><code><span>## Pick Elements</span>

\<span>`\`</span>\`bash
./pick.js &#34;Click the submit button&#34;
\<span>`\`</span>\`

Interactive element picker. Click to select, Cmd/Ctrl+Click for multi-select, Enter to finish.
</code></pre><p>And here&#39;s the code:</p>
<pre><code><span>#!/usr/bin/env node</span>

<span>import</span> puppeteer <span>from</span> <span>&#34;puppeteer-core&#34;</span>;

<span>const</span> message = process.<span>argv</span>.<span>slice</span>(<span>2</span>).<span>join</span>(<span>&#34; &#34;</span>);
<span>if</span> (!message) {
    <span>console</span>.<span>log</span>(<span>&#34;Usage: pick.js &#39;message&#39;&#34;</span>);
    <span>console</span>.<span>log</span>(<span>&#34;\nExample:&#34;</span>);
    <span>console</span>.<span>log</span>(<span>&#39;  pick.js &#34;Click the submit button&#34;&#39;</span>);
    process.<span>exit</span>(<span>1</span>);
}

<span>const</span> b = <span>await</span> puppeteer.<span>connect</span>({
    <span>browserURL</span>: <span>&#34;http://localhost:9222&#34;</span>,
    <span>defaultViewport</span>: <span>null</span>,
});

<span>const</span> p = (<span>await</span> b.<span>pages</span>()).<span>at</span>(-<span>1</span>);

<span>if</span> (!p) {
    <span>console</span>.<span>error</span>(<span>&#34;✗ No active tab found&#34;</span>);
    process.<span>exit</span>(<span>1</span>);
}


<span>await</span> p.<span>evaluate</span>(<span>() =&gt;</span> {
    <span>if</span> (!<span>window</span>.<span>pick</span>) {
        <span>window</span>.<span>pick</span> = <span>async</span> (message) =&gt; {
            <span>if</span> (!message) {
                <span>throw</span> <span>new</span> <span>Error</span>(<span>&#34;pick() requires a message parameter&#34;</span>);
            }
            <span>return</span> <span>new</span> <span>Promise</span>(<span>(<span>resolve</span>) =&gt;</span> {
                <span>const</span> selections = [];
                <span>const</span> selectedElements = <span>new</span> <span>Set</span>();

                <span>const</span> overlay = <span>document</span>.<span>createElement</span>(<span>&#34;div&#34;</span>);
                overlay.<span>style</span>.<span>cssText</span> =
                    <span>&#34;position:fixed;top:0;left:0;width:100%;height:100%;z-index:2147483647;pointer-events:none&#34;</span>;

                <span>const</span> highlight = <span>document</span>.<span>createElement</span>(<span>&#34;div&#34;</span>);
                highlight.<span>style</span>.<span>cssText</span> =
                    <span>&#34;position:absolute;border:2px solid #3b82f6;background:rgba(59,130,246,0.1);transition:all 0.1s&#34;</span>;
                overlay.<span>appendChild</span>(highlight);

                <span>const</span> banner = <span>document</span>.<span>createElement</span>(<span>&#34;div&#34;</span>);
                banner.<span>style</span>.<span>cssText</span> =
                    <span>&#34;position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#1f2937;color:white;padding:12px 24px;border-radius:8px;font:14px sans-serif;box-shadow:0 4px 12px rgba(0,0,0,0.3);pointer-events:auto;z-index:2147483647&#34;</span>;

                <span>const</span> <span>updateBanner</span> = (<span></span>) =&gt; {
                    banner.<span>textContent</span> = <span>`<span>${message}</span> (<span>${selections.length}</span> selected, Cmd/Ctrl+click to add, Enter to finish, ESC to cancel)`</span>;
                };
                <span>updateBanner</span>();

                <span>document</span>.<span>body</span>.<span>append</span>(banner, overlay);

                <span>const</span> <span>cleanup</span> = (<span></span>) =&gt; {
                    <span>document</span>.<span>removeEventListener</span>(<span>&#34;mousemove&#34;</span>, onMove, <span>true</span>);
                    <span>document</span>.<span>removeEventListener</span>(<span>&#34;click&#34;</span>, onClick, <span>true</span>);
                    <span>document</span>.<span>removeEventListener</span>(<span>&#34;keydown&#34;</span>, onKey, <span>true</span>);
                    overlay.<span>remove</span>();
                    banner.<span>remove</span>();
                    selectedElements.<span>forEach</span>(<span>(<span>el</span>) =&gt;</span> {
                        el.<span>style</span>.<span>outline</span> = <span>&#34;&#34;</span>;
                    });
                };

                <span>const</span> <span>onMove</span> = (<span>e</span>) =&gt; {
                    <span>const</span> el = <span>document</span>.<span>elementFromPoint</span>(e.<span>clientX</span>, e.<span>clientY</span>);
                    <span>if</span> (!el || overlay.<span>contains</span>(el) || banner.<span>contains</span>(el)) <span>return</span>;
                    <span>const</span> r = el.<span>getBoundingClientRect</span>();
                    highlight.<span>style</span>.<span>cssText</span> = <span>`position:absolute;border:2px solid #3b82f6;background:rgba(59,130,246,0.1);top:<span>${r.top}</span>px;left:<span>${r.left}</span>px;width:<span>${r.width}</span>px;height:<span>${r.height}</span>px`</span>;
                };

                <span>const</span> <span>buildElementInfo</span> = (<span>el</span>) =&gt; {
                    <span>const</span> parents = [];
                    <span>let</span> current = el.<span>parentElement</span>;
                    <span>while</span> (current &amp;&amp; current !== <span>document</span>.<span>body</span>) {
                        <span>const</span> parentInfo = current.<span>tagName</span>.<span>toLowerCase</span>();
                        <span>const</span> id = current.<span>id</span> ? <span>`#<span>${current.id}</span>`</span> : <span>&#34;&#34;</span>;
                        <span>const</span> cls = current.<span>className</span>
                            ? <span>`.<span>${current.className.trim().split(/\s+/).join(<span>&#34;.&#34;</span>)}</span>`</span>
                            : <span>&#34;&#34;</span>;
                        parents.<span>push</span>(parentInfo + id + cls);
                        current = current.<span>parentElement</span>;
                    }

                    <span>return</span> {
                        <span>tag</span>: el.<span>tagName</span>.<span>toLowerCase</span>(),
                        <span>id</span>: el.<span>id</span> || <span>null</span>,
                        <span>class</span>: el.<span>className</span> || <span>null</span>,
                        <span>text</span>: el.<span>textContent</span>?.<span>trim</span>().<span>slice</span>(<span>0</span>, <span>200</span>) || <span>null</span>,
                        <span>html</span>: el.<span>outerHTML</span>.<span>slice</span>(<span>0</span>, <span>500</span>),
                        <span>parents</span>: parents.<span>join</span>(<span>&#34; &gt; &#34;</span>),
                    };
                };

                <span>const</span> <span>onClick</span> = (<span>e</span>) =&gt; {
                    <span>if</span> (banner.<span>contains</span>(e.<span>target</span>)) <span>return</span>;
                    e.<span>preventDefault</span>();
                    e.<span>stopPropagation</span>();
                    <span>const</span> el = <span>document</span>.<span>elementFromPoint</span>(e.<span>clientX</span>, e.<span>clientY</span>);
                    <span>if</span> (!el || overlay.<span>contains</span>(el) || banner.<span>contains</span>(el)) <span>return</span>;

                    <span>if</span> (e.<span>metaKey</span> || e.<span>ctrlKey</span>) {
                        <span>if</span> (!selectedElements.<span>has</span>(el)) {
                            selectedElements.<span>add</span>(el);
                            el.<span>style</span>.<span>outline</span> = <span>&#34;3px solid #10b981&#34;</span>;
                            selections.<span>push</span>(<span>buildElementInfo</span>(el));
                            <span>updateBanner</span>();
                        }
                    } <span>else</span> {
                        <span>cleanup</span>();
                        <span>const</span> info = <span>buildElementInfo</span>(el);
                        <span>resolve</span>(selections.<span>length</span> &gt; <span>0</span> ? selections : info);
                    }
                };

                <span>const</span> <span>onKey</span> = (<span>e</span>) =&gt; {
                    <span>if</span> (e.<span>key</span> === <span>&#34;Escape&#34;</span>) {
                        e.<span>preventDefault</span>();
                        <span>cleanup</span>();
                        <span>resolve</span>(<span>null</span>);
                    } <span>else</span> <span>if</span> (e.<span>key</span> === <span>&#34;Enter&#34;</span> &amp;&amp; selections.<span>length</span> &gt; <span>0</span>) {
                        e.<span>preventDefault</span>();
                        <span>cleanup</span>();
                        <span>resolve</span>(selections);
                    }
                };

                <span>document</span>.<span>addEventListener</span>(<span>&#34;mousemove&#34;</span>, onMove, <span>true</span>);
                <span>document</span>.<span>addEventListener</span>(<span>&#34;click&#34;</span>, onClick, <span>true</span>);
                <span>document</span>.<span>addEventListener</span>(<span>&#34;keydown&#34;</span>, onKey, <span>true</span>);
            });
        };
    }
});

<span>const</span> result = <span>await</span> p.<span>evaluate</span>(<span>(<span>msg</span>) =&gt;</span> <span>window</span>.<span>pick</span>(msg), message);

<span>if</span> (<span>Array</span>.<span>isArray</span>(result)) {
    <span>for</span> (<span>let</span> i = <span>0</span>; i &lt; result.<span>length</span>; i++) {
        <span>if</span> (i &gt; <span>0</span>) <span>console</span>.<span>log</span>(<span>&#34;&#34;</span>);
        <span>for</span> (<span>const</span> [key, value] <span>of</span> <span>Object</span>.<span>entries</span>(result[i])) {
            <span>console</span>.<span>log</span>(<span>`<span>${key}</span>: <span>${value}</span>`</span>);
        }
    }
} <span>else</span> <span>if</span> (<span>typeof</span> result === <span>&#34;object&#34;</span> &amp;&amp; result !== <span>null</span>) {
    <span>for</span> (<span>const</span> [key, value] <span>of</span> <span>Object</span>.<span>entries</span>(result)) {
        <span>console</span>.<span>log</span>(<span>`<span>${key}</span>: <span>${value}</span>`</span>);
    }
} <span>else</span> {
    <span>console</span>.<span>log</span>(result);
}

<span>await</span> b.<span>disconnect</span>();
</code></pre><p>Whenever I think it&#39;s faster for me to just click on a bunch of DOM elements instead of having the agent figure out the DOM structure, I can just tell it to use the pick tool. It&#39;s super efficient and allows me to build scrapers in no time. It&#39;s also fantastic to adjust the scraper if the DOM layout of a site changed.</p>
<p>If you&#39;re having trouble following what this tool does, worry not, I will have a video at the end of the blog post where you can see it in action. Before we look at that, let me show you an additional tool.</p>
<h2 id="toc_9">Adding the Cookies Tool</h2>
<p>During one of my recent scraping adventures, I had a need for HTTP-only cookies of that site, so the deterministic scraper could pretend it&#39;s me. The Evaluate JavaScript tool cannot handle this as it executes in the page context. But it took not even a minute for me to instruct Claude to create that tool, add it to the readme, and away we went.</p>
<img src="https://hamy.xyz/blog/media/extension.png" loading="lazy"/>

<p>This is so much easier than adjusting, testing, and debugging an existing MCP server.</p>
<h2 id="toc_10">A Contrived Example</h2>
<p>Let me illustrate usage of this set of tools with a contrived example. I set out to build a simple Hacker News scraper where I basically pick the DOM elements for the agent, based on which it can then write a minimal Node.js scraper. Here&#39;s how that looks in action. I sped up a few sections where Claude was its usual slow self.</p>
<video src="media/scrape.mp4" poster="media/scrape-poster.png" controls="">
</video>

<p>Real world scraping tasks would look a bit more involved. Also, there&#39;s no point in doing it like this for such a simple site like Hacker News. But you get the idea.</p>
<p>Final token tally:</p>
<img src="https://hamy.xyz/blog/media/scrape-tokens.png" loading="lazy"/>

<h2 id="toc_11">Making This Reusable Across Agents</h2>
<p>Here&#39;s how I&#39;ve set things up so I can use this with Claude Code and other agents. I have a folder <code>agent-tools</code> in my home directory. I then clone the repositories of individual tools, like the browser tools repository above, into that folder. Then I set up an alias:</p>
<pre><code><span>alias</span> cl=<span>&#34;PATH=<span>$PATH</span>:/Users/badlogic/agent-tools/browser-tools:&lt;other-tool-dirs&gt; &amp;&amp; claude --dangerously-skip-permissions&#34;</span>
</code></pre><p>This way all of the scripts are available to sessions of Claude, but don&#39;t pollute my normal environment. I also prefix each script with the full tool name, e.g. <code>browser-tools-start.js</code>, to eliminate name collisions. I also add a single sentence to the README telling the agent that all the scripts are globally available. This way, the agent doesn&#39;t have to change its working directory just to call a tool script, saving a few tokens here and there, and reducing the chances of the agent getting confused by the constant working directory changes.</p>
<p>Finally, I add the agent tools directory as a working directory to Claude Code via <code>/add-dir</code>, so I can use <code>@README.md</code> to reference a specific tool&#39;s README file and get it into the agent&#39;s context. I prefer this to Anthropic&#39;s skill auto-discovery, which I found to not work reliably in practice. It also means I save a few more tokens: Claude Code injects all the frontmatter of all skills it can find into the system prompt (or first user message, I forgot, see <a href="https://cchistory.mariozechner.at">https://cchistory.mariozechner.at</a>)</p>
<h2 id="toc_12">In Conclusion</h2>
<p>Building these tools is ridiculously easy, gives you all the freedom you need, and makes you, your agent, and your token usage efficient. You can find the browser tools on <a href="https://github.com/badlogic/browser-tools">GitHub</a>.</p>
<p>This general principle can apply to any kind of harness that has some kind of code execution environment. Think outside the MCP box and you&#39;ll find that this is much more powerful than the more rigid structure you have to follow with MCP.</p>
<p>With great power comes great responsibility though. You will have to come up with a structure for how you build and maintain those tools yourself. Anthropic&#39;s skill system can be one way to do it, though that&#39;s less transferable to other agents. Or you follow my setup above.</p>
<p>
    This page respects your privacy by not using cookies or similar technologies and by not collecting any personally identifiable information.
</p>

</article></div>
  </body>
</html>
