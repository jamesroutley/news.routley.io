<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://alexanderpruss.blogspot.com/2022/02/game-boy-wordle-how-to-compress-12972.html">Original</a>
    <h1>Game Boy Wordle clone: How to compress 12972 five-letter words to 17871 bytes</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-3551507233187648679" itemprop="description articleBody">
<p><b>Update:</b> You can play an updated version online <a href="https://arpruss.github.io/fiver">here</a> in the binjgb Game Boy emulator. This is the version with the frequency-based answer list rather than the official Wordle list, for copyright reasons.</p>
<p>There is a <a href="https://github.com/stacksmashing/gb-wordle">Game
Boy version</a> of Wordle, using a bloom filter, a reduced vocabulary
and a reduced list of guess words, all fitting on one 32K cartridge. I
decided to challenge myself and see if I could fit in the whole 12972
word Wordle vocabulary, with the whole 2315 word answer list. So the
challenge is:</p>
<ul>
<li><p>Compress 12972 five-letter words (Vocabulary)</p></li>
<li><p>Compress a distinguished 2315 word subset (Answers).</p></li>
</ul>
<p>I <a href="https://github.com/arpruss/gb-fiver">managed it</a>
(download ROM <a href="https://github.com/arpruss/gb-fiver/releases/">here</a>), and it
works in a Game Boy emulator. There is more than one way, and what I did
may be excessively complicated, but I don’t have a good feel for how
fast the Game Boy runs, so I did a bit of speed optimization.</p>
<p><strong>Step 0:</strong> We start with <span>12972 × 5 = 64860</span> bytes of uncompressed
data.</p>
<p><strong>Step 1:</strong> Divide the 12972 word list into 26 lists,
based on the first letter of the word. Since in each list, the first
letter is the same, we now need only store four letters per word, along
with some overhead for each list. (The overhead in the final analysis
will be 108 bytes.) If we stop here,</p>
<p><strong>Step 2:</strong> Each four letter “word” (or tail of a word)
can be stored with 5 bits per letter, thereby yielding a 20 bit unsigned
integer. If we stop here, we can store each word in 2.5 bytes, for a
total of 32430. That would fit on the cartridge if there was no code,
but it is some progress.</p>
<p><strong>Step 3:</strong> Here was my one clever idea. Each of the
lists of four letter “words”, is in alphabetical order, and encoded the
natural way as 20 bit numbers, the numbers will be in ascending order.
Instead of storing these numbers, we need only store their arithmetical
differences, starting with an initial (invalid) 0.</p>
<p><strong>Step 4:</strong> Since the differences are always at least 1,
we can subtract one from each difference to make the numbers slightly
smaller. (This is a needless complication, but I had it, and don’t feel
like removing it.)</p>
<p><strong>Step 5:</strong> Store a stream of bytes encoding the
difference-minus-ones. Each number is encoded as one, two or three
bytes, seven-bits in each byte, with the high bit of each byte being 1
if it’s the last 7-bit sequence and 0 if it’s not. It turns out that the
result is 17763 bytes, plus 108 bytes of overhead, for a total of 17871
bytes, or 28% of the original list, with very, very simple
decompression.</p>
<p><strong>Step 6:</strong> Now we replace each word in the
alphabetically-sorted Answers list with an index into the vocabulary
list. Since each index fits into 2 bytes, this would let us store the
2315 words of the Answers as <span>2315 × 2 = 4630</span> bytes.</p>
<p><strong>Step 7:</strong> However, it turns out that the difference
between two successive indexes is never bigger than 62. So we can re-use
the trick of storing successive differences, and store the Answers in
2315 bytes. (In fact, since we only need 6 bits for the differences, we
could go down to 1737 bytes, but it would complicate the code
significantly.)</p>
<p><strong>Result:</strong> Vocabulary plus Answers goes down to
108+17763+2315=20186 bytes. This was too big to fit on a 32K cartridge
using the existing code. But it turns out that most of the existing code
was library support code for <code>gprintf()</code>, and replacing the
single <code>gprintf()</code> call, which was just being used to format
a string containing a single-digit integer variable, with
<code>gprint()</code>, seemed to get everything to fit in 32K.</p>
<p><strong>Example of the Vocabulary compression:</strong></p>
<ul>
<li><p>The first six words are: aahed, aalii, aargh, aarti, abaca,
abaci.</p></li>
<li><p>Dropping the initial “a”, we get ahed, alii, argh, arti, baca,
baci.</p></li>
<li><p>Encoding as 20-bit integers and adding an initial zero, we get 0,
7299, 11528, 17607, 18024, 32832, 32840.</p></li>
<li><p>The differences-minus-one are 7298, 4228, 6078, 416, 14807,
7.</p></li>
<li><p>Each of these fits in 14-bits (two bytes, given the high-bit
usage), with the last one in 7-bits. In practice, there are a lot of
differences that fit in 7-bits, so this ends up being more efficient
than it looks—the first six words are not representative.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
  <li><p>With the code as described above, there are 250 bytes to spare in the cartridge.</p></li>
<li><p>One might wonder whether making up the compression algorithm
saves much memory over using a standard general purpose compressor. Yes.
<code>gzip</code> run on the 64860 bytes of uncompressed Vocabulary
yields 30338 bytes, which is rather worse than my 17871 byte compression
of the Vocabulary. Plus the decompression code would, I expect, be quite
a bit more complex.</p></li>
<li><p>One could save a little memory by encoding the four-letter
“words” in Step 2 in base-26 instead of four 5-bit sequences. But it
would save only about 0.5K of memory, and the code would be much nastier
(the Game Boy uses library functions for division!).</p></li>
<li><p>The Answers could be stored as a bitmap of length 12972, which
would be 1622 bytes. But this would make the code for generating a
random word more complicated and slower.</p></li>
</ul>

</div></div>
  </body>
</html>
