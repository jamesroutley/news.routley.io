<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/21%29-Top-K-Frequent-Elements">Original</a>
    <h1>21) Top K Frequent Elements</h1>
    
    <div id="readability-page-1" class="page"><article><p>Sorta floundered about and got here:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> topKFrequent</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[], </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span>[] {</span></span>
<span data-line=""><span>    // so I&#39;m thinking a map</span></span>
<span data-line=""><span>    // where Map&lt;the Number, incrementing count of those elements&gt;</span></span>
<span data-line=""><span>    // the trickier part is the sorting I think, at the end. where I take a map</span></span>
<span data-line=""><span>    // wait what? How many numbers am I supposed to return?</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> kMap</span><span>:</span><span> Map</span><span>&lt;</span><span>number</span><span>, </span><span>number</span><span>&gt; </span><span>=</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> num </span><span>of</span><span> nums){</span></span>
<span data-line=""><span>        if</span><span> (</span><span>!</span><span>kMap.</span><span>has</span><span>(num)){</span></span>
<span data-line=""><span>            kMap.</span><span>set</span><span>(num, </span><span>1</span><span>)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            kMap.</span><span>set</span><span>(num, Kmap.</span><span>get</span><span>(num)</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> nar</span><span> =</span><span> Array.</span><span>from</span><span>(kMap)</span></span>
<span data-line=""><span>    console.</span><span>log</span><span>(nar)</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>But what I was missing was an idea for how to sort the map, and really everything on this last crazy line in this example I found:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> topKFrequent</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[], </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span>[] {</span></span>
<span data-line=""><span>    // so I&#39;m thinking a map</span></span>
<span data-line=""><span>    // where Map&lt;the Number, incrementing count of those elements&gt;</span></span>
<span data-line=""><span>    // the trickier part is the sorting I think, at the end. where I take a map</span></span>
<span data-line=""><span>    // wait what? How many numbers am I supposed to return?</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> kMap</span><span>:</span><span> Map</span><span>&lt;</span><span>number</span><span>, </span><span>number</span><span>&gt; </span><span>=</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> num </span><span>of</span><span> nums){</span></span>
<span data-line=""><span>        if</span><span> (</span><span>!</span><span>kMap.</span><span>has</span><span>(num)){</span></span>
<span data-line=""><span>            kMap.</span><span>set</span><span>(num, </span><span>1</span><span>)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            kMap.</span><span>set</span><span>(num, kMap.</span><span>get</span><span>(num)</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> [</span><span>...</span><span>kMap.</span><span>entries</span><span>()].</span><span>sort</span><span>((</span><span>a</span><span>,</span><span>b</span><span>)</span><span>=&gt;</span><span>b[</span><span>1</span><span>]</span><span>-</span><span>a[</span><span>1</span><span>]).</span><span>map</span><span>(</span><span>num</span><span>=&gt;</span><span>num[</span><span>0</span><span>]).</span><span>slice</span><span>(</span><span>0</span><span>,k)</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>So sick! The sorting function, map to return first element, and slice I probably would have gotten to eventually, but they were sort of overwhelming me.</p>
<p>In the context of interviewing, it definitely would be a good idea to just break them down into multiple lines, verbosely if necessary, any way I knew how.</p>
<p>But it is also nice to see this succinct way of doing things.</p>
<p>Sweet, reproduced it:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> topKFrequent</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[], </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span>[] {</span></span>
<span data-line=""><span>    const</span><span> numMap</span><span> =</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>const</span><span> num</span><span> of</span><span> nums){</span></span>
<span data-line=""><span>        if</span><span> (numMap.</span><span>has</span><span>(num)){</span></span>
<span data-line=""><span>            const</span><span> current</span><span> =</span><span> numMap.</span><span>get</span><span>(num)</span></span>
<span data-line=""><span>            numMap.</span><span>set</span><span>(num, current</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            numMap.</span><span>set</span><span>(num, </span><span>1</span><span>)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> [</span><span>...</span><span>numMap.</span><span>entries</span><span>()].</span><span>sort</span><span>((</span><span>a</span><span>, </span><span>b</span><span>)</span><span>=&gt;</span><span>b[</span><span>1</span><span>]</span><span>-</span><span>a[</span><span>1</span><span>]).</span><span>map</span><span>(</span><span>n</span><span>=&gt;</span><span>n[</span><span>0</span><span>]).</span><span>slice</span><span>(</span><span>0</span><span>, k)</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>I think the thing I grok the least here is the sort function to be honest. How does <code>b-a</code> evaluate in a useful way? It’s clearly an iteration over the map of some kind, that evaluates relationships.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">Okay so looking here<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>, and there is an optional compare function that can be passed in, which defines how custom sorting happens.</p>
<p>The compare function has the following form:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> compareFn</span><span>(</span><span>a</span><span>, </span><span>b</span><span>) {</span></span>
<span data-line=""><span>  if</span><span> (a is less than b by some ordering criterion) {</span></span>
<span data-line=""><span>    return</span><span> -</span><span>1</span><span>;</span></span>
<span data-line=""><span>  } </span><span>else</span><span> if</span><span> (a is greater than b by the ordering criterion) {</span></span>
<span data-line=""><span>    return</span><span> 1</span><span>;</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  // a must be equal to b</span></span>
<span data-line=""><span>  return</span><span> 0</span><span>;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>Okay…that makes sense, but doesn’t really apply to <code>b[1]-a[1]</code> as far as I can tell, because this statement could return all sorts of integers, positive or negative, besides 1 and -1.</p>
<p>Ah okay, here’s the real definition:</p>

























<div><table><thead><tr><th><code>compareFn(a, b)</code> return value</th><th>sort order</th></tr></thead><tbody><tr><td>&gt; 0</td><td>sort <code>a</code> after <code>b</code>, e.g. <code>[b, a]</code></td></tr><tr><td>&lt; 0</td><td>sort <code>a</code> before <code>b</code>, e.g. <code>[a, b]</code></td></tr><tr><td>=== 0</td><td>keep original order of <code>a</code> and <code>b</code></td></tr><tr><td>Okay let me just grok this in human language.</td><td></td></tr></tbody></table></div>
<p>If we run our compare function with arguments <code>(a,b)</code>, if return value is more than <code>0</code>, sort a <em>after</em> b. So positive leads to <code>b,a</code>, ordering. If a is <code>10</code>, and be is <code>5</code>, then <code>a-b</code> would result in a positive, and this to <code>b,a</code> sorting order.</p>

<p>Time to completion: <code>3:47</code></p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> topKFrequent</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[], </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span>[] {</span></span>
<span data-line=""><span>    const</span><span> numMap</span><span>:</span><span> Map</span><span>&lt;</span><span>number</span><span>, </span><span>number</span><span>&gt; </span><span>=</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> num </span><span>of</span><span> nums){</span></span>
<span data-line=""><span>        if</span><span> (numMap.</span><span>has</span><span>(num)){</span></span>
<span data-line=""><span>            let</span><span> current </span><span>=</span><span> numMap.</span><span>get</span><span>(num)</span></span>
<span data-line=""><span>            numMap.</span><span>set</span><span>(num, current</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            numMap.</span><span>set</span><span>(num, </span><span>1</span><span>)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> [</span><span>...</span><span>numMap.</span><span>entries</span><span>()].</span><span>sort</span><span>((</span><span>a</span><span>, </span><span>b</span><span>)</span><span>=&gt;</span><span>b[</span><span>1</span><span>]</span><span>-</span><span>a[</span><span>1</span><span>]).</span><span>map</span><span>(</span><span>n</span><span>=&gt;</span><span>n[</span><span>0</span><span>]).</span><span>slice</span><span>(</span><span>0</span><span>,k)</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Tried using <code>const numMap: Map&lt;number, number[]&gt;</code> which is I supposed an approach that could work, but is probably an unnecessary expensive space complexity.</p>
<p>I did find myself wondering if there was a more efficient way to do the type of map manipulation I am doing, where I check if a map has an entry and then immediately change that entry, otherwise setting it to a default value.</p>
<p>First off, I have to ask the question, why use <code>.has</code> instead of just <code>.get</code> on maps?</p>
<p>It turns out that one reason is that if the key to get is falsy, this can kind of mess things up. Not really an issue here though.</p>
<p>Claude says we can get ride of a TON of lines:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> topKFrequent</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[], </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span>[] {</span></span>
<span data-line=""><span>    const</span><span> numMap</span><span> =</span><span> new</span><span> Map</span><span>&lt;</span><span>number</span><span>, </span><span>number</span><span>&gt;();</span></span>
<span data-line=""><span>    nums.</span><span>forEach</span><span>(</span><span>num</span><span> =&gt;</span><span> numMap.</span><span>set</span><span>(num, (numMap.</span><span>get</span><span>(num) </span><span>||</span><span> 0</span><span>) </span><span>+</span><span> 1</span><span>));</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    return</span><span> [</span><span>...</span><span>numMap.</span><span>entries</span><span>()]</span></span>
<span data-line=""><span>        .</span><span>sort</span><span>((</span><span>a</span><span>, </span><span>b</span><span>) </span><span>=&gt;</span><span> b[</span><span>1</span><span>] </span><span>-</span><span> a[</span><span>1</span><span>])</span></span>
<span data-line=""><span>        .</span><span>slice</span><span>(</span><span>0</span><span>, k)</span></span>
<span data-line=""><span>        .</span><span>map</span><span>(([</span><span>num</span><span>]) </span><span>=&gt;</span><span> num);</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>Wow. Okay so we have this forEach…then for each, we TRY to get a value, and if it’s undefined, we default it to 0, and we add 1 regardless. Beautiful! This is so cool. Let me try to implement this from memory.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> topKFrequent</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[], </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span>[] {</span></span>
<span data-line=""><span>    const</span><span> numMap</span><span>:</span><span> Map</span><span>&lt;</span><span>number</span><span>, </span><span>number</span><span>&gt; </span><span>=</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""><span>    nums.</span><span>forEach</span><span>(</span><span>num</span><span> =&gt;</span><span> numMap.</span><span>set</span><span>(num, (numMap.</span><span>get</span><span>(num) </span><span>||</span><span> 0</span><span>) </span><span>+</span><span> 1</span><span>))</span></span>
<span data-line=""><span>    return</span><span> [</span><span>...</span><span>numMap.</span><span>entries</span><span>()].</span><span>sort</span><span>((</span><span>a</span><span>, </span><span>b</span><span>)</span><span>=&gt;</span><span>b[</span><span>1</span><span>]</span><span>-</span><span>a[</span><span>1</span><span>]).</span><span>map</span><span>(</span><span>n</span><span>=&gt;</span><span>n[</span><span>0</span><span>]).</span><span>slice</span><span>(</span><span>0</span><span>,k)</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Wow, got it!</p>
<p>Time to completion: <code>3:16</code></p>
<p><em>Technically</em> a three liner. I like how claude split up the dots. Also, the 3rd line is definitely not readable, but it is cool that it CAN be one line.</p></article></div>
  </body>
</html>
