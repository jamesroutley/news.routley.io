<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://notes.eatonphil.com/compiler-basics-lisp-to-assembly.html">Original</a>
    <h1>Writing a Lisp compiler (Lisp to assembly) from scratch in JavaScript (2018)</h1>
    
    <div id="readability-page-1" class="page"><div>
          <p>
  Next in compiler basics:
  <!-- forgive me, for I have sinned -->
  </p><p>In this post we&#39;ll write a simple compiler in Javascript (on Node)
without any third-party libraries. Our goal is to take an input
program like <code>(+ 1 (+ 2 3))</code> and produce an output assembly program
that does these operations to produce <code>6</code> as the exit code. The
resulting compiler can be found
<a href="https://github.com/eatonphil/ulisp">here</a>.</p>
<p>We&#39;ll cover:</p>
<ul>
<li>Parsing</li>
<li>Code generation</li>
<li>Assembly basics</li>
<li>Syscalls</li>
</ul>
<p>And for now we&#39;ll omit:</p>
<ul>
<li>Programmable function definitions</li>
<li>Non-symbol/-numeric data types</li>
<li>More than 3 function arguments</li>
<li>Lots of safety</li>
<li>Lots of error messsages</li>
</ul>
<h3 id="parsing">Parsing</h3><p>We pick the <a href="https://en.wikipedia.org/wiki/S-expression">S-expression</a>
syntax mentioned earlier because it&#39;s very easy to parse. Furthermore,
our input language is so limited that we won&#39;t even break our parser
into separate lexing/parsing stages.</p>
<p>
  Once you need to support string literals, comments, decimal
  literals, and other more complex literals it becomes easier to use
  separate stages.

  </p><p>The parser should produce an Abstract Syntax Tree (AST), a data
structure representing the input program. Specifically, we want <code>(+ 1 (+ 2 3))</code>
to produce <code>[&#39;+&#39;, 1, [&#39;+&#39;, 2, 3]]</code> in Javascript.</p>
<p>There are many different ways to go about parsing but the most
intuitive to me is to have a function that accepts a program (a
string) and returns a tuple containing the program parsed so far (an
AST) and the rest of the program (a string) that hasn&#39;t been
parsed.</p>
<p>That leaves us with a function skeleton that looks like this:</p>
<div><pre><span></span><span>module</span><span>.</span><span>exports</span><span>.</span><span>parse</span><span> </span><span>=</span><span> </span><span>function</span><span> </span><span>parse</span><span>(</span><span>program</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>const</span><span> </span><span>tokens</span><span> </span><span>=</span><span> </span><span>[];</span>

<span>  </span><span>...</span><span> </span><span>logic</span><span> </span><span>to</span><span> </span><span>be</span><span> </span><span>added</span><span> </span><span>...</span>

<span>  </span><span>return</span><span> </span><span>[</span><span>tokens</span><span>,</span><span> </span><span>&#39;&#39;</span><span>];</span>
<span>};</span>
</pre></div>
<p>The code that initially calls parse will thus have to deal with
unwrapping the outermost tuple to get to the AST. For a more helpful
compiler we could check that the entire program <em>was</em> actually parsed
by failing if the second element of the return result is not the empty
string.</p>
<p>Within the function we will iterate over each character and accumulate
until we hit space, left or right parenthesis:</p>
<div><pre><span></span><span>module</span><span>.</span><span>exports</span><span>.</span><span>parse</span><span> </span><span>=</span><span> </span><span>function</span><span> </span><span>parse</span><span>(</span><span>program</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>const</span><span> </span><span>tokens</span><span> </span><span>=</span><span> </span><span>[];</span>
<span>  </span><span>let</span><span> </span><span>currentToken</span><span> </span><span>=</span><span> </span><span>&#39;&#39;</span><span>;</span>

<span>  </span><span>for</span><span> </span><span>(</span><span>let</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>program</span><span>.</span><span>length</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>const</span><span> </span><span>char</span><span> </span><span>=</span><span> </span><span>program</span><span>.</span><span>charAt</span><span>(</span><span>i</span><span>);</span>

<span>    </span><span>switch</span><span> </span><span>(</span><span>char</span><span>)</span><span> </span><span>{</span>
<span>      </span><span>case</span><span> </span><span>&#39;(&#39;</span><span>:</span><span> </span><span>// TODO</span>
<span>        </span><span>break</span><span>;</span>
<span>      </span><span>case</span><span> </span><span>&#39;)&#39;</span><span>:</span><span> </span><span>// TODO</span>
<span>        </span><span>break</span><span>;</span>
<span>      </span><span>case</span><span> </span><span>&#39; &#39;</span><span>:</span>
<span>        </span><span>tokens</span><span>.</span><span>push</span><span>(</span><span>+</span><span>currentToken</span><span> </span><span>||</span><span> </span><span>currentToken</span><span>);</span>
<span>        </span><span>currentToken</span><span> </span><span>=</span><span> </span><span>&#39;&#39;</span><span>;</span>
<span>        </span><span>break</span><span>;</span>
<span>      </span><span>default</span><span>:</span>
<span>        </span><span>currentToken</span><span> </span><span>+=</span><span> </span><span>char</span><span>;</span>
<span>        </span><span>break</span><span>;</span>
<span>    </span><span>}</span>
<span>  </span><span>}</span>

<span>  </span><span>return</span><span> </span><span>[</span><span>tokens</span><span>,</span><span> </span><span>&#39;&#39;</span><span>];</span>
<span>};</span>
</pre></div>
<p>The recursive parts are always the most challenging. The right paren
is easiest. We must push the current token and return all tokens with
the rest of the program:</p>
<div><pre><span></span><span>module</span><span>.</span><span>exports</span><span>.</span><span>parse</span><span> </span><span>=</span><span> </span><span>function</span><span> </span><span>parse</span><span>(</span><span>program</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>const</span><span> </span><span>tokens</span><span> </span><span>=</span><span> </span><span>[];</span>
<span>  </span><span>let</span><span> </span><span>currentToken</span><span> </span><span>=</span><span> </span><span>&#39;&#39;</span><span>;</span>

<span>  </span><span>for</span><span> </span><span>(</span><span>let</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>program</span><span>.</span><span>length</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>const</span><span> </span><span>char</span><span> </span><span>=</span><span> </span><span>program</span><span>.</span><span>charAt</span><span>(</span><span>i</span><span>);</span>

<span>    </span><span>switch</span><span> </span><span>(</span><span>char</span><span>)</span><span> </span><span>{</span>
<span>      </span><span>case</span><span> </span><span>&#39;(&#39;</span><span>:</span><span> </span><span>// TODO</span>
<span>        </span><span>break</span><span>;</span>
<span>      </span><span>case</span><span> </span><span>&#39;)&#39;</span><span>:</span>
<span>        </span><span>tokens</span><span>.</span><span>push</span><span>(</span><span>+</span><span>currentToken</span><span> </span><span>||</span><span> </span><span>currentToken</span><span>);</span>
<span>        </span><span>return</span><span> </span><span>[</span><span>tokens</span><span>,</span><span> </span><span>program</span><span>.</span><span>substring</span><span>(</span><span>i</span><span> </span><span>+</span><span> </span><span>1</span><span>)];</span>
<span>      </span><span>case</span><span> </span><span>&#39; &#39;</span><span>:</span>
<span>        </span><span>tokens</span><span>.</span><span>push</span><span>(</span><span>+</span><span>currentToken</span><span> </span><span>||</span><span> </span><span>currentToken</span><span>);</span>
<span>        </span><span>currentToken</span><span> </span><span>=</span><span> </span><span>&#39;&#39;</span><span>;</span>
<span>        </span><span>break</span><span>;</span>
<span>      </span><span>default</span><span>:</span>
<span>        </span><span>currentToken</span><span> </span><span>+=</span><span> </span><span>char</span><span>;</span>
<span>        </span><span>break</span><span>;</span>
<span>    </span><span>}</span>
<span>  </span><span>}</span>

<span>  </span><span>return</span><span> </span><span>[</span><span>tokens</span><span>,</span><span> </span><span>&#39;&#39;</span><span>];</span>
<span>};</span>
</pre></div>
<p>Finally the left paren should recurse, add the parsed tokens to the
list of sibling tokens, and force the loop to start at the new
unparsed point.</p>
<div><pre><span></span><span>module</span><span>.</span><span>exports</span><span>.</span><span>parse</span><span> </span><span>=</span><span> </span><span>function</span><span> </span><span>parse</span><span>(</span><span>program</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>const</span><span> </span><span>tokens</span><span> </span><span>=</span><span> </span><span>[];</span>
<span>  </span><span>let</span><span> </span><span>currentToken</span><span> </span><span>=</span><span> </span><span>&#39;&#39;</span><span>;</span>

<span>  </span><span>for</span><span> </span><span>(</span><span>let</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>program</span><span>.</span><span>length</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>const</span><span> </span><span>char</span><span> </span><span>=</span><span> </span><span>program</span><span>.</span><span>charAt</span><span>(</span><span>i</span><span>);</span>

<span>    </span><span>switch</span><span> </span><span>(</span><span>char</span><span>)</span><span> </span><span>{</span>
<span>      </span><span>case</span><span> </span><span>&#39;(&#39;</span><span>:</span><span> </span><span>{</span>
<span>        </span><span>const</span><span> </span><span>[</span><span>parsed</span><span>,</span><span> </span><span>rest</span><span>]</span><span> </span><span>=</span><span> </span><span>parse</span><span>(</span><span>program</span><span>.</span><span>substring</span><span>(</span><span>i</span><span> </span><span>+</span><span> </span><span>1</span><span>));</span>
<span>        </span><span>tokens</span><span>.</span><span>push</span><span>(</span><span>parsed</span><span>);</span>
<span>        </span><span>program</span><span> </span><span>=</span><span> </span><span>rest</span><span>;</span>
<span>        </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>        </span><span>break</span><span>;</span>
<span>      </span><span>}</span>
<span>      </span><span>case</span><span> </span><span>&#39;)&#39;</span><span>:</span>
<span>        </span><span>tokens</span><span>.</span><span>push</span><span>(</span><span>+</span><span>currentToken</span><span> </span><span>||</span><span> </span><span>currentToken</span><span>);</span>
<span>        </span><span>return</span><span> </span><span>[</span><span>tokens</span><span>,</span><span> </span><span>program</span><span>.</span><span>substring</span><span>(</span><span>i</span><span> </span><span>+</span><span> </span><span>1</span><span>)];</span>
<span>      </span><span>case</span><span> </span><span>&#39; &#39;</span><span>:</span>
<span>        </span><span>tokens</span><span>.</span><span>push</span><span>(</span><span>+</span><span>currentToken</span><span> </span><span>||</span><span> </span><span>currentToken</span><span>);</span>
<span>        </span><span>currentToken</span><span> </span><span>=</span><span> </span><span>&#39;&#39;</span><span>;</span>
<span>        </span><span>break</span><span>;</span>
<span>      </span><span>default</span><span>:</span>
<span>        </span><span>currentToken</span><span> </span><span>+=</span><span> </span><span>char</span><span>;</span>
<span>        </span><span>break</span><span>;</span>
<span>    </span><span>}</span>
<span>  </span><span>}</span>

<span>  </span><span>return</span><span> </span><span>[</span><span>tokens</span><span>,</span><span> </span><span>&#39;&#39;</span><span>];</span>
<span>};</span>
</pre></div>
<p>Assuming this is all in <code>parser.js</code>, let&#39;s try it out in the REPL:</p>
<div><pre><span></span>$<span> </span>node
&gt;<span> </span>const<span> </span><span>{</span><span> </span>parse<span> </span><span>}</span><span> </span><span>=</span><span> </span>require<span>(</span><span>&#39;./parser&#39;</span><span>)</span><span>;</span>
undefined
&gt;<span> </span>console.log<span>(</span>JSON.stringify<span>(</span>parse<span>(</span><span>&#39;(+ 3 (+ 1 2)&#39;</span><span>)))</span><span>;</span>
<span>[[[</span><span>&#34;+&#34;</span>,3,<span>[</span><span>&#34;+&#34;</span>,1,2<span>]]]</span>,<span>&#34;&#34;</span><span>]</span>
</pre></div>
<p>Solid. We move on.</p>
<h3 id="assembly-101">Assembly 101</h3><p>Assembly is essentially the lowest-level programming language we can
use. It is a human readable, 1:1 representation of the binary
instructions the CPU can interpret. Conversion from assembly to
binary is done with an assembler; the reverse step is done with a
disassembler. We&#39;ll use <code>gcc</code> for assembling since it deals with some
<a href="http://fabiensanglard.net/macosxassembly/index.php">oddities</a> of
assembly programming on macOS.</p>
<p>The primary data structures in assembly are registers (temporary
variables stored by the CPU) and the program stack. Every function in
a program has access to the same registers, but convention cordons
off sections of the stack for each function so it ends up being a
slightly more durable store than registers. <code>RAX</code>, <code>RDI</code>, <code>RDX</code>, and
<code>RSI</code> are a few registers available to us.</p>
<p>Now we only need to know a few instructions to compile our program
(the rest of programming assembly is convention):</p>
<ul>
<li><code>MOV</code>: store one register&#39;s content into another, or store a literal number into a register</li>
<li><code>ADD</code>: store the sum of two register&#39;s contents in the first register</li>
<li><code>PUSH</code>: store a register&#39;s content on the stack</li>
<li><code>POP</code>: remove the top-most value from the stack and store in a register</li>
<li><code>CALL</code>: enter a new section of the stack and start running the function</li>
<li><code>RET</code>: enter the calling functions stack and return to evaluating from the next instruction after the call</li>
<li><code>SYSCALL</code>: like <code>CALL</code> but where the function is handled by the kernel</li>
</ul>
<h3 id="function-calling-convention">Function calling convention</h3><p>Assembly instructions are flexible enough that there is no
language-defined way to make function calls. Therefore it is important
to answer (at least) the following few questions:</p>
<ul>
<li>Where are parameters stored by the caller so that the callee has access to them?</li>
<li>Where is the return value stored by the callee so the caller has access to it?</li>
<li>What registers are saved by whom?</li>
</ul>
<p>Without getting too far into the specifics, we&#39;ll assume the following
answers for development on x86_64 macOS and Linux systems:</p>
<ul>
<li>Parameters are stored (in order) in the <code>RDI</code>, <code>RSI</code>, and <code>RDX</code> registers<ul>
<li>We won&#39;t support passing more than three arguments</li>
</ul>
</li>
<li>The return value is stored in the <code>RAX</code> register</li>
<li><code>RDI</code>, <code>RSI</code>, and <code>RDX</code> registers are stored by the caller</li>
</ul>
<h3 id="code-generation">Code generation</h3><p>With assembly basics and the function call convention in mind, we&#39;ve
got enough to generate code from the parsed program&#39;s AST.</p>
<p>The skeleton of our compile code will look like this:</p>
<div><pre><span></span><span>function</span><span> </span><span>emit</span><span>(</span><span>depth</span><span>,</span><span> </span><span>code</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>const</span><span> </span><span>indent</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Array</span><span>(</span><span>depth</span><span> </span><span>+</span><span> </span><span>1</span><span>).</span><span>map</span><span>(()</span><span> </span><span>=&gt;</span><span> </span><span>&#39;&#39;</span><span>).</span><span>join</span><span>(</span><span>&#39;  &#39;</span><span>);</span>
<span>  </span><span>console</span><span>.</span><span>log</span><span>(</span><span>indent</span><span> </span><span>+</span><span> </span><span>code</span><span>);</span>
<span>}</span>

<span>function</span><span> </span><span>compile_argument</span><span>(</span><span>arg</span><span>,</span><span> </span><span>destination</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>// If arg AST is a list, call compile_call on it</span>

<span>  </span><span>// Else must be a literal number, store in destination register</span>
<span>}</span>

<span>function</span><span> </span><span>compile_call</span><span>(</span><span>fun</span><span>,</span><span> </span><span>args</span><span>,</span><span> </span><span>destination</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>// Save param registers to the stack</span>

<span>  </span><span>// Compile arguments and store in param registers</span>

<span>  </span><span>// Call function</span>

<span>  </span><span>// Restore param registers from the stack</span>

<span>  </span><span>// Move result into destination if provided</span>
<span>}</span>

<span>function</span><span> </span><span>emit_prefix</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>// Assembly prefix</span>
<span>}</span>

<span>function</span><span> </span><span>emit_postfix</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>// Assembly postfix</span>
<span>}</span>

<span>module</span><span>.</span><span>exports</span><span>.</span><span>compile</span><span> </span><span>=</span><span> </span><span>function</span><span> </span><span>parse</span><span>(</span><span>ast</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>emit_prefix</span><span>();</span>
<span>  </span><span>compile_call</span><span>(</span><span>ast</span><span>[</span><span>0</span><span>],</span><span> </span><span>ast</span><span>.</span><span>slice</span><span>(</span><span>1</span><span>));</span>
<span>  </span><span>emit_postfix</span><span>();</span>
<span>};</span>
</pre></div>
<p>From our pseudo-code in comments it is simple enough to fill in.
Let&#39;s fill in everything but the prefix and postfix code.</p>
<div><pre><span></span><span>function</span><span> </span><span>compile_argument</span><span>(</span><span>arg</span><span>,</span><span> </span><span>destination</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>// If arg AST is a list, call compile_call on it</span>
<span>  </span><span>if</span><span> </span><span>(</span><span>Array</span><span>.</span><span>isArray</span><span>(</span><span>arg</span><span>))</span><span> </span><span>{</span>
<span>    </span><span>compile_call</span><span>(</span><span>arg</span><span>[</span><span>0</span><span>],</span><span> </span><span>arg</span><span>.</span><span>slice</span><span>(</span><span>1</span><span>),</span><span> </span><span>destination</span><span>);</span>
<span>    </span><span>return</span><span>;</span>
<span>  </span><span>}</span>

<span>  </span><span>// Else must be a literal number, store in destination register</span>
<span>  </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>`MOV </span><span>${</span><span>destination</span><span>}</span><span>, </span><span>${</span><span>arg</span><span>}</span><span>`</span><span>);</span>
<span>}</span>

<span>const</span><span> </span><span>BUILTIN_FUNCTIONS</span><span> </span><span>=</span><span> </span><span>{</span><span> </span><span>&#39;+&#39;</span><span>:</span><span> </span><span>&#39;plus&#39;</span><span> </span><span>};</span>
<span>const</span><span> </span><span>PARAM_REGISTERS</span><span> </span><span>=</span><span> </span><span>[</span><span>&#39;RDI&#39;</span><span>,</span><span> </span><span>&#39;RSI&#39;</span><span>,</span><span> </span><span>&#39;RDX&#39;</span><span>];</span>

<span>function</span><span> </span><span>compile_call</span><span>(</span><span>fun</span><span>,</span><span> </span><span>args</span><span>,</span><span> </span><span>destination</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>// Save param registers to the stack</span>
<span>  </span><span>args</span><span>.</span><span>forEach</span><span>((</span><span>_</span><span>,</span><span> </span><span>i</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>`PUSH </span><span>${</span><span>PARAM_REGISTERS</span><span>[</span><span>i</span><span>]</span><span>}</span><span>`</span><span>));</span>

<span>  </span><span>// Compile arguments and store in param registers</span>
<span>  </span><span>args</span><span>.</span><span>forEach</span><span>((</span><span>arg</span><span>,</span><span> </span><span>i</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>compile_argument</span><span>(</span><span>arg</span><span>,</span><span> </span><span>PARAM_REGISTERS</span><span>[</span><span>i</span><span>]));</span>

<span>  </span><span>// Call function</span>
<span>  </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>`CALL </span><span>${</span><span>BUILTIN_FUNCTIONS</span><span>[</span><span>fun</span><span>]</span><span> </span><span>||</span><span> </span><span>fun</span><span>}</span><span>`</span><span>);</span>

<span>  </span><span>// Restore param registers from the stack</span>
<span>  </span><span>args</span><span>.</span><span>forEach</span><span>((</span><span>_</span><span>,</span><span> </span><span>i</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>`POP </span><span>${</span><span>PARAM_REGISTERS</span><span>[</span><span>args</span><span>.</span><span>length</span><span> </span><span>-</span><span> </span><span>i</span><span> </span><span>-</span><span> </span><span>1</span><span>]</span><span>}</span><span>`</span><span>));</span>

<span>  </span><span>// Move result into destination if provided</span>
<span>  </span><span>if</span><span> </span><span>(</span><span>destination</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>`MOV </span><span>${</span><span>destination</span><span>}</span><span>, RAX`</span><span>);</span>
<span>  </span><span>}</span>

<span>  </span><span>emit</span><span>(</span><span>0</span><span>,</span><span> </span><span>&#39;&#39;</span><span>);</span><span> </span><span>// For nice formatting</span>
<span>}</span>
</pre></div>
<p>In a better compiler, we would not make <code>plus</code> a built-in
function. We&#39;d emit code for the assembly instruction <code>ADD</code>. However,
making <code>plus</code> a function makes code generation simpler and also allows
us to see what function calls look like.</p>
<p>We&#39;ll define the <code>plus</code> built-in function in the prefix code.</p>
<h3 id="the-prefix">The prefix</h3><p>Assembly programs consist of a few &#34;sections&#34; in memory. The most
important of which are the <code>text</code> and <code>data</code> sections. <code>text</code> is a
read-only section where the program instructions themselves are
stored. The CPU is instructed to start interpreting from some location
in this text section and it will increment through instructions,
evaluating each instruction until it reaches an instruction that tells
it to jump to a different location to evaluate instructions (e.g. with
CALL, RET, or JMP).</p>
<p>To denote the text section we emit <code>.text</code> in our prefix before we
emit our generated code.</p>
<p>
  The data section is for statically initialized values (e.g. global
  variables). We don&#39;t have any need for that right now so we&#39;ll
  ignore it.
  </p><p>Additionally, we need to emit an entrypoint (we&#39;ll use <code>_main</code>) and
add a notice (<code>.global _main</code>) so that the location of this entrypoint
is visible externally. This is important because we let <code>gcc</code> handle
the hairier parts of generating an executable file and it needs access
to the entrypoint.</p>
<p>So far, our prefix looks like this:</p>
<div><pre><span></span><span>function</span><span> </span><span>emit_prefix</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>&#39;.global _main\n&#39;</span><span>);</span>

<span>  </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>&#39;.text\n&#39;</span><span>);</span>

<span>  </span><span>// TODO: add built-in functions</span>

<span>  </span><span>emit</span><span>(</span><span>0</span><span>,</span><span> </span><span>&#39;_main:&#39;</span><span>);</span>
<span>}</span>
</pre></div>
<p>The last part of our prefix needs to include the <code>plus</code> built-in
function. For this, we add the first two parameter registers we agreed
on (<code>RDI</code> and <code>RSI</code>) and store the result in <code>RAX</code>.</p>
<div><pre><span></span><span>function</span><span> </span><span>emit_prefix</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>&#39;.global _main\n&#39;</span><span>);</span>

<span>  </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>&#39;.text\n&#39;</span><span>);</span>

<span>  </span><span>emit</span><span>(</span><span>0</span><span>,</span><span> </span><span>&#39;plus:&#39;</span><span>);</span>
<span>  </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>&#39;ADD RDI, RSI&#39;</span><span>);</span>
<span>  </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>&#39;MOV RAX, RDI&#39;</span><span>);</span>
<span>  </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>&#39;RET\n&#39;</span><span>);</span>

<span>  </span><span>emit</span><span>(</span><span>0</span><span>,</span><span> </span><span>&#39;_main:&#39;</span><span>);</span>
<span>}</span>
</pre></div>
<p>And we&#39;re golden.</p>
<h3 id="the-postfix">The postfix</h3><p>The job of the postfix will be simple, call <code>exit</code> with the value of
<code>RAX</code> since this will be the result of the last function called by the
program.</p>
<p><code>exit</code> is a syscall, so we&#39;ll use the <code>SYSCALL</code> instruction to call
it. The x86_64 calling convention on macOS and Linux for <code>SYSCALL</code>
defines parameters the same way <code>CALL</code> does. But we also need to tell
<code>SYSCALL</code> what syscall to call. The convention is to set <code>RAX</code> to the
integer representing the syscall on the current system. On Linux it
will be <code>60</code>; on macOS it is <code>0x2000001</code>.</p>
<p>
  When I say &#34;convention&#34;, I don&#39;t mean that you really have a choice
  as a programmer. It was arbitrary when the operating system and
  standard libraries chose it. But if you want to write a working
  program that uses syscalls or calls out to (say) glibc, you&#39;ll need
  to follow these conventions.
</p><p>The postfix then looks like this:</p>
<div><pre><span></span><span>const</span><span> </span><span>os</span><span> </span><span>=</span><span> </span><span>require</span><span>(</span><span>&#39;os&#39;</span><span>);</span>

<span>const</span><span> </span><span>SYSCALL_MAP</span><span> </span><span>=</span><span> </span><span>os</span><span>.</span><span>platform</span><span>()</span><span> </span><span>===</span><span> </span><span>&#39;darwin&#39;</span><span> </span><span>?</span><span> </span><span>{</span>
<span>    </span><span>&#39;exit&#39;</span><span>:</span><span> </span><span>&#39;0x2000001&#39;</span><span>,</span>
<span>}</span><span> </span><span>:</span><span> </span><span>{</span>
<span>    </span><span>&#39;exit&#39;</span><span>:</span><span> </span><span>60</span><span>,</span>
<span>};</span>

<span>function</span><span> </span><span>emit_postfix</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>&#39;MOV RDI, RAX&#39;</span><span>);</span><span> </span><span>// Set exit arg</span>
<span>  </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>`MOV RAX, </span><span>${</span><span>SYSCALL_MAP</span><span>[</span><span>&#39;exit&#39;</span><span>]</span><span>}</span><span>`</span><span>);</span><span> </span><span>// Set syscall number</span>
<span>  </span><span>emit</span><span>(</span><span>1</span><span>,</span><span> </span><span>&#39;SYSCALL&#39;</span><span>);</span>
<span>}</span>
</pre></div>
<p>And we&#39;re set here too.</p>
<h3 id="putting-it-all-together">Putting it all together</h3><p>We can finally write our Javascript entrypoint and run our compiler
against a sample program.</p>
<p>The entrypoint might look like this:</p>
<div><pre><span></span><span>const</span><span> </span><span>{</span><span> </span><span>parse</span><span> </span><span>}</span><span> </span><span>=</span><span> </span><span>require</span><span>(</span><span>&#39;./parser&#39;</span><span>);</span>
<span>const</span><span> </span><span>{</span><span> </span><span>compile</span><span> </span><span>}</span><span> </span><span>=</span><span> </span><span>require</span><span>(</span><span>&#39;./compiler&#39;</span><span>);</span>

<span>function</span><span> </span><span>main</span><span>(</span><span>args</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>const</span><span> </span><span>script</span><span> </span><span>=</span><span> </span><span>args</span><span>[</span><span>2</span><span>];</span>
<span>  </span><span>const</span><span> </span><span>[</span><span>ast</span><span>]</span><span> </span><span>=</span><span> </span><span>parse</span><span>(</span><span>script</span><span>);</span>
<span>  </span><span>compile</span><span>(</span><span>ast</span><span>[</span><span>0</span><span>]);</span>
<span>}</span>

<span>main</span><span>(</span><span>process</span><span>.</span><span>argv</span><span>);</span>
</pre></div>
<p>And we can call it like so:</p>
<div><pre><span></span><span>$</span><span> </span><span>node</span><span> </span><span>ulisp.js</span><span> </span><span>&#39;(+ 3 (+ 2 1))&#39;</span>
<span>  </span><span>.global</span><span> </span><span>_main</span>

<span>  </span><span>.text</span>

<span>plus:</span>
<span>  </span><span>ADD</span><span> </span><span>RDI</span><span>,</span><span> </span><span>RSI</span>
<span>  </span><span>MOV</span><span> </span><span>RAX</span><span>,</span><span> </span><span>RDI</span>
<span>  </span><span>RET</span>

<span>_main:</span>
<span>  </span><span>PUSH</span><span> </span><span>RDI</span>
<span>  </span><span>PUSH</span><span> </span><span>RSI</span>
<span>  </span><span>MOV</span><span> </span><span>RDI</span><span>,</span><span> </span><span>3</span>
<span>  </span><span>PUSH</span><span> </span><span>RDI</span>
<span>  </span><span>PUSH</span><span> </span><span>RSI</span>
<span>  </span><span>MOV</span><span> </span><span>RDI</span><span>,</span><span> </span><span>2</span>
<span>  </span><span>MOV</span><span> </span><span>RSI</span><span>,</span><span> </span><span>1</span>
<span>  </span><span>CALL</span><span> </span><span>plus</span>
<span>  </span><span>POP</span><span> </span><span>RSI</span>
<span>  </span><span>POP</span><span> </span><span>RDI</span>
<span>  </span><span>MOV</span><span> </span><span>RSI</span><span>,</span><span> </span><span>RAX</span>

<span>  </span><span>CALL</span><span> </span><span>plus</span>
<span>  </span><span>POP</span><span> </span><span>RSI</span>
<span>  </span><span>POP</span><span> </span><span>RDI</span>

<span>  </span><span>MOV</span><span> </span><span>RDI</span><span>,</span><span> </span><span>RAX</span>
<span>  </span><span>MOV</span><span> </span><span>RAX</span><span>,</span><span> </span><span>0x2000001</span>
<span>  </span><span>SYSCALL</span>
</pre></div>
<h3 id="generating-an-executable-file-from-the-output">Generating an executable file from the output</h3><p>If we redirect the previous output to an assembly file and call <code>gcc</code>
on it, we can generate a program we can run. Then we can echo the <code>$?</code>
variable to see the exit code of the previous process.</p>
<div><pre><span></span>$<span> </span>node<span> </span>ulisp.js<span> </span><span>&#39;(+ 3 (+ 2 1))&#39;</span><span> </span>&gt;<span> </span>program.S
$<span> </span>gcc<span> </span>-mstackrealign<span> </span>-masm<span>=</span>intel<span> </span>-o<span> </span>program<span> </span>program.s
$<span> </span>./program
$<span> </span><span>echo</span><span> </span><span>$?</span>
<span>6</span>
</pre></div>
<p>And we&#39;ve got a working compiler! The full source of the compiler is
available <a href="https://github.com/eatonphil/ulisp">here</a>.</p>
<h3 id="further-reading">Further reading</h3><ul>
<li><a href="https://aaronbloomfield.github.io/pdr/book/x86-64bit-ccc-chapter.pdf">x86_64 calling convention</a></li>
<li>macOS assembly programming<ul>
<li><a href="http://fabiensanglard.net/macosxassembly/index.php">Stack alignment on macOS</a></li>
<li><a href="https://filippo.io/making-system-calls-from-assembly-in-mac-os-x/">Syscalls on macOS</a></li>
</ul>
</li>
<li>Destination-driven code generation<ul>
<li><a href="https://www.cs.indiana.edu/~dyb/pubs/ddcg.pdf">Kent Dybvig&#39;s original paper</a></li>
<li><a href="http://cs.au.dk/~mis/dOvs/slides/46b-codegeneration-in-V8.pdf">One-pass code generation in V8</a></li>
</ul>
</li>
</ul>
<blockquote><p lang="en" dir="ltr">Finished that intro to compilers post :) lisp to assembly in Javascript <a href="https://t.co/0HDIn4Mv7a">https://t.co/0HDIn4Mv7a</a></p>â€” Phil Eaton (@phil_eaton) <a href="https://twitter.com/phil_eaton/status/1066863077000441856?ref_src=twsrc%5Etfw">November 26, 2018</a></blockquote> 

	</div></div>
  </body>
</html>
