<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/great-things-about-rust-beyond-perf/?utm_source=atom&amp;utm_medium=feed">Original</a>
    <h1>Great things about Rust that aren&#39;t just performance</h1>
    
    <div id="readability-page-1" class="page"><div><p>Nearly every line of code I write for fun is in Rust.
It&#39;s not because I need great performance, though that&#39;s a nice benefit.
I write a lot of Rust because it&#39;s a joy to write code in.
There is so much else to love about Rust <em>beyond</em> going fast without segfaults.</p>
<p>Here are a few of my favorite things about it.
Note that these are <em>not</em> unique to Rust by any stretch!
Other languages have similar combinations of features.</p>

<p>There are two aspects of Rust&#39;s type system that I really enjoy: type safety and expressiveness.</p>
<p>I got a taste of this expressiveness back when I learned Haskell, and had been seeking it.
I found it in Rust.
One of the other languages I use a fair amount at work is Go, and its type system is much harder for me to express ideas in.
You can do it, but you&#39;re not getting the type system&#39;s help.
Rust lets you put your design straight into types, with enums and structs and traits giving you a lot of room to maneuver.</p>
<p>All the while, it&#39;s also giving you good type safety!
I can express a lot in Python, but I don&#39;t <em>trust</em> the code as much without robust tests.
You don&#39;t have a compiler checking your work!
It&#39;s remarkably helpful having Rust&#39;s compiler by your side, making sure that you&#39;re using types correctly and satisfying constraints on things.
To call back to data races, the type system is one of the reasons we can prevent those!
There are traits that tell you whether or not data is safe to send to another thread or to share with another thread.
If your language doesn&#39;t have the equivalent of these traits, then you&#39;re probably relying on the programmer to ensure those properties!</p>
<p>That said, Rust&#39;s type system isn&#39;t an unmitigated good for me.
It can take longer to get something up and running in Rust than in Python, for example, because of the rigidity of the type system: satisfy it or you don&#39;t run.
And I find a lot of Rust that uses generics is very hard to read, feeling like it is a soup of traits.
What we make generic is an implementation question, and a cultural question, so that isn&#39;t necessarily inherent to the language but does come strongly bundled to it.</p>

<p>Okay, I have a beef with Go.
They included Tony Hoare&#39;s <a href="https://en.wikipedia.org/wiki/Tony_Hoare#Research_and_career">&#34;billion-dollar mistake&#34;</a>: null pointers.
Go gives you pointers, and they can be null!
This means that you can try to invoke methods on a null pointer, which can crash your program.</p>
<p>In contrast, Rust tries very very hard to make you never crash.
You can make null pointers, but you have to use <code>unsafe</code> and if you do that, well, you&#39;re taking on the risk.
If you have something which is nullable, you&#39;d use an <code>Option</code> of it and then the type system will make sure you handle both cases.</p>
<p>The places you typically see crashes in Rust are when someone either intentionally panics, for an unrecoverable error, or when they <em>unintentionally</em> panic, if they use <code>unwrap</code> on an <code>Option</code> or <code>Result</code>.
It&#39;s better to handle the other case explicitly.</p>
<p>Fortunately, you can configure the linter, clippy, to deny code that uses <code>unwrap</code> (or <code>expect</code>)!
If you add this to your Cargo.toml file, it will reject any code which uses <code>unwrap</code>.</p>
<pre data-lang="toml"><code data-lang="toml">[lints.clippy]
unwrap_used = &#34;deny&#34;
</code></pre>

<p>It&#39;s <em>so</em> hard to write concurrent code that works correctly.
Data races are one of the biggest factors contributing to this.
Rust&#39;s data race prevention is an incredible help for writing concurrent code.</p>
<p>Rust isn&#39;t <em>immune</em> to data races, but you have to work harder to make one happen.
They&#39;re almost trivial to introduce in most languages, but in Rust, it&#39;s a lot harder!
This happens because of the borrow checker, so it&#39;s harder to have multiple concurrent actors racing on the same data.</p>

<p>With Rust, you know a lot more about what the CPU and memory will be doing than in many other languages.
You can know this with C and C++, and newer systems programming languages like Zig.
Rust is a little unique, to me, in being notably higher level than these languages while giving you ultimately the same amount of control (if you break glass enough, for some things).</p>
<p>You&#39;re still subject to the operating system, most of the time, so you can&#39;t control the CPU and memory <em>fully</em>, but you get a lot more control than in Python.
Or even than Go, another language used when you need good performance.</p>
<p>This lets you predict what your code is going to do.
You&#39;re not going to have surprise pauses for the garbage collector, and you&#39;re not going to have the runtime scheduler put some tasks off for a while.
Instead, you know (or can determine) when memory will be deallocated.
And you ultimately control when threads take tasks (though with async and the Tokio runtime, this gets <em>much</em> muddier and you do lose some of this control).</p>
<p>This predictability is really nice.
It&#39;s useful in production, but it&#39;s also just really pleasant and comforting.</p>

<p>Rust lets you write in a functional programming style, and it also lets you write in an imperative programming style.
Most idiomatic code tends toward functional style, but there&#39;s a lot of code that uses imperative style effectively as well!</p>
<p>This is pretty unique in my experience, and I really like it.
It means that I, the programmer, can pick the paradigm that best fits the problem at hand at any given moment.
Code can be more expressive and clearer for the author and the team working on the code.</p>
<p>One of the cool things here, too, is that the two paradigms effectively translate between each other!
If you use iterators in Rust, they convert into <a href="https://ntietz.com/blog/rusts-iterators-optimize-footgun/">the same compiled binary</a> as the imperative code.
You often don&#39;t lose any efficiency from using either approach, and you&#39;re truly free to express yourself!</p>

<p>A few other languages are renowned for their error message quality—Elm comes to mind.
Rust is a standout here, as well.</p>
<p>Earlier in my career, I was <a href="https://ntietz.com/blog/lessons-from-my-first-on-call/">abused by C++</a>.
Besides all the production crashes and the associated stress of that, the compiler errors for it were absolutely inscrutable.
If you messed up a template, you&#39;d sometimes get thousands of lines of errors—from one missing semicolon.
And those wouldn&#39;t tell you what the error was, but rather, what came <em>after</em> the mistake.</p>
<p>In contrast, Rust&#39;s compiler error messages are usually pretty good at telling you exactly what the error is.
They even provide suggestions for how to fix it, and where to read more about the error.
Sometimes you get into a funny loop with these, where following the compiler&#39;s suggestions will lead to a loop of suggesting you change it another way and never get it to succeed, but that&#39;s fine.
The fact that they&#39;re often useful is remarkable!</p>

<p>This is the big one for me.
It&#39;s very subjective!
I really like Rust for all the reasons listed above, and many more I&#39;ve forgotten.</p>
<p>There are certainly painful times, and learning to love the borrow checker is a process (but one made faster if you&#39;ve been abused by C++ before).
But on balance, using Rust has been great.</p>
<p>It&#39;s fun having the <em>ability</em> to go ripping fast even when you don&#39;t <em>need</em> to.
It&#39;s lovely having a type system that lets you express yourself (even if it lets you express yourself <em>too</em> much sometimes).
The tooling is a joy.</p>
<p>All around, there&#39;s so <em>much</em> to love about Rust.
The performance and safety are great, but they&#39;re the tip of the iceberg, and it&#39;s a language worth considering even when you don&#39;t need top performance.</p>
<hr/>


</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts and support my work, subscribe to the <a href="https://phoboslab.org/newsletter/">newsletter</a>. There is also an <a href="https://phoboslab.org/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
