<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.smidt.dev/posts/0004/">Original</a>
    <h1>Bit Vectors and my first steps into assembly</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><h2><a href="https://blog.smidt.dev/posts/0004/">Bit Vectors and my first steps into assembly</a></h2><h3>Trying to speedup my lexer using lookups and bitvectors but simd was just a step to far for me.</h3></div></div></div><section><h2 id="intro">Intro</h2><p>I’ve recently started reading “Writing an Interpreter in Go” as part of my journey to sharpen my programming skills.
The main goal is actually to redo the book but in different languages like zig and rust.</p><p>At the time of writing, I was working on the lexer component and decided to explore performance optimizations Since A lexer is a state machine which essentially splits string into tokens.
Based on a few simple branches like take any character, number and underscore for an identifier.</p><p>In this post i will explore a few ways to speed up branches i also had the idea to use some SIMD instructions but this was rather hard.</p><h2 id="token-splitting">Token splitting</h2><p>So the main performance optimization is to find consecutive characters which are part of a token.
In the examples we are looking for any alphanumeric word.</p><h3 id="branches">branches</h3><p>The most strait forward way of doing this is to have a branch like:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td><td><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>&#39;0&#39;</span> <span>&lt;=</span> <span>x</span> <span>&amp;&amp;</span> <span>x</span> <span>&lt;=</span> <span>&#39;9&#39;</span> <span>||</span> <span>&#39;a&#39;</span> <span>&lt;=</span> <span>x</span> <span>&amp;&amp;</span> <span>x</span> <span>&lt;=</span> <span>&#39;z&#39;</span> <span>||</span> <span>&#39;A&#39;</span> <span>&lt;=</span> <span>x</span> <span>&amp;&amp;</span> <span>x</span> <span>&lt;=</span> <span>&#39;Z&#39;</span> <span>{</span>
</span></span><span><span>	<span>...</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>This however becomes slower the more tokens you are searching for since for a ‘B’ all the checks will need to be done.</p><h3 id="lookup-tables">Lookup Tables</h3><p>A lookup table is a very simple way to speed up the code we can just precompute the result for all ascii characters.
<img src="https://blog.smidt.dev/posts/0004/array-lookup.svg" loading="lazy" alt="Lookup table"/></p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span></code></pre></td><td><pre tabindex="0"><code data-lang="go"><span><span><span>// using an 256 sized array to remove bound checks.
</span></span></span><span><span><span></span><span>var</span> <span>identifier</span> <span>[</span><span>256</span><span>]</span><span>bool</span>
</span></span><span><span><span>init</span> <span>{</span>
</span></span><span><span>	<span>// populate the identifier
</span></span></span><span><span><span></span>	<span>for</span> <span>x</span> <span>:=</span> <span>range</span> <span>256</span> <span>{</span>
</span></span><span><span>		<span>if</span> <span>&#39;0&#39;</span> <span>&lt;=</span> <span>x</span> <span>&amp;&amp;</span> <span>x</span> <span>&lt;=</span> <span>&#39;9&#39;</span> <span>||</span> <span>&#39;a&#39;</span> <span>&lt;=</span> <span>x</span> <span>&amp;&amp;</span> <span>x</span> <span>&lt;=</span> <span>&#39;z&#39;</span> <span>||</span> <span>&#39;A&#39;</span> <span>&lt;=</span> <span>x</span> <span>&amp;&amp;</span> <span>x</span> <span>&lt;=</span> <span>&#39;Z&#39;</span> <span>{</span>
</span></span><span><span>			<span>identifier</span><span>[</span><span>x</span><span>]</span> <span>=</span> <span>true</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>isIdentifier</span> <span>(</span><span>x</span> <span>uint8</span><span>)</span> <span>bool</span><span>{</span>
</span></span><span><span>  <span>return</span> <span>identifier</span><span>[</span><span>x</span><span>]</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h3 id="bitvectors">bitvectors</h3><p>Bit vectors compress the state representation by mapping each ASCII character to a bit. This reduces memory usage while still allowing efficient lookups.</p><p><img src="https://blog.smidt.dev/posts/0004/bitvector.svg" loading="lazy" alt="bit vector"/></p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span></code></pre></td><td><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>AsciiVector</span> <span>[</span><span>4</span><span>]</span><span>uint64</span>
</span></span><span><span>
</span></span><span><span><span>const</span> <span>mask</span> <span>=</span> <span>64</span> <span>-</span> <span>1</span>
</span></span><span><span>
</span></span><span><span><span>// Set ith bit
</span></span></span><span><span><span></span><span>func</span> <span>(</span><span>bv</span> <span>*</span><span>AsciiVector</span><span>)</span> <span>Set</span><span>(</span><span>i</span> <span>uint8</span><span>)</span> <span>{</span>
</span></span><span><span>	<span>idx</span> <span>:=</span> <span>i</span> <span>&gt;&gt;</span> <span>6</span>
</span></span><span><span>	<span>bv</span><span>[</span><span>idx</span><span>]</span> <span>|=</span> <span>1</span> <span>&lt;&lt;</span> <span>(</span><span>i</span> <span>&amp;</span> <span>mask</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>bv</span> <span>AsciiVector</span><span>)</span> <span>Get</span><span>(</span><span>i</span> <span>uint8</span><span>)</span> <span>bool</span> <span>{</span>
</span></span><span><span>	<span>idx</span> <span>:=</span> <span>i</span> <span>&gt;&gt;</span> <span>6</span>
</span></span><span><span>	<span>bit</span> <span>:=</span> <span>i</span> <span>&amp;</span> <span>(</span><span>mask</span><span>)</span>
</span></span><span><span>	<span>return</span> <span>(</span><span>bv</span><span>[</span><span>idx</span><span>]</span> <span>&amp;</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>bit</span><span>))</span> <span>!=</span> <span>0</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h2 id="benchmark">benchmark</h2><p>To evaluate the performance of these methods, I benchmarked them on an AMD Ryzen 5 3600 6-Core Processor:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span></code></pre></td><td><pre tabindex="0"><code data-lang="fallback"><span><span>cpu: AMD Ryzen 5 3600 6-Core Processor              
</span></span><span><span>BenchmarkArrayIndex-12                     85222             12510 ns/op
</span></span><span><span>BenchmarkBranch-12                        325195              3767 ns/op
</span></span><span><span>BenchmarkAsciiVector-12                   422432              2910 ns/op
</span></span><span><span>BenchmarkWillfLibBitvector-12             449012              2597 ns/op
</span></span><span><span>BenchmarkLookup-12                        479762              2370 ns/op
</span></span></code></pre></td></tr></tbody></table></div></div><p>The code is available here <a href="https://github.com/borissmidt/smidt-blog-examples/0004" target="_blank" rel="noopener">https://github.com/borissmidt/smidt-blog-examples/0004</a>.</p><h2 id="failed-attempts">Failed Attempts</h2><h3 id="naive-simd">’naive’ simd</h3><p>X86 processors have 128 bit MMX registers and 256bit MMY registers, the latest processors even have 512 bit registers.
There is a VTEST instruction which test if a mask matches the bit flag. But sadly x86 is missing an instruction to shift the register beyond 64 bits.
Also x86 can be quite hard you can not set a value directly to an MMX register, you first have to load the constant in an GP64 register to then load it to an MMX register.
(asm source)[https://github.com/borissmidt/smidt-blog-examples/0004/asm/simd_bitset_asm.go]</p><p>Since go doesn’t inline assembly i decided to include the search loop into the assembly itself and to return the index of the non matching character.
Sadly i didn’t get it to work fully because i’m missing tools to actually debug the assembly itself.</p><h3 id="zig">zig</h3><p>Here’s my working example in Zig. Since zig has arbitrary sized integer types it was trivial to implement the bitvector.
But sadly it didn’t use any SIMD registers.
To see the compiler output you can copy the code below and open it in <a href="https://zig.godbolt.org/" target="_blank" rel="noopener">godbolt</a>.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span></code></pre></td><td><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span><span>std</span><span> </span><span>=</span><span> </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>!</span><span>void</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// Prints to stderr (it&#39;s a shortcut based on `std.io.getStdErr()`)
</span></span></span><span><span><span></span><span>    </span><span>var</span><span> </span><span>c</span><span> </span><span>:</span><span> </span><span>u7</span><span> </span><span>=</span><span> </span><span>&#39;A&#39;</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span><span>mask</span><span>:</span><span> </span><span>u128</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span><span>(</span><span>0</span><span>..</span><span>26</span><span>)</span><span> </span><span>|</span><span>_</span><span>|</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>var</span><span> </span><span>register</span><span>:</span><span> </span><span>u128</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>register</span><span> </span><span>=</span><span> </span><span>register</span><span> </span><span>&lt;&lt;</span><span> </span><span>c</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>mask</span><span> </span><span>|=</span><span> </span><span>register</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>c</span><span>+=</span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>for</span><span> </span><span>(</span><span>0</span><span>..</span><span>127</span><span>)</span><span> </span><span>|</span><span>v</span><span> </span><span>|</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>c</span><span> </span><span>=</span><span> </span><span>@intCast</span><span>(</span><span> </span><span>v</span><span>);</span><span>
</span></span></span><span><span><span>        </span><span>var</span><span> </span><span>register</span><span>:</span><span> </span><span>u128</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>register</span><span> </span><span>=</span><span> </span><span>register</span><span> </span><span>&lt;&lt;</span><span> </span><span>c</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>register</span><span> </span><span>&amp;=</span><span> </span><span>mask</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span><span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;is this true? {} {}</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>.{</span><span>c</span><span>,</span><span> </span><span>register</span><span> </span><span>!=</span><span> </span><span>0</span><span>});</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></td></tr></tbody></table></div></div><h2 id="conclusion">conclusion</h2><p>Following a book like “Writing an Interpreter in Go” is an enjoyable way to dive into low-level programming.
The bit vector approach offers a compelling middle ground, and for bigger sets it is for sure a useful tool.</p><p>It was an interesting experience write my own assembly and use it a program. Its nice to see that with go its pretty easy to include assembly in the code.</p><p>While the idea of leveraging SIMD turned out to be overly ambitious, it was a fascinating challenge that highlighted just how niche this domain is.
Although I didn’t achieve my initial goals, I took my baby steps in assembly and the nuances of performance optimization.</p><h2 id="references">references</h2><p>Later on i discovered this post, which goes deeper into simd processing and how it is best to normalize characters first with a ‘perfect hash’:</p><ul><li><a href="https://mcyoung.xyz/2023/11/27/simd-base64/" target="_blank" rel="noopener">https://mcyoung.xyz/2023/11/27/simd-base64/</a></li></ul><p>More resources:</p><ul><li><a href="https://github.com/awesome-simd/awesome-simd" target="_blank" rel="noopener">https://github.com/awesome-simd/awesome-simd</a> awesome github lists are always a good start for these kind of things.</li><li><a href="https://github.com/mmcloughlin/avo" target="_blank" rel="noopener">https://github.com/mmcloughlin/avo</a> i used this to write assembly for go.</li><li><a href="https://godbolt.org/" target="_blank" rel="noopener">https://godbolt.org/</a> useful to investigate what the compiler generates, i used this to check the 128 bit integers of zig.</li><li><a href="https://www.felixcloutier.com/x86/" target="_blank" rel="noopener">https://www.felixcloutier.com/x86/</a> to see the x86 assembly</li><li><a href="https://branchfree.org/" target="_blank" rel="noopener">https://branchfree.org/</a> :
The creator of simd json. Because the writers audience are other simd developers he expects you to know the subject quite deeply.
So whenever he states an x86 simd instruction but the ‘alphabet soup’ named <a href="https://www.felixcloutier.com/x86/pclmulqdq" target="_blank" rel="noopener">PCLMULQDQ</a> doesn’t really make it clear what its used for.</li></ul><p><a href="https://branchfree.org/2024/06/09/a-draft-taxonomy-of-simd-usage/" target="_blank" rel="noopener">https://branchfree.org/2024/06/09/a-draft-taxonomy-of-simd-usage/</a></p><p>git repo:</p><ul><li><a href="https://github.com/borissmidt/smidt-blog-examples/bitvectors" target="_blank" rel="noopener">https://github.com/borissmidt/smidt-blog-examples/bitvectors</a></li></ul></section></div>
  </body>
</html>
