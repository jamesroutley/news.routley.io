<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.danielh.cc/blog/path">Original</a>
    <h1>Path Isn&#39;t Real on Linux</h1>
    
    <div id="readability-page-1" class="page"><div data-v-39a288b8=""><div data-v-39a288b8=""><div><p>On a fresh installation of Debian 12 (bookworm), executing <code>echo $PATH</code> shows the following output:</p><div><pre tabindex="0"><code><span><span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span></code></pre></div><p><code>/usr/bin</code> contains <code>/usr/bin/cat</code>, and <code>/usr/bin</code> is in <code>PATH</code>, so just typing <code>cat</code> will run <code>/usr/bin/cat</code>. But what exactly is doing this lookup?</p><p>By running <code>strace cat</code>, you can see the Linux system calls that are used:</p><div><p><span>c</span></p><pre tabindex="0"><code><span><span>execve</span><span>(</span><span>&#34;/usr/bin/cat&#34;</span><span>, [</span><span>&#34;cat&#34;</span><span>], </span><span>0x</span><span>7ffdfb2367a0</span><span> /* 63 vars */</span><span>) </span><span>=</span><span> 0</span></span></code></pre></div><p>The Linux kernel already has the full path (<code>/usr/bin/cat</code>), so where is <code>/usr/bin</code> coming from?</p><h2 id="reading-the-source" tabindex="-1">Reading the source <a href="#reading-the-source" aria-label="Permalink to &#34;Reading the source&#34;">​</a></h2><p>On Debian, shell scripts using <code>/bin/sh</code> use <a href="http://gondor.apana.org.au/~herbert/dash/" target="_blank" rel="noreferrer">dash</a>, which is responsible for interpreting and executing commands. Digging into <code>main.c</code> which contains the entry point:</p><div><p><span>c</span></p><pre tabindex="0"><code><span><span>/*</span></span>
<span><span> * Main routine.  We initialize things, parse the arguments, execute</span></span>
<span><span> * profiles if we&#39;re a login shell, and then call cmdloop to execute</span></span>
<span><span> * commands.  The setjmp call sets up the location to jump to when an</span></span>
<span><span> * exception occurs.  When an exception occurs the variable &#34;state&#34;</span></span>
<span><span> * is used to figure out how far we had gotten.</span></span>
<span><span> */</span></span>
<span></span>
<span><span>// ...</span></span>
<span></span>
<span><span>static</span><span> int</span></span>
<span><span>cmdloop</span><span>(</span><span>int</span><span> top</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    // ...</span></span>
<span><span>    for</span><span> (;;) {</span></span>
<span><span>        // ...</span></span>
<span><span>        n </span><span>=</span><span> parsecmd</span><span>(inter);</span></span>
<span><span>        // ...</span></span>
<span><span>        i </span><span>=</span><span> evaltree</span><span>(n, </span><span>0</span><span>);</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre></div><p><code>evaltree</code> in <code>eval.c</code> is responsible for executing commands:</p><div><p><span>c</span></p><pre tabindex="0"><code><span><span>int</span></span>
<span><span>evaltree</span><span>(</span><span>union</span><span> node </span><span>*</span><span>n</span><span>, </span><span>int</span><span> flags</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    // ...</span></span>
<span><span>    case NCMD:</span></span>
<span><span>    		evalfn </span><span>=</span><span> evalcommand;</span></span>
<span><span>checkexit:</span></span>
<span><span>    		checkexit </span><span>=</span><span> EV_TESTED;</span></span>
<span><span>    		goto</span><span> calleval;</span></span>
<span><span>    // ...</span></span>
<span><span>calleval:</span></span>
<span><span>    		status </span><span>=</span><span> evalfn</span><span>(n, flags);</span></span>
<span><span>    		break</span><span>;</span></span></code></pre></div><p>Then, <code>evalcommand</code> is used as the final step when the command is just executing a program:</p><div><p><span>c</span></p><pre tabindex="0"><code><span><span>STATIC </span><span>int</span></span>
<span><span>// ...</span></span>
<span><span>evalcommand</span><span>(</span><span>union</span><span> node </span><span>*</span><span>cmd</span><span>, </span><span>int</span><span> flags</span><span>, </span><span>struct</span><span> backcmd </span><span>*</span><span>backcmd</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    // ...</span></span>
<span><span>    default:</span></span>
<span><span>    		flush_input</span><span>();</span></span>
<span></span>
<span><span>    		/* Fork off a child process if necessary. */</span></span>
<span><span>    		if</span><span> (</span><span>!</span><span>(flags </span><span>&amp;</span><span> EV_EXIT) </span><span>||</span><span> have_traps</span><span>()) {</span></span>
<span><span>    			INTOFF;</span></span>
<span><span>    			jp </span><span>=</span><span> vforkexec</span><span>(cmd, argv, path, cmdentry.u.index);</span></span>
<span><span>    			break</span><span>;</span></span>
<span><span>    		}</span></span>
<span><span>    		shellexec</span><span>(argv, path, cmdentry.u.index);</span></span>
<span><span>    // ...</span></span>
<span><span>}</span></span></code></pre></div><p><code>shellexec</code> in <code>exec.c</code> calls <code>padvance</code>:</p><div><p><span>c</span></p><pre tabindex="0"><code><span><span>void</span></span>
<span><span>shellexec</span><span>(</span><span>char</span><span> **</span><span>argv</span><span>, </span><span>const</span><span> char</span><span> *</span><span>path</span><span>, </span><span>int</span><span> idx</span><span>)</span></span>
<span><span>{</span></span>
<span><span>    // ...</span></span>
<span><span>    while</span><span> (</span><span>padvance</span><span>(</span><span>&amp;</span><span>path, </span><span>argv</span><span>[</span><span>0</span><span>]) </span><span>&gt;=</span><span> 0</span><span>) {</span></span>
<span><span>			cmdname </span><span>=</span><span> stackblock</span><span>();</span></span>
<span><span>			if</span><span> (</span><span>--</span><span>idx </span><span>&lt;</span><span> 0</span><span> &amp;&amp;</span><span> pathopt </span><span>==</span><span> NULL</span><span>) {</span></span>
<span><span>				tryexec</span><span>(cmdname, argv, envp);</span></span>
<span><span>				if</span><span> (errno </span><span>!=</span><span> ENOENT </span><span>&amp;&amp;</span><span> errno </span><span>!=</span><span> ENOTDIR)</span></span>
<span><span>					e </span><span>=</span><span> errno;</span></span>
<span><span>			}</span></span>
<span><span>		}</span></span>
<span><span>    // ...</span></span>
<span><span>}</span></span></code></pre></div><p>But what is <code>padvance</code>? Looking further into <code>exec.c</code>:</p><div><p><span>c</span></p><pre tabindex="0"><code><span><span>/*</span></span>
<span><span> * Do a path search.  The variable path (passed by reference) should be</span></span>
<span><span> * set to the start of the path before the first call; padvance will update</span></span>
<span><span> * this value as it proceeds.  Successive calls to padvance will return</span></span>
<span><span> * the possible path expansions in sequence.  If an option (indicated by</span></span>
<span><span> * a percent sign) appears in the path entry then the global variable</span></span>
<span><span> * pathopt will be set to point to it; otherwise pathopt will be set to</span></span>
<span><span> * NULL.</span></span>
<span><span> *</span></span>
<span><span> * If magic is 0 then pathopt recognition will be disabled.  If magic is</span></span>
<span><span> * 1 we shall recognise %builtin/%func.  Otherwise we shall accept any</span></span>
<span><span> * pathopt.</span></span>
<span><span> */</span></span>
<span></span>
<span><span>const</span><span> char</span><span> *</span><span>pathopt;</span></span>
<span></span>
<span><span>int</span><span> padvance_magic</span><span>(</span><span>const</span><span> char</span><span> **</span><span>path</span><span>, </span><span>const</span><span> char</span><span> *</span><span>name</span><span>, </span><span>int</span><span> magic</span><span>)</span></span>
<span><span>{</span></span></code></pre></div><p>The shell, not the Linux kernel, is responsible for searching for executables in <code>PATH</code>!</p><h2 id="what-about-other-code" tabindex="-1">What about other code? <a href="#what-about-other-code" aria-label="Permalink to &#34;What about other code?&#34;">​</a></h2><p>Python&#39;s <code>subprocess</code> can be used like this:</p><div><p><span>python</span></p><pre tabindex="0"><code><span><span>subprocess.run([</span><span>&#34;ls&#34;</span><span>, </span><span>&#34;-l&#34;</span><span>])</span></span></code></pre></div><p>This calls <code>/usr/bin/ls</code> since <code>/usr/bin</code> is in <code>PATH</code>. But who&#39;s doing the path lookup?</p><p>CPython contains the following code for <code>subprocess</code>:</p><div><p><span>python</span></p><pre tabindex="0"><code><span><span># This matches the behavior of os._execvpe().</span></span>
<span><span>executable_list </span><span>=</span><span> tuple</span><span>(</span></span>
<span><span>    os.path.join(os.fsencode(</span><span>dir</span><span>), executable)</span></span>
<span><span>    for</span><span> dir</span><span> in</span><span> os.get_exec_path(env))</span></span></code></pre></div><p>which searches <code>PATH</code> directly in Python before calling out to Linux&#39;s <code>execve</code>.</p><p>Go is similar — <code>lp_unix.go</code> contains it&#39;s own implementation to search in <code>PATH</code>:</p><div><p><span>go</span></p><pre tabindex="0"><code><span><span>// LookPath searches for an executable named file in the</span></span>
<span><span>// directories named by the PATH environment variable.</span></span>
<span><span>// If file contains a slash, it is tried directly and the PATH is not consulted.</span></span>
<span><span>// Otherwise, on success, the result is an absolute path.</span></span>
<span><span>//</span></span>
<span><span>// In older versions of Go, LookPath could return a path relative to the current directory.</span></span>
<span><span>// As of Go 1.19, LookPath will instead return that path along with an error satisfying</span></span>
<span><span>// [errors.Is](err, [ErrDot]). See the package documentation for more details.</span></span>
<span><span>func</span><span> LookPath</span><span>(</span><span>file</span><span> string</span><span>) (</span><span>string</span><span>, </span><span>error</span><span>) {</span></span></code></pre></div><p>Rust&#39;s <code>Command::spawn</code> eventually calls <code>libc::execvp</code>, which searches <code>PATH</code>:</p><div><p><span>c</span></p><pre tabindex="0"><code><span><span>/* Execute FILE, searching in the `PATH&#39; environment variable if it contains</span></span>
<span><span>   no slashes, with arguments ARGV and environment from `environ&#39;.  */</span></span>
<span><span>int</span></span>
<span><span>execvp</span><span> (file, argv)</span></span>
<span><span>     const</span><span> char</span><span> *</span><span>file;</span></span>
<span><span>     char</span><span> *const</span><span> argv</span><span>[]</span><span>;</span></span>
<span><span>{</span></span></code></pre></div><p>In fact, Linux doesn&#39;t know about <code>PATH</code> at all! Specifying a program in an executable text file using a <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)" target="_blank" rel="noreferrer">shebang</a> requires an absolute path:</p><p>works, but</p><p>doesn&#39;t. This is also the reason many programs use this trick:</p><div><p><span>py</span></p><pre tabindex="0"><code><span><span>#!/usr/bin/env python</span></span>
<span><span>print</span><span>(</span><span>&#39;Hello world&#39;</span><span>)</span></span></code></pre></div><p>since <code>/usr/bin/env</code> calls <code>execvp</code>, which will search <code>PATH</code>.</p></div></div></div></div>
  </body>
</html>
