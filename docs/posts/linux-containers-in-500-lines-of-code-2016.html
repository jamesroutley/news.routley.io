<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.lizzie.io/linux-containers-in-500-loc.html">Original</a>
    <h1>Linux containers in 500 lines of code (2016)</h1>
    
    <div id="readability-page-1" class="page"><div id="content">


<p>
I&#39;ve used Linux containers <a href="https://circleci.com">directly</a> and <a href="https://chromium.googlesource.com/chromium/src/%2B/master/docs/linux_sandboxing.md">indirectly</a> for years, but I
wanted to become more familiar with them. So I wrote some code. This
used to be 500 lines of code, I swear, but I&#39;ve revised it some since
publishing; I&#39;ve ended up with about 70 lines more.
</p>

<p>
I wanted specifically to find a minimal set of restrictions to run
untrusted code. This isn&#39;t how you should approach containers on
anything with any exposure: you should restrict everything you
can. But I think it&#39;s important to know which permissions are
categorically unsafe! I&#39;ve tried to back up things I&#39;m saying with
links to code or people I trust, but <a href="mailto:_@lizzie.io">I&#39;d love to know if I missed
anything.</a>
</p>

<p>
This is a <a href="https://www.cs.tufts.edu/~nr/noweb/"><code>noweb</code></a>-style piece of literate code. References named
<code>&lt;&lt;x&gt;&gt;</code> will be expanded to the code block named <code>x</code>. You can find the
tangled source <a href="https://blog.lizzie.io/linux-containers-in-500-loc/contained.c">here</a>. This document is an <a href="http://orgmode.org/">orgmode</a> document, you can
find its source <a href="https://blog.lizzie.io/linux-containers-in-500-loc.org">here</a>. This document and this code are licensed under
the GPLv3; you can find its source <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">here</a>.
</p>

<div id="outline-container-orgba868eb">
<h2 id="orgba868eb">Container setup</h2>
<div id="text-orgba868eb">
<p>
There are several complementary and overlapping mechanisms that make
up modern Linux containers. Roughly,
</p>

<ul>
<li><code>namespaces</code> are used to group kernel objects into different sets
that can be accessed by specific process trees. For example, pid
namespaces limit the view of the process list to the processes
within the namespace. There are a couple of different kind of
namespaces. I&#39;ll go into this more later.</li>
<li><code>capabilities</code> are used here to set some coarse limits on what uid 0
can do.</li>
<li><code>cgroups</code> is a mechanism to limit usage of resources like memory,
disk io, and cpu-time.</li>
<li><code>setrlimit</code> is another mechanism for limiting resource usage. It&#39;s
older than cgroups, but can do some things cgroups can&#39;t.</li>
</ul>

<p>
These are all Linux kernel mechanisms. Seccomp, capabilities, and
<code>setrlimit</code> are all done with system calls. <code>cgroups</code> is accessed
through a filesystem.
</p>

<p>
There&#39;s a lot here, and the scope of each mechanism is pretty
unclear. They overlap a lot and it&#39;s tricky to find the best way to
limit things. User namespaces are somewhat new, and promise to unify a
lot of this behavior. But unfortunately compiling the kernel with user
namespaces enabled complicates things. Compiling with user namespaces changes the
semantics of capabilities system-wide, which could cause more problems
or at least confusion<sup><a id="fnr.1" href="#fn.1">1</a></sup>. There have been a
large number of privilege-escalation bugs exposed by user
namespaces. <a href="https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-1-1.pdf">&#34;Understanding and Hardening Linux Containers&#34;</a> explains
</p>

<blockquote>
<p>
Despite the large upsides the user namespace provides in terms of
security, due to the sensitive nature of the user namespace,
somewhat conflicting security models and large amount of new code,
several serious vulnerabilities have been discovered and new
vulnerabilities have unfortunately continued to be discovered.
These deal with both the implementation of user namespaces itself or
allow the illegitimate or unintended use of the user namespace to
perform a privilege escalation. Often these issues present
themselves on systems where containers are not being used, and where
the kernel version is recent enough to support user namespaces.
</p>
</blockquote>

<p>
It&#39;s turned off by default in Linux at the time of this
writing<sup><a id="fnr.2" href="#fn.2">2</a></sup>, but many distributions apply patches
to turn it on in a limited way<sup><a id="fnr.3" href="#fn.3">3</a></sup>.
</p>


<p>
But all of these issues apply to hosts with user namespaces compiled
in; it doesn&#39;t really matter whether we use user namespaces or not,
especially since I&#39;ll be preventing nested user namespaces. So I&#39;ll
only use a user namespace if they&#39;re available.
</p>

<p>
(The user-namespace handling in this code was originally pretty
broken. Jann Horn in particular gave great feedback. Thanks!)
</p>
</div>
</div>

<div id="outline-container-org39f5223">
<h2 id="org39f5223"><code>contained.c</code></h2>
<div id="text-org39f5223">
<p>
This program can be used like this, to run <code>/misc/img/bin/sh</code> in
<code>/misc/img</code> as <code>root</code>:
</p>

<pre id="org8739f7e">[lizzie@empress l-c-i-500-l]$ sudo ./contained -m ~/misc/busybox-img/ -u 0 -c /bin/sh
=&gt; validating Linux version...4.7.10.201610222037-1-grsec on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.oQ5jOY...done.
=&gt; trying a user namespace...writing /proc/32627/uid_map...writing /proc/32627/gid_map...done.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
/ # whoami
root
/ # hostname
05fe5c-three-of-pentacles
/ # exit
=&gt; cleaning cgroups...done.
</pre>

<p>
So, a skeleton for it:
</p>

<div>
<p><label><span>Listing 7: </span><code>contained.c</code></label></p><pre>/* -*- compile-command: &#34;gcc -Wall -Werror -lcap -lseccomp contained.c -o contained&#34; -*- */
/* This code is licensed under the GPLv3. You can find its text here:
   https://www.gnu.org/licenses/gpl-3.0.en.html */


#define _GNU_SOURCE
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;grp.h&gt;
#include &lt;pwd.h&gt;
#include &lt;sched.h&gt;
#include &lt;seccomp.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/capability.h&gt;
#include &lt;sys/mount.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/utsname.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;linux/capability.h&gt;
#include &lt;linux/limits.h&gt;

struct child_config {
	int argc;
	uid_t uid;
	int fd;
	char *hostname;
	char **argv;
	char *mount_dir;
};

&lt;&lt;capabilities&gt;&gt;

&lt;&lt;mounts&gt;&gt;

&lt;&lt;syscalls&gt;&gt;

&lt;&lt;resources&gt;&gt;

&lt;&lt;child&gt;&gt;

&lt;&lt;choose-hostname&gt;&gt;

int main (int argc, char **argv)
{
	struct child_config config = {0};
	int err = 0;
	int option = 0;
	int sockets[2] = {0};
	pid_t child_pid = 0;
	int last_optind = 0;
	while ((option = getopt(argc, argv, &#34;c:m:u:&#34;))) {
		switch (option) {
		case &#39;c&#39;:
			config.argc = argc - last_optind - 1;
			config.argv = &amp;argv[argc - config.argc];
			goto finish_options;
		case &#39;m&#39;:
			config.mount_dir = optarg;
			break;
		case &#39;u&#39;:
			if (sscanf(optarg, &#34;%d&#34;, &amp;config.uid) != 1) {
				fprintf(stderr, &#34;badly-formatted uid: %s\n&#34;, optarg);
				goto usage;
			}
			break;
		default:
			goto usage;
		}
		last_optind = optind;
	}
finish_options:
	if (!config.argc) goto usage;
	if (!config.mount_dir) goto usage;

&lt;&lt;check-linux-version&gt;&gt;

	char hostname[256] = {0};
	if (choose_hostname(hostname, sizeof(hostname)))
		goto error;
	config.hostname = hostname;

&lt;&lt;namespaces&gt;&gt;

	goto cleanup;
usage:
	fprintf(stderr, &#34;Usage: %s -u -1 -m . -c /bin/sh ~\n&#34;, argv[0]);
error:
	err = 1;
cleanup:
	if (sockets[0]) close(sockets[0]);
	if (sockets[1]) close(sockets[1]);
	return err;
}
</pre>
</div>

<p>
Since I&#39;ll be blacklisting system calls and capabilities, it&#39;s
important to make sure there aren&#39;t any new ones.
</p>

<div>
<p><label><span>Listing 8: </span><code>&lt;&lt;check-linux-version&gt;&gt;</code> =</label></p><pre>	fprintf(stderr, &#34;=&gt; validating Linux version...&#34;);
	struct utsname host = {0};
	if (uname(&amp;host)) {
		fprintf(stderr, &#34;failed: %m\n&#34;);
		goto cleanup;
	}
	int major = -1;
	int minor = -1;
	if (sscanf(host.release, &#34;%u.%u.&#34;, &amp;major, &amp;minor) != 2) {
		fprintf(stderr, &#34;weird release format: %s\n&#34;, host.release);
		goto cleanup;
	}
	if (major != 4 || (minor != 7 &amp;&amp; minor != 8)) {
		fprintf(stderr, &#34;expected 4.7.x or 4.8.x: %s\n&#34;, host.release);
		goto cleanup;
	}
	if (strcmp(&#34;x86_64&#34;, host.machine)) {
		fprintf(stderr, &#34;expected x86_64: %s\n&#34;, host.machine);
		goto cleanup;
	}
	fprintf(stderr, &#34;%s on %s.\n&#34;, host.release, host.machine);
</pre>
</div>

<p>
(This had a bug. <a href="https://www.reddit.com/r/programming/comments/57x26h/linux_containers_in_500_lines_of_code/d8w07vf?context%3D3">captainjey on reddit let me know. Thanks!</a>)
</p>

<p>
And I wasn&#39;t quite at 500 lines of code, so I thought I had some
space to build nice hostnames.
</p>

<div>
<p><label><span>Listing 9: </span><code>&lt;&lt;choose-hostname&gt;&gt;</code> =</label></p><pre>int choose_hostname(char *buff, size_t len)
{
	static const char *suits[] = { &#34;swords&#34;, &#34;wands&#34;, &#34;pentacles&#34;, &#34;cups&#34; };
	static const char *minor[] = {
		&#34;ace&#34;, &#34;two&#34;, &#34;three&#34;, &#34;four&#34;, &#34;five&#34;, &#34;six&#34;, &#34;seven&#34;, &#34;eight&#34;,
		&#34;nine&#34;, &#34;ten&#34;, &#34;page&#34;, &#34;knight&#34;, &#34;queen&#34;, &#34;king&#34;
	};
	static const char *major[] = {
		&#34;fool&#34;, &#34;magician&#34;, &#34;high-priestess&#34;, &#34;empress&#34;, &#34;emperor&#34;,
		&#34;hierophant&#34;, &#34;lovers&#34;, &#34;chariot&#34;, &#34;strength&#34;, &#34;hermit&#34;,
		&#34;wheel&#34;, &#34;justice&#34;, &#34;hanged-man&#34;, &#34;death&#34;, &#34;temperance&#34;,
		&#34;devil&#34;, &#34;tower&#34;, &#34;star&#34;, &#34;moon&#34;, &#34;sun&#34;, &#34;judgment&#34;, &#34;world&#34;
	};
	struct timespec now = {0};
	clock_gettime(CLOCK_MONOTONIC, &amp;now);
	size_t ix = now.tv_nsec % 78;
	if (ix &lt; sizeof(major) / sizeof(*major)) {
		snprintf(buff, len, &#34;%05lx-%s&#34;, now.tv_sec, major[ix]);
	} else {
		ix -= sizeof(major) / sizeof(*major);
		snprintf(buff, len,
			 &#34;%05lxc-%s-of-%s&#34;,
			 now.tv_sec,
			 minor[ix % (sizeof(minor) / sizeof(*minor))],
			 suits[ix / (sizeof(minor) / sizeof(*minor))]);
	}
	return 0;
}
</pre>
</div>
</div>


<div id="outline-container-org0aee542">
<h3 id="org0aee542">Namespaces</h3>
<div id="text-org0aee542">
<p>
<code>clone</code> is the system call behind <code>fork()</code> et al. It&#39;s also the key to
all of this. Conceptually we want to create a process with different
properties than its parent: it should be able to mount a different
<code>/</code>, set its own hostname, and do other things. We&#39;ll specify all of
this by passing flags to <code>clone</code> <sup><a id="fnr.4" href="#fn.4">4</a></sup>.
</p>

<p>
The child needs to send some messages to the parent, so we&#39;ll
initialize a socketpair, and then make sure the child only receives
access to one.
</p>

<div>
<p><label><span>Listing 10: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label></p><pre>	if (socketpair(AF_LOCAL, SOCK_SEQPACKET, 0, sockets)) {
		fprintf(stderr, &#34;socketpair failed: %m\n&#34;);
		goto error;
	}
	if (fcntl(sockets[0], F_SETFD, FD_CLOEXEC)) {
		fprintf(stderr, &#34;fcntl failed: %m\n&#34;);
		goto error;
	}
	config.fd = sockets[1];
</pre>
</div>

<p>
But first we need to set up room for a stack. We&#39;ll <code>execve</code> later,
which will actually set up the stack again, so this is only
temporary.<sup><a id="fnr.5" href="#fn.5">5</a></sup>
</p>

<div>
<p><label><span>Listing 13: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label></p><pre>	#define STACK_SIZE (1024 * 1024)

	char *stack = 0;
	if (!(stack = malloc(STACK_SIZE))) {
		fprintf(stderr, &#34;=&gt; malloc failed, out of memory?\n&#34;);
		goto error;
	}
</pre>
</div>

<p>
We&#39;ll also prepare the cgroup for this process tree. More on this later.
</p>

<div>
<p><label><span>Listing 14: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label></p><pre>	if (resources(&amp;config)) {
		err = 1;
		goto clear_resources;
	}
</pre>
</div>

<p>
We&#39;ll namespace the mounts, pids, IPC data structures, network
devices, and hostname / domain name. I&#39;ll go into these more in the
code for capabilities, cgroups, and syscalls.
</p>

<div>
<p><label><span>Listing 15: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label></p><pre>	int flags = CLONE_NEWNS
		| CLONE_NEWCGROUP
		| CLONE_NEWPID
		| CLONE_NEWIPC
		| CLONE_NEWNET
		| CLONE_NEWUTS;
</pre>
</div>

<p>
Stacks on x86, and almost everything else Linux runs on, grow
downwards, so we&#39;ll add <code>STACK_SIZE</code> to get a pointer just below the
end.<sup><a id="fnr.6" href="#fn.6">6</a></sup> We also <code>|</code> the flags with <code>SIGCHLD</code> so
that we can <code>wait</code> on it.
</p>

<div>
<p><label><span>Listing 16: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label></p><pre>	if ((child_pid = clone(child, stack + STACK_SIZE, flags | SIGCHLD, &amp;config)) == -1) {
		fprintf(stderr, &#34;=&gt; clone failed! %m\n&#34;);
		err = 1;
		goto clear_resources;
	}
</pre>
</div>

<p>
Close and zero the child&#39;s socket, so that if something breaks then we
don&#39;t leave an open fd, possibly causing the child to or the parent to
hang.
</p>

<div>
<p><label><span>Listing 17: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label></p><pre>	close(sockets[1]);
	sockets[1] = 0;
</pre>
</div>

<p>
The parent process will configure the child&#39;s user namespace and then
pause until the child process tree exits<sup><a id="fnr.7" href="#fn.7">7</a></sup>.
</p>

<div>
<p><label><span>Listing 21: </span><code>&lt;&lt;child&gt;&gt;</code> +=</label></p><pre>#define USERNS_OFFSET 10000
#define USERNS_COUNT 2000

int handle_child_uid_map (pid_t child_pid, int fd)
{
	int uid_map = 0;
	int has_userns = -1;
	if (read(fd, &amp;has_userns, sizeof(has_userns)) != sizeof(has_userns)) {
		fprintf(stderr, &#34;couldn&#39;t read from child!\n&#34;);
		return -1;
	}
	if (has_userns) {
		char path[PATH_MAX] = {0};
		for (char **file = (char *[]) { &#34;uid_map&#34;, &#34;gid_map&#34;, 0 }; *file; file++) {
			if (snprintf(path, sizeof(path), &#34;/proc/%d/%s&#34;, child_pid, *file)
			    &gt; sizeof(path)) {
				fprintf(stderr, &#34;snprintf too big? %m\n&#34;);
				return -1;
			}
			fprintf(stderr, &#34;writing %s...&#34;, path);
			if ((uid_map = open(path, O_WRONLY)) == -1) {
				fprintf(stderr, &#34;open failed: %m\n&#34;);
				return -1;
			}
			if (dprintf(uid_map, &#34;0 %d %d\n&#34;, USERNS_OFFSET, USERNS_COUNT) == -1) {
				fprintf(stderr, &#34;dprintf failed: %m\n&#34;);
				close(uid_map);
				return -1;
			}
			close(uid_map);
		}
	}
	if (write(fd, &amp; (int) { 0 }, sizeof(int)) != sizeof(int)) {
		fprintf(stderr, &#34;couldn&#39;t write: %m\n&#34;);
		return -1;
	}
	return 0;
}
</pre>
</div>

<p>
The child process  will send a message to the parent process about
whether it should set uid and gid mappings. If that works, it will
<code>setgroups</code>, <code>setresgid</code>, and <code>setresuid</code>. Both <code>setgroups</code> and
<code>setresgid</code> are necessary here since there are two separate group
mechanisms on Linux<sup><a id="fnr.9" href="#fn.9">9</a></sup>. I&#39;m also assuming here
that every uid has a corresponding gid, which is common but not
necessarily universal.
</p>

<div>
<p><label><span>Listing 23: </span><code>&lt;&lt;child&gt;&gt;</code> +=</label></p><pre>int userns(struct child_config *config)
{
	fprintf(stderr, &#34;=&gt; trying a user namespace...&#34;);
	int has_userns = !unshare(CLONE_NEWUSER);
	if (write(config-&gt;fd, &amp;has_userns, sizeof(has_userns)) != sizeof(has_userns)) {
		fprintf(stderr, &#34;couldn&#39;t write: %m\n&#34;);
		return -1;
	}
	int result = 0;
	if (read(config-&gt;fd, &amp;result, sizeof(result)) != sizeof(result)) {
		fprintf(stderr, &#34;couldn&#39;t read: %m\n&#34;);
		return -1;
	}
	if (result) return -1;
	if (has_userns) {
		fprintf(stderr, &#34;done.\n&#34;);
	} else {
		fprintf(stderr, &#34;unsupported? continuing.\n&#34;);
	}
	fprintf(stderr, &#34;=&gt; switching to uid %d / gid %d...&#34;, config-&gt;uid, config-&gt;uid);
	if (setgroups(1, &amp; (gid_t) { config-&gt;uid }) ||
	    setresgid(config-&gt;uid, config-&gt;uid, config-&gt;uid) ||
	    setresuid(config-&gt;uid, config-&gt;uid, config-&gt;uid)) {
		fprintf(stderr, &#34;%m\n&#34;);
		return -1;
	}
	fprintf(stderr, &#34;done.\n&#34;);
	return 0;
}
</pre>
</div>

<p>
And this is where the child process from <code>clone</code> will end up. We&#39;ll
perform all of our setup, switch users and groups, and then load the
executable. The order is important here: we can&#39;t change mounts
without certain capabilities, we can&#39;t <code>unshare</code> after we limit the
syscalls, etc.
</p>

<div>
<p><label><span>Listing 24: </span><code>&lt;&lt;child&gt;&gt;</code> +=</label></p><pre>int child(void *arg)
{
	struct child_config *config = arg;
	if (sethostname(config-&gt;hostname, strlen(config-&gt;hostname))
	    || mounts(config)
	    || userns(config)
	    || capabilities()
	    || syscalls()) {
		close(config-&gt;fd);
		return -1;
	}
	if (close(config-&gt;fd)) {
		fprintf(stderr, &#34;close failed: %m\n&#34;);
		return -1;
	}
	if (execve(config-&gt;argv[0], config-&gt;argv, NULL)) {
		fprintf(stderr, &#34;execve failed! %m.\n&#34;);
		return -1;
	}
	return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga723de6">
<h3 id="orga723de6">Capabilties</h3>
<div id="text-orga723de6">
<p>
<code>capabilities</code> subdivide the property of &#34;being root&#34; on Linux. It&#39;s
useful to compartmentalize privileges so that, for example a process
can allocate network devices (<code>CAP_NET_ADMIN</code>) but not read all files
(<code>CAP_DAC_OVERRIDE</code>). I&#39;ll use them here to drop the ones we don&#39;t
want.
</p>

<p>
But not all of &#34;being root&#34; is subvidivided into capabilities. For
example, writing to parts of procfs is allowed by root even after
having dropped capabilities<sup><a id="fnr.10" href="#fn.10">10</a></sup>. There are a lot of
things like this: this is part of why need other restrictions beside
capabilities.
</p>

<p>
It&#39;s also important to think about how we&#39;re dropping capabilities. <code>man 7
capabilities</code> has an algorithm for us:
</p>

<div>
<pre>	During  an   execve(2),  the   kernel  calculates   the  new
	capabilities of the process using the following algorithm:

	    P&#39;(ambient) = (file is privileged) ? 0 : P(ambient)

	    P&#39;(permitted) = (P(inheritable) &amp; F(inheritable)) |
					(F(permitted) &amp; cap_bset) | P&#39;(ambient)

	    P&#39;(effective) = F(effective) ? P&#39;(permitted) : P&#39;(ambient)

	    P&#39;(inheritable) = P(inheritable)    [i.e., unchanged]

	where:

	    P         denotes the  value of a thread  capability set
			    before the execve(2)

	    P&#39;        denotes the  value of a thread  capability set
			    after the execve(2)

	    F         denotes a file capability set

	    cap_bset  is the  value of  the capability  bounding set
			    (described below).
</pre>
</div>

<p>
We&#39;d like <code>P&#39;(ambient)</code> and <code>P(inheritable)</code> to be empty, and
<code>P&#39;(permitted)</code> and <code>P(effective)</code> to only include the capabilities
above. This is achievable by doing the following
</p>

<ul>
<li>Clearing our own inheritable set. This clears the ambient set; <code>man
  7 capabilities</code> says &#34;The ambient capability set obeys the invariant
that no capability can ever be ambient if it is not both permitted
and inheritable.&#34; This also clears the child&#39;s inheritable set.</li>
<li>Clearing the bounding set. This limits the file capabilities we&#39;ll
gain when we <code>execve</code>, and the rest are limited by clearing the
inheritable and ambient sets.</li>
</ul>

<p>
If we were to only drop our own effective, permitted and inheritable
sets, we&#39;d regain the permissions in the child file&#39;s capabilities.
This is how <code>bash</code> can call <code>ping</code>, for example.<sup><a id="fnr.11" href="#fn.11">11</a></sup>
</p>
</div>


<div id="outline-container-org07e738c">
<h4 id="org07e738c">Dropped capabilities</h4>
<div id="text-org07e738c">
<div>
<p><label><span>Listing 29: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>int capabilities()
{
	fprintf(stderr, &#34;=&gt; dropping capabilities...&#34;);
</pre>
</div>

<p>
<code>CAP_AUDIT_CONTROL</code>, <code>_READ</code>, and <code>_WRITE</code> allow access to the audit
system of the kernel (i.e. functions like <code>audit_set_enabled</code>, usually
used with <code>auditctl</code>). The kernel prevents messages that normally
require <code>CAP_AUDIT_CONTROL</code> outside of the first pid namespace, but it
does allow messages that would require <code>CAP_AUDIT_READ</code> and
<code>CAP_AUDIT_WRITE</code> from any namespace.<sup><a id="fnr.12" href="#fn.12">12</a></sup> So
let&#39;s drop them all. We especially want to drop <code>CAP_AUDIT_READ</code>,
since it isn&#39;t namespaced<sup><a id="fnr.13" href="#fn.13">13</a></sup> and may contain important
information, but <code>CAP_AUDIT_WRITE</code> may also allow the contained
process to falsify logs or DOS the audit system.
</p>

<div>
<p><label><span>Listing 32: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>	int drop_caps[] = {
		CAP_AUDIT_CONTROL,
		CAP_AUDIT_READ,
		CAP_AUDIT_WRITE,
</pre>
</div>

<p>
<code>CAP_BLOCK_SUSPEND</code> lets programs prevent the system from suspending,
either with <code>EPOLLWAKEUP</code> or
/proc/sys/wake_lock.<sup><a id="fnr.14" href="#fn.14">14</a></sup> Supend isn&#39;t namespaced, so
we&#39;d like to prevent this.
</p>

<div>
<p><label><span>Listing 34: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_BLOCK_SUSPEND,
</pre>
</div>

<p>
<code>CAP_DAC_READ_SEARCH</code> lets programs call <code>open_by_handle_at</code> with an
arbitrary <code>struct file_handle *</code>. <code>struct file_handle</code> is in theory an
opaque type, but in practice it corresponds to inode numbers. So it&#39;s
easy to brute-force them, and read arbitrary files. This was used by
Sebastian Krahmer to write a program to read arbitrary system files
from within Docker in 2014.<sup><a id="fnr.15" href="#fn.15">15</a></sup>
</p>

<div>
<p><label><span>Listing 36: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_DAC_READ_SEARCH,
</pre>
</div>

<p>
<code>CAP_FSETID</code>, without user namespacing, allows the process to modify a
setuid executable without removing the setuid bit. This is pretty
dangerous! It means that if we include a setuid binary in a container,
it&#39;s easy for us to accidentally leave a dangerous setuid root binary
on our disk, which any user can use to escalate
privileges.<sup><a id="fnr.16" href="#fn.16">16</a></sup>
</p>

<div>
<p><label><span>Listing 40: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_FSETID,
</pre>
</div>

<p>
<code>CAP_IPC_LOCK</code> can be used to lock more of a process&#39; own memory than
would normally be allowed<sup><a id="fnr.17" href="#fn.17">17</a></sup>, which could be a way to deny service.
</p>

<div>
<p><label><span>Listing 43: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_IPC_LOCK,
</pre>
</div>

<p>
<code>CAP_MAC_ADMIN</code> and <code>CAP_MAC_OVERRIDE</code> are used by the mandatory acess
control systems Apparmor, SELinux, and SMACK to restrict access to
their settings. These aren&#39;t namespaced, so they could be used by the
contained programs to circumvent system-wide access control.
</p>

<div>
<p><label><span>Listing 44: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_MAC_ADMIN,
		CAP_MAC_OVERRIDE,
</pre>
</div>

<p>
<code>CAP_MKNOD</code>, without user namespacing, allows programs to create
device files corresponding to real-world devices. This includes
creating new device files for existing hardware. If this capability
were not dropped, a contained process could re-create the hard disk
device, remount it, and read or write to it.<sup><a id="fnr.18" href="#fn.18">18</a></sup>
</p>

<div>
<p><label><span>Listing 47: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_MKNOD,
</pre>
</div>

<p>
I was worried that <code>CAP_SETFCAP</code> could be used to add a capability to
an executable and <code>execve</code> it, but it&#39;s not actually possible for a
process to set capabilities it doesn&#39;t have<sup><a id="fnr.19" href="#fn.19">19</a></sup>. But!
An executable altered this way could be executed by any unsandboxed
user, so I think it unacceptably undermines the security of the
system.
</p>

<div>
<p><label><span>Listing 51: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_SETFCAP,
</pre>
</div>

<p>
<code>CAP_SYSLOG</code> lets users perform destructive actions against the
syslog. Importantly, it doesn&#39;t prevent contained processes from
reading the syslog, which could be risky. It also exposes kernel
addresses, which could be used to circumvent kernel address layout
randomization<sup><a id="fnr.20" href="#fn.20">20</a></sup>.
</p>

<div>
<p><label><span>Listing 54: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_SYSLOG,
</pre>
</div>

<p>
<code>CAP_SYS_ADMIN</code> allows many behaviors! We don&#39;t want most of them
(<code>mount</code>, <code>vm86</code>, etc). Some would be nice to have (<code>sethostname</code>,
<code>mount</code> for bind mounts…) but the extra complexity doesn&#39;t seem
worth it.
</p>

<div>
<p><label><span>Listing 55: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_SYS_ADMIN,
</pre>
</div>


<p>
<code>CAP_SYS_BOOT</code> allows programs to restart the system (the <code>reboot</code>
syscall) and load new kernels (the <code>kexec_load</code> and <code>kexec_file</code>
syscalls)<sup><a id="fnr.21" href="#fn.21">21</a></sup>. We absolutely don&#39;t want
this. <code>reboot</code> is user-namespaced, and the <code>kexec*</code> functions only work
in the root user namespace, but neither of those help us.
</p>

<div>
<p><label><span>Listing 59: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_SYS_BOOT,
</pre>
</div>

<p>
<code>CAP_SYS_MODULE</code> is used by the syscalls <code>delete_module</code>,
<code>init_module</code>, <code>finit_module</code> <sup><a id="fnr.22" href="#fn.22">22</a></sup>, by the code for <code>kmod</code> <sup><a id="fnr.23" href="#fn.23">23</a></sup>,
and by the code for loading device modules with ioctl<sup><a id="fnr.24" href="#fn.24">24</a></sup>.
</p>

<div>
<p><label><span>Listing 66: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_SYS_MODULE,
</pre>
</div>

<p>
<code>CAP_SYS_NICE</code> allows processes to set higher priority on given pids
than the default<sup><a id="fnr.25" href="#fn.25">25</a></sup>. The default kernel scheduler
doesn&#39;t know anything about pid namespaces, so it&#39;s possible for a
contained process to deny service to the rest of the system<sup><a id="fnr.26" href="#fn.26">26</a></sup>.
</p>

<div>
<p><label><span>Listing 71: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_SYS_NICE,
</pre>
</div>

<p>
<code>CAP_SYS_RAWIO</code> allows full access to the host systems memory with
<code>/proc/kcore</code>, <code>/dev/mem</code>, and <code>/dev/kmem</code> <sup><a id="fnr.27" href="#fn.27">27</a></sup>, but a
contained process would need <code>mknod</code> to access these within the
namespace.<sup><a id="fnr.28" href="#fn.28">28</a></sup>. But it also allows things like <code>iopl</code>
and <code>ioperm</code>, which give raw access to the IO ports<sup><a id="fnr.29" href="#fn.29">29</a></sup>.
</p>

<div>
<p><label><span>Listing 76: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_SYS_RAWIO,
</pre>
</div>

<p>
<code>CAP_SYS_RESOURCE</code> specifically allows circumventing kernel-wide
limits, so we probably should drop it<sup><a id="fnr.30" href="#fn.30">30</a></sup>. But I
don&#39;t think this can do more than DOS the
kernel, in general<sup><a id="fnr.31" href="#fn.31">31</a></sup>.
</p>

<div>
<p><label><span>Listing 78: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_SYS_RESOURCE,
</pre>
</div>

<p>
<code>CAP_SYS_TIME</code>: setting the time isn&#39;t namespaced, so we should prevent
contained processes from altering the system-wide
time<sup><a id="fnr.32" href="#fn.32">32</a></sup>.
</p>

<div>
<p><label><span>Listing 79: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_SYS_TIME,
</pre>
</div>

<p>
<code>CAP_WAKE_ALARM</code>, like <code>CAP_BLOCK_SUSPEND</code>, lets the contained process
interfere with suspend<sup><a id="fnr.33" href="#fn.33">33</a></sup>, and we&#39;d like to prevent that.
</p>

<div>
<p><label><span>Listing 81: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>		CAP_WAKE_ALARM
	};
</pre>
</div>

<div>
<p><label><span>Listing 82: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label></p><pre>	size_t num_caps = sizeof(drop_caps) / sizeof(*drop_caps);
	fprintf(stderr, &#34;bounding...&#34;);
	for (size_t i = 0; i &lt; num_caps; i++) {
		if (prctl(PR_CAPBSET_DROP, drop_caps[i], 0, 0, 0)) {
			fprintf(stderr, &#34;prctl failed: %m\n&#34;);
			return 1;
		}
	}
	fprintf(stderr, &#34;inheritable...&#34;);
	cap_t caps = NULL;
	if (!(caps = cap_get_proc())
	    || cap_set_flag(caps, CAP_INHERITABLE, num_caps, drop_caps, CAP_CLEAR)
	    || cap_set_proc(caps)) {
		fprintf(stderr, &#34;failed: %m\n&#34;);
		if (caps) cap_free(caps);
		return 1;
	}
	cap_free(caps);
	fprintf(stderr, &#34;done.\n&#34;);
	return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc6d2b81">
<h4 id="orgc6d2b81">Retained Capabilities</h4>
<div id="text-orgc6d2b81">
<p>
It&#39;s important to keep track of the capabilities I&#39;m not dropping,
too.
</p>

<p>
I&#39;ve heard multiple places<sup><a id="fnr.34" href="#fn.34">34</a></sup> that <code>CAP_DAC_OVERRIDE</code>
might expose the same functionality as <code>CAP_DAC_READ_SEARCH</code>
(i.e. <code>open_by_handle_at</code>), but as far as I can tell that isn&#39;t
true. <code>shocker.c</code> doesn&#39;t get anywhere with only
<code>CAP_DAC_OVERRIDE</code> <sup><a id="fnr.35" href="#fn.35">35</a></sup>, and the
only usage in the kernel is in the Unix permission-checking
code<sup><a id="fnr.36" href="#fn.36">36</a></sup>. So my understanding is that
<code>CAP_DAC_OVERRIDE</code> on its own doesn&#39;t allow processes to read outside
of their mount namespaces (&#34;DAC&#34; or &#34;Discretionary Access Control&#34;
refers here to ordinary unix permissions).
</p>

<p>
<code>CAP_FOWNER</code>, <code>CAP_LEASE</code>, and <code>CAP_LINUX_IMMUTABLE</code> all operate on
files inside of the mount namespace.
</p>

<p>
Likewise, <code>CAP_SYS_PACCT</code> allows processes to switch accounting on and
off for itself. The <code>acct</code> system call takes a path to log to (which
must be within the mount namespace), and only operates on the calling
process. We&#39;re not using process accounting in our containerization,
so turning it off should be harmless as well.<sup><a id="fnr.37" href="#fn.37">37</a></sup>
</p>

<p>
<code>CAP_IPC_OWNER</code> is only used by functions that respect IPC
namespaces<sup><a id="fnr.38" href="#fn.38">38</a></sup>; since we&#39;re in a separate IPC namespace
from the host, we can allow this.
</p>

<p>
<code>CAP_NET_ADMIN</code> lets processes create network devices;
<code>CAP_NET_BIND_SERVICE</code> lets processes bind to low ports on those
devices; <code>CAP_NET_RAW</code> lets processes send raw packets on those
devices. Since we&#39;re going to isolate the networking with a virtual
bridge, and the contained process is inside of a network namespace,
these shouldn&#39;t be an issue<sup><a id="fnr.39" href="#fn.39">39</a></sup>. I was wondering
whether we could recreate an existing device like <code>mknod</code> does, but I
don&#39;t think it&#39;s possible <sup><a id="fnr.40" href="#fn.40">40</a></sup>.
</p>


<p>
<code>CAP_SYS_PTRACE</code> doesn&#39;t allow ptrace across pid
namespaces<sup><a id="fnr.41" href="#fn.41">41</a></sup>. <code>CAP_KILL</code> doesn&#39;t allow signals across
pid namespaces<sup><a id="fnr.42" href="#fn.42">42</a></sup>.
</p>

<p>
<code>CAP_SETUID</code> and <code>CAPSETGID</code> have similar behaviors<sup><a id="fnr.43" href="#fn.43">43</a></sup>:
</p>
<ul>
<li><code>Make arbitrary manipulations of process UIDS and GIDs and
  supplementary GID list</code>, which will only apply to pids in the
namespace.</li>
<li><code>forge UID (GID) when passing socket credentials via UNIX domain
  sockets</code> the mount namespace should prevent us from reading the host
system&#39;s unix domain sockets.</li>
<li><code>write a user(group ID) mapping in a user namespace (see
  user_namespaces(7))</code>: this is <code>/proc/self/uid_map</code>, which will be
hidden inside the container.</li>
</ul>

<p>
<code>CAP_SETPCAP</code> only lets processes add or drop capabilities they
already effectively have; <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html"><code>man 7 capabilities</code></a> says
</p>
<blockquote>
<p>
If file capabilities are  supported: add any capability
from  the   calling  thread&#39;s   bounding  set   to  its
inheritable  set; drop  capabilities from  the bounding
set (via prctl(2) PR_CAPBSET_DROP); make changes to the
securebits flags.
</p>
</blockquote>
<p>
We&#39;ve dropped everything relevant from the bounding set, and dropping
further capabilities should be harmless.
</p>

<p>
<code>CAP_SYS_CHROOT</code> is traditionally abused by changing root to a
directory with a setuid root binary and tampered-with dynamic
libraries<sup><a id="fnr.44" href="#fn.44">44</a></sup>. Additionally, it can be used
to escape a chroot &#34;jail&#34;<sup><a id="fnr.45" href="#fn.45">45</a></sup>. Neither of those
should be relevant in our setup so this should be harmless.
</p>

<p>
<a href="https://forums.grsecurity.net/viewtopic.php?f%3D7&amp;t%3D2522">Brad Spengler, in &#34;False Boundaries and Arbitrary Code Execution&#34;</a> says
that <code>CAP_SYS_TTYCONFIG</code> can &#34;temporarily change the keyboard
mapping of an administrator&#39;s tty via the KDSETKEYCODE ioctl to cause
a different command to be executed than intended&#34;, but again this is
an <code>ioctl</code> against a device that should be impossible to access within
the mount namespace.
</p>
</div>
</div>
</div>

<div id="outline-container-org00cc412">
<h3 id="org00cc412">Mounts</h3>
<div id="text-org00cc412">
<p>
The child process is in its own mount namespace, so we can unmount
things that it specifically shouldn&#39;t have access to. Here&#39;s how:
</p>

<ul>
<li>Create a temporary directory, and one inside of it.</li>
<li>Bind mount of the user argument onto the temporary directory</li>
<li><code>pivot_root</code>, making the bind mount our root and mounting the old
root onto the inner temporary directory.</li>
<li><code>umount</code> the old root, and remove the inner temporary directory.</li>
</ul>

<p>
But first we&#39;ll remount everything with <code>MS_PRIVATE</code>. This is mostly a
convenience, so that the bind mount is invisible outside of our
namespace.
</p>

<div>
<p><label><span>Listing 108: </span><code>&lt;&lt;mounts&gt;&gt;</code> =</label></p><pre>&lt;&lt;pivot-root&gt;&gt;

int mounts(struct child_config *config)
{
	fprintf(stderr, &#34;=&gt; remounting everything with MS_PRIVATE...&#34;);
	if (mount(NULL, &#34;/&#34;, NULL, MS_REC | MS_PRIVATE, NULL)) {
		fprintf(stderr, &#34;failed! %m\n&#34;);
		return -1;
	}
	fprintf(stderr, &#34;remounted.\n&#34;);

	fprintf(stderr, &#34;=&gt; making a temp directory and a bind mount there...&#34;);
	char mount_dir[] = &#34;/tmp/tmp.XXXXXX&#34;;
	if (!mkdtemp(mount_dir)) {
		fprintf(stderr, &#34;failed making a directory!\n&#34;);
		return -1;
	}

	if (mount(config-&gt;mount_dir, mount_dir, NULL, MS_BIND | MS_PRIVATE, NULL)) {
		fprintf(stderr, &#34;bind mount failed!\n&#34;);
		return -1;
	}

	char inner_mount_dir[] = &#34;/tmp/tmp.XXXXXX/oldroot.XXXXXX&#34;;
	memcpy(inner_mount_dir, mount_dir, sizeof(mount_dir) - 1);
	if (!mkdtemp(inner_mount_dir)) {
		fprintf(stderr, &#34;failed making the inner directory!\n&#34;);
		return -1;
	}
	fprintf(stderr, &#34;done.\n&#34;);

	fprintf(stderr, &#34;=&gt; pivoting root...&#34;);
	if (pivot_root(mount_dir, inner_mount_dir)) {
		fprintf(stderr, &#34;failed!\n&#34;);
		return -1;
	}
	fprintf(stderr, &#34;done.\n&#34;);

	char *old_root_dir = basename(inner_mount_dir);
	char old_root[sizeof(inner_mount_dir) + 1] = { &#34;/&#34; };
	strcpy(&amp;old_root[1], old_root_dir);

	fprintf(stderr, &#34;=&gt; unmounting %s...&#34;, old_root);
	if (chdir(&#34;/&#34;)) {
		fprintf(stderr, &#34;chdir failed! %m\n&#34;);
		return -1;
	}
	if (umount2(old_root, MNT_DETACH)) {
		fprintf(stderr, &#34;umount failed! %m\n&#34;);
		return -1;
	}
	if (rmdir(old_root)) {
		fprintf(stderr, &#34;rmdir failed! %m\n&#34;);
		return -1;
	}
	fprintf(stderr, &#34;done.\n&#34;);
	return 0;
}

</pre>
</div>

<p>
<code>pivot_root</code> is a system call lets us swap the mount at <code>/</code> with
another. Glibc doesn&#39;t provide a wrapper for it, but includes a
prototype in the man page.  I don&#39;t really understand, but OK, we&#39;ll
include our own.
</p>

<div>
<p><label><span>Listing 109: </span><code>&lt;&lt;pivot-root&gt;&gt;</code> =</label></p><pre>int pivot_root(const char *new_root, const char *put_old)
{
	return syscall(SYS_pivot_root, new_root, put_old);
}

</pre>
</div>


<p>
It&#39;s worth noting that I&#39;m avoiding packing and unpackaging
containers. This is fertile ground for
vulnerabilities<sup><a id="fnr.46" href="#fn.46">46</a></sup>; I&#39;ll count on the user to
ensure that the mounted directory doesn&#39;t contain trusted or sensitive
files or hard links.
</p>
</div>
</div>


<div id="outline-container-org8504d16">
<h3 id="org8504d16">System Calls</h3>
<div id="text-org8504d16">
<p>
I&#39;ll be blacklisting system calls that I can demonstrate causing harm
or sandbox escapes. Again this isn&#39;t the best way to do this, but it
seems like the most illustrative.
</p>

<p>
<a href="https://github.com/docker/docker.github.io/blob/master/engine/security/seccomp.md">Docker&#39;s documentation</a> and <a href="https://github.com/docker/docker/blob/b248de7e332b6e67b08a8981f68060e6ae629ccf/profiles/seccomp/default.json">default seccomp profile</a> are reasonable
sources for dangerous system calls<sup><a id="fnr.47" href="#fn.47">47</a></sup>. They
also include obsolete sytem calls and calls that overlap with
restricted capabilities; I&#39;ll ignore those.
</p>
</div>


<div id="outline-container-org141a19c">
<h4 id="org141a19c">Disallowed System Calls</h4>
<div id="text-org141a19c">
<div>
<p><label><span>Listing 113: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label></p><pre>#define SCMP_FAIL SCMP_ACT_ERRNO(EPERM)

int syscalls()
{
	scmp_filter_ctx ctx = NULL;
	fprintf(stderr, &#34;=&gt; filtering syscalls...&#34;);
	if (!(ctx = seccomp_init(SCMP_ACT_ALLOW))
</pre>
</div>

<p>
We want to prevent new setuid / setgid executables from being created,
since in the absence of user namespaces the contained process could
create a setuid binary that could be used by any user to get
root.<sup><a id="fnr.48" href="#fn.48">48</a></sup>
</p>

<div>
<p><label><span>Listing 116: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label></p><pre>	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(chmod), 1,
				SCMP_A1(SCMP_CMP_MASKED_EQ, S_ISUID, S_ISUID))
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(chmod), 1,
				SCMP_A1(SCMP_CMP_MASKED_EQ, S_ISGID, S_ISGID))
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(fchmod), 1,
				SCMP_A1(SCMP_CMP_MASKED_EQ, S_ISUID, S_ISUID))
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(fchmod), 1,
				SCMP_A1(SCMP_CMP_MASKED_EQ, S_ISGID, S_ISGID))
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(fchmodat), 1,
				SCMP_A2(SCMP_CMP_MASKED_EQ, S_ISUID, S_ISUID))
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(fchmodat), 1,
				SCMP_A2(SCMP_CMP_MASKED_EQ, S_ISGID, S_ISGID))
</pre>
</div>

<p>
Allowing contained processes to start new user namespaces can allow
processes to gain new (albeit limited) capabilities, so we prevent
it.
</p>

<div>
<p><label><span>Listing 117: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label></p><pre>	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(unshare), 1,
				SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER))
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(clone), 1,
				SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER))
</pre>
</div>

<p>
<code>TIOCSTI</code> allows contained processes to write to the controlling
terminal<sup><a id="fnr.49" href="#fn.49">49</a></sup>.
</p>

<div>
<p><label><span>Listing 121: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label></p><pre>	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(ioctl), 1,
				SCMP_A1(SCMP_CMP_MASKED_EQ, TIOCSTI, TIOCSTI))
</pre>
</div>

<p>
The kernel keyring system isn&#39;t namespaced.<sup><a id="fnr.50" href="#fn.50">50</a></sup>
</p>

<div>
<p><label><span>Listing 123: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label></p><pre>	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(keyctl), 0)
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(add_key), 0)
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(request_key), 0)
</pre>
</div>

<p>
Before Linux 4.8, <code>ptrace</code> totally breaks seccomp<sup><a id="fnr.51" href="#fn.51">51</a></sup>.
</p>

<div>
<p><label><span>Listing 127: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label></p><pre>	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(ptrace), 0)
</pre>
</div>

<p>
These system calls let processes assign NUMA nodes. I don&#39;t have
anything specific in mind, but I could see these being used to deny
service to some other NUMA-aware application on the host.
</p>

<div>
<p><label><span>Listing 128: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label></p><pre>	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(mbind), 0)
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(migrate_pages), 0)
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(move_pages), 0)
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(set_mempolicy), 0)
</pre>
</div>

<p>
<code>userfaultd</code> allows userspace to handle page
faults<sup><a id="fnr.52" href="#fn.52">52</a></sup>. It doesn&#39;t require any privileges, so in
theory it should be safe to be called by an unprivileged user. But it
can be used to pause execution in the kernel by triggering page faults
in system calls. This is an important part in some kernel
exploits<sup><a id="fnr.53" href="#fn.53">53</a></sup>. It&#39;s only rarely used legitimately, so
I&#39;ll disable it.
</p>


<div>
<p><label><span>Listing 130: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label></p><pre>	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(userfaultfd), 0)
</pre>
</div>

<p>
I was initially worried about <code>perf_event_open</code> because the <a href="https://github.com/docker/docker.github.io/blob/master/engine/security/seccomp.md">Docker
documentation says</a> it &#34;could leak a lot of information on the host&#34;,
but it can&#39;t be used in our system to see information for
out-of-namespace processes<sup><a id="fnr.54" href="#fn.54">54</a></sup>. But, if
<code>/proc/sys/kernel/perf_event_paranoid</code> is less than 2, it can be used
to discover kernel addresses and possibly uninitialized memory. 2 is
the default since is the default since 4.6, but it can be changed, and
relying on it seems like a bad idea<sup><a id="fnr.55" href="#fn.55">55</a></sup>.
</p>

<div>
<p><label><span>Listing 135: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label></p><pre>	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(perf_event_open), 0)
</pre>
</div>

<p>
We&#39;ll set <code>PR_SET_NO_NEW_PRIVS</code> to 0. The name is a little vague: it
specifically prevents <code>setuid</code> and <code>setcap</code>&#39;d binaries from being
executed with their additional privileges. This has some security
benefits (it makes it harder for an unprivileged user in-container to
exploit a vulnerability in a setuid or setcap executable to become
in-container root, for example). But it&#39;s a little weird, and means
that, for example, <code>ping</code> won&#39;t work in a container for an
unprivileged user<sup><a id="fnr.56" href="#fn.56">56</a></sup>.
</p>

<div>
<p><label><span>Listing 140: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label></p><pre>	    || seccomp_attr_set(ctx, SCMP_FLTATR_CTL_NNP, 0)
</pre>
</div>

<p>
And we&#39;ll actually apply it to the process, and release the context.
</p>

<div>
<p><label><span>Listing 141: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label></p><pre>	    || seccomp_load(ctx)) {
		if (ctx) seccomp_release(ctx);
		fprintf(stderr, &#34;failed: %m\n&#34;);
		return 1;
	}
	seccomp_release(ctx);
	fprintf(stderr, &#34;done.\n&#34;);
	return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8ee812f">
<h4 id="org8ee812f">Allowed System Calls</h4>
<div id="text-org8ee812f">
<p>
Here are the system calls that are disallowed by the default Docker
policy but permitted by this code:
</p>

<p>
<code>_sysctl</code> is obsolete and disabled by
default<sup><a id="fnr.57" href="#fn.57">57</a></sup>. <code>alloc_hugepages</code> and
<code>free_hugepages</code> <sup><a id="fnr.58" href="#fn.58">58</a></sup>, <code>bdflush</code> <sup><a id="fnr.59" href="#fn.59">59</a></sup>,
<code>create_module</code> <sup><a id="fnr.60" href="#fn.60">60</a></sup>, <code>nfsservctl</code> <sup><a id="fnr.61" href="#fn.61">61</a></sup>,
<code>perfctr</code> <sup><a id="fnr.62" href="#fn.62">62</a></sup>, <code>get_kernel_syms</code> <sup><a id="fnr.63" href="#fn.63">63</a></sup>, and
<code>setup</code> <sup><a id="fnr.64" href="#fn.64">64</a></sup> are not present on modern Linux.
</p>

<p>
<code>clock_adjtime</code>, <code>clock_settime</code> <sup><a id="fnr.65" href="#fn.65">65</a></sup>, and
<code>adjtime</code> <sup><a id="fnr.66" href="#fn.66">66</a></sup> depend on <code>CAP_SYS_TIME</code>.
</p>

<p>
<code>pciconfig_read</code> and <code>pciconfig_write</code> <sup><a id="fnr.67" href="#fn.67">67</a></sup> and all of the
side-effecting operations of <code>quotactl</code> <sup><a id="fnr.68" href="#fn.68">68</a></sup> are prevented by
<code>CAP_SYS_ADMIN</code>.
</p>

<p>
<code>get_mempolicy</code> and <code>getpagesize</code> reveal information about the memory
layout of the system, but they can be made by unprivileged processes,
and are probably harmless. <code>pciconfig_iobase</code> can be made by
unprivileged processes, and reveals information about PCI decvices.
<code>ustat</code> <sup><a id="fnr.69" href="#fn.69">69</a></sup> and <code>sysfs</code> <sup><a id="fnr.70" href="#fn.70">70</a></sup> leak some information about
the filesystems, but are nothing that I see as critical. <code>uselib</code> is
more-or-less obsolete, but is just used for loading a shared library
in userspace <sup><a id="fnr.71" href="#fn.71">71</a></sup>
</p>

<p>
<code>sync_file_range2</code> is <code>sync_file_range</code> with swapped argument
order<sup><a id="fnr.72" href="#fn.72">72</a></sup>.
</p>

<p>
<code>readdir</code> is mostly obsolete, but probably harmless<sup><a id="fnr.73" href="#fn.73">73</a></sup>.
</p>

<p>
<code>kexec_file_load</code> and <code>kexec_load</code> are prevented by
<code>CAP_SYS_BOOT</code> <sup><a id="fnr.74" href="#fn.74">74</a></sup>.
</p>

<p>
<code>nice</code> can only be used to lower priority without
<code>CAP_SYS_NICE</code> <sup><a id="fnr.75" href="#fn.75">75</a></sup>.
</p>

<p>
<code>oldfstat</code>, <code>oldlstat</code>, <code>oldolduname</code>, <code>oldstat</code>, and <code>olduname</code> are
just older versions of their respective functions. I expect them to
have the same security properties as the modern ones.
</p>

<p>
<code>perfmonctl</code> <sup><a id="fnr.76" href="#fn.76">76</a></sup> is only available on
IA-64. <code>ppc_rtas</code> <sup><a id="fnr.77" href="#fn.77">77</a></sup>, <code>spu_create</code> <sup><a id="fnr.78" href="#fn.78">78</a></sup> and
<code>spu_run</code> <sup><a id="fnr.79" href="#fn.79">79</a></sup>, and <code>subpage_prot</code> <sup><a id="fnr.80" href="#fn.80">80</a></sup> are only
avaiable on PowerPC. <code>utrap_install</code> is only available on
Sparc<sup><a id="fnr.81" href="#fn.81">81</a></sup>. <code>kern_features</code> is only available on
Sparc64, and should be harmless anyway<sup><a id="fnr.82" href="#fn.82">82</a></sup>.
</p>

<p>
I don&#39;t believe <code>pivot_root</code> is a problem in our setup (but it could
probably be used to circumvent path-based MAC).
</p>

<p>
<code>preadv2</code> and <code>pwritev2</code> are just extensions to <code>preadv</code> and <code>pwritev</code>
/ <code>readv</code> and <code>writev</code>, which are &#34;scatter input&#34; / &#34;gather output&#34;
extensions to <code>read</code> and <code>write</code> <sup><a id="fnr.83" href="#fn.83">83</a></sup>.
</p>
</div>
</div>
</div>

<div id="outline-container-org36fcb0f">
<h3 id="org36fcb0f">Resources</h3>
<div id="text-org36fcb0f">
<p>
We&#39;d like to prevent badly-behaved child processes from denying
service to the rest of the system<sup><a id="fnr.84" href="#fn.84">84</a></sup>. Cgroups let
us limit memory and cpu time in particular; limiting the pid count and
IO usage is also useful. <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt">There&#39;s a very useful document in the kernel
tree about it</a>.
</p>

<p>
The <code>cgroup</code> and <code>cgroup2</code> filesystems are the canonical interfaces to
the cgroup system.  <code>cgroup2</code> is a little different, and unitialized
on my system, so I&#39;ll use the first version here.
</p>

<p>
Cgroup namespaces are a little different from, for example, mount
namespaces. We need to create the cgroup before we enter a cgroup
namespace; once we do, that cgroup will behave like the root cgroup
inside of the namespace<sup><a id="fnr.85" href="#fn.85">85</a></sup>. This isn&#39;t the most
relevant, since a contained process can&#39;t mount the cgroup filesystem
or <code>/proc</code> for introspection, but it&#39;s nice to be thorough.
</p>

<p>
I&#39;ll set up a struct so I don&#39;t have to repeat myself too much, with
the following instructions:
</p>

<ul>
<li>Set <code>memory/$hostname/memory.limit_in_bytes</code>, so the contained
process and its child processes can&#39;t total more than 1GB memory in
userspace<sup><a id="fnr.86" href="#fn.86">86</a></sup>.</li>
<li>Set <code>memory/$hostname/memory.kmem.limit_in_bytes</code>, so that the
contained process and its child processes can&#39;t total more than 1GB
memory in userspace<sup><a id="fnr.87" href="#fn.87">87</a></sup>.</li>
<li>Set <code>cpu/$hostname/cpu.shares</code> to 256. CPU shares are chunks of
1024; 256 * 4 = 1024, so this lets the contained process take a
quarter of cpu-time on a busy system at most<sup><a id="fnr.88" href="#fn.88">88</a></sup>.</li>
<li>Set the <code>pids/$hostname/pid.max</code>, allowing the contained process and
its children to have 64 pids at most. This is useful because there
are per-user pid limits that we could hit on the host if the
contained process occupies too many<sup><a id="fnr.89" href="#fn.89">89</a></sup>.</li>
<li>Set <code>blkio/$hostname/weight</code> to 50, so that it&#39;s lower than the rest
of the system and prioritized accordingly<sup><a id="fnr.90" href="#fn.90">90</a></sup>.</li>
</ul>

<p>
I&#39;ll also add the calling process for each of
<code>{memory,cpu,blkio,pids}/$hostname/tasks</code> by writing &#39;0&#39; to it.
</p>

<div>
<p><label><span>Listing 181: </span><code>&lt;&lt;resources&gt;&gt;</code> +=</label></p><pre>#define MEMORY &#34;1073741824&#34;
#define SHARES &#34;256&#34;
#define PIDS &#34;64&#34;
#define WEIGHT &#34;10&#34;
#define FD_COUNT 64

struct cgrp_control {
	char control[256];
	struct cgrp_setting {
		char name[256];
		char value[256];
	} **settings;
};
struct cgrp_setting add_to_tasks = {
	.name = &#34;tasks&#34;,
	.value = &#34;0&#34;
};

struct cgrp_control *cgrps[] = {
	&amp; (struct cgrp_control) {
		.control = &#34;memory&#34;,
		.settings = (struct cgrp_setting *[]) {
			&amp; (struct cgrp_setting) {
				.name = &#34;memory.limit_in_bytes&#34;,
				.value = MEMORY
			},
			&amp; (struct cgrp_setting) {
				.name = &#34;memory.kmem.limit_in_bytes&#34;,
				.value = MEMORY
			},
			&amp;add_to_tasks,
			NULL
		}
	},
	&amp; (struct cgrp_control) {
		.control = &#34;cpu&#34;,
		.settings = (struct cgrp_setting *[]) {
			&amp; (struct cgrp_setting) {
				.name = &#34;cpu.shares&#34;,
				.value = SHARES
			},
			&amp;add_to_tasks,
			NULL
		}
	},
	&amp; (struct cgrp_control) {
		.control = &#34;pids&#34;,
		.settings = (struct cgrp_setting *[]) {
			&amp; (struct cgrp_setting) {
				.name = &#34;pids.max&#34;,
				.value = PIDS
			},
			&amp;add_to_tasks,
			NULL
		}
	},
	&amp; (struct cgrp_control) {
		.control = &#34;blkio&#34;,
		.settings = (struct cgrp_setting *[]) {
			&amp; (struct cgrp_setting) {
				.name = &#34;blkio.weight&#34;,
				.value = PIDS
			},
			&amp;add_to_tasks,
			NULL
		}
	},
	NULL
};
</pre>
</div>


<p>
Writing to the cgroups version 1 filesystem works like
this<sup><a id="fnr.91" href="#fn.91">91</a></sup>:
</p>
<ul>
<li>In each controller, you can create a cgroup with a name with
<code>mkdir</code>. For memory, <code>mkdir /sys/fs/cgroup/memory/$hostname</code>.</li>
<li>Inside of that you can write to the individual files to set
values. For example, <code>echo $MEMORY &gt;
  /sys/fs/cgroup/memory/$hostname/memory.limit_in_bytes</code>.</li>
<li>You can a pid to <code>tasks</code> to add the process tree to the cgroup. &#34;0&#34;
is a special value that means &#34;the writing process&#34;.</li>
</ul>

<p>
so I&#39;ll iterate over that structure and fill in the values.
</p>

<div>
<p><label><span>Listing 183: </span><code>&lt;&lt;resources&gt;&gt;</code> +=</label></p><pre>int resources(struct child_config *config)
{
	fprintf(stderr, &#34;=&gt; setting cgroups...&#34;);
	for (struct cgrp_control **cgrp = cgrps; *cgrp; cgrp++) {
		char dir[PATH_MAX] = {0};
		fprintf(stderr, &#34;%s...&#34;, (*cgrp)-&gt;control);
		if (snprintf(dir, sizeof(dir), &#34;/sys/fs/cgroup/%s/%s&#34;,
			     (*cgrp)-&gt;control, config-&gt;hostname) == -1) {
			return -1;
		}
		if (mkdir(dir, S_IRUSR | S_IWUSR | S_IXUSR)) {
			fprintf(stderr, &#34;mkdir %s failed: %m\n&#34;, dir);
			return -1;
		}
		for (struct cgrp_setting **setting = (*cgrp)-&gt;settings; *setting; setting++) {
			char path[PATH_MAX] = {0};
			int fd = 0;
			if (snprintf(path, sizeof(path), &#34;%s/%s&#34;, dir,
				     (*setting)-&gt;name) == -1) {
				fprintf(stderr, &#34;snprintf failed: %m\n&#34;);
				return -1;
			}
			if ((fd = open(path, O_WRONLY)) == -1) {
				fprintf(stderr, &#34;opening %s failed: %m\n&#34;, path);
				return -1;
			}
			if (write(fd, (*setting)-&gt;value, strlen((*setting)-&gt;value)) == -1) {
				fprintf(stderr, &#34;writing to %s failed: %m\n&#34;, path);
				close(fd);
				return -1;
			}
			close(fd);
		}
	}
	fprintf(stderr, &#34;done.\n&#34;);
</pre>
</div>

<p>
I&#39;ll also lower the hard limit on the number of file descriptors. The
file descriptor number, like the number of pids, is per-user, and so
we want to prevent in-container process from occupying all of
them. Setting the hard limit sets a permanent upper bound for this
process tree, since I&#39;ve dropped
<code>CAP_SYS_RESOURCE</code> <sup><a id="fnr.92" href="#fn.92">92</a></sup>.
</p>

<div>
<p><label><span>Listing 185: </span><code>&lt;&lt;resources&gt;&gt;</code> +=</label></p><pre>	fprintf(stderr, &#34;=&gt; setting rlimit...&#34;);
	if (setrlimit(RLIMIT_NOFILE,
		      &amp; (struct rlimit) {
			.rlim_max = FD_COUNT,
			.rlim_cur = FD_COUNT,
		})) {
		fprintf(stderr, &#34;failed: %m\n&#34;);
		return 1;
	}
	fprintf(stderr, &#34;done.\n&#34;);
	return 0;
}
</pre>
</div>


<p>
We&#39;d also like to clean up the cgroup for this hostname. There&#39;s
built-in functionality for this, but we would need to change
system-wide values to do it cleanly<sup><a id="fnr.93" href="#fn.93">93</a></sup>. Since we
have the <code>contained</code> process waiting on the contained process, it&#39;s
simple to do it this way. First we move the <code>contained</code> process back
into the root <code>tasks</code>; then, since the child process is finished, and
leaving the pid namespace <code>SIGKILLS</code> its children, the <code>tasks</code> is
empty. We can safely <code>rmdir</code> at this point.
</p>

<div>
<p><label><span>Listing 187: </span><code>&lt;&lt;resources&gt;&gt;</code> +=</label></p><pre>int free_resources(struct child_config *config)
{
	fprintf(stderr, &#34;=&gt; cleaning cgroups...&#34;);
	for (struct cgrp_control **cgrp = cgrps; *cgrp; cgrp++) {
		char dir[PATH_MAX] = {0};
		char task[PATH_MAX] = {0};
		int task_fd = 0;
		if (snprintf(dir, sizeof(dir), &#34;/sys/fs/cgroup/%s/%s&#34;,
			     (*cgrp)-&gt;control, config-&gt;hostname) == -1
		    || snprintf(task, sizeof(task), &#34;/sys/fs/cgroup/%s/tasks&#34;,
				(*cgrp)-&gt;control) == -1) {
			fprintf(stderr, &#34;snprintf failed: %m\n&#34;);
			return -1;
		}
		if ((task_fd = open(task, O_WRONLY)) == -1) {
			fprintf(stderr, &#34;opening %s failed: %m\n&#34;, task);
			return -1;
		}
		if (write(task_fd, &#34;0&#34;, 2) == -1) {
			fprintf(stderr, &#34;writing to %s failed: %m\n&#34;, task);
			close(task_fd);
			return -1;
		}
		close(task_fd);
		if (rmdir(dir)) {
			fprintf(stderr, &#34;rmdir %s failed: %m&#34;, dir);
			return -1;
		}
	}
	fprintf(stderr, &#34;done.\n&#34;);
	return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org65bbba4">
<h3 id="org65bbba4">Networking</h3>
<div id="text-org65bbba4">
<p>
Container networking takes a little too much explanation for this
space. It usually works like this:
</p>

<ul>
<li>Create a bridge device.</li>
<li>Create a virtual ethernet pair and attach one end to the bridge.</li>
<li>Put the other end in the network namespace.</li>
<li>For outside networking access, the host needs to be set to forward
(and possibly NAT) packets.</li>
</ul>

<p>
Having multiple contained processes sharing a bridge device would mean
they&#39;re both on the same LAN from the host&#39;s perspective. So ARP
spoofing is a recurring issue with containers that work this
way<sup><a id="fnr.94" href="#fn.94">94</a></sup>.
</p>

<p>
The canonical way to do this from C is the <code>rtnetlink</code> interface; it
would probably be easier to use <code>ip link ...</code>.
</p>


<p>
We could also limit the network usage with the <code>net_prio</code> cgroup
controller<sup><a id="fnr.95" href="#fn.95">95</a></sup>.
</p>
</div>
</div>
</div>
</div></div>
  </body>
</html>
