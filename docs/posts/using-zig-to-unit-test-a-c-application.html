<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mtlynch.io/notes/zig-unit-test-c/">Original</a>
    <h1>Using Zig to Unit Test a C Application</h1>
    
    <div id="readability-page-1" class="page"><div><p><a href="https://ziglang.org/">Zig</a> is a new, independently developed low-level programming language. It’s a modern reimagining of C that attempts to retain C’s performance while embracing improvements from the last 30 years of tooling and language design.</p><p>Zig makes calling into C code easier than any other language I’ve used. Zig also treats unit testing as a first-class feature, which the C language certainly does not.</p><p>These two properties of Zig create an interesting opportunity: Zig allows you to add unit tests to existing C code. You can do this without rewriting any of your C code or build logic.</p><p>To demonstrate how to use Zig to test existing C code, I added unit tests to a real-world C application that I use daily.</p><h2 id="the-real-world-c-application-ustreamer">The real-world C application: uStreamer<a href="#the-real-world-c-application-ustreamer" arialabel="Anchor"> 🔗︎</a></h2><p>For the past three years, I’ve been working on <a href="https://tinypilotkvm.com">TinyPilot</a>, an open-source KVM over IP. TinyPilot allows you to <a href="https://mtlynch.io/tinypilot">plug a Raspberry Pi into any computer</a> and then control that computer remotely.</p><p>To stream the target computer’s display, TinyPilot uses <a href="https://github.com/pikvm/ustreamer">uStreamer</a>, a video streaming utility that’s optimized for Raspberry Pi’s hardware.</p><figure><a href="https://mtlynch.io/notes/zig-unit-test-c/ustreamer-display.webp"><img sizes="(min-width: 768px) 800px, 98vw" srcset="https://d33wubrfki0l68.cloudfront.net/62c88af50185a1053610a8189ff937dfba1e6da5/34bd9/notes/zig-unit-test-c/ustreamer-display_huc9be7d30c6e5a82d20477fdf5077c027_132828_300x0_resize_q90_h2_lanczos_2.webp 300w,
https://d33wubrfki0l68.cloudfront.net/cd5d701b130b5c46c52f10cadadae9b008a21c78/ef6b7/notes/zig-unit-test-c/ustreamer-display_huc9be7d30c6e5a82d20477fdf5077c027_132828_600x0_resize_q90_h2_lanczos_2.webp 600w,
https://d33wubrfki0l68.cloudfront.net/b5d04354a95ae6a6f623813514dc2cb0cff846eb/e868d/notes/zig-unit-test-c/ustreamer-display_huc9be7d30c6e5a82d20477fdf5077c027_132828_800x0_resize_q90_h2_lanczos_2.webp 800w,
https://d33wubrfki0l68.cloudfront.net/e0a7e07dc7688ee160f48766d808364e68e30640/c6b56/notes/zig-unit-test-c/ustreamer-display_huc9be7d30c6e5a82d20477fdf5077c027_132828_1200x0_resize_q90_h2_lanczos_2.webp 1200w,
https://d33wubrfki0l68.cloudfront.net/c9f820c017c547652186859d92758dca2d497225/4a9b1/notes/zig-unit-test-c/ustreamer-display.webp 1400w" src="https://d33wubrfki0l68.cloudfront.net/c9f820c017c547652186859d92758dca2d497225/4a9b1/notes/zig-unit-test-c/ustreamer-display.webp" alt="Screenshot of TinyPilot in a browser window displaying a Dell boot screen" loading="lazy"/></a><figcaption><p>TinyPilot uses the C uStreamer application to stream video</p></figcaption></figure><p>I’ve been working with uStreamer for several years, but I find the codebase difficult to approach. It’s implemented in C, and it doesn’t have any automated tests.</p><p>I learn best by tinkering with code, so exercising uStreamer’s C code through Zig feels like a good way to learn more about both uStreamer and Zig.</p><h2 id="getting-the-ustreamer-source-code">Getting the uStreamer source code<a href="#getting-the-ustreamer-source-code" arialabel="Anchor"> 🔗︎</a></h2><p>To begin, I’ll grab the uStreamer source code. The latest release as of this writing is <code>v5.45</code>, so I’ll grab that version:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>USTREAMER_VERSION</span>=<span>&#39;v5.45&#39;</span>
</span></span><span><span>git clone <span>\
</span></span></span><span><span><span></span>  --branch <span>&#34;</span><span>${</span><span>USTREAMER_VERSION</span><span>}</span><span>&#34;</span> <span>\
</span></span></span><span><span><span></span>  https://github.com/pikvm/ustreamer.git
</span></span></code></pre></div><h2 id="whats-the-simplest-c-function-in-ustreamer">What’s the simplest C function in uStreamer?<a href="#whats-the-simplest-c-function-in-ustreamer" arialabel="Anchor"> 🔗︎</a></h2><p>For this exercise, the challenge is going to be using Zig, so I want the C part to be as simple as possible.</p><p>I want to find a dead simple function in uStreamer’s C code — something that I can feed some input, and it gives me some output that I can inspect easily.</p><p>Scanning through the filenames, I noticed <a href="https://github.com/pikvm/ustreamer/blob/v5.45/src/libs/base64.c"><code>base64.c</code></a>. That sounded promising. I know that <a href="https://en.wikipedia.org/wiki/Base64">base64</a> is a scheme for encoding arbitrary data as a printable string.</p><p>For example, if I read 10 bytes from <code>/dev/random</code> into my terminal, I get some unprintable bytes:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ head -c <span>10</span> /dev/random &gt; /tmp/output &amp;&amp; cat /tmp/output
</span></span><span><span>V�1A�����b
</span></span></code></pre></div><p>If I encode the data as base64, I get clean, printable charcters:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ base64 &lt; /tmp/output
</span></span><span><span><span>Vo8xQbWmnsLQYg</span>==
</span></span></code></pre></div><p>Here’s the signature of uStreamer’s base64 function:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// src/libs/base64.h
</span></span></span><span><span><span></span>
</span></span><span><span><span>void</span> <span>us_base64_encode</span>(<span>const</span> <span>uint8_t</span> *data, <span>size_t</span> size, <span>char</span> **encoded, <span>size_t</span> *allocated);
</span></span></code></pre></div><p>From inspecting the function’s implementation in <a href="https://github.com/pikvm/ustreamer/blob/v5.45/src/libs/base64.c"><code>base64.c</code></a>, here’s what I deduce about the semantics of <code>us_base64_encode</code>:</p><ul><li><code>data</code> is input data to encode with the base64 encoding scheme.</li><li><code>size</code> is the length of the <code>data</code> buffer (in bytes).</li><li><code>encoded</code> is a pointer to an output buffer in which <code>us_base64_encode</code> stores the base64-encoded string.<ul><li><code>us_base64_encode</code> allocates memory for the output, and the caller is responsible for freeing the memory when they’re done with it.</li><li>Technically, <code>us_base64_encode</code> allows the caller to allocate the buffer for <code>encoded</code>, but, for simplicity, I’m ignoring that functionality.</li></ul></li><li><code>allocated</code> is a pointer that <code>us_base64_encode</code> populates with the number of bytes it allocated into <code>encoded</code>.</li></ul><p>Here’s a simple test program to call this function from C:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// src/test.c
</span></span></span><span><span><span></span>
</span></span><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#include</span> <span>&#34;libs/base64.h&#34;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>void</span> <span>main</span>(<span>void</span>) {
</span></span><span><span>  <span>char</span> *input = <span>&#34;hello, world!&#34;</span>;
</span></span><span><span>  <span>char</span> *encoded = <span>NULL</span>;
</span></span><span><span>  <span>size_t</span> encoded_bytes = <span>0</span>;
</span></span><span><span>  <span>us_base64_encode</span>((<span>uint8_t</span> *)input, <span>strlen</span>(input), &amp;encoded, &amp;encoded_bytes);
</span></span><span><span>  <span>printf</span>(<span>&#34;input:        %s</span><span>\n</span><span>&#34;</span>, input);
</span></span><span><span>  <span>printf</span>(<span>&#34;output:       %s</span><span>\n</span><span>&#34;</span>, encoded);
</span></span><span><span>  <span>printf</span>(<span>&#34;output bytes: %lu</span><span>\n</span><span>&#34;</span>, encoded_bytes);
</span></span><span><span>  <span>free</span>(encoded);
</span></span><span><span>}
</span></span></code></pre></div><p>I’ll compile it with gcc, a popular C compiler:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gcc src/test.c src/libs/base64.c -o /tmp/b64test
</span></span><span><span>In file included from src/libs/base64.h:31,
</span></span><span><span>                 from src/test.c:3:
</span></span><span><span>src/libs/tools.h: In <span>function</span> ‘us_signum_to_string’:
</span></span><span><span>src/libs/tools.h:194:34: warning: implicit declaration of <span>function</span> ‘sigabbrev_np’ [-Wimplicit-function-declaration]
</span></span><span><span>  <span>194</span> |         const char *const <span>name</span> = sigabbrev_np(signum);
</span></span><span><span>      |                                  ^~~~~~~~~~~~
</span></span></code></pre></div><p>Hmm, the code compiles, but I’m getting a lot of compiler warnings about a <code>tools.h</code> header that the uStreamer code includes.</p><p>If I look into <code>src/libs/tools.h</code>, I see that all the errors are around a single function: <a href="https://github.com/pikvm/ustreamer/blob/v5.45/src/libs/tools.h#L192-L210"><code>us_signum_to_string</code></a>. Let me see if I can just comment out that function to clear away the irrelevant warnings.</p><div><pre tabindex="0"><code data-lang="c"><span><span>
</span></span><span><span><span>/*
</span></span></span><span><span><span>DEBUG: Temporarily delete this function to get the build working again.
</span></span></span><span><span><span>INLINE char *us_signum_to_string(int signum) {
</span></span></span><span><span><span>...
</span></span></span><span><span><span>  return buf;
</span></span></span><span><span><span>}
</span></span></span><span><span><span>*/</span>
</span></span></code></pre></div><p>With the pesky <code>us_signum_to_string</code> function removed, I’ll try to compile build again:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gcc src/test.c src/libs/base64.c -o /tmp/b64test &amp;&amp; /tmp/b64test
</span></span><span><span>input:        hello, world!
</span></span><span><span>output:       <span>aGVsbG8sIHdvcmxkIQ</span>==
</span></span><span><span>output bytes: <span>21</span>
</span></span></code></pre></div><p>Hooray, no more compiler warnings.</p><p>If I were trying to compile all of uStreamer, I’d have to figure out how to get <code>us_signum_to_string</code> to compile. For this exercise, I’m just calling <code>us_base64_encode</code> from Zig, so I don’t need <code>us_signum_to_string</code>.</p><p>If I compare my <code>test.c</code> program’s output to my system’s built-in <code>base64</code> utility, I can verify that I’m producing the correct result:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ <span>printf</span> <span>&#39;hello, world!&#39;</span> | base64
</span></span><span><span><span>aGVsbG8sIHdvcmxkIQ</span>==
</span></span></code></pre></div><p>The complete example at this stage <a href="https://github.com/tiny-pilot/ustreamer/tree/zig-00-c-test">is on Github</a>.</p><h2 id="adding-zig-to-my-ustreamer-project-environment">Adding Zig to my uStreamer project environment<a href="#adding-zig-to-my-ustreamer-project-environment" arialabel="Anchor"> 🔗︎</a></h2><p>My favorite way of installing Zig is <a href="https://zero-to-nix.com/">with Nix</a>, as it allows me to switch Zig versions easily. Feel free to <a href="https://ziglang.org/learn/getting-started/">install Zig</a> any way you prefer.</p><p>I added the following <code>flake.nix</code> file to my project, which pulls Zig 0.11.0 into my environment:</p><div><pre tabindex="0"><code data-lang="nix"><span><span>{
</span></span><span><span>  description = <span>&#34;Dev environment for zig-c-simple&#34;</span>;
</span></span><span><span>
</span></span><span><span>  inputs = {
</span></span><span><span>    flake-utils.url = <span>&#34;github:numtide/flake-utils&#34;</span>;
</span></span><span><span>
</span></span><span><span>    <span># 0.11.0</span>
</span></span><span><span>    zig_dep.url = <span>&#34;github:NixOS/nixpkgs/46688f8eb5cd6f1298d873d4d2b9cf245e09e88e&#34;</span>;
</span></span><span><span>  };
</span></span><span><span>
</span></span><span><span>  outputs = { self, flake-utils, zig_dep }@inputs :
</span></span><span><span>    flake-utils.lib.eachDefaultSystem (system:
</span></span><span><span>    <span>let</span>
</span></span><span><span>      zig_dep = inputs.zig_dep.legacyPackages.<span>${</span>system<span>}</span>;
</span></span><span><span>    <span>in</span>
</span></span><span><span>    {
</span></span><span><span>      devShells.default = zig_dep.mkShell {
</span></span><span><span>        packages = [
</span></span><span><span>          zig_dep.zig
</span></span><span><span>        ];
</span></span><span><span>
</span></span><span><span>        shellHook = <span>&#39;&#39;
</span></span></span><span><span><span>          echo &#34;zig&#34; &#34;$(zig version)&#34;
</span></span></span><span><span><span>        &#39;&#39;</span>;
</span></span><span><span>      };
</span></span><span><span>    });
</span></span><span><span>}
</span></span></code></pre></div><p>From here, I can run <code>nix develop</code>, and I see that Nix 0.11.0 is available in my project environment:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># There&#39;s a weird quirk of Nix flakes that they have to be added to your git</span>
</span></span><span><span><span># repo.</span>
</span></span><span><span>$ git add flake.nix
</span></span><span><span>$ nix develop
</span></span><span><span>zig 0.11.0
</span></span></code></pre></div><h2 id="creating-a-zig-executable">Creating a Zig executable<a href="#creating-a-zig-executable" arialabel="Anchor"> 🔗︎</a></h2><p>The Zig compiler’s <code>init-exe</code> creates a boilerplate Zig application, so I’ll use it to create a simple Zig app within the uStreamer source tree:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig init-exe
</span></span><span><span>info: Created build.zig
</span></span><span><span>info: Created src/main.zig
</span></span><span><span>info: Next, try <span>`</span>zig build --help<span>`</span> or <span>`</span>zig build run<span>`</span>
</span></span></code></pre></div><p>If I try compiling and running the boilerplate Zig application, I see that everything works:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>All your codebase are belong to us.
</span></span><span><span>Run <span>`</span>zig build <span>test</span><span>`</span> to run the tests.
</span></span></code></pre></div><p>The uStreamer C file I want to call <a href="https://github.com/pikvm/ustreamer/blob/v5.45/src/libs/base64.h#L25-L27">depends on the C standard library</a>, so I need to make a small adjustment to my <code>build.zig</code> file to link against that library. While I’m adjusting, I’ll also replace the boilerplate binary name with <code>base64-encoder</code>:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>    </span><span>const</span><span> </span>exe<span> </span>=<span> </span>b.addExecutable(.{<span>
</span></span></span><span><span><span>        </span>.name<span> </span>=<span> </span><span>&#34;base64-encoder&#34;</span>,<span> </span><span>// Change binary name.
</span></span></span><span><span><span></span><span>        </span>.root_source_file<span> </span>=<span> </span>.{<span> </span>.path<span> </span>=<span> </span><span>&#34;src/main.zig&#34;</span><span> </span>},<span>
</span></span></span><span><span><span>        </span>.target<span> </span>=<span> </span>target,<span>
</span></span></span><span><span><span>        </span>.optimize<span> </span>=<span> </span>optimize,<span>
</span></span></span><span><span><span>    </span>});<span>
</span></span></span><span><span><span>    </span>exe.linkLibC();<span>               </span><span>// Link against C standard library.
</span></span></span><span><span><span></span><span>    </span>exe.addIncludePath(.{<span> </span>.path<span> </span>=<span> </span><span>&#34;src&#34;</span><span> </span>});<span>
</span></span></span></code></pre></div><h2 id="calling-ustreamer-code-from-zig">Calling uStreamer code from Zig<a href="#calling-ustreamer-code-from-zig" arialabel="Anchor"> 🔗︎</a></h2><p>Now, I want to call the <code>us_base64_encode</code> C function from Zig.</p><p>As a reminder, here’s the C function I’m trying to call from Zig, which I explained <a href="http://blog.local:1313/notes/zig-unit-test-c/#whats-the-simplest-c-function-in-ustreamer">above</a>:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// src/libs/base64.h
</span></span></span><span><span><span></span>
</span></span><span><span><span>void</span> <span>us_base64_encode</span>(<span>const</span> <span>uint8_t</span> *data, <span>size_t</span> size, <span>char</span> **encoded, <span>size_t</span> *allocated);
</span></span></code></pre></div><p>Figuring out how to translate between C types and Zig types turned out to be the hardest part of this process, as I’m still a Zig novice.</p><p>Here was my first attempt:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>// src/main.zig
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>const</span><span> </span>ustreamer<span> </span>=<span> </span><span>@cImport</span>({<span>
</span></span></span><span><span><span>    </span><span>@cInclude</span>(<span>&#34;libs/base64.c&#34;</span>);<span>
</span></span></span><span><span><span></span>});<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span>main()<span> </span>!<span>void</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>cEncoded:<span> </span>*<span>u8</span><span> </span>=<span> </span><span>undefined</span>;<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span>    </span><span>// WRONG: This doesn&#39;t compile.
</span></span></span><span><span><span></span><span>    </span>ustreamer.us_base64_encode(&amp;input,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>That yielded this compiler error:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>zig build-exe b64 Debug native: error: the following <span>command</span> failed with <span>1</span> compilation errors:
</span></span><span><span>...
</span></span><span><span>src/main.zig:17:32: error: expected <span>type</span> <span>&#39;[*c]const u8&#39;</span>, found <span>&#39;*const *const [13:0]u8&#39;</span>
</span></span><span><span>    ustreamer.us_base64_encode(&amp;input, input.len, &amp;cEncoded, &amp;allocatedSize);
</span></span><span><span>                               ^~~~~~
</span></span><span><span>src/main.zig:17:32: note: pointer <span>type</span> child <span>&#39;*const [13:0]u8&#39;</span> cannot cast into pointer <span>type</span> child <span>&#39;u8&#39;</span>
</span></span><span><span>/home/mike/ustreamer/zig-cache/o/9599bf4c636d23e50eddd1a55dd088ff/cimport.zig:1796:43: note: parameter <span>type</span> declared here
</span></span><span><span>pub <span>export</span> fn us_base64_encode(arg_data: [*c]const u8, arg_size: usize, arg_encoded: [*c][*c]u8, arg_allocated: [*c]usize) void {
</span></span></code></pre></div><p>I had trouble understanding this error at first because so much of it was unfamiliar.</p><p>The important bit of the compiler error above is <code>error: expected type &#39;[*c]const u8&#39;, found &#39;*const *const [13:0]u8&#39;</code>. It’s telling me that I tried to pass in a <code>*const *const [13:0]u8</code>, but Zig needs me to pass in <code>[*c]const u8</code>.</p><p>What does that mean?</p><h3 id="understanding-the-type-i-used">Understanding the type I used<a href="#understanding-the-type-i-used" arialabel="Anchor"> 🔗︎</a></h3><p>According to the Zig compiler, I passed in a parameter of type <code>&#39;*const *const [13:0]u8</code>. To understand what this means, I’ll go from right to left:</p><p><code>u8</code> is an unsigned byte, which is how Zig represents characters in a string.</p><p><code>[13:0]</code> means a null-terminated array. The <code>13</code> is the length of the array, which Zig calculates at compile-time. <code>:0</code> means that the array has an extra byte with a value of <code>0</code> to indicate the end of the string. For more details about the mechanics of null-terminated strings in Zig, see <a href="https://mtlynch.io/notes/zig-strings-call-c-code/">my previous post</a>.</p><p><code>*const</code> means a constant pointer. A pointer is an address in memory, and the <code>const</code> means that subsequent code may not reassign the variable.</p><p><code>*const *const</code> means a constant pointer to a constant pointer. In other words, <code>input</code> is a constant pointer to a string, so that means <code>&amp;input</code> is a constant pointer to a constant pointer.</p><h3 id="converting-a-zig-type-to-a-c-type">Converting a Zig type to a C type<a href="#converting-a-zig-type-to-a-c-type" arialabel="Anchor"> 🔗︎</a></h3><p>Okay, now I understand how Zig views the string that I passed. What did Zig <em>want</em> me to pass as the <code>input</code> type?</p><div><pre tabindex="0"><code data-lang="text"><span><span>expected type &#39;[*c]const u8&#39;
</span></span></code></pre></div><p>What the heck does <code>[*c]</code> mean?</p><p>This was surprisingly hard to figure out. I eventually pieced it together from a few different sources.</p><p>Here’s the official Zig documentation:</p><blockquote><h3 id="c-pointers">C Pointers<a href="#c-pointers" arialabel="Anchor"> 🔗︎</a></h3><p>This type is to be avoided whenever possible. The only valid reason for using a C pointer is in auto-generated code from translating C code.</p><p>When importing C header files, it is ambiguous whether pointers should be translated as single-item pointers (*T) or many-item pointers ([*]T). C pointers are a compromise so that Zig code can utilize translated header files directly.</p><p><a href="https://ziglang.org/documentation/0.11.0/#C-Pointers">https://ziglang.org/documentation/0.11.0/#C-Pointers</a></p></blockquote><p>I didn’t understand the documentation, as it seemed to be warning against using C pointers rather than explaining what they are.</p><p>More <a href="https://kagi.com">Kagi</a>‘ing led me to this explanation on reddit, which I found more accessible:</p><blockquote><p><code>[*c]T</code> is just a C pointer to type T, it says that it doesn’t know whether there are multiple elements in that pointer or not. There could be, there could not be. We also don’t know the length of it (it’s not a slice which has pointer+length, it’s just a pointer). And if there are multiple elements, we don’t know if it is say null-terminated or not.</p><p><a href="https://www.reddit.com/r/Zig/comments/11uqo84/comment/jcplxiz/">-/u/slimsag on reddit</a></p></blockquote><p>Okay, that makes more sense.</p><p>In C, a pointer is just a memory address and a data type. A C type of <code>char*</code> could point to a single character like <code>&#39;A&#39;</code>, or it could point to the first character in a sequence like <code>&#34;ABCD&#34;</code>.</p><p>In Zig, a pointer to an array is a different type than a pointer to a single element. When Zig has to infer a data type from C code, Zig can’t tell whether the C code is referring to a single element or an array, so the C pointer type (<code>[*c]T</code>) is Zig’s way of saying, “I don’t know. I got this from C.”</p><p>Through trial and error, I figured out that Zig wanted me to get a pointer to <code>input</code> by referencing <code>input.ptr</code> rather than using the address-of operator <code>&amp;</code>.</p><p>This Zig snippet shows the difference between the <code>.ptr</code> and <code>&amp;</code>:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span></span>std.debug.print(<span>&#34;input     is type {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{<span>@typeName</span>(<span>@TypeOf</span>(input))});<span>
</span></span></span><span><span><span></span>std.debug.print(<span>&#34;&amp;input    is type {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{<span>@typeName</span>(<span>@TypeOf</span>(&amp;input))});<span>
</span></span></span><span><span><span></span>std.debug.print(<span>&#34;input.ptr is type {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{<span>@typeName</span>(<span>@TypeOf</span>(input.ptr))});<span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="text"><span><span>input     is type *const [13:0]u8
</span></span><span><span>&amp;input    is type *const *const [13:0]u8
</span></span><span><span>input.ptr is type [*]const u8
</span></span></code></pre></div><p>Recall that Zig wants me to pass <code>us_base64_encode</code> a parameter of type <code>[*c]const u8</code>, so it looks like it can convert <code>[*]const u8</code> to that type.</p><p>Okay, let me try calling <code>us_base64_encode</code> again:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span></span><span>var</span><span> </span>cEncoded:<span> </span>*<span>u8</span><span> </span>=<span> </span><span>undefined</span>;<span>
</span></span></span><span><span><span></span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span></span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span></code></pre></div><p>That gives me:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>zig build-exe b64 Debug native: error: the following <span>command</span> failed with <span>1</span> compilation errors:
</span></span><span><span>...
</span></span><span><span>src/main.zig:12:54: error: expected <span>type</span> <span>&#39;[*c][*c]u8&#39;</span>, found <span>&#39;**u8&#39;</span>
</span></span><span><span>    ustreamer.us_base64_encode(input.ptr, input.len, &amp;cEncoded, &amp;allocatedSize);
</span></span><span><span>                                                     ^~~~~~~~~
</span></span></code></pre></div><p>Progress!</p><p>The code still doesn’t compile, but Zig is now complaining about the third parameter instead of the first. That at least tells me that I’ve supplied the expected types for the first two parameters.</p><h3 id="translating-the-output-parameters-into-zig">Translating the output parameters into Zig<a href="#translating-the-output-parameters-into-zig" arialabel="Anchor"> 🔗︎</a></h3><p>The compiler error also contains a helpful bit of information for calling into the C implementation of <code>us_base64_encode</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>pub <span>export</span> fn us_base64_encode(arg_data: [*c]const u8, arg_size: usize, arg_encoded: [*c][*c]u8, arg_allocated: [*c]usize) void {
</span></span></code></pre></div><p>That’s the signature of the C function translated into Zig, so Zig is telling me exactly the types I need to pass in to call the function.</p><p>Alternatively, I can use the <code>zig translate-c</code> utility to translate this C function signature into Zig. This effectively gives the same results as the compiler error above, but it preserves the original parameter names, whereas the compiler error prefixes them with <code>arg_</code>.</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># We add --library c to let Zig know the code depends on libc.</span>
</span></span><span><span>$ zig translate-c src/libs/base64.h --library c | grep us_base64
</span></span><span><span>pub extern fn us_base64_encode(data: [*c]const u8, size: usize, encoded: [*c][*c]u8, allocated: [*c]usize) void;
</span></span></code></pre></div><p>From more trial and error, I eventually guessed my way to these semantics for calling <code>us_base64_encode</code> from Zig:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span></span><span>var</span><span> </span>cEncoded:<span> </span>[*c]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span></span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span></span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span></code></pre></div><p>And it compiles successfully!</p><h3 id="can-i-do-better-than-c-pointers">Can I do better than C pointers?<a href="#can-i-do-better-than-c-pointers" arialabel="Anchor"> 🔗︎</a></h3><p>Recall what the Zig documentation <a href="https://ziglang.org/documentation/0.11.0/#C-Pointers">said about C pointers</a>:</p><blockquote><p>The only valid reason for using a C pointer is in auto-generated code…</p></blockquote><p>I’m writing this code by hand, so I guess I shouldn’t be using a type reserved for auto-generated code.</p><p>I know that the third parameter to <code>us_base64_encode</code> is a pointer to a null-terminated string. How do I represent that in Zig?</p><p>My first thought was to do this:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span><span> </span>cEncoded:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>undefined</span>;<span>
</span></span></span><span><span><span></span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span></code></pre></div><p>That seemed reasonable. I know that <code>us_base64_encode</code> will populate <code>cEncoded</code> with a string, and <code>[*:0]u8</code> represents a null-terminated string of unkown length. But when I compile, Zig said no:</p><div><pre tabindex="0"><code data-lang="text"><span><span>error: expected type &#39;[*c][*c]u8&#39;, found &#39;*[*:0]u8&#39;
</span></span></code></pre></div><p>I was stumped, so I asked for help on <a href="https://ziggit.dev/">Ziggit</a>, a Zig discussion forum. Within an hour, another user <a href="https://ziggit.dev/t/improving-on-c-u8-when-calling-a-c-function-that-allocates-a-string/2489/4?u=mtlynch">showed me a solution</a>:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span><span> </span>cEncoded:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span></span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span></code></pre></div><p>The issue was that in C, a type of <code>char**</code> can be <code>null</code>, whereas a Zig type of <code>[*:0]u8</code> cannot be null. That’s why Zig refused to let me pass in my previous attempt.</p><p>Breaking down the correct type of <code>?[*:0]u8</code>, I see that it’s:</p><ul><li>a null-terminated slice of bytes (<code>:0]u8</code>)</li><li>of unknown length (<code>[*</code>)</li><li>that <a href="https://ziglang.org/documentation/0.11.0/#Optionals">might be null</a> (<code>?</code>)</li></ul><p>The new type allows me to compile the code, but if I try to print the value of <code>cEncoded</code>, I get what appears to be a memory address rather than a string:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>input:       hello, world!
</span></span><span><span>output:      u8@2b12a0      <span># &lt;&lt; whoops, not what I expected</span>
</span></span><span><span>output size: <span>21</span>
</span></span></code></pre></div><p>In order to convert <code>cEncoded</code> back to a printable string, I have to unwrap it from its optional variable by verifying in code that its value is non-null:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span><span> </span>cEncoded:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span></span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span></span><span>const</span><span> </span>output:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncoded<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span>...<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span>std.debug.print(<span>&#34;output:      {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{output});<span>
</span></span></span></code></pre></div><p>And then it prints the correct result:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>input: hello, world!
</span></span><span><span>output: <span>aGVsbG8sIHdvcmxkIQ</span>==
</span></span><span><span>output size: <span>21</span>
</span></span></code></pre></div><h3 id="completing-the-call-to-c-from-zig">Completing the call to C from Zig<a href="#completing-the-call-to-c-from-zig" arialabel="Anchor"> 🔗︎</a></h3><p>At this point, I now have complete working code for calling the C <code>us_base64_encode</code> from Zig. Here’s the full <code>src/main.zig</code> file:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>// src/main.zig
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>const</span><span> </span>std<span> </span>=<span> </span><span>@import</span>(<span>&#34;std&#34;</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Import the base64 implementation from uStreamer&#39;s C source file.
</span></span></span><span><span><span></span><span>const</span><span> </span>ustreamer<span> </span>=<span> </span><span>@cImport</span>({<span>
</span></span></span><span><span><span>    </span><span>@cInclude</span>(<span>&#34;libs/base64.c&#34;</span>);<span>
</span></span></span><span><span><span></span>});<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span>main()<span> </span>!<span>void</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>// Create a standard Zig string.
</span></span></span><span><span><span></span><span>    </span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Create variables to store the ouput parameters of us_base64_encode.
</span></span></span><span><span><span></span><span>    </span><span>var</span><span> </span>cEncoded:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Call the uStreamer C function from Zig.
</span></span></span><span><span><span></span><span>    </span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Get the output as a non-optional type.
</span></span></span><span><span><span></span><span>    </span><span>const</span><span> </span>output:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncoded<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Free the memory that the C function allocated when this function exits.
</span></span></span><span><span><span></span><span>    </span><span>defer</span><span> </span>std.c.free(cEncoded);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Print the input and output of the base64 encode operation.
</span></span></span><span><span><span></span><span>    </span>std.debug.print(<span>&#34;input:       {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{input});<span>
</span></span></span><span><span><span>    </span>std.debug.print(<span>&#34;output:      {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{output});<span>
</span></span></span><span><span><span>    </span>std.debug.print(<span>&#34;output size: {d}</span><span>\n</span><span>&#34;</span>,<span> </span>.{allocatedSize});<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>input:       hello, world!
</span></span><span><span>output:      <span>aGVsbG8sIHdvcmxkIQ</span>==
</span></span><span><span>output size: <span>21</span>
</span></span></code></pre></div><p>Great! That worked. And the results are identical to <a href="#whats-the-simplest-c-function-in-ustreamer">my C implementation above</a>.</p><p>The complete example at this stage <a href="https://github.com/tiny-pilot/ustreamer/tree/zig-10-simple-exe">is on Github</a>.</p><h2 id="creating-a-zig-wrapper-for-the-native-c-implementation">Creating a Zig wrapper for the native C implementation<a href="#creating-a-zig-wrapper-for-the-native-c-implementation" arialabel="Anchor"> 🔗︎</a></h2><p>At this point, I can successfully call the C <code>us_base64_encode</code> function from Zig, but the code is a bit messy. Most of my <code>main()</code> function is dealing with translating values to and from C code.</p><p>One way to improve the code is to add a Zig wrapper function for <code>us_base64_encode</code>. That way, I could encapsulate all the Zig to C interop logic, and callers of my wrapper wouldn’t have to know or care that I’m calling C.</p><p>What should my wrapper function look like?</p><p>It should accept arbitrary bytes and return a null-terminated string, so the function signature should look something like this:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span><span> </span>base64Encode(data:<span> </span>[]<span>const</span><span> </span><span>u8</span>)<span> </span>[:<span>0</span>]<span>u8</span><span> </span>{...}<span>
</span></span></span></code></pre></div><p>I already have the first few lines of my implementation based on my <code>main()</code> function <a href="#completing-the-call-to-c-from-zig">above</a>:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span><span> </span>base64Encode(data:<span> </span>[]<span>const</span><span> </span><span>u8</span>)<span> </span>[:<span>0</span>]<span>u8</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>var</span><span> </span>cEncoded:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span>  </span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span>ustreamer.us_base64_encode(data.ptr,<span> </span>data.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>// TODO: Complete the implementation.
</span></span></span></code></pre></div><h3 id="whos-responsible-for-freeing-the-memory-c-allocated">Who’s responsible for freeing the memory C allocated?<a href="#whos-responsible-for-freeing-the-memory-c-allocated" arialabel="Anchor"> 🔗︎</a></h3><p>There’s a problem I haven’t addressed yet. <code>us_base64_encode</code> allocated memory into the <code>cEncoded</code> pointer. The caller is responsible for either freeing that memory or passing off that responsibility to its callers.</p><p>Normally, it’s fine for a function to declare that the caller is responsible for freeing an output value, but this case is a little trickier. This isn’t a normal Zig-allocated memory buffer — it’s a C-allocated buffer that requires a special free function (<code>std.c.free</code>).</p><p>I want to abstract away the C implementation details, so callers shouldn’t have to use a C-specific memory freeing function.</p><p>That tells me what I need to do to complete the implementation of my Zig wrapper. I use <code>defer std.c.free</code> to free the C-allocated memory, and then I’ll need to copy it into a Zig-managed slice:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span><span> </span>base64Encode(data:<span> </span>[]<span>const</span><span> </span><span>u8</span>)<span> </span>![:<span>0</span>]<span>u8</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>var</span><span> </span>cEncodedOptional:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span>  </span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span>ustreamer.us_base64_encode(data.ptr,<span> </span>data.len,<span> </span>&amp;cEncodedOptional,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span>  </span><span>const</span><span> </span>cEncoded:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncodedOptional<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>// Get the output as a non-optional type.
</span></span></span><span><span><span></span><span>  </span><span>const</span><span> </span>output:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncoded<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>// Free the C-allocated memory buffer before exiting the function.
</span></span></span><span><span><span></span><span>  </span><span>defer</span><span> </span>std.c.free(cEncoded);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>// TODO: Copy the contents of cEncoded into a [:0]u8 buffer.
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><h3 id="converting-a-c-string-to-a-zig-string">Converting a C string to a Zig string<a href="#converting-a-c-string-to-a-zig-string" arialabel="Anchor"> 🔗︎</a></h3><p>At this point, I’ve got the string as a <code>[*:0]u8</code> (unknown length, zero-terminated Zig slice), but I want to return <code>[:0]u8</code> (length-aware, null-terminated Zig slice). How do I convert a C-style string to a Zig slice?</p><p>In <a href="https://mtlynch.io/notes/zig-strings-call-c-code/#improving-the-wrapper-with-zig-managed-buffers">my previous post</a>, I converted a C string to a Zig string with this process:</p><ol><li>Create a Zig slice of the C string using <a href="https://ziglang.org/documentation/0.11.0/std/#A;std:mem.span"><code>std.mem.span</code></a>.</li><li>Use <a href="https://ziglang.org/documentation/0.11.0/std/#A;std:mem.Allocator.dupeZ"><code>allocator.dupeZ</code></a> to copy the contents of the slice into a newly allocated Zig slice.</li></ol><p>That process would work here, but I’d be doing a useless work in step (1). <code>std.mem.span</code> has to iterate the string to find the null terminator. In this code, I already know where the null terminator is because <code>us_base64_encode</code> stores that information in the <code>allocatedSize</code> parameter.</p><p>Instead, I create a length-aware Zig slice of the <code>cEncoded</code> slice like this:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>// The allocatedSize includes the null terminator, so subtract 1 to get the
</span></span></span><span><span><span>// number of non-null characters in the string.
</span></span></span><span><span><span></span><span>const</span><span> </span>cEncodedLength<span> </span>=<span> </span>allocatedSize<span> </span>-<span> </span><span>1</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Convert cEncoded (unknown length slice) to a length-aware slice.
</span></span></span><span><span><span></span><span>const</span><span> </span>outputLengthAware:<span> </span>[:<span>0</span>]<span> </span>=<span> </span>cEncoded[<span>0</span>..cEncodedLength<span> </span>:<span>0</span>];<span>
</span></span></span></code></pre></div><p>At this point, I can complete the implementation of my wrapper function:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span><span> </span>base64Encode(allocator:<span> </span>std.mem.Allocator,<span> </span>data:<span> </span>[]<span>const</span><span> </span><span>u8</span>)<span> </span>![:<span>0</span>]<span>u8</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>cEncoded:<span> </span>[*c]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span>ustreamer.us_base64_encode(data.ptr,<span> </span>data.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Get the output as a non-optional type.
</span></span></span><span><span><span></span><span>    </span><span>const</span><span> </span>output:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncoded<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Free the C-allocated memory buffer before exiting the function.
</span></span></span><span><span><span></span><span>    </span><span>defer</span><span> </span>std.c.free(cEncoded);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// The allocatedSize includes the null terminator, so subtract 1 to get the
</span></span></span><span><span><span></span><span>    </span><span>// number of non-null characters in the string.
</span></span></span><span><span><span></span><span>    </span><span>const</span><span> </span>cEncodedLength<span> </span>=<span> </span>allocatedSize<span> </span>-<span> </span><span>1</span>;<span>
</span></span></span><span><span><span>    </span><span>return</span><span> </span>allocator.dupeZ(<span>u8</span>,<span> </span>cEncoded[<span>0</span>..cEncodedLength<span> </span>:<span>0</span>]);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>To call <code>dupeZ</code>, I need a Zig allocator, so I adjusted the semantics of my <code>base64Encode</code> wrapper to accept a <code>std.mem.Allocator</code> type.</p><h3 id="tying-it-all-together">Tying it all together<a href="#tying-it-all-together" arialabel="Anchor"> 🔗︎</a></h3><p>With my Zig wrapper in place, it’s now trivial to exercise the C <code>us_base64_encode</code> function from Zig.</p><p>Recall that my previous code looked like this:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span></span><span>var</span><span> </span>cEncoded:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span></span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span></span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span></span><span>const</span><span> </span>output:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncoded<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span></span><span>defer</span><span> </span>std.c.free(cEncoded);<span>
</span></span></span></code></pre></div><p>With my Zig wrapper, the semantics simplify to two lines:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span>output<span> </span>=<span> </span><span>try</span><span> </span>base64Encode(allocator,<span> </span><span>&#34;hello, world!&#34;</span>);<span>
</span></span></span><span><span><span></span><span>defer</span><span> </span>allocator.free(output);<span>
</span></span></span></code></pre></div><p>Here’s the full example:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span>std<span> </span>=<span> </span><span>@import</span>(<span>&#34;std&#34;</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Import the base64 implementation from uStreamer&#39;s C source file.
</span></span></span><span><span><span></span><span>const</span><span> </span>ustreamer<span> </span>=<span> </span><span>@cImport</span>({<span>
</span></span></span><span><span><span>    </span><span>@cInclude</span>(<span>&#34;libs/base64.c&#34;</span>);<span>
</span></span></span><span><span><span></span>});<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span><span> </span>base64Encode(allocator:<span> </span>std.mem.Allocator,<span> </span>data:<span> </span>[]<span>const</span><span> </span><span>u8</span>)<span> </span>![:<span>0</span>]<span>u8</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>cEncodedOptional:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span>ustreamer.us_base64_encode(data.ptr,<span> </span>data.len,<span> </span>&amp;cEncodedOptional,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>cEncoded:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncodedOptional<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span>    </span><span>defer</span><span> </span>std.c.free(cEncodedOptional);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>cEncodedLength<span> </span>=<span> </span>allocatedSize<span> </span>-<span> </span><span>1</span>;<span>
</span></span></span><span><span><span>    </span><span>return</span><span> </span>allocator.dupeZ(<span>u8</span>,<span> </span>cEncoded[<span>0</span>..cEncodedLength<span> </span>:<span>0</span>]);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span>main()<span> </span>!<span>void</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>gpa<span> </span>=<span> </span>std.heap.GeneralPurposeAllocator(.{}){};<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>allocator<span> </span>=<span> </span>gpa.allocator();<span>
</span></span></span><span><span><span>    </span><span>defer</span><span> </span>_<span> </span>=<span> </span>gpa.deinit();<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>output<span> </span>=<span> </span><span>try</span><span> </span>base64Encode(allocator,<span> </span>input);<span>
</span></span></span><span><span><span>    </span><span>defer</span><span> </span>allocator.free(output);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Print the input and output of the base64 encode operation.
</span></span></span><span><span><span></span><span>    </span>std.debug.print(<span>&#34;input:       {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{input});<span>
</span></span></span><span><span><span>    </span>std.debug.print(<span>&#34;output:      {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{output});<span>
</span></span></span><span><span><span>    </span>std.debug.print(<span>&#34;output size: {d}</span><span>\n</span><span>&#34;</span>,<span> </span>.{output.len});<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>input:       hello, world!
</span></span><span><span>output:      <span>aGVsbG8sIHdvcmxkIQ</span>==
</span></span><span><span>output size: <span>20</span>
</span></span></code></pre></div><p>The output size is now <code>20</code> instead of <code>21</code> because the underlying data type changed. Previously, I was printing the output size parameter that <code>us_base64_encode</code> populated, which included the null terminator. Now, I’m using the <code>.len</code> property of the output string, which does not include the null terminator.</p><p>The complete example at this stage <a href="https://github.com/tiny-pilot/ustreamer/tree/zig-20-wrapper-fn">is on Github</a>.</p><h2 id="creating-the-first-unit-test">Creating the first unit test<a href="#creating-the-first-unit-test" arialabel="Anchor"> 🔗︎</a></h2><p>Now that I can call the C <code>us_base64_encode</code> function through a convenient Zig wrapper, I’m ready to start writing unit tests to verify that the C implementation is correct.</p><p>The first thing I need to do is make a couple of small adjustments to my <code>build.zig</code> file so that the unit tests can access libc and uStreamer’s C source files:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>// build.zig
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>unit_tests<span> </span>=<span> </span>b.addTest(.{<span>
</span></span></span><span><span><span>        </span>.root_source_file<span> </span>=<span> </span>.{<span> </span>.path<span> </span>=<span> </span><span>&#34;src/main.zig&#34;</span><span> </span>},<span>
</span></span></span><span><span><span>        </span>.target<span> </span>=<span> </span>target,<span>
</span></span></span><span><span><span>        </span>.optimize<span> </span>=<span> </span>optimize,<span>
</span></span></span><span><span><span>    </span>});<span>
</span></span></span><span><span><span>    </span>unit_tests.linkLibC();<span>                          </span><span>// Link against libc.
</span></span></span><span><span><span></span><span>    </span>unit_tests.addIncludePath(.{<span> </span>.path<span> </span>=<span> </span><span>&#34;src&#34;</span><span> </span>});<span>  </span><span>// Search src path for includes.
</span></span></span></code></pre></div><p>I’ve already done the heavy lifting here by writing my Zig wrapper function, so writing my first unit test is straightforward:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>// src/main.zig
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>test</span><span> </span><span>&#34;encode simple string as base64&#34;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>allocator<span> </span>=<span> </span>std.testing.allocator;<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>actual<span> </span>=<span> </span><span>try</span><span> </span>base64Encode(allocator,<span> </span><span>&#34;hello, world!&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>defer</span><span> </span>allocator.free(actual);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>std.testing.expectEqualStrings(<span>&#34;aGVsbG8sIHdvcmxkIQ==&#34;</span>,<span> </span>actual);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>The <code>zig build test</code> command runs my unit test:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build <span>test</span> --summary all
</span></span><span><span>Build Summary: 3/3 steps succeeded; 1/1 tests passed
</span></span><span><span><span>test</span> success
</span></span><span><span>└─ run <span>test</span> <span>1</span> passed 1ms MaxRSS:1M
</span></span><span><span>   └─ zig <span>test</span> Debug native success 2s MaxRSS:211M
</span></span></code></pre></div><p>Success! My first unit test is working and exercising the C code.</p><p>The complete example at this stage <a href="https://github.com/tiny-pilot/ustreamer/tree/zig-30-unit-test">is on Github</a>.</p><h2 id="checking-for-false-positive-test-results">Checking for false positive test results<a href="#checking-for-false-positive-test-results" arialabel="Anchor"> 🔗︎</a></h2><p>My unit test is succeeding, but I want to ensure that the test is truly executing the C code and not just returning a false positive. I can verify this by intentionally introducing a bug into the C code.</p><p>This is a snippet from the implementation of <a href="https://github.com/pikvm/ustreamer/blob/v5.45/src/libs/base64.c"><code>base64.c</code></a>:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#    define OCTET(_name) unsigned _name = (data_index &lt; size ? (uint8_t)data[data_index++] : 0)
</span></span></span><span><span><span></span>    <span>OCTET</span>(octet_a);
</span></span><span><span>    <span>OCTET</span>(octet_b);
</span></span><span><span>    <span>OCTET</span>(octet_c);
</span></span><span><span><span>#    undef OCTET
</span></span></span></code></pre></div><p>Let me try swapping the order of these two lines:</p><div><pre tabindex="0"><code data-lang="c"><span><span>    <span>OCTET</span>(octet_a);
</span></span><span><span>    <span>OCTET</span>(octet_c); <span>// I&#39;ve swapped these
</span></span></span><span><span><span></span>    <span>OCTET</span>(octet_b); <span>// two lines.
</span></span></span></code></pre></div><p>And here’s what happens when I try re-running my unit test on the C function after my tampering:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build <span>test</span> --summary all
</span></span><span><span>run test: error: <span>&#39;test.encode simple string as base64&#39;</span> failed: ====== expected this output: =========
</span></span><span><span><span>aGVsbG8sIHdvcmxkIQ</span>==␃
</span></span><span><span>
</span></span><span><span>======== instead found this: =========
</span></span><span><span><span>aGxlbCxvIG93cmRsIQ</span>==␃
</span></span></code></pre></div><p>Cool, the test works!</p><p>When I introduced a bug into <code>us_base64_encode</code>, my test failed and revealed the bug.</p><h2 id="adding-multiple-unit-tests">Adding multiple unit tests<a href="#adding-multiple-unit-tests" arialabel="Anchor"> 🔗︎</a></h2><p>I’d like to extend my single test case into many test cases to increase my confidence that I’m exercising more of the C function’s logic.</p><p>Half of the lines in my first unit test were boilerplate around managing memory, so I’d like to avoid repeating that for each test. I wrote a utility function to capture the boilerplate:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span><span> </span>testBase64Encode(<span>
</span></span></span><span><span><span>    </span>input:<span> </span>[]<span>const</span><span> </span><span>u8</span>,<span>
</span></span></span><span><span><span>    </span>expected:<span> </span>[:<span>0</span>]<span>const</span><span> </span><span>u8</span>,<span>
</span></span></span><span><span><span></span>)<span> </span>!<span>void</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>allocator<span> </span>=<span> </span>std.testing.allocator;<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>actual<span> </span>=<span> </span><span>try</span><span> </span>base64Encode(allocator,<span> </span>input);<span>
</span></span></span><span><span><span>    </span><span>defer</span><span> </span>allocator.free(actual);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>std.testing.expectEqualStrings(expected,<span> </span>actual);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>My test utility function allows me to add new tests easily:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>test</span><span> </span><span>&#34;encode strings as base64&#34;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(<span>&#34;&#34;</span>,<span> </span><span>&#34;&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(<span>&#34;h&#34;</span>,<span> </span><span>&#34;aA==&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(<span>&#34;he&#34;</span>,<span> </span><span>&#34;aGU=&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(<span>&#34;hel&#34;</span>,<span> </span><span>&#34;aGVs&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(<span>&#34;hell&#34;</span>,<span> </span><span>&#34;aGVsbA==&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(<span>&#34;hello, world!&#34;</span>,<span> </span><span>&#34;aGVsbG8sIHdvcmxkIQ==&#34;</span>);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>test</span><span> </span><span>&#34;encode raw bytes as base64&#34;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(&amp;[_]<span>u8</span>{<span>0</span>},<span> </span><span>&#34;AA==&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(&amp;[_]<span>u8</span>{<span> </span><span>0</span>,<span> </span><span>0</span><span> </span>},<span> </span><span>&#34;AAA=&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(&amp;[_]<span>u8</span>{<span> </span><span>0</span>,<span> </span><span>0</span>,<span> </span><span>0</span><span> </span>},<span> </span><span>&#34;AAAA&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(&amp;[_]<span>u8</span>{<span>255</span>},<span> </span><span>&#34;/w==&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(&amp;[_]<span>u8</span>{<span> </span><span>255</span>,<span> </span><span>255</span><span> </span>},<span> </span><span>&#34;//8=&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(&amp;[_]<span>u8</span>{<span> </span><span>255</span>,<span> </span><span>255</span>,<span> </span><span>255</span><span> </span>},<span> </span><span>&#34;////&#34;</span>);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build <span>test</span> --summary all
</span></span><span><span>Build Summary: 3/3 steps succeeded; 2/2 tests passed
</span></span><span><span><span>test</span> success
</span></span><span><span>└─ run <span>test</span> <span>2</span> passed 2ms MaxRSS:2M
</span></span><span><span>   └─ zig <span>test</span> Debug native success 2s MaxRSS:195M
</span></span></code></pre></div><p>The complete example at this stage <a href="https://github.com/tiny-pilot/ustreamer/tree/zig-40-multi-test">is on Github</a>.</p><h2 id="wrap-up">Wrap up<a href="#wrap-up" arialabel="Anchor"> 🔗︎</a></h2><p>Because of Zig’s excellent interoperability with C, it’s possible to add unit tests to an existing C application without modifying any of the C code or build process.</p><p>In the example I showed, the C code doesn’t know about Zig at all, and it continues to work as-is with no changes to its existing <code>Makefile</code>.</p><p>I found this exercise a useful way of learning more about both the Zig language and the C code I’m testing.</p><hr/><p><em>Thanks to the Ziggit community for <a href="https://ziggit.dev/t/improving-on-c-u8-when-calling-a-c-function-that-allocates-a-string/2489?u=mtlynch">their help with this blog post</a>. Excerpts from uStreamer are used under <a href="https://github.com/pikvm/ustreamer/blob/v5.45/LICENSE">the GPLv3 license</a>.</em></p></div></div>
  </body>
</html>
