<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mtlynch.io/notes/zig-unit-test-c/">Original</a>
    <h1>Using Zig to Unit Test a C Application</h1>
    
    <div id="readability-page-1" class="page"><div><p><a href="https://ziglang.org/">Zig</a> is a new, independently developed low-level programming language. It‚Äôs a modern reimagining of C that attempts to retain C‚Äôs performance while embracing improvements from the last 30 years of tooling and language design.</p><p>Zig makes calling into C code easier than any other language I‚Äôve used. Zig also treats unit testing as a first-class feature, which the C language certainly does not.</p><p>These two properties of Zig create an interesting opportunity: Zig allows you to add unit tests to existing C code. You can do this without rewriting any of your C code or build logic.</p><p>To demonstrate how to use Zig to test existing C code, I added unit tests to a real-world C application that I use daily.</p><h2 id="the-real-world-c-application-ustreamer">The real-world C application: uStreamer<a href="#the-real-world-c-application-ustreamer" arialabel="Anchor"> üîóÔ∏é</a></h2><p>For the past three years, I‚Äôve been working on <a href="https://tinypilotkvm.com">TinyPilot</a>, an open-source KVM over IP. TinyPilot allows you to <a href="https://mtlynch.io/tinypilot">plug a Raspberry Pi into any computer</a> and then control that computer remotely.</p><p>To stream the target computer‚Äôs display, TinyPilot uses <a href="https://github.com/pikvm/ustreamer">uStreamer</a>, a video streaming utility that‚Äôs optimized for Raspberry Pi‚Äôs hardware.</p><figure><a href="https://mtlynch.io/notes/zig-unit-test-c/ustreamer-display.webp"><img sizes="(min-width: 768px) 800px, 98vw" srcset="https://d33wubrfki0l68.cloudfront.net/62c88af50185a1053610a8189ff937dfba1e6da5/34bd9/notes/zig-unit-test-c/ustreamer-display_huc9be7d30c6e5a82d20477fdf5077c027_132828_300x0_resize_q90_h2_lanczos_2.webp 300w,
https://d33wubrfki0l68.cloudfront.net/cd5d701b130b5c46c52f10cadadae9b008a21c78/ef6b7/notes/zig-unit-test-c/ustreamer-display_huc9be7d30c6e5a82d20477fdf5077c027_132828_600x0_resize_q90_h2_lanczos_2.webp 600w,
https://d33wubrfki0l68.cloudfront.net/b5d04354a95ae6a6f623813514dc2cb0cff846eb/e868d/notes/zig-unit-test-c/ustreamer-display_huc9be7d30c6e5a82d20477fdf5077c027_132828_800x0_resize_q90_h2_lanczos_2.webp 800w,
https://d33wubrfki0l68.cloudfront.net/e0a7e07dc7688ee160f48766d808364e68e30640/c6b56/notes/zig-unit-test-c/ustreamer-display_huc9be7d30c6e5a82d20477fdf5077c027_132828_1200x0_resize_q90_h2_lanczos_2.webp 1200w,
https://d33wubrfki0l68.cloudfront.net/c9f820c017c547652186859d92758dca2d497225/4a9b1/notes/zig-unit-test-c/ustreamer-display.webp 1400w" src="https://d33wubrfki0l68.cloudfront.net/c9f820c017c547652186859d92758dca2d497225/4a9b1/notes/zig-unit-test-c/ustreamer-display.webp" alt="Screenshot of TinyPilot in a browser window displaying a Dell boot screen" loading="lazy"/></a><figcaption><p>TinyPilot uses the C uStreamer application to stream video</p></figcaption></figure><p>I‚Äôve been working with uStreamer for several years, but I find the codebase difficult to approach. It‚Äôs implemented in C, and it doesn‚Äôt have any automated tests.</p><p>I learn best by tinkering with code, so exercising uStreamer‚Äôs C code through Zig feels like a good way to learn more about both uStreamer and Zig.</p><h2 id="getting-the-ustreamer-source-code">Getting the uStreamer source code<a href="#getting-the-ustreamer-source-code" arialabel="Anchor"> üîóÔ∏é</a></h2><p>To begin, I‚Äôll grab the uStreamer source code. The latest release as of this writing is <code>v5.45</code>, so I‚Äôll grab that version:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>USTREAMER_VERSION</span>=<span>&#39;v5.45&#39;</span>
</span></span><span><span>git clone <span>\
</span></span></span><span><span><span></span>  --branch <span>&#34;</span><span>${</span><span>USTREAMER_VERSION</span><span>}</span><span>&#34;</span> <span>\
</span></span></span><span><span><span></span>  https://github.com/pikvm/ustreamer.git
</span></span></code></pre></div><h2 id="whats-the-simplest-c-function-in-ustreamer">What‚Äôs the simplest C function in uStreamer?<a href="#whats-the-simplest-c-function-in-ustreamer" arialabel="Anchor"> üîóÔ∏é</a></h2><p>For this exercise, the challenge is going to be using Zig, so I want the C part to be as simple as possible.</p><p>I want to find a dead simple function in uStreamer‚Äôs C code ‚Äî something that I can feed some input, and it gives me some output that I can inspect easily.</p><p>Scanning through the filenames, I noticed <a href="https://github.com/pikvm/ustreamer/blob/v5.45/src/libs/base64.c"><code>base64.c</code></a>. That sounded promising. I know that <a href="https://en.wikipedia.org/wiki/Base64">base64</a> is a scheme for encoding arbitrary data as a printable string.</p><p>For example, if I read 10 bytes from <code>/dev/random</code> into my terminal, I get some unprintable bytes:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ head -c <span>10</span> /dev/random &gt; /tmp/output &amp;&amp; cat /tmp/output
</span></span><span><span>VÔøΩ1AÔøΩÔøΩÔøΩÔøΩÔøΩb
</span></span></code></pre></div><p>If I encode the data as base64, I get clean, printable charcters:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ base64 &lt; /tmp/output
</span></span><span><span><span>Vo8xQbWmnsLQYg</span>==
</span></span></code></pre></div><p>Here‚Äôs the signature of uStreamer‚Äôs base64 function:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// src/libs/base64.h
</span></span></span><span><span><span></span>
</span></span><span><span><span>void</span> <span>us_base64_encode</span>(<span>const</span> <span>uint8_t</span> *data, <span>size_t</span> size, <span>char</span> **encoded, <span>size_t</span> *allocated);
</span></span></code></pre></div><p>From inspecting the function‚Äôs implementation in <a href="https://github.com/pikvm/ustreamer/blob/v5.45/src/libs/base64.c"><code>base64.c</code></a>, here‚Äôs what I deduce about the semantics of <code>us_base64_encode</code>:</p><ul><li><code>data</code> is input data to encode with the base64 encoding scheme.</li><li><code>size</code> is the length of the <code>data</code> buffer (in bytes).</li><li><code>encoded</code> is a pointer to an output buffer in which <code>us_base64_encode</code> stores the base64-encoded string.<ul><li><code>us_base64_encode</code> allocates memory for the output, and the caller is responsible for freeing the memory when they‚Äôre done with it.</li><li>Technically, <code>us_base64_encode</code> allows the caller to allocate the buffer for <code>encoded</code>, but, for simplicity, I‚Äôm ignoring that functionality.</li></ul></li><li><code>allocated</code> is a pointer that <code>us_base64_encode</code> populates with the number of bytes it allocated into <code>encoded</code>.</li></ul><p>Here‚Äôs a simple test program to call this function from C:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// src/test.c
</span></span></span><span><span><span></span>
</span></span><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#include</span> <span>&#34;libs/base64.h&#34;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>void</span> <span>main</span>(<span>void</span>) {
</span></span><span><span>  <span>char</span> *input = <span>&#34;hello, world!&#34;</span>;
</span></span><span><span>  <span>char</span> *encoded = <span>NULL</span>;
</span></span><span><span>  <span>size_t</span> encoded_bytes = <span>0</span>;
</span></span><span><span>  <span>us_base64_encode</span>((<span>uint8_t</span> *)input, <span>strlen</span>(input), &amp;encoded, &amp;encoded_bytes);
</span></span><span><span>  <span>printf</span>(<span>&#34;input:        %s</span><span>\n</span><span>&#34;</span>, input);
</span></span><span><span>  <span>printf</span>(<span>&#34;output:       %s</span><span>\n</span><span>&#34;</span>, encoded);
</span></span><span><span>  <span>printf</span>(<span>&#34;output bytes: %lu</span><span>\n</span><span>&#34;</span>, encoded_bytes);
</span></span><span><span>  <span>free</span>(encoded);
</span></span><span><span>}
</span></span></code></pre></div><p>I‚Äôll compile it with gcc, a popular C compiler:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gcc src/test.c src/libs/base64.c -o /tmp/b64test
</span></span><span><span>In file included from src/libs/base64.h:31,
</span></span><span><span>                 from src/test.c:3:
</span></span><span><span>src/libs/tools.h: In <span>function</span> ‚Äòus_signum_to_string‚Äô:
</span></span><span><span>src/libs/tools.h:194:34: warning: implicit declaration of <span>function</span> ‚Äòsigabbrev_np‚Äô [-Wimplicit-function-declaration]
</span></span><span><span>  <span>194</span> |         const char *const <span>name</span> = sigabbrev_np(signum);
</span></span><span><span>      |                                  ^~~~~~~~~~~~
</span></span></code></pre></div><p>Hmm, the code compiles, but I‚Äôm getting a lot of compiler warnings about a <code>tools.h</code> header that the uStreamer code includes.</p><p>If I look into <code>src/libs/tools.h</code>, I see that all the errors are around a single function: <a href="https://github.com/pikvm/ustreamer/blob/v5.45/src/libs/tools.h#L192-L210"><code>us_signum_to_string</code></a>. Let me see if I can just comment out that function to clear away the irrelevant warnings.</p><div><pre tabindex="0"><code data-lang="c"><span><span>
</span></span><span><span><span>/*
</span></span></span><span><span><span>DEBUG: Temporarily delete this function to get the build working again.
</span></span></span><span><span><span>INLINE char *us_signum_to_string(int signum) {
</span></span></span><span><span><span>...
</span></span></span><span><span><span>  return buf;
</span></span></span><span><span><span>}
</span></span></span><span><span><span>*/</span>
</span></span></code></pre></div><p>With the pesky <code>us_signum_to_string</code> function removed, I‚Äôll try to compile build again:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ gcc src/test.c src/libs/base64.c -o /tmp/b64test &amp;&amp; /tmp/b64test
</span></span><span><span>input:        hello, world!
</span></span><span><span>output:       <span>aGVsbG8sIHdvcmxkIQ</span>==
</span></span><span><span>output bytes: <span>21</span>
</span></span></code></pre></div><p>Hooray, no more compiler warnings.</p><p>If I were trying to compile all of uStreamer, I‚Äôd have to figure out how to get <code>us_signum_to_string</code> to compile. For this exercise, I‚Äôm just calling <code>us_base64_encode</code> from Zig, so I don‚Äôt need <code>us_signum_to_string</code>.</p><p>If I compare my <code>test.c</code> program‚Äôs output to my system‚Äôs built-in <code>base64</code> utility, I can verify that I‚Äôm producing the correct result:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ <span>printf</span> <span>&#39;hello, world!&#39;</span> | base64
</span></span><span><span><span>aGVsbG8sIHdvcmxkIQ</span>==
</span></span></code></pre></div><p>The complete example at this stage <a href="https://github.com/tiny-pilot/ustreamer/tree/zig-00-c-test">is on Github</a>.</p><h2 id="adding-zig-to-my-ustreamer-project-environment">Adding Zig to my uStreamer project environment<a href="#adding-zig-to-my-ustreamer-project-environment" arialabel="Anchor"> üîóÔ∏é</a></h2><p>My favorite way of installing Zig is <a href="https://zero-to-nix.com/">with Nix</a>, as it allows me to switch Zig versions easily. Feel free to <a href="https://ziglang.org/learn/getting-started/">install Zig</a> any way you prefer.</p><p>I added the following <code>flake.nix</code> file to my project, which pulls Zig 0.11.0 into my environment:</p><div><pre tabindex="0"><code data-lang="nix"><span><span>{
</span></span><span><span>  description = <span>&#34;Dev environment for zig-c-simple&#34;</span>;
</span></span><span><span>
</span></span><span><span>  inputs = {
</span></span><span><span>    flake-utils.url = <span>&#34;github:numtide/flake-utils&#34;</span>;
</span></span><span><span>
</span></span><span><span>    <span># 0.11.0</span>
</span></span><span><span>    zig_dep.url = <span>&#34;github:NixOS/nixpkgs/46688f8eb5cd6f1298d873d4d2b9cf245e09e88e&#34;</span>;
</span></span><span><span>  };
</span></span><span><span>
</span></span><span><span>  outputs = { self, flake-utils, zig_dep }@inputs :
</span></span><span><span>    flake-utils.lib.eachDefaultSystem (system:
</span></span><span><span>    <span>let</span>
</span></span><span><span>      zig_dep = inputs.zig_dep.legacyPackages.<span>${</span>system<span>}</span>;
</span></span><span><span>    <span>in</span>
</span></span><span><span>    {
</span></span><span><span>      devShells.default = zig_dep.mkShell {
</span></span><span><span>        packages = [
</span></span><span><span>          zig_dep.zig
</span></span><span><span>        ];
</span></span><span><span>
</span></span><span><span>        shellHook = <span>&#39;&#39;
</span></span></span><span><span><span>          echo &#34;zig&#34; &#34;$(zig version)&#34;
</span></span></span><span><span><span>        &#39;&#39;</span>;
</span></span><span><span>      };
</span></span><span><span>    });
</span></span><span><span>}
</span></span></code></pre></div><p>From here, I can run <code>nix develop</code>, and I see that Nix 0.11.0 is available in my project environment:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># There&#39;s a weird quirk of Nix flakes that they have to be added to your git</span>
</span></span><span><span><span># repo.</span>
</span></span><span><span>$ git add flake.nix
</span></span><span><span>$ nix develop
</span></span><span><span>zig 0.11.0
</span></span></code></pre></div><h2 id="creating-a-zig-executable">Creating a Zig executable<a href="#creating-a-zig-executable" arialabel="Anchor"> üîóÔ∏é</a></h2><p>The Zig compiler‚Äôs <code>init-exe</code> creates a boilerplate Zig application, so I‚Äôll use it to create a simple Zig app within the uStreamer source tree:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig init-exe
</span></span><span><span>info: Created build.zig
</span></span><span><span>info: Created src/main.zig
</span></span><span><span>info: Next, try <span>`</span>zig build --help<span>`</span> or <span>`</span>zig build run<span>`</span>
</span></span></code></pre></div><p>If I try compiling and running the boilerplate Zig application, I see that everything works:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>All your codebase are belong to us.
</span></span><span><span>Run <span>`</span>zig build <span>test</span><span>`</span> to run the tests.
</span></span></code></pre></div><p>The uStreamer C file I want to call <a href="https://github.com/pikvm/ustreamer/blob/v5.45/src/libs/base64.h#L25-L27">depends on the C standard library</a>, so I need to make a small adjustment to my <code>build.zig</code> file to link against that library. While I‚Äôm adjusting, I‚Äôll also replace the boilerplate binary name with <code>base64-encoder</code>:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>    </span><span>const</span><span> </span>exe<span> </span>=<span> </span>b.addExecutable(.{<span>
</span></span></span><span><span><span>        </span>.name<span> </span>=<span> </span><span>&#34;base64-encoder&#34;</span>,<span> </span><span>// Change binary name.
</span></span></span><span><span><span></span><span>        </span>.root_source_file<span> </span>=<span> </span>.{<span> </span>.path<span> </span>=<span> </span><span>&#34;src/main.zig&#34;</span><span> </span>},<span>
</span></span></span><span><span><span>        </span>.target<span> </span>=<span> </span>target,<span>
</span></span></span><span><span><span>        </span>.optimize<span> </span>=<span> </span>optimize,<span>
</span></span></span><span><span><span>    </span>});<span>
</span></span></span><span><span><span>    </span>exe.linkLibC();<span>               </span><span>// Link against C standard library.
</span></span></span><span><span><span></span><span>    </span>exe.addIncludePath(.{<span> </span>.path<span> </span>=<span> </span><span>&#34;src&#34;</span><span> </span>});<span>
</span></span></span></code></pre></div><h2 id="calling-ustreamer-code-from-zig">Calling uStreamer code from Zig<a href="#calling-ustreamer-code-from-zig" arialabel="Anchor"> üîóÔ∏é</a></h2><p>Now, I want to call the <code>us_base64_encode</code> C function from Zig.</p><p>As a reminder, here‚Äôs the C function I‚Äôm trying to call from Zig, which I explained <a href="http://blog.local:1313/notes/zig-unit-test-c/#whats-the-simplest-c-function-in-ustreamer">above</a>:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// src/libs/base64.h
</span></span></span><span><span><span></span>
</span></span><span><span><span>void</span> <span>us_base64_encode</span>(<span>const</span> <span>uint8_t</span> *data, <span>size_t</span> size, <span>char</span> **encoded, <span>size_t</span> *allocated);
</span></span></code></pre></div><p>Figuring out how to translate between C types and Zig types turned out to be the hardest part of this process, as I‚Äôm still a Zig novice.</p><p>Here was my first attempt:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>// src/main.zig
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>const</span><span> </span>ustreamer<span> </span>=<span> </span><span>@cImport</span>({<span>
</span></span></span><span><span><span>    </span><span>@cInclude</span>(<span>&#34;libs/base64.c&#34;</span>);<span>
</span></span></span><span><span><span></span>});<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span>main()<span> </span>!<span>void</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>cEncoded:<span> </span>*<span>u8</span><span> </span>=<span> </span><span>undefined</span>;<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span>    </span><span>// WRONG: This doesn&#39;t compile.
</span></span></span><span><span><span></span><span>    </span>ustreamer.us_base64_encode(&amp;input,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>That yielded this compiler error:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>zig build-exe b64 Debug native: error: the following <span>command</span> failed with <span>1</span> compilation errors:
</span></span><span><span>...
</span></span><span><span>src/main.zig:17:32: error: expected <span>type</span> <span>&#39;[*c]const u8&#39;</span>, found <span>&#39;*const *const [13:0]u8&#39;</span>
</span></span><span><span>    ustreamer.us_base64_encode(&amp;input, input.len, &amp;cEncoded, &amp;allocatedSize);
</span></span><span><span>                               ^~~~~~
</span></span><span><span>src/main.zig:17:32: note: pointer <span>type</span> child <span>&#39;*const [13:0]u8&#39;</span> cannot cast into pointer <span>type</span> child <span>&#39;u8&#39;</span>
</span></span><span><span>/home/mike/ustreamer/zig-cache/o/9599bf4c636d23e50eddd1a55dd088ff/cimport.zig:1796:43: note: parameter <span>type</span> declared here
</span></span><span><span>pub <span>export</span> fn us_base64_encode(arg_data: [*c]const u8, arg_size: usize, arg_encoded: [*c][*c]u8, arg_allocated: [*c]usize) void {
</span></span></code></pre></div><p>I had trouble understanding this error at first because so much of it was unfamiliar.</p><p>The important bit of the compiler error above is <code>error: expected type &#39;[*c]const u8&#39;, found &#39;*const *const [13:0]u8&#39;</code>. It‚Äôs telling me that I tried to pass in a <code>*const *const [13:0]u8</code>, but Zig needs me to pass in <code>[*c]const u8</code>.</p><p>What does that mean?</p><h3 id="understanding-the-type-i-used">Understanding the type I used<a href="#understanding-the-type-i-used" arialabel="Anchor"> üîóÔ∏é</a></h3><p>According to the Zig compiler, I passed in a parameter of type <code>&#39;*const *const [13:0]u8</code>. To understand what this means, I‚Äôll go from right to left:</p><p><code>u8</code> is an unsigned byte, which is how Zig represents characters in a string.</p><p><code>[13:0]</code> means a null-terminated array. The <code>13</code> is the length of the array, which Zig calculates at compile-time. <code>:0</code> means that the array has an extra byte with a value of <code>0</code> to indicate the end of the string. For more details about the mechanics of null-terminated strings in Zig, see <a href="https://mtlynch.io/notes/zig-strings-call-c-code/">my previous post</a>.</p><p><code>*const</code> means a constant pointer. A pointer is an address in memory, and the <code>const</code> means that subsequent code may not reassign the variable.</p><p><code>*const *const</code> means a constant pointer to a constant pointer. In other words, <code>input</code> is a constant pointer to a string, so that means <code>&amp;input</code> is a constant pointer to a constant pointer.</p><h3 id="converting-a-zig-type-to-a-c-type">Converting a Zig type to a C type<a href="#converting-a-zig-type-to-a-c-type" arialabel="Anchor"> üîóÔ∏é</a></h3><p>Okay, now I understand how Zig views the string that I passed. What did Zig <em>want</em> me to pass as the <code>input</code> type?</p><div><pre tabindex="0"><code data-lang="text"><span><span>expected type &#39;[*c]const u8&#39;
</span></span></code></pre></div><p>What the heck does <code>[*c]</code> mean?</p><p>This was surprisingly hard to figure out. I eventually pieced it together from a few different sources.</p><p>Here‚Äôs the official Zig documentation:</p><blockquote><h3 id="c-pointers">C Pointers<a href="#c-pointers" arialabel="Anchor"> üîóÔ∏é</a></h3><p>This type is to be avoided whenever possible. The only valid reason for using a C pointer is in auto-generated code from translating C code.</p><p>When importing C header files, it is ambiguous whether pointers should be translated as single-item pointers (*T) or many-item pointers ([*]T). C pointers are a compromise so that Zig code can utilize translated header files directly.</p><p><a href="https://ziglang.org/documentation/0.11.0/#C-Pointers">https://ziglang.org/documentation/0.11.0/#C-Pointers</a></p></blockquote><p>I didn‚Äôt understand the documentation, as it seemed to be warning against using C pointers rather than explaining what they are.</p><p>More <a href="https://kagi.com">Kagi</a>‚Äòing led me to this explanation on reddit, which I found more accessible:</p><blockquote><p><code>[*c]T</code> is just a C pointer to type T, it says that it doesn‚Äôt know whether there are multiple elements in that pointer or not. There could be, there could not be. We also don‚Äôt know the length of it (it‚Äôs not a slice which has pointer+length, it‚Äôs just a pointer). And if there are multiple elements, we don‚Äôt know if it is say null-terminated or not.</p><p><a href="https://www.reddit.com/r/Zig/comments/11uqo84/comment/jcplxiz/">-/u/slimsag on reddit</a></p></blockquote><p>Okay, that makes more sense.</p><p>In C, a pointer is just a memory address and a data type. A C type of <code>char*</code> could point to a single character like <code>&#39;A&#39;</code>, or it could point to the first character in a sequence like <code>&#34;ABCD&#34;</code>.</p><p>In Zig, a pointer to an array is a different type than a pointer to a single element. When Zig has to infer a data type from C code, Zig can‚Äôt tell whether the C code is referring to a single element or an array, so the C pointer type (<code>[*c]T</code>) is Zig‚Äôs way of saying, ‚ÄúI don‚Äôt know. I got this from C.‚Äù</p><p>Through trial and error, I figured out that Zig wanted me to get a pointer to <code>input</code> by referencing <code>input.ptr</code> rather than using the address-of operator <code>&amp;</code>.</p><p>This Zig snippet shows the difference between the <code>.ptr</code> and <code>&amp;</code>:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span></span>std.debug.print(<span>&#34;input     is type {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{<span>@typeName</span>(<span>@TypeOf</span>(input))});<span>
</span></span></span><span><span><span></span>std.debug.print(<span>&#34;&amp;input    is type {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{<span>@typeName</span>(<span>@TypeOf</span>(&amp;input))});<span>
</span></span></span><span><span><span></span>std.debug.print(<span>&#34;input.ptr is type {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{<span>@typeName</span>(<span>@TypeOf</span>(input.ptr))});<span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="text"><span><span>input     is type *const [13:0]u8
</span></span><span><span>&amp;input    is type *const *const [13:0]u8
</span></span><span><span>input.ptr is type [*]const u8
</span></span></code></pre></div><p>Recall that Zig wants me to pass <code>us_base64_encode</code> a parameter of type <code>[*c]const u8</code>, so it looks like it can convert <code>[*]const u8</code> to that type.</p><p>Okay, let me try calling <code>us_base64_encode</code> again:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span></span><span>var</span><span> </span>cEncoded:<span> </span>*<span>u8</span><span> </span>=<span> </span><span>undefined</span>;<span>
</span></span></span><span><span><span></span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span></span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span></code></pre></div><p>That gives me:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>zig build-exe b64 Debug native: error: the following <span>command</span> failed with <span>1</span> compilation errors:
</span></span><span><span>...
</span></span><span><span>src/main.zig:12:54: error: expected <span>type</span> <span>&#39;[*c][*c]u8&#39;</span>, found <span>&#39;**u8&#39;</span>
</span></span><span><span>    ustreamer.us_base64_encode(input.ptr, input.len, &amp;cEncoded, &amp;allocatedSize);
</span></span><span><span>                                                     ^~~~~~~~~
</span></span></code></pre></div><p>Progress!</p><p>The code still doesn‚Äôt compile, but Zig is now complaining about the third parameter instead of the first. That at least tells me that I‚Äôve supplied the expected types for the first two parameters.</p><h3 id="translating-the-output-parameters-into-zig">Translating the output parameters into Zig<a href="#translating-the-output-parameters-into-zig" arialabel="Anchor"> üîóÔ∏é</a></h3><p>The compiler error also contains a helpful bit of information for calling into the C implementation of <code>us_base64_encode</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>pub <span>export</span> fn us_base64_encode(arg_data: [*c]const u8, arg_size: usize, arg_encoded: [*c][*c]u8, arg_allocated: [*c]usize) void {
</span></span></code></pre></div><p>That‚Äôs the signature of the C function translated into Zig, so Zig is telling me exactly the types I need to pass in to call the function.</p><p>Alternatively, I can use the <code>zig translate-c</code> utility to translate this C function signature into Zig. This effectively gives the same results as the compiler error above, but it preserves the original parameter names, whereas the compiler error prefixes them with <code>arg_</code>.</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># We add --library c to let Zig know the code depends on libc.</span>
</span></span><span><span>$ zig translate-c src/libs/base64.h --library c | grep us_base64
</span></span><span><span>pub extern fn us_base64_encode(data: [*c]const u8, size: usize, encoded: [*c][*c]u8, allocated: [*c]usize) void;
</span></span></code></pre></div><p>From more trial and error, I eventually guessed my way to these semantics for calling <code>us_base64_encode</code> from Zig:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span></span><span>var</span><span> </span>cEncoded:<span> </span>[*c]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span></span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span></span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span></code></pre></div><p>And it compiles successfully!</p><h3 id="can-i-do-better-than-c-pointers">Can I do better than C pointers?<a href="#can-i-do-better-than-c-pointers" arialabel="Anchor"> üîóÔ∏é</a></h3><p>Recall what the Zig documentation <a href="https://ziglang.org/documentation/0.11.0/#C-Pointers">said about C pointers</a>:</p><blockquote><p>The only valid reason for using a C pointer is in auto-generated code‚Ä¶</p></blockquote><p>I‚Äôm writing this code by hand, so I guess I shouldn‚Äôt be using a type reserved for auto-generated code.</p><p>I know that the third parameter to <code>us_base64_encode</code> is a pointer to a null-terminated string. How do I represent that in Zig?</p><p>My first thought was to do this:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span><span> </span>cEncoded:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>undefined</span>;<span>
</span></span></span><span><span><span></span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span></code></pre></div><p>That seemed reasonable. I know that <code>us_base64_encode</code> will populate <code>cEncoded</code> with a string, and <code>[*:0]u8</code> represents a null-terminated string of unkown length. But when I compile, Zig said no:</p><div><pre tabindex="0"><code data-lang="text"><span><span>error: expected type &#39;[*c][*c]u8&#39;, found &#39;*[*:0]u8&#39;
</span></span></code></pre></div><p>I was stumped, so I asked for help on <a href="https://ziggit.dev/">Ziggit</a>, a Zig discussion forum. Within an hour, another user <a href="https://ziggit.dev/t/improving-on-c-u8-when-calling-a-c-function-that-allocates-a-string/2489/4?u=mtlynch">showed me a solution</a>:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span><span> </span>cEncoded:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span></span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span></code></pre></div><p>The issue was that in C, a type of <code>char**</code> can be <code>null</code>, whereas a Zig type of <code>[*:0]u8</code> cannot be null. That‚Äôs why Zig refused to let me pass in my previous attempt.</p><p>Breaking down the correct type of <code>?[*:0]u8</code>, I see that it‚Äôs:</p><ul><li>a null-terminated slice of bytes (<code>:0]u8</code>)</li><li>of unknown length (<code>[*</code>)</li><li>that <a href="https://ziglang.org/documentation/0.11.0/#Optionals">might be null</a> (<code>?</code>)</li></ul><p>The new type allows me to compile the code, but if I try to print the value of <code>cEncoded</code>, I get what appears to be a memory address rather than a string:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>input:       hello, world!
</span></span><span><span>output:      u8@2b12a0      <span># &lt;&lt; whoops, not what I expected</span>
</span></span><span><span>output size: <span>21</span>
</span></span></code></pre></div><p>In order to convert <code>cEncoded</code> back to a printable string, I have to unwrap it from its optional variable by verifying in code that its value is non-null:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span><span> </span>cEncoded:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span></span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span></span><span>const</span><span> </span>output:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncoded<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span>...<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span>std.debug.print(<span>&#34;output:      {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{output});<span>
</span></span></span></code></pre></div><p>And then it prints the correct result:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>input: hello, world!
</span></span><span><span>output: <span>aGVsbG8sIHdvcmxkIQ</span>==
</span></span><span><span>output size: <span>21</span>
</span></span></code></pre></div><h3 id="completing-the-call-to-c-from-zig">Completing the call to C from Zig<a href="#completing-the-call-to-c-from-zig" arialabel="Anchor"> üîóÔ∏é</a></h3><p>At this point, I now have complete working code for calling the C <code>us_base64_encode</code> from Zig. Here‚Äôs the full <code>src/main.zig</code> file:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>// src/main.zig
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>const</span><span> </span>std<span> </span>=<span> </span><span>@import</span>(<span>&#34;std&#34;</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Import the base64 implementation from uStreamer&#39;s C source file.
</span></span></span><span><span><span></span><span>const</span><span> </span>ustreamer<span> </span>=<span> </span><span>@cImport</span>({<span>
</span></span></span><span><span><span>    </span><span>@cInclude</span>(<span>&#34;libs/base64.c&#34;</span>);<span>
</span></span></span><span><span><span></span>});<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span>main()<span> </span>!<span>void</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>// Create a standard Zig string.
</span></span></span><span><span><span></span><span>    </span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Create variables to store the ouput parameters of us_base64_encode.
</span></span></span><span><span><span></span><span>    </span><span>var</span><span> </span>cEncoded:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Call the uStreamer C function from Zig.
</span></span></span><span><span><span></span><span>    </span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Get the output as a non-optional type.
</span></span></span><span><span><span></span><span>    </span><span>const</span><span> </span>output:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncoded<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Free the memory that the C function allocated when this function exits.
</span></span></span><span><span><span></span><span>    </span><span>defer</span><span> </span>std.c.free(cEncoded);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Print the input and output of the base64 encode operation.
</span></span></span><span><span><span></span><span>    </span>std.debug.print(<span>&#34;input:       {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{input});<span>
</span></span></span><span><span><span>    </span>std.debug.print(<span>&#34;output:      {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{output});<span>
</span></span></span><span><span><span>    </span>std.debug.print(<span>&#34;output size: {d}</span><span>\n</span><span>&#34;</span>,<span> </span>.{allocatedSize});<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>input:       hello, world!
</span></span><span><span>output:      <span>aGVsbG8sIHdvcmxkIQ</span>==
</span></span><span><span>output size: <span>21</span>
</span></span></code></pre></div><p>Great! That worked. And the results are identical to <a href="#whats-the-simplest-c-function-in-ustreamer">my C implementation above</a>.</p><p>The complete example at this stage <a href="https://github.com/tiny-pilot/ustreamer/tree/zig-10-simple-exe">is on Github</a>.</p><h2 id="creating-a-zig-wrapper-for-the-native-c-implementation">Creating a Zig wrapper for the native C implementation<a href="#creating-a-zig-wrapper-for-the-native-c-implementation" arialabel="Anchor"> üîóÔ∏é</a></h2><p>At this point, I can successfully call the C <code>us_base64_encode</code> function from Zig, but the code is a bit messy. Most of my <code>main()</code> function is dealing with translating values to and from C code.</p><p>One way to improve the code is to add a Zig wrapper function for <code>us_base64_encode</code>. That way, I could encapsulate all the Zig to C interop logic, and callers of my wrapper wouldn‚Äôt have to know or care that I‚Äôm calling C.</p><p>What should my wrapper function look like?</p><p>It should accept arbitrary bytes and return a null-terminated string, so the function signature should look something like this:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span><span> </span>base64Encode(data:<span> </span>[]<span>const</span><span> </span><span>u8</span>)<span> </span>[:<span>0</span>]<span>u8</span><span> </span>{...}<span>
</span></span></span></code></pre></div><p>I already have the first few lines of my implementation based on my <code>main()</code> function <a href="#completing-the-call-to-c-from-zig">above</a>:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span><span> </span>base64Encode(data:<span> </span>[]<span>const</span><span> </span><span>u8</span>)<span> </span>[:<span>0</span>]<span>u8</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>var</span><span> </span>cEncoded:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span>  </span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span>ustreamer.us_base64_encode(data.ptr,<span> </span>data.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>// TODO: Complete the implementation.
</span></span></span></code></pre></div><h3 id="whos-responsible-for-freeing-the-memory-c-allocated">Who‚Äôs responsible for freeing the memory C allocated?<a href="#whos-responsible-for-freeing-the-memory-c-allocated" arialabel="Anchor"> üîóÔ∏é</a></h3><p>There‚Äôs a problem I haven‚Äôt addressed yet. <code>us_base64_encode</code> allocated memory into the <code>cEncoded</code> pointer. The caller is responsible for either freeing that memory or passing off that responsibility to its callers.</p><p>Normally, it‚Äôs fine for a function to declare that the caller is responsible for freeing an output value, but this case is a little trickier. This isn‚Äôt a normal Zig-allocated memory buffer ‚Äî it‚Äôs a C-allocated buffer that requires a special free function (<code>std.c.free</code>).</p><p>I want to abstract away the C implementation details, so callers shouldn‚Äôt have to use a C-specific memory freeing function.</p><p>That tells me what I need to do to complete the implementation of my Zig wrapper. I use <code>defer std.c.free</code> to free the C-allocated memory, and then I‚Äôll need to copy it into a Zig-managed slice:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span><span> </span>base64Encode(data:<span> </span>[]<span>const</span><span> </span><span>u8</span>)<span> </span>![:<span>0</span>]<span>u8</span><span> </span>{<span>
</span></span></span><span><span><span>  </span><span>var</span><span> </span>cEncodedOptional:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span>  </span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span>ustreamer.us_base64_encode(data.ptr,<span> </span>data.len,<span> </span>&amp;cEncodedOptional,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span>  </span><span>const</span><span> </span>cEncoded:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncodedOptional<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>// Get the output as a non-optional type.
</span></span></span><span><span><span></span><span>  </span><span>const</span><span> </span>output:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncoded<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>// Free the C-allocated memory buffer before exiting the function.
</span></span></span><span><span><span></span><span>  </span><span>defer</span><span> </span>std.c.free(cEncoded);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>// TODO: Copy the contents of cEncoded into a [:0]u8 buffer.
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><h3 id="converting-a-c-string-to-a-zig-string">Converting a C string to a Zig string<a href="#converting-a-c-string-to-a-zig-string" arialabel="Anchor"> üîóÔ∏é</a></h3><p>At this point, I‚Äôve got the string as a <code>[*:0]u8</code> (unknown length, zero-terminated Zig slice), but I want to return <code>[:0]u8</code> (length-aware, null-terminated Zig slice). How do I convert a C-style string to a Zig slice?</p><p>In <a href="https://mtlynch.io/notes/zig-strings-call-c-code/#improving-the-wrapper-with-zig-managed-buffers">my previous post</a>, I converted a C string to a Zig string with this process:</p><ol><li>Create a Zig slice of the C string using <a href="https://ziglang.org/documentation/0.11.0/std/#A;std:mem.span"><code>std.mem.span</code></a>.</li><li>Use <a href="https://ziglang.org/documentation/0.11.0/std/#A;std:mem.Allocator.dupeZ"><code>allocator.dupeZ</code></a> to copy the contents of the slice into a newly allocated Zig slice.</li></ol><p>That process would work here, but I‚Äôd be doing a useless work in step (1). <code>std.mem.span</code> has to iterate the string to find the null terminator. In this code, I already know where the null terminator is because <code>us_base64_encode</code> stores that information in the <code>allocatedSize</code> parameter.</p><p>Instead, I create a length-aware Zig slice of the <code>cEncoded</code> slice like this:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>// The allocatedSize includes the null terminator, so subtract 1 to get the
</span></span></span><span><span><span>// number of non-null characters in the string.
</span></span></span><span><span><span></span><span>const</span><span> </span>cEncodedLength<span> </span>=<span> </span>allocatedSize<span> </span>-<span> </span><span>1</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Convert cEncoded (unknown length slice) to a length-aware slice.
</span></span></span><span><span><span></span><span>const</span><span> </span>outputLengthAware:<span> </span>[:<span>0</span>]<span> </span>=<span> </span>cEncoded[<span>0</span>..cEncodedLength<span> </span>:<span>0</span>];<span>
</span></span></span></code></pre></div><p>At this point, I can complete the implementation of my wrapper function:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span><span> </span>base64Encode(allocator:<span> </span>std.mem.Allocator,<span> </span>data:<span> </span>[]<span>const</span><span> </span><span>u8</span>)<span> </span>![:<span>0</span>]<span>u8</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>cEncoded:<span> </span>[*c]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span>ustreamer.us_base64_encode(data.ptr,<span> </span>data.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Get the output as a non-optional type.
</span></span></span><span><span><span></span><span>    </span><span>const</span><span> </span>output:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncoded<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Free the C-allocated memory buffer before exiting the function.
</span></span></span><span><span><span></span><span>    </span><span>defer</span><span> </span>std.c.free(cEncoded);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// The allocatedSize includes the null terminator, so subtract 1 to get the
</span></span></span><span><span><span></span><span>    </span><span>// number of non-null characters in the string.
</span></span></span><span><span><span></span><span>    </span><span>const</span><span> </span>cEncodedLength<span> </span>=<span> </span>allocatedSize<span> </span>-<span> </span><span>1</span>;<span>
</span></span></span><span><span><span>    </span><span>return</span><span> </span>allocator.dupeZ(<span>u8</span>,<span> </span>cEncoded[<span>0</span>..cEncodedLength<span> </span>:<span>0</span>]);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>To call <code>dupeZ</code>, I need a Zig allocator, so I adjusted the semantics of my <code>base64Encode</code> wrapper to accept a <code>std.mem.Allocator</code> type.</p><h3 id="tying-it-all-together">Tying it all together<a href="#tying-it-all-together" arialabel="Anchor"> üîóÔ∏é</a></h3><p>With my Zig wrapper in place, it‚Äôs now trivial to exercise the C <code>us_base64_encode</code> function from Zig.</p><p>Recall that my previous code looked like this:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span></span><span>var</span><span> </span>cEncoded:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span></span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span></span>ustreamer.us_base64_encode(input.ptr,<span> </span>input.len,<span> </span>&amp;cEncoded,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span></span><span>const</span><span> </span>output:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncoded<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span></span><span>defer</span><span> </span>std.c.free(cEncoded);<span>
</span></span></span></code></pre></div><p>With my Zig wrapper, the semantics simplify to two lines:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span>output<span> </span>=<span> </span><span>try</span><span> </span>base64Encode(allocator,<span> </span><span>&#34;hello, world!&#34;</span>);<span>
</span></span></span><span><span><span></span><span>defer</span><span> </span>allocator.free(output);<span>
</span></span></span></code></pre></div><p>Here‚Äôs the full example:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span><span> </span>std<span> </span>=<span> </span><span>@import</span>(<span>&#34;std&#34;</span>);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Import the base64 implementation from uStreamer&#39;s C source file.
</span></span></span><span><span><span></span><span>const</span><span> </span>ustreamer<span> </span>=<span> </span><span>@cImport</span>({<span>
</span></span></span><span><span><span>    </span><span>@cInclude</span>(<span>&#34;libs/base64.c&#34;</span>);<span>
</span></span></span><span><span><span></span>});<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span><span> </span>base64Encode(allocator:<span> </span>std.mem.Allocator,<span> </span>data:<span> </span>[]<span>const</span><span> </span><span>u8</span>)<span> </span>![:<span>0</span>]<span>u8</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>cEncodedOptional:<span> </span>?[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span><span>null</span>;<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>allocatedSize:<span> </span><span>usize</span><span> </span>=<span> </span><span>0</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span>ustreamer.us_base64_encode(data.ptr,<span> </span>data.len,<span> </span>&amp;cEncodedOptional,<span> </span>&amp;allocatedSize);<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>cEncoded:<span> </span>[*:<span>0</span>]<span>u8</span><span> </span>=<span> </span>cEncodedOptional<span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>error</span>.UnexpectedNull;<span>
</span></span></span><span><span><span>    </span><span>defer</span><span> </span>std.c.free(cEncodedOptional);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>cEncodedLength<span> </span>=<span> </span>allocatedSize<span> </span>-<span> </span><span>1</span>;<span>
</span></span></span><span><span><span>    </span><span>return</span><span> </span>allocator.dupeZ(<span>u8</span>,<span> </span>cEncoded[<span>0</span>..cEncodedLength<span> </span>:<span>0</span>]);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span>main()<span> </span>!<span>void</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>var</span><span> </span>gpa<span> </span>=<span> </span>std.heap.GeneralPurposeAllocator(.{}){};<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>allocator<span> </span>=<span> </span>gpa.allocator();<span>
</span></span></span><span><span><span>    </span><span>defer</span><span> </span>_<span> </span>=<span> </span>gpa.deinit();<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>input<span> </span>=<span> </span><span>&#34;hello, world!&#34;</span>;<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>output<span> </span>=<span> </span><span>try</span><span> </span>base64Encode(allocator,<span> </span>input);<span>
</span></span></span><span><span><span>    </span><span>defer</span><span> </span>allocator.free(output);<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// Print the input and output of the base64 encode operation.
</span></span></span><span><span><span></span><span>    </span>std.debug.print(<span>&#34;input:       {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{input});<span>
</span></span></span><span><span><span>    </span>std.debug.print(<span>&#34;output:      {s}</span><span>\n</span><span>&#34;</span>,<span> </span>.{output});<span>
</span></span></span><span><span><span>    </span>std.debug.print(<span>&#34;output size: {d}</span><span>\n</span><span>&#34;</span>,<span> </span>.{output.len});<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build run
</span></span><span><span>input:       hello, world!
</span></span><span><span>output:      <span>aGVsbG8sIHdvcmxkIQ</span>==
</span></span><span><span>output size: <span>20</span>
</span></span></code></pre></div><p>The output size is now <code>20</code> instead of <code>21</code> because the underlying data type changed. Previously, I was printing the output size parameter that <code>us_base64_encode</code> populated, which included the null terminator. Now, I‚Äôm using the <code>.len</code> property of the output string, which does not include the null terminator.</p><p>The complete example at this stage <a href="https://github.com/tiny-pilot/ustreamer/tree/zig-20-wrapper-fn">is on Github</a>.</p><h2 id="creating-the-first-unit-test">Creating the first unit test<a href="#creating-the-first-unit-test" arialabel="Anchor"> üîóÔ∏é</a></h2><p>Now that I can call the C <code>us_base64_encode</code> function through a convenient Zig wrapper, I‚Äôm ready to start writing unit tests to verify that the C implementation is correct.</p><p>The first thing I need to do is make a couple of small adjustments to my <code>build.zig</code> file so that the unit tests can access libc and uStreamer‚Äôs C source files:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>// build.zig
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>unit_tests<span> </span>=<span> </span>b.addTest(.{<span>
</span></span></span><span><span><span>        </span>.root_source_file<span> </span>=<span> </span>.{<span> </span>.path<span> </span>=<span> </span><span>&#34;src/main.zig&#34;</span><span> </span>},<span>
</span></span></span><span><span><span>        </span>.target<span> </span>=<span> </span>target,<span>
</span></span></span><span><span><span>        </span>.optimize<span> </span>=<span> </span>optimize,<span>
</span></span></span><span><span><span>    </span>});<span>
</span></span></span><span><span><span>    </span>unit_tests.linkLibC();<span>                          </span><span>// Link against libc.
</span></span></span><span><span><span></span><span>    </span>unit_tests.addIncludePath(.{<span> </span>.path<span> </span>=<span> </span><span>&#34;src&#34;</span><span> </span>});<span>  </span><span>// Search src path for includes.
</span></span></span></code></pre></div><p>I‚Äôve already done the heavy lifting here by writing my Zig wrapper function, so writing my first unit test is straightforward:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>// src/main.zig
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>test</span><span> </span><span>&#34;encode simple string as base64&#34;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>allocator<span> </span>=<span> </span>std.testing.allocator;<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>actual<span> </span>=<span> </span><span>try</span><span> </span>base64Encode(allocator,<span> </span><span>&#34;hello, world!&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>defer</span><span> </span>allocator.free(actual);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>std.testing.expectEqualStrings(<span>&#34;aGVsbG8sIHdvcmxkIQ==&#34;</span>,<span> </span>actual);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>The <code>zig build test</code> command runs my unit test:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build <span>test</span> --summary all
</span></span><span><span>Build Summary: 3/3 steps succeeded; 1/1 tests passed
</span></span><span><span><span>test</span> success
</span></span><span><span>‚îî‚îÄ run <span>test</span> <span>1</span> passed 1ms MaxRSS:1M
</span></span><span><span>   ‚îî‚îÄ zig <span>test</span> Debug native success 2s MaxRSS:211M
</span></span></code></pre></div><p>Success! My first unit test is working and exercising the C code.</p><p>The complete example at this stage <a href="https://github.com/tiny-pilot/ustreamer/tree/zig-30-unit-test">is on Github</a>.</p><h2 id="checking-for-false-positive-test-results">Checking for false positive test results<a href="#checking-for-false-positive-test-results" arialabel="Anchor"> üîóÔ∏é</a></h2><p>My unit test is succeeding, but I want to ensure that the test is truly executing the C code and not just returning a false positive. I can verify this by intentionally introducing a bug into the C code.</p><p>This is a snippet from the implementation of <a href="https://github.com/pikvm/ustreamer/blob/v5.45/src/libs/base64.c"><code>base64.c</code></a>:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#    define OCTET(_name) unsigned _name = (data_index &lt; size ? (uint8_t)data[data_index++] : 0)
</span></span></span><span><span><span></span>    <span>OCTET</span>(octet_a);
</span></span><span><span>    <span>OCTET</span>(octet_b);
</span></span><span><span>    <span>OCTET</span>(octet_c);
</span></span><span><span><span>#    undef OCTET
</span></span></span></code></pre></div><p>Let me try swapping the order of these two lines:</p><div><pre tabindex="0"><code data-lang="c"><span><span>    <span>OCTET</span>(octet_a);
</span></span><span><span>    <span>OCTET</span>(octet_c); <span>// I&#39;ve swapped these
</span></span></span><span><span><span></span>    <span>OCTET</span>(octet_b); <span>// two lines.
</span></span></span></code></pre></div><p>And here‚Äôs what happens when I try re-running my unit test on the C function after my tampering:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build <span>test</span> --summary all
</span></span><span><span>run test: error: <span>&#39;test.encode simple string as base64&#39;</span> failed: ====== expected this output: =========
</span></span><span><span><span>aGVsbG8sIHdvcmxkIQ</span>==‚êÉ
</span></span><span><span>
</span></span><span><span>======== instead found this: =========
</span></span><span><span><span>aGxlbCxvIG93cmRsIQ</span>==‚êÉ
</span></span></code></pre></div><p>Cool, the test works!</p><p>When I introduced a bug into <code>us_base64_encode</code>, my test failed and revealed the bug.</p><h2 id="adding-multiple-unit-tests">Adding multiple unit tests<a href="#adding-multiple-unit-tests" arialabel="Anchor"> üîóÔ∏é</a></h2><p>I‚Äôd like to extend my single test case into many test cases to increase my confidence that I‚Äôm exercising more of the C function‚Äôs logic.</p><p>Half of the lines in my first unit test were boilerplate around managing memory, so I‚Äôd like to avoid repeating that for each test. I wrote a utility function to capture the boilerplate:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span><span> </span>testBase64Encode(<span>
</span></span></span><span><span><span>    </span>input:<span> </span>[]<span>const</span><span> </span><span>u8</span>,<span>
</span></span></span><span><span><span>    </span>expected:<span> </span>[:<span>0</span>]<span>const</span><span> </span><span>u8</span>,<span>
</span></span></span><span><span><span></span>)<span> </span>!<span>void</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>allocator<span> </span>=<span> </span>std.testing.allocator;<span>
</span></span></span><span><span><span>    </span><span>const</span><span> </span>actual<span> </span>=<span> </span><span>try</span><span> </span>base64Encode(allocator,<span> </span>input);<span>
</span></span></span><span><span><span>    </span><span>defer</span><span> </span>allocator.free(actual);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>std.testing.expectEqualStrings(expected,<span> </span>actual);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>My test utility function allows me to add new tests easily:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>test</span><span> </span><span>&#34;encode strings as base64&#34;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(<span>&#34;&#34;</span>,<span> </span><span>&#34;&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(<span>&#34;h&#34;</span>,<span> </span><span>&#34;aA==&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(<span>&#34;he&#34;</span>,<span> </span><span>&#34;aGU=&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(<span>&#34;hel&#34;</span>,<span> </span><span>&#34;aGVs&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(<span>&#34;hell&#34;</span>,<span> </span><span>&#34;aGVsbA==&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(<span>&#34;hello, world!&#34;</span>,<span> </span><span>&#34;aGVsbG8sIHdvcmxkIQ==&#34;</span>);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>test</span><span> </span><span>&#34;encode raw bytes as base64&#34;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(&amp;[_]<span>u8</span>{<span>0</span>},<span> </span><span>&#34;AA==&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(&amp;[_]<span>u8</span>{<span> </span><span>0</span>,<span> </span><span>0</span><span> </span>},<span> </span><span>&#34;AAA=&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(&amp;[_]<span>u8</span>{<span> </span><span>0</span>,<span> </span><span>0</span>,<span> </span><span>0</span><span> </span>},<span> </span><span>&#34;AAAA&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(&amp;[_]<span>u8</span>{<span>255</span>},<span> </span><span>&#34;/w==&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(&amp;[_]<span>u8</span>{<span> </span><span>255</span>,<span> </span><span>255</span><span> </span>},<span> </span><span>&#34;//8=&#34;</span>);<span>
</span></span></span><span><span><span>    </span><span>try</span><span> </span>testBase64Encode(&amp;[_]<span>u8</span>{<span> </span><span>255</span>,<span> </span><span>255</span>,<span> </span><span>255</span><span> </span>},<span> </span><span>&#34;////&#34;</span>);<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span>$ zig build <span>test</span> --summary all
</span></span><span><span>Build Summary: 3/3 steps succeeded; 2/2 tests passed
</span></span><span><span><span>test</span> success
</span></span><span><span>‚îî‚îÄ run <span>test</span> <span>2</span> passed 2ms MaxRSS:2M
</span></span><span><span>   ‚îî‚îÄ zig <span>test</span> Debug native success 2s MaxRSS:195M
</span></span></code></pre></div><p>The complete example at this stage <a href="https://github.com/tiny-pilot/ustreamer/tree/zig-40-multi-test">is on Github</a>.</p><h2 id="wrap-up">Wrap up<a href="#wrap-up" arialabel="Anchor"> üîóÔ∏é</a></h2><p>Because of Zig‚Äôs excellent interoperability with C, it‚Äôs possible to add unit tests to an existing C application without modifying any of the C code or build process.</p><p>In the example I showed, the C code doesn‚Äôt know about Zig at all, and it continues to work as-is with no changes to its existing <code>Makefile</code>.</p><p>I found this exercise a useful way of learning more about both the Zig language and the C code I‚Äôm testing.</p><hr/><p><em>Thanks to the Ziggit community for <a href="https://ziggit.dev/t/improving-on-c-u8-when-calling-a-c-function-that-allocates-a-string/2489?u=mtlynch">their help with this blog post</a>. Excerpts from uStreamer are used under <a href="https://github.com/pikvm/ustreamer/blob/v5.45/LICENSE">the GPLv3 license</a>.</em></p></div></div>
  </body>
</html>
