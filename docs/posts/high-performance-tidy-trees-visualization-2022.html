<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.zxch3n.com/tidy/tidy/">Original</a>
    <h1>High-performance tidy trees visualization (2022)</h1>
    
    <div id="readability-page-1" class="page"><article itemscope="" itemtype="http://schema.org/Article"><header><p>June 14, 2022<!-- --> · <!-- -->17 min read</p></header><p>This article introduces the algorithm to draw non-layered trees in linear time and re-layout partially when some nodes change in O(d) time, where d is the maximum depth of the changed node.</p><p>The source code is available at <a target="_blank" href="https://github.com/zxch3n/tidy">zxch3n/tidy</a>. It only takes a few milliseconds to finish the layout of a tree with tens of thousands of nodes within the web browser.</p><ul><li><a href="#introduction">Introduction</a><ul><li><a href="#layered-and-non-layered">Layered and non-layered</a></li><li><a href="#aesthetic-rules">Aesthetic rules</a></li></ul></li><li><a href="#a-naive-non-layered-tree-visualization">A naive non-layered tree visualization</a></li><li><a href="#tidy-tree-visualization-algorithm">Tidy tree visualization algorithm</a><ul><li><a href="#how-to-achieve-compactness">How to achieve compactness</a></li><li><a href="#fix-aesthetic-rule-7">Fix aesthetic rule 7</a></li><li><a href="#the-on-layout-algorithm-5">The O(n) layout algorithm [5]</a><ul><li><a href="#determine-move-distance">Determine move distance</a></li><li><a href="#get-collided-subtree">Get collided subtree</a></li><li><a href="#distribute-spacing">Distribute spacing</a></li></ul></li><li><a href="#final-code">Final Code</a></li><li><a href="#interactive-example">Interactive example</a></li></ul></li><li><a href="#relayout-partially">Relayout partially</a></li><li><a href="#benchmark">Benchmark</a></li><li><a href="#future-work">Future work</a><ul><li><a href="#remaining-aesthetic-issue">Remaining aesthetic issue</a></li><li><a href="#the-tidy-library">The Tidy Library</a></li></ul></li><li><a href="#references">References</a></li></ul><p>Trees are ubiquitous data structures. Various visualizations of trees were proposed to help people understand different aspects of trees. This article focuses on the classical node-link diagrams.</p><p>A good tree drawing should be aesthetically pleasing while using as little space as possible. In 1979, Wetherell and Shannon [<a href="#ref1">1</a>] formalized aesthetic rules for tidy trees and presented the first O(n) algorithm to solve it. In 1981, Reingold and Tilford [<a href="#ref2">2</a>] extended the aesthetic rules to make the drawings more aesthetically pleasing and compact. However, both of them would <a href="#fix-aesthetic-rule-7">violate the aesthetic rules when extended to m-ary trees</a>. In 1990, Walker [<a href="#ref3">3</a>] solved this problem with O(n^2) time complexity. Buchheim [<a href="#ref4">4</a>] improved Walker’s work to run in O(n) in 2002. In 2014, Ploeg [<a href="#ref5">5</a>] presented the first O(n) algorithm to produce tidy non-layered drawings of trees.</p><p>This article introduces the layout algorithm of non-layered tidy trees [<a href="#ref5">5</a>] and presents a fast relayout algorithm. Engineers can use it to build fast tree editor tools like mindmaps.</p><h2 id="layered-and-non-layered"><a href="#layered-and-non-layered" aria-label="layered and non layered permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Layered and non-layered</h2><p>In tree visualization, each node may have variant width and height. For example, nodes may contain text content of different lengths. In this case, the tree can be drawn as layered, where nodes with the same depth are horizontally aligned, or non-layered, where there is a fixed vertical distance between parent and children.</p><p>Layered drawings make depth comparison easier, whereas non-layered ones generally use less space.</p><p>The algorithm of non-layered drawing is harder than the layered one since the former can be easily extended to the latter. Ploeg [<a href="#ref5">5</a>] designed the first algorithm to finish the layout of non-layered tidy trees in linear time. The detail of the algorithm will be covered in the rest of this article. If you are interested in how layered drawing works, you can read the article by Bill Mill [<a href="#ref6">6</a>].</p><h2 id="aesthetic-rules"><a href="#aesthetic-rules" aria-label="aesthetic rules permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aesthetic rules</h2><p>A tidy drawing of a tree should obey the aesthetic rules while using as little space as possible. The aesthetic rules include:</p><ol><li>No overlapped node</li><li>No crossed line</li><li>A node’s children should stay on the same line</li><li>Parents should be centered over their children</li><li>A subtree should be drawn the same way regardless of where it occurs in the tree</li><li>Nodes are ordered. Drawings of nodes should have the same order.</li><li>A tree and its mirror image should produce drawings that are reflections of one another, which implies<ul><li>Small, interior subtrees should be spaced out evenly among larger subtrees, where the larger subtrees are adjacent at one or more levels.</li><li>Small subtrees at the far left or far right should be adjacent to larger subtrees.</li></ul></li></ol><p>Most mind map applications use a naive version of the tidy layout, i.e., it obeys the aesthetic rules but does not care about compactness.</p><p>The naive tidy visualization algorithm treats each node and its offsprings as a bounding box, avoiding collision between the bounding boxes.</p><div data-language="ts"><pre><code><span>function</span> <span>naiveTidyLayout</span><span>(</span>root<span>)</span> <span>{</span>
  root<span>.</span>y <span>=</span> <span>0</span>
  root<span>.</span><span>preOrderTraverse</span><span>(</span>node <span>=&gt;</span> <span>{</span>
    node<span>.</span>y <span>=</span> node<span>.</span>parent<span>.</span>y <span>+</span> node<span>.</span>parent<span>.</span>height <span>+</span> margin
  <span>}</span><span>)</span>
  root<span>.</span><span>postOrderTraverse</span><span>(</span>node <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span>node<span>.</span>children<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
      node<span>.</span>bbox<span>.</span>width <span>=</span> node<span>.</span>width
      <span>return</span>
    <span>}</span>

    <span>const</span> childrenWidth <span>=</span> node<span>.</span>children<span>.</span><span>reduce</span><span>(</span>
      <span>(</span>acc<span>,</span> cur<span>)</span> <span>=&gt;</span> acc <span>+</span> cur<span>.</span>width <span>+</span> margin<span>,</span>
      <span>-</span>margin
    <span>)</span>
    node<span>.</span>bbox<span>.</span>width <span>=</span> <span>max</span><span>(</span>node<span>.</span>width<span>,</span> childrenWidth<span>)</span>
    <span>let</span> relativeX <span>=</span> node<span>.</span>width <span>/</span> <span>2</span> <span>-</span> childrenWidth <span>/</span> <span>2</span>
    <span>for</span> <span>(</span><span>const</span> child <span>of</span> node<span>.</span>children<span>)</span> <span>{</span>
      child<span>.</span>relativeX <span>=</span> relativeX <span>+</span> child<span>.</span>bbox<span>.</span>width <span>/</span> <span>2</span> <span>-</span> child<span>.</span>width <span>/</span> <span>2</span>
      relativeX <span>+=</span> child<span>.</span>bbox<span>.</span>width <span>+</span> margin
    <span>}</span>
  <span>}</span><span>)</span>
  root<span>.</span><span>preOrderTraverse</span><span>(</span>node <span>=&gt;</span> <span>{</span>
    node<span>.</span>x <span>=</span> node<span>.</span>parent<span>.</span>x <span>+</span> node<span>.</span>relativeX
  <span>}</span><span>)</span>
<span>}</span></code></pre></div><p>It is easy to implement and has good performance. But its layout is not compact, as shown in <a href="#interactive_example">the interactive example</a>.</p><h2 id="how-to-achieve-compactness"><a href="#how-to-achieve-compactness" aria-label="how to achieve compactness permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How to achieve compactness</h2><p>Note that the aesthetic rules require that a subtree should be drawn the same way no matter where it appears in the tree. It means that if the layout of the subtree is done, inside it, all nodes’ relative positions to their parent are finalized. So we can use a post-order traversal to determine the relative positions. A high-level abstraction of the tree visualization algorithm is</p><div data-language="ts"><pre><code><span>function</span> <span>layout</span><span>(</span>root<span>)</span> <span>{</span>
  root<span>.</span><span>postOrderTraverse</span><span>(</span>node <span>=&gt;</span> <span>{</span>
    
    <span>layoutSubtree</span><span>(</span>node<span>,</span> node<span>.</span>children<span>)</span>
  <span>}</span><span>)</span>

  root<span>.</span><span>preOrderTraverse</span><span>(</span>node <span>=&gt;</span> <span>{</span>
    <span>finalizeAbsolutePosition</span><span>(</span>node<span>)</span>
  <span>}</span><span>)</span>
<span>}</span></code></pre></div><p>To arrange children compactly, during <code>layoutSubtree</code>, we need child subtrees to be as close to their siblings as possible. Therefore, we can abstract a tidy layout algorithm as below.</p><div data-language="ts"><pre><code><span>function</span> <span>layoutSubtree</span><span>(</span>node<span>,</span> children<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>children<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>const</span> prev <span>=</span> <span>[</span>children<span>[</span><span>0</span><span>]</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> children<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> cur <span>=</span> children<span>[</span>i<span>]</span>
    cur<span>.</span>relativeX <span>=</span> <span>getMoveDistance</span><span>(</span>prev<span>,</span> cur<span>)</span>
    prev<span>.</span><span>push</span><span>(</span>cur<span>)</span>
  <span>}</span>

  <span>positionRoot</span><span>(</span>node<span>)</span>
<span>}</span></code></pre></div><p>Suppose we are visualizing a complete k-ary tree, then we have <span></span>, where <span></span> is the time complexity of the <code>getMoveDistance</code> function. Based on <a target="_blank" href="https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)">master theorem</a>,</p><ul><li>If <span></span> , then <span></span> .</li><li>If <span></span> , then <span></span> .</li><li>If <span></span> , then <span></span> .</li><li>ϵ &gt; 0 is a constant.</li></ul><p>We only need a distance function with complexity of <span></span> to make the algorithm run in linear time. - Ploeg [<a href="#ref5">5</a>] proposed a algorithm with <span></span> , so that <span></span>. Ploeg [<a href="#ref5">5</a>] prooved its linear complexity for the cases other than complete k-ary tree.</p><h2 id="fix-aesthetic-rule-7"><a href="#fix-aesthetic-rule-7" aria-label="fix aesthetic rule 7 permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fix aesthetic rule 7</h2><p>The above algorithm satisfies aesthetic rules 1-6, but not aesthetic rule 7: a tree and its mirror image should produce drawings that are reflections of one another, as shown in the image below.</p><p>It happens when large neighbors surround small subtrees. The algorithm will pile the small ones to the left.</p><p>A simple fix is to take the average positions of the original layout and the mirror of the mirrored layout. But it tends to cluster the small subtrees at the center.</p><p>Walker [<a href="#ref3">3</a>] designed the first algorithm to address this issue, giving a more visually pleasing output. Its idea is that when moving a subtree to the right, the move distance should also be distributed to the smaller interior subtrees.</p><p><span>
      <span></span>
  <img alt="How to fix aesthetic rule 7" title="How to fix aesthetic rule 7" src="https://joaoabbottgribben.bearblog.dev/static/8169ae6ec013c2138ed6dd5352e17179/f058b/fix-a7.png" srcset="/static/8169ae6ec013c2138ed6dd5352e17179/c26ae/fix-a7.png 158w,/static/8169ae6ec013c2138ed6dd5352e17179/6bdcf/fix-a7.png 315w,/static/8169ae6ec013c2138ed6dd5352e17179/f058b/fix-a7.png 630w,/static/8169ae6ec013c2138ed6dd5352e17179/40601/fix-a7.png 945w,/static/8169ae6ec013c2138ed6dd5352e17179/4ad3a/fix-a7.png 1152w" sizes="(max-width: 630px) 100vw, 630px" loading="lazy" decoding="async"/>
    </span></p><p>To make the overall algorithm run within linear time, we need an O(1) method to</p><ol><li>Find the intermediate siblings</li><li>Distribute the distance evenly to the intermedia siblings</li></ol><p>Now the code changes to</p><div data-language="ts"><pre><code><span>function</span> <span>layoutSubtree</span><span>(</span>node<span>,</span> children<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>children<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>

  <span>const</span> prev <span>=</span> <span>[</span>children<span>[</span><span>0</span><span>]</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> children<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> cur <span>=</span> children<span>[</span>i<span>]</span>
    <span>const</span> collideIndex <span>=</span> <span>getCollisionIndex</span><span>(</span>prev<span>,</span> cur<span>)</span>
    <span>const</span> distance <span>=</span> <span>getMoveDistance</span><span>(</span>prev<span>,</span> cur<span>)</span>
    cur<span>.</span>relativeX <span>=</span> distance
    <span>distributeDistanceToInteriorSubtrees</span><span>(</span>children<span>,</span> distance<span>,</span> collideIndex<span>,</span> i<span>)</span>
    prev<span>.</span><span>push</span><span>(</span>cur<span>)</span>
  <span>}</span>

  <span>positionRoot</span><span>(</span>node<span>)</span>
<span>}</span></code></pre></div><h2 id="the-on-layout-algorithm-5"><a href="#the-on-layout-algorithm-5" aria-label="the on layout algorithm 5 permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The O(n) layout algorithm [<a href="#ref5">5</a>]</h2><p>To make the overall algorithm run in O(n), we need the following methods done in <span></span></p><div data-language="md"><pre><code><span>1.</span>  getMoveDistance(leftSiblings, subtree)
<span>2.</span>  getCollisionIndex(leftSiblings, subtree)
<span>3.</span>  distributeDistanceToInteriorSubtrees(children, distance, collideIndex, currentIndex)</code></pre></div><h3 id="determine-move-distance"><a href="#determine-move-distance" aria-label="determine move distance permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Determine move distance</h3><p><code>getMoveDistance</code> calculates how far a subtree needs to move to avoid colliding with the siblings on its left. For this purpose, it only needs to calculate the distance between the siblings’ right and the subtree’s left contour.</p><p>Note that aesthetic rule 5 requires: a subtree should be drawn the same way regardless of where it occurs in the tree. So a subtree’s left and right contour are not affected by other subtrees or their ancestors.</p><p>We introduce four new variables for this purpose.</p><ul><li>threadLeft: points to the next left contour node</li><li>modifierThreadLeft: the next left contour node x position relative to this</li><li>threadRight: points to the next right contour node</li><li>modifierThreadRight: the next right contour node x position relative to this</li></ul><p>The thread of the right contour is:</p><ul><li>The first node of the thread is the rightmost subtree’s root.</li><li>If the current thread node has children, then the next node in the thread is its last-child</li><li>If the current thread node <code>c</code> has no child, the next node in the thread is <code>c.threadRight</code>.</li><li><code>c.modifierThreadRight</code> is <code>c.threadRight</code>’s x position relative to <code>c</code></li></ul><p>The left contour thread follows the right contour’s mirrored rules.</p><p>When calculating the contour’s distance, only nodes with intersections on the y-axis need to be compared. And in both layered and non-layered cases, each node’s y positions can be precomputed.</p><p>We can express the extended behaviors in pseudocode.</p><div data-language="ts"><pre><code><span>function</span> <span>layoutSubtree</span><span>(</span>node<span>,</span> children<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>children<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>return</span><span>;</span>
  <span>}</span>

  <span>const</span> prev <span>=</span> <span>[</span>children<span>[</span><span>0</span><span>]</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> children<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> cur <span>=</span> children<span>[</span>i<span>]</span><span>;</span>
    <span>const</span> collideIndex <span>=</span> <span>getCollisionIndex</span><span>(</span>prev<span>,</span> cur<span>)</span><span>;</span>
    <span>const</span> distance <span>=</span> <span>getMoveDistance</span><span>(</span>prev<span>,</span> cur<span>)</span><span>;</span>
    cur<span>.</span>relativeX <span>=</span> distance<span>;</span>
    <span>distributeDistanceToInteriorSubtrees</span><span>(</span>children<span>,</span> distance<span>,</span> collideIndex<span>,</span> i<span>)</span><span>;</span>
<span>+</span>   <span>mergeContour</span><span>(</span>prev<span>,</span> cur<span>)</span><span>;</span>
    prev<span>.</span><span>push</span><span>(</span>cur<span>)</span><span>;</span>
  <span>}</span>

  <span>positionRoot</span><span>(</span>node<span>)</span><span>;</span>
<span>}</span>

<span>+</span><span>function</span> <span>getMoveDistance</span><span>(</span>prev<span>,</span> cur<span>)</span> <span>{</span>
<span>+</span>  <span>const</span> curLeftContour <span>=</span> cur<span>;</span>
<span>+</span>  <span>const</span> prevRightContour <span>=</span> prev<span>[</span>prev<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>;</span>
<span>+</span>  <span>let</span> maxDistance <span>=</span> <span>0</span><span>;</span>
<span>+</span>  <span>while</span> <span>(</span>curLeftContour <span>&amp;&amp;</span> prevRightContour<span>)</span> <span>{</span>
<span>+</span>    <span>const</span> xL <span>=</span> <span>getRelativeX</span><span>(</span>curLeftContour<span>)</span>
<span>+</span>    <span>const</span> xR <span>=</span> <span>getRelativeX</span><span>(</span>prevRightContour<span>)</span> <span>+</span> prevRightContour<span>.</span>width <span>+</span> margin<span>;</span>
<span>+</span>    maxDistance <span>=</span> <span>max</span><span>(</span>maxDistance<span>,</span> xR <span>-</span> xL<span>)</span><span>;</span>
<span>+</span>    <span>const</span> yL <span>=</span> curLeftContour<span>.</span>y <span>+</span> curLeftContour<span>.</span>height<span>;</span>
<span>+</span>    <span>const</span> yR <span>=</span> prevRightContour<span>.</span>y <span>+</span> prevRightContour<span>.</span>height<span>;</span>
<span>+</span>    <span>if</span> <span>(</span>yL <span>&lt;=</span> yR<span>)</span> <span>{</span>
<span>+</span>      curLeftContour <span>=</span> <span>nextLeftContour</span><span>(</span>curLeftContour<span>)</span><span>;</span>
<span>+</span>    <span>}</span>
<span>+</span>    <span>if</span> <span>(</span>yL <span>&gt;=</span> yR<span>)</span> <span>{</span>
<span>+</span>      prevRightContour <span>=</span> <span>nextRightContour</span><span>(</span>prevRightContour<span>)</span><span>;</span>
<span>+</span>    <span>}</span>
<span>+</span>  <span>}</span>
<span>+</span>
<span>+</span>  <span>return</span> maxDistance<span>;</span>
<span>+</span><span>}</span>
<span>+</span>
<span>+</span><span>function</span> <span>mergeContour</span><span>(</span>prev<span>,</span> cur<span>)</span> <span>{</span>
<span>+</span>  <span>if</span> <span>(</span><span>bottom</span><span>(</span>prev<span>)</span> <span>&gt;</span> <span>bottom</span><span>(</span>cur<span>)</span><span>)</span> <span>{</span>
<span>+</span>    <span>const</span> extremeRight <span>=</span> <span>getRightThreadLastNode</span><span>(</span>cur<span>)</span>
<span>+</span>    extremeRight<span>.</span>threadRight <span>=</span> <span>getRightThreadNodeAtY</span><span>(</span>prev<span>[</span>prev<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>,</span> extremeRight<span>.</span>y<span>)</span><span>;</span>
<span>+</span>    extremeRight<span>.</span>modifierThreadRight <span>=</span> <span>...</span><span>;</span>
<span>+</span>  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>bottom</span><span>(</span>prev<span>)</span> <span>&lt;</span> <span>bottom</span><span>(</span>cur<span>)</span><span>)</span> <span>{</span>
<span>+</span>    <span>const</span> extremeLeft <span>=</span> <span>getLeftThreadLastNode</span><span>(</span>prev<span>[</span><span>0</span><span>]</span><span>)</span>
<span>+</span>    extremeLeft<span>.</span>threadLeft <span>=</span> <span>getLeftThreadNodeAtY</span><span>(</span>cur<span>,</span> extremeLeft<span>.</span>y<span>)</span><span>;</span>
<span>+</span>    extremeLeft<span>.</span>modifierThreadLeft <span>=</span> <span>...</span><span>;</span>
<span>+</span>  <span>}</span>
<span>+</span><span>}</span></code></pre></div><h3 id="get-collided-subtree"><a href="#get-collided-subtree" aria-label="get collided subtree permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Get collided subtree</h3><p>During the post-order traversal, inside each iteration, we do layouts on subtrees that share the same parent.
<code>getCollisionIndex</code> get which subtree the right contour node, which produces the <code>maxDistance</code>, belongs to.</p><p>The easiest way to implement is to follow the parent pointer of the node to find the subtree’s root. But in the worst case, it takes O(n^2).</p><p>Notice that each subtree can only take a continuous y-span in the right contour thread of a forest. And the y-span always starts with another subtree’s bottom or 0 and ends with the bottom of the subtree.</p><p>So we can tell which subtree the right contour node belongs to by the y position.</p><p>Ploeg [<a href="#ref5">5</a>] used a linked list to construct this data structure:</p><div data-language="ts"><pre><code><span>+</span><span>class</span> <span><span>IYL</span></span> <span>{</span>
<span>+</span>  <span>constructor</span><span>(</span>
<span>+</span>    <span>public</span> bottom<span>:</span> <span>number</span><span>,</span>
<span>+</span>    <span>public</span> index<span>:</span> <span>number</span><span>,</span>
<span>+</span>    <span>public</span> next<span>:</span> <span>IYL</span> <span>|</span> <span>null</span>
<span>+</span>  <span>)</span> <span>{</span><span>}</span>
<span>+</span>
<span>+</span>  <span>update</span><span>(</span>minY<span>:</span> <span>number</span><span>,</span> index<span>:</span> <span>number</span><span>)</span> <span>{</span>
<span>+</span>    <span>let</span> cur <span>=</span> <span>this</span><span>;</span>
<span>+</span>    <span>while</span> <span>(</span>cur <span>!=</span> <span>null</span> <span>&amp;&amp;</span> minY <span>&gt;=</span> cur<span>.</span>bottom<span>)</span> cur <span>=</span> cur<span>.</span>next<span>;</span>
<span>+</span>    <span>return</span> <span>new</span> <span><span>IYL</span></span><span>(</span>minY<span>,</span> index<span>,</span> cur<span>)</span><span>;</span>
<span>+</span>  <span>}</span>
<span>+</span><span>}</span>

<span>function</span> <span>layoutSubtree</span><span>(</span>node<span>,</span> children<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>children<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>return</span><span>;</span>
  <span>}</span>

  <span>const</span> prev <span>=</span> <span>[</span>children<span>[</span><span>0</span><span>]</span><span>]</span><span>;</span>
<span>+</span> <span>let</span> iyl <span>=</span> <span>new</span> <span><span>IYL</span></span><span>(</span><span>getBottom</span><span>(</span>children<span>[</span><span>0</span><span>]</span><span>)</span><span>,</span> <span>0</span><span>,</span> <span>null</span><span>)</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> children<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> cur <span>=</span> children<span>[</span>i<span>]</span><span>;</span>
<span>+</span>   <span>const</span> <span>[</span>distance<span>,</span> collideIndex<span>]</span> <span>=</span> <span>getMoveDistance</span><span>(</span>prev<span>,</span> cur<span>,</span> iyl<span>)</span><span>;</span>
    cur<span>.</span>relativeX <span>=</span> distance<span>;</span>
    <span>distributeDistanceToInteriorSubtrees</span><span>(</span>children<span>,</span> distance<span>,</span> collideIndex<span>,</span> i<span>)</span><span>;</span>
    <span>mergeContour</span><span>(</span>prev<span>,</span> cur<span>)</span><span>;</span>
    prev<span>.</span><span>push</span><span>(</span>cur<span>)</span><span>;</span>
<span>+</span>   iyl <span>=</span> iyl<span>.</span><span>update</span><span>(</span><span>getBottom</span><span>(</span>cur<span>)</span><span>,</span> i<span>)</span><span>;</span>
  <span>}</span>

  <span>positionRoot</span><span>(</span>node<span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>getMoveDistance</span><span>(</span>prev<span>,</span> cur<span>,</span> iyl<span>)</span> <span>{</span>
  <span>const</span> curLeftContour <span>=</span> cur<span>;</span>
  <span>const</span> prevRightContour <span>=</span> prev<span>[</span>prev<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>;</span>
  <span>let</span> maxDistance <span>=</span> <span>0</span><span>;</span>
  <span>let</span> collideIndex <span>=</span> <span>0</span><span>;</span>
  <span>while</span> <span>(</span>curLeftContour <span>&amp;&amp;</span> prevRightContour<span>)</span> <span>{</span>
<span>+</span>   <span>if</span> <span>(</span>xR<span>.</span>y <span>+</span> xR<span>.</span>height <span>&gt;</span> iyl<span>.</span>bottom<span>)</span> <span>{</span>
<span>+</span>     iyl <span>=</span> iyl<span>.</span>next<span>;</span>
<span>+</span>   <span>}</span>

    <span>const</span> xL <span>=</span> <span>getRelativeX</span><span>(</span>curLeftContour<span>)</span>
    <span>const</span> xR <span>=</span> <span>getRelativeX</span><span>(</span>prevRightContour<span>)</span> <span>+</span> prevRightContour<span>.</span>width <span>+</span> margin<span>;</span>
<span>+</span>   <span>if</span> <span>(</span>xR <span>-</span> xL <span>&gt;</span> maxDistance<span>)</span> <span>{</span>
<span>+</span>     maxDistance <span>=</span> xR <span>-</span> xL<span>;</span>
<span>+</span>     collideIndex <span>=</span> iyl<span>.</span>index<span>;</span>
<span>+</span>   <span>}</span>

    <span>const</span> yL <span>=</span> curLeftContour<span>.</span>y <span>+</span> curLeftContour<span>.</span>height<span>;</span>
    <span>const</span> yR <span>=</span> prevRightContour<span>.</span>y <span>+</span> prevRightContour<span>.</span>height<span>;</span>
    <span>if</span> <span>(</span>yL <span>&lt;=</span> yR<span>)</span> <span>{</span>
      curLeftContour <span>=</span> <span>nextLeftContour</span><span>(</span>curLeftContour<span>)</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>yL <span>&gt;=</span> yR<span>)</span> <span>{</span>
      prevRightContour <span>=</span> <span>nextRightContour</span><span>(</span>prevRightContour<span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>return</span> <span>[</span>maxDistance<span>,</span> collideIndex<span>]</span><span>;</span>
<span>}</span></code></pre></div><h3 id="distribute-spacing"><a href="#distribute-spacing" aria-label="distribute spacing permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Distribute spacing</h3><p>We can implement it in a bruit-force way as below. But in the worst case, it causes the overall complexity to be <span></span>.</p><div data-language="ts"><pre><code><span>function</span> <span>distributeDistanceToInteriorSubtrees</span><span>(</span>children<span>,</span> distance<span>,</span> from<span>,</span> to<span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> from <span>+</span> <span>1</span><span>;</span> i <span>&lt;</span> to<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    children<span>[</span>i<span>]</span><span>.</span>relativeX <span>+=</span> <span>(</span>distance <span>*</span> <span>(</span>i <span>-</span> from<span>)</span><span>)</span> <span>/</span> <span>(</span>to <span>-</span> from<span>)</span>
  <span>}</span>
<span>}</span></code></pre></div><p>[<a href="#ref4">4</a>] introduced a simple trick to make it O(1). Given that the distance distributed is always an arithmetic progression, we can cache the difference at the start node and clear the effect at the end node. We need two variables: <code>shiftAcceleration</code> and <code>shiftChange</code>. They are cached position changes that will apply to children<!-- -->[from+1..to]<!-- --> in <code>finalizeAbsolutePosition</code>.</p><div data-language="ts"><pre><code><span>function</span> <span>layout</span><span>(</span>root<span>)</span> <span>{</span>
  root<span>.</span><span>postOrderTraverse</span><span>(</span>node <span>=&gt;</span> <span>{</span>
    
    <span>layoutSubtree</span><span>(</span>node<span>,</span> node<span>.</span>children<span>)</span><span>;</span>
  <span>}</span><span>)</span>

  root<span>.</span><span>preOrderTraverse</span><span>(</span>node <span>=&gt;</span> <span>{</span>
    <span>finalizeAbsolutePosition</span><span>(</span>node<span>)</span><span>;</span>
  <span>}</span><span>)</span>
<span>}</span>

<span>function</span> <span>finalizeAbsolutePosition</span><span>(</span>node<span>)</span> <span>{</span>
  <span>addChildSpacing</span><span>(</span>node<span>)</span><span>;</span>
  <span>...</span>
<span>}</span>

<span>function</span> <span>addChildSpacing</span><span>(</span>node<span>)</span> <span>{</span>
  <span>let</span> speed <span>=</span> <span>0.</span><span>;</span>
  <span>let</span> delta <span>=</span> <span>0.</span><span>;</span>
  <span>for</span> <span>(</span><span>const</span> child <span>of</span> node<span>.</span>children<span>)</span> <span>{</span>
    speed <span>+=</span> child<span>.</span>shiftAcceleration<span>;</span>
    delta <span>+=</span> speed <span>+</span> child<span>.</span>shiftChange<span>;</span>
    child<span>.</span>relativeX <span>+=</span> delta<span>;</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>distributeDistanceToInteriorSubtrees</span><span>(</span>children<span>,</span> distance<span>,</span> from<span>,</span> to<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>to <span>==</span> from <span>+</span> <span>1</span><span>)</span><span>{</span>
    <span>return</span><span>;</span>
  <span>}</span>

  children<span>[</span>from <span>+</span> <span>1</span><span>]</span><span>.</span>shiftAcceleration <span>+=</span> distance<span>/</span><span>(</span>to<span>-</span>from<span>)</span><span>;</span>
  children<span>[</span>to<span>]</span><span>.</span>shiftAcceleration <span>-=</span> distance<span>/</span><span>(</span>to<span>-</span>from<span>)</span><span>;</span>
  children<span>[</span>to<span>]</span><span>.</span>shiftChange <span>-=</span> distance <span>-</span> distance<span>/</span><span>(</span>to<span>-</span>from<span>)</span><span>;</span>
<span>}</span></code></pre></div><h2 id="final-code"><a href="#final-code" aria-label="final code permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Final Code</h2><p>You can find the final code of this article <a target="_blank" href="https://gist.github.com/zxch3n/1f28317731876a8d9026d4d7d4eef892">here</a>. However, there are still a few trivial details missing in this abstraction. For details, please refer to the <a target="_blank" href="https://github.com/zxch3n/tidy/blob/master/rust/crates/tidy-tree/src/layout/tidy_layout.rs">source code</a>.</p><h2 id="interactive-example"><a href="#interactive-example" aria-label="interactive example permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interactive example</h2><p>In this example, you can try non-layered tidy layout, layered tidy layout, and naive layout.</p><p>Node editing is a common scenario in applications like mind maps. If the relayout time is larger than 16ms, there will be obvious freezes, which is unacceptable. Therefore, a partial relayout is required for a smooth user experience on large editable tree visualization.</p><p>In this section, we exclude the <code>finalizeAbsolutePosition</code> and only talk about how to re-calculate each node’s relative position to their parent. Because changing one node’s size may cause the entire tree’s absolute positions to change, relative positions are much more stable as <a title="A subtree should be drawn the same way regardless of where it occurs in the tree" href="#aesthetic-rules">aesthetic rule 5</a> required. And in the real-world application, we only need the absolute positions of the nodes inside the screen. By detecting the collision between trees’ bounding boxes and the screen, we can filter out the offscreen content swiftly. Strictly speaking, the time complexity of partial relayout is O(d + m), where m is the in-screen nodes number, and d is the max depth of changed nodes.</p><p>Adding the partially relayout support to the naive version is relatively easy. Because the affected states are straightforward to reason about, i.e., only the bounding boxes of the edited nodes and their ancestors are changed.</p><p>For partial relayout, we need to determine which thread pointer caches are outdated. We say a subtree is changed if it or its offspring’s sizes change or an insertion or deletion happens inside this subtree. Note that</p><ol><li>If all nodes inside a subtree are not changed, the thread pointers of its nodes that point to the node inside this subtree won’t change. This is because the layout of a tree is agnostic about nodes outside. And the thread pointers that point inside are only affected by the structure of the subtree itself.</li><li>In a subtree, only the deepest nodes, which have the greatest value of <code>node.y + node.height</code>, have thread pointers that point outside of the tree. This rule is obvious in the <code>mergeContour</code> implementation.</li><li>Based on 1 and 2, we can infer that we only need to update the thread pointers of its deepest nodes for an unchanged subtree.</li><li>From 3, we can infer that if a node and its parent are roots of unchanged subtrees, we only need to update the parent subtree’s deepest nodes’ threads.</li><li>Generalizing 4, for all unchanged subtrees, only those who are siblings of the changed subtrees need to update their deepest nodes’ thread pointers.</li></ol><p>Based on the above observations, we only need to relayout the changed subtree and update its siblings’ thread pointers. Below is the code about partial relayout when there is a single changed node. We can easily extend it to multiple changed nodes.</p><div data-language="ts"><pre><code><span>function</span> <span>relayout</span><span>(</span>root<span>,</span> changedNode<span>)</span> <span>{</span>
  <span>let</span> node <span>=</span> changedNode
  <span>while</span> <span>(</span>node<span>.</span>parent<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> sibling <span>of</span> node<span>.</span>parent<span>.</span>children<span>)</span> <span>{</span>
      <span>const</span> r <span>=</span> <span>getRightBottomNode</span><span>(</span>sibling<span>)</span>
      r<span>.</span>threadRight <span>=</span> <span>null</span>
      r<span>.</span>modifierThreadRight <span>=</span> <span>0</span>
      <span>const</span> l <span>=</span> <span>getLeftBottomtNode</span><span>(</span>sibling<span>)</span>
      l<span>.</span>threadRight <span>=</span> <span>null</span>
      l<span>.</span>modifierThreadRight <span>=</span> <span>0</span>
    <span>}</span>

    <span>layoutSubtree</span><span>(</span>node<span>.</span>parent<span>,</span> node<span>.</span>parent<span>.</span>children<span>)</span>
    node <span>=</span> node<span>.</span>parent
  <span>}</span>
<span>}</span></code></pre></div><p>The code is available at <a target="_blank" href="https://github.com/zxch3n/tidy">GitHub</a>. The layout algorithms are written in Rust and compiled to WASM. The renderer is written in TypeScript.</p><p><span>
      <span></span>
  <img alt="benchmark" title="benchmark" src="https://joaoabbottgribben.bearblog.dev/static/ac9d4951191ec1fbc601ff7907727e27/f058b/benchmark.png" srcset="/static/ac9d4951191ec1fbc601ff7907727e27/c26ae/benchmark.png 158w,/static/ac9d4951191ec1fbc601ff7907727e27/6bdcf/benchmark.png 315w,/static/ac9d4951191ec1fbc601ff7907727e27/f058b/benchmark.png 630w,/static/ac9d4951191ec1fbc601ff7907727e27/40601/benchmark.png 945w,/static/ac9d4951191ec1fbc601ff7907727e27/78612/benchmark.png 1260w,/static/ac9d4951191ec1fbc601ff7907727e27/0faf1/benchmark.png 1956w" sizes="(max-width: 630px) 100vw, 630px" loading="lazy" decoding="async"/>
    </span></p><p>Benchmarks were done on MacBook Pro (13-inch, M1, 2020). It only measures the layout algorithm without the allocation and deallocation time. Mysteriously, the WASM build is faster than the native build on large data. It is very interesting, but I have not found out why.</p><h2 id="remaining-aesthetic-issue"><a href="#remaining-aesthetic-issue" aria-label="remaining aesthetic issue permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Remaining aesthetic issue</h2><p>The current layout algorithm is still not ideal in some cases.</p><p>As the above example shows, the root’s children are not symmetric in the current layout though it obeys the aesthetic rules. It does not violate <a title="A tree and its mirror image should produce drawings that are reflections of one another, which implies" href="#aesthetic-rules">aesthetic rule 7</a>, since the drawing of mirrored structure would give a mirrored layout.</p><p>To fix this issue, we need a new aesthetic rule to formalize the problem.</p><h2 id="the-tidy-library"><a href="#the-tidy-library" aria-label="the tidy library permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Tidy Library</h2><p>Though tidy tree visualization is useful in many fields, we haven’t seen many adoptions of this algorithm in the industry
because it is error-prone and slower. I hope <a target="_blank" href="https://github.com/zxch3n/tidy">Tidy Lib</a> can make the adoption simple and reliable.</p><p>The plan is to add full support for partial relayout, compress wasm size, and performance improvement.
This lib mainly focuses on the layout algorithm. Building a full-fledged tree visualization tool or editor is not a priority of this lib.</p><p>This lib is published under MIT License. Don’t hesitate to contact me if you want to participate or have any suggestions.</p><ul><li id="ref1">[1]C. Wetherell and A. Shannon, “Tidy Drawings of Trees,” IEEE Transactions on Software Engineering, vol. SE-5, no. 5, pp. 514–520, Sep. 1979, doi: 10.1109/TSE.1979.234212.</li><li id="ref2">[2] E. M. Reingold and J. S. Tilford, “Tidier Drawings of Trees,” IEEE Transactions on Software Engineering, vol. SE-7, no. 2, pp. 223–228, Mar. 1981, doi: 10.1109/TSE.1981.234519.</li><li id="ref3">[3] J. Q. Walker II, “A node-positioning algorithm for general trees,” Software: Practice and Experience, vol. 20, no. 7, pp. 685–705, 1990, doi: 10.1002/spe.4380200705.</li><li id="ref4">[4] C. Buchheim, M. Jünger, and S. Leipert, “Improving Walker’s Algorithm to Run in Linear Time,” in Graph Drawing, Berlin, Heidelberg, 2002, pp. 344–353. doi: 10.1007/3-540-36151-0_32.</li><li id="ref5">[5] A. van der Ploeg, “Drawing non-layered tidy trees in linear time,” Software: Practice and Experience, vol. 44, no. 12, pp. 1467–1484, 2014, doi: 10.1002/spe.2213.</li><li id="ref6">[6] Bill Mill, “Drawing Presentable Trees.” https://llimllib.github.io/pymag-trees/ 2008</li></ul><hr/></article></div>
  </body>
</html>
