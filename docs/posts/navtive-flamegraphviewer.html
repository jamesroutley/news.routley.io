<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://laladrik.xyz/blog/flameGraphViewer/">Original</a>
    <h1>Navtive FlameGraphViewer</h1>
    
    <div id="readability-page-1" class="page"><div id="outline-container-org896cbc0">
<h2 id="org896cbc0">The story of profiling</h2>
<div id="text-org896cbc0">
<p>
There is something in <a href="https://rust-analyzer.github.io/">Rust Analyzer</a> that I would like to fix.  This requires understanding its interaction with <a href="https://github.com/rust-lang/chalk">Chalk</a>.  To find the starting point I ran Rust Analyzer with <a href="https://perf.wiki.kernel.org/index.php/Main_Page">Linux Perf</a> to get the tree of calls represented in a <a href="https://www.brendangregg.com/flamegraphs.html">Flame Graph</a>.  The Flame Graph was so big, that it was rendered in the browser for quite a few seconds.  The hover events were delayed.  Nothing happened when I tried to open a frame of the graph.  Reading the text representation of the call trees was hard, and I am used to flame graphs. After a little adventure I created my <a href="http://laladrik.xyz/projects/FlameGraphViewer">FlameGraphViewer</a>.
</p>


<figure id="org891567b">
<img src="https://laladrik.xyz/img/flameGraph1.png" alt="flameGraph1.png"/>

<figcaption><span>Figure 1: </span>FlameGraph generated for Rust Analyzer</figcaption>
</figure>
</div>

<div id="outline-container-orgc3beba4">
<h3 id="orgc3beba4">The alternatives</h3>
<div id="text-orgc3beba4">
<p>
I tried to find something fast and native.  Saying &#34;native&#34; I mean something which doesn&#39;t require a browser.  W3C specifications are <a href="https://drewdevault.com/2020/03/18/Reckless-limitless-scope.html">bigger</a> than POSIX.  A modern browser complies with those specifications. I have a strong belief that it&#39;s wrong using something big like that to draw an interactive graph. A browser brings <a href="https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=chrome">thousands of vulnerabilities</a>.
</p>

<p>
The application <a href="https://github.com/KDAB/hotspot">Hotspot</a> is written in <a href="https://www.qt.io/">Qt</a> and <a href="https://cplusplus.com/">C++</a>, but it doesn&#39;t render my flame graph fast enough.  Another option is <a href="https://profiler.firefox.com/">https://profiler.firefox.com/</a>, but it doesn&#39;t work offline and still requires a browser. My computer has 64GB RAM, 8 Cores each with 3.5 GHz and a gaming graphic card. With this machine I can&#39;t draw a graph. I decided to make a viewer of flame graphs.  I had been thinking of practicing in GUI application development.  Now I have an opportunity to try it.
</p>
</div>
</div>
<div id="outline-container-org349ffcb">
<h3 id="org349ffcb">My picture of a Flame Graph</h3>
<p>
As the flame graph had a lot of rectangles, my initial idea was to find a GUI toolkit which would allow you to make 1000 buttons.  This is because I saw every rectangle as a button.  Each rectangle has a caption, border, background, and you can click it.  Also, I had a thought in my mind that it shouldn&#39;t consume too much memory.  I remember playing <a href="https://en.wikipedia.org/wiki/StarCraft:_Brood_War">StarCraft: Brood War</a> on the PC with 32MB RAM.  Sometimes there were battles with 800 zerlings on the map.  So 1000 buttons should not be a big deal for a modern computer.
</p>
</div>
</div><div id="outline-container-org73efcf8">
<h2 id="org73efcf8">The adventure</h2>
<p>
The adventure has 2 parts: the analysis of software which I can use as the foundation for my application, and the challenges I faced.
</p>
<div id="outline-container-orgc5acd54">
<h3 id="orgc5acd54">Choosing a GUI toolkit and the amount of code</h3>
<div id="text-orgc5acd54">
<p>
Speaking of the language, I will use <a href="https://www.rust-lang.org/">Rust</a> as it is currently my favorite language. As I need to draw a window with some controls, I need a GUI toolkit.  Which one should I choose?  Back in university I had some experience in the field of GUI development.  I still have some knowledge in this area.  I worked with Qt 4.6 and <a href="https://www.gtk.org/">GTK</a> 2. Additionally, as I used C++, I worked with <a href="https://gtkmm.org/en/index.html">GTKmm</a>.  Previously, I worked with Windows and did some Windows Forms and had some exposure to <a href="https://en.wikipedia.org/wiki/Windows_API">WinAPI</a>.
</p>

<p>
Since that time things have changed.  I&#39;m happy to see new options for Linux which can be used with Rust.  Some of the toolkits are written in Rust. Such as <a href="https://github.com/emilk/egui/">Egui</a>, <a href="https://slint.dev/">Slint</a>, <a href="https://iced.rs/">Iced</a>.  I have played with Egui a little bit.  I wanted to make a game and Egui helped me to make the user interface for the game.  Also, I remember that someone made a spreadsheet with 1 million cells with Egui.  I don&#39;t believe that 1000 buttons will be an issue.
</p>

<p>
I ran the example <code>hello_word</code> from Egui and it consumed of 53MB… of resident memory… in release mode.  That was a bit unexpected, because I remember that my university projects consuming about 5MB in release mode and 15MB in debug.  Also, I couldn&#39;t help but remember that 800 zerlings in StarCraft (with their animations) fit on a 32MB computer and I need just 1000 buttons.
</p>

<p>
I understand that there are plenty of things implemented in the library.  Those nice effects, animations and text rendering with customizable fonts aren&#39;t for free.  Drawing letters is a quite little list of solved problems.  And making a convenient GUI toolkit with a friendly API is a great challenge.  Egui does provide a friendly API.  But I&#39;m not gonna use most of the things.
</p>

<p>
Also, I understand that the memory consumption depends on the used data structures.
</p>
<ul>
<li>The memory allocator can spread some trees or linked lists across the entire address space in some cases.</li>
<li>The memory can also be used for some caches to reduce disk readings and make the user interface more responsive.</li>
<li>The memory pages can be poorly aligned.  The Rust compiler deals with it sorting the fields, but it&#39;s not applied for structures which are decorated with <code>#[repr(C)]</code>.</li>
</ul>
<p>
These issues can arise from the layers of abstractions created to provide a nice API for solving typical, tasks faster. However, my task is not that typical. Including all these nice features will make the user paying for it. I don&#39;t want to make users pay for things they don&#39;t use.  Moreover, I didn&#39;t want to delve into the library&#39;s source code to understand how to optimize it, because was to create a solution and return to working on Rust Analyzer.
</p>

<p>
I took GTK 4, because it was something familiar and I was wondering how the memory consumption changed for a Hello World. 83MB.  It became interesting how much I should pay for 1000 buttons. 103MB.  Following this, I started  every GUI toolkit.  A check included running a &#34;Hello World&#34; program and running a &#34;Hello World&#34; program with 1000 buttons.  I even switched from Rust to C++ to check Qt.  The results are below.
</p>

<table>


<colgroup>
<col/>

<col/>

<col/>

<col/>
</colgroup>
<tbody>
<tr>
<td>Name</td>
<td>Version</td>
<td>Memory (MB)</td>
<td>Memory with 1000 buttons</td>
</tr>

<tr>
<td>Egui</td>
<td>0.21.3</td>
<td>53</td>
<td>65</td>
</tr>

<tr>
<td>GTK 4</td>
<td>4</td>
<td>83</td>
<td>103</td>
</tr>

<tr>
<td>Iced</td>
<td>0.9.0</td>
<td>147</td>
<td>148</td>
</tr>

<tr>
<td>Qt (C++)</td>
<td>6.5.1</td>
<td>71</td>
<td>69</td>
</tr>

<tr>
<td>FLTK</td>
<td>1.3.8</td>
<td>12</td>
<td>46</td>
</tr>
</tbody>
</table>

<p>
Slint is not in the table as I couldn&#39;t find a way to create 1000 buttons programmatically.  The Hello World program with one button is 73MB. The version of Slint I had is 1.0.0. <a href="https://www.fltk.org/">FLTK</a> is definitely a winner.  The blocker I came across was binding the key Tab and the Shift-Tab combination for lists. It&#39;s <a href="https://github.com/fltk/fltk/blob/be07e5448f54fbd84c5299cbadfd097d1ce893db/src/Fl_Group.cxx#L123">hardcoded</a>:
</p>

<div>
<pre><span>static</span> <span>int</span> <span>navkey</span>() {
  
  <span>switch</span> (<span>Fl</span>::event_key()) {
  
  <span>case</span> FL_Tab:
    <span>if</span> (<span>!</span><span>Fl</span>::event_state(FL_SHIFT)) <span>return</span> FL_Right;
    <span>return</span> FL_Left;
  
  }
  <span>return</span> 0;
}
</pre>
</div>

<p>
It&#39;s not a problem in C++.  I could have made a child class from it if I had written the program in C++.  I haven&#39;t found any way to change it in the Rust binding.  This limitation made me think that it&#39;s not a good start.
</p>
</div>
</div>
<div id="outline-container-orgff99b96">
<h3 id="orgff99b96">Let&#39;s go without a GUI toolkit</h3>
<div id="text-orgff99b96">
<p>
After the results of my research, I started thinking that probably removing a GUI toolkit from the stack is not a bad idea.  In Linux you can use <a href="https://www.x.org/releases/current/doc/libX11/libX11/libX11.html">Xlib</a> to create windows, handle input and draw something.  Previously, I had some experience with Xlib.  Also, I slightly patched my terminal <a href="https://st.suckless.org/">ST</a> and <a href="https://tools.suckless.org/dmenu/">Dmenu</a>. Both are written with Xlib only.  When I was younger, I even tried to make own GUI toolkit in <a href="https://dlang.org">D language</a> being inspired by <a href="https://github.com/jwatte/hgui">HermitGUI</a> and <a href="https://github.com/buggins/dlangui">DlangUI</a>.  Also, I tried to make a markdown viewer. In that viewer, I couldn&#39;t make text selection across multiple sections of the text. I couldn&#39;t find a way of doing this, because I implemented every section as a window in that viewer.  Therefore, every event of mouse click, release and move is assigned to its own window.
</p>

<p>
The deal with Xlib is that the documentation is like quests in <a href="https://en.wikipedia.org/wiki/The_Elder_Scrolls_III:_Morrowind">The Elder Scrolls: Morrowind</a>.  You gather pieces from the entire world to get a complete picture. The last time I did it, the gathering was hard and fun.  Therefore, in order to deal with Xlib I will need to read some code of other projects and probably the source code of Xlib itself. Well, I&#39;m a mature programmer and not afraid of reading large amount of C code.
</p>

<p>
Apart from making windows, I need to render some text.  In my case the rendering is easier because:
</p>

<ol>
<li>I don&#39;t need to support multiple languages.  That&#39;s because I have never seen a program written in something other than the Roman alphabet (as used in English).  Therefore, I don&#39;t need to support right to left writing either.</li>
<li>I need to use only the monospace font. Programmers like to read the code in monospace fonts, because symbols <code>lI1|</code> look different. Another reason is that a &#34;dot&#34; occupies the same space as a regular symbol.</li>
<li>I don&#39;t need formatting, different sizes, line breaks or word wraps.</li>
</ol>

<p>
With this in mind, I took two dependencies: <a href="https://crates.io/crates/x11-dl">x11-dl</a> for Xlib bindings and <a href="https://crates.io/crates/rusttype">RustType</a> to render text.
</p>
</div>
</div>
<div id="outline-container-orgb685a15">
<h3 id="orgb685a15">Unexpected challenges</h3>
<div id="text-orgb685a15">
<p>
I created 1000 buttons with Xlib, and it consumed 3.5 MB memory.  I was happy to see this number. The application loads instantly.  However, I wouldn&#39;t have written the article if I hadn&#39;t met any challenge.
</p>

<p>
Unexpected challenges go first.  It would have been confusing if I had started with the expected challenges.
</p>
</div>
<div id="outline-container-org1432bb6">
<h4 id="org1432bb6">Perf format</h4>
<div id="text-org1432bb6">
<p>
Linux Perf creates a binary with the recorded events.  I expected to read the binary file to avoid using <code>stackcollapse-perf.pl</code>. Reading of the binary file would allow my program to depend only on Linux Perf, but I didn&#39;t understand the file <a href="https://github.com/torvalds/linux/blob/master/tools/perf/Documentation/perf.data-file-format.txt">format</a>. Luckily, I found this command in the <a href="https://www.brendangregg.com/blog/2016-04-30/linux-perf-folded.html">blog</a> of Brendan Gregg (the author of stockcollapse.pl):
</p>
<div>
<pre>perf report --stdio --no-children -n -g folded,0,caller,count -s comm | <span>\</span>
    awk <span>&#39;/^ / { comm = $3 } /^[0-9]/ { print comm &#34;;&#34; $2, $1 }&#39;</span> &gt; collapsed.perf
</pre>
</div>
<p>
After that, I had a look at the format of the output file and found that an event has one number.  In order to understand what the number means, I read the code of flamegraph.pl. The logic was more or less clear apart from this piece:
</p>
<div>
<pre>$<span>Tmp</span>{$<span>k</span>}-&gt;{delta} += $<span>i</span> == $<span>len_b</span> ? $<span>d</span> : 0;
</pre>
</div>
<p>
As far as I&#39;m aware, I am not the only one <a href="https://github.com/jonhoo/inferno/blob/45558809934935cae894b62fcc256f2a51bdb987/src/flamegraph/merge.rs#L92">who</a> is confused by this.  I decided to ignore it for now.
</p>

<p>
Another aspect I couldn&#39;t understand is the <code>value</code> for a perf event can have various formats.  In the stackcollapse.pl, you can find this regular expression to extract any variant.
</p>
<div>
<pre>($<span>stack</span>, $<span>samples</span>) = $<span>stack</span> =~ (<span>/^(.*)\s+?(\d+(?:\.\d*)?)$/</span>);
</pre>
</div>
<p>
So far, I decided to avoid regular expressions and to process just one integer after the last space.
</p>
<div>
<pre><span>let</span> <span>split</span> = line.split(<span>char</span>::is_whitespace).rev();
<span>let</span> <span>samples</span> = split.next()<span>?</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org4f1ecdb">
<h4 id="org4f1ecdb">Scrolling consumes up to 50% CPU</h4>
<div id="text-org4f1ecdb">
<p>
As I don&#39;t have a pre-existing widget for scrolling, I had to create one myself. My initial design of the widget involved making a big canvas and moving a viewport showing only some area of it.
</p>

<p>
I made a pixmap and a window.  The pixmap is the big canvas and the window is the viewport. The pixmap is drawn from a certain offset with a static length. Technically, the drawing is copying the pixels from the pixmap to the window.  The problem is Xlib doesn&#39;t allow to make pixmaps that are too big. As a result, I needed to move the buttons themselves.
</p>

<p>
The simple solution to move the buttons is simply changing the coordinates of each button.  I implemented the solution quickly: it&#39;s a loop over the 1000 buttons. Every iteration of the loop processes the respective button. The processing involves calculation of the new coordinates for the button and calling <code>XMoveWindow</code>.  It&#39;s stupid, but I wanted to see the numbers to be sure that it is stupid. It consumes 30-35% of CPU.  I want less.
</p>

<p>
The processing, which runs every iteration, should run only when necessary.  The obvious criteria of the necessity is visibility of the button.  That says that only the visible buttons should be scrolled. Let&#39;s solve the problem then.  The basic solution, I can do, is unmapping those buttons which are beyond the viewport. To explain, if a button is beyond the boundaries of the viewport, I call <code>XUnmapWindow</code>.  If a button is in the viewport, even partially, I call <code>XMapWindow</code>. As a result, <code>XMoveWindow</code> is still called, but it costs nothing for the unmapped windows.
</p>
<video controls="controls" width="350" id="orgc632525">
<source src="/InitialScrollIdea.webm" type="video/webm"/>
<p>
Your browser does not support the video tag.
</p>
</video>
<p>
The CPU consumption dropped to 10-15%.  It&#39;s better, but I still wasn&#39;t happy with the numbers, because it&#39;s just scrolling.
</p>

<p>
It&#39;s better to avoid recalculating the coordinates of those buttons that are unmapped. To achieve this, I need to maintain the range of visible buttons.  The coordinates of the invisible buttons aren&#39;t recalculated.  Also, I can stop calling <code>XMoveWindow</code> for unmapped windows.
</p>
<video controls="controls" width="350" id="orgc3f1647">
<source src="/ScrollOnStringIdea.webm" type="video/webm"/>
<p>
Your browser does not support the video tag.
</p>
</video>
<p>
Steps of the algorithm
</p>
<ol>
<li>Make a range of the visible buttons.</li>
<li>Maintain the range when scrolling happens.
<ol>
<li>Change the offset.</li>
<li>Move the visible buttons by the offset.</li>
<li>If the button is out of the viewport, exclude it from the range.</li>
<li>Pick the first button from those beyond the viewport, and if the viewport has space for it, move it by the offset and include it in the range.</li>
</ol></li>
</ol>

<p>
I failed to implement the algorithm correctly the first time.  Buttons didn&#39;t appear in the viewport after a couple of scrolls.  What happened?  My implementation of the algorithm involved having 2 stacks of buttons. One stack is above the viewport and one stack is beyond the viewport. The unexpected thing happened at the initialization of the program. At that moment, the buttons weren&#39;t in a stack. The buttons laid in a row next to each other.
</p>
<video controls="controls" width="350" id="org3acdc08">
<source src="/ScrollOnStringBug.webm" type="video/webm"/>
<p>
Your browser does not support the video tag.
</p>
</video>

<p>
When the user scrolled the window, the first &#34;invisible&#34; button was moved by the offset distance, but from its initial position.  The idea of the fix was to place the first &#34;invisible&#34; button right after the last &#34;visible&#34; button.
</p>
<video controls="controls" width="350" id="org1f32346">
<source src="/ScrollOnStringFix.webm" type="video/webm"/>
<p>
Your browser does not support the video tag.
</p>
</video>
<p>
Finally, the CPU load was barely above 0%.
</p>
</div>
</div>
<div id="outline-container-org576f5c9">
<h4 id="org576f5c9">Parsing the file with the Perf folded data</h4>
<div id="text-org576f5c9">
<p>
The Perf data in the <a href="https://www.brendangregg.com/blog/2016-04-30/linux-perf-folded.html">folded format</a> looks like this
</p>
<pre id="org177295c">rust-analyzer;&lt;DB as hir_def::db::DefDatabase&gt;::attrs::__shim;salsa::QueryTable&lt;Q&gt;::get;salsa::QueryTable&lt;Q&gt;::try_get;&lt;salsa::derived::DerivedStorage&lt;Q,MP&gt; as salsa::plumbing::QueryStorageOps&lt;Q&gt;&gt;::try_fetch;salsa::derived::slot::Slot&lt;Q,MP&gt;::read;salsa::derived::slot::Slot&lt;Q,MP&gt;::read_upgrade;salsa::derived::slot::PanicGuard&lt;Q,MP&gt;::proceed;salsa::derived::slot::PanicGuard&lt;Q,MP&gt;::overwrite_placeholder;salsa::runtime::Runtime::unblock_queries_blocked_on_self;salsa::runtime::DependencyGraph&lt;K&gt;::remove_edge 1
rust-analyzer;&lt;DB as hir_def::db::DefDatabase&gt;::attrs::__shim;salsa::QueryTable&lt;Q&gt;::get;salsa::QueryTable&lt;Q&gt;::try_get;&lt;salsa::derived::DerivedStorage&lt;Q,MP&gt; as salsa::plumbing::QueryStorageOps&lt;Q&gt;&gt;::try_fetch;salsa::derived::slot::Slot&lt;Q,MP&gt;::read;salsa::derived::slot::Slot&lt;Q,MP&gt;::read_upgrade;salsa::derived::slot::PanicGuard&lt;Q,MP&gt;::proceed;salsa::derived::slot::PanicGuard&lt;Q,MP&gt;::overwrite_placeholder;salsa::runtime::Runtime::unblock_queries_blocked_on_self;salsa::runtime::DependencyGraph&lt;K&gt;::remove_edge;&lt;&amp;smallvec::SmallVec&lt;A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter 1
</pre>
<p>
These lines are pretty long, but in the model, I have in my mind, they are like a tree with two leaves.
</p>

<figure id="orgbdff26e">
<img src="https://laladrik.xyz/img/tree.png" alt="tree.png"/>

<figcaption><span>Figure 2: </span>The representation of the perf data</figcaption>
</figure>

<p>
Every parent has the value of its children plus its own.  Also, they have names.  A simple parser should do just fine.  Let&#39;s run it… it took 7 seconds to load.  Why?  Because I have to draw 38003 buttons instead of 1000.
</p>
</div>
</div>
<div id="outline-container-org82ca2cb">
<h4 id="org82ca2cb">More than 1000 buttons</h4>
<div id="text-org82ca2cb">
<p>
Well, given that I need to make a lot more buttons, I should stop using windows and instead draw a few rectangles on a canvas. This means that solving the challenges with the window scrolling only served to give me more experience.
</p>

<p>
Xlib provides the function <code>XFillRectangle</code> to draw a rectangle. The function needs the size and the position of the rectangle.
</p>
<ol>
<li>Size.
<ol>
<li>Height is constant.  It&#39;s clear from the picture.</li>
<li>Width should be calculated.  To be specific, it&#39;s a sum the <code>value</code> of a perf event plus the <code>value</code> of the direct children.</li>
</ol></li>
<li>Position.
<ol>
<li>Abscissa (x coordinate) is the sum of the width and the abscissa of the neighbouring element on the left.  The abscissa of the first rectangle is equal to the abscissa of its parent plus the <code>value</code> of the parent.</li>
<li>Ordinate (y coordinate) is the number of the ascendants of the rectangle multiplied by the height, which is constant.</li>
</ol></li>
</ol>

<p>
The main thing I had been scared of was handling the click and hover events (when the pointer is over a button).  Both of the events require finding the button by the position of the cursor.
</p>

<p>
My initial idea was to make a <a href="https://www.cs.princeton.edu/courses/archive/spr13/cos226/lectures/99GeometricSearch.pdf">KD tree</a>, which is not a big deal for 2 dimensions.  Luckily, I didn&#39;t need to implement KD tree at all.  Instead of the tree,  I made a simple index for the buttons, which effectively is a vector of vectors.  The outer vector represents the vector of rows in the graph.  An inner vector represents a row with the buttons. To find the position in the outer vector, I simply divide the ordinate by the height.  The complexity of the search is just <code>O(1)</code>.  The rectangles in the inner vector should be sorted by the abscissa, allowing the button to be found using <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a>.  Binary search has the complexity <code>O(log(n))</code>.  Another stroke of luck is that, in addition to the height being constant, the buttons are already sorted in the input data.  This means, that building the index doesn&#39;t require any sorting.
</p>
<div>
<pre><span>fn</span> <span>find_rect</span>&lt;&#39;<span>a</span>, &#39;<span>node</span>&gt;(
    <span>button_table</span>: <span>&amp;</span>&#39;<span>a</span> [<span>Rectangle</span>&lt;&#39;<span>node</span>&gt;],
    <span>position_index</span>: <span>&amp;</span>[<span>impl</span> <span>AsRef</span>&lt;[<span>RectangleIndex</span>]&gt;],
    <span>pos</span>: <span>Position</span>,
) -&gt; <span>Result</span>&lt;<span>&amp;</span>&#39;<span>a</span> <span>Rectangle</span>&lt;&#39;<span>node</span>&gt;, <span>usize</span>&gt; {
    <span>let</span> <span>lvl</span> = <span>&amp;</span>position_index
        .get((pos.1 <span>as</span> <span>u32</span> / <span>HEIGHT</span>) <span>as</span> <span>usize</span>)
        .ok_or(0<span>usize</span>)<span>?</span>;
    lvl.as_ref()
        .binary_search_by(|((x_left, x_right), _)| {
            <span>if</span> pos.0 &gt; *x_right {
                <span>Ordering</span>::<span>Less</span>
            } <span>else</span> <span>if</span> pos.0 &lt; *x_left {
                <span>Ordering</span>::<span>Greater</span>
            } <span>else</span> {
                <span>Ordering</span>::<span>Equal</span>
            }
        })
        .map(|x| <span>&amp;</span>button_table[lvl.as_ref()[x].1])
}
</pre>
</div>

<p>
It is worth mentioning that while the binary search is good on paper, but it might be bad in the computer, because the CPU processes data in cache lines.  When you read an array the CPU reads ahead filling the <a href="https://lwn.net/Articles/252125/">cache line</a>.  This means, if you read an array sequentially, the next element might be in the cache. As a result, the CPU won&#39;t go to RAM to fetch that next element.  On the other hand, the binary search doesn&#39;t read an array sequentially. To confirm that binary search is efficient, I did a simple benchmark. Namely, I compared binary search with sequential reading of the index.  In my case, the binary search worked at the same speed, so I left the binary search.
</p>

<p>
I implemented the lookup and was happy that it worked fast enough and, of cause, correctly.  The handling of clicks is not as intensive as the handling of mouse moving.  As I wanted to highlight the button under the cursor, I needed to handle the intensity.
</p>


<figure id="org114e284">
<img src="https://laladrik.xyz/img/frameHighlight.png" alt="frameHighlight.png"/>

<figcaption><span>Figure 3: </span>The frame in the center is under the cursor</figcaption>
</figure>

<p>
Surprisingly, the code for the clicks worked fast enough for mouse moving as well.  The same lookup in the index worked just fine and doesn&#39;t consume CPU.
</p>
</div>
</div>
<div id="outline-container-org0151ca3">
<h4 id="org0151ca3">Hover events and highlighting</h4>
<div id="text-org0151ca3">
<p>
The idea involves drawing a border around a rectangle when the cursor is over it and remove the border when the cursor is beyond the rectangle.  The border can be drawn with <code>XDrawRectangle</code>, but drawing the border was not a trick.  The trick was removing it, because the picture should be restored to its state before the border has been drawn.
</p>

<p>
In order to do it, I created an additional instance of <code>Pixmap</code> for the window displaying the graph. The new pixmap helped to make triple buffering to render the graph.  Namely, the buffers are:
</p>
<ol>
<li>The window itself.  The thing which the user sees.</li>
<li>The back buffer.  It accumulates the changes and flushes them into the window.</li>
<li>The backup buffer.  It holds the initial picture of the graph and flushes into the window when a button is no longer highlighted.</li>
</ol>
<div>
<pre>graph.restore(<span>&amp;</span>ui_factory);  
<span>if</span> <span>let</span> <span>Ok</span>(r) = find_rect(
    <span>&amp;</span>button_table,
    <span>&amp;</span>position_index,
    (x_cursor, y_cursor + graph.offset_y),
) {
    graph.draw_rectangle(<span>&amp;</span>ui_factory, r);
    graph.set_to_draw(<span>BufferSide</span>::<span>Back</span>);  
    status_line_upper.set_text(<span>&amp;</span>ui_factory, r.node.name());
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org229a47a">
<h4 id="org229a47a">Scrolling the new graph</h4>
<p>
The last piece is scrolling.  All of my previous experiments to make scrolling working were for a bunch of windows, but now, I no longer use windows.  Instead of the windows I have just a pixmap.  That enabled me to implement my initial idea of scrolling.  In particular, I keep track of the offset and copy the pixels from the back buffer into the window using this offset.
</p>
</div>
</div>
<div id="outline-container-org95e7b66">
<h3 id="org95e7b66">Expected challenges</h3>
<p>
The challenges in the section are well-known.  Unfortunately, the solutions and explanations for these challenges aren&#39;t that popular - unlike a new JavaScript framework being released two weeks ago.  I just want to make another place on the internet where they are discussed.
</p>
<div id="outline-container-org697c95e">
<h4 id="org697c95e">Drawing with Xlib after certain events</h4>
<div id="text-org697c95e">
<p>
It&#39;s confusing when you need to write: &#34;here is the text with this background&#34;.  You create a window, define its position and the color, and you get nothing.  Here is the example of the code which brings you to this situation
</p>
<div>
<pre><span>fn</span> <span>main</span>() -&gt; <span>Result</span>&lt;(), <span>Box</span>&lt;<span>dyn</span> <span>std</span>::<span>error</span>::<span>Error</span>&gt;&gt; {
    
    <span>let</span> <span>mut</span> <span>xlib</span> = <span>ui</span>::new_xlib()<span>?</span>;
    <span>let</span> <span>mut</span> <span>display</span> = <span>ui</span>::<span>Display</span>::try_new(<span>&amp;</span>xlib)<span>?</span>;
    <span>let</span> <span>screen</span> = <span>ui</span>::<span>Screen</span>::try_new(<span>&amp;</span><span>mut</span> xlib, <span>&amp;</span><span>mut</span> display)<span>?</span>;
    <span>let</span> <span>mut</span> <span>visual</span> = <span>ui</span>::<span>Visual</span>::try_new(<span>&amp;</span>xlib, <span>&amp;</span><span>mut</span> display, <span>&amp;</span>screen)<span>?</span>;
    <span>let</span> <span>root_win</span> = <span>ui</span>::<span>Window</span>::new_root(<span>&amp;</span>xlib, <span>&amp;</span><span>mut</span> display, <span>&amp;</span>screen);
    <span>let</span> <span>background</span> = 0x1d2021;
    <span>let</span> <span>mut</span> <span>main_win</span> = <span>ui</span>::<span>Window</span>::new_main(
        <span>&amp;</span>xlib,
        <span>&amp;</span><span>mut</span> display,
        <span>&amp;</span>screen,
        <span>&amp;</span><span>mut</span> visual,
        <span>&amp;</span>root_win,
        (0, 0, 800, 600),
        background,
        <span>&#34;FlameGraph Viewer&#34;</span>,
        <span>&#34;FlameGraph Viewer&#34;</span>,
        <span>std</span>::<span>env</span>::args(),
    )<span>?</span>;

    <span>let</span> <span>mut</span> <span>pixmap</span> = <span>ui</span>::<span>Pixmap</span>::new(<span>&amp;</span>xlib, <span>&amp;</span><span>mut</span> display, <span>&amp;</span>main_win);
    <span>let</span> <span>gc</span> = <span>ui</span>::<span>GraphicContext</span>::new(<span>&amp;</span>xlib, <span>&amp;</span><span>mut</span> display, <span>&amp;</span>main_win);
    <span>let</span> <span>mut</span> <span>ui_factory</span> = <span>ui</span>::<span>Factory</span>::new(xlib, display, screen, visual, root_win, gc);

    <span>let</span> <span>font_data</span> = <span>include_bytes!</span>(<span>&#34;../DejaVuSansMono.ttf&#34;</span>);
    <span>let</span> <span>font</span> =
        <span>Font</span>::try_from_bytes(font_data <span>as</span> <span>&amp;</span>[<span>u8</span>]).expect(<span>&#34;error constructing a Font from bytes&#34;</span>);
    

    ui_factory.show_window(<span>&amp;</span>main_win);

    ui_factory.set_foreground(background);
    ui_factory.set_background(0xffffff);
    ui_factory.fill_rectange(<span>&amp;</span>pixmap, (main_win.width(), main_win.height()));
    draw_caption(<span>&#34;RustType&#34;</span>,
        <span>&amp;</span><span>mut</span> ui_factory, <span>&amp;</span>font, <span>&amp;</span>pixmap, 0xffffff, background);
    <span>let</span> <span>mut</span> <span>quit</span> = <span>false</span>;
    <span>while</span> !quit {
        <span>let</span> <span>event</span> = ui_factory.wait_event();
        <span>match</span> event {
            <span>ui</span>::<span>Event</span>::<span>Expose</span>(_) =&gt; (),
            <span>ui</span>::<span>Event</span>::<span>KeyPress</span>(<span>KEY_Q</span>) =&gt; quit = <span>true</span>,
            <span>ui</span>::<span>Event</span>::<span>KeyPress</span>(key) =&gt; <span>println!</span>(<span>&#34;key code </span><span>{:x}</span><span>&#34;</span>, key),
            <span>ui</span>::<span>Event</span>::<span>ConfigureNotify</span> { width, height } =&gt; {
                main_win.set_width(width <span>as</span> _);
                main_win.set_height(height <span>as</span> _);
                pixmap = ui_factory.resize_pixmap(pixmap, <span>&amp;</span>main_win);
            }
        };
    }

    <span>Ok</span>(())
}
</pre>
</div>
<p>
In Xlib, you don&#39;t make UI in the declarative way. Instead, you keep track of the events in the window and redraw it as needed.  In this case, the solution is to draw the text only when the Expose event occurs.
</p>
<div>
<pre><span>fn</span> <span>main</span>() -&gt; <span>Result</span>&lt;(), <span>Box</span>&lt;<span>dyn</span> <span>std</span>::<span>error</span>::<span>Error</span>&gt;&gt; {
    
    <span>let</span> <span>mut</span> <span>xlib</span> = <span>ui</span>::new_xlib()<span>?</span>;
    <span>let</span> <span>mut</span> <span>display</span> = <span>ui</span>::<span>Display</span>::try_new(<span>&amp;</span>xlib)<span>?</span>;
    <span>let</span> <span>screen</span> = <span>ui</span>::<span>Screen</span>::try_new(<span>&amp;</span><span>mut</span> xlib, <span>&amp;</span><span>mut</span> display)<span>?</span>;
    <span>let</span> <span>mut</span> <span>visual</span> = <span>ui</span>::<span>Visual</span>::try_new(<span>&amp;</span>xlib, <span>&amp;</span><span>mut</span> display, <span>&amp;</span>screen)<span>?</span>;
    <span>let</span> <span>root_win</span> = <span>ui</span>::<span>Window</span>::new_root(<span>&amp;</span>xlib, <span>&amp;</span><span>mut</span> display, <span>&amp;</span>screen);
    <span>let</span> <span>background</span> = 0x1d2021;
    <span>let</span> <span>mut</span> <span>main_win</span> = <span>ui</span>::<span>Window</span>::new_main(
        <span>&amp;</span>xlib,
        <span>&amp;</span><span>mut</span> display,
        <span>&amp;</span>screen,
        <span>&amp;</span><span>mut</span> visual,
        <span>&amp;</span>root_win,
        (0, 0, 800, 600),
        background,
        <span>&#34;FlameGraph Viewer&#34;</span>,
        <span>&#34;FlameGraph Viewer&#34;</span>,
        <span>std</span>::<span>env</span>::args(),
    )<span>?</span>;

    <span>let</span> <span>mut</span> <span>pixmap</span> = <span>ui</span>::<span>Pixmap</span>::new(<span>&amp;</span>xlib, <span>&amp;</span><span>mut</span> display, <span>&amp;</span>main_win);
    <span>let</span> <span>gc</span> = <span>ui</span>::<span>GraphicContext</span>::new(<span>&amp;</span>xlib, <span>&amp;</span><span>mut</span> display, <span>&amp;</span>main_win);
    <span>let</span> <span>mut</span> <span>ui_factory</span> = <span>ui</span>::<span>Factory</span>::new(xlib, display, screen, visual, root_win, gc);

    <span>let</span> <span>font_data</span> = <span>include_bytes!</span>(<span>&#34;../DejaVuSansMono.ttf&#34;</span>);
    <span>let</span> <span>font</span> =
        <span>Font</span>::try_from_bytes(font_data <span>as</span> <span>&amp;</span>[<span>u8</span>]).expect(<span>&#34;error constructing a Font from bytes&#34;</span>);
    
    ui_factory.show_window(<span>&amp;</span>main_win);

    <span>let</span> <span>mut</span> <span>quit</span> = <span>false</span>;
    <span>while</span> !quit {
        <span>let</span> <span>mut</span> <span>is_redraw</span> = <span>false</span>;
        <span>let</span> <span>event</span> = ui_factory.wait_event();
        
        
        ui_factory.set_foreground(background);
        ui_factory.set_background(0xffffff);
        ui_factory.fill_rectange(<span>&amp;</span>pixmap, (main_win.width(), main_win.height()));
        <span>match</span> event {
            
            <span>ui</span>::<span>Event</span>::<span>Expose</span>(0) =&gt; {
                draw_caption(<span>&#34;RustType&#34;</span>,
                    <span>&amp;</span><span>mut</span> ui_factory, <span>&amp;</span>font, <span>&amp;</span>pixmap, 0xffffff, background);
                <span>println!</span>(<span>&#34;expose redraw&#34;</span>);
                is_redraw = <span>true</span>;
            }
            
            <span>ui</span>::<span>Event</span>::<span>Expose</span>(_) =&gt; (),
            <span>ui</span>::<span>Event</span>::<span>KeyPress</span>(<span>KEY_Q</span>) =&gt; quit = <span>true</span>,
            <span>ui</span>::<span>Event</span>::<span>KeyPress</span>(key) =&gt; <span>println!</span>(<span>&#34;key code </span><span>{:x}</span><span>&#34;</span>, key),
            <span>ui</span>::<span>Event</span>::<span>ConfigureNotify</span> { width, height } =&gt; {
                main_win.set_width(width <span>as</span> _);
                main_win.set_height(height <span>as</span> _);
                pixmap = ui_factory.resize_pixmap(pixmap, <span>&amp;</span>main_win);
            }
        };

        <span>if</span> is_redraw {
            <span>println!</span>(<span>&#34;swap buffers&#34;</span>);
            ui_factory.swap_buffer(<span>&amp;</span>main_win, <span>&amp;</span>pixmap);
        }
    }

    <span>Ok</span>(())
}
</pre>
</div>
<p>
It&#39;s annoying at first, but as I approached the implementation of the search feature in the application, I clearly understood the possible states of the application from the code.
</p>
<ol>
<li>The search should be invalidated after one of the buttons is clicked.</li>
<li>The keys <code>n</code> and <code>N</code> should work only after the search program has successfully finished.</li>
<li>If the search program finishes unsuccessfully, it shouldn&#39;t affect the current active search.</li>
</ol>
</div>
</div>

<div id="outline-container-orgef96479">
<h4 id="orgef96479">Render only the visible text</h4>
<div id="text-orgef96479">
<p>
Rendering text for every rectangle doesn&#39;t really work in this case, because the rectangles are short, while the text is long.  As a result, the text goes beyond the rectangle and sets on top of the text of neighboring rectangle.  It makes such a mess in which you can&#39;t read the names of the rectangles.  Luckily, when you draw text at this level, you control every pixel.  In order to prevent the mess, I needed to trim that text which goes beyond its button.  There was one more reason for the trimming - the drawing of names of the perf events took a couple of minutes.  The API of rusttype allows me to get the information of every glyph (in our case it means a character).  It allows me to get the coordinates of the pixels of every glyph and draw them on the canvas.  As I know the coordinates of the pixels I can omit those ones which are beyond the rectangles.
</p>
<div>
<pre><span>let</span> <span>scale</span> = <span>Scale</span>::uniform(font_size);
<span>let</span> <span>v_metrics</span> = font.v_metrics(scale);
<span>let</span> <span>offset</span> = point(0.0, v_metrics.ascent);
<span>let</span> <span>glyphs</span>: <span>Vec</span>&lt;_&gt; = font.layout(content.as_ref(), scale, offset).collect();
glyphs.iter().for_each(|g| {
    <span>if</span> <span>let</span> <span>Some</span>(bb) = g.pixel_bounding_box() {
        g.draw(|x, y, v| {
            <span>let</span> <span>color</span> = color_blend(foreground, background, v);
            <span>let</span> <span>x</span> = x <span>as</span> <span>i32</span> + bb.min.x + start_at.0;
            <span>let</span> <span>y</span> = y <span>as</span> <span>i32</span> + bb.min.y + start_at.1;
            <span>if</span> ((x - start_at.0) <span>as</span> <span>u32</span>) &lt; width_limit {
                canvas.draw_point(color, x, y);
            }
        })
    }
});
</pre>
</div>
<p>
Once I&#39;ve drawn the text, I realized that it doesn&#39;t make sense to draw text on a very small button, as the first 2-3 letters are unlikely to convey any meaningful idea about the name of the button&#39;s perf event.  Just one simple condition solves the problem.
</p>
<div>
<pre>button_table.into_iter().for_each(|rect| {
    rect.draw(ui_factory, scrollable_pixmap);
    <span>if</span> rect.width &gt; 10 {
        draw_caption(
            rect.node.name(),
            <span>&amp;</span><span>ButtonDrawer</span> {
                ui_factory,
                <span>pixmap</span>: scrollable_pixmap,
            },
            font,
            <span>FONT_SIZE</span>,
            <span>TEXT_COLOR</span>,
            rect.color,
            rect.pos,
            rect.width,
        );
    }
});
</pre>
</div>
</div>
</div>
<div id="outline-container-orga1b4c1c">
<h4 id="orga1b4c1c">Segmentation fault is not a big deal</h4>
<div id="text-orga1b4c1c">
<p>
One function of Flame Graph Viewer is zooming to a certain frame.  If you zoom to a certain frame, you get the traceback to the frame.  The traceback consists of all of the parents of the frame.  In order to find them, I need to hold a reference to the parent in every frame.  So far, Rust doesn&#39;t allow the creation of self-referential structures with a regular pointer.  If it had allowed, the code would have looked like this:
</p>
<div>
<pre><span>struct</span> <span>Node</span>&lt;&#39;<span>self</span>&gt; {
    <span>parent</span>: <span>&amp;</span>&#39;<span>self</span> <span>Node</span>
}
</pre>
</div>

<p>
In short,  it&#39;s impossible because the Rust compiler can&#39;t determine how long the self reference should live.  Details are <a href="https://arunanshub.hashnode.dev/self-referential-structs-in-rust">here</a>.
</p>

<p>
There are a couple of popular options to deal with it:
</p>
<ol>
<li><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a> or his brother <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a>.  This way you can get a memory leak if you forget to clean references.</li>
<li>An unsafe option is <a href="https://devdocs.io/rust/std/ptr/index">raw pointer</a>.  Using this method, you have to deal with <a href="https://en.wikipedia.org/wiki/Dangling_pointer">dangling</a> pointers and null pointers.  In other words, there are three cases:
<ol>
<li>It points to an inaccessible memory block.  The address 0x0 for example.</li>
<li>It points the memory block which is freed, but the type of the data matches the type of the pointer.</li>
<li>It points to the block of memory is <a href="https://nrk.neocities.org/articles/free-null">freed</a> and filled with some data of the type which doesn&#39;t match the type of the pointer.</li>
</ol></li>
<li>Use <a href="https://crates.io/crates/self_cell">one</a> <a href="https://crates.io/crates/zc">of</a> <a href="https://crates.io/crates/components-arena">the</a> <a href="https://crates.io/crates/selfie">crates</a> which allows you to create a self-referential structure.  Of course, each one has its pros and cons.</li>
<li>Maintain a vector of objects and keep the index to the parent.</li>
</ol>

<p>
In my case the tree is immutable.  The parent of a node lives as long as the tree. Once a parent is created, all of the pointers from its children are valid.  This means I will not come across the problems mentioned in point 3.  With this in mind, I decided to use raw pointers.
</p>

<p>
So the structure of node is
</p>
<div>
<pre><span>struct</span> <span>Node</span> {
    <span>parent</span>: <span>Option</span>&lt;<span>NonNull</span>&lt;<span>Node</span>&gt;&gt;, 
    <span>children</span>: <span>Vec</span>&lt;<span>Node</span>&gt;, 
    <span>name</span>: <span>String</span>,
    <span>time</span>: <span>Range</span>&lt;<span>u64</span>&gt;,
}
</pre>
</div>
<p>
With absolute confidence, I used this structure.  Unfortunately, it failed me when I implemented the handlers for the button clicks.  Namely, once a button is clicked, the tree is rebuilt, and I see the subtree.  The root of the subtree is the button I&#39;ve pressed.  It wasn&#39;t even clear in the beginning that I had issues with the memory.  Later I found that clicking the same button gives a different subtree.  It&#39;s definitely a bug.
</p>

<p>
I realized that the problem is related to the fact that vectors of children move in the memory if they don&#39;t have enough space to extend.  An extension is needed when you push items into a vector.  In this case, the extension involves a process called reallocation. A new space is allocated for the vector.  That new space is large enough for the vector to extend.  The vector data is copied to the new space in the memory and the capacity of the vector is increased.
</p>

<p>
The old space of the vector still holds the old data, but the space is marked as unallocated and can be reused.  Eventually, the pointer points to the data at the old space.  Dereferencing the pointer leads to these 3 situations:
</p>

<ol>
<li>Segmentation fault if the old space remains unallocated.</li>
<li>Glitches if the old space is allocated.  In my case the old space is reused for the new nodes. I pressed on the parent node, but end up at some unexpected place of the graph.</li>
<li>Glitches again if the old space is allocated, but the type of the data is different.  The pointer is dereferenced, and the data is cast to the type the pointer expects, rather than data which is actually there.  It didn&#39;t happen in my case, but it&#39;s possible.</li>
</ol>

<p>
In this animation, I show two arrows (-1- and -2-) which point to their parents.  Then their parents are moved, and the arrows point to an unallocated space.  Then the space is reused for the vector of the children of the new Parent 3. The arrow -1- points to the first child (n1p3) of the Parent 3, which means that the child of the Parent 1 thinks that n1p3 is its parent, which is absurd.
</p>

<video controls="controls" width="600" id="org5a25a00">
<source src="/VectorMove.webm" type="video/webm"/>
<p>
Your browser does not support the video tag.
</p>
</video>

<p>
I decided to make vectors with a big capacity to prevent the reallocations.  It didn&#39;t help.  I was surprised, but sure that the problem is related to reallocation.  I removed the setting of the capacity and made vectors of boxes. Thus, the <code>parent</code> pointer points not to an element of the vector, but to the chunk of memory allocated for the box.  Once a vector is moved, the addresses of the boxes are changed, but not the addresses of the nodes in the boxes.
</p>

<video controls="controls" width="600" id="org89962be">
<source src="/VectorMoveSolution.webm" type="video/webm"/>
<p>
Your browser does not support the video tag.
</p>
</video>

<p>
And eventually the code of the structure looks like this
</p>
<div>
<pre><span>struct</span> <span>Node</span> {
    <span>parent</span>: <span>Option</span>&lt;<span>NonNull</span>&lt;<span>Node</span>&gt;&gt;, 
    <span>children</span>: <span>Vec</span>&lt;<span>Box</span>&lt;<span>Node</span>&gt;&gt;, 
    <span>name</span>: <span>String</span>,
    <span>time</span>: <span>Range</span>&lt;<span>u64</span>&gt;,
}
</pre>
</div>

<p>
Actually, Rust has a container, named <a href="https://doc.rust-lang.org/std/pin/struct.Pin.html">Pin</a>, designed for these kinds of situations.  It&#39;s designed to prevent references to those objects which move around the stack.  The moving implies that when you pass an object as an argument to a function, it has a different address.  As a result, the parent of a node in a tree should be on the heap.  It was hard for me to understand.  I got it only when I found how function calling is generally implemented in assembly.
</p>

<p>
The detail explanation of Pin I understood came from this <a href="https://www.youtube.com/watch?v=DkMwYxfSYNQ">video</a>.  In short the value in the container must satisfy the trait <a href="https://doc.rust-lang.org/std/marker/trait.Unpin.html">Unpin</a>.
</p>
<div>
<pre><span>impl</span>&lt;<span>P</span>&gt; <span>Pin</span>&lt;<span>P</span>&gt;
<span>where</span>
    <span>P</span>: <span>Deref</span>,
    &lt;<span>P</span> <span>as</span> <span>Deref</span>&gt;::<span>Target</span>: <span>Unpin</span>
</pre>
</div>

<p>
A better data type would be <code>children: Vec&lt;Pin&lt;Box&lt;Node&gt;&gt;&gt;</code>.  I avoided it for now, as I wanted to completely avoid these double references.
</p>
</div>
</div>
<div id="outline-container-org7c90fd6">
<h4 id="org7c90fd6">Search</h4>
<div id="text-org7c90fd6">
<p>
I really missed having a proper search in flamegraphs.  Sometimes I preferred to inspect perf events in plain text format instead of the flamegraph.  It allows me to use the tools like <a href="https://www.gnu.org/software/grep/manual/grep.html">grep</a>, <a href="https://github.com/junegunn/fzf">fzf</a>, <a href="https://www.gnu.org/software/sed/">sed</a>, <a href="https://github.com/kriomant/ogrep-rs">ogrep</a> to manipulate the text representation of the perf events and look and examine the hot spots in the program from different angles.
</p>

<p>
In order to implement a search box, you have to address a few aspects apart from text drawing.
</p>
<ol>
<li>Selection</li>
<li>Deletion</li>
<li>Copying</li>
<li>Pasting</li>
<li>Jumping of the caret</li>
</ol>
<p>
I checked the code of ST in order to understand how much work needs to be done.  At that moment, I wished I had used some GUI toolkit.  Apart from those things, I had to implement the actual search, and I wanted to have the search be fuzzy.  This reminded me that I had embedded <a href="https://github.com/davatorium/rofi">Rofi</a> into my ST to search for links in the terminal output.
</p>


<figure id="org9d4e312">
<img src="https://laladrik.xyz/img/stWithRofi.png" alt="stWithRofi.png"/>

<figcaption><span>Figure 4: </span>Simple Terminal with embedded Rofi to pick hyper links from the output</figcaption>
</figure>

<p>
I didn&#39;t want to use Rofi for this project.  Rofi is good, but it&#39;s not as fast as <a href="https://tools.suckless.org/dmenu/">Dmenu</a>.  I did a little test with it and my 38003 records were loaded momentarily.  Moreover, the search results updated without any delay after I pressed a button.  I needed to embed it into my application.  X11 allows to set a window of one application to be a parent for a window of another application.  Dmenu exposes the functionality, so you don&#39;t need to change the source code for it. In order to embed Dmenu into your application, you have to:
</p>
<ol>
<li>Get the ID of the window of your application.  You get it when you call <code>XCreateWindow</code>.</li>
<li>Invoke Dmenu with the flag <code>-w</code> where you pass the ID.</li>
</ol>

<p>
I added a search box which makes the actual fuzzy search.  The default behavior didn&#39;t meet my needs.  It returned only the picked record.  In order to make it usable for me, I added a couple of patches:
</p>
<ol>
<li><a href="https://tools.suckless.org/dmenu/patches/navhistory/">History</a>.  Just to pop up the previous search.</li>
<li><a href="https://tools.suckless.org/dmenu/patches/numbers/">Numbers</a>.  This will return the number of the results.  It allows me to relate the search results to the buttons in the graph.</li>
<li><a href="https://tools.suckless.org/dmenu/patches/multi-selection/">Multiple selection</a>.  In case I want to check a couple of buttons with the same name.</li>
<li><a href="https://tools.suckless.org/dmenu/patches/case-insensitive/">Case-insensitive</a>.  The patch allows setting whether the search is case-sensitive or not. Given the case in a symbol name matters, I&#39;ve added it.</li>
</ol>

<p>
Also, I implemented a feature in Dmenu to select all the results. So:
</p>
<ol>
<li>Press Enter to add the selected entry to the results and close the window.</li>
<li>Press Ctrl-Enter to add the current entry to the results.</li>
<li>Press Alt-Enter to add all of the filtered entries to the results.</li>
</ol>


<figure id="org6f22028">
<img src="https://laladrik.xyz/img/fgvWithDmenu.png" alt="fgvWithDmenu.png"/>

<figcaption><span>Figure 5: </span>Flame Graph Viewer with Dmenu as a searchbox</figcaption>
</figure>
</div>
</div>
</div>
</div><div id="outline-container-orgd4a5c5f">
<h2 id="orgd4a5c5f">Conclusion</h2>
<p>
What&#39;s the bottom line? I got a tool I had needed for a long time. I learnt a few lessons.  I demystified a quite popular dogma.  I had fun.
</p>
<div id="outline-container-orgcb3a2c1">
<h3 id="orgcb3a2c1">The dogma</h3>
<div id="text-orgcb3a2c1">
<p>
We don&#39;t need to care about the memory and CPU, because we have a lot.
</p>

<p>
It&#39;s fair from one side, but it went too far. The developers started thinking that only one application runs on a user&#39;s computer - the application which they create.  Let&#39;s make everything in a browser, because it has everything.  The example of this particular application is not that representative, because the author of FlameGraph created it for himself and wanted to solve his problem.  Unintentionally, FlameGraph solved problems of a lot of programmers and system engineers. It helped me quite a few times.  This time it failed because of the limits of a browser.
</p>

<p>
Nowadays we say something like: &#34;We have a lot of memory and CPU, so we don&#39;t need to care about it&#34;, and after we make a browser application instead of a native client. Inspecting flamegraphs in a browser doesn&#39;t work with the amount of Perf Events generated for a more or less big project.  I have 16 threads and 64GB RAM.  Did it help me?  Any browser takes ages to load the generated SVG along with its JS.  After loading, it just can&#39;t show me a subgraph when I click something.
</p>

<p>
My solution has two dependencies.  I haven&#39;t done any optimizations. I just took enough to solve the problem.  We should start asking the question: &#34;Do we really need all of this to make a program?&#34;.  Yes, modern computers have a lot of memory, but they also run many programs besides the one you&#39;re developing.
</p>
</div>
</div>
<div id="outline-container-orge7094f5">
<h3 id="orge7094f5">Lessons</h3>
<div id="text-orge7094f5">
<ol>
<li>Vector doesn’t guarantee that its data remains at a specific address, even without reallocations.  You can&#39;t be sure that a raw pointer points to a valid data from a vector. The issue might be specific for Rust. That remains an area to research.  The experience showed that a vector of pointers can be safe for raw pointers.  And the raw pointers should point to the data which is pointed at by those pointers from that vector.</li>
<li>There are some X11 applications which can be reused.  I&#39;m not sure if it&#39;s possible in <a href="https://wayland.freedesktop.org/">Wayland</a>. But this seems to be a very neat feature.  We do it constantly in websites.  We embed audio/video players, calendars, chats (a chat with a consultant), advertisements, VoIP widgets, commercials. We get a script and invoke a command or two from the script.  A similar approach was taken with Dmenu - I set a command to invoke it.</li>
<li>Throwing out extra stuff does not imply harder implementation.  Here is where the marketing comes.  The total amount of code with tests and comments is <b>1710</b> lines.  The original implementation of FlameGraph in Perl is <b>1161</b> lines.  Yes, I wrote more code, but it&#39;s not that much if you take into the account these things:
<ul>
<li>The speed of the application, which allows to inspect 1000 times bigger flame graphs.</li>
<li>The fuzzy search.  What was possible only if you inspected the text report instead of the graphics.</li>
<li>Some tests.  The original solution has none.</li>
<li>Defined types to make relations in code explicit.</li>
<li>The application doesn&#39;t require such a big application like a browser.</li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org1809506">
<h3 id="org1809506">Fun</h3>
<div id="text-org1809506">
<p>
It was a really interesting experience.  Apart from achieving the program I wanted, I solved a couple of problems that I don’t usually encounter at work:
</p>
<ol>
<li>I implemented scrolling that doesn’t consume much CPU.  Eventually I threw it away, but it was interesting to understand the underlying difficulties.</li>
<li>Handling clicks by myself was overwhelming, but it was a relief to discover that a simple data structure solved most of the problem. In addition, I was really happy to see the synergy when the same data structure also solved the problem of hover events.</li>
<li>Dealing with visual glitches.  It was scary to see the first blinking of the application.  It&#39;s not like fixing a bug in transferring data from the database to the frontend and back.  You can examine the data, because it&#39;s human-readable.  With graphics, what are you going to check?  The numbers of the matrix of the result picture?  I sat down and thought through the process, made a picture of the transitions in the state machine, considered how the canvas is drawn.  After that, finding one extra flushing of the buffer fixed the glitch was easy. It made me feel great.</li>
<li>Finding a segmentation fault was challenging when I was a university student.  But after reading a few books, I stopped being scared of these kinds of things.  Understanding the underlying processes behind containers and the OS API helped to find the bug fast.  But to be fair, I took a break and solved the problem the next day.</li>
</ol>
</div>
</div>
<div id="outline-container-org9fd8aa0">
<h3 id="org9fd8aa0">Plans</h3>
<div id="text-org9fd8aa0">
<p>
I have a few things I want to see
</p>
<ol>
<li>Proper resizing without reloading.</li>
<li>Automated tests of the user interface.</li>
<li>Usage documentation.</li>
<li>Some continuous integration would be really nice to have, to run the tests and build the package.</li>
<li>Create a package for some of the top Linux distributions, or at least for <a href="https://search.nixos.org/packages">Nix</a>.</li>
<li>The condition of drawing the text in small rectangles should consider DPI.</li>
</ol>
</div>
</div>
</div></div>
  </body>
</html>
