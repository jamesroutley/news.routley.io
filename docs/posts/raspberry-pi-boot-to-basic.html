<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://popey.com/blog/2021/01/raspberry-pi-boot-to-basic/">Original</a>
    <h1>Raspberry Pi Boot to BASIC</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
  <div>
    <div>
      <article role="main">
        <h2 id="10-rem-tldr">10 REM TL;DR</h2>
<p>My Raspberry Pi 400 boots from this:</p>
<p><img src="http://mattambrogi.bearblog.dev/blog/images/2021-01-25/piboot.jpg" alt="Pi 400"/></p>
<p>To this.</p>
<p><img src="http://mattambrogi.bearblog.dev/blog/images/2021-01-25/bbcsdl.jpg" alt="BBC SDL"/></p>
<p>BBC BASIC!</p>
<p>This blog post is what parts I smashed together to make this work and why.</p>
<h2 id="20-print-hello">20 PRINT ‚ÄúHELLO‚Äù</h2>
<p>40 years ago this Christmas, I got my first ‚Äúpersonal computer‚Äù. It was a Sinclair ZX81 with 1KiB of RAM and a tape deck for storage. Every time I powered it on, like all ‚Äò81 owners, I was greeted with this.</p>
<p><img src="http://mattambrogi.bearblog.dev/blog/images/2021-01-25/zx81_1.png" alt="ZX81"/></p>
<p>A couple of taps later, and I had written some code!</p>
<p><img src="http://mattambrogi.bearblog.dev/blog/images/2021-01-25/zx81_2.png" alt="ZX81"/></p>
<p>Ok, not a super auspicious creation, but it‚Äôs a start. It‚Äôs likely the same first program you wrote if you had one. Perhaps with rude words, who knows, they were fun times back in the ‚Äô80s. Through the following years I had a <a href="https://en.wikipedia.org/wiki/Sinclair_Research">Sinclair</a> <a href="https://en.wikipedia.org/wiki/ZX_Spectrum">ZX Spectrum 16K</a> (later upgraded to 48K), a <a href="https://en.wikipedia.org/wiki/ZX_Spectrum#ZX_Spectrum_+2">Spectrum +2 128K</a> and an <a href="https://en.wikipedia.org/wiki/Amstrad">Amstrad</a> <a href="https://en.wikipedia.org/wiki/Amstrad_CPC#CPC_464">CPC 464</a>. All of which also booted directly to a programming language - <a href="https://en.wikipedia.org/wiki/BASIC">BASIC</a>.</p>
<p>After school, in 1988 I studied BTEC National Diploma in Computer Studies. We had some classes on a <a href="https://en.wikipedia.org/wiki/PRIMOS">Pr1meOS</a> based system (yes, it‚Äôs written with a ‚Äú1‚Äù for an ‚ÄúI‚Äù), and other times we‚Äôd use <a href="https://en.wikipedia.org/wiki/BBC_Micro">BBC Micro computers</a>.</p>
<p>In one class on <a href="https://en.wikipedia.org/wiki/DBase">databases</a>, we used genuine IBM PCs which is probably where my nostalgic <a href="http://mattambrogi.bearblog.dev/blog/2020/12/keyboards-old-and-new/">love</a> of the Model M keyboard comes from. Often times we‚Äôd arrive before the lecturer. Each machine had two floppy disk drives, and no hard drive. The lecturer had the floppies, so we sat and waited, getting bored before the lesson started.</p>
<p>IBM PCs back then had BASIC on ROM, much like the contemporary 8-bit microcomputers I‚Äôd had at home. So if there was no operating system found, such as on floppy or hard disk, you‚Äôd get this.</p>
<p><img src="http://mattambrogi.bearblog.dev/blog/images/2021-01-25/basic.png" alt="BASIC"/></p>
<p>I would often get so bored that I‚Äôd start coding something in BASIC while we waited for class to start. Most of the time I‚Äôd just create simple programs to display funky graphical patterns on the display. It was a brain exercise before the classes started, a creative outlet, and was fun too.</p>
<p>On one occasion my friends - also bored - saw what I was doing and started suggesting I make changes. ‚ÄúMake the lines different colours!‚Äù - ‚Äú<em>Make the lines bounce off the walls of the screen!</em>‚Äù, ‚Äú<em>Make it go slower/faster!</em>‚Äù etc. Rapidly channelling my classmates‚Äô requests into code was a fun coding challenge in the morning.</p>
<p>Soon after that computers started shipping with hard disks by default, which contained operating systems instead of booting directly to a programming language. Having an on-board mass storage device, which could contain a myriad languages, made shipping one in ROM a bit pointless. But I miss those days of booting directly to a language and nothing else.</p>
<p><em>‚ÄúBut Alan, Linux computers boot to a shell prompt, BASH, which you can program in and MacOS ships it too, and Windows has PowerShell etc</em>‚Äù</p>
<p>Shhh! While that‚Äôs all true, no modern, mainstream operating system boots <em>to</em> a programming language, specifically not to BASIC.</p>
<p>I <em>miss</em> computers that boot to BASIC. So I looked into how interesting it might be to make a desktop or laptop computer boot to BASIC in 2021.</p>
<p>Sure, I could hook up one of my many retro computers, or boot an old ThinkPad and load some BASIC interpreter, I wanted something new, and zeitgeisty!  Then it hit me, I have the perfect computer to do this, the Raspberry Pi 400! The Pi has a strong connection back to the original BBC Micros I used in the 80‚Äôs. It even looks like an 80‚Äôs computer.</p>
<p><img src="http://mattambrogi.bearblog.dev/blog/images/2021-01-25/pi400.jpg" alt="Raspberry Pi 400"/></p>
<p>It‚Äôs a travesty that it <em>doesn‚Äôt</em> boot to BASIC out of the box (one might argue) üòÄ. So I set out on my goal of getting BASIC booting on the Pi. My key requirement was that it show me a traditional full-featured BASIC on boot, without having to login. I didn‚Äôt want to have to wait for a full desktop environment to start, and didn‚Äôt like the idea of logging in at the <code>console</code> / <code>TTY</code>.</p>
<h2 id="30-gosub-8086">30 GOSUB 8086</h2>
<p>The easy solution is to use an emulator of a system of yore, and just use the onboard BASIC which shipped on ROM. This seemed like cheating to me. Anyone can spin up an emulator on basically anything, that‚Äôs not a challenge. So I dismissed emulation.</p>
<p><img src="http://mattambrogi.bearblog.dev/blog/images/2021-01-25/dosbox-x.png" alt="DOSBOX-X"/></p>
<p>I did consider looking for the BASIC / BASICA / <a href="https://en.wikipedia.org/wiki/GW-BASIC">GW-BASIC</a> binaries and try booting them somehow, but give they‚Äôre not freely available, and more importantly are Intel 8086 machine code, and I‚Äôm using an ARM based Raspberry Pi, that wouldn‚Äôt easily fly (without emulation).</p>
<p>I am not capable of writing a BASIC interpreter, but the good news is, other people have. I found a couple of ‚Äúmodern‚Äù re-implementations of BASIC which were good candidates, <a href="https://robhagemans.github.io/pcbasic/">PCBASIC</a> by Rob Hagemans and <a href="http://www.bbcbasic.co.uk/index.html">BBCSDL</a> by R. T. Russell. Both are excellent, open source, currently maintained projects!</p>
<p><img src="http://mattambrogi.bearblog.dev/blog/images/2021-01-25/bbcbasic.png" alt="BBC BASIC"/></p>
<p><img src="http://mattambrogi.bearblog.dev/blog/images/2021-01-25/pcbasic.png" alt="PC-BASIC"/></p>
<p>Both of them have some platform requirements which are served well on traditional Linux distributions. The above screenshots were taken on my desktop while I tested the various interpreter options. There‚Äôs other options like <a href="https://www.qb64.org/portal/">QB64</a> which carefully reproduces the QBasic / QuickBasic of the late MS-DOS era. While I like QB64, it‚Äôs not the aesthetic I was after.</p>
<p><img src="http://mattambrogi.bearblog.dev/blog/images/2021-01-25/qb64.png" alt="QB64"/></p>
<h2 id="40-return">40 RETURN</h2>
<p>For the operating system, something Linux based was the only real logical option here. I‚Äôm sure all the FreeBSD, RISCOS and other alternative OS freaks are tutting or closing this tab right now, sorry. I only really know Linux well, and for a quick fun hack project I didn‚Äôt want to have to re-learn a new OS just for this. Another day, maybe.</p>
<p>I did briefly consider whether it might be possible to boot directly into BASIC without any operating system at all. That might be somewhat beyond my capabilities right now as I imagine I‚Äôd need to deal with re-implementing an awful lot of the graphics, input, sound and IO stack that‚Äôs already well-done in Linux today.</p>
<p>I tried a whole bunch of distributions including <a href="https://dietpi.com/">Diet Pi</a>, <a href="http://www.tinycorelinux.net/">Tiny Core</a> and <a href="https://www.raspberrypi.org/software/operating-systems/">Raspbian</a>. However I had some small but frustrating issues with all of them here and there, so decided to return to something I knew well. This was to isolate problems I was dealing with to the BASIC interpreters themselves and libraries, and not the OS too. I‚Äôm sure all of what I have done <em>can</em> be made to work on the above distros, I just chose another path.</p>
<p>I went for <a href="https://ubuntu.com/">Ubuntu</a>, duh. I didn‚Äôt want to use the new <a href="https://ubuntu.com/blog/build-a-raspberry-pi-desktop-with-an-ubuntu-heart">Ubuntu Desktop</a> image for Raspberry Pi because it has a ton of extra graphical packages installed which takes me away from my lean ‚ÄúBoot to BASIC‚Äù plan. Sure, I could rip all that out, but that‚Äôs more time and effort. I wanted something quite lean from the get-go. There‚Äôs two <a href="https://ubuntu.com/download/raspberry-pi">options</a> available here, Ubuntu Server and Ubuntu Core.</p>
<p>Ubuntu Server is available as an image for the Raspberry Pi which can be blatted onto an microSD card via <code>ddrescue</code> or your favourite tool. Ubuntu Server is basically a command-line only minimal install of Ubuntu with a few server related things installed, no desktop. It uses the traditional <code>apt</code> package manager, and has support for <code>snap</code> too.</p>
<p>Ubuntu Core is also available for the Pi as an image. It is an immutable <code>snap</code> based super-minimal install of Ubuntu designed for IoT and applicance use cases. I think this would have been the ideal candidate. However, because Ubuntu Core doesn‚Äôt have <code>apt</code> it isn‚Äôt ideal for doing the iterative development and hacking.</p>
<p>So I went for Ubuntu Server to hack and build on, and when I put this in ‚Äúproduction‚Äù I‚Äôll migrate to Ubuntu Core, maybe. üò¨</p>
<h2 id="50-peek-2">50 PEEK 2</h2>
<p>PCBASIC is written in Python, and is already packaged in Ubuntu. I figured this would be an easy way forward as I could <code>apt install python3-pcbasic</code> then run <code>pcbasic</code>. That does indeed work in that you get a BASIC interpreter, but the default mode when no GUI is available is to run like any other curses-style console application.</p>
<p>That‚Äôs fine, and I could certainly configure the system to auto-login and run this console application, it‚Äôs not quite right. The interpreter wouldn‚Äôt be able to do any kinds of graphical operations, I‚Äôd <em>only</em> have text mode. That‚Äôs be fun for sure, but not quite what I‚Äôm after.</p>
<p>In parallel I was also looking at BBCSDL which is written in C, and levergaes SDL2. With a bit of hacking I got it launching using Mir as a wayland compositor on top of Ubuntu Server. However the video output was corrupt.</p>
<p><img src="http://mattambrogi.bearblog.dev/blog/images/2021-01-25/bbconmir.png" alt="BBCSDL on Mir"/></p>
<p>After some discussion with the Mir team last week, it seems BBCSDL was trying to set a specific resolution and for whatever reason Mir didn‚Äôt like this. BBCSDL works in a window under Mir on a GUI or Pi running a desktop environment. But when launched as an ‚Äòappliance‚Äô as the only graphical surface, I got the unusable display above.</p>
<h2 id="60-stop">60 STOP</h2>
<p>I took a break from fiddling with this toy project for a day or so. Then my colleague Oliver Grawert (<a href="https://ograblog.wordpress.com/">ogra</a>) mentioned he‚Äôd played and had some success. He‚Äôs been working on building some interesting SDL2 applications in snaps to run as full-screen appliances without X or Wayland on a Pi. More on those another day. I wasn‚Äôt aware, but it‚Äôs possible that SDL2 applications can draw graphics directly to the display, much like using the framebuffer on a PC.</p>
<p>He offered some patches to improve my snap. It works! Here‚Äôs what it currently looks like. It‚Äôs a bit slow, but that‚Äôs mostly the Ubuntu side doing a bunch of Ubuntu things. Once it‚Äôs booted though, it runs just like you expect.</p>


<iframe width="560" height="315" src="https://www.youtube.com/embed/be9b_a9pNzQ" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>The snapcraft.yaml we used to build this snap is over on this <a href="https://gist.github.com/popey/02363a3768d0d01a0ad5c0abb759c7fe">GitHub gist</a>. I haven‚Äôt published the snap in the Snap Store, I just built and installed it locally for now. The key takeaways from this are:</p>
<ul>
<li>It builds armhf binaries, which can be installed on armhf (32-bit) or arm64 (64-bit) installs</li>
<li>We build and bundle <a href="https://github.com/spurious/SDL-mirror">sdl2</a> specifically without building X11 or Wayland support</li>
<li>ALSA is redirected to pulseaudio using the <a href="https://github.com/diddlesnaps/snapcraft-alsa">snapcraft-alsa</a> work by <a href="https://github.com/diddlesnaps">Daniel Llewellyn</a>. Although currently I‚Äôve not tested audio.</li>
<li>The <a href="https://github.com/ubuntu/snapcraft-desktop-helpers">desktop helpers</a> are used to configure a bunch of desktop-ish stuff like font caches</li>
<li>The <a href="https://github.com/raspberrypi/firmware">pi firmware</a> enables us to draw pixels on the screen without X11 and Wayland</li>
<li><a href="https://github.com/rtrussell/BBCSDL">BBCSDL</a> is built without staging the examples in the snap, only the binary and one library are snapped</li>
<li>The snap needs <code>devmode</code> confinement (currently) because there‚Äôs not an interface to get input from the keyboard without X11 or Wayland being present. I believe ogra is working on that.</li>
<li>The <code>bbcsdl</code> command is defined in the snap as a <code>daemon</code> which causes a systemd unit to be created and enabled on install, which launches the application on boot</li>
</ul>
<p>This could certainly be cleaned up. But for a proof of concept, and a bit of fun on the weekend, I think it‚Äôs pretty neat.</p>
<h2 id="run">RUN</h2>
<p>So I now have a Raspberry Pi 400 which boots directly into BBC BASIC. Great success. What now?</p>
<p>Well, <a href="https://www.bbcbasic.co.uk/bbcwin/tutorial/index.html">learn</a> (or re-learn) BBC BASIC!</p>
<p>There‚Äôs room for improvement though. The boot process is quite long - certainly not instant-on like all the 8-bit computers of yore. Perhaps I can improve boot speed with some of these:</p>
<ul>
<li>Use a faster SD card - this can make a tremendous difference</li>
<li>Stop / remove some services - I could disable networking or ssh if I‚Äôm not going to use them</li>
<li>Use <code>systemd-analyze blame</code> to find more things to remove or improve</li>
<li>Switch to a faster booting distro - I could maybe re-visit some of the lean distros like Diet Pi, now I have a working package</li>
</ul>
<p>I haven‚Äôt tested any IO (saving / loading) because I initially wanted the ‚Äúraw‚Äù experience of typing code in from cold-start, without having the <em>luxury</em> of a storage device to hold my code. I‚Äôll maybe work on that so I can load in some of the great example code that BBCSDL ships with.</p>
<p>I may also re-visit PC BASIC now we have a working (albeit kinda kludgy) setup for launching full screen applications on the Pi without X11 or Wayland. Suggestions on what to do next, also welcome!</p>
<p>No, not Commodore BASIC. ü§Æ</p>


        
          
        

        

        
      </article>

      
        
      


      

    </div>
  </div>
</div></div>
  </body>
</html>
