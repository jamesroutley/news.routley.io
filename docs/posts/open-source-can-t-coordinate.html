<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2025/05/20/open-source-cant-coordinate.html">Original</a>
    <h1>Open source can&#39;t coordinate?</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        
        <p>
          I was taking a shower this morning, and was pondering <a href="https://matklad.github.io/2025/05/19/profiling-challenge-results.html">yesterday’s problem</a>, where I <em>suspect</em>
          that I have an outdated version of <a href="https://github.com/KDAB/hotspot">hotspot</a> Linux profiler, but I can’t just go and download a fresh
          release from GitHub, because hotspot is a KDE app, and I use NixOS.
          And NixOS isn’t a problem — it’s a solution.
        </p>
        <p>
          Linux on desktop is a rickety tower of competing libraries, protocols
          and standards, which is always in an Escheresque sort of perpetual
          motion, taking off but simultaneously falling, and the best way to
          enjoy it is to take a photo, a frozen snapshot in time.
        </p>
        <p>
          The underlying force there is the absence of one unified baseline set
          of APIs for writing desktop programs. There’s no single entity that
          can coordinate the API, in contrast to Windows and MacOS.
        </p>
        <p>
          But then, how can Linux exist? How does that square with “never break
          the user space?” I’ll let you ponder the question, but let me first
          tell you a story from a domain where I consider myself an expert.
        </p>
        <section id="Better-LSP-Than-Never">
          <h2>
            <a href="#Better-LSP-Than-Never">Better LSP Than Never </a>
          </h2>
          <p>
            The past ten years saw a big shift in how we are writing software:
            baseline level of “interactive static analysis” became the norm, go
            to definition is universally available. The surprising fact here is
            that the shift occurred a decade too late!
          </p>
          <p>
            The shift was caused by Microsoft releasing its Language Server
            Protocol specification. But there’s little value in the protocol
            itself. Its implementation is
            <a href="https://matklad.github.io/2023/10/12/lsp-could-have-been-better.html">mediocre</a>, it was strictly worse than <a href="https://htmlpreview.github.io/?https://github.com/dart-lang/sdk/blob/8e6a02d899ef62ef5b8405518b36340e609198e2/pkg/analysis_server/doc/api.html">the state of the art at that time</a>, and its
            <a href="https://github.com/microsoft/language-server-protocol/pull/2027#issuecomment-2822857896">governance is abysmal</a>. The only great thing about LSP is that
            it exists!
          </p>
          <p>
            If you were anywhere near JetBrains a decade ago, it was blindingly
            obvious that the absence of broad availability of basic IDE features
            leaves a lot of the value on the table, and that the multi-process
            IPC architecture is the way to go (JetBrains did IPC for Rider). But
            it is also clear why JetBrains didn’t do LSP — why would they? While
            the right solution on the technical grounds, you aren’t going to get
            paid for being technically right. As sad as it is, some amount of
            <a href="https://en.wikipedia.org/wiki/Deadweight_loss">deadweight loss</a> is needed to capture some of the value you are
            producing, and you need to be able to capture value to invest in
            things! So the world had to wait for Microsoft to pick up the slack
            here, when they decided to gobble up the entire developer ecosystem
            as an investment.
          </p>
          <p>
            There was a decade of opportunity for OSS to coordinate around an
            IDE protocol, but that didn’t happen, because OSS is bad at
            coordination.
          </p>
        </section>
        <section id="Why-Linux">
          <h2>
            <a href="#Why-Linux">Why Linux? </a>
          </h2>
          <p>
            But then, why and how does Linux exist? I think part of that is a
            rather unique governance structure, where there’s a centralized
            control over the API area and strong commitment to the public
            interfaces. But the bigger part is POSIX. The reason why we have
            Linux, and BSDs, and XNU is that they all provide the same baseline
            API, which was defined from the outside. The coordination problem
            was pre-solved, and what remained is just filling-in the
            implementation. But there was no one to coordinate Linux on desktop.
          </p>
        </section>
      </article>
    </div></div>
  </body>
</html>
