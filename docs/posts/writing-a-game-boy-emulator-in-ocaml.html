<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://linoscope.github.io/writing-a-game-boy-emulator-in-ocaml/">Original</a>
    <h1>Writing a Game Boy Emulator in OCaml</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><p>For the past few months, I have been working on a project called <em>CAMLBOY</em>, a Game Boy emulator written in OCaml that runs in the browser. You can try it out on the following demo page:</p><p><strong><a href="https://linoscope.github.io/CAMLBOY/" target="_blank" rel="noopener noreffer">Demo Page</a></strong></p><p>I included several homebrew ROMs in the demo, so please try them out (I recommend <em>Bouncing ball</em> and <em>Rocket Man Demo</em>). You can also play with it in your mobile browser as it runs at 60 FPS on recent smartphones.</p><h2 id="repository">Repository</h2><p>You can find the repository here:</p><p><strong><a href="https://github.com/linoscope/CAMLBOY" target="_blank" rel="noopener noreffer">https://github.com/linoscope/CAMLBOY</a></strong></p><p><a href="https://github.com/linoscope/CAMLBOY" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star linoscope/CAMLBOY on GitHub">Star</a><a href="https://github.com/linoscope/CAMLBOY/fork" data-icon="octicon-repo-forked" data-size="large" data-show-count="true" aria-label="Fork linoscope/CAMLBOY on GitHub">Fork</a></p><h2 id="screenshots">Screenshots</h2><p><img src="https://linoscope.github.io/images/pokemon-vs-green.gif" alt="pokemon vs greef gif" title="pokemon-vs-green"/></p><p><img src="https://linoscope.github.io/images/zelda-opening.gif" alt="zelda-gif" title="zelda-gif"/>
<img src="https://linoscope.github.io/images/kirby-opening.gif" alt="kirby-gif" title="kirby-gif"/>
<img src="https://linoscope.github.io/images/tetris-opening.gif" alt="tetris-gif" title="tetris-gif"/>
<img src="https://linoscope.github.io/images/donkykong-opening.gif" alt="donkykong-gif" title="donkykong-gif"/></p><h2 id="why-implement-a-game-boy-emulator-in-ocaml">Why implement a Game Boy emulator in OCaml?</h2><p>Have you ever felt like the following when learning a new programming language?</p><ul><li>You can write simple program snippets but <strong>you don’t know how to write medium/large scale code<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></strong>.</li><li>You have studied <strong>advanced language features<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></strong> and have a rough understanding of how they work, but <strong>you don’t know how to use them in practice</strong>.</li></ul><p>These were exactly my thoughts when I started to study OCaml seriously a few months ago. I understood the basics of the language by reading books and implementing simple algorithms, but the above two “don’t know&#34;s prevented me from feeling like I could <em>really</em> write OCaml. I knew that the only way to get out of this situation was practice, so I started looking for a project to work on.</p><p>I choose a Game Boy emulator as the project for the following reasons:</p><ul><li>It has clear specifications, so there is no need to think about what to implement.</li><li>It is complex enough that it cannot be completed in a few days or weeks.</li><li>It is not so complex that it can’t be completed in a few months.</li><li>I have fond childhood memories of playing the Game Boy.</li></ul><p>I set the following goals for the emulator:</p><ul><li>Write code with an emphasis on readability and maintainability.</li><li>Compile to JavaScript using <a href="https://github.com/ocsigen/js_of_ocaml" target="_blank" rel="noopener noreffer">js_of_ocaml</a> and run it in the browser.</li><li>Achieve playable FPS in the smartphone browser.</li><li>Implement some benchmarks and compare various compiler backends<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>.</li></ul><h2 id="goal-of-this-article">Goal of this article</h2><p>This article aims to take you through the journey of creating a Game Boy emulator in OCaml.</p><p>This article is for you if you are interested in what it is like to</p><ul><li>Implement a Game Boy emulator.</li><li>Implement a middle-scale project in OCaml.</li><li>Use advanced features of OCaml in practice.</li></ul><p>We will cover things like</p><ul><li>Overview of the Game Boy architecture.</li><li>How to structure your code in a testable and reusable way.</li><li>How to use functors, GADTs, and first-class modules in practice.</li><li>How to find bottlenecks and improve performance.</li><li>General thoughts on OCaml.</li></ul><p>We will not cover things like</p><ul><li>Basic OCaml syntax.</li><li>Details of the Game Boy architecture.</li></ul><p>You can find materials about these uncovered topics in the <a href="#recommended-materials" rel="">Recommended Materials</a> section.</p><h2 id="architecture-diagram">Architecture diagram</h2><p>A schematic diagram of CAMLBOY looks like this:<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></p><p><img src="https://linoscope.github.io/images/camlboy-architecture.png" alt="camlboy architecture" title="camlboy-architecture"/></p><p>I’ll explain the details as needed, but in a nutshell:</p><ul><li>The CPU/timer/GPU operates at a fixed rate according to a clock.</li><li>The bus sits between the CPU and various hardware modules and routes data reads/writes based on the given address. For example, writes to address <code>0xFFFF</code> is routed to the interrupt controller and enables/disables interrupts based on the written value.</li><li>Hardware modules connected to the bus implement the interface <code>Addressable_intf.S</code> (which I will explain later)</li><li>The bus implements the interface <code>Word_addressable_intf.S</code> (which I will explain later)</li><li>There are various types of cartridges.</li><li>The timer, GPU, serial port, and joypad can request interrupts. The interrupt controller will notify the requested interrupt to the CPU (further explanation of interrupts is omitted in this article).</li></ul><h2 id="main-loop">Main loop</h2><p>The main loop is responsible for progressing the clocked hardware modules (highlighted in red below) in a synchronized way.</p><p><img src="https://linoscope.github.io/images/camlboy-architecture-clocked.png" alt="camlboy architecture clocked" title="camlboy-architecture-clocked"/></p><p>In real hardware, the CPU/timer/GPU share the same hardware clock, so they naturally run in a synchronized state. On the other hand, the emulator is just a sequential execution loop, so we need to devise a way to reproduce the synchronization between these components. To do so, I implemented the main loop to contain the following steps:</p><ol><li>Let the CPU execute one instruction and keep track of the number of cycles consumed as a result.</li><li>Advance the timer by the number of cycles consumed by the CPU.</li><li>Advance the GPU by the number of cycles consumed by the CPU.</li></ol><p>We sometimes call this the <em>catch up method</em> because it makes the timer and GPU “catch up” with the CPU. Here is the implementation:</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* camlboy.ml *)</span>
</span></span><span><span><span>let</span> <span>run_instruction</span> <span>t</span> <span>=</span>
</span></span><span><span>  <span>let</span> <span>mcycles</span> <span>=</span> <span>Cpu</span><span>.</span><span>run_instruction</span> <span>t</span><span>.</span><span>cpu</span> <span>in</span>
</span></span><span><span>  <span>Timer</span><span>.</span><span>run</span> <span>t</span><span>.</span><span>timer</span> <span>~</span><span>mcycles</span><span>;</span>
</span></span><span><span>  <span>Gpu</span><span>.</span><span>run</span> <span>t</span><span>.</span><span>gpu</span> <span>~</span><span>mcycles</span>
</span></span></code></pre></div><h2 id="interface-for-readingwriting-data">Interface for reading/writing data</h2><p>We will look at some basic interfaces used throughout the emulator.</p><h3 id="interface-for-readingwriting-8-bit-data">Interface for reading/writing 8-bit data</h3><p>First, let’s look at the interface for reading/writing 8-bit data used in the red line below.</p><p><img src="https://linoscope.github.io/images/camlboy-architecture-addressable.png" alt="camlboy architecture addressable" title="camlboy-architecture-addressable"/></p><p>The Bus can read and write 8-bit data from various hardware modules such as GPU and RAM. Since we will be implementing many modules that can read and write 8-bit data, we’d like to share their interface in some form.</p><p>With OOP, you would</p><ol><li>Write an interface (<code>public interface A {...}</code> in Java).</li><li>Implement it (<code>implements A</code> in Java).</li></ol><p>With OCaml, you can</p><ol><li>Write a signature (<code>module type S = sig ... end</code>).</li><li>Include it (<code>include S with type t := t </code>).</li></ol><p>Following these steps, we define the signature <code>Addressable_intf.S</code> as below<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>.</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* addressable_intf.mli *)</span>
</span></span><span><span><span>module</span> <span>type</span> <span>S</span> <span>=</span> <span>sig</span>
</span></span><span><span>  <span>type</span> <span>t</span>
</span></span><span><span>  <span>(* reads 8-bit data from address addr *)</span>
</span></span><span><span>  <span>val</span> <span>read_byte</span> <span>:</span> <span>t</span> <span>-&gt;</span> <span>uint16</span> <span>-&gt;</span> <span>uint8</span>
</span></span><span><span>  <span>(* writes 8-bit data to address addr *)</span>
</span></span><span><span>  <span>val</span> <span>write_byte</span> <span>:</span> <span>t</span> <span>-&gt;</span> <span>addr</span><span>:</span><span>uint16</span> <span>-&gt;</span> <span>data</span><span>:</span><span>uint8</span> <span>-&gt;</span> <span>unit</span>
</span></span><span><span>  <span>(* returns true if it accepts reads/writes from addr and returns false if it can not *)</span>
</span></span><span><span>  <span>val</span> <span>accepts</span> <span>:</span> <span>t</span> <span>-&gt;</span> <span>uint16</span> <span>-&gt;</span> <span>bool</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>Then we include <code>Addressable_intf.S</code> in the interface files of modules that provide 8-bit reads/writes. For example, the RAM module’s interface file <code>ram.mli</code> looks like this:</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* ram.mli *)</span>
</span></span><span><span><span>type</span> <span>t</span>
</span></span><span><span><span>...</span>
</span></span><span><span><span>include</span> <span>Addressable_intf</span><span>.</span><span>S</span> <span>with</span> <span>type</span> <span>t</span> <span>:=</span> <span>t</span>
</span></span></code></pre></div><p>In the same way, <code>gpu.mli</code>, <code>joypad.mli</code>, <code>timer.mli</code>, etc, include <code>Addressable_intf.S</code>.</p><p><strong>Note</strong></p><p>The <code>with type t := t</code> in the above code may need explanation. In general, <code>A with type t := s</code> replaces <code>t</code> in the signature <code>A</code> with <code>s</code>. So <code>include Addressable_intfS with type t := t</code> means:</p><p><em>replace type <code>t</code> in <code>Addressable_intfS</code> with type <code>t</code> in <code>Ram</code>, and then <code>include</code> (“expand” it here)</em>.</p><p>In other words, the above <code>ram.mli</code> is the same as the following:</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* ram.mli *)</span>
</span></span><span><span><span>type</span> <span>t</span>
</span></span><span><span><span>...</span>
</span></span><span><span><span>(* include Addressable_intf.S with type t := t will be &#34;expanded&#34; as the following *)</span>
</span></span><span><span><span>val</span> <span>read_byte</span> <span>:</span> <span>t</span> <span>-&gt;</span> <span>uint16</span> <span>-&gt;</span> <span>uint8</span>
</span></span><span><span><span>val</span> <span>write_byte</span> <span>:</span> <span>t</span> <span>-&gt;</span> <span>addr</span><span>:</span><span>uint16</span> <span>-&gt;</span> <span>data</span><span>:</span><span>uint8</span> <span>-&gt;</span> <span>unit</span>
</span></span><span><span><span>val</span> <span>accepts</span> <span>:</span> <span>t</span> <span>-&gt;</span> <span>uint16</span> <span>-&gt;</span> <span>bool</span>
</span></span></code></pre></div><h3 id="interface-for-readingwriting-16-bit-data">Interface for reading/writing 16-bit data</h3><p>Next, let’s look at the interface for reading/writing 16-bit data used in the red line below.</p><p><img src="https://linoscope.github.io/images/camlboy-architecture-word-addressable.png" alt="camlboy architecture word addressable" title="camlboy-architecture-word-addressable"/></p><p>Between the CPU and the bus, in addition to 8-bit data, 16-bit data can also be read/written. To express this, it would be nice if we could somehow “extend” the interface for 8-bit data read/write (<code>Addressable_intf.S</code>) with 16-bit read/write functions.</p><p>In OOP, you would</p><ol><li>Inherit the interface (<code>extends A</code> in Java).</li></ol><p>With OCaml, you can</p><ol><li>Include the signature (<code>include A with type t := t </code>).</li></ol><p>Hence to extend <code>Addressable_intf.S</code> with 16-bit reads/writes, we can</p><ol><li>Define a signature called <code>Word_addressable_intf.S</code>.</li><li>Include <code>Addressable_intf.S</code></li><li>Add additional functions (<code>read_word</code> and <code>write_word</code>)</li></ol><p>Resulting in this definition:</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* word_addressable_intf.ml *)</span>
</span></span><span><span><span>(** Interface that provide 16-bit read/write in addition to 8-bit read/write *)</span>
</span></span><span><span><span>module</span> <span>type</span> <span>S</span> <span>=</span> <span>sig</span>
</span></span><span><span>  <span>type</span> <span>t</span>
</span></span><span><span>  <span>include</span> <span>Addressable_intf</span><span>.</span><span>S</span> <span>with</span> <span>type</span> <span>t</span> <span>:=</span> <span>t</span>
</span></span><span><span>  <span>(* 16-bit reads/writes *)</span>
</span></span><span><span>  <span>val</span> <span>read_word</span> <span>:</span> <span>t</span> <span>-&gt;</span> <span>uint16</span> <span>-&gt;</span> <span>uint16</span>
</span></span><span><span>  <span>val</span> <span>write_word</span> <span>:</span> <span>t</span> <span>-&gt;</span> <span>addr</span><span>:</span><span>uint16</span> <span>-&gt;</span> <span>data</span><span>:</span><span>uint16</span> <span>-&gt;</span> <span>unit</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><h2 id="the-bus">The Bus</h2><p>Let’s take a look at the implementation of the bus, highlighted in the red box below.</p><p><img src="https://linoscope.github.io/images/camlboy-architecture-bus.png" alt="camlboy architecture bus" title="camlboy-architecture-bus"/></p><p>The bus sits between the CPU and various hardware modules, and routes data reads/writes based on the given address. For example, the bus routs read/write to address <code>0xC000</code> to the RAM. You can find the full memory map <a href="https://gbdev.io/pandocs/Memory_Map.html" target="_blank" rel="noopener noreffer">here</a></p><p>Using the <code>Word_addressable_intf.S</code> implemented above, we can define the interface of the bus module (<code>bus.mli</code>) as the following.</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* bus.mli *)</span>
</span></span><span><span><span>type</span> <span>t</span>
</span></span><span><span><span>val</span> <span>create</span> <span>:</span>
</span></span><span><span>  <span>gpu</span><span>:</span><span>Gpu</span><span>.</span><span>t</span> <span>-&gt;</span>
</span></span><span><span>  <span>timer</span><span>:</span><span>Timer</span><span>.</span><span>t</span> <span>-&gt;</span>
</span></span><span><span>  <span>wram</span><span>:</span><span>Ram</span><span>.</span><span>t</span> <span>-&gt;</span>
</span></span><span><span>  <span>...</span> <span>-&gt;</span>
</span></span><span><span>  <span>t</span>
</span></span><span><span><span>include</span> <span>Word_addressable_intf</span><span>.</span><span>S</span> <span>with</span> <span>type</span> <span>t</span> <span>:=</span> <span>t</span>
</span></span></code></pre></div><p>Then, we can implement the bus (<code>bus.ml</code>) like below:</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* bus.ml *)</span>
</span></span><span><span><span>type</span> <span>t</span> <span>=</span> <span>{</span>
</span></span><span><span>  <span>gpu</span>   <span>:</span> <span>Gpu</span><span>.</span><span>t</span><span>;</span>
</span></span><span><span>  <span>timer</span> <span>:</span> <span>Timer</span><span>.</span><span>t</span><span>;</span>
</span></span><span><span>  <span>wram</span>  <span>:</span> <span>Ram</span><span>.</span><span>t</span><span>;</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>(* takes the modules connected to the bus as its argument *)</span>
</span></span><span><span><span>let</span> <span>create</span> <span>~</span><span>gpu</span> <span>~</span><span>timer</span> <span>~</span><span>wram</span> <span>...</span> <span>=</span> <span>{</span>
</span></span><span><span>  <span>gpu</span><span>;</span>
</span></span><span><span>  <span>timer</span><span>;</span>
</span></span><span><span>  <span>wram</span><span>;</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>let</span> <span>read_byte</span> <span>t</span> <span>addr</span> <span>=</span>
</span></span><span><span>  <span>(* routes the data read to the appropriate module based on the given address *)</span>
</span></span><span><span>  <span>match</span> <span>addr</span> <span>with</span>
</span></span><span><span>  <span>|</span> <span>_</span> <span>when</span> <span>Gpu</span><span>.</span><span>accepts</span> <span>t</span><span>.</span><span>gpu</span> <span>addr</span> <span>-&gt;</span>
</span></span><span><span>    <span>Gpu</span><span>.</span><span>read_byte</span> <span>t</span><span>.</span><span>gpu</span> <span>addr</span>
</span></span><span><span>  <span>|</span> <span>_</span> <span>when</span> <span>Timer</span><span>.</span><span>accepts</span> <span>t</span><span>.</span><span>timer</span> <span>addr</span> <span>-&gt;</span>
</span></span><span><span>    <span>Timer</span><span>.</span><span>read_byte</span> <span>t</span><span>.</span><span>timer</span> <span>addr</span>
</span></span><span><span>  <span>|</span> <span>_</span> <span>when</span> <span>Ram</span><span>.</span><span>accepts</span> <span>t</span><span>.</span><span>wram</span> <span>addr</span> <span>-&gt;</span>
</span></span><span><span>    <span>Ram</span><span>.</span><span>read_byte</span> <span>t</span><span>.</span><span>wram</span> <span>addr</span>
</span></span><span><span>  <span>|</span> <span>...</span>
</span></span><span><span>
</span></span><span><span><span>let</span> <span>read_word</span> <span>t</span> <span>addr</span> <span>=</span>
</span></span><span><span>  <span>(* The read_word function archives 16-bit reads by calling read_byte twice.
</span></span></span><span><span><span>     The actual hardware also achieves 16-bit read/write by conducting 8-bit read/write twice. *)</span>
</span></span><span><span>  <span>let</span> <span>lo</span> <span>=</span> <span>Uint8</span><span>.</span><span>to_int</span> <span>(</span><span>read_byte</span> <span>t</span> <span>addr</span><span>)</span> <span>in</span>
</span></span><span><span>  <span>let</span> <span>hi</span> <span>=</span> <span>Uint8</span><span>.</span><span>to_int</span> <span>(</span><span>read_byte</span> <span>t</span> <span>Uint16</span><span>.</span><span>(</span><span>succ</span> <span>addr</span><span>))</span> <span>in</span>
</span></span><span><span>  <span>(</span><span>hi</span> <span>lsl</span> <span>8</span><span>)</span> <span>+</span> <span>lo</span> <span>|&gt;</span> <span>Uint16</span><span>.</span><span>of_int</span>
</span></span></code></pre></div><h2 id="registers">Registers</h2><p>Let’s take a look at the implementation of registers, highlighted in the red box below.</p><p><img src="https://linoscope.github.io/images/camlboy-architecture-registers.png" alt="camlboy architecture registers" title="camlboy-architecture-registers"/></p><p>The Game Boy’s CPU has eight 8-bit registers, <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>, <code>F</code>, <code>H</code>, and <code>L</code>. These 8-bit registers can be combined to be used as 16-bit registers <code>AF</code>, <code>BC</code>, <code>DE</code>, and <code>HL</code>. Below is the interface of the <code>Registers</code> module (implementation is omitted):</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* registers.mli *)</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>t</span>
</span></span><span><span><span>(* identifiers of the 8-bit registers *)</span>
</span></span><span><span><span>type</span> <span>r</span> <span>=</span> <span>A</span> <span>|</span> <span>B</span> <span>|</span> <span>C</span> <span>|</span> <span>D</span> <span>|</span> <span>E</span> <span>|</span> <span>F</span> <span>|</span> <span>H</span> <span>|</span> <span>L</span>
</span></span><span><span><span>(* identifiers for the 16-bit registers *)</span>
</span></span><span><span><span>type</span> <span>rr</span> <span>=</span> <span>AF</span> <span>|</span> <span>BC</span> <span>|</span> <span>DE</span> <span>|</span> <span>HL</span>
</span></span><span><span>
</span></span><span><span><span>...</span>
</span></span><span><span>
</span></span><span><span><span>(* read/write functions for the above registers *)</span>
</span></span><span><span><span>val</span> <span>read_r</span>   <span>:</span> <span>t</span> <span>-&gt;</span>  <span>r</span> <span>-&gt;</span> <span>uint8</span>
</span></span><span><span><span>val</span> <span>write_r</span>  <span>:</span> <span>t</span> <span>-&gt;</span>  <span>r</span> <span>-&gt;</span> <span>uint8</span> <span>-&gt;</span> <span>unit</span>
</span></span><span><span><span>val</span> <span>read_rr</span>  <span>:</span> <span>t</span> <span>-&gt;</span> <span>rr</span> <span>-&gt;</span> <span>uint16</span>
</span></span><span><span><span>val</span> <span>write_rr</span> <span>:</span> <span>t</span> <span>-&gt;</span> <span>rr</span> <span>-&gt;</span> <span>uint16</span> <span>-&gt;</span> <span>unit</span>
</span></span></code></pre></div><h2 id="the-cpu">The CPU</h2><p>Let’s take a look at the implementation of the CPU, highlighted in the red box below.</p><p><img src="https://linoscope.github.io/images/camlboy-architecture-cpu.png" alt="camlboy architecture cpu" title="camlboy-architecture-cpu"/></p><h3 id="my-initial-implementation-of-the-cpu">My initial implementation of the CPU</h3><p>Below is my initial implementation of the CPU. Details of the <code>execute</code> function are omitted here and will be discussed when implementing the instruction set.</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* cpu.mli *)</span>
</span></span><span><span><span>type</span> <span>t</span>
</span></span><span><span><span>val</span> <span>create</span> <span>:</span> <span>bus</span><span>:</span><span>Bus</span><span>.</span><span>t</span> <span>-&gt;</span> <span>registers</span><span>:</span><span>Registers</span><span>.</span><span>t</span> <span>-&gt;</span> <span>...</span> <span>-&gt;</span> <span>t</span>
</span></span><span><span><span>val</span> <span>run_instruction</span> <span>:</span> <span>t</span> <span>-&gt;</span> <span>int</span> <span>(* returns the # of cycles consumed *)</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* cpu.ml *)</span>
</span></span><span><span><span>type</span> <span>t</span> <span>=</span> <span>{</span>
</span></span><span><span>  <span>registers</span>  <span>:</span> <span>Registers</span><span>.</span><span>t</span><span>;</span>
</span></span><span><span>  <span>bus</span>        <span>:</span> <span>Bus</span><span>.</span><span>t</span><span>;</span>
</span></span><span><span>  <span>mutable</span> <span>pc</span> <span>:</span> <span>uint16</span><span>;</span> <span>(* Program counter *)</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>(* Initializes the CPU by passing it&#39;s dependencies *)</span>
</span></span><span><span><span>let</span> <span>create</span> <span>~</span><span>bus</span> <span>~</span><span>registers</span> <span>...</span> <span>=</span> <span>{</span>
</span></span><span><span>    <span>bus</span><span>;</span>
</span></span><span><span>    <span>registers</span><span>;</span>
</span></span><span><span>    <span>...</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>(* Omitted for now. *)</span>
</span></span><span><span><span>let</span> <span>execute</span> <span>t</span> <span>inst</span> <span>=</span> <span>...</span>
</span></span><span><span>
</span></span><span><span><span>(* Fetches, decodes, and executes an instruction *)</span>
</span></span><span><span><span>let</span> <span>run_instruction</span> <span>t</span> <span>=</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span>  <span>let</span> <span>inst</span> <span>=</span> <span>Fetch_and_decode</span><span>.</span><span>f</span> <span>t</span><span>.</span><span>bus</span> <span>~</span><span>pc</span><span>:</span><span>t</span><span>.</span><span>pc</span> <span>in</span>
</span></span><span><span>  <span>execute</span> <span>t</span> <span>inst</span>
</span></span></code></pre></div><h3 id="the-problem-with-the-initial-implementation-of-the-cpu">The problem with the initial implementation of the CPU</h3><p>The above implementation of the CPU works, but there is one problem — it is hard to test. The following diagram illustrates why:</p><p><img src="https://linoscope.github.io/images/camlboy-architecture-simplified.png" alt="camlboy architecture simplified" title="camlboy-architecture-simplified"/></p><p>Notice that the bus has many dependencies on various modules. These dependencies make it hard to instantiate the CPU in our unit tests. Furthermore, it is impossible to instantiate the CPU until we implement the bus and all the connected modules, which would be pretty later on in the development process.</p><p>To make the CPU testable, we want to abstract away the implementation of the bus from the CPU. Once we do this, we can swap the bus with a mock implementation, as illustrated below:</p><p><img src="https://linoscope.github.io/images/camlboy-architecture-mocked-bus.png" alt="camlboy architecture mocked bus" title="camlboy-architecture-mocked-bus"/></p><p>In OCaml, you can achieve such abstraction of implementation using <em><strong>functors</strong></em>.</p><h3 id="using-functors-to-improve-testability">Using functors to improve testability</h3><p>I have reimplemented the CPU using functors like this:</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* cpu.mli *)</span>
</span></span><span><span>
</span></span><span><span><span>(* We can now &#34;inject&#34; different implementations of the Bus via this functor argument *)</span>
</span></span><span><span><span>module</span> <span>Make</span> <span>(</span><span>Bus</span> <span>:</span> <span>Word_addressable_intf</span><span>.</span><span>S</span><span>)</span> <span>:</span> <span>sig</span>
</span></span><span><span>  <span>type</span> <span>t</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* cpu.ml *)</span>
</span></span><span><span>
</span></span><span><span><span>module</span> <span>Make</span> <span>(</span><span>Bus</span> <span>:</span> <span>Word_addressable_intf</span><span>.</span><span>S</span><span>)</span> <span>=</span> <span>struct</span>
</span></span><span><span>  <span>type</span> <span>t</span> <span>=</span> <span>{</span>
</span></span><span><span>    <span>registers</span>  <span>:</span> <span>Registers</span><span>.</span><span>t</span><span>;</span>
</span></span><span><span>    <span>bus</span>        <span>:</span> <span>Bus</span><span>.</span><span>t</span><span>;</span>
</span></span><span><span>    <span>mutable</span> <span>pc</span> <span>:</span> <span>uint16</span><span>;</span> <span>(* Program counter *)</span>
</span></span><span><span>    <span>...</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>Thanks to this change, we can use a mock implementation of the bus to instantiate the CPU in our unit tests, as illustrated below:</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* test_cpu.ml *)</span>
</span></span><span><span><span>...</span>
</span></span><span><span><span>(* Mock_bus is a simple implementation of `Word_addressable_intf.S`
</span></span></span><span><span><span>   which is implemented using a single byte array. *)</span>
</span></span><span><span><span>module</span> <span>Cpu</span> <span>=</span> <span>Cpu</span><span>.</span><span>Make</span><span>(</span><span>Mock_bus</span><span>)</span>
</span></span><span><span><span>let</span> <span>cpu</span> <span>=</span> <span>Cpu</span><span>.</span><span>create</span> <span>~</span><span>bus</span><span>:(</span><span>Mock_bus</span><span>.</span><span>create</span> <span>~</span><span>size</span><span>:</span><span>0xFF</span><span>)</span> <span>...</span>
</span></span><span><span><span>...</span>
</span></span></code></pre></div><h2 id="instruction-set">Instruction set</h2><p>Let’s encode Game Boy’s instruction in OCaml.</p><p>The instruction set of Game Boy consists of</p><ul><li><em>8-bit instructions</em>: takes 8-bit values (8-bit registers, 8-bit immediate values, etc.) as arguments.</li><li><em>16-bit instructions</em>: takes 16-bit values (16-bit registers, 16-bit immediate values, etc.) as arguments.</li></ul><p>For example, there are two versions of addition as shown below:</p><div><pre tabindex="0"><code data-lang="mysql"><span><span><span># 8-bit version
</span></span></span><span><span><span># Adds the 8-bit `A` register and `0x12`, then stores the result in the `A` register
</span></span></span><span><span><span></span><span>ADD8</span><span> </span><span>A</span><span>,</span><span> </span><span>0</span><span>x12</span><span>
</span></span></span><span><span><span></span><span># 16-bit version
</span></span></span><span><span><span># adds the 16-bit `AF` register and `0x1234`, then stores the result in the `AF` register
</span></span></span><span><span><span></span><span>ADD16</span><span> </span><span>AF</span><span>,</span><span> </span><span>0</span><span>x1234</span><span>
</span></span></span></code></pre></div><p>Now, how should we define such an instruction set in OCaml?</p><h3 id="define-the-instruction-set-using-variants">Define the instruction set using variants</h3><p>As a first attempt, I represented the instructions and their arguments as variants, as shown below:</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* instruction.ml *)</span>
</span></span><span><span>
</span></span><span><span><span>(* Instruction arguments definied using variants *)</span>
</span></span><span><span><span>type</span> <span>arg</span> <span>=</span>
</span></span><span><span>  <span>|</span> <span>Immediate8</span>  <span>of</span> <span>uint8</span>   <span>(*  8-bit value *)</span>
</span></span><span><span>  <span>|</span> <span>Immediate16</span> <span>of</span> <span>uint16</span> <span>(* 16-bit value *)</span>
</span></span><span><span>  <span>|</span> <span>R</span>           <span>of</span> <span>Registers</span><span>.</span><span>r</span>      <span>(*  8-bit register *)</span>
</span></span><span><span>  <span>|</span> <span>RR</span>          <span>of</span> <span>Registers</span><span>.</span><span>rr</span>    <span>(* 16-bit register *)</span>
</span></span><span><span>  <span>|</span> <span>...</span>
</span></span><span><span>
</span></span><span><span><span>(* Instructions *)</span>
</span></span><span><span><span>type</span> <span>t</span> <span>=</span>
</span></span><span><span>  <span>|</span> <span>ADD8</span>  <span>of</span> <span>arg</span> <span>*</span> <span>arg</span> <span>(*  8-bit version of ADD *)</span>
</span></span><span><span>  <span>|</span> <span>ADD16</span> <span>of</span> <span>arg</span> <span>*</span> <span>arg</span> <span>(* 16-bit version of ADD *)</span>
</span></span><span><span>  <span>|</span> <span>...</span>
</span></span></code></pre></div><p>But I soon noticed that this approach does not work.</p><h3 id="problem-with-the-definition-using-variants">Problem with the definition using variants</h3><p>Why does this approach not work? The problem arises when we try to “consume” the instruction set in the <code>execute</code> function, as shown below:</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* cpu.ml *)</span>
</span></span><span><span>
</span></span><span><span><span>(* Takes a single instruction and executes it. *)</span>
</span></span><span><span><span>let</span> <span>execute</span> <span>t</span> <span>(</span><span>inst</span> <span>:</span> <span>Instruction</span><span>.</span><span>t</span><span>)</span> <span>=</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span>  <span>let</span> <span>read_arg</span> <span>=</span> <span>function</span>
</span></span><span><span>    <span>(* fetch values stored in the given argument *)</span>
</span></span><span><span>    <span>|</span> <span>Immidiate8</span>  <span>x</span> <span>-&gt;</span> <span>x</span>
</span></span><span><span>    <span>|</span> <span>Immediate16</span> <span>x</span> <span>-&gt;</span> <span>x</span>
</span></span><span><span>    <span>|</span> <span>R</span>  <span>r</span>          <span>-&gt;</span> <span>Registers</span><span>.</span><span>read_r</span> <span>r</span>
</span></span><span><span>    <span>|</span> <span>RR</span> <span>rr</span>         <span>-&gt;</span> <span>Registers</span><span>.</span><span>read_rr</span> <span>rr</span>
</span></span><span><span>    <span>|</span> <span>...</span>
</span></span><span><span>  <span>in</span>
</span></span><span><span>  <span>match</span> <span>inst</span> <span>with</span>
</span></span><span><span>  <span>|</span> <span>Add8</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>-&gt;</span>
</span></span><span><span>    <span>(* Fetches the value stored in the arguments x and y adds them. *)</span>
</span></span><span><span>    <span>let</span> <span>sum</span> <span>=</span> <span>Uint8</span><span>.</span><span>add</span> <span>(</span><span>read_arg</span> <span>x</span><span>)</span> <span>(</span><span>read_arg</span> <span>y</span><span>)</span> <span>in</span>
</span></span><span><span>    <span>...</span>
</span></span><span><span>  <span>|</span> <span>Add16</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>-&gt;</span>
</span></span><span><span>    <span>let</span> <span>sum</span> <span>=</span> <span>Uint16</span><span>.</span><span>add</span> <span>(</span><span>read_arg</span> <span>x</span><span>)</span> <span>(</span><span>read_arg</span> <span>y</span><span>)</span> <span>in</span>
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span><span>let</span> <span>run_instruction</span> <span>t</span> <span>=</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span>  <span>let</span> <span>inst</span> <span>=</span> <span>Fetch_and_decode</span><span>.</span><span>f</span> <span>t</span><span>.</span><span>bus</span> <span>~</span><span>pc</span><span>:</span><span>t</span><span>.</span><span>pc</span> <span>in</span>
</span></span><span><span>  <span>execute</span> <span>t</span> <span>inst</span>
</span></span></code></pre></div><p>I have extracted the <code>read_arg</code> function below to understand the problem. Notice that the return value of the entire function cannot be uniquely determined. This is because the return type of the match expression changes depending on which constructor it matches, as highlighted in the comments.</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span>  <span>(* What is the type of the return value? *)</span>
</span></span><span><span>  <span>let</span> <span>read_arg</span> <span>:</span> <span>Instruction</span><span>.</span><span>arg</span> <span>-&gt;</span> <span>???</span> <span>=</span> <span>function</span>
</span></span><span><span>    <span>...</span>
</span></span><span><span>    <span>|</span> <span>R</span> <span>r</span>  <span>-&gt;</span>
</span></span><span><span>      <span>(* fetches the value of 8-bit register. *)</span>
</span></span><span><span>      <span>(* returns uint8 in this case. *)</span>
</span></span><span><span>      <span>Registers</span><span>.</span><span>read_r</span> <span>r</span>
</span></span><span><span>    <span>|</span> <span>RR</span> <span>r</span> <span>-&gt;</span>
</span></span><span><span>      <span>(* fetches the value of 16-bit register. *)</span>
</span></span><span><span>      <span>(* returns uint16 in this case. *)</span>
</span></span><span><span>      <span>Registers</span><span>.</span><span>read_rr</span> <span>r</span>
</span></span><span><span>  <span>in</span>
</span></span></code></pre></div><p>At this point, I remembered <em><strong>GADT</strong></em> (<em><strong>Generalized Algebraic Data Type</strong></em>), a language feature that I had studied before but never really felt comfortable with.</p><h3 id="gadts-to-the-rescue">GADTs to the rescue</h3><p>Below is the redefined instruction set that uses GADTs. Notice that the definition of the <code>arg</code> type looks different from the previous variant definition.</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* instruction.ml *)</span>
</span></span><span><span>
</span></span><span><span><span>(* Instruction arguments definied using GADTs *)</span>
</span></span><span><span><span>type</span> <span>_</span> <span>arg</span> <span>=</span>
</span></span><span><span>  <span>|</span> <span>Immediate8</span>  <span>:</span> <span>uint8</span>        <span>-&gt;</span> <span>uint8</span>  <span>arg</span>
</span></span><span><span>  <span>|</span> <span>Immediate16</span> <span>:</span> <span>uint16</span>       <span>-&gt;</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>R</span>           <span>:</span> <span>Registers</span><span>.</span><span>r</span>  <span>-&gt;</span> <span>uint8</span>  <span>arg</span>
</span></span><span><span>  <span>|</span> <span>RR</span>          <span>:</span> <span>Registers</span><span>.</span><span>rr</span> <span>-&gt;</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>...</span>
</span></span><span><span>
</span></span><span><span><span>(* Instructions *)</span>
</span></span><span><span><span>type</span> <span>t</span> <span>=</span>
</span></span><span><span>  <span>|</span> <span>ADD8</span>  <span>of</span> <span>uint8</span> <span>arg</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>ADD16</span> <span>of</span> <span>uint16</span> <span>arg</span> <span>*</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>...</span>
</span></span></code></pre></div><p>To understand the meaning of this definition, let’s focus on the third line of the <code>arg</code> type:</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span>  <span>|</span> <span>R</span> <span>:</span> <span>Registers</span><span>.</span><span>r</span> <span>-&gt;</span> <span>uint8</span>  <span>arg</span>
</span></span></code></pre></div><p>The argument type of the constructor (<code>Registers.r</code> in <code>Registers.r -&gt; uint8 arg</code>) has the same functionality as the <code>of Registers.r</code> in the variant definition. It changes the <strong>type of the value you <em>get</em> in the pattern match based on the constructor</strong>. In the below match statement, notice that the type of value we get in the match statement (type of <code>r</code> and <code>rr</code>) is different depending on the constructor we match. This is possible because the argument type of the constructor is different.</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>let</span> <span>read_arg</span> <span>=</span> <span>function</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span>  <span>|</span> <span>R</span>   <span>r</span> <span>-&gt;</span> <span>..</span> <span>(* type of r is Registers.r *)</span>
</span></span><span><span>  <span>|</span> <span>RR</span> <span>rr</span> <span>-&gt;</span> <span>..</span> <span>(* type of rr is Registers.rr *)</span>
</span></span><span><span>  <span>...</span>
</span></span></code></pre></div><p>Then what does the return type of the constructor (<code>uint8 arg</code> in <code>Registers.r -&gt; uint8 arg</code>) represent? There seems to be nothing corresponding to this in the variant definition. The answer is: it changes <strong>type of the value you <em>return</em> in the pattern match based on the constructor</strong>. Take a look at the below match statement. Notice that the type of value we return in the match statement is different depending on the constructor we match. This is possible because the return type of the constructor is different.</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>let</span> <span>read_arg</span> <span>=</span> <span>function</span>
</span></span><span><span>  <span>..</span>
</span></span><span><span>  <span>|</span> <span>R</span>   <span>r</span> <span>-&gt;</span> <span>Registers</span><span>.</span><span>read_r</span> <span>r</span>   <span>(* returns uint8 *)</span>
</span></span><span><span>  <span>|</span> <span>RR</span> <span>rr</span> <span>-&gt;</span> <span>Registers</span><span>.</span><span>read_rr</span> <span>rr</span> <span>(* returns uint16 *)</span>
</span></span><span><span>  <span>...</span>
</span></span></code></pre></div><p>In summary, <strong>variants can parametrize the type of values we get in the match statement</strong>, while <strong>GATDs can also parameterize the type of the value we return in the match statement</strong>. In this sense, GADTs are more “general” than variants, which I guess is where the name “Generalized” Algebraic Data Type comes from.</p><p>Using the newly defined <code>Instruction.arg</code>, which uses GADTs, we can write <code>execute</code> as below. The type <code>&#39;a Instruction.arg -&gt; &#39;a</code> of <code>read_arg</code> indicates that the return type changes based on the type of the given constructor.</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>let</span> <span>execute</span> <span>t</span> <span>(</span><span>inst</span> <span>:</span> <span>Instruction</span><span>.</span><span>t</span><span>)</span> <span>=</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span>  <span>let</span> <span>read_arg</span> <span>:</span> <span>type</span> <span>a</span><span>.</span> <span>a</span> <span>Instruction</span><span>.</span><span>arg</span> <span>-&gt;</span> <span>a</span> <span>=</span> <span>fun</span> <span>arg</span> <span>-&gt;</span>
</span></span><span><span>    <span>match</span> <span>arg</span> <span>with</span>
</span></span><span><span>    <span>|</span> <span>Immediate8</span>  <span>n</span> <span>-&gt;</span> <span>n</span>
</span></span><span><span>    <span>|</span> <span>Immediate16</span> <span>n</span> <span>-&gt;</span> <span>n</span>
</span></span><span><span>    <span>|</span> <span>...</span>
</span></span><span><span>  <span>in</span>
</span></span><span><span>  <span>match</span> <span>inst</span> <span>with</span>
</span></span><span><span>  <span>|</span> <span>Add8</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>-&gt;</span>
</span></span><span><span>    <span>let</span> <span>sum</span> <span>=</span> <span>Uint8</span><span>.</span><span>add</span> <span>(</span><span>read_arg</span> <span>x</span><span>)</span> <span>(</span><span>read_arg</span> <span>y</span><span>)</span> <span>in</span>
</span></span><span><span>    <span>...</span>
</span></span><span><span>  <span>|</span> <span>Add16</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>-&gt;</span>
</span></span><span><span>    <span>let</span> <span>sum</span> <span>=</span> <span>Uint16</span><span>.</span><span>add</span> <span>(</span><span>read_arg</span> <span>x</span><span>)</span> <span>(</span><span>read_arg</span> <span>y</span><span>)</span> <span>in</span>
</span></span><span><span>    <span>...</span>
</span></span></code></pre></div><p>For refrence, here is the full instruction set defined using GADTs (click to expand):</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>type</span> <span>_</span> <span>arg</span> <span>=</span>
</span></span><span><span>  <span>|</span> <span>Immediate8</span>  <span>:</span> <span>uint8</span>        <span>-&gt;</span> <span>uint8</span>  <span>arg</span>
</span></span><span><span>  <span>|</span> <span>Immediate16</span> <span>:</span> <span>uint16</span>       <span>-&gt;</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>Direct8</span>     <span>:</span> <span>uint16</span>       <span>-&gt;</span> <span>uint8</span>  <span>arg</span>
</span></span><span><span>  <span>|</span> <span>Direct16</span>    <span>:</span> <span>uint16</span>       <span>-&gt;</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>R</span>           <span>:</span> <span>Registers</span><span>.</span><span>r</span>  <span>-&gt;</span> <span>uint8</span>  <span>arg</span>
</span></span><span><span>  <span>|</span> <span>RR</span>          <span>:</span> <span>Registers</span><span>.</span><span>rr</span> <span>-&gt;</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>RR_indirect</span> <span>:</span> <span>Registers</span><span>.</span><span>rr</span> <span>-&gt;</span> <span>uint8</span>  <span>arg</span>
</span></span><span><span>  <span>|</span> <span>FF00_offset</span> <span>:</span> <span>uint8</span>        <span>-&gt;</span> <span>uint8</span>  <span>arg</span>
</span></span><span><span>  <span>|</span> <span>FF00_C</span>      <span>:</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>HL_inc</span>      <span>:</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>HL_dec</span>      <span>:</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>SP</span>          <span>:</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>SP_offset</span>   <span>:</span> <span>int8</span>         <span>-&gt;</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>condition</span> <span>=</span>
</span></span><span><span>  <span>|</span> <span>None</span>
</span></span><span><span>  <span>|</span> <span>NZ</span>
</span></span><span><span>  <span>|</span> <span>Z</span>
</span></span><span><span>  <span>|</span> <span>NC</span>
</span></span><span><span>  <span>|</span> <span>C</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>t</span> <span>=</span>
</span></span><span><span>  <span>|</span> <span>LD8</span>   <span>of</span> <span>uint8</span> <span>arg</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>LD16</span>  <span>of</span> <span>uint16</span> <span>arg</span> <span>*</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>ADD8</span>  <span>of</span> <span>uint8</span> <span>arg</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>ADD16</span> <span>of</span> <span>uint16</span> <span>arg</span> <span>*</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>ADDSP</span> <span>of</span> <span>int8</span>
</span></span><span><span>  <span>|</span> <span>ADC</span>   <span>of</span> <span>uint8</span> <span>arg</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>SUB</span>   <span>of</span> <span>uint8</span> <span>arg</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>SBC</span>   <span>of</span> <span>uint8</span> <span>arg</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>AND</span>   <span>of</span> <span>uint8</span> <span>arg</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>OR</span>    <span>of</span> <span>uint8</span> <span>arg</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>XOR</span>   <span>of</span> <span>uint8</span> <span>arg</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>CP</span>    <span>of</span> <span>uint8</span> <span>arg</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>INC</span>   <span>of</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>INC16</span> <span>of</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>DEC</span>   <span>of</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>DEC16</span> <span>of</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>SWAP</span>  <span>of</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>DAA</span>
</span></span><span><span>  <span>|</span> <span>CPL</span>
</span></span><span><span>  <span>|</span> <span>CCF</span>
</span></span><span><span>  <span>|</span> <span>SCF</span>
</span></span><span><span>  <span>|</span> <span>NOP</span>
</span></span><span><span>  <span>|</span> <span>HALT</span>
</span></span><span><span>  <span>|</span> <span>STOP</span>
</span></span><span><span>  <span>|</span> <span>DI</span>
</span></span><span><span>  <span>|</span> <span>EI</span>
</span></span><span><span>  <span>|</span> <span>RLCA</span>
</span></span><span><span>  <span>|</span> <span>RLA</span>
</span></span><span><span>  <span>|</span> <span>RRCA</span>
</span></span><span><span>  <span>|</span> <span>RRA</span>
</span></span><span><span>  <span>|</span> <span>RLC</span>   <span>of</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>RL</span>    <span>of</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>RRC</span>   <span>of</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>RR</span>    <span>of</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>SLA</span>   <span>of</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>SRA</span>   <span>of</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>SRL</span>   <span>of</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>BIT</span>   <span>of</span> <span>int</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>SET</span>   <span>of</span> <span>int</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>RES</span>   <span>of</span> <span>int</span> <span>*</span> <span>uint8</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>PUSH</span>  <span>of</span> <span>Registers</span><span>.</span><span>rr</span>
</span></span><span><span>  <span>|</span> <span>POP</span>   <span>of</span> <span>Registers</span><span>.</span><span>rr</span>
</span></span><span><span>  <span>|</span> <span>JP</span>    <span>of</span> <span>condition</span> <span>*</span> <span>uint16</span> <span>arg</span>
</span></span><span><span>  <span>|</span> <span>JR</span>    <span>of</span> <span>condition</span> <span>*</span> <span>int8</span>
</span></span><span><span>  <span>|</span> <span>CALL</span>  <span>of</span> <span>condition</span> <span>*</span> <span>uint16</span>
</span></span><span><span>  <span>|</span> <span>RST</span>   <span>of</span> <span>uint16</span>
</span></span><span><span>  <span>|</span> <span>RET</span>   <span>of</span> <span>condition</span>
</span></span><span><span>  <span>|</span> <span>RETI</span>
</span></span></code></pre></div><h2 id="the-cartridges">The Cartridges</h2><p>Let’s look at the implementation of the cartridges, highlighted in the red box below.</p><p><img src="https://linoscope.github.io/images/camlboy-architecture-cartridge.png" alt="camlboy architecture cartridge" title="camlboy-architecture-cartridge"/></p><p>You might think that Game Boy cartridges are just a ROM (read-only memory) that stores game data/code, but this is not the case. Many Game Boy cartridges contain hardware components to enhance the Game Boy’s limited functionality. For example, while ROM_ONLY type cartridges (such as Tetris) only include the ROM that stores the game data/code, MBC3 type cartridges (such as Pokémon Red) contain independent RAM and timers in addition to the ROM.</p><p>Since each cartridge type has separate functionality, we will implement each cartridge type as individual modules. Therefore, we need a mechanism to select a module according to the cartridge type at runtime.</p><p><strong><em>First-class modules</em></strong> are helpful for this kind of “runtime module selection”. As shown below, you can write <code>Detect_cartridge.f</code> that returns a first-class module based on the cartridge type. We will omit the implementation in this article.</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>(* detect_cartridge.mli *)</span>
</span></span><span><span><span>val</span> <span>f</span> <span>:</span> <span>rom_bytes</span><span>:</span><span>Bigstringaf</span><span>.</span><span>t</span> <span>-&gt;</span> <span>(</span><span>module</span> <span>Cartridge_intf</span><span>.</span><span>S</span><span>)</span>
</span></span></code></pre></div><h2 id="integration-tests">Integration tests</h2><p>I used test ROMs and <code>ppx_expect</code> to catch regressions and to enable <em>exploratory programming</em>.</p><h3 id="what-are-test-roms">What are test ROMs</h3><p>Test ROMs are programs that test certain functionality of the emulator. For example, there are test ROMs that:</p><ul><li>Test if the basic arithmetic instructions are working as expected.</li><li>Test if the MBC1 cartridge type is adequately supported.</li></ul><p>Such test ROMs are extremely helpful when developing emulators since, unlike game ROMs, they</p><ul><li>Indicate which aspect of the emulator is failing.</li><li>Runs even if some core functionality of the emulator is missing.</li></ul><p>Test ROMs typically output the test results to the display<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>. For example, <a href="https://github.com/Gekkio/mooneye-test-suite" target="_blank" rel="noopener noreffer">mooneye test ROMs</a> results look like below. The text displayed in the failure case is the register dump and assertion failure information.</p><p><img src="https://linoscope.github.io/images/test_rom_failed.png" alt="test rom failed" title="test-rom-failed"/>
<img src="https://linoscope.github.io/images/test_rom_success.png" alt="test rom success" title="test-rom-success"/></p><h3 id="setting-up-the-tests">Setting up the tests</h3><p>Below is an example integration test implemented using a test ROM and <a href="https://github.com/janestreet/ppx_expect" target="_blank" rel="noopener noreffer"><code>ppx_expect</code></a>. Here is what is happening:</p><ol><li><code>M.run_test_rom_and_print_framebuffer</code> runs the given ROM and prints the final state of the screen in ASCII characters.</li><li>The printed string is matched with the <code>...</code> in <code>[%expect{|...|}]</code>.</li></ol><p>Details about <code>ppx_expect</code> can be found in <a href="https://blog.janestreet.com/testing-with-expectations" target="_blank" rel="noopener noreffer">this article</a>.</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>let</span><span>%</span><span>expect_test</span> <span>&#34;bits_mode.gb&#34;</span> <span>=</span>
</span></span><span><span>  <span>M</span><span>.</span><span>run_test_rom_and_print_framebuffer</span> <span>&#34;mbc1/bits_mode.gb&#34;</span><span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>[%</span><span>expect</span><span>{|</span>
</span></span><span><span>    <span>008</span><span>:-#######-----------------------------------###---#---#----------------------------------------------------------------------------------------------------------</span>
</span></span><span><span>    <span>009</span><span>:----#-----####-----###-----#--------------#---#--#--#-----------------------------------------------------------------------------------------------------------</span>
</span></span><span><span>    <span>010</span><span>:----#----#----#---#-------####------------#---#--#-#------------------------------------------------------------------------------------------------------------</span>
</span></span><span><span>    <span>011</span><span>:----#----######----##------#--------------#---#--###------------------------------------------------------------------------------------------------------------</span>
</span></span><span><span>    <span>012</span><span>:----#----#-----------#-----#--------------#---#--#--#-----------------------------------------------------------------------------------------------------------</span>
</span></span><span><span>    <span>013</span><span>:----#-----####----###------##--------------###---#---#----------------------------------------------------------------------------------------------------------</span> <span>|}]</span>
</span></span></code></pre></div><p>These integration tests gave me the confidence to make large code changes as the test suit would catch regressions.</p><h3 id="exploratory-programming">Exploratory programming</h3><p>Furthermore, these integration tests enabled me to implement the emulator in a <a href="https://blog.janestreet.com/repeatable-exploratory-programming/" target="_blank" rel="noopener noreffer"><em>exploratory programming</em></a> style. Whenever I would implement new functionality, I would</p><ol><li>Find a test ROM that checks the functionality.</li><li>Set up <code>ppx_expect</code> tests that run the test ROM.</li><li>Run the tests and commit the failed output.</li><li>Implement the functionality.</li><li>Check if the test changed to the “Test OK” state.</li></ol><h2 id="compiling-to-javascript">Compiling to JavaScript</h2><p>Compiling to JavaScript was surprisingly easy thanks to <a href="https://github.com/ocsigen/js_of_ocaml" target="_blank" rel="noopener noreffer">js_of_ocaml</a>. I was able to get the emulator working in the browser with just a <a href="https://github.com/linoscope/CAMLBOY/commit/ac04c5d1ca39514cf7f34d19b2c5e702cc3d28c1" target="_blank" rel="noopener noreffer">single commit</a>.</p><p>I used a library called <a href="https://github.com/dbuenzli/brr" target="_blank" rel="noopener noreffer">Brr</a> when implementing the browser UI. The great thing about Brr is that it maps JS objects to OCaml modules, unlike <code>js_of_ocaml</code> ’s built-in browser API that maps JS objects to OCaml objects, requiring some knowledge about the “O” in OCaml.</p><h2 id="optimization">Optimization</h2><p>Although I was able to get it working in my browser, it had one problem — it was unplayably slow. Below is how it looked like in the PC browser at this point, running at around 20 FPS. The actual Game Boy runs at 60 FPS, so we need to improve the performance by a factor of three.</p><p><img src="https://linoscope.github.io/images/before-optimize.gif" alt="before optimize" title="before-optimize"/></p><p>Now started the journey of optimization.</p><h3 id="finding-bottlenecks-with-a-profiler">Finding bottlenecks with a profiler</h3><p>The first thing I did was use Chrome’s profiler<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup> and find out the bottlenecks. Here are the results:</p><p><img src="https://linoscope.github.io/images/profile-result.png" alt="profile result" title="profile-result"/></p><p>The above show that the GPU consumes ~73% of the time, with <code>tile_data.ml</code>, <code>oam_table.ml</code>, and <code>tile_map</code> consuming 34%, 18%, and 8% of the time, respectively.</p><p>Similarly, I found that <code>timer.ml</code> and some <code>Bigstringaf</code> functions were consuming a lot of time.</p><h3 id="removing-the-bottlenecks">Removing the bottlenecks</h3><p>Now that I knew where the bottlenecks were, I worked on removing them. Since this article does not cover the parts that these changes touch, I will only list what I optimized and their results.</p><ul><li>Optimize <code>oam_table.ml</code> (<a href="https://github.com/linoscope/CAMLBOY/commit/47989b77451873202268c955bc3b650420e648e8" target="_blank" rel="noopener noreffer">commit</a>):<ul><li>14fps -&gt; 24fps</li></ul></li><li>Optimize <code>tile_data.ml</code> (<a href="https://github.com/linoscope/CAMLBOY/commit/bdc7c58c8ec1720eb38f59a64320d06f655f78f5" target="_blank" rel="noopener noreffer">commit</a>):<ul><li>24fps -&gt; 35fps</li></ul></li><li>Optimize <code>timer.ml</code> (<a href="https://github.com/linoscope/CAMLBOY/commit/db49742096db50f1f52cb72b2e5136fbd4912163" target="_blank" rel="noopener noreffer">commit</a>):<ul><li>35fps -&gt; 40fps</li></ul></li><li>Optimize <code>tile_map.ml</code> (<a href="https://github.com/linoscope/CAMLBOY/commit/7c2a6b9f694c57983da032d71a44f81f51e3cb65" target="_blank" rel="noopener noreffer">commit</a>):<ul><li>40fps -&gt; 50fps</li></ul></li><li>Use <code>Bigstringaf.unsafe_get</code> instead of <code>Bigstringaf.get</code> (<a href="https://github.com/linoscope/CAMLBOY/commit/2691a664465051eaa3b93954675e636ca4ec835a" target="_blank" rel="noopener noreffer">commit</a>):<ul><li>50fps -&gt; 60fps</li></ul></li></ul><h3 id="disabling-inlining">Disabling inlining</h3><p>At this point, the emulator was running at 60 FPS on my PC browser, but only at 20~40 FPS on my phone. As I wondered what to do, I realized that the JS output from the release build was slower than the JS output from the dev build. With the <a href="https://discuss.ocaml.org/t/js-of-ocaml-output-performs-considerably-worse-when-built-with-profile-release-flag/8862" target="_blank" rel="noopener noreffer">help</a> from people at discuss.ocaml.org, we found that js_of_ocaml’s inlining was slowing down the JS performance<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup>. (Update 2022-01-12: The negative impact of inlining is being addressed in <a href="https://github.com/ocsigen/js_of_ocaml/pull/1220" target="_blank" rel="noopener noreffer">ocsigen/js_of_ocaml#1220</a>.)</p><p>After disabling inlining, I achieved 100 FPS on my PC and 60 FPS on my phone. Below is the gif of the emulator running in 100 FPS in the PC browser.</p><p><img src="https://linoscope.github.io/images/after-optimize.gif" alt="after optimize" title="after-optimize"/></p><p>As a side note, optimizing the JS performance also improved the native performance. Below is the emulator running in ~1000 FPS in native.</p><p><img src="https://linoscope.github.io/images/after-optimize-native.gif" alt="after optimize native" title="after-optimize-native"/></p><h2 id="some-benchmarks">Some benchmarks</h2><p>I implemented a <em>headless benchmarking mode</em> to run the emulator without UI. I measured the FPS in various OCaml compiler backends, and the result was as follows:<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup></p><p><img src="https://linoscope.github.io/images/benchmark-result.png" alt="benchmark result" title="benchmark-result"/></p><h2 id="thoughts-on-emulator-development">Thoughts on emulator development</h2><p>I found emulator development to be similar to competitive programming. They both proceed through an iteration of the following steps:</p><ul><li>Read the specification — the problem statement in competitive programming and the manuals/wiki pages in emulator development.</li><li>Implement according to the specification.</li><li>Check whether the implementation satisfies the specification — submitting to an online judge in competitive programming and running test ROMs in emulator development.</li></ul><p>In the past, I have recommended competitive programming to people (like me) who want to code but have a hard time thinking of what to implement. In the future, I would also recommend emulator development to such people.</p><h2 id="things-i-liked-about-ocaml">Things I liked about OCaml</h2><h4 id="the-ecosystem">The ecosystem</h4><p>The ecosystem of OCaml has improved a lot since the last time I touched OCaml (around six years ago). To list a few examples:</p><ul><li>Thanks to <a href="https://dune.readthedocs.io/en/stable/" target="_blank" rel="noopener noreffer">dune</a>, we now have the “just throw the files in the directory, and the build system will do the rest” experience, which is becoming the norm in modern programming languages.</li><li>Thanks to software such as <a href="https://github.com/ocaml/merlin" target="_blank" rel="noopener noreffer">Merlin</a> and <a href="https://github.com/ocaml-ppx/ocamlformat" target="_blank" rel="noopener noreffer">OCamlformat</a>, introducing autocomplete, code navigation, and autoformat is mostly effortless.</li><li>Thanks to <a href="https://github.com/ocaml/setup-ocaml" target="_blank" rel="noopener noreffer">setup-ocaml</a>, we can set up Github actions that builds and test your code by just committing a single file.</li></ul><p>If you tried OCaml a few years ago but left because of the ecosystem, you should give it another shot.</p><h4 id="doesnt-have-to-be-functional-to-be-useful">Doesn’t have to be “functional” to be useful</h4><p>A functional language is often defined as “a language that supports a programming style that uses as few side effects as possible”, but I have always felt uncomfortable with this “side effects” part. I am not saying that the definition is wrong; I just never thought side effects themselves were a huge problem. An exposed mutable state is bad, but isn’t it OK if hidden behind an abstraction?</p><p>In fact, the implementation of CAMLBOY has mutable states everywhere for performance reasons. Many modules have functions with the type <code>t -&gt; ... -&gt; unit</code>, which indicates modification of some mutable state. And despite this non-“functional” implementation, I never felt that I was missing out on the benefits of OCaml.</p><p>Maybe it’s not that I like “functional” languages; I like statically typed languages with variants, pattern matching, a module system, and nice type inference.</p><h2 id="things-i-didnt-like-about-ocaml">Things I didn’t like about OCaml</h2><h4 id="the-ecosystem-1">The ecosystem</h4><p>Although the ecosystem has significantly improved, some things still feel complex or poorly documented. For example, I had trouble resolving dependencies in a reproducible way as there seemed to be no clear instructions in the <a href="https://opam.ocaml.org/doc/Usage.html" target="_blank" rel="noopener noreffer">official opam document</a>. I ended up reading the source of <a href="https://github.com/ocaml/setup-ocaml" target="_blank" rel="noopener noreffer"><code>setup-ocaml</code></a> to find out the required commands, and the commands I found felt a little complex (we need to “publish” the package locally, then install the locally published package). It would be super nice if there was a single command that resolves the dependencies and builds the code in a reproducible way.</p><h4 id="the-syntactical-cost-of-depending-on-abstractions">The syntactical cost of depending on abstractions</h4><p>OCaml has a high cost of “depending on abstractions”. Let me illustrate what I mean with an example.</p><p>Suppose we have modules <code>A</code>, <code>B</code>, and <code>C</code> with the dependency <code>A</code> -&gt; <code>B</code> -&gt; <code>C</code> (<code>A</code> references <code>B</code> which references <code>C</code>), as shown below.</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>module</span> <span>A</span> <span>=</span> <span>struct</span> <span>..</span> <span>B</span><span>.</span><span>foo</span> <span>()</span> <span>..</span> <span>end</span>
</span></span><span><span><span>module</span> <span>B</span> <span>=</span> <span>struct</span> <span>..</span> <span>C</span><span>.</span><span>bar</span> <span>()</span> <span>..</span> <span>end</span>
</span></span><span><span><span>module</span> <span>C</span> <span>=</span> <span>struct</span> <span>..</span> <span>end</span>
</span></span></code></pre></div><p>Say you want to break the hard-coded dependency between <code>B</code> and <code>C</code>. In other words, you want to make <code>B</code> depend on the <code>C</code> ’s interface and not <code>C</code> ’s concrete implementation. You will want to do this, for example, if you want to swap <code>C</code> with a mock implementation in the unit test of <code>B</code>. You can do this with the following steps:</p><ol><li>Extract the interface of <code>C</code> into a signature called <code>C_intf</code></li><li>Define <code>B</code> as a functor that takes <code>C_int</code> as an argument</li></ol><p>The result of these changes should look like the following. Notice that <code>B</code> is now a functor that takes a module that satisfies <code>C</code>’s interface <code>C_intf</code>.</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>module</span> <span>A</span>              <span>=</span> <span>struct</span> <span>..</span> <span>B</span><span>.</span><span>foo</span> <span>()</span> <span>..</span> <span>end</span>
</span></span><span><span><span>module</span> <span>B</span> <span>(</span><span>C</span> <span>:</span> <span>C_intf</span><span>)</span> <span>=</span> <span>struct</span> <span>..</span> <span>C</span><span>.</span><span>bar</span> <span>()</span> <span>..</span> <span>end</span>
</span></span><span><span><span>module</span> <span>C</span>              <span>=</span> <span>struct</span> <span>..</span> <span>end</span>
</span></span></code></pre></div><p>But this won’t compile because <code>B</code> referenced in <code>A</code> is now a functor and not a module. Therefore, we need to repeat the above steps and abstract away <code>B</code> from <code>A</code> like this:</p><div><pre tabindex="0"><code data-lang="OCaml"><span><span><span>module</span> <span>A</span> <span>(</span><span>B</span> <span>:</span> <span>B_intf</span><span>)</span>          <span>=</span> <span>struct</span> <span>..</span> <span>B</span><span>.</span><span>foo</span> <span>()</span> <span>..</span> <span>end</span>
</span></span><span><span><span>module</span> <span>B</span> <span>(</span><span>C</span> <span>:</span> <span>C_intf</span><span>)</span> <span>:</span> <span>B_intf</span> <span>=</span> <span>struct</span> <span>..</span> <span>C</span><span>.</span><span>bar</span> <span>()</span> <span>..</span> <span>end</span>
</span></span><span><span><span>module</span> <span>C</span>                       <span>=</span> <span>struct</span> <span>..</span> <span>end</span>
</span></span></code></pre></div><p>Let’s see what happened here in detail. Any module have two types of dependencies:</p><ul><li><p>(a) How the module depends on other modules</p></li><li><p>(b) How the module is depended on by other modules</p></li></ul><p>The motivation for converting a module into a functor is to change (a), but converting a module to a functor also changes (b). In other words, <strong>converting a module to a functor not only changes how the module <em>depends on</em> other modules, but it also changes how it is <em>dependend on by</em> other modules</strong>.</p><p>This will be a bigger problem if many modules depend on <code>B</code> or if we have a deeper dependency graph.</p><p>Note that this won’t happen in the OOP paradigm. Changing class <code>B</code> ’s constructor to take an interface <code>C_intf</code> instead of a concrete class <code>C</code> will not change the type of class <code>B</code> itself.<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup></p><p>While working on CAMLBOY, I ran into this problem when I tried to make the cartridge implementation switchable at runtime (I had the dependency graph of <code>Camlboy</code> -&gt; <code>Bus</code> -&gt; <code>Cartridge</code> and wanted just to decouple the <code>Bus</code> -&gt; <code>Cartridge</code> part).</p><h2 id="about-ocaml">About OCaml</h2><ul><li><a href="https://github.com/janestreet/learn-ocaml-workshop" target="_blank" rel="noopener noreffer">Learn OCaml Workshop</a><ul><li>I highly recommend this workshop material used (used to be used?) within Jane Street. It consists of OCaml code with holes and tests that require filling the holes to pass, so you can learn the basics of OCaml efficiently in a hands-on way. The second half of the book deals with pretty complex programs such as Snake and Lumines, so you can learn how to separate modules effectively, how you can use the build system, etc.</li></ul></li><li><a href="https://dev.realworldocaml.org/" target="_blank" rel="noopener noreffer">Real World OCaml</a><ul><li>I recommend this book if you know the basic syntax of OCaml or have experience in other functional languages. It introduces the knowledge needed to write “real world” programs in OCaml with practical examples.</li></ul></li></ul><h2 id="about-game-boy">About Game Boy</h2><ul><li><a href="https://www.youtube.com/watch?v=HyzD8pNlpwI" target="_blank" rel="noopener noreffer">The Ultimate Game Boy Talk</a><ul><li>This is a great video that explains the whole Game Boy architecture in just one hour. I’ve watched it countless times during the course of development.</li></ul></li><li><a href="https://izik1.github.io/gbops/" target="_blank" rel="noopener noreffer">gbops</a><ul><li>A table of Game Boy’s instruction set. Information necessary for decoding instructions is summarized here.</li></ul></li><li><a href="http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf" target="_blank" rel="noopener noreffer">Game Boy CPU Manual</a><ul><li>CPU manual. I used this manual to implement the instructions. Note that some parts (especially around the register flags) are incorrect.</li></ul></li><li><a href="https://gbdev.io/pandocs/" target="_blank" rel="noopener noreffer">Pandocs</a><ul><li>A wiki with details on how each hardware module should work. I constantly referenced this wiki while implementing GPU, Timer, etc.</li></ul></li><li><a href="https://imrannazar.com/GameBoy-Emulation-in-JavaScript" target="_blank" rel="noopener noreffer">Imran Nazar’s blog</a><ul><li>A tutorial on how to implement a Game Boy emulator in JavaScript. I read it to get a rough understanding of what to implement.</li></ul></li></ul></div></div>
  </body>
</html>
