<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xnacly.me/posts/2025/json-parser-in-c-with-methods/">Original</a>
    <h1>Abusing C to implement JSON parsing with struct methods</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="idea">Idea</h2><ol><li>Build a JSON parser in c</li><li>Instead of using by itself functions: attach functions to a struct and use
these as methods</li><li>make it C issue family free (segfaults, leaks, stack overflows, etc…)</li><li>provide an ergonomic API</li></ol><h3 id="usage">Usage</h3><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>#include</span> <span>&#34;json.h&#34;</span><span>
</span></span></span><span><span> 2</span><span><span>#include</span> <span>&lt;stdlib.h&gt;</span><span>
</span></span></span><span><span> 3</span><span><span></span>
</span></span><span><span> 4</span><span><span>int</span> <span>main</span>(<span>void</span>) {
</span></span><span><span> 5</span><span>  <span>struct</span> json json <span>=</span> <span>json_new</span>(<span>JSON</span>({
</span></span><span><span> 6</span><span>    <span>&#34;object&#34;</span> <span>:</span> {},
</span></span><span><span> 7</span><span>    <span>&#34;array&#34;</span> <span>:</span> [[]],
</span></span><span><span> 8</span><span>    <span>&#34;atoms&#34;</span> <span>:</span> [ <span>&#34;string&#34;</span>, <span>0.1</span>, <span>true</span>, <span>false</span>, null ]
</span></span><span><span> 9</span><span>  }));
</span></span><span><span>10</span><span>  <span>struct</span> json_value json_value <span>=</span> json.<span>parse</span>(<span>&amp;</span>json);
</span></span><span><span>11</span><span>  <span>json_print_value</span>(<span>&amp;</span>json_value);
</span></span><span><span>12</span><span>  <span>puts</span>(<span>&#34;&#34;</span>);
</span></span><span><span>13</span><span>  <span>json_free_value</span>(<span>&amp;</span>json_value);
</span></span><span><span>14</span><span>  <span>return</span> EXIT_SUCCESS;
</span></span><span><span>15</span><span>}</span></span></code></pre></div><div id="callout"><h3>Tip - Compiling C projects the easy way</h3><blockquote><p>Don’t take this as a guide for using make, in my projects I just use it as a
command runner.</p></blockquote><h4 id="compiler-flags">Compiler flags</h4><blockquote><p>These flags can be specific to <code>gcc</code>, I use <code>gcc (GCC) 14.2.1 20250207</code>, so
take this with a grain of salt.</p></blockquote><p>I use these flags in almost every c project I ever started.</p><p><span>SH</span></p><div><pre tabindex="0"><code data-lang="sh"><span><span> 1</span><span>gcc -std<span>=</span>c23 <span>\
</span></span></span><span><span> 2</span><span><span></span>	-O2 <span>\
</span></span></span><span><span> 3</span><span><span></span>	-Wall <span>\
</span></span></span><span><span> 4</span><span><span></span>	-Wextra <span>\
</span></span></span><span><span> 5</span><span><span></span>	-Werror <span>\
</span></span></span><span><span> 6</span><span><span></span>	-fdiagnostics-color<span>=</span>always <span>\
</span></span></span><span><span> 7</span><span><span></span>	-fsanitize<span>=</span>address,undefined <span>\
</span></span></span><span><span> 8</span><span><span></span>	-fno-common <span>\
</span></span></span><span><span> 9</span><span><span></span>	-Winit-self <span>\
</span></span></span><span><span>10</span><span><span></span>	-Wfloat-equal <span>\
</span></span></span><span><span>11</span><span><span></span>	-Wundef <span>\
</span></span></span><span><span>12</span><span><span></span>	-Wshadow <span>\
</span></span></span><span><span>13</span><span><span></span>	-Wpointer-arith <span>\
</span></span></span><span><span>14</span><span><span></span>	-Wcast-align <span>\
</span></span></span><span><span>15</span><span><span></span>	-Wstrict-prototypes <span>\
</span></span></span><span><span>16</span><span><span></span>	-Wstrict-overflow<span>=</span><span>5</span> <span>\
</span></span></span><span><span>17</span><span><span></span>	-Wwrite-strings <span>\
</span></span></span><span><span>18</span><span><span></span>	-Waggregate-return <span>\
</span></span></span><span><span>19</span><span><span></span>	-Wswitch-default <span>\
</span></span></span><span><span>20</span><span><span></span>	-Wno-discarded-qualifiers <span>\
</span></span></span><span><span>21</span><span><span></span>	-Wno-aggregate-return <span>\
</span></span></span><span><span>22</span><span><span></span>    main.c</span></span></code></pre></div><table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody><tr><td><code>-std=c23</code></td><td>set lang standard, i use ISO C23</td></tr><tr><td><code>-O2</code></td><td>optimize more than <code>-O1</code></td></tr><tr><td><code>-Wall</code></td><td>enable a list of warnings</td></tr><tr><td><code>-Wextra</code></td><td>enable more warnings than -Wall</td></tr><tr><td><code>-Werror</code></td><td>convert all warnings to errors</td></tr><tr><td><code>-fdiagnostics-color=always</code></td><td>use color in diagnostics</td></tr><tr><td><code>-fsanitize=address,undefined</code></td><td>enable AddressSanitizer and UndefinedBehaviorSanitizer</td></tr><tr><td><code>-fno-common</code></td><td>place uninitialized global variables in the BSS section</td></tr><tr><td><code>-Winit-self</code></td><td>warn about uninitialized variables</td></tr><tr><td><code>-Wfloat-equal</code></td><td>warn if floating-point values are used in equality comparisons.</td></tr><tr><td><code>-Wundef</code></td><td>warn if an undefined identifier is evaluated</td></tr><tr><td><code>-Wshadow</code></td><td>warn whenever a local variable or type declaration shadows another variable, parameter, type</td></tr><tr><td><code>-Wpointer-arith</code></td><td>warn about anything that depends on the “size of” a function type or of void</td></tr><tr><td><code>-Wcast-align</code></td><td>warn whenever a pointer is cast such that the required alignment of the target is increased.</td></tr><tr><td><code>-Wstrict-prototypes</code></td><td>warn if a function is declared or defined without specifying the argument types</td></tr><tr><td><code>-Wstrict-overflow=5</code></td><td>warns about cases where the compiler optimizes based on the assumption that signed overflow does not occu</td></tr><tr><td><code>-Wwrite-strings</code></td><td>give string constants the type <code>const char[length]</code>, warns on copy into non const char*</td></tr><tr><td><code>-Wswitch-default</code></td><td>warn whenever a switch statement does not have a default case</td></tr><tr><td><code>-Wno-discarded-qualifiers</code></td><td>do not warn if type qualifiers on pointers are being discarded.</td></tr><tr><td><code>-Wno-aggregate-return</code></td><td>do not warn if any functions that return structures or unions are defined or called.</td></tr></tbody></table><h4 id="sourcing-source-files">Sourcing source files</h4><p>I generally keep my header and source files in the same directory as the
makefile, so i use <code>find</code> to find them:</p><p><span>SHELL</span></p><div><pre tabindex="0"><code data-lang="shell"><span><span>1</span><span>shell find . -name <span>&#34;*.c&#34;</span></span></span></code></pre></div><h4 id="make-and-makefiles">Make and Makefiles</h4><blockquote><p>I don’t define the <code>build</code> target as <code>.PHONY</code> because i generally never have
a <code>build</code> directory.</p></blockquote><p>Putting it all together as a makefile:</p><p><span>MAKE</span></p><div><pre tabindex="0"><code data-lang="make"><span><span> 1</span><span><span>CFLAGS</span> <span>:=</span> -std<span>=</span>c23 <span>\
</span></span></span><span><span> 2</span><span><span></span>	-O2 <span>\
</span></span></span><span><span> 3</span><span><span></span>	-Wall <span>\
</span></span></span><span><span> 4</span><span><span></span>	-Wextra <span>\
</span></span></span><span><span> 5</span><span><span></span>	-Werror <span>\
</span></span></span><span><span> 6</span><span><span></span>	-fdiagnostics-color<span>=</span>always <span>\
</span></span></span><span><span> 7</span><span><span></span>	-fsanitize<span>=</span>address,undefined <span>\
</span></span></span><span><span> 8</span><span><span></span>	-fno-common <span>\
</span></span></span><span><span> 9</span><span><span></span>	-Winit-self <span>\
</span></span></span><span><span>10</span><span><span></span>	-Wfloat-equal <span>\
</span></span></span><span><span>11</span><span><span></span>	-Wundef <span>\
</span></span></span><span><span>12</span><span><span></span>	-Wshadow <span>\
</span></span></span><span><span>13</span><span><span></span>	-Wpointer-arith <span>\
</span></span></span><span><span>14</span><span><span></span>	-Wcast-align <span>\
</span></span></span><span><span>15</span><span><span></span>	-Wstrict-prototypes <span>\
</span></span></span><span><span>16</span><span><span></span>	-Wstrict-overflow<span>=</span><span>5</span> <span>\
</span></span></span><span><span>17</span><span><span></span>	-Wwrite-strings <span>\
</span></span></span><span><span>18</span><span><span></span>	-Waggregate-return <span>\
</span></span></span><span><span>19</span><span><span></span>	-Wcast-qual <span>\
</span></span></span><span><span>20</span><span><span></span>	-Wswitch-default <span>\
</span></span></span><span><span>21</span><span><span></span>	-Wno-discarded-qualifiers <span>\
</span></span></span><span><span>22</span><span><span></span>	-Wno-aggregate-return
</span></span><span><span>23</span><span>
</span></span><span><span>24</span><span><span>FILES</span> <span>:=</span> <span>$(</span>shell find . -name <span>&#34;*.c&#34;</span><span>)</span>
</span></span><span><span>25</span><span>
</span></span><span><span>26</span><span><span>build</span><span>:</span>
</span></span><span><span>27</span><span>	<span>$(</span>CC<span>)</span> <span>$(</span>CFLAGS<span>)</span> <span>$(</span>FILES<span>)</span> -o jsoninc
</span></span></code></pre></div></div><h2 id="variadic-macros-to-write-inline-raw-json">Variadic macros to write inline raw JSON</h2><p>This doesn’t really deserve its own section, but I use <code>#&lt;expression&gt;</code> to
stringify C expressions in conjunction with <code>__VA_ARGS__</code>:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>#define JSON(...) #__VA_ARGS__</span></span></span></code></pre></div><p>To enable:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>char</span> <span>*</span>raw_json <span>=</span> <span>JSON</span>({ <span>&#34;array&#34;</span> <span>:</span> [ [], {}] });</span></span></code></pre></div><p>Inlines to:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>char</span> <span>*</span>raw_json <span>=</span> <span>&#34;{ </span><span>\&#34;</span><span>array</span><span>\&#34;</span><span> : [[]], }&#34;</span>;</span></span></code></pre></div><h2 id="representing-json-values-in-memory">Representing JSON values in memory</h2><p>I need a structure to hold a parsed JSON value, their types and their values.</p><h3 id="types-of-json-values">Types of JSON values</h3><p>JSON can be either one of:</p><ol><li>null</li><li>true</li><li>false</li><li>number</li><li>string</li><li>array</li><li>object</li></ol><p>In C i use an enum to represent this:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>// json.h
</span></span></span><span><span> 2</span><span><span></span><span>enum</span> json_type {
</span></span><span><span> 3</span><span>  json_number,
</span></span><span><span> 4</span><span>  json_string,
</span></span><span><span> 5</span><span>  json_boolean,
</span></span><span><span> 6</span><span>  json_null,
</span></span><span><span> 7</span><span>  json_object,
</span></span><span><span> 8</span><span>  json_array,
</span></span><span><span> 9</span><span>};
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span><span>extern</span> <span>char</span> <span>*</span>json_type_map[];</span></span></code></pre></div><p>And i use <code>json_type_map</code> to map all <code>json_type</code> values to their <code>char*</code> representation:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>char</span> <span>*</span>json_type_map[] <span>=</span> {
</span></span><span><span>2</span><span>    [json_number] <span>=</span> <span>&#34;json_number&#34;</span>,   [json_string] <span>=</span> <span>&#34;json_string&#34;</span>,
</span></span><span><span>3</span><span>    [json_boolean] <span>=</span> <span>&#34;json_boolean&#34;</span>, [json_null] <span>=</span> <span>&#34;json_null&#34;</span>,
</span></span><span><span>4</span><span>    [json_object] <span>=</span> <span>&#34;json_object&#34;</span>,   [json_array] <span>=</span> <span>&#34;json_array&#34;</span>,
</span></span><span><span>5</span><span>};</span></span></code></pre></div><h3 id="json_value--unions-for-atoms-array-elements-or-object-values-and-object-keys">json_value &amp; unions for atoms, array elements or object values and object keys</h3><p>The <code>json_value</code> struct holds the type, as defined above, a union sharing
memory space for either a boolean, a string or a number, a list of <code>json_value</code>
structures as array children or object values, a list of strings that are
object keys and the length for the three aforementioned fields.</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>struct</span> json_value {
</span></span><span><span> 2</span><span>  <span>enum</span> json_type type;
</span></span><span><span> 3</span><span>  <span>union</span> {
</span></span><span><span> 4</span><span>    <span>bool</span> boolean;
</span></span><span><span> 5</span><span>    <span>char</span> <span>*</span>string;
</span></span><span><span> 6</span><span>    <span>double</span> number;
</span></span><span><span> 7</span><span>  } value;
</span></span><span><span> 8</span><span>  <span>struct</span> json_value <span>*</span>values;
</span></span><span><span> 9</span><span>  <span>char</span> <span>**</span>object_keys;
</span></span><span><span>10</span><span>  <span>size_t</span> length;
</span></span><span><span>11</span><span>};</span></span></code></pre></div><h3 id="tearing-values-down">Tearing values down</h3><p>Since some of the fields in <code>json_value</code> are heap allocated, we have to destroy
/ free the structure upon either no longer using it or exiting the process.
<code>json_free_value</code> does exactly this:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>void</span> <span>json_free_value</span>(<span>struct</span> json_value <span>*</span>json_value) {
</span></span><span><span> 2</span><span>  <span>switch</span> (json_value<span>-&gt;</span>type) {
</span></span><span><span> 3</span><span>  <span>case</span> <span>json_string</span>:
</span></span><span><span> 4</span><span>    <span>free</span>(json_value<span>-&gt;</span>value.string);
</span></span><span><span> 5</span><span>    <span>break</span>;
</span></span><span><span> 6</span><span>  <span>case</span> <span>json_object</span>:
</span></span><span><span> 7</span><span>    <span>for</span> (<span>size_t</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> json_value<span>-&gt;</span>length; i<span>++</span>) {
</span></span><span><span> 8</span><span>      <span>free</span>(json_value<span>-&gt;</span>object_keys[i]);
</span></span><span><span> 9</span><span>      <span>json_free_value</span>(<span>&amp;</span>json_value<span>-&gt;</span>values[i]);
</span></span><span><span>10</span><span>    }
</span></span><span><span>11</span><span>    <span>if</span> (json_value<span>-&gt;</span>object_keys <span>!=</span> <span>NULL</span>) {
</span></span><span><span>12</span><span>      <span>free</span>(json_value<span>-&gt;</span>object_keys);
</span></span><span><span>13</span><span>      json_value<span>-&gt;</span>object_keys <span>=</span> <span>NULL</span>;
</span></span><span><span>14</span><span>    }
</span></span><span><span>15</span><span>    <span>if</span> (json_value<span>-&gt;</span>values <span>!=</span> <span>NULL</span>) {
</span></span><span><span>16</span><span>      <span>free</span>(json_value<span>-&gt;</span>values);
</span></span><span><span>17</span><span>      json_value<span>-&gt;</span>values <span>=</span> <span>NULL</span>;
</span></span><span><span>18</span><span>    }
</span></span><span><span>19</span><span>    <span>break</span>;
</span></span><span><span>20</span><span>  <span>case</span> <span>json_array</span>:
</span></span><span><span>21</span><span>    <span>for</span> (<span>size_t</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> json_value<span>-&gt;</span>length; i<span>++</span>) {
</span></span><span><span>22</span><span>      <span>json_free_value</span>(<span>&amp;</span>json_value<span>-&gt;</span>values[i]);
</span></span><span><span>23</span><span>    }
</span></span><span><span>24</span><span>    <span>if</span> (json_value<span>-&gt;</span>values <span>!=</span> <span>NULL</span>) {
</span></span><span><span>25</span><span>      <span>free</span>(json_value<span>-&gt;</span>values);
</span></span><span><span>26</span><span>      json_value<span>-&gt;</span>values <span>=</span> <span>NULL</span>;
</span></span><span><span>27</span><span>    }
</span></span><span><span>28</span><span>    <span>break</span>;
</span></span><span><span>29</span><span>  <span>case</span> <span>json_number</span>:
</span></span><span><span>30</span><span>  <span>case</span> <span>json_boolean</span>:
</span></span><span><span>31</span><span>  <span>case</span> <span>json_null</span>:
</span></span><span><span>32</span><span>  <span>default</span><span>:</span>
</span></span><span><span>33</span><span>    <span>break</span>;
</span></span><span><span>34</span><span>  }
</span></span><span><span>35</span><span>  json_value<span>-&gt;</span>type <span>=</span> json_null;
</span></span><span><span>36</span><span>}</span></span></code></pre></div><p>As simple as that, we ignore stack allocated JSON value variants, such as
<code>json_number</code>, <code>json_boolean</code> and <code>json_null</code>, while freeing allocated memory
space for <code>json_string</code>, each <code>json_array</code> child and <code>json_object</code> keys and
values.</p><h3 id="printing-json_values">Printing json_values</h3><p>Only a memory representation and no way to inspect it has no value to us, thus
I dumped <code>print_json_value</code> into <code>main.c</code>:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>void</span> <span>print_json_value</span>(<span>struct</span> json_value <span>*</span>json_value) {
</span></span><span><span> 2</span><span>  <span>switch</span> (json_value<span>-&gt;</span>type) {
</span></span><span><span> 3</span><span>  <span>case</span> <span>json_null</span>:
</span></span><span><span> 4</span><span>    <span>printf</span>(<span>&#34;null&#34;</span>);
</span></span><span><span> 5</span><span>    <span>break</span>;
</span></span><span><span> 6</span><span>  <span>case</span> <span>json_number</span>:
</span></span><span><span> 7</span><span>    <span>printf</span>(<span>&#34;%f&#34;</span>, json_value<span>-&gt;</span>value.number);
</span></span><span><span> 8</span><span>    <span>break</span>;
</span></span><span><span> 9</span><span>  <span>case</span> <span>json_string</span>:
</span></span><span><span>10</span><span>    <span>printf</span>(<span>&#34;</span><span>\&#34;</span><span>%s</span><span>\&#34;</span><span>&#34;</span>, json_value<span>-&gt;</span>value.string);
</span></span><span><span>11</span><span>    <span>break</span>;
</span></span><span><span>12</span><span>  <span>case</span> <span>json_boolean</span>:
</span></span><span><span>13</span><span>    <span>printf</span>(json_value<span>-&gt;</span>value.boolean <span>?</span> <span>&#34;true&#34;</span> <span>:</span> <span>&#34;false&#34;</span>);
</span></span><span><span>14</span><span>    <span>break</span>;
</span></span><span><span>15</span><span>  <span>case</span> <span>json_object</span>:
</span></span><span><span>16</span><span>    <span>printf</span>(<span>&#34;{&#34;</span>);
</span></span><span><span>17</span><span>    <span>for</span> (<span>size_t</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> json_value<span>-&gt;</span>length; i<span>++</span>) {
</span></span><span><span>18</span><span>      <span>printf</span>(<span>&#34;</span><span>\&#34;</span><span>%s</span><span>\&#34;</span><span>: &#34;</span>, json_value<span>-&gt;</span>object_keys[i]);
</span></span><span><span>19</span><span>      <span>print_json_value</span>(<span>&amp;</span>json_value<span>-&gt;</span>values[i]);
</span></span><span><span>20</span><span>      <span>if</span> (i <span>&lt;</span> json_value<span>-&gt;</span>length <span>-</span> <span>1</span>) {
</span></span><span><span>21</span><span>        <span>printf</span>(<span>&#34;, &#34;</span>);
</span></span><span><span>22</span><span>      }
</span></span><span><span>23</span><span>    }
</span></span><span><span>24</span><span>    <span>printf</span>(<span>&#34;}&#34;</span>);
</span></span><span><span>25</span><span>    <span>break</span>;
</span></span><span><span>26</span><span>  <span>case</span> <span>json_array</span>:
</span></span><span><span>27</span><span>    <span>printf</span>(<span>&#34;[&#34;</span>);
</span></span><span><span>28</span><span>    <span>for</span> (<span>size_t</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> json_value<span>-&gt;</span>length; i<span>++</span>) {
</span></span><span><span>29</span><span>      <span>print_json_value</span>(<span>&amp;</span>json_value<span>-&gt;</span>values[i]);
</span></span><span><span>30</span><span>      <span>if</span> (i <span>&lt;</span> json_value<span>-&gt;</span>length <span>-</span> <span>1</span>) {
</span></span><span><span>31</span><span>        <span>printf</span>(<span>&#34;, &#34;</span>);
</span></span><span><span>32</span><span>      }
</span></span><span><span>33</span><span>    }
</span></span><span><span>34</span><span>    <span>printf</span>(<span>&#34;]&#34;</span>);
</span></span><span><span>35</span><span>    <span>break</span>;
</span></span><span><span>36</span><span>  <span>default</span><span>:</span>
</span></span><span><span>37</span><span>    <span>ASSERT</span>(<span>0</span>, <span>&#34;Unimplemented json_value case&#34;</span>);
</span></span><span><span>38</span><span>    <span>break</span>;
</span></span><span><span>39</span><span>  }
</span></span><span><span>40</span><span>}</span></span></code></pre></div><p>Calling this function:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>int</span> <span>main</span>(<span>void</span>) {
</span></span><span><span> 2</span><span>  <span>struct</span> json_value json_value <span>=</span> {
</span></span><span><span> 3</span><span>      .type <span>=</span> json_array,
</span></span><span><span> 4</span><span>      .length <span>=</span> <span>4</span>,
</span></span><span><span> 5</span><span>      .values <span>=</span>
</span></span><span><span> 6</span><span>          (<span>struct</span> json_value[]){
</span></span><span><span> 7</span><span>              (<span>struct</span> json_value){.type <span>=</span> json_string, .value.string <span>=</span> <span>&#34;hi&#34;</span>},
</span></span><span><span> 8</span><span>              (<span>struct</span> json_value){.type <span>=</span> json_number, .value.number <span>=</span> <span>161</span>},
</span></span><span><span> 9</span><span>              (<span>struct</span> json_value){
</span></span><span><span>10</span><span>                  .type <span>=</span> json_object,
</span></span><span><span>11</span><span>                  .length <span>=</span> <span>1</span>,
</span></span><span><span>12</span><span>                  .object_keys <span>=</span>
</span></span><span><span>13</span><span>                      (<span>char</span> <span>*</span>[]){
</span></span><span><span>14</span><span>                          <span>&#34;key&#34;</span>,
</span></span><span><span>15</span><span>                      },
</span></span><span><span>16</span><span>                  .values <span>=</span>
</span></span><span><span>17</span><span>                      (<span>struct</span> json_value[]){
</span></span><span><span>18</span><span>                          (<span>struct</span> json_value){.type <span>=</span> json_string,
</span></span><span><span>19</span><span>                                              .value.string <span>=</span> <span>&#34;value&#34;</span>},
</span></span><span><span>20</span><span>                      },
</span></span><span><span>21</span><span>              },
</span></span><span><span>22</span><span>              (<span>struct</span> json_value){.type <span>=</span> json_null},
</span></span><span><span>23</span><span>          },
</span></span><span><span>24</span><span>  };
</span></span><span><span>25</span><span>  <span>json_print_value</span>(<span>&amp;</span>json_value);
</span></span><span><span>26</span><span>  <span>puts</span>(<span>&#34;&#34;</span>);
</span></span><span><span>27</span><span>  <span>return</span> EXIT_SUCCESS;
</span></span><span><span>28</span><span>}</span></span></code></pre></div><p>Results in:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>[&#34;hi&#34;, 161.000000, {&#34;key&#34;: &#34;value&#34;}, null]</span></span></code></pre></div><h3 id="json-parser-struct-function-pointers-and-how-to-use-them-they-suck"><code>json</code> Parser struct, Function pointers and how to use them (they suck)</h3><p>As contrary as it sounds, one can attach functions to structures in c very
easily, just define a field of a struct as a function pointer, assign a
function to it and you got a method, as you would in Go or Rust.</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>struct</span> json {
</span></span><span><span> 2</span><span>  <span>char</span> <span>*</span>input;
</span></span><span><span> 3</span><span>  <span>size_t</span> pos;
</span></span><span><span> 4</span><span>  <span>size_t</span> length;
</span></span><span><span> 5</span><span>  <span>char</span> (<span>*</span>cur)(<span>struct</span> json <span>*</span>json);
</span></span><span><span> 6</span><span>  <span>bool</span> (<span>*</span>is_eof)(<span>struct</span> json <span>*</span>json);
</span></span><span><span> 7</span><span>  <span>void</span> (<span>*</span>advance)(<span>struct</span> json <span>*</span>json);
</span></span><span><span> 8</span><span>  <span>struct</span> <span>json_value</span> (<span>*</span>atom)(<span>struct</span> json <span>*</span>json);
</span></span><span><span> 9</span><span>  <span>struct</span> <span>json_value</span> (<span>*</span>array)(<span>struct</span> json <span>*</span>json);
</span></span><span><span>10</span><span>  <span>struct</span> <span>json_value</span> (<span>*</span>object)(<span>struct</span> json <span>*</span>json);
</span></span><span><span>11</span><span>  <span>struct</span> <span>json_value</span> (<span>*</span>parse)(<span>struct</span> json <span>*</span>json);
</span></span><span><span>12</span><span>};</span></span></code></pre></div><p>Of course you have to define a function the c way (<code>&lt;return type&gt; &lt;name&gt;(&lt;list of params&gt;);</code>) and assign it to your method field - but I is not that
complicated:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>struct</span> json <span>json_new</span>(<span>char</span> <span>*</span>input) {
</span></span><span><span> 2</span><span>  <span>ASSERT</span>(input <span>!=</span> <span>NULL</span>, <span>&#34;corrupted input&#34;</span>);
</span></span><span><span> 3</span><span>  <span>struct</span> json j <span>=</span> (<span>struct</span> json){
</span></span><span><span> 4</span><span>      .input <span>=</span> input,
</span></span><span><span> 5</span><span>      .length <span>=</span> <span>strlen</span>(input) <span>-</span> <span>1</span>,
</span></span><span><span> 6</span><span>  };
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span>  j.cur <span>=</span> cur;
</span></span><span><span> 9</span><span>  j.is_eof <span>=</span> is_eof;
</span></span><span><span>10</span><span>  j.advance <span>=</span> advance;
</span></span><span><span>11</span><span>  j.parse <span>=</span> parse;
</span></span><span><span>12</span><span>  j.object <span>=</span> object;
</span></span><span><span>13</span><span>  j.array <span>=</span> array;
</span></span><span><span>14</span><span>  j.atom <span>=</span> atom;
</span></span><span><span>15</span><span>
</span></span><span><span>16</span><span>  <span>return</span> j;
</span></span><span><span>17</span><span>}</span></span></code></pre></div><p><code>cur</code>, <code>is_eof</code> and <code>advance</code> are small helper functions:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>static</span> <span>char</span> <span>cur</span>(<span>struct</span> json <span>*</span>json) {
</span></span><span><span> 2</span><span>  <span>ASSERT</span>(json <span>!=</span> <span>NULL</span>, <span>&#34;corrupted internal state&#34;</span>);
</span></span><span><span> 3</span><span>  <span>return</span> json<span>-&gt;</span><span>is_eof</span>(json) <span>?</span> <span>-</span><span>1</span> <span>:</span> json<span>-&gt;</span>input[json<span>-&gt;</span>pos];
</span></span><span><span> 4</span><span>}
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span><span>static</span> <span>bool</span> <span>is_eof</span>(<span>struct</span> json <span>*</span>json) {
</span></span><span><span> 7</span><span>  <span>ASSERT</span>(json <span>!=</span> <span>NULL</span>, <span>&#34;corrupted internal state&#34;</span>);
</span></span><span><span> 8</span><span>  <span>return</span> json<span>-&gt;</span>pos <span>&gt;</span> json<span>-&gt;</span>length;
</span></span><span><span> 9</span><span>}
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span><span>static</span> <span>void</span> <span>advance</span>(<span>struct</span> json <span>*</span>json) {
</span></span><span><span>12</span><span>  <span>ASSERT</span>(json <span>!=</span> <span>NULL</span>, <span>&#34;corrupted internal state&#34;</span>);
</span></span><span><span>13</span><span>  json<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>14</span><span>  <span>skip_whitespace</span>(json);
</span></span><span><span>15</span><span>}</span></span></code></pre></div><p><code>ASSERT</code> is a simple assertion macro:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>#define ASSERT(EXP, context)                                                   \
</span></span></span><span><span>2</span><span><span>  if (!(EXP)) {                                                                \
</span></span></span><span><span>3</span><span><span>    fprintf(stderr,                                                            \
</span></span></span><span><span>4</span><span><span>            &#34;jsoninc: ASSERT(&#34; #EXP &#34;): `&#34; context                             \
</span></span></span><span><span>5</span><span><span>            &#34;` failed at %s, line %d\n&#34;,                                       \
</span></span></span><span><span>6</span><span><span>            __FILE__, __LINE__);                                               \
</span></span></span><span><span>7</span><span><span>    exit(EXIT_FAILURE);                                                        \
</span></span></span><span><span>8</span><span><span>  }</span></span></span></code></pre></div><p>Failing for instance if the argument to the <code>json_new</code> function is a null pointer:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>int</span> <span>main</span>(<span>void</span>) {
</span></span><span><span>2</span><span>  <span>struct</span> json json <span>=</span> <span>json_new</span>(<span>NULL</span>);
</span></span><span><span>3</span><span>  <span>return</span> EXIT_SUCCESS;
</span></span><span><span>4</span><span>}</span></span></code></pre></div><p>Even with a descriptive comment:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>jsoninc: ASSERT(input != NULL): `corrupted input` failed at ./json.c, line 16</span></span></code></pre></div><h2 id="parsing-json-with-methods">Parsing JSON with methods</h2><p>Since we now have the whole setup out of the way, we can start with the crux of
the project: parsing JSON. Normally I would have done a lexer and parser, but
for the sake of simplicity - I combined these passes into a single parser
architecture.</p><h3 id="ignoring-whitespace">Ignoring Whitespace</h3><p>As far as we are concerned, JSON does not say anything about whitespace - so we
just use the <code>skip_whitespace</code> function to ignore all and any whitespace:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span>1</span><span><span>static</span> <span>void</span> <span>skip_whitespace</span>(<span>struct</span> json <span>*</span>json) {
</span></span><span><span>2</span><span>  <span>while</span> (<span>!</span>json<span>-&gt;</span><span>is_eof</span>(json) <span>&amp;&amp;</span>
</span></span><span><span>3</span><span>         (json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39; &#39;</span> <span>||</span> json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;\t&#39;</span> <span>||</span>
</span></span><span><span>4</span><span>          json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;\n&#39;</span>)) {
</span></span><span><span>5</span><span>    json<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>6</span><span>  }
</span></span><span><span>7</span><span>}</span></span></code></pre></div><h3 id="parsing-atoms">Parsing Atoms</h3><p>Since JSON has five kinds of an atom, we need to parse them into our
<code>json_value</code> struct using the <code>json-&gt;atom</code> method:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>static</span> <span>struct</span> json_value <span>atom</span>(<span>struct</span> json <span>*</span>json) {
</span></span><span><span> 2</span><span>    <span>ASSERT</span>(json <span>!=</span> <span>NULL</span>, <span>&#34;corrupted internal state&#34;</span>);
</span></span><span><span> 3</span><span>
</span></span><span><span> 4</span><span>    <span>skip_whitespace</span>(json);
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span>    <span>char</span> cc <span>=</span> json<span>-&gt;</span><span>cur</span>(json);
</span></span><span><span> 7</span><span>    <span>if</span> ((cc <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> cc <span>&lt;=</span> <span>&#39;9&#39;</span>) <span>||</span> cc <span>==</span> <span>&#39;.&#39;</span> <span>||</span> cc <span>==</span> <span>&#39;-&#39;</span>) {
</span></span><span><span> 8</span><span>        <span>return</span> <span>number</span>(json);
</span></span><span><span> 9</span><span>    }
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span>    <span>switch</span> (cc) {
</span></span><span><span>12</span><span>        <span>// ... all of the atoms ...
</span></span></span><span><span>13</span><span><span></span>    <span>default</span><span>:</span>
</span></span><span><span>14</span><span>        <span>printf</span>(<span>&#34;unknown character &#39;%c&#39; at pos %zu</span><span>\n</span><span>&#34;</span>, json<span>-&gt;</span><span>cur</span>(json), json<span>-&gt;</span>pos);
</span></span><span><span>15</span><span>        <span>ASSERT</span>(<span>false</span>, <span>&#34;unknown character&#34;</span>);
</span></span><span><span>16</span><span>        <span>return</span> (<span>struct</span> json_value){.type <span>=</span> json_null};
</span></span><span><span>17</span><span>    }
</span></span><span><span>18</span><span>}</span></span></code></pre></div><h4 id="numbers">numbers</h4><div id="callout"><h3>Info</h3><p>Technically numbers in JSON should include scientific notation and other fun
stuff, but lets just remember the projects simplicity and my sanity, see
<a href="https://xnacly.me/posts/2025/json-parser-in-c-with-methods/www.json.org/">json.org</a>.</p></div><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>static</span> <span>struct</span> json_value <span>number</span>(<span>struct</span> json <span>*</span>json) {
</span></span><span><span> 2</span><span>  <span>ASSERT</span>(json <span>!=</span> <span>NULL</span>, <span>&#34;corrupted internal state&#34;</span>);
</span></span><span><span> 3</span><span>  <span>size_t</span> start <span>=</span> json<span>-&gt;</span>pos;
</span></span><span><span> 4</span><span>  <span>// i don&#39;t give a fuck about scientific notation &lt;3
</span></span></span><span><span> 5</span><span><span></span>  <span>for</span> (<span>char</span> cc <span>=</span> json<span>-&gt;</span><span>cur</span>(json);
</span></span><span><span> 6</span><span>       ((cc <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> cc <span>&lt;=</span> <span>&#39;9&#39;</span>) <span>||</span> cc <span>==</span> <span>&#39;_&#39;</span> <span>||</span> cc <span>==</span> <span>&#39;.&#39;</span> <span>||</span> cc <span>==</span> <span>&#39;-&#39;</span>);
</span></span><span><span> 7</span><span>       json<span>-&gt;</span><span>advance</span>(json), cc <span>=</span> json<span>-&gt;</span><span>cur</span>(json))
</span></span><span><span> 8</span><span>    ;
</span></span><span><span> 9</span><span>
</span></span><span><span>10</span><span>  <span>char</span> <span>*</span>slice <span>=</span> <span>malloc</span>(<span>sizeof</span>(<span>char</span>) <span>*</span> json<span>-&gt;</span>pos <span>-</span> start <span>+</span> <span>1</span>);
</span></span><span><span>11</span><span>  <span>ASSERT</span>(slice <span>!=</span> <span>NULL</span>, <span>&#34;failed to allocate slice for number parsing&#34;</span>)
</span></span><span><span>12</span><span>  <span>memcpy</span>(slice, json<span>-&gt;</span>input <span>+</span> start, json<span>-&gt;</span>pos <span>-</span> start);
</span></span><span><span>13</span><span>  slice[json<span>-&gt;</span>pos <span>-</span> start] <span>=</span> <span>0</span>;
</span></span><span><span>14</span><span>  <span>double</span> number <span>=</span> <span>strtod</span>(slice, <span>NULL</span>);
</span></span><span><span>15</span><span>  <span>free</span>(slice);
</span></span><span><span>16</span><span>
</span></span><span><span>17</span><span>  <span>return</span> (<span>struct</span> json_value){.type <span>=</span> json_number, .value <span>=</span> {.number <span>=</span> number}};
</span></span><span><span>18</span><span>}</span></span></code></pre></div><p>We keep track of the start of the number, advance as far as the number is still
considered a number (any of <code>0-9 | _ | . | -</code>). Once we hit the end we allocate
a temporary string, copy the chars containing the number from the input string
and terminate the string with <code>\0</code>. <code>strtod</code> is used to convert this string to
a double. Once that is done we free the slice and return the result as a
<code>json_value</code>.</p><h4 id="null-true-and-false">null, true and false</h4><p><code>null</code>, <code>true</code> and <code>false</code> are unique atoms and easy to reason about, regarding
constant size and characters, as such we can just assert their characters:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>static</span> <span>struct</span> json_value <span>atom</span>(<span>struct</span> json <span>*</span>json) {
</span></span><span><span> 2</span><span>  <span>ASSERT</span>(json <span>!=</span> <span>NULL</span>, <span>&#34;corrupted internal state&#34;</span>);
</span></span><span><span> 3</span><span>
</span></span><span><span> 4</span><span>  <span>skip_whitespace</span>(json);
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span>  <span>char</span> cc <span>=</span> json<span>-&gt;</span><span>cur</span>(json);
</span></span><span><span> 7</span><span>  <span>if</span> ((cc <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> cc <span>&lt;=</span> <span>&#39;9&#39;</span>) <span>||</span> cc <span>==</span> <span>&#39;.&#39;</span> <span>||</span> cc <span>==</span> <span>&#39;-&#39;</span>) {
</span></span><span><span> 8</span><span>    <span>return</span> <span>number</span>(json);
</span></span><span><span> 9</span><span>  }
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span>  <span>switch</span> (cc) {
</span></span><span><span>12</span><span>  <span>case</span> <span>&#39;n&#39;</span><span>:</span> <span>// null
</span></span></span><span><span>13</span><span><span></span>    json<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>14</span><span>    <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;u&#39;</span>, <span>&#34;unknown atom &#39;n&#39;, wanted &#39;null&#39;&#34;</span>)
</span></span><span><span>15</span><span>    json<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>16</span><span>    <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;l&#39;</span>, <span>&#34;unknown atom &#39;nu&#39;, wanted &#39;null&#39;&#34;</span>)
</span></span><span><span>17</span><span>    json<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>18</span><span>    <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;l&#39;</span>, <span>&#34;unknown atom &#39;nul&#39;, wanted &#39;null&#39;&#34;</span>)
</span></span><span><span>19</span><span>    json<span>-&gt;</span><span>advance</span>(json);
</span></span><span><span>20</span><span>    <span>return</span> (<span>struct</span> json_value){.type <span>=</span> json_null};
</span></span><span><span>21</span><span>  <span>case</span> <span>&#39;t&#39;</span><span>:</span> <span>// true
</span></span></span><span><span>22</span><span><span></span>    json<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>23</span><span>    <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;r&#39;</span>, <span>&#34;unknown atom &#39;t&#39;, wanted &#39;true&#39;&#34;</span>)
</span></span><span><span>24</span><span>    json<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>25</span><span>    <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;u&#39;</span>, <span>&#34;unknown atom &#39;tr&#39;, wanted &#39;true&#39;&#34;</span>)
</span></span><span><span>26</span><span>    json<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>27</span><span>    <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;e&#39;</span>, <span>&#34;unknown atom &#39;tru&#39;, wanted &#39;true&#39;&#34;</span>)
</span></span><span><span>28</span><span>    json<span>-&gt;</span><span>advance</span>(json);
</span></span><span><span>29</span><span>    <span>return</span> (<span>struct</span> json_value){.type <span>=</span> json_boolean,
</span></span><span><span>30</span><span>                               .value <span>=</span> {.boolean <span>=</span> <span>true</span>}};
</span></span><span><span>31</span><span>  <span>case</span> <span>&#39;f&#39;</span><span>:</span> <span>// false
</span></span></span><span><span>32</span><span><span></span>    json<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>33</span><span>    <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;a&#39;</span>, <span>&#34;invalid atom &#39;f&#39;, wanted &#39;false&#39;&#34;</span>)
</span></span><span><span>34</span><span>    json<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>35</span><span>    <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;l&#39;</span>, <span>&#34;invalid atom &#39;fa&#39;, wanted &#39;false&#39;&#34;</span>)
</span></span><span><span>36</span><span>    json<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>37</span><span>    <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;s&#39;</span>, <span>&#34;invalid atom &#39;fal&#39;, wanted &#39;false&#39;&#34;</span>)
</span></span><span><span>38</span><span>    json<span>-&gt;</span>pos<span>++</span>;
</span></span><span><span>39</span><span>    <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;e&#39;</span>, <span>&#34;invalid atom &#39;fals&#39;, wanted &#39;false&#39;&#34;</span>)
</span></span><span><span>40</span><span>    json<span>-&gt;</span><span>advance</span>(json);
</span></span><span><span>41</span><span>    <span>return</span> (<span>struct</span> json_value){.type <span>=</span> json_boolean,
</span></span><span><span>42</span><span>                               .value <span>=</span> {.boolean <span>=</span> <span>false</span>}};
</span></span><span><span>43</span><span>  <span>// ... strings ...
</span></span></span><span><span>44</span><span><span></span>  <span>default</span><span>:</span>
</span></span><span><span>45</span><span>    <span>printf</span>(<span>&#34;unknown character &#39;%c&#39; at pos %zu</span><span>\n</span><span>&#34;</span>, json<span>-&gt;</span><span>cur</span>(json), json<span>-&gt;</span>pos);
</span></span><span><span>46</span><span>    <span>ASSERT</span>(<span>false</span>, <span>&#34;unknown character&#34;</span>);
</span></span><span><span>47</span><span>    <span>return</span> (<span>struct</span> json_value){.type <span>=</span> json_null};
</span></span><span><span>48</span><span>  }
</span></span><span><span>49</span><span>}</span></span></code></pre></div><h4 id="strings">strings</h4><div id="callout"><h3>Info</h3><p>Again, similarly to JSON numbers, JSON strings should include escapes for
quotation marks and other fun stuff, but lets again just remember the projects
simplicity and my sanity, see <a href="https://xnacly.me/posts/2025/json-parser-in-c-with-methods/www.json.org/">json.org</a>.</p></div><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>static</span> <span>char</span> <span>*</span><span>string</span>(<span>struct</span> json <span>*</span>json) {
</span></span><span><span> 2</span><span>  json<span>-&gt;</span><span>advance</span>(json);
</span></span><span><span> 3</span><span>  <span>size_t</span> start <span>=</span> json<span>-&gt;</span>pos;
</span></span><span><span> 4</span><span>  <span>for</span> (<span>char</span> cc <span>=</span> json<span>-&gt;</span><span>cur</span>(json); cc <span>!=</span> <span>&#39;\n&#39;</span> <span>&amp;&amp;</span> cc <span>!=</span> <span>&#39;&#34;&#39;</span>;
</span></span><span><span> 5</span><span>       json<span>-&gt;</span><span>advance</span>(json), cc <span>=</span> json<span>-&gt;</span><span>cur</span>(json))
</span></span><span><span> 6</span><span>    ;
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span>  <span>char</span> <span>*</span>slice <span>=</span> <span>malloc</span>(<span>sizeof</span>(<span>char</span>) <span>*</span> json<span>-&gt;</span>pos <span>-</span> start <span>+</span> <span>1</span>);
</span></span><span><span> 9</span><span>  <span>ASSERT</span>(slice <span>!=</span> <span>NULL</span>, <span>&#34;failed to allocate slice for a string&#34;</span>)
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span>  <span>memcpy</span>(slice, json<span>-&gt;</span>input <span>+</span> start, json<span>-&gt;</span>pos <span>-</span> start);
</span></span><span><span>12</span><span>  slice[json<span>-&gt;</span>pos <span>-</span> start] <span>=</span> <span>0</span>;
</span></span><span><span>13</span><span>
</span></span><span><span>14</span><span>  <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;&#34;&#39;</span>, <span>&#34;unterminated string&#34;</span>);
</span></span><span><span>15</span><span>  json<span>-&gt;</span><span>advance</span>(json);
</span></span><span><span>16</span><span>  <span>return</span> slice;
</span></span><span><span>17</span><span>}</span></span></code></pre></div><p>Pretty easy stuff, as long as we are inside of the string (before <code>\&#34;</code>,<code>\n</code> and
<code>EOF</code>) we advance, after that we copy it into a new slice and return that slice
(this function is especially useful for object keys - that’s why it is a
function).</p><h3 id="parsing-arrays">Parsing Arrays</h3><p>Since arrays a any amount of JSON values between <code>[]</code> and separated via <code>,</code> -
this one is not that hard to implement too:</p><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>struct</span> json_value <span>array</span>(<span>struct</span> json <span>*</span>json) {
</span></span><span><span> 2</span><span>  <span>ASSERT</span>(json <span>!=</span> <span>NULL</span>, <span>&#34;corrupted internal state&#34;</span>);
</span></span><span><span> 3</span><span>  <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;[&#39;</span>, <span>&#34;invalid array start&#34;</span>);
</span></span><span><span> 4</span><span>  json<span>-&gt;</span><span>advance</span>(json);
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span>  <span>struct</span> json_value json_value <span>=</span> {.type <span>=</span> json_array};
</span></span><span><span> 7</span><span>  json_value.values <span>=</span> <span>malloc</span>(<span>sizeof</span>(<span>struct</span> json_value));
</span></span><span><span> 8</span><span>
</span></span><span><span> 9</span><span>  <span>while</span> (<span>!</span>json<span>-&gt;</span><span>is_eof</span>(json) <span>&amp;&amp;</span> json<span>-&gt;</span><span>cur</span>(json) <span>!=</span> <span>&#39;]&#39;</span>) {
</span></span><span><span>10</span><span>    <span>if</span> (json_value.length <span>&gt;</span> <span>0</span>) {
</span></span><span><span>11</span><span>      <span>if</span> (json<span>-&gt;</span><span>cur</span>(json) <span>!=</span> <span>&#39;,&#39;</span>) {
</span></span><span><span>12</span><span>        <span>json_free_value</span>(<span>&amp;</span>json_value);
</span></span><span><span>13</span><span>      }
</span></span><span><span>14</span><span>      <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;,&#39;</span>,
</span></span><span><span>15</span><span>             <span>&#34;expected , as the separator between array members&#34;</span>);
</span></span><span><span>16</span><span>      json<span>-&gt;</span><span>advance</span>(json);
</span></span><span><span>17</span><span>    }
</span></span><span><span>18</span><span>    <span>struct</span> json_value member <span>=</span> json<span>-&gt;</span><span>parse</span>(json);
</span></span><span><span>19</span><span>    json_value.values <span>=</span> <span>realloc</span>(json_value.values,
</span></span><span><span>20</span><span>                                <span>sizeof</span>(json_value) <span>*</span> (json_value.length <span>+</span> <span>1</span>));
</span></span><span><span>21</span><span>    json_value.values[json_value.length<span>++</span>] <span>=</span> member;
</span></span><span><span>22</span><span>  }
</span></span><span><span>23</span><span>
</span></span><span><span>24</span><span>  <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;]&#39;</span>, <span>&#34;missing array end&#34;</span>);
</span></span><span><span>25</span><span>  json<span>-&gt;</span><span>advance</span>(json);
</span></span><span><span>26</span><span>  <span>return</span> json_value;
</span></span><span><span>27</span><span>}</span></span></code></pre></div><p>We start with a array length of one and reallocate for every new child we find.
We also check for the <code>,</code> between each child.</p><blockquote><p>A growing array would probably be better to minimize allocations, but here we
are, writing unoptimized C code - still, it works :)</p></blockquote><h3 id="parsing-objects">Parsing Objects</h3><p><span>C</span></p><div><pre tabindex="0"><code data-lang="c"><span><span> 1</span><span><span>struct</span> json_value <span>object</span>(<span>struct</span> json <span>*</span>json) {
</span></span><span><span> 2</span><span>  <span>ASSERT</span>(json <span>!=</span> <span>NULL</span>, <span>&#34;corrupted internal state&#34;</span>);
</span></span><span><span> 3</span><span>  <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;{&#39;</span>, <span>&#34;invalid object start&#34;</span>);
</span></span><span><span> 4</span><span>  json<span>-&gt;</span><span>advance</span>(json);
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span>  <span>struct</span> json_value json_value <span>=</span> {.type <span>=</span> json_object};
</span></span><span><span> 7</span><span>  json_value.object_keys <span>=</span> <span>malloc</span>(<span>sizeof</span>(<span>char</span> <span>*</span>));
</span></span><span><span> 8</span><span>  json_value.values <span>=</span> <span>malloc</span>(<span>sizeof</span>(<span>struct</span> json_value));
</span></span><span><span> 9</span><span>
</span></span><span><span>10</span><span>  <span>while</span> (<span>!</span>json<span>-&gt;</span><span>is_eof</span>(json) <span>&amp;&amp;</span> json<span>-&gt;</span><span>cur</span>(json) <span>!=</span> <span>&#39;}&#39;</span>) {
</span></span><span><span>11</span><span>    <span>if</span> (json_value.length <span>&gt;</span> <span>0</span>) {
</span></span><span><span>12</span><span>      <span>if</span> (json<span>-&gt;</span><span>cur</span>(json) <span>!=</span> <span>&#39;,&#39;</span>) {
</span></span><span><span>13</span><span>        <span>json_free_value</span>(<span>&amp;</span>json_value);
</span></span><span><span>14</span><span>      }
</span></span><span><span>15</span><span>      <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;,&#39;</span>,
</span></span><span><span>16</span><span>             <span>&#34;expected , as separator between object key value pairs&#34;</span>);
</span></span><span><span>17</span><span>      json<span>-&gt;</span><span>advance</span>(json);
</span></span><span><span>18</span><span>    }
</span></span><span><span>19</span><span>    <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;&#34;&#39;</span>,
</span></span><span><span>20</span><span>           <span>&#34;expected a string as the object key, did not get that&#34;</span>)
</span></span><span><span>21</span><span>    <span>char</span> <span>*</span>key <span>=</span> <span>string</span>(json);
</span></span><span><span>22</span><span>    <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;:&#39;</span>, <span>&#34;expected object key and value separator&#34;</span>);
</span></span><span><span>23</span><span>    json<span>-&gt;</span><span>advance</span>(json);
</span></span><span><span>24</span><span>
</span></span><span><span>25</span><span>    <span>struct</span> json_value member <span>=</span> json<span>-&gt;</span><span>parse</span>(json);
</span></span><span><span>26</span><span>    json_value.values <span>=</span> <span>realloc</span>(json_value.values, <span>sizeof</span>(<span>struct</span> json_value) <span>*</span>
</span></span><span><span>27</span><span>                                                       (json_value.length <span>+</span> <span>1</span>));
</span></span><span><span>28</span><span>    json_value.values[json_value.length] <span>=</span> member;
</span></span><span><span>29</span><span>    json_value.object_keys <span>=</span> <span>realloc</span>(json_value.object_keys,
</span></span><span><span>30</span><span>                                     <span>sizeof</span>(<span>char</span> <span>**</span>) <span>*</span> (json_value.length <span>+</span> <span>1</span>));
</span></span><span><span>31</span><span>    json_value.object_keys[json_value.length] <span>=</span> key;
</span></span><span><span>32</span><span>    json_value.length<span>++</span>;
</span></span><span><span>33</span><span>  }
</span></span><span><span>34</span><span>
</span></span><span><span>35</span><span>  <span>ASSERT</span>(json<span>-&gt;</span><span>cur</span>(json) <span>==</span> <span>&#39;}&#39;</span>, <span>&#34;missing object end&#34;</span>);
</span></span><span><span>36</span><span>  json<span>-&gt;</span><span>advance</span>(json);
</span></span><span><span>37</span><span>  <span>return</span> json_value;
</span></span><span><span>38</span><span>}</span></span></code></pre></div><p>Same as arrays, only instead of a single atom we have a string as the key, <code>:</code>
as a separator and a <code>json_value</code> as the value. Each pair is separated with
<code>,</code>.</p></div></div>
  </body>
</html>
