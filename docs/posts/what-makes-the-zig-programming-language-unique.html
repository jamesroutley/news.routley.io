<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikexplores.substack.com/p/what-makes-the-zig-programming-language">Original</a>
    <h1>What Makes the Zig Programming Language Unique?</h1>
    
    <div id="readability-page-1" class="page"><div><div dir="auto"><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F63aab9a7-3856-46dd-9a1a-97a3cfc2685b_1024x1024.png" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F63aab9a7-3856-46dd-9a1a-97a3cfc2685b_1024x1024.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F63aab9a7-3856-46dd-9a1a-97a3cfc2685b_1024x1024.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F63aab9a7-3856-46dd-9a1a-97a3cfc2685b_1024x1024.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F63aab9a7-3856-46dd-9a1a-97a3cfc2685b_1024x1024.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F63aab9a7-3856-46dd-9a1a-97a3cfc2685b_1024x1024.png" width="1024" height="1024" data-attrs="{&#34;src&#34;:&#34;https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/63aab9a7-3856-46dd-9a1a-97a3cfc2685b_1024x1024.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:1024,&#34;width&#34;:1024,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:null,&#34;alt&#34;:&#34;Zig mascot Zero the Ziguana&#34;,&#34;title&#34;:null,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:false,&#34;internalRedirect&#34;:null}" alt="Zig mascot Zero the Ziguana" title="Zig mascot Zero the Ziguana" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F63aab9a7-3856-46dd-9a1a-97a3cfc2685b_1024x1024.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F63aab9a7-3856-46dd-9a1a-97a3cfc2685b_1024x1024.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F63aab9a7-3856-46dd-9a1a-97a3cfc2685b_1024x1024.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F63aab9a7-3856-46dd-9a1a-97a3cfc2685b_1024x1024.png 1456w" sizes="100vw"/></picture></div></a><figcaption>Zig mascot Zero the Ziguana</figcaption></figure></div><p><span>Programming language experts told Andrew Kelley, the creator of the Zig programming language, that having code which could run at compile time was a really dumb idea. But he went ahead and implemented it anyway. Years later, this has proven to be one of the killer features of Zig. In the Zig world, we call it </span><code>comptime</code><span>, from the keyword used to mark code required to run at compile time or variables to be known at compile time.</span></p><p>The ability to run Zig code during compilation allows Zig developers to write generic code and do meta programming without having any explicit support for generics or templates.</p><p><span>Let me walk you through some code examples to better explain what the whole idea is and why it matters. Consider the following simple function to find the maximum of two values </span><code>a</code><span> and </span><code>b</code><span>. Without generics or </span><code>comptime</code><span>code, we would need to hardwire such a function to operate on a specific variable types, such as 32-bit integers referred to as </span><code>i32</code><span> in Zig.</span></p><pre><code><code>fn maximum(a: i32, b: i32) i32 {
    var result: i32 = undefined;

    if (a &gt; b) {
        result = a;
    } else {
        result = b;
    }

    return result;
}
</code></code></pre><p><span>Usually, an executable program in Zig, will have a </span><code>main</code><span> function, just like a C/C++ program. From there we can invoke our </span><code>maximum</code><span> function. In the next code example, don&#39;t pay too much attention to how we grab </span><code>stdout</code><span> or why we need to prefix our </span><code>print</code><span> function call with the </span><code>try</code><span> keyword. The latter has to do with Zig error handling, which we will not cover in this story.</span></p><pre><code><code>pub fn main() !void {
    const stdout = std.io.getStdOut().writer();

    const a = 10;
    const b = 5;

    const biggest = maximum(a, b);

    try stdout.print(&#34;Max of {} and {} is {}\n&#34;, .{ a, b, biggest });
}
</code></code></pre><p><span>Obviously, the solution given is quite limiting. </span><code>maximum</code><span> only operates on 32-bit integers. C programmers would be very familiar with this issue. In the C programmer world, C preprocessor macros come to the rescue. However, Andrew Kelley, designed Zig specifically to not have to rely on C-style macros. In fact, the whole reason Zig exists is that Andrew just wanted to program in C, but without the bad parts such as macros. </span><code>comptime</code><span> sprung into existence precisely to replace C-macros.</span></p><p><span>Let us look at a Zig solution to this problem. We will define a generic </span><code>maxiumum</code><span> function in Zig. The </span><code>i32</code><span> type arguments will be replaced by </span><code>anytype</code><span> and </span><code>@TypeOf(a)</code><span>. At the spot the </span><code>maximum</code><span> function gets invoked, </span><code>anytype</code><span> will assume the type of the argument provided. Keep in mind that we are not dealing with a dynamic programming language. Instead, Zig will compile different variants of </span><code>maximum</code><span> for each case, where </span><code>maximum</code><span> is called with a different set of argument types. The type of </span><code>a</code><span> and </span><code>b</code><span> is still determined at compilation time rather than at runtime.</span></p><p><span>While it is possible to determine the type of an input argument at compile time, doing so for a variable or return type is trickier. You cannot state that the return type is </span><code>anytype</code><span> because the specific type cannot be determined at the call site. Instead, we use a compiler intrinsic, </span><code>@TypeOf</code><span> which runs at compile time to produce the return type. </span><code>@TypeOf(a)</code><span> evaluates to type of the </span><code>a</code><span> parameter at compilation time. We use the same trick to specify the type of the </span><code>result</code><span> variable.</span></p><pre><code><code>fn maximum(a: anytype, b: anytype) @TypeOf(a) {
    var result: @TypeOf(a) = undefined;

    if (a &gt; b) {
        result = a;
    } else {
        result = b;
    }

    return result;
}
</code></code></pre><p>While this solution is an improvement, it has a number of issues:</p><ol><li><p><span>Nothing stops you from calling </span><code>maximum</code><span> with values which are not numbers.</span></p></li><li><p><span>If </span><code>b</code><span> is the larger value, it could contain a value which requires more bits than type </span><code>@TypeOf(a)</code><span> can hold.</span></p></li></ol><p><span>To check if </span><code>a</code><span> and </span><code>b</code><span> are of the right type, we can create a function to be run at compile time which checks if a type is a number. Let us define a function </span><code>assertNumber</code><span> with a single parameter </span><code>T</code><span> representing a type rather than a value. The parameter definition is preceded with the keyword </span><code>comptime</code><span>telling the compiler that the argument </span><em>must be known</em><span> at compile time.</span></p><p><span>Also notice the switch-case statement. In Zig, switch-case can return values. We switch on the type argument </span><code>T</code><span>. If </span><code>T</code><span> matches a number type, the switch-case statement returns </span><code>true</code><span> which gets assigned to the </span><code>is_num</code><span>variable. Otherwise, we use the </span><code>else</code><span> keyword to return </span><code>false</code><span> by default.</span></p><pre><code><code>fn assertNumber(comptime T: type) void {
    const is_num = switch (T) {
        i8, i16, i32, i64 =&gt; true,
        u8, u16, u32, u64 =&gt; true,
        comptime_int, comptime_float =&gt; true,
        f16, f32, f64 =&gt; true,
        else =&gt; false,
    };

    if (!is_num) {
        @compileError(&#34;Inputs must be numbers&#34;);
    }
}

// testing function
pub fn main() !void {
    assertNumber(bool);
}
</code></code></pre><p><span>Of particular interest in this function definition is the compiler intrinsic </span><code>@compileError</code><span>. It is used to send compiler errors to the user. In this code example, I am providing a non-number type as argument to</span><code>assertNumber</code><span>. </span><code>bool</code><span> to be specific. Should you try to compile this program, you will get the following error messages:</span></p><pre><code><code>assert-number.zig:11:9: error: Inputs must be numbers
        @compileError(&#34;Inputs must be numbers&#34;);
        ^
assert-number.zig:17:17: note: called from here
    assertNumber(bool);
                ^
assert-number.zig:16:21: note: called from here
pub fn main() !void {
</code></code></pre><p>In other words, we can write code in such a way that we can give a helpful error message to the user when they try to compile invalid code.</p><p><span>We can use </span><code>assertNumber</code><span> to check the inputs to our </span><code>maximum</code><span> function. To make sure the return type is large enough, we will require that both inputs are of the same type.</span></p><pre><code><code>fn maximum(a: anytype, b: anytype) @TypeOf(a) {
    const A = @TypeOf(a);
    const B = @TypeOf(b);

    assertNumber(A);
    assertNumber(B);

    var result: @TypeOf(a) = undefined;

    if (A != B) {
        @compileError(&#34;Inputs must be of the same type&#34;);
    }

    if (a &gt; b) {
        result = a;
    } else {
        result = b;
    }

    return result;
}
</code></code></pre><p><span>When </span><code>maximum</code><span> is invoked at runtime, all the compile time code has already been run and replaced with their result.</span></p><p><span>The current solution doesn&#39;t solve all problems with our initial naive solution. We are forced to make </span><code>a</code><span> and </span><code>b</code><span> parameters of the same type. What if we want to allow both a signed 8-bit and signed 32-bit integer argument? In Zig, that would be arguments of type </span><code>i8</code><span> and </span><code>i32</code><span>. In this case we must ensure that the return type is </span><code>i32</code><span>. Our current solution doesn&#39;t do that. What we need is a function that runs at compile time comparing the types of </span><code>a</code><span> and </span><code>b</code><span> and which returns the type with the highest bit-length.</span></p><p>To achieve this, we will make a number of functions:</p><ul><li><p><code>nbits</code><span> function to figure out the number of bits in a type </span><code>T</code></p></li><li><p><code>largestType</code><span> function to pick largest of two types </span><code>A</code><span> and </span><code>B</code></p></li></ul><p><span>Notice in the next code example how we are marking the type arguments with </span><code>comptime</code><span> to tell Zig that these inputs must be known at compilation time. We use the </span><code>@typeInfo</code><span> compiler intrinsic which at compile-time returns a composite object, </span><code>info</code><span>, which describe a type: Is the type signed or unsigned? How many bits are used to represent the type?</span></p><pre><code><code>fn nbits(comptime T: type) i8 {
    return switch (@typeInfo(T)) {
        .Float =&gt; |info| info.bits,
        .Int =&gt; |info| info.bits,
        else =&gt; 64,
    };
}

fn largestType(comptime A: type, comptime B: type) type {
    if (nbits(A) &gt; nbits(B)) {
        return A;
    } else {
        return B;
    }
}

fn maximum(a: anytype, b: anytype) largestType(@TypeOf(a),
                                               @TypeOf(b)) {
    var result: @TypeOf(a) = undefined;

    if (a &gt; b) {
        result = a;
    } else {
        result = b;
    }

    return result;
}
</code></code></pre><p><span>The switch-statement in the code example above may not be entirely obvious. Let me clarify. The type returned from </span><code>@typeInfo(T)</code><span> is of type </span><code>std.builtin.TypeInfo</code><span> which is a </span><em>union type</em><span>. Union types are a bit like structs. They have multiple fields, but these fields share memory. Hence, we need to figure out which field is actually in use. The switch-case allows us to determine whether a </span><code>.Int</code><span> or </span><code>.Float</code><span> field is currently used. The </span><code>|info|</code><span>syntax is used by Zig to unwrap values. In this case we are unwrapping the struct describing a type.</span></p><p><span>The </span><code>info</code><span> object will be either of type </span><code>TypeInfo.Int</code><span> or </span><code>TypeInfo.Float</code><span>, however, both </span><code>struct</code><span> types have a </span><code>bits</code><span> field.</span></p><p><span>In our revised </span><code>maximum</code><span> function, we don&#39;t specify the return value explicitly. Instead, we call the </span><code>largestType</code><span> function which returns the type we want to use as return-type for </span><code>maximum</code><span>. I know this sounds really funky, but it works because the Zig compiler can determine that the </span><code>largestType</code><span>function call only relies on info known at compile time. The compiler will make multiple variants of </span><code>maximum</code><span> based on each place it is invoked. Each version will be compiled with different input and output types.</span></p><p><span>To demonstrate how powerful Zig </span><code>comptime</code><span> is, I will show you how it can be used to implement generics. Here we implement a </span><code>minimum</code><span> function which looks more familiar to developers accustomed to generics or template-based programming. A key difference is that the type argument </span><code>T</code><span> is provided as a regular argument. C++, Java and C# developers would invoke this function by writing something like </span><code>minimum&lt;i8&gt;(x, y)</code><span>, while Zig developers write </span><code>minimum(i8, x, y)</code><span>.</span></p><pre><code><code>fn minimum(comptime T: type, a: T, b: T) T {
    assertNumber(T);

    var result: T = undefined;
    if (a &lt; b) {
        result = a;
    } else {
        result = b;
    }

    return result;
} 
</code></code></pre><p><span>In languages such as C++, Java, C++ and Swift you can usually infer the type by looking at input arguments. With Zig, such type inference isn&#39;t possible because the parameter </span><code>T</code><span> is supplied as a regular argument and thus cannot get special treatment. While this limitation is a downside to </span><code>comptime</code><span> over generics, the benefit is that </span><code>comptime</code><span> is more flexible in how you use it.</span></p><p><span>We can use </span><code>comptime</code><span> code to define generic types. I will demonstrate with a simple 2D vector class used to represent stuff like force, velocity, or position.</span></p></div></div></div>
  </body>
</html>
