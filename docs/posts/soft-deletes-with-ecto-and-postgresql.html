<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dashbit.co/blog/soft-deletes-with-ecto">Original</a>
    <h1>Soft Deletes with Ecto and PostgreSQL</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    
<ul>
  <li>
    <i></i> José Valim
  </li>
  <li>
    <i></i> August 13th, 2024
  </li>
  <li>
    <i></i><a href="https://dashbit.co/blog/tags/ecto">ecto</a>, <a href="https://dashbit.co/blog/tags/postgres">postgres</a>, <a href="https://dashbit.co/blog/tags/soft%20deletes">soft deletes</a>
  </li>
</ul>
<p>
One of our clients at Dashbit has recently asked us what is the best way to implement
soft-deletes with Ecto.</p>
<p>
The idea of a soft-delete is that, when you choose to “delete” a given resource, let’s
call it “orders”, instead of effectively deleting it from the database, you will mark
the order as deleted, and then you simply do not show such orders to the user.</p>
<p>
There are several ways to implement such a feature. If you need it only for one resource
or another, sometimes the best option is to handle it at the application level. The
downsides of doing it at the application level is that you are responsible to make sure
they are never deleted, which can be error prone, especially once you consider foreign
keys cascade and deletion rules. Plus, on every query you perform, you must remember to
filter it only to non-“soft-deleted” resources.</p>
<p>
Therefore, if soft deletion plays an important role in your application and applies to
several resources, then enforcing it at the database level can be much more robust, as
you guarantee no one can accidentally remove this data unintentionally.</p>
<p>
This article is an adaption of <a href="https://evilmartians.com/chronicles/soft-deletion-with-postgresql-but-with-logic-on-the-database">“Soft deletion with PostgreSQL: but with logic on the
database!”</a>,
but focused on <a href="https://github.com/elixir-ecto/ecto">Ecto</a>.</p>
<h2>
Using PostgreSQL rules</h2>
<p>
In order to add soft-deletion to a resource, the first step is to add a <code>deleted_at</code>
column to its table. In this case, we are choosing a timestamp column, but a boolean
<code>deleted</code> column would suffice too:</p>
<pre><code><span>add</span><span> </span><span>:deleted_at</span><span>,</span><span> </span><span>:utc_datetime</span></code></pre>
<p>
Still in the migration, let’s add <a href="https://www.postgresql.org/docs/current/rules.html">PostgreSQL Rule</a>,
that converts deletes into updates:</p>
<pre><code><span>execute</span><span> </span><span>&#34;&#34;&#34;
        CREATE OR REPLACE RULE soft_deletion AS ON DELETE TO orders
        DO INSTEAD UPDATE orders SET deleted_at = NOW() WHERE id = OLD.id AND deleted_at IS NULL RETURNING OLD.*;
        &#34;&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;&#34;&#34;
        DROP RULE IF EXISTS soft_deletion ON orders;
        &#34;&#34;&#34;</span></code></pre>
<p>
When migrating, we create a <code>soft_deletion</code> rule on the orders table that effectively replaces
the deletion by an update statement that sets the <code>deleted_at</code> column. Notice the statement
also uses <code>RETURNING OLD.*</code>, this is necessary if you have any <code>:read_after_writes</code> field in
your schema.</p>
<h2>
Using PostgreSQL views</h2>
<p>
By using a rule, we guarantee that no one can accidentally delete this resource, even if
they are connected to the database terminal (we will see some explicit ways to bypass it though).</p>
<p>
However, this still leaves one problem: whenever you ask <code>Ecto</code> to read all orders, such as
<code>Repo.all(Order)</code>, it will include deleted orders by default. Therefore you, the application
developer, must remember to filter them.</p>
<p>
Luckily, we can solve this problem by adding two lines to our migration:</p>
<pre><code><span>execute</span><span> </span><span>&#34;CREATE OR REPLACE VIEW visible_orders AS SELECT * FROM orders WHERE deleted_at IS NULL&#34;</span><span>,</span><span>
        </span><span>&#34;DROP VIEW IF EXISTS visible_orders&#34;</span></code></pre>
<p>
The example above creates a new view, called “visible_orders”, which only contains the visible
orders. Now you only need to change your <code>Ecto</code> schema to use this new view:</p>
<pre><code><span>defmodule</span><span> </span><span>MyApp.Order</span><span> </span><span data-group-id="5281335822-1">do</span><span>
  </span><span>use</span><span> </span><span>Ecto.Schema</span><span>

  </span><span>schema</span><span> </span><span>&#34;visible_orders&#34;</span><span> </span><span data-group-id="5281335822-2">do</span><span>
    </span><span>...</span><span>
    </span><span>field</span><span> </span><span>:deleted_at</span><span>,</span><span> </span><span>:utc_datetime</span><span>
    </span><span>timestamps</span><span data-group-id="5281335822-3">(</span><span data-group-id="5281335822-3">)</span><span>
  </span><span data-group-id="5281335822-2">end</span><span>
</span><span data-group-id="5281335822-1">end</span></code></pre>
<p>
This brings two benefits. First, <code>Repo.all(MyApp.Order)</code> now only returns visible
orders. Furthermore, because Ecto treats tables (sources) and schemas as distinct
entities, if you want to query all orders, including deleted ones, you can simply
write: <code>Repo.all({&#34;orders&#34;, MyApp.Order})</code>. Or in a query:</p>
<pre><code><span>from</span><span> </span><span>o</span><span> </span><span>in</span><span> </span><span data-group-id="4631603608-1">{</span><span>&#34;orders&#34;</span><span>,</span><span> </span><span>MyApp.Order</span><span data-group-id="4631603608-1">}</span><span>,</span><span>
  </span><span>join</span><span>:</span><span> </span><span>u</span><span> </span><span>in</span><span> </span><span>assoc</span><span data-group-id="4631603608-2">(</span><span>o</span><span>,</span><span> </span><span>:users</span><span data-group-id="4631603608-2">)</span><span>,</span><span>
  </span><span>where</span><span>:</span><span> </span><span>o</span><span>.</span><span>total</span><span> </span><span>&gt;=</span><span> </span><span>^</span><span>min_value</span><span>,</span><span>
  </span><span>...</span></code></pre>
<p>
Any query you execute in this style still has all of the type casting and SQL
injection protections you are familiar with, but now applied to different
views/tables.</p>
<h2>
The caveats</h2>
<p>
There are two caveats in this approach. The first one is that, if you attempt
to delete an order, <code>Ecto</code> won’t be happy with it:</p>
<pre><code><span>Repo</span><span>.</span><span>delete</span><span data-group-id="4629907199-1">(</span><span>order</span><span data-group-id="4629907199-1">)</span></code></pre>
<p>
This raises <code>Ecto.StaleEntryError</code> by default. This happens because, since the
deletion does not happen, PostgreSQL returns the information that zero rows
were affected. In turn, Ecto parses this result set to mean that the record
no longer exists (and therefore it is stale). This is clearly spelled out in
the error message and, from Ecto v3.12, you can opt-in and say that stale
entries are expected:</p>
<pre><code><span>Repo</span><span>.</span><span>delete</span><span data-group-id="4444342787-1">(</span><span>order</span><span>,</span><span> </span><span>allow_stale</span><span>:</span><span> </span><span>true</span><span data-group-id="4444342787-1">)</span></code></pre>
<p>
Similarly, if you attempt to use <code>Repo.delete_all(from o in Order)</code>, Ecto will always report
that zero rows were affected. In case you do need to know the number of rows
affected, you can use <code>Repo.update_all</code> and manually set its <code>deleted_at</code>
column instead.</p>
<p>
The other caveat is that, if you want any cascading foreign key to delete
this resource, you need to adapt your rule accordingly. This is <a href="https://evilmartians.com/chronicles/soft-deletion-with-postgresql-but-with-logic-on-the-database#cascade-deletes">covered in
the original article</a>,
so check it out.</p>
<h2>
Making deletions possible</h2>
<p>
Before we wrap this up, there is one last question to answer: what happens
when you want/need to effectively delete the data?</p>
<p>
Luckily, PostgreSQL has a mechanism to enable and disable rules, which you
can also use from within a transaction:</p>
<pre><code><span>Repo</span><span>.</span><span>transaction</span><span data-group-id="4773406997-1">(</span><span data-group-id="4773406997-2">fn</span><span> </span><span>-&gt;</span><span>
  </span><span>Repo</span><span>.</span><span>query!</span><span data-group-id="4773406997-3">(</span><span>&#34;ALTER TABLE orders DISABLE RULE soft_deletion&#34;</span><span data-group-id="4773406997-3">)</span><span>
  </span><span>Repo</span><span>.</span><span>delete!</span><span data-group-id="4773406997-4">(</span><span>order</span><span data-group-id="4773406997-4">)</span><span>
  </span><span>Repo</span><span>.</span><span>query!</span><span data-group-id="4773406997-5">(</span><span>&#34;ALTER TABLE orders ENABLE RULE soft_deletion&#34;</span><span data-group-id="4773406997-5">)</span><span>
</span><span data-group-id="4773406997-2">end</span><span data-group-id="4773406997-1">)</span></code></pre>
<p>
In fact, you could even encapsulate this by adding a function to your <code>Ecto.Repo</code> module:</p>
<pre><code><span>defmodule</span><span> </span><span>MyApp.Repo</span><span> </span><span data-group-id="4406443129-1">do</span><span>
  </span><span>use</span><span> </span><span>Ecto.Repo</span><span>,</span><span> </span><span>otp_app</span><span>:</span><span> </span><span>:myapp</span><span>

  </span><span>def</span><span> </span><span>disable_soft_deletion</span><span data-group-id="4406443129-2">(</span><span>tables</span><span>,</span><span> </span><span>fun</span><span data-group-id="4406443129-2">)</span><span> </span><span data-group-id="4406443129-3">do</span><span>
    </span><span>transaction</span><span data-group-id="4406443129-4">(</span><span data-group-id="4406443129-5">fn</span><span> </span><span>-&gt;</span><span>
      </span><span>for</span><span> </span><span>table</span><span> </span><span>&lt;-</span><span> </span><span>tables</span><span> </span><span data-group-id="4406443129-6">do</span><span>
        </span><span>query!</span><span data-group-id="4406443129-7">(</span><span>&#34;ALTER TABLE </span><span data-group-id="4406443129-8">#{</span><span>quote_table</span><span data-group-id="4406443129-9">(</span><span>table</span><span data-group-id="4406443129-9">)</span><span data-group-id="4406443129-8">}</span><span> DISABLE RULE soft_deletion&#34;</span><span data-group-id="4406443129-7">)</span><span>
      </span><span data-group-id="4406443129-6">end</span><span>
  
      </span><span>try</span><span> </span><span data-group-id="4406443129-10">do</span><span>
        </span><span>fun</span><span>.</span><span data-group-id="4406443129-11">(</span><span data-group-id="4406443129-11">)</span><span>
      </span><span data-group-id="4406443129-10">after</span><span>
        </span><span>for</span><span> </span><span>table</span><span> </span><span>&lt;-</span><span> </span><span>tables</span><span> </span><span data-group-id="4406443129-12">do</span><span>
          </span><span>query!</span><span data-group-id="4406443129-13">(</span><span>&#34;ALTER TABLE </span><span data-group-id="4406443129-14">#{</span><span>quote_table</span><span data-group-id="4406443129-15">(</span><span>table</span><span data-group-id="4406443129-15">)</span><span data-group-id="4406443129-14">}</span><span> ENABLE RULE soft_deletion&#34;</span><span data-group-id="4406443129-13">)</span><span>
        </span><span data-group-id="4406443129-12">end</span><span>
      </span><span data-group-id="4406443129-10">end</span><span>
    </span><span data-group-id="4406443129-5">end</span><span data-group-id="4406443129-4">)</span><span>
  </span><span data-group-id="4406443129-3">end</span><span>
  
  </span><span>defp</span><span> </span><span>quote_table</span><span data-group-id="4406443129-16">(</span><span>name</span><span data-group-id="4406443129-16">)</span><span> </span><span>when</span><span> </span><span>is_binary</span><span data-group-id="4406443129-17">(</span><span>name</span><span data-group-id="4406443129-17">)</span><span> </span><span data-group-id="4406443129-18">do</span><span>
    </span><span>if</span><span> </span><span>String</span><span>.</span><span>contains?</span><span data-group-id="4406443129-19">(</span><span>name</span><span>,</span><span> </span><span>&#34;</span><span>\&#34;</span><span>&#34;</span><span data-group-id="4406443129-19">)</span><span> </span><span data-group-id="4406443129-20">do</span><span>
      </span><span>raise</span><span> </span><span>&#34;invalid table name&#34;</span><span>
    </span><span data-group-id="4406443129-20">end</span><span>
  
    </span><span data-group-id="4406443129-21">[</span><span>?&#34;</span><span>,</span><span> </span><span>name</span><span>,</span><span> </span><span>?&#34;</span><span data-group-id="4406443129-21">]</span><span>
  </span><span data-group-id="4406443129-18">end</span><span>
</span><span data-group-id="4406443129-1">end</span></code></pre>
<p>
And now:</p>
<pre><code><span>Repo</span><span>.</span><span>disable_soft_deletion</span><span data-group-id="6863873518-1">(</span><span data-group-id="6863873518-2">[</span><span>&#34;orders&#34;</span><span data-group-id="6863873518-2">]</span><span>,</span><span> </span><span data-group-id="6863873518-3">fn</span><span> </span><span>-&gt;</span><span>
  </span><span>Repo</span><span>.</span><span>delete!</span><span data-group-id="6863873518-4">(</span><span>order</span><span data-group-id="6863873518-4">)</span><span>
</span><span data-group-id="6863873518-3">end</span><span data-group-id="6863873518-1">)</span></code></pre>
<h2>
Wrapping up</h2>
<p>
This article showed how to achieve soft deletions in Ecto and PostgreSQL
by using rules and views. Not only that, we learned how Ecto allows us to
apply the same schema to different tables and views, and how it deals
with stale records on <code>delete</code> (which also applies to <code>update</code>).</p>
<p>
The technique shown here is useful when you want to keep deleted in the
same table (and therefore with the same constraints and foreign keys) as
regular data, often for historical reasons. But your application may have
different needs. For example, if you want to implement some sort of trash
bin, that stores all types of deleted resources in your application, the approach
here would require you to query several tables to get all deleted entries.
In such cases, a better solution is to <a href="https://brandur.org/fragments/deleted-record-insert">use triggers to copy a JSON
representation of the deleted data to another table</a>.
Triggers could also be effective if all you need is a generic log of
deleted entries. Your mileage may vary.</p>
<p>
Happy coding!</p>

  </article>
</div></div>
  </body>
</html>
