<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.b-list.org/weblog/2022/dec/19/boring-python-code-quality/">Original</a>
    <h1>Boring Python: Code quality</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
    <!-- These classes are used by the Bootstrap CSS framework to control layout. -->
    <div>
      




<!--
 If this entry is assigned to one or more categories, they'll appear
 in links in the paragraph below. Each of those links uses
 rel="category" to indicate it's a link to a category.

 See http://microformats.org/wiki/rel-category for details.
-->
<p>Published: <a href="https://www.b-list.org/weblog/2022/dec/19/">December 19, 2022</a>. Filed under:
<a rel="category" href="https://www.b-list.org/weblog/categories/django/">Django</a>, <a rel="category" href="https://www.b-list.org/weblog/categories/python/">Python</a>.
  
</p><p>This is the second in a series of posts I intend to write about how to build, deploy, and manage Python applications in as boring a way as possible. In <a href="https://www.b-list.org/weblog/2022/may/13/boring-python-dependencies/">the first post in the series</a> I gave a definition of what I mean by “boring”, and it’s worth revisiting:</p>
<blockquote>
<p>I don’t mean “reliable” or “bug-free” or “no incidents”. While there is some overlap, and some of the things I’ll be recommending can help to reduce bugs, I also want to be clear: there will be bugs. There will be incidents where a feature or maybe an entire service is down. “Boring”, to me, is about the sources of those incidents.</p>
</blockquote>
<p>In the first post I talked about dependency management, and laid out an approach to it designed to ensure (as much as possible) it doesn’t become a source of unexpected bugs. Today I want to talk about what’s generally called “code quality” — tools to help you identify potential bugs, and other problems, as early as possible, ideally before they ever get merged into your codebase, let alone deployed to production).</p>
<p>But a quick reminder before we go much further: I’m writing from the perspective of someone who primarily uses Python as a backend language for web applications and other networked services. That’s what I know best, and there will be a strong web-oriented flavor to this post. If you use Python for something else, hopefully there will still be some useful takeaways from this post, but I can’t promise everything here will be relevant to you.</p>
<p>This also is not a “list all the tools and let you make up your mind” post — there are plenty of those out there. This is an opinionated set of things I personally recommend, along with explanations of why I recommend them. If you don’t like my recommendations, there are other ways to achieve a lot of the goals I’ve set out here, and I encourage you to look into them.</p>
<p>Finally, if you’re just interested in the end result, scroll down to the section titled “putting it all together”. It’s a pretty simple setup once everything’s been introduced, but introducing the tools and techniques, and why I recommend them, takes a lot more words.</p>
<h2>The basics</h2>
<p>Before I mention anything else, I have to start with the absolute basics: version control, tests, continuous integration (<span>CI</span>). If you don’t have these, there is nothing I can recommend that will have a larger impact than adding them. Without version control you don’t have a way to track what’s changed in your code over time; without tests you don’t have a way to know whether your code works; without <span>CI</span> you don’t have a way to <em>automatically</em> find out when your code has been broken by recent changes. All of these are huge.</p>
<p>For version control: probably just use git like everyone else.</p>
<p>For testing: pick either <a href="https://docs.python.org/3/library/unittest.html">the <code>unittest</code> module in the standard library</a>, or <a href="https://docs.pytest.org/">the third-party <code>pytest</code> test framework</a>. I have a preference for <code>unittest</code>, and if you’re doing Django its built-in testing tools are all built around <code>unittest</code>, but <code>pytest</code> has plenty of fans and there are <a href="https://pypi.org/project/pytest-django/">third-party plugins</a> to re-create some of the nice Django testing tools on top of <code>pytest</code>.</p>
<p>For <span>CI</span>: I’ve used a lot of different <span>CI</span> systems over the years, and they all had things I liked and things I disliked. So I won’t recommend any particular <span>CI</span> tool other than to say that it’s better to have <em>any</em> <span>CI</span> than to wait around to find the <em>perfect</em> <span>CI</span>, and so if you’re having trouble deciding it’s probably best to just stop worrying and go with whatever’s built in to your code hosting platform (GitHub Actions, GitLab <span>CI</span>, etc.).</p>
<p>There also are tools in the Python ecosystem that will help you organize and orchestrate automated checks for both local and <span>CI</span> use. Historically, this is the spot where I would have mentioned and recommended <code>tox</code>, but at the moment I’m exploring alternatives to it, such as <a href="https://nox.thea.codes/">nox</a>, and as a result I don’t currently have a specific recommendation for such a tool. I’ll update this post if that changes.</p>
<h2>On coverage</h2>
<p>Test coverage — automatically measuring which, and what percentage, of lines of code in your actual codebase (your application, or library, or whatever it is you’re building) get executed during your test runs — is a controversial topic. The short summary is:</p>
<ul>
<li><em>In favor:</em> Coverage measurement points out parts of your codebase that aren’t being tested, and if you know everything in your codebase gets executed during test runs, you should have confidence that the code does what it’s supposed to.</li>
<li><em>Against:</em> Coverage measurements are too easy to “game” — you can get to 100% coverage without <em>meaningfully</em> testing all or even most of your code, and so it’s yet another example of <a href="https://en.wikipedia.org/wiki/Goodhart%27s_law">Goodhart’s Law</a> (“When a measure becomes a target, it ceases to be a good measure”).</li>
</ul>
<p>Personally, I don’t think 100% coverage as a <em>target</em> is a good idea, but I still think you should be measuring and reporting coverage during your test runs. Instead of treating it as a target, I like to treat it as a warning: I want to know if my coverage suddenly <em>drops</em>, because that’s likely a sign something else has gone wrong in either the main codebase or the test suite.</p>
<p>For Python testing, <a href="https://coverage.readthedocs.io/en/latest/">the <code>coverage</code> module</a> lets you gather and report coverage metrics. There’s also <a href="https://pypi.org/project/pytest-cov/">a plugin for <code>pytest</code></a>.</p>
<h2>Non-Python-specific tools</h2>
<p>Next, there are a few things that aren’t specifically tied to Python or any other programming language, but are still extremely useful to have.</p>
<p>The first is the ignore file for your version control system. This file is called <code>.gitignore</code> if you’re using git, <code>.hgignore</code> if you’re using Mercurial, and other names for other version control tools — look up the right one for the tool you use.</p>
<p>GitHub maintains <a href="https://github.com/github/gitignore/blob/main/Python.gitignore">a good starter <code>.gitignore</code> for Python</a> that you can just copy and use, and it will keep you from accidentally committing a lot of things that you probably didn’t want to commit, like the cache directories used by a lot of common Python tools and processes.</p>
<p>If your project builds a Docker container, also create a <code>.dockerignore</code> file to specify files and directories that should be excluded from the container.</p>
<p>The next tool is <a href="https://editorconfig.org">EditorConfig</a> — this is set up by creating a file named <code>.editorconfig</code> in the root of your repository, which can be used to tell lots of different popular IDEs/text editors some basics about how to work with your project. For example, you can use the <code>.editorconfig</code> to specify whether you want files indented with spaces or with tabs (on a per-language basis), how much indentation should be used at each level, what newline style to use, and a lot more. I usually start with a copy of <a href="https://github.com/django/django/blob/main/.editorconfig">Django’s <code>.editorconfig</code> file</a> and remove the bits I don’t need. I strongly recommend doing this, since adding the <code>.editorconfig</code> file to your project will avoid at least <em>some</em> manual configuration of IDEs/editors and get a bit of automatic consistency across everyone who works on your project, even if they don’t use the same <span>IDE</span>/editor you do.</p>
<p>One final language-agnostic tool that’s good to set up is <a href="https://pre-commit.com">pre-commit</a>, which — if you’re using <code>git</code> as your version-control system — makes it easy to plug in various checks to automatically run each time you try to make a commit, and which can either automatically fix problems for you, or just reject the commit and tell you what went wrong. Several important tools I’ll be recommending here have pre-commit hooks available, but to start with just set up a pre-commit config file and add a few of <a href="https://pre-commit.com/hooks.html">the built-in hooks</a>. I recommend using at least the following:</p>
<ul>
<li><code>check-added-large-files</code></li>
<li><code>check-ast</code></li>
<li><code>check-byte-order-marker</code></li>
<li><code>check-case-conflict</code></li>
<li><code>check-docstring-first</code></li>
<li><code>check-executables-have-shebangs</code></li>
<li><code>check-json</code></li>
<li><code>check-merge-conflict</code></li>
<li><code>check-toml</code></li>
<li><code>check-yaml</code></li>
<li><code>debug-statements</code></li>
<li><code>detect-aws-credentials</code></li>
<li><code>detect-private-key</code></li>
<li><code>end-of-file-fixer</code></li>
<li><code>requirements-txt-fixer</code></li>
<li><code>trailing-whitespace</code></li>
</ul>
<p>These will catch/fix a <em>lot</em> of common problems, from simple syntax errors all the way up to accidentally committing sensitive values.</p>
<p>For projects with multiple people working on them via a branching workflow, <code>no-commit-to-branch</code> is also useful — it lets you specify a list of branches that can’t be directly committed to (default set is <code>main</code> and <code>master</code>), so that people don’t accidentally commit locally to the primary branch of the repository instead of their own working branch. This hook regularly saves me from having to undo an accidental local commit to <code>main</code> because I forgot which branch I was on.</p>
<h2>Code style and formatting</h2>
<p>This may seem like a weird thing to treat as “quality”, but one of the most important factors in code quality, in my experience, is readability. You’re going to need to read your colleagues’ code, and they will need to read yours. You’ll also need to read your own code that you wrote months or years ago. And you should make that job easier through consistent style and formatting.</p>
<p>If you followed the advice in the last section, you’ve already got a head start on consistency of formatting from your <code>.editorconfig</code> and pre-commit hooks handling things like indenting, newline styles, and so on, but now it’s time to get into Python-specific formatting. I recommend using two tools together: <a href="https://black.readthedocs.io/">Black</a> and <a href="https://pycqa.github.io/isort/">isort</a>.</p>
<p>Black can fix up all sorts of Python syntax constructs into <a href="https://black.readthedocs.io/en/stable/the_black_code_style/current_style.html">a consistent style</a>. And the great thing about it is that it ends arguments about code formatting, because Black deliberately does not provide much ability to configure its style. It just is what it is. Meanwhile, isort will reformat blocks of Python <code>import</code> statements to follow a consistent style and to place them in a consistent order: standard-library imports first, then third-party modules, then your own code’s modules.</p>
<p>For configuration, the only option I recommend setting for Black is the target Python version, which should match the version of Python you intend to deploy on (for libraries that target multiple Python versions it’s more complex, but for an application you intend to deploy on your own servers, you should be using one Python version and targeting it). For isort, I recommend setting the “profile” option to <code>&#34;black&#34;</code> to tell isort to match Black’s preferences. If it has trouble recognizing which modules are part of your codebase and which aren’t, consider setting <code>known_first_party</code> and/or <code>known_third_party</code> to help it out.</p>
<p>In both cases, I recommend putting the configuration in a top-level <code>pyproject.toml</code> file in your repository. In the case of Black this is the <em>only</em> supported configuration file, and most other tools support using <code>pyproject.toml</code> as a centralized configuration file now — there’s only one I’m going to recommend (flake8) that doesn’t.</p>
<p>As far as <em>running</em> Black and isort, here’s a set of recommendations:</p>
<ul>
<li>Any editor/<span>IDE</span> that <em>can</em> set up to run Black and isort to reformat code automatically every time a file is saved <em>should</em> be set up to do that.</li>
<li>But just in case someone on your team doesn’t do this, set up the pre-commit hooks for both Black and isort; these will automatically reformat files at commit time.</li>
<li>In <span>CI</span>, Black and isort should both run, but <em>not</em> reformat code; both tools support a mode where they’ll just exit non-zero and print out the things that need reformatting, and that’s what you should use here.</li>
</ul>
<p>This can’t fix all the code readability problems you might run into, but at least it’s a good start.</p>
<h2>Linting</h2>
<p>Once you’ve got consistently-formatted code, it’s time to start thinking about <a href="https://en.wikipedia.org/wiki/Lint_(software)">linting</a>. The two most popular linters in the Python world are <a href="https://flake8.pycqa.org/">flake8</a> and <a href="https://pylint.pycqa.org/en/latest/">Pylint</a>, and while there’s some overlap in what they check for, there are also some pretty significant differences.</p>
<p>A massively oversimplified version of the differences between the two would be:</p>
<ul>
<li>flake8 is generally faster and will raise fewer false positives, but checks/enforces fewer things.</li>
<li>Pylint is generally slower and will have more false positives, but checks/enforces a <em>lot</em> more things.</li>
</ul>
<p>Two other things to be aware of about Pylint are that it requires <em>everything</em>, including all of your dependencies, to be importable during the run (in order to check for things like correct usage of imported modules/functions/classes), and that if you use a library or framework that does significant metaprogramming you’ll probably need a plugin to help Pylint understand that. For example, if you use Django you’ll pretty much always also use <a href="https://pypi.org/project/pylint-django/">pylint-django</a>.</p>
<p>My advice is to pick and run at least one of flake8 or Pylint. If you choose Pylint and you already have a large existing codebase, turn on its various checks gradually; Pylint’s own documentation recommends and explains how to do this. A nice hybrid option is to run Pylint as part of your <span>CI</span> suite, and flake8 in pre-commit: Pylint <a href="https://pylint.pycqa.org/en/latest/user_guide/installation/pre-commit-integration.html">is kind of tricky to use from a pre-commit hook</a> and can be slow, while flake8 <a href="https://flake8.pycqa.org/en/latest/user/using-hooks.html">has an official pre-commit hook</a> and is speedy.</p>
<p>Also, if you use flake8 in any capacity, I recommend including <a href="https://pypi.org/project/flake8-bugbear/">the flake8-bugbear plugin</a>, which adds a bunch of useful checks on top of the normal flake8 suite.</p>
<p>One more linter I strongly recommend is <a href="https://bandit.readthedocs.io/">Bandit</a>, which is focused mainly on potential security issues, and knows how to check for a lot of them. Just make sure to disable check <code>B101</code> (which by default forbids use of <code>assert</code>) when running it over unit-test code.</p>
<h2>Documentation checks</h2>
<p>Most programmers have thankfully come to understand the value of version control and automated testing. Unfortunately, there are many who are still, for whatever reason, skeptical of documentation. I don’t know why; I <em>love</em> documentation and treat it as an essential part of all my projects. I also love that Python has great tooling for it.</p>
<p>At an absolute minimum, you should be making use of Python’s ability to embed documentation alongside code via <a href="https://peps.python.org/pep-0257/">docstrings</a>. To enforce that, I recommend you use <a href="https://interrogate.readthedocs.io">interrogate</a>, which will tell you if you have any modules, classes, methods, or functions that don’t have docstrings.</p>
<p>But really you should be writing more documentation than just docstrings (though you still should have docstrings), and you should be using a proper documentation tool. In the Python world that’s <a href="https://www.sphinx-doc.org/">Sphinx</a>. If you’re someone who absolutely refuses ever to use anything other than Markdown for writing, I <em>highly</em> recommend you still at least give Sphinx’s native reStructuredText a try. And if you still hate it you can use Sphinx with Markdown documents via plugins.</p>
<p>One huge benefit of Sphinx is its rich annotation and cross-reference support, which lets you refer not just to other parts of your own codebase, but <a href="https://www.sphinx-doc.org/en/master/usage/extensions/intersphinx.html">to other Sphinx-documented codebases</a>, including Python itself (the core language and the standard library) and many popular frameworks and packages like Django.</p>
<p>You can also use <a href="https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html">the Sphinx <code>autodoc</code> plugin</a> to pull in docstrings from your codebase, but keep in mind that your documentation should be <a href="https://diataxis.fr">more than just an auto-generated <span>API</span> reference</a>.</p>
<p>My recommendation for documentation checks is:</p>
<ul>
<li>In pre-commit and <span>CI</span>, run interrogate (already mentioned) to enforce the presence of docstrings.</li>
<li>In <span>CI</span>, run a Sphinx build to prove the documentation builds without errors.</li>
<li>In <span>CI</span>, use <a href="https://pypi.org/project/sphinxcontrib-spelling/">sphinxcontrib-spelling</a> to spell-check your documentation.</li>
<li>Mark code samples in your documentation with the <code>doctest</code> directive and, in <span>CI</span>, run <a href="https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html">the Sphinx doctest plugin</a> to ensure those code samples work.</li>
</ul>
<p>That last one may be a bit controversial, but let me reiterate: this is <em>not</em> saying you should try to embed the full test suite of your codebase into the docstrings. It’s saying that any examples you put in your documentation to help people learn how to use your codebase need to be checked for correctness, and <em>that</em> is what <code>doctest</code> is for.</p>
<h2>Packaging checks</h2>
<p>If you’re working on something that’s intended to be built into a package and distributed, there are a few more tools that are useful to run.</p>
<p>First, you should install <a href="https://pypi.org/project/build/">the <code>build</code> package</a> and run <code>python -m build</code> to prove your packaging works; <code>build</code> is frontend that understands many different package-building backends and can generate the standard Python package formats (<code>.tar.gz</code> and <code>.whl</code>). If <code>python -m build</code> fails, it’s a strong sign something’s wrong with your packaging.</p>
<p>Then I recommend running a few more checks:</p>
<ul>
<li><a href="https://pypi.org/project/check-manifest/">check-manifest</a> builds your package, compares its contents to the files tracked by your version control system, and raises an error if the file lists don’t match. This is <em>incredibly</em> useful for catching when you’ve added files in version control but forgotten to update your packaging configuration to match, and can also attempt to fix the package manifest if you tell it to.</li>
<li><a href="https://pypi.org/project/check-wheel-contents/">check-wheel</a> can alert you to a number of common problems with your package, such as empty packages, accidentally including Python bytecode files, and several other issues.</li>
<li><a href="https://pypi.org/project/pyroma/">pyroma</a> will give your package a rating based on presence or absence of key package metadata values like project classifiers/keywords, license, supported Python versions, etc.</li>
<li><a href="https://twine.readthedocs.io/en/stable/#twine-check">The <code>twine check</code> utility</a> of <a href="https://pypi.org/project/twine/">the <code>twine</code> package uploader</a> can warn you if your package’s description won’t render properly on the Python Package Index.</li>
</ul>
<h2>The elep-hint in the room</h2>
<p>You may have noticed that none of the sections above talked about type annotations and static type checkers. That’s deliberate, because I’m <em>not</em> going to be recommending that you run a static type checker over your Python code. There are multiple such checkers available right now, in various states of maturity, and you should feel free to use one if you want to.</p>
<p>My own personal approach is to add type annotations to code whenever possible: they’re useful as documentation (but they should not be the <em>only</em> documentation you have!), and both documentation tools and many editors/IDEs will automatically pick up on them. But I don’t run a static type checker like <code>mypy</code>, for several reasons.</p>
<p>First and most importantly, idiomatic Python code tends to be more toward the structural-typed, or perhaps “interface-ly typed”, end of the spectrum. For example, you basically never care whether something is exactly of type <code>list</code>, you care about things like whether you can iterate over it or index into it. Yet the Python type-annotation ecosystem was strongly oriented around nominal typing (i.e., caring that something is exactly a <code>list</code>) from the beginning. Things have started to get better there, but support for <code>Protocol</code> (the official name for an interface) didn’t land in the standard library’s <code>typing</code> module until Python 3.8, and until then you either needed to use third-party implementations or, worse, tell the type checker “just trust me when I say this implements the necessary interface”, because there was no way to define what the interface looked like and have the type checker understand it.</p>
<p>And even with progress on things like protocols,  I think type hints are still not really all the way there. For example, annotating higher-order functions — which are another crucial part of idiomatic Python, not least in the form of decorators — is still a pretty rough experience, and although there have been <a href="https://peps.python.org/pep-0677/">proposals to make it better</a>, it’s going to be a while before that gets good enough for me to want to use.</p>
<p>And I already pointed out that I’m primarily a web developer. I rely heavily on libraries and frameworks — particularly ORMs like Django’s <span>ORM</span>, or SQLAlchemy — which do lots of runtime metaprogramming and as a result still don’t have great type-checking stories. There’s work underway, of course, and every so often I check out what progress has been made, but in my opinion the experience just isn’t good enough yet.</p>
<p>So, again, I encourage you to add type annotations to your code — I do! — but once they’re in place I personally use them only as documentation, and do not currently use a static type checker. You should feel free to use a static checker if you want one.</p>
<h2>Safely invoking tools</h2>
<p>For some of the tools I’ve recommended, and for some situations in which they’re run, you don’t really get to control how they’re invoked. For example, projects that provide their own pre-commit hooks decide how they should be invoked by the hook, and all the code to do that lives in their repository.</p>
<p>But at least in your <span>CI</span>, you do have control over this, and I recommend taking some care in how you do so.</p>
<p>First: although most of the things I’ve recommended do install standalone command-line entry points — like <code>black</code> for the Black code formatter — they also support being run as Python modules, like: <code>python -m black</code>. And I strongly recommend you do this whenever possible. I mentioned this in the last post, and Python core developer Brett Cannon <a href="https://snarky.ca/why-you-should-use-python-m-pip/">has a good explanation of it for the specific case of <code>pip</code></a>, but the general idea is: when you’re working with lots of Python installs/virtual environments, it’s a good idea to be as specific as possible in the invocation, to make sure you get the Python you think you’re getting. So, for example, if you want to run something using Python 3.9, <code>python3.9 -m &lt;name of thing&gt;</code> is preferable. And I personally like to extend that to all my <span>CI</span> tools.</p>
<p>Another advantage of this is that you can pass additional command-line flags to Python. One that’s a really good idea for <span>CI</span> — especially on public/open-source projects — is <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-I">the <code>-I</code> flag</a>. That’s “I” as in “Isolated”, which is what it stands for. This flag removes some implicit directories from the import path and ignores all environment variables that configure/change Python’s behavior, which is useful when you don’t necessarily trust everything you might run.</p>
<p>One example of a problem this will prevent: the current working directory is, normally, implicitly on the import path, which means a malicious pull request might, say, drop a file with the same name as a standard-library module into the directory you invoke your <span>CI</span> tooling from, and that module would then be imported and run by anything that tried to <code>import</code> the standard-library module of the same name. Running Python in isolated mode prevents this and other similar tricks.</p>
<p>Finally, at least for your test suite, I recommend adding one more command-line flag to the invocation of Python. Python supports <a href="https://docs.python.org/3/library/warnings.html">warnings</a> as a way to signal things that aren’t errors, or maybe aren’t <em>yet</em> errors, but that might still be useful to know about. One of the most important is <code>DeprecationWarning</code>, which is raised by Python and many third-party libraries to signal that particular APIs are in the process of being deprecated, and will one day be removed. But by default, Python does not display deprecation warnings, which means it’s easy to miss them. Since you probably want to know about deprecations sooner rather than later, I recommend using <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-W">the <code>-W</code> command-line flag</a> to change this behavior. Specifically, passing <code>-Wonce::DeprecationWarning</code> will show you deprecation warnings, but only the first time each particular location in the code raises a warning (so that you don’t get spammed with huge numbers of them if your code is frequently calling a deprecated <span>API</span>).</p>
<p>So if, say, you use <code>pytest</code> to run your tests, my recommendation is <em>not</em> to do this:</p>
<div><pre><span></span><code>pytest <span># pytest arguments here…</span>
</code></pre></div>

<p>But instead this:</p>
<div><pre><span></span><code>python -Wonce::DeprecationWarning -Im pytest <span># pytest arguments here…</span>
</code></pre></div>

<p>If you’re using an automation tool like <code>tox</code> or <code>nox</code>, there usually is some method of getting the specific Python interpreter for the current environment — in <code>tox</code> the <code>{envpython}</code> substitution, and in <code>nox</code> the <code>session.python</code> attribute (which returns the version number as a string, so you can construct the correct interpreter invocation as <code>f&#34;python{session.python}&#34;</code>).</p>
<h2>Putting it all together</h2>
<p>If you just want a summary of all the recommendations, here you go.</p>
<p>Must-have: version control, unit tests, automated test runs/continuous integration. Turn on <a href="https://coverage.readthedocs.io/">coverage</a> reports, but use them as a warning (if the coverage level suddenly drops) rather than as a target.</p>
<p>Set up ignore files for both your version-control system and Docker (if you’re using it).</p>
<p>Set up <a href="https://editorconfig.org">EditorConfig</a> and <a href="https://pre-commit.com">pre-commit</a>.</p>
<p>Run at least one of <a href="https://flake8.pycqa.org/">flake8</a> (with <a href="https://pypi.org/project/flake8-bugbear/">flake8-bugbear plugin</a>) or <a href="https://pylint.pycqa.org/">Pylint</a> as a linter, and run <a href="https://bandit.readthedocs.io/">the Bandit security linter</a>.</p>
<p>Document your code with <a href="https://www.sphinx-doc.org/">Sphinx</a>. Use <a href="https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html">its autodoc plugin</a> to pull docstrings from your code. Use <a href="https://www.sphinx-doc.org/en/master/usage/extensions/intersphinx.html">intersphinx</a> to cross-reference other projects (like Python, or libraries/frameworks you use), <a href="https://sphinxcontrib-spelling.readthedocs.io/">sphinxcontrib-spelling</a> to spell-check your documentation, and <a href="https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html">the Sphinx doctest plugin</a>. to check the correctness of any example code in your documentation. Enforce the presence of docstrings in all code with <a href="https://interrogate.readthedocs.io">Interrogate</a>.</p>
<p>If you’re building a package to be distributed/installed, run <a href="https://pypa-build.readthedocs.io/en/stable/">build</a>, <a href="https://twine.readthedocs.io/en/latest/#twine-check">twine check</a>, <a href="https://pypi.org/project/check-manifest/">check-manifest</a>, <a href="https://pypi.org/project/check-wheel-contents/">check-wheel-contents</a>, and <a href="https://pypi.org/project/pyroma/">pyroma</a>.</p>
<p>Add type annotations to code, if for no other reason than to use as documentation. Whether to run a static type checker, and which one, is up to you.</p>
<p>As for where to use each tool:</p>
<p>Have developers on your team configure their editor/<span>IDE</span> (if possible) to automatically run the Black and isort code formatters every time they save a file</p>
<p>In pre-commit, run:</p>
<ul>
<li>Black and isort, letting them reformat code</li>
<li>The flake8 linter</li>
<li>The Bandit security linter</li>
<li>Interrogate</li>
<li>The list of built-in pre-commit hooks listed in the full section above</li>
</ul>
<p>In <span>CI</span>, invoke tools by explicitly naming the Python interpreter to use and invoking the tool as a module with the <code>-m</code> flag (i.e., <code>python3.10 -m pytest</code> instead of just <code>pytest</code>), putting the interpreter in “isolated” mode with the <code>-I</code> flag, and for your main test suite run with deprecation warnings enabled via <code>-Wonce::DeprecationWarning</code>. And run these:</p>
<ul>
<li>Black and isort, but <em>don’t</em> let them reformat; instead have them error if they would reformat</li>
<li>At least one of flake8/Pylint</li>
<li>Bandit</li>
<li>Interrogate</li>
<li>Documentation build</li>
<li>Documentation spell-check</li>
<li>Test any example code in the documentation with Sphinx’s doctest plugin</li>
<li>If you’re building a package, run the package checks: <code>python -m build</code>, <code>twine check</code>, check-manifest, check-wheel-contents, pyroma</li>
</ul>
<h2>Until next time</h2>
<p>As with last time, that was a lot of words to cover what turns out to be not a particularly complex set of recommendations; it’s just explaining the “why” of everything that takes a while. And hopefully now you have an idea of a “boring” Python code-quality regimen; this won’t prevent every bug or problem you might introduce into your code, but it will help to catch a lot of potential issues.</p>
<p>And as before, even if you don’t adopt the recommendations I’ve given, I’d like to think that seeing them laid out and explained will at least be helpful to you, and that you’ll learn something you can take away and put to use in whatever setup you <em>do</em> choose to adopt.</p>


    </div>
  </div></div>
  </body>
</html>
