<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kellett.im/a/inverse-parentheses">Original</a>
    <h1>Inverse Parentheses</h1>
    
    <div id="readability-page-1" class="page"><div id="entry-content">
    <p>Have you ever noticed that lots of programming languages let you use parentheses to group operands, but none use them to ungroup them? No? Well let’s pretend this is a normal thing to be thinking about, and see what we can do about it.</p>
<p>Grouping with parentheses is relatively easy to add to a language grammar. The rule that accepts atomic things like <code>37</code> simply needs to also accept an opening paren,<sup id="fnref:paren"><a href="#fn:paren">1</a></sup> at which point it will recursively parse an entire expression, and then eat a closing paren.</p>
<div><pre><span></span><code><span>def</span> <span>parse_atom</span><span>(</span><span>lex</span><span>):</span>
    <span>r</span> <span>=</span> <span>next</span><span>(</span><span>lex</span><span>)</span>
    <span>if</span> <span>r</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#39;integer&#39;</span><span>:</span>
        <span>return</span> <span>int</span><span>(</span><span>r</span><span>[</span><span>1</span><span>])</span>
    <span>elif</span> <span>r</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#39;(&#39;</span><span>:</span>
        <span>expr</span> <span>=</span> <span>parse_expr</span><span>(</span><span>lex</span><span>)</span>
        <span>s</span> <span>=</span> <span>next</span><span>(</span><span>lex</span><span>)</span>
        <span>if</span> <span>s</span><span>[</span><span>0</span><span>]</span> <span>!=</span> <span>&#39;)&#39;</span><span>:</span>
            <span>raise</span> <span>ParseError</span><span>(</span><span>&#34;missing close paren&#34;</span><span>)</span>
        <span>return</span> <span>expr</span>
    <span>else</span><span>:</span>
        <span>raise</span> <span>ParseError</span><span>(</span><span>f</span><span>&#34;unexpected </span><span>{</span><span>r</span><span>[</span><span>0</span><span>]</span><span>}</span><span>&#34;</span><span>)</span>
</code></pre></div>

<p>Anti-grouping isn’t quite as straightforward. Our parser can’t follow the structure of the parentheses, because then it wouldn’t be following the structure of the expression—the whole point is that these are dissimilar.</p>
<p>I don’t know if it’s possible to write a pure parser that does this. But purity is overrated anyway. I decided to take inspiration from another language with a weird grouping system.</p>
<h2>Python</h2>
<p>Did you know that Python’s grammar has braces? You just don’t type them. The tokeniser<sup id="fnref:lexer"><a href="#fn:lexer">3</a></sup> keeps track of the indentation level and inserts special tokens when it changes. The parser itself doesn’t need to worry about counting whitespace; it just sees blocks of statements bracketed by <code>INDENT</code> and <code>DEDENT</code>,<sup id="fnref:tokname"><a href="#fn:tokname">4</a></sup> which are easy to parse.</p>
<p>As it happens, Python’s tokeniser also knows when it’s inside a parenthesised expression. Indentation inside parens is not significant, and this is implemented by <a href="https://github.com/python/cpython/blob/92d4aeafd5c678f781526583332a4deb7293f5f8/Parser/lexer/lexer.c#L1300-L1373">tracking the paren nesting depth</a> and suppressing <code>INDENT</code> and <code>DEDENT</code> while it’s non-zero.</p>
<p>What if we used the same trick? Instead of trying to do all this in the parser somehow, the tokeniser could track its nesting depth, and emit a “friendliness” score for each token. Then we can simply parse operators in ascending order of friendliness.</p>
<p>In this model <code>1 + (2 * 3)</code> will yield the following token stream:</p>


<p>We’ll leave the parentheses in the token stream, but all the parser needs to do with them is generate a syntax error if it finds one in the wrong place. Grouping will be handled entirely by the precedence levels embedded in the token stream.<sup id="fnref:precedence"><a href="#fn:precedence">5</a></sup></p>
<h2>A not-so-infinite climb</h2>
<p>The tokeniser hack solves our parsing problem, but it creates another one: our language now has infinitely many precedence levels. I don’t feel like trying to do that with handrolled recursive descent, but a rummage through school textbooks suggests a <a href="https://en.wikipedia.org/wiki/Operator-precedence_parser#Precedence_climbing_method">precedence climbing parser</a> is what we need. It deals with operators in the order it meets them, so having infinitely many <em>possible</em> precedences won’t bother it.</p>
<p>I <a href="https://gist.github.com/edk0/6295d1765b661d5f25efa1a3f90dab98#file-silly-py">hacked this together</a> and it’s appropriately silly:</p>
<div><pre><span></span><code>&gt; (1 + 2) * 3
1 + 2 * 3
&gt; 1 + (2 * 3)
(1 + 2) * 3
</code></pre></div>

<p>Something I particularly enjoy about the implementation I landed on is that if you increase friendliness instead of decreasing it, you end up with an ordinary<sup id="fnref:ordinary"><a href="#fn:ordinary">6</a></sup> parser. It’s also a good platform for other questionable syntactic innovations, like a language with <a href="https://gist.github.com/edk0/6295d1765b661d5f25efa1a3f90dab98#file-space-py">no parentheses at all, using whitespace to weaken binding</a>.</p>
<h2>Future work</h2>
<p>While we’ve achieved a lot here today,<sup id="fnref:requiring-early-attention"><a href="#fn:requiring-early-attention">7</a></sup> we’ve also raised some important new questions. For instance, is it always necessary to double-parenthesise expressions in more complex cases?</p>
<div><pre><span></span><code>&gt; ((1 * 2)) + (3 * 4)
1 * ((2 + 3) * 4)
</code></pre></div>

<p>And is it possible to have an anti-grouping parser that gives an involution when hooked up to an ordinary printer?</p>
<p>These are promising avenues for deeper study, and I’d love to hear from anyone who chooses to take them on.</p>

  </div></div>
  </body>
</html>
