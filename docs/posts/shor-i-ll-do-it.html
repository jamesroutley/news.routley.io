<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scottaaronson.blog/?p=208">Original</a>
    <h1>Shor, I’ll do it</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
        <span>
            <time datetime="2022-07-29">29 Jul 2022</time>
        </span>
        
        
        <section>
            <!--kg-card-begin: markdown--><p>They&#39;re here! <a href="https://csrc.nist.gov/projects/post-quantum-cryptography/selected-algorithms-2022">NIST selected a first batch</a> of post-quantum cryptographic key exchange and signature algorithms. <a href="https://nvlpubs.nist.gov/nistpubs/ir/2022/NIST.IR.8413.pdf">The report</a> is a nice read that explains a lot of the goals, candidates, selections, and rationales. I recommend Sections 2, 3.3, and 4.1.</p>
<p>For key exchange, NIST selected only CRYSTALS-Kyber, a KEM with IND-CCA2 security based on structured lattices, <a href="https://cryptojedi.org/peter/data/inria-20170411.pdf">a successor of NewHope</a>, with 800 bytes keys and ciphertexts (although the authors <a href="https://pq-crystals.org/kyber/">recommend</a> using the category 3 parameters, with 1184 bytes public keys and 1088 bytes ciphertexts). Four other KEMs based on codes and isogenies are continuing to a fourth round that will select a key exchange fallback in case lattices turn out to be a bad idea.</p>
<h2 id="kems">KEMs</h2>
<p>What&#39;s a KEM and what does it mean for it to have IND-CCA2 security? A Key Encapsulation Method is an implementation of the following API.</p>
<pre><code>KeyGen() -&gt; public key, secret key
Encapsulate(public key) -&gt; ciphertext, shared key
Decapsulate(secret key, ciphertext) -&gt; shared key
</code></pre>
<p>One way to implement a KEM that you might already be familiar with is with Elliptic Curve Diffie-Hellman. In ECDH, the ciphertext is more commonly called the peer or ephemeral share.</p>
<pre><code>KeyGen():
    secret key = random_scalar()
    public key = scalar_mult(secret key, generator)

Encapsulate(public key):
    ephemeral = random_scalar()
    ciphertext = scalar_mult(ephemeral, generator)
    s = scalar_mult(ephemeral, public key)
    shared key = KDF(s || public key || ciphertext)

Decapsulate(secret key, ciphertext):
    s = scalar_mult(secret key, ciphertext)
    shared key = KDF(s || public key || ciphertext)
</code></pre>
<p>One can also make a KEM from RSA. It&#39;s actually a much simpler, safer, and easier-to-prove way to do RSA encryption, compared with RSA-OAEP and especially with with RSA PKCS #1 v1.5 encryption. I regret using RSA-OAEP instead of RSA-KEM for <code>ssh-rsa</code> support in age.</p>
<pre><code>KeyGen():
    p, q = random_prime(), random_prime()
    public key = n = p * q
    e = 65537
    secret key = d = e⁻¹ mod λ(n)

Encapsulate(n):
    m = random(2, n)
    ciphertext = m ^ e mod n
    shared key = KDF(m || n || ciphertext)

Decapsulate(d, ciphertext):
    m = ciphertext ^ d mod n
    shared key = KDF(m || n || ciphertext)
</code></pre>
<p>(In the wild, you&#39;ll find RSA-KEM with configurable public exponent <code>e</code> and without <code>n</code> and <code>c</code> hashed into the shared key. Good cryptographic engineering hygiene requires <a href="https://www.imperialviolet.org/2022/03/15/pickingparameters.html">fixing parameters</a>, and hashing transcripts. The former <a href="https://github.com/ytdl-org/youtube-dl/pull/8142">saved my homebrew youtube-dl update verification function</a>, and the latter makes the KEM <a href="https://eprint.iacr.org/2019/526">contributory</a>.)</p>
<p>So that&#39;s what a KEM is. What about IND-CCA2 security? It means that it provides &#34;ciphertext indistinguishability against adaptive chosen ciphertext attacks&#34;. More concretely, it means you can reuse a public key instead of having to generate a new one for every decapsulation. The alternative is for it to be secure only against chosen plaintext attacks (CPA), where the attacker doesn&#39;t have access to a decryption oracle. In practice, that would require using each public key only once, restricting its use mostly to interactive protocols.</p>
<p>A CCA-secure KEM is a very versatile tool, that lets us do many (although not all) things we&#39;re used to doing in the pre-quantum world. The main difference from (EC)DH is that KEMs are asymmetric: you can&#39;t use the public key as a ciphertext and vice-versa.</p>
<p>Here&#39;s what can be done with a CCA-secure KEM:</p>
<ul>
<li>
<p>It can be combined with symmetric encryption in an offline KEM-DEM public key encryption scheme, like ECDHE turns into ECIES (which is what age&#39;s X25519 recipients implement): the sender does an encapsulation to the recipient&#39;s public key, uses the shared key to encrypt a message with a symmetric AEAD, and sends the KEM ciphertext and the encrypted message.</p>
</li>
<li>
<p>It can be used to build authenticated key exchanges by running the KEM three times (or two, to authenticate only one side) in parallel: once with an ephemeral  public key for forward secrecy, once with one peer&#39;s long term public key, and once with the other peer&#39;s long term public key. The three shared keys are hashed together, and using the resulting key authenticates the two peers.</p>
</li>
<li>
<p>It allows caching and reusing public keys in ephemeral key exchanges like ECDHE in TLS (which you might or might not want to do—with ECDH we pretty much collectively gave up on it, because many many many implementation errors become unexploitable if the &#34;public key&#34; is used only once).</p>
</li>
</ul>
<h2 id="kyber">Kyber</h2>
<p>Kyber is designed as a CPA-secure PKE core, turned into a CCA-secure KEM with a standard construction, but only the CCA-secure KEM is specified as an exposed primitive. This is cheap—it just adds a handful of hash invocations and a PKE encapsulation to the KEM decapsulation step—and a very good idea: we don&#39;t need two very similarly named primitives with very different security properties floating around, when we could just have the safer one everywhere. I hope implementations respect the spirit of the design and don&#39;t expose the CPA-secure PKE.</p>
<p>Another robustness detail I appreciate of Kyber is that it hashes the transcript (ciphertext and public key) into the key by design. When making a KEM out of ECDH, you need to feed shared secret, public key, and peer share/ciphertext into the KDF to get a contributory KEM. Kyber does that for you. While not required for CCA-security, contributory behavior <a href="https://eprint.iacr.org/2019/526">can prevent some neat real-world attacks</a> and should even allow using the public key as an authentication key. Enshrining this property into the design and test vectors is the right way to ensure implementations don&#39;t forget it when they need it.</p>
<h2 id="post-quantum-age">Post-quantum age</h2>
<p><a href="https://age-encryption.org">age</a> is a simple, modern, and secure file encryption format, tool, and library. Its native recipient type is based on X25519, but it supports custom recipient types through Go interfaces or an stdin/stdout plugin system. All a recipient needs to do is wrap and unwrap a file key given a recipient and identity string, respectively. Can we make a post-quantum age recipient based on Kyber?</p>
<h3 id="128-bits-are-enough">128 bits are enough</h3>
<p>The main concern is the size of the file key: 128 bits. My previous rough understanding of <a href="https://en.wikipedia.org/wiki/Grover%27s_algorithm">Grover&#39;s attack</a> was that it allowed searching an n-bit key space for a black box function in n/2 &#34;time&#34; on a quantum computer. This understanding is fairly popular: it&#39;s sort of a meme that you need to support AES-256 for &#34;post-quantum reasons&#34;. If that&#39;s right, then no matter what we use for the recipient implementation, age v1 can be attacked with a quantum computer by bruteforcing the file key (and checking it correctness against the header HMAC) in 2⁶⁴ time, which sounds unacceptable.</p>
<p>That understanding is practically wrong.</p>
<p>The <a href="https://csrc.nist.gov/projects/post-quantum-cryptography/post-quantum-cryptography-standardization/evaluation-criteria/security-(evaluation-criteria)">NIST security evaluation criteria</a> for post-quantum cryptography define five security categories of increasing strength. Each proposed post-quantum scheme provides a set of parameters to match these categories, which you can think about like key sizes in classical cryptography. To meet category 1 requirements, attacking a set of parameters &#34;must require computational resources comparable to or greater than those required for key search on a block cipher with a 128-bit key (e.g. AES128)&#34;.</p>
<p>Not only is a 128-bit key not a deal-breaker, then, but it&#39;s the benchmark against which category 1 post-quantum parameters are measured against. How to reconcile this with our understanding of Grover? NIST explains:</p>
<blockquote>
<p>[...] NIST suggests an approach where quantum attacks are restricted to a fixed running time, or circuit depth. Call this parameter MAXDEPTH. This restriction is motivated by the difficulty of running extremely long serial computations. Plausible values for MAXDEPTH range from 2⁴⁰ logical gates (the approximate number of gates that presently envisioned quantum computing architectures are expected to serially perform in a year) through 2⁶⁴ logical gates (the approximate number of gates that current classical computing architectures can perform serially in a decade), to no more than 2⁹⁶ logical gates (the approximate number of gates that atomic scale qubits with speed of light propagation times could perform in a millennium).</p>
<p>The complexity of quantum attacks can then be measured in terms of circuit size. These numbers can be compared to the resources required to break AES and SHA3. At the present time, NIST would give the following estimates for the classical and quantum gate counts for the optimal key recovery and collision attacks on AES and SHA3, respectively, where circuit depth is limited to MAXDEPTH:</p>
<p>AES-128: 2¹⁷⁰ / MAXDEPTH quantum gates</p>
<p>It is worth noting that the security categories based on these reference primitives provide substantially more quantum security than a naïve analysis might suggest. For example, categories 1, 3 and 5 are defined in terms of block ciphers, which can be broken using Grover’s algorithm, with a quadratic quantum speedup. But Grover’s algorithm requires a long-running serial computation, which is difficult to implement in practice. In a realistic attack, one has to run many smaller instances of the algorithm in parallel, which makes the quantum speedup less dramatic.</p>
</blockquote>
<p>The summary is that Grover requires an unrealistically long-running serial computation, and <a href="https://arxiv.org/abs/quant-ph/9711070">can&#39;t be parallelized better than naively running multiple instances</a>. When taking into account a conservative maximum running time, such as 2⁶⁴ gates, running Grover on a 128-bit key space would require a circuit size of 2¹⁰⁶.</p>
<p>Assuming that there aren&#39;t any better-than-Grover attacks against the age primitives—HKDF-SHA-256 followed by HMAC-SHA-256 or ChaCha20Poly1305—it&#39;s fully appropriate to match category 1 post-quantum KEMs with 128-bit symmetric keys, like in age.</p>
<blockquote data-dnt="true"><p lang="en" dir="ltr">Yes, it&#39;s fine to use Kyber512 like this. But I recommend defaulting to Kyber768 unless you have a hard performance constraint that forces you to use 512.</p>— John Schanck (@susurrusus) <a href="https://twitter.com/susurrusus/status/1544698275718053890?ref_src=twsrc%5Etfw">July 6, 2022</a></blockquote>  
<blockquote data-conversation="none" data-dnt="true"><p lang="en" dir="ltr">Indeed If 128-bit brute force is the best way of attacking the protocol, then it meets Level 1 requirements; being equivalent to AES-128.</p>— mjos\dwez (@mjos_crypto) <a href="https://twitter.com/mjos_crypto/status/1544699876545634307?ref_src=twsrc%5Etfw">July 6, 2022</a></blockquote>  
<h3 id="the-age-kyber768x25519-plugin">The age Kyber768+X25519 plugin</h3>
<p>Having established that the overall age protocol can by definition meet NIST&#39;s category 1 post-quantum security requirements, we can start thinking about how a post-quantum age plugin would look like.</p>
<p>Kyber&#39;s category 1 parameters are Kyber512, but <a href="https://pq-crystals.org/kyber/index.shtml">the authors recommend using Kyber768</a> unless prohibitive due to performance reasons. Both are plenty fast, and both have large public keys (800 vs 1184 bytes), so let&#39;s pick the conservative option. As str4d—<a href="https://github.com/str4d/rage">rage</a>&#39;s author—points out, this would also let us decide later that we do instead want to increase the file key size, while letting users keep their keys with a matching comfortable margin.</p>
<p>Any deployment of experimental post-quantum cryptography should be hybrid: paired with classical cryptography such that even if lattice cryptography turns out to be a bad idea, the combined system will be at least as secure as the classical algorithm. For our plugin, we&#39;ll just combine the Kyber768 KEM with X25519.</p>
<p>Native X25519 recipients wrap the file key using ChaCha20Poly1305 with a key derived as <code>HKDF-SHA-256(ikm = shared secret, salt = ephemeral share || recipient, info = &#34;age-encryption.org/v1/X25519&#34;)</code>. We could just add the Kyber key to the input key material, but we can take the occasion to fix a small regret in the age design: the salt is supposed to be random or fixed for domain separation, while ephemeral share and recipient should have been part of the input key material. This is not a security issue, but it makes applying some proofs more convoluted.</p>
<p>The wrapping key for the Kyber768+X25519 plugin can then be <code>HKDF-SHA-256(ikm = shared secret || ephemeral share || recipient || kyber key, salt = &#34;age-encryption.org/Kyber768+X25519&#34;, info = nil)</code>.</p>
<p>There are a few open questions that relate to optional properties that are not part of the core age guarantees but some recipients provide:</p>
<ul>
<li>Do a decryption or encryption oracle leak information about the public key? As we talked about above, the public key is hashed into the key (the KEM is contributory), so an attacker can&#39;t generate a valid ciphertext for an unknown public key. If the attacker also can&#39;t learn the public key from an oracle, it might be possible to build authentication semantics around this.</li>
<li>Are ciphertexts for the same public key efficiently linkable? X25519 and Scrypt ciphertexts are unlikable, so given two age files you can&#39;t tell if they are encrypted to the same recipient. Does the same hold for Kyber768+X25519? (This does not hold for the SSH recipients, which intentionally include a public key hash, so we don&#39;t ask for the passphrase for keys that wouldn&#39;t work.)</li>
<li>Is it possible to craft ciphertexts that are valid (and lead to known keys) under multiple public keys, enabling multi-key attacks <a href="https://github.com/FiloSottile/age/commit/2194f6962c8bb3bca8a55f313d5b9302596b593b">like against X25519 and ChaCha20Poly1305</a>? Although the impact of this is limited—allows efficient searches of the accepted public keys of a decryption oracle—it might be a good reason to use a robust AEAD instead of ChaCha20Poly1305.</li>
</ul>
<p>Finally, there&#39;s the elephant in the room: the UX issue of the large public keys.</p>
<p>One of the key strengths (pun not intended) of age is that it has small, copy-pastable recipients like age1ydzqkt4vfuumwgk5hxus22gakwpqk9knua62qnzcqw5nzta30d9q3va9x0. A Kyber768+X25519 recipient would be... quite a bit longer. I am not going to paste one here because I care about the delivery rate of this email, but it&#39;d be 1960 characters, more than 30 times longer than the X25519 one.</p>
<p>A suggestion I like was to have the plugin store keys with a <code>-learn</code> flag, and then allow using them with a short identifier, like a hash. Or, maybe we bring back the aliases file that was in the original <a href="https://age-encryption.org/design">age design document</a> but never made it to v1.0.0. Or, we just accept that Kyber768+X25519 recipients will be mostly used with <code>--recipients-file</code>. It is still shorter than an armored OpenPGP public key. I welcome opinions and ideas.</p>
<blockquote data-conversation="none" data-dnt="true"><p lang="en" dir="ltr">Does age currently use any local state? You could do like a mapping from H(public key) -&gt; public key locally, then just require registering a public key once.</p>— Lúcás Meier (@cronokirby) <a href="https://twitter.com/cronokirby/status/1544716869671784450?ref_src=twsrc%5Etfw">July 6, 2022</a></blockquote>  
<p>One more bonus UX issue: how do we stop people from mixing Kyber768+X25519 and plain X25519 recipients, defeating the post-quantum security of the file? Ideally without a special case.</p>
<h2 id="bonus-picture">Bonus picture</h2>
<p>I&#39;m <a href="https://words.filippo.io/dispatches/dsa/">back</a> on the lake for the Italian math team training (where the promising kids train and I mostly play board games)!</p>
<p><img src="https://words.filippo.io/content/images/2022/07/IMG_6905.jpg" alt="A picture of a lake taken from the shore. The sky is full of clouds colored orange from a recent storm. They reflect on the water, where a few boats sit anchored. Two wooden piers extend from the shore from right to left. In the distance mountains on the other side of the lake, and a small sliver of blue sky." loading="lazy"/></p>


<!--kg-card-end: markdown-->
        </section>
    </article>
</div></div>
  </body>
</html>
