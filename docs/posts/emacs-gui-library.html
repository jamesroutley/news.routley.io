<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andreyor.st/posts/2023-07-11-emacs-gui-library/">Original</a>
    <h1>Emacs GUI Library</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>Lately, my Magit buffer broke once again because of something weird going on with major mode, and I couldn’t stash or commit hunks unless the point was at the beginning of the line.
That once again reminded me that Emacs UI is not really a UI, all of it is mere text with a bunch of properties slapped on top.
It’s easy to forget about it, and use such things like Treemacs, Customize, heck, even Org Mode, thinking that you’re interacting with UI elements (file nodes in Treemacs, text-boxes in Customize, Org Modes sub-trees and drawers).
However, it is an illusion, though neatly crafted.
It’s still text.</p>
<p>Well, what’s bad about it you might ask?
We love to manipulate text, Emacs even makes it actually comfortable to do, with a lot of functions dedicated to it.
And buffers are also a very fast way to manipulate even moderate amounts of text.
But ask yourself, do you really want to do the same kind of thing in a different UI system, outside of Emacs?
Maybe if it came with the same amount of useful functions?
Well, maybe you’d want to, but I sure don’t.</p>
<p>I’ve made my own custom UI elements in Kakoune, making a file tree, and tag list plugins.
That was before I actually started using Emacs as my main environment, and Kakoune text properties are much less sophisticated than ones of Emacs, but…
It’s the same thing, really.</p>
<p>You programmatically spit some text into the buffer, then you parse it, find elements, walk on them, change them, and so on.
Yes, text properties, markers, overlays, all of it makes it more robust in Emacs, but even though, things still break.
Because Emacs still tries to interpret stiff in your buffer as text.</p>
<p>Because that’s what it does, it expects text!
If you call <code>forward-sexp</code> on some Magit UI element it will try to do the right thing, even if there’s no right thing - there are no sexps in the Magit buffer.
Well, maybe there are if you’re viewing diffs of your lisp code, and then yeah, the benefit of everything being text you can move on becomes obvious.
Except when we’re talking about UI it’s not working more of the times than it is useful in an occasional context of that UI element.</p>
<p>I think you probably get where I’m going with this.
And you probably don’t like it, but bear with me.
And it’s an angry bear, so don’t threaten me more than he does, please.</p>
<p>What I’m trying to say is that Emacs, as a GUI application isn’t something that I’d be advertising to other people.
You can make Emacs look beautiful, no doubt about that, <a href="https://github.com/rougier/nano-emacs" target="_blank">Nano</a> Emacs, <a href="https://github.com/doomemacs/doomemacs" target="_blank">DOOM</a>, and others try very hard to make Emacs visually appealing.
But it’s all too janky IMO.
Nano Emacs looks great on the pictures, but resize a window and the illusion of a coherent interface breaks fast.
So let’s look at different systems for inspiration:</p>
<h2 id="smalltalk">Smalltalk</h2>
<p>I’ve already mentioned Smalltalk in the past regarding comparison with Emacs in the GUI field.
And I think it is a fair thing to do - both are dynamic systems that you can program with their respective language.
Except, one is GUI oriented pretty much from the start, and the other one is Emacs.</p>
<p>Look at how Smalltalk looks when you fire up Pharo:</p>
<figure><img src="https://andreyor.st/2023-07-11-emacs-gui-library/pharo.gif"/>
</figure>

<p>It’s a GUI <em>system</em>.
Complete with windows, containing text editors, browsers, context-aware menus, and so on.
Maybe it doesn’t look as pretty as your preferred GUI toolkit, but it’s not the main point.</p>
<p>Although, here’s how Smalltalk looks when you fire up GToolkit, which is written in Pharo:</p>
<div>
<figure><img src="https://andreyor.st/2023-07-11-emacs-gui-library/gtoolkit-1.png" alt="Figure 1: Visualizing the current knowledge base through a Pharo snippet. Clicking on nodes opens the page to the right." width="580px"/><figcaption>
            <p><span>Figure 1: </span>Visualizing the current knowledge base through a Pharo snippet. Clicking on nodes opens the page to the right.</p>
        </figcaption>
</figure>

<figure><img src="https://andreyor.st/2023-07-11-emacs-gui-library/gtoolkit-2.png" alt="Figure 2: A page with a JavaScript snippet that is combined with a Pharo snippet to produce a visualization of dependencies defined in a Yarn file." width="580px"/><figcaption>
            <p><span>Figure 2: </span>A page with a JavaScript snippet that is combined with a Pharo snippet to produce a visualization of dependencies defined in a Yarn file.</p>
        </figcaption>
</figure>

<figure><img src="https://andreyor.st/2023-07-11-emacs-gui-library/gtoolkit-3.png" alt="Figure 3: Explaining a domain object through examples and custom views." width="580px"/><figcaption>
            <p><span>Figure 3: </span>Explaining a domain object through examples and custom views.</p>
        </figcaption>
</figure>

</div>
<p>There are much more pictures on the <a href="https://gtoolkit.com/" target="_blank">official web page</a>.</p>
<p>The point of it is that you can build your own tools for your tasks in this toolkit, as shown in the pictures.
They call it building an inspector, and GToolkit comes with a lot of inspectors for various kinds of data.</p>
<p>This is my favorite system so far, and it gets worse from here but I feel that we need to talk about other examples still.</p>
<h2 id="clojure"><del>Java</del> Clojure</h2>
<p>Why not?
Clojure is another dynamic system, that you can change at runtime.
While Java isn’t what comes to mind when speaking about beautiful and functional GUI, making GUI apps in Clojure is far more fun than it is in Java.
Because again, you can update your UI elements on the fly.</p>
<p>There are some examples of apps where the UI is done in Clojure, one example is the game engine called <a href="https://defold.com/product/" target="_blank">Defold</a>.</p>
<p>It looks like this:</p>
<figure><img src="https://andreyor.st/2023-07-11-emacs-gui-library/defold.png" alt="Figure 4: I couldn&amp;rsquo;t find a non-skewed image on the official page." width="580px"/><figcaption>
            <p><span>Figure 4: </span>I couldn’t find a non-skewed image on the official page.</p>
        </figcaption>
</figure>

<p>As far as I understand, its Editor is made in Clojure, and UI is handled via the JavaFX toolkit.</p>
<p>Intellij Idea is many another example of a decent-looking GUI in Java, although your opinion may vary.</p>
<p>Still, JVM isn’t the greatest at UI, and somehow another language with a J in the name managed to do somewhat better.</p>
<h2 id="web">Web</h2>
<p>Lastly, the web is another way of building user interfaces, one that is quite popular today.
Because the web works the same across a majority of operating systems, as browsers are ported to them with a lot of care.
Browsers are also extremely capable of rendering all kinds of file formats, doing interactive stuff, and JavaScript frameworks are aimed at providing facilities for building UI that is highly responsive and interactive.</p>
<p>The web is however associated with slow, often unresponsive UI, a lot of wasted screen space, and unnecessary high CPU and memory usage.
Mostly due to Electron packing lots of stuff.
I think Electron wasn’t a bad idea, the execution was just poor.
There are other projects that provide similar facilities like <a href="https://ultralig.ht/" target="_blank">Ultralight</a>, but I didn’t investigate further.
I’m OK with the idea of building UI on web technologies, as long as we’re making a robust system that works across multiple devices and actually benefits from using the browser.</p>
<p>There’s also this project, which I find cool because it looks similar to GToolkit: <a href="https://natto.dev/example/0a7aeb805e76412989946c5f270f84e5" target="_blank">natto.dev</a>.
Basically, you get an infinite canvas, on which you can place text editing widgets, video widgets, and other stuff.
Keep this thing in mind, I find the idea of such UI interesting, and probably it will be explored more in the future.</p>
<p>But, let’s get back to Emacs, and I’ll try to explain why I was bragging about all these other systems.</p>
<h2 id="emacs">Emacs</h2>
<p>Emacs has a windowing system.
Basically like a tiling window manager - you have a frame, you can divide it into windows, you can spawn other frames, you can divide them, and so on.
But, these windows can only display basic text, among some graphical elements, like SVG graphics, or bitmaps.
Needless to say, when compared to any of the systems I’ve talked about before the GUI capabilities of Emacs are quite limited.</p>
<p>Basically, Emacs is a glorified terminal, with ability to draw different font sizes and decent image support.
Don’t make such a face, you know it’s not far from the truth.
Again, this may be a bit harsh, but I believe we need to admit things in order to move forward.</p>
<p>Speaking of terminals, Emacs can actually run in a terminal!
You can start it with <code>emacs -nw</code> and it will happily transform your terminal into Emacs.
I mean, you no longer have a terminal, it just acts as a rendering engine for Emacs.
So you basically get the same thing as GUI Emacs but worse, because now your terminal is responsible for rendering fonts, and you no longer have any image support.
Well, there are terminals that support images, but come on.</p>
<p>And I think terminal support is one of the things that holds Emacs back.
Think about it - why do you even need a terminal if you’re already using Emacs?</p>
<ul>
<li>Need to ssh somewhere to edit files or run some commands?
<ul>
<li>TRAMP got you covered.</li>
</ul>
</li>
<li>Need to run some commands in general?
<ul>
<li>You can call <code>async-shell-command</code>, it even can handle your input in case there’s a prompt;</li>
<li>Or you can run <code>compile</code>, and it will be much more interactive than the raw terminal output.</li>
</ul>
</li>
<li>Want to run some complex commands with editing convenience?
<ul>
<li>You can run <code>eshell</code>, and go nuts on scripting in Emacs Lisp and calling sh scripts from the Emacs shell;</li>
<li>Or you can run a proper terminal emulator from Emacs.</li>
</ul>
</li>
</ul>
<p>I too previously was a terminal enjoyer before Emacs.
As I’ve mentioned, I was using Kakoune, and prior to that, I was a Vim user.
Now, with Emacs, I rarely open the terminal at all.
There’s simply no need to, as there are more comfortable ways of interacting with the shell.
So yeah, ditch the terminal version of Emacs, you’re ain’t gonna miss it.</p>
<p>Except, don’t.
Because the solution I’m going to propose doesn’t require anything to be ditched at all.
But before that, let’s talk XWidgets</p>
<h3 id="xwidgets">XWidgets</h3>
<p>When I was talking about the web, I’m sure some of you thought about XWidgets and Webkit support in Emacs.
Like, here, I’m running the already mentioned natto.dev inside my Emacs right now:</p>
<figure><img src="https://andreyor.st/2023-07-11-emacs-gui-library/emacs-1.png" width="580px"/>
</figure>

<p>So what gives?
And at work, I occasionally use Portal to navigate through nested data structures while debugging Clojure code:</p>
<figure><img src="https://andreyor.st/2023-07-11-emacs-gui-library/emacs-2.png" alt="Figure 5: (the code isn&amp;rsquo;t from work, just a hobby project)" width="580px"/><figcaption>
            <p><span>Figure 5: </span>(the code isn’t from work, just a hobby project)</p>
        </figcaption>
</figure>

<p>Again, what gives?
This looks like we can have interactive GUIs in Emacs, much like in GToolkit and Pharo.
However, there’s a catch.
There’s always a catch, and in the case of Emacs, it’s that the XWidget UIs are <em>foreign</em> to Emacs.</p>
<p>Here, foreign means that inside that <code>*xwidget-webkit: portal...*</code> buffer nothing you expect to work will actually work.
Remember how I mentioned that in Magit if you call <code>forward-sexp</code> it will try to do the right thing?
Well, here it can’t do anything, because this isn’t a buffer really.
It is an embedded widget that only looks like a buffer in the Emacs window, but it’s not.</p>
<p>There’s <em>no point</em> in calling <code>forward-sexp</code> because there’s literally no point in such a buffer.
You can’t use <a href="https://github.com/abo-abo/avy" target="_blank">Avy</a> to jump to an element in such a buffer because there are no textual elements that Avy can look at.</p>
<p>Because of it, it is basically the same as if you’ve opened a separate web browser side by side with Emacs and used it to browse the web, or run Portal, and it would probably even work better.
Unfortunately, we can’t embed something like Webkit into Emacs and hope that it will solve our UI problems.
Or can we?</p>

<p>So here’s my idea.
I’m pretty sure it’s not new, but that’s not the point of this blog - it is merely a container for my thoughts, original or not.</p>
<p>What if, instead of embedding Webkit into Emacs, we turn this around?
Hear me out.</p>
<p>When I was talking about opening a browser side by side with Emacs two seconds ago, I should have mentioned that window managers, or WMs for short, are quite good at placing windows.
If you’re using some kind of a tiling manager, you know what I mean - you can leave window management to your window manager.
Kakoune, for instance, does exactly that - instead of creating its own windowing system, like Vim or Emacs, it leaves it out for things like TMUX or i3 to solve.
This, of course, has some problems too, but works well enough in general.</p>
<p>But I’m not saying that we should ditch windowing from Emacs and leave it to the WM, far from it.
I would rather ditch frames from Emacs if you ask me, but that’s another topic.</p>
<p>Look at this as if Emacs was embedded into your window manager, which is basically how it works.
You start your WM of choice<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>, you launch Emacs, and as long as the Emacs window is focused, you live in Emacs.
All of your shortcuts work, and all of your navigation habits are there.</p>
<p>So what if we expand on this idea?
Instead of embedding Webkit, let’s embed Emacs in its current state as a UI widget.</p>
<h3 id="the-widget-library">The Widget Library</h3>
<p>What I’m thinking is, let’s take, say SDL2 (or maybe something like <a href="https://github.com/ocornut/imgui" target="_blank">ImGui</a>), and create a library of widgets for Emacs.
We’ll then integrate Emacs into it as the runtime system behind it, much like in the case of Smalltalk, JavaFX+Clojure, and Web+JS, and provide a set of functions to navigate through widgets in a meaningful way.
The widgets would include basic stuff, like buttons, text boxes, buffers, drawers, menus… wait, buffers?</p>
<p>Yes, why ditch something that works well?
Like when you focus Emacs in your WM and it just works, when the buffer widget is in focus it will just work too!
We can keep the redisplay code, it will just need to learn how to render into such widgets, which I’m sure is possible, as there’s a very similar feature in Emacs already, called child-frames.</p>
<p>With enough widgets, one will be able to build GUI, much like in GToolkit, but with Emacs Lisp, and we’ll still have all the legacy textual interface working, e.g. things like Magit don’t have to throw everything out of the window and adapt - they can continue to work.
We just need to be sure to provide enough extensibility, and a way to implement custom widgets, much like Emacs allows right now with its text properties, overlays, and such.
Then new plugins for the GUI toolkit will arrive, making Emacs even more extensible than before.</p>
<p>Now, imagine, you open Emacs and it creates a window that is basically like a desktop of your operating system.
You open a window, and it’s a real window, floating on that desktop.
Don’t like it?
Just maximize it, the window widget will work similarly to how windows are created in Emacs right now.
Except it doesn’t have to be a window displaying a buffer and nothing else - it can display other widgets, some of which are buffers.</p>
<p>Frames become virtual desktops, which they really are, it’s just that they’re represented as WM windows because Emacs didn’t include ways of switching them virtually (it did in the terminal mode actually).
You can still open a separate “frame” with a given virtual desktop, so again, everything would work as you’d expect.</p>
<h2 id="the-future-of-emacs">The future of Emacs</h2>
<p>…probably isn’t what I’m describing here.
I don’t know.
I’m just fantasizing, but the image of such a system I see behind my eyelids is great.</p>
<p>I <em>depend</em> on Emacs, it is my main tool for the job, this blog, my other hobbies, and other activities, so I want this system to evolve.
This is just a route I think it could take.
Again, maybe nothing of this makes any sense to you, but I encourage you to try out at least the GToolkit, I think it is the most interesting things I saw in the last years.
Pharo can be a bit less exciting but it laid the foundation for GT, and I think that’s says something.
If it wasn’t for Clojure, and maybe this blog which I do in Org-mode, and if I never used Emacs I would probably try GToolkit at some point, and maybe it would become my main tool, and I would probably look at Emacs as an inferior system.
Well, at least when it comes to GUI capabilities.
But I still love Emacs as it is, it fulfills my needs, and I can make it do what I want it to do, which is the main point.</p>
<p>This post was mostly a collection of random thoughts, hence the category, but I genuinely think that if a system like this can be created in Smalltalk or in the current state of the web, it is definitively possible in Emacs, there’s just not that much of an interest in it.
Well, actually there is, as I’ve mentioned, people trying to make emacs more beautiful and appealing, but I think we should not forget about utility too, and thus if someone is to develop a GUI toolkit for Emacs they need to put a lot of thought into it:</p>
<ul>
<li>What widgets to include;</li>
<li>How do you move from widget to widget in an efficient way;</li>
<li>What is best done with a mouse, and what should not be done with it;</li>
<li>What level of interactivity from Emacs Lisp we should get;</li>
<li>Other questions like this.</li>
</ul>
<p>So yeah, it will take a lot of planning, prototyping, maybe some competing systems to progress on this - let’s see where Emacs will go in the upcoming 30 years.
Maybe another XEmacs will happen, or it will be forced to evolve by something like <a href="https://project-mage.org/elevator" target="_blank">Project Mage</a> or <a href="https://nyxt.atlas.engineer/" target="_blank">Nyxt</a>, or even another system, that would embrace GToolkit’s modal-less interface and infinite canvas.
The advent of virtual and/or augmented reality makes an interesting infinite-canvas type of interface candidate in my opinion, so maybe we’ll stop seeing flat screens in the future, who knows?</p>
<p>Anyway, let me know what you think.
If you have any thoughts you like to share, you can find my contacts on the <a href="https://andreyor.st/about">About</a> page.
Hope it was an interesting read!</p>


  </article></div>
  </body>
</html>
