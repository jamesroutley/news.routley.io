<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://netflixtechblog.com/introducing-safetest-a-novel-approach-to-front-end-testing-37f9f88c152d">Original</a>
    <h1>SafeTest: A novel approach to front end testing</h1>
    
    <div id="readability-page-1" class="page"><section><div><div><div><div><div><div><div><div><div><div><div><a href="https://netflixtechblog.medium.com" rel="noopener follow"><div><div aria-hidden="false"><div><div><p><img alt="Netflix Technology Blog" src="https://miro.medium.com/v2/resize:fill:88:88/1*BJWRqfSMf9Da9vsXG9EBRQ.jpeg" width="44" height="44" loading="lazy" data-testid="authorPhoto"/></p></div></div></div></div></a><a href="https://netflixtechblog.com" rel="noopener  ugc nofollow"><div><div><div aria-hidden="false"><div><div><p><img alt="Netflix TechBlog" src="https://miro.medium.com/v2/resize:fill:48:48/1*ty4NvNrGg4ReETxqU2N3Og.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto"/></p></div></div></div></div></div></a></div></div></div></div></div></div></div><p id="769f">by <a href="https://medium.com/u/a155da075195" rel="noopener" target="_blank">Moshe Kolodny</a></p><p id="3432">In this post, we’re excited to introduce SafeTest, a revolutionary library that offers a fresh perspective on End-To-End (E2E) tests for web-based User Interface (UI) applications.</p><p id="5648">Traditionally, UI tests have been conducted through either unit testing or integration testing (also referred to as End-To-End (E2E) testing). However, each of these methods presents a unique trade-off: you have to choose between controlling the test fixture and setup, or controlling the test driver.</p><p id="11ab">For instance, when using <a href="https://testing-library.com/docs/react-testing-library/intro/" rel="noopener ugc nofollow" target="_blank">react-testing-library</a>, a unit testing solution, you maintain complete control over what to render and how the underlying services and imports should behave. However, you lose the ability to interact with an actual page, which can lead to a myriad of pain points:</p><ul><li id="d50e">Difficulty in interacting with complex UI elements like &lt;Dropdown /&gt; components.</li><li id="f78c">Inability to test CORS setup or GraphQL calls.</li><li id="1789">Lack of visibility into z-index issues affecting click-ability of buttons.</li><li id="25ce">Complex and unintuitive authoring and debugging of tests.</li></ul><p id="7c9f">Conversely, using integration testing tools like Cypress or Playwright provides control over the page, but sacrifices the ability to instrument the bootstrapping code for the app. These tools operate by remotely controlling a browser to visit a URL and interact with the page. This approach has its own set of challenges:</p><ul><li id="90fa">Difficulty in making calls to an alternative API endpoint without implementing custom network layer API rewrite rules.</li><li id="8108">Inability to make assertions on spies/mocks or execute code within the app.</li><li id="bef2">Testing something like dark mode entails clicking the theme switcher or knowing the localStorage mechanism to override.</li><li id="3189">Inability to test segments of the app, for example if a component is only visible after clicking a button and waiting for a 60 second timer to countdown, the test will need to run those actions and will be at least a minute long.</li></ul><p id="6d84">Recognizing these challenges, solutions like E2E Component Testing have emerged, with offerings from <a href="https://docs.cypress.io/guides/component-testing/overview" rel="noopener ugc nofollow" target="_blank">Cypress</a> and <a href="https://playwright.dev/docs/test-components" rel="noopener ugc nofollow" target="_blank">Playwright</a>. While these tools attempt to rectify the shortcomings of traditional integration testing methods, they have other limitations due to their architecture. They start a dev server with bootstrapping code to load the component and/or setup code you want, which limits their ability to handle complex enterprise applications that might have OAuth or a complex build pipeline. Moreover, updating TypeScript usage could break your tests until the Cypress/Playwright team updates their runner.</p><p id="7bcb">SafeTest aims to address these issues with a novel approach to UI testing. The main idea is to have a <a href="https://www.npmjs.com/package/safetest#bootstrapping-your-application" rel="noopener ugc nofollow" target="_blank">snippet of code in our application bootstrapping stage that injects hooks to run our tests</a> (see the <a href="https://www.npmjs.com/package/safetest#how-safetest-works" rel="noopener ugc nofollow" target="_blank">How Safetest Works</a> sections for more info on what this is doing). <strong>Note that how this works has no measurable impact on the regular usage of your app since SafeTest leverages lazy loading to dynamically load the tests only when running the tests (in the README example, the tests aren’t in the production bundle at all).</strong> Once that’s in place, we can use Playwright to run regular tests, thereby achieving the ideal browser control we want for our tests.</p><p id="564d">This approach also unlocks some exciting features:</p><ul><li id="1ba4">Deep linking to a specific test without needing to run a node test server.</li><li id="4596">Two-way communication between the browser and test (node) context.</li><li id="e8c3">Access to all the DX features that come with Playwright (excluding the ones that come with @playwright/test).</li><li id="2d40">Video recording of tests, trace viewing, and pause page functionality for trying out different page selectors/actions.</li><li id="8881">Ability to make assertions on spies in the browser in node, matching snapshot of the call within the browser.</li></ul><p id="0a0a">SafeTest is designed to feel familiar to anyone who has conducted UI tests before, as it leverages the best parts of existing solutions. Here’s an example of how to test an entire application:</p><pre><span id="f3f5">import { describe, it, expect } from &#39;safetest/jest&#39;;</span></pre><p id="645d">We can just as easily test a specific component</p><pre><span id="a79b">import { describe, it, expect, browserMock } from &#39;safetest/jest&#39;;</span></pre><p id="0b57">SafeTest utilizes React Context to allow for value overrides during tests. For an example of how this works, let’s assume we have a fetchPeople function used in a component:</p><pre><span id="36b1">import { useAsync } from &#39;react-use&#39;;</span></pre><p id="3830">We can modify the People component to use an Override:</p><pre><span id="fd00"> import { fetchPerson } from &#39;./api/person&#39;;</span></pre><p id="7f56">Now, in our test, we can override the response for this call:</p><pre><span id="9be7">const pending = new Promise(r =&gt; { /* Do nothing */ });</span></pre><p id="f8e2">The render function also accepts a function that will be passed the initial app component, allowing for the injection of any desired elements anywhere in the app:</p><pre><span id="719c">it(&#39;has a people loaded state&#39;, async () =&gt; {</span></pre><p id="49c7">With overrides, we can write complex test cases such as ensuring a service method which combines API requests from <code>/foo</code>, <code>/bar</code>, and <code>/baz</code>, has the correct retry mechanism for just the failed API requests and still maps the return value correctly. So if <code>/bar</code> takes 3 attempts to resolve the method will make a total of 5 API calls.</p><p id="3a19">Overrides aren’t limited to just API calls (since we can use also use <code><a href="https://playwright.dev/docs/api/class-page#page-route" rel="noopener ugc nofollow" target="_blank">page.route</a></code>), we can also override specific app level values like feature flags or changing some static value:</p><pre><span id="2bad">+const UseFlags = createOverride(useFlags);</span></pre><p id="875d">Overrides are a powerful feature of SafeTest and the examples here only scratch the surface. For more information and examples, refer to the <a href="https://www.npmjs.com/package/safetest#overrides" rel="noopener ugc nofollow" target="_blank">Overrides section</a> on the <a href="https://github.com/kolodny/safetest/blob/main/README.md" rel="noopener ugc nofollow" target="_blank">README</a>.</p><p id="9159">SafeTest comes out of the box with powerful reporting capabilities, such as automatic linking of video replays, Playwright trace viewer, and even <a href="https://safetest-two.vercel.app/vite-react-ts/?test_path=.%2FAnother.safetest&amp;test_name=Main2+can+do+many+interactions+fast" rel="noopener ugc nofollow" target="_blank">deep link directly to the mounted tested component</a>. The SafeTest repo <a href="https://github.com/kolodny/safetest/blob/main/README.md" rel="noopener ugc nofollow" target="_blank">README</a> links to all the <a href="https://safetest-two.vercel.app/" rel="noopener ugc nofollow" target="_blank">example apps</a> as well as the <a href="https://safetest-two.vercel.app/report.html#results=vite-react-ts/artifacts/results.json&amp;url=vite-react-ts/" rel="noopener ugc nofollow" target="_blank">reports</a></p><figure><div role="button" tabindex="0"><div><picture><source srcset="https://miro.medium.com/v2/resize:fit:640/format:webp/1*OFmV3PX7Is8X48-V9ryeig.png 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/1*OFmV3PX7Is8X48-V9ryeig.png 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/1*OFmV3PX7Is8X48-V9ryeig.png 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/1*OFmV3PX7Is8X48-V9ryeig.png 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/1*OFmV3PX7Is8X48-V9ryeig.png 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/1*OFmV3PX7Is8X48-V9ryeig.png 1100w, https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFmV3PX7Is8X48-V9ryeig.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/v2/resize:fit:640/1*OFmV3PX7Is8X48-V9ryeig.png 640w, https://miro.medium.com/v2/resize:fit:720/1*OFmV3PX7Is8X48-V9ryeig.png 720w, https://miro.medium.com/v2/resize:fit:750/1*OFmV3PX7Is8X48-V9ryeig.png 750w, https://miro.medium.com/v2/resize:fit:786/1*OFmV3PX7Is8X48-V9ryeig.png 786w, https://miro.medium.com/v2/resize:fit:828/1*OFmV3PX7Is8X48-V9ryeig.png 828w, https://miro.medium.com/v2/resize:fit:1100/1*OFmV3PX7Is8X48-V9ryeig.png 1100w, https://miro.medium.com/v2/resize:fit:1400/1*OFmV3PX7Is8X48-V9ryeig.png 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px"/><img alt="Image of SafeTest report showing a video of a test run" width="700" height="565" loading="lazy"/></picture></div></div></figure><p id="b09e">Many large corporations need a form of authentication to use the app. Typically, navigating to localhost:3000 just results in a perpetually loading page. You need to go to a different port, like localhost:8000, which has a proxy server to check and/or inject auth credentials into underlying service calls. This limitation is one of the main reasons that Cypress/Playwright Component Tests aren’t suitable for use at Netflix.</p><p id="cff2">However, there’s usually a service that can generate test users whose credentials we can use to log in and interact with the application. This facilitates creating a light wrapper around SafeTest to automatically generate and assume that test user. For instance, here’s basically how we do it at Netflix:</p><pre><span id="d4d4">import { setup } from &#39;safetest/setup&#39;;</span></pre><p id="0c05">After setting this up, we simply import the above package in place of where we would have used safetest/setup.</p><p id="e8be">While this post focused on how SafeTest works with React, it’s not limited to just React. SafeTest also works with Vue, Svelte, Angular, and even can run on NextJS or Gatsby. It also runs using either Jest or Vitest based on which test runner your scaffolding started you off with. The <a href="https://github.com/kolodny/safetest/tree/main/examples" rel="noopener ugc nofollow" target="_blank">examples folder</a> demonstrates how to use SafeTest with different tooling combinations, and we encourage contributions to add more cases.</p><p id="c359">At its core, SafeTest is an intelligent glue for a test runner, a UI library, and a browser runner. Though the most common usage at Netflix employs Jest/React/Playwright, it’s easy to add more adapters for other options.</p><p id="1420">SafeTest is a powerful testing framework that’s being adopted within Netflix. It allows for easy authoring of tests and provides comprehensive reports when and how any failures occurred, complete with links to view a playback video or manually run the test steps to see what broke. We’re excited to see how it will revolutionize UI testing and look forward to your feedback and contributions.</p></div></div></div></div></section></div>
  </body>
</html>
