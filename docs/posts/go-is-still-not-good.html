<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.habets.se/2025/07/Go-is-still-not-good.html">Original</a>
    <h1>Go is still not good</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">


  

  <div itemprop="articleBody">
    <p>Previous posts <a href="https://blog.habets.se/2013/10/Why-Go-is-not-my-favourite-language.html">Why Go is not my favourite language</a> and <a href="https://blog.habets.se/2022/02/Go-programs-are-not-portable.html">Go programs
are not portable</a> have me critiquing Go for over a decade.</p>

<p>These things about Go are bugging me more and more. Mostly because they’re so
unnecessary. The world knew better, and yet Go was created the way it was.</p>

<p>For readers of previous posts you’ll find some things repeated here. Sorry
about that.</p>

<h2 id="error-variable-scope-is-forced-to-be-wrong">Error variable scope is forced to be wrong</h2>

<p>Here’s an example of the language forcing you to do the wrong thing. It’s very
helpful for the reader of code (and code is read more often than it’s written),
to minimize the scope of a variable. If by mere syntax you can tell the reader
that a variable is just used in these two lines, then that’s a good thing.</p>

<p>Example:</p>

<div><pre><code><span>if</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>foo</span><span>();</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span>
   </span><span>return</span><span> </span><span>err</span><span>
</span><span>}</span><span>
</span></code></pre>
</div>

<p>(enough has been said about this verbose repeated boilerplate that I don’t have
to. I also don’t particularly care)</p>

<p>So that’s fine. The reader knows <code>err</code> is here and only here.</p>

<p>But then you encounter this:</p>

<div><pre><code><span>bar</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>foo</span><span>()</span><span>
</span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span>
  </span><span>return</span><span> </span><span>err</span><span>
</span><span>}</span><span>
</span><span>if</span><span> </span><span>err</span><span> </span><span>=</span><span> </span><span>foo2</span><span>();</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span>
  </span><span>return</span><span> </span><span>err</span><span>
</span><span>}</span><span>
</span><span>[</span><span>…</span><span> </span><span>a</span><span> </span><span>lot</span><span> </span><span>of</span><span> </span><span>code</span><span> </span><span>below</span><span> </span><span>…</span><span>]</span><span>
</span></code></pre>
</div>

<p>Wait, what? Why is <code>err</code> reused for <code>foo2()</code>? Is there’s something subtle I’m
not seeing? Even if we change that to <code>:=</code>, we’re left to wonder why <code>err</code> is
in scope for (potentially) the rest of the function. Why? Is it read later?</p>

<p>Especially when looking for bugs, an experienced coder will see these things
and slow down, because here be dragons. Ok, now I’ve wasted a couple of seconds
on the red herring of reusing <code>err</code> for <code>foo2()</code>.</p>

<p>Is a bug perhaps that the function ends with this?</p>

<div><pre><code><span>// Return foo99() error. (oops, that&#39;s not what we&#39;re doing)</span><span>
</span><span>foo99</span><span>()</span><span>
</span><span>return</span><span> </span><span>err</span><span> </span><span>// This is `err` from way up there in the foo() call.</span><span>
</span></code></pre>
</div>

<p>Why does the scope of <code>err</code> extend way beyond where it’s relevant?</p>

<p>The code would have been so much easier to read if only <code>err</code>’s scope had been
smaller. But that’s not syntactically possible in Go.</p>

<p>This was not thought through. Deciding on this was not thinking, it was typing.</p>

<h2 id="two-types-of-nil">Two types of nil</h2>

<p>Look at this nonsense:</p>

<div><pre><code><span>package</span><span> </span><span>main</span><span>
</span><span>import</span><span> </span><span>&#34;fmt&#34;</span><span>
</span><span>type</span><span> </span><span>I</span><span> </span><span>interface</span><span>{}</span><span>
</span><span>type</span><span> </span><span>S</span><span> </span><span>struct</span><span>{}</span><span>
</span><span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span>
    </span><span>var</span><span> </span><span>i</span><span> </span><span>I</span><span>
    </span><span>var</span><span> </span><span>s</span><span> </span><span>*</span><span>S</span><span>
    </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>s</span><span>,</span><span> </span><span>i</span><span>)</span><span> </span><span>// nil nil</span><span>
    </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>s</span><span> </span><span>==</span><span> </span><span>nil</span><span>,</span><span> </span><span>i</span><span> </span><span>==</span><span> </span><span>nil</span><span>,</span><span> </span><span>s</span><span> </span><span>==</span><span> </span><span>i</span><span>)</span><span> </span><span>// t,t,f: They&#39;re equal, but they&#39;re not.</span><span>
    </span><span>i</span><span> </span><span>=</span><span> </span><span>s</span><span>
    </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>s</span><span>,</span><span> </span><span>i</span><span>)</span><span> </span><span>// nil nil</span><span>
    </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>s</span><span> </span><span>==</span><span> </span><span>nil</span><span>,</span><span> </span><span>i</span><span> </span><span>==</span><span> </span><span>nil</span><span>,</span><span> </span><span>s</span><span> </span><span>==</span><span> </span><span>i</span><span>)</span><span> </span><span>// t,f,t: They are not equal, but they are.</span><span>
</span><span>}</span><span>
</span></code></pre>
</div>

<p>Go was not satisfied with one <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">billion dollar
mistake</a>,
so they decided to have <strong>two</strong> flavors of <code>NULL</code>.</p>

<p>“What color is your nil?” — The two billion dollar mistake.</p>

<p>The reason for the difference boils down to again, not thinking, just typing.</p>

<h2 id="its-not-portable">It’s not portable</h2>

<p>Adding comment near the top of the file for conditional compilation must be the
dumbest thing ever. Anybody who’s actually tried to maintain a portable program
will tell you this will only cause suffering.</p>

<p>It’s an <a href="https://en.wikipedia.org/wiki/Aristotelian_physics">Aristotle way of the science</a> of designing a language; lock
yourself up in a room, and never test your hypotheses against reality.</p>

<p>The problem is that this is not year 350 BCE. We actually have experience that
aside from air resistance, heavy and light objects actually fall at the same
speed. And we have experience with portable programs, and would not do
something this dumb.</p>

<p>If this had been the year 350 BCE, then this could be forgiven. Science as we
know it hadn’t been invented yet. But this is after decades of very widely
available experience in portability.</p>

<p>More details in <a href="https://blog.habets.se/2022/02/Go-programs-are-not-portable.html">this post</a>.</p>

<h2 id="append-with-no-defined-ownership"><code>append</code> with no defined ownership</h2>

<p>What does this print?</p>

<div><pre><code><span>package</span><span> </span><span>main</span><span>
</span><span>import</span><span> </span><span>&#34;fmt&#34;</span><span>
</span><span>func</span><span> </span><span>foo</span><span>(</span><span>a</span><span> </span><span>[]</span><span>string</span><span>)</span><span> </span><span>{</span><span>
    </span><span>a</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>a</span><span>,</span><span> </span><span>&#34;NIGHTMARE&#34;</span><span>)</span><span>
</span><span>}</span><span>
</span><span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span>
    </span><span>a</span><span> </span><span>:=</span><span> </span><span>[]</span><span>string</span><span>{</span><span>&#34;hello&#34;</span><span>,</span><span> </span><span>&#34;world&#34;</span><span>,</span><span> </span><span>&#34;!&#34;</span><span>}</span><span>
    </span><span>foo</span><span>(</span><span>a</span><span>[</span><span>:</span><span>1</span><span>])</span><span>
    </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>a</span><span>)</span><span>
</span><span>}</span><span>
</span></code></pre>
</div>

<p>Probably <code>[hello NIGHTMARE !]</code>. Who wants that? Nobody wants that.</p>

<p>Ok, how about this?</p>

<div><pre><code><span>package</span><span> </span><span>main</span><span>
</span><span>import</span><span> </span><span>&#34;fmt&#34;</span><span>
</span><span>func</span><span> </span><span>foo</span><span>(</span><span>a</span><span> </span><span>[]</span><span>string</span><span>)</span><span> </span><span>{</span><span>
    </span><span>a</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>a</span><span>,</span><span> </span><span>&#34;BACON&#34;</span><span>,</span><span> </span><span>&#34;THIS&#34;</span><span>,</span><span> </span><span>&#34;SHOULD&#34;</span><span>,</span><span> </span><span>&#34;WORK&#34;</span><span>)</span><span>
</span><span>}</span><span>
</span><span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span>
    </span><span>a</span><span> </span><span>:=</span><span> </span><span>[]</span><span>string</span><span>{</span><span>&#34;hello&#34;</span><span>,</span><span> </span><span>&#34;world&#34;</span><span>,</span><span> </span><span>&#34;!&#34;</span><span>}</span><span>
    </span><span>foo</span><span>(</span><span>a</span><span>[</span><span>:</span><span>1</span><span>])</span><span>
    </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>a</span><span>)</span><span>
</span><span>}</span><span>
</span></code></pre>
</div>

<p>If you guessed <code>[hello world !]</code>, then you know more than anybody should have
to know about quirks of a stupid programming language.</p>

<h2 id="defer-is-dumb"><code>defer</code> is dumb</h2>

<p>Even in a GC language, sometimes you just can’t wait to destroy a resource. It
really does need to run as we leave the local code, be it by normal return, or
via an exception (aka panic).</p>

<p>What we clearly want is RAII, or something like it.</p>

<p>Java has it:</p>

<div><pre><code><span>try</span> <span>(</span><span>MyResource</span> <span>r</span> <span>=</span> <span>new</span> <span>MyResource</span><span>())</span> <span>{</span>
  <span>/*
  work with resource r, which will be cleaned up when the scope ends via
  .close(), not merely when the GC feels like it.
  */</span>
<span>}</span>
</code></pre>
</div>

<p>Python has it. Though Python is <em>almost</em> entirely refcounted, so one can pretty
much rely on the <code>__del__</code> finalizer being called. But if it’s important, then
there’s the <code>with</code> syntax.</p>

<div><pre><code><span>with</span> <span>MyResource</span><span>()</span> <span>as</span> <span>res</span><span>:</span>
  <span># some code. At end of the block __exit__ will be called on res.</span>
</code></pre>
</div>

<p>Go? Go makes you go read the manual and see if this particular resource needs
to have a defer function called on it, and which one.</p>

<div><pre><code><span>foo</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>myResource</span><span>()</span><span>
</span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span>
  </span><span>return</span><span> </span><span>err</span><span>
</span><span>}</span><span>
</span><span>defer</span><span> </span><span>foo</span><span>.</span><span>Close</span><span>()</span><span>
</span></code></pre>
</div>

<p>This is so dumb. Some resources need a defer destroy. Some don’t. Which ones?
Good fucking luck.</p>

<p>And you also regularly end up with stuff like this monstrosity:</p>

<div><pre><code><span>f</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>openFile</span><span>()</span><span>
</span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span>
  </span><span>return</span><span> </span><span>nil</span><span>,</span><span> </span><span>err</span><span>
</span><span>}</span><span>
</span><span>defer</span><span> </span><span>f</span><span>.</span><span>Close</span><span>()</span><span>
</span><span>if</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>f</span><span>.</span><span>Write</span><span>(</span><span>something</span><span>());</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span>
  </span><span>return</span><span> </span><span>nil</span><span>,</span><span> </span><span>err</span><span>
</span><span>}</span><span>
</span><span>if</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>f</span><span>.</span><span>Close</span><span>();</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span>
  </span><span>return</span><span> </span><span>nil</span><span>,</span><span> </span><span>err</span><span>
</span><span>}</span><span>
</span></code></pre>
</div>

<p>Yes, this is what you NEED to do to safely write something to a file in Go.</p>

<p>What’s this, a <em>second</em> <code>Close()</code>? Oh yeah, of course that’s needed. Is it even
safe to double-close, or does my defer need to check for that? It happens to be
safe on <code>os.File</code>, but on other things: WHO KNOWS?!</p>

<h2 id="the-standard-library-swallows-exceptions-so-all-hope-is-lost">The standard library swallows exceptions, so all hope is lost</h2>

<p>(Largely a repeat of part of <a href="https://blog.habets.se/2013/10/Why-Go-is-not-my-favourite-language.html">a previous post</a>)</p>

<p>Go says it doesn’t have exceptions. Go makes it extremely awkward to use
exceptions, because they want to punish programmers who use them.</p>

<p>Ok, fine so far.</p>

<p>But all Go programmers must still write exception safe code. Because while
<em>they</em> don’t use exceptions, other code will. Things will panic.</p>

<p>So you need, not should, NEED, to write code like:</p>

<div><pre><code><span>func</span><span> </span><span>(</span><span>f</span><span> </span><span>*</span><span>Foo</span><span>)</span><span> </span><span>foo</span><span>()</span><span> </span><span>{</span><span>
    </span><span>f</span><span>.</span><span>mutex</span><span>.</span><span>Lock</span><span>()</span><span>
    </span><span>defer</span><span> </span><span>f</span><span>.</span><span>mutex</span><span>.</span><span>Unlock</span><span>()</span><span>
    </span><span>f</span><span>.</span><span>bar</span><span>()</span><span>
</span><span>}</span><span>
</span></code></pre>
</div>

<p>What is this stupid middle endian system? That’s dumb just like putting the day
in the middle of a date is dumb. MMDDYY, honestly? (separate rant)</p>

<p>But panic will terminate the program, they say, so why do you care if you
unlock a mutex five milliseconds before it exits anyway?</p>

<p>Because what if something swallows that exception and carries on as normal, and
you’re now stuck with a locked mutex?</p>

<p>But surely nobody would do that? Reasonable and strict coding standards would
surely prevent it, under penalty of being fired?</p>

<p>The standard library does that. <code>fmt.Print</code> when calling <code>.String()</code>, and the
standard library HTTP server does that, for exceptions in the HTTP handlers.</p>

<p>All hope is lost. You MUST write exception safe code. But you can’t use
exceptions. You can only have the downsides of exceptions be thrust upon you.</p>

<p>Don’t let them gaslight you.</p>

<h2 id="sometimes-things-arent-utf-8">Sometimes things aren’t UTF-8</h2>

<p>If you stuff random binary data into a <code>string</code>, Go just steams along, as
described <a href="https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride">in this post</a>.</p>

<p>Over the decades I have lost data to tools skipping non-UTF-8 filenames. I
should not be blamed for having files that were named before UTF-8 existed.</p>

<p>Well… I had them. They’re gone now. They were silently skipped in a
backup/restore.</p>

<p>Go wants you to continue losing data. Or at least, when you lose data, it’ll
say “well, what (encoding) was the data wearing?”.</p>

<p>Or how about you just do something more thought through, when you design a
language? How about doing the right thing, instead of the obviously wrong
simple thing?</p>

<h2 id="memory-use">Memory use</h2>

<p>Why do I care about memory use? RAM is cheap. Much cheaper than the time it
takes to read this blog post. I care because my service runs on a cloud
instance where you actually pay for RAM. Or you run containers, and you want to
run a thousand of them on the same machine. Your data may <a href="https://yourdatafitsinram.net/">fit in
RAM</a>, but it’s still expensive if you have to
give your thousand containers 4TiB of RAM instead of 1TiB.</p>

<p>You can manually trigger a GC run with <code>runtime.GC()</code>, but “oh no don’t do
that”, they say, “it’ll run when it has to, just trust it”.</p>

<p>Yeah, 90% of the time, that works every time. But then it doesn’t.</p>

<p>I rewrote some stuff in another language because over time the Go version would
use more and more memory.</p>

<h2 id="it-didnt-have-to-be-this-way">It didn’t have to be this way</h2>

<p>We knew better. This was not the COBOL debate over whether to use symbols or
English words.</p>

<p>And it’s not like when we didn’t know at the time that <a href="https://blog.habets.se/2022/08/Java-a-fractal-of-bad-experiments.html">Java’s ideas were
bad</a>, because we did know Go’s ideas were bad.</p>

<p>We already knew better than Go, and yet now we’re stuck with bad Go codebases.</p>

<h2 id="other-peoples-posts">Other people’s posts</h2>

<ul>
  <li>https://www.uber.com/en-GB/blog/data-race-patterns-in-go/</li>
  <li>https://fasterthanli.me/articles/lies-we-tell-ourselves-to-keep-using-golang</li>
  <li>https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride</li>
</ul>


  </div>

  
  
  
  
  
  
</article>

      </div>
    </div></div>
  </body>
</html>
