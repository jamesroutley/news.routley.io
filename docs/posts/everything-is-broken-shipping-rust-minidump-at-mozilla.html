<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hacks.mozilla.org/2022/06/everything-is-broken-shipping-rust-minidump-at-mozilla/">Original</a>
    <h1>Everything Is Broken: Shipping Rust-Minidump at Mozilla</h1>
    
    <div id="readability-page-1" class="page"><article role="article">
    
<p>For the last year I‚Äôve been leading the development of <a href="https://github.com/luser/rust-minidump/">rust-minidump</a>, a pure-Rust replacement for the minidump-processing half of <a href="https://chromium.googlesource.com/breakpad/breakpad/">google-breakpad</a>.</p>
<p>Well actually in some sense I <em>finished</em> that work, because Mozilla already <a href="https://github.com/luser/rust-minidump/tree/master/minidump-stackwalk">deployed it</a> as <a href="https://crash-stats.mozilla.org/">the crash processing backend for Firefox</a> 6 months ago, it runs in half the time, and seems to be more reliable. (And you know, <em>isn‚Äôt</em> a terrifying ball of C++ that parses and evaluates arbitrary input from the internet. We did our best to isolate Breakpad, but still‚Ä¶ <em>yikes</em>.)</p>
<p>This is a pretty fantastic result, but there‚Äôs always more work to do because <em>Minidumps are an inky abyss that grows deeper the further you delve‚Ä¶</em> wait no I‚Äôm getting ahead of myself. First the light, then the abyss. Yes. Light first.</p>
<p>What I <em>can</em> say is that we have a very solid implementation of the core functionality of minidump parsing+analysis for the biggest platforms (x86, x64, ARM, ARM64; Windows, MacOS, Linux, Android). But if you want to read minidumps generated on a <em>PlayStation 3</em> or process a <em>Full Memory</em> dump, you won‚Äôt be served quite as well.</p>
<p>We‚Äôve put a lot of effort into documenting and testing this thing, so I‚Äôm pretty confident in it!</p>
<p><strong>Unfortunately! Confidence! Is! Worth! Nothing!</strong></p>
<p>Which is why this is the story of how we did our best to make this nightmare as robust as we could and still got 360 dunked on from space by the sudden and <em>incredible</em> fuzzing efforts of <a href="https://github.com/5225225">@5225225</a>.</p>
<p>This article is broken into two parts:</p>
<ol>
<li>what minidumps are, and how we made rust-minidump</li>
<li>how we got absolutely owned by simple fuzzing</li>
</ol>
<p>You are reading part 1, wherein we build up our hubris.</p>

<p>Your program crashes. You want to know why your program crashed, but it happened on a user‚Äôs machine on the other side of the world. A full coredump (all memory allocated by the program) is enormous ‚Äî we can‚Äôt have users sending us 4GB files! Ok let‚Äôs just collect up the most important regions of memory like the stacks and where the program crashed. Oh and I guess if we‚Äôre taking the time, let‚Äôs stuff some metadata about the system and process in there too.</p>
<p>Congratulations you have invented <a href="https://docs.microsoft.com/en-us/windows/win32/debug/minidump-files">Minidumps</a>. Now you can turn a 100-thread coredump that would otherwise be 4GB into a nice little 2MB file that you can send over the internet and do postmortem analysis on.</p>
<p>Or more specifically, Microsoft did. So long ago that their docs don‚Äôt even discuss platform support. MiniDumpWriteDump‚Äôs supported versions are simply ‚ÄúWindows‚Äù. Microsoft Research has presumably developed a time machine to guarantee this.</p>
<p>Then Google came along (circa 2006-2007) and said ‚Äúwouldn‚Äôt it be nice if we could make minidumps on <em>any</em> platform‚Äù? Thankfully Microsoft had actually built the format pretty extensibly, so it wasn‚Äôt too bad to extend the format for Linux, MacOS, BSD, Solaris, and so on. Those extensions became <a href="https://chromium.googlesource.com/breakpad/breakpad/">google-breakpad</a> (or just Breakpad) which included a ton of different tools for generating, parsing, and analyzing their extended minidump format (and native Microsoft ones).</p>
<p>Mozilla helped out with this a lot because apparently, our crash reporting infrastructure (‚ÄúTalkback‚Äù) was <em>miserable</em> circa 2007, and this seemed like a nice improvement. Needless to say, we‚Äôre pretty invested in breakpad‚Äôs minidumps at this point.</p>
<p>Fast forward to the present day and in a hilarious twist of fate, products like VSCode mean that Microsoft now supports applications that run on Linux and MacOS so it runs breakpad in production and has to handle non-Microsoft minidumps somewhere in its crash reporting infra, so someone else‚Äôs extension of their own format is somehow their problem now!</p>
<p>Meanwhile, Google has kind-of moved on to <a href="https://chromium.googlesource.com/crashpad/crashpad">Crashpad</a>. I say kind-of because there‚Äôs still a lot of Breakpad in there, but they‚Äôre more interested in building out tooling on top of it than improving Breakpad itself. Having made a few changes to Breakpad: <strong>honestly fair</strong>, I don‚Äôt want to work on it either. Still, this was a bit of a problem for us, because it meant the project became increasingly under-staffed.</p>
<p>By the time I started working on crash reporting, Mozilla had basically given up on upstreaming fixes/improvements to Breakpad, and was just using its own patched fork. But even <em>without</em> the need for upstreaming patches, every change to Breakpad filled us with dread: many proposed improvements to our crash reporting infrastructure stalled out at ‚Äútime to implement this in Breakpad‚Äù.</p>
<p>Why is working on Breakpad so miserable, you ask?</p>
<p>Parsing and analyzing minidumps is basically an exercise in writing a fractal parser of platform-specific formats nested in formats nested in formats. For many operating systems. For many hardware architectures. And all the inputs you‚Äôre parsing and analyzing are terrible and buggy so you <em>have</em> to write a really permissive parser and crawl forward however you can.</p>
<p>Some specific MSVC toolchain that was part of Windows XP had a bug in its debuginfo format? <strong>Too bad, symbolicate that stack frame anyway!</strong></p>
<p>The program crashed because it horribly corrupted its own stack? <strong>Too bad, produce a backtrace anyway!</strong></p>
<p>The minidump writer itself completely freaked out and wrote a bunch of garbage to one stream? <strong>Too bad, produce whatever output you can anyway!</strong></p>
<p>Hey, you know who has a lot of experience dealing with really complicated permissive parsers written in C++? Mozilla! That‚Äôs like <em>the core functionality</em> of a web browser.</p>
<p>Do you know Mozilla‚Äôs secret solution to writing really complicated permissive parsers in C++?</p>
<p><strong>We stopped doing it.</strong></p>
<p>We developed Rust and ported our nastiest parsers to it.</p>
<p>We‚Äôve done it a lot, and <a href="https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/">when we do</a> we‚Äôre always like <a href="https://www.joshmatthews.net/rbr17/">‚Äúwow this is so much more reliable and easy to maintain and it‚Äôs even faster now‚Äù</a>. Rust is a really good language for writing parsers. C++ really isn‚Äôt.</p>
<p>So we Rewrote It In Rust (or as the kids call it, ‚ÄúOxidized It‚Äù). Breakpad is big, so we haven‚Äôt actually covered all of its features. We‚Äôve specifically written and deployed:</p>
<ul>
<li><a href="https://github.com/mozilla/dump_syms">dump_syms</a> which processes native build artifacts into symbol files.</li>
<li><a href="https://github.com/luser/rust-minidump/">rust-minidump</a> which is a collection of crates that parse and analyze minidumps. Or more specifically, we deployed <a href="https://github.com/luser/rust-minidump/tree/master/minidump-stackwalk">minidump-stackwalk</a>, which is the high-level cli interface to all of rust-minidump.</li>
</ul>
<p>Notably missing from this picture is <em>minidump writing</em>, or what google-breakpad calls a <em>client</em> (because it runs on the client‚Äôs machine). We <em>are </em>working <a href="https://github.com/rust-minidump/minidump-writer">on a rust-based minidump writer</a>, but it‚Äôs not something we can recommend using quite yet (although it has sped up a lot thanks to help from <a href="https://embark.dev/">Embark Studios</a>).</p>
<p>This is arguably the messiest and hardest work because it has a horrible job: use a bunch of native system APIs to gather up a bunch of OS-specific and Hardware-specific information about the crash AND do it for a program that just crashed, on a machine that <em>caused </em>the program to crash.</p>
<p>We have a long road ahead but every time we get to the other side of one of these projects it‚Äôs <em>wonderful</em>.</p>


<p>One of rust-minidump‚Äôs (<a href="https://github.com/luser/rust-minidump/tree/master/minidump-stackwalk">minidump-stackwalk‚Äôs</a>) most important jobs is to take the state for a thread (general purpose registers and stack memory) and create a backtrace for that thread (unwind/stackwalk). This is a surprisingly complicated and messy job, made only more complicated by the fact that <em>we are trying to analyze the memory of a process that got messed up enough to crash</em>.</p>
<p>This means our stackwalkers are inherently working with dubious data, and all of our stackwalking techniques are based on heuristics that can go wrong and we can very easily find ourselves in situations where the stackwalk goes backwards or sideways or infinite and we just have to try to deal with it!</p>
<p>It‚Äôs also pretty common to see a stackwalker start <em>hallucinating</em>, which is my term for ‚Äúthe stackwalker found something that looked plausible enough and went on a wacky adventure through the stack and made up a whole pile of useless garbage frames‚Äù. Hallucination is most common near the bottom of the stack where it‚Äôs also least offensive. This is because each frame you walk is another chance for something to go wrong, but also increasingly uninteresting because you‚Äôre rarely interested in confirming that a thread started in The Same Function All Threads Start In.</p>
<p>All of these problems would basically go away if everyone agreed to properly preserve their cpu‚Äôs <a href="https://gankra.github.io/blah/compact-unwinding/#frame-pointer-unwinding-standard-prologues">PERFECTLY GOOD DEDICATED FRAME POINTER REGISTER</a>. Just kidding, turning on frame pointers doesn‚Äôt really work either because Microsoft <a href="https://github.com/rust-lang/rust/issues/82333">invented chaos frame pointers</a> that can‚Äôt be used for unwinding! I assume this happened because they accidentally stepped on the wrong butterfly while they were traveling back in time to invent minidumps. (I‚Äôm sure it was a decision that made more sense 20 years ago, but it has not aged well.)</p>
<p>If you would like to learn more about the different techniques for unwinding, <a href="https://gankra.github.io/blah/compact-unwinding/#background-unwinding-and-debug-info">I wrote about them over here</a> in my <a href="https://gankra.github.io/blah/compact-unwinding">article on Apple‚Äôs Compact Unwind Info</a>. I‚Äôve also attempted to <a href="https://docs.rs/breakpad-symbols/latest/breakpad_symbols/walker/index.html">document breakpad‚Äôs STACK WIN and STACK CFI unwind info formats here</a>, which are more similar to the¬† DWARF and PE32 unwind tables (which are basically tiny programming languages).</p>
<p>If you would like to learn more about ABIs in general, <a href="https://gankra.github.io/blah/rust-layouts-and-abis/#calling-conventions">I wrote an entire article about them here</a>. The end of that article also includes an <a href="https://gankra.github.io/blah/rust-layouts-and-abis/#calling-conventions">introduction to how calling conventions work</a>. Understanding calling conventions is key to implementing unwinders.</p>

<p><strong>How Hard Did You Really Test Things?</strong></p>
<p>Hopefully you now have a bit of a glimpse into why analyzing minidumps is an enormous headache. And of course you know how the story ends: that fuzzer kicks our butts! But of course to really savor our defeat, you have to see how hard we tried to do a good job! It‚Äôs time to build up our hubris and pat ourselves on the back.</p>
<p>So how much work <em>actually</em> went into making rust-minidump robust before the fuzzer went to work on it?</p>
<p>Quite a bit!</p>
<p>I‚Äôll never argue all the work we did was <em>perfect</em> but we definitely did some good work here, both for synthetic inputs and real world ones. Probably the biggest ‚Äúflaw‚Äù in our methodology was the fact that we were only focused on getting Firefox‚Äôs usecase to work. Firefox runs on a lot of platforms and sees a lot of messed up stuff, but it‚Äôs still a fairly coherent product that only uses so many features of minidumps.</p>
<p>This is one of the nice benefits of our recent work with <a href="https://sentry.io/">Sentry</a>, which is basically a Crash Reporting As A Service company. They are <em>way</em> more liable to stress test all kinds of weird corners of the format that Firefox doesn‚Äôt, and they have definitely found (and fixed!) some places where something is wrong or missing! (And they recently deployed it into production too! üéâ)</p>
<p>But hey don‚Äôt take my word for it, check out all the different testing we did:</p>
<h2><strong>Synthetic Minidumps for Unit Tests</strong></h2>
<p>rust-minidump includes a <a href="https://github.com/rust-minidump/rust-minidump/tree/553735e2624dcc6af82167f502cf92ae9a9fdc87/minidump-synth">synthetic minidump generator</a> which lets you come up with a high-level description of the contents of a minidump, and then produces an actual minidump binary that we can feed it into the full parser:</p>
<p>// Let‚Äôs make a synth minidump with this particular Crashpad Info‚Ä¶</p>
<pre>let module = ModuleCrashpadInfo::new(42, Endian::Little)
    .add_list_annotation(&#34;annotation&#34;)
    .add_simple_annotation(&#34;simple&#34;, &#34;module&#34;)
    .add_annotation_object(&#34;string&#34;, AnnotationValue::String(&#34;value&#34;.to_owned()))
    .add_annotation_object(&#34;invalid&#34;, AnnotationValue::Invalid)
    .add_annotation_object(&#34;custom&#34;, AnnotationValue::Custom(0x8001, vec![42]));

let crashpad_info = CrashpadInfo::new(Endian::Little)
    .add_module(module)
    .add_simple_annotation(&#34;simple&#34;, &#34;info&#34;);

let dump = SynthMinidump::with_endian(Endian::Little).add_crashpad_info(crashpad_info);

// convert the synth minidump to binary and read it like a normal minidump
let dump = read_synth_dump(dump).unwrap();</pre>
<p>// Now check that the minidump reports the values we expect‚Ä¶</p>
<p>minidump-synth intentionally avoids sharing layout code with the actual implementation so that incorrect changes to layouts won‚Äôt ‚Äúaccidentally‚Äù pass tests.</p>
<p><em>A brief aside for some history</em>: this testing framework was started by the original lead on this project, <a href="https://twitter.com/TedMielczarek">Ted Mielczarek</a>. He started rust-minidump as a side project to learn Rust when 1.0 was released and just never had the time to finish it. Back then he was working at Mozilla and also a major contributor to Breakpad, which is why rust-minidump has a lot of similar design choices and terminology.</p>
<p>This case is no exception: our minidump-synth is a shameless copy of the <a href="https://chromium.googlesource.com/breakpad/breakpad/+/refs/heads/main/src/processor/synth_minidump.cc">synth-minidump utility in breakpad‚Äôs code</a>, which was originally written by our <em>other</em> coworker <a href="https://www.red-bean.com/~jimb/">Jim Blandy</a>. Jim is one of the only people in the world that I will actually admit writes really good tests and docs, so I am totally happy to blatantly copy his work here.</p>
<p>Since this was all a learning experiment, Ted was understandably less rigorous about testing than usual. This meant a lot of minidump-synth was unimplemented when I came along, which also meant lots of minidump features were completely untested. (He built an absolutely great skeleton, just hadn‚Äôt had the time to fill it all in!)</p>
<p>We spent <em>a lot</em> of time filling in more of minidump-synth‚Äôs implementation so we could write more tests and catch more issues, but this is <em>definitely</em> the weakest part of our tests. Some stuff was implemented before I got here, so I don‚Äôt even <em>know</em> what tests are missing!</p>
<p>This is a good argument for some code coverage checks, but it would probably come back with ‚Äúwow you should write a lot more tests‚Äù and we would all look at it and go ‚Äúwow we sure should‚Äù and then we would probably never get around to it, because there are <em>many</em> things we <em>should</em> do.</p>
<p>On the other hand, Sentry has been very useful in this regard because they already <em>have</em> a mature suite of tests full of weird corner cases they‚Äôve built up over time, so they can easily identify things that really matter, know what the fix should roughly be, and can contribute pre-existing test cases!</p>
<h2><strong>Integration and Snapshot Tests</strong></h2>
<p>We tried our best to shore up coverage issues in our unit tests by adding more holistic tests. There‚Äôs a few checked in Real Minidumps that we have <a href="https://github.com/luser/rust-minidump/blob/40c3390f5705890f932f78b7db4fc02866e012b8/minidump-processor/tests/test_processor.rs">some integration tests for</a> to make sure we handle Real Inputs properly.</p>
<p>We even wrote a bunch of <a href="https://github.com/luser/rust-minidump/blob/40c3390f5705890f932f78b7db4fc02866e012b8/minidump-stackwalk/tests/test-minidump-stackwalk.rs">integration tests for the CLI application that snapshot its output</a> to confirm that we never <em>accidentally</em> change the results.</p>
<p>Part of the motivation for this is to ensure we don‚Äôt break the JSON output, which we also wrote a <a href="https://github.com/luser/rust-minidump/blob/40c3390f5705890f932f78b7db4fc02866e012b8/minidump-processor/json-schema.md">very detailed schema document for</a> and are trying to keep stable so people can actually rely on it while the actual implementation details are still in flux.</p>
<p>Yes, <a href="https://github.com/luser/rust-minidump/tree/master/minidump-stackwalk">minidump-stackwalk</a> is supposed to be stable and reasonable to use in production!</p>
<p>For our snapshot tests we use <a href="https://github.com/mitsuhiko/insta">insta</a>, which I think is fantastic and more people should use. All you need to do is assert_snapshot! any output you want to keep track of and it will magically take care of the storing, loading, and diffing.</p>
<p>Here‚Äôs one of the snapshot tests where we invoke the CLI interface and snapshot stdout:</p>
<pre>#[test]
fn test_evil_json() {
    // For a while this didn&#39;t parse right
    let bin = env!(&#34;CARGO_BIN_EXE_minidump-stackwalk&#34;);
    let output = Command::new(bin)
        .arg(&#34;--json&#34;)
        .arg(&#34;--pretty&#34;)
        .arg(&#34;--raw-json&#34;)
        .arg(&#34;../testdata/evil.json&#34;)
        .arg(&#34;../testdata/test.dmp&#34;)
        .arg(&#34;../testdata/symbols/&#34;)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output()
        .unwrap();

    let stdout = String::from_utf8(output.stdout).unwrap();
    let stderr = String::from_utf8(output.stderr).unwrap();

    assert!(output.status.success());
    insta::assert_snapshot!(&#34;json-pretty-evil-symbols&#34;, stdout);
    assert_eq!(stderr, &#34;&#34;);
}

</pre>
<h2><b>Stackwalker Unit Testing</b></h2>
<p>The stackwalker is easily the most complicated and subtle part of the new implementation, because every platform can have <em>slight</em> quirks and you need to implement several different unwinding strategies and carefully tune everything to work well <em>in practice</em>.</p>
<p>The scariest part of this was the call frame information (CFI) unwinders, because they are basically little virtual machines we need to parse and execute at runtime. Thankfully breakpad had long ago smoothed over this issue by defining a simplified and unified CFI format, STACK CFI (well, nearly unified, x86 Windows was still a special case as STACK WIN). So even if DWARF CFI has a ton of complex features, we mostly need to implement a <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation Calculator</a> except it can read registers and load memory from addresses it computes (and for STACK WIN it has access to named variables it can declare and mutate).</p>
<p>Unfortunately, <a href="https://chromium.googlesource.com/breakpad/breakpad/+/master/docs/symbol_files.md">Breakpad‚Äôs description for this format is pretty underspecified</a> so I had to basically pick some semantics I thought made sense and go with that. This made me <em>extremely</em> paranoid about the implementation. (And yes I will be more first-person for this part, because this part was genuinely where I personally spent most of my time and did a lot of stuff from scratch. All the blame belongs to me here!)</p>
<p>The<a href="https://docs.rs/breakpad-symbols/latest/breakpad_symbols/walker/index.html"> STACK WIN / STACK CFI parser+evaluator</a> is 1700 lines. 500 of those lines are a detailed documentation and discussion of the format, and 700 of those lines are an enormous pile of ~80 test cases where I tried to come up with every corner case I could think of.</p>
<p>I even checked in two tests I <em>knew</em> were failing just to be honest that there were a couple cases to fix! One of them is a corner case involving dividing by a negative number that almost certainly just doesn‚Äôt matter. The other is a buggy input that old x86 Microsoft toolchains actually produce and parsers need to deal with. The latter was fixed before the fuzzing started.</p>
<p>And 5225225 <em>still</em> found an integer overflow in the STACK WIN preprocessing step! (Not actually that surprising, it‚Äôs a hacky mess that tries to cover up for how messed up x86 Windows unwinding tables were.)</p>
<p>(The code isn‚Äôt terribly interesting here, it‚Äôs just a ton of assertions that a given input string produces a given output/error.)</p>
<p>Of course, I wasn‚Äôt satisfied with just coming up with my own semantics and testing them: I also <a href="https://github.com/luser/rust-minidump/blob/master/minidump-processor/src/stackwalker/x86_unittest.rs">ported most of breakpad‚Äôs own stackwalker tests to rust-minidump</a>! This definitely found a bunch of bugs I had, but also taught me some weird quirks in Breakpad‚Äôs stackwalkers that I‚Äôm not sure I <em>actually</em> agree with. But in this case I was flying so blind that even being bug-compatible with Breakpad was some kind of relief.</p>
<p>Those tests also included several tests for the non-CFI paths, which were similarly wobbly and quirky. I still really hate a lot of the weird platform-specific rules they have for stack scanning, but I‚Äôm forced to work on the assumption that they might be load-bearing. (I definitely had several cases where I disabled a breakpad test because it was ‚Äúobviously nonsense‚Äù and then hit it in the wild while testing. I quickly learned to accept that <strong>Nonsense Happens And Cannot Be Ignored</strong>.)</p>
<p>One major thing I <em>didn‚Äôt</em> replicate was some of the really hairy hacks for STACK WIN. Like there are several places where they introduce extra stack-scanning to try to deal with the fact that stack frames can have mysterious extra alignment that the windows unwinding tables just don‚Äôt tell you about? I guess?</p>
<p>There‚Äôs almost certainly some exotic situations that rust-minidump does worse on because of this, but it probably also means we do better in some random other situations too. I never got the two to perfectly agree, but at some point the divergences were all in weird enough situations, and as far as I was concerned both stackwalkers were producing equally bad results in a bad situation. Absent any reason to prefer one over the other, divergence seemed acceptable to keep the implementation cleaner.</p>
<p>Here‚Äôs a simplified version of one of the ported breakpad tests, if you‚Äôre curious (thankfully minidump-synth is based off of the same binary data mocking framework these tests use):</p>
<pre>#[test]
fn test_x86_frame_pointer() {
    let mut f = TestFixture::new();
    let frame0_ebp = Label::new();
    let frame1_ebp = Label::new();
    let mut stack = Section::new();

    // Setup the stack and registers so frame pointers will work
    stack.start().set_const(0x80000000);
    stack = stack
        .append_repeated(12, 0) // frame 0: space
        .mark(&amp;frame0_ebp)      // frame 0 %ebp points here
        .D32(&amp;frame1_ebp)       // frame 0: saved %ebp
        .D32(0x40008679)        // frame 0: return address
        .append_repeated(8, 0)  // frame 1: space
        .mark(&amp;frame1_ebp)      // frame 1 %ebp points here
        .D32(0)                 // frame 1: saved %ebp (stack end)
        .D32(0);                // frame 1: return address (stack end)
    f.raw.eip = 0x4000c7a5;
    f.raw.esp = stack.start().value().unwrap() as u32;
    f.raw.ebp = frame0_ebp.value().unwrap() as u32;

    // Check the stackwalker&#39;s output:
    let s = f.walk_stack(stack).await;
    assert_eq!(s.frames.len(), 2);
    {
        let f0 = &amp;s.frames[0];
        assert_eq!(f0.trust, FrameTrust::Context);
        assert_eq!(f0.context.valid, MinidumpContextValidity::All);
        assert_eq!(f0.instruction, 0x4000c7a5);
    }
    {
        let f1 = &amp;s.frames[1];
        assert_eq!(f1.trust, FrameTrust::FramePointer);
        assert_eq!(f1.instruction, 0x40008678);
    }
}</pre>
<h2>A Dedicated Production Diffing, Simulating, and Debugging Tool</h2>
<p>Because minidumps are so horribly fractal and corner-casey, I spent <em>a lot</em> of time terrified of subtle issues that would become huge disasters if we ever actually tried to deploy to production. So I also spent a bunch of time building <a href="https://github.com/Gankra/socc-pair/">socc-pair</a>, which takes the id of a crash report from Mozilla‚Äôs <a href="https://crash-stats.mozilla.org/">crash reporting system</a> and pulls down the minidump, the old breakpad-based implementation‚Äôs output, and extra metadata.</p>
<p>It then runs a local rust-minidump (minidump-stackwalk) implementation on the minidump and does a domain-specific diff over the two inputs. The most substantial part of this is a fuzzy diff on the stackwalks that tries to better handle situations like when one implementation adds an extra frame but the two otherwise agree. It also uses the reported techniques each implementation used to try to identify whose output is more trustworthy when they totally diverge.</p>
<p>I also ended up adding a bunch of mocking and benchmarking functionality to it as well, as I found more and more places where I just wanted to simulate a production environment.</p>
<p>Oh also I added <a href="https://github.com/luser/rust-minidump/tree/master/minidump-stackwalk#debugging-stackwalking">really detailed trace-logging for the stackwalker</a> so that I could easily post-mortem debug why it made the decisions it made.</p>
<p>This tool found so many issues and more importantly has helped me quickly isolate their causes. I am so happy I made it. Because of it, we know we actually <em>fixed</em> several issues that happened with the old breakpad implementation, which is great!</p>
<p>Here‚Äôs a trimmed down version of the kind of report socc-pair would produce (yeah I abused diff syntax to get error highlighting. It‚Äôs a great hack, and I love it like a child):</p>
<pre>comparing json...

: {
    crash_info: {
        address: 0x7fff1760aca0
        crashing_thread: 8
        type: EXCEPTION_BREAKPOINT
    }
    crashing_thread: {
        frames: [
            0: {
                file: wrappers.cpp:1750da2d7f9db490b9d15b3ee696e89e6aa68cb7
                frame: 0
                function: RustMozCrash(char const*, int, char const*)
                function_offset: 0x00000010
-               did not match
+               line: 17
-               line: 20
                module: xul.dll

.....

    unloaded_modules: [
        0: {
            base_addr: 0x7fff48290000
-           local val was null instead of:
            code_id: 68798D2F9000
            end_addr: 0x7fff48299000
            filename: KBDUS.DLL
        }
        1: {
            base_addr: 0x7fff56020000
            code_id: DFD6E84B14000
            end_addr: 0x7fff56034000
            filename: resourcepolicyclient.dll
        }
    ]
~   ignoring field write_combine_size: &#34;0&#34;
}

- Total errors: 288, warnings: 39

benchmark results (ms):
    2388, 1986, 2268, 1989, 2353, 
    average runtime: 00m:02s:196ms (2196ms)
    median runtime: 00m:02s:268ms (2268ms)
    min runtime: 00m:01s:986ms (1986ms)
    max runtime: 00m:02s:388ms (2388ms)

max memory (rss) results (bytes):
    267755520, 261152768, 272441344, 276131840, 279134208, 
    average max-memory: 258MB (271323136 bytes)
    median max-memory: 259MB (272441344 bytes)
    min max-memory: 249MB (261152768 bytes)
    max max-memory: 266MB (279134208 bytes)

Output Files: 
    * (download) Minidump: b4f58e9f-49be-4ba5-a203-8ef160211027.dmp
    * (download) Socorro Processed Crash: b4f58e9f-49be-4ba5-a203-8ef160211027.json
    * (download) Raw JSON: b4f58e9f-49be-4ba5-a203-8ef160211027.raw.json
    * Local minidump-stackwalk Output: b4f58e9f-49be-4ba5-a203-8ef160211027.local.json
    * Local minidump-stackwalk Logs: b4f58e9f-49be-4ba5-a203-8ef160211027.log.txt</pre>
<h2><b>Staging and Deploying to Production</b></h2>
<p>Once we were confident enough in the implementation, a lot of the remaining testing was taken over by Will Kahn-Greene, who‚Äôs responsible for a lot of the server-side details of our crash-reporting infrastructure.</p>
<p>Will spent a bunch of time getting a bunch of machinery setup to manage the deployment and monitoring of rust-minidump. He also did a lot of the hard work of cleaning up all our server-side configuration scripts to handle any differences between the two implementations. (Although I spent a lot of time on compatibility, we both agreed this was a good opportunity to clean up old cruft and mistakes.)</p>
<p>Once all of this was set up, he turned it on in staging and we got our first look at how rust-minidump actually worked in ~production:</p>
<p><strong>Terribly!</strong></p>
<p>Our staging servers take in about 10% of the inputs that also go to our production servers, but even at that reduced scale we very quickly found several new corner cases and we were getting <em>tons</em> of crashes, which is mildly embarrassing for<em> the thing that handles other people‚Äôs crashes</em>.</p>
<p>Will did a great job here in monitoring and reporting the issues. Thankfully they were all fairly easy for us to fix. Eventually, everything smoothed out and things seemed to be working just as reliably as the old implementation on the production server. The only places where we were completely failing to produce any output were for horribly truncated minidumps that may as well have been empty files.</p>
<p>We originally <em>did</em> have some grand ambitions of running socc-pair on everything the staging servers processed or something to get <em>really</em> confident in the results. But by the time we got to that point, we were completely exhausted and feeling pretty confident in the new implementation.</p>
<p>Eventually Will just said ‚Äúlet‚Äôs turn it on in production‚Äù and I said ‚ÄúAAAAAAAAAAAAAAA‚Äù.</p>
<p>This moment was pure terror. There had always been <em>more</em> corner cases. There‚Äôs no way we could just be <em>done</em>. This will probably set all of Mozilla on fire and delete Firefox from the internet!</p>
<p>But Will convinced me. We wrote up some docs detailing all the subtle differences and sent them to everyone we could. Then the moment of truth finally came: Will turned it on in production, and I got to really see how well it worked in production:</p>
<p><em>*dramatic drum roll*</em></p>
<p>It worked fine.</p>
<p>After all that stress and anxiety, we turned it on and it was <em>fine</em>.</p>
<p>Heck, I‚Äôll say it: it ran <em>well</em>.</p>
<p>It was faster, it crashed less, and we even knew it fixed some issues.</p>
<p>I was in a bit of a stupor for the rest of that week, because I kept waiting for the other shoe to drop. I kept waiting for someone to emerge from the mist and explain that I had somehow bricked <em>Thunderbird</em> or something. But no, it just worked.</p>
<p>So we left for the holidays, and I kept waiting for it to break, but it was <em>still fine</em>.</p>
<p>I am honestly still shocked about this!</p>
<p>But hey, as it turns out we really did put a <em>lot</em> of careful work into testing the implementation. At every step we found new problems but that was <em>good</em>, because once we got to the final step there were no more problems to surprise us.</p>
<p><strong>And the fuzzer still kicked our butts afterwards.</strong></p>
<p>But that‚Äôs part 2! Thanks for reading!</p>

    <section>
                                
                                <p><a href="https://hacks.mozilla.org/author/abeingessnermozilla-com/">More articles by Aria Beingessner‚Ä¶</a></p>
                  </section>
  </article></div>
  </body>
</html>
