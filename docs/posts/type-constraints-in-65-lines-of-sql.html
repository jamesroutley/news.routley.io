<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/type-constraints-in-65-lines-of-sql">Original</a>
    <h1>Type constraints in 65 lines of SQL</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><span><img alt="Type Constraints in 65 lines of SQL" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>PostgreSQL has a rich and extensible type system. Beyond <a href="https://www.postgresql.org/docs/current/datatype-enum.html">enums</a> and <a href="https://www.postgresql.org/docs/current/rowtypes.html">composite</a> types, we can:</p>
<ul>
<li>apply data validation rules</li>
<li>override comparison operators like <code>=</code> / <code>+</code> / <code>-</code></li>
<li>create custom aggregations</li>
<li>define casting rules between types</li>
</ul>
<p>With a little effort, a user-defined type can feel indistinguishable from a built-in. In this article we focus on validation and ergonomics while quickly touching on a few other concepts.</p>
<p>To illustrate, we’ll create an <code>semver</code> data type to represent <a href="https://semver.org">Semantic Versioning</a> values. We’ll then add validation rules to make invalid states unrepresentable.</p>
<h2 id="semver">SemVer</h2>
<p>A (very) loose primer on SemVer:</p>
<p>SemVer is a specification for representing software versions that communicate information about backwards compatibility. The type is typically represented as a string with 5 components.</p>
<p><span><span><img alt="image" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>Where <code>pre-release</code> and <code>metadata</code> are optional.</p>
<p>The intent of each component is outside the scope of this article but, as an example, incrementing the major version number notifies users that the release includes at least one backwards incompatible change.</p>
<p>For a concise representation of the full spec, <a href="https://semver.org/#backusnaur-form-grammar-for-valid-semver-versions">check out the grammar</a>.</p>
<h2 id="sql">SQL</h2>
<p>For our purposes, we’ll assume that the SemVer type is a critical component of the application that needs to be queried flexibly and efficiently.</p>
<h3 id="storing-components">Storing Components</h3>
<p>To that end, we’ll store each component of the version as a separate field on a <a href="https://www.postgresql.org/docs/current/rowtypes.html">composite type</a>.</p>
<!-- -->

<p>We can create an instance of this type in SQL by casting a tuple as the <code>semver_components</code> type.</p>
<!-- -->

<p>Unfortunately, our definition is far too permissive.</p>
<!-- -->

<p>Our data type has no problem accepting invalid components. To list a few of the SemVer rules we violated:</p>
<ul>
<li>Major version must not be null</li>
<li>Minor version must be ≥ 0</li>
<li>Patch version must not be null</li>
<li>Pre-release elements must only include characters [A-z0-9]</li>
<li>Build metadata elements may not be empty strings</li>
</ul>
<p>We need to add some validation rules to meet our “make invalid states unrepresentable” goal.</p>
<h3 id="validation">Validation</h3>
<p><a href="https://www.postgresql.org/docs/current/sql-createdomain.html">Domains</a> are Postgres’ solution for optionally layering constraints over a data type. Domains are to types what <a href="https://www.postgresql.org/docs/current/ddl-constraints.html">check constraints</a> are to tables. If you’re not familiar with check constraints, you can think of them as equivalent to zod/pydantic in javascript/python.</p>
<p>Let&#39;s codify some SemVer rules, layer them on the <code>semver_components</code> type, and give the new domain a friendly name.</p>
<!-- -->

<p>which references a helper function:</p>
<!-- -->

<p>Now, if we repeat our positive and negative test cases using the <code>semver</code> type (vs <code>semver_components</code>) we still accept valid states:</p>
<!-- -->

<p>while invalid states are rejected with an error:</p>
<!-- -->

<h3 id="testing">Testing</h3>
<p>Our validation doesn’t have to be called manually. The <code>semver</code> domain can be used anywhere you’d use the <code>semver_components</code> type and the validations are automatically applied.</p>
<!-- -->

<p>Good stuff!</p>
<p>We’re 48 lines of SQL in and have solved for making invalid states unrepresentable. Now lets think about ergonomics.</p>
<h3 id="displaying">Displaying</h3>
<p>Now that our data type is well constrained, you might notice that selecting values from a <code>semver</code> typed column returns a tuple, rather than the SemVer string we’re used to seeing.</p>
<!-- -->

<p>For example: <code>(2,0,0,&#34;{rc,1}&#34;,)</code> vs <code>2.0.0-rc.1</code></p>
<p>We could work around that problem with some <a href="https://www.postgresql.org/docs/current/sql-createcast.html">custom casts</a>, but I’d recommend keeping everything explicit with a function call.</p>
<!-- -->

<p>Which allows us to query the <code>package_version</code> table and retrieve a string representation of the data.</p>
<!-- -->

<p>Or, better yet, use a <a href="https://www.postgresql.org/docs/current/ddl-generated-columns.html">generated column</a></p>
<!-- -->

<p>so the text representation is persisted along with the <code>semver</code> type and incurs no query/filter penalty.</p>
<h3 id="other-tricks">Other Tricks</h3>
<p>Postgres provides all the tools you could want to make your data types/domains work with SQL as seamlessly as builtins.</p>
<p>For example, you could:</p>
<ul>
<li>add convenience functions to parse a <a href="https://github.com/supabase/dbdev/blob/ca338584203d9b2eb7a4a378f5724674c15b9c25/supabase/migrations/20220117141507_semver.sql#L78">semver type from text</a></li>
<li><a href="https://github.com/supabase/dbdev/blob/ca338584203d9b2eb7a4a378f5724674c15b9c25/supabase/migrations/20220117141507_semver.sql#L37-L63">override the equality operator</a> (<code>=</code>) to correctly reflect that versions differing only in build metadata are considered equal</li>
<li><a href="https://github.com/supabase/dbdev/blob/ca338584203d9b2eb7a4a378f5724674c15b9c25/supabase/migrations/20220117141507_semver.sql#L122-L140">add a <code>max</code> function</a> to efficiently query for the newest version of each package from within the database</li>
</ul>
<p>to name a few.</p>
<p>Aligning the right parts of your business’ logic with the database can dramatically improve throughput, decrease IO, and simplify application code.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Admittedly, building performant and ergonomic custom data types in Postgres involves a lot of ceremony.</p>
<p>That said, in cases where:</p>
<ul>
<li>the type’s data integrity is critical</li>
<li>the type is well specified</li>
<li>the type’s spec does not change (or changes infrequently)</li>
</ul>
<p>Teaching Postgres to have first class support for your custom type can be transformative for data integrity and performance.</p></div></article></div>
  </body>
</html>
