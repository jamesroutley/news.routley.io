<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/967049/0ffb9b9ed8940013/">Original</a>
    <h1>A memory model for Rust code in the kernel</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-trial,v 1.1 2005-11-04 21:27:01 corbet Exp $ -->
<center>
<table>
<tbody><tr><td>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider accepting the trial offer on the right.  Thank you
for visiting LWN.net!
</p></td><td>
<div>
<h3>Free trial subscription</h3>
           <p>
           Try LWN for free for 1 month: no payment
           or credit card required.  <a href="https://lwn.net/Promo/slink-trial2-3/claim">Activate
           your trial subscription now</a> and see why thousands of
           readers subscribe to LWN.net.
           
</p></div>
</td>
</tr>

</tbody></table>
</center>
<p>
The Rust programming language differs from C in many ways; those
differences tend to be what users admire in the language.  But those
differences can also lead to an impedance mismatch when Rust code is
integrated into a C-dominated system, and it can be even worse in the
kernel, which is not a typical C program.  Memory models are a case in
point.  A programming language&#39;s view of memory is sufficiently fundamental
and arcane that many developers never have to learn much about it.  It is
hard to maintain that sort of blissful ignorance while working in the
kernel, though, so a recent discussion of how to choose a memory model for
kernel code in Rust is of interest.
</p><h4>Memory models</h4>
<p>
It is convenient to view a system&#39;s memory as a simple array of bytes that
can be accessed from any CPU.  The reality, though, is more complicated.
Memory accesses are slow, so a lot of effort goes into minimizing them;
modern systems are built with multiple levels of caching for that purpose.
Without that caching, performance would slow to a crawl, severely impacting
the production, delivery, and consumption of cat videos, phishing spam, and
cryptocurrency scams.  This prospect is seen as a bad thing.
</p><p>
Multi-level caching speeds computation, but it brings a problem of its own:
it is no longer true that every CPU in the system sees the same memory
contents.  If one CPU has modified some data in a local cache,
another CPU reading that data may not see the changes.  Operations
performed in a carefully arranged order may appear in a different order
elsewhere in the system.  As is the case in relativistic situations, the
ordering of events depends on who is observing them.  Needless to say, this
kind of uncertainty also has the potential to create disorder within an
operating-system kernel.
</p><p>
CPUs have special operations that can ensure that a given memory store is
simultaneously visible across the system.  These operations, though, are
slow and need to be used with care.  Modern CPUs provide a range of
&#34;barrier&#34; operations that can be used to properly sequence access to data
with less overhead; see <a href="https://lwn.net/Articles/576486/">this article</a> for an
overview of some of them.  Use of these barriers can be somewhat complex
(and architecture-specific), so a few generic interfaces have been created
to simplify things (to the extent that they <i>can</i> be simplified).  A
memory model combines a specification of how barriers should be used and
any interfaces that ease that use, describing how to safely access data in
concurrent settings.
</p><div><p>
&#34;The majority of the _good_ programmers I know run away screaming
from this stuff. As was said many, many years ago - understanding
</p><tt>memory-barriers.txt</tt><p> is an -extremely high bar- to set as a basic
requirement for being a kernel developer.&#34;</p></div><p>

The C11 standard, for example, defines some <a href="https://en.cppreference.com/w/c/language/atomic">atomic types</a> and
<a href="https://en.cppreference.com/w/c/atomic">atomic operations</a>.
C++ offers <a href="https://en.cppreference.com/w/cpp/atomic/atomic">an
atomic type</a> of its own.  While the kernel community has occasionally <a href="https://lwn.net/Articles/691128/">discussed</a> using the C atomic types, that has
never happened for a number of reasons, some of which will become apparent
below.  Instead, the kernel defines its own memory model, described in the
infamous <a href="https://www.kernel.org/doc/html/latest/core-api/wrappers/memory-barriers.html">memory-barriers.txt</a>
file (and sometimes referred to as &#34;LKMM&#34;).  Few kernel developers
understand this model in detail (and many <a href="https://lwn.net/Articles/827180/">find
it too subtle</a> to understand deeply), but it governs how memory
access works at the lowest levels.  (See also <a href="https://lwn.net/Articles/718628/">this article series</a> for more on the kernel&#39;s
memory model).

</p><p>
One of the early concerns about incorporating Rust into the kernel is that
the Rust language lacked a memory model of its own.  That gap has since
been filled; the <a href="https://doc.rust-lang.org/std/sync/atomic/#memory-model-for-atomic-accesses">Rust
memory model</a> looks a lot like the C++ model.  Boqun Feng, who helps
maintain the kernel&#39;s memory model, thought that it would be good to
formalize a model for Rust code to use in the kernel.  Should the Rust
model be used, the kernel&#39;s model, or some combination of the two?  He <a href="https://lwn.net/ml/linux-kernel/20240322233838.868874-1-boqun.feng@gmail.com/">posted
his conclusion</a> to the linux-kernel mailing list: Rust code should
adhere to the kernel&#39;s memory model.  He included an initial patch set
showing what that would look like.
</p><h4>Using the kernel&#39;s model</h4>
<p>
The reasoning behind this conclusion is simple enough: &#34;<q>Because kernel
developers are more familiar with LKMM and when Rust code interacts with C
code, it has to use the model that C code uses</q>&#34;.  Learning one memory
model is hard enough; requiring developers to learn two models to work with
the kernel would not lead to good results.  Even worse results are likely
when Rust and C code interact, each depending on its respective memory model
to ensure proper data ordering.  So, as long as the kernel has its own
memory model, that is what Rust code will have to use.
</p><p>
Kent Overstreet <a href="https://lwn.net/ml/linux-kernel/s2jeqq22n5ef5jknaps37mfdjvuqrns4w7i22qp2r7r4bzjqs2@my3eyxoa3pl3/">pointed
out</a> a disadvantage of this approach: the kernel will remain
incompatible with other Rust code and will not be able to incorporate it
easily.  He suggested that, perhaps, the kernel&#39;s memory model could be
rebuilt on top of C or C++ atomic operations, at which point supporting the
Rust model would be easier.  That seems unlikely to happen, though, given
the strong opposition from Linus Torvalds to any such change.
</p><p>
One of Torvalds&#39;s arguments was that <a href="https://lwn.net/ml/linux-kernel/CAHk-=whY5A=S=bLwCFL=043DoR0TTgSDUmfPDx2rXhkk3KANPQ@mail.gmail.com/">language-based
memory models are insufficiently reliable</a> for use in the kernel, and
that is not a problem that can be addressed quickly.
&#34;<q>The C++ memory model may be reliable in another decade. And then a
decade after *that*, we can drop support for the pre-reliable
compilers.</q>&#34; Thus, he said, &#34;<q>I do not understand why people think
that we wouldn&#39;t want to roll our own</q>&#34;.  Feng <a href="https://lwn.net/ml/linux-kernel/Zf4fDJNBeRN5HOYo@boqun-archlinux/">added</a> that
the kernel&#39;s memory model encompasses a number of use cases, such as
mixed-size operations on the same variable, that are important to the
kernel.  Those uses are not addressed (or allowed) in the Rust model.
He did suggest that, perhaps, a subset of the Rust model could be
implemented on top of the kernel&#39;s operations.
</p><p>
Another reason for the kernel project to implement its own memory model,
Torvalds <a href="https://lwn.net/ml/linux-kernel/CAHk-=whkQk=zq5XiMcaU3xj4v69+jyoP-y6Sywhq-TvxSSvfEA@mail.gmail.com/">said</a>,
is that kernel developers need to be deeply familiar with the architectures
they are supporting anyway.  There is no way to create a kernel without a
lot of architecture-specific code.  Given that, &#34;<q>having the architecture
also define things like atomics is just a pretty small (and relatively
straightforward) detail</q>&#34;.
</p><p>
Torvalds has <a href="https://lwn.net/ml/linux-kernel/CAHk-=wjP1i014DGPKTsAC6TpByC3xeNHDjVA4E4gsnzUgJBYBQ@mail.gmail.com/">another
reason</a> for sticking with the kernel&#39;s memory model, though: he thinks
that the C++ model is fundamentally misdesigned.  A key aspect of that
model is that data exposed to concurrent access is given a special atomic
type, and the compiler automatically inserts the right barriers when that
data is accessed.  Such a model can ensure that a developer never forgets
to use the proper atomic operations, which is an appealing feature.  That
is, however, not how the kernel&#39;s model works.
</p><p>
In the kernel&#39;s memory model, it is not the type of the data that
determines how it must be accessed, but the context in which that access
happens.  A simple example is data that is protected by a lock; while the
lock is held, that data is not truly shared since the lock holder has
exclusive access.  So there is no need for expensive atomic operations;
instead, a simple barrier when the lock is released is sufficient.  In
other settings, where a lock is not held, atomic operations may be needed
to access the same data.
</p><p>
Torvalds argued that the kernel&#39;s approach to shared data makes more sense:
</p><blockquote>
	In fact, I personally will argue that it is fundamentally wrong to
	think that the underlying data has to be volatile. A variable may
	be entirely stable in some cases (ie locks held), but not in
	others.
<p>
	So it&#39;s not the *variable* (aka &#34;object&#34;) that is &#39;volatile&#39;, it&#39;s
	the *context* that makes a particular access volatile.
</p><p>
	That explains why the kernel has basically zero actual volatile
	objects, and 99% of all volatile accesses are done through accessor
	functions that use a cast to mark a particular access volatile.
</p></blockquote>
<p>
This approach has been taken in the kernel for a long time; it is described
in the <a href="https://docs.kernel.org/process/volatile-considered-harmful.html">volatile-considered-harmful
document</a> that was first <a href="https://git.kernel.org/linus/0faa45480261">added to the kernel</a>
for the 2.6.22 release in 2007.
</p><p>
The outcome of this discussion is clear enough: Rust code in the kernel
will have to use the kernel&#39;s memory model for the foreseeable future.  The
Rust language brings with it a number of new ways of doing things, many of
which have significant advantages over C.  But bringing a new language
into a code base that is old, large, and subject to special requirements is
always going to require some compromises on the new-language side.  Using
the kernel&#39;s memory model may not actually be a compromise, but it is
different from what other Rust code will do; it will be one of the many
things Rust developers will have to learn to work in the kernel project.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Memory_model">Memory model</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
