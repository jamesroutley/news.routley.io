<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xania.org/202512/03-more-adding-integers">Original</a>
    <h1>You Can&#39;t Fool the Optimizer</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
        

        <p>Written by me, proof-read by an LLM.
</p>
<p>Sometimes you’ll step through code in a debugger and find a complex-looking loop… that executes as a single instruction. The compiler saw through the obfuscation and generated the obvious code anyway.</p>
<p>Consider this assortment of highly questionable unsigned addition routines<sup id="fnref:greg"><a href="#fn:greg">1</a></sup> - for variety, here compiled for ARM (unlike <a href="https://xania.org/202512/02-adding-integers">yesterday’s addition example</a>).</p>


<p>Despite these all being very different ways of returning <code>x + y</code>, the compiler sees through it all and recognises that it’s just a single <code>add w0, w1, w0</code><sup id="fnref:arm"><a href="#fn:arm">2</a></sup> instruction. Even the recursive <code>add_v4</code> - which calls itself - gets optimised down to the same single instruction<sup id="fnref:tco"><a href="#fn:tco">3</a></sup>.</p>
<p>The compiler’s ability to recognise patterns and replace them with efficient alternatives - even when the code is pretty obfuscated - is a superpower. It lets programmers choose <em>how</em> to write their code that’s intention-revealing (not like these contrived examples, obviously!) and leave the code generation up to the compiler, knowing that most of the time it’ll do the right thing.</p>
<p>So how does the compiler spot these patterns? Is it maintaining a database of “silly ways to add numbers”? Not quite. Internally, it translates your code into an intermediate representation - a simplified, abstract form that’s easier to analyse. When the compiler sees the while loop in <code>add_v3</code>, it transforms it into something like “increment y by x, then return y”, which it then recognises as mathematically equivalent to “return x + y”. This process of converting different code patterns into a standard, canonical form is what lets the compiler treat them all identically. By the time code generation happens, all four functions look the same to the optimiser<sup id="fnref:opt"><a href="#fn:opt">4</a></sup>.</p>
<p>This pattern recognition is remarkably robust - the compiler will happily optimise code you’d never want to write in the first place. Throughout this series we’ll see how far this canonicalisation can take us.</p>
<p><em>See <a href="https://youtu.be/wHg9lYPMvvE">the video</a> that accompanies this post.</em></p>
<hr/>
<p><em>This post is day 3 of <a href="https://xania.org/AoCO2025">Advent of Compiler Optimisations 2025</a>,
a 25-day series exploring how compilers transform our code.</em></p>
<p><em>This post was written by a human (<a href="https://xania.org/MattGodbolt">Matt Godbolt</a>) and reviewed and proof-read by LLMs and humans.</em></p>
<p><em>Support Compiler Explorer on <a href="https://patreon.com/c/mattgodbolt">Patreon</a>
or <a href="https://github.com/sponsors/compiler-explorer">GitHub</a>,
or by buying CE products in the <a href="https://shop.compiler-explorer.com">Compiler Explorer Shop</a></em>.</p>

    </div>
</div></div>
  </body>
</html>
