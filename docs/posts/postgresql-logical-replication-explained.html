<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.postgresql.fastware.com/blog/inside-logical-replication-in-postgresql">Original</a>
    <h1>PostgreSQL Logical Replication Explained</h1>
    
    <div id="readability-page-1" class="page"><div data-widget-type="blog_content" data-x="0" data-w="11">
<div>
  <div>
   <div>
     <div>
       <!-- (open curly bracket) % blog_social_sharing "blog_social_sharing" overrideable=False, label='Blog Social Sharing' %}-->
       <div>
         <div>
           <div>   
              <h2><span id="hs_cos_wrapper_post_body" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>Last month, I was proud to talk about the internals of logical replication to a room full of PostgreSQL enthusiasts at PGConf India 2023. In case you missed it, let&#39;s go through it together.</p></span></h2>
           </div>
          <!-- (Marcelo 04-10-22) Commmented to remove featured image from the post body -->  
      <!-- <div class="span5 fast-blog-image-social-sharing"> -->
      <!--        <span id="hs_cos_wrapper_image" class="hs_cos_wrapper hs_cos_wrapper_widget hs_cos_wrapper_type_image" style="" data-hs-cos-general-type="widget" data-hs-cos-type="image" ><img src="https://www.postgresql.fastware.com/hubfs/Images/Featured/img-featured-postgresql-14-and-beyond.png" class="hs-image-widget "  style="width:550px;border-width:0px;border:0px;" width="550" alt="" title=""></span>-->
      <!--        <span id="hs_cos_wrapper_executive_image" class="hs_cos_wrapper hs_cos_wrapper_widget hs_cos_wrapper_type_image" style="" data-hs-cos-general-type="widget" data-hs-cos-type="image" ></span> -->
      <!--      </div> -->
         </div>
       </div>
       <p><span id="hs_cos_wrapper_rich_text" data-hs-cos-general-type="widget" data-hs-cos-type="rich_text"></span>
         <span id="hs_cos_wrapper_left_column" data-hs-cos-general-type="widget" data-hs-cos-type="rich_text"><div>
<p><img src="https://www.postgresql.fastware.com/hubfs/Images/Blogs/img-blog-curtain-author-vignesh-orange-to-yellow.png" alt="" loading="lazy"/></p>
<div>
<p>Logical replication allows fine-grained control over both data replication and security. In this blog I&#39;ll go through the fundamentals of Logical Replication and some use cases. </p>
</div>
</div>
<p>My paper on the Internals of Logical Replication was one of the 27 CFP&#39;s selected from 120 submissions. During the event, I covered the following topics:</p>

<a id="Introduction" data-hs-anchor="true"></a>
<h3>Introduction</h3>
<img src="https://www.postgresql.fastware.com/hubfs/Images/Blogs/img-blog-2023-pgconf-india-vignesh-on-stage-01.jpg" alt="Vigneshwaran C on stage at PFConf India 2023" loading="lazy"/>
<p>Logical replication is a method of replicating data changes from publisher to subscriber. The node where a publication is defined is referred to as the publisher. The node where a subscription is defined is referred to as the subscriber. Logical replication allows fine-grained control over both data replication and security.</p>
<p>Logical replication uses a publish and subscribe model with one or more subscribers subscribing to one or more publications on a publisher node. Subscribers pull data from the publications they subscribe to and may subsequently re-publish data to allow cascading replication or more complex configurations.</p>
<a id="UseCases" data-hs-anchor="true"></a>
<h3>Use cases</h3>
<ul>
<li>Sending incremental changes in a single database or a subset of a database to subscribers as they occur.</li>
<li>Firing triggers for individual changes as they arrive on the subscriber.</li>
<li>Consolidating multiple databases into a single one (e.g., for analytical purposes).  Replicating between different major versions of PostgreSQL.</li>
<li>Replicating between PostgreSQL instances on different platforms (e.g., Linux to Windows).</li>
<li>Giving access to replicated data to different groups of users.</li>
<li>Sharing a subset of the database between multiple databases.</li>
</ul>
<a id="Architecture" data-hs-anchor="true"></a>
<h3>Architecture</h3>
<p>Below, I illustrate how logical replication works in PostgreSQL 15. I will refer back to this diagram later in this post.</p>
<p><img src="https://www.postgresql.fastware.com/hubfs/Images/Blogs/img-dgm-logical-replcation-architecture-01.svg" alt="img-dgm-logical-replcation-02" width="650" height="650" loading="lazy"/></p>
<a id="Publication" data-hs-anchor="true"></a>
<h3>Publication</h3>
<p>Publications can be defined on the primary node whose changes should be replicated. A publication is a set of changes generated from a table or a group of tables and might also be described as a change set or replication set. Each publication exists in only one database.</p>
<p>Each table can be added to multiple publications if needed. Publications may currently only contain tables and all tables in schema.</p>
<p>Publications can choose to limit the changes they produce to any combination of <span>INSERT</span>, <span>UPDATE</span>, <span>DELETE</span>, and <span>TRUNCATE</span>, similar to how triggers are fired by particular event types. By default, all operation types are replicated.</p>
<p>When a publication is created, the publication information will be added to <span>pg_publication</span> catalogue table:</p>
<div><p>postgres=# CREATE PUBLICATION <span>pub_alltables</span> FOR ALL TABLES;</p></div>
<p>Information about table publication is added to <span>pg_publication_rel</span> catalog table:</p>
<div><p>postgres=# CREATE PUBLICATION pub_employee FOR TABLE employee;</p></div>
<p>Information about schema publications is added to <span>pg_publication_namespace</span> catalog table:</p>
<div><p>postgres=# CREATE PUBLICATION pub_sales_info FOR TABLES IN SCHEMA marketing, sales;</p></div>
<a id="Subscription" data-hs-anchor="true"></a>
<h3>Subscription</h3>
<p>A subscription is the downstream side of logical replication.  It defines the connection to another database and set of publications (one or more) to which it wants to subscribe.</p>
<p>The subscriber database behaves in the same way as any other PostgreSQL instance, and can be used as a publisher for other databases by defining its own publications. A subscriber node may have multiple subscriptions.  It is possible to define multiple subscriptions between a single publisher-subscriber pair, in which case care must be taken to ensure that the subscribed publication objects don&#39;t overlap.</p>
<p>Each subscription will receive changes via one replication slot.  Additional replication slots may be required for the initial synchronization of pre-existing table data, which will be dropped at the end of data synchronization.</p>
<p>When a subscription is created, the subscription information will be added to the <span>pg_subscription</span> catalog table:</p>
<div><p>postgres=# CREATE SUBSCRIPTION sub_alltables</p></div>
<p>The subscriber will connect to the publisher and get the list of tables that the publisher is publishing. In our earlier example, we created <span>pub_alltables</span> to publish data of all tables - the publication relations will be added to the <span>pg_subscription_rel</span> catalog tables:</p>
<div><p>postgres=# SELECT srsubid, srerelid::regclass FROM <span>pg_subscription_rel</span>;</p></div>
<p>The subscriber connects to the publisher and creates a replication slot, whose information is available in <span>pg_replication_slots</span>:</p>
<div><p>postgres=# SELECT slot_name, plugin, type, datoid, database, temporary, active, </p></div>
<p>Subscribers add the subscription stats information to <span>pg_stat_subscription</span></p>
<div><p>postgres=# SELECT subid, subname, received_lsn FROM <span>pg_stat_subscription</span>;</p></div>
<p>The initial part of the CREATE SUBSCRIPTION command will be completed and returned to the user. The remaining work will be done in the background by the <span>replication launcher</span>, <span>walsender</span>, <span>apply worker,</span> and <span>tablesync worker</span> after the CREATE SUBSCRIPTION command is completed.</p>
<a id="Processes" data-hs-anchor="true"></a>
<h3>Processes</h3>
<h4>Replication launcher</h4>
<p>This process is started by the postmaster during the start of the instance. It will periodically check the pg_subscription catalog table to see if any subscriptions have been added or enabled.</p>
<p>The logical replication worker launcher uses the background worker infrastructure to start the logical replication workers for every enabled subscription.</p>
<div><p>vignesh 24438 /home/vignesh/postgres/inst/bin/postgres -D subscriber</p></div>
<p>Once the launcher process identifies that a new subscription has been created or enabled, it will start an apply worker process.</p>
<div><p>vignesh 24438 /home/vignesh/postgres/inst/bin/postgres -D subscriber</p></div>
<p>The above information illustrates step 1 mentioned in the <a href="#Architecture" rel="noopener">Architecture</a> section above.</p>
<h4>Apply worker</h4>
<p>The apply worker will iterate through the table list and launch tablesync workers to synchronize the tables. Each table will be synchronized by one tablesync worker.</p>
<p>Multiple tablesync workers (one for each table) will run in parallel based on the <span>max_sync_workers_per_subscription</span> configuration.</p>
<img src="https://www.postgresql.fastware.com/hubfs/Images/Blogs/img-dgm-logical-replication-apply-worker-01.svg" alt="img-dgm-logical-replication-apply-worker-01" width="450" height="430" loading="lazy"/><span></span>
<p>The apply worker will wait until the tablesync worker copies the initial table data and sets the table state to ready state in <span>pg_subscription_rel</span>.</p>
<div><p>postgres=# SELECT srsubid, srrelid::regclass, srsubstate, srsublsn FROM <span>pg_subscription_rel</span>;</p></div>
<p>The above information illustrates step 2 mentioned in the <a href="#Architecture" rel="noopener">Architecture</a> section above.<span></span><span></span></p>
<p><span>Note:</span> Currently, DDL operations are not supported by logical replication. Only DML changes will be replicated. </p>
<h4>Tablesync worker</h4>
<ul>
<li>The initial data synchronization is done separately for each table, by a separate tablesync worker.</li>
<li>Create a replication slot with the <span>USE_SNAPSHOT</span> option and copy table data with the COPY command.</li>
<li>The tablesync worker will request the publisher to start replicating data from the publisher.</li>
<li>The tablesync worker will synchronize data from walsender until it reaches the syncworker’s LSN set by the apply worker. </li>
</ul>
<p><img src="https://www.postgresql.fastware.com/hubfs/Images/Blogs/img-dgm-logical-replication-tablesync-worker-01.svg" alt="img-dgm-logical-replication-tablesync-worker-01" width="500" height="401" loading="lazy"/></p>
<p>The above information illustrates step 3 mentioned in the <a href="#Architecture" rel="noopener">Architecture</a> section above.</p>
<h4>Walsender</h4>
<p>The walsender is started when the subscriber connects to the publisher and requests WAL. It then reads the WAL record by record, and decodes it to get the tuple data and size.</p>
<p>The changes are queued into the <span>reorderbufferqueue</span>. The <span>reorderbufferqueue</span><span> </span>collects individual pieces of transactions in the order they are written to the WAL. When a transaction is completed, it will reassemble the transaction and call the output plugin with the changes. If the <span>reorderbufferqueue</span><span> </span>exceeds logical_decoding_work_mem, then find the largest transaction and evict it to disk.</p>
<p>If streaming is enabled, then this transaction data will be sent to the subscriber, but will be applied in the subscriber only after the transaction is committed in the publisher.</p>
<p>Once the transaction is committed, the walsender performs the following:</p>
<ul>
<li>Checks if this relation should be published (based on <span><i>ALL TABLES</i></span><i> </i>or <span><i>TABLE</i></span><span> </span>list or <span><i>TABLES IN SCHEMA</i></span> list specified in the publication).</li>
<li>Checks if this operation should be published (based on what the user has specified for the <span><i>publish</i> </span>option – insert/update/delete/truncate).</li>
<li>Changes the publish relation ID if <span><i>publish_via_partition_root</i></span><i> </i><i>is set</i>. In this case, the relation ID of the ancestor will be sent.</li>
<li>Checks if this row should be sent based on the condition specified by <span>row filter</span></li>
<li>Checks if this column should be sent based on the <span>column list</span> specified.</li>
</ul>
<p>The walsender then updates the statistics like txn count, txn bytes, spill count, spill bytes, spill txns, stream count, stream bytes, stream txns.</p>
<p>The above information illustrates steps 7 and 8 mentioned in the <a href="#Architecture" rel="noopener">Architecture</a>.</p>
<a id="ReplicatingIncrementalChanges" data-hs-anchor="true"></a>
<h3>Replicating incremental changes</h3>
<p>Incremental changes are handled by the walsender and the apply worker, as described below.</p>
<img src="https://www.postgresql.fastware.com/hubfs/Images/Blogs/img-dgm-logical-replication-replicationg-incremental-changes-01.svg" alt="img-dgm-logical-replication-replicationg-incremental-changes-01" width="750" height="446" loading="lazy"/>The table above details step 9 mentioned in the <a href="#Architecture" rel="noopener">Architecture</a> diagram.<a id="ApplyWorkerFailureHandling" data-hs-anchor="true"></a>
<h3>Apply worker failure handling</h3>
<p>If the apply worker fails due to an error, the apply worker process will exit. During its normal operation, the apply worker will have maintained the origin LSN during the last transaction commit.</p>
<p>The replication launcher will periodically check if the subscription worker is running. If the launcher identifies that it is not, then it will restart the worker for the subscription. The apply worker will request start_replication streaming from the last origin LSN that was committed. The walsender will start streaming transactions from the origin LSN (last committed transaction) requested by the apply worker.</p>
<p>Whenever the apply worker encounters a constraint error such as duplicate constraint error, check constraint error, etc, it will exit and repeat the steps mentioned above.</p>
<div><p>2023-02-22 11:55:51.479 IST [21204] ERROR:  duplicate key value violates unique constraint &#34;employee_pkey&#34;</p></div>
<p>There is an option to skip the LSN in case of errors - user can <span>set skip lsn</span> of the failing transaction in this case. If the user sets to skip LSN, the apply worker will check if the transaction matches the LSN specified, skip this transaction, and proceed to the next one.</p>
<div><p>postgres=# ALTER SUBSCRIPTION sub_alltables SKIP (lsn = &#39;<span>0/1562C10</span>&#39;);</p></div>
<p>The user can use <span>disable_on_error</span> instead of repeatedly trying the steps. In this case, any error in the apply worker will be caught using try() /catch(), and the subscription will be disabled before the apply worker exists. As the subscription is disabled, the launcher will not restart the apply worker for the subscription.</p>
<div><p>postgres=# ALTER SUBSCRIPTION sub_alltables <span>SET (DISABLE_ON_ERROR = &#39;on&#39;)</span>;</p></div>
<a id="AlteringASubscription" data-hs-anchor="true"></a>
<h3>Altering a subscription</h3>
<p><img src="https://www.postgresql.fastware.com/hubfs/Images/Blogs/img-dgm-logical-replication-altering-a-subscription-01.svg" alt="img-dgm-logical-replication-altering-a-subscription-01" width="150" height="293" loading="lazy"/>The apply worker will periodically check the current subscription values against the new ones - if they have been changed:</p>
<ul>
<li>The apply worker will exit.</li>
<li>The launcher will restart the apply worker.</li>
<li>The apply worker will load the new subscription values from the pg_subscription system table.</li>
<li>The apply worker will apply the changes using the newly modified values.</li>
</ul>
<a id="HowSynchronousCommitIsAchieved" data-hs-anchor="true"></a>
<h3>How <span>synchronous_commit</span> is achieved</h3>
<p>In the subscriber, create a subscription with the synchronous_commit option set to ‘on’</p>
<p>In the publisher, use ALTER SYSTEM SET to set the synschronous_standby_names option to the subscription name, and reload the configuration using pg_reload_conf. Verify that is_sync option is enabled in pg_stat_replication.</p>
<div><p>postgres=# CREATE SUBSCRIPTION <span>sync</span></p></div>
<p>Publisher</p>
<div><p>postgres=# ALTER SYSTEM SET synchronous_standby_names TO &#39;<span>sync</span>&#39;;</p></div>
<img src="https://www.postgresql.fastware.com/hubfs/Images/Blogs/img-dgm-logical-replication-how-synchronous-commit-is-achieved-01.svg" alt="img-dgm-logical-replication-how-synchronous-commit-is-achieved-01" width="800" height="387" loading="lazy"/><a id="ReplicationSlot" data-hs-anchor="true"></a>
<h3>Replication slot</h3>
<p>A replication slot ensures that the publisher will retain the WAL logs that are needed by the replicas even when they are disconnected from the subscriber.</p>
<p>As mentioned earlier, each (active) subscription receives changes from a replication slot on the remote (publishing) side.</p>
<p>Additional table synchronization slots are normally transient, created internally to perform initial table synchronization, and dropped automatically when they are no longer needed.</p>
<p>Normally, the remote replication slot is created automatically when the subscription is created during <i>CREATE SUBSCRIPTION, </i>and it is dropped automatically when the subscription is dropped during <i>DROP SUBSCRIPTION</i>.</p>
<p>Replication slots provide an automated way to ensure that the primary does not remove WAL segments until they have been received by all standbys.</p>
<a id="RowFilters" data-hs-anchor="true"></a>
<h3>Row filters</h3>
<p>When creating a publication, a WHERE clause can be specified. This information is stored in the <span>pg_publication_rel</span><i> </i>catalog table:</p>
<div><p>postgres=# CREATE PUBLICATION active_departments FOR TABLE departments WHERE <span>(active IS TRUE)</span>;</p></div>
<p>Rows that don&#39;t satisfy this WHERE clause will be filtered by the publisher. This allows a set of tables to be partially replicated.</p>
<p>During table synchronization, only the table data that satisfies the row filter will be copied to the subscriber. </p>
<p>If the subscription has several publications, and at least one of them was specified using ALL TABLES or TABLES IN SCHEMA and the table belongs to the referred schema, then those publications take precedence, and the publication behaves as if there are no row filters. </p>
<h4>Replication filters transformation</h4>
<p>For insert operations, the publisher checks if the new row satisfies the row filter condition to determine if the new record should be sent to the subscriber or skipped.</p>
<p>For delete operations, the publisher checks if the row satisfies the row filter condition to determine if the operation should be sent to the subscriber or skipped.</p>
<p>The update operation is handled in a slightly different manner:</p>
<ul>
<li>If neither the old row nor the new one match the row filter condition: Update is skipped.</li>
<li>If the old row does not satisfy the row filter condition, but the new one does: Transform the update to insertion of new row on the subscriber.</li>
<li>If the old row satisfies the row filter condition but the new one does not: Transform the update into deletion of old row from the subscriber.</li>
<li>If both the old row and the new one satisfy the row filter condition: Send the data as an update to the subscriber, without any transformation.</li>
</ul>
<a id="ColumnLists" data-hs-anchor="true"></a>
<h3>Column lists</h3>
<p>When creating a publication, a column list clause can be specified. This information is stored in <span>pg_publication_rel</span> catalog table:</p>
<div>
<p>postgres=# CREATE PUBLICATION users_filtered FOR TABLE users (user_id, firstname);</p>

</div>
<p>Columns not included in this list are not sent to the subscriber. This allows the schema on the subscriber to be a subset of the publisher schema, as illustrated below.</p>
<p><img src="https://www.postgresql.fastware.com/hubfs/Images/Blogs/img-dgm-logical-replication-column-lists-01.svg" alt="img-dgm-logical-replication-column-lists-01" width="520" height="373" loading="lazy"/></p>
<p>During the initial table synchronization, only columns included in the column list are copied to the subscriber.</p>
<p>When sending incremental transaction changes, the publisher will check for the relation information and send to the subscriber the values only for the columns that match the specified column list.</p>
<p>For partitioned tables, publish_via_partition_root determines whether the column list for the root or leaf relation will be used. If the parameter is &#39;false&#39; (the default), the list defined for the leaf relation is used. Otherwise, the column list for the root partition will be used.</p>
<p>Specifying a column list when the publication also publishes FOR TABLES IN SCHEMA is not supported.</p>
<a id="AdvantagesOfRowFiltersAndColumnLists" data-hs-anchor="true"></a>
<h3>Advantages of row filters and column lists</h3>
<p>The row filter and column list features provide the following advantages:</p>
<ul>
<li>Reduces network traffic (and increases performance) by replicating only a small subset of a large data table.</li>
<li>Provides only the data that is relevant to a subscriber node.</li>
<li>Acts as a form of security by hiding sensitive information (not replicating credit card numbers).</li>
</ul>
<a id="ReplicatingTablesInSchema" data-hs-anchor="true"></a>
<h3>Replicating TABLES IN SCHEMA</h3>
<p>One or more schemas can be specified in FOR TABLES IN SCHEMA. This information is maintained in the <span>pg_publication_namespace</span> catalog table:</p>
<div><p>postgres=# CREATE PUBLICATION sales_publication FOR TABLES IN SCHEMA marketing, sales;</p></div>
<p>During the initial table synchronization, only tables that belong to the specified schema are copied to the subscriber. When sending the incremental transaction changes, the publisher will check if this transaction’s relation belongs to one of the schemas and publish only those changes.</p>
<p>If the subscription has several publications, and at least one was specified using ALL TABLES, then those publications will be given higher precedence and all the table data will be sent to the subscription.</p>
<p>Any new table created in the schema after creation of the publication will be automatically added to it. Similarly, tables removed from the schema will be automatically removed from the publication. But data of newly created tables (after creation of subscription) will not be replicated automatically - the user will have to run ALTER SUBSCRIPTION … REFRESH PUBLICATION, which will fetch the missing tables and take care of synchronizing the data from the publisher.</p>
<p>ALL TABLES replication is similar to TABLES IN SCHEMA publication, except that it will replicate data from all tables, instead of just the tables present in the schema.</p>
<a id="FutherReading" data-hs-anchor="true"></a>
<h3>Further reading</h3>
<p>If you have more questions or would like to extend your knowledge, here is some recommended reading:</p>
<ul>
<li><a href="https://www.postgresql.fastware.com/blog/logical-replication-tablesync-workers">Logical Replication Tablesync Workers</a></li>
<li><a href="https://www.postgresql.fastware.com/blog/logical-replication-of-tables-in-schema-in-postgresql-15">Logical replication of tables in schema in PostgreSQL 15</a></li>
<li><a href="https://www.postgresql.fastware.com/blog/how-to-gain-insight-into-the-pg-stat-replication-slots-view-by-examining-logical-replication">How to gain insight into the pg_stat_replication_slots view by examining logical replication</a></li>
<li><a href="https://www.postgresql.fastware.com/blog/column-lists-in-logical-replication-publications">Column lists in logical replication publications</a></li>
<li><a href="https://www.postgresql.fastware.com/blog/introducing-publication-row-filters">Introducing publication row filters</a></li>
<li><a href="https://www.postgresql.fastware.com/blog/addressing-replication-conflicts-using-alter-subscription-skip">Addressing logical replication conflicts using ALTER SUBSCRIPTION SKIP</a></li>
</ul>
<img src="https://www.postgresql.fastware.com/hs-fs/hubfs/Images/Blogs/img-blog-2023-pgconf-india-audience-01.jpg?width=1000&amp;height=380&amp;name=img-blog-2023-pgconf-india-audience-01.jpg" alt="img-blog-2023-pgconf-india-audience-01" width="1000" height="380" loading="lazy" srcset="https://www.postgresql.fastware.com/hs-fs/hubfs/Images/Blogs/img-blog-2023-pgconf-india-audience-01.jpg?width=500&amp;height=190&amp;name=img-blog-2023-pgconf-india-audience-01.jpg 500w, https://www.postgresql.fastware.com/hs-fs/hubfs/Images/Blogs/img-blog-2023-pgconf-india-audience-01.jpg?width=1000&amp;height=380&amp;name=img-blog-2023-pgconf-india-audience-01.jpg 1000w, https://www.postgresql.fastware.com/hs-fs/hubfs/Images/Blogs/img-blog-2023-pgconf-india-audience-01.jpg?width=1500&amp;height=570&amp;name=img-blog-2023-pgconf-india-audience-01.jpg 1500w, https://www.postgresql.fastware.com/hs-fs/hubfs/Images/Blogs/img-blog-2023-pgconf-india-audience-01.jpg?width=2000&amp;height=760&amp;name=img-blog-2023-pgconf-india-audience-01.jpg 2000w, https://www.postgresql.fastware.com/hs-fs/hubfs/Images/Blogs/img-blog-2023-pgconf-india-audience-01.jpg?width=2500&amp;height=950&amp;name=img-blog-2023-pgconf-india-audience-01.jpg 2500w, https://www.postgresql.fastware.com/hs-fs/hubfs/Images/Blogs/img-blog-2023-pgconf-india-audience-01.jpg?width=3000&amp;height=1140&amp;name=img-blog-2023-pgconf-india-audience-01.jpg 3000w" sizes="(max-width: 1000px) 100vw, 1000px"/>
<div>
<div>
<div>
<div>
<div>
<p><a href="https://www.postgresql.fastware.com/compare-postgresql-versions" rel="noopener"><img src="https://www.postgresql.fastware.com/hubfs/Images/Roundels/roundel-justice-scales-01-orange-to-yellow-01.svg"/></a></p>
<p><span>Fujitsu Enterprise Postgres</span></p></div>
<p>Compare the list of features.</p>

</div>
</div>
</div>
</div>
<div>
<div>
<p>We also have a series of technical articles for PostgreSQL enthusiasts of all stripes, with tips and how-to&#39;s.</p>
<!--HubSpot Call-to-Action Code --><p><span id="hs-cta-wrapper-a2bb4af2-87cc-4ede-8c72-0a394a2413b0"><span id="hs-cta-a2bb4af2-87cc-4ede-8c72-0a394a2413b0"><!--[if lte IE 8]><div id="hs-cta-ie-element"></div><![endif]--><a href="https://cta-redirect.hubspot.com/cta/redirect/2585850/a2bb4af2-87cc-4ede-8c72-0a394a2413b0"><img id="hs-cta-img-a2bb4af2-87cc-4ede-8c72-0a394a2413b0" src="https://no-cache.hubspot.com/cta/default/2585850/a2bb4af2-87cc-4ede-8c72-0a394a2413b0.png" alt="Explore PostgreSQL Insider &gt;"/></a></span></span></p><!-- end HubSpot Call-to-Action Code --></div>
</div>
<div>
<p>Subscribe to be notified of future blog posts</p>
<p>If you would like to be notified of my next blog posts and other PostgreSQL-related articles, fill the form <a href="#form-blog-subscription">here</a>.</p>
</div></span>   
       </p>
       
         <p id="hubspot-topic_data"> Topics:
           
             <a href="https://www.postgresql.fastware.com/blog/topic/postgresql">PostgreSQL</a>,
           
             <a href="https://www.postgresql.fastware.com/blog/topic/postgresql-community">PostgreSQL community</a>,
           
             <a href="https://www.postgresql.fastware.com/blog/topic/postgresql-development">PostgreSQL development</a>
           
         </p>
       
       <!-- (Marcelo 18-03-20) I commented the 'social sharing' portion below -->
       <!--<div class="customized-socialshare clearfix">
         <div class="widget-span widget-type-social_sharing" style="" data-widget-type="social_sharing" data-x="0" data-w="12">
           <div class="cell-wrapper layout-widget-wrapper">
             <span id="hs_cos_wrapper_module_14364866409015078" class="hs_cos_wrapper hs_cos_wrapper_widget hs_cos_wrapper_type_social_sharing" style="" data-hs-cos-general-type="widget" data-hs-cos-type="social_sharing" ><a href="http://www.facebook.com/share.php?u=https%3A%2F%2Fwww.postgresql.fastware.com%2Fblog%2Finside-logical-replication-in-postgresql%3Futm_medium%3Dsocial%26utm_source%3Dfacebook" target="_blank" rel="noopener" style="width:24px;border-width:0px;border:0px;"><img src="https://static.hubspot.com/final/img/common/icons/social/facebook-24x24.png" class="hs-image-widget hs-image-social-sharing-24" style="max-height:24px;max-width:24px;border-width:0px;border:0px;" width="24" hspace="0" alt="Share on Facebook" loading="lazy"></a> <a href="http://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fwww.postgresql.fastware.com%2Fblog%2Finside-logical-replication-in-postgresql%3Futm_medium%3Dsocial%26utm_source%3Dlinkedin" target="_blank" rel="noopener" style="width:24px;border-width:0px;border:0px;"><img src="https://static.hubspot.com/final/img/common/icons/social/linkedin-24x24.png" class="hs-image-widget hs-image-social-sharing-24" style="max-height:24px;max-width:24px;border-width:0px;border:0px;" width="24" hspace="0" alt="Share on LinkedIn" loading="lazy"></a> <a href="https://twitter.com/intent/tweet?original_referer=https%3A%2F%2Fwww.postgresql.fastware.com%2Fblog%2Finside-logical-replication-in-postgresql%3Futm_medium%3Dsocial%26utm_source%3Dtwitter&url=https%3A%2F%2Fwww.postgresql.fastware.com%2Fblog%2Finside-logical-replication-in-postgresql%3Futm_medium%3Dsocial%26utm_source%3Dtwitter&source=tweetbutton&text=Inside%20logical%20replication%20in%20PostgreSQL%3A%20How%20it%20works" target="_blank" rel="noopener" style="width:24px;border-width:0px;border:0px;"><img src="https://static.hubspot.com/final/img/common/icons/social/twitter-24x24.png" class="hs-image-widget hs-image-social-sharing-24" style="max-height:24px;max-width:24px;border-width:0px;border:0px;" width="24" hspace="0" alt="Share on Twitter" loading="lazy"></a></span>
           </div>
         </div>
       </div>-->
     </div>
    </div>
    <!-- Optional: Blog Author Bio Box -->
    
  </div>
</div>
</div></div>
  </body>
</html>
