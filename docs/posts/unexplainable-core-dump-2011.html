<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stackoverflow.com/questions/4703844/unexplainable-core-dump">Original</a>
    <h1>“Unexplainable” core dump (2011)</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
                
<p>I&#39;ve seen many core dumps in my life, but this one has me stumped.</p>

<p>Context:</p>

<ul>
<li>multi-threaded Linux/x86_64 program running on a cluster of <a href="http://en.wikipedia.org/wiki/AMD_K10">AMD Barcelona</a> CPUs</li>
<li>the code that crashes is executed a <em>lot</em></li>
<li>running 1000 instances of the program (the exact same optimized binary) under load produces 1-2 crashes per hour</li>
<li>the crashes happen on different machines (but the machines themselves are pretty identical)</li>
<li>the crashes all look the same (same exact address, same call stack)</li>
</ul>

<p>Here are the details of the crash:</p>

<pre><code>Program terminated with signal 11, Segmentation fault.
#0  0x00000000017bd9fd in Foo()
(gdb) x/i $pc
=&gt; 0x17bd9fd &lt;_Z3Foov+349&gt;: rex.RB orb $0x8d,(%r15)

(gdb) x/6i $pc-12
0x17bd9f1 &lt;_Z3Foov+337&gt;:    mov    (%rbx),%eax
0x17bd9f3 &lt;_Z3Foov+339&gt;:    mov    %rbx,%rdi
0x17bd9f6 &lt;_Z3Foov+342&gt;:    callq  *0x70(%rax)
0x17bd9f9 &lt;_Z3Foov+345&gt;:    cmp    %eax,%r12d
0x17bd9fc &lt;_Z3Foov+348&gt;:    mov    %eax,-0x80(%rbp)
0x17bd9ff &lt;_Z3Foov+351&gt;:    jge    0x17bd97e &lt;_Z3Foov+222&gt;
</code></pre>

<p>You&#39;ll notice that the crash happened in the <em>middle</em> of instruction at <code>0x17bd9fc</code>, which is after return from a call at <code>0x17bd9f6</code> to a virtual function.</p>

<p>When I examine the virtual table, I see that it is not corrupted in any way:</p>

<pre><code>(gdb) x/a $rbx
0x2ab094951f80: 0x3f8c550 &lt;_ZTI4Foo1+16&gt;
(gdb) x/a 0x3f8c550+0x70
0x3f8c5c0 &lt;_ZTI4Foo1+128&gt;:  0x2d3d7b0 &lt;_ZN4Foo13GetEv&gt;
</code></pre>

<p>and that it points to this trivial function (as expected by looking at the source):</p>

<pre><code>(gdb) disas 0x2d3d7b0
Dump of assembler code for function _ZN4Foo13GetEv:
   0x0000000002d3d7b0 &lt;+0&gt;: push   %rbp
   0x0000000002d3d7b1 &lt;+1&gt;: mov    0x70(%rdi),%eax
   0x0000000002d3d7b4 &lt;+4&gt;: mov    %rsp,%rbp
   0x0000000002d3d7b7 &lt;+7&gt;: leaveq 
   0x0000000002d3d7b8 &lt;+8&gt;: retq   
End of assembler dump.
</code></pre>

<p>Further, when I look at the return address that <code>Foo1::Get()</code> should have returned to:</p>

<pre><code>(gdb) x/a $rsp-8
0x2afa55602048: 0x17bd9f9 &lt;_Z3Foov+345&gt;
</code></pre>

<p>I see that it points to the right instruction, so it&#39;s as if during the return from <code>Foo1::Get()</code>, some gremlin came along and incremented <code>%rip</code> by 4.</p>

<p>Plausible explanations?</p>
    </div></div>
  </body>
</html>
