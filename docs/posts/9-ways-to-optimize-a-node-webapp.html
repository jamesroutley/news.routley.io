<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/Dev-Notes/Javascript/9-Ways-to-optimize-a-Node-Webapp">Original</a>
    <h1>9 Ways to optimize a Node Webapp</h1>
    
    <div id="readability-page-1" class="page"><article><p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/3f89be910009459066e2e7f874ede5ec.jpeg" alt="image"/></p>
<p><em>Lessons I’ve learned on optimizing the performance of web applications while building a multiplayer game with websockets</em></p>

<p>The browser has a wealth of tools that allow us to peek into our application. I’ll be focusing on the Network and Performance tabs of Google Chrome, but I suspect this is just the tip of the iceburg.</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/b4d14ef00dc64ab4ec6395c14dc5d286.png" alt="image"/></p>
<h2 id="a-the-network-tab">A) The Network Tab<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#a-the-network-tab"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>I was familiar with this tab before this project but hadn’t drilled down to the sizes, compression, and load time of each individual request. In fact, I hadn’t totally comprehended how this list of requests encapsulates a truer representation of my project than the IDE does, because here I can see the order of execution of not only my code, but all of the dependencies my project relies on to function. For example, I can see how Vite is bundling my JavaScript, HML and CSS files, and then chunking it. I can also see every google font I am requesting, and every npm package.</p>
<p>For example, we can see the entirety of the Socket.io library being installed from NPM here:</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/1ca5de826ab04e931dc1916c65fe3fb4.png" alt="image"/></p>
<p>We can see the browser requesting every part of the THREE.JS library it needs <em>here</em>:
<img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/5962702e1635baeb476980e3bc17a50f.png" alt="image"/></p>
<p>Next on our tour is the timing window, where we can see how long each step of a script takes:</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/9c935991ed7945d34c4fa28184cfba19.png" alt="image"/></p>
<blockquote>
<p>This is ThreeJS again ^</p>
</blockquote>
<p>Chrome also provides a helpful visualization of all messages sent over websockets, which can be zeroed in on by clicking the websocket filter
<img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/58ae12bbd5f5d279031510329a7690c1.png" alt="image"/></p>
<p>And allow us to see a play-by-play of the messages sent on a particular WS channel:</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/dc74072f6907ee2a6b6a3e0d269fb8e9.png" alt="image"/></p>
<h2 id="b-the-performance-tab">B) The Performance Tab<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#b-the-performance-tab"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>As powerful as the network tab is, the performance tab is like a spaceship. When I first opened this, I was so overwhelmed it didn’t even seem like it contained any useful information. As I’ve used it more, I’ve learned that it’s a swiss-army knife that can be used in a variety of ways.</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/de4a8c4372d8b855644c773ab15fed40.png" alt="image"/></p>
<p>When zoomed in, it shows every process run on a website.<img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/d7ad0a484da94b5b0b5af38148f7cce8.png" alt="image"/>
Those processes can be cross-referenced with still taken from renders of the website displayed in parallel, above them:</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/5ff73eaa143ac9e7a4e267eb9be560a8.png" alt="image"/></p>
<p>And each process can be clicked on in order to understand the exact sub-processes that it triggers and is dependent on and has relationships with, how long each one took, how much memory, how much CPU.</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/752df6d741558332f634b40a6fd0f1e0.png" alt="image"/></p>
<p>It’s great for:</p>
<ul>
<li>Zooming in on a particular event in an application</li>
<li>Investigating what order functions are called in the event loop</li>
<li>Discovering memory leaks using the graph of memory and other performance metrics</li>
<li>Seeing when garbage collection takes place (or doesn’t)</li>
</ul>

<p>We’ve looked at a lot of profiling in the client, but it is also possible to profile the server. In order to start this process, <a href="https://nodejs.org/en/learn/getting-started/debugging">run your server file with the <code>--inspect</code> flag:<svg viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>node </span><span>--</span><span>inspect index.js</span></span></code></pre></figure>
<p>You should see some output that looks a little something like:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>Debugger listening on </span><span>ws</span><span>:</span><span>//127.0.0.1:9229/7825c3f2-d5c0-4c44-b6fe-dbb616650ae7</span></span>
<span data-line=""><span>For help, </span><span>see</span><span>: </span><span>https</span><span>:</span><span>//nodejs.org/en/docs/inspector</span></span></code></pre></figure>
<blockquote>
<p>I’m not really sure what this output is about to be honest. When I navigate to the supplied URL, I don’t see anything.</p>
</blockquote>
<p>Next, we navigate to chrome://inspect, and press “inspect” on our remote target,</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/dead2b731075e1026f59c5cb4d1b616d.png" alt="image"/></p>
<p>providing us with a profiler window much like what we have seen on the client:</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/8184e4b31674071968da29460507e3bd.png" alt="image"/>
We can record activity in the Performance tab just like we’ve been doing in the client as well, and see the slew of events being recorded.</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/10bfbca80c28e46ff98d07ef25c566f9.png" alt="image"/></p>
<p>Which is amazing because I can zoom in to see exactly how long each of my methods take to run in the call tree:</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/a4b8bb9e24a825c52149a5023d4bdf82.png" alt="image"/></p>
<blockquote>
<p>Zoomed in view of the event stream</p>
</blockquote>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/f37e130193a54e2d6202e85c771989d7.png" alt="image"/></p>
<blockquote>
<p>The call tree that makes up my <code>getState</code> function</p>
</blockquote>

<p>You might benefit from automated browser testing if:</p>
<ul>
<li>your roommate is out and can’t test your site</li>
<li>you are developing carpal tunnel syndrome from repeatedly typing <code>localhost:5163</code></li>
</ul>
<p>My tool of choice is called Playwright, which I was introduced to by the excellent <a href="https://www.linkedin.com/in/james-watters-tech/">James Watters<svg viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>when I worked at <a href="https://www.linkedin.com/feed/">Tcare<svg viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>. Playwright is a well-documented, asynchronous testing framework for the browser performance of Python, Java, Net and Javascript webapps.</p>
<p>It supports all major browsers and will translate browser actions into code to help you write tests quickly. It also has a profiler that allows a test to be “rewinded”, saved, and loaded.</p>
<p>It <em>also</em> allows for tests to be run in parallel, which I have taken full advantage of to stress test my application.</p>
<p><video muted="" loop="" autoplay="" controls=""> <source src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/3c0631838546db1ff90e5dbe1cdfa82f.mov"/> Your browser does not support the video tag. </video></p>
<p>What slowly became apparent was that manually testing my application was not empirical enough. By nature of being human, testing my application introduced too many unknowable or unquantifiable independent variables to compare different architectures or configurations with the certainty that I wasn’t in fact comparing some inconsistency I had introduced.</p>
<p>Just pressing a few buttons as a single user in this game wasn’t adequate or consistent as a test. Only under heavy load and the strange edge cases that can be created by twelve, or even twenty autonomous agents, can I quickly and reliably discover weaknesses in my code.</p>
<p>For example, I attempted to batch the update events emitted by my server to every client, and quickly found that collapsing the updates of a single entity into the most recent event caused a lot of side effects.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>updates </span><span>=</span><span> [</span></span>
<span data-line=""><span>	&#39;object-09ua9u&#39;</span><span>: [</span><span>...</span><span>],</span></span>
<span data-line=""><span>	&#39;object-08uaus&#39;</span><span>: [</span><span>...</span><span>]</span></span>
<span data-line=""><span>	&#39;object-a89273&#39;</span><span>: [</span></span>
<span data-line=""><span>		&#34;create&#34;</span><span>: {x: </span><span>2</span><span>, y: </span><span>3</span><span>},</span></span>
<span data-line=""><span>		&#34;move&#34;</span><span>: {x: </span><span>2</span><span>, y: </span><span>4</span><span>},</span></span>
<span data-line=""><span>		&#34;delete&#34;</span><span>: </span><span>null</span></span>
<span data-line=""><span>	]</span></span>
<span data-line=""><span>]</span></span></code></pre></figure>
<p>Automated testing made this apparent almost immediately in a way manual testing probably wouldn’t have. In the end, testing with playwright has saved me a lot of time and hassle and provided me with the first real clear performance metrics I had in this process. I wish I had started doing this on the first day.</p>
<p>One challenge I have faced is outputting metrics aggregated from each test instance. My scrappy solution was building a test server than can receive memory usage gathered by each test and print out the average.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="typescript" data-theme="github-light github-dark"><code data-language="typescript" data-theme="github-light github-dark"><span data-line=""><span>// Start memory usage collection</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> intervalId</span><span> =</span><span> setInterval</span><span>(</span><span>async</span><span> () </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>	const</span><span> memory</span><span> =</span><span> await</span><span> page.</span><span>evaluate</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>		const</span><span> performance</span><span> =</span><span> window.performance </span><span>as</span><span> Performance</span><span> &amp;</span><span> { </span><span>memory</span><span>?:</span><span> any</span><span> };</span></span>
<span data-line=""><span>			if</span><span> (performance </span><span>&amp;&amp;</span><span> performance.memory) {</span></span>
<span data-line=""><span>				return</span><span> {</span></span>
<span data-line=""><span>					jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,</span></span>
<span data-line=""><span>					totalJSHeapSize: performance.memory.totalJSHeapSize,</span></span>
<span data-line=""><span>					usedJSHeapSize: performance.memory.usedJSHeapSize,</span></span>
<span data-line=""><span>				};</span></span>
<span data-line=""> </span>
<span data-line=""><span>			}</span></span>
<span data-line=""> </span>
<span data-line=""><span>		return</span><span> null</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>	});</span></span>
<span data-line=""> </span>
<span data-line=""><span>	if</span><span> (memory) {</span></span>
<span data-line=""><span>		memoryUsageData.</span><span>push</span><span>(memory.usedJSHeapSize </span><span>/</span><span> 1024</span><span> /</span><span> 1024</span><span>); </span><span>// Convert bytes to MB</span></span>
<span data-line=""><span>	}</span></span>
<span data-line=""> </span>
<span data-line=""><span>}, </span><span>1000</span><span>); </span><span>// Collect data every second</span></span>
<span data-line=""> </span>
<span data-line=""><span>...</span></span>
<span data-line=""> </span>
<span data-line=""><span>await</span><span> fetch</span><span>(</span><span>&#39;http://localhost:3088/report/&#39;</span><span>, {</span></span>
<span data-line=""><span>	method: </span><span>&#39;POST&#39;</span><span>,</span></span>
<span data-line=""><span>	headers: {</span></span>
<span data-line=""><span>	&#39;Content-Type&#39;</span><span>: </span><span>&#39;application/json&#39;</span></span>
<span data-line=""><span>	}, body: </span><span>JSON</span><span>.</span><span>stringify</span><span>({ avgMemoryUsage, maxMemoryUsage, minMemoryUsage})</span></span>
<span data-line=""><span>})</span></span></code></pre></figure>
<p>In the future I would like to check out a load-testing library called <a href="https://www.artillery.io/">artillery<svg viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> and to investigate better ways to log test results.</p>

<p>I happened to be in a room full of people so I walked around and just told them to try out my live demo.</p>
<p><video muted="" loop="" autoplay="" controls=""> <source src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/8c3b99e796595dce53d598e5b754fefe.mov" type="video/mp4"/> Your browser does not support the video tag. </video></p>
<blockquote>
<p>User testing is the most indispensable performance testing tactic of them all, but it’s an even better <em>design</em> tactic, as it allows you to see what human beings actually respond to.</p>
</blockquote>
<p>Playwright is great, and so is automated testing, but it has some weaknesses. If I tell playwright to open up 24 chromium instances on my brave little Macbook Air, I’m not really testing concurrent connections anymore. I’m just overstepping the reasonable memory limitations of my computer, and no longer getting very meaningful results.</p>
<p>This is the perfect example of how tests in at least an exact copy of the production are the only way to truly know the performance of an application. This includes user behavior - users do unexpected things without exception, and I don’t believe it’s possible to forecast the effect user behavior will have on performance, especially in something like a multiplayer game. It’s a far more effective use of time to observe and take notes.</p>
<p>Like Tommy Caldwell on pitch 15, you can build an exact replica of specific, significant performance challenges you see out in the world. You can try to solve them in every possible way in a controlled environment, and see if your results check out.</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/f13da2561c3c1c516a84c481c970e7ca.png" alt="image"/></p>
<blockquote>
<p>Photo by <a href="https://www.instagram.com/beccajcaldwell/?hl=en">Becca Caldwell<svg viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
</blockquote>

<p>It’s a little embarrassing, but until last week I really can’t say I understood how <code>logging</code> as a concept was distinct from <code>console.logging</code> in JS or <code>print</code> in python.</p>
<p>Somewhere in between that first <code>Hello World</code> and the situation in which I was setting up cloud watch alerts on the log for an EC2 instance at my job, I had an opportunity to ask “What is the fundamental makeup of these pieces of text, and how are they different than one another?” And I never really did that.</p>
<p>During this project, I’ve checked the logs of the running processes of the community server I’m using. Chaotically, these logs are shared by about ten different projects. I have to admit, I like this - it makes visualizing the community server’s activity dead simple. It’s one server, it’s serving a dozen projects, and this is what it brain looks like.</p>
<p>But if you see this long enough, and you start to think, “there must be a better way”. Something along the lines of, I dunno, what if we just concatenated these lines of text into a file, but maybe separate files. That way they’d:</p>
<ul>
<li>Persist</li>
<li>Be separated into meaningful streams of information</li>
</ul>
<p>Since we could ostensibly format the text ourselves, we could really reform the text to have any timestamp conventions we want, any indentation, etc. Whatever was easiest for us to read, really.</p>
<p>And you start to think, well, if I don’t trust the persistence of the server, I could save it to a database. Or even to another server. Or I could even email things to myself - it’s logging, not a web protocol. The information should be structured and transmitted in the ways that are most valuable for debugging.</p>
<p>So you write something like this to get started:
<img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/76320a2bae2bf78e52e8b142d2a4289f.png" alt="image"/></p>
<p>And think, cool, now the next time my server crashes, I’ll know why.</p>

<p>Testing individual functions for performance seems like a good idea - one I have not yet done. I would imagine the browser profiling tools may be able to help with some of this, automated testing tools could to, and there may also be tools that allow this to be done inside of an IDE. What I imagine is something that catalogues every method and records how long it takes to run on average over several instances.</p>

<p>Originally, I sent the entire board state of my game both:</p>
<ul>
<li>From the server to the client</li>
<li>From the client to server</li>
</ul>
<p>It was a lot of network overhead. I changed this architecture to <em>only</em> send updates of individual entities. In the profiling section, I also mention an attempt at batching some of these updates (with less success so far). Both of these changes represent ways that the interplay between client and server could be made more efficient.</p>
<p>It’s important to validate these things before enacting them. I’ll admit, I did this refactor on a hunch. My refactor saved about 14MB of unnecessary data being sent with each request. This is nice, but it took me about a week.</p>
<p>I paired this refactor with re-using rendered geometries and meshes on the frontend rather than tearing down every object in the scene and re-instantiating it.</p>
<p>Even together, the combined performance gains of these refactors are humble.</p>
<p>However, they are definitely a better design, and had I been more experienced at this interplay of a 3D-ish world being synchronized over websockets, I might have designed it from the beginning.</p>
<p>Some other architectural / data model changes I’d like to explore:</p>
<ul>
<li>Locality: limiting updates to players within a certain range of those updates</li>
<li>A sparser representation of initial state</li>
<li>A sparser representation of <em>all</em> state, possibly using raw binary instead of unicode</li>
</ul>
<p>What I’ve learned from these architectural changes is that architectural refactors are costly in terms of time, and it’s prudent to profile prototypes of these changes. Doing this research up front can make sure that time is being used to solve tangible performance issues.</p>

<p>Sometimes the best way to break down a complex pipeline, application, or interconnected set of any sort of processes is to walk someone else through it. In the process, it seems common to realize new perspectives on what was built. The person we walk through this process almost always can offer some additional novel perspectives as well.</p>
<p>I was lucky enough to pair with <a href="https://www.linkedin.com/in/robin-neufeld-2b4847a4/?original_referer=https%3A%2F%2Fwww%2Egoogle%2Ecom%2F&amp;originalSubdomain=ca">Robin Neufeld<svg viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> on this project. I was straightforward about my optimization goal was:</p>
<p><em>allow about 10 people to join and play the game without experiencing noticeable lag</em></p>
<p>And that although I could think of many potential performance improvements, I didn’t know which one would be the most productive in achieving my goal. However, after walking her through all the tools I had at my disposal for assessing different techniques, I feel a lot closer to understanding how my goal could be achieved.</p>
<blockquote>
<p>A list of the most promising optimizations I could implement</p>
</blockquote>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/69efc5f5792c38308e28009287830215.jpeg" alt="image"/></p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/60c018f203303a4425f95de54dde2942.jpeg" alt="image"/></p>
<blockquote>
<p>A scrappy list of why I might experience performance issues in certain situations</p>
</blockquote>
<p>Robin took a very stress free dive into profiling tools and just sort of opened up my ability to interface with these tools. I was very driven and specific in how I wanted to use them, but Robin was not, and consequently seemed to play around with them a lot more, discovering a lot of the features about these browser profiling tools I have documented above.</p>
<p>Most importantly, Robin kept me on track, not allowing me to dive into rabbitholes that weren’t yet validated as worthwhile.</p>

<p>Some examples</p>
<ul>
<li>Different Deployments</li>
<li>Different Machines</li>
<li>Different Browsers</li>
<li>Different Node Versions</li>
</ul>
<p>The bottom line is, consider the assumptions you are making about the universality of the environment you are running your code in and explore how it behaves in as many other environments as possible.</p>
<p>The local / remote comparison is one of the most important. I’ve become a very big believer in deploying early, since a deployed environment and the considerations that come with it are often dramatically different than a local environment. Learning lessons in this early in a project’s lifecycle can sometimes change the architecture of a project in ways that will be difficult to implement later on.</p>
<p>I am a full-stack web developer with no formal CS training. I started with frontend javascript web frameworks for the most part, moved on to server-side development mostly in the very abstract languages of Javascript and Python, and then eventually began to engage in Devops almost exclusively with highly abstracted cloud service products. Only recently have I begun learning about the low-level components that power these things, like distributed computing, memory-safe languages, virtual memory, web protocols, and a slew of technologies closer to the actual hardware powering the abstractions I’ve grown so familiar with.</p>
<p>From this perspective, it’s a bit easier to ignore the differences of different server setups. But I’m coming to realize that understanding the base hardware, or at least the architecture of the distributed or server-less service being used, is crucial to understanding what my performance expectations should be.
<img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/2b817e57449169bff96c9bdf0c9aafd1.png" alt="image"/>
<img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/25b15f7299eaaf14a1870f5431c8c0a4.png" alt="image"/></p>
<p>All deployment examples you’ve seen so far are run off of a raspberry pi in the next room that is serving about fourteen other fun projects:</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/ccc5d1d3d97deee0289c571427268598.png" alt="image"/></p>
<p>It’s a great solution because these projects are mostly pretty small in scale, and don’t usually deal with simultaneous traffic, as they are generally demo’d and tested at different times.</p>
<p>However, it’s obviously not the most robust server solution! So even after all this optimization work, my expectations can only be so high.</p>
<p>In the future, I really look forward to using these tools to understanding the performance tradeoffs of many other types of deployment solutions, memories, data structures, and architectures. I set out to make a fun game, never knowing that the performance hurtles I discovered would teach me far more about programming than the game logic or network protocols ever would.</p></article></div>
  </body>
</html>
