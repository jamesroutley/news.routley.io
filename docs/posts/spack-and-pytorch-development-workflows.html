<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rgoswami.me/posts/spack-pytorch-dev-workflow/">Original</a>
    <h1>Spack and PyTorch Development Workflows</h1>
    
    <div id="readability-page-1" class="page"><div><blockquote><p><code>pytorch</code> local development environments without tears, root access or <code>spack dev-build</code></p></blockquote><h2 id="background">Background</h2><p>Build systems are a bit of a nightmare. I spend most of my time SSH’ed into more
powerful CPU machines, and sometimes on machines with more exotic compute
devices. <code>micromamba</code> is typically my poison of choice where <code>nix</code> is not
an option.</p><p>However, <code>micromamba</code> doesn’t allow a whole lot in the way of setting up
environments which do not use packages already on <code>conda-forge</code>. <a href="https://spack.readthedocs.io/en/latest/getting_started.html">Spack</a> fills a
nice niche for such situations<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. Additionally, it can be coerced
into use for local development and the same cannot easily be said of <code>conda</code>
based workflows.</p><h2 id="humble-origins">Humble Origins</h2><p>We’ll start from scratch, grabbing <code>spack</code> and bootstrapping <code>clingo</code> for its
dependency resolution as per <a href="https://spack.readthedocs.io/en/latest/getting_started.html">the documentation</a>.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>git clone -c feature.manyFiles<span>=</span><span>true</span> https://github.com/spack/spack.git
</span></span><span><span>2</span><span>. spack/share/spack/setup-env.sh <span># Assumes zsh || bash</span>
</span></span><span><span>3</span><span>spack spec zlib <span># Or anything really</span>
</span></span><span><span>4</span><span>spack --bootstrap find <span># Should have clingo</span>
</span></span></code></pre></div><h3 id="environments-and-purity">Environments and Purity</h3><p>Unlike <code>nix</code>, <code>spack</code> does not offer strong guarantees of purity. There are
primarily two approaches to using environments in <code>spack</code>, somewhat analogously
to the <code>conda</code> environment logic.</p><dl><dt><strong>Named Environments</strong></dt><dd>These are essentially equivalent to <code>conda</code> environments, and can be activated and deactivated at will. However, the folder structure in this case, along with the dependencies are localized within <code>$SPACK_HOME/var/spack/environments/$ENV_NAME</code></dd><dt><strong>Anonymous Environments</strong></dt><dd>These can be setup inside any directory, and can be activated but not deactivated (<code>despacktivate</code> will not work). These are useful for development environments.</dd></dl><p>We will use both kinds of environments. Additionally, <code>spack</code> supports multiple
<code>variants</code> which can be queried by <code>spack info $PKG_NAME</code>. These are used to
support various build configurations while providing a unified interface build
through <code>spack install</code>.</p><h2 id="basic-anonymous-environments">Basic Anonymous Environments</h2><p>For starters we will need to setup a development environment.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>mkdir spackPyTorch
</span></span><span><span>2</span><span><span>cd</span> spackPyTorch
</span></span><span><span>3</span><span>spack env create -d .
</span></span></code></pre></div><p>To ensure that the dependencies are resolved consistently, the <code>concretization</code>
option to needs to be set to <code>together</code>. We will start by adding some packages.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>spack -e . add py-ipython
</span></span><span><span>2</span><span>spack -e . config edit <span># Make changes</span>
</span></span></code></pre></div><p>For ease of manual customization, it is best to lightly edit the <code>spack.yaml</code>
file to have each dependency on its own line. At this point a bare-minimum
near-empty environment is ready.</p><div><pre tabindex="0"><code data-lang="yaml"><span><span>1</span><span><span>spack</span><span>:</span><span>
</span></span></span><span><span>2</span><span><span>  </span><span>specs</span><span>:</span><span>
</span></span></span><span><span>3</span><span><span>    </span>- <span>py-ipython</span><span>
</span></span></span><span><span>4</span><span><span>  </span><span>view</span><span>:</span><span> </span><span>true</span><span>
</span></span></span><span><span>5</span><span><span>  </span><span>concretization</span><span>:</span><span> </span><span>together</span><span>
</span></span></span></code></pre></div><p>To ensure dependencies are resolved simultaneously, <code>concretize</code> is set to
<code>together</code>.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>spack -e . concretize <span># doesn&#39;t install</span>
</span></span><span><span>2</span><span>spack -e . install
</span></span><span><span>3</span><span>spack env activate . <span># or spacktivate .</span>
</span></span><span><span>4</span><span><span># Can also use the fully qualified path instead of .</span>
</span></span></code></pre></div><p>Recall that changes are propagated via:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>spack -e . concretize --force
</span></span><span><span>2</span><span>spack -e . install
</span></span></code></pre></div><p>This establishes baseline environments, but precludes setting up development
workflows. Most packages can be included as described above, with the exception
of compiler toolchains.</p><h3 id="compiler-setups">Compiler Setups</h3><p>Setting up compiler toolchains like a <code>fortran</code> compiler (perhaps for
<code>openblas</code>) can take a bit more effort. Although this discussion will focus on
obtaining a <code>fortran</code> compiler it is equally applicable to updating a version.
For <code>spack</code>, unlike many system package managers, <code>gcc</code> will install the <code>C</code>,
<code>C++</code> and <code>Fortran</code> toolchains. Thus:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span><span># outside the spack environment</span>
</span></span><span><span>2</span><span>spack install gcc@11.2.0 <span># will take a while</span>
</span></span></code></pre></div><p>Now we need to let <code>spack</code> register this compiler.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>spack compiler find <span>$(</span>spack location -i gcc@11.2.0<span>)</span>
</span></span><span><span>2</span><span>spack compilers <span># should now list GCC 11.2.0</span>
</span></span></code></pre></div><p>Finally we can edit our <code>spack.yml</code> environment to reflect the new compiler toolchain.</p><div><pre tabindex="0"><code data-lang="yaml"><span><span>1</span><span><span>spack</span><span>:</span><span>
</span></span></span><span><span>2</span><span><span>  </span><span>definitions</span><span>:</span><span>
</span></span></span><span><span>3</span><span><span>    </span>- <span>compilers</span><span>:</span><span> </span><span>[</span><span>gcc@11.2.0]</span><span>
</span></span></span><span><span>4</span><span><span>  </span><span>specs</span><span>:</span><span>
</span></span></span><span><span>5</span><span><span>    </span>- <span>py-ipython</span><span>
</span></span></span><span><span>6</span><span><span>  </span><span>view</span><span>:</span><span> </span><span>true</span><span>
</span></span></span><span><span>7</span><span><span>  </span><span>concretization</span><span>:</span><span> </span><span>together</span><span>
</span></span></span></code></pre></div><p>One of the nicer parts of <code>spack</code> being an HPC environment management tool is
that there is first-class support for proprietary compiler toolchains like Intel
and families of compilers can also be specified with the <code>%intel</code> syntax as
well. Much <a href="https://spack-tutorial.readthedocs.io/en/latest/tutorial_configuration.html#yaml-format">more fine-tuning</a> is also possible including registering system
compilers if required.</p><h2 id="pytorch-local-development">PyTorch Local Development</h2><p>One of the caveats of local development with <code>spack</code> is that the base URL needs
to be updated from within the local copy of <code>spack</code>. This means editing:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>vim <span>$SPACK_ROOT</span>/var/spack/repos/builtin/packages/py-torch/package.py <span># edit</span>
</span></span></code></pre></div><p>The patch is minimally complicated, for a fork and a working branch like <code>npeye</code>
it would look like this diff:</p><div><pre tabindex="0"><code data-lang="diff"><span><span> 1</span><span><span>diff --git a/var/spack/repos/builtin/packages/py-torch/package.py b/var/spack/repos/builtin/packages/py-torch/package.py
</span></span></span><span><span> 2</span><span><span>index 8190e01102..c276009d10 100644
</span></span></span><span><span> 3</span><span><span></span><span>--- a/var/spack/repos/builtin/packages/py-torch/package.py
</span></span></span><span><span> 4</span><span><span></span><span>+++ b/var/spack/repos/builtin/packages/py-torch/package.py
</span></span></span><span><span> 5</span><span><span></span><span>@@ -14,7 +14,7 @@ class PyTorch(PythonPackage, CudaPackage):
</span></span></span><span><span> 6</span><span><span></span>     with strong GPU acceleration.&#34;&#34;&#34;
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span>     homepage = &#34;https://pytorch.org/&#34;
</span></span><span><span> 9</span><span><span>-    git      = &#34;https://github.com/pytorch/pytorch.git&#34;
</span></span></span><span><span>10</span><span><span></span><span>+    git      = &#34;https://github.com/HaoZeke/pytorch.git&#34;
</span></span></span><span><span>11</span><span><span></span>
</span></span><span><span>12</span><span>     maintainers = [&#39;adamjstewart&#39;]
</span></span><span><span>13</span><span>
</span></span><span><span>14</span><span><span>@@ -22,6 +22,7 @@ class PyTorch(PythonPackage, CudaPackage):
</span></span></span><span><span>15</span><span><span></span>     # core libraries to ensure that the package was successfully installed.
</span></span><span><span>16</span><span>     import_modules = [&#39;torch&#39;, &#39;torch.autograd&#39;, &#39;torch.nn&#39;, &#39;torch.utils&#39;]
</span></span><span><span>17</span><span>
</span></span><span><span>18</span><span><span>+    version(&#39;npeye&#39;, branch=&#39;npeye&#39;, submodules=True)
</span></span></span><span><span>19</span><span><span></span>     version(&#39;master&#39;, branch=&#39;master&#39;, submodules=True)
</span></span><span><span>20</span><span>     version(&#39;1.11.0&#39;, tag=&#39;v1.11.0&#39;, submodules=True)
</span></span><span><span>21</span><span>     version(&#39;1.10.2&#39;, tag=&#39;v1.10.2&#39;, submodules=True)
</span></span><span><span>22</span><span><span>@@ -348,7 +349,8 @@ def enable_or_disable(variant, keyword=&#39;USE&#39;, var=None, newer=False):
</span></span></span><span><span>23</span><span><span></span>         elif &#39;~onnx_ml&#39; in self.spec:
</span></span><span><span>24</span><span>             env.set(&#39;ONNX_ML&#39;, &#39;OFF&#39;)
</span></span><span><span>25</span><span>
</span></span><span><span>26</span><span><span>-        if not self.spec.satisfies(&#39;@master&#39;):
</span></span></span><span><span>27</span><span><span></span><span>+        if not (self.spec.satisfies(&#39;@master&#39;) or
</span></span></span><span><span>28</span><span><span>+                self.spec.satisfies(&#39;@npeye&#39;)):
</span></span></span><span><span>29</span><span><span></span>             env.set(&#39;PYTORCH_BUILD_VERSION&#39;, self.version)
</span></span><span><span>30</span><span>             env.set(&#39;PYTORCH_BUILD_NUMBER&#39;, 0)
</span></span></code></pre></div><p>Applying such a patch is straightforward.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span><span>cd</span> <span>$SPACK_ROOT</span>
</span></span><span><span>2</span><span><span># Assuming it is named pytorchspack.diff</span>
</span></span><span><span>3</span><span>git apply pytorchspack.diff
</span></span></code></pre></div><p>This modified environment can now be enabled for use with the appropriate
variants (details found with <code>spack info py-torch</code>).
However, there is one rather important variant missing for local development,
<code>DEBUG</code>. The application of this patch will rectify this until <a href="https://github.com/spack/spack/pull/30267">an upstream PR</a> is
merged.</p><div><pre tabindex="0"><code data-lang="diff"><span><span> 1</span><span><span>diff --git a/var/spack/repos/builtin/packages/py-torch/package.py b/var/spack/repos/builtin/packages/py-torch/package.py
</span></span></span><span><span> 2</span><span><span>index 8190e01102..d7b68ae4bd 100644
</span></span></span><span><span> 3</span><span><span></span><span>--- a/var/spack/repos/builtin/packages/py-torch/package.py
</span></span></span><span><span> 4</span><span><span></span><span>+++ b/var/spack/repos/builtin/packages/py-torch/package.py
</span></span></span><span><span> 5</span><span><span></span><span>@@ -49,6 +49,7 @@ class PyTorch(PythonPackage, CudaPackage):
</span></span></span><span><span> 6</span><span><span></span>
</span></span><span><span> 7</span><span>     # All options are defined in CMakeLists.txt.
</span></span><span><span> 8</span><span>     # Some are listed in setup.py, but not all.
</span></span><span><span> 9</span><span><span>+    variant(&#39;debug&#39;, default=False, description=&#34;Build with debugging support&#34;)
</span></span></span><span><span>10</span><span><span></span>     variant(&#39;caffe2&#39;, default=True, description=&#39;Build Caffe2&#39;, when=&#39;@1.7:&#39;)
</span></span><span><span>11</span><span>     variant(&#39;test&#39;, default=False, description=&#39;Build C++ test binaries&#39;)
</span></span><span><span>12</span><span>     variant(&#39;cuda&#39;, default=not is_darwin, description=&#39;Use CUDA&#39;)
</span></span><span><span>13</span><span><span>@@ -343,6 +344,12 @@ def enable_or_disable(variant, keyword=&#39;USE&#39;, var=None, newer=False):
</span></span></span><span><span>14</span><span><span></span>         enable_or_disable(&#39;gloo&#39;, newer=True)
</span></span><span><span>15</span><span>         enable_or_disable(&#39;tensorpipe&#39;)
</span></span><span><span>16</span><span>
</span></span><span><span>17</span><span><span>+        if &#39;+debug&#39; in self.spec:
</span></span></span><span><span>18</span><span><span>+            env.set(&#39;DEBUG&#39;, 1)
</span></span></span><span><span>19</span><span><span>+        elif &#39;-debug&#39; or &#39;~debug&#39; in self.spec:
</span></span></span><span><span>20</span><span><span>+            env.set(&#39;DEBUG&#39;, &#39;0&#39;)
</span></span></span><span><span>21</span><span><span>+
</span></span></span><span><span>22</span><span><span>+
</span></span></span><span><span>23</span><span><span></span>         if &#39;+onnx_ml&#39; in self.spec:
</span></span><span><span>24</span><span>             env.set(&#39;ONNX_ML&#39;, &#39;ON&#39;)
</span></span><span><span>25</span><span>         elif &#39;~onnx_ml&#39; in self.spec:
</span></span></code></pre></div><p>All together now the variants can be used in conjunction with the development
branch. To focus on the <code>pytorch</code> workflow, we will unpin <code>python@3.10</code> and add
<code>ipython</code> instead.</p><h3 id="cpu">CPU</h3><p>Normally, for a CPU build we would setup something like the following:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span><span>DEBUG</span><span>=</span><span>1</span> <span>USE_DISTRIBUTED</span><span>=</span><span>0</span> <span>USE_MKLDNN</span><span>=</span><span>0</span> <span>USE_CUDA</span><span>=</span><span>0</span> <span>BUILD_TEST</span><span>=</span><span>0</span> <span>USE_FBGEMM</span><span>=</span><span>0</span> <span>USE_NNPACK</span><span>=</span><span>0</span> <span>USE_QNNPACK</span><span>=</span><span>0</span> <span>USE_XNNPACK</span><span>=</span><span>0</span> <span>BUILD_CAFFE2</span><span>=</span><span>0</span> <span>USE_KINETO</span><span>=</span><span>0</span> python setup.py develop
</span></span></code></pre></div><p>The rationale behind the build flags can be found in the <a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md">upstream contributing
guide</a>. In an appropriately defined environment. For us, this translates to
(with the patch added for <code>debug</code>):</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>spacktivate .
</span></span><span><span>2</span><span><span># CPU only, disable cuda</span>
</span></span><span><span>3</span><span><span># Also disable a bunch of optionals</span>
</span></span><span><span>4</span><span>spack add py-torch@npeye -cuda -fbgemm -nnpack -mkldnn -test -qnnpack +debug
</span></span><span><span>5</span><span>spack concretize -f
</span></span></code></pre></div><p>However, we need to also register this package for development (with the branch
setup previously), which is accomplished by:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>spack develop py-torch@npeye -cuda -fbgemm -nnpack -mkldnn -test -qnnpack +debug
</span></span></code></pre></div><p>This generates a sub-directory <code>py-torch</code> with the right branch checked out,
along with the dependencies needed for the build. Additionally, the
<code>python</code> version is also localized to the <code>spack</code> installation spec.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>spack install <span># concretizes and installs</span>
</span></span></code></pre></div><p>If additional dependencies are required for testing or other purposes, they are
easily obtained. After making changes <code>spack install</code> will rebuild with the
appropriate flags.</p><h3 id="cuda-setup">CUDA Setup</h3><p>The good news is that updating the build system to use CUDA is very
straightforward. While changing variants, it is occasionally necessary to
forcibly clear out the cache.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span><span>cd</span> py-torch
</span></span><span><span>2</span><span>rm -rf build
</span></span><span><span>3</span><span>python setup.py clean
</span></span><span><span>4</span><span><span># More extreme cases</span>
</span></span><span><span>5</span><span>git submodule deinit -f .
</span></span><span><span>6</span><span>git clean -xdf
</span></span><span><span>7</span><span>python setup.py clean
</span></span><span><span>8</span><span>git submodule update --init --recursive --jobs <span>0</span>
</span></span><span><span>9</span><span>python setup.py develop
</span></span></code></pre></div><p>We will require the CUDA version to install the appropriate tool-chain.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span><span>export</span> <span>NVCC_CUDA_VERSION</span><span>=</span><span>$(</span>nvidia-smi -q <span>|</span> awk -F<span>&#39;: &#39;</span> <span>&#39;/CUDA Version/ {print $2}&#39;</span><span>)</span>
</span></span><span><span>2</span><span>spack add cuda@<span>$NVCC_CUDA_VERSION</span>
</span></span><span><span>3</span><span>spack concretize --force
</span></span><span><span>4</span><span>spack install
</span></span></code></pre></div><p>One caveat of CUDA installations (which cannot be dealt with here) is that
<code>spack</code> needs to have read/write access to <code>/tmp/cuda-installer.log</code> because of
a <a href="https://forums.developer.nvidia.com/t/change-the-path-of-install-log-when-installing-cuda-toolkit/183179">ridiculous upstream bug</a>.</p><p>Finally we update the <code>spack.yaml</code> to reflect our new changes:</p><div><pre tabindex="0"><code data-lang="yaml"><span><span> 1</span><span><span>spack</span><span>:</span><span>
</span></span></span><span><span> 2</span><span><span>  </span><span>definitions</span><span>:</span><span>
</span></span></span><span><span> 3</span><span><span>  </span>- <span>compilers</span><span>:</span><span> </span><span>[</span><span>gcc@11.2.0]</span><span>
</span></span></span><span><span> 4</span><span><span>    </span><span># add package specs to the `specs` list</span><span>
</span></span></span><span><span> 5</span><span><span>  </span><span>specs</span><span>:</span><span>
</span></span></span><span><span> 6</span><span><span>  </span>- <span>py-ipython</span><span>
</span></span></span><span><span> 7</span><span><span>  </span>- <span>cuda@11.3</span><span>
</span></span></span><span><span> 8</span><span><span>  </span>- <span>py-torch@npeye+cuda+debug~fbgemm~mkldnn~nnpack~qnnpack~test</span><span>
</span></span></span><span><span> 9</span><span><span>  </span><span>view</span><span>:</span><span> </span><span>true</span><span>
</span></span></span><span><span>10</span><span><span>  </span><span>concretization</span><span>:</span><span> </span><span>together</span><span>
</span></span></span><span><span>11</span><span><span>  </span><span>develop</span><span>:</span><span>
</span></span></span><span><span>12</span><span><span>    </span><span>py-torch</span><span>:</span><span>
</span></span></span><span><span>13</span><span><span>      </span><span>spec</span><span>:</span><span> </span><span>py-torch@npeye+cuda+debug~fbgemm~mkldnn~nnpack~qnnpack~test</span><span>
</span></span></span></code></pre></div><p>Which now works seamlessly with <code>spack install</code>.</p><h2 id="baseline-environment">Baseline Environment</h2><p>Finally, to test changes against the main branch upstream, it is useful to
define an environment for the same. This can be named since it allows for better
usage semantics with <code>deactivate</code>.</p><div><pre tabindex="0"><code data-lang="bash"><span><span> 1</span><span>spack env create pytorchBaseline
</span></span><span><span> 2</span><span>spack -e pytorchBaseline add py-torch@master -cuda -fbgemm -nnpack -mkldnn -test -qnnpack
</span></span><span><span> 3</span><span>spack -e pytorchBaseline add py-ipython
</span></span><span><span> 4</span><span>spack -e pytorchBaseline config edit
</span></span><span><span> 5</span><span><span># Add compilers, concretization</span>
</span></span><span><span> 6</span><span>spacktivate pytorchBaseline
</span></span><span><span> 7</span><span>spack concretize --force
</span></span><span><span> 8</span><span>spack install
</span></span><span><span> 9</span><span><span># Do tests, compare</span>
</span></span><span><span>10</span><span><span># ...</span>
</span></span><span><span>11</span><span><span># Wrap up and deactivate</span>
</span></span><span><span>12</span><span>despacktivate pytorchBaseline
</span></span></code></pre></div><h2 id="conclusions">Conclusions</h2><p>Dependency management is always painful. CUDA management doubly so. Better
workflows with <a href="https://spack-tutorial.readthedocs.io/en/sc20/tutorial_developer_workflows.html">spack dev-build</a> are available for some packages, <a href="https://github.com/kokkos/kokkos/blob/master/Spack.md">like KOKKOS</a>, but
<code>spack dev-build</code> doesn’t work yet for <code>pytorch</code>, and also appears to be removed
from the present set of tutorials. Personally, I’d still prefer <code>nix</code>, but where
<code>micromamba</code> falls short in terms of source builds, <code>spack</code> is a good
alternative, if one has the resources to rebuild everything needed.</p></div></div>
  </body>
</html>
