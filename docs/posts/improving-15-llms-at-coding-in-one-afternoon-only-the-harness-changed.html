<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://blog.can.ac/2026/02/12/the-harness-problem/">Original</a>
    <h1>Improving 15 LLMs at Coding in One Afternoon. Only the Harness Changed</h1>
    
    <div id="readability-page-1" class="page"><div><p>In fact only the edit tool changed. That’s it.</p><benchmark-embed></benchmark-embed><hr/><h2 id="0x0-the-wrong-question">0x0: The Wrong Question</h2><p>The conversation right now is almost entirely about which model is best at coding, GPT-5.3 or Opus. Gemini vs whatever dropped this week. This framing is increasingly misleading because it treats the model as the only variable that matters, when in reality one of the bottlenecks is something much more mundane: <strong>the harness.</strong></p><p>Not only is it where you capture the first impression of the user (is it uncontrollably scrolling, or smooth as butter?), it is also the source of every input token, and the interface between their output and every change made to your workspace.</p><p>I maintain a little “hobby harness”, <a href="https://github.com/can1357/oh-my-pi">oh-my-pi</a>, a fork of <a href="https://github.com/badlogic/pi-mono">Pi</a>, a wonderful open-source coding agent by Mario Zechner. I’ve so far authored ~1,300 commits, mostly playing around and making incremental improvements here and there when I see a pain point, (<del>or autism strikes and I see an opportunity to embed more Rust via N-API because “spawning rg feels wrong”</del>).</p><p>Why bother, you ask? Opus may be a great model, but Claude Code to this day leaks raw JSONL from sub-agent outputs, wasting hundreds of thousands of tokens. I get to say, “fuck it, subagents output structured data now”.</p><p>Tool schemas, error messages, state management, everything between “the model knows what to change” and “the issue is resolved.” This is where most failures happen in practice.</p><p>Being model agnostic, it is a great testing ground, as the model is but a parameter. The real variable is the harness, where you have unimaginable control over.</p><p>Anyhow, let me tell you about this one <em>variable</em> I changed yesterday.</p><hr/><p>Before I explain what I built, it’s worth understanding the state of the art.</p><p><strong>Codex uses <code>apply_patch</code></strong>: It takes a string as input, which is essentially an OpenAI-flavored diff, and instead of relying on a structured schema, the harness just expects this blob to follow a strict set of rules. Since OpenAI folks are without a doubt smart, I’m sure the token selection process is biased to fit this structure at the LLM gateway for the Codex variants of GPT, similar to how other constraints like JSON schemas or required tool calls work.</p><p>But give this to any other model, completely unaware of it? Patch failures go through the roof. Grok 4’s patch failure rate in my benchmark was <strong>50.7%</strong>, GLM-4.7’s was <strong>46.2%</strong>. These aren’t bad models — they just don’t speak the language.</p><p><strong>Claude Code (and most others) use <code>str_replace</code></strong>: find the <strong>exact</strong> old text, swap in the new text. Very simple to think about. But the model must reproduce every character perfectly, including whitespace and indentation. Multiple matches? Rejected. The “String to replace not found in file” error is so common it has <a href="https://github.com/anthropics/claude-code/issues/3471">its own GitHub issues megathread</a> (+27 other issues). Not exactly optimal. Gemini does essentially the same thing plus some fuzzy whitespace matching.</p><p><strong>Cursor trained a separate neural network</strong>: a fine-tuned 70B model whose entire job is to take a draft edit and merge it into the file correctly. The harness problem is so hard that one of the most well-funded AI companies decided to throw another model at it, and even then they mention in their <a href="https://cursor.com/blog/instant-apply">own blog post</a> that “fully rewriting the full file outperforms aider-like diffs for files under 400 lines.”</p><p><strong>Aider’s <a href="https://aider.chat/docs/benchmarks.html">own benchmarks</a></strong> show that format choice alone swung GPT-4 Turbo from 26% to 59%, but GPT-3.5 scored only 19% with the same format because it couldn’t reliably produce valid diffs. The format matters as much as the model.</p><p>The <a href="https://arxiv.org/abs/2510.12487">Diff-XYZ benchmark</a> from JetBrains confirmed it systematically: no single edit format dominates across models and use cases. <a href="https://arxiv.org/abs/2511.04486">EDIT-Bench</a> found that only one model achieves over 60% pass@1 on realistic editing tasks.</p><p>As you can see, there is no real consensus on the “best solution” to the simple “how do you change things” problem. My 5c: <strong>none of these tools give the model a stable, verifiable identifier for the lines it wants to change without wasting tremendous amounts of context and depending on perfect recall.</strong> They all rely on the model reproducing content it already saw. When it can’t — and it often can’t — the user blames the model.</p><hr/><h2 id="0x2-hashline">0x2: Hashline!</h2><p>Now bear with me here. What if, when the model reads a file, or greps for something, every line comes back tagged with a 2-3 character content hash:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>1</span><span>1:a3|function hello() {
</span></span><span><span>2</span><span>2:f1|  return &#34;world&#34;;
</span></span><span><span>3</span><span>3:0e|}</span></span></code></pre></div><p>When the model edits, it references those tags — <em>“replace line <code>2:f1</code>, replace range <code>1:a3</code> through <code>3:0e</code>, insert after <code>3:0e</code>.”</em> If the file changed since the last read, the hashes (optimistically) won’t match and the edit is rejected before anything gets corrupted.</p><p>If they can recall a pseudo-random tag, chances are, they know what they’re editing. The model then wouldn’t need to reproduce old content, or god forbid whitespace, to demonstrate a trusted “anchor” to express its changes off of.</p><hr/><h2 id="0x3-the-benchmark">0x3: The Benchmark</h2><p>Since my primary concern was about real-world performance, the fixtures are generated as follows:</p><ol><li>Take a random file from the React codebase.</li><li>Introduce mutations, framed as bugs, via an edit whose inverse we can expect (e.g. operator swaps, boolean flips, off-by-one errors, optional chains removed, identifiers renamed).</li><li>Generate a description of the issue in plain English.</li></ol><p>An average task description looks something like this:</p><div><pre tabindex="0"><code data-lang="markdown"><span><span>1</span><span><span># Fix the bug in `useCommitFilteringAndNavigation.js`
</span></span></span><span><span>2</span><span>
</span></span><span><span>3</span><span>A guard clause (early return) was removed.
</span></span><span><span>4</span><span>The issue is in the <span>`useCommitFilteringAndNavigation`</span> function.
</span></span><span><span>5</span><span>Restore the missing guard clause (if statement with early return).</span></span></code></pre></div><p>Naturally, we don’t expect 100% success rate here, since the model can come up with a unique solution that isn’t necessarily the exact same file, but the bugs are mechanical enough that most of the time, the fix is our mutation being reverted.</p><p>3 runs per task, 180 tasks per run. Fresh agent session each time, four tools (read, edit, write). We simply give it a temporary workspace, pass the prompt, and once the agent stops, we compare against the original file before and after formatting.</p><p>Sixteen models, three edit tools, and the outcome is unambiguous: <strong>patch is the worst format for nearly every model, hashline matches or beats replace for most, and the weakest models gain the most.</strong> Grok Code Fast 1 went from 6.7% to 68.3%, a tenfold improvement, because patch was failing so catastrophically that the model’s actual coding ability was almost completely hidden behind mechanical edit failures. MiniMax more than doubled. Grok 4 Fast’s output tokens dropped 61% because it stopped burning tokens on retry loops.</p><hr/><h2 id="0x4-so-what">0x4: So What?</h2><p><strong>+8% improvement in the success rate of Gemini is bigger than most model upgrades deliver, and it cost zero training compute.</strong> Just a little experimenting (and ~$300 spent benchmarking).</p><p>Often the model isn’t flaky at understanding the task. It’s flaky at expressing itself. You’re blaming the pilot for the landing gear.</p><hr/><h2 id="0x5-little-bit-about-the-vendors">0x5: Little Bit About the Vendors</h2><p>Anthropic recently <a href="https://news.ycombinator.com/item?id=46625918">blocked OpenCode</a>, a massively popular open-source coding agent, from accessing Claude through Claude Code subscriptions.</p><p>Anthropic’s position “OpenCode reverse-engineered a private API” is fair on its face. Their infrastructure, their rules. But look at what the action signals:</p><p><strong>Don’t build harnesses. Use ours.</strong></p><p>It’s not just Anthropic either. While writing this article, Google banned my account from Gemini entirely:</p><p><img src="http://blog.can.ac/2026/02/12/the-harness-problem/gemini-ban.png" alt="Google disabled my Gemini account"/></p><p>Not rate-limited. Not warned. <strong>Disabled</strong>. For running a benchmark — the same one that showed Gemini 3 Flash hitting 78.3% with a novel technique that beats their best attempt at it by 5.0 pp. I don’t even know what for.</p><p>Here is why that is backwards. I just showed that a different edit format improves <em>their own models</em> by 5 to 14 points while cutting output tokens by ~20%. That’s not a threat. It’s free R&amp;D.</p><p>No vendor will do harness optimization for competitors’ models. Anthropic won’t tune for Grok. xAI won’t tune for Gemini. OpenAI won’t tune for Claude. But an open-source harness tunes for all of them, because contributors use different models and fix the failures they personally encounter.</p><p>The model is the moat. The harness is the bridge. Burning bridges just means fewer people bother to cross. <strong>Treating harnesses as solved, or even inconsequential, is very short-sighted.</strong></p><hr/><p>I come from a background of game security. Cheaters are hugely destructive to the ecosystem. Sure, they get banned, chased, sued, but a well-known secret is that eventually the security team asks, “Cool! Want to show us how you got around that?”, and they join the defense.</p><p>The correct response when someone messes with your API, and manages to gather a significant following using their tools is “tell us more”, not “let’s blanket-ban them in thousands; plz beg in DMs if you want it reversed tho.”</p><p>The harness problem is real, measurable, and it’s the highest-leverage place to innovate right now. The gap between “cool demo” and “reliable tool” isn’t model magic. It’s careful, rather boring, empirical engineering at the tool boundary.</p><p>The harness problem will be solved. The question is whether it gets solved by one company, in private, for one model, or by a community, in the open, for all of them.</p><p>The benchmark results speak for themselves.</p><hr/><p><em>All code, benchmarks, and per-run reports:</em> <a href="https://github.com/can1357/oh-my-pi/tree/main/packages/react-edit-benchmark">oh-my-pi</a></p></div></div>
  </body>
</html>
