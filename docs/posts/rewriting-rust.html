<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://josephg.com/blog/rewriting-rust/">Original</a>
    <h1>Rewriting Rust</h1>
    
    <div id="readability-page-1" class="page"><section>
                <p>The Rust programming language feels like a first generation product.</p>

<p>You know what I mean. Like the first iPhone - <a href="https://www.youtube.com/watch?v=MnrJzXM7a6o">which was amazing by the way</a>. They made an entire operating system around multitouch. A smart phone with no keyboard. And a working web browser. Within a few months, we all realised what the iPhone really wanted to be. Only, the first generation iphone wasn&#39;t quite there. It didn&#39;t have 3G internet. There was no GPS chip. And there was no app store. In the next few years, iPhones would get a lot better.</p>

<p>Rust feels a bit like that first iPhone.</p>

<p>I fell in love with Rust at the start. Algebraic types? Memory safety without compromising on performance? A modern package manager? Count me in. But now that I&#39;ve been programming in rust for 4 years or so, it just feels like its never quite there.</p>

<p>And I don&#39;t know if it will ever be there. Progress on the language has slowed <em>so much</em>. When I first started using it, every release seemed to add new, great features in stable rust. Now? Crickets. The <a href="https://doc.rust-lang.org/unstable-book/the-unstable-book.html">rust &#34;unstable book&#34;</a> lists <em>700</em> different unstable features - which presumably are all implemented, but which have yet to be enabled in stable rust. Most of them are changes to the standard library - but seriously. Holy cow.</p>

<p>How much of this stuff will <em>ever</em> make it into the language proper? The rust RFC process is a graveyard of good ideas.</p>

<p>Features like <a href="https://doc.rust-lang.org/unstable-book/language-features/coroutines.html">Coroutines</a>. This RFC is 7 years old now. Make no mistake - coroutines are implemented in the compiler. They&#39;re just, not available for us &#34;stable rust&#34; peasants to use. If coroutines were a child, they would be in grade school by now. At this point, the coroutines RFC has lasted longer than World War 1 or 2.</p>

<p>I suspect rust is calcifying because its consensus process just doesn&#39;t scale. Early on, rust had a small group of contributors who just <em>decided</em> things. The monsters. Now, there are issue threads like <a href="https://github.com/rust-lang/rust/issues/93740#issuecomment-1041391284">this</a>, in which 25 smart, well meaning people spent 2 years and over 200 comments trying to figure out how to improve <code>Mutex</code>. And as far as I can tell, in the end they more or less gave up.</p>

<p>Maybe this is by design. Good languages are stable languages. It might be time to think of rust as a fully baked language - warts and all. Python 2.7 for life.</p>

<p>But that doesn&#39;t change anything for me. I want a better rust, and I feel powerless to make that happen. Where are my coroutines? Even javascript has <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">coroutines</a>.</p>

<h2 id="fantasylanguage">Fantasy language</h2>

<p>Sometimes I lie awake at night fantasising about forking the compiler. I know how I&#39;d do it. In my fork, I&#39;d leave all the rust stuff alone and but make my own &#34;seph&#34; <a href="https://doc.rust-lang.org/edition-guide/editions/">edition</a> of the rust language. Then I could add all sorts of breaking features to that edition. So long as my compiler still compiles mainline rust as well, I could keep using all the wonderful crates on Cargo.</p>

<p>I think about this a lot. If I did it, here&#39;s what I&#39;d change:</p>

<h3 id="functiontraitseffects">Function traits (effects)</h3>

<p>Rust has traits on structs. These are used in all sorts of ways. Some are markers. Some are understood by the compiler (like <code>Copy</code>). Some are user defined.</p>

<p>Rust should also define a bunch of traits for functions. In other languages, function traits are called &#34;effects&#34;.</p>

<p>This sounds weird at first glance - but hear me out. See, there&#39;s lots of different &#34;traits&#34; that functions have. Things like:</p>

<ul>
<li>Does the function ever panic?</li>
<li>Does the function have a fixed stack size?</li>
<li>Does the function run to the end, or does it yield / await?</li>
<li>If the function is a coroutine, what is the type of the continuation?</li>
<li>Is the function &#34;pure&#34; (ie, the same input produces the same output, and it has no side effects)</li>
<li>Does the function (directly or indirectly) run unsafe code in semi-trusted libraries?</li>
<li>Is the function guaranteed to terminate?</li>
</ul>

<p>And so on.</p>

<p>A function&#39;s parameters and return type are just associated types on the function:</p>

<pre><code>fn some_iter() -&gt; impl Iterator&lt;Item = usize&gt; {  
    vec![1,2,3].into_iter()
}

fn main() {  
    // Why doesn&#39;t this work already via FnOnce?
    let x: some_iter::Output = some_iter();
}
</code></pre>

<p><a href="https://rust-lang.github.io/rfcs/2515-type_alias_impl_trait.html">TAIT</a> eat your heart out.</p>

<p>Exposing these properties is super useful. For example, the linux kernel wants to guarantee (at compile time) that some block of code will never panic. This is impossible to do in rust today. But using function traits, we could explicitly mark a function as being able - or unable - to panic:</p>

<pre><code>#[disallow(Panic)] // Syntax TBD.
fn some_fn() { ... }  
</code></pre>

<p>And if the function does anything which could panic (even recursively), the compiler would emit an error.</p>

<p>The compiler already sort of implements traits on functions, like <code>Fn</code>, <code>FnOnce</code> and <code>FnMut</code>. But for some reason they&#39;re anemic. (Why??)</p>

<p>I want something like this:</p>

<pre><code>/// Automatically implemented on all functions.
trait Function {  
  type Args,
  type Output,
  type Continuation, // Unit type () for normal functions
  // ... and so on.

  fn call_once(self, args: Self::Args) -&gt; Self::Output;
}

trait NoPanic {} // Marker trait, implemented automatically by the compiler.

/// Automatically implemented on all functions which don&#39;t recurse.
trait KnownStackSize {  
  const STACK_SIZE: usize,
}
</code></pre>

<p>Then you could write code like this:</p>

<pre><code>fn some_iter() -&gt; impl Iterator&lt;Item = usize&gt; {  
  vec![1,2,3].into_iter();
}

struct SomeWrapperStruct {  
  iter: some_iter::Output, // In 2024 this is still impossible in stable rust.
}
</code></pre>

<p>Or with coroutines:</p>

<pre><code>coroutine fn numbers() -&gt; impl Iterator&lt;Item = usize&gt; {  
  yield 1;
  yield 2;
  yield 3;
}

coroutine fn double&lt;I: Iterator&lt;Item=usize&gt;&gt;(inner: I) -&gt; impl Iterator&lt;Item = usize&gt; {  
  for x in inner {
    yield x * 2;
  }
}

struct SomeStruct {  
  // Suppose we want to store the iterator. We can name it directly:
  iterator: double&lt;numbers&gt;::Continuation,
}
</code></pre>

<p>Or, say, take a function parameter but require that the parameter itself doesn&#39;t panic:</p>

<pre><code>fn foo&lt;F&gt;(f: F)  
    where F: NoPanic + FnOnce() -&gt; String
{ ... }
</code></pre>

<p>Yoshua Wuyts has an excellent <a href="https://blog.yoshuawuyts.com/extending-rusts-effect-system/">talk &amp; blog post</a> going into way more detail about effects - why they&#39;re useful and how this could work.</p>

<h3 id="compiletimecapabilities">Compile-time Capabilities</h3>

<p>Most rust projects pull in an insane number of 3rd party crates. Most of these crates are small utility libraries - like the <a href="https://crates.io/crates/human-size"><code>human-size</code></a> crate which formats file sizes for human consumption. Great stuff! But unfortunately, all of these little crates add supply chain risk. Any of those authors could push out an update which contains malicious code - cryptolockering our computers, our servers or sneaking bad code into our binaries.</p>

<p>I think this problem is similar to the problem of memory safety. Sure - its sometimes useful to write memory-unsafe code. The rust standard library is full of it. But rust&#39;s <code>unsafe</code> keyword lets authors opt in to potentially unsafe things. We only add <code>unsafe</code> blocks when its necessary.</p>

<p>Lets do the same thing for privileged function calls - like reading and writing to and from the filesystem or the network. This is useful stuff, but its potentially dangerous. Developers should actively whitelist code that is allowed to call these functions.</p>

<p>To implement this, first we want to add marker traits to all the security-sensitive functions in the standard library (opening a file from a string, <code>exec</code>, FFI, opening network connections, most unsafe functions that interact with raw pointers, and so on). So, for example, <a href="https://doc.rust-lang.org/std/fs/fn.write.html"><code>std::fs::write(path, contents)</code></a> writes to an arbitrary path on disk with the credentials of the user. We add some <code>#[cap(fs_write)]</code> marker tag to the function itself, marking that this can only be called from code which is in some way trusted. The compiler automatically &#34;taints&#34; any other functions which call <code>write</code> in the entire call tree.</p>

<p>Suppose I call a function in a 3rd party crate which needs the <code>fs_write</code> capability. In order to call that function, I need to explicitly whitelist that call. (Either by adding the permission explicitly in my <code>Cargo.toml</code> or maybe with an annotation at the call site).</p>

<p>So, lets say the <code>foo</code> crate contains a function like this. The function will be marked (tainted) with the &#34;writes to filesystem&#34; tag:</p>

<pre><code>// In crate `foo`.

// (this function is implicitly tagged with #[cap(fs_write)])
pub fn do_stuff() {  
  std::fs::write(&#34;blah.txt&#34;, &#34;some text&#34;).unwrap();
}
</code></pre>

<p>When I try to run that function from my code:</p>

<pre><code>fn main() {  
  foo::do_stuff();
}
</code></pre>

<p>The compiler can give me a nice rusty error, like this:</p>

<pre><code>Error: foo::do_stuff() writes to the local filesystem, but the `foo` crate has not been trusted with this capability in Cargo.toml.

Tainted by this line in do_stuff:

  std::fs::write(&#34;blah.txt&#34;, &#34;some text&#34;).unwrap();

Add this to your Cargo.toml to fix:

foo = { version = &#34;1.0.0&#34;, allow_capabilities: [&#34;fs_write&#34;] }  
</code></pre>

<p>Obviously, most uses of <code>unsafe</code> would also require explicit whitelisting.</p>

<p>Most crates I use - like <code>human-size</code> or <code>serde</code> don&#39;t need any special capabilities to work. So we don&#39;t need to worry so much about their authors &#34;turning evil&#34; and adding malicious code to our software. Reducing the supply chain risk from the 100 or so crates I currently transitively depend on down to just a few would be massive.</p>

<p>This is a very simple, static way that capabilities could be introduced to Rust. But it might be possible &amp; better to change privileged code to require an extra <code>Capability</code> parameter (some unit struct type). And heavily restrict how <code>Capability</code> objects can be instantiated. Eg:</p>

<pre><code>struct FsWriteCapability;

impl FsWriteCapability {  
    fn new() { Self } // Only callable from the root crate
}

// Then change std::fs::write&#39;s signature to this:
pub fn write(path: Path, contents: &amp;[u8], cap: FsWriteCapability) { ... }  
</code></pre>

<p>This requires more boilerplate, but its much more flexible. (And obviously, we&#39;d also need to, somehow, apply a similar treatment to <code>build.rs</code> scripts and <code>unsafe</code> blocks.)</p>

<p>The result of all of this is that utility crates become &#34;uncorruptable&#34;. Imagine if crates.io is hacked and serde is maliciously updated to include with cryptolocker code. Today, that malicious code would be run automatically on millions of developer machines, and compiled into programs everywhere. With this change, you&#39;d just get a compiler error.</p>

<p>This is huge, and singlehandedly this one feature is probably worth the cost of forking rust. At least, to someone. (Anyone want to sponsor this work?)</p>

<h3 id="pinmoveandstructborrows">Pin, Move and Struct Borrows</h3>

<blockquote>
  <p>Feel free to skip this section if Pin &amp; the borrow checker gives you a migraine.</p>
</blockquote>

<p><code>Pin</code> in rust is a weird, complicated hack to work around a hole in the borrow checker. Its a band-aid from the land of bizzaro choices that only make sense when you need to maintain backwards compatibility at all costs.</p>

<ul>
<li>Its the reverse of the trait you actually want. It would make way more sense to have a <code>Move</code> marker trait (like <code>Copy</code>) indicating objects which <em>can</em> move.</li>
<li>But <code>Pin</code> isn&#39;t an actual trait. There&#39;s only <code>Unpin</code> (double negative now) and <code>!Unpin</code> - which is not-not-not-<code>Move</code>. For example <a href="https://doc.rust-lang.org/1.81.0/src/core/marker.rs.html#923"><code>impl !Unpin for PhantomPinned</code></a>. Is <code>!Unpin</code> the same as <code>Pin</code>? Uhhhh, ... No? Because .. reasons? I get an instant headache when I think about this stuff. Here&#39;s the <a href="https://doc.rust-lang.org/std/marker/trait.Unpin.html">documentation for Unpin</a> if you want to try your luck.</li>
<li>Pin only applies to reference types. If you read through code which uses <code>Pin</code> a lot, you&#39;ll find unnecessary <code>Box</code>-ing of values <em>everywhere</em>. For example, <a href="https://docs.rs/tokio-stream/latest/src/tokio_stream/wrappers/broadcast.rs.html#11-18">in tokio</a>, or helper libraries like <a href="https://lib.rs/crates/ouroboros">ouroboros</a>, <a href="https://docs.rs/async-trait/latest/async_trait/">async<em>trait</em></a><em> and <a href="https://docs.rs/self_cell/latest/self_cell/">self</a></em><a href="https://docs.rs/self_cell/latest/self_cell/">cell</a>.</li>
<li>The pain spreads. Any function that takes a pinned value needs the value wrapped using some horrible abomonation <a href="https://doc.rust-lang.org/std/future/trait.Future.html">like <code>Future::poll(self: Pin&lt;&amp;mut Self&gt;, ..)</code></a>. And then you need to figure out how to read the actual values out using projections, which are so complicated there are <a href="https://docs.rs/pin-project/latest/pin_project/">multiple</a> <a href="https://crates.io/crates/pin-project-lite/">crates</a> for dealing with them. The pain cannot be confined. It spreads outwards, forever, corrupting everything.</li>
</ul>

<p>I swear, it took more effort to learn pinning in rust than it took me to learn the entire Go programming language. And I&#39;m still not convinced I&#39;m totally across it. And I&#39;m not alone. I&#39;ve heard the <a href="https://fuchsia.dev/">Fuchsia operating system project</a> abandoned Rust for C++ in some parts because of how impossibly complex Pin makes everything.</p>

<p>Why is <code>Pin</code> needed, anyway?</p>

<p>We can write rust functions like this:</p>

<pre><code>fn main() {  
    let x = vec![1,2,3];
    let y = &amp;x;

    //drop(x); // error[E0505]: cannot move out of `x` because it is borrowed
    dbg!(y);
}
</code></pre>

<p>All variables in a rust function are actually, secretly in one of 3 different states:</p>

<ul>
<li>Normal (owned)</li>
<li>Borrowed</li>
<li>Mutably borrowed</li>
</ul>

<p>While a variable is borrowed (<code>y = &amp;x</code>), you can&#39;t move, mutate or drop the variable. In this example, <code>x</code> is put into a special &#34;borrowed&#34; state throughout the lifetime of <code>y</code>. Variables in the &#34;borrowed&#34; state are pinned, immutable, and have a bunch of other constraints. This &#34;borrowed state&#34; is visible to the compiler, but its completely invisible to the programmer. You can&#39;t tell that something is borrowed until you try to compile your program. (Aside: I wish Rust IDEs made this state visible while programming!)</p>

<p>But at least this program <em>works</em>.</p>

<p>Unfortunately, there&#39;s no equivalent to this for structs. Lets turn the function <code>async</code>:</p>

<pre><code>async fn foo() {  
    let x = vec![1,2,3];
    let y = &amp;x;

    some_future().await;

    dbg!(y);
}
</code></pre>

<p>When you compile this, the compiler creates a hidden struct for you, which stores the suspended state of this function. It looks something like this:</p>

<pre><code>struct FooFuture {  
  x: Vec&lt;usize&gt;,
  y: &amp;&#39;_ Vec&lt;usize&gt;,
}

impl Future for FooFuture { ... }  
</code></pre>

<p><code>x</code> is borrowed by <code>y</code>. So it needs to be placed under all the constraints of a borrowed variable:</p>

<ul>
<li>It must not move in memory. (It needs to be Pinned)</li>
<li>It must be immutable</li>
<li>We can&#39;t take mutable references to <code>x</code> (because of the &amp; xor &amp;mut rule).</li>
<li><code>x</code> must outlive <code>y</code>.</li>
</ul>

<p>But there&#39;s no syntax for this. Rust doesn&#39;t have syntax to mark a struct field as being in a borrowed state. And we can&#39;t express the lifetime of <code>y</code>.</p>

<p>Remember: the rust compiler already generates and uses structs like this whenever you use <code>async</code> functions. The compiler just doesn&#39;t provide any way to write code like this ourselves. Lets just extend the borrow checker and fix that!</p>

<p>I don&#39;t know what the ideal syntax would be, but I&#39;m sure we can come up with something. For example, maybe <code>y</code> gets declared as a &#34;local borrow&#34;, written as <code>y: &amp;&#39;Self::x Vec&lt;usize&gt;</code>. The compiler uses that annotation to figure out that <code>x</code> is borrowed. And it puts it under the same set of constraints as a borrowed variable inside a function.</p>

<p>This would also let you work with self-referential structs, like an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree (AST)</a> in a compiler:</p>

<pre><code>struct Ast {  
  source: String,
  ast_nodes: Vec&lt;&amp;&#39;Self::source str&gt;,
}
</code></pre>

<p>This syntax could also be adapted to support partial borrows:</p>

<pre><code>impl Foo {  
  fn get_some_field&lt;&#39;a&gt;(&amp;&#39;a self) -&gt; &amp;&#39;a::some_field usize {
    &amp;self.some_field
  }
}
</code></pre>

<p>This isn&#39;t a complete solution.</p>

<p>We&#39;d also need a <code>Move</code> marker trait, to replace <code>Pin</code>. Any struct with borrowed fields can&#39;t be Moved - so it wouldn&#39;t have <code>impl Move</code>. I&#39;d also consider a <code>Mover</code> trait, which would allow structs to intelligently move themselves in memory. Eg:</p>

<pre><code>trait Mover {  
  // Something like that.
  unsafe fn move(from: *Self, to: MaybeUninit&lt;&amp;mut Self&gt;);
}
</code></pre>

<p>We&#39;d also need a sane, safe way to construct structs like this in the first place. I&#39;m sure we can do better than <code>MaybeUninit</code>.</p>

<p>Miguel Young de la Sota <a href="https://www.youtube.com/watch?v=UrDhMWISR3w">gave a fantastic talk a few years ago</a> talking about <code>Move</code> in rust. But I think it would be much more &#34;rusty&#34; to lean on the borrow checker instead.</p>

<p>If you ask me, <code>Pin</code> is a dead end solution. Rust already has a borrow checker. Lets use it for structs.</p>

<h3 id="comptime">Comptime</h3>

<p>This is a hot opinion. I haven&#39;t spent a lot of time with zig, but at least from a distance I adore <a href="https://zig.guide/language-basics/comptime/">comptime</a>.</p>

<p>In the rust compiler we essentially implement two languages: Rust and the Rust Macro language. (Well, arguably there&#39;s 3 - because proc macros). The Rust programming language is lovely. But the rust macro languages are horrible.</p>

<p>But, if you already know rust, why not just use rust itself instead of sticking another language in there? This is the genius behind Zig&#39;s <code>comptime</code>. The compiler gets a little interpreter tacked on that can run parts of your code at compile time. Functions, parameters, if statements and loops can all be marked as compile-time code. Any non-comptime code in your block is emitted into the program itself.</p>

<p>I&#39;m not going to explain the feature in full here. Instead, take in just how <em>gorgeous</em> this makes Zig&#39;s <a href="https://ziglang.org/documentation/master/#Case-Study-print-in-Zig">std <code>print</code> function</a>.</p>

<p>Its entirely implemented using comptime. So when you write this in zig:</p>

<pre><code>pub fn main() void {  
    print(&#34;here is a string: &#39;{s}&#39; here is a number: {}\n&#34;, .{ a_string, a_number });
}
</code></pre>

<p><code>print</code> takes the format string as a comptime parameter, and parses it within a <code>comptime</code> loop. Aside from a couple keywords, the function is just regular zig code - familiar to anyone who knows the language. It just gets executed within the compiler. And the result? It emits this beauty:</p>

<pre><code>pub fn print(self: *Writer, arg0: []const u8, arg1: i32) !void {  
    try self.write(&#34;here is a string: &#39;&#34;);
    try self.printValue(arg0);
    try self.write(&#34;&#39; here is a number: &#34;);
    try self.printValue(arg1);
    try self.write(&#34;\n&#34;);
    try self.flush();
}
</code></pre>

<p>Read the <a href="https://ziglang.org/documentation/master/#Case-Study-print-in-Zig">full case study</a> for more details.</p>

<p>In comparison, I tried to look up how rust&#39;s <code>println!()</code> macro is implemented. But <a href="https://doc.rust-lang.org/src/std/macros.rs.html#138-145">println! calls some secret <code>format_args_nl</code> function</a>. I assume that function is hardcoded in the rust compiler itself.</p>

<p>Its not a great look when even the rust compiler authors don&#39;t want to use rust&#39;s macro language.</p>

<h3 id="weirdlittlefixes">Weird little fixes</h3>

<p>Bonus round time. Here&#39;s some other little &#34;nits&#34; I&#39;d love to fix while we&#39;re at it:</p>

<ul>
<li><code>impl&lt;T: Copy&gt; for Range&lt;T&gt;</code>. If you know, you know.</li>
<li>Fix <a href="https://github.com/rust-lang/rust/issues/26925">derive with associated types</a>. <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6fd2c813f411f6eb1abb66a473425c89">Full example here</a>.</li>
<li>Make if-let expressions support logical AND. Its so simple, so obvious, and so useful. This should work:</li>
</ul>

<pre><code>// Compile error! We can&#39;t have nice things.
if let Some(x) = some_var &amp;&amp; some_expr { }  
</code></pre>

<p>You can sort of work around this problem today as below, but its awkward to write, hard to read and the semantics are different from how normal <code>if</code> statements work because it lacks short-circuit evaluation.</p>

<pre><code>// check_foo() will run even if some_var is None.
if let (Some(x), true) = (some_var, check_foo()) { ... }  
</code></pre>

<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e4c4521e6a0ab49462c0b9d55da97480">Full example here</a>.</p>

<p>Rust&#39;s ergonomics for raw pointers are also uniquely horrible. When I work with unsafe code, my code should be as easy to read &amp; write as humanly possible. But the rust compiler seems intent on punishing me for my sins. For example, if I have a reference to a struct in rust, I can write <code>myref.x</code>. But if I have a pointer, rust insists that I write <code>(*myptr).x</code> or, worse: <code>(*(*myptr).p).y</code>. Horrible. Horrible and entirely counterproductive. Unsafe code should be clear.</p>

<p>I&#39;d also change all the built in collection types to take an <code>Allocator</code> as a constructor argument. I personally don&#39;t like Rust&#39;s decision to use a global allocator. Explicit is better than implicit.</p>

<h2 id="closingthoughts">Closing thoughts</h2>

<p>Thats all the ideas I have. I mean, async needs some love too. But there&#39;s so much to say on the topic that async deserves a post of its own.</p>

<p>Unfortunately, most of these changes would be incompatible with existing rust. Even adding security capabilities would require a new rust edition, since it introduces a new way that crates can break semver compatibility.</p>

<p>A few years ago I would have considered writing RFCs for all of these proposals. But I like programming more than I like dying slowly in the endless pit of github RFC comments. I don&#39;t want months of work to result in yet another idea in <a href="https://doc.rust-lang.org/reference/items/associated-items.html">rust&#39;s landfill of unrealised dreams</a>.</p>

<p>Maybe I should fork the compiler and do it myself. Urgh. So many projects. If I could live a million lifetimes, I&#39;d devote one to working on compilers.</p>
            </section></div>
  </body>
</html>
