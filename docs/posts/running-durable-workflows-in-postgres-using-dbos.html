<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/durable-workflows-in-postgres-dbos">Original</a>
    <h1>Running Durable Workflows in Postgres Using DBOS</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><img alt="Running Durable Workflows in Postgres using DBOS" loading="lazy" decoding="async" data-nimg="fill" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" srcset="/_next/image?url=%2Fimages%2Fblog%2Fdbos%2Fog.png&amp;w=256&amp;q=100 256w, /_next/image?url=%2Fimages%2Fblog%2Fdbos%2Fog.png&amp;w=384&amp;q=100 384w, /_next/image?url=%2Fimages%2Fblog%2Fdbos%2Fog.png&amp;w=640&amp;q=100 640w, /_next/image?url=%2Fimages%2Fblog%2Fdbos%2Fog.png&amp;w=750&amp;q=100 750w, /_next/image?url=%2Fimages%2Fblog%2Fdbos%2Fog.png&amp;w=828&amp;q=100 828w, /_next/image?url=%2Fimages%2Fblog%2Fdbos%2Fog.png&amp;w=1080&amp;q=100 1080w, /_next/image?url=%2Fimages%2Fblog%2Fdbos%2Fog.png&amp;w=1200&amp;q=100 1200w, /_next/image?url=%2Fimages%2Fblog%2Fdbos%2Fog.png&amp;w=1920&amp;q=100 1920w, /_next/image?url=%2Fimages%2Fblog%2Fdbos%2Fog.png&amp;w=2048&amp;q=100 2048w, /_next/image?url=%2Fimages%2Fblog%2Fdbos%2Fog.png&amp;w=3840&amp;q=100 3840w" src="https://owentrueblood.com/_next/image?url=%2Fimages%2Fblog%2Fdbos%2Fog.png&amp;w=3840&amp;q=100"/></p><p>Michael Stonebraker is the inventor of Postgres and a Turing Award winner. His latest venture is <a href="https://www.dbos.dev/">DBOS</a>, a three-year joint research project between Stanford and MIT. The DBOS team have built a Durable Workflow engine using Postgres. It&#39;s one of the of the more elegant designs I&#39;ve seen, leveraging the features of Postgres to keep it lightweight and fast.</p>
<p>The DBOS team have released a Supabase integration, so you can use your Postgres database as a durable workflow engine.</p>
<!-- -->
<p><strong>Continue reading or just get started?</strong></p>
<p>I really love the design of DBOS, so I&#39;m going to write more below. Their design is aligned with our philosophy at Supabase: “just use Postgres”. I&#39;ll take you through the lower-level details in the rest of this post. If you just want to get started using DBOS with Supabase, get started using their tutorial:</p>
<p><a href="https://docs.dbos.dev/integrations/supabase">Use DBOS With Supabase →</a></p>

<p>Let&#39;s start with a common situation where a workflow is useful: you&#39;re running an e-commerce platform where an order goes through multiple “steps”:</p>
<!-- -->
<p>The process is simple, but writing a <em>robust</em> program for this is surprisingly difficult. Some potential problems:</p>
<ul>
<li>You get to step 2, “Check Inventory”, and you&#39;re out of stock. You need to wait 24 hours for the new inventory before you can ship it. You need that “step” to sleep for a day.</li>
<li>Your program crashes during step 3, “Ship Order”, and it doesn&#39;t record that you&#39;ve shipped the inventory. You end up sending the same order twice.</li>
</ul>
<p>A Durable Workflow Engine helps with these problems (and more). There are a few on the market that provide different architectures like <a href="https://trigger.dev/">Trigger.dev</a>, <a href="https://www.inngest.com/">Inngest</a>, <a href="https://www.windmill.dev">Windmill</a>, <a href="https://temporal.io/">Temporal</a>, and <a href="https://aws.amazon.com/step-functions/">AWS Step Functions</a>.</p>
<p>DBOS offers a relatively unique approach to Workflows, storing the state in your own Postgres database. Let&#39;s explore how DBOS does it.</p>

<p>DBOS is a platform where you can write your programming logic in serverless functions (similar to Supabase Edge Functions). Functions can be written in either <a href="https://docs.dbos.dev/python/programming-guide">Python</a> or <a href="https://docs.dbos.dev/typescript/programming-guide">TypeScript</a>.</p>
<h3 id="creating-workflows-with-decorators">Creating workflows with decorators<a href="#creating-workflows-with-decorators" aria-hidden="true"><span aria-hidden="true">#</span></a></h3>
<p>One thing that&#39;s different to Supabase Edge Functions is the ability to add <strong>decorators</strong> to your Functions with <code>DBOS.step()</code> and <code>DBOS.workflow()</code>:</p>
<!-- -->
<p>When you do this, DBOS stores the “state” of every step in Postgres:</p>
<!-- -->
<p>This is the part I find the most interesting! If you&#39;re a gamer, it&#39;s a bit like having a “<a href="https://en.wikipedia.org/wiki/Saved_game">save point</a>” in your programs. If a Function fails at any point, a new Function can start, picking up at the last checkpoint.</p>
<!-- -->
<h3 id="storing-function-state-in-postgres">Storing function state in Postgres<a href="#storing-function-state-in-postgres" aria-hidden="true"><span aria-hidden="true">#</span></a></h3>
<p>When you create an application with DBOS, they create a new database inside your Postgres cluster for storing this state.</p>
<p>Using their “Widget Store” example, you can see two new databases -</p>
<ol>
<li><code>widget_store</code>: for storing the application data</li>
<li><code>widget_store_dbos_sys</code>: for storing the workflow state.</li>
</ol>
<!-- -->
<p>The <code>widget_store_dbos_sys</code> database holds the workflow state:</p>
<!-- -->
<h3 id="workflow-logic"><strong>Workflow logic</strong><a href="#workflow-logic" aria-hidden="true"><span aria-hidden="true">#</span></a></h3>
<p>The DBOS team were kind enough to share some of the logic with me about how their workflow engine works:</p>
<ol>
<li>When a workflow starts, it generates a unique ID and stores it in a Postgres <code>workflow_status</code> table with a <code>PENDING</code> status. It also stores its inputs in Postgres.</li>
<li>Each time a step completes, it stores its output in a Postgres <code>operation_outputs</code> table.</li>
<li>When a workflow completes, it updates its status in the Postgres <code>workflow_status</code> table to <code>SUCCESS</code> (or to <code>ERROR</code>, if it threw an uncaught exception).</li>
</ol>
<h3 id="error-logic">Error logic<a href="#error-logic" aria-hidden="true"><span aria-hidden="true">#</span></a></h3>
<p>If a program is interrupted, on restart the DBOS library launches a background thread that resumes all incomplete workflows from the last completed step.</p>
<ol>
<li>It queries Postgres to find all <code>PENDING</code> workflows, then starts each one. Because workflows are just Python functions, it can restart a workflow by simply calling the workflow function with its original inputs, retrieved from Postgres.</li>
<li>As a workflow re-executes, before trying each step, it first checks Postgres to see if that step was previously executed. If it finds the step in Postgres, it doesn&#39;t re-execute the step, instead re-using its original output.</li>
<li>Eventually, the workflow reaches the first step whose output isn&#39;t stored in Postgres and resumes execution from there - “resuming from the last completed step.”</li>
</ol>
<p>All this works because workflows are deterministic, so they can re-execute them using stored step outputs to recover their pre-interruption state.</p>
<h2 id="the-benefits-of-using-postgres">The benefits of using Postgres<a href="#the-benefits-of-using-postgres" aria-hidden="true"><span aria-hidden="true">#</span></a></h2>
<p>DBOS isn&#39;t the first to create a workflow engine. Others in the market include <a href="https://temporal.io/">Temporal</a> and <a href="https://aws.amazon.com/step-functions/">AWS Step Functions</a>. DBOS provides a number of benefits over workflow engines that use external orchestrators like AWS Step Functions:</p>
<h3 id="performance">Performance<a href="#performance" aria-hidden="true"><span aria-hidden="true">#</span></a></h3>
<p>Because a step transition is just a Postgres write (~1ms) versus an async dispatch from an external orchestrator (~100ms), it means DBOS is <a href="https://www.dbos.dev/blog/dbos-vs-aws-step-functions-benchmark">25x faster than AWS Step Functions</a>:</p>
<!-- -->
<h3 id="exactly-once-execution">Exactly-once execution<a href="#exactly-once-execution" aria-hidden="true"><span aria-hidden="true">#</span></a></h3>
<p>DBOS has a special <code>@DBOS.Transaction</code> decorator. This runs the entire step inside a Postgres transaction. This guarantees exactly-once execution for databases transactional steps.</p>
<h3 id="idempotency">Idempotency<a href="#idempotency" aria-hidden="true"><span aria-hidden="true">#</span></a></h3>
<p>You can set an idempotency key for a workflow to guarantee it executes only once, even if called multiple times with that key. Under the hood, this works by setting the workflow&#39;s unique ID to your idempotency key.</p>
<h3 id="other-postgres-features">Other Postgres features<a href="#other-postgres-features" aria-hidden="true"><span aria-hidden="true">#</span></a></h3>
<p>Since it&#39;s all in Postgres, you get all the tooling you&#39;re familiar with. Backups, GUIs, CLI tools - you name it. It all “just works”.</p>

<p>To get started with DBOS and Supabase, check out their official integration docs:</p>
<p><a href="https://docs.dbos.dev/integrations/supabase">Use DBOS With Supabase →</a></p></div></article></div>
  </body>
</html>
