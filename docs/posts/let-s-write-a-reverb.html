<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://signalsmith-audio.co.uk/writing/2021/lets-write-a-reverb/">Original</a>
    <h1>Let&#39;s Write a Reverb</h1>
    
    <div id="readability-page-1" class="page"><article data-presentation-ignore="figcaption,p">
			<header>
				
				<address>Geraint Luff
					
				</address>
				
				<p>No magic numbers, no tricky tuning: a clean and flexible approach to designing a smooth high-quality reverb, using a variation on the classic feedback-delay network (FDN) structure.</p>
				<img src="https://signalsmith-audio.co.uk/writing/2021/lets-write-a-reverb/images/preview.png"/>
			</header>

			<nav></nav>

<!--			<p><em>Whooo</em>, this one took a while.  I scrapped and re-started the whole thing several times, but hopefully it makes sense now.  Reverbs are one of my favourite effects, and feedback-delay networks in particular are a great way to play around with them and try out weird things.</p>-->
			<p>Reverbs are one of my favourite effects, both to use and to write, and feedback-delay networks are a great way to play around and try things.</p>
<!--			<p>This article goes through one possible reverb design which I think is very friendly (as in, easy to configure correctly and get a good sound) and sidesteps some of the common FDN design problems which can give them a reputation for being tricky.</p>-->
			<p>Reverbs sometimes have a bad reputation for being tricky to tune, so this article goes through one possible reverb design which I hope is simple and intuitive to understand, and I also think is friendly and robust (as in, easy to configure correctly and get a good sound).</p>
			
			<p>So let&#39;s get to it!</p>
			<slide>
				<h2>What do we want from a reverb?</h2>
				
				<slide>
					<slide>
						<p>We&#39;ll <span>start by laying out what we&#39;re looking for.  Artificial reverberation is quite a wide field, covering a few different use-cases, but let&#39;s</span> take a fairly simple definition:</p>
						<blockquote id="reverb-goals">
							An effect which creates a sense of space, by generating a diffuse longer-lasting sound from a short input
						</blockquote>
					</slide>
				</slide>
			
				<h3>Approaches</h3>
				<p>There are many ways to achieve this, but two common approaches are convolution and feedback delay networks.  There are advantages and disadvantages to both:</p>
				<slide>
					<figure>
						<h4>Convolution</h4>
						<table>
							<tbody><tr>
								<td>
									❌ complicated</td>
								<td>
									✅ very customisable</td>
						</tr></tbody></table>
					</figure>
					<figure>
						<h4>Feedback delay network (FDN)</h4>
						<table>
							<tbody><tr>
								<td>
									❌ tricky to make realistic</td>
								<td>
									✅ very efficient</td>
						</tr></tbody></table>
					</figure>
				</slide>
				<p>We&#39;re going to take the FDN approach, because you can make a decent-sounding reverb with low CPU and a fairly simple design.</p>
			</slide>

			<slide>
				<h2>The feedback-delay loop</h2>
				
				<slide>
					<p>Here&#39;s a simple feedback loop:</p>
					<figure>
						
					</figure>
					<p>The input signal is sent through a delay, which then goes to the output - but it&#39;s also fed back into the delay input.  This means the signal travels round in a loop, producing a series of echoes from a single input pulse.
					</p><p>There are a few variations on this, like where in the loop we take the output from, or where the gain is placed.  The essential part is the feedback which produces an infinitely-looping output, with a gain to make it decay over time.</p>
					
					<figure>
						<audio src="out/feedback-loop.delayed.wav.mp3" controls=""></audio>
						<figcaption>The echoes repeat at regular intervals, producing a predictable pattern.</figcaption>
					</figure>
				</slide>
				
				<h3>A multi-channel feedback loop</h3>
				<slide>
					<p>Now let&#39;s look at a multi-channel version of the same loop:</p>
					<figure>
						
						<figcaption>Rather than draw out a separate feedback loop for each channel (which makes for cluttered diagrams), I find it neater to consider them as multi-channel signals/blocks.  I&#39;ve used double-borders to indicate multi-channel processing.</figcaption>
					</figure>
					<p>An important property here is that each channel gets delayed by a different amount, so they each produce a different echo pattern.  If we mix all the output channels together, the result still has repeating patterns, but it&#39;s more complex than the single-channel version:</p>
					<figure>
						<audio src="out/feedback-network-simple.mono.wav.mp3" controls="">
					</audio></figure>
				</slide>

				<slide>
					<h4 id="ok-fine">Adding a mixing matrix</h4>
					<p>That more complex sound is good - we don&#39;t want identifiable repeating patterns in our reverb.  But in the loop above, each channel only repeats its own echoes.  Could we get an even more complex result if they picked up each <em>other</em>&#39;s echoes as well?</p>
					<p>We can achieve this by putting a <dfn>mixing matrix</dfn> inside the feedback loop.  This is an <equation>N \times N</equation> orthogonal matrix, where <equation>N</equation> is the number of channels.</p>
					<details>
						<summary>Matrices, and orthogonal matrices</summary>
						<p>If you aren&#39;t familiar with matrices, for this article, we can just say: a matrix is a function which takes in multiple inputs, and adds those together in different ways to produce multiple outputs:</p>
						<figure>
							
						</figure>
						<p>A simple example would be a mid-side encoder, which takes two input channels, and returns them in a linear combination:</p>
						<figure>
							
						</figure>
						<p>For a mixing matrix, we treat each simultaneous set of input samples (from the <equation>N</equation> channels) as the inputs to the function, and use that to generate one sample for each output channel.</p>
						<h4>Orthogonal Matrix</h4>
						<p>An <dfn>orthogonal matrix</dfn> is a matrix where the total energy of the output always equals the total energy of the input.</p>
						<figure>
							
						</figure>
						<p>You don&#39;t need to know how to construct these, we&#39;re going to use some off-the-shelf orthogonal mixing matrices.  However, this property where the output energy matches the input energy is going to be really useful later.</p>
					</details>
					
						
					<figure>
						
					</figure>
					<p>Because of this cross-mixing, as the signal travels around the loop, the echoes appear more and more often, giving an increasingly chaotic result:</p>
					<figure>
						<audio src="out/feedback-network-householder.mono.wav.mp3" controls="">
					</audio></figure>
					<p>The tail end of that is even starting to sound like a reverb, right?</p>
				</slide>

				<slide>
					<h3 id="warning">Caution</h3>
					<p>At this point, it&#39;s tempting to mix the channels as much as possible, or put a bunch of other things inside the feedback loop to speed up diffusion.</p>

					<figure>
						
						<figcaption>Emojis aside, various well-known FDN reverb designs (such as rings, or Dattoro&#39;s figure-of-8 tank) can be understood and analysed as instances of this pattern.</figcaption>
					</figure>
					
<!--					because you end up trading off delay times, or using matrices which provide a lot of mixing (such as Hadamard, which we'll <a href="#hadamard">mention later</a>)-->

					<p id="mixing-warning">There are some interesting designs here - and they work, but they often require careful tuning.  As well as finding a good compromise for the delay time, using too much inter-channel mixing can lock the delays together so they act like a cohesive unit, which isn&#39;t great for longer tails.</p>
					

					<p>Designing a feedback loop to produce a diffuse, long-lasting sound with no strong resonances is <em>hard</em> - but we don&#39;t have to do it!</p>
				</slide>
			</slide>

			<slide>
				<h2>Diffusion</h2>
				<p>There were two properties we said <a href="#reverb-goals">we wanted</a> from the reverb tail:</p>
				<slide>
					<figure>
						<ul>
							<li>diffuse</li>
							<li>long-lasting <slide>✅</slide></li>
						</ul>
						<figcaption>#reverbgoals ✌️</figcaption>
					</figure>
					<p>Even a basic feedback loop handles the &#34;long-lasting&#34; part nicely.  Rather than trying to get the feedback loop to <em>also</em> produce a diffuse sound, we&#39;re going to separate the two concerns:</p>
					<figure>
						
						<figcaption>The two requirements are handled by two separate stages.</figcaption>
					</figure>
					<p>If the diffuser does its job well, we shouldn&#39;t really need to build up echo density in the feedback loop.</p>
					
					<p>Now we just need to design a <em>really good</em> diffuser.</p>
				</slide>
				
				<slide>
					<h3>Single-channel allpass filters</h3>

					<p>We want our diffuser to smudge the sound without adding much of its own timbre.  A useful concept for this is an <dfn>allpass filter</dfn>.</p>
					<p>Allpass filters have a flat frequency response (meaning that whatever frequencies you put in, those frequencies have the same energy in the output), but they can have a varying phase response (meaning some frequencies are delayed more than others, providing the &#34;smudging&#34; that we want).</p>
					
					<slide>
						<h4>Schroeder allpass</h4>
						<p>The <a href="https://ccrma.stanford.edu/~jos/pasp/Allpass_Two_Combs.html">Schroeder allpass</a> is an IIR filter which often comes up when discussing reverb diffusion.  It&#39;s made from a (single-channel) feedback loop which produces a series of echoes, with an extra feed-forward part which gives it a flat frequency response:</p>
						
						<figure>
							
							<figcaption>A classic Schroeder allpass filter</figcaption>
						</figure>

						
						<figure>
							<img src="https://signalsmith-audio.co.uk/writing/2021/lets-write-a-reverb/out/schroeder-allpass-impulse.svg"/>
						</figure>

						<p>For a reverb diffuser, the delay-time is typically set to a handlful of milliseconds, so one allpass on its own doesn&#39;t provide much diffusion - but you can put a bunch of them in a row.  The result is definitely diffuse, but it has a slight metallic edge to it:</p>
						<slide>
							<figure>
								
							</figure>
							<figure>
								<audio controls="" src="out/schroeder-allpass-chain.chain.wav.mp3"></audio>
								<figcaption>10 Schroeder allpasses in series, with delays from 1-15ms, and a feedback gain of 40%</figcaption>
							</figure>
						</slide>
						
					</slide>
					
					<slide>
						<h4>More complex designs</h4>
						<p id="schroeder-flat-phase-patterns">You can make more sophisticated allpasses by replacing the inner delay by another allpass, or using second-order allpasses (which can be combined in series to make even higher orders).  These can improve the sound by disrupting the very regular phase-response of the basic design.</p>
						<figure>
							
							<figcaption><em>*Inception horn noise*</em></figcaption>
						</figure>
						<p>There are some good designs made from just these basic elements - but choosing a design (or understanding why it&#39;s good) isn&#39;t very intuitive.  It&#39;s a tricky tuning problem, from the allpass structures to the delay-times and feedback amounts.</p>
					</slide>
				</slide>

				<slide>
					<h3>Multi-channel allpasses</h3>
					<p>Things get a bit more varied if we look at <em>multi-channel</em> allpasses - but first, we need to define what that actually means.</p>
					<p>This idea of a flat frequency-response which passes through all frequencies (and minimises colouration for a diffuser) is a good place to start.  Let&#39;s phrase it slightly differently:</p>
					<slide></slide>
					<slide>
						<figure id="multi-allpass-definition">
							<blockquote>
								The total energy of the output must match the total energy of the input.
							</blockquote>
							<figcaption>— Mark Twain and Albert Einstein, simultaneously</figcaption>
						</figure>
						<figure>
							
							<figcaption>The energy of the signal is preserved, but it may occur in a different channel or time in the output</figcaption>
						</figure>
						<p>For single-channel allpasses, this is equivalent to the standard &#34;flat frequency-response&#34;, but this definition generalises nicely into multi-dimensional/multi-channel situations.</p>
						<p>Compared to the single-channel case, we have a slightly wider range of basic building-blocks available.  Let&#39;s look at a few examples:</p>
<!--						<aside class="before">-->
<!--							<p>I've usedA technical term for what we're looking for is a <dfn>unitary delay matrix</dfn></p>-->
<!--						</aside>-->
					</slide>
					<slide>
						<h4>Multi-channel delay</h4>
						<p>Much like a single-channel delay is technically an allpass filter (because it has a flat frequency response), a multi-channel delay fits the bill:</p>
						<figure>
							
							<figcaption>It&#39;s more interesting than the single-channel case, because each channel can be delayed by a different amount.</figcaption>
						</figure>
						<p>This will be useful for our diffuser: if the input channels are somehow synchronised in time (e.g. an echo occuring in all channels simultaneously), a multi-channel delay can de-sychronise those echoes.</p>
					</slide>
					<slide>
						<h4>Mixing matrix</h4>
						<p>Another type of allpass (which only makes sense for the multi-channel case) is a mixing matrix:</p>
						<figure>
							
						</figure>
						
						
						<p>Each output channel is a linear combination of the input channels.  If some input feature (e.g. an echo at a certain time) appears in only one channel, this distributes that feature across the other channels as well.</p>
						
						<section>
							<h5 id="hadamard">Hadamard matrices</h5>
							<ul>
								<li>maximum inter-channel mixing</li>
								<li>efficient: <equation>N \log_2(N)</equation> additions for an <equation>N</equation>-channel matrix. </li>
							</ul>
						</section>
						<p>The <a href="https://en.wikipedia.org/wiki/Hadamard_matrix">Hadamard</a> family of matrices provides the maximum amount of inter-channel mixing, and can also be computed pretty efficiently for powers of 2 (<equation>N \log_2(N)</equation> additions for <equation>N</equation> channels) - here&#39;s some <a href="https://github.com/Signalsmith-Audio/reverb-example-code/blob/2798498231eac8c31e8d75e7c1ddea1e4c794f18/mix-matrix.h#L24">example code</a>.</p>
					</slide>
					<slide>
						<h4>Shuffling channels and inverting polarity</h4>
						<p>OK, so it&#39;s not very interesting - but swapping channels around is (technically) a multi-channel allpass.  We can also invert the polarity (multiply by <equation>-1</equation>) on some or all of the channels:</p>
						<figure>
							
						</figure>
						
					</slide>
					<slide>
						<h4>... and more</h4>
						<p>There are a host of other multi-channel allpass structures available, including:</p>
						<ul>
							<li>IIR allpasses (e.g. <a href="https://ccrma.stanford.edu/~jos/pasp/Gerzon_Nested_MIMO_Allpass.html">Gerzon</a>)</li>
							<li>Single-channel allpasses applied to the channels independently</li>
							<li>Lower-dimensional allpasses applied to subset of the channels</li>
						</ul>
						<p>It&#39;s worth noting that in the single-channel case, IIR allpasses are pretty much the only tool we have.</p>
						<p>In the multi-channel case, we highlighted some basic building-blocks which don&#39;t contain any feedback, but are still enough to design a great diffuser by just combining them in series - which exactly what we&#39;re going to do.</p>
					</slide>
				</slide>

				<slide>
					<h3>A multi-channel diffuser</h3>
					
					<p>So, here&#39;s the plan for our diffuser: we define a &#34;diffusion step&#34;, made from a sequence of (multi-channel) operations:</p>
					<slide></slide>
					<figure>
						<h4>Single diffusion step</h4>
						<ol>
							<li>delay</li>
							<li>shuffle channels &amp; invert (some) polarity</li>
							<li>Hadamard mixing matrix</li>
						</ol>
						<figcaption>Shuffling and polarity-flipping can technically be considered part of the Hadamard matrix, but I&#39;ve listed it separately to make it clear that the shuffling/inversion should be different for each step.</figcaption>
					</figure>
					<p>The delay takes an input (containing some number of echoes) and un-aligns the channels.  After some shuffling, the Hadamard matrix takes each unaligned echo, and redistributes it across all the channels:</p>
					<slide>
						<figure>
<!--							<slide class="slide-only"><object data="diagrams/diffusion-step-1.svg" style="max-height:50vh"><img src="diagrams/diffusion-step.svg"></object></slide>-->
<!--							<slide class="slide-only"><object data="diagrams/diffusion-step-2.svg" style="max-height:50vh"><img src="diagrams/diffusion-step.svg"></object></slide>-->
<!--							<slide class="slide-only"><object data="diagrams/diffusion-step-3.svg" style="max-height:50vh"><img src="diagrams/diffusion-step.svg"></object></slide>-->
							<slide></slide>
							<figcaption>The delay makes sure every echo is at a distinct time, and the Hadamard matrix make sure each distinct echo time is present in every channel.</figcaption>
						</figure>
						<p>Every time we apply a diffusion step like this, we end up with <equation>N</equation> times more echoes in the output than we had in the input (where <equation>N</equation> is the number of channels).</p>
						<p>For a larger number of channels (e.g. 8+), this means we can get a very dense result from a small number of these diffusion steps.</p>

						<slide>
							<h4>Examples</h4>
							<slide></slide>
							
							<p>Let&#39;s run some clicks through this diffuser, to see what it sounds like.  Here&#39;s a 4-channel diffuser, with 3 diffusion steps, each with delays from 0-60ms:</p>
							<figure>
								<audio controls="" src="out/diffusion4-chain-3-60.chain.wav.mp3"></audio>
								<figcaption><strong>4</strong> channels, <strong>3</strong> stages, delays from <strong>0-60ms</strong>.</figcaption>
							</figure>
							
							<p>To get smoother diffusion, you can either add more diffusion steps, or increase the number of channels.  Here&#39;s an 8-channel, 4-step diffuser:</p>
							<figure>
								<audio controls="" src="out/diffusion8-chain-4-60.chain.wav.mp3"></audio>
								<figcaption><strong>8</strong> channels, <strong>4</strong> stages, delays from <strong>0-60ms</strong></figcaption>
							</figure>

							<p>You still need to choose the number of channels and diffusion steps, but it&#39;s pretty easy to get a good configuration out of this pattern.</p>
						</slide>
					</slide>
				</slide>

				<slide>
					<h4>Down-mixing</h4>
					<p>At some point in our final effect, we need to mix these multi-channel signals back down to a mono (or stereo) output.</p>
					<p>When you do this downmixing, the system as a whole stops being an allpass (even if you&#39;re just mixing down to the same number of channels as you started with).</p>
					<slide>
						<figure>
							
						</figure>
						<figure>
							
							<figcaption>Ceci n&#39;est pas un passe-tout.</figcaption>
						</figure>
					</slide>
					<p>This is fine as long as your phase-shifts don&#39;t have <a href="#schroeder-flat-phase-patterns">regular patterns</a> which could produce an identifiable &#34;comb&#34; timbre.  The diffuser design we&#39;ve explored here gives a nicely irregular phase-response, particularly for larger numbers of channels (<equation>N</equation>).</p>
					<p>Because the Hadamard matrix has mixed things already, we can just take the top 1 or 2 output channels to get a good result - this is what we did for the examples above.</p>
					<p>In our final reverb design, the diffuser&#39;s multi-channel output will head straight into the multi-channel feedback loop, so we don&#39;t downmix until later.</p>
				</slide>

				<slide>
					<h4>Choosing delay times</h4>
					<p>Once you&#39;ve decided what range of delay times you want for a particular diffusion step, you could pick each channel&#39;s delay time randomly.  However, if you divide the range into equal segments, and use one sub-range for each channel, they end up <em>approximately</em> evenly-distributed while still being randomised.</p>
					<slide>
						<figure>
							
						</figure>
						<figure>
							
						</figure>
					</slide>
					
				</slide>
				<slide>
					<h4 id="uneven-diffusion-steps">Uneven diffusion steps</h4>
					<p>There&#39;s no reason the diffusion steps need to have similar delay-lengths.  You could stack together short steps and long steps.</p>
					<p>To show the difference, here&#39;s a really long diffuser: 8 channels, 5 diffusion steps, with delays from 0-300ms:</p>
					<figure>
						
						<slide>
							<audio controls="" src="out/diffusion8-chain-5-300.chain.wav.mp3"></audio>
						</slide>
						<figcaption>Even though the middle part is very diffuse, the start and end are slightly rough.</figcaption>
					</figure>
					<slide>
						<p>Here&#39;s a similar setup with the same total diffusion length, except each diffusion step is twice as long as the last:</p>
						<figure>
							
							<slide>
								<audio controls="" src="out/diffusion8-chain-5-300-vary.chain.wav.mp3"></audio>
							</slide>
						</figure>
						<slide>
							<p>This gives a smoother start/end, and a less noticeable &#34;peak&#34; in the middle.</p>
							<figure>
								<img src="https://signalsmith-audio.co.uk/writing/2021/lets-write-a-reverb/out/diffusion-long-even.svg"/>
								<figcaption>Comparing the waveform of the two examples</figcaption>
							</figure>
							<p>So, it&#39;s not like you can&#39;t experiment and tweak this design - but both of the options sound pretty good.  Varying the diffusion-step sizes like this just puts a bit of icing on the cake.</p>
						</slide>
					</slide>
				</slide>
			</slide>
			<slide>
				<h2>Putting it together</h2>
				
				<slide>
					<p>So: we have a multi-channel diffuser, and we have a multi-channel feedback-delay loop.  All we have to do is duplicate our input, and mix down our output, and we&#39;re done!</p>
					<p>Here&#39;s our combined design:</p>
					<figure>
						
						<figcaption>Everything between &#34;split&#34; and &#34;mix&#34; is a multi-channel signal.  I would recommend using at least 8 internal channels for a high-quality output.</figcaption>
					</figure>

					

					<p>The input and output don&#39;t have to be mono - just choose something appropriate when converting to/from <equation>N</equation> channels, and you can have a stereo (or more) reverb.</p>
					
					<slide>
						<h3>Examples</h3>
						<slide>
							<p>We&#39;ll use a fairly long reverb configuration:
							</p><ul>
								<li>8 channels for the diffuser and feedback-loop</li>
								<li>4 diffusion steps (20ms, 40ms, 80ms, 160ms)</li>
								<li>feedback gain of 85%</li>
								<li>feedback delays from 100-200ms</li>
							</ul>
						</slide>
						
						<slide>
							<h4>Click response</h4>
							<p>Here&#39;s what happens when we put a short &#34;click&#34; through it:</p>
							<figure>
								<audio controls="" src="out/reverb8-pulse.reverb.wav.mp3"></audio>
							</figure>
							<p>Pretty smooth!  Let&#39;s try it on some more musical inputs:</p>
						</slide>
						
						<figure>
							<table>
								<thead>
									<tr>
										<th>input</th>
										<th>original</th>
										<th>reverb (wet)</th>
										<th>reverb (5% wet)</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>drums</td>
										<td><audio controls="" src="audio/drums.wav.mp3"></audio></td>
										<td><audio controls="" src="out/reverb8-drums.wav.mp3"></audio></td>
										<td><audio controls="" src="out/reverb8-drums-mix.wav.mp3"></audio></td>
									</tr>
									<tr>
										<td>piano</td>
										<td><audio controls="" src="audio/piano-soft.wav.mp3"></audio></td>
										<td><audio controls="" src="out/reverb8-piano.wav.mp3"></audio></td>
										<td><audio controls="" src="out/reverb8-piano-mix.wav.mp3"></audio></td>
									</tr>
								</tbody>
							</table>
						</figure>
						
						<slide>
							<h4>Drums</h4>
							<p>Here&#39;s a little drum riff:</p>
							<slide>
								<figure>
									<audio controls="" src="audio/drums.wav.mp3"></audio>
									<figcaption>
								</figcaption></figure>
							</slide>
							<p>And here&#39;s the output from our reverb:</p>
							<slide>
								<figure>
									<audio controls="" src="out/reverb8-drums.wav.mp3"></audio>
									<figcaption>
								</figcaption></figure>
							</slide>
						</slide>
						<slide>
							<h4>Piano</h4>
							<p>Here&#39;s a little bit of piano:</p>
							<slide>
								<figure>
									<audio controls="" src="audio/piano-soft.wav.mp3"></audio>
									<figcaption>
								</figcaption></figure>
							</slide>
							<p>And here&#39;s the output from our reverb:</p>
							<slide>
								<figure>
									<audio controls="" src="out/reverb8-piano.wav.mp3"></audio>
									<figcaption>
								</figcaption></figure>
							</slide>
						</slide>
					</slide>
				</slide>
				
				<slide>
					<h3>Next steps</h3>
					<p>This is a very minimal reverb design, and there are loads of ways to extend it.  I&#39;m not going to go into much detail, just sketch out a few things you might want to add:</p>
					<slide></slide>
					<slide>
						<h4>Early reflections</h4>
						<p>The delays in the feedback loop mean there&#39;s a gap between the original sound and the earliest echoes.  To bridge this gap, we can use a separate delay path (taken from the diffused signal) to fill the time until the first echoes from the feedback loop come through.</p>
						<figure>
							
						</figure>
						<p>The diffuser itself also delays the sound a bit - so we could even take some input from earlier in the diffuser, so the reverberation starts as sharply as possible (especially if the earlier diffusion steps have shorter delays as <a href="#uneven-diffusion-steps">mentioned above</a>).</p>
					</slide>
					<slide>
						<h4>Modulation</h4>
						<p>In a real space, small movements in the environment (even air currents) produce subtle variations in delay times.  In an FDN reverb, this can be modeled by gently modulating some of the delay times - or cranked way past realism to get a supernaturally thick sound.</p>
						<p>There are a couple of places where you could modulate the delays in this design, which will produce slightly different sounds:</p>
						<figure>
							
						</figure>
						
					</slide>
					<slide>
						<h4>Filtering</h4>
						<p>In real spaces, high frequencies are often absorbed faster, and have shorter decay times.  We can achieve this in an FDN reverb by using shelving filters to get frequency-dependent decay gain.</p>
						<figure>
							
							<figcaption>If the decay gain inside your feedback loop is -1.5dB, then adding a -1.5dB high-shelf filter would make high frequencies die away twice as fast.</figcaption>
						</figure>
					</slide>
					<slide>
						<p>With those extra details in the design, you can get some a pretty good sounds:</p>
						<figure>
							<audio src="audio/celadon-ident.mp3" controls=""></audio>
							<figcaption>An example made from piano, synth bass and reverb</figcaption>
						</figure>
					</slide>
				</slide>
			</slide>
			<slide>
				<h2>That&#39;s it!</h2>

				<figure>
					
					<figcaption>Everything between &#34;split&#34; and &#34;mix&#34; is a multi-channel signal.  I would recommend using at least 8 internal channels for a high-quality output.</figcaption>
				</figure>

				<p>Hopefully it wasn&#39;t too complicated.  You can look at some <a href="https://github.com/Signalsmith-Audio/reverb-example-code/blob/main/reverb-example-code.h">C++ example code</a> to see these ideas in action.</p>
				<p>I really wanted to write this article, because many of the better-known FDN designs include magic numbers or peculiar allpass structures which seem like they&#39;ve been very carefuly tuned.</p>
				<p>I didn&#39;t like this, and when one day someone asked me to write &#34;a reverb&#34; (no specifics), I sketched out a design which included <em>no</em> IIR allpasses, and was robust enough that I could throw a random-number generator at all the delay times and it would still sound good.</p>
				<p>This is a distilled version of that design, and I hope it&#39;s a useful starting point from which people can try a bunch of interesting things. 🙂</p>
			</slide>
			
		</article></div>
  </body>
</html>
