<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bernsteinbear.com/blog/liveness-datalog/?utm_source=rss">Original</a>
    <h1>Liveness analysis with Datalog</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>After publishing <a href="https://bernsteinbear.com/blog/linear-scan">Linear scan register allocation on SSA</a>, I
had a nice call with <a href="https://waleedkhan.name">Waleed Khan</a> where he showed me
how to Datalog. He thought it might be useful to try implementing liveness
analysis as a Datalog problem.</p>

<p>We started off with the Wimmer2010 CFG example from that post, sketching out
manually which variables were live out of each block: R10 out of B1, R12 out of
B2, etc.</p>

<figure>

<figcaption>
    <p>The graph from Wimmer2010 has come back! Remember, we’re using block arguments
instead of phis, so <code>B1(R10, R11)</code> defines R10 and R11 before the first
instruction in B1.</p>
  </figcaption>
</figure>

<p>Then we tried to formulate liveness as a Datalog relation.</p>

<p>Liveness is normally (at least for me) defined in terms of two relations:
live-in and live-out. Live-out is “what is needed” from all of the successors
of a block and live-in is the “what is needed” summary for a block. So, in
fake math notation:</p>

<div><div><pre><code>live-out(b) = union(live-in(s) for each successor s of b)
live-in(b) = (live-out(b) + used(b)) - defined(b)
</code></pre></div></div>

<p>where each of the component parts of that expression represent sets of
variables:</p>

<ul>
  <li><em>used(b)</em> is the set of variables referenced as in-operands to instructions in
a block</li>
  <li><em>defined(b)</em> is the set of variables defined by instructions in a block</li>
</ul>

<p>We ended up computing the live-in sets for blocks in the register allocator
post but then using the live-out sets instead. So today let’s compute both
live-in and live-out sets with Datalog!</p>

<h2 id="datalog">Datalog</h2>

<p>Datalog is a logic programming language. It probably looks and feels different
from every other programming language you have used… except for maybe SQL. It
might feel similar to SQL, except SQL has a certain order to it that Datalog
does not.</p>

<p>We’ll be using Souffle here because Waleed mentioned it and also I learned a
bit about it in my databases class.</p>

<p>The thing you do first is define your relations, which is what Datalog calls a
table.</p>

<p>In this case, if we want to compute liveness information, we have to know
information about what a block uses, defines, and what successors it has.</p>

<p>First, the thing you have to know about Datalog, is that it’s kind of like
the opposite of array programming. We’re going to express things about sets by
expressing facts about individual items in a set.</p>

<p>For example, we’re not going to say “this block B4 uses [R10, R12, R16]”. We’re
going to say three separate facts: “B4 uses R10”, “B4 uses R12”, “B4 uses R16”.
You can think about it like each relation being a database table where each
parameter is a column name.</p>

<p>Here are the relations for block uses, block defs, and which blocks follow
other blocks:</p>

<div><div><pre><code>// liveness.dl
.decl block_use(block:symbol, var:symbol)
.decl block_def(block:symbol, var:symbol)
.decl block_succ(succ:symbol, pred:symbol)
</code></pre></div></div>

<p>Where <code>symbol</code> here means string.</p>

<p>We can then embed some facts inline. For example, this says “A defines R0 and
R1 and uses R0”:</p>

<div><div><pre><code>block_def(&#34;A&#34;, &#34;R0&#34;).
block_def(&#34;A&#34;, &#34;R1&#34;).
block_use(&#34;A&#34;, &#34;R0&#34;).
</code></pre></div></div>

<p>You can also provide facts as a TSV but this file format is so irritating to
construct manually and has given me silently wrong answers in Souffle before so
I am not doing that for this example.</p>

<p>You can, for your edification, manually encode all the use/def/successor facts
from the previous post into Souffle—or you can copy this chunk into your file:</p>

<div><div><pre><code>// liveness.dl
// ...
block_def(&#34;B1&#34;, &#34;R10&#34;).
block_def(&#34;B1&#34;, &#34;R11&#34;).
block_use(&#34;B1&#34;, &#34;R11&#34;).

block_def(&#34;B2&#34;, &#34;R12&#34;).
block_def(&#34;B2&#34;, &#34;R13&#34;).
block_use(&#34;B2&#34;, &#34;R13&#34;).

block_def(&#34;B3&#34;, &#34;R14&#34;).
block_def(&#34;B3&#34;, &#34;R15&#34;).
block_use(&#34;B3&#34;, &#34;R12&#34;).
block_use(&#34;B3&#34;, &#34;R13&#34;).
block_use(&#34;B3&#34;, &#34;R14&#34;).
block_use(&#34;B3&#34;, &#34;R15&#34;).

block_def(&#34;B4&#34;, &#34;R16&#34;).
block_use(&#34;B4&#34;, &#34;R16&#34;).
block_use(&#34;B4&#34;, &#34;R10&#34;).
block_use(&#34;B4&#34;, &#34;R12&#34;).

block_succ(&#34;B2&#34;, &#34;B1&#34;).
block_succ(&#34;B3&#34;, &#34;B2&#34;).
block_succ(&#34;B2&#34;, &#34;B3&#34;).
block_succ(&#34;B4&#34;, &#34;B2&#34;).
</code></pre></div></div>

<p>We can declare our live-in and live-out relations similarly to our use/def/succ
relations. We mark them as being <code>.output</code> so that Souffle presents us with the
results.</p>

<div><div><pre><code>// liveness.dl
// ...
.decl live_out(block:symbol, var:symbol)
.output live_out
.decl live_in(block:symbol, var:symbol)
.output live_in
</code></pre></div></div>

<p>Now it’s time to define our relations. You may notice that the Souffle
definitions look very similar to our earlier definitions. This is no mistake;
Datalog was created for dataflow and graph problems.</p>

<p>We’ll start with live-out:</p>

<div><div><pre><code>// liveness.dl
// ...
live_out(b, v) :- block_succ(s, b), live_in(s, v).
</code></pre></div></div>

<p>We read this left to right as “a variable <code>v</code> is live-out of block <code>b</code> if block
<code>s</code> is a successor of <code>b</code> and <code>v</code> is live-in to <code>s</code>”. The <code>:-</code> defines the left
side in terms of the right side. The comma between <code>block_succ</code> and <code>live_in</code>
means it’s a conjunction—<em>and</em>.</p>

<p>Where’s the union? Well, remember what I said about array programming? We’re
not thinking in terms of sets. We’re thinking one program variable at a time.
As Souffle executes our relations, <code>live_out</code> will incrementally build up a
table.</p>

<p>It’s also a little weird to program in this style because <code>s</code> wasn’t textually
defined anywhere like a parameter or a variable. You kind of have to think of
<code>s</code> as connector, a binder, a foreign key—what have you. It’s a placeholder.
(I don’t know how to explain this well. Sorry.)</p>

<p>Then we can define live-in. This on the surface looks more complicated but I
think that is only because of Souffle’s choice of syntax.</p>

<div><div><pre><code>// liveness.dl
// ...
live_in(b, v) :- (live_out(b, v); block_use(b, v)), !block_def(b, v).
</code></pre></div></div>

<p>It reads as “a variable <code>v</code> is live-in to <code>b</code> if it is either live-out of <code>b</code>
or used in <code>b</code>, and <em>not</em> defined in <code>b</code>. The semicolons are
disjunctions—<em>or</em>—and the exclamation points negations—<em>not</em>.</p>

<p>These relations look endlessly mutually recursive but you have to keep in mind
that we’re not running functions on data, exactly. We’re declaratively
expressing definitions of rules—relations. <code>block_use(b, v)</code> in the body of
<code>live_in</code> is not calling a function but instead making a query—is the row
<code>(b, v)</code> in the table <code>block_use</code>? Datalog builds the tables until saturation.</p>

<p>Now we can run Souffle! We tell it to dump to standard output with <code>-D-</code> but
you could just as easily have it dump each output relation in its own separate
file in the current directory by specifying <code>-D.</code>.</p>

<div><div><pre><code><span>$</span><span> </span>souffle <span>-D-</span> liveness.dl
<span>---------------
live_in
block   var
===============
B2      R10
B3      R10
B3      R12
B3      R13
B4      R10
B4      R12
===============
---------------
live_out
block   var
===============
B1      R10
B2      R10
B2      R12
B2      R13
B3      R10
===============
</span><span>$</span><span>
</span></code></pre></div></div>

<p>That’s neat. We got nicely formatted tables and it only took us two lines of
code! Let’s compare to our Ruby code from the previous post to underscore the
point:</p>

<div><div><pre><code><span>def</span> <span>analyze_liveness</span>
  <span>order</span> <span>=</span> <span>post_order</span>
  <span>gen</span><span>,</span> <span>kill</span> <span>=</span> <span>compute_initial_liveness_sets</span><span>(</span><span>order</span><span>)</span>
  <span>live_in</span> <span>=</span> <span>Hash</span><span>.</span><span>new</span> <span>0</span>
  <span>changed</span> <span>=</span> <span>true</span>
  <span>while</span> <span>changed</span>
    <span>changed</span> <span>=</span> <span>false</span>
    <span>for</span> <span>block</span> <span>in</span> <span>order</span>
      <span>block_live</span> <span>=</span> <span>block</span><span>.</span><span>successors</span><span>.</span><span>map</span> <span>{</span> <span>|</span><span>succ</span><span>|</span> <span>live_in</span><span>[</span><span>succ</span><span>]</span> <span>}.</span><span>reduce</span><span>(</span><span>0</span><span>,</span> <span>:|</span><span>)</span>
      <span>block_live</span> <span>|=</span> <span>gen</span><span>[</span><span>block</span><span>]</span>
      <span>block_live</span> <span>&amp;=</span> <span>~</span><span>kill</span><span>[</span><span>block</span><span>]</span>
      <span>if</span> <span>live_in</span><span>[</span><span>block</span><span>]</span> <span>!=</span> <span>block_live</span>
        <span>changed</span> <span>=</span> <span>true</span>
        <span>live_in</span><span>[</span><span>block</span><span>]</span> <span>=</span> <span>block_live</span>
      <span>end</span>
    <span>end</span>
  <span>end</span>
  <span>live_in</span>
<span>end</span>
</code></pre></div></div>

<p>This is because we have separated the iteration-to-fixpoint bit from the main
bit of the dataflow analysis: the equation. If we let Datalog do the data
movement for us, we can work on defining the rules—and only the rules.</p>

<blockquote>
  <p>This is probably why, in the fullness of time, many static analysis and
compiler tools end up growing some kind of embedded (partial) Datalog engine.
Call it Scholz’s tenth rule.</p>
</blockquote>

<p>Souffle also has the ability to compile to C++, which gives you two nice
things:</p>

<ol>
  <li>you can probably get faster execution</li>
  <li>you can use it from an existing C++ program</li>
</ol>

<p>I don’t have any experience with this API.</p>

<p>This is when Waleed mentioned offhandedly that he had heard about some embedded
Rust datalog called <a href="https://s-arash.github.io/ascent/">Ascent</a>.</p>

<h2 id="rust">Rust</h2>

<p>The front page of the Ascent website is a really great sell if you show up
thinking “gee, I wish I had Datalog to use in my Rust program”. Right out the
gate, you get reasonable-enough Datalog syntax via a proc macro.</p>

<p>For example, here is the canonical path example for Souffle:</p>

<div><div><pre><code>.decl edge(x:number, y:number)
.decl path(x:number, y:number)

path(x, y) :- edge(x, y).
path(x, y) :- path(x, z), edge(z, y).
</code></pre></div></div>

<p>and in Ascent:</p>

<div><div><pre><code><span>ascent!</span> <span>{</span>
   <span>relation</span> <span>edge</span><span>(</span><span>i32</span><span>,</span> <span>i32</span><span>);</span>
   <span>relation</span> <span>path</span><span>(</span><span>i32</span><span>,</span> <span>i32</span><span>);</span>

   <span>path</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>&lt;--</span> <span>edge</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>);</span>
   <span>path</span><span>(</span><span>x</span><span>,</span> <span>z</span><span>)</span> <span>&lt;--</span> <span>edge</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>),</span> <span>path</span><span>(</span><span>y</span><span>,</span> <span>z</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Super.</p>

<p>We weren’t sure if the Souffle liveness would port cleanly to Rust, but it sure
did! It even lets you use your own datatypes instead of just <code>i32</code> (which the
front-page example uses).</p>

<div><div><pre><code><span>use</span> <span>ascent</span><span>::</span><span>ascent</span><span>;</span>

<span>#[derive(Clone,</span> <span>PartialEq,</span> <span>Eq,</span> <span>Hash,</span> <span>Copy)]</span>
<span>struct</span> <span>BlockId</span><span>(</span><span>i32</span><span>);</span>

<span>impl</span> <span>std</span><span>::</span><span>fmt</span><span>::</span><span>Debug</span> <span>for</span> <span>BlockId</span> <span>{</span>
    <span>fn</span> <span>fmt</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>f</span><span>:</span> <span>&amp;</span><span>mut</span> <span>std</span><span>::</span><span>fmt</span><span>::</span><span>Formatter</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span><span>)</span> <span>-&gt;</span> <span>std</span><span>::</span><span>fmt</span><span>::</span><span>Result</span> <span>{</span>
        <span>write!</span><span>(</span><span>f</span><span>,</span> <span>&#34;B{}&#34;</span><span>,</span> <span>self</span><span>.0</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>#[derive(Clone,</span> <span>PartialEq,</span> <span>Eq,</span> <span>Hash,</span> <span>Copy)]</span>
<span>struct</span> <span>VarId</span><span>(</span><span>i32</span><span>);</span>

<span>impl</span> <span>std</span><span>::</span><span>fmt</span><span>::</span><span>Debug</span> <span>for</span> <span>VarId</span> <span>{</span>
    <span>fn</span> <span>fmt</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>f</span><span>:</span> <span>&amp;</span><span>mut</span> <span>std</span><span>::</span><span>fmt</span><span>::</span><span>Formatter</span><span>&lt;</span><span>&#39;_</span><span>&gt;</span><span>)</span> <span>-&gt;</span> <span>std</span><span>::</span><span>fmt</span><span>::</span><span>Result</span> <span>{</span>
        <span>write!</span><span>(</span><span>f</span><span>,</span> <span>&#34;R{}&#34;</span><span>,</span> <span>self</span><span>.0</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>ascent!</span> <span>{</span>
    <span>relation</span> <span>block_use</span><span>(</span><span>BlockId</span><span>,</span> <span>VarId</span><span>);</span>
    <span>relation</span> <span>block_def</span><span>(</span><span>BlockId</span><span>,</span> <span>VarId</span><span>);</span>
    <span>relation</span> <span>block_succ</span><span>(</span><span>BlockId</span><span>,</span> <span>BlockId</span><span>);</span>  <span>// (succ, pred)</span>
    <span>relation</span> <span>live_out</span><span>(</span><span>BlockId</span><span>,</span> <span>VarId</span><span>);</span>
    <span>relation</span> <span>live_in</span><span>(</span><span>BlockId</span><span>,</span> <span>VarId</span><span>);</span>
    <span>live_out</span><span>(</span><span>b</span><span>,</span> <span>v</span><span>)</span> <span>&lt;--</span> <span>block_succ</span><span>(</span><span>s</span><span>,</span> <span>b</span><span>),</span> <span>live_in</span><span>(</span><span>s</span><span>,</span> <span>v</span><span>);</span>
    <span>live_in</span><span>(</span><span>b</span><span>,</span> <span>v</span><span>)</span> <span>&lt;--</span> <span>(</span><span>live_out</span><span>(</span><span>b</span><span>,</span> <span>v</span><span>)</span> <span>|</span> <span>block_use</span><span>(</span><span>b</span><span>,</span> <span>v</span><span>)),</span> <span>!</span><span>block_def</span><span>(</span><span>b</span><span>,</span> <span>v</span><span>);</span>
<span>}</span>
<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>// ...</span>
<span>}</span>
</code></pre></div></div>

<p>Notice how we don’t have an <code>input</code> or <code>output</code> annotation like we did in
Datalog. That’s because this is designed to be embedded in an existing program,
which probably doesn’t to deal with the disk (or at least wants to read/write
in its own format).</p>

<p>Ascent lets us give it some vectors of data and then at the end lets us read
some vectors of data too.</p>

<div><div><pre><code><span>// ...</span>
<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>let</span> <span>mut</span> <span>prog</span> <span>=</span> <span>AscentProgram</span><span>::</span><span>default</span><span>();</span>
    <span>let</span> <span>b1</span> <span>=</span> <span>BlockId</span><span>(</span><span>1</span><span>);</span>
    <span>let</span> <span>b2</span> <span>=</span> <span>BlockId</span><span>(</span><span>2</span><span>);</span>
    <span>let</span> <span>b3</span> <span>=</span> <span>BlockId</span><span>(</span><span>3</span><span>);</span>
    <span>let</span> <span>b4</span> <span>=</span> <span>BlockId</span><span>(</span><span>4</span><span>);</span>
    <span>let</span> <span>r10</span> <span>=</span> <span>VarId</span><span>(</span><span>10</span><span>);</span>
    <span>let</span> <span>r11</span> <span>=</span> <span>VarId</span><span>(</span><span>11</span><span>);</span>
    <span>let</span> <span>r12</span> <span>=</span> <span>VarId</span><span>(</span><span>12</span><span>);</span>
    <span>let</span> <span>r13</span> <span>=</span> <span>VarId</span><span>(</span><span>13</span><span>);</span>
    <span>let</span> <span>r14</span> <span>=</span> <span>VarId</span><span>(</span><span>14</span><span>);</span>
    <span>let</span> <span>r15</span> <span>=</span> <span>VarId</span><span>(</span><span>15</span><span>);</span>
    <span>let</span> <span>r16</span> <span>=</span> <span>VarId</span><span>(</span><span>16</span><span>);</span>
    <span>prog</span><span>.block_def</span> <span>=</span> <span>vec!</span><span>[</span>
        <span>(</span><span>b1</span><span>,</span> <span>r10</span><span>),</span>
        <span>(</span><span>b1</span><span>,</span> <span>r11</span><span>),</span>
        <span>(</span><span>b2</span><span>,</span> <span>r12</span><span>),</span>
        <span>(</span><span>b2</span><span>,</span> <span>r13</span><span>),</span>
        <span>(</span><span>b3</span><span>,</span> <span>r14</span><span>),</span>
        <span>(</span><span>b3</span><span>,</span> <span>r15</span><span>),</span>
        <span>(</span><span>b4</span><span>,</span> <span>r16</span><span>),</span>
    <span>];</span>
    <span>prog</span><span>.block_succ</span> <span>=</span> <span>vec!</span><span>[</span>
        <span>(</span><span>b2</span><span>,</span> <span>b1</span><span>),</span>
        <span>(</span><span>b3</span><span>,</span> <span>b2</span><span>),</span>
        <span>(</span><span>b2</span><span>,</span> <span>b3</span><span>),</span>
        <span>(</span><span>b4</span><span>,</span> <span>b2</span><span>),</span>
    <span>];</span>
    <span>prog</span><span>.block_use</span> <span>=</span> <span>vec!</span><span>[</span>
        <span>(</span><span>b1</span><span>,</span> <span>r11</span><span>),</span>
        <span>(</span><span>b2</span><span>,</span> <span>r13</span><span>),</span>
        <span>(</span><span>b3</span><span>,</span> <span>r12</span><span>),</span>
        <span>(</span><span>b3</span><span>,</span> <span>r13</span><span>),</span>
        <span>(</span><span>b3</span><span>,</span> <span>r14</span><span>),</span>
        <span>(</span><span>b3</span><span>,</span> <span>r15</span><span>),</span>
        <span>(</span><span>b4</span><span>,</span> <span>r10</span><span>),</span>
        <span>(</span><span>b4</span><span>,</span> <span>r12</span><span>),</span>
        <span>(</span><span>b4</span><span>,</span> <span>r16</span><span>),</span>
    <span>];</span>
    <span>prog</span><span>.run</span><span>();</span>
    <span>println!</span><span>(</span><span>&#34;live out: {:?}&#34;</span><span>,</span> <span>prog</span><span>.live_out</span><span>);</span>
    <span>println!</span><span>(</span><span>&#34;live in: {:?}&#34;</span><span>,</span> <span>prog</span><span>.live_in</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Then we need only run <code>cargo add ascent</code> and <code>cargo run</code>—both of which worked
with zero issues—and see the results.</p>

<div><div><pre><code><span>$</span><span> </span>cargo run
<span>    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/liveness`
live out: [(B2, R12), (B2, R13), (B2, R10), (B1, R10), (B3, R10)]
live in: [(B3, R12), (B3, R13), (B4, R10), (B4, R12), (B2, R10), (B3, R10)]
</span><span>$</span><span>
</span></code></pre></div></div>

<p>It’s not a fancy looking table, but it’s very close to my program, which is
neat.</p>

<p>This is similar to embedding Souffle in C++ and then calling the C++. One
difference, though, is the Souffle process has two steps. It’s a slight build
system complication. But this isn’t meant to be a Datalog comparison post!</p>

<h2 id="more">More?</h2>

<p>Can we model all of linear scan this way? Maybe. I’m new to all this stuff.</p>

<p>Ascent also seems to support lattices, which means we can use it to do abstract
interpretation on some cool domains.</p>

<p><a href="https://pointersgonewild.com/">Maxime Chevalier-Boisvert</a> and I prototyped
<a href="https://github.com/shopify/loupe">loupe</a>, an interprocedural type analysis in
Rust. We had to build our own iterate-to-fixpoint engine, which was
non-trivial. I wonder how it would look to build something similar on top of
Ascent.</p>

<p>I kind of want to check out <a href="https://github.com/frankmcsherry/">Frank
McSherry</a>’s
<a href="https://github.com/frankmcsherry/blog/blob/master/posts/2025-06-03.md">datatoad</a>.</p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>That’s all for now, folks. Just a couple Datalog snippets. Happy hacking.</p>

        </div></div>
  </body>
</html>
