<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ashvardanian/less_slow.cpp">Original</a>
    <h1>Less Slow C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<blockquote>
<p dir="auto">The benchmarks in this repository don&#39;t aim to cover every topic entirely, but they help form a mindset and intuition for performance-oriented software design.
It also provides an example of using some non-<a href="https://en.wikipedia.org/wiki/Standard_Template_Library" rel="nofollow">STL</a> but de facto standard libraries in C++, importing them via CMake, and compiling from source.
For higher-level abstractions and languages, check out <a href="https://github.com/ashvardanian/less_slow.rs"><code>less_slow.rs</code></a> and <a href="https://github.com/ashvardanian/less_slow.py"><code>less_slow.py</code></a>.</p>
</blockquote>
<p dir="auto">Much modern code suffers from common pitfalls, such as bugs, security vulnerabilities, and <strong>performance bottlenecks</strong>.
University curricula often teach outdated concepts, while bootcamps oversimplify crucial software development principles.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/ashvardanian/ashvardanian/blob/master/repositories/less_slow.cpp.jpg?raw=true"><img src="https://github.com/ashvardanian/ashvardanian/raw/master/repositories/less_slow.cpp.jpg?raw=true" alt="Less Slow C++"/></a></p>
<p dir="auto">This repository offers practical examples of writing efficient C and C++ code.
It leverages C++20 features and is designed primarily for GCC and Clang compilers on Linux, though it may work on other platforms.
The topics range from basic micro-kernels executing in a few nanoseconds to more complex constructs involving parallel algorithms, coroutines, and polymorphism.
Some of the highlights include:</p>
<ul dir="auto">
<li><strong>100x cheaper random inputs?!</strong> Discover how input generation sometimes costs more than the algorithm.</li>
<li><strong>1% error in trigonometry at 1/40 cost:</strong> Approximate STL functions like <a href="https://en.cppreference.com/w/cpp/numeric/math/sin" rel="nofollow"><code>std::sin</code></a> in just 3 lines of code.</li>
<li><strong>4x faster lazy-logic</strong> with custom <a href="https://en.cppreference.com/w/cpp/ranges" rel="nofollow"><code>std::ranges</code></a> and iterators!</li>
<li><strong>Compiler optimizations beyond <code>-O3</code>:</strong> Learn about less obvious flags and techniques for another 2x speedup.</li>
<li><strong>Multiplying matrices?</strong> Check how a 3x3x3 GEMM can be 70% slower than 4x4x4, despite 60% fewer ops.</li>
<li><strong>Scaling AI?</strong> Measure the gap between theoretical <a href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit" rel="nofollow">ALU</a> throughput and your <a href="https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms" rel="nofollow">BLAS</a>.</li>
<li><strong>How many if conditions are too many?</strong> Test your CPU&#39;s branch predictor with just 10 lines of code.</li>
<li><strong>Prefer recursion to iteration?</strong> Measure the depth at which your algorithm will <a href="https://en.wikipedia.org/wiki/Segmentation_fault" rel="nofollow"><code>SEGFAULT</code></a>.</li>
<li><strong>Why avoid exceptions?</strong> Take <code>std::error_code</code> or <a href="https://en.cppreference.com/w/cpp/utility/variant" rel="nofollow"><code>std::variant</code></a>-like wrappers?</li>
<li><strong>Scaling to many cores?</strong> Learn how to use <a href="https://en.wikipedia.org/wiki/OpenMP" rel="nofollow">OpenMP</a>, Intel&#39;s oneTBB, or your custom thread pool.</li>
<li><strong>How to handle <a href="https://www.json.org/json-en.html" rel="nofollow">JSON</a> avoiding memory allocations?</strong> Is it easier with C++ 20 or old-school C 99 tools?</li>
<li><strong>How to properly use STL&#39;s associative containers</strong> with custom keys and transparent comparators?</li>
<li><strong>How to beat a hand-written parser</strong> with <a href="https://en.cppreference.com/w/cpp/language/consteval" rel="nofollow"><code>consteval</code></a> RegEx engines?</li>
<li><strong>Is the pointer size really 64 bits</strong> and how to exploit <a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="nofollow">pointer-tagging</a>?</li>
<li><strong>How many packets is <a href="https://www.cloudflare.com/learning/ddos/glossary/user-datagram-protocol-udp/" rel="nofollow">UDP</a> dropping</strong> and how to serve web requests in <a href="https://en.wikipedia.org/wiki/Io_uring" rel="nofollow"><code>io_uring</code></a> from user-space?</li>
<li><strong>Scatter and Gather</strong> for 50% faster vectorized disjoint memory operations.</li>
<li><strong>Intel&#39;s oneAPI vs Nvidia&#39;s CCCL?</strong> What&#39;s so special about <code>&lt;thrust&gt;</code> and <code>&lt;cub&gt;</code>?</li>
<li><strong>CUDA C++, <a href="https://en.wikipedia.org/wiki/Parallel_Thread_Execution" rel="nofollow">PTX</a> Intermediate Representations, and SASS</strong>, and how do they differ from CPU code?</li>
<li><strong>How to choose between intrinsics, inline <code>asm</code>, and separate <code>.S</code> files</strong> for your performance-critical code?</li>
<li><strong>Tensor Cores &amp; Memory</strong> differences on CPUs, and Volta, Ampere, Hopper, and Blackwell GPUs!</li>
<li><strong>How coding FPGA differs from GPU</strong> and what is High-Level Synthesis, Verilog, and VHDL? ðŸ”œ #36</li>
<li><strong>What are Encrypted Enclaves</strong> and what&#39;s the latency of Intel SGX, AMD SEV, and ARM Realm? ðŸ”œ #31</li>
</ul>
<p dir="auto">To read, jump to the <a href="https://github.com/ashvardanian/less_slow.cpp/blob/main/less_slow.cpp"><code>less_slow.cpp</code> source file</a> and read the code snippets and comments.
Follow the instructions below to run the code in your environment and compare it to the comments as you read through the source.</p>

<p dir="auto">The project aims to be compatible with GCC, Clang, and MSVC compilers on Linux, MacOS, and Windows.
That said, to cover the broadest functionality, using GCC on Linux is recommended:</p>
<ul dir="auto">
<li>If you are on Windows, it&#39;s recommended that you set up a Linux environment using <a href="https://docs.microsoft.com/en-us/windows/wsl/install" rel="nofollow">WSL</a>.</li>
<li>If you are on MacOS, consider using the non-native distribution of Clang from <a href="https://brew.sh" rel="nofollow">Homebrew</a> or <a href="https://www.macports.org" rel="nofollow">MacPorts</a>.</li>
<li>If you are on Linux, make sure to install CMake and a recent version of GCC or Clang compilers to support C++20 features.</li>
</ul>
<p dir="auto">If you are familiar with C++ and want to review code and measurements as you read, you can clone the repository and execute the following commands.</p>
<div dir="auto" data-snippet-clipboard-copy-content="git clone https://github.com/ashvardanian/less_slow.cpp.git # Clone the repository
cd less_slow.cpp                                            # Change the directory

pip install cmake --upgrade                                 # PyPI has a newer version of CMake
sudo apt-get install -y build-essential g++                 # Install default build tools
sudo apt-get install -y pkg-config liburing-dev             # Install liburing for kernel-bypass
sudo apt-get install -y libopenblas-base                    # Install numerics libraries

cmake -B build_release -D CMAKE_BUILD_TYPE=Release          # Generate the build files
cmake --build build_release --config Release                # Build the project
build_release/less_slow                                     # Run the benchmarks"><pre>git clone https://github.com/ashvardanian/less_slow.cpp.git <span><span>#</span> Clone the repository</span>
<span>cd</span> less_slow.cpp                                            <span><span>#</span> Change the directory</span>

pip install cmake --upgrade                                 <span><span>#</span> PyPI has a newer version of CMake</span>
sudo apt-get install -y build-essential g++                 <span><span>#</span> Install default build tools</span>
sudo apt-get install -y pkg-config liburing-dev             <span><span>#</span> Install liburing for kernel-bypass</span>
sudo apt-get install -y libopenblas-base                    <span><span>#</span> Install numerics libraries</span>

cmake -B build_release -D CMAKE_BUILD_TYPE=Release          <span><span>#</span> Generate the build files</span>
cmake --build build_release --config Release                <span><span>#</span> Build the project</span>
build_release/less_slow                                     <span><span>#</span> Run the benchmarks</span></pre></div>
<p dir="auto">The build will pull and compile several third-party dependencies from the source:</p>
<ul dir="auto">
<li>Google&#39;s <a href="https://github.com/google/benchmark">Benchmark</a> is used for profiling.</li>
<li>Intel&#39;s <a href="https://github.com/uxlfoundation/oneTBB">oneTBB</a> is used as the Parallel STL backend.</li>
<li>Meta&#39;s <a href="https://github.com/facebookexperimental/libunifex">libunifex</a> is used for senders &amp; executors.</li>
<li>Eric Niebler&#39;s <a href="https://github.com/ericniebler/range-v3">range-v3</a> replaces <code>std::ranges</code>.</li>
<li>Victor Zverovich&#39;s <a href="https://github.com/fmtlib/fmt">fmt</a> replaces <code>std::format</code>.</li>
<li>Ash Vardanian&#39;s <a href="https://github.com/ashvardanian/stringzilla">StringZilla</a> replaces <code>std::string</code>.</li>
<li>Hana DusÃ­kovÃ¡&#39;s <a href="https://github.com/hanickadot/compile-time-regular-expressions">CTRE</a> replaces <code>std::regex</code>.</li>
<li>Niels Lohmann&#39;s <a href="https://github.com/nlohmann/json">json</a> is used for JSON deserialization.</li>
<li>Yaoyuan Guo&#39;s <a href="https://github.com/ibireme/yyjson">yyjson</a> for faster JSON processing.</li>
<li>Google&#39;s <a href="https://github.com/abseil/abseil-cpp">Abseil</a> replaces STL&#39;s associative containers.</li>
<li>Lewis Baker&#39;s <a href="https://github.com/lewissbaker/cppcoro">cppcoro</a> implements C++20 coroutines.</li>
<li>Jens Axboe&#39;s <a href="https://github.com/axboe/liburing">liburing</a> to simplify Linux kernel-bypass.</li>
<li>Chris Kohlhoff&#39;s <a href="https://github.com/chriskohlhoff/asio">ASIO</a> as a <a href="https://en.cppreference.com/w/cpp/experimental/networking" rel="nofollow">networking TS</a> extension.</li>
<li>Nvidia&#39;s <a href="https://github.com/nvidia/cccl">CCCL</a> for GPU-accelerated algorithms.</li>
<li>Nvidia&#39;s <a href="https://github.com/nvidia/cutlass">CUTLASS</a> for GPU-accelerated Linear Algebra.</li>
</ul>
<p dir="auto">To build without Parallel STL, Intel TBB, and CUDA:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cmake -B build_release -D CMAKE_BUILD_TYPE=Release -D USE_INTEL_TBB=OFF -D USE_NVIDIA_CCCL=OFF
cmake --build build_release --config Release"><pre>cmake -B build_release -D CMAKE_BUILD_TYPE=Release -D USE_INTEL_TBB=OFF -D USE_NVIDIA_CCCL=OFF
cmake --build build_release --config Release</pre></div>
<p dir="auto">To control the output or run specific benchmarks, use the following flags:</p>
<div dir="auto" data-snippet-clipboard-copy-content="build_release/less_slow --benchmark_format=json             # Output in JSON format
build_release/less_slow --benchmark_out=results.json        # Save the results to a file instead of `stdout`
build_release/less_slow --benchmark_filter=std_sort         # Run only benchmarks containing `std_sort` in their name"><pre>build_release/less_slow --benchmark_format=json             <span><span>#</span> Output in JSON format</span>
build_release/less_slow --benchmark_out=results.json        <span><span>#</span> Save the results to a file instead of `stdout`</span>
build_release/less_slow --benchmark_filter=std_sort         <span><span>#</span> Run only benchmarks containing `std_sort` in their name</span></pre></div>
<p dir="auto">To enhance stability and reproducibility, disable Simultaneous Multi-Threading <strong>(SMT)</strong> on your CPU and use the <code>--benchmark_enable_random_interleaving=true</code> flag, which shuffles and interleaves benchmarks as described <a href="https://github.com/google/benchmark/blob/main/docs/random_interleaving.md">here</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="build_release/less_slow --benchmark_enable_random_interleaving=true"><pre>build_release/less_slow --benchmark_enable_random_interleaving=true</pre></div>
<p dir="auto">Google Benchmark supports <a href="https://github.com/google/benchmark/blob/main/docs/perf_counters.md">User-Requested Performance Counters</a> through <code>libpmf</code>.
Note that collecting these may require <code>sudo</code> privileges.</p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo build_release/less_slow --benchmark_enable_random_interleaving=true --benchmark_format=json --benchmark_perf_counters=&#34;CYCLES,INSTRUCTIONS&#34;"><pre>sudo build_release/less_slow --benchmark_enable_random_interleaving=true --benchmark_format=json --benchmark_perf_counters=<span><span>&#34;</span>CYCLES,INSTRUCTIONS<span>&#34;</span></span></pre></div>
<p dir="auto">Alternatively, use the Linux <code>perf</code> tool for performance counter collection:</p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo perf stat taskset 0xEFFFEFFFEFFFEFFFEFFFEFFFEFFFEFFF build_release/less_slow --benchmark_enable_random_interleaving=true --benchmark_filter=super_sort"><pre>sudo perf stat taskset 0xEFFFEFFFEFFFEFFFEFFFEFFFEFFFEFFF build_release/less_slow --benchmark_enable_random_interleaving=true --benchmark_filter=super_sort</pre></div>

<p dir="auto">The primary file of this repository is clearly the <code>less_slow.cpp</code> C++ file with CPU-side code.
Several other files for different hardware-specific optimizations are created:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ tree .
.
â”œâ”€â”€ CMakeLists.txt          # Build &amp; assembly instructions for all files
â”œâ”€â”€ less_slow.cpp           # Primary CPU-side benchmarking code with the majority of examples
â”œâ”€â”€ less_slow_amd64.S       # Hand-written Assembly kernels for 64-bit x86 CPUs
â”œâ”€â”€ less_slow_aarch64.S     # Hand-written Assembly kernels for 64-bit Arm CPUs
â”œâ”€â”€ less_slow.cu            # CUDA C++ examples for parallel algorithms for Nvidia GPUs
â”œâ”€â”€ less_slow_sm70.ptx      # Hand-written PTX IR kernels for Nvidia Volta GPUs
â””â”€â”€ less_slow_sm90a.ptx     # Hand-written PTX IR kernels for Nvidia Hopper GPUs"><pre>$ tree <span>.</span>
<span>.</span>
â”œâ”€â”€ CMakeLists.txt          <span><span>#</span> Build &amp; assembly instructions for all files</span>
â”œâ”€â”€ less_slow.cpp           <span><span>#</span> Primary CPU-side benchmarking code with the majority of examples</span>
â”œâ”€â”€ less_slow_amd64.S       <span><span>#</span> Hand-written Assembly kernels for 64-bit x86 CPUs</span>
â”œâ”€â”€ less_slow_aarch64.S     <span><span>#</span> Hand-written Assembly kernels for 64-bit Arm CPUs</span>
â”œâ”€â”€ less_slow.cu            <span><span>#</span> CUDA C++ examples for parallel algorithms for Nvidia GPUs</span>
â”œâ”€â”€ less_slow_sm70.ptx      <span><span>#</span> Hand-written PTX IR kernels for Nvidia Volta GPUs</span>
â””â”€â”€ less_slow_sm90a.ptx     <span><span>#</span> Hand-written PTX IR kernels for Nvidia Hopper GPUs</span></pre></div>

<p dir="auto">Educational content without memes?!
Come on!</p>
<markdown-accessiblity-table></markdown-accessiblity-table>
<div dir="auto"><h2 tabindex="-1" dir="auto">Google Benchmark Functionality</h2><a id="user-content-google-benchmark-functionality" aria-label="Permalink: Google Benchmark Functionality" href="#google-benchmark-functionality"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This benchmark suite uses most of the features provided by Google Benchmark.
If you write a lot of benchmarks and avoid going to the full <a href="https://github.com/google/benchmark/blob/main/docs/user_guide.md">User Guide</a>, here is a condensed list of the most useful features:</p>
<ul dir="auto">
<li><code>-&gt;Args({x, y})</code> - Pass multiple arguments to parameterized benchmarks</li>
<li><code>BENCHMARK()</code> - Register a basic benchmark function</li>
<li><code>BENCHMARK_CAPTURE()</code> - Create variants of benchmarks with different captured values</li>
<li><code>Counter::kAvgThreads</code> - Specify thread-averaged counters</li>
<li><code>DoNotOptimize()</code> - Prevent compiler from optimizing away operations</li>
<li><code>ClobberMemory()</code> - Force memory synchronization</li>
<li><code>-&gt;Complexity(oNLogN)</code> - Specify and validate algorithmic complexity</li>
<li><code>-&gt;SetComplexityN(n)</code> - Set input size for complexity calculations</li>
<li><code>-&gt;ComputeStatistics(&#34;max&#34;, ...)</code> - Calculate custom statistics across runs</li>
<li><code>-&gt;Iterations(n)</code> - Control exact number of iterations</li>
<li><code>-&gt;MinTime(n)</code> - Set minimum benchmark duration</li>
<li><code>-&gt;MinWarmUpTime(n)</code> - To warm up the data caches</li>
<li><code>-&gt;Name(&#34;...&#34;)</code> - Assign custom benchmark names</li>
<li><code>-&gt;Range(start, end)</code> - Profile for a range of input sizes</li>
<li><code>-&gt;RangeMultiplier(n)</code> - Set multiplier between range values</li>
<li><code>-&gt;ReportAggregatesOnly()</code> - Show only aggregated statistics</li>
<li><code>state.counters[&#34;name&#34;]</code> - Create custom performance counters</li>
<li><code>state.PauseTiming()</code>, <code>ResumeTiming()</code> - Control timing measurement</li>
<li><code>state.SetBytesProcessed(n)</code> - Record number of bytes processed</li>
<li><code>state.SkipWithError()</code> - Skip benchmark with error message</li>
<li><code>-&gt;Threads(n)</code> - Run benchmark with specified number of threads</li>
<li><code>-&gt;Unit(kMicrosecond)</code> - Set time unit for reporting</li>
<li><code>-&gt;UseRealTime()</code> - Measure real time instead of CPU time</li>
<li><code>-&gt;UseManualTime()</code> - To feed custom timings for GPU and IO benchmarks</li>
</ul>
</article></div></div>
  </body>
</html>
