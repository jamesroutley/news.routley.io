<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://discourse.llvm.org/t/rfc-lifetime-annotations-for-c/61377">Original</a>
    <h1>Lifetime Annotations for C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
          <p>Martin Brænne <a href="https://discourse.llvm.org/u/martinboehme">@martinboehme</a></p>

<p>We are designing, implementing, and evaluating an attribute-based annotation scheme for C++ that describes object lifetime contracts. It allows relatively cheap, scalable, local static analysis to find many common cases of heap-use-after-free and stack-use-after-return bugs. It allows other static analysis algorithms to be less conservative in their modeling of the C++ object graph and potential mutations done to it. Lifetime annotations also enable better C++/Rust and C++/Swift interoperability.</p>
<p>This annotation scheme is inspired by Rust lifetimes, but it is adapted to C++ so that it can be incrementally rolled out to existing C++ codebases. Furthermore, the annotations can be automatically added to an existing codebase by a tool that infers the annotations based on the current behavior of each function’s implementation.</p>
<p>Clang has existing features for detecting lifetime bugs (<code>[[clang::lifetimebound]]</code> and <code>-Wdangling-gsl</code>). The lifetime annotations we propose are a strict superset of <code>[[clang::lifetimebound]]</code>. They support the majority of use cases of <code>-Wdangling-gsl</code> and many that it cannot express. A <a href="#heading--other-work">dedicated section</a> below contains a detailed comparison with these existing approaches. We plan to enable our lifetime analysis to understand the existing annotations by translating them into our annotation syntax internally (where possible).</p>
<p>We are looking to contribute our current early implementation of lifetime annotations and supporting static analysis to Clang and Clang-Tidy. Developing it upstream would allow us to more easily collaborate on the design and implementation and get feedback from the community and early adopters that build the LLVM/Clang toolchain from git HEAD (for example, Chrome).</p>

<p>We propose the following:</p>
<ul>
<li>
<p>Add a general-purpose type annotation attribute <code>annotate_type</code> to Clang (see <a href="https://discourse.llvm.org/t/rfc-new-attribute-annotate-type-iteration-2/61378">this separate RFC</a> for details).</p>
</li>
<li>
<p>Add an experimental Clang-Tidy check that infers the lifetime contracts based on the current behavior of source code and suggests annotations to add to the source code that describe these contracts. Each user will use this check once to annotate their codebase.</p>
</li>
<li>
<p>Add an experimental Clang-Tidy check that validates that the code follows the lifetime contracts described by the annotations.</p>
</li>
<li>
<p>Develop lifetime annotations for libc and libc++, stored in <a href="https://clang.llvm.org/docs/APINotes.html" rel="noopener nofollow ugc">API notes</a> files. Upstream code from the apple/swift-clang fork of Clang for <a href="https://github.com/apple/swift-clang/blob/stable/lib/Sema/SemaAPINotes.cpp" rel="noopener nofollow ugc">ingesting API notes in Sema</a>.</p>
</li>
<li>
<p>Extend Clang’s API notes to not require Clang Modules.</p>
</li>
<li>
<p>Evaluate the annotations and Clang-Tidy checks with early adopters. Fine-tune the system based on the feedback.</p>
</li>
<li>
<p>Make a decision about stabilizing the Clang-Tidy checks and marking them non-experimental. If and when this happens, we could consider introducing attributes that are specific to our annotation scheme instead of using general-purpose annotation attributes.</p>
</li>
<li>
<p>Move libc++ annotations from API notes files into headers.</p>
</li>
</ul>

<p>We have implemented a work-in-progress Clang-Tidy check that infers the lifetime contracts from un-annotated C++ code. It is already able to infer lifetimes in a wide range of non-trivial situations (see <a href="#heading--appendix-b">appendix B</a> for examples). This gives us enough confidence in the annotation scheme to present it publicly and propose moving experimentation upstream.</p>
<p>We have not started working on the verification tool yet, but we believe it is a lot less risky than inference. Verification can reuse most of the complex static analysis algorithms required for inference; this also implies that inference will generate lifetimes that satisfy the verification tool. The two main additions that are required for verification are being able to distinguish different local lifetimes and producing good error messages when lifetime contracts are violated. Implementing this additional functionality will require some effort but not much innovation. We prioritize figuring out the type checking and inference rules and are therefore focusing on inference tooling first.</p>

<p>Because the annotation scheme will be experimental for a while, we are not proposing to add any attributes to Clang that are specific to lifetimes. The only change to core Clang that we are proposing is adding a general-purpose type annotation attribute. Apart from this, the implementation will be contained in new Clang-Tidy checks, making it well isolated from the rest of the codebase.</p>
<p>In case our experimentation fails, the Clang-Tidy checks can be easily removed from Clang without breaking users’ builds. The general-purpose <code>annotate_type</code> attribute will remain in Clang as we expect it to be useful for other purposes.</p>

<p>Lifetime annotations describe the lifetime contracts of C++ APIs in a modular, machine-readable manner, with enough flexibility to cover many modern C++ architectural and local coding patterns. Having such descriptions available in C++ source code enables the following use cases:</p>
<ul>
<li>
<p><strong>Improved readability for humans.</strong> Users can easily find the lifetime contracts in the function signature, and trust this information to be correct. Typical current practice is to use prose in documentation comments to describe lifetime contracts, but code authors don’t do this consistently or reliably: The information is often missing, and when it is present, it is sometimes incorrect.</p>
</li>
<li>
<p><strong>Improved static analysis capabilities: understanding of the object graph and mutations.</strong> Static analysis tooling today often suffers from an inability to precisely reason about mutations in a modular way. Scalable, local static analysis that needs soundness has to conservatively assume that all pointers passed to a function call will escape, and that subsequent function calls will mutate objects reachable from those pointers. Lifetime annotations allow static analysis tools to derive a more precise approximation of possible object graph state and mutations. See <a href="#heading--appendix-c">appendix C</a> for an example.</p>
<p>Concretely, lifetime annotations improve modeling of function call side effects in the <a href="https://discourse.llvm.org/t/rfc-a-dataflow-analysis-framework-for-clang-ast/59085">Clang dataflow analysis framework</a>.</p>
</li>
<li>
<p><strong>Better C++/Rust interoperability.</strong> Lifetime annotations open an avenue for more complete, more automatic, more ergonomic, and safer C++/Rust interoperability than is currently provided by state-of-the-art Rust crates such as <a href="https://cxx.rs/" rel="noopener nofollow ugc">cxx</a> and <a href="https://crates.io/crates/autocxx" rel="noopener nofollow ugc">autocxx</a>. Existing interop solutions can only bridge C++ APIs that accept and return objects either by value or inside owning smart pointers. Lifetime annotations allow us to automatically bridge C++ functions with complex lifetime contracts. Lifetime contracts from C++ function signatures can be mapped to Rust lifetimes, enabling us to map C++ pointers and references to safe references in Rust. See <a href="#heading--appendix-d">appendix D</a> for a concrete example.</p>
</li>
<li>
<p><strong>Better C++/Swift interoperability.</strong> Lifetime annotations can help provide safer C++/Swift interoperability. Swift does not expose lifetime annotations in the language, but internally in the compiler the mechanisms and principles are rather similar to what Rust exposes at the language level. The Swift compiler starts tracking object lifetimes after converting Swift AST to the Swift intermediate language (SIL). When Swift code calls a C++ foreign function or uses an instance of a C++ struct/class, the Swift compiler can get the corresponding lifetime contract from the C++ header and validate that the input and output objects live long enough.</p>
</li>
</ul>

<p>The static analysis based on the proposed lifetime annotations cannot catch all memory safety problems in C++ code. Specifically, it cannot catch all temporal memory safety bugs (for example, ones caused by iterator invalidation), and of course lifetime annotations don’t help with spatial memory safety (for example, indexing C-style arrays out of bounds). See the comparison with Rust below for a detailed discussion.</p>

<blockquote>
<p><strong>Note</strong></p>
</blockquote>
<p>The lifetime annotation scheme we propose is inspired by and similar to <a href="https://doc.rust-lang.org/nomicon/lifetimes.html" rel="noopener nofollow ugc">lifetimes in Rust</a>. Rust is an industrial-strength language with complete and consistent support for static lifetime checking. It embodies a wealth of experience on how to make lifetime checking work on large real-world codebases, and we think this is a good reason to borrow these tried-and-true concepts for C++. We will, however, present the annotation scheme in a way that should make it understandable to readers without any knowledge of Rust.</p>
<p>Defining the annotation scheme completely would take many pages, and we don’t feel it would be productive to go into this level of detail in this high-level RFC. Instead, we will present a few representative examples with explanations that provide enough detail to give a feel for how the annotation scheme works. We’re happy to provide more details if needed.</p>
<h2>
<a name="example-8" href="#example-8"></a>Example</h2>
<p>Here is a simple example:</p>
<pre><code>const std::string&amp; [[clang::annotate_type(&#34;lifetime&#34;, &#34;a&#34;)]] smaller(
    const std::string&amp; [[clang::annotate_type(&#34;lifetime&#34;, &#34;a&#34;)]] s1,
    const std::string&amp; [[clang::annotate_type(&#34;lifetime&#34;, &#34;a&#34;)]] s2) {
  if (s1 &lt; s2) {
    return s1;
  } else {
    return s2;
  }
}
</code></pre>
<p>This function takes two references to strings and returns a reference to the lexicographically smaller of the two strings. Because the return value might refer to either of the two input strings, its lifetime is tied to the two inputs. This is expressed by the annotation <code>[[clang::annotate_type(&#34;lifetime&#34;, &#34;a&#34;)]]</code>.</p>
<p>The <code>annotate_type</code> attribute has no effect on the formal C++ type system or runtime semantics; the lifetime inference and verification tooling use it to establish a “shadow” type system. For more details, see the <a href="https://discourse.llvm.org/t/rfc-new-attribute-annotate-type-iteration-2/61378">RFC for <code>annotate_type</code></a>.</p>
<p>The annotation in its “raw” form is verbose and obscures the rest of the function signature. In practice, it is preferable to define a macro that expands to the attribute. In the rest of this proposal, we will assume that a macro <code>$a</code> has been defined to expand to <code>[[clang::annotate_type(&#34;lifetime&#34;, &#34;a&#34;)]]</code>, and similarly <code>$b</code>, <code>$c</code>, and so on. (Most major compilers, including Clang, GCC, and MSVC, allow <code>$</code> as an implementation-defined character in identifiers.) With this, the function signature looks as follows:</p>
<pre><code>const std::string&amp; $a smaller(const std::string&amp; $a s1, const std::string&amp; $a s2) {
   ...
}
</code></pre>
<p>We think this style of macros makes the lifetimes visually distinctive as well as brief, so we will use it throughout this proposal. However, the macros are not part of our proposal; every codebase can define its own macro shortcuts that work within the context of that codebase.</p>
<p>The names of lifetimes have no connection to any other identifiers in the program. A lifetime may happen to have the same name as another entity in the program, but this does not affect its meaning. Lifetimes in function signatures are implicitly scoped to the function in which they appear; we will elaborate on scoping rules in detailed design docs.</p>
<p>Tooling can use the annotations to detect lifetime bugs, for example:</p>
<pre><code>void f() {
  std::string foo = &#34;foo&#34;;
  const std::string&amp; first = smaller(foo, &#34;bar&#34;);
  std::cout &lt;&lt; first &lt;&lt; “\n”;
}
</code></pre>
<p>The second argument to <code>smaller</code> is a temporary <code>std::string</code> object, whose lifetime lasts only until the end of the statement. The lifetime annotations tell us that the reference <code>first</code> may be bound to this temporary, and that therefore accessing this reference in the following line is UB.</p>
<p>Note: Both parameters of <code>smaller</code> are annotated with the same lifetime <code>$a</code>, but this does not mean that the objects passed in as arguments need to have exactly the same lifetime. Indeed, this is not the case in the example call <code>smaller(foo, &#34;bar&#34;)</code> above.</p>
<p>Informally, the annotation means that the return value can have the lifetime of either of the two arguments.</p>
<p>Formally, we can think of the lifetime <code>$a</code> as being a generic parameter of the function <code>smaller()</code>. A concrete lifetime is substituted for this parameter at every callsite of <code>smaller()</code>. A reference with a given lifetime may be implicitly converted to a reference of shorter lifetime. For the example call <code>smaller(foo, &#34;bar&#34;)</code> above, we therefore choose <code>$a</code> to be the shorter of the two argument lifetimes; this is the lifetime of the second argument, the implicitly constructed temporary. The string <code>foo</code> has a longer lifetime than this temporary, so it can be implicitly converted to a reference with lifetime <code>$a</code>. We therefore conclude that the lifetime of the reference returned by <code>smaller()</code> is equal to the lifetime of the temporary.</p>
<h2>
<a name="lifetime-of-this-9" href="#lifetime-of-this-9"></a>Lifetime of <code>this</code>
</h2>
<p>The annotation for the lifetime of a <code>this</code> pointer is placed at the end of the member function declaration, for example:</p>
<pre><code>struct StringPair {
  std::string first, second;
  const std::string&amp; $a smaller() const $a {
    if (first &lt; second) {
      return first;
    } else {
      return second;
    }
  }
};
</code></pre>
<p>This expresses that the lifetime of the reference returned by <code>StringPair::smaller()</code> is tied to the lifetime of the <code>StringPair</code> object on which the member function is called. Note that the <code>$a</code> signifying the lifetime of the <code>this</code> pointer comes in a natural position directly after the <code>const</code> signifying the constness of the <code>this</code> pointer. The syntax remains consistent if we added a ref-qualifier, e.g., <code>const std::string&amp; $a smaller() const &amp; $a</code>.</p>
<h2>
<a name="lifetimes-in-template-arguments-10" href="#lifetimes-in-template-arguments-10"></a>Lifetimes in template arguments</h2>
<p>Lifetimes may be added to template arguments, e.g.</p>
<pre><code>int* $a get_first(const std::vector&lt;int* $a&gt;&amp; $b v) {
  return v.at(0);
}
</code></pre>
<p>This expresses that the lifetime <code>$a</code> of the return value is tied to the lifetime of the pointers contained in the vector, and that this lifetime is independent of the lifetime <code>$b</code> of the vector itself.</p>
<h2>
<a name="lifetime-parameterized-types-11" href="#lifetime-parameterized-types-11"></a>Lifetime-parameterized types</h2>
<p>Some types are reference-like in the sense that they refer to data whose lifetime is independent of their own lifetime. An example of this from the standard library is <code>string_view</code>: It refers to string data whose lifetime is independent of the lifetime of the <code>string_view</code> itself.</p>
<p>This is expressed by adding a <em>lifetime parameter</em> to the type that represents the lifetime of the data referred to by the type. Here is an excerpt of what this would look like for a <code>string_view</code>-like type:</p>
<pre><code>class LIFETIME_PARAM(s) simple_string_view {
  char* $s data_ptr;
  size_t data_size;
public:
  const char* $s data() const $a {
    return data_ptr;
  }
// …
};
</code></pre>
<p><code>LIFETIME_PARAM(s)</code> is a macro that expands to the attribute <code>[[clang::annotate(“lifetime_param”, “s”)]]</code>. Again, the particular name of the macro is not part of this proposal.</p>
<p>The lifetime parameter <code>$s</code> is used in the definition of the member variable <code>data_ptr</code> to express that the lifetime of the string data is <code>$s</code>, a lifetime that is independent of the lifetime of the <code>simple_string_view</code> itself.</p>
<p>Similarly, <code>$s</code> is used in the <code>data()</code> member function to express that the lifetime of the return value is equal to the lifetime of the string data pointed to by <code>data_ptr</code>, not the lifetime <code>$a</code> of the <code>simple_string_view</code> itself.</p>
<p>When lifetime-parameterized types are used elsewhere in the code, they should be annotated with a lifetime in the same way that pointers and references are. For example, here is a <code>simple_string_view</code> version of the function <code>smaller()</code> that we showed earlier:</p>
<pre><code>simple_string_view $a smaller(simple_string_view $a s1, simple_string_view $a s2) {
  if (s1 &lt; s2) {
    return s1;
  } else {
    return s2;
  }
}
</code></pre>
<p><a href="#heading--appendix-a">Appendix A</a> shows an annotated version of the most important parts of the actual standard <code>string_view</code> type.</p>
<p>Formally, lifetimes are generic type parameters, identified by their index, and type-erased at code generation time.</p>
<h2>
<a name="lifetime-elision-12" href="#lifetime-elision-12"></a>Lifetime elision</h2>
<p>As in Rust, to avoid unnecessary annotation clutter, we allow lifetime annotations to be elided (omitted) from a function signature when they conform to certain regular patterns. Lifetime elision is merely a shorthand for these regular lifetime patterns. Elided lifetimes are treated exactly as if they had been spelled out explicitly; in particular, they are subject to lifetime verification, so they are just as safe as explicitly annotated lifetimes.</p>
<p>We propose to use the same rules as in Rust, as these transfer naturally to C++. We call lifetimes on parameters <em>input lifetimes</em> and lifetimes on return values <em>output lifetimes</em>. (Note that all lifetimes on parameters are called input lifetimes, even if those parameters are output parameters.) Here are the rules:</p>
<ol>
<li>Each input lifetime that is elided (i.e., not stated explicitly) becomes a distinct lifetime.</li>
<li>If there is exactly one input lifetime (whether stated explicitly or elided), that lifetime is assigned to all elided output lifetimes.</li>
<li>If there are multiple input lifetimes but one of them applies to the implicit <code>this</code> parameter, that lifetime is assigned to all elided output lifetimes.</li>
</ol>
<p>In practice, lifetime elision allows explicit annotations to be omitted in many cases. For example, the lifetimes of the <code>StringPair::smaller()</code> example we showed earlier are implied by the elision rules and could therefore be omitted: <code>const std::string&amp; $a smaller() const $a</code>.</p>
<p>Introducing lifetimes to a codebase will have to happen incrementally. During this process, missing lifetimes need to be interpreted differently in different files:</p>
<ul>
<li>In files on which we have already run the lifetime inference tooling, the elision rules should be applied to types that require lifetimes but do not have lifetime annotations (these are pointers, references, and lifetime-parameterized types).</li>
<li>In files on which we have not yet run the inference tooling, none of the functions have lifetime annotations, and the elision rules should not be applied because the lifetimes they imply are generally not correct.</li>
</ul>
<p>We therefore propose using a pragma <code>#pragma clang lifetime_elision</code> to mark source files where lifetime elision should be applied. Note that support for this pragma can be implemented entirely within the Clang-Tidy check using the <code>clang::PragmaHandler</code> API; no changes to Clang itself are needed.</p>
<h2>
<a name="alternative-annotation-syntax-using-only-clangannotate-13" href="#alternative-annotation-syntax-using-only-clangannotate-13"></a>Alternative annotation syntax using only <code>[[clang::annotate]]</code>
</h2>
<p>If our proposal to add a general-purpose type annotation attribute <code>annotate_type</code> to Clang does not meet with approval, we can instead use the existing <code>[[clang::annotate]]</code> attribute, though at the cost of readability. For example:</p>
<pre><code>class [[clang::annotate(&#34;lifetime_params”, “s&#34;)]] simple_string_view {
  [[clang::annotate(&#34;member_lifetimes”, “s&#34;)]]
  const char* data_ptr;
};

[[clang::annotate(&#34;function_lifetimes”, “a, a -&gt; a&#34;)]]
const std::string&amp; smaller(const std::string&amp; s1, const std::string&amp; s2);

template&lt;typename T, typename U&gt;
[[clang::annotate(&#34;function_lifetimes”, “(a, b) -&gt; a&#34;)]]
int* get_first(const std::vector&lt;int*&gt;&amp; v);
</code></pre>
<p>Since <code>[[clang::annotate]]</code> is a declaration attribute, it can’t appear inline within a type, and must be attached to the declaration. This attribute placement detaches the lifetime information from the type, and we think that it is less readable. Certain cases of lifetime elision, where only some of the lifetimes in a function are elided, would also not be possible with this notation.</p>

<h2>
<a name="no-subtyping-constraints-between-lifetimes-15" href="#no-subtyping-constraints-between-lifetimes-15"></a>No subtyping constraints between lifetimes</h2>
<p>We do not have an equivalent of Rust’s <code>where</code> clauses, which establish “outlives” constraints between lifetimes. Consider this example:</p>
<pre><code>void push_first(std::vector&lt;int*&gt;&amp; a, std::vector&lt;int*&gt;&amp; b) {
  a.push_back(b[0]);
}
</code></pre>
<p>We should be able to call <code>push_first</code> if the lifetime of the pointers in <code>b</code> is at least as long as the lifetime of the pointers in <code>a</code>, but there is no way to express this constraint with the current annotations.</p>
<p>This limitation could be solved by introducing a <code>LIFETIME_CONSTRAINTS</code> annotation:</p>
<pre><code>LIFETIME_CONSTRAINTS(a &lt;= b)
void push_first(std::vector&lt;int* $a&gt;&amp; a, std::vector&lt;int* $b&gt;&amp; b) {
  a.push_back(b[0]);
}
</code></pre>
<h2>
<a name="no-equality-constraints-between-lifetime-parameters-16" href="#no-equality-constraints-between-lifetime-parameters-16"></a>No equality constraints between lifetime parameters</h2>
<p>If a class has multiple lifetime parameters, those lifetimes are always assumed to be independent of each other; individual member functions cannot impose constraints on them. This creates a limitation in expressivity. For example, we cannot annotate <code>Pair::Method()</code> in the following example with lifetimes since it may only be called when <code>$a == $b</code>:</p>
<pre><code>struct LIFETIME_PARAM(a, b) Pair {
  int* $a first;
  int* $b second;

  void Method() {
    TakeSpecialPair(this);
  }
};

void TakeSpecialPair(Pair $a $a * p);
</code></pre>
<p>Rust solves this issue by allowing users to write multiple <code>impl</code> blocks for a struct, where each carries its own generic signature for <code>self</code>.</p>
<p>Again, we could solve this issue in C++ by adding per-method equality constraints:</p>
<pre><code>struct LIFETIME_PARAM(a, b) Pair {
  int* $a first;
  int* $b second;

  LIFETIME_CONSTRAINTS(a == b)
  void Method() {
    TakeSpecialPair(this);
  }
};
</code></pre>
<p>C++23’s explicit object parameter syntax ((P0847R7)[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html" rel="noopener nofollow ugc">Deducing this</a>]) will allow this constraint to be expressed directly:</p>
<pre><code>struct LIFETIME_PARAM(a, b) Pair {
  int* $a first;
  int* $b second;

  void Method(this Pair $c $c &amp;self) {
    TakeSpecialPair(self);
  }
};
</code></pre>
<h2 id="heading--limitation-pre-post-condition">Cannot define different constraints for function entry and exit</h2><p>
Our annotation scheme cannot express different lifetime constraints at function entry and exit, i.e., it cannot express separate pre- and post-conditions. Note that Rust has the same limitation.
</p><p>The use cases for different lifetime constraints at function entry and exit are probably rare, but they do exist. As an example, consider <code>string_view::swap</code>. It exchanges the data pointers of the two <code>string_view</code> objects and hence also their lifetimes, but our annotation scheme cannot express this. Instead, we must more conservatively demand that the lifetimes of the two <code>string_view</code>s are the same:</p>
<pre><code>class LIFETIME_PARAM(s) string_view {
  size_t __size;
  const char* $s __data;

public:
  void swap(string_view $s &amp; __other);
};
</code></pre>
<p>A similar limitation applies to <code>std::swap</code>.</p>
<p>However, this overly conservative annotation does not appear to be an issue for most practical applications. For example, when using <code>string_view::swap</code> to implement a sorting algorithm, the lifetimes of the <code>string_view</code>s being sorted will anyhow be the same. The fact that Rust’s lifetime annotations have the same limitation is further evidence that it does not appear to be a problem in practice.</p>
<p>Lifting this limitation is possible, but it would require more complexity in the annotation scheme and likely also significant additional complexity in the lifetime inference and verification algorithms. We should only commit to this additional complexity if we discover an important use case that requires it.</p>

<h2>
<a name="clanglifetimebound-17" href="#clanglifetimebound-17"></a>[[clang::lifetimebound]]</h2>
<p>Clang implements an attribute <code>[[clang::lifetimebound]]</code> (<a href="https://clang.llvm.org/docs/AttributeReference.html#lifetimebound" rel="noopener nofollow ugc">Attributes in Clang — Clang 15.0.0git documentation</a>) that can express a strict subset of the lifetime annotations that we are proposing. Specifically, <code>[[clang::lifetimebound]]</code> only supports connecting the top-level lifetime of a function argument object to all lifetimes of the return value. It does not support, for example, expressing a relationship between two lifetimes of arguments, or talking about a lifetime that is not at the top level of the type (for example, nested in a template argument):</p>
<pre><code>void push_back_if_not_null(std::vector&lt;int* $a&gt; xs, int* $a x) {
  if (x != nullptr) {
    xs.push_back(x);
  }
}
</code></pre>
<p>The function <code>push_back_if_not_null</code> can be annotated with our proposed lifetime annotations as shown, but cannot be annotated with <code>[[clang::lifetimebound]]</code>.</p>
<p>Our lifetime analysis will desugar <code>[[clang::lifetimebound]]</code> into the lifetime representation that it uses.</p>
<h2>
<a name="lifetime-safety-preventing-common-dangling-wg21-proposal-p1179-wdangling-gsl-18" href="#lifetime-safety-preventing-common-dangling-wg21-proposal-p1179-wdangling-gsl-18"></a>Lifetime safety: preventing common dangling (WG21 proposal P1179, -Wdangling-gsl)</h2>
<p><a href="https://wg21.link/p1179" rel="noopener nofollow ugc">P1179</a> describes an analysis that has preliminary implementations in MSVC and a <a href="https://github.com/mgehre/llvm-project" rel="noopener nofollow ugc">fork</a> of Clang. This analysis also inspired some statement-local warnings that are implemented in MSVC and the Clang trunk (<code>-Wdangling-gsl</code>, on by default); see tests <a href="https://github.com/llvm/llvm-project/blob/main/clang/test/Sema/warn-lifetime-analysis-nocfg.cpp" rel="noopener nofollow ugc">here</a>. The statement-local warnings have found many bugs in many real-world codebases.</p>
<p>The analysis described in P1179 is a flow-sensitive points-to analysis. It had the explicit goal to only warn when dangling pointers are actually dereferenced (not when they are created). It aims to prevent many kinds of errors, including:</p>
<ul>
<li>Use after free</li>
<li>Use of a moved-from object</li>
<li>Dereferencing an invalid iterator</li>
<li>Null dereference</li>
</ul>
<p>The analysis uses contract-style annotations to describe lifetime preconditions and postconditions. The separate pre- and postconditions help circumvent the limitations described above in the section <a href="#heading--limitation-pre-post-condition">“Cannot define different constraints for function entry and exit”</a>.</p>
<h3>
<a name="implementations-19" href="#implementations-19"></a>Implementations</h3>
<ul>
<li>The Clang implementation (in the fork) lacks full support for field-sensitivity.</li>
<li>The Clang implementation will not attempt to find use-after-move errors.</li>
<li>The MSVC implementation does not support annotations.</li>
<li>None of the implementations support the <code>SharedOwner</code> concept that was introduced in the R1 version of the paper.</li>
<li>Both implementations do fixed-point iteration (as opposed to doing the acyclic CFG approach suggested by the paper).</li>
<li>According to the benchmarks, the Clang implementation imposes ~5% impact on full compilation including codegen (closer to 10% without codegen).</li>
<li>Currently, none of the implementations are actively developed, as contracts were not voted into the standard.</li>
</ul>
<p>The readme of the Clang fork has direct links to the tests that can give a picture of the current state.</p>
<h3>
<a name="comparison-to-rust-style-lifetimes-20" href="#comparison-to-rust-style-lifetimes-20"></a>Comparison to Rust-style lifetimes</h3>
<p>Here is a comparison between the properties of the Rust-style lifetime annotations proposed here and the P1179-style lifetime annotations:</p>
<ul>
<li>
<strong>Annotation syntax and semantics</strong>
<ul>
<li>This proposal: Introduces lifetime parameters via type annotations. Users need to learn a new concept, but the annotations are concise, spelled within the relevant type, and syntactically close to the function parameter names.</li>
<li>P1179: Describes points-to relationships via contracts, often in terms of abstract locations (e.g., the syntax <code>o&#39;</code> refers to the memory owned by an owner <code>o</code>). Developers are familiar with points-to relationships, but the contracts-style annotations can be overly verbose and syntactically far from the parameters. Certain ambiguities require additional annotations, e.g., a non-const reference parameter can be either out or in-out, which has implications on its assumed “moved-from”-ness.</li>
</ul>
</li>
<li>
<strong>New concepts</strong>
<ul>
<li>This proposal: Introduces a relatively low number of new concepts.</li>
<li>P1179: Reuses concepts developers are already familiar with, such as “Owner” or “Pointer”.</li>
</ul>
</li>
<li>
<strong>Scope</strong>
<ul>
<li>This proposal: Iterator invalidation, use-after-move, null dereference are not in scope.</li>
<li>P1179: Can catch problems related to iterator invalidation but might need additional annotations to avoid certain false positives. Certain patterns (e.g. <code>std::vector::reserve</code>) cannot be supported in the model.</li>
</ul>
</li>
<li>
<strong>Limitations</strong>
<ul>
<li>This proposal: Certain patterns (like conditional lifetimes) cannot be represented.</li>
<li>P1179: Certain concepts (like conditional points-to relationships) cannot be represented. Moreover, the dataflow analysis cannot handle arbitrary code patterns and can be confused even when the underlying pattern is supported.</li>
</ul>
</li>
<li>
<strong>Treatment of dangling pointers</strong>
<ul>
<li>This proposal: Warns when a dangling pointer is created.</li>
<li>P1179: Warns when a dangling pointer is dereferenced.</li>
</ul>
</li>
<li>
<strong>Rules for default lifetimes</strong>
<ul>
<li>This proposal: Simple, easy-to understand default lifetimes and lifetime elision rules.</li>
<li>P1179: More sophisticated, harder to understand, rules to infer default annotations from signatures that cover the most common cases.</li>
</ul>
</li>
<li>
<strong>Mutations</strong>
<ul>
<li>This proposal: Cannot represent certain mutations (e.g., <code>std::swap(ptr1, ptr2)</code> requires <code>ptr1</code> and <code>ptr2</code> to have the same lifetimes).</li>
<li>P1179: Has no problems with mutations in general.</li>
</ul>
</li>
<li>
<strong>Support for user-defined classes</strong>
<ul>
<li>This proposal: Supports arbitrary user-defined classes as long as they don’t do anything forbidden (e.g., conditional lifetimes).</li>
<li>P1179: Certain user-defined constructs are not supported (e.g., a pointer-like type with multiple pointees at the same time).</li>
</ul>
</li>
</ul>
<h3>
<a name="examples-21" href="#examples-21"></a>Examples</h3>
<p>Here are some code examples annotated in both styles.</p>
<p><strong>Function that returns a pointer parameter</strong></p>
<pre><code>// This proposal
int* $a f(int* $a i);

// P1179
int* f(int* i)
  [[post: lifetime(Return, i)]];
</code></pre>
<p><strong>Struct containing a pointer</strong></p>
<pre><code>// This proposal
struct LIFETIME_PARAM(s) S {
  int* $s m;
};

void f(int* $a i, S $a * out) {
  out-&gt;m = i;
}

// P1179
struct S { int* m; };

void f(int* i, S* out)
  [[post: lifetime(out-&gt;m, i)]]
{
  out-&gt;m = i;
}
</code></pre>
<p><strong>Lifetimes of pointers in template arguments</strong></p>
<pre><code>// This proposal
void push_back_if_not_null(std::vector&lt;int* $a&gt;&amp; xs, int* $a x) {
  if (x != nullptr) {
    xs.push_back(x);
  }
}

// Not actually supported by P1179, but the Clang implementation had experiments in
// this direction.
void push_back_if_not_null(std::vector&lt;int*&gt;&amp; xs, int* x)
  [[pre: lifetime(deref(xs), x)]]
  [[post: lifetime(deref(xs), x)]]
{
  if (x != nullptr) {
    xs.push_back(x);
  }
}
</code></pre>
<p>The <code>deref</code> notation in the P1179 example above was originally developed for smart pointer types, hence the “dereference” nomenclature. It would require additional annotation (not shown above) of <code>std::vector&lt;int*&gt;</code> member functions that take or return an <code>int*</code>.</p>
<p><strong>Template with multiple pointer arguments</strong></p>
<pre><code>// This proposal
void insert_if_not_null(map&lt;int* $a, int* $b&gt;&amp; m, int* $a key, int* $b value) {
  if (key != nullptr &amp;&amp; value != nullptr) {
    m[key] = value;
  }
}

// This is not supported in P1179, as confirmed with Herb Sutter, but he is willing
// to look into making this work (and include something officially for the case above).
</code></pre>
<h2>
<a name="lifetimes-and-the-borrow-checker-in-rust-22" href="#lifetimes-and-the-borrow-checker-in-rust-22"></a>Lifetimes and the borrow checker in Rust</h2>
<p>Rust code that passes type checking and does not use <code>unsafe</code> is guaranteed to be memory safe. Our proposed lifetime annotations are heavily inspired by Rust, but they don’t catch all memory safety problems in C++ code. Specifically:</p>
<ul>
<li>
<p><strong>Lifetimes don’t help with statically proving spatial memory safety</strong> (that all reads/writes are in bounds). This is expected, since lifetime annotations and the borrow checker in Rust don’t help with spatial memory safety either. Instead Rust relies on runtime bounds checking and API design that makes accesses in-bounds by construction (for example, range-based for loops).</p>
</li>
<li>
<p><strong>The proposed static analysis for C++ is not a borrow checker.</strong> It does not enforce <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#the-rules-of-references" rel="noopener nofollow ugc">Rust’s borrowing rule</a>: “At any given time, you can have either one mutable reference or any number of immutable references.”</p>
</li>
</ul>
<p>Enforcing the borrowing rule is a critical component of Rust’s memory safety guarantee. For example, memory safety bugs caused by iterator invalidation are not caught by lifetime annotations alone.</p>
<p>For example, the following code passes lifetime verification, but it contains a possible use-after-free (it might or might not happen at runtime depending on the implementation details of <code>std::vector</code>):</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; xs = { 10, 20, 30 };
  auto it = xs.cbegin();
  xs.push_back(40);
  std::cout &lt;&lt; *it; // possible use-after-free: dereferencing an iterator that was invalidated
}
</code></pre>
<p>The Rust compiler would reject the equivalent Rust code because <code>xs.push_back()</code> needs to borrow <code>xs</code> mutably within the live region of the variable <code>it</code>, which borrows <code>xs</code> immutably.</p>
<p>Unfortunately, C++ iterators seem to be incompatible with Rust’s borrowing rule, since the vast majority of algorithms operate on pairs of non-const iterators borrowed from the same container.</p>
<p>To summarize, enforcing the borrowing rule in C++ is unfortunately not so simple because there is a lot of existing code that creates multiple non-const pointers or references to the same object, intentionally violating the borrowing rule. At this point we don’t have a plan of how we could incrementally roll out the borrowing rule to existing C++ code, but it is a very interesting direction for future work.</p>
<p>
As an example of real-world code with our proposed lifetime annotations, here is an annotated version of representative parts of `std::string_view`.
</p><pre><code>namespace std {

template&lt;class _CharT, class _Traits = char_traits&lt;_CharT&gt; &gt;
    class basic_string_view;

typedef basic_string_view&lt;char&gt;     string_view;

template&lt;class _CharT, class _Traits&gt;
class LIFETIME_PARAM(s) basic_string_view {
public:
    // types
    LIFETIME_PARAM(d)  typedef _CharT* $d                pointer;
    LIFETIME_PARAM(d)  typedef const _CharT* $d          const_pointer;
    LIFETIME_PARAM(d)  typedef _CharT&amp; $d                reference;
    LIFETIME_PARAM(d)  typedef const _CharT&amp; $d          const_reference;
    LIFETIME_PARAM(d)  typedef const_pointer $d          const_iterator;
    LIFETIME_PARAM(d)  typedef const_iterator $d         iterator;
    LIFETIME_PARAM(d)  typedef std::reverse_iterator&lt;const_iterator $d&gt;   const_reverse_iterator;

    typedef _Traits                                      traits_type;
    typedef _CharT                                       value_type;
    typedef size_t                                       size_type;
    typedef ptrdiff_t                                    difference_type;
    static _LIBCPP_CONSTEXPR const size_type npos = -1; // size_type(-1);

    basic_string_view();
    basic_string_view(const basic_string_view $s &amp; __s);
    basic_string_view $s &amp; operator=(const basic_string_view $s &amp;);
    basic_string_view(const _CharT* $s __s, size_type __len);
    basic_string_view(const _CharT* $s __s);


    const_iterator $s begin() const;
    const_iterator $s end() const;
    const_pointer $s data() const;


    const_reference $s operator[](size_type __pos) const;
    basic_string_view $s substr(size_type __pos = 0, size_type __n = npos) const;

    void remove_prefix(size_type __n);
    void remove_suffix(size_type __n);

    void swap(basic_string_view $s &amp;__other);

    // copy() and find() don&#39;t allow their arguments to escape, therefore their lifetimes
    // are independent of $s.
    // According to lifetime elision rules, they don&#39;t need an explicit annotation.
    size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
    size_type find(const _CharT* $t __s, size_type __pos, size_type __n) const;

private:
    const   value_type* $s __data;
    size_type              __size;
};

} // namespace std
</code></pre>
<p>
This appendix contains a selection of functions that illustrate the range of C++ language constructs on which our current experimental implementation can automatically infer lifetimes.
</p><p>The input to the lifetime inference algorithm is the unannotated source code. All lifetime annotations below were automatically inferred from the function implementations.</p>
<p><strong>A simple example to get started</strong></p>
<pre><code>int* $a get_lesser_of(int* $a a, int* $a b) {
  return *a &lt; *b? a : b;
}
</code></pre>
<p><strong>Lifetime inference is flow-sensitive</strong></p>
<pre><code>int* $p target(int* $p p, int* a, int* $p b) {
  // Note: `int* a` is not annotated. The lifetime elision rules imply that it has a
  // unique lifetime different from `$p`.
  for (int i = 0; i &lt; *a; i++) {
    p = a;
    p = b;
  }
  return p;
}
</code></pre>
<p><strong>Lifetime inference for class template arguments</strong></p>
<pre><code>template &lt;typename A&gt;
struct S { A array; };

void target(S&lt;int* $a *&gt;* s, int* $a p, int* $a q) {
  s-&gt;array[0] = p;
  s-&gt;array[1] = q;
}
</code></pre>
<p><strong>Lifetime inference for variadic class template arguments</strong></p>
<pre><code>template &lt;int idx, typename... Args&gt; struct S {};
template &lt;int idx, typename T, typename... Args&gt;
struct S&lt;idx, T, Args...&gt; {
  T t;
  S&lt;idx+1, Args...&gt; nested;
};

template &lt;typename... Args&gt;
struct tuple: public S&lt;0, Args...&gt; {};

int*$a target(tuple&lt;int*, int* $a&gt;&amp; s) {
  return s.nested.t;
}
</code></pre>
<p><strong>Lifetime inference for nested class templates</strong></p>
<pre><code>template &lt;typename T&gt;
struct R {
  R(T t) : t(t) {}
  T t;
};

bool some_condition();

template &lt;typename T&gt;
struct S {
  S(T a, T b) : r(some_condition() ? R(a) : R(b)) {}
  R&lt;T&gt; r;
};

int* $a target(int* $a a, int* $a b) {
  S&lt;int*&gt; s(a, b);
  return s.r.t;
}

// The algorithm infers the following lifetimes for class template instantiations
// (which cannot be annotated directly in the code):
// R&lt;int* $a&gt;::R(int* $a) $b
// S&lt;int* $a&gt;::S(int* $a, int* $a) $b
</code></pre>
<p>
Lifetime annotations can help static analysis tools in general better understand how a function call may mutate the object graph.
</p><p>As an example, say we want to implement a static analysis that detects unchecked unwraps of <code>std::optional</code>. Here is an example program:</p>
<pre><code>struct A {
  std::optional&lt;int&gt; opt_int;
};
struct B { … };

void MutateAB(A* a, B* b);
void MutateB(B* b);
void Use(int x);

void Target() {
  A a;
  B b;
  MutateAB(&amp;a, &amp;b);
  if (a.opt_int.has_value()) {
    MutateB(&amp;b);
    Use(*a.opt_int); // Safe?
  }
}
</code></pre>
<p>Many programmers will say that accessing the value of the optional in <code>Use(*a.opt_int)</code> is safe because it is protected by the <code>if (... has_value …)</code> check, and the <code>MutateB(&amp;b)</code> call does not change <code>a</code>.</p>
<p>However, <code>MutateAB(&amp;a, &amp;b)</code> could have stored a pointer to <code>a</code> inside <code>b</code>. Subsequently, <code>MutateB(&amp;b)</code> could have cleared <code>a.opt_int</code>, invalidating the <code>if (... has_value…)</code> check.</p>
<p>A sound static analysis must therefore warn that <code>Use(*a.opt_int)</code> is not safe, but many users will flag this warning in their code as a false positive, because in practice modern C++ code rarely has this kind of action-at-a-distance.</p>
<p>Note that even (unsoundly) assuming absence of global variables does not help here, since no global variables are involved. To eliminate this false positive we need to assume that the object graphs reachable from <code>a</code> and <code>b</code> are disjoint. A scalable, local analysis can’t gather enough evidence from the program to make such assumptions on a solid basis.</p>
<p>Lifetime annotations allow the programmer to express the possible mutations to the object graph in a machine-readable way. If <code>B</code> can point to <code>A</code> and <code>MutateAB()</code> sets this pointer, the code can express it with lifetime annotations:</p>
<pre><code>// Indicate that the lifetimes implied by elision rules are indeed correct.
#pragma clang lifetime_elision

struct A {
  std::optional&lt;int&gt; opt_int;
};

struct B [[clang::lifetime_param(a)]] {
  std::vector&lt;A* $a&gt; helpers;
};

// Lifetime annotations express that the object graph behind the pointer `b` may point to `a`:
void MutateAB(A* $a a, B $a * $b b);

// Or, equivalently, using lifetime elision shorthand syntax:
void MutateAB(A* $a a, B $a * b);

void MutateAB(A* a, B* b) {
  b-&gt;helpers.push_back(a);
}
</code></pre>
<p>Furthermore, the Clang-Tidy check that verifies that the implementation of <code>MutateAB</code> follows its lifetime contract would reject any other lifetime annotations. In other words, lifetime annotations are not just a promise equivalent to comments; they are checked and can be relied upon.</p>
<p>If, conversely,  <code>B</code> can’t point to <code>A</code> – the common case that many engineers expect – the original code without explicit annotations already expresses the right semantics:</p>
<pre><code>// Indicate that the lifetimes implied by elision rules are indeed correct.
#pragma clang lifetime_elision

struct A {
  std::optional&lt;int&gt; opt_int;
};

// Absence of lifetime parameters on `B` means that it can&#39;t point to other objects
// in the object graph that it does not own.
struct B { … };

// Lifetime annotations express that object graphs behind pointers `a` and `b` are unrelated:
void MutateAB(A* $a a, B* $b b);

// Or, equivalently, using lifetime elision shorthand syntax:
void MutateAB(A* a, B* b);
</code></pre>

<h2>
<a name="references-and-pointers-in-rust-23" href="#references-and-pointers-in-rust-23"></a>References and pointers in Rust</h2>
<p>Rust provides two kinds of indirections, references and pointers, that have different semantics:</p>
<p><strong>References</strong></p>
<ul>
<li>References are safe. Each reference has a lifetime associated with it. For example, a reference to a 32-bit integer with lifetime <code>’a</code> is written <code>&amp;’a i32</code>. The lifetimes allow the borrow checker to verify that references are used in a memory-safe way.</li>
<li>References are non-nullable. Nullability can be added explicitly where necessary by using the <code>Option&lt;T&gt;</code> type, for example <code>Option&lt;&amp;&#39;a i32&gt;</code>.</li>
<li>References are ergonomic. Rust’s syntax and libraries are optimized for using references most of the time.</li>
<li>References are idiomatic. Rust programmers prefer to use references in their code as much as possible.</li>
</ul>
<p><strong>Pointers</strong></p>
<ul>
<li>Pointers are unsafe. They don’t carry lifetime information. For example, a non-mutable pointer to a 32-bit integer is simply written <code>*const i32</code>. The borrow checker cannot verify that pointers are used in a memory-safe way.</li>
<li>Pointers are nullable. To express a non-null constraint one must add an annotation.</li>
<li>Pointers lead to non-ergonomic code. For example, verbose casts are required to convert between references and pointers. To convert a pointer <code>x</code> to a reference one must write <code>unsafe {&amp;*x}</code>.</li>
<li>Pointers are non-idiomatic. Rust programmers avoid using pointers.</li>
</ul>
<h2>
<a name="crust-interoperability-without-lifetime-annotations-in-c-24" href="#crust-interoperability-without-lifetime-annotations-in-c-24"></a>C++/Rust interoperability without lifetime annotations in C++</h2>
<p>Let’s say we want to call the following C++ function from Rust:</p>
<pre><code>// C++:
const int&amp; smaller(const int&amp; x, const int&amp; y);
</code></pre>
<p>This function signature does not explain the lifetime contract. A tool that generates C++/Rust bindings based on C++ headers (for example, <a href="https://crates.io/crates/bindgen" rel="noopener nofollow ugc">bindgen</a>) has no choice but to declare <code>smaller()</code> using unsafe pointers that don’t have a Rust lifetime:</p>
<pre><code>// Rust bindings (automatically generated):
extern &#34;C&#34; {
  pub fn smaller(x: *const i32, y: *const i32) -&gt; *const i32;
}
</code></pre>
<p>Rust code can now call <code>smaller()</code>, but callers must use unsafe pointers:</p>
<pre><code>// Rust caller of C++ `smaller()` function that does not have lifetime annotations:
fn user() {
  let x = 10;
  let y = 5;
  let m = unsafe { smaller(&amp;x, &amp;y) };
  println!(&#34;smaller({x}, {y}) is {}&#34;, unsafe{*m});
}
</code></pre>
<h2>
<a name="crust-interoperability-with-lifetime-annotations-in-c-25" href="#crust-interoperability-with-lifetime-annotations-in-c-25"></a>C++/Rust interoperability with lifetime annotations in C++</h2>
<p>Now let’s annotate <code>smaller()</code> with lifetimes on the C++ side:</p>
<pre><code>// C++:
const int&amp; $a smaller(const int&amp; $a x, const int&amp; $a y);
</code></pre>
<p>Equipped with this machine-readable lifetime information, a tool that generates C++/Rust bindings can define a safe Rust wrapper. This wrapper exposes safe Rust references and describes the lifetime contract of <code>smaller()</code> to the Rust borrow checker:</p>
<pre><code>// Rust bindings (automatically generated):
pub fn smaller&lt;&#39;a&gt;(x: &amp;&#39;a i32, y: &amp;&#39;a i32) -&gt; &amp;&#39;a i32 {
  // Glue code to call C++ function through foreign-function interface omitted.
}
</code></pre>
<p>Now <code>smaller()</code> can be ergonomically called like any other safe Rust function:</p>
<pre><code>// Rust caller of C++ `smaller()` function that is annotated with lifetimes:
fn user() {
  let x = 10;
  let y = 5;
  let m = smaller(&amp;x, &amp;y);
  println!(&#34;smaller({x}, {y}) is {m}&#34;);
}
</code></pre>
<p>
Here we answer the usual set of questions about contributing extensions to Clang (https://clang.llvm.org/get_involved.html)
</p><h2>
<a name="evidence-of-a-significant-user-community-26" href="#evidence-of-a-significant-user-community-26"></a>Evidence of a significant user community</h2>
<ul>
<li>
<p>Large parts of the C++ community are interested in finding memory safety bugs in C++ code. This is evidenced by the popularity of dynamic analysis tools such as <a href="https://clang.llvm.org/docs/AddressSanitizer.html" rel="noopener nofollow ugc">AddressSanitizer</a> and <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html" rel="noopener nofollow ugc">UndefinedBehaviorSanitizer</a>, used in combination with manually written tests and fuzzing.</p>
</li>
<li>
<p>Finding memory safety bugs statically is also very interesting to users, since it allows bugs to be found before the tests are written and run. This interest is evidenced by Clang’s existing efforts in this area: <code>-Wreturn-stack-address</code>, <code>-Wdangling</code>, and <code>-Wdangling-gsl</code>. The latter two warnings are based on a partial implementation of the WG21 proposal P1179. All of these warnings have been on by default for a few years, have received little to no pushback from users, and have proven themselves valuable by finding quite a few bugs (based on our experience running them on our internal codebases).</p>
</li>
<li>
<p>Interest in source code annotations that help statically finding memory safety bugs is evidenced by P1179 itself, which has been partially implemented in Clang for a few years.</p>
</li>
<li>
<p>Interoperability between C++ and other languages is desired by some C++ users. For example, <a href="https://cxx.rs/" rel="noopener nofollow ugc">https://cxx.rs/</a> is a relatively popular crate for C++/Rust interop (750K+ downloads on <a href="http://crates.io" rel="noopener nofollow ugc">crates.io</a> (<a href="https://crates.io/crates/cxx" rel="noopener nofollow ugc">https://crates.io/crates/cxx</a>) ), and C++/Swift interop has been worked on for a few years already. However, the fact that pointers and references in C++ APIs have unclear ownership and lifetime semantics presents a huge obstacle to automatic, ergonomic, safe bridging of C++ to other languages. Due to this issue, for example, cxx.rs does not support borrowed data as much as one could desire to bridge many idiomatic C++ APIs to Rust.</p>
</li>
</ul>
<h2>
<a name="a-specific-need-to-reside-within-the-clang-tree-27" href="#a-specific-need-to-reside-within-the-clang-tree-27"></a>A specific need to reside within the Clang tree</h2>
<ul>
<li>
<p>Clang-Tidy is one of the industry standard static analysis tools, integrated into many workflows and IDEs (both free and commercial). Having our proposed analysis integrated into Clang-Tidy will allow interested engineers to run it much more easily than with an out-of-tree tool.</p>
</li>
<li>
<p>The only change to core Clang we are proposing is a general-purpose type annotation attribute that is not specific to the lifetime analysis. The lifetime analysis itself is kept separate in Clang-Tidy.</p>
</li>
<li>
<p>We believe that the biggest impact from the proposed static analysis could be realized if it was included into the core compiler as a warning. We are not ready to propose this yet because we are still experimenting with the semantics of the annotations and need to collect feedback from early adopters.</p>
</li>
</ul>
<h2>
<a name="specification-28" href="#specification-28"></a>Specification</h2>
<p>At this point, we are still experimenting with the semantics of the annotations. This document includes a high-level overview. We will be committing more detailed design docs and specifications together with the implementation, but they will be in flux for some time.</p>
<h2>
<a name="representation-within-the-appropriate-governing-organization-29" href="#representation-within-the-appropriate-governing-organization-29"></a>Representation within the appropriate governing organization</h2>
<p>We believe it is too early to ask this question. In principle, the existence of P1179 shows that WG21 has some interest in this kind of annotations.</p>
<h2>
<a name="a-long-term-support-plan-30" href="#a-long-term-support-plan-30"></a>A long-term support plan</h2>
<p>If the experimentation confirms that this type of annotations and static analysis is useful in practice, maintaining them is very similar to maintaining any other Clang-Tidy check: organizations and individuals that enable it for their codebases will do the maintenance work.</p>
<h2>
<a name="a-high-quality-implementation-with-a-test-suite-31" href="#a-high-quality-implementation-with-a-test-suite-31"></a>A high-quality implementation with a test suite</h2>
<p>We will be contributing a high-quality implementation with extensive tests. This is in our best interest since the burden is on us to show that this style of lifetime annotations is worth the added complexity for engineers reading and writing C++.</p>
        </div></div>
  </body>
</html>
