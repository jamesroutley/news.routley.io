<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wordsandbuttons.online/sympy_makes_math_fun_again.html">Original</a>
    <h1>SymPy makes math fun again</h1>
    
    <div id="readability-page-1" class="page"><div>
	<p>This is <a href="https://wordsandbuttons.online/index.html">Words and Buttons Online</a> — a collection of interactive <a href="https://wordsandbuttons.online/all_tutorials.html">#tutorials</a>, <a href="https://wordsandbuttons.online/all_demos.html">#demos</a><a>, and </a><a href="https://wordsandbuttons.online/all_quizzes.html">#quizzes</a> about <a href="https://wordsandbuttons.online/all_mathematics.html">#mathematics</a>, <a href="https://wordsandbuttons.online/all_algorithms.html">#algorithms</a> and <a href="https://wordsandbuttons.online/all_programming.html">#programming</a>.</p>
	
	<p>
I remember my own struggle with calculus at university. Limits, integrals, differential equations. Lots of practice, lots of homework. Pages and pages of exercises. I loved math, loved the connection between algebra and geometry, loved the very pleasure of solving problems by making different concepts work together. But I hated doing the “paperwork”.
	</p>
	<p>
Taking it seriously, I still studied through the semester, studied harder the week before the exam, studied even harder the night before. I got 62/100. That&#39;s 1 point above the lowest possible passing grade.
	</p>
	<p>
Well, maybe math is not for everyone. But wait a minute! The next semester I took part in the Math Olympiad, went through the faculty round, then through the university round, went to the nationals, and even managed to score a few points there. Which counted as a pass on that semester&#39;s exam.
	</p>
	<p>
My professors were proud of me. And for almost a year, they thought that the first semester&#39;s score was a mistake. Until in the third semester, I scored 65/100.
	</p>
	
	<p>
Mathematics is a lot of things. It&#39;s the fun of problem-solving, it&#39;s the excitement of discoveries, it&#39;s the pride of accomplishments, and it&#39;s a ton of tedious computations, too. I never liked that last part. I still don&#39;t. That&#39;s why I&#39;m so happy to live in the XXI century since I can give it away to computers and still enjoy the first three.
	</p>
	<h2>
<span id="index_sympy">SymPy</span> it is
	</h2>
	<p>
According to the <a href="https://www.sympy.org/en/index.html">official site</a>:
	</p>
	<p><i>
SymPy is a Python library for <span id="index_symbolic_mathematics">symbolic mathematics</span>. It aims to become a full-featured computer algebra system (CAS) while keeping the code as simple as possible in order to be comprehensible and easily extensible.
	</i></p>
	<p>
Symbolic mathematics? Algebra system? Sounds exclusive. Sounds like it&#39;s a tool for practicing mathematicians and maybe the students who desperately want to become one. But it isn&#39;t. It is for practicing engineers who have just enough math knowledge to state a problem but not enough patience to solve it.
	</p>
	<p>
It does integration and differentiation. It finds limits, and it expands power series. It solves equations and systems of equations. It can even do statistics. And it does it all just like you would do on a math exam yourself. It doesn&#39;t just compute numbers, it computes formulas.
	</p>
	<p>
It is a Python library that does the boring part of math for you. Moreover, it does the math fast, accurately, and without angst. In other words, it is everything I&#39;m not.
	</p>
	<h2>
Let SymPy do some math for you
	</h2>
	<p>
Let&#39;s say we want to model the sine function with a polynomial. Let&#39;s pretend we have a reason. Now how do we do that?
	</p>
	<p>
How about, we gather all we know about the sine function in one bowl and let SymPy do the rest? Sounds good?
	</p>
	<canvas id="sine" width="640" height="480"></canvas>
	
	<p>
We know that <i>sin(0) = 0</i>, right? Everybody knows that. Also, as you might have heard, you can approximate a small sine with its own argument: <i>sin(0.001) ≃ 0.001</i>. This means that the derivative of sine in <i>0</i> is <i>1</i>.
	</p>
	<p>
The sine function climbs from <i>0</i> to <i>π/2</i> and then it starts going down. In <i>π/2</i> it&#39;s neither climbing nor descending, it&#39;s at its peak. This means that the derivative of <i>sin(π/2)&#39; = 0</i>. Also, since the sine only climbs to <i>1</i>, <i>sin(π/2) = 1</i>.
	</p>
	<p>
The sine is symmetrical relative to <i>π/2</i>. This means that it descends exactly as it climbs, and at the point where it reaches full <i>π</i>, its derivative is <i>sin(π)&#39; = -1</i>, and the function itself <i>sin(π) = 0</i>.
	</p>
	<p>
Also, one less known (but easily computable) fact, the integral of the sine from <i>0</i> to <i>π/2</i> is <i>1</i>. Let&#39;s throw this into the bowl as well.
	</p>
	<p>
So, we have 7 facts. This implies 7 equations. This implies that our polynomial will have 7 coefficients and the highest degree will be then 6.
	</p>
	<p>
Let&#39;s translate it all into Python.
	</p>
	<div>
	<pre id="code_1">from sympy import *

a, b, c, d, e, f, g, x = symbols(&#39;a b c d e f g x&#39;)

sine = a*x**6 + b*x**5 + c*x**4 + d*x**3 + e*x**2 + f*x + g
sine_d = diff(sine, x)
sine_i = integrate(sine, x)

the_system = [
    sine_i.subs(x, pi / 2) - sine_i.subs(x, 0) - 1,
    sine_d.subs(x, 0) - 1,
    sine_d.subs(x, pi / 2),
    sine_d.subs(x, pi) + 1,
    sine.subs(x, 0),
    sine.subs(x, pi / 2) - 1,
    sine.subs(x, pi)
]

res = solve(the_system, (a, b, c, d, e, f, g))

print(res)
</pre>
	</div>
	<p>
You can browse <a href="https://docs.sympy.org/latest/tutorial/index.html">the tutorial</a> if you like but it should be more or less clear as it is. <span>sine</span> is our polynomial model. <span>diff</span> is differentiation. <span>integrate</span> is integration. <span>solve</span> is solve. Simple!
	</p>
	<p>
Our solution now is a Python dictionary of formulas:
	</p>
	<p>
{a: (-448*pi - 28*pi**2 + 1680)/pi**7,</p>
	<p>
Which is nice but not be exactly what we expected. We need the coefficients for a polynomial model and SymPy gave us the way to compute these coefficients from <i>π</i> instead. Well, it&#39;s what it does, it computes things symbolically not numerically. Or does it?
	</p>
	<p>
Look! I&#39;ll add one more line and SymPy will compute our coefficients as floating-point numbers.
	</p>
	<div>
	<pre id="code_2">from sympy import *
from math import pi

a, b, c, d, e, f, g, x = symbols(&#39;a b c d e f g x&#39;)

sine = a*x**6 + b*x**5 + c*x**4 + d*x**3 + e*x**2 + f*x + g
sine_d = diff(sine, x)
sine_i = integrate(sine, x)

the_system = [
    sine_i.subs(x, pi / 2) - sine_i.subs(x, 0) - 1,
    sine_d.subs(x, 0) - 1,
    sine_d.subs(x, pi / 2),
    sine_d.subs(x, pi) + 1,
    sine.subs(x, 0),
    sine.subs(x, pi / 2) - 1,
    sine.subs(x, pi)
]

res = solve(the_system, (a, b, c, d, e, f, g))

for var, exp in res.items():
    print(var, srepr(exp))
</pre>
	</div>
	<p>
Have you noticed which line it is? Anyway, the result is now this:
	</p>
	<p>
{a: -0.00125233934372311,</p>
	<p>
The line was <span>from math import pi</span>. This overloads the <i>pi</i> in the scope to be a floating-point number, not a symbol. And voilà — SymPy is now numeric. We can take these numbers, put them into our polynomial and it will be our model.
	</p>
	<canvas id="sine_model" width="640" height="480"></canvas>
	
	<p>
The model works wonders in the <i>[0; π]</i> range. Outside this range, the model diverges from the sine but we never specified that it shouldn&#39;t.
	</p>
	<p>
The polynomial bears all the properties we told SymPy about with our equations and nothing more.
	</p>
	<p>
In my <a href="https://www.manning.com/books/geometry-for-programmers">Geometry for Programers</a> book, I used a less graphic but more practical example. I modeled the sine on [0, π/2] range with only four non-zero coefficients and then compared my model to a conventional one obtained as a <a href="https://en.m.wikipedia.org/wiki/Taylor_series">power series</a>. Mine appeared to be an order of magnitude more precise.
	</p>
	<h2>
Now let SymPy write some code for us
	</h2>
	<p>
Let&#39;s say we want something that looks like the sine but isn&#39;t. Something we can tweak interactively. Like the sine but with the movable middle point.
	</p>
	<p>
We can start the same way. Let&#39;s retain the point locations. The integral criterion and the derivatives in the endpoints criteria are better to be lifted. But that&#39;s just my opinion, you can try to retain them yourself and see what&#39;ll happen.
	</p>
	<p>
Anyway, the code that states the problem now looks like this:
	</p>
	<div>
	<pre id="code_3">from sympy import *

a, b, c, d, x, px, py = symbols(&#39;a b c d x px py&#39;)

sine = a*x**3 + b*x**2 + c*x + d
sine_d = diff(sine, x)

the_system = [
    sine_d.subs(x, px),
    sine.subs(x, 0),
    sine.subs(x, px) - py,
    sine.subs(x, pi)
]

res = solve(the_system, (a, b, c, d))

print(res)
</pre>
	</div>
	<p>
When run, it prints out that:
	</p>
	<p>
{a: (-2*px*py + pi*py)/(px**4 - 2*pi*px**3 + pi**2*px**2),</p>
	<p>
This is already code-like, you can copy-paste this to your program and maul it a bit so it would fit the syntax of your favorite language. Or you can ask SymPy to do that for you as well!
	</p>
	<p>
Just replace <span>print(res)</span> with <span>print(jscode(res))</span> and SymPy will write the solution in JavaScript!
	</p>
	<p>
{a: (-2*px*py + Math.PI*py)/(Math.pow(px, 4) -</p>
	<p>
The formulas are now completely runnable code. Here I used them to make this very interactive widget ↓
	</p>
	<canvas id="not_sine" width="640" height="480"></canvas>
	
	
	<p>
SymPy can also write code in Rust, C++, Fortran, Matematica, and more. Most of the non-esoterical languages are <a href="https://docs.sympy.org/latest/modules/printing.html">already there</a>.
	</p>
	<p>
They say that AI will replace programmers in the future. Well, for a certain part, the future is here. SymPy already writes your code for you and not just some boilerplate. It really solves a mathematical problem and turns the solution into something you can run. Well, if writing code means solving equations without any creative thought involved, I don&#39;t mind being replaced.
	</p>
	<h2>
Conclusion
	</h2>
	<p>
I disagree with the “math is not for everyone”. Math is vast and diverse. Surely there is enough math for everyone. But some parts of it are better left to computers.
	</p>
	<p>
Hope this demonstration shows that computers are happy to help you. It&#39;s not that hard to state a problem and it&#39;s even easier to interpret results. And it&#39;s fun.
	</p>
	<p>
If my humble introduction to SymPy will help you enjoy math long after your final calculus exam, it&#39;ll make me happy too.
	</p>

	
	</div></div>
  </body>
</html>
