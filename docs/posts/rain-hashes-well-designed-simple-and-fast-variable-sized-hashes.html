<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/DOSAYGO-Research/rain">Original</a>
    <h1>Show HN: Rain hashes – well designed, simple and fast variable sized hashes</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><strong>News</strong>
Rainsum v1.2.0 now includes improvements adapted from <a href="https://gitlab.com/fwojcik/smhasher3" rel="nofollow">Frank J. T. Wojcik&#39;s SMHasher3</a>, the gold standard for evaluating non-cryptographic hash functions. SMHasher3 provides extensive speedups, bug fixes, and enhancements over SMHasher and SMHasher2. From their repo:
<em>&#34;SMHasher3 is a test suite for evaluating non-cryptographic hash functions.&#34;</em></p>
<p dir="auto">This repository features the <strong>Rainbow</strong> and <strong>Rainstorm</strong> hash functions, created by <a href="https://github.com/o0101">Cris</a> at <a href="https://github.com/dosyago">DOSAYGO</a> and licensed under Apache-2.0. All size variants of both hashes pass all tests in SMHasher3. Relevant <a href="https://github.com/DOSAYGO-Research/rain/blob/rain/results">results</a> are available in the <code>results/</code> directory.</p>
<p dir="auto">The codebase includes:</p>
<ul dir="auto">
<li>A C++ reference implementation</li>
<li>A WASM port (for Node.js and browser environments)</li>
<li>A Makefile for building all targets</li>
</ul>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Algorithm</th>
<th>Speed</th>
<th>Hash Size</th>
<th>Purpose</th>
<th>Core Mixing Function</th>
<th>Security</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rainbow</td>
<td>~5.79 GiB/s</td>
<td>64, 128, 256 bits</td>
<td>General-purpose, non-crypto hash</td>
<td>Multiplication, addition/subtraction, rotation, XOR</td>
<td>Not designed as cryptographic</td>
</tr>
<tr>
<td>Rainstorm</td>
<td>~1.91 GiB/s (4 rds)</td>
<td>64 to 512 bits</td>
<td>Experimental cryptographic-like hashing</td>
<td>Addition/subtraction, rotation, XOR</td>
<td>Unvetted, no formal analysis</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<hr/>

<ul dir="auto">
<li><a href="#usage-options">Usage Options</a></li>
<li><a href="#assets">Assets</a></li>
<li><a href="#building">Building</a></li>
<li><a href="#benchmark">Benchmark</a></li>
<li><a href="#repository-structure">Repository Structure</a></li>
<li><a href="#rainbow">Rainbow</a></li>
<li><a href="#rainstorm---unvetted-for-security">Rainstorm - Unvetted for Security</a></li>
<li><a href="#note-on-cryptographic-intent">Note on Cryptographic Intent</a></li>
<li><a href="#genesis">Genesis</a></li>
<li><a href="#license">License</a></li>
<li><a href="#rainsum-field-manual">Rainsum Field Manual</a>
<ul dir="auto">
<li><a href="#1-introduction">1. Introduction</a></li>
<li><a href="#2-basic-usage">2. Basic Usage</a>
<ul dir="auto">
<li><a href="#21-command-structure">2.1 Command Structure</a></li>
<li><a href="#22-options">2.2 Options</a></li>
</ul>
</li>
<li><a href="#3-modes-of-operation">3. Modes of Operation</a>
<ul dir="auto">
<li><a href="#31-digest-mode">3.1 Digest Mode</a></li>
<li><a href="#32-stream-mode">3.2 Stream Mode</a></li>
</ul>
</li>
<li><a href="#4-hash-algorithms-and-sizes">4. Hash Algorithms and Sizes</a></li>
<li><a href="#5-test-vectors">5. Test Vectors</a></li>
<li><a href="#6-seed-values">6. Seed Values</a></li>
<li><a href="#7-help-and-version-information">7. Help and Version Information</a></li>
<li><a href="#8-compilation">8. Compilation</a></li>
<li><a href="#9-conclusion">9. Conclusion</a></li>
</ul>
</li>
<li><a href="#developer-information">Developer Information</a>
<ul dir="auto">
<li><a href="#stability">Stability</a></li>
<li><a href="#test-vectors">Test vectors</a></li>
<li><a href="#building-and-installing">Building and Installing</a></li>
<li><a href="#contributions">Contributions</a></li>
</ul>
</li>
<li><a href="#story">Story</a></li>
</ul>
<hr/>

<div dir="auto"><h3 tabindex="-1" dir="auto">JavaScript (WASM) Channel</h3><a id="user-content-javascript-wasm-channel" aria-label="Permalink: JavaScript (WASM) Channel" href="#javascript-wasm-channel"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ol dir="auto">
<li>
<p dir="auto"><strong>Node.js Library</strong>
Install:</p>
<div dir="auto" data-snippet-clipboard-copy-content="npm i @dosyago/rainsum@latest"><pre>npm i @dosyago/rainsum@latest</pre></div>
<p dir="auto">Usage:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { rainbowHash, rainstormHash } from &#39;@dosyago/rainsum&#39;;

const seed = 0x0;
const hash = await rainbowHash(256, seed, &#39;Hello there!&#39;);
const intendedCryptoHash = await rainstormHash(512, seed, Buffer.from(&#39;Hello there!&#39;));"><pre><span>import</span> <span>{</span> <span>rainbowHash</span><span>,</span> <span>rainstormHash</span> <span>}</span> <span>from</span> <span>&#39;@dosyago/rainsum&#39;</span><span>;</span>

<span>const</span> <span>seed</span> <span>=</span> <span>0x0</span><span>;</span>
<span>const</span> <span>hash</span> <span>=</span> <span>await</span> <span>rainbowHash</span><span>(</span><span>256</span><span>,</span> <span>seed</span><span>,</span> <span>&#39;Hello there!&#39;</span><span>)</span><span>;</span>
<span>const</span> <span>intendedCryptoHash</span> <span>=</span> <span>await</span> <span>rainstormHash</span><span>(</span><span>512</span><span>,</span> <span>seed</span><span>,</span> <span>Buffer</span><span>.</span><span>from</span><span>(</span><span>&#39;Hello there!&#39;</span><span>)</span><span>)</span><span>;</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Global Binary via NPM</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="npm i -g @dosyago/rainsum@latest
jsrsum --help"><pre>npm i -g @dosyago/rainsum@latest
jsrsum --help</pre></div>
</li>
</ol>

<ol dir="auto">
<li>
<p dir="auto"><strong>Build everything</strong> (For WASM ensure <a href="https://emscripten.org/docs/getting_started/downloads.html" rel="nofollow">Emscripten</a> is installed):</p>
<div dir="auto" data-snippet-clipboard-copy-content="make clean &amp;&amp; make
sudo make install  # optional, installs &#39;rainsum&#39; globally"><pre>make clean <span>&amp;&amp;</span> make
sudo make install  <span><span>#</span> optional, installs &#39;rainsum&#39; globally</span></pre></div>
</li>
<li>
<p dir="auto"><strong>Use as a library or CLI</strong>:</p>
<ul dir="auto">
<li>Link <code>rainstorm.o</code> or <code>rainbow.o</code> into your project, or include <code>tool.h</code> and source files from <code>./src/</code>.</li>
<li>Use the <code>rainsum</code> CLI directly:
<div dir="auto" data-snippet-clipboard-copy-content="rainsum file.txt
# By default: Rainbow, 256-bit hash
rainsum --help"><pre>rainsum file.txt
<span><span>#</span> By default: Rainbow, 256-bit hash</span>
rainsum --help</pre></div>
</li>
</ul>
</li>
</ol>
<p dir="auto"><code>jsrsum</code> (via NPM + WASM) mirrors the CLI/API of <code>rainsum</code> but runs slower.</p>
<hr/>

<ul dir="auto">
<li><code>rainsum</code> CLI tool and associated <code>.o</code> object files (C++)</li>
<li>WASM binary</li>
<li>JS CLI tool (<code>jsrsum</code>) with an ES Module API exporting <code>rainbowHash</code> and <code>rainstormHash</code></li>
<li>Scripts:
<ul dir="auto">
<li><code>./scripts/bench.mjs</code>: Benchmark JS WASM vs C++</li>
<li><code>./scripts/verify.mjs</code>: Verify correctness</li>
<li>Other utility scripts</li>
</ul>
</li>
</ul>
<hr/>


<p dir="auto">Optional installation:</p>

<hr/>

<p dir="auto"><strong>C++ vs WASM (Node.js)</strong></p>
<p dir="auto">These benchmarks highlight the performance gap between native C++ and the WASM-based implementation under Node.js:</p>
<div data-snippet-clipboard-copy-content="Test Input &amp; Size          Run   C++ Version        WASM Version       Speedup
10 bytes (input1)          1     6,964,250 ns     129,892,625 ns     18x (C++ wins!)
100 bytes (input2)         1     6,876,208 ns     127,928,542 ns     18x (C++ wins!)
1,000 bytes (input3)       1     6,583,125 ns     127,668,333 ns     19x (C++ wins!)
10,000 bytes (input4)      1     5,920,167 ns     127,438,666 ns     21x (C++ wins!)
100,000 bytes (input5)     1     6,214,916 ns     127,551,791 ns     20x (C++ wins!)
1,000,000 bytes (input6)   1     5,321,500 ns     126,986,167 ns     23x (C++ wins!)
10,000,000 bytes (input7)  1     9,879,042 ns     132,929,875 ns     13x (C++ wins!)
100,000,000 bytes (input8) 1    49,761,375 ns     207,500,917 ns      4x (C++ wins!)"><pre><code>Test Input &amp; Size          Run   C++ Version        WASM Version       Speedup
10 bytes (input1)          1     6,964,250 ns     129,892,625 ns     18x (C++ wins!)
100 bytes (input2)         1     6,876,208 ns     127,928,542 ns     18x (C++ wins!)
1,000 bytes (input3)       1     6,583,125 ns     127,668,333 ns     19x (C++ wins!)
10,000 bytes (input4)      1     5,920,167 ns     127,438,666 ns     21x (C++ wins!)
100,000 bytes (input5)     1     6,214,916 ns     127,551,791 ns     20x (C++ wins!)
1,000,000 bytes (input6)   1     5,321,500 ns     126,986,167 ns     23x (C++ wins!)
10,000,000 bytes (input7)  1     9,879,042 ns     132,929,875 ns     13x (C++ wins!)
100,000,000 bytes (input8) 1    49,761,375 ns     207,500,917 ns      4x (C++ wins!)
</code></pre></div>
<p dir="auto">Runs 2 and 3 show similar results, consistently demonstrating that the native C++ version outperforms the WASM variant by a factor of ~3x to ~25x, depending on input size.</p>
<hr/>

<div data-snippet-clipboard-copy-content=".
├─ LICENSE.txt
├─ Makefile
├─ README.md
├─ docs/
├─ js/
├─ rain/
│  ├─ bin/
│  └─ obj/
├─ results/
│  ├─ dieharder/
│  └─ smhasher3/
├─ scripts/
└─ src/
   ├─ common.h
   ├─ rainbow.cpp
   ├─ rainstorm.cpp
   ├─ rainsum.cpp
   ├─ tool.h
   └─ ..."><pre><code>.
├─ LICENSE.txt
├─ Makefile
├─ README.md
├─ docs/
├─ js/
├─ rain/
│  ├─ bin/
│  └─ obj/
├─ results/
│  ├─ dieharder/
│  └─ smhasher3/
├─ scripts/
└─ src/
   ├─ common.h
   ├─ rainbow.cpp
   ├─ rainstorm.cpp
   ├─ rainsum.cpp
   ├─ tool.h
   └─ ...
</code></pre></div>
<hr/>

<p dir="auto"><strong>Rainbow</strong> is a fast, general-purpose non-cryptographic hash that can produce 64-bit, 128-bit, or 256-bit hashes. It is simple, compact (~140 LOC), and passes all SMHasher3 tests for its 64-bit variant. Its prime-based mixing function yields strong avalanche properties.</p>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">Rainstorm - Unvetted for Security</h2><a id="user-content-rainstorm---unvetted-for-security" aria-label="Permalink: Rainstorm - Unvetted for Security" href="#rainstorm---unvetted-for-security"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><strong>Rainstorm</strong> is a slower, more complex hash function inspired by cryptographic designs. It supports output sizes of 64 to 512 bits and adjustable rounds. While it uses operations reminiscent of cryptographic hashes, it <strong>is not formally analyzed by any 3rd-party</strong>. Consider it experimental, but designed to be secure.</p>
<hr/>
<div dir="auto"><h2 tabindex="-1" dir="auto">Note on Cryptographic Intent</h2><a id="user-content-note-on-cryptographic-intent" aria-label="Permalink: Note on Cryptographic Intent" href="#note-on-cryptographic-intent"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Rainstorm&#39;s design includes concepts from cryptographic hashing, but without formal analysis, it should not be considered secure. Feedback and analysis are welcome.</p>
<hr/>

<p dir="auto">The mixing functions were inspired by Discohash and refined iteratively using SMHasher3 over a few weeks, guided by experience and intuition. Careful prime selection ensured broad avalanche properties.</p>
<hr/>

<p dir="auto">Apache-2.0 © 202 - 20243 Cris &amp; DOSAYGO Corporation. With improvements © Frank J. T. Wojcik 2023</p>
<hr/>


<p dir="auto">Rainsum is a CLI tool for hashing input data using Rainbow or Rainstorm. It supports two primary modes:</p>
<ul dir="auto">
<li><strong>Digest Mode:</strong> Produces a fixed-length hexadecimal output.</li>
<li><strong>Stream Mode:</strong> Iteratively feeds the hash back into itself to produce a variable-length stream of binary output.</li>
</ul>
<p dir="auto">A JavaScript WASM version (<code>jsrsum</code>) offers similar functionality at reduced speed.</p>


<div data-snippet-clipboard-copy-content="rainsum [OPTIONS] [INFILE]"><pre><code>rainsum [OPTIONS] [INFILE]
</code></pre></div>
<p dir="auto">If no <code>INFILE</code> is provided, input is read from standard input.</p>

<ul dir="auto">
<li><code>-m, --mode [digest|stream]</code>: Default <code>digest</code>.</li>
<li><code>-a, --algorithm [bow|storm]</code>: Choose <code>rainbow</code> (<code>bow</code>) or <code>rainstorm</code> (<code>storm</code>). Default <code>storm</code>.</li>
<li><code>-s, --size [64-256|64-512]</code>: Hash size in bits. Default <code>256</code>. Rainbow supports 64,128,256. Rainstorm supports 64,128,256,512.</li>
<li><code>-o, --output-file FILE</code>: Write output to <code>FILE</code>.</li>
<li><code>-t, --test-vectors</code>: Run test vectors.</li>
<li><code>-l, --output-length HASHES</code>: For stream mode, number of iterations.</li>
<li><code>--seed VALUE</code>: Sets the seed (64-bit number or string). A string seed is hashed by Rainstorm to produce a 64-bit seed.</li>
<li><code>-h, --help</code>: Show help.</li>
<li><code>-v, --version</code>: Print version.</li>
</ul>


<p dir="auto">Produces a single, fixed-size hash in hex. For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="rainsum -m digest -a storm -s 256 -o output.txt input.txt"><pre>rainsum -m digest -a storm -s 256 -o output.txt input.txt</pre></div>

<p dir="auto">Generates a stream of hashes by repeatedly feeding the previous hash into the function. Specify iterations with <code>-l</code>. Example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="rainsum -m stream -a storm -s 512 -l 1000000 -o output.txt input.txt"><pre>rainsum -m stream -a storm -s 512 -l 1000000 -o output.txt input.txt</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">4. Hash Algorithms and Sizes</h2><a id="user-content-4-hash-algorithms-and-sizes" aria-label="Permalink: 4. Hash Algorithms and Sizes" href="#4-hash-algorithms-and-sizes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li><code>bow</code> (Rainbow): 64, 128, 256 bits</li>
<li><code>storm</code> (Rainstorm): 64, 128, 256, 512 bits</li>
</ul>

<p dir="auto">Use <code>-t, --test-vectors</code> to verify correctness against known inputs.</p>

<p dir="auto">Use <code>--seed</code> to set a custom seed. String seeds are hashed to a 64-bit value.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">7. Help and Version Information</h2><a id="user-content-7-help-and-version-information" aria-label="Permalink: 7. Help and Version Information" href="#7-help-and-version-information"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li><code>rainsum --help</code></li>
<li><code>rainsum --version</code></li>
</ul>

<p dir="auto">A modern C++17 compiler is required. Run <code>make</code> to build. Ensure necessary build tools (like <code>xcode-select</code> on macOS) are installed.</p>

<p dir="auto">Rainsum provides flexible hashing through Rainbow or Rainstorm. Experiment freely and enjoy the convenience of multiple modes and sizes.</p>
<hr/>


<p dir="auto">The hash definitions may evolve. Changes that affect outputs will be indicated by version increments.</p>

<p dir="auto">Refer to <code>--test-vectors</code> and <code>results/</code> for known outputs and verification.</p>

<div dir="auto" data-snippet-clipboard-copy-content="make
sudo make install
rainsum --help"><pre>make
sudo make install
rainsum --help</pre></div>

<p dir="auto">Improvements, analyses, and faster implementations are welcomed.</p>
<hr/>

<p dir="auto">This is my hash included in the best hash testing library out there &#34;SMHasher3&#34; maintained by Frank T Wojcik: <a href="https://gitlab.com/fwojcik/smhasher3" rel="nofollow">https://gitlab.com/fwojcik/smhasher3</a>
This test lib has many improvements over SMHasher 1 &amp; 2, listed on the previous link. Results are: <a href="https://gitlab.com/fwojcik/smhasher3/-/blob/main/results/README.md" rel="nofollow">https://gitlab.com/fwojcik/smhasher3/-/blob/main/results/README.md</a></p>
<p dir="auto">Rainbow is the fastest 128-bit hash, and the fastest 256-bit hash (non-crypto). The 8th fastest 64-bit hash (by family, or 9th fastest overall, and 13-th fatest overall if you include 32-bit hashes). The advantage of rainbow is its easily scalable output size (64, 128 and 256), its high quality (passes all the tests), and its utter simplicity: it is under 140 source lines of code, easily readable</p>
<p dir="auto">The random constants are primes that were selected based on their avalanche quality under a multiply modulo operation. This part of the development was interesting different primes had very distinctly different avalanche qualities. The highest quality primes caused good avalanche (~ 50% bit flip probability) across the widest possible set of bits, on average. These are quite rare. A lot of large primes only avalanche across a narrow range of bits, even in a 128-bit space. The search program took a couple of days to discover all these primes running on a 2020s era MBP. Primes are chosen because they give a complete residue set under the modulus, ensuring a long cycle length at least regarding the nominal test operation.</p>
<p dir="auto">The rest of the hash was developed by trial and error using my intuition on developing hashes arising from long experience of doing so, and using SMHasher3 to evaluate the results, by iterating to improve and re-testing, over a period of a couple of weeks in the holidays a few years ago. I started making hash functions in my teens as a fun hobby.</p>
</article></div></div>
  </body>
</html>
