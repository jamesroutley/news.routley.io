<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/kstenerud/kbnf/blob/master/kbnf_v1.md">Original</a>
    <h1>Ask HN: Please Review My Metalanguage</h1>
    
    <div id="readability-page-1" class="page"><div>

    <div data-target="readme-toc.content">
      
  


        <div id="readme">
    <article itemprop="text">
<p dir="auto">Version 1-prerelease</p>
<h2 dir="auto"><a id="user-content-work-in-progress" aria-hidden="true" href="#work-in-progress"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>WORK IN PROGRESS</h2>
<p dir="auto">Current status: Second reading (Feb 5, 2023).</p>
<p dir="auto">The second reading uncovered a number of issues, so there will be a third reading in two weeks.</p>
<p dir="auto">If no major issues are found, I&#39;ll release version 1.</p>
<h2 dir="auto"><a id="user-content-introduction" aria-hidden="true" href="#introduction"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Introduction</h2>
<p dir="auto">Syntactic metalanguages have made mainly haphazard gains over the past 60 years, and still only describe text-based formats. KBNF aims to be a modernized metalanguage with better expressivity and binary support.</p>
<h2 dir="auto"><a id="user-content-contents" aria-hidden="true" href="#contents"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Contents</h2>
<ul dir="auto">
<li><a href="#karls-backus-naur-form">Karl&#39;s Backus-Naur Form</a>
<ul dir="auto">
<li><a href="#work-in-progress">WORK IN PROGRESS</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#contents">Contents</a></li>
<li><a href="#design-objectives">Design Objectives</a>
<ul dir="auto">
<li><a href="#human-readability">Human readability</a></li>
<li><a href="#better-expressivity">Better expressivity</a></li>
<li><a href="#character-set-support">Character set support</a></li>
<li><a href="#codepoints-as-first-class-citizens">Codepoints as first-class citizens</a></li>
<li><a href="#binary-grammar-support">Binary grammar support</a></li>
<li><a href="#future-proof">Future proof</a></li>
</ul>
</li>
<li><a href="#forward-notes">Forward Notes</a>
<ul dir="auto">
<li><a href="#about-the-descriptions-and-examples">About the Descriptions and Examples</a></li>
<li><a href="#bit-ordering">Bit Ordering</a></li>
<li><a href="#non-greedy">Non-Greedy</a></li>
</ul>
</li>
<li><a href="#grammar-document">Grammar Document</a>
<ul dir="auto">
<li><a href="#document-header">Document Header</a></li>
</ul>
</li>
<li><a href="#production-rules">Production Rules</a>
<ul dir="auto">
<li><a href="#start-rule">Start Rule</a></li>
<li><a href="#symbols">Symbols</a></li>
<li><a href="#macros">Macros</a></li>
<li><a href="#functions">Functions</a>
<ul dir="auto">
<li><a href="#function-parameter-and-return-types">Function Parameter and Return Types</a></li>
<li><a href="#ranged-types">Ranged Types</a></li>
<li><a href="#variadic-functions">Variadic Functions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#variables">Variables</a></li>
<li><a href="#types">Types</a>
<ul dir="auto">
<li><a href="#identifier">Identifier</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#numbers">Numbers</a></li>
</ul>
</li>
<li><a href="#literals">Literals</a>
<ul dir="auto">
<li><a href="#numeric-literals">Numeric Literals</a></li>
<li><a href="#codepoints">Codepoints</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#escape-sequence">Escape Sequence</a>
<ul dir="auto">
<li><a href="#codepoint-escape">Codepoint Escape</a></li>
</ul>
</li>
<li><a href="#prose">Prose</a></li>
</ul>
</li>
<li><a href="#combinations">Combinations</a>
<ul dir="auto">
<li><a href="#concatenation">Concatenation</a></li>
<li><a href="#alternative">Alternative</a></li>
<li><a href="#exclusion">Exclusion</a></li>
<li><a href="#repetition">Repetition</a></li>
</ul>
</li>
<li><a href="#grouping">Grouping</a></li>
<li><a href="#calculations">Calculations</a></li>
<li><a href="#conditions">Conditions</a></li>
<li><a href="#ranges">Ranges</a></li>
<li><a href="#comments">Comments</a></li>
<li><a href="#builtin-functions">Builtin Functions</a>
<ul dir="auto">
<li><a href="#sized-function"><code>sized</code> Function</a></li>
<li><a href="#aligned-function"><code>aligned</code> Function</a></li>
<li><a href="#swapped-function"><code>swapped</code> Function</a></li>
<li><a href="#when-function"><code>when</code> Function</a></li>
<li><a href="#bind-function"><code>bind</code> Function</a></li>
<li><a href="#unicode-function"><code>unicode</code> Function</a></li>
<li><a href="#uint-function"><code>uint</code> Function</a></li>
<li><a href="#sint-function"><code>sint</code> Function</a></li>
<li><a href="#float-function"><code>float</code> Function</a></li>
<li><a href="#inf-function"><code>inf</code> Function</a></li>
<li><a href="#qnan-function"><code>qnan</code> Function</a></li>
<li><a href="#snan-function"><code>snan</code> Function</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a>
<ul dir="auto">
<li><a href="#a-complex-example">A Complex Example</a></li>
<li><a href="#example-internet-protocol-version-4">Example: Internet Protocol version 4</a></li>
</ul>
</li>
<li><a href="#the-kbnf-grammar-in-kbnf">The KBNF Grammar in KBNF</a></li>
</ul>
</li>
</ul>
<h2 dir="auto"><a id="user-content-design-objectives" aria-hidden="true" href="#design-objectives"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Design Objectives</h2>
<h3 dir="auto"><a id="user-content-human-readability" aria-hidden="true" href="#human-readability"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Human readability</h3>
<p dir="auto">The primary use case for KBNF is to describe text and binary grammars in a formalized way in documentation. Such a format must therefore be human-accessible, while also being concise and unambiguous.</p>
<h3 dir="auto"><a id="user-content-better-expressivity" aria-hidden="true" href="#better-expressivity"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Better expressivity</h3>
<p dir="auto">Binary formats tend to be structured in much more complicated ways than text formats in order to optimize for speed, throughput, or ease-of-processing. A metalanguage for describing such data will require much more expressivity than current metalanguages allow. Better expressivity reduces boilerplate and improves readability even in text format descriptions.</p>
<ul dir="auto">
<li><strong>Repetition</strong>: Any expression can have repetition applied to it, for a specific number of occurrences or a range of occurrences.</li>
<li><strong>Bindings</strong>: Some constructs (such as here documents or length delimited fields) require access to previously decoded values. KBNF supports assigning decoded values to variables.</li>
<li><strong>Exclusion</strong>: Sometimes it&#39;s easier to express something as &#34;everything except for ...&#34;.</li>
<li><strong>Grouping</strong>: Grouping expressions together is an obvious convenince that most other BNF offshoots have already adopted.</li>
<li><strong>Prose</strong>: In many cases, the actual encoding of something is already well-known and specified elsewhere, or is too complex for KBNF to describe adequately. Prose offers a free-form way to describe part of a grammar.</li>
<li><strong>Whitespace not significant</strong>: Many BNF notations (including the original BNF) assign meaning to whitespace (for example: whitespace as concatenation, or linefeeds to mark the end of a rule). This is bad from a UX perspective because it makes things harder for a human to parse in many circumstances, and reduces the ways in which a rule can be expressed over multiple lines.</li>
</ul>
<h3 dir="auto"><a id="user-content-character-set-support" aria-hidden="true" href="#character-set-support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Character set support</h3>
<p dir="auto">Metalanguages tend to support only ASCII, with Unicode (encoded as UTF-8) generally added as an afterthought. This restricts the usefulness of the metalanguage, as any other character sets (many of which are still in use) have no support at all.</p>
<p dir="auto">KBNF can be used with any character set, and requires the character set to be specified as part of the grammar document header.</p>
<h3 dir="auto"><a id="user-content-codepoints-as-first-class-citizens" aria-hidden="true" href="#codepoints-as-first-class-citizens"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Codepoints as first-class citizens</h3>
<ul dir="auto">
<li>Codepoints beyond the ASCII range must be directly inputtable into a grammar document.</li>
<li>Difficult codepoints must also be supported (for example via escape sequences).</li>
<li><a href="https://unicode.org/glossary/#general_category" rel="nofollow">Unicode categories</a> must be supported.</li>
</ul>
<h3 dir="auto"><a id="user-content-binary-grammar-support" aria-hidden="true" href="#binary-grammar-support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Binary grammar support</h3>
<p dir="auto">Binary grammars have different needs from textual grammars, and require special support:</p>
<ul dir="auto">
<li><strong>Bit arrays</strong>: Binary formats tend to work at bit-level granularity, and thus require support for arbitrarily sized bit arrays.</li>
<li><strong>Variables, Macros &amp; Functions</strong>: Binary formats often represent data in complex ways that can&#39;t be parsed without passing some context around.</li>
<li><strong>Conditionals &amp; Logic</strong>: Binary formats often include or exclude portions based on encoded values elsewhere. Evaluating these requires the use of conditionals and logic operators.</li>
<li><strong>Calculations</strong>: Many binary field sizes are determined by data stored elsewhere in the document, and often they require calculations of some sort to determine the final field size.</li>
<li><strong>Transformations</strong>: Binary data often undergoes transformations that are too complex for normal BNF-style rules to express (for example <a href="https://en.wikipedia.org/wiki/LEB128" rel="nofollow">LEB128</a>).</li>
</ul>
<h3 dir="auto"><a id="user-content-future-proof" aria-hidden="true" href="#future-proof"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Future proof</h3>
<p dir="auto">No specification is perfect, nor can it stand the test of time. Eventually an incompatible change will become necessary in order to stay relevant.</p>
<p dir="auto">KBNF documents are versioned to a particular KBNF specification so that changes can be made to the specification without breaking existing tooling.</p>
<h2 dir="auto"><a id="user-content-forward-notes" aria-hidden="true" href="#forward-notes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Forward Notes</h2>
<h3 dir="auto"><a id="user-content-about-the-descriptions-and-examples" aria-hidden="true" href="#about-the-descriptions-and-examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>About the Descriptions and Examples</h3>
<p dir="auto">Descriptions and examples will usually include some KBNF notation. When in doubt, please refer to the <a href="#the-kbnf-grammar-in-kbnf">full KBNF grammar at the end of this document</a>.</p>
<h3 dir="auto"><a id="user-content-bit-ordering" aria-hidden="true" href="#bit-ordering"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Bit Ordering</h3>
<p dir="auto">All sequences of bits (i.e. all <a href="#expressions">expressions</a>) are assumed to be in big endian bit order (higher bits come first), and if necessary can be swapped at any granularity using the <a href="#swapped-function"><code>swapped</code> function</a>.</p>
<p dir="auto"><strong>For example</strong>:</p>
<ul dir="auto">
<li><code>uint(16,0xc01f)</code> matches big endian 0xc01f (bit sequence 1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1).</li>
<li><code>swapped(8, uint(16,0xc01f))</code> matches little endian 0xc01f (bit sequence 0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0).</li>
<li><code>swapped(1, uint(16,0xc01f))</code> matches bit-swapped 0xc01f (bit sequence 1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1).</li>
</ul>
<p dir="auto"><a href="#codepoints">Codepoints</a> follow the byte ordering of the character encoding scheme specified in the <a href="#document-header">document header</a> (although per-byte bit ordering remains nominally big endian). Character sets with ambiguous byte ordering (such as <code>utf-16</code>) should generally be avoided in favor of those with explicit byte ordering (<code>utf-16be</code>, <code>utf-16le</code>).</p>
<h3 dir="auto"><a id="user-content-non-greedy" aria-hidden="true" href="#non-greedy"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Non-Greedy</h3>
<p dir="auto">All expression matching is assumed to be non-greedy.</p>
<p dir="auto">For example, given the following grammar:</p>
<div data-snippet-clipboard-copy-content="document  = record+;
record    = letter+ &amp; terminator;
letter    = &#39;a&#39;~&#39;z&#39;;
terminaor = &#34;zzz&#34;;"><pre lang="kbnf"><code>document  = record+;
record    = letter+ &amp; terminator;
letter    = &#39;a&#39;~&#39;z&#39;;
terminaor = &#34;zzz&#34;;
</code></pre></div>
<p dir="auto">The document <code>azzzbzzzczzz</code> contains 3 records (<code>a</code>, <code>b</code>, and <code>c</code>), not one record (<code>azzzbzzzc</code>).</p>
<h2 dir="auto"><a id="user-content-grammar-document" aria-hidden="true" href="#grammar-document"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Grammar Document</h2>
<p dir="auto">A KBNF grammar document begins with a <a href="#document-header">header section</a>, followed by a series of <a href="#production-rules">production rules</a>.</p>
<div data-snippet-clipboard-copy-content="document = document_header &amp; MAYBE_WSLC &amp; start_rule &amp; (MAYBE_WSLC &amp; rule)*;"><pre lang="kbnf"><code>document = document_header &amp; MAYBE_WSLC &amp; start_rule &amp; (MAYBE_WSLC &amp; rule)*;
</code></pre></div>
<h3 dir="auto"><a id="user-content-document-header" aria-hidden="true" href="#document-header"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Document Header</h3>
<p dir="auto">The document header identifies the file format as KBNF, and contains the following mandatory information:</p>
<ul dir="auto">
<li>The version of the KBNF specification that the document adheres to.</li>
<li>The case-insensitive name of the character encoding used for all codepoint related expressions (use the <a href="https://www.iana.org/assignments/character-sets/character-sets.xhtml" rel="nofollow">IANA preferred MIME name</a> whenever possible).</li>
</ul>
<p dir="auto">Optionally, it may also include header lines. An empty line terminates the document header section.</p>
<div data-snippet-clipboard-copy-content="document_header    = &#34;kbnf_v&#34; &amp; kbnf_version &amp; SOME_WS
                   &amp; character_encoding &amp; LINE_END
                   &amp; header_line* &amp; LINE_END
                   ;
character_encoding = (&#39;a&#39;~&#39;z&#39; | &#39;A&#39;~&#39;Z&#39; | &#39;0&#39;~&#39;9&#39; | &#39;_&#39; | &#39;-&#39; | &#39;.&#39; | &#39;:&#39; | &#39;+&#39; | &#39;(&#39; | &#39;)&#39;){1~40};
header_line        = &#39;-&#39; &amp; SOME_WS
                   &amp; header_name &amp; MAYBE_WS
                   &amp; &#39;=&#39; &amp; MAYBE_WS
                   &amp; header_value &amp; LINE_END
                   ;
header_name        = printable+;
header_value       = printable_ws+;"><pre lang="kbnf"><code>document_header    = &#34;kbnf_v&#34; &amp; kbnf_version &amp; SOME_WS
                   &amp; character_encoding &amp; LINE_END
                   &amp; header_line* &amp; LINE_END
                   ;
character_encoding = (&#39;a&#39;~&#39;z&#39; | &#39;A&#39;~&#39;Z&#39; | &#39;0&#39;~&#39;9&#39; | &#39;_&#39; | &#39;-&#39; | &#39;.&#39; | &#39;:&#39; | &#39;+&#39; | &#39;(&#39; | &#39;)&#39;){1~40};
header_line        = &#39;-&#39; &amp; SOME_WS
                   &amp; header_name &amp; MAYBE_WS
                   &amp; &#39;=&#39; &amp; MAYBE_WS
                   &amp; header_value &amp; LINE_END
                   ;
header_name        = printable+;
header_value       = printable_ws+;
</code></pre></div>
<p dir="auto">The following headers are officially recognized (all others are allowed, but are not standardized):</p>
<ul dir="auto">
<li><code>identifier</code>: A unique identifier for the grammar being described. It&#39;s customary to append a version number to the identifier.</li>
<li><code>description</code>: A brief, one-line description of the grammar.</li>
<li><code>kbnf_specification</code>: A pointer to the KBNF specification as a courtesy to anyone reading the document.</li>
</ul>
<p dir="auto"><strong>Example</strong>: A UTF-8 KBNF grammar called &#34;mygrammar_v1&#34;.</p>
<div data-snippet-clipboard-copy-content="kbnf_v1 utf-8
- identifier  = mygrammar_v1
- description = My first grammar, version 1
- kbnf_specification = https://github.com/kstenerud/kbnf/blob/master/kbnf_v1.md

document = &#34;a&#34;; # Yeah, this grammar doesn&#39;t do much..."><pre lang="kbnf"><code>kbnf_v1 utf-8
- identifier  = mygrammar_v1
- description = My first grammar, version 1
- kbnf_specification = https://github.com/kstenerud/kbnf/blob/master/kbnf_v1.md

document = &#34;a&#34;; # Yeah, this grammar doesn&#39;t do much...
</code></pre></div>
<h2 dir="auto"><a id="user-content-production-rules" aria-hidden="true" href="#production-rules"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Production Rules</h2>
<p dir="auto">Production rules are written in the form <code>nonterminal = expression;</code>, with optional whitespace (including newlines) between rule elements. The terminating semicolon makes it more clear where a rule ends, and also allows more freedom for visually laying out the elements of a rule.</p>
<div data-snippet-clipboard-copy-content="rule          = symbol_rule | macro_rule | function_rule;
start_rule    = symbol_rule;
symbol_rule   = symbol &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; expression &amp; TOKEN_SEP &amp; &#39;;&#39;;
macro_rule    = macro &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; expression &amp; TOKEN_SEP &amp; &#39;;&#39;;
function_rule = function &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; prose &amp; TOKEN_SEP &amp; &#39;;&#39;;"><pre lang="kbnf"><code>rule          = symbol_rule | macro_rule | function_rule;
start_rule    = symbol_rule;
symbol_rule   = symbol &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; expression &amp; TOKEN_SEP &amp; &#39;;&#39;;
macro_rule    = macro &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; expression &amp; TOKEN_SEP &amp; &#39;;&#39;;
function_rule = function &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; prose &amp; TOKEN_SEP &amp; &#39;;&#39;;
</code></pre></div>
<p dir="auto">The left part of a rule can define a <a href="#symbols">symbol</a>, a <a href="#macros">macro</a>, or a <a href="#functions">function</a>. Their case-sensitive names share the same global namespace (i.e. they must be globally unique).</p>
<p dir="auto"><strong>Note</strong>: Whitespace in a KBNF rule is only used to separate tokens and for visual layout purposes; it does not imply any semantic meaning.</p>
<h3 dir="auto"><a id="user-content-start-rule" aria-hidden="true" href="#start-rule"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Start Rule</h3>
<p dir="auto">The first rule listed in a KBNF document is the start rule. Only a <a href="#symbols">symbol</a> can be a start rule.</p>
<h3 dir="auto"><a id="user-content-symbols" aria-hidden="true" href="#symbols"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Symbols</h3>
<p dir="auto">A symbol acts as a placeholder for something to be substituted in another rule.</p>
<div data-snippet-clipboard-copy-content="symbol_rule           = symbol &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; expression &amp; TOKEN_SEP &amp; &#39;;&#39;;
symbol                = identifier_restricted;
identifier_restricted = identifier_any ! reserved_identifiers;
identifier_any        = name;
name                  = name_firstchar &amp; name_nextchar*;
name_firstchar        = unicode(L,M);
name_nextchar         = name_firstchar | unicode(N) | &#39;_&#39;;
reserved_identifiers  = &#34;sized&#34; | &#34;aligned&#34; | &#34;swapped&#34; | &#34;when&#34; | &#34;bind&#34;
                      | &#34;uint&#34; | &#34;sint&#34; | &#34;float&#34; | &#34;inf&#34; | &#34;qnan&#34; | &#34;snan&#34;;"><pre lang="kbnf"><code>symbol_rule           = symbol &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; expression &amp; TOKEN_SEP &amp; &#39;;&#39;;
symbol                = identifier_restricted;
identifier_restricted = identifier_any ! reserved_identifiers;
identifier_any        = name;
name                  = name_firstchar &amp; name_nextchar*;
name_firstchar        = unicode(L,M);
name_nextchar         = name_firstchar | unicode(N) | &#39;_&#39;;
reserved_identifiers  = &#34;sized&#34; | &#34;aligned&#34; | &#34;swapped&#34; | &#34;when&#34; | &#34;bind&#34;
                      | &#34;uint&#34; | &#34;sint&#34; | &#34;float&#34; | &#34;inf&#34; | &#34;qnan&#34; | &#34;snan&#34;;
</code></pre></div>
<p dir="auto"><strong>Note</strong>: Symbol names are not limited to ASCII.</p>
<p dir="auto"><strong>Example</strong>: A record consists of a company name (which must not contain two full-width colons in a row), followed by two full-width colons, followed by an employee count in full-width characters (possibly approximated to the nearest 10,000), and is terminated by a linefeed.</p>
<div data-snippet-clipboard-copy-content="記録		= 会社名 &amp; &#34;：：&#34; &amp; 従業員数 &amp; LF;
会社名		= unicode(L,M) &amp; unicode(L,M,N,P,S,Zs)* ! &#34;：：&#34;;
従業員数		= &#39;１&#39;~&#39;９&#39; &amp; &#39;０&#39;~&#39;９&#39;* &amp; &#39;万&#39;?;
LF		= &#39;\[a]&#39;;"><pre lang="kbnf"><code>記録		= 会社名 &amp; &#34;：：&#34; &amp; 従業員数 &amp; LF;
会社名		= unicode(L,M) &amp; unicode(L,M,N,P,S,Zs)* ! &#34;：：&#34;;
従業員数		= &#39;１&#39;~&#39;９&#39; &amp; &#39;０&#39;~&#39;９&#39;* &amp; &#39;万&#39;?;
LF		= &#39;\[a]&#39;;
</code></pre></div>
<p dir="auto">Or if you prefer, the same thing with English symbol names:</p>
<div data-snippet-clipboard-copy-content="record         = company_name &amp; &#34;：：&#34; &amp; employee_count &amp; LF;
company_name   = unicode(L,M) &amp; unicode(L,M,N,P,S,Zs)* ! &#34;：：&#34;;
employee_count = &#39;１&#39;~&#39;９&#39; &amp; &#39;０&#39;~&#39;９&#39;* &amp; &#39;万&#39;?;
LF             = &#39;\[a]&#39;;"><pre lang="kbnf"><code>record         = company_name &amp; &#34;：：&#34; &amp; employee_count &amp; LF;
company_name   = unicode(L,M) &amp; unicode(L,M,N,P,S,Zs)* ! &#34;：：&#34;;
employee_count = &#39;１&#39;~&#39;９&#39; &amp; &#39;０&#39;~&#39;９&#39;* &amp; &#39;万&#39;?;
LF             = &#39;\[a]&#39;;
</code></pre></div>
<h3 dir="auto"><a id="user-content-macros" aria-hidden="true" href="#macros"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Macros</h3>
<p dir="auto">A macro is essentially a symbol that accepts parameters, which are bound to local <a href="#variables">variables</a> for use within the macro. The macro&#39;s contents are written like regular rules, but also have access to the injected local variables.</p>
<div data-snippet-clipboard-copy-content="macro_rule = macro &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; expression &amp; TOKEN_SEP &amp; &#39;;&#39;;
macro      = identifier_restricted &amp; PARENTHESIZED(param_name &amp; (ARG_SEP &amp; param_name)*);"><pre lang="kbnf"><code>macro_rule = macro &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; expression &amp; TOKEN_SEP &amp; &#39;;&#39;;
macro      = identifier_restricted &amp; PARENTHESIZED(param_name &amp; (ARG_SEP &amp; param_name)*);
</code></pre></div>
<p dir="auto">When called, a macro substitutes the passed-in parameters and proceeds like a normal rule would. Parameter and return <a href="#types">types</a> are inferred based on how the parameters are used within the macro, and the type resulting from the macro&#39;s expression. The grammar is malformed if a macro is called with incompatible types, or is used in a context that is incompatible with its return type.</p>
<div data-snippet-clipboard-copy-content="call       = identifier_any &amp; PARENTHESIZED(call_param &amp; (ARG_SEP &amp; call_param)*);
call_param = any_type;"><pre lang="kbnf"><code>call       = identifier_any &amp; PARENTHESIZED(call_param &amp; (ARG_SEP &amp; call_param)*);
call_param = any_type;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: The main section consists of three records: A type 1 record and two type 2 records. A record begins with a type byte, followed by a length byte, followed by that many bytes of data.</p>
<div data-snippet-clipboard-copy-content="main_section = record(1) &amp; record(2){2};
record(type) = byte(type) byte(bind(length, ~)) &amp; byte(~){length};
byte(v)      = uint(8,v);"><pre lang="kbnf"><code>main_section = record(1) &amp; record(2){2};
record(type) = byte(type) byte(bind(length, ~)) &amp; byte(~){length};
byte(v)      = uint(8,v);
</code></pre></div>
<p dir="auto">In the above example, <code>record</code> must only be called with an unsigned integer, because the <code>type</code> field is passed to the <code>byte</code> macro, which calls the <a href="#uint-function"><code>uint</code> function</a>, which expects an unsigned parameter.</p>
<p dir="auto"><strong>Example</strong>: An <a href="https://mikkel.ca/kstenerud/kbnf/blob/master/ipv4.kbnf">IPV4</a> packet contains &#34;header length&#34; and &#34;total length&#34; fields, which together determine how big the &#34;options&#34; and &#34;payload&#34; sections are. &#34;protocol&#34; determines the protocol of the payload.</p>
<div data-snippet-clipboard-copy-content="ip_packet                    = ...
                             &amp; u4(bind(header_length, 5~)) # length is in 32-bit words
                               ...
                             &amp; u16(bind(total_length, 20~)) # length is in bytes
                               ...
                             &amp; u8(bind(protocol, registered_protocol))
                               ...
                             &amp; options((header_length-5) * 32)
                             &amp; payload(protocol, (total_length-(header_length*4)) * 8)
                             ;

options(bit_count)           = sized(bit_count, option*);
option                       = option_eool
                             | option_nop
                             | ...
                             ;

payload(protocol, bit_count) = sized(bit_count, payload_contents(protocol) &amp; u1(0)*);
payload_contents(protocol)   = when(protocol = 0, protocol_hopopt)
                             | when(protocol = 1, protocol_icmp)
                             | ...
                             ;"><pre lang="kbnf"><code>ip_packet                    = ...
                             &amp; u4(bind(header_length, 5~)) # length is in 32-bit words
                               ...
                             &amp; u16(bind(total_length, 20~)) # length is in bytes
                               ...
                             &amp; u8(bind(protocol, registered_protocol))
                               ...
                             &amp; options((header_length-5) * 32)
                             &amp; payload(protocol, (total_length-(header_length*4)) * 8)
                             ;

options(bit_count)           = sized(bit_count, option*);
option                       = option_eool
                             | option_nop
                             | ...
                             ;

payload(protocol, bit_count) = sized(bit_count, payload_contents(protocol) &amp; u1(0)*);
payload_contents(protocol)   = when(protocol = 0, protocol_hopopt)
                             | when(protocol = 1, protocol_icmp)
                             | ...
                             ;
</code></pre></div>
<h3 dir="auto"><a id="user-content-functions" aria-hidden="true" href="#functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Functions</h3>
<p dir="auto">Functions behave similarly to macros, except that they are opaque: whereas a macro is defined within the bounds of the grammatical notation, a function&#39;s procedure is either one of the <a href="#builtin-functions">built-in functions</a>, or is user-defined in <a href="#prose">prose</a> (as a description, or as a URL pointing to a description).</p>
<p dir="auto">Functions that take no parameters are defined and called without the trailing parentheses (similar to defining or calling a <a href="#symbols">symbol</a>).</p>
<h4 dir="auto"><a id="user-content-function-parameter-and-return-types" aria-hidden="true" href="#function-parameter-and-return-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Function Parameter and Return Types</h4>
<p dir="auto">Since functions are opaque, their parameter and return <a href="#types">types</a> cannot be automatically deduced like they can for <a href="#macros">macros</a>. Functions therefore declare all parameter and return <a href="#types">types</a>. If a function is called with the wrong types or its return value is used in an incompatible context, the grammar is malformed.</p>
<p dir="auto">The following standard types are recognized:</p>
<ul dir="auto">
<li><code>expression</code></li>
<li><code>condition</code></li>
<li><code>number</code></li>
<li><code>unsigned</code></li>
<li><code>signed</code></li>
<li><code>real</code></li>
</ul>
<p dir="auto">Custom types may be invented when the standard types are insufficient (such as in the <a href="#unicode-function">unicode function</a>), provided their textual representation doesn&#39;t cause ambiguities with the KBNF document encoding.</p>
<h4 dir="auto"><a id="user-content-ranged-types" aria-hidden="true" href="#ranged-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Ranged Types</h4>
<p dir="auto">Numeric types used as parameters or return types from functions can be prepended with a tilde (<code>~</code>) to indicate that they accept <a href="#ranges">ranges</a> (such as in the <a href="#uint-function">uint</a>, <a href="#sint-function">sint</a>, and <a href="#float-function">float</a> functions).</p>
<h4 dir="auto"><a id="user-content-variadic-functions" aria-hidden="true" href="#variadic-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Variadic Functions</h4>
<p dir="auto">The last parameter in a function can be made variadic by appending <code>...</code> (such as in the <a href="#unicode-function">unicode function</a>).</p>
<div data-snippet-clipboard-copy-content="function_rule      = function &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; prose &amp; TOKEN_SEP &amp; &#39;;&#39;;
function           = function_no_args | function_with_args;
function_no_args   = identifier_restricted &amp; TOKEN_SEP &amp; type_specifier;
function_with_args = identifier_restricted
                   &amp; PARENTHESIZED(function_param &amp; (ARG_SEP &amp; function_param)*)
                   &amp; TOKEN_SEP &amp; type_specifier
                   ;
function_param     = param_name &amp; TOKEN_SEP &amp; type_specifier;
type_specifier     = &#39;:&#39; &amp; TOKEN_SEP &amp; type_alternatives &amp; (TOKEN_SEP &amp; vararg)?;
type_alternatives  = maybe_ranged_type &amp; (TOKEN_SEP &amp; &#39;|&#39; &amp; TOKEN_SEP &amp; maybe_ranged_type)*;
vararg             = &#34;...&#34;;
maybe_ranged_type  = &#39;~&#39;? &amp; (basic_type_name | custom_type_name);
basic_type_name    = &#34;expression&#34;
                   | &#34;condition&#34;
                   | &#34;number&#34;
                   | &#34;unsigned&#34;
                   | &#34;signed&#34;
                   | &#34;real&#34;
                   ;
custom_type_name   = name;"><pre lang="kbnf"><code>function_rule      = function &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; prose &amp; TOKEN_SEP &amp; &#39;;&#39;;
function           = function_no_args | function_with_args;
function_no_args   = identifier_restricted &amp; TOKEN_SEP &amp; type_specifier;
function_with_args = identifier_restricted
                   &amp; PARENTHESIZED(function_param &amp; (ARG_SEP &amp; function_param)*)
                   &amp; TOKEN_SEP &amp; type_specifier
                   ;
function_param     = param_name &amp; TOKEN_SEP &amp; type_specifier;
type_specifier     = &#39;:&#39; &amp; TOKEN_SEP &amp; type_alternatives &amp; (TOKEN_SEP &amp; vararg)?;
type_alternatives  = maybe_ranged_type &amp; (TOKEN_SEP &amp; &#39;|&#39; &amp; TOKEN_SEP &amp; maybe_ranged_type)*;
vararg             = &#34;...&#34;;
maybe_ranged_type  = &#39;~&#39;? &amp; (basic_type_name | custom_type_name);
basic_type_name    = &#34;expression&#34;
                   | &#34;condition&#34;
                   | &#34;number&#34;
                   | &#34;unsigned&#34;
                   | &#34;signed&#34;
                   | &#34;real&#34;
                   ;
custom_type_name   = name;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: A function to convert an unsigned int to its unsigned little endian base 128 representation.</p>
<div data-snippet-clipboard-copy-content="uleb128(v: unsigned): expression = &#34;&#34;&#34;https://en.wikipedia.org/wiki/LEB128#Unsigned_LEB128&#34;&#34;&#34;;"><pre lang="kbnf"><code>uleb128(v: unsigned): expression = &#34;&#34;&#34;https://en.wikipedia.org/wiki/LEB128#Unsigned_LEB128&#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: A record contains a date followed by a colon, followed by a temperature reading.</p>
<div data-snippet-clipboard-copy-content="record              = iso8601 &amp; &#39;:&#39; &amp; temperature;
iso8601: expression = &#34;&#34;&#34;https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations&#34;&#34;&#34;;
temperature         = digit+ &amp; (&#39;.&#39; &amp; digit+)?;
digit               = &#39;0&#39;~&#39;9&#39;;"><pre lang="kbnf"><code>record              = iso8601 &amp; &#39;:&#39; &amp; temperature;
iso8601: expression = &#34;&#34;&#34;https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations&#34;&#34;&#34;;
temperature         = digit+ &amp; (&#39;.&#39; &amp; digit+)?;
digit               = &#39;0&#39;~&#39;9&#39;;
</code></pre></div>
<h2 dir="auto"><a id="user-content-variables" aria-hidden="true" href="#variables"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Variables</h2>
<p dir="auto">In some contexts, resolved data (data that has already been matched) or literal values can be bound to a variable for use elsewhere. Variables are bound either manually using the <a href="#bind-function"><code>bind</code></a> builtin function, or automatically when passing parameters to a <a href="#macros">macro</a>. The variable&#39;s <a href="#types">type</a> is inferred from its provenance and where it is ultimately used (a type mismatch indicates a malformed grammar).</p>
<p dir="auto"><strong>Note</strong>: Variables cannot be re-bound.</p>
<p dir="auto">When <a href="#bind-function">binding</a> an <a href="#expressions">expression</a> that itself binds a variable, that expression&#39;s bound variables are accessible from the outer scope using dot notation (<code>this_exp_bound_value.sub_exp_bound_value</code>).</p>
<p dir="auto"><strong>Example</strong>: A document consists of a type 1 record, followed by any number of type 5, 6, and 7 records, and is terminated with a type 0 record of length 0. A record begins with a header consisting of an 8-bit type and a 16-bit big endian unsigned integer indicating how many bytes of record data follow.</p>
<div data-snippet-clipboard-copy-content="document            = record(1) &amp; (record(5) | record(6) | record(7))* &amp; terminator_record;
record(type)        = bind(header, record_header(type)) &amp; record_data(header.length);
record_header(type) = u8(type) &amp; u16(bind(length, ~));
record_data(length) = u8(~){length};
terminator_record   = u8(0) u16(0);
u8(v)               = uint(8, v);
u16(v)              = uint(16, v);"><pre lang="kbnf"><code>document            = record(1) &amp; (record(5) | record(6) | record(7))* &amp; terminator_record;
record(type)        = bind(header, record_header(type)) &amp; record_data(header.length);
record_header(type) = u8(type) &amp; u16(bind(length, ~));
record_data(length) = u8(~){length};
terminator_record   = u8(0) u16(0);
u8(v)               = uint(8, v);
u16(v)              = uint(16, v);
</code></pre></div>
<ul dir="auto">
<li>The <code>record</code> rule (a <a href="#macros">macro</a> because it takes parameters) binds the result of the <code>record_header</code> rule to a variable called <code>header</code>. This gives it access to the <code>record_header</code> <code>length</code> variable as <code>header.length</code>.</li>
<li>The <code>record_header</code> rule specifies an 8-bit type value (a variable passed in to the macro as a parameter), and binds a 16-bit integer value to a variable called <code>length</code>.</li>
<li>The <code>record_data</code> rule takes a length parameter and matches that many bytes using <a href="#repetition">repetition</a>.</li>
</ul>
<h2 dir="auto"><a id="user-content-types" aria-hidden="true" href="#types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Types</h2>
<p dir="auto">KBNF has four main types:</p>
<ul dir="auto">
<li><a href="#identifier"><code>identifier</code></a></li>
<li><a href="#expressions"><code>expression</code></a></li>
<li><a href="#conditions"><code>condition</code></a></li>
<li><a href="#numbers"><code>number</code></a>, of which there are three subtypes:
<ul dir="auto">
<li><code>unsigned</code>: limited to positive integers and 0</li>
<li><code>signed</code>: limited to positive and negative integers, and 0 (but excluding -0)</li>
<li><code>real</code>: any value from the set of reals, including <a href="#qnan-function">qnan</a> and <a href="#snan-function">snan</a> unless otherwise specified</li>
</ul>
</li>
</ul>
<p dir="auto">Types become relevant when calling <a href="#functions">functions</a> (and indirectly when calling <a href="#macros">macros</a>), which have restrictions on what types they accept and return. Also, <a href="#repetition">repetition</a> amounts are restricted to unsigned integers.</p>
<p dir="auto"><strong>Note</strong>: <code>number</code> &#34;subtypes&#34; (<code>signed</code>, <code>unsigned</code>, <code>real</code>) aren&#39;t actual types per se, but rather restrictions on what values are allowed in a particular context. <a href="#calculations">calculations</a>, for example, are done as if all operands were reals regardless of their actual &#34;subtype&#34; (subtracting two unsigned integers can give a negative result, dividing integers can result in a fraction, etc).</p>
<h3 dir="auto"><a id="user-content-identifier" aria-hidden="true" href="#identifier"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Identifier</h3>
<p dir="auto">A unique identifier for <a href="#symbols">symbols</a>, <a href="#macros">macros</a>, and <a href="#functions">functions</a> (which are all scoped globally), or <a href="#variables">variables</a> (which are scoped locally).</p>
<p dir="auto">Identifiers are case sensitive, and must be unique to their scope. Locally scoped identifiers (i.e. variable names) must be unique to <em>both</em> the local and global scope (name shadowing is not allowed).</p>
<p dir="auto">Identifiers start with a letter, and can contain letters, numbers and the underscore character. The <a href="#builtin-functions">builtin function names</a> are reserved at the global scope.</p>
<p dir="auto">The general convention is to use all uppercase identifiers for &#34;background-y&#34; things like whitespace and separators and other structural components, which makes them easier for a human to gloss over (see <a href="#the-kbnf-grammar-in-kbnf">the KBNF grammar document</a> as an example).</p>
<div data-snippet-clipboard-copy-content="identifier           = (identifier_firstchar &amp; identifier_nextchar*) ! reserved_identifiers;
identifier_firstchar = unicode(L,M);
identifier_nextchar  = identifier_firstchar | unicode(N) | &#39;_&#39;;
reserved_identifiers = &#34;sized&#34; | &#34;aligned&#34; | &#34;swapped&#34; | &#34;when&#34; | &#34;bind&#34;
                     | &#34;uint&#34; | &#34;sint&#34; | &#34;float&#34; | &#34;inf&#34; | &#34;qnan&#34; | &#34;snan&#34;
                     ;"><pre lang="kbnf"><code>identifier           = (identifier_firstchar &amp; identifier_nextchar*) ! reserved_identifiers;
identifier_firstchar = unicode(L,M);
identifier_nextchar  = identifier_firstchar | unicode(N) | &#39;_&#39;;
reserved_identifiers = &#34;sized&#34; | &#34;aligned&#34; | &#34;swapped&#34; | &#34;when&#34; | &#34;bind&#34;
                     | &#34;uint&#34; | &#34;sint&#34; | &#34;float&#34; | &#34;inf&#34; | &#34;qnan&#34; | &#34;snan&#34;
                     ;
</code></pre></div>
<h3 dir="auto"><a id="user-content-expressions" aria-hidden="true" href="#expressions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Expressions</h3>
<p dir="auto">An expression represents the set of possible bit sequences that can be produced. Expressions are non-greedy (the shortest possible interpretation of an expression will be matched first).</p>
<div data-snippet-clipboard-copy-content="expression = symbol
           | call
           | string_literal
           | maybe_ranged(codepoint_literal)
           | combination
           | builtin_functions
           | variable
           | grouped(expression)
           ;"><pre lang="kbnf"><code>expression = symbol
           | call
           | string_literal
           | maybe_ranged(codepoint_literal)
           | combination
           | builtin_functions
           | variable
           | grouped(expression)
           ;
</code></pre></div>
<h3 dir="auto"><a id="user-content-numbers" aria-hidden="true" href="#numbers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Numbers</h3>
<p dir="auto">Numbers are used in <a href="#calculations">calculations</a>, numeric <a href="#ranges">ranges</a>, and as parameters to <a href="#functions">functions</a>.</p>
<p dir="auto">Certain <a href="#functions">functions</a> take numeric parameters but restrict the allowed values (e.g. integers only, min/max value, etc).</p>
<p dir="auto">Numbers can be expressed as <a href="#numeric-literals">numeric literals</a>, or derived from <a href="#functions">functions</a>, <a href="#macros">macros</a>, and <a href="#calculations">calculations</a>.</p>
<h2 dir="auto"><a id="user-content-literals" aria-hidden="true" href="#literals"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Literals</h2>
<h3 dir="auto"><a id="user-content-numeric-literals" aria-hidden="true" href="#numeric-literals"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Numeric Literals</h3>
<p dir="auto">Numeric literals can be expressed in binary, octal, decimal, or hexadecimal notation for integers, and in decimal or hexadecimal notation for reals.</p>
<p dir="auto"><strong>Note</strong>: Decimal real notation translates more cleanly to decimal float encodings such as <a href="https://en.wikipedia.org/wiki/Decimal64_floating-point_format" rel="nofollow">ieee754 decimal</a>, and hexadecimal real notation translates more cleanly to binary float encodings such as <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="nofollow">ieee754 binary</a>.</p>
<p dir="auto">Conversions from literal reals to floating point encodings that differ in base are assumed to follow the generally accepted algorithms for such conversions (e.g. <code>Grisu</code>, <code>std::strtod</code>).</p>
<div data-snippet-clipboard-copy-content="number_literal       = int_literal_bin | int_literal_oct | int_real_literal_dec | int_real_literal_hex;
int_real_literal_dec = neg? digit_dec+
                     &amp; (&#39;.&#39; &amp; digit_dec+ &amp; ((&#39;e&#39; | &#39;E&#39;) (&#39;+&#39; | &#39;-&#39;)? &amp; digit_dec+)?)?
                     ;
int_real_literal_hex = neg? &amp; &#39;0&#39; &amp; (&#39;x&#39; | &#39;X&#39;) &amp; digit_hex+
                     &amp; (&#39;.&#39; &amp; digit_hex+ &amp; ((&#39;p&#39; | &#39;P&#39;) &amp; (&#39;+&#39; | &#39;-&#39;)? &amp; digit_dec+)?)?
                     ;
int_literal_bin      = neg? &amp; &#39;0&#39; &amp; (&#39;b&#39; | &#39;B&#39;) &amp; digit_bin+;
int_literal_oct      = neg? &amp; &#39;0&#39; &amp; (&#39;o&#39; | &#39;O&#39;) &amp; digit_oct+;
neg                  = &#39;-&#39;;"><pre lang="kbnf"><code>number_literal       = int_literal_bin | int_literal_oct | int_real_literal_dec | int_real_literal_hex;
int_real_literal_dec = neg? digit_dec+
                     &amp; (&#39;.&#39; &amp; digit_dec+ &amp; ((&#39;e&#39; | &#39;E&#39;) (&#39;+&#39; | &#39;-&#39;)? &amp; digit_dec+)?)?
                     ;
int_real_literal_hex = neg? &amp; &#39;0&#39; &amp; (&#39;x&#39; | &#39;X&#39;) &amp; digit_hex+
                     &amp; (&#39;.&#39; &amp; digit_hex+ &amp; ((&#39;p&#39; | &#39;P&#39;) &amp; (&#39;+&#39; | &#39;-&#39;)? &amp; digit_dec+)?)?
                     ;
int_literal_bin      = neg? &amp; &#39;0&#39; &amp; (&#39;b&#39; | &#39;B&#39;) &amp; digit_bin+;
int_literal_oct      = neg? &amp; &#39;0&#39; &amp; (&#39;o&#39; | &#39;O&#39;) &amp; digit_oct+;
neg                  = &#39;-&#39;;
</code></pre></div>
<p dir="auto"><strong>Examples</strong>:</p>
<div data-snippet-clipboard-copy-content="header_signature = uint(5, 0b10111);
ascii_char_8bit  = uint(8, 0x00~0x7f);
tolerance        = float(32, -1.5~1.5);"><pre lang="kbnf"><code>header_signature = uint(5, 0b10111);
ascii_char_8bit  = uint(8, 0x00~0x7f);
tolerance        = float(32, -1.5~1.5);
</code></pre></div>
<h3 dir="auto"><a id="user-content-codepoints" aria-hidden="true" href="#codepoints"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Codepoints</h3>
<p dir="auto">Codepoints can be represented as literals, <a href="#ranges">ranges</a>, and <a href="#unicode-function">category sets</a>. Codepoint literals are placed between single or double quotes.</p>
<p dir="auto">Expressing codepoint literals as a <a href="#ranges">range</a> causes every codepoint in the range to be added as an <a href="#alternative">alternative</a>.</p>
<div data-snippet-clipboard-copy-content="codepoint_literal = &#39;&#34;&#39; &amp; maybe_escaped(printable_ws ! &#39;&#34;&#39;){1} &amp; &#39;&#34;&#39;
                  | &#34;&#39;&#34; &amp; maybe_escaped(printable_ws ! &#34;&#39;&#34;){1} &amp; &#34;&#39;&#34;
                  ;"><pre lang="kbnf"><code>codepoint_literal = &#39;&#34;&#39; &amp; maybe_escaped(printable_ws ! &#39;&#34;&#39;){1} &amp; &#39;&#34;&#39;
                  | &#34;&#39;&#34; &amp; maybe_escaped(printable_ws ! &#34;&#39;&#34;){1} &amp; &#34;&#39;&#34;
                  ;
</code></pre></div>
<p dir="auto"><strong>Examples</strong>:</p>
<div data-snippet-clipboard-copy-content="letter_a     = &#39;a&#39;;     # or &#34;a&#34;
a_to_c       = &#39;a&#39;~&#39;c&#39;; # or &#34;a&#34;~&#34;c&#34;, or &#39;a&#39; | &#39;b&#39; | &#39;c&#39;, or &#34;a&#34; | &#34;b&#34; | &#34;c&#34;
alphanumeric = unicode(L,N);"><pre lang="kbnf"><code>letter_a     = &#39;a&#39;;     # or &#34;a&#34;
a_to_c       = &#39;a&#39;~&#39;c&#39;; # or &#34;a&#34;~&#34;c&#34;, or &#39;a&#39; | &#39;b&#39; | &#39;c&#39;, or &#34;a&#34; | &#34;b&#34; | &#34;c&#34;
alphanumeric = unicode(L,N);
</code></pre></div>
<h3 dir="auto"><a id="user-content-strings" aria-hidden="true" href="#strings"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Strings</h3>
<p dir="auto">A string is syntactic sugar for a series of specific <a href="#codepoints">codepoints</a> <a href="#concatenation">concatenated</a> together. String literals are placed between single or double quotes.</p>
<div data-snippet-clipboard-copy-content="string_literal = &#39;&#34;&#39; &amp; maybe_escaped(printable_ws ! &#39;&#34;&#39;){2~} &amp; &#39;&#34;&#39;
               | &#34;&#39;&#34; &amp; maybe_escaped(printable_ws ! &#34;&#39;&#34;){2~} &amp; &#34;&#39;&#34;
               ;"><pre lang="kbnf"><code>string_literal = &#39;&#34;&#39; &amp; maybe_escaped(printable_ws ! &#39;&#34;&#39;){2~} &amp; &#39;&#34;&#39;
               | &#34;&#39;&#34; &amp; maybe_escaped(printable_ws ! &#34;&#39;&#34;){2~} &amp; &#34;&#39;&#34;
               ;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: The following are all equivalent:</p>
<div data-snippet-clipboard-copy-content="str_abc_1 = &#34;abc&#34;;
str_abc_2 = &#39;abc&#39;;
str_abc_3 = &#34;a&#34; &amp; &#34;b&#34; &amp; &#34;c&#34;;
str_abc_4 = &#39;a&#39; &amp; &#39;b&#39; &amp; &#39;c&#39;;"><pre lang="kbnf"><code>str_abc_1 = &#34;abc&#34;;
str_abc_2 = &#39;abc&#39;;
str_abc_3 = &#34;a&#34; &amp; &#34;b&#34; &amp; &#34;c&#34;;
str_abc_4 = &#39;a&#39; &amp; &#39;b&#39; &amp; &#39;c&#39;;
</code></pre></div>
<h3 dir="auto"><a id="user-content-escape-sequence" aria-hidden="true" href="#escape-sequence"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Escape Sequence</h3>
<p dir="auto"><a href="#codepoints">Codepoint literals</a>, <a href="#strings">string literals</a>, and <a href="#prose">prose</a> may contain codepoint escape sequences to represent troublesome codepoints.</p>
<p dir="auto">Escape sequences are initiated with the backslash (<code>\</code>) character. If the next character following is an open square brace (<code>[</code>), it begins a <a href="#codepoint-escape">codepoint escape</a>. Otherwise the sequence represents that literal character.</p>
<div data-snippet-clipboard-copy-content="escape_sequence = &#39;\\&#39; &amp; (printable ! &#39;[&#39;) | codepoint_escape);"><pre lang="kbnf"><code>escape_sequence = &#39;\\&#39; &amp; (printable ! &#39;[&#39;) | codepoint_escape);
</code></pre></div>
<p dir="auto"><strong>Example</strong>: A string containing double quotes.</p>
<div data-snippet-clipboard-copy-content="mystr = &#34;This is a \&#34;string\&#34;&#34;; # or you could use single quotes: &#39;This is a &#34;string&#34;&#39;"><pre lang="kbnf"><code>mystr = &#34;This is a \&#34;string\&#34;&#34;; # or you could use single quotes: &#39;This is a &#34;string&#34;&#39;
</code></pre></div>
<h4 dir="auto"><a id="user-content-codepoint-escape" aria-hidden="true" href="#codepoint-escape"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Codepoint Escape</h4>
<p dir="auto">A codepoint escape interprets the hex digits between the sequence <code>\[</code> and <code>]</code> as the hexadecimal numeric value of the codepoint being referred to.</p>
<div data-snippet-clipboard-copy-content="codepoint_escape = &#39;[&#39; &amp; digit_hex+ &amp; &#39;]&#39;;"><pre lang="kbnf"><code>codepoint_escape = &#39;[&#39; &amp; digit_hex+ &amp; &#39;]&#39;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Emoji</p>
<div data-snippet-clipboard-copy-content="mystr = &#34;This is a \[1f415]&#34;; # &#34;This is a 🐕&#34;"><pre lang="kbnf"><code>mystr = &#34;This is a \[1f415]&#34;; # &#34;This is a 🐕&#34;
</code></pre></div>
<h3 dir="auto"><a id="user-content-prose" aria-hidden="true" href="#prose"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Prose</h3>
<p dir="auto">Prose is meant as a last resort in attempting to describe something. If it has already been described elsewhere, you could put a URL in here. Otherise you could put in a natural language description.</p>
<div data-snippet-clipboard-copy-content="prose = &#39;&#34;&#34;&#34;&#39; &amp; (maybe_escaped(printable_wsl)+ ! &#39;&#34;&#34;&#34;&#39;) &amp; &#39;&#34;&#34;&#34;&#39;
      | &#34;&#39;&#39;&#39;&#34; &amp; (maybe_escaped(printable_wsl)+ ! &#34;&#39;&#39;&#39;&#34;) &amp; &#34;&#39;&#39;&#39;&#34;
      ;"><pre lang="kbnf"><code>prose = &#39;&#34;&#34;&#34;&#39; &amp; (maybe_escaped(printable_wsl)+ ! &#39;&#34;&#34;&#34;&#39;) &amp; &#39;&#34;&#34;&#34;&#39;
      | &#34;&#39;&#39;&#39;&#34; &amp; (maybe_escaped(printable_wsl)+ ! &#34;&#39;&#39;&#39;&#34;) &amp; &#34;&#39;&#39;&#39;&#34;
      ;
</code></pre></div>
<p dir="auto"><strong>Note</strong>: Prose can only be used to define a <a href="#functions">function</a> because it is by nature opaque; the function definition will assign types.</p>
<p dir="auto"><strong>Example</strong>: A record contains a date and temperature separated by <code>:</code>, followed by a newline, followed by a flowery description of any length in iambic pentameter (newlines allowed), terminated by <code>=====</code> on its own line.</p>
<div data-snippet-clipboard-copy-content="record              = date &amp; &#39;:&#39; &amp; temperature &amp; LF &amp; flowery_description &amp; LF &amp; &#39;=====&#39; &amp; LF;
date                = &#34;&#34;&#34;YYYY-MM-DD, per https://en.wikipedia.org/wiki/ISO_8601#Calendar_dates&#34;&#34;&#34;;
temperature         = digit+ &amp; (&#39;.&#39; &amp; digit+)?;
digit               = &#39;0&#39;~&#39;9&#39;;
flowery_description: expression = &#34;&#34;&#34;
A poetic description of the weather, written in iambic pentameter. For example:

While barred clouds bloom the soft-dying day,
And touch the stubble-plains with rosy hue;
Then in a wailful choir the small gnats mourn
Among the river sallows, borne aloft
Or sinking as the light wind lives or dies.
&#34;&#34;&#34;;"><pre lang="kbnf"><code>record              = date &amp; &#39;:&#39; &amp; temperature &amp; LF &amp; flowery_description &amp; LF &amp; &#39;=====&#39; &amp; LF;
date                = &#34;&#34;&#34;YYYY-MM-DD, per https://en.wikipedia.org/wiki/ISO_8601#Calendar_dates&#34;&#34;&#34;;
temperature         = digit+ &amp; (&#39;.&#39; &amp; digit+)?;
digit               = &#39;0&#39;~&#39;9&#39;;
flowery_description: expression = &#34;&#34;&#34;
A poetic description of the weather, written in iambic pentameter. For example:

While barred clouds bloom the soft-dying day,
And touch the stubble-plains with rosy hue;
Then in a wailful choir the small gnats mourn
Among the river sallows, borne aloft
Or sinking as the light wind lives or dies.
&#34;&#34;&#34;;
</code></pre></div>
<h2 dir="auto"><a id="user-content-combinations" aria-hidden="true" href="#combinations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Combinations</h2>
<p dir="auto">Combinations combine expressions together into more powerful expressions.</p>
<p dir="auto">Combination precedence (low to high):</p>
<ul dir="auto">
<li><a href="#alternative">Alternative</a></li>
<li><a href="#exclusion">Exclusion</a></li>
<li><a href="#concatenation">Concatenation</a></li>
<li><a href="#repetition">Repetition</a></li>
</ul>
<h3 dir="auto"><a id="user-content-concatenation" aria-hidden="true" href="#concatenation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Concatenation</h3>
<p dir="auto">The concatenation combination produces an expression consisting of the expression on the left, followed by the expression on the right (both must match in their proper order for the combined expression to match). The operator symbol is <code>&amp;</code> (think of it as meaning &#34;x and then y&#34;).</p>
<div data-snippet-clipboard-copy-content="concatenate = expression &amp; TOKEN_SEP &amp; &#39;&amp;&#39; &amp; TOKEN_SEP &amp; expression;"><pre lang="kbnf"><code>concatenate = expression &amp; TOKEN_SEP &amp; &#39;&amp;&#39; &amp; TOKEN_SEP &amp; expression;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Assignment consists of an identifier, at least one space, an equals sign, at least one space, and then an integer value, followed by a linefeed.</p>
<div data-snippet-clipboard-copy-content="assignment = &#34;a&#34;~&#34;z&#34;+ 
           &amp; &#34; &#34;+
           &amp; &#34;=&#34;
           &amp; &#34; &#34;+
           &amp; &#34;0&#34;~&#34;9&#34;+
           &amp; &#34;\[a]&#34;
           ;"><pre lang="kbnf"><code>assignment = &#34;a&#34;~&#34;z&#34;+ 
           &amp; &#34; &#34;+
           &amp; &#34;=&#34;
           &amp; &#34; &#34;+
           &amp; &#34;0&#34;~&#34;9&#34;+
           &amp; &#34;\[a]&#34;
           ;
</code></pre></div>
<h3 dir="auto"><a id="user-content-alternative" aria-hidden="true" href="#alternative"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Alternative</h3>
<p dir="auto">The alternative combination produces an expression that can match either the expression on the left or the expression on the right.</p>
<p dir="auto">Alternatives are separated by a pipe (<code>|</code>) character. Only one of the alternative branches will be taken.</p>
<div data-snippet-clipboard-copy-content="alternate = expression &amp; TOKEN_SEP &amp; &#39;|&#39; &amp; TOKEN_SEP &amp; expression;"><pre lang="kbnf"><code>alternate = expression &amp; TOKEN_SEP &amp; &#39;|&#39; &amp; TOKEN_SEP &amp; expression;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Addition or subtraction consists of an identifier, at least one space, a plus or minus sign, at least one space, and then another identifier, followed by a linefeed.</p>
<div data-snippet-clipboard-copy-content="caculation = &#34;a&#34;~&#34;z&#34;+
           &amp; &#34; &#34;+
           &amp; (&#34;+&#34; | &#34;-&#34;)
           &amp; &#34; &#34;+
           &amp; &#34;a&#34;~&#34;z&#34;+
           &amp; &#34;\[a]&#34;
           ;"><pre lang="kbnf"><code>caculation = &#34;a&#34;~&#34;z&#34;+
           &amp; &#34; &#34;+
           &amp; (&#34;+&#34; | &#34;-&#34;)
           &amp; &#34; &#34;+
           &amp; &#34;a&#34;~&#34;z&#34;+
           &amp; &#34;\[a]&#34;
           ;
</code></pre></div>
<h3 dir="auto"><a id="user-content-exclusion" aria-hidden="true" href="#exclusion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Exclusion</h3>
<p dir="auto">Exclusion removes an expression from the set of expression alternatives.</p>
<div data-snippet-clipboard-copy-content="exclude = expression &amp; TOKEN_SEP &amp; &#39;!&#39; &amp; TOKEN_SEP &amp; expression;"><pre lang="kbnf"><code>exclude = expression &amp; TOKEN_SEP &amp; &#39;!&#39; &amp; TOKEN_SEP &amp; expression;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: An identifier can be any lowercase ASCII string except &#34;fred&#34;.</p>
<div data-snippet-clipboard-copy-content="identifier = &#34;a&#34;~&#34;z&#34;+ ! &#34;fred&#34;;"><pre lang="kbnf"><code>identifier = &#34;a&#34;~&#34;z&#34;+ ! &#34;fred&#34;;
</code></pre></div>
<h3 dir="auto"><a id="user-content-repetition" aria-hidden="true" href="#repetition"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Repetition</h3>
<p dir="auto">&#34;Repetition&#34; is a bit of a misnomer, because it actually defines how many times an expression occurs, not how many times it repeats. Repetition amounts can be defined as a <a href="#ranges">range</a> or as a discrete amount. Think of repetition as &#34;this <a href="#expressions">expression</a>, <a href="#concatenation">concatenated</a> together for this range of occurrences&#34;.</p>
<p dir="auto">The repetition amount is an unsigned integer, appended to an expression as a discrete amount or <a href="#ranges">range</a> between curly braces (e.g. <code>{10}</code> or <code>{1~5}</code>). There are also shorthand notations for common cases:</p>
<ul dir="auto">
<li><code>?</code>: Zero or one (equivalent to <code>{0~1}</code>)</li>
<li><code>*</code>: Zero or more (equivalent to <code>{0~}</code>)</li>
<li><code>+</code>: One or more (equivalent to <code>{1~}</code>)</li>
</ul>
<div data-snippet-clipboard-copy-content="repetition          = repeat_range | repeat_zero_or_one | repeat_zero_or_more | repeat_one_or_more;
repeat_range        = expression &amp; &#39;{&#39; &amp; TOKEN_SEP &amp; maybe_ranged(number) &amp; TOKEN_SEP &amp; &#39;}&#39;;
repeat_zero_or_one  = expression &amp; &#39;?&#39;;
repeat_zero_or_more = expression &amp; &#39;*&#39;;
repeat_one_or_more  = expression &amp; &#39;+&#39;;"><pre lang="kbnf"><code>repetition          = repeat_range | repeat_zero_or_one | repeat_zero_or_more | repeat_one_or_more;
repeat_range        = expression &amp; &#39;{&#39; &amp; TOKEN_SEP &amp; maybe_ranged(number) &amp; TOKEN_SEP &amp; &#39;}&#39;;
repeat_zero_or_one  = expression &amp; &#39;?&#39;;
repeat_zero_or_more = expression &amp; &#39;*&#39;;
repeat_one_or_more  = expression &amp; &#39;+&#39;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: An identifier is 5, 6, 7, or 8 characters long, and is made up of characters from &#39;a&#39; to &#39;z&#39;.</p>
<div data-snippet-clipboard-copy-content="identifier = &#39;a&#39;~&#39;z&#39;{5~8};"><pre lang="kbnf"><code>identifier = &#39;a&#39;~&#39;z&#39;{5~8};
</code></pre></div>
<p dir="auto"><strong>Example</strong>: An identifier must start with at least one uppercase ASCII letter, optionally followed by any number of lowercase ASCII letters, and optionally suffixed with an underscore.</p>
<div data-snippet-clipboard-copy-content="identifier = &#39;A&#39;~&#39;Z&#39;+ &amp; &#39;a&#39;~&#39;z&#39;* &amp; &#39;_&#39;?;"><pre lang="kbnf"><code>identifier = &#39;A&#39;~&#39;Z&#39;+ &amp; &#39;a&#39;~&#39;z&#39;* &amp; &#39;_&#39;?;
</code></pre></div>
<h2 dir="auto"><a id="user-content-grouping" aria-hidden="true" href="#grouping"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Grouping</h2>
<p dir="auto"><a href="#expressions">Expressions</a>, <a href="#calculations">calculations</a> and <a href="#conditions">conditions</a> can be grouped in order to override the default precedence, or as a visual aid to make things more readable. To group, place the items between parentheses.</p>
<div data-snippet-clipboard-copy-content="grouped(item)       = PARENTHESIZED(item);
PARENTHESIZED(item) = &#39;(&#39; &amp; TOKEN_SEP item TOKEN_SEP &amp; &#39;)&#39;;"><pre lang="kbnf"><code>grouped(item)       = PARENTHESIZED(item);
PARENTHESIZED(item) = &#39;(&#39; &amp; TOKEN_SEP item TOKEN_SEP &amp; &#39;)&#39;;
</code></pre></div>
<p dir="auto"><strong>Exmples</strong>:</p>
<div data-snippet-clipboard-copy-content="my_rule         = (&#39;a&#39; | &#39;b&#39;) &amp; (&#39;x&#39; | &#39;y&#39;);
my_macro1(a)    = uint(8, (a + 5) * 2);
my_macro2(a, b) = when( (a &lt; 10 | a &gt; 20) &amp; (b &lt; 10 | b &gt; 20), &#34;abc&#34; )
                | &#34;def&#34;
                ;"><pre lang="kbnf"><code>my_rule         = (&#39;a&#39; | &#39;b&#39;) &amp; (&#39;x&#39; | &#39;y&#39;);
my_macro1(a)    = uint(8, (a + 5) * 2);
my_macro2(a, b) = when( (a &lt; 10 | a &gt; 20) &amp; (b &lt; 10 | b &gt; 20), &#34;abc&#34; )
                | &#34;def&#34;
                ;
</code></pre></div>
<h2 dir="auto"><a id="user-content-calculations" aria-hidden="true" href="#calculations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Calculations</h2>
<p dir="auto">Calculations perform arithmetic operations on <a href="#numbers">numbers</a>, producing a new number. All operands are treated as <a href="#types">reals</a> for the purpose of the calculation.</p>
<p dir="auto">The following operations can be used:</p>
<ul dir="auto">
<li>Add (<code>+</code>)</li>
<li>Subtract (<code>-</code>)</li>
<li>Multiply (<code>*</code>)</li>
<li>Divide (<code>/</code>)</li>
<li>Modulus (<code>%</code>)</li>
<li>Power (<code>^</code>, where <code>x^y</code> means x to the power of y)</li>
<li>Negation (&#39;-&#39;)</li>
</ul>
<p dir="auto"><strong>Note</strong>: Calculations can produce a <a href="#qnan-function">quiet NaN</a> value under <a href="https://en.wikipedia.org/wiki/NaN#Operations_generating_NaN" rel="nofollow">certain conditions in accordiance with the IEEE 754 specification</a>. If different processing is required (such as traps or exceptions), this must be documented in your specification.</p>
<p dir="auto">Operator precedence (low to high):</p>
<ul dir="auto">
<li>add, subtract</li>
<li>multiply, divide, modulus</li>
<li>power</li>
<li>negation</li>
</ul>
<div data-snippet-clipboard-copy-content="number       = calc_add | calc_sub | calc_mul_div;
calc_mul_div = calc_mul | calc_div | calc_mod | calc_pow_neg;
calc_pow_neg = calc_pow | calc_neg_val;
calc_neg_val = calc_neg | calc_val;
calc_val     = number_literal | variable | maybe_grouped(number);
calc_add     = number &amp; TOKEN_SEP &amp; &#39;+&#39; &amp; TOKEN_SEP &amp; calc_mul_div;
calc_sub     = number &amp; TOKEN_SEP &amp; &#39;-&#39; &amp; TOKEN_SEP &amp; calc_mul_div;
calc_mul     = calc_mul_div &amp; TOKEN_SEP &amp; &#39;*&#39; &amp; TOKEN_SEP &amp; calc_pow_val;
calc_div     = calc_mul_div &amp; TOKEN_SEP &amp; &#39;/&#39; &amp; TOKEN_SEP &amp; calc_pow_val;
calc_mod     = calc_mul_div &amp; TOKEN_SEP &amp; &#39;%&#39; &amp; TOKEN_SEP &amp; calc_pow_val;
calc_pow     = calc_pow_val &amp; TOKEN_SEP &amp; &#39;^&#39; &amp; TOKEN_SEP &amp; calc_neg_val;
calc_neg     = &#39;-&#39; &amp; calc_val;"><pre lang="kbnf"><code>number       = calc_add | calc_sub | calc_mul_div;
calc_mul_div = calc_mul | calc_div | calc_mod | calc_pow_neg;
calc_pow_neg = calc_pow | calc_neg_val;
calc_neg_val = calc_neg | calc_val;
calc_val     = number_literal | variable | maybe_grouped(number);
calc_add     = number &amp; TOKEN_SEP &amp; &#39;+&#39; &amp; TOKEN_SEP &amp; calc_mul_div;
calc_sub     = number &amp; TOKEN_SEP &amp; &#39;-&#39; &amp; TOKEN_SEP &amp; calc_mul_div;
calc_mul     = calc_mul_div &amp; TOKEN_SEP &amp; &#39;*&#39; &amp; TOKEN_SEP &amp; calc_pow_val;
calc_div     = calc_mul_div &amp; TOKEN_SEP &amp; &#39;/&#39; &amp; TOKEN_SEP &amp; calc_pow_val;
calc_mod     = calc_mul_div &amp; TOKEN_SEP &amp; &#39;%&#39; &amp; TOKEN_SEP &amp; calc_pow_val;
calc_pow     = calc_pow_val &amp; TOKEN_SEP &amp; &#39;^&#39; &amp; TOKEN_SEP &amp; calc_neg_val;
calc_neg     = &#39;-&#39; &amp; calc_val;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: A record begins with a 4-bit length field (length is in 32-bit increments) and 4-bit flags field containing (...), followed by the contents of the record.</p>
<div data-snippet-clipboard-copy-content="record = uint(4, bind(length, ~)) &amp; flags &amp; uint(8, ~){length*4};
flags  = ..."><pre lang="kbnf"><code>record = uint(4, bind(length, ~)) &amp; flags &amp; uint(8, ~){length*4};
flags  = ...
</code></pre></div>
<h2 dir="auto"><a id="user-content-conditions" aria-hidden="true" href="#conditions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Conditions</h2>
<p dir="auto">Conditions are produced by comparing <a href="#numbers">numbers</a>, and by performing logical operations on those comparisons, resulting in either true or false. Conditions are used in <a href="#when-function"><code>when</code></a> calls, and can be <a href="#grouping">grouped</a>.</p>
<p dir="auto">Comparisons:</p>
<ul dir="auto">
<li>Less than (<code>&lt;</code>)</li>
<li>Less than or equal to (<code>&lt;=</code>)</li>
<li>Equal to (<code>=</code>)</li>
<li>Greater than or equal to (<code>&gt;=</code>)</li>
<li>Greater than (<code>&gt;</code>)</li>
</ul>
<p dir="auto">Logical operations:</p>
<ul dir="auto">
<li>And (<code>&amp;</code>)</li>
<li>Or (<code>|</code>)</li>
<li>Not (<code>!</code>), which is a unary operator</li>
</ul>
<p dir="auto">Condition precedence (low to high):</p>
<ul dir="auto">
<li>comparisons</li>
<li>logical or</li>
<li>logical and</li>
<li>logical not</li>
</ul>
<div data-snippet-clipboard-copy-content="condition          = comparison | logical_op;
logical_op         = logical_or | logical_op_and_not;
logical_op_and_not = logical_and | logical_op_not;
logical_op_not     = logical_not | maybe_grouped(condition);
comparison         = number &amp; TOKEN_SEP &amp; comparator &amp; TOKEN_SEP &amp; number;
comparator         = &#34;&lt;&#34; | &#34;&lt;=&#34; | &#34;=&#34; | &#34;&gt;= | &#34;&gt;&#34;;
logical_or         = condition &amp; TOKEN_SEP &amp; &#39;|&#39; &amp; TOKEN_SEP &amp; condition;
logical_and        = condition &amp; TOKEN_SEP &amp; &#39;&amp;&#39; &amp; TOKEN_SEP &amp; condition;
logical_not        = &#39;!&#39; &amp; TOKEN_SEP &amp; condition;"><pre lang="kbnf"><code>condition          = comparison | logical_op;
logical_op         = logical_or | logical_op_and_not;
logical_op_and_not = logical_and | logical_op_not;
logical_op_not     = logical_not | maybe_grouped(condition);
comparison         = number &amp; TOKEN_SEP &amp; comparator &amp; TOKEN_SEP &amp; number;
comparator         = &#34;&lt;&#34; | &#34;&lt;=&#34; | &#34;=&#34; | &#34;&gt;= | &#34;&gt;&#34;;
logical_or         = condition &amp; TOKEN_SEP &amp; &#39;|&#39; &amp; TOKEN_SEP &amp; condition;
logical_and        = condition &amp; TOKEN_SEP &amp; &#39;&amp;&#39; &amp; TOKEN_SEP &amp; condition;
logical_not        = &#39;!&#39; &amp; TOKEN_SEP &amp; condition;
</code></pre></div>
<p dir="auto"><strong>Example</strong>:</p>
<div data-snippet-clipboard-copy-content="record       = uint(8, bind(type, 1~))
             &amp; ( when(type = 1, type_1)
               | when(type = 2, type_2)
               | when(type &gt; 2, type_default)
               )
             ;
type_1       = ...
type_2       = ...
type_default = ..."><pre lang="kbnf"><code>record       = uint(8, bind(type, 1~))
             &amp; ( when(type = 1, type_1)
               | when(type = 2, type_2)
               | when(type &gt; 2, type_default)
               )
             ;
type_1       = ...
type_2       = ...
type_default = ...
</code></pre></div>
<h2 dir="auto"><a id="user-content-ranges" aria-hidden="true" href="#ranges"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Ranges</h2>
<p dir="auto">A range consists of one of the following:</p>
<ul dir="auto">
<li>A low value and a high value separated by a tilde (low ~ high), indicating a (closed interval) low and high bound.</li>
<li>A low value followed by a tilde (low ~), indicating a low bound only.</li>
<li>A tilde followed by a high value (~ high), indicating a high bound only.</li>
<li>A tilde by itself (~), indicating no bound.</li>
<li>A value with no tilde, restricting the &#34;range&#34; to only that value.</li>
</ul>
<p dir="auto">A <a href="#codepoints">codepoint</a> range represents the set of each codepoint in the range as <a href="#alternative">alternatves</a>.</p>
<p dir="auto">A <a href="#repetition">repetition</a> range represents a range in the number of occurrences that will match the rule.</p>
<p dir="auto">A <a href="#numbers">number</a> range will ultimately be passed to a context requiring a specific <a href="#types">subtype</a> (such as <a href="#repetition">repetition</a>, <a href="#uint-function">uint</a>, <a href="#sint-function">sint</a>, <a href="#float-function">float</a>), and will thus represent each value in the range (for all discrete values that are representable by the <a href="#types">subtype</a>) as <a href="#alternative">alternatves</a>.</p>
<p dir="auto"><strong>Notes</strong>:</p>
<ul dir="auto">
<li><a href="#qnan-function">Quiet NaN</a> and <a href="#snan-function">signaling NaN</a> values are <strong>never</strong> included in the set of reals returned by a <a href="#ranges">range</a> (e.g. <code>float(64,~)</code>, <code>float(64,0~)</code>, <code>float(64,~0)</code> etc do <strong>not</strong> include <code>float(64,qnan)</code> or <code>float(64,snan)</code>).</li>
<li>The concept of negative zero (<code>-0</code>) <em>is</em> included in the set returned by any range that crosses out of negative values.</li>
</ul>
<div data-snippet-clipboard-copy-content="expression         = ...
                   | maybe_ranged(codepoint_literal)
                   | ...
                   ;
repeat_range       = expression &amp; &#39;{&#39; &amp; TOKEN_SEP &amp; maybe_ranged(number) &amp; TOKEN_SEP &amp; &#39;}&#39;;
function_uint      = fname_uint &amp; PARENTHESIZED(bit_count &amp; ARG_SEP &amp; maybe_ranged(number));
function_sint      = fname_sint &amp; PARENTHESIZED(bit_count &amp; ARG_SEP &amp; maybe_ranged(number));
function_float     = fname_float &amp; PARENTHESIZED(bit_count &amp; ARG_SEP &amp; maybe_ranged(number));
ranged(item)       = (item &amp; TOKEN_SEP)? &amp; &#39;~&#39; &amp; (TOKEN_SEP &amp; item)?;
maybe_ranged(item) = item | ranged(item);"><pre lang="kbnf"><code>expression         = ...
                   | maybe_ranged(codepoint_literal)
                   | ...
                   ;
repeat_range       = expression &amp; &#39;{&#39; &amp; TOKEN_SEP &amp; maybe_ranged(number) &amp; TOKEN_SEP &amp; &#39;}&#39;;
function_uint      = fname_uint &amp; PARENTHESIZED(bit_count &amp; ARG_SEP &amp; maybe_ranged(number));
function_sint      = fname_sint &amp; PARENTHESIZED(bit_count &amp; ARG_SEP &amp; maybe_ranged(number));
function_float     = fname_float &amp; PARENTHESIZED(bit_count &amp; ARG_SEP &amp; maybe_ranged(number));
ranged(item)       = (item &amp; TOKEN_SEP)? &amp; &#39;~&#39; &amp; (TOKEN_SEP &amp; item)?;
maybe_ranged(item) = item | ranged(item);
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Codepoint range.</p>
<div data-snippet-clipboard-copy-content="hex_digit = (&#39;0&#39;~&#39;9&#39; | &#39;a&#39;~&#39;f&#39;);"><pre lang="kbnf"><code>hex_digit = (&#39;0&#39;~&#39;9&#39; | &#39;a&#39;~&#39;f&#39;);
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Repetition range: A name field contains between 1 and 100 characters.</p>
<div data-snippet-clipboard-copy-content="name_field = unicode(L,M,N,P,S){1~100};"><pre lang="kbnf"><code>name_field = unicode(L,M,N,P,S){1~100};
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Number range: The RPM value is an unsigned 16 bit big endian integer from 0 to 1000.</p>
<div data-snippet-clipboard-copy-content="rpm = uint(16, ~1000); # It&#39;s a uint, so already limited to 0~"><pre lang="kbnf"><code>rpm = uint(16, ~1000); # It&#39;s a uint, so already limited to 0~
</code></pre></div>
<h2 dir="auto"><a id="user-content-comments" aria-hidden="true" href="#comments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Comments</h2>
<p dir="auto">A comment begins with a hash char (<code>#</code>) and continues to the end of the current line. Comments can be placed after pretty much any token.</p>
<div data-snippet-clipboard-copy-content="comment = &#39;#&#39; &amp; (printable_ws ! LINE_END)* &amp; LINE_END;"><pre lang="kbnf"><code>comment = &#39;#&#39; &amp; (printable_ws ! LINE_END)* &amp; LINE_END;
</code></pre></div>
<p dir="auto"><strong>Example</strong>:</p>
<div data-snippet-clipboard-copy-content="kbnf_v1 utf-8
- identifier = mygrammar_v1
- description = My first grammar

# This is the first place where a comment can exist.
myrule # comment
 = # comment
 myexpression # comment
 ; # comment
# comment"><pre lang="kbnf"><code>kbnf_v1 utf-8
- identifier = mygrammar_v1
- description = My first grammar

# This is the first place where a comment can exist.
myrule # comment
 = # comment
 myexpression # comment
 ; # comment
# comment
</code></pre></div>
<h2 dir="auto"><a id="user-content-builtin-functions" aria-hidden="true" href="#builtin-functions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Builtin Functions</h2>
<p dir="auto">KBNF comes with some fundamental functions built-in:</p>
<h3 dir="auto"><a id="user-content-sized-function" aria-hidden="true" href="#sized-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>sized</code> Function</h3>
<div data-snippet-clipboard-copy-content="sized(bit_count: unsigned, expr: expression): expression =
    &#34;&#34;&#34;
    Requires that `expr` produce exactly `bit_count` bits.
    Expressions containing repetition that would have matched on their own are
    no longer sufficient until the production fills exactly `bit_count` bits.
    &#34;&#34;&#34;;"><pre lang="kbnf"><code>sized(bit_count: unsigned, expr: expression): expression =
    &#34;&#34;&#34;
    Requires that `expr` produce exactly `bit_count` bits.
    Expressions containing repetition that would have matched on their own are
    no longer sufficient until the production fills exactly `bit_count` bits.
    &#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: A name field must contain exactly 200 bytes worth of character data, padded with spaces as needed.</p>
<div data-snippet-clipboard-copy-content="name_field = sized(200*8, unicode(L,M,N,P,Zs)* &amp; &#39; &#39;*);"><pre lang="kbnf"><code>name_field = sized(200*8, unicode(L,M,N,P,Zs)* &amp; &#39; &#39;*);
</code></pre></div>
<p dir="auto">Technically, the <code>&amp; &#39; &#39;*</code> part is superfluous since Unicode category <code>Zs</code> already includes space, but it helps readability to highlight how to pad the field. One could even be more explicit:</p>
<div data-snippet-clipboard-copy-content="name_field    = sized(200*8, unicode(L,M,N,P,Zs)* &amp; space_padding);
space_padding = &#39; &#39;*;"><pre lang="kbnf"><code>name_field    = sized(200*8, unicode(L,M,N,P,Zs)* &amp; space_padding);
space_padding = &#39; &#39;*;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: The &#34;records&#34; section can contain any number of length-delimited records, but must be exactly 1024 bytes long. This section can be padded with 0 length records (which is a record with a length field of 0 and no payload - essentially a zero byte).</p>
<div data-snippet-clipboard-copy-content="record_section     = sized(1024*8, record* &amp; zero_length_record*);
record             = byte(bind(length,~)) &amp; byte(~){length};
zero_length_record = byte(0);
byte(v)            = uint(8,v);"><pre lang="kbnf"><code>record_section     = sized(1024*8, record* &amp; zero_length_record*);
record             = byte(bind(length,~)) &amp; byte(~){length};
zero_length_record = byte(0);
byte(v)            = uint(8,v);
</code></pre></div>
<h3 dir="auto"><a id="user-content-aligned-function" aria-hidden="true" href="#aligned-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>aligned</code> Function</h3>
<div data-snippet-clipboard-copy-content="aligned(bit_count: unsigned, expr: expression, padding: expression): expression =
    &#34;&#34;&#34;
    Requires that `expr` and `padding` together produce a multiple of `bit_count` bits.
    If `expr` doesn&#39;t produce a multiple of `bit_count` bits, the `padding` expression
    is used in the same manner as the `sized` function to produce the remaining bits.
    &#34;&#34;&#34;;"><pre lang="kbnf"><code>aligned(bit_count: unsigned, expr: expression, padding: expression): expression =
    &#34;&#34;&#34;
    Requires that `expr` and `padding` together produce a multiple of `bit_count` bits.
    If `expr` doesn&#39;t produce a multiple of `bit_count` bits, the `padding` expression
    is used in the same manner as the `sized` function to produce the remaining bits.
    &#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: The &#34;records&#34; section can contain any number of length-delimited records, but must end on a 32-bit boundary. This section can be padded with 0 length records (which is a record with a length field of 0 and no payload - essentially a zero byte).</p>
<div data-snippet-clipboard-copy-content="record_section     = aligned(32, record*, zero_length_record*);
record             = byte(bind(length,~)) &amp; byte(~){length};
zero_length_record = byte(0);
byte(v)            = uint(8, v);"><pre lang="kbnf"><code>record_section     = aligned(32, record*, zero_length_record*);
record             = byte(bind(length,~)) &amp; byte(~){length};
zero_length_record = byte(0);
byte(v)            = uint(8, v);
</code></pre></div>
<h3 dir="auto"><a id="user-content-swapped-function" aria-hidden="true" href="#swapped-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>swapped</code> Function</h3>
<div data-snippet-clipboard-copy-content="swapped(bit_granularity: unsigned, expr: expression): expression =
    &#34;&#34;&#34;
    Swaps the order of `expr`&#39;s bits with a granularity of `bit_granularity`.
    If `expr` doesn&#39;t resolve to a multiple of `bit_granularity` bits, the
    expression doesn&#39;t match.
    &#34;&#34;&#34;;"><pre lang="kbnf"><code>swapped(bit_granularity: unsigned, expr: expression): expression =
    &#34;&#34;&#34;
    Swaps the order of `expr`&#39;s bits with a granularity of `bit_granularity`.
    If `expr` doesn&#39;t resolve to a multiple of `bit_granularity` bits, the
    expression doesn&#39;t match.
    &#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: A document begins with a 32-bit little endian unsigned int version field, followed by the contents. Only version 5 documents are supported.</p>
<div data-snippet-clipboard-copy-content="document  = version_5 &amp; contents;
version_5 = swapped(8, uint(32, 5));
contents  = ..."><pre lang="kbnf"><code>document  = version_5 &amp; contents;
version_5 = swapped(8, uint(32, 5));
contents  = ...
</code></pre></div>
<p dir="auto"><strong>Example</strong>: A header begins with a 16-bit unsigned int identifier that is actually bit-swapped, followed by contents based on the identifier.</p>
<div data-snippet-clipboard-copy-content="header               = bitswapped_uint16(bind(identifier, ~)) &amp; contents(identifier);
bitswapped_uint16(v) = swapped(1, uint(16, v));
contents(identifier) = when(identifier = 1, type_1)
                     | when(identifier = 2, type_2)
                     ;
type_1               = ...
type_2               = ..."><pre lang="kbnf"><code>header               = bitswapped_uint16(bind(identifier, ~)) &amp; contents(identifier);
bitswapped_uint16(v) = swapped(1, uint(16, v));
contents(identifier) = when(identifier = 1, type_1)
                     | when(identifier = 2, type_2)
                     ;
type_1               = ...
type_2               = ...
</code></pre></div>
<h3 dir="auto"><a id="user-content-when-function" aria-hidden="true" href="#when-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>when</code> Function</h3>
<div data-snippet-clipboard-copy-content="when(cond: condition, expr: expression): expression =
    &#34;&#34;&#34;
    Matches `expr` only when `cond` is true.
    &#34;&#34;&#34;;"><pre lang="kbnf"><code>when(cond: condition, expr: expression): expression =
    &#34;&#34;&#34;
    Matches `expr` only when `cond` is true.
    &#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: The extensions section contains 32 extension slots. Each extension starts with a 1-byte type field, followed by a 24-bit big endian field containing the length of the payload. Valid payload types are 1, 2, or 3 (payload type 0 is a dummy type meaning &#34;no extension&#34;, so the length field is ignored and there is no payload data). The same extension type can be used multiple times.</p>
<div data-snippet-clipboard-copy-content="extensions          = extension{32};
extension           = uint(8,bind(type,0~3)) &amp; uint(24,bind(length,~))
                    &amp; ( when(type = 1, extension_1(length))
                      | when(type = 2, extension_2(length))
                      | when(type = 3, extension_3(length))
                      # When type is 0, no extension and length is ignored
                      )
                    ;
extension_1(length) = ...
extension_2(length) = ...
extension_3(length) = ..."><pre lang="kbnf"><code>extensions          = extension{32};
extension           = uint(8,bind(type,0~3)) &amp; uint(24,bind(length,~))
                    &amp; ( when(type = 1, extension_1(length))
                      | when(type = 2, extension_2(length))
                      | when(type = 3, extension_3(length))
                      # When type is 0, no extension and length is ignored
                      )
                    ;
extension_1(length) = ...
extension_2(length) = ...
extension_3(length) = ...
</code></pre></div>
<h3 dir="auto"><a id="user-content-bind-function" aria-hidden="true" href="#bind-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>bind</code> Function</h3>
<div data-snippet-clipboard-copy-content="bind(variable_name: identifier, value: expression | ~number): expression | ~number =
    &#34;&#34;&#34;
    Binds `value` to a local variable for subsequent re-use in the current rule.
    `bind` transparently passes through the type and value of `value`, meaning that
    the context around the `bind` call behaves as though only what the `bind`
    function surrounded is present. This allows a match as normal, while also
    allowing the resolved value to be used again later in the rule.
    &#34;&#34;&#34;;"><pre lang="kbnf"><code>bind(variable_name: identifier, value: expression | ~number): expression | ~number =
    &#34;&#34;&#34;
    Binds `value` to a local variable for subsequent re-use in the current rule.
    `bind` transparently passes through the type and value of `value`, meaning that
    the context around the `bind` call behaves as though only what the `bind`
    function surrounded is present. This allows a match as normal, while also
    allowing the resolved value to be used again later in the rule.
    &#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Match &#34;abc/abc&#34;, &#34;fred/fred&#34; etc.</p>
<div data-snippet-clipboard-copy-content="sequence = bind(repeating_value,(&#39;a&#39;~&#39;z&#39;)+) &amp; &#39;/&#39; &amp; repeating_value;"><pre lang="kbnf"><code>sequence = bind(repeating_value,(&#39;a&#39;~&#39;z&#39;)+) &amp; &#39;/&#39; &amp; repeating_value;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: BASH &#34;here&#34; document: Bind the variable &#34;terminator&#34; to whatever follows the &#34;&lt;&lt;&#34; until the next linefeed. The here-document contents continue until the terminator value is encountered again.</p>
<div data-snippet-clipboard-copy-content="here_document             = &#34;&lt;&lt;&#34; &amp; bind(terminator, NOT_LF+) &amp; LF &amp; here_contents(terminator) &amp; terminator;
here_contents(terminator) = ANY_CHAR* ! terminator;
ANY_CHAR                  = ~;
LF                        = &#39;\[a]&#39;;
NOT_LF                    = ANY_CHAR ! LF;"><pre lang="kbnf"><code>here_document             = &#34;&lt;&lt;&#34; &amp; bind(terminator, NOT_LF+) &amp; LF &amp; here_contents(terminator) &amp; terminator;
here_contents(terminator) = ANY_CHAR* ! terminator;
ANY_CHAR                  = ~;
LF                        = &#39;\[a]&#39;;
NOT_LF                    = ANY_CHAR ! LF;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Interpret the next 16 bits as a big endian unsigned int and bind the resolved number to &#34;length&#34;. That many following bytes make up the record contents.</p>
<div data-snippet-clipboard-copy-content="length_delimited_record = uint16(bind(length, ~)) &amp; record_contents(length);
record_contents(length) = byte(~){length};
uint16(v)               = uint(16, v);
byte(v)                 = uint(8, v);"><pre lang="kbnf"><code>length_delimited_record = uint16(bind(length, ~)) &amp; record_contents(length);
record_contents(length) = byte(~){length};
uint16(v)               = uint(16, v);
byte(v)                 = uint(8, v);
</code></pre></div>
<h3 dir="auto"><a id="user-content-unicode-function" aria-hidden="true" href="#unicode-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>unicode</code> Function</h3>
<div data-snippet-clipboard-copy-content="unicode(categories: unicode_category ...): expression =
    &#34;&#34;&#34;
    Creates an expression containing the alternatives set of all Unicode
    codepoints that have any of the given Unicode categories.

    `categories` is a comma separated list of 1 letter major category or 2-letter minor
    category names, as listed in https://www.unicode.org/versions/Unicode15.0.0/ch04.pdf#G134153

    Example: all letters and space separators: unicode(L,Zs)
    &#34;&#34;&#34;;"><pre lang="kbnf"><code>unicode(categories: unicode_category ...): expression =
    &#34;&#34;&#34;
    Creates an expression containing the alternatives set of all Unicode
    codepoints that have any of the given Unicode categories.

    `categories` is a comma separated list of 1 letter major category or 2-letter minor
    category names, as listed in https://www.unicode.org/versions/Unicode15.0.0/ch04.pdf#G134153

    Example: all letters and space separators: unicode(L,Zs)
    &#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Allow letter, numeral, and space characters.</p>
<div data-snippet-clipboard-copy-content="letter_digit_space = unicode(N,L,Zs);"><pre lang="kbnf"><code>letter_digit_space = unicode(N,L,Zs);
</code></pre></div>
<h3 dir="auto"><a id="user-content-uint-function" aria-hidden="true" href="#uint-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>uint</code> Function</h3>
<div data-snippet-clipboard-copy-content="uint(bit_count: unsigned, range: ~unsigned): expression =
    &#34;&#34;&#34;
    Creates an expression that matches the given range of big endian unsigned
    integers with the given number of bits.
    &#34;&#34;&#34;;"><pre lang="kbnf"><code>uint(bit_count: unsigned, range: ~unsigned): expression =
    &#34;&#34;&#34;
    Creates an expression that matches the given range of big endian unsigned
    integers with the given number of bits.
    &#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: The length field is a 16-bit unsigned integer value.</p>

<h3 dir="auto"><a id="user-content-sint-function" aria-hidden="true" href="#sint-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>sint</code> Function</h3>
<div data-snippet-clipboard-copy-content="sint(bit_count: unsigned, range: ~signed): expression =
    &#34;&#34;&#34;
    Creates an expression that matches the given range of big endian signed
    integers with the given number of bits.
    &#34;&#34;&#34;;"><pre lang="kbnf"><code>sint(bit_count: unsigned, range: ~signed): expression =
    &#34;&#34;&#34;
    Creates an expression that matches the given range of big endian signed
    integers with the given number of bits.
    &#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: The points field is a 16-bit signed integer value from -10000 to 10000.</p>
<div data-snippet-clipboard-copy-content="points = sint(32, -10000~10000);"><pre lang="kbnf"><code>points = sint(32, -10000~10000);
</code></pre></div>
<h3 dir="auto"><a id="user-content-float-function" aria-hidden="true" href="#float-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>float</code> Function</h3>
<div data-snippet-clipboard-copy-content="float(bit_count: unsigned, range: ~real): expression =
    &#34;&#34;&#34;
    Creates an expression that matches the given range of big endian ieee754 binary
    floating point values. `bit_count` must be a valid size according to ieee754 binary.
    &#34;&#34;&#34;;"><pre lang="kbnf"><code>float(bit_count: unsigned, range: ~real): expression =
    &#34;&#34;&#34;
    Creates an expression that matches the given range of big endian ieee754 binary
    floating point values. `bit_count` must be a valid size according to ieee754 binary.
    &#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Note</strong>: <a href="#ranges">ranges</a> passed to the <code>float</code> function will <strong>never</strong> include <a href="#qnan-function">qnan</a> or <a href="#snan-function">snan</a>. These special values cannot be part of a range, and instead must be explicitly passed to the <code>float</code> function.</p>
<p dir="auto"><strong>Example</strong>: The temperature field is a 32-bit float value from -1000 to 1000.</p>
<div data-snippet-clipboard-copy-content="rpm = float(32, -1000~1000);"><pre lang="kbnf"><code>rpm = float(32, -1000~1000);
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Accept any real or any NaN, encoded as a float64.</p>
<div data-snippet-clipboard-copy-content="value                 = float64_or_nan(~);
float64_or_nan(range) = float(64,range) | float(64,qnan) | float(64,snan);"><pre lang="kbnf"><code>value                 = float64_or_nan(~);
float64_or_nan(range) = float(64,range) | float(64,qnan) | float(64,snan);
</code></pre></div>
<h3 dir="auto"><a id="user-content-inf-function" aria-hidden="true" href="#inf-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>inf</code> Function</h3>
<div data-snippet-clipboard-copy-content="inf: real =
    &#34;&#34;&#34;
    Returns a number representing the mathematical concept of infinity.
    The sign of the infinity can be reversed using negation.
    This representation is only for the concept itself; actual encodings in a
    document will depend on the encoding format used.
    &#34;&#34;&#34;;"><pre lang="kbnf"><code>inf: real =
    &#34;&#34;&#34;
    Returns a number representing the mathematical concept of infinity.
    The sign of the infinity can be reversed using negation.
    This representation is only for the concept itself; actual encodings in a
    document will depend on the encoding format used.
    &#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Negative infinity used as a record terminator.</p>
<div data-snippet-clipboard-copy-content="record     = reading* terminator;
reading    = float(32, ~) ! terminator;
terminator = float(32, -inf);"><pre lang="kbnf"><code>record     = reading* terminator;
reading    = float(32, ~) ! terminator;
terminator = float(32, -inf);
</code></pre></div>
<h3 dir="auto"><a id="user-content-qnan-function" aria-hidden="true" href="#qnan-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>qnan</code> Function</h3>
<div data-snippet-clipboard-copy-content="qnan: real =
    &#34;&#34;&#34;
    returns a number representing the concept of &#34;not-a-number&#34; in its quiet form.
    This representation is only for the concept itself; actual encodings in a
    document will depend on the encoding format used.
    &#34;&#34;&#34;;"><pre lang="kbnf"><code>qnan: real =
    &#34;&#34;&#34;
    returns a number representing the concept of &#34;not-a-number&#34; in its quiet form.
    This representation is only for the concept itself; actual encodings in a
    document will depend on the encoding format used.
    &#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Quiet NaN used to mark invalid readings.</p>
<div data-snippet-clipboard-copy-content="record  = reading{32};
reading = float(32, ~) | invalid;
invalid = float(32, qnan);"><pre lang="kbnf"><code>record  = reading{32};
reading = float(32, ~) | invalid;
invalid = float(32, qnan);
</code></pre></div>
<h3 dir="auto"><a id="user-content-snan-function" aria-hidden="true" href="#snan-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>snan</code> Function</h3>
<div data-snippet-clipboard-copy-content="snan: real =
    &#34;&#34;&#34;
    returns a number representing the concept of &#34;not-a-number&#34; in its signaling form.
    This representation is only for the concept itself; actual encodings in a
    document will depend on the encoding format used.
    &#34;&#34;&#34;;"><pre lang="kbnf"><code>snan: real =
    &#34;&#34;&#34;
    returns a number representing the concept of &#34;not-a-number&#34; in its signaling form.
    This representation is only for the concept itself; actual encodings in a
    document will depend on the encoding format used.
    &#34;&#34;&#34;;
</code></pre></div>
<p dir="auto"><strong>Example</strong>: Signaling NaN used to mark invalid readings.</p>
<div data-snippet-clipboard-copy-content="record  = reading{32};
reading = float(32, ~) | invalid;
invalid = float(32, snan);"><pre lang="kbnf"><code>record  = reading{32};
reading = float(32, ~) | invalid;
invalid = float(32, snan);
</code></pre></div>
<h2 dir="auto"><a id="user-content-examples" aria-hidden="true" href="#examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Examples</h2>
<h3 dir="auto"><a id="user-content-a-complex-example" aria-hidden="true" href="#a-complex-example"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>A Complex Example</h3>
<ul dir="auto">
<li>A <code>document</code> contains one or more <code>sections</code>, and terminates on EOF.</li>
<li>A <code>section</code> begins with a <code>sentinel</code> (a record with type between 0x80 and 0xfe, and a length of 0), followed by an arbitrary number of <code>records</code>, followed by the same <code>sentinel</code> value again to terminate the list of <code>records</code> in this <code>section</code>.</li>
<li>A <code>record</code> is comprised of an 8-bit <code>record_type</code>, a <code>payload</code>, and a possible <code>suffix</code> depending on the <code>record_type</code>.</li>
<li>The <code>payload</code> is comprised of a little endian 24-bit <code>length</code> field representing the number of bytes in the payload, followed by the payload bytes, followed by possible 0xff padding to bring it to a multiple of 32 bits.</li>
<li>Depending on the <code>record_type</code>, there may be a <code>suffix</code>.</li>
</ul>
<div data-snippet-clipboard-copy-content="document                = section+;
section                 = bind(sentinel,uint(8,0x80~0xfe)) &amp; length_field(0) &amp; record* &amp; sentinel;
record                  = bind(record_type,type_field) &amp; padded_payload &amp; suffix(record_type.type);
type_field              = uint(8,bind(type,0~2));
padded_payload          = aligned(32, payload, uint(8,0xff)*);
payload                 = length_field(bind(byte_count,~)) &amp; uint(8,~){byte_count};
length_field(contents)  = swapped(8, uint(24,contents));
suffix(type)            = when(type = 2, type2)
                        | when(type = 1, type1)
                        # type 0 means no suffix
                        ;
type1                   = ...
type2                   = ..."><pre lang="kbnf"><code>document                = section+;
section                 = bind(sentinel,uint(8,0x80~0xfe)) &amp; length_field(0) &amp; record* &amp; sentinel;
record                  = bind(record_type,type_field) &amp; padded_payload &amp; suffix(record_type.type);
type_field              = uint(8,bind(type,0~2));
padded_payload          = aligned(32, payload, uint(8,0xff)*);
payload                 = length_field(bind(byte_count,~)) &amp; uint(8,~){byte_count};
length_field(contents)  = swapped(8, uint(24,contents));
suffix(type)            = when(type = 2, type2)
                        | when(type = 1, type1)
                        # type 0 means no suffix
                        ;
type1                   = ...
type2                   = ...
</code></pre></div>
<h3 dir="auto"><a id="user-content-example-internet-protocol-version-4" aria-hidden="true" href="#example-internet-protocol-version-4"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example: Internet Protocol version 4</h3>
<p dir="auto">See accompanying document: <a href="https://mikkel.ca/kstenerud/kbnf/blob/master/ipv4.kbnf">ipv4.kbnf</a></p>
<h2 dir="auto"><a id="user-content-the-kbnf-grammar-in-kbnf" aria-hidden="true" href="#the-kbnf-grammar-in-kbnf"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The KBNF Grammar in KBNF</h2>
<div data-snippet-clipboard-copy-content="kbnf_v1 utf-8
- identifier  = kbnf_v1
- description = Karl&#39;s Backus-Naur Form, version 1

document               = document_header &amp; MAYBE_WSLC &amp; start_rule &amp; (MAYBE_WSLC &amp; rule)*;

kbnf_version           = &#39;1&#39;;

document_header        = &#34;kbnf_v&#34; &amp; kbnf_version &amp; SOME_WS
                       &amp; character_encoding &amp; LINE_END
                       &amp; header_line* &amp; LINE_END
                       ;
character_encoding     = (&#39;a&#39;~&#39;z&#39; | &#39;A&#39;~&#39;Z&#39; | &#39;0&#39;~&#39;9&#39; | &#39;_&#39; | &#39;-&#39; | &#39;.&#39; | &#39;:&#39; | &#39;+&#39; | &#39;(&#39; | &#39;)&#39;){1~40};
header_line            = &#39;-&#39; &amp; SOME_WS
                       &amp; header_name &amp; MAYBE_WS
                       &amp; &#39;=&#39; &amp; MAYBE_WS
                       &amp; header_value &amp; LINE_END
                       ;
header_name            = printable+;
header_value           = printable_ws+;

rule                   = symbol_rule | macro_rule | function_rule;
start_rule             = symbol_rule;
symbol_rule            = symbol &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; expression &amp; TOKEN_SEP &amp; &#39;;&#39;;
macro_rule             = macro &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; expression &amp; TOKEN_SEP &amp; &#39;;&#39;;
function_rule          = function &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; prose &amp; TOKEN_SEP &amp; &#39;;&#39;;

expression             = symbol
                       | call
                       | string_literal
                       | maybe_ranged(codepoint_literal)
                       | combination
                       | builtin_functions
                       | variable
                       | grouped(expression)
                       ;

symbol                 = identifier_restricted;
macro                  = identifier_restricted &amp; PARENTHESIZED(param_name &amp; (ARG_SEP &amp; param_name)*);
param_name             = identifier_restricted;
function               = function_no_args | function_with_args;
function_no_args       = identifier_restricted &amp; TOKEN_SEP &amp; type_specifier;
function_with_args     = identifier_restricted
                       &amp; PARENTHESIZED(function_param &amp; (ARG_SEP &amp; function_param)*)
                       &amp; TOKEN_SEP &amp; type_specifier
                       ;
function_param         = param_name &amp; TOKEN_SEP &amp; type_specifier;
type_specifier         = &#39;:&#39; &amp; TOKEN_SEP &amp; type_alternatives &amp; (TOKEN_SEP &amp; vararg)?;
type_alternatives      = type_name &amp; (TOKEN_SEP &amp; &#39;|&#39; &amp; TOKEN_SEP &amp; type_name)*;
vararg                 = &#34;...&#34;;
type_name              = basic_type_name | custom_type_name;
basic_type_name        = &#34;expression&#34;
                       | &#34;condition&#34;
                       | &#34;number&#34;
                       | &#34;unsigned&#34;
                       | &#34;signed&#34;
                       | &#34;real&#34;
                       ;
custom_type_name       = name;

call                   = identifier_any &amp; PARENTHESIZED(call_param &amp; (ARG_SEP &amp; call_param)*);
call_param             = any_type;

combination            = alternate | combination_w_exclude;
combination_w_exclude  = exclude | combination_w_concat;
combination_w_concat   = concatenate | combination_w_repeat;
combination_w_repeat   = repetition | combination;
alternate              = expression &amp; TOKEN_SEP &amp; &#39;|&#39; &amp; TOKEN_SEP &amp; expression;
concatenate            = expression &amp; TOKEN_SEP &amp; &#39;&amp;&#39; &amp; TOKEN_SEP &amp; expression;
exclude                = expression &amp; TOKEN_SEP &amp; &#39;!&#39; &amp; TOKEN_SEP &amp; expression;
repetition             = repeat_range | repeat_zero_or_one | repeat_zero_or_more | repeat_one_or_more;
repeat_range           = expression &amp; &#39;{&#39; &amp; TOKEN_SEP &amp; maybe_ranged(number) &amp; TOKEN_SEP &amp; &#39;}&#39;;
repeat_zero_or_one     = expression &amp; &#39;?&#39;;
repeat_zero_or_more    = expression &amp; &#39;*&#39;;
repeat_one_or_more     = expression &amp; &#39;+&#39;;

prose                  = &#39;&#34;&#34;&#34;&#39; &amp; maybe_escaped(printable_wsl)+ &amp; &#39;&#34;&#34;&#34;&#39;
                       | &#34;&#39;&#39;&#39;&#34; &amp; maybe_escaped(printable_wsl)+ &amp; &#34;&#39;&#39;&#39;&#34;
                       ;
codepoint_literal      = &#39;&#34;&#39; &amp; maybe_escaped(printable_ws ! &#39;&#34;&#39;){1} &amp; &#39;&#34;&#39;
                       | &#34;&#39;&#34; &amp; maybe_escaped(printable_ws ! &#34;&#39;&#34;){1} &amp; &#34;&#39;&#34;
                       ;
string_literal         = &#39;&#34;&#39; &amp; maybe_escaped(printable_ws ! &#39;&#34;&#39;){2~} &amp; &#39;&#34;&#39;
                       | &#34;&#39;&#34; &amp; maybe_escaped(printable_ws ! &#34;&#39;&#34;){2~} &amp; &#34;&#39;&#34;
                       ;
maybe_escaped(charset) = (charset ! &#39;\\&#39;) | escape_sequence;
escape_sequence        = &#39;\\&#39; &amp; (printable ! &#39;[&#39;) | codepoint_escape);
codepoint_escape       = &#39;[&#39; &amp; digit_hex+ &amp; &#39;]&#39;;

builtin_functions      = sized
                       | aligned
                       | swapped
                       | when
                       | bind
                       | unicode
                       | uint
                       | sint
                       | float
                       | inf
                       | qnan
                       | snan
                       ;

sized(bit_count: unsigned, expr: expression): expression =
    &#34;&#34;&#34;
    Requires that `expr` produce exactly `bit_count` bits.
    Expressions containing repetition that would have matched on their own are
    no longer sufficient until the production fills exactly `bit_count` bits.
    &#34;&#34;&#34;;

aligned(bit_count: unsigned, expr: expression, padding: expression): expression =
    &#34;&#34;&#34;
    Requires that `expr` and `padding` together produce a multiple of `bit_count` bits.
    If `expr` doesn&#39;t produce a multiple of `bit_count` bits, the `padding` expression
    is used in the same manner as the `sized` function to produce the remaining bits.
    &#34;&#34;&#34;;

swapped(bit_granularity: unsigned, expr: expression): expression =
    &#34;&#34;&#34;
    Swaps the order of `expr`&#39;s bits with a granularity of `bit_granularity`.
    If `expr` doesn&#39;t resolve to a multiple of `bit_granularity` bits, the
    expression doesn&#39;t match.
    &#34;&#34;&#34;;

when(cond: condition, expr: expression): expression =
    &#34;&#34;&#34;
    Matches `expr` only when `cond` is true.
    &#34;&#34;&#34;;

bind(variable_name: identifier, value: expression | ~number): expression | ~number =
    &#34;&#34;&#34;
    Binds `value` to a local variable for subsequent re-use in the current rule.
    `bind` transparently passes through the type and value of `value`, meaning that
    the context around the `bind` call behaves as though only what the `bind`
    function surrounded is present. This allows a match as normal, while also
    allowing the resolved value to be used again later in the rule.
    &#34;&#34;&#34;;

unicode(categories: unicode_category ...): expression =
    &#34;&#34;&#34;
    Creates an expression containing the alternatives set of all Unicode
    codepoints that have any of the given Unicode categories.

    `categories` is a comma separated list of 1 letter major category or 2-letter minor
    category names, as listed in https://www.unicode.org/versions/Unicode15.0.0/ch04.pdf#G134153

    Example: all letters and space separators: unicode(L,Zs)
    &#34;&#34;&#34;;

uint(bit_count: unsigned, range: ~unsigned): expression =
    &#34;&#34;&#34;
    Creates an expression that matches the given range of big endian unsigned
    integers with the given number of bits.
    &#34;&#34;&#34;;

sint(bit_count: unsigned, range: ~signed): expression =
    &#34;&#34;&#34;
    Creates an expression that matches the given range of big endian signed
    integers with the given number of bits.
    &#34;&#34;&#34;;

float(bit_count: unsigned, range: ~real): expression =
    &#34;&#34;&#34;
    Creates an expression that matches the given range of big endian ieee754 binary
    floating point values. `bit_count` must be a valid size according to ieee754 binary.
    &#34;&#34;&#34;;

inf: real =
    &#34;&#34;&#34;
    Returns a number representing the mathematical concept of infinity.
    The sign of the infinity can be reversed using negation.
    This representation is only for the concept itself; actual encodings in a
    document will depend on the encoding format used.
    &#34;&#34;&#34;;

qnan: real =
    &#34;&#34;&#34;
    returns a number representing the concept of &#34;not-a-number&#34; in its quiet form.
    This representation is only for the concept itself; actual encodings in a
    document will depend on the encoding format used.
    &#34;&#34;&#34;;

snan: real =
    &#34;&#34;&#34;
    returns a number representing the concept of &#34;not-a-number&#34; in its signaling form.
    This representation is only for the concept itself; actual encodings in a
    document will depend on the encoding format used.
    &#34;&#34;&#34;;

padding                = expression;
bit_count              = number;
bit_granularity        = number;
unicode_category       = (&#39;A&#39;~&#39;Z&#39;) &amp; (&#39;a&#39;~&#39;z&#39;)?;
any_type               = condition | number | expression;

variable               = local_id | variable &amp; &#39;.&#39; &amp; local_id;
local_id               = identifier_restricted;

condition              = comparison | logical_ops;
logical_ops            = logical_or | logical_ops_and_not;
logical_ops_and_not    = logical_and | logical_op_not;
logical_op_not         = logical_not | maybe_grouped(condition);
comparison             = number &amp; TOKEN_SEP &amp; comparator &amp; TOKEN_SEP &amp; number;
comparator             = &#34;&lt;&#34; | &#34;&lt;=&#34; | &#34;=&#34; | &#34;&gt;= | &#34;&gt;&#34;;
logical_or             = condition &amp; TOKEN_SEP &amp; &#39;|&#39; &amp; TOKEN_SEP &amp; condition;
logical_and            = condition &amp; TOKEN_SEP &amp; &#39;&amp;&#39; &amp; TOKEN_SEP &amp; condition;
logical_not            = &#39;!&#39; &amp; TOKEN_SEP &amp; condition;

number                 = calc_add | calc_sub | calc_mul_div;
calc_mul_div           = calc_mul | calc_div | calc_mod | calc_pow_neg;
calc_pow_neg           = calc_pow | calc_neg_val;
calc_neg_val           = calc_neg | calc_val;
calc_val               = number_literal | variable | maybe_grouped(number);
calc_add               = number &amp; TOKEN_SEP &amp; &#39;+&#39; &amp; TOKEN_SEP &amp; calc_mul_div;
calc_sub               = number &amp; TOKEN_SEP &amp; &#39;-&#39; &amp; TOKEN_SEP &amp; calc_mul_div;
calc_mul               = calc_mul_div &amp; TOKEN_SEP &amp; &#39;*&#39; &amp; TOKEN_SEP &amp; calc_pow_val;
calc_div               = calc_mul_div &amp; TOKEN_SEP &amp; &#39;/&#39; &amp; TOKEN_SEP &amp; calc_pow_val;
calc_mod               = calc_mul_div &amp; TOKEN_SEP &amp; &#39;%&#39; &amp; TOKEN_SEP &amp; calc_pow_val;
calc_pow               = calc_pow_val &amp; TOKEN_SEP &amp; &#39;^&#39; &amp; TOKEN_SEP &amp; calc_neg_val;
calc_neg               = &#39;-&#39; &amp; calc_val;

grouped(item)          = PARENTHESIZED(item);
ranged(item)           = (item &amp; TOKEN_SEP)? &amp; &#39;~&#39; &amp; (TOKEN_SEP &amp; item)?;
maybe_grouped(item)    = item | grouped(item);
maybe_ranged(item)     = item | ranged(item);

number_literal         = int_literal_bin | int_literal_oct | int_real_literal_dec | int_real_literal_hex;
int_real_literal_dec   = neg? digit_dec+
                       &amp; (&#39;.&#39; &amp; digit_dec+ &amp; ((&#39;e&#39; | &#39;E&#39;) (&#39;+&#39; | &#39;-&#39;)? &amp; digit_dec+)?)?
                       ;
int_real_literal_hex   = neg? &amp; &#39;0&#39; &amp; (&#39;x&#39; | &#39;X&#39;) &amp; digit_hex+
                       &amp; (&#39;.&#39; &amp; digit_hex+ &amp; ((&#39;p&#39; | &#39;P&#39;) &amp; (&#39;+&#39; | &#39;-&#39;)? &amp; digit_dec+)?)?
                       ;
int_literal_bin        = neg? &amp; &#39;0&#39; &amp; (&#39;b&#39; | &#39;B&#39;) &amp; digit_bin+;
int_literal_oct        = neg? &amp; &#39;0&#39; &amp; (&#39;o&#39; | &#39;O&#39;) &amp; digit_oct+;
neg                    = &#39;-&#39;;

identifier_any         = name;
identifier_restricted  = identifier_any ! reserved_identifiers;
reserved_identifiers   = &#34;sized&#34;
                       | &#34;aligned&#34;
                       | &#34;swapped&#34;
                       | &#34;when&#34;
                       | &#34;bind&#34;
                       | &#34;uint&#34;
                       | &#34;sint&#34;
                       | &#34;float&#34;
                       | &#34;inf&#34;
                       | &#34;qnan&#34;
                       | &#34;snan&#34;
                       ;

name                   = name_firstchar &amp; name_nextchar*;
name_firstchar         = unicode(L,M);
name_nextchar          = name_firstchar | unicode(N) | &#39;_&#39;;

printable              = unicode(L,M,N,P,S);
printable_ws           = printable | WS;
printable_wsl          = printable | WSL;
digit_bin              = &#39;0&#39;~&#39;1&#39;;
digit_oct              = &#39;0&#39;~&#39;7&#39;;
digit_dec              = &#39;0&#39;~&#39;9&#39;;
digit_bin              = (&#39;0&#39;~&#39;9&#39;) | (&#39;a&#39;~&#39;f&#39;) | (&#39;A&#39;~&#39;F&#39;);

comment                = &#39;#&#39; &amp; printable_ws* &amp; LINE_END;

PARENTHESIZED(item)    = &#39;(&#39; &amp; TOKEN_SEP &amp; item &amp; TOKEN_SEP &amp; &#39;)&#39;;
ARG_SEP                = TOKEN_SEP &amp; &#39;,&#39; &amp; TOKEN_SEP;
TOKEN_SEP              = MAYBE_WSLC;

# Whitespace
MAYBE_WS               = WS*;
SOME_WS                = WS &amp; MAYBE_WS;
MAYBE_WSLC             = (WSL | comment)*;
SOME_WSLC              = WSL &amp; MAYBE_WSLC;
WSL                    = WS | LINE_END;
WS                     = HT | SP;
LINE_END               = CR? &amp; LF;
HT                     = &#39;\[9]&#39;;
LF                     = &#39;\[a]&#39;;
CR                     = &#39;\[d]&#39;;
SP                     = &#39;\[20]&#39;;"><pre lang="kbnf"><code>kbnf_v1 utf-8
- identifier  = kbnf_v1
- description = Karl&#39;s Backus-Naur Form, version 1

document               = document_header &amp; MAYBE_WSLC &amp; start_rule &amp; (MAYBE_WSLC &amp; rule)*;

kbnf_version           = &#39;1&#39;;

document_header        = &#34;kbnf_v&#34; &amp; kbnf_version &amp; SOME_WS
                       &amp; character_encoding &amp; LINE_END
                       &amp; header_line* &amp; LINE_END
                       ;
character_encoding     = (&#39;a&#39;~&#39;z&#39; | &#39;A&#39;~&#39;Z&#39; | &#39;0&#39;~&#39;9&#39; | &#39;_&#39; | &#39;-&#39; | &#39;.&#39; | &#39;:&#39; | &#39;+&#39; | &#39;(&#39; | &#39;)&#39;){1~40};
header_line            = &#39;-&#39; &amp; SOME_WS
                       &amp; header_name &amp; MAYBE_WS
                       &amp; &#39;=&#39; &amp; MAYBE_WS
                       &amp; header_value &amp; LINE_END
                       ;
header_name            = printable+;
header_value           = printable_ws+;

rule                   = symbol_rule | macro_rule | function_rule;
start_rule             = symbol_rule;
symbol_rule            = symbol &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; expression &amp; TOKEN_SEP &amp; &#39;;&#39;;
macro_rule             = macro &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; expression &amp; TOKEN_SEP &amp; &#39;;&#39;;
function_rule          = function &amp; TOKEN_SEP &amp; &#39;=&#39; &amp; TOKEN_SEP &amp; prose &amp; TOKEN_SEP &amp; &#39;;&#39;;

expression             = symbol
                       | call
                       | string_literal
                       | maybe_ranged(codepoint_literal)
                       | combination
                       | builtin_functions
                       | variable
                       | grouped(expression)
                       ;

symbol                 = identifier_restricted;
macro                  = identifier_restricted &amp; PARENTHESIZED(param_name &amp; (ARG_SEP &amp; param_name)*);
param_name             = identifier_restricted;
function               = function_no_args | function_with_args;
function_no_args       = identifier_restricted &amp; TOKEN_SEP &amp; type_specifier;
function_with_args     = identifier_restricted
                       &amp; PARENTHESIZED(function_param &amp; (ARG_SEP &amp; function_param)*)
                       &amp; TOKEN_SEP &amp; type_specifier
                       ;
function_param         = param_name &amp; TOKEN_SEP &amp; type_specifier;
type_specifier         = &#39;:&#39; &amp; TOKEN_SEP &amp; type_alternatives &amp; (TOKEN_SEP &amp; vararg)?;
type_alternatives      = type_name &amp; (TOKEN_SEP &amp; &#39;|&#39; &amp; TOKEN_SEP &amp; type_name)*;
vararg                 = &#34;...&#34;;
type_name              = basic_type_name | custom_type_name;
basic_type_name        = &#34;expression&#34;
                       | &#34;condition&#34;
                       | &#34;number&#34;
                       | &#34;unsigned&#34;
                       | &#34;signed&#34;
                       | &#34;real&#34;
                       ;
custom_type_name       = name;

call                   = identifier_any &amp; PARENTHESIZED(call_param &amp; (ARG_SEP &amp; call_param)*);
call_param             = any_type;

combination            = alternate | combination_w_exclude;
combination_w_exclude  = exclude | combination_w_concat;
combination_w_concat   = concatenate | combination_w_repeat;
combination_w_repeat   = repetition | combination;
alternate              = expression &amp; TOKEN_SEP &amp; &#39;|&#39; &amp; TOKEN_SEP &amp; expression;
concatenate            = expression &amp; TOKEN_SEP &amp; &#39;&amp;&#39; &amp; TOKEN_SEP &amp; expression;
exclude                = expression &amp; TOKEN_SEP &amp; &#39;!&#39; &amp; TOKEN_SEP &amp; expression;
repetition             = repeat_range | repeat_zero_or_one | repeat_zero_or_more | repeat_one_or_more;
repeat_range           = expression &amp; &#39;{&#39; &amp; TOKEN_SEP &amp; maybe_ranged(number) &amp; TOKEN_SEP &amp; &#39;}&#39;;
repeat_zero_or_one     = expression &amp; &#39;?&#39;;
repeat_zero_or_more    = expression &amp; &#39;*&#39;;
repeat_one_or_more     = expression &amp; &#39;+&#39;;

prose                  = &#39;&#34;&#34;&#34;&#39; &amp; maybe_escaped(printable_wsl)+ &amp; &#39;&#34;&#34;&#34;&#39;
                       | &#34;&#39;&#39;&#39;&#34; &amp; maybe_escaped(printable_wsl)+ &amp; &#34;&#39;&#39;&#39;&#34;
                       ;
codepoint_literal      = &#39;&#34;&#39; &amp; maybe_escaped(printable_ws ! &#39;&#34;&#39;){1} &amp; &#39;&#34;&#39;
                       | &#34;&#39;&#34; &amp; maybe_escaped(printable_ws ! &#34;&#39;&#34;){1} &amp; &#34;&#39;&#34;
                       ;
string_literal         = &#39;&#34;&#39; &amp; maybe_escaped(printable_ws ! &#39;&#34;&#39;){2~} &amp; &#39;&#34;&#39;
                       | &#34;&#39;&#34; &amp; maybe_escaped(printable_ws ! &#34;&#39;&#34;){2~} &amp; &#34;&#39;&#34;
                       ;
maybe_escaped(charset) = (charset ! &#39;\\&#39;) | escape_sequence;
escape_sequence        = &#39;\\&#39; &amp; (printable ! &#39;[&#39;) | codepoint_escape);
codepoint_escape       = &#39;[&#39; &amp; digit_hex+ &amp; &#39;]&#39;;

builtin_functions      = sized
                       | aligned
                       | swapped
                       | when
                       | bind
                       | unicode
                       | uint
                       | sint
                       | float
                       | inf
                       | qnan
                       | snan
                       ;

sized(bit_count: unsigned, expr: expression): expression =
    &#34;&#34;&#34;
    Requires that `expr` produce exactly `bit_count` bits.
    Expressions containing repetition that would have matched on their own are
    no longer sufficient until the production fills exactly `bit_count` bits.
    &#34;&#34;&#34;;

aligned(bit_count: unsigned, expr: expression, padding: expression): expression =
    &#34;&#34;&#34;
    Requires that `expr` and `padding` together produce a multiple of `bit_count` bits.
    If `expr` doesn&#39;t produce a multiple of `bit_count` bits, the `padding` expression
    is used in the same manner as the `sized` function to produce the remaining bits.
    &#34;&#34;&#34;;

swapped(bit_granularity: unsigned, expr: expression): expression =
    &#34;&#34;&#34;
    Swaps the order of `expr`&#39;s bits with a granularity of `bit_granularity`.
    If `expr` doesn&#39;t resolve to a multiple of `bit_granularity` bits, the
    expression doesn&#39;t match.
    &#34;&#34;&#34;;

when(cond: condition, expr: expression): expression =
    &#34;&#34;&#34;
    Matches `expr` only when `cond` is true.
    &#34;&#34;&#34;;

bind(variable_name: identifier, value: expression | ~number): expression | ~number =
    &#34;&#34;&#34;
    Binds `value` to a local variable for subsequent re-use in the current rule.
    `bind` transparently passes through the type and value of `value`, meaning that
    the context around the `bind` call behaves as though only what the `bind`
    function surrounded is present. This allows a match as normal, while also
    allowing the resolved value to be used again later in the rule.
    &#34;&#34;&#34;;

unicode(categories: unicode_category ...): expression =
    &#34;&#34;&#34;
    Creates an expression containing the alternatives set of all Unicode
    codepoints that have any of the given Unicode categories.

    `categories` is a comma separated list of 1 letter major category or 2-letter minor
    category names, as listed in https://www.unicode.org/versions/Unicode15.0.0/ch04.pdf#G134153

    Example: all letters and space separators: unicode(L,Zs)
    &#34;&#34;&#34;;

uint(bit_count: unsigned, range: ~unsigned): expression =
    &#34;&#34;&#34;
    Creates an expression that matches the given range of big endian unsigned
    integers with the given number of bits.
    &#34;&#34;&#34;;

sint(bit_count: unsigned, range: ~signed): expression =
    &#34;&#34;&#34;
    Creates an expression that matches the given range of big endian signed
    integers with the given number of bits.
    &#34;&#34;&#34;;

float(bit_count: unsigned, range: ~real): expression =
    &#34;&#34;&#34;
    Creates an expression that matches the given range of big endian ieee754 binary
    floating point values. `bit_count` must be a valid size according to ieee754 binary.
    &#34;&#34;&#34;;

inf: real =
    &#34;&#34;&#34;
    Returns a number representing the mathematical concept of infinity.
    The sign of the infinity can be reversed using negation.
    This representation is only for the concept itself; actual encodings in a
    document will depend on the encoding format used.
    &#34;&#34;&#34;;

qnan: real =
    &#34;&#34;&#34;
    returns a number representing the concept of &#34;not-a-number&#34; in its quiet form.
    This representation is only for the concept itself; actual encodings in a
    document will depend on the encoding format used.
    &#34;&#34;&#34;;

snan: real =
    &#34;&#34;&#34;
    returns a number representing the concept of &#34;not-a-number&#34; in its signaling form.
    This representation is only for the concept itself; actual encodings in a
    document will depend on the encoding format used.
    &#34;&#34;&#34;;

padding                = expression;
bit_count              = number;
bit_granularity        = number;
unicode_category       = (&#39;A&#39;~&#39;Z&#39;) &amp; (&#39;a&#39;~&#39;z&#39;)?;
any_type               = condition | number | expression;

variable               = local_id | variable &amp; &#39;.&#39; &amp; local_id;
local_id               = identifier_restricted;

condition              = comparison | logical_ops;
logical_ops            = logical_or | logical_ops_and_not;
logical_ops_and_not    = logical_and | logical_op_not;
logical_op_not         = logical_not | maybe_grouped(condition);
comparison             = number &amp; TOKEN_SEP &amp; comparator &amp; TOKEN_SEP &amp; number;
comparator             = &#34;&lt;&#34; | &#34;&lt;=&#34; | &#34;=&#34; | &#34;&gt;= | &#34;&gt;&#34;;
logical_or             = condition &amp; TOKEN_SEP &amp; &#39;|&#39; &amp; TOKEN_SEP &amp; condition;
logical_and            = condition &amp; TOKEN_SEP &amp; &#39;&amp;&#39; &amp; TOKEN_SEP &amp; condition;
logical_not            = &#39;!&#39; &amp; TOKEN_SEP &amp; condition;

number                 = calc_add | calc_sub | calc_mul_div;
calc_mul_div           = calc_mul | calc_div | calc_mod | calc_pow_neg;
calc_pow_neg           = calc_pow | calc_neg_val;
calc_neg_val           = calc_neg | calc_val;
calc_val               = number_literal | variable | maybe_grouped(number);
calc_add               = number &amp; TOKEN_SEP &amp; &#39;+&#39; &amp; TOKEN_SEP &amp; calc_mul_div;
calc_sub               = number &amp; TOKEN_SEP &amp; &#39;-&#39; &amp; TOKEN_SEP &amp; calc_mul_div;
calc_mul               = calc_mul_div &amp; TOKEN_SEP &amp; &#39;*&#39; &amp; TOKEN_SEP &amp; calc_pow_val;
calc_div               = calc_mul_div &amp; TOKEN_SEP &amp; &#39;/&#39; &amp; TOKEN_SEP &amp; calc_pow_val;
calc_mod               = calc_mul_div &amp; TOKEN_SEP &amp; &#39;%&#39; &amp; TOKEN_SEP &amp; calc_pow_val;
calc_pow               = calc_pow_val &amp; TOKEN_SEP &amp; &#39;^&#39; &amp; TOKEN_SEP &amp; calc_neg_val;
calc_neg               = &#39;-&#39; &amp; calc_val;

grouped(item)          = PARENTHESIZED(item);
ranged(item)           = (item &amp; TOKEN_SEP)? &amp; &#39;~&#39; &amp; (TOKEN_SEP &amp; item)?;
maybe_grouped(item)    = item | grouped(item);
maybe_ranged(item)     = item | ranged(item);

number_literal         = int_literal_bin | int_literal_oct | int_real_literal_dec | int_real_literal_hex;
int_real_literal_dec   = neg? digit_dec+
                       &amp; (&#39;.&#39; &amp; digit_dec+ &amp; ((&#39;e&#39; | &#39;E&#39;) (&#39;+&#39; | &#39;-&#39;)? &amp; digit_dec+)?)?
                       ;
int_real_literal_hex   = neg? &amp; &#39;0&#39; &amp; (&#39;x&#39; | &#39;X&#39;) &amp; digit_hex+
                       &amp; (&#39;.&#39; &amp; digit_hex+ &amp; ((&#39;p&#39; | &#39;P&#39;) &amp; (&#39;+&#39; | &#39;-&#39;)? &amp; digit_dec+)?)?
                       ;
int_literal_bin        = neg? &amp; &#39;0&#39; &amp; (&#39;b&#39; | &#39;B&#39;) &amp; digit_bin+;
int_literal_oct        = neg? &amp; &#39;0&#39; &amp; (&#39;o&#39; | &#39;O&#39;) &amp; digit_oct+;
neg                    = &#39;-&#39;;

identifier_any         = name;
identifier_restricted  = identifier_any ! reserved_identifiers;
reserved_identifiers   = &#34;sized&#34;
                       | &#34;aligned&#34;
                       | &#34;swapped&#34;
                       | &#34;when&#34;
                       | &#34;bind&#34;
                       | &#34;uint&#34;
                       | &#34;sint&#34;
                       | &#34;float&#34;
                       | &#34;inf&#34;
                       | &#34;qnan&#34;
                       | &#34;snan&#34;
                       ;

name                   = name_firstchar &amp; name_nextchar*;
name_firstchar         = unicode(L,M);
name_nextchar          = name_firstchar | unicode(N) | &#39;_&#39;;

printable              = unicode(L,M,N,P,S);
printable_ws           = printable | WS;
printable_wsl          = printable | WSL;
digit_bin              = &#39;0&#39;~&#39;1&#39;;
digit_oct              = &#39;0&#39;~&#39;7&#39;;
digit_dec              = &#39;0&#39;~&#39;9&#39;;
digit_bin              = (&#39;0&#39;~&#39;9&#39;) | (&#39;a&#39;~&#39;f&#39;) | (&#39;A&#39;~&#39;F&#39;);

comment                = &#39;#&#39; &amp; printable_ws* &amp; LINE_END;

PARENTHESIZED(item)    = &#39;(&#39; &amp; TOKEN_SEP &amp; item &amp; TOKEN_SEP &amp; &#39;)&#39;;
ARG_SEP                = TOKEN_SEP &amp; &#39;,&#39; &amp; TOKEN_SEP;
TOKEN_SEP              = MAYBE_WSLC;

# Whitespace
MAYBE_WS               = WS*;
SOME_WS                = WS &amp; MAYBE_WS;
MAYBE_WSLC             = (WSL | comment)*;
SOME_WSLC              = WSL &amp; MAYBE_WSLC;
WSL                    = WS | LINE_END;
WS                     = HT | SP;
LINE_END               = CR? &amp; LF;
HT                     = &#39;\[9]&#39;;
LF                     = &#39;\[a]&#39;;
CR                     = &#39;\[d]&#39;;
SP                     = &#39;\[20]&#39;;
</code></pre></div>
</article>
  </div>

    </div>

  </div></div>
  </body>
</html>
