<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interjectedfuture.com/a-simple-way-to-understand-crdts/">Original</a>
    <h1>A simple way to understand CRDTs</h1>
    
    <div id="readability-page-1" class="page"><section>
        <p>There&#39;s a simple way to understand CRDTs: It leverages algebra to unmix the inevitable mixing of data when syncing over an unreliable network.</p><p>Why are networks unreliable? For one, it&#39;d be really expensive to build a network that assured 100% only-once delivery. But also, the internet was designed to allow variable routing paths and dynamic topologies to adapt to failures and congestion. This flexibility allows the network to stay up. The downside of this robustness is the variability of time delays and mixing of data when sending it from node to node.</p><p>There are three ways a network can mix up your data, and CRDTs constrain operations on the data to be algebraic to address each of them when syncing data.</p><ol><li>Two pieces of data can arrive out of sequential order.</li><li>Two pieces of data can arrive and we can&#39;t tell which one came first.</li><li>A piece of data could be repeated more than once.</li></ol><p>CRDTs neutralize this if an operation has three algebraic properties.</p><p>As an aside, For state-based CRDTs, the operation is called a merge, where given a data packet coming in, we can merge it with the existing state. For op-based CRDTs, the operation is called an apply, but it&#39;s effectively a merge with one less required property. We&#39;ll get to that.</p><p>When data comes in out of sequential order, we can neutralize this mixing if our merge op is <strong>associative</strong>. I&#39;ll denote our operation as a dot.</p><blockquote>(A . B) . C = A . (B . C)</blockquote><p>means that it doesn&#39;t matter whether B is merged first or C is merged first. The result will be the same.</p><p>When data comes in, and we can&#39;t tell which one came first, we can neutralize this mixing if our merge op is <strong>commutative</strong>.</p><blockquote>A . B = B . A</blockquote><p>means it doesn&#39;t matter whether they occurred at the same time. We can apply them in either order and get the same result.</p><p>And when data gets repeated more than once, we can neutralize it if our merge op is <strong>idempotent</strong>.</p><blockquote>A . B = A . B . B</blockquote><p>means we can apply B as much as we want, but it&#39;ll remain the same as applying it once. Not all operations we do on data will have these properties. But if we can constrain ourselves to only operations that have these algebraic properties over the data, then we have a much easier time syncing the data.</p><p>State-based CRDTs rely on their merge operation to have all three properties. But they aren&#39;t used in practice because their protocol requires sending the entire replica state, which can be prohibitive. That is unless they send deltas or diffs.</p><p>Op-based CRDTs sends cmds/events instead. The apply/merge operation here only needs to be commutative and idempotent. The associativity isn&#39;t required because Op-based CRDTs requires the protocol to enforce causal delivery of data. It simply shifted complexity from merge op to protocol.</p><p>All the details around CRDTs are just how to do this effectively. There&#39;s lots of details for sure, but just as a way to wrap your head around what it&#39;s doing, this is the core. The main idea is that by <em>constraining the power of our operations so that we get the same answer regardless of how they&#39;re applied, we can neutralize the unreliable nature of the network</em>. I&#39;ve seen lots of CRDT intros, but no one ever spells this out. </p>
    </section></div>
  </body>
</html>
