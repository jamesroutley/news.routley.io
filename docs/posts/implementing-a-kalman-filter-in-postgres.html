<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neon.com/blog/implementing-a-kalman-filter-in-postgres-to-smooth-gps-data">Original</a>
    <h1>Implementing a Kalman Filter in Postgres</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><span aria-owns="rmiz-modal-" data-rmiz=""><span data-rmiz-content="not-found"><img alt="Post image" fetchpriority="high" width="1024" height="576" decoding="async" data-nimg="1" sizes="(max-width: 767px) 100vw" srcset="/_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fneon-kalman.jpg&amp;w=640&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 640w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fneon-kalman.jpg&amp;w=750&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 750w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fneon-kalman.jpg&amp;w=828&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 828w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fneon-kalman.jpg&amp;w=1080&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 1080w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fneon-kalman.jpg&amp;w=1200&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 1200w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fneon-kalman.jpg&amp;w=1920&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 1920w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fneon-kalman.jpg&amp;w=2048&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 2048w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fneon-kalman.jpg&amp;w=3840&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 3840w" src="https://neon.com/_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fneon-kalman.jpg&amp;w=3840&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx"/></span></span></p><p>Modern GPS datasets are notoriously noisy: satellites drift, buildings scatter signals, and consumer devices introduce frequent errors. When working with millions of position samples from vehicles, smartphones, or IoT devices, this noise makes analysis unreliable. Routes jump, tracks zigzag, and outliers distort aggregates.</p>



<p>The <a href="https://en.wikipedia.org/wiki/Kalman_filter">Kalman Filter </a>is the standard technique for smoothing such data. Traditionally, it is applied outside the database in environments like Python or MATLAB. But for large-scale datasets stored in Postgres, filtering directly inside the database has clear advantages: no additional processing pipeline, results available immediately in SQL, and scalable analytics over billions of rows.</p>



<p>For our own usage at <a href="https://neon.com/blog/why-traconiq-migrated-from-aws-rds-to-neon">traconiq</a>, we built an open source project that implements a Kalman Filter in Postgres. You can explore the code and try it yourself here, if you also have GPS data:<a href="https://github.com/traconiq/kalman-filter-neon"> </a></p>



<p><a href="https://github.com/traconiq/kalman-filter-neon">github.com/traconiq/kalman-filter-neon</a></p>







<p>The Kalman Filter is a recursive algorithm used to estimate the true state of a dynamic system, such as the position of a moving vehicle, from noisy observations. At each step, it combines two parts:</p>



<ul>
<li>Prediction: uses a motion model to project the next position (and optionally velocity).</li>



<li>Update: corrects that prediction using the latest observed measurement.</li>
</ul>



<p>What makes the Kalman Filter effective is that it explicitly models uncertainty. Both the process (how the system evolves) and the measurements (GPS fixes) carry noise, represented in a covariance matrix. The filter continually refines its estimates as new data arrives, producing a smoothed track that follows the real trajectory more closely than raw GPS data.</p>



<p>Because of this, Kalman Filters are widely used in navigation, robotics, signal processing, and finance. Applied to GPS data, they can turn jittery position samples into realistic paths suitable for analytics or visualization.</p>



<figure><span aria-owns="rmiz-modal-" data-rmiz=""><span data-rmiz-content="not-found"><img alt="Post image" loading="lazy" width="1024" height="787" decoding="async" data-nimg="1" sizes="(max-width: 767px) 100vw" srcset="/_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-7.png&amp;w=640&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 640w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-7.png&amp;w=750&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 750w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-7.png&amp;w=828&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 828w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-7.png&amp;w=1080&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 1080w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-7.png&amp;w=1200&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 1200w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-7.png&amp;w=1920&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 1920w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-7.png&amp;w=2048&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 2048w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-7.png&amp;w=3840&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 3840w" src="https://neon.com/_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-7.png&amp;w=3840&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx"/></span></span><figcaption>An artificial GPS track with a very low confidence (high HDOP values). Red track: observations. Purple track: filtered data.</figcaption></figure>



<figure><span aria-owns="rmiz-modal-" data-rmiz=""><span data-rmiz-content="not-found"><img alt="Post image" loading="lazy" width="1024" height="787" decoding="async" data-nimg="1" sizes="(max-width: 767px) 100vw" srcset="/_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-8.png&amp;w=640&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 640w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-8.png&amp;w=750&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 750w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-8.png&amp;w=828&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 828w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-8.png&amp;w=1080&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 1080w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-8.png&amp;w=1200&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 1200w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-8.png&amp;w=1920&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 1920w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-8.png&amp;w=2048&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 2048w, /_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-8.png&amp;w=3840&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx 3840w" src="https://neon.com/_next/image?url=https%3A%2F%2Fneondatabase.wpengine.com%2Fwp-content%2Fuploads%2F2025%2F09%2Fimage-8.png&amp;w=3840&amp;q=85&amp;dpl=dpl_2Hd3eXZt5V9C7PqxyKUTxEJpkXJx"/></span></span><figcaption>A real GPS track with outliers (blue track: sensor data, red track: filtered track) and very low confidence (high HDOP values) in that area. The outliers that jump to the north are damped and smoothed, but not fully eliminated.</figcaption></figure>











<p>Implementing a Kalman Filter inside Postgres comes with a few difficulties. Unlike procedural languages, SQL does not naturally keep track of “state” across rows, and the filter depends on carrying forward information from one step to the next.</p>



<p>Three requirements in particular need to be addressed:</p>



<ul>
<li>State: the filter must store not only the last position estimate but also the covariance matrix that describes its uncertainty. Both are required to compute the next estimate.</li>



<li>Transition: for each new measurement, a user-defined function must update the state. This function can incorporate additional sensor data when available, such as the reported accuracy (HDOP) or measured speed, to adjust or even skip an update.</li>



<li>Sequencing: GPS points must be processed in strict time order. The filter only works if each step builds on the previous one, which means queries need to respect record order.</li>
</ul>



<p>For online filtering, state can be stored per device and updated with each insert. For offline filtering across historical tracks, the sequential nature of the filter makes it harder to implement efficiently in SQL, and requires more advanced techniques.</p>







<p>All code in this repo: <a href="https://github.com/traconiq/kalman-filter-neon">github.com/traconiq/kalman-filter-neon</a></p>







<p>The script <code>example-schema.sql</code> sets up a schema called <code>kalman</code> with two core tables. This design ensures that the state (estimate + covariance) needed for the next filter step is always available:</p>



<ul>
<li><code>kalman.positions</code>: stores raw GPS points as well as the filtered positions created during online filtering.</li>



<li><code>kalman.devices</code>: stores device information, including the last known position estimate and covariance matrix for each device.</li>
</ul>







<p>The main function to perform the Kalman step is <code>kalman.kalman_step</code>: it takes the previous estimate and covariance, along with the current measurement, and returns an updated estimate.For online filtering, a wrapper function (<code>kalman.kalman_upsert_position</code>) handles inserts a new GPS point into <code>kalman.positions</code> and simultaneously applies the Kalman step, updating the device’s state in <code>kalman.devices</code>.</p>







<p>Online filtering is applied as each GPS point is inserted. This ensures smoothed positions are always available, but it comes at the cost of higher insert latency.</p>



<p>Offline filtering is applied later, in batch, across a history of positions. This can be done in two ways:</p>



<ul>
<li>Recursive CTEs: step through ordered GPS history, carrying the filter state forward record by record. Transparent, but slower.</li>



<li>Custom aggregates: repeatedly apply the filter under the hood as rows are combined. More efficient for large-scale postprocessing and fits naturally into SQL analytics.</li>
</ul>






<div><p><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none" viewBox="0 0 14 15"><g clip-path="url(#note_inline_svg__a)"><path fill="currentColor" fill-rule="evenodd" d="M1.697 7.497a5.302 5.302 0 1 1 10.605 0 5.302 5.302 0 0 1-10.605 0M7 .794A6.702 6.702 0 1 0 7 14.2 6.702 6.702 0 0 0 7 .794m0 3.214a.7.7 0 0 1 .7.7v3.447a.7.7 0 1 1-1.4 0V4.708a.7.7 0 0 1 .7-.7m0 6.99a.777.777 0 1 0 0-1.555.777.777 0 0 0 0 1.555" clip-rule="evenodd"></path></g><defs><clipPath id="note_inline_svg__a"><path fill="#fff" d="M0 .5h14v14H0z"></path></clipPath></defs></svg><h4>TL;DR</h4></p><div><p>Online filtering is practical if you need filtered positions available immediately, but more expensive per insert.</p></div></div>


<p>Of course, we wanted to measure performance. We run four pgbench scripts:</p>



<ul>
<li><code>benchmark_insert_nofilter.sql</code> to insert GPS points without filtering</li>



<li><code>benchmark_insert_upsert.sql</code> to insert GPS points with online filtering</li>



<li><code>benchmark_offline_recursive.sql</code> for offline filtering via a recursive query.</li>



<li><code>benchmark_offline_aggregate.sql</code> for offline filtering via a custom aggregate</li>
</ul>



<p>All benchmarks were run on the same machine and dataset, using <code>pgbench -f &lt;script&gt;.sql -t 1000</code>.</p>



<p>The results show that applying the filter during inserts is feasible but comes with a significant performance penalty: throughput drops by about 35 – 40%. For applications where smoothed data must be immediately available, this tradeoff may be acceptable.</p>



<figure><table><thead><tr><th>Test</th><th data-align="center">INSERT NO FILTER</th><th data-align="center">INSERT WITH FILTER</th></tr></thead><tbody><tr><td>number of clients</td><td data-align="center">1</td><td data-align="center">1</td></tr><tr><td>number of transactions</td><td data-align="center">1000</td><td data-align="center">1000</td></tr><tr><td>latency avg (ms)</td><td data-align="center">8.543</td><td data-align="center">13.560</td></tr><tr><td>tps (excluding connections)</td><td data-align="center">117.048322</td><td data-align="center">73.743893</td></tr></tbody></table><figcaption>Benchmark: Online filtering during insert<br/></figcaption></figure>



<p>When comparing it to the offline filtering method, the difference is clear. Recursive queries work, but they add considerable overhead. Custom aggregates, by contrast, achieve higher throughput and are therefore the preferred method for large datasets or batch processing.</p>



<figure><table><thead><tr><th>Test</th><th data-align="center">Offline recursive</th><th data-align="center">Offline aggregate</th></tr></thead><tbody><tr><td>number of clients</td><td data-align="center">1</td><td data-align="center">1</td></tr><tr><td>number of transactions</td><td data-align="center">1000</td><td data-align="center">1000</td></tr><tr><td>latency avg (ms)</td><td data-align="center">0.290</td><td data-align="center">0.226</td></tr><tr><td>tps (excluding connections)</td><td data-align="center">3442.637060</td><td data-align="center">4419.401171</td></tr></tbody></table><figcaption>Benchmark: Offline filtering via recursive query vs aggregate</figcaption></figure>







<p><a href="https://github.com/traconiq/kalman-filter-neon/blob/main/example-schema.sql">This script </a>provides a complete demonstration of how the Kalman Filter can be used directly inside Postgres for both real-time smoothing and large-scale postprocessing.</p>







<p>You can explore the full implementation in the repo: <a href="https://github.com/traconiq/kalman-filter-neon">github.com/traconiq/kalman-filter-neon</a></p>



<p>To get the feel for it, </p>



<ol>
<li>Run <code>example-schema.sql</code> to create the schema, tables, and functions</li>



<li>Load <code>example-usage.sql</code> to insert sample data and see online and offline filtering in action.</li>



<li>Experiment with the benchmark scripts (<code>benchmark_insert_nofilter.sql</code>, <code>benchmark_insert_upsert.sql</code>, <code>benchmark_offline_recursive.sql</code>, <code>benchmark_offline_aggregate.sql</code>) to compare performance in your own environment.</li>
</ol>


<div><p><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none" viewBox="0 0 14 15"><g clip-path="url(#tip_inline_svg__a)"><path fill="currentColor" fill-rule="evenodd" d="M7.002.5c-2.9 0-5.236 2.374-5.236 5.286a5.29 5.29 0 0 0 1.943 4.107c.56.457.892.98.892 1.484v.46a.7.7 0 0 0 .7.699h3.402a.7.7 0 0 0 .7-.7v-.459c0-.504.331-1.027.891-1.484a5.29 5.29 0 0 0 1.944-4.107C12.238 2.874 9.9.501 7.002.501M3.166 5.787c0-2.153 1.724-3.885 3.836-3.885s3.836 1.732 3.836 3.885a3.89 3.89 0 0 1-1.43 3.023c-.646.527-1.302 1.322-1.394 2.327H5.99c-.093-1.005-.749-1.8-1.395-2.327a3.89 3.89 0 0 1-1.43-3.023M5.3 13.103a.7.7 0 1 0 0 1.4h3.402a.7.7 0 1 0 0-1.4z" clip-rule="evenodd"></path></g><defs><clipPath id="tip_inline_svg__a"><path fill="#fff" d="M0 .5h14v14H0z"></path></clipPath></defs></svg><h4>Run it on Neon</h4></p><p><a href="https://neon.com/">Neon’s</a> serverless architecture is great to test recursive queries and aggregates on large datasets, while autoscaling and branching let you experiment without extra setup. <a href="https://console.neon.tech/signup">Spin up a free Postgres database instantly for free</a> and point your client to the Neon connection string to get started.</p></div></div></div>
  </body>
</html>
