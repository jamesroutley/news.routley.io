<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.magicleap.com/en-us/magic-leap-2-video">Original</a>
    <h1>Magic Leap 2: The most immersive AR platform for enterprise</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <p><strong>Wednesday, September 28, 2022</strong></p>

    <p>In software engineering, there are two principles that often come into conflict.
The first one is the principal of least surprise.
The second one is doing the right thing.
These come into conflict when the usual thing that people do is in fact the wrong thing.
A particular example of this is the behavior of rounding.</p>
<p>In school we were taught that rounding is always done in one particular way.
When you round a number it goes toward the nearest hole number, but if it ends in 5, than it goes toward the higher one.
For example, 1.3 rounds to 1, and 1.7 rounds to 2. And we were taught that 1.5 rounds to 2, and 2.5 goes to 3.</p>
<p>Because this is the way that we were taught rounding works, it can be quite surprising when rounding works differently.
In fact, there are a number of different ways to round numbers.
The Wikipedia <a href="https://en.wikipedia.org/wiki/Rounding">article on rounding</a> gives no fewer than 14 different methods of rounding.
Fortunately, with computers, we expect fewer: The IEEE 754 standard for floating point numbers defines five rounding rules.</p>
<p>Those five rules, along with their Python equivalents, are:</p>
<ul>
<li>round toward infinity (<code>math.ceil</code>)</li>
<li>round toward negative infinity (<code>math.floor</code>)</li>
<li>round toward zero (<code>math.trunc</code>)</li>
<li>round half-to-even (<code>round</code>)</li>
<li>round half-away-from-0 (no built-in equivalent that I found)</li>
</ul>
<p>Sneaking in there is <code>round</code>, defined as rounding half-to-even.
A lot of people are surprised by this the first time they call <code>round</code> with Python!
It definitely is surprising if you are expecting the &#34;round half toward higher numbers&#34; behavior.</p>
<pre><code><span>&gt;&gt;&gt; </span><span>round</span><span>(</span><span>1</span><span>.</span><span>5</span><span>)
</span><span>2
</span><span>&gt;&gt;&gt; </span><span>round</span><span>(</span><span>2</span><span>.</span><span>5</span><span>)
</span><span>2
</span></code></pre>
<p>So that we can see that Python&#39;s rounding behavior the principal least surprise.
Why is this the default behavior?</p>
<p>There really two good reasons have rounding half-to-even as the default:</p>
<ol>
<li>
<p>It&#39;s more likely what you actually want.
When you always round up, you introduce bias across a lot of rounding operations.
When you sum up the rounded values, you&#39;ll have a little bit less bias in the final sum.</p>
<p>In fact, some of the <a href="https://docs.python.org/3/library/math.html#math.fsum">Python docs</a> mention that floating point math guarantees rely on the half-even rounding in some cases:</p>
<blockquote>
<p>The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even.</p>
</blockquote>
</li>
<li>
<p>Having it as the default is... the standard.
The IEEE 754 standard for floating point numbers requires this as the default.</p>
<p>From the standard:</p>
<blockquote>
<p>The roundTiesToEven rounding-direction attribute shall be the default rounding-direction attribute for
results in binary formats.</p>
</blockquote>
</li>
</ol>
<p>Of course, the standard also requires that five different rounding mechanisms are available to users.
Python does make those available, but only on the <code>decimal</code> type.
The other expected behavior can typically be implemented using <code>floor</code>, <code>ceil</code>, and <code>trunc</code>.
Of course, that&#39;s extra work and room to get things wrong.</p>
<p>At the end of the day, if your application depends on specific rounding behavior than you should probably verify what behavior your libraries give you before you use them.
And, of course, Python does give you the functionality you need in the <a href="https://docs.python.org/3/library/decimal.html#module-decimal">decimal</a> package.
To quote the docs:</p>
<blockquote>
<p>The decimal module provides support for fast correctly rounded decimal floating point arithmetic.</p>
</blockquote>
<p>It gives you all the rounding modes you want, more exact representations, and less error introduced into arithmetic.
When you care about the details a <em>lot</em> and your application depends on them, you can get the rounding you want!
And when you don&#39;t care about it, but just want the thing that probably works, Python gives you a reasonable default.</p>
<p>Ultimately, I think that the Python and choice here the break ties toward even numbers is a sensible choice, made stronger by the presence of the decimal package.
Managing these tradeoffs is difficult, and the Python developer who chose this rounding behavior made the right call.
I, for one, would rather have people accidentally do the right thing and be surprised, rather than avoid surprise so that people can do the wrong thing.</p>
<hr/>
<p>Extra content time!
I did some sleuthing to see where and when this behavior came from.
This is all &#34;as far as I can tell&#34;—if there are errors, please let me know nicely.</p>
<p><strong>When was the <code>round</code> function added to Python?</strong></p>
<p>It was added in commit <a href="https://github.com/python/cpython/commit/9e51f9bec85">9e51f9bec85</a> by Guido van Rossum himself.
The intial implementation:</p>
<pre><code><span>static</span><span> object </span><span>*
</span><span>builtin_round</span><span>(self</span><span>, </span><span>args)
	object </span><span>*</span><span>self</span><span>;
</span><span>	object </span><span>*</span><span>args</span><span>;
</span><span>{
	</span><span>extern double</span><span> floor </span><span>PROTO</span><span>((</span><span>double</span><span>))</span><span>;
	</span><span>extern double</span><span> ceil </span><span>PROTO</span><span>((</span><span>double</span><span>))</span><span>;
	</span><span>double</span><span> x</span><span>;
	</span><span>double</span><span> f</span><span>;
	</span><span>int</span><span> ndigits </span><span>= </span><span>0</span><span>;
	</span><span>int</span><span> sign </span><span>= </span><span>1</span><span>;
	</span><span>int</span><span> i</span><span>;
	</span><span>if </span><span>(</span><span>!</span><span>getargs</span><span>(args</span><span>, </span><span>&#34;d&#34;</span><span>, </span><span>&amp;</span><span>x)) {
		</span><span>err_clear</span><span>()</span><span>;
		</span><span>if </span><span>(</span><span>!</span><span>getargs</span><span>(args</span><span>, </span><span>&#34;(di)&#34;</span><span>, </span><span>&amp;</span><span>x</span><span>, </span><span>&amp;</span><span>ndigits))
			</span><span>return NULL</span><span>;
	</span><span>}
	f </span><span>= </span><span>1</span><span>.</span><span>0</span><span>;
	</span><span>for </span><span>(i </span><span>=</span><span> ndigits</span><span>; </span><span>--</span><span>i </span><span>&gt;= </span><span>0</span><span>; </span><span>)
		f </span><span>=</span><span> f</span><span>*</span><span>10</span><span>.</span><span>0</span><span>;
	</span><span>for </span><span>(i </span><span>=</span><span> ndigits</span><span>; </span><span>++</span><span>i </span><span>&lt;= </span><span>0</span><span>; </span><span>)
		f </span><span>=</span><span> f</span><span>*</span><span>0</span><span>.</span><span>1</span><span>;
	</span><span>if </span><span>(x </span><span>&gt;= </span><span>0</span><span>.</span><span>0</span><span>)
		</span><span>return </span><span>newfloatobject</span><span>(</span><span>floor</span><span>(x</span><span>*</span><span>f </span><span>+ </span><span>0</span><span>.</span><span>5</span><span>) </span><span>/</span><span> f)</span><span>;
	</span><span>else
		return </span><span>newfloatobject</span><span>(</span><span>ceil</span><span>(x</span><span>*</span><span>f </span><span>- </span><span>0</span><span>.</span><span>5</span><span>) </span><span>/</span><span> f)</span><span>;
</span><span>}
</span></code></pre>
<p>It looks like it was initially rounding half-away-from-zero!
And it&#39;s pretty easy to read.</p>
<p>This was changed in 2007 by Guido van Rossum, Alex Martelli, and Keir Mierle in commit <a href="https://github.com/python/cpython/commit/2fa33db12b8cb6ec1dd1b87df6911e311d98457b">2fa33db12b8cb6ec1dd1b87df6911e311d98457b</a>.
Here you can see the now-more-complex implementation:</p>
<pre><code><span>static</span><span> PyObject </span><span>*
</span><span>float_round</span><span>(PyObject </span><span>*</span><span>v</span><span>,</span><span> PyObject </span><span>*</span><span>args)
{
</span><span>#define UNDEF_NDIGITS </span><span>(</span><span>-</span><span>0x7fffffff</span><span>) </span><span>/* Unlikely ndigits value */
	</span><span>double</span><span> x</span><span>;
	</span><span>double</span><span> f</span><span>;
	</span><span>double</span><span> flr</span><span>,</span><span> cil</span><span>;
	</span><span>double</span><span> rounded</span><span>;
	</span><span>int</span><span> i</span><span>;
	</span><span>int</span><span> ndigits </span><span>=</span><span> UNDEF_NDIGITS</span><span>;

	</span><span>if </span><span>(</span><span>!</span><span>PyArg_ParseTuple</span><span>(args</span><span>, </span><span>&#34;|i&#34;</span><span>, </span><span>&amp;</span><span>ndigits))
		</span><span>return NULL</span><span>;

</span><span>	x </span><span>= </span><span>PyFloat_AsDouble</span><span>(v)</span><span>;

	</span><span>if </span><span>(ndigits </span><span>!=</span><span> UNDEF_NDIGITS) {
		f </span><span>= </span><span>1</span><span>.</span><span>0</span><span>;
</span><span>		i </span><span>= </span><span>abs</span><span>(ndigits)</span><span>;
		</span><span>while  </span><span>(</span><span>--</span><span>i </span><span>&gt;= </span><span>0</span><span>)
			f </span><span>=</span><span> f</span><span>*</span><span>10</span><span>.</span><span>0</span><span>;
		</span><span>if </span><span>(ndigits </span><span>&lt; </span><span>0</span><span>)
			x </span><span>/=</span><span> f</span><span>;
		</span><span>else
</span><span>			x </span><span>*=</span><span> f</span><span>;
	</span><span>}

	flr </span><span>= </span><span>floor</span><span>(x)</span><span>;
</span><span>	cil </span><span>= </span><span>ceil</span><span>(x)</span><span>;

	</span><span>if </span><span>(x</span><span>-</span><span>flr </span><span>&gt; </span><span>0</span><span>.</span><span>5</span><span>)
		rounded </span><span>=</span><span> cil</span><span>;
	</span><span>else if </span><span>(x</span><span>-</span><span>flr </span><span>== </span><span>0</span><span>.</span><span>5</span><span>)
		rounded </span><span>= </span><span>fmod</span><span>(flr</span><span>, </span><span>2</span><span>) </span><span>== </span><span>0 </span><span>?</span><span> flr </span><span>:</span><span> cil</span><span>;
	</span><span>else
</span><span>		rounded </span><span>=</span><span> flr</span><span>;

	</span><span>if </span><span>(ndigits </span><span>!=</span><span> UNDEF_NDIGITS) {
		</span><span>if </span><span>(ndigits </span><span>&lt; </span><span>0</span><span>)
			rounded </span><span>*=</span><span> f</span><span>;
		</span><span>else
</span><span>			rounded </span><span>/=</span><span> f</span><span>;
		</span><span>return </span><span>PyFloat_FromDouble</span><span>(rounded)</span><span>;
	</span><span>}

	</span><span>return </span><span>PyLong_FromDouble</span><span>(rounded)</span><span>;
</span><span>#undef</span><span> UNDEF_NDIGITS
}
</span></code></pre>
<p>Notably, we can see from the tags on GitHub that this was present in Python 2.7 and in Python 3.0.
So, this behavior has been around for quite a while.
There was <a href="https://bugs.python.org/issue32956">quite some discussion</a> about it in the Python bug tracker at the time.</p>
<p>Well, our little historical escapade is over!
I still agree with the folks in that discussion that round half-to-even is the right behavior.</p>
<p>Later! 👋</p>
<hr/>
<p>There&#39;s a companion post to this one over on my friend John&#39;s blog!
You can read <a href="https://thetmpfiles.com/2022/09/28/why-is-python-rounding-wrong/">his post</a> for another take on Python&#39;s rounding behavior.</p>

  </article><p>If you have comments or find errors, please <a href="mailto:blogfeedback@ntietz.com">email me</a>! For updates when I post new things, I have a lovely <a href="https://ntietz.com/atom.xml">RSS feed</a> you can use.
</p></div>
  </body>
</html>
