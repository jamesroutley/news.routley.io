<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://muxup.com/2022q3/whats-new-for-risc-v-in-llvm-15">Original</a>
    <h1>What&#39;s new for RISC-V in LLVM 15</h1>
    
    <div id="readability-page-1" class="page"><div id="article-container">


<p><span title="2022-09-21">2022Q3</span>.</p>
<p>LLVM 15.0.0 was
<a href="https://discourse.llvm.org/t/llvm-15-0-0-release/65099">released</a> around
about two weeks ago now, and I wanted to highlight some of RISC-V specific
changes or improvements that were introduced while going into a little more
detail than I was able to in the <a href="https://releases.llvm.org/15.0.0/docs/ReleaseNotes.html#changes-to-the-risc-v-backend">release
notes</a>.</p>
<p>In case you&#39;re not familiar with LLVM&#39;s release schedule, it&#39;s worth noting
that there are two major LLVM releases a year (i.e. one roughly every 6
months) and these are timed releases as opposed to being cut when a pre-agreed
set of feature targets have been met. We&#39;re very fortunate to benefit from an
active and growing set of contributors working on RISC-V support in LLVM
projects, who are responsible for the work I describe below - thank you!
I coordinate biweekly sync-up calls for RISC-V LLVM contributors, so if you&#39;re
working in this area please <a href="https://discourse.llvm.org/c/code-generation/riscv/57">consider dropping
in</a>.</p>
<h2 id="linker-relaxation"><a href="#linker-relaxation" aria-hidden="true" tabindex="-1"></a>Linker relaxation</h2>
<p>Linker relaxation is a mechanism for allowing the linker to optimise code
sequences at link time. A code sequence to jump to a symbol might
conservatively take two instructions, but once the target address is known at
link-time it might be small enough to fit in the immediate of a single
instruction, meaning the other can be deleted. Because a linker performing
relaxation may delete bytes (rather than just patching them), offsets
including those for jumps within a function may be changed. To allow this to
happen without breaking program semantics, even local branches that might
typically be resolved by the assembler must be emitted as a relocation when
linker relaxation is enabled. See the <a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc#linker-relaxation">description in the RISC-V
psABI</a>
or <a href="https://www.sifive.com/blog/all-aboard-part-3-linker-relaxation-in-riscv-toolchain">Palmer Dabbelt&#39;s blog post on linker
relaxation</a>
for more background.</p>
<p>Although LLVM has supported codegen for linker relaxation for a long time, LLD
(the LLVM linker) has until now lacked support for processing these
relaxations. Relaxation is primarily an optimisation, but processing of
<code>R_RISCV_ALIGN</code> (the alignment relocation) is necessary for correctness when
linker relaxation is enabled, meaning it&#39;s not possible to link such object
files correctly without at least some minimal support. Fangrui Song
implemented support for
<code>R_RISCV_ALIGN/R_RISCV_CALL/R_RISCV_CALL_PLT/R_RISCV_TPREL_*</code> relocations in
LLVM 15 and wrote up a <a href="https://maskray.me/blog/2022-07-10-riscv-linker-relaxation-in-lld">blog post with more implementation
details</a>,
which is a major step in bringing us to parity with the GCC/binutils
toolchain.</p>
<h2 id="optimisations"><a href="#optimisations" aria-hidden="true" tabindex="-1"></a>Optimisations</h2>
<p>As with any release, there&#39;s been a large number of codegen improvements, both
target-independent and target-dependent. One addition to highlight in the
RISC-V backend is the new <a href="https://github.com/llvm/llvm-project/blob/release/15.x/llvm/lib/Target/RISCV/RISCVCodeGenPrepare.cpp">RISCVCodeGenPrepare
pass</a>.
This is the latest piece of a long-running campaign (largely led by Craig
Topper) to improve code generation related to sign/zero extensions on RV64.
<a href="https://llvm.org/docs/Passes.html#codegenprepare-optimize-for-code-generation">CodeGenPrepare</a>
is a target-independent pass that performs some late-stage transformations to
the input ahead of lowering to SelectionDAG. The RISC-V specific version looks
for opportunities to convert zero-extension to i64 with a sign-extension
(which is cheaper).</p>
<p>Another new pass that may be of interest is
<a href="https://github.com/llvm/llvm-project/blob/release/15.x/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp">RISCVMakeCompressible</a>
(contributed by Lewis Revill and Craig Blackmore).  Rather than trying to
improve generated code performance, this is solely focused on reducing code
size, and may increase the static instruction count in order to do so (which
is why it&#39;s currently only enabled at the <code>-Oz</code> optimisation level). It looks
for cases where an instruction has been selected which can&#39;t be represented by
one of the compressed (16-bit as opposed to 32-bit wide) instruction forms.
For instance due to the register not being one of the registers addressable
from the compressed instruction, or the offset being out of range). It will
then look for opportunities to transform the input to make the instructions
compressible. Grabbing two examples from the header comment of the pass:</p>
<div><pre><span></span><code><span>; &#39;zero&#39; register not addressable in compressed store.</span>
                 <span>=&gt;</span>   <span>li</span> <span>a1</span>, <span>0</span>
<span>sw</span> <span>zero</span>, <span>0</span>(<span>a0</span>)   <span>=&gt;</span>   <span>c.sw</span> <span>a1</span>, <span>0</span>(<span>a0</span>)
<span>sw</span> <span>zero</span>, <span>8</span>(<span>a0</span>)   <span>=&gt;</span>   <span>c.sw</span> <span>a1</span>, <span>8</span>(<span>a0</span>)
<span>sw</span> <span>zero</span>, <span>4</span>(<span>a0</span>)   <span>=&gt;</span>   <span>c.sw</span> <span>a1</span>, <span>4</span>(<span>a0</span>)
<span>sw</span> <span>zero</span>, <span>24</span>(<span>a0</span>)  <span>=&gt;</span>   <span>c.sw</span> <span>a1</span>, <span>24</span>(<span>a0</span>) 
</code></pre></div>

<p>and</p>
<div><pre><span></span><code><span>; compressed stores support limited offsets</span>
<span>lui</span> <span>a2</span>, <span>983065</span>     <span>=&gt;</span>   <span>lui</span> <span>a2</span>, <span>983065</span> 
                   <span>=&gt;</span>   <span>addi</span>  <span>a3</span>, <span>a2</span>, <span>-256</span>
<span>sw</span>  <span>a1</span>, <span>-236</span>(<span>a2</span>)   <span>=&gt;</span>   <span>c.sw</span>  <span>a1</span>, <span>20</span>(<span>a3</span>)
<span>sw</span>  <span>a1</span>, <span>-240</span>(<span>a2</span>)   <span>=&gt;</span>   <span>c.sw</span>  <span>a1</span>, <span>16</span>(<span>a3</span>)
<span>sw</span>  <span>a1</span>, <span>-244</span>(<span>a2</span>)   <span>=&gt;</span>   <span>c.sw</span>  <span>a1</span>, <span>12</span>(<span>a3</span>)
<span>sw</span>  <span>a1</span>, <span>-248</span>(<span>a2</span>)   <span>=&gt;</span>   <span>c.sw</span>  <span>a1</span>, <span>8</span>(<span>a3</span>)
<span>sw</span>  <span>a1</span>, <span>-252</span>(<span>a2</span>)   <span>=&gt;</span>   <span>c.sw</span>  <span>a1</span>, <span>4</span>(<span>a3</span>)
<span>sw</span>  <span>a0</span>, <span>-256</span>(<span>a2</span>)   <span>=&gt;</span>   <span>c.sw</span>  <span>a0</span>, <span>0</span>(<span>a3</span>)
</code></pre></div>

<p>There&#39;s a whole range of other backend codegen improvements, including
additions to existing RISC-V specific passes but unfortunately it&#39;s not
feasible to enumerate them all.</p>
<p>One improvement to note from the Clang frontend is that <a href="https://reviews.llvm.org/rG7a5cb15ea6fa">the C intrinsics for
the RISC-V Vector extension are now lazily
generated</a>, avoiding the need to
parse a huge pre-generated header file and improving compile times.</p>
<h2 id="support-for-new-instruction-set-extensions"><a href="#support-for-new-instruction-set-extensions" aria-hidden="true" tabindex="-1"></a>Support for new instruction set extensions</h2>
<p>A batch of new instruction set extensions <a href="https://riscv.org/announcements/2021/12/riscv-ratifies-15-new-specifications/">were ratified at the end of last
year</a>
(see also the <a href="https://wiki.riscv.org/display/HOME/Recently+Ratified+Extensions">recently ratified extension
list</a>.  LLVM
14 already <a href="https://releases.llvm.org/14.0.0/docs/ReleaseNotes.html#changes-to-the-risc-v-target">featured a number of
these</a>
(with the vector and ratified bit manipulation extensions no longer being
marked as experimental). In LLVM 15 we were able to fill in some of the gaps,
adding support for additional ratified extensions as well as some new
experimental extensions.</p>
<p>In particular:</p>
<ul>
<li>Assembler and disassembler support for the <a href="https://github.com/riscv/riscv-zfinx/blob/main/zfinx-1.0.0.pdf">Zdinx, Zfinx, Zhinx, and Zhinxmin
extensions</a>.
Cores that implement these extensions store double/single/half precision
floating point values in the integer register file (GPRs) as opposed to having a
separate floating-point register file (FPRs).
<ul>
<li>The instructions defined in the conventional floating point extensions are
defined to instead operate on the general purpose registers, and
instructions that become redundant (namely those that involve moving
values from FPRs to GPRs) are removed.</li>
<li>Cores might implement these extensions rather than the conventional
floating-point in order to reduce the amount of architectural state that
is needed, reducing area and context-switch cost. The downside is of
course that register pressure for the GPRs will be increased.</li>
<li>Codegen for these extensions is not yet supported (i.e. the extensions are
only supported for assembly input or inline assembly). A patch to provide
this support <a href="https://reviews.llvm.org/D122918">is under review</a> though.</li>
</ul>
</li>
<li>Assembler and disassembler support for the <a href="https://github.com/riscv/riscv-CMOs/blob/master/specifications/cmobase-v1.0.pdf">Zicbom, Zicbop, and Zicboz
extensions</a>.
These cache management operation (CMO) extensions add new instructions for
invalidating, cleaning, and flushing cache blocks (Zicbom), zeroing cache
blocks (Zicboz), and prefetching cache blocks (Zicbop).
<ul>
<li>These operations aren&#39;t currently exposed via C intrinsics, but these will
be added once the appropriate naming has been agreed.</li>
<li>One of the questions raised during implementation was about the <a href="https://github.com/riscv/riscv-CMOs/issues/47">preferred
textual format for the
operands</a>. Specifically,
whether it should be e.g. <code>cbo.clean (a0)</code>/<code>cbo.clean 0(a0)</code> to match the
format used for other memory operations, or <code>cbo.clean a0</code> as was used in
an early binutils patch. We were able to agree between the CMO working
group, LLVM, and GCC developers on the former approach.</li>
</ul>
</li>
<li>Assembler, disassembler, and codegen support for the <a href="https://github.com/riscv/riscv-isa-manual/commit/f518c259c008f926eba4aba67804f62531b6e94b">Zmmul
extension</a>.
This extension is just a subset of the &#39;M&#39; extension providing just the
multiplication instructions without the division instructions.</li>
<li>Assembler and disassembler support for the additional CSRs (control and
status registers) and instructions introduced by the <a href="https://github.com/riscv/riscv-isa-manual/commit/f518c259c008f926eba4aba67804f62531b6e94b">hypervisor and
Svinval additions to the privileged architecture
specification</a>.
Svinval provides fine-grained address-translation cache invalidation and
fencing, while the hypervisor extension provides support for efficiently
virtualising the supervisor-level architecture (used to implement KVM for
RISC-V).</li>
<li>Assembler and disassembler support for the
<a href="https://github.com/riscv/riscv-isa-manual/blob/266f3759c9c88b0ae18cfca70f875662d89b52db/src/zihintpause.tex">Zihintpause
extension</a>.
This adds the <code>pause</code> instruction intended for use as a hint within
spin-wait loops.
<ul>
<li>Zihintpause was actually the first extension to <a href="https://riscv.org/announcements/2021/02/risc-v-international-unveils-fast-track-architecture-extension-process-and-ratifies-zihintpause-extension/">go
through</a>
RISC-V International&#39;s fast-track architecture extension process back in
early 2021. We were clearly slow to add it to LLVM, but are trying to keep
a closer eye on ratified extensions going forwards.</li>
</ul>
</li>
<li>Support was added for the not yet ratified <a href="https://github.com/riscv/riscv-v-spec/pull/780">Zvfh
extension</a>, providing
support for half precision floating point values in RISC-V vectors.
<ul>
<li>Unlike the extensions listed above, support for Zvfh is experimental. This
is a status we use within the RISC-V backend for extensions that are not
yet ratified and may change from release to release with no guarantees on
backwards compatibility. Enabling support for such extensions requires
passing <code>-menable-experimental-extensions</code> to Clang and specifying the
extension&#39;s version when listing it in the <code>-march</code> string.</li>
</ul>
</li>
</ul>
<p>It&#39;s not present in LLVM 15, but LLVM 16 onwards will feature a
<a href="https://github.com/llvm/llvm-project/blob/main/llvm/docs/RISCVUsage.rst">user guide for the RISC-V
target</a>
summarising the level of support for each extension (huge thanks to Philip
Reames for kicking off this effort).</p>
<h2 id="other-changes"><a href="#other-changes" aria-hidden="true" tabindex="-1"></a>Other changes</h2>
<p>In case I haven&#39;t said it enough times, there&#39;s far more interesting changes
than I could reasonably cover. Apologies if I&#39;ve missed your favourite new
feature or improvement. In particular, I&#39;ve said relatively little about
RISC-V Vector support. There&#39;s been a long series of improvements and
correctness fixes in the LLVM 15 development window, after RVV was made
non-experimental in LLVM 14 and there&#39;s much more to come in LLVM 16 (e.g.
scalable vectorisation becoming enabled by default).</p>

</div></div>
  </body>
</html>
