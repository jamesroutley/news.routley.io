<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nical.github.io/posts/rust-custom-allocators.html">Original</a>
    <h1>Custom Allocators in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Lately I have been looking into custom allocators in the Rust. Recent internet chatter about <a href="https://ziglang.org/">the Zig programming language</a> has brought allocators back to my attention, but custom allocators are an old topic. I remember playing with that a long while back in my C++ days after watching <a href="https://www.youtube.com/watch?v=LIb3L4vKZ7U&amp;t=21s">a talk by Andrei Alexandrescu</a>. I found it a satisfying thing to hack on because you can start off with simple things that work quickly, build them out of composable parts and of course the rabbit hole is deep enough that after spending a lot of time you get to feel great about pulling advanced stunts. That said, I&#39;m already digressing. I am not going to write about building memory allocators today, just about writing data structures that can accept different allocators. This isn&#39;t about replacing the global allocator either, mind you, but making it possible for different parts of a program to chose their memory allocation strategies. I&#39;ll first superficially ramble a bit about the the motivation and state of affairs in the Rust ecosystem, then I&#39;ll go over an experiment I made to integrate custom allocators in <a href="https://crates.io/crates/lyon">lyon</a>&#39;s tessellator in a few different ways.</p>

<p>I&#39;ve long had a mild dislike for the &#34;one and only global allocator&#34; strategy. It&#39;s a pretty simple and decent default, to a point that a lot of programmers forgot that there are alternative ways to work with memory. I look at performance profiles a lot at work and allocation/deallocation is at the same time always prominent and also kind of elusive. It is hard to distill down simple benchmarks for allocation overhead, because of much of that overhead comes from cache misses and contention between multiple threads using the same allocator.</p>
<p>To mitigate allocation performance issues, it is very common to build algorithms in ways that allow keeping the data structures that hold intermediate state around. This way subsequent runs can reuse the allocations from the previous ones. <a href="https://crates.io/crates/lyon">lyon</a>&#39;s tessellator is written like that for example. In <a href="https://github.com/servo/webrender">WebRender</a> we also try to keep temporary allocations around. I&#39;ll refer to this approach as &#34;recycling allocations&#34; and it is basically about accepting that interacting with allocators is slow and making contraptions to avoid it.</p>
<p>Another option is to take a step back and think a bit about whether memory allocations really need to be slow. What are the different allocation patterns? Are they all best served by a general purpose allocator? Bump allocators are very good at providing very fast short-lived allocations. They also can work very well with groups of allocations with a common and well defined scope, for example a frame in a video game or a graphics rendering engine. Most allocations stay in the thread they are created with. Using a simpler thread-local allocator wherever it makes sense can provides some wins.
Of course there are also long-lived allocations with mostly unpredictable lifetimes backing resources that may or may not move to different threads. These are well served by a global allocator, are they the majority of allocations in majority of programs? I don&#39;t think so and I&#39;m not the only one. Some languages (Zig, Jai and others) have made that it a pillar of their library design to make it possible and convenient to pick the right allocation strategy everywhere allocation needs to happen.</p>
<p>Using custom allocators to avoid paying the cost of memory allocations for temporary data sounds like more work than recycling for about the same benefits, but the benefits can go beyond merely skipping the allocator overhead. When keeping around an allocation for later use, we take memory that is nice and warm in the cache hierarchy after its use and enforce that only future uses of this specific code will be able to use it again. Something else that runs immediately after could have benefited from that memory for its own temporary allocations, but it will have to reach for other pieces of memory that may not be as readily available.
When running on a tight memory budgets, hoarding temporary data structures can also occupy precious resources.</p>
<p>Of course all of these advantages require understanding allocation lifetime patterns and picking the right strategy for the each part of the code. It&#39;s not like slapping a bump allocator under an algorithm will always make it faster. That algorithm could be made slower if the underlying allocator is fast but fails to reuse memory that is warm in CPU caches. It&#39;s an extra mental load for the programmer for sure and it may not be the right amount of effort for everyone. Whether or not this option is good for everyone, I think that we will be in a good place when that option is easily reachable.</p>

<p>Rust, like most languages chose to start with the stance that most people should not have to think about how memory allocation is happening. All allocations go through a default general-purpose global allocator. The good news is that the standard library provisioned for evolving into eventually letting you opt into custom allocators.</p>
<p>There are two proposals for adding/exposing support for custom memory allocators. The one I am most interested in is the <a href="https://github.com/rust-lang/rust/issues/32838">allocator-api</a> feature which can be used with nightly versions of rustc today. The <a href="https://crates.io/crates/allocator-api2">allocator-api2 crate</a> can be used as a polyfill on stable Rust while waiting for the feature to be stabilized.
There is also the <a href="https://github.com/rust-lang/wg-allocators/issues/93">storage proposal</a> which aims to provide, a superset of <code>allocator-api</code>&#39;s features, mainly to be able to express things like <code>SmallVec</code> directly in the <code>Vec</code> type using a custom storage.</p>
<p>In a nutshell, the main conceptual differences between the two proposals are:</p>
<ul>
<li><code>allocator-api</code> adds a fairly straightforward <code>Allocator</code> trait with methods for allocating, deallocating and reallocating memory. You ask that trait to allocate memory and it gives you a pointer.</li>
<li>The <code>storage</code> proposal instead wants to replace the pointer, so that it can express inline allocations (that can be moved along with the data structure).</li>
</ul>
<p>In my humble opinion I prefer the <code>allocator-api</code> proposal, because it is much simpler while covering the majority of the important features. I understand the appeal of a more general solution, but the added features don&#39;t quite pull the weight of the extra complexity for me. <code>SmallVec</code> (and equivalents for other data structures) can be a separate implementation, it does not <em>need</em> to be unified into <code>Vec</code>. Of course, that&#39;s a very personal view, I don&#39;t think I&#39;m going to sway anyone that&#39;s already emotionally invested in the debate with this argument, and that&#39;s not the aim of this blog post.</p>

<p>Apologies for the overlong preamble, here comes the part that this post is really about.</p>
<p>There are a few different ways to go about making data structures accept custom allocators in rust. In this post I am focusing on the particular case of temporary data structures. The stuff that is tied to the internal needs of an algorithm and typically have very short lifetimes. Keep this in mind because the mentioned trade-offs would be different for the longer lived data structures that represent the interesting state of your programs. First I am going to simplify the problem down to an imaginary <code>Tessellator</code> struct containing a single vector so that the code snippets remain approachable. I leave extrapolating to a more realistic/complex case as an exercise to the reader (or if you feel adventurous, go through the branches in lyon&#39;s repository that are linked later in the post). Then I&#39;ll briefly expand on how various approaches played out with <a href="https://crates.io/crates/lyon">lyon</a>&#39;s fill tessellator.</p>
<h3>Hard coded custom allocator</h3>
<div><pre><span></span><code><span>struct</span> <span>Tessellator</span><span> </span><span>{</span>
<span>    </span><span>data</span>: <span>Vec</span><span>&lt;</span><span>u32</span><span>,</span><span> </span><span>CustomAllocator</span><span>&gt;</span><span>,</span>
<span>}</span>
</code></pre></div>

<p>This is as simple as it gets. Not very flexible, sure, but flexibility isn&#39;t always the goal. When creating small modular crates it can be hard to pick this approach, but for code that belongs to an application this is typically the most efficient and least amount of work.</p>
<h3>Generic parameter on the data structure</h3>
<div><pre><span></span><code><span>struct</span> <span>Tessellator</span><span>&lt;</span><span>A</span>: <span>Allocator</span><span> </span><span>=</span><span> </span><span>Global</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>data</span>: <span>Vec</span><span>&lt;</span><span>u32</span><span>,</span><span> </span><span>A</span><span>&gt;</span><span>,</span>
<span>}</span>
</code></pre></div>

<p>This version is the most flexible: it abstracts over whether the data structure is owned or borrowed, sendable, etc. It takes advantage of the common case where the Allocator type is zero-sized (like <code>Global</code>, for example).</p>
<p>I would default to this approach with data structures that are already generic and when I don&#39;t want to enforce constraints about things like <code>Send</code> and <code>Sync</code>.</p>
<p>Adding a generic parameter to a complex structure that otherwise did not have any can be a bummer, though.</p>
<ul>
<li>It adds noise in the code and documentation.</li>
<li>For something like custom memory allocators that are likely not going to be used by the majority of users of this API, it isn&#39;t very satisfying (to me at least) to put this advanced parameter under everyone&#39;s nose by making it show at the type level.</li>
<li>For things that contain a large amount of code, it is easy to bloat the binary size by (accidentally) causing multiple instantiations of the entire thing. Not that in this case the power is still in the user&#39;s hands, they can decide to always use the same allocator or always use a <code>&amp;dyn Allocator</code> as the allocator type.</li>
</ul>
<p>On the performance side the pros and cons are:</p>
<ul>
<li><strong>pro</strong>: sometimes static dispatch produces faster code than dynamic dispatch (the compiler has more information work with after all).</li>
<li><strong>con</strong>: sometimes static dispatch produces <em>slower</em> code than dynamic dispatch. Yes. Slower code. That&#39;s actually the case with lyon&#39;s tessellator and the impact in this case is hard to ignore. More on that at the end of the post.</li>
</ul>
<h3>Borrowed trait object</h3>
<p>Static dispatch is not the only way to interact with allocators. Lyon&#39;s fill tessellator already treats allocation and deallocation as slow operations, so the overhead of dynamic dispatch should not matter for performance. In this context, solutions that don&#39;t involve generics can be appealing.</p>
<div><pre><span></span><code><span>pub</span><span> </span><span>struct</span> <span>Tessellator</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>data</span>: <span>Vec</span><span>&lt;</span><span>u32</span><span>,</span><span> </span><span>&amp;&#39;</span><span>a</span><span> </span><span>dyn</span><span> </span><span>Allocator</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>impl</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>Tessellator</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>pub</span><span> </span><span>fn</span> <span>new_in</span><span>(</span><span>allocator</span>: <span>&amp;</span><span>&#39;</span><span>a</span> <span>dyn</span><span> </span><span>Allocator</span><span>)</span><span> </span>-&gt; <span>Tessellator</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>{</span>
<span>        </span><span>Tessellator</span><span> </span><span>{</span><span> </span><span>data</span>: <span>Vec</span>::<span>new_in</span><span>(</span><span>allocator</span><span>)</span><span> </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>

<span>impl</span><span> </span><span>Tessellator</span><span>&lt;&#39;</span><span>static</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>// A good default. The static lifetime is functionally equivalent to not having</span>
<span>    </span><span>// a lifetime constraint which means the borrow checker will be off our back for</span>
<span>    </span><span>// objects coming out of this constructor.</span>
<span>    </span><span>pub</span><span> </span><span>fn</span> <span>new</span><span>()</span><span> </span>-&gt; <span>Tessellator</span><span>&lt;&#39;</span><span>static</span><span>&gt;</span><span> </span><span>{</span>
<span>        </span><span>Tessellator</span>::<span>new_in</span><span>(</span><span>&amp;</span><span>Global</span><span> </span><span>as</span><span> </span><span>&amp;&#39;</span><span>static</span><span> </span><span>dyn</span><span> </span><span>Allocator</span><span>)</span>
<span>    </span><span>}</span>
<span>}</span>

<span>// An alias for the common case can also help making things look a bit simpler for the</span>
<span>// common case.</span>
<span>type</span> <span>SimpleTessellator</span><span> </span><span>=</span><span> </span><span>Tessellator</span><span>&lt;&#39;</span><span>static</span><span>&gt;</span><span>;</span>

<span>// This one can move around freely.</span>
<span>let</span><span> </span><span>mut</span><span> </span><span>a</span><span> </span><span>=</span><span> </span><span>Tessellator</span>::<span>new</span><span>();</span>

<span>// This one is tied to the allocator handle on the stack.</span>
<span>let</span><span> </span><span>allocator</span><span> </span><span>=</span><span> </span><span>SomeBumpAllocator</span>::<span>new</span><span>();</span><span> </span>
<span>let</span><span> </span><span>mut</span><span> </span><span>b</span><span> </span><span>=</span><span> </span><span>Tessellator</span>::<span>new_in</span><span>(</span><span>&amp;</span><span>allocator</span><span>);</span>
</code></pre></div>

<p>Again, adding a lifetime parameter for purpose of custom allocators may or may not rub you the wrong way, just like the generic parameter of the previous solution. It does bother me a bit in this case, even with the type alias.
For the most part I can live with the extra noise of the lifetime parameters in the code, but I care deeply about how public facing APIs are presented to the users, in particular in the generated documentation. Conceptually I would like to have something that looks like <code>Tessellator</code> and <code>TessellatorWithAllocator&lt;&#39;alloc&gt;</code> where the simple type signature describes the simple common case while the more complicated signature describes a more advanced usage. I could have the complicated <code>TessellatorWithAllocator&lt;&#39;a&gt;</code> be the real structure and the simpler <code>Tessellator</code> be the alias, but as far as I know rustdoc can only show the methods on the actual struct, so the advanced parameter is forced on the user in a way that I am unhappy with.</p>
<p>Note that since we can default to <code>&#39;static</code> (and that works with <code>Global</code>), the lifetime does not mean we suddenly made our type difficult to move around, I think that it&#39;s pretty neat.</p>
<p>An added constraint of this scheme is that the data structure must decide up front whether it needs to be <code>Send</code>. For example the one in the snipped above is not <code>Send</code>.</p>
<p>Another important thing to note is that when using a trait object in the allocator field, types like <code>Vec</code> and <code>Box</code> (that no doubt your complex data structure uses in multiple places) put on some weight (a trait object contains two pointers so 16 bytes on most things Rust runs on these days) compared to <code>Global</code>&#39;s zero bytes. Whether that&#39;s an issue depends on how many of these find their way into your data structures and how much the performance is sensitive to the size of the structures. It did not make a measurable difference in the context of lyon&#39;s fill tessellator.
This potential bloat issue assumes your data structure is built upon types like the standard containers which store the allocator, but nothing prevents you from using equivalent containers that do not store the allocator. More on this soon, but first I want to address the extra lifetime parameter issue.</p>
<h3>Using two structures</h3>
<p>The documentation issue I had with the generic and borrowed trait object approaches can be solved by using two structs, one being a thin wrapper around the other. This gives full control over what the doc looks like at the cost of more boilerplate.</p>
<div><pre><span></span><code><span>struct</span> <span>Tessellator</span><span> </span><span>{</span>
<span>    </span><span>inner</span>: <span>TessellatorWithAllocator</span><span>&lt;&#39;</span><span>static</span><span>&gt;</span><span>,</span>
<span>}</span>
<span>// or</span>
<span>struct</span> <span>Tessellator</span><span> </span><span>{</span>
<span>    </span><span>inner</span>: <span>TessellatorWithAllocator</span><span>&lt;</span><span>Global</span><span>&gt;</span><span>,</span>
<span>}</span>
</code></pre></div>

<h3>Static trait object</h3>
<p>Dynamic dispatch was fine but for some reason you do not want to make the structure parameterized over a lifetime. No problem, you can just force the lifetime to be static:</p>
<div><pre><span></span><code><span>struct</span> <span>Tessellator</span><span> </span><span>{</span>
<span>    </span><span>data</span>: <span>Vec</span><span>&lt;</span><span>u32</span><span>,</span><span> </span><span>&amp;&#39;</span><span>static</span><span> </span><span>dyn</span><span> </span><span>Allocator</span><span>&gt;</span>
<span>}</span>

<span>impl</span><span> </span><span>Tessellator</span><span> </span><span>{</span>
<span>    </span><span>// A good default.</span>
<span>    </span><span>pub</span><span> </span><span>fn</span> <span>new</span><span>()</span><span> </span>-&gt; <span>Tessellator</span><span> </span><span>{</span>
<span>        </span><span>Tessellator</span>::<span>new_in</span><span>(</span><span>&amp;</span><span>Global</span><span> </span><span>as</span><span> </span><span>&amp;&#39;</span><span>static</span><span> </span><span>dyn</span><span> </span><span>Allocator</span><span>)</span>
<span>    </span><span>}</span>

<span>    </span><span>/// Using a custom allocator.</span>
<span>    </span><span>///</span>
<span>    </span><span>/// Note: Users of this type can decide at their own risk to cast away the static</span>
<span>    </span><span>/// lifetime. This will not cause problem with this type as long as the provided</span>
<span>    </span><span>/// allocator outlives the data structure.</span>
<span>    </span><span>pub</span><span> </span><span>fn</span> <span>new_in</span><span>(</span><span>allocator</span>: <span>&amp;</span><span>&#39;</span><span>static</span> <span>dyn</span><span> </span><span>Allocator</span><span>)</span><span> </span>-&gt; <span>Tessellator</span><span> </span><span>{</span>
<span>        </span><span>Tessellator</span><span> </span><span>{</span><span> </span><span>data</span>: <span>Vec</span>::<span>new_in</span><span>(</span><span>allocator</span><span>)</span><span> </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre></div>

<p>This version is actually a subset of the borrowed trait object restricted to the static lifetime and with nicer syntax (no <code>&lt;&#39;a&gt;</code> everywhere).</p>
<p>This one is probably closest to what one would write in languages like C++. The data structure just assumes the allocator will outlive it, and it is up to the user to either use an static allocator, or pretend to using unsafe code to cast away the lifetime while making sure that the allocator outlives the data structure without the compiler&#39;s support.</p>
<p>I know many in the Rust community will frown upon this approach, but to be honest I don&#39;t think that it is a terrible solution in the context of an advanced feature like custom allocation strategies. <code>Tessellator</code> does not expose an unsafe API, but it documents that if its users were to break the rules they&#39;d simply have to make sure the allocator outlives the data structure. In any other language with this kind of control over memory management, this contract would have to be manually upheld by users of the API and it is considered normal.</p>
<h3>Trait objects Ã  la Zig</h3>
<p>I wrote earlier about how the extra space occupied by the allocator field in the vectors, boxes and maps that make your data structure may or may not be an issue. What can we do about it? Well, we could use a similar container types that do not store their own allocator. Matklad <a href="https://matklad.github.io/2023/03/26/zig-and-rust.html">wrote recently</a> about how Zig provides a vector container that takes the allocator as a parameter of all of the methods that may need to allocate or deallocate memory. There are tradeoffs to this approach. In Rust, almost all of these allocating methods have to be marked <code>unsafe</code> since memory safety depends on the user correctly passing the same allocator the container was created with. In the context of a larger data structure that&#39;s a pretty trivial contract to uphold, the outer data structure would probably just store the allocator at its root and pass it to the internal containers.
Let&#39;s have a look:</p>
<div><pre><span></span><code><span>struct</span> <span>Tessellator</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>allocator</span>: <span>&amp;</span><span>&#39;</span><span>a</span> <span>dyn</span><span> </span><span>Allocator</span><span>,</span>
<span>    </span><span>data</span>: <span>RawVector</span><span>&lt;</span><span>u32</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>impl</span><span> </span><span>Tessellator</span><span>&lt;&#39;</span><span>static</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>// A good default.</span>
<span>    </span><span>pub</span><span> </span><span>fn</span> <span>new</span><span>()</span><span> </span>-&gt; <span>Tessellator</span><span>&lt;&#39;</span><span>static</span><span>&gt;</span><span> </span><span>{</span>
<span>        </span><span>Tessellator</span>::<span>new_in</span><span>(</span><span>&amp;</span><span>Global</span><span> </span><span>as</span><span> </span><span>&amp;&#39;</span><span>static</span><span> </span><span>dyn</span><span> </span><span>Allocator</span><span>)</span>
<span>    </span><span>}</span>
<span>}</span>

<span>impl</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>Tessellator</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>pub</span><span> </span><span>fn</span> <span>new_in</span><span>(</span><span>allocator</span>: <span>&amp;</span><span>&#39;</span><span>a</span> <span>dyn</span><span> </span><span>Allocator</span><span>)</span><span> </span>-&gt; <span>Tessellator</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>{</span>
<span>        </span><span>Tessellator</span><span> </span><span>{</span>
<span>           </span><span>data</span>: <span>RawVector</span>::<span>with_capacity</span><span>(</span><span>128</span><span>,</span><span> </span><span>allocator</span><span>),</span>
<span>           </span><span>allocator</span><span>,</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>

<span>impl</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>Drop</span><span> </span><span>for</span><span> </span><span>Tessellator</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>{</span>
<span>    </span><span>fn</span> <span>drop</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>// Don&#39;t forget to free the memory!</span>
<span>        </span><span>unsafe</span><span> </span><span>{</span>
<span>            </span><span>self</span><span>.</span><span>data</span><span>.</span><span>deallocate</span><span>(</span><span>self</span><span>.</span><span>allocator</span><span>);</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>}</span>
</code></pre></div>

<p>If you would like to play with an unsafe manually allocated vector like this, I wrote one in the <a href="https://docs.rs/shared_vector/latest/shared_vector/struct.RawVector.html">shared_vector</a> crate. This wasn&#39;t the initial goal of that crate, but it contains a vector type mostly similar to the standard library&#39;s and it was easy for me to refactor it into a <code>RawVector&lt;T&gt;</code> that contains most of the code and takes the allocator explicitly on top of which the <code>Vector&lt;T, Allocator&gt;</code> type is implemented as a thin wrapper. That code is rather fresh so there may be some bugs but fuzzing isn&#39;t finding issues so far.</p>

<p>I wanted to experiment with custom allocators in a non-committal way. To do so I tried Some of the approaches I described earlier in lyon&#39;s <a href="https://docs.rs/lyon_tessellation/latest/lyon_tessellation/struct.FillTessellator.html">fill tessellator</a>. It is the perfect size for this experiment: big enough to show how things would play out in a non-trivial chunk of code, but small enough to fit in a manageable amount of time while trying a couple of approaches.</p>
<p>The fill tessellator implements an algorithm that generates a triangle mesh from a vector path (the kind of paths you would find in a <a href="https://developer.mozilla.org/fr/docs/Web/API/CanvasRenderingContext2D">canvas</a>-style API or an SVG document). Internally it needs to allocate memory for a lot of different things, which I won&#39;t bore you with in this post. As a mentioned earlier, the tessellator is a structure instead of a pure function so that it can retain memory allocations in subsequent uses.</p>
<p>The code for the experiment can be found in the following branches:
 - Generic parameter: <a href="https://github.com/nical/lyon/blob/alloc-generic/crates/tessellation/src/fill.rs">alloc-generic branch</a>
 - Borrowed trait object: <a href="https://github.com/nical/lyon/blob/alloc-trait-object/crates/tessellation/src/fill.rs">alloc-trait-object branch</a>
 - Zig-style manually managed trait object: <a href="https://github.com/nical/lyon/blob/alloc-raw/crates/tessellation/src/fill.rs">alloc-raw branch</a></p>
<p>The most adventurous readers might find the courage to read and compare all of that code, I wouldn&#39;t blame you if you don&#39;t. Here are my thoughts after this little experiment:</p>
<ul>
<li>Adding support for custom allocators can be a bit tedious, but it is rather easy.</li>
<li>I believe that the yet-to-be-stabilized <code>Allocator</code> trait is the right abstraction.</li>
<li>I had been waiting patiently for the nightly-only <a href="https://github.com/rust-lang/rust/issues/32838">allocator-api</a> feature to stabilize, but since that&#39;s just a library thing anyone can use the stable polyfill from the <a href="https://crates.io/crates/allocator-api2">allocator-api2</a> crate today in stable rust. I&#39;m happy I stumbled upon it just in time for this experiment.</li>
<li>The fill tessellator is not just one struct like in the simplified example from earlier there are a number of structs only visible internally. Adding a generic or lifetime parameter to all of them is tedious and adds noise that I am not very pleased with. In an ideal world, adding support for custom allocators to an algorithm is so simple that it becomes an idiomatic thing that crate implementors just do even when they don&#39;t necessarily need it, just like implementing the <code>Default</code>  trait. In this ideal world there may even be a clippy lint that nudges you towards using custom allocators in some places.</li>
<li>Generalizing to a whole program, If everything that allocates memory needs to have generic or lifetime parameters, it may be too tedious as well, or perhaps I have to get used to reading <code>&lt;things&gt;</code> everywhere.</li>
<li>At the API level, I am not super fond of adding a generic or lifetime parameter either for an advanced knob that isn&#39;t at the forefront of the tessellator&#39;s functionality.</li>
</ul>
<h2>Performance</h2>
<p>I mentioned somewhat surprising performance results for the generic version of the tessellator&#39;s allocator parameter. What&#39;s up with that?</p>
<p>The tessellator recycles its allocations, so using a faster or slower allocator should only significantly affect the performance the first time the tessellator runs. The repository contains a few benchmarks which reuse the same allocator many times so it would make sense for this experiment to not affect these benchmarks. Yet, I have been bitten in the past by surprising performance difference between static and dynamic dispatch so I made sure to run the benchmarks again as a sanity check. In particular I there was a significant performance increase a few years ago when the tessellator&#39;s output parameter was converted from a generic parameter to a trait object (making the tessellator entire free of generic parameters).
I observed the same effect when comparing the different approaches: Adding a generic parameter for the allocator regresses the benchmarks by a solid 5 to 8 percents. Every other approach performed roughly the same (as expected since allocator performance should not be a factor of these benchmarks).</p>
<p>It&#39;s difficult to tell what&#39;s going on here. There if a fair amount of code involved, so eyeballing the generated code is too much hassle for me to commit to right now. Hopefully there exists some tools for looking at how compiler optimizations played out at a large-ish scale. I can&#39;t make particularly educated guesses here, all I know is that:</p>
<ul>
<li>The benchmarks use a single instance of the generic parameter, so if bloat is to blame it comes from poor inlining decisions and not multiple generic instantiations.</li>
<li>It doesn&#39;t seem to matter what parameter is made generic. Any generic parameter on the tessellator appears to throw a wrench into some heuristics and snowballs into slower code <em>for this particular code</em>.</li>
<li>I don&#39;t have reasons to believe that this generalizes to other code. All I would gather from that is that contrary to popular belief, static dispatch does not always produce faster code than dynamic dispatch (especially at a larger scale than simple code snippets). If performance matters, don&#39;t make assumption, try things, measure and then decide.</li>
</ul>
<p>If you are interested, here are a couple of performance profiles (the link will probably go stale after a while):</p>
<p>Generic allocator parameter: <a href="https://share.firefox.dev/3ZDHPlr">(profile link)</a></p>
<div><pre><span></span><code>test fill_events_01_logo                ... bench:      36,856 ns/iter (+/- 6,452)
test fill_events_02_logo_pre_flattened  ... bench:      22,195 ns/iter (+/- 503)
test fill_events_03_logo_with_tess      ... bench:      87,390 ns/iter (+/- 1,464)
test fill_tess_01_logo                  ... bench:      71,749 ns/iter (+/- 1,279)
test fill_tess_03_logo_no_intersections ... bench:      82,140 ns/iter (+/- 379)
test fill_tess_05_logo_no_curve         ... bench:      34,081 ns/iter (+/- 857)
test fill_tess_06_logo_with_ids         ... bench:      70,721 ns/iter (+/- 1,166)```
</code></pre></div>

<p>Non-generic: <a href="https://share.firefox.dev/3ZGE136">(profile link)</a></p>
<div><pre><span></span><code>test fill_events_01_logo                ... bench:      29,859 ns/iter (+/- 835)
test fill_events_02_logo_pre_flattened  ... bench:      14,986 ns/iter (+/- 437)
test fill_events_03_logo_with_tess      ... bench:      72,470 ns/iter (+/- 5,095)
test fill_tess_01_logo                  ... bench:      56,008 ns/iter (+/- 1,347)
test fill_tess_03_logo_no_intersections ... bench:      66,380 ns/iter (+/- 2,144)
test fill_tess_05_logo_no_curve         ... bench:      28,297 ns/iter (+/- 171)
test fill_tess_06_logo_with_ids         ... bench:      54,785 ns/iter (+/- 2,835)
</code></pre></div>


<p>Fast software is written with memory allocations in mind. Recycling allocations is an easy way to paper over allocator overhead but picking the right allocator for specific parts of the code is another option which can be even more effective. Ideally developers would have the possibility to easily reach for both and do what makes most sense in context.</p>
<p>I think that custom allocators are a pretty cool feature for a performance-focused library to add. Very few crates do today, probably in part because the standard library hasn&#39;t stabilized custom allocators yet, but also because it is very easy and convenient to not think about it at all. There is certainly a niche to fill in the ecosystem for specialized custom allocators. There is <a href="https://docs.rs/blink-alloc/">blink-alloc</a> and probably a few others. As this niche fills up and the the allocator API stabilizes, I hope that more people will join the fun. Will I integrate custom allocators in my own crates? I think so. I still need to ponder some more on the different ways to do it. I don&#39;t think that one way is strictly superior to the others. For some things a generic parameter is the obvious choice while for others I find that making an entire chunks of a program generic for the sake of supporting custom allocators is not sustainable. Dynamic dispatch for custom allocators can work well in many cases. In lyon I am leaning towards using a generic parameter in the <code>Path</code> data structure and dynamic dispatch in the tessellator.</p>
<p>And there is this thorny generics performance situation, but that&#39;s more anecdotal. The point is that making code generic over something can have somewhat unexpected consequence (good or bad) the only right thing to do is to validate assumptions. I still hope that static dispatch can produce faster code more often than not.</p>
<p>Comments/reactions/discussions about this post on <a href="https://www.reddit.com/r/rust/comments/12di5bo/custom_allocators_in_rust/">reddit</a></p>

<p>Here are few notes following some of the reddit discussions.</p>
<p>A discussion with one of the storage proposal authors provided me with more context and put the proposal in a better light:</p>
<ul>
<li>The storage API does not need to be as complicated as the code I read in one of its versions.</li>
<li>Even though there is an unresolved issue with Box coercion, that problem only affects some specific cases. The proposal could be stabilized without necessarily resolving it.</li>
<li>Ideally the  <code>Storage</code> and <code>Allocator</code> traits would both exist and some <code>Storage</code> implementations could leverage <code>Allocator</code> ones. <code>Storage</code> would mainly allow distinguishing between inline and allocator provided memory.</li>
</ul>
<p>I was also reminded of the <a href="https://crates.io/crates/bumpalo">bumpallo</a> crate, which also implements support for the unstable <code>Allocator</code> trait. The crate does not rely on <code>allocator-api2</code> for polyfilling the <code>Allocator</code> trait. This underlines the need for stabilizing the <code>Allocator</code> trait to let a healthy ecosystem develop on common foundations.</p>
<p>Another interesting highlight: <a href="https://github.com/emi2k01/okaoka">okaoka</a> allows switching between allocators using a hook on the global allocator. It does not provide the type of granularity that I was after, it allows injection a different allocator for third party code that does not provide options. None of the approaches discussed in this post let you do that.</p>
  </div></div>
  </body>
</html>
