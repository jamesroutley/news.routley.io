<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.commandlinefu.com/commands/browse">Original</a>
    <h1>Command Line One-Liners</h1>
    
    <div id="readability-page-1" class="page"><div>
    <h3>What&#39;s this?</h3>
    <div>
        <p><strong>commandlinefu.com</strong> is the place to record those command-line gems that you return to again and again.
        That way others can gain from your <abbr title="Command-line interface">CLI</abbr> wisdom and you from theirs too.  All commands can be commented on, discussed and 
        voted up or down. </p>
		<p><a href="https://www.commandlinefu.com/commands/edit"><strong><i></i> Share Your Commands</strong></a></p>
        <!-- <p>If you have a new feature suggestion or find a bug, please 
        get in touch via <a href="http://commandlinefu.uservoice.com/"><strong>http://commandlinefu.uservoice.com/</strong></a><p>-->
    </div>
</div><div>
    <h3>Check These Out</h3>
			
				<p>Replace 12/31/1970 with your birth date.</p>
				
			
				<p>That is an alternative to command 8368.

Command 8368 is EXTREMELY NOT clever.
1) Will break also for files with spaces AND new lines in them AND for an empty expansion of the glob &#39;*&#39;
2) For making such a simple task it uses two pipes, thus forking.
3) xargs(1) is dangerous (broken) when processing filenames that are not NUL-terminated.
4) ls shows you a representation of files. They are NOT file names (for simple names, they mostly happen to be equivalent). Do NOT try to parse it.
Why? see this :http://mywiki.wooledge.org/ParsingLs

Recursive version:
$ find . -depth -name &#34;*foo*&#34; -exec bash -c &#39;for f; do base=${f##*/}; mv -- &#34;$f&#34; &#34;${f%/*}/${base//foo/bar}&#34;; done&#39; _ {} +</p>
				
			
				
			
				<p>The variable ? contain the last exit status of a command, it can be printed for troubleshooting purpose.</p>
				
			
				<p>Shows a simple clock in the console
-t param removes the watch header
Ctrl-c to exit</p>
				
			
				<p>Enter your ssh public key in the remote end for future key-based authentication. Just type your password one last time. The next time you should be able to login with the public key. If you don&#39;t have a key, generate one with ssh-keygen.
Requires Bourne-compatible shell in the remote end.</p>
				
			
				<p>This uses some tricks I found while reading the bash man page to enumerate and display all the current environment variables, including those not listed by the &#39;env&#39; command which according to the bash docs are more for internal use by BASH. The main trick is the way bash will list all environment variable names when performing expansion on ${!A*}.  Then the eval builtin makes it work in a loop.

I created a function for this and use it instead of env.  (by aliasing env).

This is the function that given any parameters lists the variables that start with it.  So &#39;aae B&#39; would list all env variables starting wit B.  And &#39;aae {A..Z} {a..z}&#39; would list all variables starting with any letter of the alphabet.  And &#39;aae TERM&#39; would list all variables starting with TERM.
$ aae(){ local __a __i __z;for __a in &#34;$@&#34;;do __z=\${!${__a}*};for __i in `eval echo &#34;${__z}&#34;`;do echo -e &#34;$__i: ${!__i}&#34;;done;done; }

And my printenv replacement is:
$ alias env=&#39;aae {A..Z} {a..z} &#34;_&#34;|sort|cat -v 2&gt;&amp;1 | sed &#34;s/\\^\\[/\\\\033/g&#34;&#39;

From: http://www.askapache.com/linux-unix/bash_profile-functions-advanced-shell.html</p>
				
			
				<p>Replace &#39;csv_file.csv&#39; with your filename.</p>
				
			
				<p>Greater than 500M and sorted by size.</p>
				
			
				<p>I&#39;ve used this scan to sucessfully find many rogue APs on a very, very large network.</p>
				
	</div></div>
  </body>
</html>
