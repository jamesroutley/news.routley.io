<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bun.sh/blog/bun-report-is-buns-new-crash-reporter">Original</a>
    <h1>Bun&#39;s New Crash Reporter</h1>
    
    <div id="readability-page-1" class="page"><article><p>At the time of writing, Bun has over <a href="https://github.com/oven-sh/bun">2,600 open GitHub issues</a>. We love having users and feedback, but some issues are really hard for us to reproduce and debug.</p><p>Apps and SaaS products get to use wonderful crash reporting services like <a href="https://sentry.io/">Sentry</a>, but for CLI tooling like Bun, uploading core dumps has privacy, performance, and executable size tradeoffs that are harder to justify.</p><p>That&#39;s why in Bun v1.1.5, I wrote a compact new format for Zig and C++ crash reports. The crash report fits in a ~150 byte URL containing zero personal information.</p><figure><a href="https://bun.sh/images/crash-report-1.png"><img src="https://bun.sh/images/crash-report-1.png" alt=""/></a></figure><h2 level="2" anchor-id="why-not-just-use-the-os-crash-reporter" id="why-not-just-use-the-os-crash-reporter"><a name="why-not-just-use-the-os-crash-reporter"></a><a href="#why-not-just-use-the-os-crash-reporter">Why not just use the OS crash reporter?</a></h2><p>Some operating systems like macOS have built-in crash reporters, but that usually means shipping debug symbols with the application. For Linux, these debug symbols are around 30 MB and macOS around 9 MB.</p><p>And on Windows, the <code>.pdb</code> file is over 250 MB</p><div><div><div><pre><code><span><span>(gi bun.pdb).Length </span><span>/</span><span> </span><span>1</span><span>mb</span></span></code></pre></div></div></div><p>30 MB - 250 MB is a huge amount of bloat to add to every install of Bun.</p><p>But without debug symbols, crashes are pretty limited. And with <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address space layout randomization</a> in the mix, all of the function addresses are made useless.</p><div><div><div><pre><code><span><span>uh-oh: reached unreachable code</span></span>
<span><span>bun will crash now ðŸ˜­ðŸ˜­ðŸ˜­</span></span>
<span><span></span></span>
<span><span>----- bun meta -----</span></span>
<span><span>Bun v1.1.0 (5903a614) Windows x64</span></span>
<span><span>AutoCommand:</span></span>
<span><span>Builtins: &#34;bun:main&#34;</span></span>
<span><span>Elapsed: 27ms | User: 0ms | Sys: 0ms</span></span>
<span><span>RSS: 91.69MB | Peak: 91.69MB | Commit: 0.14GB | Faults: 22579</span></span>
<span><span>----- bun meta -----</span></span>
<span><span></span></span>
<span><span>Search GitHub issues https://bun.sh/issues or join in #windows channel in https://bun.sh/discord</span></span>
<span><span></span></span>
<span><span>thread 104348 panic: reached unreachable code</span></span>
<span><span>???:?:?: 0x7ff62a629f17 in ??? (bun.exe)</span></span>
<span><span>???:?:?: 0x7ff62a907a83 in ??? (bun.exe)</span></span>
<span><span>???:?:?: 0x7ff62a61f392 in ??? (bun.exe)</span></span>
<span><span>???:?:?: 0x7ff62ade7ff1 in ??? (bun.exe)</span></span>
<span><span>???:?:?: 0x7ff62ab2193c in ??? (bun.exe)</span></span>
<span><span>???:?:?: 0x7ff62ab21166 in ??? (bun.exe)</span></span>
<span><span>???:?:?: 0x7ff62cd3ddeb in ??? (bun.exe)</span></span>
<span><span>???:?:?: 0x7ff62b7a4bb6 in ??? (bun.exe)</span></span>
<span><span>???:?:?: 0x7ff62b7a33bd in ??? (bun.exe)</span></span>
<span><span>???:?:?: 0x1bab9ca115d in ??? (???)</span></span>
<span><span>???:?:?: 0x1bab9ca111f in ??? (???)</span></span>
<span><span></span></span></code></pre></div></div></div><h2 level="2" anchor-id="the-new-crash-reporter" id="the-new-crash-reporter"><a name="the-new-crash-reporter"></a><a href="#the-new-crash-reporter">The new crash reporter</a></h2><p>In Bun v1.1.5, when a crash or panic occurs, Bun prints a message like this:</p><div><div><div><pre><code><span><span>Bun v1.1.5 (0989f1a) Windows x64</span></span>
<span><span>Args: &#34;C:\Users\dave\.bun\bin\bun.exe&#34;, &#34;.\crash.js&#34;</span></span>
<span><span>Builtins: &#34;bun:main&#34;</span></span>
<span><span>Elapsed: 40ms | User: 15ms | Sys: 15ms</span></span>
<span><span>RSS: 92.80MB | Peak: 92.80MB | Commit: 0.14GB | Faults: 22857</span></span>
<span><span></span></span>
<span><span>panic(main thread): Internal assertion failure</span></span>
<span><span>oh no: Bun has crashed. This indicates a bug in Bun, not your code.</span></span>
<span><span></span></span>
<span><span>To send a redacted crash report to Bun&#39;s team,</span></span>
<span><span>please file a GitHub issue using the link below:</span></span>
<span><span></span></span>
<span><span>https://bun.report/1.1.5/wa10989f1aAAg6xyL+rqoIwzn0F+oqC0v5R+52pGkr6Om7h+Oy3voK+9qoKA0eNrzzCtJLcpLzFFILC5OLSrJzM9TSEvMzCktSgUAiSkKPg</span></span>
<span><span></span></span></code></pre></div></div></div><p>This <code>bun.report</code> link, when clicked, redirects to open a pre-filled GitHub issue form, with the remapped stack trace encoded in the URL.</p><figure><a href="https://github.com/oven-sh/bun/assets/24465214/18867c15-663b-469a-ba98-1088e6bbd424"><img src="https://github.com/oven-sh/bun/assets/24465214/18867c15-663b-469a-ba98-1088e6bbd424" alt=""/></a></figure><h2 level="2" anchor-id="making-addresses-useful" id="making-addresses-useful"><a name="making-addresses-useful"></a><a href="#making-addresses-useful">Making addresses useful</a></h2><p>The function addresses are pointers in memory to where the application code is loaded, which includes a randomized offset for security reasons. This means if we try and demangle these, we get nothing.</p><div><div><div><pre><code><span><span>llvm-symbolizer --exe ./bun.pdb 0x7ff62a629f17 0x7ff62a907a83</span></span></code></pre></div></div></div><p>The trick is to simply subtract the address from the base address of the binary.</p><div><div><div><pre><code><span><span>pub</span><span> </span><span>fn</span><span> </span><span>getRelativeAddress</span><span>(address: </span><span>usize</span><span>) ?</span><span>usize</span><span> {</span></span>
<span><span>    </span><span>const</span><span> module = </span><span>getModuleFromAddress</span><span>(address) </span><span>orelse</span><span> {</span></span>
<span><span>      </span><span>// Could not resolve address! This can be hit for some</span></span>
<span><span>      </span><span>// Windows internals, as well as JIT&#39;d JavaScript.</span></span>
<span><span>      </span><span>return</span><span> </span><span>null</span><span>;</span></span>
<span><span>    };</span></span>
<span></span>
<span><span>    </span><span>return</span><span> address </span><span>-</span><span> module.base_address;</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><p>In reality, this function is <a href="https://github.com/oven-sh/bun/blob/2abe6e7c3f6f66771bb9eac6365699353590bfa9/src/crash_handler.zig#L803">a lot more complicated</a>, as there are different APIs for each platform.</p><p><strong>Note</strong> â€“ What I referred to as a &#34;module&#34; above is only the case for Windows. It called an &#34;image&#34; on macOS, and a &#34;shared object&#34; on Linux. They all refer to the same concept of a loaded library or executable in memory. For simplicity, I&#39;ll continue to refer to them as &#34;modules&#34;.</p><ul><li><strong>Windows</strong>: Call <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandleexw"><code>GetModuleHandleExW</code></a> with the <code>GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS</code> flag. The base address is the pointer of the module.</li><li><strong>Linux</strong>: Use <a href="https://man7.org/linux/man-pages/man3/dl_iterate_phdr.3.html"><code>dl_iterate_phdr</code></a> to iterate over the loaded modules, once you find one that the raw address is contained in, <code>.dlpi_addr</code> on the <code>dl_phdr_info</code> struct will be the base address.</li><li><strong>macOS</strong>: The functions <a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html"><code>_dyld_image_count</code></a> and <code>_dyld_get_image_header</code> can be used to iterate over modules, and then <code>_dyld_get_image_vmaddr_slide</code> gets the ASLR slide.<ul><li>The resulting address still includes an offset to the image (for Bun it is <code>0x100000000</code>, can list these in lldb with <code>image list</code>). To encode a shorter URL, this offset is removed, but it <a href="https://github.com/oven-sh/bun.report/blob/7ff10116749b38bacc17fe0de7c47d7633b10d01/backend/remap.ts#L94">must be re-added before remapping</a> or else <code>llvm-symbolizer</code> will fail.</li></ul></li></ul><p>For Linux and MacOS, the first module refers to the main application binary. On Windows, you can compare the module&#39;s name to <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-rtl_user_process_parameters#members"><code>peb.ProcessParameters.ImagePathName</code></a> to determine if it is the main binary.</p><p>Normally, once the module and relative address are resolved, the application will immediately open debug symbols and demangle the function. To avoid the cost of downloading and parsing debug symbols, let&#39;s offload demangling to a server. This server could cache all of the debug symbols, and demangle stack traces within seconds. At the same time, it can serve as the link to open a new GitHub issue.</p><h2 level="2" anchor-id="bun-report-s-url-structure" id="bun-report-s-url-structure"><a name="bun-report-s-url-structure"></a><a href="#bun-report-s-url-structure">bun.report&#39;s URL Structure</a></h2><figure><a href="https://bun.sh/images/crash-report-1.png"><img src="https://bun.sh/images/crash-report-1.png" alt=""/></a></figure><p>Let&#39;s take another look at this URL, and break down how it is been encoded:</p><ul><li><strong>Platform</strong>: A single character indicating the platform. <code>w</code> is for x86_64 Windows, <code>M</code> is for aarch64 macOS, and <a href="https://github.com/oven-sh/bun/blob/2abe6e7c3f6f66771bb9eac6365699353590bfa9/src/crash_handler.zig#L778">so on</a>.</li><li><strong>Subcommand</strong>: A single character indicating the <a href="https://github.com/oven-sh/bun/blob/2abe6e7c3f6f66771bb9eac6365699353590bfa9/src/cli.zig#L2028">subcommand</a>, such as <code>bun test</code>, <code>bun install</code>, or <code>bun run</code>.</li><li><strong>Commit SHA</strong>: The commit SHA of the current version of Bun. This is used to fetch debug symbols later.</li><li><strong>Feature Flags</strong>: Indicators for what APIs and features were used before Bun crashed.</li><li><strong>Stack Trace Addresses</strong>: The addresses calculated earlier.</li><li><strong>Crash Type</strong>: A single character indicating the <a href="https://github.com/oven-sh/bun/blob/2abe6e7c3f6f66771bb9eac6365699353590bfa9/src/crash_handler.zig#L54">type of crash</a>.</li><li><strong>Crash Message</strong>: The message from the crash, the format of this depending on the type.</li></ul><p><strong>Note</strong> â€“ The version number in the URL is actually just for show. This is so that given just the info above, one can figure out a lot about the crash by hand. For example, you can quickly identify a windows crash by the <code>w</code> platform identifier. Less trivially, you could identify a segmentation fault by looking for <code>A2</code> near the end of the string.</p><h2 level="2" anchor-id="vlqs-are-fun" id="vlqs-are-fun"><a name="vlqs-are-fun"></a><a href="#vlqs-are-fun">VLQs are fun</a></h2><p>To keep the URL reasonably short, the stack trace addresses are encoded using base64 <a href="https://en.wikipedia.org/wiki/Variable-length_quantity">Variable Length Quantity</a> numbers. This allows small numbers to be encoded with less characters, while still being able to encode large numbers. This is the same technique used in JavaScript source maps for storing line numbers.</p><p>The transformation looks like this. Notice how the VLQ encodes smaller addresses as smaller numbers.</p><figure><a href="https://bun.sh/images/crash-report-2.png"><img src="https://bun.sh/images/crash-report-2.png" alt=""/></a></figure><p>The server can <a href="https://github.com/oven-sh/bun.report/blob/7ff10116749b38bacc17fe0de7c47d7633b10d01/lib/parser.ts#L104">decode these back into relative addresses</a>, <a href="https://github.com/oven-sh/bun.report/blob/7ff10116749b38bacc17fe0de7c47d7633b10d01/backend/debug-store.ts#L46">download debug symbols</a> using the commit hash and platform, and use <code>llvm-symbolizer</code> to demangle the function names.</p><figure><a href="https://bun.sh/images/crash-report-3.png"><img src="https://bun.sh/images/crash-report-3.png" alt=""/></a></figure><p>It now becomes plainly obvious what happened: There is a tripped assertion in <code>dirInfoCachedMaybeLog</code>, which came from part of the module resolver code on Windows.</p><h2 level="2" anchor-id="what-are-features" id="what-are-features"><a name="what-are-features"></a><a href="#what-are-features">What are &#34;Features&#34;</a></h2><p>The URL also encodes a 64-bit integer, where each bit corresponds to if a certain feature in Bun was used. These flags give a hint as to what APIs and systems could have led the crash. For example, the <code>dotenv</code> feature is set when any <code>.env</code> file is automatically loaded, <code>fetch</code> is set when <code>fetch()</code> is used, and so on. (<a href="https://github.com/oven-sh/bun/blob/e3689e7e83507ae9c63dac7d785e41884daead66/src/analytics/analytics_thread.zig#L82-L109">Full list</a>)</p><p>Zig&#39;s compile-time metaprogramming makes creating this bitfield easy. We already had a container of global variables for tracking features.</p><div><div><div><pre><code><span><span>pub</span><span> </span><span>const</span><span> </span><span>Features</span><span> = </span><span>struct</span><span> {</span></span>
<span><span>    </span><span>pub</span><span> </span><span>var</span><span> bunfig: </span><span>usize</span><span> = </span><span>0</span><span>;</span></span>
<span><span>    </span><span>pub</span><span> </span><span>var</span><span> http_server: </span><span>usize</span><span> = </span><span>0</span><span>;</span></span>
<span><span>    </span><span>pub</span><span> </span><span>var</span><span> shell: </span><span>usize</span><span> = </span><span>0</span><span>;</span></span>
<span><span>    </span><span>pub</span><span> </span><span>var</span><span> spawn: </span><span>usize</span><span> = </span><span>0</span><span>;</span></span>
<span><span>    </span><span>pub</span><span> </span><span>var</span><span> macros: </span><span>usize</span><span> = </span><span>0</span><span>;</span></span>
<span><span>    </span><span>// ... and so on</span></span>
<span><span>};</span></span>
<span></span></code></pre></div></div></div><p>And inside various APIs, we would increment these numbers to mark usage of a feature.</p><p>For encoding these into a single <code>u64</code> integer, we can use <code>std.meta</code> to iterate over the list of features and create a list.</p><div><div><div><pre><code><span><span>pub</span><span> </span><span>const</span><span> feature_list = brk: {</span></span>
<span><span>    </span><span>const</span><span> decls = std.meta.</span><span>declarations</span><span>(</span><span>Features</span><span>);</span></span>
<span><span>    </span><span>var</span><span> names: [decls.len][:</span><span>0</span><span>]</span><span>const</span><span> </span><span>u8</span><span> = </span><span>undefined</span><span>;</span></span>
<span><span>    </span><span>var</span><span> i = </span><span>0</span><span>;</span></span>
<span><span>    </span><span>for</span><span> (decls) </span><span>|</span><span>decl</span><span>|</span><span> {</span></span>
<span><span>        </span><span>if</span><span> (</span><span>@TypeOf</span><span>(</span><span>@field</span><span>(</span><span>Features</span><span>, decl.name)) </span><span>==</span><span> </span><span>usize</span><span>) {</span></span>
<span><span>            names[i] = decl.name;</span></span>
<span><span>            i </span><span>+=</span><span> </span><span>1</span><span>;</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>    </span><span>const</span><span> names_const = names[</span><span>0</span><span>..i].</span><span>*</span><span>;</span></span>
<span><span>    </span><span>break</span><span> :brk names_const;</span></span>
<span><span>};</span></span>
<span></span></code></pre></div></div></div><p>Then, a packed struct can be created dynamically derivied to use one bit per feature. This structure functions like an integer, but interacts like a struct.</p><div><div><div><pre><code><span><span>// note: some fields omitted for brevity</span></span>
<span><span>pub</span><span> </span><span>const</span><span> </span><span>PackedFeatures</span><span> = </span><span>@Type</span><span>(.{</span></span>
<span><span>    .</span><span>Struct</span><span> = .{</span></span>
<span><span>        .layout = .@&#34;packed&#34;,</span></span>
<span><span>        .backing_integer = </span><span>u64</span><span>,</span></span>
<span><span>        .fields = brk: {</span></span>
<span><span>            </span><span>var</span><span> fields: [</span><span>64</span><span>]</span><span>StructField</span><span> = </span><span>undefined</span><span>;</span></span>
<span><span>            </span><span>for</span><span> (feature_list, </span><span>0</span><span>..) </span><span>|</span><span>name, i</span><span>|</span><span> {</span></span>
<span><span>                fields[i] = .{ .name = name, .</span><span>type</span><span> = </span><span>bool</span><span> };</span></span>
<span><span>            }</span></span>
<span><span>            fields[feature_list.len] = .{</span></span>
<span><span>                .name = </span><span>&#34;__padding&#34;</span><span>,</span></span>
<span><span>                .</span><span>type</span><span> = </span><span>@Type</span><span>(.{ .</span><span>Int</span><span> = .{ .bits = </span><span>64</span><span> </span><span>-</span><span> feature_list.len } }),</span></span>
<span><span>            };</span></span>
<span><span>            </span><span>break</span><span> :brk fields[</span><span>0</span><span>..feature_list.len </span><span>+</span><span> </span><span>1</span><span>];</span></span>
<span><span>        },</span></span>
<span><span>    },</span></span>
<span><span>});</span></span>
<span></span></code></pre></div></div></div><p>And finally, when Bun crashes, the bitfield can be constructed very trivially using <code>inline for</code>, a way to iterate over something at compile time, but perform the inner contents at runtime.</p><div><div><div><pre><code><span><span>pub</span><span> </span><span>fn</span><span> </span><span>packedFeatures</span><span>() </span><span>PackedFeatures</span><span> {</span></span>
<span><span>    </span><span>var</span><span> bits = </span><span>PackedFeatures</span><span>{};</span></span>
<span><span>    </span><span>inline</span><span> </span><span>for</span><span> (feature_list) </span><span>|</span><span>name</span><span>|</span><span> {</span></span>
<span><span>        </span><span>if</span><span> (</span><span>@field</span><span>(</span><span>Features</span><span>, name) &gt; </span><span>0</span><span>) {</span></span>
<span><span>            </span><span>@field</span><span>(bits, name) = </span><span>true</span><span>;</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>    </span><span>return</span><span> bits;</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><p>Now, adding a new feature to the original struct <code>Features</code> will properly handle it in the crash reporter, without needing to repeat ourselves.</p><p>Doing this sort of thing is possible with C or Rust via macros, but I feel like it&#39;s so much simpler and readable with Zig <code>comptime</code>.</p><h2 level="2" anchor-id="how-does-this-compare-to-a-core-dump" id="how-does-this-compare-to-a-core-dump"><a name="how-does-this-compare-to-a-core-dump"></a><a href="#how-does-this-compare-to-a-core-dump">How does this compare to a core dump?</a></h2><p>Core dumps have a lot more information, but they are massive, need debug symbols to be useful, and include lots of potentially sensitive or confidential information.</p><p>We wanted to avoid the possibility of sending any JavaScript/TypeScript source code, environment variables, or other sensitive information in the reports. This is why we only send the Zig/C++ stack trace and a few other details. Instead of sending everything by default, this approach sends only what we (probably) need to diagnose the issue. If we need more information, we can ask the user to provide it, but this is so much better than nothingness of a bunch of unmapped addresses we had before.</p><h2 level="2" anchor-id="demo" id="demo"><a name="demo"></a><a href="#demo">Demo</a></h2><p>To put it all together, I wrote a small webapp that lets you test out the crash reporter, which is available at the homepage, <a href="https://bun.report/1.1.5/wa10989f1aAAg6xyL+rqoIwzn0F+oqC0v5R+52pGkr6Om7h+Oy3voK+9qoKA0eNrzzCtJLcpLzFFILC5OLSrJzM9TSEvMzCktSgUAiSkKPg/view">bun.report</a>. It is also where you end up if you append <code>/view</code> to the end of any crash report URL.</p><h2 level="2" anchor-id="bun-is-hiring-in-san-francisco" id="bun-is-hiring-in-san-francisco"><a name="bun-is-hiring-in-san-francisco"></a><a href="#bun-is-hiring-in-san-francisco">Bun is hiring in San Francisco</a></h2><p>If you&#39;re interested in working on projects like this, we&#39;re hiring engineers in San Francisco! We&#39;re looking for systems engineers to help build the future of JavaScript. <strong><a href="https://bun.sh/careers">Apply here</a></strong></p></article></div>
  </body>
</html>
