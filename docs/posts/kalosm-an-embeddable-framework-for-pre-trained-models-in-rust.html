<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://floneum.com/blog/kalosm_0_2/">Original</a>
    <h1>Show HN: Kalosm an embeddable framework for pre-trained models in Rust</h1>
    
    <div id="readability-page-1" class="page"><section data-node-hydration="12"><div><div><article><p data-node-hydration="14">We&#39;re excited to announce the release of Kalosm v0.2.0! This release includes a number of new features, improvements, and bug fixes including:</p><ul data-node-hydration="15"><li>Tasks and Agents</li><li>Task Evaluation</li><li>Prompt Auto-Tuning</li><li>Regex Validation</li><li>Surreal Database Integration</li><li>RAG improvements</li><li>Performance Improvements</li><li>New Models</li></ul><h2 id="tasks-and-agents" data-node-hydration="16"><a href="#tasks-and-agents">Tasks and Agents!</a></h2><p data-node-hydration="17">Kalosm now includes utilities for running, evaluating, and improving tasks and agents.</p><p data-node-hydration="18">Let&#39;s build a simple task and agent to demonstrate the new functionality.</p><div data-node-hydration="19"><div><pre><span>use </span><span>kalosm::language::*;
</span><span>
</span><span>#[</span><span>tokio</span><span>::</span><span>main</span><span>]
</span><span>async </span><span>fn </span><span>main</span><span>() {
</span><span>	</span><span>// You can use tasks with llama, mistral or phi models.
</span><span>    </span><span>let</span><span> llm = Phi::new_chat();
</span><span>
</span><span>    </span><span>// Now we can create a task. We will create a simple assistant that identifies keywords in a sentence.
</span><span>    </span><span>let</span><span> task = Task::builder(&amp;llm, &#34;</span><span>You are an assistant who identifies keywords in a sentence. When identifying keywords, you will output the keywords in a comma-separated list.</span><span>&#34;)
</span><span>		</span><span>// You can optionally add constraints to the task.
</span><span>        </span><span>// accept 2-5 keywords of 2-15 characters each
</span><span>        .</span><span>with_constraints</span><span>(RegexParser::new(</span><span>r</span><span>#</span><span>&#34;The keywords are:([ a-z]{2,15},){2,5}</span><span>&#34;#).</span><span>unwrap</span><span>())
</span><span>		</span><span>/// You can also add examples to the task to help the agent learn how to solve math problems.
</span><span>        .</span><span>with_example</span><span>(&#34;</span><span>What is the weather like in New York?</span><span>&#34;, &#34;</span><span>The keywords are: weather, new york, </span><span>&#34;)
</span><span>        .</span><span>with_example</span><span>(&#34;</span><span>What is the capital of France?</span><span>&#34;, &#34;</span><span>The keywords are: capital, france, </span><span>&#34;)
</span><span>        .</span><span>build</span><span>();
</span><span>
</span><span>    </span><span>// The first time we use the task, it will load the model and prompt which will take a bit longer.
</span><span>    task.</span><span>run</span><span>(&#34;</span><span>What is the temperature in Chicago?</span><span>&#34;, &amp;llm)
</span><span>        .await
</span><span>        .</span><span>unwrap</span><span>()
</span><span>        .</span><span>to_std_out</span><span>()
</span><span>        .await
</span><span>        .</span><span>unwrap</span><span>();
</span><span>}
</span></pre>
</div></div><p data-node-hydration="20">Or you can use more complex constraints to </p><div data-node-hydration="21"><div><pre><span>// First, we need to create a Llama instance. We will use the default chat model (open chat) for this example. Tasks work with chat and text generation models.
</span><span>let mut</span><span> llm = Llama::new_chat();
</span><span>
</span><span>// Next (optionally), we can define constraints for the task. In this example, we will use a regex to validate the output of the task.
</span><span>let</span><span> constraints =
</span><span>	RegexParser::new(</span><span>r</span><span>&#34;(Step \d: \d+ [+\-*/] \d+ = \d+\n){1,3}Output: \d+</span><span>&#34;).</span><span>unwrap</span><span>();
</span><span>
</span><span>// Now we can create a task. We will create a simple math problem solving task.
</span><span>let</span><span> task = Task::builder(&amp;llm, &#34;</span><span>You are an assistant who solves math problems. When solving problems, you will always solve problems step by step with one step per line. Once you have solved the problem, you will output the result in the format &#39;Output: &lt;result&gt;&#39;.</span><span>&#34;)
</span><span>	.</span><span>with_constraints</span><span>(constraints)
</span><span>	</span><span>// You can also add examples to the task to help the agent learn how to solve math problems.
</span><span>	.</span><span>with_example</span><span>(&#34;</span><span>What is 1 + 2?</span><span>&#34;, &#34;</span><span>Step 1: 1 + 2 = 3</span><span>\n</span><span>Output: 3</span><span>&#34;)
</span><span>	.</span><span>with_example</span><span>(&#34;</span><span>What is 3 + 4?</span><span>&#34;, &#34;</span><span>Step 1: 3 + 4 = 7</span><span>\n</span><span>Output: 7</span><span>&#34;)
</span><span>	.</span><span>with_example</span><span>(&#34;</span><span>What is (4 + 8) / 3?</span><span>&#34;, &#34;</span><span>Step 1: 4 + 8 = 12</span><span>\n</span><span>Step 2: 12 / 3 = 4</span><span>\n</span><span>Output: 4</span><span>&#34;)
</span><span>	.</span><span>build</span><span>();
</span><span>
</span><span>// The first time we use the task, it will load the model and prompt which will take a bit longer.
</span><span>task.</span><span>run</span><span>(&#34;</span><span>What is 2 + 2?</span><span>&#34;, &amp;llm)
</span><span>	.await
</span><span>	.</span><span>unwrap</span><span>()
</span><span>	.</span><span>to_std_out</span><span>()
</span><span>	.await
</span><span>	.</span><span>unwrap</span><span>();
</span></pre>
</div></div><p data-node-hydration="22">Tasks can efficiently reuse the session between runs, which can significantly speed up the process:</p><div data-node-hydration="23"><div><pre><span>question </span><span>1
</span><span>Step </span><span>1</span><span>: </span><span>2 </span><span>+ </span><span>2 </span><span>= </span><span>4
</span><span>Output: </span><span>4.
</span><span>first question took: </span><span>18.371939709</span><span>s
</span><span>question </span><span>2
</span><span>Step </span><span>1</span><span>: </span><span>4 </span><span>+ </span><span>4 </span><span>= </span><span>8
</span><span>Output: </span><span>8
</span><span>second question took: </span><span>5.723529959</span><span>s
</span><span>question </span><span>3
</span><span>Step </span><span>1</span><span>: </span><span>7 </span><span>+ </span><span>5 </span><span>= </span><span>12
</span><span>Step </span><span>2</span><span>: </span><span>12 </span><span>/ </span><span>2 </span><span>= </span><span>6
</span><span>Output: </span><span>6
</span><span>third question took: </span><span>9.303650625</span><span>s
</span></pre>
</div></div><p data-node-hydration="24">The third question required a more complex calculation and took more tokens to solve, but the time to solve the question was still significantly faster than the first question. The session from the first question was reused for the second and third questions which made the second and third questions run faster.</p><ul data-node-hydration="25"><li><strong>Evaluation Abstraction:</strong> Introducing an evaluation abstraction, providing enhanced functionality. (<a href="https://github.com/floneum/floneum/pull/113">#113</a>)</li></ul><div data-node-hydration="26"><div><pre><span>+-----------------+-------+
</span><span>| Statistic       | Value |
</span><span>+=========================+
</span><span>| Mean            | </span><span>0.75  </span><span>|
</span><span>|-----------------+-------|
</span><span>| Median          | </span><span>0.77  </span><span>|
</span><span>|-----------------+-------|
</span><span>| Min             | </span><span>0.49  </span><span>|
</span><span>|-----------------+-------|
</span><span>| Max             | </span><span>0.94  </span><span>|
</span><span>|-----------------+-------|
</span><span>| 25th Percentile | </span><span>0.67  </span><span>|
</span><span>|-----------------+-------|
</span><span>| 75th Percentile | </span><span>0.81  </span><span>|
</span><span>+-----------------+-------+
</span><span>+------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------+--------------------+
</span><span>| Expected Output                                                                          | Actual Output                                                                             | Score              |
</span><span>+===========================================================================================================================================================================================================+
</span><span>| What are Floneum plugins?                                                                | What is designed to support an expanding ecosystem of plugins?                            | </span><span>0.49 </span><span>(low outlier) |
</span><span>|------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------+--------------------|
</span><span>| What is supervised learning in machine learning?                                         | What is required </span><span>for</span><span> machine learning models in order to make accurate predictions?       | </span><span>0.50 </span><span>(low outlier) |
</span><span>|------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------+--------------------|
</span><span>| What distinguishes open-source software from proprietary software?                       | What </span><span>type </span><span>of access does open source software provide </span><span>for</span><span> its users?                      | </span><span>0.64               </span><span>|
</span><span>|------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------+--------------------|
</span><span>| How does blockchain contribute to the security of cryptocurrencies?                      | What is the advantage of cryptocurrency over traditional currencies in terms of security? | </span><span>0.65               </span><span>|
</span><span>|------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------+--------------------|
</span><span>| What are the tradeoffs of using chat </span><span>GPT</span><span>?                                                | What is an example of how using ChatGPT may </span><span>become</span><span> challenging in certain situations?     | </span><span>0.65               </span><span>|
</span><span>|------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------+--------------------|
</span><span>| What is the relationship between DevOps, continuous integration and continuous delivery? | What is the main goal of DevOps?                                                          | </span><span>0.67               </span><span>|
</span><span>|------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------+--------------------|
</span><span>| ... </span><span>18</span><span> more                                                                              |                                                                                           | </span><span>0.80 </span><span>(average)     |
</span><span>+------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------+--------------------+
</span><span>| Score Histogram        |
</span><span>| </span><span>0.00 </span><span>- </span><span>0.10</span><span>:           |
</span><span>| </span><span>0.10 </span><span>- </span><span>0.20</span><span>:           |
</span><span>| </span><span>0.20 </span><span>- </span><span>0.30</span><span>:           |
</span><span>| </span><span>0.30 </span><span>- </span><span>0.40</span><span>:           |
</span><span>| </span><span>0.40 </span><span>- </span><span>0.50</span><span>: *         |
</span><span>| </span><span>0.50 </span><span>- </span><span>0.60</span><span>: *         |
</span><span>| </span><span>0.60 </span><span>- </span><span>0.70</span><span>: ******    |
</span><span>| </span><span>0.70 </span><span>- </span><span>0.80</span><span>: ********* |
</span><span>| </span><span>0.80 </span><span>- </span><span>0.90</span><span>: *****     |
</span><span>| </span><span>0.90 </span><span>- </span><span>1.00</span><span>: **        |
</span></pre>
</div></div><ul data-node-hydration="27"><li><strong>Prompt Auto-Tuning:</strong> Prompts can now be automatically tuned for better performance. (<a href="https://github.com/floneum/floneum/pull/132">#132</a>)</li></ul><p data-node-hydration="28">Lets take a look at the new prompt auto-tuning feature with an example. As part of the <a href="#Improved-Chunking-Strategies">RAG improvements</a>, kalosm includes a task that generates hypothetical questions about a text for an embedding model that can be used to find similar documents based on the meaning of the text for the  section. We can tune that task to find the best examples for the task with a PromptAnnealer:</p><div data-node-hydration="29"><div><pre><span>const </span><span>EXAMPLES</span><span>: &amp;[(&amp;</span><span>str</span><span>, &amp;</span><span>str</span><span>)]= &amp;[
</span><span>    (&#34;</span><span>An example input to the task</span><span>&#34;, &#34;</span><span>An example output to the task</span><span>&#34;),
</span><span>    </span><span>// ...more examples
</span><span>];
</span><span>
</span><span>let</span><span> llm = Phi::v2();
</span><span>const </span><span>PREFIX</span><span>: &amp;</span><span>str </span><span>= &#34;</span><span>Questions that are answered by the previous text: </span><span>&#34;;
</span><span>const </span><span>QUESTION_STARTERS</span><span>: [&amp;</span><span>str</span><span>; </span><span>9</span><span>] = [
</span><span>    &#34;</span><span>Who</span><span>&#34;, &#34;</span><span>What</span><span>&#34;, &#34;</span><span>When</span><span>&#34;, &#34;</span><span>Where</span><span>&#34;, &#34;</span><span>Why</span><span>&#34;, &#34;</span><span>How</span><span>&#34;, &#34;</span><span>Which</span><span>&#34;, &#34;</span><span>Whom</span><span>&#34;, &#34;</span><span>Whose</span><span>&#34;,
</span><span>];
</span><span>let</span><span> constraints = LiteralParser::new(</span><span>PREFIX</span><span>).</span><span>then</span><span>(
</span><span>    IndexParser::new(
</span><span>        </span><span>QUESTION_STARTERS
</span><span>            .</span><span>iter</span><span>()
</span><span>            .</span><span>copied</span><span>()
</span><span>            .</span><span>map</span><span>(LiteralParser::new)
</span><span>            .collect::&lt;Vec&lt;_&gt;&gt;(),
</span><span>    )
</span><span>    .</span><span>then</span><span>(StopOn::new(&#34;</span><span>?</span><span>&#34;).</span><span>filter_characters</span><span>(
</span><span>        |</span><span>c</span><span>| matches!(c, &#39; &#39; | &#39;</span><span>?</span><span>&#39; | &#39;</span><span>a</span><span>&#39;..=&#39;</span><span>z</span><span>&#39; | &#39;</span><span>A</span><span>&#39;..=&#39;</span><span>Z</span><span>&#39; | &#39;</span><span>0</span><span>&#39;..=&#39;</span><span>9</span><span>&#39; | &#39;</span><span>,</span><span>&#39;),
</span><span>    ))
</span><span>    .</span><span>repeat</span><span>(</span><span>1</span><span>..=</span><span>5</span><span>),
</span><span>);
</span><span>let</span><span> task = Task::builder(&#34;</span><span>You generate hypothetical questions that may be answered by the given text. The questions restate any information necessary to understand the question</span><span>&#34;)
</span><span>    .</span><span>with_constraints</span><span>(constraints);
</span><span>let mut</span><span> annealing = kalosm::PromptAnnealer::builder(&amp;llm, </span><span>EXAMPLES</span><span>, task)
</span><span>    .</span><span>with_initial_temperature</span><span>(</span><span>0.6</span><span>)
</span><span>    .</span><span>with_initial_choice_range</span><span>(</span><span>1</span><span>..</span><span>4</span><span>)
</span><span>    .</span><span>build</span><span>()
</span><span>    .await;
</span><span>
</span><span>let</span><span> result = annealing.</span><span>run</span><span>().await;
</span><span>
</span><span>println!(&#34;</span><span>Result: </span><span>{:?}</span><span>&#34;, result);
</span></pre>
</div></div><p data-node-hydration="30">Here is the best set of examples that the prompt annealer found for the task:</p><table data-node-hydration="31"><thead><tr><th>Input</th><th>Output</th></tr></thead><tbody><tr><th>While traditional databases rely on a fixed schema, NoSQL databases like MongoDB offer a flexible structure, allowing you to store and retrieve data in a more dynamic way. This flexibility is particularly beneficial for applications with evolving data requirements.</th><th>&#34;How does MongoDB differ from traditional databases?</th></tr><tr><th>Blockchain technology, beyond cryptocurrencies, is being explored for applications like smart contracts. Smart contracts are self-executing contracts with the terms of the agreement directly written into code.</th><th>&#34;How is blockchain technology utilized in the concept of smart contracts?</th></tr></tbody></table><p data-node-hydration="32">Feeding those two examples into the task achieves a similarity score of 0.71 for all of the other examples compared to choosing two random examples from the task which only achieves a similarity score of  0.62 for all of the other examples.</p><h2 id="regex-validation" data-node-hydration="33"><a href="#regex-validation">Regex Validation</a></h2><p data-node-hydration="34">Some feedback we got from the initial release of kalosm, was that constraints for constrained generation was too complex. Constraints in Kalosm serve two purposes:</p><ol data-node-hydration="35"><li>Validation: Constraints can be used to validate the output of the model. The model will only output text that can be parsed by the constraints. This lets you ensure that the output of the model is in the format you expect.</li></ol><p data-node-hydration="36">For example, you may want to force the model response to always start with a prefix that guides the model:</p><div data-node-hydration="37"><div><pre><span>use </span><span>kalosm::language::*;
</span><span>
</span><span>#[</span><span>tokio</span><span>::</span><span>main</span><span>]
</span><span>async </span><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> llm = Llama::default();
</span><span>    </span><span>let</span><span> prompt = &#34;</span><span>Generate a list of 10 words you use to describe yourself: </span><span>&#34;;
</span><span>
</span><span>    </span><span>let</span><span> validator = LiteralParser::new(&#34;</span><span>(Responding as a pirate) </span><span>&#34;).</span><span>then</span><span>(OneLine);
</span><span>    </span><span>let</span><span> stream = llm.</span><span>stream_structured_text</span><span>(prompt, validator).await.</span><span>unwrap</span><span>();
</span><span>
</span><span>    stream.</span><span>to_std_out</span><span>().await.</span><span>unwrap</span><span>();
</span><span>}
</span></pre>
</div></div><ol data-node-hydration="38"><li>Parsing: Constraints can be used to parse the output of the model. This can be extremely useful when you want to generate a specific structure from an LLM without writing separate logic for validation and parsing.</li></ol><p data-node-hydration="39">For example, you may want to generate a list of 10 numbers:</p><div data-node-hydration="40"><div><pre><span>use </span><span>kalosm::language::*;
</span><span>
</span><span>#[</span><span>tokio</span><span>::</span><span>main</span><span>]
</span><span>async </span><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> llm = Llama::default();
</span><span>    </span><span>let</span><span> prompt = &#34;</span><span>Prime numbers: </span><span>&#34;;
</span><span>
</span><span>    </span><span>let</span><span> validator = &lt;[</span><span>f32</span><span>; </span><span>10</span><span>] as HasParser&gt;::new_parser();
</span><span>    </span><span>let</span><span> words = llm.</span><span>stream_structured_text</span><span>(prompt, validator).await.</span><span>unwrap</span><span>();
</span><span>
</span><span>    </span><span>let</span><span> result: [</span><span>f32</span><span>; </span><span>10</span><span>] = words.</span><span>result</span><span>().await.</span><span>unwrap</span><span>();
</span><span>    println!(&#34;</span><span>Prime numbers: </span><span>{:?}</span><span>&#34;, result);
</span><span>}
</span></pre>
</div></div><p data-node-hydration="41">If you only need to validate the output of the model, the existing constraints can be more complex than what you need. In this release, we&#39;ve added support for regex validation. This makes it easier to validate the output of the model without handling parsing:</p><div data-node-hydration="42"><div><pre><span>use </span><span>kalosm::language::*;
</span><span>
</span><span>#[</span><span>tokio</span><span>::</span><span>main</span><span>]
</span><span>async </span><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> llm = Llama::default();
</span><span>    </span><span>let</span><span> prompt = &#34;</span><span>Generate a list of 10 words you use to describe yourself: </span><span>&#34;;
</span><span>
</span><span>    </span><span>let</span><span> validator = RegexParser::new(</span><span>r</span><span>&#34;\(Responding as a pirate\) ([a-z]{1,10}, ){10}</span><span>&#34;).</span><span>unwrap</span><span>();
</span><span>    </span><span>let</span><span> stream = llm.</span><span>stream_structured_text</span><span>(prompt, validator).await.</span><span>unwrap</span><span>();
</span><span>
</span><span>    stream.</span><span>to_std_out</span><span>().await.</span><span>unwrap</span><span>();
</span><span>}
</span></pre>
</div></div><h2 id="surreal-database-integration" data-node-hydration="43"><a href="#surreal-database-integration">Surreal Database Integration</a></h2><p data-node-hydration="44">Vector databases can be very useful when combined with LLMs. They can be used to store and retrieve similar documents based on the meaning of the text, not just the words used. However, vector databases only handle a very limited number of use cases. In this release, we&#39;ve added support for Surreal DB for more traditional database use cases. Surreal DB can be embedded into your application and used to store and retrieve data locally as well as over the network.</p><p data-node-hydration="45">Kalosm 0.2 allows you to create tables within Surreal DB that are indexed by vectors. You can then insert documents (or other embeddings) into the table and query the table for similar documents based on the meaning of the text.</p><p data-node-hydration="46">Let&#39;s take a look at how you can use the Surreal DB integration to store and retrieve similar documents based on the meaning of the text:</p><div data-node-hydration="47"><div><pre><span>use </span><span>comfy_table::{Cell, Color, Row, Table};
</span><span>use </span><span>kalosm::language::*;
</span><span>use </span><span>kalosm::*;
</span><span>use </span><span>std::path::PathBuf;
</span><span>use </span><span>surrealdb::{engine::local::RocksDb, Surreal};
</span><span>
</span><span>let</span><span> exists = std::path::Path::new(&#34;</span><span>./db</span><span>&#34;).</span><span>exists</span><span>();
</span><span>
</span><span>// Create or open a new database at ./db/temp.db
</span><span>let</span><span> db = Surreal::new::&lt;RocksDb&gt;(&#34;</span><span>./db/temp.db</span><span>&#34;).await.</span><span>unwrap</span><span>();
</span><span>
</span><span>// Select a specific namespace / database within the database
</span><span>db.</span><span>use_ns</span><span>(&#34;</span><span>test</span><span>&#34;).</span><span>use_db</span><span>(&#34;</span><span>test</span><span>&#34;).await.</span><span>unwrap</span><span>();
</span><span>
</span><span>// Create a new document table that uses arroy for fast vector search
</span><span>let</span><span> document_table = db
</span><span>    .</span><span>document_table_builder</span><span>(&#34;</span><span>documents</span><span>&#34;)
</span><span>    </span><span>// Store the embedding database in the same directory as the document table
</span><span>    .</span><span>at</span><span>(&#34;</span><span>./db/embeddings.db</span><span>&#34;)
</span><span>    .</span><span>build</span><span>()
</span><span>    .</span><span>unwrap</span><span>();
</span><span>
</span><span>// If the database doesn&#39;t exist, create it and insert some documents
</span><span>if </span><span>!exists {
</span><span>    std::fs::create_dir_all(&#34;</span><span>documents</span><span>&#34;).</span><span>unwrap</span><span>();
</span><span>    </span><span>// Load some files from a directory
</span><span>    </span><span>let</span><span> documents = DocumentFolder::try_from(PathBuf::from(&#34;</span><span>./documents</span><span>&#34;)).</span><span>unwrap</span><span>();
</span><span>
</span><span>    </span><span>// Convert the folder into a vector of documents
</span><span>    </span><span>let</span><span> documents = documents.</span><span>into_documents</span><span>().await.</span><span>unwrap</span><span>();
</span><span>    </span><span>for</span><span> document in documents {
</span><span>        </span><span>// And insert the documents into the table (this will automatically chunk and embed the documents before they are inserted into the table and vector database)
</span><span>        document_table.</span><span>insert</span><span>(document).await.</span><span>unwrap</span><span>();
</span><span>    }
</span><span>}
</span><span>
</span><span>// Now we can query the table for similar documents based on the meaning of the text
</span><span>loop </span><span>{
</span><span>    </span><span>// Get a query from the user and embed that query into a vector
</span><span>    </span><span>let</span><span> user_question = </span><span>prompt_input</span><span>(&#34;</span><span>Query: </span><span>&#34;).</span><span>unwrap</span><span>();
</span><span>    </span><span>let</span><span> user_question_embedding = document_table
</span><span>        .</span><span>embedding_model_mut</span><span>()
</span><span>        .</span><span>embed</span><span>(&amp;user_question)
</span><span>        .await
</span><span>        .</span><span>unwrap</span><span>();
</span><span>
</span><span>    </span><span>// Select the 5 most similar documents to the user&#39;s query
</span><span>    </span><span>let</span><span> nearest_5 = document_table
</span><span>        .</span><span>select_nearest_embedding</span><span>(user_question_embedding, </span><span>5</span><span>)
</span><span>        .await
</span><span>        .</span><span>unwrap</span><span>();
</span><span>
</span><span>    </span><span>// Display the results in a formatted table with colors based on the distance from the query
</span><span>    </span><span>let mut</span><span> table = Table::new();
</span><span>    table.</span><span>set_header</span><span>(vec![&#34;</span><span>Score</span><span>&#34;, &#34;</span><span>Value</span><span>&#34;]);
</span><span>
</span><span>    </span><span>for</span><span> result in nearest_5 {
</span><span>        </span><span>let mut</span><span> row = Row::new();
</span><span>        </span><span>let</span><span> color = </span><span>if</span><span> result.distance &lt; </span><span>0.25 </span><span>{
</span><span>            Color::Green
</span><span>        } </span><span>else if</span><span> result.distance &lt; </span><span>0.75 </span><span>{
</span><span>            Color::Yellow
</span><span>        } </span><span>else </span><span>{
</span><span>            Color::Red
</span><span>        };
</span><span>        row.</span><span>add_cell</span><span>(Cell::new(result.distance).</span><span>fg</span><span>(color))
</span><span>            .</span><span>add_cell</span><span>(Cell::new(result.record.</span><span>body</span><span>()[</span><span>0</span><span>..</span><span>50</span><span>].</span><span>to_string</span><span>() + &#34;</span><span>...</span><span>&#34;));
</span><span>        table.</span><span>add_row</span><span>(row);
</span><span>    }
</span><span>
</span><span>    println!(&#34;</span><span>{}</span><span>&#34;, table);
</span><span>}
</span></pre>
</div></div><h2 id="rag-improvements" data-node-hydration="48"><a href="#rag-improvements">RAG improvements</a></h2><p data-node-hydration="49">RAG (Retrieval-Augmented Generation) is a powerful tool for generating text with up-to-date or proprietary information. Resource augmented generation generally follows the following steps:</p><ol data-node-hydration="50"><li>Gather context from some local files, your database, or web data. In kalosm, you can retrieve data from any source that implements <a href="https://docs.rs/kalosm/0.2.0/kalosm/language/trait.IntoDocument.html"><code>IntoDocument</code></a> or <a href="https://docs.rs/kalosm/0.2.0/kalosm/language/trait.IntoDocuments.html"><code>IntoDocuments</code></a>. You can gather your sources from <a href="https://docs.rs/kalosm/0.2.0/kalosm/language/struct.DocumentFolder.html">local documents</a>, a <a href="https://docs.rs/kalosm/0.2.0/kalosm/language/struct.SearchQuery.html">search term</a>, <a href="https://docs.rs/kalosm/0.2.0/kalosm/language/struct.Url.html">specific web page</a>, an <a href="https://docs.rs/kalosm/0.2.0/kalosm/language/struct.RssFeed.html">RSS feed</a>, or even a <a href="https://docs.rs/kalosm/0.2.0/kalosm/language/enum.Page.html#method.crawl">custom web crawler</a>.</li><li>Insert that context into a searchable database. Kalosm includes a <a href="https://docs.rs/kalosm/0.2.0/kalosm/language/struct.VectorDB.html">vector database</a> that can be used to store and retrieve similar documents.</li></ol><p data-node-hydration="51">Vector databases use an embedding model which generates a vector for a chunk of text (typically smaller than the entire document). The vector is then stored in the database. When you want to retrieve similar documents, you can embed a query and search for similar vectors in the database.</p><p data-node-hydration="52">The vectors represent the meaning of the text, so you can search for similar documents based on the meaning of the text, not just the words used.</p><ol data-node-hydration="53"><li>Use the context to generate text. You can find text similar to the question or a search generated by the LLM and then generate a response based on the context.</li></ol><p data-node-hydration="54">In this release, we&#39;ve made several improvements to RAG! (<a href="https://github.com/floneum/floneum/pull/126">#126</a>)</p><h3 id="improved-chunking-strategies" data-node-hydration="55"><a href="#improved-chunking-strategies">Improved Chunking Strategies</a></h3><p data-node-hydration="56">When you insert a document into a vector database, it needs to be split into smaller chunks before the text is embedded. The chunks you choose can have a significant impact on the performance of the results you get from the vector database. In this release, we&#39;ve added two new chunking strategies to the vector database:</p><ul data-node-hydration="57"><li>Hypothetical Questions</li></ul><p data-node-hydration="58">Instead of generating embeddings based on the content of the document, this chunking strategy generates embeddings based on hypothetical questions generated about the document. This can be extremely useful when building a chatbot that needs to find context that is relevant to a question.</p><p data-node-hydration="59">For example, if you have a document about the history of the United States, you can generate hypothetical questions like &#34;What is the capital of the United States?&#34; and &#34;Who was the first president of the United States?&#34; and then generate embeddings based on those questions.</p><p data-node-hydration="60">Then if you query the vector database with a question like &#34;Who was the leader of the US?&#34; you can find the document about the history of the United States.</p><blockquote data-node-hydration="61"><p>Notice that the question &#34;Who was the leader of the US?&#34; doesn&#39;t contain many of the same words as the hypothetical questions, but it does convey a similar meaning, so the vector database can still find the relevant document.</p></blockquote><ul data-node-hydration="62"><li>Summaries</li></ul><p data-node-hydration="63">This chunking strategy generates embeddings based on the summary of the document. This can be useful when you have a large document and you want to find similar documents based on the main points of the document.</p><p data-node-hydration="64">Generating embeddings based on the summary of the document can create better embeddings that contain more information about the document than embeddings that only contain one small chunk of the document.</p><h3 id="incremental-indexing" data-node-hydration="65"><a href="#incremental-indexing">Incremental Indexing</a></h3><p data-node-hydration="66">In addition to the new chunking strategies, we&#39;ve also added support for incremental indexing. This means you can add new documents to the vector database without having to recreate the entire database. This can be extremely useful when you have a large database or you have constantly updating context you want to provide to your LLM.</p><p data-node-hydration="67">Kalosm&#39;s Vector database is now backed by <a href="https://github.com/meilisearch/arroy">arroy</a>, a space-efficient and incrementally indexed vector database backed by MeiliSearch!</p><h2 id="performance-improvements" data-node-hydration="68"><a href="#performance-improvements">Performance Improvements</a></h2><p data-node-hydration="69">The llama implementation has been rewritten and optimized for better performance and modularity. The new implementation is now 7-25% faster than the previous version. In future releases, we plan to add support for fine tuning models and training new heads for existing models. (<a href="https://github.com/floneum/floneum/pull/122">#122</a>)</p><p data-node-hydration="70">Language models like Llama and Phi output probabilities for each token in the vocabulary. To generate text you need to sample from the probability distribution. Sampling from the probability distribution can be slow, especially with large vocabularies. Kalosm 0.2 uses an optimization introduced in <a href="https://github.com/KerfuffleV2/llm-samplers/pull/9">llm-samplers</a> to only sample top 512 tokens. This optimization can make sampling up to 2x faster. (<a href="https://github.com/floneum/floneum/pull/123">#123</a>)</p><p data-node-hydration="71">Large sections of text that are static within a constraint in structured generation is now loaded in a batch which can significantly speed up the process.</p><p data-node-hydration="72">For example if you have the constraints:</p><div data-node-hydration="73"><div><pre><span>let</span><span> constraints = RegexParser::new(</span><span>r</span><span>#</span><span>&#34;(The title of the book is [a-z]{2,15}\n)*</span><span>&#34;#).</span><span>unwrap</span><span>();
</span></pre>
</div></div><p data-node-hydration="74">The text &#34;The title of the book is &#34; will be loaded in a batch instead of one token at a time. Batched loading has been restored in constrained generation. (<a href="https://github.com/floneum/floneum/pull/131">#131</a>)</p><h2 id="new-models" data-node-hydration="75"><a href="#new-models">New Models</a></h2><p data-node-hydration="76">Kalosm 0.2 adds support for several new models, including:</p><ul data-node-hydration="77"><li><strong>Dolphin Phi v2</strong> A tiny chat model</li><li><strong>Solar-11b Models</strong> A set of models for chat, text, and code generation</li><li><strong>Tiny Llama 1.0</strong> A tiny set of models for chat, and text text generation</li></ul><h2 id="full-changelog" data-node-hydration="78"><a href="#full-changelog">Full Changelog</a></h2><p data-node-hydration="79">For a detailed list of changes between v0.1.0 and v0.2.0, please see the <a href="https://github.com/floneum/floneum/compare/v0.2.0...v0.2.0-kalosm">full changelog</a>.</p><p data-node-hydration="80">I hope you enjoy using Kalosm v0.2.0! Your feedback is invaluable to us, so please don&#39;t hesitate to share your thoughts and report any issues you encounter.</p><h2 id="whats-next" data-node-hydration="81"><a href="#whats-next">What&#39;s next?</a></h2><p data-node-hydration="82">In the next release, we plan to add support for fine tuning models and training new heads for existing models. We also plan to continue improving the performance of the language models and adding support for more models.</p><p data-node-hydration="83">If any of those features sound interesting or you want to propose a new feature, consider contributing on <a href="https://github.com/floneum/floneum/tree/master/interfaces/kalosm">Github</a>.</p><p data-node-hydration="84">If you are interested in building an application with Kalosm, <a href="https://discord.gg/dQdmhuB8q5">join the Discord</a> and get involved with the community!</p></article></div></div></section></div>
  </body>
</html>
