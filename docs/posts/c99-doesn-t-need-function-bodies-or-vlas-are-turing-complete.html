<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemon.rip/w/c99-vla-tricks/">Original</a>
    <h1>C99 doesn&#39;t need function bodies, or &#39;VLAs are Turing complete&#39;</h1>
    
    <div id="readability-page-1" class="page">
  <section>
    <div>
      

<nav>
  <a href="https://lemon.rip/">Home</a> <a href="https://lemon.rip/w/">Go Back</a>
</nav>

<p>19 Feb 2022</p>

<hr/>

<p>The 1999 revision to the C programming language brought several interesting
changes and additions to the standard. Among those are variable length arrays,
or VLAs for short, which allow array types to have lengths that are determined
at runtime. These can show up in different contexts, but for the purposes of
this post we will be looking at VLAs as parameters to functions. For example:</p>
<pre><code>void f(int n, float v[n]);
</code></pre>
<p>Since array parameters decay to their corresponding pointer type, that
declaration is functionally equivalent, and compatible (<a href="http://port70.net/%7Ensz/c/c99/n1256.html#6.7.5.3p7">6.7.5.3p7</a>) to the
following:</p>
<pre><code>void f(int n, float *v);
</code></pre>
<p>The length of <code>v</code> in the first declaration is given by the value of a previous
parameter of the function, which can only be known at runtime. However, in a
function prototype (i.e. not a function definition) like the above, the length
of a VLA parameter is never computed and essentially ignored (<a href="http://port70.net/%7Ensz/c/c99/n1256.html#6.7.5.2p5">6.7.5.2p5</a>).
But in a function definition, the length is evaluated and must be greater than
zero. In practice this is rather useless because the sizeof operator doesn&#39;t
work as one might expect it to with array parameters (<a href="http://port70.net/%7Ensz/c/c99/n1256.html#note88">6.5.3.4-note88</a>):</p>
<pre><code>void f(int n, float param[n]) {
    float local[n];
    int a = sizeof local,
        b = sizeof param;

    printf(&#34;n = %d\n&#34;, n);
    printf(&#34;sizeof local = %d\n&#34;, a); // this will be n * sizeof(float)
    printf(&#34;sizeof param = %d\n&#34;, b); // but this will be sizeof(float *)
}
</code></pre>
<p>In other words, using sizeof with a VLA will evaluate the runtime-known length
and calculate the array size based on that, except when that VLA is a function
parameter, then, for whatever reason, it is the size of the corresponding
pointer type (in this example, <code>sizeof local === n * sizeof(float)</code> but <code>sizeof param == sizeof(float *)</code>). The length of a VLA parameter may be used when e.g.
computing indices when accessing multi-dimensional variable length arrays.</p>
<p>Alas, the standard mandates that the variable array length be computed when
the function is called. Of course, the expression in between the square
brackets is not limited to simple expressions like <code>n</code>, so one can write
something like:</p>
<pre><code>void f(int a, int b, int m[(a + b) / 2]) {}
</code></pre>
<p>or</p>
<pre><code>void f(int x, int b[abs(x)]) {}
</code></pre>
<p>or even</p>
<pre><code>void f(int v[getchar()]) {}
</code></pre>

<p>The following program should give you an idea of the kind of constructs
that these rules allow for (<a href="https://godbolt.org/z/f3chYMvh5">try it on compiler explorer</a>):</p>
<pre><code>int main(int argc, char *argv[printf(&#34;Hello&#34;)])
{
    printf(&#34; world!\n&#34;);
}
</code></pre>
<p>The length expression of the VLA is evaluated before any of the statements in
<code>main</code>. I couldn&#39;t find anywhere in the standard saying whether this evaluation
order is well-defined but it is what clang and gcc do, and luckily, it does not
matter for the sake of this article, as we will see shortly.</p>
<p>Let us refer to the subset of C99 where function bodies must be empty as
<em>disembodied C</em>. You might naturally ask yourself what things can be
accomplished in this subset (though you can probably guess the answer from the
title of this page). In other words, what can you do in C if you are limited to
just evaluating expressions and no statements?</p>
<ul>
<li>
<p>Using the comma operator, we can sequence arbitrarily many expressions for
their side effects, so</p>
<pre><code>void f() {
    printf(&#34;Press enter to confirm: &#34;);
    getchar();
    printf(&#34;thanks.\n&#34;);
}
</code></pre>
<p>becomes</p>
<pre><code>void f(char _[(
    printf(&#34;Press enter to confirm: &#34;),
    getchar(),
    printf(&#34;thanks.\n&#34;),
    1
)]) {}
</code></pre>
<p>In a comma expression, the operands are evaluated left-to-right and the value
of the last operand is the resulting value of the whole expression. The <code>1</code>
at the end ensures that the evaluated array length is &gt;0 (to avoid UB).</p>
</li>
<li>
<p>Functions in disembodied C are going to need a dummy parameter where the VLA
length expression evaluation can take place. For consistency, we will denote
it as <code>char _[...]</code> and give it the value <code>&#34;&#34;</code> (the empty string) when calling
said functions (note that the value we give it doesn&#39;t actually matter, though
its size should be at least as big as the computed VLA size to avoid UB).</p>
</li>
<li>
<p>If-else statements can be replaced with ternary conditional expressions, such that</p>
<pre><code>void f(int n) {
    if (n &lt; 0)
        printf(&#34;negative!&#34;);
    else if (n &gt; 0)
        printf(&#34;positive!&#34;);
    else
        printf(&#34;zero!&#34;);
}
</code></pre>
<p>becomes</p>
<pre><code>void f(int n, char _[(
    (n &lt; 0) ?
        printf(&#34;negative!&#34;)
    : (n &gt; 0) ?
        printf(&#34;positive!&#34;)
    :
        printf(&#34;zero!&#34;)
    , 1
)]) {}
</code></pre>
</li>
<li>
<p>Remember that the VLA length expression can access previous function arguments,
so parameter passing is essentially unchanged.</p>
</li>
<li>
<p>We cannot return values, but we can use out parameters by taking advantage of
the fact that assignments are expressions in C, so instead of</p>
<pre><code>int imax(int a, int b) {
    return a &gt; b ? a : b;
}
</code></pre>
<p>we can write</p>
<pre><code>void imax(int *out, int a, int b, char _[
    (*out = a &gt; b ? a : b),
    1
]) {}
</code></pre>
</li>
<li>
<p>We cannot define local variables inside of expressions, but we can just add
extra function parameters to use as temporaries, rewriting</p>
<pre><code>void fswapf(float *a, float *b) {
    float tmp = *a;
    *a = *b;
    *b = tmp;
}
</code></pre>
<p>as</p>
<pre><code>static void fswapf_aux(float *a, float *b, float tmp, char _[(
    tmp = *a,
    *a = *b,
    *b = tmp,
    1
)]) {}

void fswapf(float *a, float *b, char _[(
    fswapf_aux(a, b, 0, &#34;&#34;), 1
)]) {}
</code></pre>
<p>Alternatively, if re-entrancy and thread-safety are disregarded, we could
just use global (static) variables.</p>
</li>
<li>
<p>What about loops? Clearly we cannot use <code>while</code> or <code>for</code> inside expressions.
Thankfully, they are unnecessary thanks to recursion. For example:</p>
<pre><code>float sum(float *v, size_t n) {
    float sum = 0.0f;
    for (size_t i = 0; i &lt; n; ++i)
        sum += v[i];
    return sum;
}
</code></pre>
<p>can be expressed as</p>
<pre><code>/* the forward declaration is necessary */
static void sum_aux(float *out, float *v, size_t n, char *);
static void sum_aux(float *out, float *v, size_t n, char _[(
    (n &gt; 0) ? (
        *out += *v,
        sum_aux(out, v + 1, n - 1, &#34;&#34;),
        1
    ) : 1
)]) {}

void sum(float *out, float *v, size_t n, char _[(
    *out = 0.0f,
    sum_aux(out, v, n, &#34;&#34;),
    1
)]) {}
</code></pre>
<p>In fact, any imperative-style loop can be turned into an equivalent recursive
loop (as any functional programmer will be happy to demonstrate), though since
C lacks closures or any form of anonymous functions, it can get quite unwieldy
(I hope you like auxiliary functions).</p>
<p>The astute reader might point out that these two versions of <code>sum</code> are not
equivalent because the recursive definition may cause a stack overflow for
large enough values of <code>n</code>. This is unfortunately true, and the major hurdle
for the practicality of disembodied C, but does not preclude Turing
completeness (an ideal <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing machine</a> has infinite memory at its
disposal). Luckily, modern compilers are smart, and if we write our functions
carefully to be <a href="https://en.wikipedia.org/wiki/Tail_call">tail recursive</a>, they will often be able to perform tail
call elimination, removing the risk of a stack overflow. For the above
example, both gcc and clang are able to optimize the tail call (<a href="https://godbolt.org/z/b1aG78os5">see on
compiler explorer</a>).</p>
</li>
<li>
<p>Although not relevant to standard C99, in case you had the idea of using <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">gcc
statement expressions</a> to bypass these limitations, the compiler will stop
you right on your tracks since it doesn&#39;t allow those outside of function
bodies.</p>
</li>
</ul>

<p>After all of that, it seems that basically anything can be done in disembodied
C, so, is there something that <em>can&#39;t</em> be expressed in this C99 subset?</p>
<p>With the rules that we&#39;ve laid down so far, yes. In particular:</p>
<ul>
<li>
<p>It is not possible in the general case to use APIs that require callbacks.
For example, look at the standard <code>qsort</code> function:</p>
<pre><code> void qsort(void *base, size_t nmemb, size_t size,
            int (*compar)(const void *, const void *));
</code></pre>
<p>The <code>compar</code> parameter is a pointer to a function that should return the
result of comparing two values in the given array. Since its parameters are
void pointers, we can&#39;t have the VLA argument we need to perform computations
(arrays of <code>void</code> are not valid C), and we also cannot provide an <code>int</code>
return value. Thus there is no way (that I know of) to use this function in
standards-compliant disembodied C.</p>
<p>This is not a dealbreaker since we could just reimplement <code>qsort</code> ;).</p>
</li>
<li>
<p>We cannot access the program arguments. The entry point of a program in
disembodied C looks like this:</p>
<pre><code>int main(int argc, char *argv[ /* code here ... */ ]) {}
</code></pre>
<p>In the VLA length expression for <code>argv</code>, <code>argc</code> is in scope, but <code>argv</code> is
not.</p>
<p>Fortunately there is a way to work around this: we can use the common
extension where <code>main</code> can take a third argument which is a pointer to the
environment. According to the standard (<a href="http://port70.net/%7Ensz/c/c99/n1256.html#J.5.1">J.5.1</a>), this is implemented in
hosted environments. In practice, POSIX environments and Microsoft both
support it. Then, our entry point looks like this instead:</p>
<pre><code>int main(int argc, char **argv, char *envp[/* ... */]) {}
</code></pre>
<p>Now <code>argv</code> is in scope within the <code>envp</code> array length expression.</p>
<p>Side note: even though we can&#39;t <code>return</code>, <code>main</code> is the exception to the rule
that reaching the closing <code>}</code> of a function returning non-void is verboten,
and is equivalent to returning zero (<a href="http://port70.net/%7Ensz/c/c99/n1256.html#5.1.2.2.3">5.1.2.2.3</a>). If we need to terminate
with an exit code other than zero, we can use <code>exit()</code>.</p>
</li>
</ul>

<p>It seems that with enough effort anything can be done with these peculiar
restrictions. As an example, I wrote implementations of the <a href="https://git.sr.ht/%7Elsof/x/tree/main/item/vla/md5sum.c">MD5</a> and <a href="https://git.sr.ht/%7Elsof/x/tree/main/item/vla/sha256sum.c">SHA256</a>
hash functions as well as <a href="https://git.sr.ht/%7Elsof/x/tree/main/item/vla/life.c">Conway&#39;s Game of Life using SDL for graphics</a>.
I was also working on a more interesting and &#34;useful&#34; program but I kind of
lost motivation halfway through. I&#39;ll update this article if I ever come back
to finish that.</p>
<p>In case it wasn&#39;t clear enough, there is zero practical reason to ever do any
of this. I hope you&#39;ll agree it&#39;s a fun party trick though :).</p>


    </div>
  </section>



</div>
  </body>
</html>
