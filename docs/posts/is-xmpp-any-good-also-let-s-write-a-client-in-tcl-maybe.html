<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wusspuss.neocities.org/xmpp.html">Original</a>
    <h1>Is xmpp any good? Also, let&#39;s write a client in tcl, maybe</h1>
    
    <div id="readability-page-1" class="page">


<ol>
    <li><a href="#foreword">Foreword: changing times</a></li>
    <li><a href="#philosophy">How protocols think, or why messages are lost</a></li>
    <li><a href="#xml">Making XML worse takes talent, or an overview of some XMPP ideas</a>
      <ol>
        <li><a href="#prefixes">XML namespaces, verbosity and stupidity </a></li>
        <li><a href="#markup">XML not even good for markup?</a></li>
        <li><a href="#stanza-ids">XML isn&#39;t a minor issue. Case study: stanza ids</a></li>
      </ol>
    </li>
    <li><a href="#implementing">A half-assed attempt at implementing</a>
      <ol start="0">
        <li><a href="#parsing">Step zero: Parsing it</a></li>
        <li><a href="#step1">Step one: starttls, restart stream</a></li>
        <li><a href="#step2">Step two: auth, restart stream again</a></li>
        <li><a href="#step3">Step three: bind (also presence)</a></li>
        <li><a href="#afterthoughts">Afterthoughts</a></li>
        <li><a href="#code">Complete source code</a></li>
      </ol>
    </li>
    
</ol>

<h2 id="foreword">Foreword: changing times</h2>
<p>I still have my Nokia 5800 lying around. It runs Symbian. That platform is quite different from Android. For one thing the internal storage size is 81 MB - less than what your single android app takes up, even in RAM, and it works faster than modern smartphones - e.g. the SMS app opens instantaneously. Another peculiarity of the latter is that unlike any modern chat app, including the android SMS app, it doesn&#39;t actually <a href="https://en.wikipedia.org/wiki/SMS#Threaded_SMS">divide your messages into chats</a> and presents them in a single &#34;inbox&#34; - like what you see in most e-mail clients. </p>

<p>Aside from stimulating coherent communication (where you&#39;d want to write your thought as a single coherent message, not bombard your interlocutor with two-word brainfarts like zoomers do) it meant that communications probably went at a different pace. It was not the only type of messaging interface - IRC clients certainly didn&#39;t look like that - but from the fact that such interface was <b>acceptable</b> we can conclude that messaging culture looked different.
That&#39;s the era when xmpp was developed. Oh wait, actually xmpp was conceived <b>yet another decade</b> before this phone would be released. Smartphones didn&#39;t even exist back then. Texting went at a yet different pace.</p>

<p>That&#39;s why it&#39;s so &#34;buggy&#34; today: the devs did not have the modern use case in mind. Who could&#39;ve known twenty years ago we&#39;d all be carrying our electronic dopamine stimulants in our pockets, maybe also have a slightly bigger portable pleasure/espionage rectangle lying around just because, maybe also pay extra to have espionage built in to our watches and so on and so forth, and reasonably expect all those to synchronise between each other? </p>
<p>Everything that we expect today - chat history, reliable message delivery, multi-device synchronization - is an afterthought in XMPP.</p>

<h2 id="philosophy">How protocols think, or why messages are lost</h2>
<p>If you take any modern chat platform, it will basically be a database. You don&#39;t just send messages to your pal, you two share a chat history together which you two edit. There are some rules to this editing of course, like you can&#39;t spoof message date and so on, but ideally you can edit any message any time, you can delete any message any time, and that will affect both your profiles. Today you expect a messenger to be a database. Such is very much the case with Telegram, and with Matrix the database is also distributed. People call out a <a href="https://lukesmith.xyz/articles/matrix-vs-xmpp"> metadata</a> <a href="https://gist.github.com/maxidorius/5736fd09c9194b7a6dc03b6b8d7220d0">disaster</a> in Matrix, but it functions as it should - it is a database, it stores data.</p>

<p>Xmpp per se, without extensions, does NOT see your chats as a (distributed) database. To the xmpp protocol, in essence, only messages exist that are passed around and forgotten. It <a href="https://xmpp.org/extensions/xep-0160.html">may</a> store your message temporarily if the recipient is not currently online - or it may not. This isn&#39;t even specified by the RFC. </p>

<p>See excerpt from the <a href="https://spec.matrix.org/latest/">Matrix docs</a>:
</p><blockquote>Matrix defines APIs for synchronising extensible JSON objects known as &#34;events&#34; between compatible clients, servers and services.</blockquote>
Ctrl+F &#34;event&#34; on the Matrix page and you find 73 matches, just on that page alone, without following any links. Do the same for <a href="https://xmpp.org/rfcs/rfc3920.html">the core xmpp rfc</a> - what few matches you find will be irrelevant. Xmpp doesn&#39;t think in such terms.
<p>Ctrl+F &#34;synchronis&#34; on that page and you&#39;ll get 8 matches. If you do the same for the xmpp rfc  you&#39;ll get zero matches - xmpp didn&#39;t have this in mind. </p>
<p>Similar to Matrix in this regard is <a href="https://core.telegram.org/api/updates">Telegram</a>. But xmpp wasn&#39;t designed to compete against Telegram. It was designed to compete against IRC if anything. Whenever I try bringing someone over to XMPP we stumble into messages being lost - again, XMPP didn&#39;t account for OSes like android that kill apps at random and do other &#34;optimizations&#34;. Only my most patient friends remain, and while the situation has improved over the years, we still occasionally realize that some message was not delivered. And it&#39;s good when we realize it at all.
</p>
<h2 id="xml">Making XML worse takes talent, or an overview of some XMPP ideas</h2>
<p>Today there&#39;s an ongoing competition between companies at producing as slow and as buggy webpages as possible while employing as many people as possible. But while ReactJS was invented less than a decade ago, <a href="https://theanarchistlibrary.org/library/david-graeber-bullshit-jobs">bullshit jobs</a> in general have existed much longer. In the late nineties there was a competition at using <a href="https://en.wikipedia.org/wiki/XML">a certain already bloated markup format</a> as a serialization format, in as silly and as ugly a way as possible. First time reading <a href="https://en.wikipedia.org/wiki/XML-RPC">XML-RPC examples</a> made me smile - for a moment I thought it was a joke like <a href="https://en.wikipedia.org/wiki/IP_over_Avian_Carriers">IP over Avian Carriers</a>. XMPP is also a child of that competition, or at least greatly inspired by it. And while XMPP&#39;s go at the competition, unlike XML-RPC, doesn&#39;t seem as bad at first sight and won&#39;t make you think it&#39;s a prank, you&#39;ll soon learn that in practice it is actually much more wicked. XML-RPC at least works in complete documents transferred over http, as laughable as those documents may be, so you may use one of the many XML libraries already available for virtually every language, (<a href="https://docs.python.org/3/library/xml.html#xml-vulnerabilities">good chunk of them vulnerable and never fixed</a>).</p>
<p>XMPP <a href="https://en.wikipedia.org/wiki/Streaming_XML">streams XML</a> over tcp. An unitiated person might think XML streaming refers to length-prefixed or record-separator documents over tcp, but hey, remember about the competition?</p>
<p>Instead the entire XMPP stream is one big XML document that is never closed:</p>
<pre>  &lt;stream:stream from=&#34;gmail.com&#34; id=&#34;{ID}&#34; version=&#34;1.0&#34; xmlns:stream=&#34;http://etherx.jabber.org/streams&#34; xmlns=&#34;jabber:client&#34;&gt;
    &lt;stream:features&gt;
      &lt;starttls xmlns=&#34;urn:ietf:params:xml:ns:xmpp-tls&#34;&gt;&lt;required/&gt;&lt;/starttls&gt;
      &lt;mechanisms xmlns=&#34;urn:ietf:params:xml:ns:xmpp-sasl&#34;&gt;
        &lt;mechanism&gt;X-GOOGLE-TOKEN&lt;/mechanism&gt;&lt;mechanism&gt;X-OAUTH2&lt;/mechanism&gt;
      &lt;/mechanisms&gt;
    &lt;/stream:features&gt;
</pre>
<p>At that level, the document goes on forever. No <code>&lt;/stream:stream&gt;</code> is seen ever, except in the unlikely scenario where your client or server disconnects and decides to send this closing tag as well, for no practical reason. An XMPP protocol message is an immediate child element of that document and is referred to as <b>stanza</b>. Doesn&#39;t seem that bad? See <a href="#parsing">parsing</a>.</p>

<h3 id="prefixes">XML namespaces, verbosity and stupidity </h3>
XML has a lovely feature called namespaces which XMPP makes heavy use of, as you can see in the example above. It is a very userful feature: after all, <i>how on earth</i> could you tell what <code>&lt;starttls&gt;</code> alone means, without <code>xmlns=&#34;urn:ietf:params:xml:ns:xmpp-tls&#34;</code>? And there would <i>definitely</i> be name collisions without it! Now, unfortunately for all the advantages this feature provides, there&#39;s a slight disadvantage: wasting bandwidth. This is especially laughable in <a href="https://xmpp.org/extensions/xep-0198.html">XMPP&#39;s attempt at reliability</a>, see:
<pre>&lt;a xmlns=&#39;urn:xmpp:sm:3&#39; h=&#39;1&#39;/&gt;</pre>
<p>There are <b>2 meaningful characters</b> here: &#34;a&#34; (it&#39;s an ack) and &#34;1&#34; (1 stanza ack&#39;d). That <code>xmlns=&#39;urn:xmpp:sm:3&#39;</code> takes <b>19 characters</b>.</p>
<p>To solve this <i>totally unavoidable</i> problem, XML offers us <code>namespace prefixes</code>. In the previous stanza example, note that <code>&lt;stream:features&gt;</code> doesn&#39;t have to specify <code>xmlns=&#34;http://etherx.jabber.org/streams&#34;</code> (<i>ah, that http:// is an especially useful inclusion!</i>) - instead the namespace is associated with the prefix <code>stream</code> in the very top tag once and now whatever element that has this namespace can specify the shorter prefix.</p>
<p>
  Luckily now <code>&lt;a xmlns=&#39;urn:xmpp:sm:3&#39; h=&#39;1&#39;/&gt;</code> can be shortened to <code>&lt;a:a h=&#39;1&#39;/&gt;</code>. Sike! In practice, many xmpp servers and clients will break should you feed them any prefixes other than the strandard <code>xmlns:stream=&#34;http://etherx.jabber.org/streams&#34;</code>. And if you don&#39;t specify this one, they may also break. And if you don&#39;t specify namespaces at all, they&#39;ll break too. So yes, <code>&lt;a xmlns=&#39;urn:xmpp:sm:3&#39; h=&#39;$N&#39;/&gt;</code> will be sent all over again all the time. It also means you get lovely stanzas like
  </p><pre>    &lt;message id=&#39;aeb213&#39; to=&#39;juliet@capulet.lit/chamber&#39;&gt;
      &lt;result xmlns=&#39;urn:xmpp:mam:2&#39; queryid=&#39;f27&#39; id=&#39;28482-98726-73623&#39;&gt;
        &lt;forwarded xmlns=&#39;urn:xmpp:forward:0&#39;&gt;
          &lt;delay xmlns=&#39;urn:xmpp:delay&#39; stamp=&#39;2010-07-10T23:08:25Z&#39;/&gt;
          &lt;message xmlns=&#39;jabber:client&#39; from=&#34;witch@shakespeare.lit&#34; to=&#34;macbeth@shakespeare.lit&#34;&gt;
            &lt;body&gt;Hail to thee&lt;/body&gt;
          &lt;/message&gt;
        &lt;/forwarded&gt;
      &lt;/result&gt;
    &lt;/message&gt;
  </pre>
Where <code>&lt;forwarded&gt;</code> just isn&#39;t enough to convene that the message is forwarded, <code>&lt;delay&gt;</code> just isn&#39;t enough to convene that there&#39;s a delay and so on.


<h3 id="markup">XML not even good for markup?</h3>
How would you implement message markup using XML? Well, like any other markup of course, something like
<pre>&lt;b&gt;Hello&lt;/b&gt; &lt;i&gt;world&lt;/i&gt;!</pre>
Neat right? Something XML is actually good for! <a href="https://xmpp.org/extensions/xep-0071.html">XHTML-IM</a> was however deprecated. What XMPP went for instead is <a href="https://xmpp.org/extensions/xep-0394.html">this</a>:
<pre>&lt;message&gt;
  &lt;body&gt;There is really no reason to worry.&lt;/body&gt;
  &lt;markup xmlns=&#34;urn:xmpp:markup:0&#34;&gt;
    &lt;span start=&#34;9&#34; end=&#34;15&#34;&gt;
      &lt;emphasis/&gt;
    &lt;/span&gt;
  &lt;/markup&gt;
&lt;/message&gt;
</pre>
<p>What... what the hell did I just read?</p>
<img src="data:image/jpeg;base64, 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" alt="Ah sweet, man-made horrors beyond my comprehension.jpg"/>
<p>There is a less terrifying <a href="https://xmpp.org/extensions/xep-0393.html">alternative</a> that again doesn&#39;t use xml to do the actual markup. This one is actually not pointless: after all, if you type it by hand, <SPAN color="green">&gt;quote</SPAN> is much handier than say <SPAN color="green">&lt;q&gt;quote&lt;/q&gt;</SPAN>. So maybe XML just has no place in instant messaging to begin with?</p> 
<h3 id="stanza-ids">XML isn&#39;t a minor issue. Case study: stanza ids</h3>
<p>It can come in quite handy to be able to uniquely identify a message. Like with a hash, you know. But you can&#39;t hash stanzas in XMPP. Well, theoretically you could, <a href="#parsing">but in practice you won&#39;t, and if you do, others won&#39;t</a>. Thus you&#39;ll probably want to assign randomly generated ids to stanzas. Luckily, there&#39;s already an <code>id</code> attribute:
  <code>&lt;message id=&#34;{e.g. a UUID}&#34;&gt;...&lt;/message&gt;</code> But again, XMPP is wary of collisions - and there really can be UUID collisions. So they came up with <a href="https://xmpp.org/extensions/xep-0359.html">an idea</a> of allowing several entities to assign their UUIDs simultaneously:
  </p><pre>&lt;message xmlns=&#39;jabber:client&#39;
         to=&#39;room@muc.example.com&#39;
         type=&#39;groupchat&#39;&gt;
  &lt;body&gt;Typical body text&lt;/body&gt;
  &lt;stanza-id xmlns=&#39;urn:xmpp:sid:0&#39;
             id=&#39;5f3dbc5e-e1d3-4077-a492-693f3769c7ad&#39;
             by=&#39;room@muc.example.com&#39;/&gt;
  &lt;origin-id xmlns=&#39;urn:xmpp:sid:0&#39; id=&#39;de305d54-75b4-431b-adb2-eb6b9e546013&#39;/&gt;
&lt;/message&gt;
  </pre>
  Ah sweet, those repeating namespaces again, that verbosity... Now, in this particular example the ids take up <b>180 characters</b>, while the actual message a human supposedly wrote is <b>18 characters</b>. And this is not unrealistic, and this is their own example. That&#39;s a ten time difference in size between data and its id, and the id is the bigger one. At this point one could as well be just comparing the message itself - it&#39;d actually be more effecient. And what percentage of instant texts exceed 180 characters?

<p>Note that this overhead achieves nothing. Readability and ease of use are actually impeded by XML here no less than bandwidth effeciency is. The problem (inability to hash) is created by overdosing on XML in the first place.</p>
<h2 id="implementing">A half-assed attempt at implementing </h2>
Actual usability is not a goal, of course. 
<h3 id="parsing">Parsing it</h3>
<p>Now the question comes up, how do you parse <a href="#xml">this</a>? There most probably are ready made solutions for parsing xml one &#34;stanza&#34; at a time, but this (ab)use-case is so rare it&#39;s unlikely that you&#39;ll find a library that is available for your particular language, has been updated in the last decade, and also isn&#39;t tightly-coupled to an existing XMPP client.</p>
<ol>
  <li>
    You might think you can just modify an existing XML library to do that. But XML libraries are big. <a href="https://gitlab.gnome.org/GNOME/libxml2.git">Libxml2</a> features about almost 43,0000 SLOC. Good luck digging into that code, it might take more time than writing the rest of the XMPP client. There are <a href="https://github.com/michaelrsweet/mxml">smaller</a> xml libs, but chances are they won&#39;t support even namespaces. Not to mention language bindings.
  </li>
  <li>
    You might think that because <a href="https://en.wikipedia.org/wiki/Simple_API_for_XML">SAX</a> is available for virtually every language, parsing XML in chunks should be handier than it seems. No, it&#39;s not. What you&#39;d end up doing is building, in an awkward way, an object from every stanza - you know, like what you&#39;d readily get from an actual <b>serialization</b> format. Some <a href="https://github.com/horazont/aioxmpp/blob/devel/aioxmpp/xso/model.py">clients</a> actually seem to do just that. Maybe it has some merit to it, but this is definitely not the shortest path. Classes upon classes, metaclasses, policies and handlers. An enterprise dev&#39;s wet dream, just to get some coherently structured data.
  </li>
  <li>You might think you can just write a mini tokenizer to break XML into stanzas. At least one <a href="https://github.com/younix/sj">client</a> does just that. XML however isn&#39;t that simple. You can&#39;t always just rip out a child from a parent and still get valid xml, like you could with e.g. JSON. See the <a href="#prefixes">paragraph on ns prefixes</a>.
  </li>
  <li>
    You might think &#34;screw this, I&#39;ll just write my own XML library, a very small one&#34;. <a href="https://github.com/dino/dino/blob/master/xmpp-vala/src/core/stanza_node.vala">More</a> clients <a href="https://github.com/gajim/python-nbxmpp/blob/master/nbxmpp/simplexml.py">actually</a> do <a href="https://github.com/strophe/libstrophe/blob/master/src/stanza.c">this</a> than you might expect.
    <p>Of course they don&#39;t reimplement the actual parsing - this isn&#39;t <a href="https://en.wikipedia.org/wiki/Bencode">bencode</a> where you could write a complete parser in a couple of hours just for fun, and besides there&#39;s no need to, since libs like expat are available in virtually every language, complete with a ton of features you won&#39;t need, <a href="https://www.cvedetails.com/vulnerability-list/vendor_id-16735/Libexpat-Project.html">a history of some vulnerabilities </a> or insane defaults to the point where Gajim still <a href="https://github.com/gajim/python-nbxmpp/blob/master/nbxmpp/simplexml.py">tells</a> Expat explicitly not to use DTDs to not leak IP (although this in particular should no longer be necessary). </p>
    <p>What they do reimplement is DOM. Problem is, XML by itself doesn&#39;t map nicely into native language structures like lists or dicts or even bools. How do you find if the server requires starttls from the mess below? 
</p><pre>    &lt;stream:features&gt;
      &lt;starttls xmlns=&#34;urn:ietf:params:xml:ns:xmpp-tls&#34;&gt;&lt;required/&gt;&lt;/starttls&gt;
      &lt;mechanisms xmlns=&#34;urn:ietf:params:xml:ns:xmpp-sasl&#34;&gt;
        &lt;mechanism&gt;X-GOOGLE-TOKEN&lt;/mechanism&gt;&lt;mechanism&gt;X-OAUTH2&lt;/mechanism&gt;
      &lt;/mechanisms&gt;
    &lt;/stream:features&gt;
</pre>
You could use xpath: <code>boolean(/tls:starttls/tls:required)</code>. Oh yeah, xpath, basically yet another language. Do you want to spend time implementing it? If you don&#39;t... you&#39;re still going to come up with and create helper functions to e.g. find nodes by name, etc. Or you could manually loop over the DOM every time. Either way that&#39;s still not a 1 hour project.
    
  </li>
  <li>
    You might think you can hook up to SAX/expat and build a string with a proper xml document for each stanza. Well, we&#39;ll do that. Luckily, <b>generating</b> XML isn&#39;t that hard (though harder than may seem if you want to do it correctly, particularly namespaces), and with this approach you can also make the client accept any ns prefixes. Generating xml only to parse it again may not be the most effecient approach, but hey, streamed XML isn&#39;t the most effecient or sane format to begin with. 
  </li>
</ol>

<p>For this brief note&#39;s purposes we&#39;ll go with a mixture of 3rd and 5th options: we&#39;ll use expat, but we&#39;ll tell it to ignore namespaces, because we&#39;re lazy. It won&#39;t be 100% correct xml and we&#39;ll need a dom parser that can ignore namespaces as well - luckily, tdom can do that. And yes, we too will break when encountering non-standard ns prefixes.</p> 
<p>The wicked logic will boil down to this:</p>
<pre>    ...
    <b><SPAN color="#ca14ca">method</SPAN></b> OnElemStart {tag attrs} {
        <b><SPAN color="#3a6797">append</SPAN></b> Stanza <SPAN color="#7d1a1a">&#34;&lt;<SPAN color="#1b1baa">$</SPAN>tag <SPAN color="#1b1baa">[</SPAN>join <SPAN color="#1b1baa">[</SPAN>lmap <SPAN color="#1b1baa">{</SPAN>k v<SPAN color="#1b1baa">}</SPAN> <SPAN color="#1b1baa">$</SPAN>attrs <SPAN color="#1b1baa">{</SPAN>set - <SPAN color="#1b1baa">$</SPAN>k=&#39;<SPAN color="#1b1baa">[</SPAN>xesc <SPAN color="#1b1baa">$</SPAN>v<SPAN color="#1b1baa">]</SPAN>&#39;<SPAN color="#1b1baa">}]]</SPAN>&gt;&#34;</SPAN>
        <b><SPAN color="#3a6797">if</SPAN></b> {<SPAN color="#1b1baa">$Depth</SPAN>==0} {
            <b><SPAN color="#3a6797">lappend</SPAN></b> Queue <SPAN color="#1b1baa">$Stanza</SPAN>
            <b><SPAN color="#3a6797">set</SPAN></b> Stanza {}
        }
        <b><SPAN color="#3a6797">incr</SPAN></b> Depth
    }
    <b><SPAN color="#ca14ca">method</SPAN></b> OnElemEnd tag {
        <b><SPAN color="#3a6797">append</SPAN></b> Stanza <!--<font color=#1b1baa-->$tag&gt;
        <b><SPAN color="#3a6797">incr</SPAN></b> Depth -1
        <b><SPAN color="#3a6797">if</SPAN></b> {<SPAN color="#1b1baa">$Depth</SPAN>==1} {
            <b><SPAN color="#3a6797">lappend</SPAN></b> Queue <SPAN color="#1b1baa">$Stanza</SPAN>
            <b><SPAN color="#3a6797">set</SPAN></b> Stanza {}
        }
    }
    <b><SPAN color="#ca14ca">method</SPAN></b> OnCdata cdata {
        <b><SPAN color="#3a6797">append</SPAN></b> Stanza [xesc <SPAN color="#1b1baa">$cdata</SPAN>]
    }
    ...
</pre>

<h3 id="step1">Step one: starttls, restart stream</h3>
<p>XMPP uses port 5222 and is by default not encrypted. Just picking a standard port for encrypted XMPP, like it is done with HTTP (80 vs 443) would be too simple for the XML mindset - there are <a href="https://xmpp.org/extensions/xep-0368.html">SRV records</a> for specifying a port, but there is no standard port. There&#39;s STARTTLS as well and it is described in the <a href="https://xmpp.org/rfcs/rfc3920.html">RFC</a> itself, so that&#39;s what we&#39;ll go for, to really get a taste of the XMPP core.</p>
<p>The way it&#39;s supposed to go is:</p>
  <SPAN color="grey">&lt;!--You send this unholy mess to the server over plaintext:--&gt;</SPAN></div>
  </body>
</html>
