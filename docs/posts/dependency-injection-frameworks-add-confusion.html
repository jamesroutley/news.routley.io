<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://rednafi.com/go/di_frameworks_bleh/">Original</a>
    <h1>Dependency injection frameworks add confusion</h1>
    
    <div id="readability-page-1" class="page"><div><p>When working with Go in an <a href="https://peter.bourgon.org/go-for-industrial-programming/">industrial</a> context, I feel like dependency injection (DI) often
gets a bad rep because of <em>DI frameworks</em>. But DI as a technique is quite useful. It just
tends to get explained with too many OO jargons and triggers PTSD among those who came to Go
to escape GoF theology.</p><blockquote><p><em>Dependency Injection is a 25-dollar term for a 5-cent concept.</em></p><p><em>— James Shore</em></p></blockquote><p>DI basically means <em>passing values into a constructor instead of creating them inside it</em>.
That’s really it. Observe:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>server</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>db</span> <span>DB</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// NewServer constructs a server instance</span>
</span></span><span><span><span>func</span> <span>NewServer</span><span>()</span> <span>*</span><span>server</span> <span>{</span>
</span></span><span><span>    <span>db</span> <span>:=</span> <span>DB</span><span>{}</span>            <span>// The dependency is created here</span>
</span></span><span><span>    <span>return</span> <span>&amp;</span><span>server</span><span>{</span><span>db</span><span>:</span> <span>db</span><span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Here, <code>NewServer</code> creates its own <code>DB</code>. Instead, to inject the dependency, build <code>DB</code>
elsewhere and pass it in as a constructor parameter:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>NewServer</span><span>(</span><span>db</span> <span>DB</span><span>)</span> <span>*</span><span>server</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>&amp;</span><span>server</span><span>{</span><span>db</span><span>:</span> <span>db</span><span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Now the constructor no longer decides how a database is built; it simply <em>receives</em> one.</p><p>In Go, DI is often done using interfaces. You collate the behavior you care about in an
interface, and then provide different concrete implementations for different contexts. In
production, you pass a real implementation of <code>DB</code>. In unit tests, you pass a fake
implementation that behaves the same way from the caller’s perspective but avoids real
database calls.</p><p>Here’s how that looks:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// behaviour we care about</span>
</span></span><span><span><span>type</span> <span>DB</span> <span>interface</span> <span>{</span>
</span></span><span><span>    <span>Get</span><span>(</span><span>id</span> <span>string</span><span>)</span> <span>(</span><span>string</span><span>,</span> <span>error</span><span>)</span>
</span></span><span><span>    <span>Save</span><span>(</span><span>id</span><span>,</span> <span>value</span> <span>string</span><span>)</span> <span>error</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>server</span> <span>struct</span><span>{</span> <span>db</span> <span>DB</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>// NewServer accepts a concrete implementation of the DB interface in runtime</span>
</span></span><span><span><span>// and passes it to the server struct.</span>
</span></span><span><span><span>func</span> <span>NewServer</span><span>(</span><span>db</span> <span>DB</span><span>)</span> <span>*</span><span>server</span> <span>{</span> <span>return</span> <span>&amp;</span><span>server</span><span>{</span><span>db</span><span>:</span> <span>db</span><span>}</span> <span>}</span>
</span></span></code></pre></div><p>A real implementation of <code>DB</code> might look like this:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>RealDB</span> <span>struct</span><span>{</span> <span>url</span> <span>string</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>NewDB</span><span>(</span><span>url</span> <span>string</span><span>)</span> <span>*</span><span>RealDB</span> <span>{</span> <span>return</span> <span>&amp;</span><span>RealDB</span><span>{</span><span>url</span><span>:</span> <span>url</span><span>}</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>r</span> <span>*</span><span>RealDB</span><span>)</span> <span>Get</span><span>(</span><span>id</span> <span>string</span><span>)</span> <span>(</span><span>string</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// pretend we hit Postgres</span>
</span></span><span><span>    <span>return</span> <span>&#34;real value&#34;</span><span>,</span> <span>nil</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>func</span> <span>(</span><span>r</span> <span>*</span><span>RealDB</span><span>)</span> <span>Save</span><span>(</span><span>id</span><span>,</span> <span>value</span> <span>string</span><span>)</span> <span>error</span> <span>{</span> <span>return</span> <span>nil</span> <span>}</span>
</span></span></code></pre></div><p>And a fake implementation for unit tests might be:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>FakeDB</span> <span>struct</span><span>{</span> <span>data</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>string</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>NewFake</span><span>()</span> <span>*</span><span>FakeDB</span> <span>{</span> <span>return</span> <span>&amp;</span><span>FakeDB</span><span>{</span><span>data</span><span>:</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>string</span><span>{}}</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>f</span> <span>*</span><span>FakeDB</span><span>)</span> <span>Get</span><span>(</span><span>id</span> <span>string</span><span>)</span> <span>(</span><span>string</span><span>,</span> <span>error</span><span>)</span> <span>{</span> <span>return</span> <span>f</span><span>.</span><span>data</span><span>[</span><span>id</span><span>],</span> <span>nil</span> <span>}</span>
</span></span><span><span><span>func</span> <span>(</span><span>f</span> <span>*</span><span>FakeDB</span><span>)</span> <span>Save</span><span>(</span><span>id</span><span>,</span> <span>value</span> <span>string</span><span>)</span> <span>error</span>   <span>{</span> <span>f</span><span>.</span><span>data</span><span>[</span><span>id</span><span>]</span> <span>=</span> <span>value</span><span>;</span> <span>return</span> <span>nil</span> <span>}</span>
</span></span></code></pre></div><p>Use the fake in unit tests like so:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>TestServerGet</span><span>(</span><span>t</span> <span>*</span><span>testing</span><span>.</span><span>T</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>fake</span> <span>:=</span> <span>NewFake</span><span>()</span>
</span></span><span><span>    <span>_</span>    <span>=</span> <span>fake</span><span>.</span><span>Save</span><span>(</span><span>&#34;42&#34;</span><span>,</span> <span>&#34;fake&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>srv</span> <span>:=</span> <span>NewServer</span><span>(</span><span>fake</span><span>)</span>
</span></span><span><span>    <span>val</span><span>,</span> <span>_</span> <span>:=</span> <span>srv</span><span>.</span><span>db</span><span>.</span><span>Get</span><span>(</span><span>&#34;42&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>val</span> <span>!=</span> <span>&#34;fake&#34;</span> <span>{</span>
</span></span><span><span>        <span>t</span><span>.</span><span>Fatalf</span><span>(</span><span>&#34;want fake, got %s&#34;</span><span>,</span> <span>val</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The compiler guarantees both <code>RealDB</code> and <code>FakeDB</code> satisfy <code>DB</code>, and during tests, we can
swap out the implementations without much ceremony.</p><h2 id="why-frameworks-turn-mild-annoyance-into-actual-pain">Why frameworks turn mild annoyance into actual pain</h2><p>Once <code>NewServer</code> grows half a dozen dependencies, wiring them by hand can feel noisy. That’s
when a DI framework starts looking tempting.</p><p>With Uber’s <a href="https://github.com/uber-go/dig">dig</a>, you register each constructor as a <em>provider</em>. <code>Provide</code> takes a
function, uses reflection to inspect its parameters and return type, and adds it as a node
in an internal dependency graph. Nothing is executed yet. Things only run when you call
<code>.Invoke()</code> on the container.</p><p>But that reflection-driven magic is also where the pain starts. As your graph grows, it gets
harder to tell which constructor feeds which one. Some constructor take one parameter, some
take three. There’s no single place you can glance at to understand the wiring. It’s all
figured out inside the container at runtime.</p><blockquote><p><em>Let the container figure it out!</em></p><p><em>— every DI framework ever</em></p></blockquote><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>BuildContainer</span><span>()</span> <span>*</span><span>dig</span><span>.</span><span>Container</span> <span>{</span>
</span></span><span><span>    <span>c</span> <span>:=</span> <span>dig</span><span>.</span><span>New</span><span>()</span>
</span></span><span><span>    <span>// Each Provide call teaches dig about one node in the graph.</span>
</span></span><span><span>    <span>c</span><span>.</span><span>Provide</span><span>(</span><span>NewConfig</span><span>)</span>     <span>// produces *Config</span>
</span></span><span><span>    <span>c</span><span>.</span><span>Provide</span><span>(</span><span>NewDB</span><span>)</span>         <span>// wants *Config, produces *DB</span>
</span></span><span><span>    <span>c</span><span>.</span><span>Provide</span><span>(</span><span>NewRepo</span><span>)</span>       <span>// wants *DB, produces *Repo</span>
</span></span><span><span>    <span>c</span><span>.</span><span>Provide</span><span>(</span><span>NewFlagClient</span><span>)</span> <span>// produces *FlagClient</span>
</span></span><span><span>    <span>c</span><span>.</span><span>Provide</span><span>(</span><span>NewService</span><span>)</span>    <span>// wants *Repo, *FlagClient, produces *Service</span>
</span></span><span><span>    <span>c</span><span>.</span><span>Provide</span><span>(</span><span>NewServer</span><span>)</span>     <span>// wants *Service, produces *server</span>
</span></span><span><span>    <span>return</span> <span>c</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>// Invoke kicks off the whole graph. dig topologically sorts, calls each</span>
</span></span><span><span>    <span>// constructor, and finally hands *server to your callback.</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>:=</span> <span>BuildContainer</span><span>().</span><span>Invoke</span><span>(</span>
</span></span><span><span>    	<span>func</span><span>(</span><span>s</span> <span>*</span><span>server</span><span>)</span> <span>{</span> <span>s</span><span>.</span><span>Run</span><span>()</span> <span>});</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>    	<span>panic</span><span>(</span><span>err</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Now try commenting out <code>NewFlagClient</code>. The code still <a href="https://go.dev/play/p/Vhimup7ukLo">compiles</a>. There’s no error until
runtime, when dig fails to construct <code>NewService</code> due to a missing dependency. And the error
message you get?</p><div><pre tabindex="0"><code data-lang="txt"><span><span>dig invoke failed: could not build arguments for function
</span></span><span><span>        main.main.func1 (prog.go:87)
</span></span><span><span>    : failed to build *main.Server
</span></span><span><span>    : could not build arguments for function main.NewServer (prog.go:65)
</span></span><span><span>    : failed to build *main.Service: missing dependencies for function
</span></span><span><span>        main.NewService (prog.go:55)
</span></span><span><span>    : missing type: *main.FlagClient
</span></span></code></pre></div><p>That’s five stack frames deep, far from where the problem started. Now you’re digging
through dig’s internals to reconstruct the graph in your head.</p><p>Google’s <a href="https://github.com/google/wire">wire</a> takes a different approach: it shifts the graph-building to <em>code
generation</em>. You collect your constructors in a <code>wire.NewSet</code>, call <code>wire.Build</code>, and the
generator writes a <code>wire_gen.go</code> that wires everything up explicitly.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> <span>serverSet</span> <span>=</span> <span>wire</span><span>.</span><span>NewSet</span><span>(</span>
</span></span><span><span>    <span>NewConfig</span><span>,</span>
</span></span><span><span>    <span>NewDB</span><span>,</span>
</span></span><span><span>    <span>NewRepo</span><span>,</span>
</span></span><span><span>    <span>NewFlagClient</span><span>,</span>   <span>// comment this line out to see Wire complain at compile time</span>
</span></span><span><span>    <span>NewService</span><span>,</span>
</span></span><span><span>    <span>NewServer</span><span>,</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>InitializeServer</span><span>()</span> <span>(</span><span>*</span><span>server</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>wire</span><span>.</span><span>Build</span><span>(</span><span>serverSet</span><span>)</span>
</span></span><span><span>    <span>return</span> <span>nil</span><span>,</span> <span>nil</span> <span>// replaced by generated code</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Comment out <code>NewFlagClient</code> and Wire fails earlier—during generation:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>wire: ../../service/wire.go:13:2: cannot find dependency for *flags.Client
</span></span></code></pre></div><p>It’s better than dig’s runtime panic, but still comes with its own headaches:</p><ul><li>You need to remember to run <code>go generate ./...</code> whenever constructor signatures change.</li><li>When something breaks, you’re stuck reading through hundreds of lines of autogenerated
glue to trace the issue.</li><li>You have to teach every teammate Wire’s DSL—<code>wire.NewSet</code>, <code>wire.Build</code>, build tags, and
sentinel rules. And if you ever switch to something different like dig, you’ll need to
learn a completely different set of concepts: <code>Provide</code>, <code>Invoke</code>, scopes, named values,
etc.</li></ul><p>While DI frameworks tend to use vocabularies like <em>provider</em> or <em>container</em> to give you an
essense of familiarity, they still reinvent the API surface every time. Switching between
them means relearning a new mental model.</p><p>So the promise of “just register your providers and forget about wiring” ends up trading
clear, compile-time control for either reflection or hidden generator logic—and yet another
abstraction layer you have to debug.</p><h2 id="the-boring-alternative-keep-wiring-explicit">The boring alternative: keep wiring explicit</h2><p>In Go, you can just wire your own dependencies manually. Like this:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>cfg</span> <span>:=</span> <span>NewConfig</span><span>()</span>
</span></span><span><span>
</span></span><span><span>    <span>db</span>    <span>:=</span> <span>NewDB</span><span>(</span><span>cfg</span><span>.</span><span>DSN</span><span>)</span>
</span></span><span><span>    <span>repo</span>  <span>:=</span> <span>NewRepo</span><span>(</span><span>db</span><span>)</span>
</span></span><span><span>    <span>flags</span> <span>:=</span> <span>NewFlagClient</span><span>(</span><span>cfg</span><span>.</span><span>FlagURL</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>svc</span> <span>:=</span> <span>NewService</span><span>(</span><span>repo</span><span>,</span> <span>flags</span><span>,</span> <span>cfg</span><span>.</span><span>APIKey</span><span>)</span>
</span></span><span><span>    <span>srv</span> <span>:=</span> <span>NewServer</span><span>(</span><span>svc</span><span>,</span> <span>cfg</span><span>.</span><span>ListenAddr</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>srv</span><span>.</span><span>Run</span><span>()</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Longer? Yes. But:</p><ul><li><p>The call order is the dependency graph.</p></li><li><p>Errors are handled right where they happen.</p></li><li><p>If a constructor changes, the compiler points straight at every broken call:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>./main.go:33:39: not enough arguments in call to NewService
</span></span><span><span>    have (*Repo, *FlagClient)
</span></span><span><span>    want (*Repo, *FlagClient, string)
</span></span></code></pre></div></li></ul><p>No reflection, no generated code, no global state. Go type-checks the dependency graph early
and loudly, exactly how it should be. And also, it doesn’t confuse your LSP, so your IDE
keeps on being useful.</p><p>If <code>main()</code> really grows unwieldy, split <em>your</em> code:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>buildInfra</span><span>(</span><span>cfg</span> <span>*</span><span>Config</span><span>)</span> <span>(</span><span>*</span><span>DB</span><span>,</span> <span>*</span><span>FlagClient</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// ...</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>buildService</span><span>(</span><span>cfg</span> <span>*</span><span>Config</span><span>)</span> <span>(</span><span>*</span><span>Service</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>db</span><span>,</span> <span>flags</span><span>,</span> <span>err</span> <span>:=</span> <span>buildInfra</span><span>(</span><span>cfg</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span> <span>return</span> <span>nil</span><span>,</span> <span>err</span> <span>}</span>
</span></span><span><span>    <span>return</span> <span>NewService</span><span>(</span><span>NewRepo</span><span>(</span><span>db</span><span>),</span> <span>flags</span><span>,</span> <span>cfg</span><span>.</span><span>APIKey</span><span>),</span> <span>nil</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>cfg</span> <span>:=</span> <span>NewConfig</span><span>()</span>
</span></span><span><span>    <span>svc</span><span>,</span> <span>err</span> <span>:=</span> <span>buildService</span><span>(</span><span>cfg</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span> <span>log</span><span>.</span><span>Fatal</span><span>(</span><span>err</span><span>)</span> <span>}</span>
</span></span><span><span>    <span>NewServer</span><span>(</span><span>svc</span><span>,</span> <span>cfg</span><span>.</span><span>ListenAddr</span><span>).</span><span>Run</span><span>()</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Each helper is a regular function that anyone can skim without reading a framework manual.
Also, you usually build all of your dependency in one place and it’s really not that big of
a deal if your builder function takes in 20 parameters and builds all the dependencies. Just
put each function parameter on their own line and use gofumpt to format the code to make it
readable.</p><h2 id="reflection-works-elsewhere-so-why-not-here">Reflection works elsewhere, so why not here?</h2><p>Other languages lean on containers because often times constructors cannot be overloaded and
compile times hurt. Go already gives you:</p><ul><li>First-class functions so constructors are plain values.</li><li>Interfaces so implementations swap cleanly in tests.</li><li>Fast compilation so feedback loops stay tight.</li></ul><p>A DI framework often fixes problems Go already solved and trades away readability to do it.</p><blockquote><p><em>The most magical thing about Go is how little magic it allows.</em></p><p><em>— Some Gopher on Reddit</em></p></blockquote><h2 id="you-might-still-want-a-framework">You might still want a framework</h2><p>It’s tempting to make a blanket statement saying that you should <strong>never</strong> pick up a DI
framework, but context matters here.</p><p>I was watching Uber’s <a href="https://www.youtube.com/watch?v=nLskCRJOdxM&amp;t">talk</a> on how they use Go and how their DI framework <a href="https://github.com/uber-go/fx">Fx</a> (which uses
dig underneath) allows them to achieve consistency at scale. If you’re Uber and have all the
observability tools in place to get around the downsides, then you’ll know.</p><p>Also, if you’re working in a codebase that’s already leveraging a framework and it works
well, then it doesn’t make sense to refactor it without any incentives.</p><p>Or, you’re writing one of those languages where using a DI framework is the norm, and
you’ll be called a weirdo if you try to reinvent the wheel there.</p><p>However, in my experience, even in organizations that maintain a substantial number of Go
repos, DI frameworks add more confusion than they’re worth. If your experience is otherwise,
I’d love to be proven wrong.</p><hr/><p>The post got a fair bit of discussion going around the web. You might find it interesting.</p><ul><li><a href="https://news.ycombinator.com/item?id=44086235">hackernews</a></li><li><a href="https://www.reddit.com/r/golang/comments/1kv0y1u/you_probably_dont_need_a_di_framework/">r/golang</a></li><li><a href="https://www.reddit.com/r/ExperiencedDevs/comments/1kv0y3n/you_probably_dont_need_a_di_framework/">r/experienceddevs</a></li><li><a href="https://www.reddit.com/r/programming/comments/1kv0y2l/you_probably_dont_need_a_di_framework/">r/programming</a></li></ul><p>~~~</p><h2>Recent posts</h2><ul><li><a href="http://rednafi.com/go/prevent_struct_copies/">Preventing accidental struct copies in Go</a></li><li><a href="http://rednafi.com/go/tool_directive/">Go 1.24&#39;s &#34;tool&#34; directive</a></li><li><a href="http://rednafi.com/go/capture_console_output/">Capturing console output in Go tests</a></li><li><a href="http://rednafi.com/go/deferred_teardown_closure/">Deferred teardown closure in Go testing</a></li><li><a href="http://rednafi.com/go/sort_slice/">Three flavors of sorting Go slices</a></li><li><a href="http://rednafi.com/go/nil_interface_comparison/">Nil comparisons and Go interface</a></li><li><a href="http://rednafi.com/go/middleware_vs_delegation/">Stacked middleware vs embedded delegation in Go</a></li><li><a href="http://rednafi.com/go/io_reader_signature/">Why does Go&#39;s io.Reader have such a weird signature?</a></li><li><a href="http://rednafi.com/go/slice_gotchas/">Go slice gotchas</a></li><li><a href="http://rednafi.com/zephyr/domain_knowledge_dilemma/">The domain knowledge dilemma</a></li></ul></div></div>
  </body>
</html>
