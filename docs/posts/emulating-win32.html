<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neugierig.org/software/blog/2023/01/emulating-win32.html">Original</a>
    <h1>Emulating Win32</h1>
    
    <div id="readability-page-1" class="page"><div>

<div id="post-heading">
  <h2><a href="">Emulating win32</a></h2>
  <p>January 21, 2023</p>
</div>

<p>The most common question about
<a href="https://neugierig.org/software/blog/2022/10/retrowin32.html">retrowin32</a>, my
Windows emulator — after &#34;why even do this?&#34; — is about how it actually works.
This is the kind of thing that now feels obvious to me but which was a great
mystery before I understood it, so here I hope to present it in a way that will
make it obvious to you too.</p>
<h2>Emulating the Windows API</h2>
<p>To start with, imagine you&#39;re on an x86 machine that is running some OS other
than Windows and you want to run a Windows program somehow. The main observation
of Wine (which, as the acronym expands, is <em>not</em> an emulator) is that a Windows
executable ultimately contains a bunch of x86 instructions and your x86 is
already capable of executing them directly. To execute a Windows <code>.exe</code> then you
just load it into memory (which requires unpacking the <code>.exe</code> file format) and
tell the processor to jump to the first instruction.</p>
<p>The only remaining piece — a massive one — is how this exe interacts with the
operating system, to e.g. open files or put something on the screen. The
mechanism here differs a lot between operating systems but ultimately depends on
the kernel&#39;s interface. In the specific case of Windows the kernel interface is
pretty fiddly (the
<a href="https://j00ru.vexillium.org/syscalls/nt/64/">syscall ids vary between Windows releases</a>)
and the stable API boundary is generally understood to be in DLLs with names you
might recognize like <code>kernel32.dll</code>. (This is in direct contrast to Linux, which
famously <a href="https://lkml.org/lkml/2012/12/23/75">cares a lot</a> about having a very
stable interface at the kernel boundary instead.)</p>
<p>How this works is the <code>.exe</code> file format can declare &#34;hey, I will need to call
<code>kernel32.dll</code>&#39;s function named <code>WriteFile()</code>&#34;, and when the <code>.exe</code> is loaded
the OS will put the appropriate code at the appropriate place such that this
function call works. On Windows the kernel32 function then calls through to the
appropriate kernel interface. For our goal of running on a non-Windows OS this
is convenient because all we need to do is provide our own implementations of
those functions without even thinking about the kernel interface.</p>
<p>And that is just what Wine does: it loads <code>.exe</code> files and it provides
implementations of all the Windows DLLs. It is of course significantly more
complicated than that in practice, and Wine has seen programmer-centuries of
effort to provide all the nooks and crannies of the Windows interface, which
itself has seen decades of <a href="https://www.hyrumslaw.com/">Hyrum&#39;s law</a>.</p>
<p>For one random example of just how deep that rabbit hole can go, check out
<a href="https://github.com/wine-mirror/wine/blob/a8c1d5c108fc57e4d78e9db126f395c89083a83d/dlls/ntdll/unix/signal_x86_64.c#L2647">this snippet</a>
found in a blob of x86 assembly in Wine&#39;s syscall dispatcher:</p>
<pre><code>/* Legends of Runeterra hooks the first system call return instruction, and
 * depends on us returning to it. Adjust the return address accordingly. */
&#34;subq $0xb,0x70(%rcx)\n\t&#34;
</code></pre>
<p>The great <a href="https://werat.dev/blog/how-wine-works-101/">how Wine works</a> goes much
depeer in detail on Wine. The above intentionally elides a bunch of details.</p>
<p>(By the way, one neat application of Wine — entirely unrelated to this post&#39;s
goal of running a random exe — is that if you have the source code of a Windows
program you can
<a href="https://wiki.winehq.org/Winelib_User%27s_Guide">compile it against Wine&#39;s implementation of the Windows API</a>
and get a native executable out the other side.)</p>
<h2>Emulating x86</h2>
<p>The above is all well and good if you are on x86 hardware, but what if you&#39;re on
some other archicture, like these fancy new ARM-based Macs? You must then
emulate the x86 instruction set, in just the same way a Game Boy emulator might
emulate the Game Boy&#39;s CPU.</p>
<p>That is no small feat! Apple
<a href="https://twitter.com/ErrataRob/status/1331735383193903104">reportedly even
added special x86 support</a>
to their ARM processors to make emulation faster. But once you have that in
place, there are two broad approaches you can take for the Windows part of it.</p>
<p>One is to additionally emulate all the hardware found on an x86 machine, such as
the BIOS and disk interfaces, such that you can install the actual Windows OS
into your emulator. This is the approach that <a href="https://www.qemu.org/">qemu</a>
takes. On the web, <a href="https://copy.sh/v86/">v86</a> can run many different OSes,
including Windows.</p>
<p>This approach is great because it runs a real actual copy of Windows and will
consequently run Windows programs correctly. The main downside of this approach
is that it requires you to install a real actual copy of Windows, which also
requires a bunch of disk space and time to boot that Windows before it can do
anything.</p>
<p>The second approach is to instead emulate just the x86 instruction set, and use
Wine as described above as an implementation of the massive Windows API backing
onto something more tractable to then emulate, such as the Linux kernel API.
After publishing retrowin32 I learned about
<a href="http://www.boxedwine.org/">BoxedWine</a> which does this on the web and which can
execute many sophisticated Windows programs.</p>
<h2>retrowin32&#39;s take</h2>
<p>My retrowin32 project is mostly about exploring whatever I find interesting.
What that currently means is that I have a not very good x86 emulator, a not
very good win32 implementation, and some minor explorations of related tasks.</p>
<p>In all, I think if you&#39;re looking to actually run a Windows program on the web
then BoxedWine and v86 likely cover it. But if you&#39;re curious about my side
quests I plan to write a subsequent post about retrowin32 status in particular.</p>

</div></div>
  </body>
</html>
