<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.forrestthewoods.com/blog/failing-to-learn-zig-via-advent-of-code/">Original</a>
    <h1>Failing to Learn Zig via Advent of Code</h1>
    
    <div id="readability-page-1" class="page"><div>

            <p>This isn&#39;t the blog post I intended to write.</p>
            <p>
                In 2018 I wrote
                <a href="https://www.forrestthewoods.com/blog/learning-rust-via-advent-of-code/">Learning Rust via
                    Advent of Code</a>. This was supposed to be the exciting sequel where I learn
                <a href="https://ziglang.org/">Zig</a>. Unfortunately I failed. Zig sparked
                more frustration than joy and I fizzled out after 6 days.
            </p>
            <p>
                My biggest failure was a poor decision to solve all Advent of Code puzzles in
                both Rust and Zig. Unfortunately I lost motivation to reimplement
                them in Zig. Some mild office competition didn&#39;t help. In hindsight I should have
                gritted my teeth and focused exclusively on Zig. Lesson learned.
            </p>
            <p>
                I kept pretty good notes on my initial Zig experience. Rather than let it go
                to waste I want to share it here.
            </p>
            <p>
                GitHub:
                <a href="https://github.com/forrestthewoods/aoc2021/blob/master/zig/src/main.zig">Link</a>
            </p>

            

            
            <p>To help paint context here&#39;s a little bit about me.</p>
            <p>
                I&#39;m a game/VR developer with 15 years work experience. Most of that time
                has been spent in C++ and C# (Unity). I&#39;ve done a mix of gameplay and
                systems code. I love Rust and
                <a href="https://www.forrestthewoods.com/blog/things-i-like-about-python/">hate Python</a>. I don&#39;t
                know anything about webdev or JavaScript; and intend to keep it
                that way. I probably like C++ more than C, but I try to keep my C++ simple and
                somewhat C-like.
            </p>

            

            
            <p>
                A few months ago I didn&#39;t know really anything about Zig. I knew it
                existed, but not much else.
            </p>
            <p>
                I attended the awesome
                <a href="https://handmade-seattle.com/">Handmade Seattle</a> conference where
                Zig had a very strong presence.
                <a href="https://twitter.com/andy_kelley">Andrew Kelley</a>, Zig&#39;s benevolent
                dictator of life, gave a stellar presentation on
                <a href="https://media.handmade-seattle.com/practical-data-oriented-design/">A Practical Guide to Data
                    Oriented Design</a>. Numerous presentations were for projects built in Zig.
            </p>
            <p>My mental model is:</p>
            <ul>
                <li>Rust is trying to be a better C++</li>
                <li>Zig is trying to be a better C</li>
            </ul>
            <p>
                I don&#39;t know if that&#39;s entirely accurately. I think it&#39;s fair.
            </p>

            

            
            <p>
                I decided to use
                <a href="https://adventofcode.com/2021/about">Advent of Code</a> to help learn
                Zig. I had a great time doing this with Rust back in 2018. Before AoC I did my
                best to read Zig docs. Here are some of the more useful pages I found:
            </p>
            <ul>
                <li><a href="https://ziglearn.org/">Zig Learn</a></li>
                <li>
                    <a href="https://ziglang.org/learn/why_zig_rust_d_cpp/">Why Zig When There is Already C++, D,
                        and
                        Rust?</a>
                </li>
                <li><a href="https://ziglang.org/learn/overview/">In-depth Overview</a></li>
                <li>
                    <a href="https://ziglang.org/documentation/0.9.0/">Language Reference</a>
                </li>
            </ul>
            <p>
                Downloading Zig and compiling Hello World was delightfully simple by following
                the
                <a href="https://ziglang.org/learn/getting-started/">Getting Started</a> page.
            </p>

            

            
            <p>
                I took a lot of notes when solving AoC puzzles. I tried to write down every
                question I had or problem I encountered. It&#39;s a long list.
            </p>
            <p>
                The next few sections contain these notes in semi-raw form. I&#39;ll share my
                takeaways after.
            </p>

            
            <p>
                Immediately confused by <code>anyerror!void</code>. I think <code>!</code> is
                <code>Option</code> / <code>std::optional</code>. So I thought
                <code>!</code> was a prefix, but it&#39;s also a suffix? Very confused. (Note:
                I was wrong. <code>?T</code> is <code>Option&lt;T&gt;</code> and
                <code>E!T</code> is <code>Result&lt;T,E&gt;</code>).
            </p>
            <p>
                Can&#39;t figure out how to print an integer. Can&#39;t find documentation or
                an example in ZigLearn. Needed to search for <code>std.debug.print</code> not
                <code>std.log.info</code> to find the example. Annoying.
            </p>
            <p>
                Building is slow. It takes about ~3 seconds minimum which is frustratingly
                slow when I&#39;m fighting basic syntax errors. I wish there was a fast
                <code>zig check</code>.
            </p>
            <p>
                Compile error messages are mediocre. They&#39;re full of useless information
                and compiler callstacks I don&#39;t care about.
            </p>
            <p>
                Zig reference documentation badly needs examples. Can&#39;t figure out how to
                use <code>std.fmt.parseInt</code>.
            </p>
            <p>
                Catching memory leaks at run-time by default is very cool! Compiler should be
                able to trivially detect not calling <code>nums.deinit()</code> at
                compile-time.
            </p>
            <p>
                Can not figure out how to get the number of items in an
                <code>ArrayList</code>. The
                <a href="https://ziglang.org/documentation/0.8.1/std/#std;ArrayList">documentation</a>
                does not reveal this basic information. The type of <code>items</code> is
                <code>var</code>. That is not helpful.
            </p>
            <p>
                Can&#39;t figure out how to array access an <code>ArrayList</code>. I get a
                compile error of:
                <code>error: array access of non-array type
                &#39;std.array_list.ArrayListAligned(u32,null)&#39;</code>. That sure seems like an array type to me.
            </p>
            <p>
                Need to access <code>myArray.items[idx]</code> instead of
                <code>myArray[idx]</code>. I get it. But very unintuitive and requires
                knowledge of implementation details.
            </p>
            <p>Massive callstack on failed <code>expect</code> is annoying.</p>

            
            <p>
                Can&#39;t figure out how to compare string. Can&#39;t find anything in
                ZigLearn or reference. Googling &#34;zig string compare&#34; is not helpful.
                This is a shockingly hard blocker.
            </p>
            <p>
                Ah hah. There is no such thing as strings. just <code>[]const u8</code>. Need
                to use <code>std.mem.eql</code>.
            </p>
            <p>
                Can&#39;t figure out how to make an <code>ArrayList</code> of tuples. Never
                figured this out. Had to make a helper struct.
            </p>
            <p>
                It&#39;s really weird that I can call <code>myArraylist.push</code> but need
                to loop over <code>for (myArrayList.items)</code>. It feels inconsistent. I
                get it, but it&#39;s super unintuitive. I&#39;ve used many programming
                languages and none behave this way.
            </p>
            <p>
                I can&#39;t actually figure out how to run in release mode.
                <code>zig build run</code> will build and run debug. Eventually figured out
                that <code>zig build -Drelease-safe</code> builds release. The internet told
                me it needed to be run manually. I didn&#39;t figure out until typing this
                blog post I can build and run via <code>zig build -Drelease-safe run</code>.
            </p>
            <p>
                <code>std.mem.tokenize</code> is great. Awesome feature over vanilla C when
                combined with <code>foreach</code>-like <code>for</code> loop.
            </p>
            <p>
                <a href="https://ziglang.org/documentation/master/std/#std;builtin.TypeInfo">Documentation</a>
                for <code>TypeInfo</code> is beyond worthless.
            </p>


            
            <p>
                Should I pass the allocator to every function? Doesn&#39;t seem great. Maybe
                I&#39;m supposed to create a global? Globals are evil and feel bad.
            </p>
            <p>
                How do I print a number in binary? Googling how to do things in Zig has like a
                50% chance of taking you to a
                <a href="https://github.com/ziglang/zig/issues/1358">GitHub issue</a> where
                the feature is being discussed. This happened to me a LOT.
            </p>
            <p>
                How do I get the length of a tokenized line? What does
                <a href="https://ziglang.org/documentation/master/std/#std;mem.tokenize">tokenize</a>
                return? It returns <code>anytype</code>. Cool. Very helpful. Had to compile,
                fail, and see in error spew the type was <code>[]const u8</code>.
            </p>
            <p>Lack of <code>zig-analyzer</code> makes learning hard.</p>
            <p>
                How do I make a lambda / closure / local function? There&#39;s a too complicated
                pattern with numerous issues. There is, of course, a
                <a href="https://github.com/ziglang/zig/issues/229">GitHub issue</a>
                discussing this.
            </p>


            <pre><span>const</span> do_thing <span>=</span> (<span>struct</span> {
    <span>fn</span> call(self<span>:</span> <span>@</span>This(), last_number<span>:</span> <span>u8</span>, tiles<span>:</span> []Tile) <span>?</span>usize {
        _ <span>=</span> self;
        <span>// do stuff</span>
        <span>return</span> num;
        }
    }
{}).call;
</pre>

            <p>
                Bit-shifting is a monumental pain in the ass.
                <code>const mask : usize = @as(usize, 1) &lt;&lt; @truncate(u6, i);</code>. I
                eventually wound up with:
                <code>@truncate(u16, @as(usize, 1) &lt;&lt; @truncate(u6, i));</code>. Blech.
            </p>
            <p>
                The following line doesn&#39;t compile:
                <code>const mask = 1 &lt;&lt; (num_bits - 1);</code>. Blech.
            </p>
            <p>Casting seems too complex too: <code>@as(type, value)</code>. Blech.</p>
            <p>Can&#39;t <code>xor</code> bools!? Blech.</p>
            <p>
                Can&#39;t redirect output of <code>zig build run</code>. The following
                doesn&#39;t work: <code>zig build run &gt; c:/temp/out.txt</code>. :(
            </p>

            

            <p>Parsing <code>i32</code> is delightful (once I figured it out).</p>
            <p><code>tokenize</code> is delightful.</p>
            <p><code>try</code> syntax is nice and clean.</p>
            <p>
                Callstack on zig compiler error is too long and not helpful. Have to scroll
                way up to find actual error.
            </p>
            <p>
                <code>zig fmt src/main.zig</code> is nice. Wish it automatically ran on all
                files.
            </p>
            <p>Wish there was an easy way to pretty print nested <code>ArrayList</code>.</p>
            <p>Producing an array of arrays required a lot of painful trial and error.</p>
            <p>
                Struggled to mutably iterate an <code>ArrayList</code>. The trick was:
                <code>for (board.tiles.items) |*tile| { ... }</code>. I don&#39;t get it. I
                found understanding value vs reference semantics in Zig very difficult and
                confusing.
            </p>
            <p>
                Index checking is cool... but the error message is not helpful.
                <code>thread 9888 panic: index out of bounds</code>. What was the index? What
                was the slice length? This is important information.
            </p>
            <p>VSCode breakpoint on exception works great.</p>
            <p>
                First-class support for callstacks is stellar. Something sorely missing in C
                and C++.
            </p>
            <p>
                My parser isn&#39;t working, but not sure why. Omg <code>tokenize</code> does
                not work as expected. Needed to use <code>split</code> not
                <code>tokenize</code>. Horrifically insidious.
            </p>
            
            
            <p>
                Wanted to use regular expression. There&#39;s nothing built-in. There is a
                GitHub project. Not sure how to use it.
            </p>
            <p>
                No standard package manager in Zig. Gyro, zigmod, and submodules all exist. No
                standard.
            </p>
            <p>
                No zig tutorial shows how to correctly import external Zig code. This feels
                like a huge oversight.
            </p>
            <p>VSCode debugging of Zig is easy to setup.</p>
            <p>
                Debugging <code>ArrayList</code> is not useful. Only shows first element. :(
            </p>
            <p>
                Zig templates/generics is interesting.
                <code>pub fn max(x: anytype, y: anytype) @TypeOf(x, y) { return if (x &gt; y) x
                else y; }</code>
            </p>
            <p>
                Compile times still frustrating. I wish there was a fast
                <code>zig check</code> similar to <code>cargo check</code>.
            </p>
            <p>
                Hard to cast <code>i32*i32</code> to <code>usize</code>. (Not sure why I made
                this note.)
            </p>
            <p>
                I don&#39;t actually know what <code>@</code> prefix means. I think
                &#34;built-in&#34;. For some unspecified definition of built-in.
            </p>
            <p>
                Zig&#39;s inability to infer type is annoying. If I create
                <code>var count</code> and return it and the function return type is
                <code>usize</code> then <code>var count</code> is obviously a
                <code>usize</code>.
            </p>

            
            <p>
                No notes. Simple problem that didn&#39;t require learning anything new. Maybe
                I&#39;m starting to grasp the basics?
            </p>

            

            <p>Did not complete in Zig.</p>
            <p>
                This is where I fell off the rails. I didn&#39;t intend to stop. I said
                I&#39;ll catch back up in a couple of days. I never did. The motivation
                drained out of me for no particular reason.
            </p>
            <p>
                The thought of picking Zig back up felt like a chore. There were things I knew
                I would have to learn in Zig, for example <code>HashMap</code> and
                <code>HashSet</code>, and the idea of fighting did not spark joy.
            </p>

            

            
            <p>
                I tried to pick Zig + AoC back up in January after a nice holiday break.
                Somewhere along the lines
                <a href="https://ziglang.org/download/0.9.0/release-notes.html">Zig 0.9</a>
                released so I decided it would be a good exercise to upgrade.
            </p>
            <p>
                Upgrading Zig is a manual process. Download a new <code>zig.exe</code> and
                replace your old one in the path. A little tedious.
            </p>
            <p>
                I immediately encountered new errors about unused function parameters. My
                overly complex workaround for local functions stopped working, sometimes. I
                don&#39;t know why so I just turned it into a normal function.
            </p>
            <p>
                Next, I had to deal with
                <a href="https://pithlessly.github.io/allocgate.html">allocgate</a>. I found
                the release notes for this really frustrating. The blog post explains in
                detail why the change was made. But it did not clearly explain what changes I
                needed to make to my code to make it compile. This was needlessly frustrating
                to figure out imho.
            </p>
            <p>
                Once I got my code working I realized something shocking. Zig appears to not
                report compiler errors for functions that get optimized out. Wat? I needed to
                explicitly make sure all functions were called for allocgate errors to be
                detected. Blech.
            </p>

            <p>At this point I simply have other projects that interest me more. Zig is going back on the shelf.</p>
            
            
            
            
            <p>So where does this leave me? I think I have three key impressions.</p>
            <ol>
                <li>Zig does not currently spark joy</li>
                <li>Zig may have several profound ideas</li>
                <li>Zig is exciting and I will revisit for Advent of Code 2022</li>
            </ol>
            <p>
                Zig is not ready for primetime. This is not controversial. The Zig team
                explicitly states it is not ready for production use. I concur.
            </p>
            <p>
                I don&#39;t think Zig is ready for most programmers. It is not as far along as
                I thought it was. </p>
                
                <p>There is very little info on Zig out there. It&#39;s very
                difficult to use Google to answer questions. r/zig is not active. r/adventofcode solution threads do not have Zig solutions. </p>
                
                <p>The Zig Discord is very active and the #advent-of-code channel is full of
                very friendly, very helpful people. They answered many questions from me.
                Without their help I likely would have given up earlier due to frustration.
            </p>

            

            
            <p>
                Zig has poor documentation. The
                <a href="https://ziglang.org/documentation/0.9.0/std/">standard library reference</a>
                is experimental and not useful. The
                <a href="https://ziglang.org/documentation/0.9.0/">language reference</a> is
                pretty good, but it&#39;s a reference not a guide or tutorial.
            </p>
            <p>
                <a href="https://ziglearn.org/">ZigLearn</a> is the best learning resource I
                found. It&#39;s a good start. It isn&#39;t
                the best at introducing concepts. For example it starts off with a bunch of
                unfamiliar <code>test &#34;Do Thing&#34;</code> function declarations
                without explaining what that syntax means or how to run tests. The second
                example introduces the <code>try</code> keyword, but it isn&#39;t defined.
                That critically important definition occurs 7 sections later, in the middle,
                in an off-hand comment that&#39;s trivially easy to miss.
            </p>
            <p>
                Writing documentation is <b>hard</b>. I&#39;ve tried to not
                compare Zig to Rust. However I simply have to compare Zig&#39;s lack of
                documentation to the absolute stellar
                <a href="https://doc.rust-lang.org/stable/book/">Rust book</a> and
                <a href="https://doc.rust-lang.org/stable/std/">Rust Standard Library Documentation</a>. </p>
                
                <p>I think Zig needs to put significant
                resources into the &#34;Zig Book&#34; now. It takes years of refinement and
                waiting for Zig 1.0 is too late IMHO. Start now and by Zig 1.2 it should be
                pretty good.
            </p>

            

            
            <p>
                I&#39;m going to complain briefly about the Zig page titled
                <a href="https://ziglang.org/learn/why_zig_rust_d_cpp/">Why Zig When There is Already C++, D, and
                    Rust?</a>.
            </p>
            <p>
                Zig is a cool language. I think it has a lot of interesting ideas. I think in
                the future there are numerous reasons why someone might choose to use Zig.
                Here are the bullet points from &#34;Why Zig&#34;:
            </p>
            <ul>
                <li>No hidden control flow</li>
                <li>No hidden allocations</li>
                <li>First class support for no standard library</li>
                <li>A portable language for libraries</li>
                <li>A package manager and Build System for existing projects</li>
                <li>Simplicity</li>
                <li>Tooling</li>
            </ul>
            <p>
                This list is not compelling IMHO. Zig is a cool languge with a lot of really
                cool ideas. This list is not cool and does include most of the features that excite me. &#34;It&#39;s like C, but better in every
                way&#34;. Now that&#39;s a hell of a sales pitch.
            </p>
            <p>
                &#34;No hidden control flow&#34; seems to be a rallying cry of the Zig
                community. That is definitely not what I would put as the #1 most compelling
                bullet point for a new programming language. I don&#39;t know why it&#39;s the first feature listed on every page.
            </p>
            <p>
                I also think it&#39;s partially wrong. No one in the history of the world has
                ever been confused or upset by <code>a + b</code> calling a function.
                Operating overloading can be very evil. Don&#39;t allow
                <code>operator.</code> or <code>operator-&gt;</code> overloads. Overloading
                basic math operators is fine, not confusing, and a good idea. I do a lot of 3d
                vector math so I&#39;m willing to die on this hill.
            </p>
<pre><span>fn</span> lerp(a<span>:</span> Vec3f, b<span>:</span> Vec3f, t<span>:</span> <span>f32</span>) Vec3f {
    <span>// Obviously good and easy to read</span>
    <span>return</span> a<span>*</span>(<span>1.0</span><span>-</span>t) <span>+</span> b<span>*</span>t;

    <span>// Obviously bad and hard to read</span>
    <span>return</span> add(mul(a, <span>1.0</span> <span>-</span> t), mul(b, t));
}</pre>

            

            
            <p>I think Zig might have several profound ideas.</p>
            <p>
                No language allocator function is profound. Passing allocators into every
                struct function is somewhat tedious, but profound. In C++ you have the
                workhorse <code>std::vector&lt;Foo&gt;</code>. Specifying the allocator
                requires specifying a template type, which is a monumental pain in the ass. In
                Zig you can trivially change the allocator type.
                <code>std.heap</code> contains <code>ArenaAllocator</code>,
                <code>FixedBufferAllocator</code>, <code>GeneralPurposeAllocator</code>, and
                <code>StackFallbackAllocator</code>. Delightful.
            </p>
            <p>
                Zig has a seemingly powerful ability to intergrate into existing projects.
                It&#39;s ability to cross-compile for different platforms is enviable. I think
                that &#34;using Zig for isolated parts of your project&#34; might be
                profound. I&#39;m not sure. I strongly suspect integrating Zig into real
                projects is harder than the Zig team suggests.
            </p>
            <p>
                Zig&#39;s comptime generic capabilities are fascinating and profound. I
                don&#39;t fully understand them yet. I&#39;m not entirely sure how they compare to
                C++ template or Rust generics. Can Zig comptime do anything C++ templates can
                do? Are there limitations? I&#39;m not sure.
            </p>
            <p>
                Zig&#39;s
                <a href="https://ziglang.org/documentation/0.9.0/#Errors">error handling</a>
                is profound and powerful. It&#39;s also super confusing. I failed to grok
                erors sets which can be merged, inferred, coerced, deferred, and
                traced. Error tracing is super cool and something I badly wish was in other
                languages. I don&#39;t love syntax such as <code>anyerror!?u32</code>.
            </p>
            <p>
                Zig&#39;s
                <a href="https://kristoff.it/blog/zig-colorblind-async-await/">colorblind</a>
                async / coroutine system may be especially profound. I haven&#39;t dug deep
                enough to form an opinion. This could be a huge feature advantage over C and even C++.
            </p>

            

            
            <p>
                Zig did not spark my joy. I found it difficult and frustrating to learn. Lack
                of documentation, lack of tutorials, poor compiler errors, unintuitive types,
                confusing syntax, confusing reference vs value, ungoogleable, non-composable
                iterators, and more.
            </p>
            <p>
                However Zig has many things I loved and expect in a modern language. Runtime
                safety, slices, defer, simd, tagged unions (needs syntactic sugar),
                <code>foreach</code> style <code>for</code> loops, comptime, a standard build
                system, a promise of a package manager, basic iterators, and more.
            </p>
            <p>
                I&#39;m excited for the future of Zig. I love that it is exploring new ideas
                and pushing forward the next generation of programming languages. I think it
                will likely be very solid when Zig 1.0 releases. That looks to be several
                years from now.
            </p>
            <p>
                I&#39;ve dipped my toes in the Zig water and it was chilly. I&#39;m not
                ready to jump in. I will likely give Zig a more exclusive go for Advent of
                Code 2022. Next time I&#39;ll have a better idea of what I&#39;m signing up
                for.
            </p>
            <p>Thanks for reading.</p>

        </div></div>
  </body>
</html>
