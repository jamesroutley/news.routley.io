<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://qntm.org/clean">Original</a>
    <h1>It&#39;s probably time to stop recommending Clean Code (2020)</h1>
    
    <div id="readability-page-1" class="page">
    <div>
      <div>
        <div>
          <!-- <h1 class="page__h1">
            <a href="/">
              Things Of Interest            </a>
          </h1> -->

          

          <h2>
            It&#39;s probably time to stop recommending Clean Code             
          </h2>

           
            
           
        </div>
      </div>
    </div>

    <div>
      <div>
         

        <div>
          <p>It may not be possible for us to ever reach empirical definitions of &#34;good code&#34; or &#34;clean code&#34;, which means that any one person&#39;s opinions about another person&#39;s opinions about &#34;clean code&#34; are necessarily highly subjective. I cannot review Robert C. Martin&#39;s 2008 book <a href="https://learning.oreilly.com/library/view/clean-code/9780136083238/"><i>Clean Code</i></a> from your perspective, only mine.</p>

<p>That said, the major problem I have with <i>Clean Code</i> is that a lot of the example code in the book is <em>just dreadful</em>.</p>

<h4>*</h4>

<p>In chapter 3, &#34;Functions&#34;, Martin gives a variety of advice for writing functions well. Probably the strongest single piece of advice in this chapter is that <strong>functions should not mix levels of abstraction</strong>; they should not perform both high-level and low-level tasks, because this is confusing and muddles the function&#39;s responsibility. There&#39;s other valid stuff in this chapter: Martin says that function names should be descriptive, and consistent, and should be verb phrases, and should be chosen carefully. He says that functions should do exactly one thing, and do it well, which I agree with... provided that we aren&#39;t too dogmatic about how we define &#34;one thing&#34;, and we understand that in plenty of cases this can be highly impractical. He says that functions should not have side effects (and he provides a really great example), and that output arguments are to be avoided in favour of return values. He says that functions should generally either be commands, which <em>do</em> something, or queries, which <em>answer</em> something, but not both. This is all reasonable entry-level advice.</p>

<p>But mixed into the chapter there are more questionable assertions. Martin says that Boolean flag arguments are bad practice, which I agree with, because an unadorned <code>true</code> or <code>false</code> in source code is opaque and unclear <i>versus</i> an explicit <code>IS_SUITE</code> or <code>IS_NOT_SUITE</code>... but Martin&#39;s reasoning is rather that a Boolean argument means that a function does more than one thing, which it shouldn&#39;t.</p>

<p>Martin says that it should be possible to read a single source file from top to bottom as narrative, with the level of abstraction in each function descending as we read on, each function calling out to others further down. This is far from universally relevant. Many source files, I would even say most source files, cannot be neatly hierarchised in this way. And even for the ones which can, an IDE lets us trivially jump from function call to function implementation and back, the same way that we browse websites.</p>

<p>He says code duplication &#34;may be the root of all evil in software&#34; and fiercely advocates <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>. At the time, this was quite standard advice. In more recent times, however, we generally understand that <a href="https://overreacted.io/goodbye-clean-code/">a little duplication isn&#39;t the worst thing in the world</a>; it can be clearer, and it can be <a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction">cheaper than the wrong abstraction</a>.</p>

<p>And then it gets weird. Martin says that functions should not be large enough to hold <em>nested</em> control structures (conditionals and loops); equivalently, they should not be indented to more than two levels. He says blocks should be one line long, consisting probably of a single function call. He says that an ideal function has <em>zero arguments</em> (but still no side effects?), and that a function with just three arguments is confusing and difficult to test. Most bizarrely, Martin asserts that an ideal function is <em>two to four lines of code long</em>. This piece of advice is actually placed at the start of the chapter. It&#39;s the first and most important rule:</p>

<blockquote>
<p>The first rule of functions is that they should be small. The second rule of functions is that <em>they should be smaller than that</em>. This is not an assertion that I can justify. I can’t provide any references to research that shows that very small functions are better. What I can tell you is that for nearly four decades I have written functions of all different sizes. I’ve written several nasty 3,000-line abominations. I’ve written scads of functions in the 100 to 300 line range. And I’ve written functions that were 20 to 30 lines long. What this experience has taught me, through long trial and error, is that functions should be very small.</p>

<p>[...]</p>

<p>When Kent [Beck] showed me the code, I was struck by how small all the functions were. I was used to functions in Swing programs that took up miles of vertical space. Every function in <em>this</em> program was just two, or three, or four lines long. Each was transparently obvious. Each told a story. And each led you to the next in a compelling order. <em>That’s</em> how short your functions should be!</p>
</blockquote>

<p>All of this sounds like hyperbole. A case for short functions instead of long ones can certainly be made, but we assume that Martin doesn&#39;t <em>literally</em> mean that every function in our entire application <em>must</em> be four lines long or less.</p>

<p>But the book is being absolutely serious about this. All of this advice culminates in the following source code listing at the end of chapter 3. This example code is <strong>Martin&#39;s preferred refactoring</strong> of <a href="https://github.com/unclebob/fitnesse/blob/3bec390e6f8e9e341149b7d060551a92b93d3154/src/fitnesse/html/HtmlUtil.java#L279-L331">a pair of Java methods</a> originating in an open-source testing tool, <a href="http://www.fitnesse.org/">FitNesse</a>.</p>

<pre>package fitnesse.html;

import fitnesse.responders.run.SuiteResponder;
import fitnesse.wiki.*;

public class SetupTeardownIncluder {
  private PageData pageData;
  private boolean isSuite;
  private WikiPage testPage;
  private StringBuffer newPageContent;
  private PageCrawler pageCrawler;


  public static String render(PageData pageData) throws Exception {
    return render(pageData, false);
  }

  public static String render(PageData pageData, boolean isSuite)
    throws Exception {
    return new SetupTeardownIncluder(pageData).render(isSuite);
  }

  private SetupTeardownIncluder(PageData pageData) {
    this.pageData = pageData;
    testPage = pageData.getWikiPage();
    pageCrawler = testPage.getPageCrawler();
    newPageContent = new StringBuffer();
  }

  private String render(boolean isSuite) throws Exception {
     this.isSuite = isSuite;
    if (isTestPage())
      includeSetupAndTeardownPages();
    return pageData.getHtml();
  }

  private boolean isTestPage() throws Exception {
    return pageData.hasAttribute(&#34;Test&#34;);
  }

  private void includeSetupAndTeardownPages() throws Exception {
    includeSetupPages();
    includePageContent();
    includeTeardownPages();
    updatePageContent();
  }


  private void includeSetupPages() throws Exception {
    if (isSuite)
      includeSuiteSetupPage();
    includeSetupPage();
  }

  private void includeSuiteSetupPage() throws Exception {
    include(SuiteResponder.SUITE_SETUP_NAME, &#34;-setup&#34;);
  }

  private void includeSetupPage() throws Exception {
    include(&#34;SetUp&#34;, &#34;-setup&#34;);
  }

  private void includePageContent() throws Exception {
    newPageContent.append(pageData.getContent());
  }

  private void includeTeardownPages() throws Exception {
    includeTeardownPage();
    if (isSuite)
      includeSuiteTeardownPage();
  }

  private void includeTeardownPage() throws Exception {
    include(&#34;TearDown&#34;, &#34;-teardown&#34;);
  }

  private void includeSuiteTeardownPage() throws Exception {
    include(SuiteResponder.SUITE_TEARDOWN_NAME, &#34;-teardown&#34;);
  }

  private void updatePageContent() throws Exception {
    pageData.setContent(newPageContent.toString());
  }

  private void include(String pageName, String arg) throws Exception {
    WikiPage inheritedPage = findInheritedPage(pageName);
    if (inheritedPage != null) {
      String pagePathName = getPathNameForPage(inheritedPage);
      buildIncludeDirective(pagePathName, arg);
    }
  }

  private WikiPage findInheritedPage(String pageName) throws Exception {
    return PageCrawlerImpl.getInheritedPage(pageName, testPage);
  }

  private String getPathNameForPage(WikiPage page) throws Exception {
    WikiPagePath pagePath = pageCrawler.getFullPath(page);
    return PathParser.render(pagePath);
  }

  private void buildIncludeDirective(String pagePathName, String arg) {
    newPageContent
      .append(&#34;\n!include &#34;)
      .append(arg)
      .append(&#34; .&#34;)
      .append(pagePathName)
      .append(&#34;\n&#34;);
  }
}
</pre>

<p>I&#39;ll say again: this is Martin&#39;s own code, written to his personal standards. This is the ideal, presented to us as a learning example.</p>

<p>I will confess at this stage that my Java skills are dated and rusty, almost as dated and rusty as this book, which is from 2008. But surely, even in 2008, this code was illegible trash?</p>

<p>Let&#39;s ignore the wildcard <code>import</code>.</p>

<p>First, the class name, <code>SetupTeardownIncluder</code>, is dreadful. It <em>is</em>, at least, a noun phrase, as all class names should be. But it&#39;s a nouned verb phrase, the strangled kind of class name you invariably get when you&#39;re working in strictly object-oriented code, where everything has to be a class, but sometimes the thing you really need is just one simple gosh-danged <em>function</em>.</p>

<p>Inside the class, we have:</p>

<ul>
<li>two public, static methods, as before, plus</li>
<li>one new private constructor and</li>
<li><strong>fifteen</strong> new private methods.</li>
</ul>

<p>Of the fifteen private methods, fully thirteen of them either have side effects (they modify variables which were not passed into them as arguments, such as <code>buildIncludeDirective</code>, which has side effects on <code>newPageContent</code>) or call out to other methods which have side effects (such as <code>include</code>, which calls <code>buildIncludeDirective</code>). Only <code>isTestPage</code> and <code>findInheritedPage</code> look to be side-effect-free. They still make use of variables which aren&#39;t passed into them (<code>pageData</code> and <code>testPage</code> respectively) but they <em>appear</em> to do so in side-effect-free ways.</p>

<p>At this point you might reason that maybe Martin&#39;s definition of &#34;side effect&#34; doesn&#39;t include member variables of the object whose method we just called. If we take this definition, then the five member variables, <code>pageData</code>, <code>isSuite</code>, <code>testPage</code>, <code>newPageContent</code> and <code>pageCrawler</code>, are implicitly passed to <em>every</em> private method call, and they are considered fair game; any private method is free to do anything it likes to any of these variables.</p>

<p>But Martin&#39;s own definition contradicts this. This is from earlier in this exact chapter, with emphasis added:</p>

<blockquote>
<p>Side effects are lies. Your function promises to do one thing, but it also does other hidden things. <strong>Sometimes it will make unexpected changes to the variables of its own class.</strong> Sometimes it will make them to the parameters passed into the function or to system globals. In either case they are devious and damaging mistruths that often result in strange temporal couplings and order dependencies.</p>
</blockquote>

<p>I like this definition. I agree with this definition. It&#39;s a useful definition, because it enables us to reason about what a function does, with some degree of confidence, by referring only to its inputs and output. I agree that it&#39;s bad for a function to make <em>unexpected</em> changes to the variables of its own class.</p>

<p>So why does Martin&#39;s own code, &#34;clean&#34; code, do <em>nothing but this</em>? Rather than have a method pass arguments to another method, Martin makes a distressing habit of having the first method set a member variable which the second method, or some other method, then reads back. This makes it incredibly hard to figure out what any of this code does, because all of these incredibly tiny methods do almost nothing and work exclusively through side effects.</p>

<p>Let&#39;s just look at one private method.</p>

<pre>private String render(boolean isSuite) throws Exception {
   this.isSuite = isSuite;
  if (isTestPage())
    includeSetupAndTeardownPages();
  return pageData.getHtml();
}
</pre>

<p>So... imagine that someone enters a kitchen, because they want to show you how to make a cup of coffee. As you watch carefully, they flick a switch on the wall. The switch looks like a light switch, but none of the lights in the kitchen turn on or off. Next, they open a cabinet and take down a mug, set it on the worktop, and then tap it twice with a teaspoon. They wait for thirty seconds, and finally they reach behind the refrigerator, where you can&#39;t see, and pull out a <em>different</em> mug, this one full of fresh coffee.
</p>

<p>...What just happened? What was flicking the switch for? Was tapping the empty mug part of the procedure? Where did the coffee come from?</p>

<p>That&#39;s what this code is like. Why does <code>render</code> have a side effect of setting the value of <code>this.isSuite</code>? When is <code>this.isSuite</code> read back, in <code>isTestPage</code>, in <code>includeSetupAndTeardownPages</code>, in both, in neither? If it does get read back, why not just pass <code>isSuite</code> in as a Boolean? Or perhaps the caller reads it back?</p>

<p>Why do we return <code>pageData.getHtml()</code> when we never touched <code>pageData</code>? How did the HTML get there? Was it already there? We might make an educated guess that <code>includeSetupAndTeardownPages</code> has side effects on <code>pageData</code>, but then, what? We can&#39;t know either way until we look. And what other side effects does that have on other member variables? The uncertainty becomes so great that we suddenly have to wonder if calling <code>isTestPage()</code> could have side effects too.</p>

<p>How would you unit-test this method? Well, you can&#39;t. It&#39;s not a unit. It can&#39;t be separated from the side-effects it has on other parts of the code. (And what&#39;s up with the indentation? And where are the danged braces?)</p>

<p>Martin states, in this very chapter, that it makes sense to break a function down into smaller functions &#34;if you can extract another function from it with a name that is not merely a restatement of its implementation&#34;. But then he gives us:</p>

<pre>private boolean isTestPage() throws Exception {
  return pageData.hasAttribute(&#34;Test&#34;);
}
</pre>

<p>and:</p>

<pre>private WikiPage findInheritedPage(String pageName) throws Exception {
  return PageCrawlerImpl.getInheritedPage(pageName, testPage);
}
</pre>

<p>and half a dozen others, none of which are even called from more than one location.</p>

<p>There is at least one questionable aspect of this code which isn&#39;t Martin&#39;s fault: the fact that <code>pageData</code>&#39;s content gets destroyed. Unlike the member variables (<code>isSuite</code>, <code>testPage</code>, <code>newPageContent</code> and <code>pageCrawler</code>), <code>pageData</code> is not actually ours to modify. It is originally passed in to the top-level public <code>render</code> methods by an external caller. The <code>render</code> method does a lot of work and ultimately returns a <code>String</code> of HTML. However, during this work, as a side effect, <code>pageData</code> is destructively modified (see <code>updatePageContent</code>). Surely it would be preferable to create a brand new <code>PageData</code> object with our desired modifications, and leave the original untouched? If the caller tries to use <code>pageData</code> for something else afterwards, they might be very surprised about what&#39;s happened to its content. But this is <a href="https://github.com/unclebob/fitnesse/blob/3bec390e6f8e9e341149b7d060551a92b93d3154/src/fitnesse/html/HtmlUtil.java#L329">how the original code behaved</a> prior to the refactoring, and the behaviour could be intentional. Martin has preserved the behaviour, though he has buried it very effectively.</p>

<p>Some other mild puzzles: why do we use <code>pageData.hasAttribute(&#34;Test&#34;)</code> to figure out whether this is a test page, but we have to consult a separate Boolean to figure out whether or not this is a test <em>suite</em> page? And what exactly is the separation of concerns between <code>PageCrawler</code> and <code>PageCrawlerImpl</code>, both of which are in use here?</p>

<h4>*</h4>

<p>Is the whole book like this?</p>

<p>Pretty much, yeah. <i>Clean Code</i> mixes together a disarming combination of strong, timeless advice and advice which is highly questionable or dated or both.</p>

<p>Much of the book is no longer of much use. There are multiple chapters of what are basically filler, focusing on laborious worked examples of refactoring Java code; there is a whole chapter examining the internals of JUnit. This book is from 2008, so you can imagine how relevant that is now. There&#39;s a whole chapter on formatting, which these days reduces to a single sentence: &#34;Pick a sensible standard formatting, configure automated tools to enforce it, and then never think about this topic again.&#34;</p>

<p>The content focuses almost exclusively on object-oriented code, to the exclusion of other programming paradigms. Object-oriented programming was very fashionable at the time of publication. Martin is a huge proponent of OO, having invented three of the five principles which make up <a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a>, and having popularised the term. But the total absence of functional programming techniques or even simple procedural code was regrettable even then, and has only grown more obvious in the years since.</p>

<p>The book focuses on Java code, to the exclusion of other programming languages, even other object-oriented programming languages. Java was popular at the time, and if you&#39;re writing a book like this, it makes sense to pick a single well-known language and stick with it, and Java is still very popular and may still be a strong choice for this purpose. But the book&#39;s overall use of Java is very dated.</p>

<p>This kind of thing is unavoidable — programming books date legendarily poorly. That&#39;s part of the reason why <i>Clean Code</i> was a recommended read at one time, and I now think that the pendulum is swinging back in the opposite direction.</p>

<p>But even for the time, even for 2008-era Java, much of the provided code is <em>bad</em>.</p>

<p>There&#39;s a chapter on unit testing. There&#39;s a lot of good, basic, stuff in this chapter, about how unit tests should be fast, independent and repeatable, about how unit tests enable more confident refactoring of source code, about how unit tests should be about as voluminous as the code under test, but strictly simpler to read and comprehend. But then he shows us a unit test with what he says is too much detail:</p>

<pre>@Test
  public void turnOnLoTempAlarmAtThreashold() throws Exception {
    hw.setTemp(WAY_TOO_COLD);
    controller.tic();
    assertTrue(hw.heaterState());
    assertTrue(hw.blowerState());
    assertFalse(hw.coolerState());
    assertFalse(hw.hiTempAlarm());
    assertTrue(hw.loTempAlarm());
  }
</pre>

<p>and he proudly refactors it to:</p>

<pre>@Test
  public void turnOnLoTempAlarmAtThreshold() throws Exception {
    wayTooCold();
    assertEquals(“HBchL”, hw.getState());
  }
</pre>

<p>This is done as part of an overall lesson in the virtue of <em>inventing a new domain-specific testing language for your tests</em>. I was left so confused by this suggestion. I would use exactly the same code to demonstrate exactly the opposite lesson. Don&#39;t do this!</p>

<p>Which is to say nothing of the method named <code>wayTooCold</code>. This is an adjective phrase. It&#39;s entirely unclear what this method does. Does it <em>set</em> the world&#39;s state to be way too cold? Does it <em>react</em> to the world&#39;s state <em>becoming</em> way too cold? Or is it an <em>assertion</em> that the world&#39;s state currently must <em>be</em> way too cold?</p>

<p>Methods should have verb or verb phrase names like <code>postPayment</code>, <code>deletePage</code>, or <code>save</code>. That&#39;s not me saying that. That&#39;s a direct quote from this book. Chapter 2, &#34;Meaningful Names&#34;:</p>

<blockquote>
<p>Methods should have verb or verb phrase names like <code>postPayment</code>, <code>deletePage</code>, or <code>save</code>.</p>
</blockquote>

<p>This is perfectly sound advice. And <code>hw.setTemp(WAY_TOO_COLD);</code> was a perfectly unambiguous line of code. What gives?</p>

<p>And even if you guess correctly that calling <code>wayTooCold()</code> <em>sets</em> the temperature to be way too cold... there&#39;s no way that you could guess that it also calls <code>controller.tic()</code> internally. Earlier, we were advised to avoid code having side effects. This, also, was sound advice. And it is, again, being ignored in the actual written code example.</p>

<p>(And since we&#39;re here, this, the original unrefactored code, is a fine demonstration of the drawbacks of unadorned Booleans. What does it mean when, say, <code>coolerState</code> returns <code>true</code>? Does it mean that the cooler&#39;s current state is good, <i>i.e.</i> cold enough, <i>i.e.</i> switched off? Or does it mean that it is powered on, and actively cooling? An <code>enum</code> with a few values, <code>ON</code> and <code>OFF</code>, could be less ambiguous.)

</p><h4>*</h4>

<p>The book presents us with the <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> loop:</p>

<blockquote>
<p><b>First Law</b> You may not write production code until you have written a failing unit test.</p>

<p><b>Second Law</b> You may not write more of a unit test than is sufficient to fail, and not compiling is failing.</p>

<p><b>Third Law</b> You may not write more production code than is sufficient to pass the currently failing test.</p>

<p>These three laws lock you into a cycle that is perhaps thirty seconds long. The tests and the production code are written together, with the tests just a few seconds ahead of the production code.</p>
</blockquote>

<p>But the book doesn&#39;t acknowledge the missing zeroth step in the process: figuring out how to break down the programming task in front of you, so that you can take a minuscule thirty-second bite out of it. <em>That</em>, in many cases, is exceedingly time-consuming, and frequently obviously useless, and frequently impossible.</p>

<h4>*</h4>

<p>There&#39;s a whole chapter on &#34;Objects and Data Structures&#34;. In it, we&#39;re provided with this example of a data structure:</p>

<pre>public class Point {
  public double x;
  public double y;
}
</pre>

<p>and this example of an object (well, the interface for one):</p>

<pre>public interface Point {
  double getX();
  double getY();
  void setCartesian(double x, double y);
  double getR();
  double getTheta();
  void setPolar(double r, double theta);
}
</pre>

<p>Martin writes:</p>

<blockquote>
<p>These two examples show the difference between objects and data structures. Objects hide their data behind abstractions and expose functions that operate on that data. Data structure expose their data and have no meaningful functions. Go back and read that again. Notice the complimentary nature of the two definitions. They are virtual opposites. This difference may seem trivial, but it has far-reaching implications.</p>
</blockquote>

<p>And... that&#39;s it?</p>

<p>Yes, you&#39;re understanding this correctly. Martin&#39;s definition of &#34;data structure&#34; disagrees with the definition everybody else uses. This is a very strange choice of definition, though Martin does at least define his term clearly. Drawing a clear distinction between objects as dumb data and objects as sophisticated abstractions with methods is legitimate, and useful. But it&#39;s quite glaring that there is no content in the book <em>at all</em> about clean coding using <a href="https://en.wikipedia.org/wiki/List_of_data_structures">what most of us consider to be real data structures</a>: arrays, linked lists, hash maps, binary trees, graphs, stacks, queues and so on. This chapter is <em>much</em> shorter than I expected, and contains very little information of value.</p>

<h4>*</h4>

<p>I&#39;m not going to rehash all the rest of my notes. I took a lot of them, and calling out everything I perceive to be wrong with this book would be counterproductive. I&#39;ll stop with one more egregious piece of example code. This is from chapter 8, a prime number generator:</p>

<pre>package literatePrimes;

import java.util.ArrayList;

public class PrimeGenerator {
  private static int[] primes;
  private static ArrayList&lt;Integer&gt; multiplesOfPrimeFactors;

  protected static int[] generate(int n) {
    primes = new int[n];
    multiplesOfPrimeFactors = new ArrayList&lt;Integer&gt;();
    set2AsFirstPrime();
    checkOddNumbersForSubsequentPrimes();
    return primes;
  }

  private static void set2AsFirstPrime() {
    primes[0] = 2;
    multiplesOfPrimeFactors.add(2);
  }

  private static void checkOddNumbersForSubsequentPrimes() {
    int primeIndex = 1;
    for (int candidate = 3;
         primeIndex &lt; primes.length;
         candidate += 2) {
      if (isPrime(candidate))
        primes[primeIndex++] = candidate;
    }
  }

  private static boolean isPrime(int candidate) {
    if (isLeastRelevantMultipleOfNextLargerPrimeFactor(candidate)) {
      multiplesOfPrimeFactors.add(candidate);
      return false;
    }
    return isNotMultipleOfAnyPreviousPrimeFactor(candidate);
  }

  private static boolean
  isLeastRelevantMultipleOfNextLargerPrimeFactor(int candidate) {
    int nextLargerPrimeFactor = primes[multiplesOfPrimeFactors.size()];
    int leastRelevantMultiple = nextLargerPrimeFactor * nextLargerPrimeFactor;
    return candidate == leastRelevantMultiple;
  }

  private static boolean
  isNotMultipleOfAnyPreviousPrimeFactor(int candidate) {
    for (int n = 1; n &lt; multiplesOfPrimeFactors.size(); n++) {
      if (isMultipleOfNthPrimeFactor(candidate, n))
        return false;
    }
    return true;
  }

  private static boolean
  isMultipleOfNthPrimeFactor(int candidate, int n) {
   return
     candidate == smallestOddNthMultipleNotLessThanCandidate(candidate, n);
  }

  private static int
  smallestOddNthMultipleNotLessThanCandidate(int candidate, int n) {
    int multiple = multiplesOfPrimeFactors.get(n);
    while (multiple &lt; candidate)
      multiple += 2 * primes[n];
    multiplesOfPrimeFactors.set(n, multiple);
    return multiple;
  }
}
</pre>

<p>What the heck is this code? What is this algorithm? What are these <em>method names</em>? <code>set2AsFirstPrime</code>? <code>smallestOddNthMultipleNotLessThanCandidate</code>? Why does the code break with an out-of-bounds exception if we replace the <code>int[]</code> with a second <code>ArrayList&lt;Integer&gt;</code>? Earlier, we were advised that a method should be a command, which <em>does</em> something, or a query, which <em>answers</em> something, but not both. This was good advice, so why do nearly all of these methods ignore it? And what of thread safety?</p>

<p>Is this meant to be clean code? Is this meant to be a legible, intelligent way to search for prime numbers? Are we supposed to write code like this? And if not, why is this example in the book? And where is the &#34;real&#34; answer?</p>

<p>If this is the quality of code which this programmer produces — at his own leisure, under ideal circumstances, with none of the pressures of real production software development, <em>as a teaching example</em> — then why should you pay any attention at all to the rest of his book? Or to his other books?</p>

<h4>*</h4>

<p>I wrote this essay because I keep seeing people recommend <i>Clean Code</i>. I felt the need to offer an anti-recommendation.</p>

<p>I originally read <i>Clean Code</i> as part of a reading group which had been organised at work. We read about a chapter a week for thirteen weeks. (The book has seventeen chapters, we skipped some for reasons already mentioned.)</p>

<p>Now, you don&#39;t want a reading group to get to the end of each session with nothing but unanimous agreement. You want the book to draw out some kind of reaction from the readers, something additional to say in response. And I guess, to a certain extent, that means that the book has to either say something you disagree with, or not say everything you think it should say. On that basis, <i>Clean Code</i> was <em>okay</em>. We had good discussions. We were able to use the individual chapters as launching points for deeper discussions of <em>actual</em> modern practices. We talked about a great deal which was not covered in the book. We disagreed with a lot in the book.</p>

<p>Would I recommend this book? <strong>No.</strong> Would I recommend it as a beginner&#39;s text, with all the caveats above? No. Would I recommend it as a historical artifact, an educational snapshot of what programming best practices used to look like, way back in 2008? No, I would not.</p>

<h4>*</h4>

<p>So the killer question is, what book(s) would I recommend instead? I don&#39;t know. Suggestions in the comments, unless I&#39;ve closed them.</p>

<h3 id="sec0">Update, 2020-12-19</h3>

<p>After suggestions from comments below, I read <i>A Philosophy of Software Design</i> (2018) by John Ousterhout and found it to be a much more positive experience. I would be happy to recommend it over <i>Clean Code</i>.</p>

<p><i>A Philosophy of Software Design</i> is not a drop-in replacement for <i>Clean Code</i>. As the title suggests, it focuses more on the practice of software design at a higher level than it does on the writing or critiquing of actual individual lines of code. (As such, it contains relatively few code examples.) Because it&#39;s aimed at this higher level, I think it&#39;s possibly not a suitable read for absolute beginner programmers. A lot of this high-level theory is difficult to comprehend or put into practice until you have some real experience to compare it with. I think there actually is something of a gap in the market for an entry-level introductory programming text right now.</p>

<p>Having said that, I found <i>A Philosophy of Software Design</i> to be informative, cogent, concise and <em>much</em> more up-to-date. I found that I agreed with nearly all of Ousterhout&#39;s assertions and suggestions for good software design, many of which are diametrically opposed to those found in <i>Clean Code</i>. By virtue of providing relatively high-level advice, I feel that the book is likely to age rather better too.</p>

<p>Of course, software development is still moving forwards as I write this. Who knows what a good programming book will look like in ten more years?</p>

<h3 id="sec1">Afterword, 2022-03-21</h3>
<p>Probably the most common defence of <i>Clean Code</i> that I&#39;ve seen coming from readers of this essay is that the book <em>is</em> still worth recommending, despite the objections above, because the advice in the book shouldn&#39;t be taken entirely literally, or applied dogmatically. The burden is on the reader to think critically, draw their own conclusions, and selectively ignore the book&#39;s advice when that advice is bad. Even the book itself says:</p>

<blockquote>
<p>[M]any of the recommendations in this book are controversial. You will probably not agree with all of them. You might violently disagree with some of them. That&#39;s fine. We can&#39;t claim final authority.<!-- On the other hand, the recommendations in this book are things that we have thought long and hard about it. We have learned them through decades of experience and repeated trial and error. So whether you agree or disagree, it would be a shame if you did not see, and respect, our point of view. --></p>
</blockquote>

<p>I don&#39;t think this is a particularly convincing defence of the book containing bad advice and bad example code in the first place.</p>

<p>It&#39;s true that we should always engage critically with material instead of passively letting it wash over us. This is universally understood; this is what reading <em>is</em>; this is what the essay above is. This doesn&#39;t need to be stated, and it&#39;s redundant for the book itself to mention the point at all. This isn&#39;t something which can be used to shield a book from criticism.</p>

<p>What&#39;s more important is what the book actually says. And, especially in an instructional text like this, <em>how carefully</em> the book has to be read in order to get a positive experience out of it, and what happens if the book isn&#39;t read sufficiently critically.</p>

<p>Experienced programmers will get almost nothing out of reading <i>Clean Code</i>. They&#39;ll be able to weigh the advice given against their own experiences and make an informed decision — and the book will tell them almost nothing that they didn&#39;t learn years ago.</p>

<p>Inexperienced programmers, meanwhile — and <i>Clean Code</i> is an entry-level programming text, so this is the target audience, whose experiences are most important — won&#39;t be able to distinguish the good advice from the bad, and won&#39;t be able to see that the example code is bad and shouldn&#39;t be imitated. Inexperienced programmers will take those lessons at face value, and it might be years before they figure out how badly they were misled.</p>
        </div>

         
          
         
      </div>
    </div>

          <div>
        

        

        <div>
          <h3>Discussion (123)</h3>

                      <div id="komment5ef8e3d15e5ea">
              <h4>
                <a href="#komment5ef8e3d15e5ea">2020-06-28 20:39:13</a>
                by qntm:
              </h4>

              <div>Side note, Clean Architecture is absolute garbage, I didn&#39;t get through it. However, I think there&#39;s general agreement on that topic.</div>

               
            </div>
                      <div id="komment5ef917dd20b7e">
              <h4>
                <a href="#komment5ef917dd20b7e">2020-06-29 00:21:17</a>
                by Gary Stephenson:
              </h4>

              <div>imho, the best book I ever read on programming was
&#34;Concepts, Techniques and Models of Computer Programming&#34; by Peter Van Roy.  Alas the language it expounds  (Oz / Mozart) is pretty much dead (still-born?).  I think the closest thing to it I&#39;ve seen that is still somewhat alive would probably be Picat.</div>

               
            </div>
                      <div id="komment5ef91892494fc">
              <h4>
                <a href="#komment5ef91892494fc">2020-06-29 00:24:18</a>
                by Cgk:
              </h4>

              <div>&#34;Working effectively with legacy code&#34; by Michael C. Feathers was (and is) a practical book.

It provides techniques for working with existing code, which is likely to happen more often than working things from scratch.</div>

               
            </div>
                      <div id="komment5ef91ca5bfbc2">
              <h4>
                <a href="#komment5ef91ca5bfbc2">2020-06-29 00:41:41</a>
                by qntm:
              </h4>

              <div>All code is legacy. It&#39;s like how the speed of light is finite, which means technically you&#39;re always looking at the world as it was at some time in the past. You commit some new code, you go for a coffee break, you come back - it&#39;s legacy code now.</div>

               
            </div>
                      <div id="komment5ef92858c3d14">
              <h4>
                <a href="#komment5ef92858c3d14">2020-06-29 01:31:36</a>
                by kevin:
              </h4>

              <div>Michael Feathers has his own definition of legacy code. Quote from the book&#39;s back cover: &#34;Is your code easy to change? Can you get nearly instantaneous feedback when you do change it? Do you understand it? If the answer to any of these questions is no, you have legacy code, [...]&#34;

It should really be called &#34;Working Effectively with Garbage Code&#34;.</div>

               
            </div>
                      <div id="komment5ef92ab7c7044">
              <h4>
                <a href="#komment5ef92ab7c7044">2020-06-29 01:41:43</a>
                by kevin:
              </h4>

              <div>I&#39;ve seen a lot of backlash against Clean Code recently. It was transformative for me as a software greenhorn, introducing me to concepts like testability and readability, which they didn&#39;t tell us about in college. It gave me a vocabulary to discuss program design. And it was short and easily digestible, minus some tedious examples. So until someone comes up with a wartless alternative, I&#39;ll continue recommending it to newbies, with the caveat that they should keep a grain of salt to hand and skip the boring parts. As long as you have more experienced devs around to show you actually good programming, it can&#39;t do much harm.</div>

               
            </div>
                      <div id="komment5ef9394eda411">
              <h4>
                <a href="#komment5ef9394eda411">2020-06-29 02:43:58</a>
                by Stephen Paul Weber:
              </h4>

              <div>If you want a book about refactoring and OOP and such that is modern and not by a terrible human, https://www.sandimetz.com/99bottles is great</div>

               
            </div>
                      <div id="komment5ef93bbf24a02">
              <h4>
                <a href="#komment5ef93bbf24a02">2020-06-29 02:54:23</a>
                by Greg johnson:
              </h4>

              <div>A philosophy of software design by John Ousterhaut.  This is a short and accessible book that penetrates to the heart of deep truths about software development.  Single best book I’ve read on how to write software.</div>

               
            </div>
                      <div id="komment5ef94a72d3302">
              <h4>
                <a href="#komment5ef94a72d3302">2020-06-29 03:57:06</a>
                by kazer:
              </h4>

              <div>Someone made the point about legacy code but that term is rather dubious and used often just as derogatory term as opposed to something written in new trendier tools.
Working useful code is quite often reused or called upon from other pieces of code, just look at any operating system and oldest piece of code it has: is it working? if so, why change it?
Calling code &#34;legacy&#34; is missing the point: if it is garbage it is one thing, if it is written for a platform you no longer have that is quite another.</div>

               
            </div>
                      
                      
                      <div id="komment5ef96805cb957">
              <h4>
                <a href="#komment5ef96805cb957">2020-06-29 06:03:17</a>
                by Andrei:
              </h4>

              <div>I&#39;m ruby on rails dev and one of the thoughtbot guys recommended I read Practical Object-Oriented Design in Ruby by Sandi Metz few years ago. I think it&#39;s very good.  I think they follow her rules in their workflow. Also, you can see it in their teaching platform - upcase.com.

I believe those resources help me write my web apps in a way that I&#39;m not embarrassed for.</div>

               
            </div>
                      <div id="komment5ef96b96465e2">
              <h4>
                <a href="#komment5ef96b96465e2">2020-06-29 06:18:30</a>
                by gnusosa:
              </h4>

              <div>The two other books that are absolute garbage are Code Complete and The Clean Architecture books. I wouldn&#39;t recommend them at all. Thanks for creating a counter argument to all the people that create dogma out of this book.</div>

               
            </div>
                      <div id="komment5ef975e147ed9">
              <h4>
                <a href="#komment5ef975e147ed9">2020-06-29 07:02:25</a>
                by Daniel:
              </h4>

              <div>What is your definition of a data structure? I started with Pascal in 1991 and my definition matches Martin&#39;s. I do agree with your conclusion about Martin&#39;s work however.</div>

               
            </div>
                      <div id="komment5ef97fa169a9c">
              <h4>
                <a href="#komment5ef97fa169a9c">2020-06-29 07:44:01</a>
                by tomjakubowski:
              </h4>

              <div>I recommend The Practice of Programming by Kernighan and Pike, despite many of their publicly stated opinions on the subject. I would add that the &#34;hardware state&#34; DSL would actually be good if it were also used in places other than tests, for example as a short state representation for debugging in logs, or for setting state in an emulator or test rig.</div>

               
            </div>
                      <div id="komment5ef981ac62c94">
              <h4>
                <a href="#komment5ef981ac62c94">2020-06-29 07:52:44</a>
                by heldev:
              </h4>

              <div>The book as you pointed out has issues. But not sure that there is an option to stop recommending it. Yes there is Code Complete  but it’s hard to sell because of the size and style. It’s a great book and I would recommend it to people who want/can read books. It explains everything, not dogmatic, has academic foundations, but most of developers want short and simple ready to use solutions they are not going to read it.
So if you are interested in improving overall code quality Clean Code is still “thewirecutter’s choice for most of the people “ and Code Complete is a memorable mention “the best ... money can buy for advanced users”</div>

               
            </div>
                      <div id="komment5ef98732095e7">
              <h4>
                <a href="#komment5ef98732095e7">2020-06-29 08:16:18</a>
                by Maksym:
              </h4>

              <div>Another recommendedation for A Philosophy of Software Design by John Ousterhaut. Its scope is intentionally limited to issues directly related to design, but on those it really shines. It also has a high density of insights per page, which I&#39;ve found not to be the case in several other similar books.</div>

               
            </div>
                      <div id="komment5ef987583eaad">
              <h4>
                <a href="#komment5ef987583eaad">2020-06-29 08:16:56</a>
                by ALB:
              </h4>

              <div>An excellent alternative is John Ousterhout&#39;s &#34;A Philosophy of Software Design.&#34; A concise, brilliant book  that has a lot of implementation detail that is thought-through thoroughly and presented intelligently.</div>

               
            </div>
                      <div id="komment5ef9922207996">
              <h4>
                <a href="#komment5ef9922207996">2020-06-29 09:02:58</a>
                by FeepingCreature:
              </h4>

              <div>I can&#39;t find the source, but there&#39;s a quote going around about some other book along the lines of &#34;Where it is true, it&#39;s trivial; where it is nontrivial, it&#39;s wrong.&#34;</div>

               
            </div>
                      
                      <div id="komment5ef9a4789921e">
              <h4>
                <a href="#komment5ef9a4789921e">2020-06-29 10:21:12</a>
                by TZ:
              </h4>

              <div>I reread your breakdown of the FitNesse code example a few times and I felt less and less generous about the analysis each time. Here&#39;s two and half questions:

1) If private fields are NOT to be considered implicit arguments to every private method, what exactly are they for? (And if they should not be modified, why would they be anything other than &#39;final&#39;?)

2) Why do you consider Martin&#39;s definition of side-effect, which speaks of &#39;global state&#39; and &#39;unexpected changes&#39; to include changes to private members of the class in functions that document those changes via their signature?

You could answer those uncharitably and make Uncle Bob look bad, or you could answer them charitably and then his code makes sense. 

I also have to say I don&#39;t understand how &#39;illegible trash&#39; is remotely an appropriate description. This is as good as just about anything I&#39;ve seen in actual production work in 10 years. It&#39;s extremely readable and quite testable. There are nits to pick (and you&#39;ve done an excellent job of that), but for some part of those at least I feel like they&#39;re to be picked with 2008 Java API and coding standards rather than the author.

I can&#39;t see that reading this book would be a net negative for 95% of people writing OO code. If you also don&#39;t know of a better book either, I&#39;m stumped as to why you&#39;d stop recommending it.

Finally, it looks to me like there&#39;s people out to get Uncle Bob cancelled for not being on-board with a certain political invasion of software that&#39;s going around at the moment (you can already see a comment calling him &#39;a terrible human&#39;), so I&#39;m somewhat suspicious of ulterior motives here. If that&#39;s not your intent, my apologies. 

I did like this article in general and found it to be plenty insightful, so I&#39;d love to read more from you.</div>

               
            </div>
                      <div id="komment5ef9af4f81c23">
              <h4>
                <a href="#komment5ef9af4f81c23">2020-06-29 11:07:27</a>
                by BobStannerz:
              </h4>

              <div>Clean code is a very useful book and will be helpful to 99% of Junior devs out there. You want to argue that parts of it (or code examples) are less good, do it, but if you expect to agree 100% with 400 pages of material to classify a book as &#34;good&#34; or &#34;useful&#34; you are misguided.

Its principles are mostly solid. We are developers, not toddlers to be spoon fed, read it and use critical thinking to decide what to keep and what to throw away. You would be hard pressed to find another books with such a good ration of keep / throw.

So is it time to stop recommending it, absolutely not. Are there other books out there that outline the same principles more or less, sure.

I will not go into the politics, because judging a book and ideas based on the creators political ideas is idiotic. Attack the ideas not the person.</div>

               
            </div>
                      <div id="komment5ef9ba0a5d411">
              <h4>
                <a href="#komment5ef9ba0a5d411">2020-06-29 11:53:14</a>
                by Sander Vermeer:
              </h4>

              <div>I think the idea of clean code is ridiculous. Code should simply be straightforward. A common pitfall is over-engineering, where the code is made more complicated than needs to be. 

But I see this in every aspect of programming, where people spend hours in creating a build file (Cmake etc.), creating UML diagrams, pre-defining API&#39;s, but also create unnecessary functions and classes (&#39;I might need that later on&#39;) etc. etc. Which honestly is just a waste of time.
Since programming is an inherent iterative process, code should be written as such. The general idea is simple; create a quick and dirty solution for the problem at hand. Than, refine the code so it&#39;s more reusable, more readable, more testable. More often than not, the API and data structures needed to solve that problem naturally emerge. Also, because the code was developed bottom up, any oversights or over-complications are easily avoided.

Oh and what most people lost over time is the ability to think about programming as the transformation of data. In game development for instance, every game is essentially 1) handle user input, 2) generate images and sound. Of course there are thousands of steps in between (you need to simulate some system/world, load assets from disk, populate the world, calculate animations, create a rendering pipeline), but every step is still the manipulation of data into a desired result. And I think that way of reasoning about your code is lost when OOP became the defacto paradigm.</div>

               
            </div>
                      <div id="komment5ef9d6785b9b0">
              <h4>
                <a href="#komment5ef9d6785b9b0">2020-06-29 13:54:32</a>
                by Paddy3118:
              </h4>

              <div>I gave up on print, and read copious blog posts on methodology. Many of them, as does this, comment on printed works, but you get much more real life views and a feel for those that are trying to buy-in and those that have a way that works for them.

On your specific comments, I would reject the book if I opened it to find it put 50 character identifiers in a simple prime number generator. 

Thank you so much for your well written critique. I enjoyed it, (although that could be mostly down to agreeing with you). :-)</div>

               
            </div>
                      <div id="komment5efa1702e1f83">
              <h4>
                <a href="#komment5efa1702e1f83">2020-06-29 18:29:54</a>
                by Elf M. Sternberg:
              </h4>

              <div>The thing that drives me absolutely crazy about Martin&#39;s approach is his almost religious insistence that one not &#34;choose a database&#34; before writing code. The relational algebra is one of the most important algorithms of the 20th century, and yet Martin wants you to write and manage your own relationships in the code you write yourself. To me, writing your own relational management code when you have a perfectly solid enforcement mechanism already present is programmatic malpractice.

The other thing that I find infuriating is that I&#39;ll run into people who insist &#34;no frameworks!&#34;  Martin says that your code shouldn&#39;t be about Javabeans or Django, it should be about what it&#39;s about: if you&#39;re writing a payroll app, the app&#39;s repository should say &#34;payroll!&#34;  Which is great advice.  But every time I&#39;ve looked over an application written to &#34;clean code&#34; standards, I see folders labeled &#34;domain,&#34; &#34;services,&#34; &#34;use_cases,&#34; &#34;gateways,&#34; &#34;adapters.&#34;  I call this &#34;Writing to the Clean Code Framework,&#34; because that&#39;s exactly what it is.</div>

               
            </div>
                      <div id="komment5efa2bc6c7130">
              <h4>
                <a href="#komment5efa2bc6c7130">2020-06-29 19:58:30</a>
                by Hamled:
              </h4>

              <div>One thing I remember from watching the old SICP lecture videos was this idea that you should look at your code as defining a new language, and factor your code with functions which are the most useful terms in that language. Pretty basic advice I suppose, but it feels relevant to what Martin is talking about in this book. If you factor your code into functions that are minimal but necessary, you can provide clarity through both the structure and explicit naming of meaningful concepts/actions.

However, based on these examples it seems like Martin has perverted that idea quite a bit. He&#39;s taken this core of a good idea and morphing it into an odd approach to self-documenting code: instead of writing a comment next to every few lines, you put it into a function named the same as what that comment would have been.

Of course, the commenting style is noisy but broadly innocuous. Doing the same with factoring instead ends up implying many things about the code that are orthogonal to the original goal of documentation. Basically zero of these tiny functions he&#39;s created in these examples are called in multiple places, for example. And of course it&#39;s throwing away the point of abstraction if you use a naming convention that seeks to encompass every detail of the unit being named.

I think his prime number generator example contains another great example of these problems, not mentioned in the post. His code for checking whether a candidate is &#34;a multiple of any previous prime factor&#34; actually has side-effects despite being named like a &#34;query&#34; function in his terminology. Not only that, the side-effect is modifying an array while that array is being iterated. This is probably just how a prime sieve works (IDK), but it&#39;s far from obvious that is what&#39;s going on because the mutative function is multiple calls away from the function with the loop.

I wonder how much Martin has been subject to code reviews throughout his career.</div>

               
            </div>
                      <div id="komment5efafadeb5f96">
              <h4>
                <a href="#komment5efafadeb5f96">2020-06-30 10:42:06</a>
                by George Bellarious:
              </h4>

              <div>I think there&#39;s a collision between OO and FP thinking. Everything about the FP Kool-Aid is counter to OO ideas:

1) Focus on the data and its transformations (not the messages between objects).

2) Don&#39;t mutate (without mutation, objects just become bags of functions).

3) Pass in everything you need (as a commenter above said, that defeats the whole purpose of an object&#39;s properties).

I think the two camps are incompatible, even though some OO ideas seem to be tending towards FP&#39;s ideas. 

OO damaged my brain, FP seems to be restoring it :)</div>

               
            </div>
                      <div id="komment5efb01247087d">
              <h4>
                <a href="#komment5efb01247087d">2020-06-30 11:08:52</a>
                by Nico:
              </h4>

              <div>Thanks for this great rebuttal to Martin&#39;s views. I&#39;ve seen too many people holding this book as a state-of-the-art reference on how to write code.

For me the main issue I see with his approach is his obsession of having zero-comment code. I find this crazy, as it leads to these myriads of weirdly named methods you describe, and end up making the code absolutely unreadable. Both of the example you gave would be so much more understandable as a couple of well-commented methods.

Sure, comments are bad if they&#39;re not looked after when you are modifying your code. But I suppose the same can be said about renaming all these 50-character long identifiers littered in Martin&#39;s code!

As another commenter put it, this book is still commendable for making people aware that the way you write code matters. Apart from that, it&#39;s pretty much garbage.</div>

               
            </div>
                      <div id="komment5efb0bfdb95cf">
              <h4>
                <a href="#komment5efb0bfdb95cf">2020-06-30 11:55:09</a>
                by Matthew Harris:
              </h4>

              <div>OK that was a tough read as it was a transformative book for me, but I can&#39;t argue with the points you have raised.&lt;br/&gt;
&lt;br/&gt;
ps, I had to google the answer to the captcha...</div>

               
            </div>
                      
                      <div id="komment5efb2403c7609">
              <h4>
                <a href="#komment5efb2403c7609">2020-06-30 13:37:39</a>
                by Chris Jenkins:
              </h4>

              <div>What is your definition of a data structure and now does it differ from Bob Martin&#39;s? From my perspective, I like the definition &#34;Data structures expose their data and have no meaningful functions&#34; as a way of distinguishing the way that data structures are used in functional programming from the way that objects are used in OO.</div>

               
            </div>
                      <div id="komment5efb3501e33a9">
              <h4>
                <a href="#komment5efb3501e33a9">2020-06-30 14:50:09</a>
                by Christian Clausen:
              </h4>

              <div>Very interesting read. Like many others I found Clean Code to be enormously helpful when I read it, and I still love the &#34;same abstraction&#34; smell which you also point out. I think there is a lot of good in it, and it is older than most software ever gets. 

As it happens I am writing a book with the specific purpose of giving junior developers a quick practical start on code smells and refactoring. It is not finished yet, but you can still check it out; it is called Five Lines of Code (https://www.manning.com/books/five-lines-of-code). As you can guess from the title, I agree with Uncle Bob that smaller methods are easier to understand, but mostly I use it to force people to refactor. If you check it out I would love you hear your thoughts.</div>

               
            </div>
                      <div id="komment5efb5c737a8fc">
              <h4>
                <a href="#komment5efb5c737a8fc">2020-06-30 17:38:27</a>
                by Sam J M:
              </h4>

              <div>Back when I was a young coder many moons ago I tried my damnedest to study and practice what uncle Bob was preaching. All my colleagues were raving about uncle Bob&#39;s masterpieces. I thought I was deficient for not being able to come to terms with and accept the folksy uncle&#39;s gospel truth.  
  
Working in a company designing and producing embedded systems and controllers drilled into my psyche the importance of clear requirements, and most of the errors we encountered were a result of imprecise requirements. This is something uncle Bob doesn&#39;t bother about, instead, he goes on about craftsmanship and professionalism.   
  
Later when I moved to larger software projects, the best ones were those that were readable, unassuming, well commented, and didn&#39;t go crazy over some religious doctrine of code styles.   
  
Uncle Bob also conveniently ignores the engineering aspect of large projects with multiple distributed teams working across different timezones and cultures and the multitude of challenges they bring. Most code is not written by &#39;craftsmen&#39; who follow a codestyle religion. A lot of requirements reviews, design reviews, and so on...
  
I recently heard him talk about some software project he had worked for some sort of content management, where he went on to say the database was an afterthought and unimportant. I lost all respect for the guy after that.</div>

               
            </div>
                      <div id="komment5efb5dcfb5521">
              <h4>
                <a href="#komment5efb5dcfb5521">2020-06-30 17:44:15</a>
                by MH:
              </h4>

              <div>After reading almost a hundred books on programming over the last several years, I still recommend &#34;Clean Code&#34; as my favorite. As a new developer I didn&#39;t learn in school to keep methods simple and names readable. The emphasis the book places on those two things is worth the price alone.</div>

               
            </div>
                      <div id="komment5efb65e82956e">
              <h4>
                <a href="#komment5efb65e82956e">2020-06-30 18:18:48</a>
                by AstroMan:
              </h4>

              <div>Responding to MH&#39;s comment about keeping names readable, Uncle Bob&#39;s own code is the antithesis of this commandment that he preaches. 
  
Anyway, he always gave me creepy vibes. Search for his ITkonekt 2019 speech on your favorite video portal, and you can see him feeling up two ladies on stage for two whole minutes at the start of the video.</div>

               
            </div>
                      <div id="komment5efb68b4b0df1">
              <h4>
                <a href="#komment5efb68b4b0df1">2020-06-30 18:30:44</a>
                by waitingForTheStorm:
              </h4>

              <div>When I was in university (back when the dinosaurs ruled the earth), required reading was The Elements of Programming Style by Kernighan and Plauger.  Forty one years of active software development, and that monograph still occupies a prominent spot on my bookshelf.  I favor a style that is based on a top-to-bottom clear and logical progression of statements, using loops and select/case (or equivalent) elements that are designed to reduce the cyclomatic complexity of the code.  My primary rule is never to enforce policy at a point too deep in the hierarchy of logical functions.  I avoid side effects, even in loop controls, and stay away from overly complex idioms.</div>

               
            </div>
                      <div id="komment5efb6e92da0f5">
              <h4>
                <a href="#komment5efb6e92da0f5">2020-06-30 18:55:46</a>
                by Chance:
              </h4>

              <div>I think this article is mostly spot-on.

However, the bit about data-structures vs objects might be pedantic in a way that misses the forest for the trees and subtracts from an otherwise excellent set of observations.

Many languages giving you operational functionality with the structures &#34;for free&#34; doesn&#39;t really change what the &#34;structure&#34; is. And in fact, even if you use a custom-type in your structure, it doesn&#39;t turn it into an object. The real &#34;structure&#34; is just the what. The accompanying operational functionality is just why you&#39;ve chosen using that type over whatever others.

Sure, you can go implement your PrimeAddressedOnlyLinkedList &#34;data-structure&#34;. I&#39;d argue that your implementation code for this new type is not *really* a &#34;data-structure&#34; at all, it&#39;s obviously a new object.

However, an instance of your new type is totally a &#34;data-structure&#34;.</div>

               
            </div>
                      <div id="komment5efb6ee75209a">
              <h4>
                <a href="#komment5efb6ee75209a">2020-06-30 18:57:11</a>
                by Jay:
              </h4>

              <div>You point out that the first example (SetupTeardownIncluder) is filled with side effects, but it isn&#39;t. Calling the static methods that the class exposes doesn&#39;t change the state of such class. It creates a new object, and calls a method to it. These methods are idempotent, and everything is the same after the caller calls SetupTeardownIncluder.render().</div>

               
            </div>
                      <div id="komment5efb7a40835f3">
              <h4>
                <a href="#komment5efb7a40835f3">2020-06-30 19:45:36</a>
                by Christoph:
              </h4>

              <div>For new Java developers I can recommend the book Java by comparison, especially for students.

I think that clean code is a more theoretic take on the problem. In practice there are things you can&#39;t avoid and some of the things from Clean Code are good as inspiration</div>

               
            </div>
                      <div id="komment5efb829e772d4">
              <h4>
                <a href="#komment5efb829e772d4">2020-06-30 20:21:18</a>
                by Chris:
              </h4>

              <div>Unit Testing Principles, Practices, and Patterns. Though its name suggests it&#39;s about unit testing, it&#39;s actually about so much more than this, including clean code and clean architecture. We are going through this book at work right now, and it incites a lot of discussions.</div>

               
            </div>
                      <div id="komment5efb924406191">
              <h4>
                <a href="#komment5efb924406191">2020-06-30 21:28:04</a>
                by Mike:
              </h4>

              <div>I think now I know the source of all this bullshit in our project. I see the same code every day: lots of side effects, small and unclear functions, dozens of structures to wrap arguments... 
The man who writes it - prays for this book and often says it is the best book ever.</div>

               
            </div>
                      <div id="komment5efb9ee68be3f">
              <h4>
                <a href="#komment5efb9ee68be3f">2020-06-30 22:21:58</a>
                by Mark Smeltzer:
              </h4>

              <div>&#34;Refactoring to Patterns&#34; by Joshua Kerievsky.

While the book contains lots of highly tactical chapters on how to apply specific patterns to messy code, the book is primarily about what not to do: viz., taking patterns too far.

His chapters on doing TDD right is gold. Best stuff written on the subject at time of print. I also haven&#39;t bought any new books on the subject since, but Kerievsky&#39;s method should stand the test of time.</div>

               
            </div>
                      <div id="komment5efba27e6f3b4">
              <h4>
                <a href="#komment5efba27e6f3b4">2020-06-30 22:37:18</a>
                by Hogan:
              </h4>

              <div>Thank you for this review. I feel the same way, but couldn&#39;t put it in words like you did.</div>

               
            </div>
                      <div id="komment5efc8fae7daff">
              <h4>
                <a href="#komment5efc8fae7daff">2020-07-01 15:29:18</a>
                by hehehe:
              </h4>

              <div>What&#39;s your thoughts on You Don&#39;t Know JS by Kyle Simpson et al?

I think a key benefit it&#39;s got is it&#39;s somewhat a living document, as each iteration is written collaboratively with open source contributors.</div>

               
            </div>
                      <div id="komment5efccc0c76f78">
              <h4>
                <a href="#komment5efccc0c76f78">2020-07-01 19:46:52</a>
                by Rastislav Svoboda:
              </h4>

              <div>watch https://www.youtube.com/watch?v=l-gF0vDhJVI
approx @1:32:20 and later
... but what you will find in those case studies is how we break the rules, because we always break the rules, the case studies show the pragmatic application of the rules and we try to hold to those rules as much as we can ...</div>

               
            </div>
                      <div id="komment5efe5f9e6e790">
              <h4>
                <a href="#komment5efe5f9e6e790">2020-07-03 00:28:46</a>
                by kpreid:
              </h4>

              <div>The test code you criticize.
{ assertEquals(“HBchL”, hw.getState()); }
does have one practical advantage over the set of assertFalse and assertTrue it is replacing: it lets you see the entire set of outputs of the controller in the test failure output, whereas the other version gives you only one of the outputs, unless you either run it under a debugger or change the order of the asserts to make another one fail first. 

That said, if I were spending time on engineering the tests, what I&#39;d do is write test helper methods for the assertions so that when *any* of those boolean assertions fail, *all* of the state is printed (which can then be less cryptic than “HBchL”). Or, use a test framework that doesn&#39;t abort execution as soon as a single assertion fails, but presents a list of all of the failures.

Another common example of unhelpful test failure I have seen is {
  assertEquals(2, list.size());
  assert something about list.get(0);
  assert something about list.get(1);
} where if the list is not the expected size, you have no information about what it actually contained.

I have found that in complex code, test failures that explain what went wrong in detail are very helpful because if you broke something *that you didn&#39;t expect to break* — that might be a distant dependent of the thing you changed — then the test having a good description of the problem means you can proceed like &#34;oh, I didn&#39;t realize I need to handle that case—there, done&#34;. instead of having to fire up the debugger or reading lots of code that you weren&#39;t intending to be working on.</div>

               
            </div>
                      <div id="komment5efe87097adb7">
              <h4>
                <a href="#komment5efe87097adb7">2020-07-03 03:16:57</a>
                by Mike Bridge:
              </h4>

              <div>You&#39;ve made several mistakes here.  Briefly:

- A boolean flag argument is usually a bad idea whether you give it a label or not.  The point---which you seem to acknowledge and then ignore---is that a boolean flag *may* indicate that you have two paths through your code.  Similarly, two boolean flags *may* mean that you have four.  This has nothing to do with the naming of the boolean argument or having to do extra work to navigate the code.

- Martin is *not* saying FitNesse example is &#34;ideal&#34; code.  His goal in chapter 3---still early in the book---is to give the high-level view of the technique for making garbage code into humanly-understandable and maintainable code by refactoring, with the help of some rules-of-thumb.  Really, this is an introduction to the whole point of the book.  Sure it&#39;s not perfect, but he&#39;s not claiming it is.

- It sounds to me like you&#39;re missing the big picture when you say there&#39;s a &#34;missing fourth step&#34; in TDD.  He *doesn&#39;t* say that you break down the problem into abstractions first, then write code, then test it---he&#39;s saying it&#39;s the opposite: you write tests, then write code, then refactor it, then keep repeating the process until you have a good abstraction.  Your first iteration may well be a mess, but he&#39;s saying that that doesn&#39;t matter---you can work on finding better abstractions once the code works.  In other words, it&#39;s much harder to write good code if you try to figure it all out in your head out a-priori.

- I&#39;m not sure how you define &#34;Data Structures&#34;, despite the link to WikiPedia.  How is this different from Martin&#39;s definition?

- And *yes*, set2AsFirstPrime and smallestOddNthMultipleNotLessThanCandidate make perfect sense to me.  Do you have a better suggestion?  &#34;What the heck?&#34; doesn&#39;t give me any insight.

- And there are perfectly good arguments for using wildcard imports.</div>

               
            </div>
                      <div id="komment5efee8bbc6db1">
              <h4>
                <a href="#komment5efee8bbc6db1">2020-07-03 10:13:47</a>
                by Gary Woodfine:
              </h4>

              <div>In my experience Clean Code is a lot like teenage sex.  Everybody brags about it, but very few are actually doing it and those that do invariably lead to accidents.

I still think, Clean Code has relevance, and is still a good starter book for many, especially for those who want to take their coding abilities to the next level.

Is it a perfect book, probably not,  there are a number of subjective opinions, but that is to be expected  on a mostly subjective topic.

As with most Software Development books, it provides a foundation to work from.  The rest is down to your continual learning, adaptation and implementation.</div>

               
            </div>
                      <div id="komment5eff0551644c4">
              <h4>
                <a href="#komment5eff0551644c4">2020-07-03 12:15:45</a>
                by ingvar:
              </h4>

              <div>You write:
  Outside of a book, do we still read code from top to bottom? Well, maybe some of us do.

I certainly do, every time I am doing a code review. I&#39;d even argue that you should start with the lowest level, then go to more and more abstract functions as you go, because that sets the reviewer&#39;s mind up to have a chance of going &#34;um, why?&#34; in a way that doesn&#39;t require scrolling all over the place (yes, in theory names should be descriptive but in theory, theory and practice are the same).</div>

               
            </div>
                      <div id="komment5effdaf300952">
              <h4>
                <a href="#komment5effdaf300952">2020-07-04 03:27:15</a>
                by Dave (yet another Software Crafter):
              </h4>

              <div>Another campaign to literally take someone down.  Love this profession don&#39;t you all?  I wonder what it&#39;d be like working with you blog poster.  I can&#39;t imagine it&#39;s a very positive ride.

Clean Architecture is great, what are you talking about?  I&#39;ve even applied the advice of  Clean Architecture before his book came out (which is basically hexagonal &amp; other solid fundamentals tied together) through the years many big applications I&#39;ve worked on.  

Written in Java? so what!  A ton of other books were written in Java from Martin Fowler, Kent Beck, Micheal Feathers and so many that a ton of us in our profession still reference and probably always will.  The ideas don&#39;t die in those books, and it&#39;s up to you to practice and try to apply them elsewhere.  Software doesn&#39;t write itself.

This post was a waste of my time, and I hope others see it for what it really is...chow.</div>

               
            </div>
                      <div id="komment5f00a26fb7045">
              <h4>
                <a href="#komment5f00a26fb7045">2020-07-04 17:38:23</a>
                by mwchase:
              </h4>

              <div>To people not sure about the data structure definition, my take on it is that anything beyond what can be expressed entirely as sum and product types is going to have some kind of invariant that needs to be maintained. For example, if you have a heap, you need to maintain the heap invariant, otherwise you don&#39;t get correct results.

So, if &#34;something that requires invariants be maintained&#34; is an inhabited kind of data structure, then it cannot be the case that all data structures expose their implementation details publicly.</div>

               
            </div>
                      <div id="komment5f03868264a3b">
              <h4>
                <a href="#komment5f03868264a3b">2020-07-06 22:16:02</a>
                by wwise:
              </h4>

              <div>Martin is mixing up data types and data structures. The main difference between a stack and a queue is the operation for removing items.

The operations are part of the definition of a queue or a stack. What he&#39;s calling an object is actually a data structure. It&#39;s just organized differently in an OO language than in a procedural (or functional, I suppose) language.</div>

               
            </div>
                      <div id="komment5f0437e328679">
              <h4>
                <a href="#komment5f0437e328679">2020-07-07 10:52:51</a>
                by ReadMe:
              </h4>

              <div>U dont recommend the book because of author&#39;s random political point of view on a social network. We dont recommend ur website and org due to ur mindset mixing our innocent programming industry with political world.</div>

               
            </div>
                      <div id="komment5f048a9e57b94">
              <h4>
                <a href="#komment5f048a9e57b94">2020-07-07 16:45:50</a>
                by Mariusz Cyranowski:
              </h4>

              <div>This book is quite hard to comprehend because of many ambiguous topics already mentioned in the article as well as in comments. The book is a good read though, but I think there are better ways to fight the complexity of software solutions then practicing patterns and TDD. This book is not a bible of programming but just another piece from well known agile evangelist.</div>

               
            </div>
                      <div id="komment5f04e52f22e88">
              <h4>
                <a href="#komment5f04e52f22e88">2020-07-07 23:12:15</a>
                by Mario:
              </h4>

              <div>You do good points! 

I must say that I use his book for teaching, but I let my students clear that it is a fully opinionated material. There are good advices? yes, but the rules he proposes are far to follow and may deviate the programmer from the goal to solve just because will be worried on the shape and not the content.
I compare the content with my personal rules like “review any code that is 2 times pressed the page down key” or “if you use a boolean in the parameters check if you are mixing logic”. I think his book is valid as reference and disussion. Then let every organization and programmer build their best practices.</div>

               
            </div>
                      <div id="komment5f0528972dbc3">
              <h4>
                <a href="#komment5f0528972dbc3">2020-07-08 03:59:51</a>
                by bdan:
              </h4>

              <div>Not sure what is worse, the book or some of the comments here. 

Thanks for taking the time to write this! I really think developers need to unite and start a GoFundMe for the author and get him to retire, his heart is in the right place but no one has done more harm to our profession than him...</div>

               
            </div>
                      <div id="komment5f058bd30e80d">
              <h4>
                <a href="#komment5f058bd30e80d">2020-07-08 11:03:15</a>
                by John Laptop:
              </h4>

              <div>While your review does make some fair points, I can&#39;t help but getting the feeling that you rather have a beef with Martin.</div>

               
            </div>
                      <div id="komment5f059fba9326f">
              <h4>
                <a href="#komment5f059fba9326f">2020-07-08 12:28:10</a>
                by Tom:
              </h4>

              <div>Odd that some people are reading politics into this review. It seems wholly fair to me, as a clear opinion piece that objectively analyses the subject at hand. Is it so hard to believe that someone could have a different opinion on something as divisive as code style without having a hidden agenda?

Just to try to understand the situation, I read Martin&#39;s blog post &#34;Thought Police&#34; mentioned above and found the idea he expressed there to be entirely reasonable and respectable and most importantly unrelated to his book and this review of it.</div>

               
            </div>
                      <div id="komment5f05b5d92e537">
              <h4>
                <a href="#komment5f05b5d92e537">2020-07-08 14:02:33</a>
                by Carlos Saltos:
              </h4>

              <div>Please find a modern approach here -&gt; https://www.deconstructconf.com/2019/dan-abramov-the-wet-codebase very valuable</div>

               
            </div>
                      <div id="komment5f0604a0d0279">
              <h4>
                <a href="#komment5f0604a0d0279">2020-07-08 19:38:40</a>
                by Arthur:
              </h4>

              <div>1. Feathers: Working Effectively with Legacy Code&lt;br/&gt;
2. Khorikov: Unit Testing Principles, Practices, and Patterns</div>

               
            </div>
                      <div id="komment5f0649db74196">
              <h4>
                <a href="#komment5f0649db74196">2020-07-09 00:34:03</a>
                by qntm:
              </h4>

              <div>A few people have recommended Code Complete as a replacement for Clean Code. I think it&#39;s a better book, but I&#39;d still be hesitant to recommend it.

I don&#39;t have anywhere near as much to say about Code Complete because I haven&#39;t read it cover to cover, because it&#39;s a monster. I have the first edition, which is 850 pages long. That in itself is well worth considering. But the main thing about Code Complete is that even if all the information in it was complete and correct at the time of going to press, it&#39;s really quite dated right now. Even the second edition is from 2004, *predating* Clean Code. As I say, this is just a standing problem which almost all programming books have. Fifteen years is a *long* time in software development.

There are some other strong recommendations in this thread, but these are books which sadly I have not read (I spend far too much time writing and not enough time reading). That means I can&#39;t recommend them myself. For what it&#39;s worth, on the basis of what people have said here and elsewhere, these are the programming books which I&#39;m most likely to read next:

* John Ousterhout, A Philosophy Of Software Design (2018)
* Michael Feathers, Working Effectively With Legacy Code (2004, oof)</div>

               
            </div>
                      <div id="komment5f071d476e46d">
              <h4>
                <a href="#komment5f071d476e46d">2020-07-09 15:36:07</a>
                by Arthur:
              </h4>

              <div>And don&#39;t get me started about the Clean Code video series.  At the suggestion of a consultant our development team watched the series.  The presentation styke was extremely grating to me.   To summarize: that was an expensive waste of team time.</div>

               
            </div>
                      <div id="komment5f0a5b63e93d5">
              <h4>
                <a href="#komment5f0a5b63e93d5">2020-07-12 02:37:55</a>
                by Staged:
              </h4>

              <div>Much of this evangelizing really demonstrates a foundational flaw I have seen: developers are really bad at reading code. Every time I have to press f12 to know what is going on my code, is the mental equivalent of somebody taking my headphones off and starting a conversation with me. That&#39;s not to say that functions or splitting out work into other packages is bad : but it is to say that we should have good reason to make us turn the page of this choose-your-own-adventure code.  If a method is called once and is one line long, it should be inline code until there is a reason to break it out. Additionally, we should try to avoid putting verbs into nouns when we can - it creates another layer of separation before we need it.</div>

               
            </div>
                      <div id="komment5f0eaa71baab9">
              <h4>
                <a href="#komment5f0eaa71baab9">2020-07-15 09:04:17</a>
                by gagga:
              </h4>

              <div>I think what would really improve this book is a Marxist version of it.</div>

               
            </div>
                      
                      <div id="komment5f1a8abe86f61">
              <h4>
                <a href="#komment5f1a8abe86f61">2020-07-24 09:16:14</a>
                by FeepingCreature:
              </h4>

              <div>FP and OOP are totally compatible. This is approximately how we do it where I work:

FP for everything small. Pure data is pure, and manipulated by pure methods. Immutable data structures, return instead of ref, recreation rather than modification. No OOP here.

Then, the application code has separated areas of responsibility. These are classes that may hold state, and mutate it by business-level methods. But each set of data is only stored and mutated in one class. Anything that can be mutated is private, and no mutable references to it are handed out.

Then, OOP is used lightly, mostly just to separate interfaces and implementations between different areas of the codebase, and for bits of dependency injection to avoid dependency cycles. So code reuse is mostly achieved by composition rather than inheritance. The FP routines manipulating data basically never see any OOP themselves.

Also, the example unittest would compare a state struct with cleanly labeled flags. Thanks to a diff routine, the mismatching flag would be highlighted in red/green. :)

That is to say: none of the examples in this post would pass code review.</div>

               
            </div>
                      <div id="komment5f44b03b29036">
              <h4>
                <a href="#komment5f44b03b29036">2020-08-25 08:31:23</a>
                by Virgo47:
              </h4>

              <div>I don&#39;t regret reading Clean Code and it helped me to progress at the time. I don&#39;t remember exactly whether I agreed with everything, it wasn&#39;t by far the first book I read. I&#39;m not sure I&#39;d recommend it today for its size and old-style Java (both version-wise and paradigm-wise). John Ousterhout&#39;s book A Philosophy of Software Design was mentioned couple of times - I have it, read it and it&#39;s great counterbalance to Clean Code + it&#39;s great book on its own. I have no idea how it is to read it in vacuum. I&#39;d not rely on a single book. Is Clean Code harmful nowadays? I don&#39;t know. If it was the only book around, I&#39;d still recommend it to a junior and as a mentor took over from there.</div>

               
            </div>
                      <div id="komment5f4ce3d073170">
              <h4>
                <a href="#komment5f4ce3d073170">2020-08-31 13:49:36</a>
                by Frank:
              </h4>

              <div>You do not recommend CC but give no alternatives? You criticize some snippets but again give no better solutions. Come on man!</div>

               
            </div>
                      <div id="komment5f528309b5409">
              <h4>
                <a href="#komment5f528309b5409">2020-09-04 19:10:17</a>
                by Ed:
              </h4>

              <div>Thank you for this blog post.

I have to agree on recommending:
A philosophy of software design by John Ousterhaut.

Short and to the point, filled with practicable usable advise that can be applied even if one has little experience.</div>

               
            </div>
                      <div id="komment5f5389529bae4">
              <h4>
                <a href="#komment5f5389529bae4">2020-09-05 13:49:22</a>
                by Stefan Houtzager:
              </h4>

              <div>John Ousterhout&#39;s &#34;A Philosophy of Software Design&#34; looks interesting : https://lethain.com//notes-philosophy-software-design/  Take into account some sidenotes by readers: https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201</div>

               
            </div>
                      <div id="komment5f5f8635c4713">
              <h4>
                <a href="#komment5f5f8635c4713">2020-09-14 16:03:17</a>
                by Rob Lang:
              </h4>

              <div>Extremely useful book is Martin Fowler&#39;s Refactoring. I dip into it on a regular basis.</div>

               
            </div>
                      <div id="komment5f60128347231">
              <h4>
                <a href="#komment5f60128347231">2020-09-15 02:01:55</a>
                by Ray:
              </h4>

              <div>Frank, I would argue that if the examples are bad enough, you&#39;re better off with no examples at all, and that the prime number generator, in particular, falls into that category.

But since you want an alternative, I&#39;ve thrown together an implementation of the same function.  I&#39;ve replaced each tab with &#34;. . &#34; in hopes of preserving the formatting. We&#39;ll see how well that works. As a side note, the below code uses the simplest prime number sieve, and takes about 45 seconds to find the first 20 million primes.  The Clean Code version takes *22 minutes*.

Based on the prime number generator alone, it is *entirely* reasonable to conclude that the author knows almost nothing about writing good code.

========
import std.stdio, std.algorithm, std.range;

// generates all primes in [start,end) and returns all primes in [0,end).
// primes array must contain all primes &lt; start
uint[] grow_sieve(uint[] primes, uint start, uint end) {
. . assert(end &gt;= start &amp;&amp; start &gt; 1);
. . bool[] composite;
. . composite.length = end - start;

. . // mask multiples of existing primes over the expanded range
. . foreach (p; primes) {
. . . . // start at first multiple of p in [start,end)
. . . . for (uint j = p * (((start - 1) / p) + 1); j &lt; end; j += p) {
. . . . . . composite[j - start] = 1;
. . . . }
. . }

. . // locate primes inside the expanded range
. . foreach (i; start..end) {
. . . . if (composite[i - start]) continue;
. . . . for (uint j = i * 2; j &lt; end; j += i) {
. . . . . . composite[j - start] = 1;
. . . . }
. . }

. . // concatenate all numbers in [start, end) that aren&#39;t marked composite
. . return primes ~ iota(start,end).filter!(a =&gt; !composite[a - start]).array;
}

// Generate first n primes by successive applications of the 
// Sieve of Eratosthenes
uint[] generate_primes(uint n) {
. . const STEP_SIZE = 10_000_000;
. . uint[] primes = [ ];
. . uint start = 2;
. . for (uint end = STEP_SIZE; primes.length &lt; n; end += STEP_SIZE) {
. . . . primes = grow_sieve(primes, start, end);
. . . . start = end;
. . }
. . return primes[0..n];
}
==========

(n.b. I started to translate this into Java for easier comparison with the original, but then I remembered that no one had a gun to my head, so I stopped.)</div>

               
            </div>
                      <div id="komment5f608cea98463">
              <h4>
                <a href="#komment5f608cea98463">2020-09-15 10:44:10</a>
                by Alex:
              </h4>

              <div>@qntm: I do not agree with your reasoning about the side effects.

When citing Martin&#39;s definition of side effects the scope of your emphasis is too wide: The emphasis should be on &#34;unexpected&#34; rather than the whole sentence, because this is the most important word there.

If he really meant it the way you interpret it then the whole section about cohesion (Chapter 10: Classes) would be useless.</div>

               
            </div>
                      <div id="komment5f6234a3c060a">
              <h4>
                <a href="#komment5f6234a3c060a">2020-09-16 16:52:03</a>
                by some jerk:
              </h4>

              <div>Great blog, but it kind of drives me crazy that your content scrunched up and pushed all the way to the left on desktop.  Perhaps kill this rule, or go with a larger, vw-based value:

.page__wrapper {
	max-width: 32rem;
}

Or maybe center it:

.page__outer {
	display: flex;
	justify-content: center;
}</div>

               
            </div>
                      
                      <div id="komment5f8bfb213199f">
              <h4>
                <a href="#komment5f8bfb213199f">2020-10-18 09:21:53</a>
                by dmyp:
              </h4>

              <div>If you ask me, I&#39;d say that you understand the book too literally.  For example, when you write about side effects and short methods with zero arguments, I would say that side effects is not about changing the private fields but about doing something that is not related to what&#39;s stated in the name of the method. Say, includeSetupPages() must not touch anything that has impact on how includePageContent() works (the example is of course artificial, but I hope the idea is clear).

If you ask me about the book in general, I would definitely recommend it to newbies, but I would warn them that the book is aimed only to give you a *feeling* of how clean code should look like, it&#39;s not a set of strict rules that must be followed. E.g., I hope everyone would agree that 2 to 4 lines of code per method is almost impossible to achieve in modern projects, and may even be harmful from performance perspective (say, in C++ function calls are not free).

In my opinion, reading this book when you are a beginner in programming will plant a seed in your head and give you a basic feeling of what should feel wrong. For experienced developers, however, most likely there is nothing new there.</div>

               
            </div>
                      <div id="komment5f954a77ac1da">
              <h4>
                <a href="#komment5f954a77ac1da">2020-10-25 09:50:47</a>
                by hdx:
              </h4>

              <div>Seems many people said that the book is ok to be ambiguous or ok to just give &#34;feeling&#34; of how clean code should looks like??????
&#34;Ambiguity&#34; and &#34;Feeling&#34; which leads many people to interpreted wrongly as well as blindly follow rules like &#34;function must be short&#34; without context is just bad, and Clean Code book just produced tons of bad engineers follow those bad rules and think that they&#39;re senior.
One more aspect that I want to discuss here is, what is the good piece of code that Bob himself wrote? fitnesse?? fitnesse is just a piece of code that NO BODY using, anything else?? If ones could not write good code, how could he &#34;teaches&#34; other people to do so?</div>

               
            </div>
                      <div id="komment5faa4602cd8aa">
              <h4>
                <a href="#komment5faa4602cd8aa">2020-11-10 07:49:22</a>
                by Victor:
              </h4>

              <div>+1 not recommending &#34;Uncle Bob&#39;s&#34; books.

Too much overengineering, which in my opinion is bad style.</div>

               
            </div>
                      <div id="komment5fafe6e3eaafd">
              <h4>
                <a href="#komment5fafe6e3eaafd">2020-11-14 14:17:07</a>
                by Jim:
              </h4>

              <div>This book should only be given as a bad example.

For new programmers it&#39;s not recommended to study paradigms or patterns, because they would be learning something they are not dealing with.

For newbies it&#39;s recommended to understand how memory/cpu works and go from there to asm/C (even if just a bit), so they know what is done in higher level languages. 

By understanding how hardware works, one understands what code needs to be written for it be good. The moment you start writing by patterns, you write inefficient code and now you expect others to know the pattern as well as interpret it in same way, while hardware is much stronger point of reference.

Paradigms/patterns are like religions, while hardware is physics.</div>

               
            </div>
                      <div id="komment5fde4bc215140">
              <h4>
                <a href="#komment5fde4bc215140">2020-12-19 18:51:46</a>
                by qntm:
              </h4>

              <div>I just added an update recommending John Ousterhout&#39;s A Philosophy of Software Design as an alternative read. Many thanks to those of you who recommended it.</div>

               
            </div>
                      <div id="komment5fe6465a84602">
              <h4>
                <a href="#komment5fe6465a84602">2020-12-25 20:06:50</a>
                by Anil Philip:
              </h4>

              <div>I am reading the chapter on Successive Refinement in &#39;Clean Code&#39; and am struggling to understand what the Args class is useful for. What was the goal of the class? Does it have exactly 3 arguments in the array, d, p, l?</div>

               
            </div>
                      <div id="komment6009f2a78a6a5">
              <h4>
                <a href="#komment6009f2a78a6a5">2021-01-21 21:31:19</a>
                by Veysel Ozdemir:
              </h4>

              <div>Thank you for writing this post. 
I recommended a chapter from this book to a friend today and just wanted to skim through the chapters again, and just within 1 hour I felt so uneasy and found myself googling &#34;critisism of clean code&#34; (of course google corrected my spelling to &#34;criticism&#34; :) 
In retrospect, as I read through the chapters, I now realise how the language of the book the language of a &#34;know it all&#34; or a &#34;brilliant jerk&#34;. 
How a disagreeable mind it is the writer, sure of himself talking from the ethical high ground but unable to demonstrate his ability to apply them, let alone applicability of that high ground by at least demonstrating examples from others applying them. 
Those who talking about political views of Martin etc, I am not in the US and I don&#39;t care a bit about the politics there. 
But I care when some holy evangelist warrior endlessly argues on a piece of code in the name of &#34;clean principles&#34; to make it a less and less readable, understandable, deeply nested layered maze. 

Kudos to Carlos Saltos, in the comments, for recommending The Wet Codebase. Heard it here for the first time, really liked it. Such a great talk. I want to repeat the link: 
https://www.deconstructconf.com/2019/dan-abramov-the-wet-codebase</div>

               
            </div>
                      <div id="komment600e18592e6fd">
              <h4>
                <a href="#komment600e18592e6fd">2021-01-25 01:01:13</a>
                by G:
              </h4>

              <div>&gt; &#34;A Philosophy of Software Design&#34;

Thanks for the book recommendation. 
I was looking at its table of content and notice that the book look very oriented towards OOP.

Does anybody have a book recommendation similar to  &#34;A Philosophy of Software Design&#34;, but less focused on objects?
(Maybe more focused on imperative, functional or Data-Oriented Desing)</div>

               
            </div>
                      <div id="komment600e1bae33afc">
              <h4>
                <a href="#komment600e1bae33afc">2021-01-25 01:15:26</a>
                by qntm:
              </h4>

              <div>I have to admit that was one of the weaknesses I found in &#34;Philosophy&#34;. Still very Java-focused, still very OO-focused, very little on the topic of functional programming.</div>

               
            </div>
                      <div id="komment601a24b9423f7">
              <h4>
                <a href="#komment601a24b9423f7">2021-02-03 04:21:13</a>
                by Jamesiepoo:
              </h4>

              <div>Sam, just wanted to say thank you for all you&#39;ve done.  I got into reading your fiction back in late &#39;09, and have been reading ever since.

After I graduated in 2013, I recognized I had many misgivings with &#34;Clean Code&#34;, but not everyone took my complaints seriously.

Your breakdown has inspired so much discussion and debate amongst my peers, with many re-evaluating their long-held positions.  Thank you for presenting so clearly that which has so bugged me.  I truly appreciate it.</div>

               
            </div>
                      <div id="komment601acbf4368f0">
              <h4>
                <a href="#komment601acbf4368f0">2021-02-03 16:14:44</a>
                by pedant:
              </h4>

              <div>If this comment gets posted then well done for remembering that -1 has two square roots!</div>

               
            </div>
                      <div id="komment601e51c38e2ec">
              <h4>
                <a href="#komment601e51c38e2ec">2021-02-06 08:22:27</a>
                by Jacob Nordfalk:
              </h4>

              <div>I really HATE clean architecture!... A simple rename of a field in a recent project involved changing 32 (thirty-two!!) files, all over the place.

CLEAN makes people forget a much more important principle, namely KISS, and tempts some developers solve simple things in the most complicated manner, adding unit test and integration tests all over the place for their complicated converters and no-op code, and makes further development crawl to a halt....
CLEAN+Coroutines+Flow+whatever-is-cool-at-the-moment+heavy use of Dagger DI and 2-3 more annotation based frameworks... costs weeks for new developers to understand the code.

I am currently taking over a one-man project on a codebase with 1200 classes where 300 classes would have sufficed, as its really just a wrapper on a REST interface with no offline logic.

It is sooo CLEAN, with so many layers and modules and packages that the code is a mess for newcomers - debugging the simplest thing involves switching threads and package at least a dozen times, which the coroutines helps to obfuscate the call stack completely. The app regularly crashes, at many places, but its hard to see why....

I am looking forward to the day CLEAN is declared dead for 1-2 man projects like e.g. apps, and we can get back to KISS and getting things done</div>

               
            </div>
                      <div id="komment604c57913edfe">
              <h4>
                <a href="#komment604c57913edfe">2021-03-13 06:11:29</a>
                by Pedro Dias:
              </h4>

              <div>I agree on almost all of your examples, but I disagree with your conclusion. 

This book, to me, is great because it puts the readers mindset into creating code that is maintainable and readable by others. The code examples to me are irrelevant. The points that this book raises are pretty much all good: 
* Write code that others can understand
* Dont fill up your code with stale comments
* Structure your code in a way that makes sense
* Make sure you get value out of your automated tests

For that reason, I still recommend this book to everyone that is asking me for advice to become better developers. Not for the specifics, and I always tell them that, but for the general advice that this book has to offer.</div>

               
            </div>
                      <div id="komment608719a68cad2">
              <h4>
                <a href="#komment608719a68cad2">2021-04-26 20:51:02</a>
                by Lluis:
              </h4>

              <div>Declaring throws Exception in each and every method shows that the author has no idea how to write good Java code. I would recommend Uncle Bob to read Effective Java, specifically the chapter about exceptions.</div>

               
            </div>
                      <div id="komment60ad1d055fa23">
              <h4>
                <a href="#komment60ad1d055fa23">2021-05-25 16:51:33</a>
                by Dale:
              </h4>

              <div>I think 2-4 line functions are a fine goal, but he&#39;s picked the wrong language (Java) for it.  You&#39;ll use up 1/2 your budget by the time you get finished writing out the names of the types it&#39;s going to deal with.

When I look at these examples, all I see is &#34;private void String throws Exception return new&#34; on every other line.  There&#39;s an algorithm here, I&#39;m sure of it, but Java hides it well.

What you need is a dynamically typed language with syntactic abstraction.  Then 2-4 lines are fine.  I think Chuck Moore would be on board with this rule of thumb.  Ken Iverson might even find it excessive!</div>

               
            </div>
                      <div id="komment60ae939d048fa">
              <h4>
                <a href="#komment60ae939d048fa">2021-05-26 19:29:49</a>
                by Kazinator:
              </h4>

              <div>bool leastRelevantBookYouWillEverReadOnJavaCoding(obj)
{
   bool retVal;

   if (obj.Title() == &#34;Clean Code&#34;)
      retVal = true;
   else
      retVal = false;

   return retVal;
}</div>

               
            </div>
                      <div id="komment60d33eca62a93">
              <h4>
                <a href="#komment60d33eca62a93">2021-06-23 15:01:46</a>
                by Massive Stallion:
              </h4>

              <div>I completely disagree with Martin&#39;s politics but he&#39;s not a politician or even discussing politics in Clean Code. Computers are tools. The Nazis used them to enslave people and the Allies used advances based on Nazi technology to send them to hell. I don&#39;t like Martin&#39;s views either but I think his insights are useful for building tools to beat Republicans. Cancel the man, sure but even better take his stuff too.

You&#39;ve got a lot of criticisms sure but what&#39;s the alternative? Clean code is a book, it&#39;s not doing your job for you. Obviously not every thing is great or practical. 

Martin has plenty of detractors but they never actually present an alternative other than figure it out yourself. Even you are following his ideas but with slight modifications. 

When I see people doing the opposite of Clean code it&#39;s one class to rule them all and copy pasta everywhere. So Obviously no guidelines at all is just a terrible way back to the 90s. No thanks.</div>

               
            </div>
                      <div id="komment60df2ca2c21d2">
              <h4>
                <a href="#komment60df2ca2c21d2">2021-07-02 16:11:30</a>
                by Paul:
              </h4>

              <div>I would have to agree with this post re the code examples (as given here: I haven&#39;t read &#39;Clean Code&#39;).  However...

I do have to wonder if some of the people dissing &#39;Clean Architecture&#39; haven&#39;t really understood much of it.

I found it to be probably the most insightful book on creating clean and maintainable systems I&#39;ve read - and I&#39;ve read quite a few.  Most other books are heavy on the management aspects, or pushing a particular metholology (usually the authors, unsurprisingly), or bound up with a particular technology (and that&#39;s just *wrong*).

In contrast, in &#39;Clean Architecture&#39; Martin makes the - perhaps surprising, to some, but entirely reasonable - observation that tools, frameworks, ORMs, and the like - have *nothing* to do with architecture.  (This in itself was good to read.  I don&#39;t remember any other text making this point quite so forcefully.)

&#39;Clean Architecture&#39; actually expounds some quite fundamental, if often misunderstood, or half understood, ideas.  In particular around dependencies, DIP and where to place boundaries in a system (and what, exactly, is meant by &#39;a boundary&#39;).

It also provides some fairly unique (in my experience) insights.  To give just one example from the first part of the book: there&#39;s a rather well thought-out summary of the three main paradigms: structured, OO and functional.  It also provides good reason to believe that these may be the *only* three paradigms that will exist (because each, although we don&#39;t usually think if it this way, actually takes something *away* from the programmer).

There&#39;s much in this book about how to apply SRP, LSP, OCP and the like.  But there&#39;s also a refrain that runs though the text: protect your &#39;business logic&#39; (which is to say, your USP - the reason you are building something in the first place) from extraneous details.  To which it can be added, as the book shows, that there&#39;s a lot more that falls under &#39;extraneous&#39; than is often accounted for.

There&#39;s also no attempt in &#39;Clean Architecture&#39; follow any of the latest trends, management fads, or the like.  Rather it tries to get at what is fundamental about good software architecture, across development platforms, application domains, or - for that matter - the last 50 or so years.  It doesn&#39;t reject what has been learnt for the latest shiny tool, but rather engages, throughout, with what can be learnt from the history of our field.

In general, I found that nearly all parts of the book left me with new ways of looking at old problems, and something new to think about.

That said, this is not an easy book to read: it takes some time and reflection to map these ideas into your own work and past-experience.   It&#39;s the sort of book that rewards a second reading.  It isn&#39;t, and I don&#39;t think it was meant to be, an Architecture 101. 

(Aside, and on a practical note, it lead me to re-architect an existing system I had started on - with much better results.)</div>

               
            </div>
                      <div id="komment60fcf31ae2da5">
              <h4>
                <a href="#komment60fcf31ae2da5">2021-07-25 06:14:02</a>
                by jCalculette:
              </h4>

              <div>I would say that even today Clean Code is worth reading. As are the 2nd editions of Fowler&#39;s Refactoring and The Pragmatic Programmer. Now while the later is mostly a philosophical book about software engineering then others are essentially full blown textbooks. For example, Fowler&#39;s book has first 100 pages dedicated to the overall idea of refactoring (how, why, what) and the next 300 pages serve essentially as a reference guide. Not to mention that Fowler&#39; himself mentions that while he has mostly only included one mechanism to achieve the refactoring, it is not the one and only one.  With the Clean Code we first have to take account that it is somewhat of an &#34;older book&#34; and software engineering has advanced a lot since then. However, it does give the general ideas that one should strive for and as always, one should make up ones own damn mind about the recommendations that the book gives. An easy example, Uncle Bob recommends using wildcard imports, I do not for various reasons. And as we read opinions on the Net we can come upon those who do agree with it, and those that don&#39;t (Google&#39;s official Java guide for example). In addition, if SonarQube analyzes your project and starts saying, that one should fix this and that - do you blindly follow suit or take it with a grain of salt and make your own opinion about it? So overall... I think one should read Clean Code but one should read Refactoring and Pragmatic Programmer and Clean Architecture and so on. As the authors of The Pragmatic Programmer suggest that if possible, you should read at least one technical book per month while not forgetting about the non-technical books. In the end, they all expand your understanding and it is left as an excercise to the reader to weed out the do&#39;s and don&#39;t&#39;s from each of them.</div>

               
            </div>
                      <div id="komment610c540e7eddf">
              <h4>
                <a href="#komment610c540e7eddf">2021-08-05 22:11:42</a>
                by Michael:
              </h4>

              <div>&gt; As a side note, the below code uses the simplest prime number sieve, and takes about 45 seconds to find the first 20 million primes.  The Clean Code version takes *22 minutes*.

That&#39;s really interesting. 22 minutes for the fast variation is so incredibly slow...
But 45 seconds is also a bit too slow. The simplest sieve variation (divide odd numbers by known primes) takes 88 seconds. Fast implementation takes only 4.3 seconds. (i7-6700, Rust) I&#39;m surprised D is so much slower. I guess it&#39;s a good thing that I&#39;ve left D for Rust. :P

(Here&#39;s the implementation, if anyone&#39;s interested: https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=ed6c28087644a6db6aa2da58990dfea9)</div>

               
            </div>
                      <div id="komment6112720eacbc9">
              <h4>
                <a href="#komment6112720eacbc9">2021-08-10 13:33:18</a>
                by Whathecode:
              </h4>

              <div>When I read the book, over a decade ago now, I was equally annoyed by the code samples. Back then, a small minority was complaining about the same issues as you raise. I&#39;m glad to see more and more people are highlighting these glaring flaws!

Personally, I wrote a blog post focusing on his tiny functions which I called &#34;Function Hell&#34;: https://whatheco.de/2010/12/07/function-hell/</div>

               
            </div>
                      <div id="komment6116ec85156aa">
              <h4>
                <a href="#komment6116ec85156aa">2021-08-13 23:04:53</a>
                by qntm:
              </h4>

              <div>Thank you for that, another amazing example of perfectly sound code being refactored into unreadable mud. Not only that, the quirks/faults in the original code become so heavily obfuscated that you can barely spot them anymore. My refactoring procedure would be almost precisely the opposite of Martin&#39;s. Clean Code has some good points, but it&#39;s just barmy to take programming advice from someone who programs like this.</div>

               
            </div>
                      <div id="komment6118ccb8bab2a">
              <h4>
                <a href="#komment6118ccb8bab2a">2021-08-15 09:13:44</a>
                by Mario:
              </h4>

              <div>Really good article in my opinion!  While the final verdict about clean code is a bit harsh I think the author explains his reasoning really well -  he is not saying that it&#39;s complete garbage, but it certainly has flaws.
Bob Martin himself could take a lesson in considering other opinions, as he preaches his ideas (like hard-core following the 3 TDD rules) like a madman, even openly insulting people with different opinions.

In my opinion he has completely lost touch with an important aspect - code should be readable and understandable, especially to others. In my opinion all his examples (not only from clean code) are actually insanely hard to read and understand and just completely overengineered. If you want to see clean-code done right check out the codebase of Spring Framework - highly testable, everything is customizeable. Most functions are really short and concise, but there are exceptions. Great examples, but let&#39;s not forget that not everyone is writing a framework used by thousands. Just keep it simple! Not saying that you should write spaghetti code, but don&#39;t hold someone elses crazy rules over common sense either.</div>

               
            </div>
                      <div id="komment611acd8614fbc">
              <h4>
                <a href="#komment611acd8614fbc">2021-08-16 21:41:42</a>
                by trignals:
              </h4>

              <div>Functions - I think it&#39;s amazing that from the perspective of everywhere else in the program, that class is reduced to two short functions! Functions so short and simple that mostly you won&#39;t need to read any part of that class because you will know you don&#39;t need to care. The odd time you do need the details in ther you probably know which private function to look at next, after which either you are done or go one step more.

Essentially extending the exact process that means we do not have to spend ALL our time thinking in terms of logic gates. The gates are still there, that is still how every single thing gets done, but we do not have to care about them.

If the book does nothing to help you write better code drop it, you don&#39;t owe it to anyone but yourself to get something from it. Personally I think you could get a lot more out of it based on the the points you made in the functions section. Well maybe not the book but the youtube seminar version. Seeing that first the intentions were all clear so I never got confused between what Bob was saying and doing like you describe.</div>

               
            </div>
                      <div id="komment611acedda1657">
              <h4>
                <a href="#komment611acedda1657">2021-08-16 21:47:25</a>
                by trignals:
              </h4>

              <div>*confused* is a bit harsh I&#39;ll down grade that to &#39;saw a contradiction&#39;</div>

               
            </div>
                      <div id="komment611ba9b37579b">
              <h4>
                <a href="#komment611ba9b37579b">2021-08-17 13:21:07</a>
                by qntm:
              </h4>

              <div>&gt; from the perspective of everywhere else in the program, that class is reduced to two short functions

Well, from the perspective of the rest of the program, the interface is completely unchanged. It&#39;s two methods before the refactoring and it&#39;s the same two methods with the same signatures afterwards.

It&#39;s the implementation which is actually under discussion here.</div>

               
            </div>
                      <div id="komment61426cb35a782">
              <h4>
                <a href="#komment61426cb35a782">2021-09-15 22:59:15</a>
                by Ray:
              </h4>

              <div>In response to Michael&#39;s, &#34;But 45 seconds is also a bit too slow&#34;:

That was due to a mix of running on an old machine, missing a couple of obvious optimizations (starting the masking at each iteration at k*k instead of k+2, stopping grow_sieve early once we have enough primes), both of which your version has, and printing *all* the generated primes, not just the last 10.

With the optimizations, and all run on the same cheap laptop, C takes 25 seconds, D 26, Rust 34 (your code, but printing all 20M primes), and Java 164 (with the sane algorithm, not the Clean Code one).</div>

               
            </div>
                      <div id="komment615cda6c155ed">
              <h4>
                <a href="#komment615cda6c155ed">2021-10-06 00:06:20</a>
                by Howe:
              </h4>

              <div>Found a link to this post and while I appreciate the anti-rec, I&#39;m even more confused by the commenters bleating on about politics. What do politics have to do with lousy code?</div>

               
            </div>
                      <div id="komment61627b1dc7c49">
              <h4>
                <a href="#komment61627b1dc7c49">2021-10-10 06:33:17</a>
                by Bogdan:
              </h4>

              <div>Thanks for this exciting post. I firmly believe that clean code is excellent practice, but after second re-reading this book, I started to have some doubts. And your post proved my doubts :)</div>

               
            </div>
                      <div id="komment6185ea9f74f19">
              <h4>
                <a href="#komment6185ea9f74f19">2021-11-06 02:38:23</a>
                by Yihao:
              </h4>

              <div>In my opinion, best books are in the form of &#34;case studies&#34;. It should start with abundant background information about the problems it is trying to solve, including key constraints. Then it describes the solution it selected. And finally it describes how well that solution solves the original problem. &lt;br/&gt;&lt;br/&gt; In one word, start from facts, and end in cautious conclusions.&lt;br/&gt;&lt;br/&gt;Unfortunately, most books take the opposit approach: they start with a conclusion, and then try to find evidence to prove that.&lt;br/&gt;&lt;br/&gt; The consequence is that a lot of key constraints are missing. When we face a slightly different scenario, the reasonable action we take may be exactly the opposite. So the conclusions in the book will sound ridiculous... &lt;br/&gt;&lt;br/&gt; And Clean Code is one example of this type of books. &lt;br/&gt;&lt;br/&gt; The solution for a reader is to read the book as if it is a case study. Think about the unspoken constraints. And just feel free to disagree when you do. Once something becomes a case study, then you are at a completely equal position as the author. You have every right to criticise the author&#39;s solution.</div>

               
            </div>
                      <div id="komment618e83c4f37d9">
              <h4>
                <a href="#komment618e83c4f37d9">2021-11-12 15:09:56</a>
                by Sparr:
              </h4>

              <div>&#34;an IDE lets us trivially jump from function call to function implementation and back&#34;

You need to spend more time in environments where this is not the case. As time goes on I see more and more people making assertions based on the environments they work in and the tools available to them, which break down outside of those environments or when those tools aren&#39;t available.</div>

               
            </div>
                      <div id="komment618e861f39690">
              <h4>
                <a href="#komment618e861f39690">2021-11-12 15:19:59</a>
                by DMR:
              </h4>

              <div>It&#39;s probably time to stop enforcing 80 character widths. I can understand code having 80 character widths, but websites?</div>

               
            </div>
                      <div id="komment61956cb5202e8">
              <h4>
                <a href="#komment61956cb5202e8">2021-11-17 20:57:25</a>
                by romatthe:
              </h4>

              <div>I read this book as part of a reading group as well, when I started my first job as a junior programmer years ago. I have to admit that I really hated both reading and discussing it. Half of the book is filled with sensible, but overtly obvious advise that you can only softly nod to in agreement. And the other half (the more bizarre bits) were usually handwaved away by fellow readers on the basis that Martin was supposedly just using extreme examples to make a point. My biggest complaint with the entire book is that none of the advise is very practical. I didn&#39;t walk away from it armed with new techniques to use on a daily basis. The entire book is about a man extolling the virtues of his own rather extreme programming practices, instead of giving young programmers (who this book is often recommended to) a decent arsenal of weapons to attack the crufty codebase they&#39;re ordered to clean up.</div>

               
            </div>
                      <div id="komment619773a961057">
              <h4>
                <a href="#komment619773a961057">2021-11-19 09:51:37</a>
                by vngantk:
              </h4>

              <div>I have read the book Clean Code and recommended it to many other people. It completely changed the way I wrote code. When you read a book, you don&#39;t need to take to the extreme to what the author says and suggests. Always think about the principles and reasoning behind the points. When he says your functions need to be no more than four lines long. Yes, these are just hyperbole. Basically, what he means is that you should try your best to keep your functions as small as possible. Always care about the readers of your code and make sure they can easily understand your code. So, he suggests that your code should be written like a prose that is easy and enjoyable to read. The function and variable names should clearly indicate the intents. The idea that a good architecture allows you to defer your technology decisions as late as possible is counter-intuitive to many people, but is extremely helpful for you to design your applications with a very robust organisation and structure. 
I don&#39;t follow his suggestion as rituals. I will make practical adjustments with it score principles in mind.</div>

               
            </div>
                      <div id="komment61bc6cf939404">
              <h4>
                <a href="#komment61bc6cf939404">2021-12-17 10:56:57</a>
                by /dev/sda1:
              </h4>

              <div>That&#39;s exactly what I was disagreeing about with of the developers in my former job, but he just couldn&#39;t get my point. In his opinion a good code should be exactly as mentioned in the Clean Code book, period. So he did extract everything to tiny little private methods, completely not testable nor reusable, with tons of side effects and ultra-long names, because he learned that methods must. Be. Small. I personally thought he completely missed the point and his code wasn&#39;t clean to me at all (and it rarely worked, but that&#39;s another story). So we never liked each others code, I guess.

Love this article, I wish I knew about it at that time. You did far better job at expressing what I tried to express.</div>

               
            </div>
                      <div id="komment61c56979b047e">
              <h4>
                <a href="#komment61c56979b047e">2021-12-24 06:32:25</a>
                by Ryan:
              </h4>

              <div>The comment section here is honestly atrocious. It feels weird after reading this book and having to stop and ask myself the intentions of the writer in certain areas to truly understand what he wanted to teach me.
&lt;br/&gt;
I bought this book a while ago after doing some research on books that could enhance my knowledge and skills. I didn&#39;t really read too much at the time, as I fell headlong into a new position, but I just broke it out again to read through the unit testing portion to refresh for an interview. Chapter 9 is only 12 pages but I feel like I&#39;ve been cheated of about 8 pages worth of useful material.
&lt;br/&gt;
I don&#39;t want to harp too much on what you have written here already, but  I want to add something after I&#39;ve gone over my notes. For a chapter in the book &#34;Clean Code&#34;, the framework for the chapter is non-existent. The chapter feels less like an instruction and more of a stream of consciousness, where random bits of knowledge fling at me in no particular order.
&lt;br/&gt;
The chapter starts with an anecdote, introduces The Three Laws of Test Driven Development, goes to another anecdote about him consulting a development team that honestly doesn&#39;t feel like a real experience which could have been cut to get to the one sentence point, which has nothing to do with the Three Laws, as the issue at hand were poor tests(he doesn&#39;t outline what made the tests poor, or &#34;dirty&#34; as he puts it) and it keeps spiraling.
&lt;br/&gt;
There are little tiny grains of knowledge in paragraphs. &#34;If you fail to maintain good tests, you&#39;ll accumulate code debt&#34;, &#34;Good tests allows for code to change easily&#34;, &#34;Tests should be easy to read and understand&#34;. And then you get hit with the &#34;BUILD-OPERATE-CHECK&#34; pattern, bringing in test data out of the blue, but never in any detail or with a good example.
&lt;br/&gt;
The main issue here is this is not instructive. Ignoring cleanliness, most of this advice is general to the point where its almost too general for unit testing in and of itself, except for the 3 testing structures he adds at random. If I had never touched JUnit before, I would be absolutely lost. Unit Testing isn&#39;t the sexiest thing in the world, but his pen jumps as if the concept itself is more important than what goes in production. And he never even establishes what a unit test *is* or should BE. Also he brings in a code example in this chapter, 9-8, to show how one would unit test a concept at a time, instead of just individual single tests as their own unconnected code, and then doesn&#39;t refactor the example to show how it *should* be done.</div>

               
            </div>
                      <div id="komment61dd6b57eee08">
              <h4>
                <a href="#komment61dd6b57eee08">2022-01-11 11:34:47</a>
                by Illo:
              </h4>

              <div>&gt; Side note, Clean Architecture is absolute garbage, I didn&#39;t get through it. However, I think there&#39;s general agreement on that topic.

Yes, yes and again, yes! The &#34;Clean Architecture&#34; Book is absolute garbage. Thank you for being so explicit about it. I thought my copy was incomplete at first.</div>

               
            </div>
                      <div id="komment61e6c4b466ea8">
              <h4>
                <a href="#komment61e6c4b466ea8">2022-01-18 13:46:28</a>
                by James:
              </h4>

              <div>First off, that was an excellent blog post. Thanks for that.

In my opinion the advice in Clean Code for the most part is excellent. From that point of view, I would recommend it.

That being said, if you read the book and understand what Martin is saying, it&#39;s impossible not to be shocked by the quality of the code samples. They are really really poor, almost to the point where you begin to think it&#39;s been done deliberately for some reason. It&#39;s quite baffling.

I&#39;m sure I&#39;ve seen short videos where Martin takes some code and applies some of his principles to refactor it into something much cleaner (pre-rehearsed, I&#39;m sure). From memory I remember these code examples being far better in quality, although I would imagine the scope was quite narrow.</div>

               
            </div>
                      <div id="komment61f3fe64530e9">
              <h4>
                <a href="#komment61f3fe64530e9">2022-01-28 14:32:04</a>
                by alban:
              </h4>

              <div>I have been into clean code architecture since 4 years now. The principles, of this book / videos are very good compared to the caos of the industry where you do not have any architecture.

Since ever I applied clean code, I have notice that my projects are scalable, extendable, durable, easy to pick over again... it totally changed the quality of the projects. I picked up a project I started 2 years ago with no issue, extending it.

Now said that, is this the best architecture? of course no. 
do we have a better one? Nope

Software developers today are like monkey coders, they write any type of code just to make things work, but never think in term of architecture: what happen if I have to add a new feature? would it be easy? how is going my unit test change?.... and what is worst is that this kind of developers tend to argue with air with no data and 
 no base

I work for the biggest cloud company, and the main issue I see here is creating of tech debt, done by bad coding/no architecture... we spend most of our dev time in figuring out and re-factoring continuously our code even for simple changes like adding a new column to a table....</div>

               
            </div>
                      <div id="komment6213dc7f9bf07">
              <h4>
                <a href="#komment6213dc7f9bf07">2022-02-21 18:39:59</a>
                by Castro:
              </h4>

              <div>Sorry but, IMO, this post is just to try grown up over a book well known among developers in the world. There is not a real critcism, just a bunch of complaints without a core objective and some of those are critcism about things that is not the book goal, like what do we do before start to code.  

This type of posts only serves to mislead knowledge into the developers, broadcast confusing arguments and perpetuate wrong guidances for everyone.

I&#39;m not a Uncle Bob&#39;s fanboy but I&#39;m totally agree with Pedro Dias. The book examples and didatics is not the better, however it brings a lot of valuable knowledge.</div>

               
            </div>
                      <div id="komment6230e51db2de6">
              <h4>
                <a href="#komment6230e51db2de6">2022-03-15 19:12:29</a>
                by Károly Ozsvárt:
              </h4>

              <div>I think the article&#39;s title should be rewritten to emphasize that it is talking about the **book** and not saying to stop recommending clean code in general.

I think the book is a great read for any software developer who wants to improve coding skills, but - as with everything - take what is written &#34;with a grain of salt&#34; and think about what it writes. If you read this book not as some holy bible but as a collection of interesting ideas, it can have great value.

When I used to read it, I skipped most code examples as I hate reading code on paper.</div>

               
            </div>
                      <div id="komment623a059dc8ab9">
              <h4>
                <a href="#komment623a059dc8ab9">2022-03-22 17:21:33</a>
                by sm:
              </h4>

              <div>I recently read that prime number generator code and am very glad to know that it&#39;s not just me that found it pretty horrible. I thought it was my failing that I struggled to make head or tail of it.

Treated as a collection of general advice on things to think about when coding it remains a useful book, I think. No one&#39;s going to treat it as their coding Bible so in the end I&#39;m not sure its many failings are going to do much harm.</div>

               
            </div>
                      <div id="komment623ac5d05d98d">
              <h4>
                <a href="#komment623ac5d05d98d">2022-03-23 07:01:36</a>
                by Peter:
              </h4>

              <div>Thank you very much for an excellent read. I really like your style of writing and I can only encourage you to write more.</div>

               
            </div>
                      <div id="komment62baf5941a528">
              <h4>
                <a href="#komment62baf5941a528">2022-06-28 13:35:32</a>
                by Sinity:
              </h4>

              <div>I always thought that advice to aggressively break functions down into ridiculously small ones is weird and doesn&#39;t actually simplify the code.

There&#39;s a nice text by Carmack: number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html

- which recommends not artificially breaking functions into 
smaller ones if these would be only called once

&#34;If everything is just run out in a 2000 line function, it is obvious which part happens first, and you can be quite sure that the later section will get executed before the frame is rendered.&#34;

&#34;The function that is least likely to cause a problem is one that doesn’t exist, which is the benefit of inlining it. If a function is only called in a single place, the decision is fairly simple.&#34;

&#34;Using large comment blocks inside the major function to delimit the minor functions is a good idea for quick scanning, and often enclosing it in a bare braced section to scope the local variables and allow editor collapsing of the section is useful. I know there are some rules of thumb about not making functions larger than a page or two, but I specifically disagree with that now – if a lot of operations are supposed to happen in a sequential fashion, their code should follow sequentially.&#34;


&#34;If a function is only called from a single place, consider inlining it.

&#34;If a function is called from multiple places, see if it is possible to arrange for the work to be done in a single place, perhaps with flags, and inline that.&#34;

&#34;If there are multiple versions of a function, consider making a single function with more, possibly defaulted, parameters.&#34;

&#34;Minimize control flow complexity and “area under ifs”, favoring consistent execution paths and times over “optimally” avoiding unnecessary work.&#34;</div>

               
            </div>
                      <div id="komment62d0130034274">
              <h4>
                <a href="#komment62d0130034274">2022-07-14 13:58:40</a>
                by Insanity:
              </h4>

              <div>@Sinity

&gt; &#34;If a function is only called from a single place, consider inlining it.
&gt; 
&gt; &#34;If a function is called from multiple places, see if it is possible to arrange for the work to be done in a single place, perhaps with flags, and inline that.&#34;

Sounds like dated advices to me.</div>

               
            </div>
                      <div id="komment6332051f1cbff">
              <h4>
                <a href="#komment6332051f1cbff">2022-09-26 21:01:35</a>
                by @Sinity:
              </h4>

              <div>While I am very strongly against this &#34;break every thing up into tiny functions madness&#34;, I believe that inlining everything is equally terrible, because you loose the ability to properly name code blocks.

Names have power!
Personally if I feel like I have a very clear and understandable name for a code block I will always factor it out into a function. What&#39;s better to read and understand for you, calling deltaImportCustomersFromSap() or 25 lines of code that you have to walk through to understand what is actually happening.

Take a look at the Code of the Spring Framework. They name everything super carefully and use methods, without going insane and creating an unreadable mess like uncle bobs method would</div>

               
            </div>
                      <div id="komment633db8fa89ef5">
              <h4>
                <a href="#komment633db8fa89ef5">2022-10-05 18:03:54</a>
                by Hemil:
              </h4>

              <div>I find it amusing that so many people are commenting about political opinions and going &#34;I wont talk with a person who has different opinions&#34; like LMAO.

Equally amusing is that the vast majority of the comments dont present objective counter arguments like you did in the original post. That code is crap. Period</div>

               
            </div>
                      <div id="komment63c01fc5e0a6b">
              <h4>
                <a href="#komment63c01fc5e0a6b">2023-01-12 14:57:09</a>
                by Tom:
              </h4>

              <div>I totally agree with you. I have re-studied Java just to understand what does the example code in the bottom of chapter 3 mean. I quiet agree that a function should be small and does limited specific things. However, I am also upgainst his example. I think the point he tries to make is that we write functions in a narrotive way that this series of functions act as a single function that could be easily understood as a narrative way (To-do graph). The issue of this is that this replies too much on how we name each function and our experience on those kind of thing. In this particular example, I have rarely programming in HTML, so even if the author claims that naming in functions is flank, I am not 100% sure what does this function do, so when reading those narrative function, I have to stop and understand the function below them before I can comprehend what the main function does. The point I wish to make is that this way of writing function requires the programmer have experience in this kind of task and a very good function name that could be generally understood by otheres, this is all difficult. I think the best way to understand a function is to write narratives in comments and direclty point out what each step does and provide example to help other developers to acutallly run the program. Writing function in a narrative could be helpful occsionally but definitely is a disgrace to comments.</div>

               
            </div>
           

                      

            

            <!-- comment -->
           
        </div><!-- comments -->
      </div>
     

    
  
</div>
  </body>
</html>
