<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.softwarelitigationconsulting.com/wp-content/uploads/2020/08/schulman_blast_from_the_past_disassembling_dos.html">Original</a>
    <h1>A blast from the past: Disassembling DOS (2020)</h1>
    
    <div id="readability-page-1" class="page">
    
    <h2><a href="http://www.SoftwareLitigationConsulting.com">Andrew
       Schulman</a></h2>
    <h3>from <u>Undocumented DOS: A Programmer&#39;s Guide to Reserved
       MS-DOS Functions and Data Structures</u> (2nd edition,
    1994)</h3>
 <b>Copyright (c) Andrew Schulman 1994-2020. All rights
    reserved.</b><p>
    <i><b>[This nearly-ancient text (along with others from <u>Undocumented
       DOS</u>
    and <u>Undocumented Windows</u>) is being presented as a case study in
    some methodologies of software reverse engineering, applied to
    mass-market software. Note that this chapter appeared in the 2nd
    edition of the book, not in the 1st edition.]</b></i>
    </p><p>
        The previous chapter showed that it possible to discover a lot about a program without resorting to what is often called reverse engineering. Simply by examining a program&#39;s outward behavior, a utility such as INTRSPY shows, for example, that Windows
        uses the undocumented DOS Get SysVars function, and that Microsoft&#39;s QuickC makes the weird SetPSP(0) and SetPSP(-1) calls that are discussed in chapter 4.
    </p>
    <p>
        But such external examination of a program&#39;s behavior can take us only so far. INTRSPY can&#39;t tell us <em>why</em> Windows calls Get SysVars — that is, which fields it uses in the SysVars data structure) — nor can INTRSPY tell us why
        QuickC passes the illegal values 0 and -1 to the DOS Set PSP function. To figure out why a program behaves in a certain way, you need to actually get inside the program. This requires disassembly.
    </p>
    <p>
        Disassembly is particularly important to understanding what goes on inside MS-DOS itself. What does DOS actually do when a program calls the Get SysVars function, for example? How does DOS carry out an INT 21h AH=4Bh EXEC request? How do DOS 5.0 and 6.0
        interact with Windows? To answer questions like these, there&#39;s no substitute for looking at the DOS code. Though Microsoft does produce a DOS OEM Adaptation Kit (OAK) that we discuss later in this chapter, source code to MS-DOS is not widely available.
        For those of us without the DOS source code, understanding DOS requires disassembling it.
    </p>
    <p>
        The goal of this chapter is to acquire an understanding of DOS internals, that is, to get an intuitive feel for what goes on when a program makes an INT 21h DOS call. Chapter 2 briefly presented a disassembly of two DOS functions, INT 21h AH=0Eh (Set
        Default Drive; see listings 2-7 and 2-8) and INT 21h AH=19h (Get Default Drive). But how did we find the code for these functions in the  place? A key purpose of this chapter is to present a close look at the key part of MS-DOS, the INT 21h
        handler, with its function dispatch table, which contains pointers to the code that handles each individual INT 21h function. Armed with this table, you can readily consult the code for any particular DOS function whose implementation interests
        you. You can apply the same technique to other pieces of code, such as DR DOS or the INT 21h hook in Novell NetWare&#39;s NETX.COM (see chapter 4).
    </p>
    <p>
        The resident DOS code is found in two files, IO.SYS and MSDOS.SYS—sometimes named IBMBIO.COM and IBMDOS.COM. DOS 6.0 and higher also has DBLSPACE.BIN, which Microsoft usually considers a third member of the DOS kernel. While there are various ways
        to examine the code in these files on disk, this chapter instead examines the INT 21h handler in memory, using Microsoft&#39;s own DEBUG, a primitive though handy tool that comes with MS-DOS.
    </p>
    <p>
        Part of the reason for using DEBUG, rather than a more sophisticated debugger or disassembly tool, is to underline the point that Microsoft itself provides the means for reverse engineering DOS. Since programmers frequently have questions about the legalities
        of disassembly, this chapter also briefly discusses the law surrounding reverse engineering and trade secrets.
    </p>
    <p>
        Of course, there is more to DOS than just IO.SYS and MSDOS.SYS. We also look briefly at the disassembly of external programs such as COMMAND.COM, MSCDEX.EXE, and PRINT.COM, which is probably the most heavily disassembled DOS utility and the one on which
        many TSR writers  figured out their craft.
    </p>
    <p>
        Whether or not you disassemble DOS depends of course on what interests you. The examination of the INT 21h dispatch code in this chapter may provide all you ever wanted to know about how DOS functions internally. On the other hand, if you absolutely,
        positively must know exactly what is going on inside MS-DOS and you have the money to pay for this information, you may want to license Microsoft&#39;s DOS OEM Adaptation Kit, which includes assembly language and C source code for many parts of DOS,
        as well as .OBJ files with full symbolic information for those parts where direct source code is not provided. We take a quick look at the OAK contents later on.
    </p>
    <h2>What is MS-DOS?</h2>
    <p>
        MS-DOS is a bit like pornography. Everyone knows what it is when they see it, but almost no one can define it.
    </p>
    <p>
         of all, MS-DOS is <em>not</em> the C&gt; prompt. While that infamous user interface seems practically synonymous with MS-DOS, it is not actually a necessary part of DOS. The C&gt; prompt is provided by COMMAND.COM, which (as chapter 10 explains
        in more detail) anyone can easily replace. As indicated by the shell= statement in CONFIG.SYS, COMMAND.COM is just a shell around the DOS kernel. Other shells, such as 4DOS or the MKS Korn shell, are widely available. Get rid of COMMAND.COM, and
        you still have MS-DOS.
    </p>
    <p>
        From a programmer&#39;s perspective, MS-DOS seems like a collection of INT 21h functions. But this isn&#39;t quite accurate either. While the INT 21h functions are the most important service provided by DOS, DOS and INT 21h are not synonymous. Several application
        wrappers in chapter 2 (listings 2-20 and 2-21) already showed how easy it is for a normal program to fiddle with INT 21h calls before or after DOS itself gets them. That a piece of code handles INT 21h doesn&#39;t necessarily make it part of DOS.
    </p>
    <p>
        So if DOS ain&#39;t necessarily the C&gt; prompt or the INT 21h interface, what then is it? And where is it?
    </p>
    <p>
        The &#34;what&#34; part is difficult to answer, except to note that DOS is in many ways what textbooks on operating systems call a microkernel. DOS provides a small bare minimum of services, on top of which other, more sophisticated, services can be built. Think
        of DOS as a software motherboard, into which the user is free to plug in various extensions. These extensions come not only from Microsoft but also from key third-party vendors such as Novell, Quarterdeck, Qualitas, Symantec, Central Point, and
        Phar Lap. DOS is the arena in which all these companies&#39; products must both compete and work together.
    </p>
    <p>
        Well, that was vague enough!
    </p>
    <p>
        Mercifully, the &#34;where&#34; part at least is easy to answer. MS-DOS consists of two files, IO.SYS and MSDOS.SYS. In both IBM PC-DOS and Novell&#39;s DR DOS, these files are called IBMBIO.COM and IBMDOS.COM. Despite the .SYS file names, these are not device drivers,
        but binary images. In MS-DOS 6.0, there is a third file, DBLSPACE.BIN, which Microsoft generally considers a full-fledged third member of the DOS kernel—the SYS and FORMAT /S commands in DOS 6.0 copy DBLSPACE.BIN over to a floppy, along
        with IO.SYS and MSDOS.SYS. Take these two or three files, and you&#39;ve got DOS. Of course, you&#39;ll also need a shell such as COMMAND.COM in order to get much work done.
    </p>
    <p>
        Among other things, MSDOS.SYS contains the DOS dispatch function, which is DOS&#39;s handler for INT 21h calls. There are other DOS functions, such as INT 25h, 26h, and 2Fh, that MSDOS.SYS and IO.SYS handle as well.
    </p>
    <p>
        IO.SYS consists of two parts, a loader (MSLOAD.COM) and BIOS support code (MSBIO.BIN); Microsoft creates IO.SYS by concatenating these two files:
    </p>
    <code> <pre>      copy /b msload.com+msbio.bin io.sys
    </pre> </code>
    <p>
        IO.SYS is <em>not</em> &#34;the BIOS,&#34; as books on DOS programming frequently claim, but merely the DOS <em>interface</em> to the BIOS. IO.SYS contains the standard device drivers such as CON, AUX, LPT1, and COM1 (see chapter 7). These device drivers
        are implemented using BIOS calls. For example, the CON driver built into IO.SYS (more precisely, MSBIO.BIN) makes INT 10h and INT 16h calls to the ROM BIOS video and keyboard routines.
    </p>
    <p>
        The MSLOAD.COM portion of IO.SYS contains a famous set of routines called SYSINIT, which is responsible for the bootstrap loading of DOS.
    </p>
    <p>
        We won&#39;t discuss SYSINIT here, as it has already been covered elsewhere (see &#34;How MS-DOS Is Loaded&#34; in chapter 2 of Ray Duncan&#39;s
        <em>Advanced MS-DOS Programming</em>, and &#34;The Components of MS-DOS&#34; in Duncan&#39;s <em>MS-DOS Encyclopedia</em> ). And practically every other book on DOS programming seems to repeat this same basic material on SYSINIT. Presumably this is not just
        because the bootstrap loading of DOS is an interesting subject, but also because Microsoft already documents SYSINIT in the DOS OAK. Geoff Chappell provides a far more original and useful description of DOS startup in his <em>DOS Internals</em>,
        chapters 1 (&#34;The System Configuration&#34;), 2 (&#34;The System Footprint&#34;), and 3 (&#34;The Startup Sequence&#34;). For example, Chappell is the  author to make the connection between SYSINIT and the List of Lists structure (whose actual name in the DOS
        source code is SysInitVars).
    </p>
    <p>
        So the DOS boot sequence is fairly well known. What hasn&#39;t been provided before, amazingly, is any description of what DOS looks like once it is up and running. This primarily requires a description of DOS&#39;s INT 21h handler and the INT 21h dispatch table.
        In other words, what code runs when you make an INT 21h call to DOS? Scores of DOS programming books of course describe what this or that DOS function call does, but few describe how any of these function calls work; and none to our knowledge
        &#34;aside from a brief discussion of DOS stack switching in Microsoft&#39;s
        <em>MS-DOS Encyclopedia</em> (pp. 353-355)&#34; describes the DOS function call mechanism itself. This seems far more important than providing yet another standard description of how DOS boots up or how SYSINIT moves segments around in memory.
    </p>
    <p>
        One of our tech reviewers writes that &#34;parts of the boot sequence are NOT well known! In DOS 6.0 and up, there&#39;s the mechanism that IO.SYS uses to load DBLSPACE.BIN. And in DOS 7.0 (Chicago), if CONFIG.SYS contains the setting DOS=ENHANCED, there is code
        in IO.SYS that loads DOS386.EXE, which is a big executable similar to WIN386.EXE.&#34;
    </p>
    <h3>Disassembling IO.SYS and MSDOS.SYS</h3>
    <p>
        The choice between describing SYSINIT or describing the INT 21h handler is an important one, because the portion of DOS which one is interested in looking at largely determines how one goes about disassembling DOS.
    </p>
    <p>
        To look at DOS initialization, you either have to acquire the DOS OAK (which provides assembly language source code to IO.SYS, including the SYSINIT modules), or you have to disassemble the actual IO.SYS and MSDOS.SYS files on disk. These files are hidden
        system files, which however can be easily unhidden:
    </p>
    <code> <pre>      C:\UNDOC\CHAP6 &gt; attrib -h -s \*.sys
    </pre> </code>
    <p>
        IO.SYS is about 32K, and MSDOS.SYS is about 37K. Once unhidden, these two files can be disassembled, even with the u (unassemble) command in the primitive DEBUG utility that comes with DOS. After running ATTRIB to unhide MSDOS.SYS or IO.SYS, type DIR
        to find the file&#39;s size. DEBUG loads the file at address 100h, so add 100h to the file size (converted to hexadecimal) to yield the disassembly end-range. For example, if MSDOS.SYS is 37,506 (9282h) bytes:
    </p>
    <code>
   <pre>    C:\UNDOC2\CHAP6&gt;type msdos.scr
    u 0100 9382
    q

    C:\UNDOC2\CHAP6&gt;debug \msdos.sys &lt; msdos.scr &gt; msdos.lst
   </pre>
    </code>
    <p>
        The resulting MSDOS.LST is about one megabyte in size; if you use a disassembler such as Sourcer, the file is about 800K. In some ways, the output from such a straightforward disassembly of MSDOS.SYS looks quite useful. For example, you can quite plainly
        see DOS&#39;s INT 21h handler inspecting the caller&#39;s function number in AH. This is the DOS code called whenever a program generates an INT 21h:
    </p>
    <code>
<pre>    6A76:040B FA            CLI
    6A76:040C 80FC6C        CMP AH,6C       ; is function &gt; 6Ch?
    6A76:040F 77D2          JA  03E3        ; yes: error
    6A76:0411 80FC33        CMP AH,33
    6A76:0414 7218          JB  042E
    6A76:0416 74A2          JZ  03BA
    6A76:0418 80FC64        CMP AH,64
    ; ... etc. ...
</pre>
    </code>
    <p>
        Likewise the MSDOS.SYS INT 2Fh handler is also visible. IO.SYS has its own INT 2Fh handler, and in the last line of the code fragment below, you can see the INT 2Fh handler in MSDOS.SYS jump to the one in IO.SYS, using a hard-wired address:
    </p>
    <code>
    <pre>    1C53:07B9 FB            STI
    1C53:07BA 80FC11        CMP AH,11
    1C53:07BD 750A          JNZ 07C9
    ;;; Go to 07BFh if an INT 2Fh call belonging to an external
    ;;; program such as a redirector, SHARE, or NLSFUNC, ends up
    ;;; in MSDOS.SYS. This means the external program isn&#39;t loaded.
    1C53:07BF 0AC0          OR	AL,AL       ; is AL=0?
    ; ... error handling ...
    1C53:07C9 80FC10        CMP AH,10       ; INT 2Fh AH=10h? (SHARE)
    1C53:07CC 74F1          JZ  07BF  ; got here, so SHARE not loaded
    1C53:07CE 80FC14        CMP AH,14		; INT 2Fh AH=14h? (NLSFUNC)
    1C53:07D1 74EC          JZ  07BF  ; got here, so NLSFUNC not loaded
    1C53:07D3 80FC12        CMP AH,12       ; INT 2Fh AH=12h?
    1C53:07D6 7503          JNZ 07DB
    1C53:07D8 E99701        JMP 0972        ; handle DOS internal functions
    1C53:07DB 80FC16        CMP AH,16       ; INT 2Fh AH=16h? (Windows)
    1C53:07DE 740D          JZ  07ED        ; might be Windows broadcast
    1C53:07E0 80FC46        CMP AH,46       ; INT 2Fh AH=46h? 
    1C53:07E3 7503          JNZ 07E8
    1C53:07E5 E93E01        JMP 0926
    1C53:07E8 EA05007000    JMP 0070:0005   ; see if IO.SYS wants it
    </pre>  
    </code>
    <p>
        But while at  this looks useful, after a few minutes it becomes clear that the quality of the unassembly is unfortunately quite poor. Much better versions of these INT 21h and INT 2Fh handlers are shown later in figures 6-7 and 6-13. For example,
        the most important part of the INT 21h handler uses the function number in AH as an index into a dispatch table:
    </p>
    <code>
      <pre>    ;;; previously moved AH func number into BX
    6A76:04FE 8B9FA73E      MOV BX,[BX+3EA7]
    6A76:0502 36871EEA05    XCHG BX,SS:[05EA]
    6A76:0507 368E1EEC05    MOV DS,SS:[05EC]
    6A76:050C 36FF16EA05    CALL SS:[05EA]
      </pre>
    </code>
    <p>
        Unfortunately, if you now go and look at 3EA7h, presumably the address of the all-important INT 21h function dispatch table, there turns out instead to be perfectly valid-looking code at that address, and not a table at all. Likewise, 05ECh and 05EAh
        are, in this context, totally bogus. This isn&#39;t a problem with DEBUG, however. A straight disassembly on disk of MSDOS.SYS or IO.SYS, even with a more sophisticated disassembler such as Sourcer, doesn&#39;t produce much better results.
    </p>
    <p>
        The problem is that the SYSINIT process (as described in the
        <em>MS-DOS Encyclopedia</em> ) moves segments around in memory and relies heavily on segment arithmetic. Address cross-references often won&#39;t match up properly in a static disassembly of DOS on disk. To get a good disassembly of the core DOS interrupt
        handlers, it is much easier to disassemble DOS <em>in memory</em>, after the DOS initialization segment movement (which might include the DOS=HIGH movement of the DOS kernel to the high memory area, or HMA) is complete.
    </p>
    <p>
        The only problem with disassembling DOS out of memory, rather than in the system files on disk, is that this misses the SYSINIT code, which is discarded from memory when the initialization is complete. However, as noted earlier, SYSINIT and the DOS bootstrap
        process have already been adequately covered elsewhere.
    </p>
    <p>
        Again, a tech reviewer writes, &#34;NO! You&#39;re forgetting all the &#34;preload&#34; stuff that IO.SYS does starting in DOS 6.0. Also, taking apart IO.SYS really isn&#39;t that difficult. To link up data with the code that uses it, you just need to subtract some fixed
        amount, which is easy to figure out once you have one code/data pair. Just look at the code in IO.SYS that preloads DBLSPACE.BIN.&#34; Hmm, it seems we ought to take a look at this...
    </p>
    <!-- --whole next sidebar section is new-- -->
    <div>
        <h4>Examining How IO.SYS Preloads DBLSPACE.BIN</h4>
        <p>
            It turns out that static disassembly of IO.SYS is actually pretty easy, even though at  glance the results produced by a disassembler such as Sourcer look inadequate. It&#39;s true that references to data don&#39;t match up with the actual locations of the
            data in the file, but once you match up just one piece of data in the file with code that references it, you can figure out everything else.
        </p>
        <p>
            For example, a Sourcer disassembly of IO.SYS from MS-DOS 6.0 contains the following data item:
        </p>
        <p><code>
        <pre>    54BF:8138  5C 44 42 4C 53 50 41 43    db    &#39;\DBLSPACE.BIN&#39;
    54BF:813E  45 2E 42 49 4E 00
        </pre>
      </code></p><p>
            This is followed shortly by code that, based on the surrounding context (the code calls the INT 21h AX=4B03h Load Overlay function), is probably loading DBLSPACE.BIN. However, the code does not reference offset 8138h. Instead, it references CS:3B62h:
        </p>
        <p><code>
        <pre>    54BF:8153  0E           push cs
    54BF:8154  1F           pop ds
    54BF:8155  BE 3B62      mov si,3B62h
        </pre>
      </code></p><p>
            If you subtract 3B62h from 8138h, you get 45D6h. If the code at 54BF:8155 really is referencing the &#39;\DBLSPACE.BIN&#39; string at offset 8138h, then 45D6h is the amount which you must add to other data references in this version of IO.SYS in order to locate
            the data itself. To confirm if this amount is accurate, just look for another data reference, and see if adding the amount onto it yields a likely-looking address. For example, a little further on in the file, IO.SYS produces an error message:
        </p>
        <p><code>
        <pre>    54BF:81E9  0E           push cs
    54BF:81EA  1F           pop ds
    54BF:81EB úBA 5823      mov dx,5823h
    54BF:81EE  B4 09        mov ah,9
    54BF:81F0  CD 21        int 21h     ; DOS Services  ah=function 09h
                                        ;  display char string at ds:dx
        </pre>
      </code></p><p>
            From the helpful comment supplied by Sourcer on how INT 21h AH=9 works, it is clear that 5823h must be the offset within CS of a string. Adding 45D6h to 5823h yields 9DF9h and there, indeed, is the error message:
        </p>
        <p><code>
        <pre>    54BF:9DF9  57 72 6F 6E 67 20    db  &#39;Wrong DBLSPACE.BIN version&#39;, 0Dh
        </pre>
        <br/>
      </code></p><p>
            Thus, we really can pick apart IO.SYS on disk. This lets us examine the DOS boot process, in particular the recent additions such as the preloading of DBLSPACE.BIN in DOS 6 and the apparent ability to preload DOS386.EXE in DOS 7. &#34;Preloading&#34; means that
            IO.SYS looks for and loads these external programs before processing any DEVICE= statements in CONFIG.SYS. Chapter 1 discussed how Stacker 3.1 uses this interface to get itself preloaded under DOS 6. By examining IO.SYS, you can see how the
            interface works.
        </p>
        <p>
            For example, after calling INT 21h AX=4B03h to load DBLSPACE.BIN, IO.SYS looks for a function pointer at offset 14h in DBLSPACE.BIN:
        </p>
        <p><code>
        <pre>    54BF:819F  E8 FBD6              call    LOAD_OVERLAY   ; subr. does 21/4B03
    ; ...
    54BF:81C6  2E: C7 06 0387 0014  mov word ptr cs:[387h],14h ; get func ptr from
    54BF:81CD  2E: 8C 06 0389       mov word ptr cs:[389h],es  ;   offset 14h
    ; ...                                                      ;   in DBLSPACE.BIN
        </pre>
      </code></p><p>
            IO.SYS saves away the function pointer provided by DBLSPACE.BIN, and then calls it:
        </p>
        <p><code>
        <pre>    54BF:81DA  0E                   push cs         ; IO.SYS passes DBLSPACE.BIN 
    54BF:81DB  07                   pop es          ;    a pointer to a buffer:
    54BF:81DC  BB 036A              mov bx,36Ah     ; 36Ah+45D6h=4940h (see below)
    54BF:81DF  B8 0006              mov ax,6        ; DOS version
    54BF:81E2  2E: FF 1E 0387       call dword ptr cs:[387h] ; call DBLSPACE.BIN
    ; ...                                                    ;    function ptr

    54BF:8228  BB 0004              mov bx,4                 ; subfunction 4
    54BF:822B  2E: FF 1E 0387       call dword ptr cs:[387h]
    ; ...

    54BF:4940  18 00                db   18h, 00h  ; a communications buffer
        </pre>
      </code></p><p>
            IO.SYS also checks for a 2E2Ch signature at offset 12 in DBLSPACE.BIN. A hex dump of DBLSPACE.BIN reveals the presence of this signature:
        </p>
        <p><code>
        <pre>    C:\UNDOC2\CHAP6&gt;dump \dos\dblspace.bin -bytes 32
    0000 | FF FF FF FF 42 48 41 08 8B 08 01 44 42 4C 53 50 | ....BHA....DBLSP
    0010 | 41 43 2C 2E E9 B2 59 00 00 EA 41 08 00 00 EA 8B | AC,...Y...A.....
        </pre>
      </code></p><p>
            Further discussion of this interface, and its possible role in the ongoing battle between Microsoft and Stac Electronics, appears in chapter 1. Here, the point is simply that all existing descriptions of the DOS boot process will need to be rewritten
            to take account of new additions to DOS such as DBLSPACE.BIN (and, in DOS 7, DOS386.EXE).
        </p>
        <p>
            In any case, one topic that hasn&#39;t been covered at all is the INT 21h dispatch code, which is executed every time a program makes a DOS call (except another program that hooks INT 21h has completely intercepted the call, without chaining). As we&#39;ll see,
            there are many important aspects to the INT 21h dispatch code, including stack switching, use of the current PSP, incrementing and decrementing the InDOS flag, handling of critical sections, Ctrl-Break, and critical errors, checking the machine&#39;s
            A20 line when DOS=HIGH, and special casing for Windows Enhanced mode.
        </p>
    </div>
    <h2>Interrupt Vectors and Chaining</h2>
    <p>
        Studying DOS internals requires finding the code in DOS that handles software interrupts such as INT 21h and INT 2Fh. As we just saw, trying to do this with IO.SYS and MSDOS.SYS on disk can produce inadequate results. In memory, however, it seems like
        it should be trivial to find DOS&#39;s INT 21h and INT 2Fh handlers. As every PC programmer knows, there is a documented DOS function, INT 21h AH=35h, which returns (in ES:BX) a far pointer to the code that handles the interrupt given in AL.
    </p>
    <p>
        Finding the current handlers for INT 21h and INT 2Fh is thus a simple matter of calling INT 21h AX=3521h and AX=352Fh and looking at the returned far pointer, or vector, as it is called. This can be wrapped up in a simple program to print out interrupt
        vectors. Add a little extra smarts, such as trying to figure out the <em>owner</em> of each interrupt vector and disassembling some frequently encountered instructions at the beginning of the interrupt handler, and the result is INTVECT.C,
        shown in listing 6-1; listing 6-2 shows MAP.C, which attempts to figure out owners.
    </p>
    <h4>Listing 6-1: INTVECT.C</h4>
    <code>
      <pre>    /*
    INTVECT.C
    bcc intvect.c map.c
    */

    #include &lt;stdlib.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;dos.h&gt;

    typedef unsigned char BYTE;
    typedef unsigned short WORD;
    typedef unsigned long DWORD;

    #define MK_LIN(fp)  ((((DWORD) FP_SEG(fp)) &lt;&lt; 4) + FP_OFF(fp))

    extern char *find_owner(DWORD lin_addr);    // in map.c

    #define ARPL    0x63
    #define IRET    0xCF
    #define JMPF    0xEA
    #define JMP8    0xEB
    #define JMP16   0xE9

    BYTE far *get_vect(int intno)   // call INT 21h AH=35h
    {
        _asm push es
        _asm mov al, byte ptr intno
        _asm mov ah, 35h
        _asm int 21h
        _asm mov dx, es
        _asm mov ax, bx
        _asm pop es
        // return value in DX:AX
    }

    void print_vect(int intno)
    {
        char *s;
        BYTE far *fp = get_vect(intno);
        printf(&#34;INT %02Xh   %Fp   &#34;, intno, fp);
        if (fp == 0)
        {
            printf(&#34;unused\n&#34;);
            return;
        }
        s = find_owner(MK_LIN(fp));
        printf(&#34;%-08s   &#34;, s? s: &#34; &#34;);

        switch (*fp)    // see if first instruction of interrupt handler
        {               // is anything really obvious
            case ARPL:  printf(&#34;arpl -- Windows V86 breakpoint&#34;); break;
            case IRET:  printf(&#34;iret -- NOP function&#34;); break;
            case JMP8:  printf(&#34;jmp %Fp&#34;, 
                ((BYTE far *) fp) + fp[1] + 2); break;
            case JMP16: printf(&#34;jmp %Fp&#34;,
                ((BYTE far *) fp) + *((WORD far *) &amp;fp[1]) + 3); break;
            case JMPF:  printf(&#34;jmp %Fp&#34;, 
                *((void far * far *) &amp;fp[1])); break;
        }
        printf(&#34;\n&#34;);
    }

    main(int argc, char *argv[])
    {
        char *end;
        int intno, i;
        if (argc &lt; 2)
            for (intno=0; intno&lt; 256; intno++)
                print_vect(intno);
        else for (i=1; i&lt; argc; i++)
            print_vect(strtoul(argv[i], &amp;end, 16));
        return 0;
    }
      </pre>
    </code>
    <p>For example:</p>
    <code>
      <pre>    C:\UNDOC2\CHAP6&gt;intvect 21 28 2f 2f
    INT 21h   C0B6:0942              
    INT 28h   18D4:0615   PRINT
    INT 29h   0070:0762   IO         
    INT 2Fh   1A82:000D   NLSFUNC
      </pre>
    </code>
    <div>
        <h4>INTVECT and Windows</h4>
        <p>
            If you run INTVECT without command line parameters, it dumps out the vectors for all 256 interrupts. This is useful, for example, in determining which interrupts Windows Enhanced mode takes over; you can run INTVECT &gt; TMP.TMP, start Windows, run INTVECT
            &gt; TMP.2 from inside a DOS box, and then use diff or a similar utility to compare the files TMP.TMP and TMP.2. The difference between these two files reveals the interrupts that Windows Enhanced mode hooks using the low memory interrupt vector
            table (it also hooks some interrupts using the protected mode interrupt descriptor table). Where
            &lt; points to the pre-Windows DOS output from INTVECT, and&gt; points to the output under Windows, part of the output from diff might look like this (the complete output also shows changes to INT 0, 3, 8, 10h, 15h, 1Ch, 22h, 23h, 24h, 67h, and 68h):
        </p>
        <p><code>
        <pre>    C:\UNDOC2\CHAP6&gt;intvect 21 28 2f 2f
    INT 21h   C0B6:0942              
    INT 28h   18D4:0615   PRINT
    INT 29h   0070:0762   IO         
    INT 2Fh   1A82:000D   NLSFUNC
        </pre>
      </code></p><p>
            INT 28h is the DOS idle interrupt, and the Virtual DMA Services (VDS) use INT 4Bh. As you can see, INTVECT examines the  byte of an interrupt handler looking for code such as the ARPL instruction, which Windows Enhanced mode uses as a V86 breakpoint,
            to force a transition from user (Ring 3) code to VMM (Ring 0) code. The seeming location of the Windows V86 breakpoints inside DBLSSYS$ (DoubleSpace) is misleading; this has to do with the way Windows implements V86 breakpoints (see Chappell,
            <em>DOS Internals</em>, chapter 2).
        </p>
    </div>
    <p>
        To build INTVECT, INTVECT.C should be linked with MAP.C (listing 6-2). MAP.C attempts to provide the owner&#39;s name for each interrupt vector, using code that is explained in detail in chapter 7 (see UDMEM.C,
        <b>listing 7-XX</b>). MAP.C will be reused with another program later in this chapter, INTCHAIN.C (listing 6-5). MAP can also be compiled with -DTESTING to produce a standalone program. For example, running MAP on one machine happened to produce
        the following output, which shows that this machine is running DoubleSpace, MSCDEX, SMARTDRV (loaded high), DOSKEY (also loaded high), and XMS and EMM servers:
    </p>
    <code>
      <pre>        C:\UNDOC2\CHAP6&gt;map
        00000700   000009A0   IO
        000009A0   00001E80   DOS
        00001E80   00002010   D:
        00002010   00005780   MS$MOUSE
        00005780   00007EA0   MSCD001 
        00007EA0   00012FA0   DBLSSYS$
        00012FA0   000131F0   SETVERXX
        000131F0   00013670   XMSXXXX0
        00013670   00014950   EMMXXXX0
        00014950   000188A0   MSCDEX
        000189A0   0002A7E0   MAP
        000CAA30   000CBBA0   COMMAND
        000CBBD0   000D2C60   SMARTDRV
        000CDDA2   000CDDB4   M:
        000CDDB4   000DE470   J:
        000DE470   000DF4A0   DOSKEY
        00100000   0010FFEE   HMA
  
      </pre>
    </code>
    <h4>Listing 6-2: MAP.C</h4>
<code>
    <pre>        /* 
        MAP.C
        bcc intvect.c map.c
        bcc intchain.c map.c
        bcc -DTESTING map.c
        */
        
        #include &lt;stdlib.h&gt;
        #include &lt;stdio.h&gt;
        #include &lt; string.h &gt;
        #include <dos.h>
        
        typedef unsigned char BYTE;
        typedef unsigned short WORD;
        typedef unsigned long DWORD;
        typedef void far *FP;
        
        #ifndef MK_FP
        #define MK_FP(s,o)      ((((DWORD) s) &lt;&lt; 16) + (o))
        #endif
        
        #pragma pack(1)
        
        typedef struct {
            DWORD start, end;
            char name[9];
            } BLOCK;
            
        static BLOCK *map;
        static int num_block = 0;
        
        int cmp_func(const void *b1, const void *b2)    
        {
            if (((BLOCK *) b1)-&gt;start &lt; ((BLOCK *) b2)-&gt;start)       return -1;
            else if (((BLOCK *) b1)-&gt;start &gt; ((BLOCK *) b2)-&gt;start)  return 1;
            else                                                     return 0;
        }
        
        typedef struct {
            BYTE type;          /* &#39;M&#39;=in chain; &#39;Z&#39;=at end */
            WORD owner;         /* PSP of the owner */
            WORD size;          /* in 16-byte paragraphs */
            BYTE unused[3];
            BYTE name[8];       /* in DOS 4+ */
            } MCB;
        
        #define IS_PSP(mcb)     (FP_SEG(mcb) + 1 == (mcb)-&gt;owner)
        
        WORD get_first_mcb(void)
        {
            _asm mov ah, 52h
            _asm int 21h
            _asm mov ax, es:[bx-2]
            // retval in AX
        }
        
        typedef struct DEV {
            struct DEV far *next;
            WORD attr, strategy, intr;
            union {
                BYTE name[8], blk_cnt;
                } u;
            } DEV;
        
        #define IS_CHAR_DEV(dev)    ((dev)-&gt;attr &amp; (1 &lt;&lt; 15))
        
        DEV far *get_nul_dev(void)
        {
            _asm mov ah, 52h
            _asm int 21h
            _asm mov dx, es
            _asm lea ax, [bx+22h]
            // retval in DX:AX
        }
        
        int get_num_block_dev(DEV far *dev)
        {
            // can&#39;t rely on # block devices at SysVars[20h]?
            // walk once through dev chain just to count # blk devs
            int num_blk = 0;
            do {
                if (! IS_CHAR_DEV(dev))
                    num_blk += dev-&gt;u.blk_cnt;
                dev = dev-&gt;next;
            } while(FP_OFF(dev-&gt;next) != (WORD) -1);
            return num_blk;
        }
        
        WORD get_umb_link(void)
        {
            _asm mov ax, 5802h
            _asm int 21h
            _asm xor ah, ah
            // return value in AX
        }
        
        WORD set_umb_link(WORD flag)
        {
            _asm mov ax, 5803h
            _asm mov bx, flag
            _asm int 21h
            _asm jc error
            _asm xor ax, ax
        error:;
            // return 0 or error code in AX
        }
        
        WORD get_dos_ds(void)
        {
            _asm push ds
            _asm mov ax, 1203h
            _asm int 2fh
            _asm mov ax, ds
            _asm pop ds
            // retval in AX
        }
        
        /* find IO.SYS segment with built-in drivers */
        WORD get_io_seg(DEV far *dev)
        {
            WORD io_seg = 0;
            do {
                if (IS_CHAR_DEV(dev))
                    if (_fstrncmp(dev-&gt;u.name, &#34;CON     &#34;, 8) == 0)
                        io_seg = FP_SEG(dev);   // we&#39;ll take the last one
                dev = dev-&gt;next;
            } while(FP_OFF(dev-&gt;next) != (WORD) -1);
            return io_seg;
        }
        
        static int did_init = 0;
        
        void do_init(void)
        {
            MCB far *mcb;
            DEV far *dev = get_nul_dev();
            WORD dos_ds, io_seg, mcb_seg, next_seg, save_link;
            BLOCK *block;
            int blk, i;
            
            map = (BLOCK *) calloc(100, sizeof(BLOCK));
            block = map;
            
            io_seg = get_io_seg(dev);
            block-&gt;start = io_seg &lt;&lt; 4; block-&gt;end = (DWORD) -1;
            strcpy(block-&gt;name, &#34;IO&#34;); block++;
            
            dos_ds = get_dos_ds();
            block-&gt;start = dos_ds &lt;&lt; 4; block-&gt;end = (DWORD) -1;
            strcpy(block-&gt;name, &#34;DOS&#34;); block++;
            
            // should really check if there IS an HMA!
            block-&gt;start = 0x100000L;   block-&gt;end =  0x10FFEEL;
            strcpy(block-&gt;name, &#34;HMA&#34;); block++;
            num_block = 3;
            
            /* walk MCB chain, looking for PSPs, interrupt owners */
            if (_osmajor &gt;= 4)
            {
                mcb_seg = get_first_mcb();
                mcb = (MCB far *) MK_FP(mcb_seg, 0);
                if (_osmajor &gt;= 5)  // be lazy; see ch. 7 for DOS &lt; 5
                {
                    save_link = get_umb_link();
                    set_umb_link(1);    // access UMBs too
                }
        
                for (;;)
                {
                    next_seg = mcb_seg + mcb-&gt;size + 1;
                    if (IS_PSP(mcb))
                    {
                        block-&gt;start = ((DWORD) mcb_seg) &lt;&lt; 4;
                        block-&gt;end = ((DWORD) next_seg) &lt;&lt; 4;
                        _fstrncpy(block-&gt;name, mcb-&gt;name, 8);
                        block-&gt;name[8] = &#39;\0&#39;;
                        block++; num_block++;
                    }
                    mcb_seg = next_seg;
                    if (mcb-&gt;type == &#39;M&#39;)
                        mcb = (MCB far *) MK_FP(next_seg, 0);
                    else
                        break;
                }
            }
            
            /* walk device chain looking for non-builtin drivers */
            blk = get_num_block_dev(dev);
            do {
                MCB far *dev_mcb;
                if ((FP_SEG(dev) != dos_ds) &amp;&amp; (FP_SEG(dev) != io_seg))
                {
                    block-&gt;start = (((DWORD) FP_SEG(dev)) &lt;&lt; 4) + FP_OFF(dev);
                    dev_mcb = (MCB far *) MK_FP(FP_SEG(dev)-1,0);
                    if (dev_mcb-&gt;owner == 8)
                    {
                        dev = dev-&gt;next;
                        continue;
                    }
                    if (dev_mcb-&gt;type == &#39;M&#39;)
                        block-&gt;end = block-&gt;start + ((DWORD) dev_mcb-&gt;size &lt;&lt; 4);
                    else
                        block-&gt;end = (DWORD) -1;
                    if (IS_CHAR_DEV(dev))
                    {
                        _fstrncpy(block-&gt;name, dev-&gt;u.name, 8);
                        block-&gt;name[8] = &#39;\0&#39;;
                    }
                    else
                    {
                        blk -= dev-&gt;u.blk_cnt; // block drivers in reverse order
                        block-&gt;name[0] = blk + &#39;A&#39;;
                        block-&gt;name[1] = &#39;:&#39;;
                        block-&gt;name[2] = &#39;\0&#39;;
                    }
                    block++; num_block++;
                }
                dev = dev-&gt;next;
            } while(FP_OFF(dev-&gt;next) != (WORD) -1);
            
            if (_osmajor &gt;= 5)
                set_umb_link(save_link);
            
            qsort(map, num_block, sizeof(BLOCK), cmp_func);
            
            for (i=0, block=map; i&lt; num_block-1; i++, block++)
                if (block-&gt;end == (DWORD) -1)
                    block-&gt;end = map[i+1].start;
            if (block-&gt;end == (DWORD) -1)   // last one
                block-&gt;end = 0xFFFFFL;
            
            did_init = 1;
        }
        
        char *find_owner(DWORD lin_addr)
        {
            BLOCK *block;
            int i;
            
            if (! did_init) do_init();
            
            for (i=0, block=map; i &lt; num_block; i++, block++)
                if ((lin_addr &gt;= block-&gt;start) &amp;&amp;
                    (lin_addr &lt;= block-&gt;end))
                    return block-&gt;name;
                
            /* still here */
            return (char *) 0;
        }
        
        #ifdef TESTING
        main()
        {
            BLOCK *block;
            int i;
            do_init();
            for (i=0, block=map; i &lt; num_block; i++, block++)
                printf(&#34;%08lX   %08lX   %s\n&#34;,
                    block-&gt;start, block-&gt;end, block-&gt;name);
        }
        #endif
    </dos.h></pre>
</code>
    <p>
        With the exception of unused interrupt vectors and those (such as INT 1Eh) that point to data rather than code, you can take addresses displayed by INTVECT and unassemble them to see how a given interrupt is handled. As an example, Figure 6-1 shows INT
        29h, which is the undocumented Fast Console Output function, located by default in the CON driver provided by IO.SYS.
    </p>
    <h4>Figure 6-1: Default Implementation of INT 29h</h4>
    <code>
      <pre>        C:\UNDOC2\CHAP6&gt;intvect 29
        INT 29h   0070:0762   IO         

        C:\UNDOC2\CHAP6&gt;debug
        -u 70:762
        0070:0762 50            PUSH  AX
        0070:0763 56            PUSH  SI
        0070:0764 57            PUSH  DI
        0070:0765 55            PUSH  BP
        0070:0766 53            PUSH  BX
        0070:0767 B40E          MOV   AH,0E
        0070:0769 BB0700        MOV   BX,0007
        0070:076C CD10          INT   10
        0070:076E 5B            POP   BX
        0070:076F 5D            POP   BP
        0070:0770 5F            POP   DI
        0070:0771 5E            POP   SI
        0070:0772 58            POP   AX
        0070:0773 CF            IRET        
      </pre>
    </code>
    <p>
        That is very straightforward. INT 29h here is just a wrapper around INT 10h AH=0Eh, which is the ROM BIOS function to write a character in teletype mode.
    </p>
    <p>
        Of course, things are never quite that simple. For example, if you install ANSI.SYS, which is a replacement CON driver, INT 29h points somewhere else:
    </p>
    <code>
      <pre>        C:\UNDOC2\CHAP6&gt;intvect 29
        INT 29h   0070:0762

        C:\UNDOC2\CHAP6&gt;\undoc2\chap7\devlod \dos\ansi.sys

        C:\UNDOC2\CHAP6&gt;intvect 29
        INT 29h   6EB3:0510   DEVLOD 
      </pre>
    </code>
    <p>
        Because we loaded ANSI.SYS using DEVLOD, the INTVECT program shows DEVLOD as the owner of the interrupt vector; the owner, of course, is actually the new CON driver in ANSI.SYS. Now the code at 6EB3:0510 is no longer just a wrapper around an INT 10h call.
        Instead, it directly manipulates video memory at segment B800h and contains special handling for ANSI escape control codes. Showing the code here would take us too far afield, even for a chapter such as this that rambles more-or-less aimlessly
        through the DOS code. The point anyway is merely that the INTVECT program, simple as it is, can help us point DEBUG at useful segment:offset addresses to unassemble.
    </p>
    <p>
        But there&#39;s a major problem here. Recall that we are interested in looking at the DOS INT 21h and INT 2Fh handlers. INTVECT can of course print out the addresses of the INT 21h and INT 2Fh handlers:
    </p>
    <code>
        <pre>        C:\UNDOC2\CHAP6&gt;intvect 21 2f
        INT 21h   0F93:32B6   MSCDEX
        INT 2Fh   1305:0285   DOSKEY  
    </pre>
    </code>
    <p>
        However, as INTVECT indicates, these interrupt vectors point, not to DOS, but to DOS add-ins such as MSCDEX and DOSKEY. In fact, it is practically
        <em>guaranteed</em> that, except on the lamest, freshly booted, stripped-down system with no AUTOEXEC.BAT or CONFIG.SYS file, INT 21h, INT 2Fh, and many other DOS interrupt vectors <em>won&#39;t</em> point into DOS. The INT 21h and INT 2Fh vectors
        are pointing at one of the plug-in subsystems rather than at the DOS motherboard.
    </p>
    <p>
        Of course, if you&#39;re interested in examining MSCDEX&#39;s INT 21h handler or DOSKEY&#39;s INT 2Fh handler, the INTVECT results are very useful. They provide all the information needed by a debugger such as DEBUG or SYMDEB (a handy debugger that Microsoft once
        included with the Windows SDK). For example, by using DEBUG or SYMDEB to unassemble the 1305:0285 address displayed by INTVECT for INT 2Fh, we can see that DOSKEY watches for the Windows and task-switcher initialization broadcasts (INT 2Fh AX=1605h
        and AX=4B05h). DOSKEY clearly uses the same piece of code (here, at offset 0299h) to handle both calls. We can also see confirmation that, as documented in Microsoft&#39;s
        <em>MS-DOS Programmer&#39;s Reference</em>, DOSKEY responds to INT 2Fh AH=48h calls:
    </p>
    <code>
        <pre>        C:\UNDOC2\CHAP6&gt;intvect 2f
        INT 2Fh   1305:0285   DOSKEY
        C:\UNDOC2\CHAP6&gt;debug
        -u 1305:0285
        1305:0285 3D0516         CMP    AX,1605
        1305:0288 740F           JZ     0299
        1305:028A 3D054B         CMP    AX,4B05
        1305:028D 740A           JZ     0299
        1305:028F 80FC48         CMP    AH,48
        1305:0292 741B           JZ     02AF
        1305:0294 2EFF2E5F02     JMP    FAR CS:[025F]
        ; ...
    </pre>
    </code>
    <p>
        But if, for example, we want to see MSCDEX&#39;s INT 2Fh handler rather than DOSKEY&#39;s, and if DOSKEY is loaded after MSCDEX, INTVECT is of no use. (Note, however, that unlike MSDOS.SYS and IO.SYS, programs such as MSCDEX.EXE and DOSKEY.EXE are easy to disassemble
        on disk with a program such as Sourcer from V Communications.)
    </p>
    <p>
        More important, INTVECT doesn&#39;t help us get the address of what we might call The One True INT 21h Handler inside MSDOS.SYS. Nor does it help with finding the original INT 2Fh handlers inside MSDOS.SYS and IO.SYS.
    </p>
    <p>
        Why? Because interrupts are handled in a kind of last-in, -out (LIFO) stack. The point was made at the beginning of this chapter that the DOS philosophy is to provide the bare minimum operating system services, along with facilities for <em>extending</em>        DOS. As discussed in greater detail in chapter 9 on TSRs, one of the keys to extending DOS is INT 21h AH=25h, the DOS Set Interrupt Vector function. Along with the Get Interrupt Vector function (AH=35h), the Set Vector function allows the creation
        of what are called interrupt chains, which are essentially linked lists (or LIFO stacks) of code. An interrupt chain consists of two or more pieces of code that handle the same interrupt. The following code fragment, adapted from the FUNC0E32
        and DOSVER programs in listings 2-20 and 2-21, illustrates this:
    </p>
    <code>
<pre>        void (interrupt far *prev)();           // ptr to previous handler in chain
        prev = _dos_getvect(0x21);              // call 21/35 -- get previous
        _dos_setvect(0x21, my_int21_handler);   // call 21/25 -- set new
        // ...
        void interrupt far my_int21_handler(REG_PARAMS r)
        {
            // look at AH to see if we&#39;re interested
            // ...
            _chain_intr(prev);  // pass interrupt down to previous owner in chain
        }
</pre>
    </code>
    <p>
        The _chain_intr() does a far JMP to the previous interrupt handler in the chain, without returning. It is important to note that sometimes interrupt handlers CALL, rather than JMP to, the previous handler. This allows a handler to post-process the interrupt
        <em>after</em> the previous handler has done its work, rather than pre-processing the interrupt beforehand, which is what happens in the more typical JMP style of interrupt chaining. Sometimes the JMP-style code is called a front-end handler,
        and the CALL-style code is called a back-end handler.
    </p>
    <p>
        It is especially important that INT 21h AH=25h and 35h allow
        <em>even INT 21h itself</em> to be hooked. This is a source of tremendous flexibility in DOS, but it also makes it difficult for us to find The One True INT 21h Handler. Calling INT 21h AX=3521h returns the head of the INT 21h linked list, that
        is, the address of the most recently installed INT 21h handler. This might conceivably be the genuine DOS INT 21h handler, but more likely it belongs to MSCDEX, NETX, or perhaps even something as dumb as the FUNC0E32 or DOSVER programs from chapter
        2. INT 21h AX=35h simply returns the <em>head</em> of an interrupt chain. Finding the original INT 21h or INT 2Fh handler belonging to DOS usually requires finding the chain&#39;s <em>tail</em>. (Usually rather than always, because there might be
        back-end handlers.)
    </p>
    <p>
        How can we find the actual INT 21h and INT 2Fh handlers provided by DOS itself, when all we have is the address of the head of the INT 21h or INT 2Fh interrupt chain? There is unfortunately no function that returns the tail of an interrupt chain. And
        while there is an undocumented DOS function (INT 2Fh AX=1203h) to return the DOS data segment, there is no equivalent function that returns the DOS code segment (which, remember, may well be in the HMA).
    </p>
    <p>
        One solution would of course be to boot on an absolutely bare-bones system and hope that INT 21h and INT 2Fh point to the original MS-DOS handlers, thereby bypassing the whole problem of how to follow interrupt chains. Or you could write a device driver
        to keep track of interrupts, and install it very early in DOS initialization. But this is ridiculous! Clearly there must be some way to <em>follow</em> the interrupt chain, as the processor does this many times a second.
    </p>
    <p>
        Unfortunately, there is no standard mechanism for interrupt chaining. IBM and Microsoft at one point put forward a specification for this purpose (David Thielen described it in detail in
        <em>Microsoft Systems Journal</em> , July 1991, pp. 24-25), but unfortunately no one seems to use it. Ralf Brown has proposed an INT 2Dh protocol (described in the Interrupt List on disk) to combat the extremely long interrupt chains that currently
        plague INT 2Fh, but again you can&#39;t rely on programs to do the right thing and use this protocol.
    </p>
    <h2>Tracing a DOS INT 21h Call</h2>
    <p>
        It turns out that Microsoft provides, with every copy of DOS, an almost perfect solution to the problem of finding the actual DOS INT 21h and INT 2Fh handlers. The solution is none other than DEBUG.
    </p>
    <p>
        Like most debuggers, DEBUG has an <em>a</em> command to assemble instructions on the fly, and a <em>t</em> command for tracing into (as opposed to stepping over) instructions. Even better, unlike some otherwise more sophisticated debuggers, the
        <em>t</em> command in DEBUG can trace
        <em>into</em> an INT instruction. For the purposes of trace, in other words, DEBUG does not treat INT as an atomic operation:
    </p>
    <code>
      <pre>        C:\UNDOC2\CHAP6&gt;intvect 21
        INT 21h   0F93:32B6   MSCDEX
        C:\UNDOC2\CHAP6&gt;debug
        -a
        19B5:0100 mov ah, 62
        19B5:0102 int 21
        19B5:0104 ret
        19B5:0105 
        -t

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000  
        DS=19B5  ES=19B5  SS=19B5  CS=19B5  IP=0102   NV UP EI PL NZ NA PO NC 
        19B5:0102 CD21          INT 21                                 
        -t

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFE8  BP=0000  SI=0000  DI=0000  
        DS=19B5  ES=19B5  SS=19B5  CS=0F93  IP=32B6   NV UP DI PL NZ NA PO NC 
        0F93:32B6 80FC60        CMP AH,60                              
        
      </pre>
    </code>
    <p>
        Notice that pressing <em>t</em> at the INT 21h instruction, took us into the  line of the handler at 0F93:32B6, rather than over it to the RET instruction at 19B5:0104. This is exactly what one might expect from pressing <em>t</em> rather
        than <em>p</em> (proceed); yet because of the way the single step interrupt works on Intel processors (see INTCHAIN.C at listing 6-5 later in this chapter), most debuggers don&#39;t behave this way; it&#39;s useful that every copy of DOS comes with one
        that does.
    </p>
    <p>
        We can use this facility in order to follow the INT 21h or INT 2Fh chain down into the bowels of DOS itself. (Yuck!) All we must do is keep tracing (either by continuously pressing <em>t</em> or by telling DEBUG with a command such as <em>t 16</em>        to trace a certain number of instructions) until the segment:offset returns to DEBUG and our RET instruction (which, in the example above, is located at 19C7:0104). This will surely locate the actual DOS INT 21h or INT 2Fh handler.
    </p>
    <p>
        However, the astute reader may wish to interject right now, before we go any further, that using DEBUG to trace into INT 21h &#34;won&#39;t work&#34; because DEBUG itself uses DOS, and DOS, as we all know, is not reentrant. This is absolutely true; a debugger that
        does not use DOS, such as Nu-Mega&#39;s Soft-ICE, is better suited than DEBUG to tracing through DOS.
    </p>
    <p>
        However, there are a handful of DOS functions that <em>are</em> reentrant, at least for the purposes of tracing with DEBUG. By examining the DOS code for INT 21h, we will soon see precisely what this reentrancy or lack thereof means. In the meantime,
        simply take it on faith that the DOS INT 21h functions shown below in table 6-1, are (with an important caveat that we&#39;ll get to) reentrant, and thus traceable using DEBUG, SYMDEB, or any other debugger that uses DOS. With the exception of the
        undocumented INT 21h AH=64h, note that these are among the INT 21h functions that Microsoft ( <em>MS-DOS Programmer&#39;s Reference</em>, chapter 7) lists as callable from a critical error handler.
    </p>
    <h4>Table 6-1: Reentrant MS-DOS Functions</h4>
    <!-- 1667 -->
    <ul>
        <li>INT 21h AH=33h (Get/Set Ctrl-Break, Get Boot Drive, Get DOS Version)</li>
        <li>INT 21h AH=51h and AH=62h (Get PSP)</li>
        <li>INT 21h AH=50h (Set PSP)</li>
        <li>INT 21h AH=64h (Set Driver Lookahead Flag)</li>
        <li><em>Note:</em> These are reentrant except if DOS=HIGH and the A20 line is disabled</li>
    </ul>
    <p>
        It is desirable for MS-DOS to single out the Get and Set PSP functions for special treatment, because this means that interrupt handlers can freely call these process-manipulation functions (see chapter 9 on TSRs). But it is not at all obvious why functions
        33h and 64h merit this special attention. It would seem that other functions, such as AH=25h and AH=35h to get and set interrupt vectors, might be more useful. On the other hand, including function 33h here means that interrupt handlers can freely
        get and set the DOS BREAK= flag.
    </p>
    <p>
        Let us now use DEBUG to trace into a call to one of these functions, INT 21h AH=62h (Get PSP), and see exactly what occurs when this function is called under DOS 6.0, in a configuration with a few standard DOS TSRs such as MSCDEX and DOSKEY. The documentation
        states that function 62h takes no parameters other than the number 62h in AH, and that the function returns the current PSP in BX. You can probably guess that the DOS implementation for this function is rather simple, doing little more than loading
        BX from the CURR_PSP location in the DOS data segment. This location corresponds to offset 10h in the Swappable Data Area (SDA; see INT 21h AX=5D06h in the appendix). However, as you&#39;ll see, the processor executes a lot of code before DOS eventually
        gets to the point of carrying out the otherwise simple Get PSP operation.
    </p>
    <p>
        As noted earlier, the key facility DEBUG provides here is that (unlike SYMDEB, for example) it traces <em>into</em> the INT instruction. In Figure 6-2, comments have been added to the following DEBUG output, using ;;; to make them stand out
    </p>
    <h4>Figure 6-2: Starting to Trace a Call to INT 21h AH=62h</h4>
    <code>
      <pre>        C:\UNDOC2\CHAP6&gt;debug
        -a
        19B5:0100 mov ah, 62
        19B5:0102 int 21
        19B5:0104 ret
        19B5:0105 
        -t

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000  
        DS=19B5  ES=19B5  SS=19B5  CS=19B5  IP=0102   NV UP EI PL NZ NA PO NC 
        19B5:0102 CD21          INT 21
        -t

        ;;; We have to keep tracing until the segment:offset comes 
        back to 
        ;;; our own code, the RET instruction at 19B5:0104.

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFE8  BP=0000  SI=0000  DI=0000
        DS=19B5  ES=19B5  SS=19B5  CS=0F93  IP=32B6   NV UP DI PL NZ NA PO NC
        0F93:32B6 80FC60        CMP AH,60
        -t

        ;;; Running MEM /D showed that above is MSCDEX. This is consistent
        ;;; with output from INTVECT program. Apparently MSCDEX is interested
        ;;; in the undocumented DOS INT 21h AH=60h (Truename) function. Note that
        ;;; we were running MSCDEX /S (for network sharing); usually MSCDEX doesn&#39;t
        ;;; care about the INT 21h AH=60h call.

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFE8  BP=0000  SI=0000  DI=0000  
        DS=19B5  ES=19B5  SS=19B5  CS=0F93  IP=32B9   NV UP DI PL NZ NA PO NC 
        0F93:32B9 7405          JZ  32C0
        -t

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFE8  BP=0000  SI=0000  DI=0000  
        DS=19B5  ES=19B5  SS=19B5  CS=0F93  IP=32BB   NV UP DI PL NZ NA PO NC 
        0F93:32BB 2E            CS:
        0F93:32BC FF2EB232      JMP FAR [32B2]                         CS:32B2=15FA
        -t

        ;;; MSCDEX decided it&#39;s not interested in our call to 21/62, so it chains
        ;;; to the previous handler, whose address it earlier retrieved (by
        ;;; calling 21/35) and saved away (apparently in CS:32B2) before installing 
        ;;; (with 21/25) its own INT 21h handler.

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFE8  BP=0000  SI=0000  DI=0000  
        DS=19B5  ES=19B5  SS=19B5  CS=07F9  IP=15FA   NV UP DI PL NZ NA PO NC 
        07F9:15FA 80FC3F        CMP AH,3F

        ;;; We&#39;re now in the previous INT 21h handler. MEM /D shows that
        ;;; 07F9:15FA is SMARTDRV. Here, it&#39;s (reasonably enough) interested in
        ;;; whether we&#39;ve called INT 21h AH=3Fh to read from a file (SMARTDRV)
        ;;; wants to see if the data we want from the file is actually 
        already
        ;;; in its cache). But we called 21/62 not 21/3F so...
      </pre>
    </code>
    <p>
        Well, you get the idea. Running DEBUG this way is a bit tedious, and saving its output to a file is difficult. As an improvement, you can drive DEBUG with input scripts, such as 2162.SCR in listing 6-3, and redirect its output to a file. (For a lengthy
        discussion of DEBUG scripts, see
        <em>PC Magazine DOS Power Tools</em>, 2nd edition, chapter 9.) Furthermore, rather than repeatedly hitting <em>t</em> to trace (single step) the next instruction, you can give the trace command a numeric parameter (for example, <em>t 16</em> or
        <em>t 32</em> ) to trace a series of instructions.
    </p>
    <h4>Listing 6-3: 2162.SCR</h4>
    <code>
      <pre>        C:\UNDOC2\CHAP6&gt;type 2162.scr
        a
        mov ah, 62
        int 21
        ret
        ; blank line below is crucial to leave assembly mode!

        t 100
        q
      </pre>
    </code>
    <p>
        The only problem is in guessing how many instructions to trace; if you ask DEBUG to trace too far, it starts executing garbage. You only want to trace until you return to the RET instruction you assembled, or at least not much past it. The best bet is
         try <em>t 16</em>, examine DEBUG&#39;s output to see if the traced instructions come back, then try
        <em>t 32</em>, examine the output again, and so on. In any case,
        <em>t 100</em> happened to work here; a larger number would be needed on machines with more TSRs that hook INT 21h installed.
    </p>
    <p>
        The only problem is in guessing how many instructions to trace; if you ask DEBUG to trace too far, it starts executing garbage. You only want to trace until you return to the RET instruction you assembled, or at least not much past it. The best bet is
         try <em>t 16</em>, examine DEBUG&#39;s output to see if the traced instructions come back, then try
        <em>t 32</em>, examine the output again, and so on. In any case,
        <em>t 100</em> happened to work here; a larger number would be needed on machines with more TSRs that hook INT 21h installed.
    </p>
    <p>
        Figure 6-3 shows a complete trace into an INT 21h AH=62h call, from the time we issued the INT 21h until DOS returns to us with the current PSP in BX. Normally all that you see (or want to see!) of an INT 21h call is your input and its output. But figure
        6-3 views the DOS call &#34;through the looking glass,&#34; as it were. Instead of looking down at DOS, you&#39;ll be inside DOS looking up at the INT 21h call. This can be slightly disorienting at , but in the end you&#39;ll have a much better &gt; understanding
        of what DOS is all about.
    </p>
    <h4>Figure 6-3: Tracing a Call to INT 21h AH=62h</h4>
    <code>
    <pre>        &lt; B &gt;C:\UNDOC2\CHAP6&gt;debug &lt; 2162.scr &gt; 2162.out

        C:\UNDOC2\CHAP6&gt;type 2162.out
        -a
        19B5:0100 mov ah, 62
        19B5:0102 int 21
        19B5:0104 ret
        19B5:0105 
        -t 106

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000  
        DS=19B5  ES=19B5  SS=19B5  CS=19B5  IP=0102   NV UP EI PL NZ NA PO NC 
        19B5:0102 CD21          INT 21

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFE8  BP=0000  SI=0000  DI=0000  
        DS=19B5  ES=19B5  SS=19B5  CS=0F93  IP=32B6   NV UP DI PL NZ NA PO NC 
        0F93:32B6 80FC60        CMP AH,60

        ;;; As before (figure 6-2), we&#39;re in MSCDEX /S now.

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFE8  BP=0000  SI=0000  DI=0000  
        DS=19B5  ES=19B5  SS=19B5  CS=0F93  IP=32B9   NV UP DI PL NZ NA PO NC 
        0F93:32B9 7405          JZ  32C0 

        ;;; The AX=xxxx BX=xxxx etc. dump that DEBUG shows each time usually
        ;;; isn&#39;t important here, so from now on we&#39;ll omit it (and blank lines)
        ;;; except when the register dump is useful.

        0F93:32BB 2E            CS:                                    
        0F93:32BC FF2EB232      JMP FAR [32B2]                         CS:32B2=15FA
        07F9:15FA 80FC3F        CMP AH,3F

        ;;; As before, we&#39;re in SMARTDRV now.

        07F9:15FD 7414          JZ  1613
        07F9:15FF 80FC0D        CMP AH,0D
        07F9:1602 7426          JZ  162A
        07F9:1604 3D1325        CMP AX,2513
        07F9:1607 7451          JZ  165A
        07F9:1609 80FC68        CMP AH,68
        07F9:160C 7442          JZ  1650

        ;;; Above provides a catalog of the DOS INT 21h function calls that
        ;;; SMARTDRV cares about:  3Fh (read file), 0Dh (disk reset), 2513h
        ;;; (set INT 13h vector), 68h (commit file). All this makes sense.
        ;;; For example, SMARTDRV uses 21/0D as a signal to flush the cache.
        ;;; For some calls such as 21/0D, SMARTDRV doesn&#39;t JMP to the previous
        ;;; handler; instead, it does a far CALL and examines the 21/0D on
        ;;; the way back.

        07F9:160E 2E            CS:                                    
        07F9:160F FF2E1423      JMP FAR [2314]                         CS:2314=0800

        ;;; We called 21/62, SMARTDRV doesn&#39;t care, so SMARTDRV chains to
        ;;; previous handler, C801:0800, which SMARTDRV earlier got from 
        ;;; calling 21/35 before installing its own 21 handler with 21/25, and 
        ;;; which is stored in CS:2314.

        C801:0800 9C            PUSHF

        ;;; Was running with DOS=UMB, so some INT 21h handlers are running
        ;;; in upper memory. Don&#39;t know who the owner of this is!

        C801:0801 FB            STI
        C801:0802 3D0258        CMP AX,5802
        C801:0805 7413          JZ  081A
        C801:0807 3D0358        CMP AX,5803
        C801:080A 7431          JZ  083D
        C801:080C 80FC31        CMP AH,31
        C801:080F 7503          JNZ 0814
        C801:0814 9D            POPF

        ;;; We can see that this handler cares about calls to INT 21h functions
        ;;; 5802h (Get UBM Link), 5803h (Set UMB Link), 31h (TSR). Wonder why.
        ;;; Anyway, we called 21/62, the handler isn&#39;t interested in that, so it
        ;;; chains to the previous handler.

        C801:0815 2E            CS:                                    
        C801:0816 FF2ECE01      JMP FAR [01CE]                         CS:01CE=0023
        0255:0023 EA8E052ECC    JMP CC2E:058E                          

        ;;; DEV shows that seg 0255h is a a block-mode device driver for
        ;;; D: through I: -- it is a low-memory stub for DoubleSpace, located in
        ;;; high memory. Stacker uses the same area; both have signatures at
        ;;; 0255:0000. DEV also shows that CC2E:058E is DBLSSYS$ (DoubleSpace).

        CC2E:058E 9C            PUSHF
        CC2E:058F FB            STI
        CC2E:0590 FC            CLD
        CC2E:0591 1E            PUSH    DS
        CC2E:0592 0E            PUSH    CS
        CC2E:0593 1F            POP DS
        CC2E:0594 C606C20700    MOV BYTE PTR [07C2],00                 DS:07C2=00
        CC2E:0599 53            PUSH    BX
        CC2E:059A 8ADC          MOV BL,AH
        CC2E:059C 80FB6C        CMP BL,6C
        CC2E:059F 7759          JA  05FA
        CC2E:05A1 32FF          XOR BH,BH
        CC2E:05A3 8A9F1305      MOV BL,[BX+0513]                       DS:0575=00
        CC2E:05A7 FFA78005      JMP [BX+0580]                          DS:0580=05FA

        ;;; DoubleSpace is sufficiently tied into DOS that it uses a jump table to
        ;;; store a handler for every DOS function. The table at CC2E:0513 holds
        ;;; byte offsets into code at CC2E:0580. Most DOS functions (including
        ;;; our 21/62 call) are just passed on. Examining the table with the FTAB
        ;;; program from later in this chapter shows that DoubleSpace cares
        ;;; about the following INT 21h functions:  00, 0A, 0D, 10, 13, 17, 25, 31, 
        ;;; 36, 39, 3A, 3E, 41, 43, 4B, 4C, 56, 57, 5D, 68. We know this from 
        ;;; running &#34;ftab cc2e:0513 6d DSI21 1 | grep -v 00&#34;. For example, it hooks
        ;;; 21/25 because (like SMARTDRV) it wants to know whenever someone sets the
        ;;; INT 13h (BIOS Disk) vector.

        CC2E:05FA 5B            POP BX
        CC2E:05FB 1F            POP DS
        CC2E:05FC 9D            POPF
        CC2E:05FD 2E            CS:
        CC2E:05FE FF2E0005      JMP FAR [0500]                         CS:0500=109E

        ;;; Trivial handling for our 21/62 call. Just pass it on to previous
        ;;; handler for INT 21h...

        0116:109E 90            NOP

        ;;; MEM /D shows that 0116h is MS-DOS. Finally!

        0116:109F 90            NOP
        0116:10A0 E8CC00        CALL    116F

        ;;; Hmm, DOS is calling some subroutine (which we&#39;ve traced into):

        0116:116F 9C            PUSHF
        0116:1170 1E            PUSH    DS
        0116:1171 06            PUSH    ES
        0116:1172 51            PUSH    CX
        0116:1173 56            PUSH    SI
        0116:1174 57            PUSH    DI

        ;;; We need to see the registers for the next few instructions.
        ;;; Note what happens to DS and ES

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFDA  BP=0000  SI=0000  DI=0000  
        DS=19B5  ES=19B5  SS=19B5  CS=0116  IP=1175   NV UP DI NG NZ AC PE CY 
        0116:1175 2E            CS:                                    
        0116:1176 C5366711      LDS SI,[1167]                          CS:1167=0080

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFDA  BP=0000  SI=0080  DI=0000  
        DS=0000  ES=19B5  SS=19B5  CS=0116  IP=117A   NV UP DI NG NZ AC PE CY 
        0116:117A 2E            CS:                                    
        0116:117B C43E6B11      LES DI,[116B]                          CS:116B=0090

        AX=6200  BX=0000  CX=0000  DX=0000  SP=FFDA  BP=0000  SI=0080  DI=0090  
        DS=0000  ES=FFFF  SS=19B5  CS=0116  IP=117F   NV UP DI NG NZ AC PE CY 
        0116:117F B90400        MOV CX,0004

        0116:1182 FC            CLD
        0116:1183 F3            REPZ
        0116:1184 A7            CMPSW
        0116:1185 7407          JZ  118E

        ;;; DOS has just compared 8 bytes (4 words) at DS:SI (0000:0080) and
        ;;; ES:DI (FFFF:0090). If they are identical, DOS jumps somewhere.
        ;;; What is this?! This particular run of DEBUG was conducted with
        ;;; DOS=HIGH. DOS is in the HMA, which is only reachable when the
        ;;; machine&#39;s A20 address line is enabled. DOS is comparing 0000:0080
        ;;; and FFFF:0090 because, if the 8 bytes at these two addresses are
        ;;; identical, it assumes that memory addresses are wrapping around, and
        ;;; therefore that A20 is off. DOS can&#39;t call routines in the HMA if A20
        ;;; is off. Thus, even when DOS=HIGH there must be a low-memory stub; the
        ;;; code at 0116:109E is that stub, which ensures that A20 is enabled before
        ;;; calling DOS in the HMA. Here, A20 was already on (0000:0080 and
        ;;; FFFF:0090 were different), but A20 has been off, we would
        ;;; have jumped to the subroutine at 0116:118E, whose job
        ;;; is to enable A20 (by calling XMS function 5, Local Enable A20).
        ;;; If that function call succeeds, DOS will jump back here, just as if
        ;;; A20 had been enabled all along. If that function call fails, we&#39;re
        ;;; in big trouble: DOS uses INT 10h AH=0Eh to display &#34;A20 Hardware
        ;;; Error&#34;, and goes into a dynamic halt. We&#39;ll come back to this
        ;;; code later. Right now, A20 is enabled so...

        0116:1187 5F            POP DI
        0116:1188 5E            POP SI
        0116:1189 59            POP CX
        0116:118A 07            POP ES
        0116:118B 1F            POP DS
        0116:118C 9D            POPF
        0116:118D C3            RET
        0116:10A3 2E            CS:                                    
        0116:10A4 FF2E6A10      JMP FAR [106A]                         CS:106A=40F8

        ;;; The low-memory stub for DOS knows it can jump to DOS in the HMA, and
        ;;; here we go:

        FDC8:40F8 FA            CLI

        ;;; We are now in The One True INT 21h Handler. That this is at
        ;;; FDC8:40F8 in this particular configuration is the one piece of
        ;;; information we&#39;re after here, because now we can go and unassemble
        ;;; (rather than trace) at that address. Static unassembly is 
        ;;; generally easier than dynamic tracing. But let&#39;s see the thing
        ;;; through, to learn exactly how 21/62 is handled...

        FDC8:40F9 80FC6C        CMP AH,6C
        FDC8:40FC 77D2          JA  40D0

        ;;; Any INT 21h function &gt; 6Ch is an error. (&#34;In DOS 7.0,
        ;;; the upper limit is 72h,&#34; writes one tech reviewer.)

        FDC8:40FE 80FC33        CMP AH,33
        FDC8:4101 7218          JB  411B

        ;;; Any INT 21h function &lt; 33h will be handled at FDC8:411B.

        FDC8:4103 74A2          JZ  40A7

        ;;; 21/33 is special:  it is handled at FDC8:40A7 (in this configuration)

        FDC8:4105 80FC64        CMP AH,64
        FDC8:4108 7711          JA  411B

        ;;; Any INT 21h function &gt; 64h will also be handled at FDC8:411B; 
        ;;; seems like 411B is the handler for &#34;normal&#34; DOS calls.

        FDC8:410A 74B5          JZ  40C1

        ;;; 21/64 is another special function, handled here at FDC8:40C1

        FDC8:410C 80FC51        CMP AH,51
        FDC8:410F 74A4          JZ  40B5
        FDC8:4111 80FC62        CMP AH,62
        FDC8:4114 749F          JZ  40B5

        ;;; Finally! DOS sees our 21/62 call, and will handle it by jumping to
        ;;; FDC8:40B5. Notice that the same code also handles calls to 21/51, which 
        ;;; makes sense, since the two functions are documented as being identical.

        FDC8:40B5 1E            PUSH    DS
        FDC8:40B6 2E            CS:
        FDC8:40B7 8E1EE73D      MOV DS,[3DE7]                          CS:3DE7=0116

        ;;; DOS DS (0116h) is stored in a variable kept at CS:3DE7. This is 
        ;;; the segment where things like SysVars and SDA live. This value is
        ;;; also returned from 2F/1203 (see appendix).

        FDC8:40BB 8B1E3003      MOV BX,[0330]                          DS:0330=1408

        ;;; Believe it or not, the line above is actually the Get PSP function!
        ;;; We know that DOS keeps the current PSP at SDA+10h. In this 
        ;;; configuration, 21/5D06 (Get SDA) returns 0116:0320. The Get PSP
        ;;; function just moves the WORD at 0116:0330 into BX. In other words, 
        ;;; 21/62 (and 21/51) just return the WORD from SDA+10h. Duh.

        FDC8:40BF 1F            POP DS
        FDC8:40C0 CF            IRET

        ;;; DOS IRETs back to our code running in DEBUG

        19B5:0104 C3            RET

        ;;; This is the RET statement in our DEBUG script.

        19B5:0000 CD20          INT 20
        0116:1094 90            NOP

        ;;; Our script has already returned to DEBUG, which did an INT 20h return
        ;;; to DOS. At this point, we start tracing all sorts of things we don&#39;t
        ;;;  care about. If we trace too far, we start to make DEBUG execute
        ;;; garbage, which can hang the machine.
        -q
            
    </pre>  
    </code>
    <!-- 2469 -->
    <p>
        The most noticeable feature of the INT 21h trace in figure 6-3 is the way that DOS extensions such as SMARTDRV and MSCDEX become indistinguishable from DOS itself. If any non-Microsoft DOS extensions such as Novell NetWare or Stacker had been running,
        they too would have appeared in the INT 21h chain, looking not a bit different from any of the Microsoft-provided software in the chain. The walk through the INT 21h chain in figure 6-3 thus presents an excellent illustration of what DOS really
        is.
    </p>
    <h3>Unassembling the Get/Set PSP Functions</h3>
    <p>
        As you can see, under normal circumstances with a few TSRs loaded, you have to wade through a lot just to get to the single line of code that actually performs the DOS Get PSP function. It should now be clear why INT 21h is called an interrupt &#34;chain.&#34;
        As you&#39;ll see later, the INT 2Fh chain is typically much longer than the INT 21h chain. Given the overhead of INT 21h on a typical machine, programmers might even consider writing their own Get PSP calls to bypass this long interrupt chain. Seeing
        how DOS implements Get PSP (when it eventually gets there!), you can also see how to implement your own:
    </p>
    <code>
<pre>        // uses get_sda() from GETSDA.C (listing 3-4a)
        WORD my_get_psp(void)
        {
            static WORD far *psp_ptr = (WORD far *) 0;
            if (! psp_ptr)                  // one-time init
                psp_ptr = (WORD far *) (get_sda() + 0x10);
            return *psp_ptr;
        }
</pre>
    </code>
    <p>
        Of course, this would cut out any TSRs or drivers that might actually need to see and respond to DOS Get PSP calls.
    </p>
    <p>
        Having already seen the code that handles the Get PSP function (INT 21h AH=51h and 62h), we might as well also examine the code for Set PSP, though we can guess what it&#39;s going to look like (we&#39;ll see later in figure 6-7 where the 40A9h address comes
        from):
    </p>
    <h4>
        Figure 6-4: Implementation of INT 21h AH=50h (Set PSP) in MS-DOS 6.0
    </h4>
    <code>
<pre>        -u fdc8:40a9
        FDC8:40A9 1E            PUSH    DS          ; save caller&#39;s DS
        FDC8:40AA 2E            CS:
        FDC8:40AB 8E1EE73D      MOV DS,[3DE7]       ; switch to DOS DS
        FDC8:40AF 891E3003      MOV [0330],BX       ; put caller&#39;s BX into CURR_PSP
        FDC8:40B3 1F            POP DS              ; restore caller&#39;s DS
        FDC8:40B4 CF            IRET                ; done!
</pre>
    </code>
    <p>
        In other words, the Get and Set PSP functions just manipulate this word at offset 330h in the DOS data segment (offset 10h in the SDA). This provides a small taste of how DOS internally uses such externally-visible structures as SysVars and the SDA. Thus:
    </p>
    <code>
<pre>        void my_set_psp(WORD psp)
        {
            static WORD far *psp_ptr = (WORD far *) 0;
            if (! psp_ptr)                  // one-time init
                psp_ptr = (WORD far *) (get_sda() + 0x10);
            *psp_ptr = psp;
        }
</pre>
    </code>
    <h3>Unassembling INT 21h AH=33h</h3>
    <p>
        A glance towards the end of the DEBUG output in figure 6-3 shows that MS-DOS special-cases a handful of functions: 33h, 51h, 62h, 64h, and (not shown in figure 6-3) 50h. These functions correspond to the reentrant DOS functions listed in table 6-1 above.
        While we&#39;re still not quite in a position to understand what makes these functions different from all other DOS functions, we do at any rate now have a bunch of addresses that we can unassemble. Recall that this was our goal in tracing through
        DOS.
    </p>
    <p>
        For example, INT 21h AH=33h is an omnibus function with a number of subfunctions relating to Ctrl-Break, the Boot Drive, and the DOS Version. For example, setting BREAK=ON ends up calling INT 21h AX=3300h with DL=1. In this configuration, code at FDC8:40A7
        handles this function:
    </p>
    <code>
<pre>        FDC8:40FE 80FC33        CMP AH,33
        FDC8:4101 7218          JB  411B
        FDC8:4103 74A2          JZ  40A7
</pre>
    </code>
    <p>
        We can now unassemble (rather than trace) at this address, using DEBUG or any other DOS debugger. Comments have been added to the output in figure 6-5, which has also been cleaned up slightly.
    </p>
    <h4>Figure 6-5: Implementation of INT 21h AH=33h in MS-DOS 6.0</h4>
    <code>
        <pre>        C:\UNDOC2\CHAP6&gt;debug
        -u fdc8:40a7
        FDC8:40A7 EBA9          JMP 4052

        -u fdc8:4052
        FDC8:4052 3C06          CMP AL,06       ; functions 3300h through 3306h
        FDC8:4054 7603          JBE 4059
        FDC8:4056 B0FF          MOV AL,FF       ; error: subfunction number too high
        FDC8:4058 CF            IRET
        FDC8:4059 1E            PUSH    DS      ; save caller&#39;s DS
        FDC8:405A 2E            CS:                                    
        FDC8:405B 8E1EE73D      MOV DS,[3DE7]   ; switch to DOS&#39;s DS; hmm, not truly
        FDC8:405F 50            PUSH    AX      ;     reentrant after all!
        FDC8:4060 56            PUSH    SI
        FDC8:4061 BE3703        MOV SI,0337     ; offset of break flag:  SDA+17h
        FDC8:4064 32E4          XOR AH,AH       ; see if subfunct 0
        FDC8:4066 0BC0          OR  AX,AX
        FDC8:4068 7504          JNZ 406E
        FDC8:406A 8A14          MOV DL,[SI]     ; 21/3300 -- get break flag
        FDC8:406C EB35          JMP 40A3
        FDC8:406E 48            DEC AX          ; see if subfunct 1
        FDC8:406F 7507          JNZ 4078                               
        FDC8:4071 80E201        AND DL,01                              
        FDC8:4074 8814          MOV [SI],DL     ; 21/3301 -- set break flag
        FDC8:4076 EB2B          JMP 40A3
        FDC8:4078 48            DEC AX          ; see if subfunct 2
        FDC8:4079 7507          JNZ 4082
        FDC8:407B 80E201        AND DL,01                              
        FDC8:407E 8614          XCHG DL,[SI]    ; 21/3302 (UNDOC) -- get/set brk flg
        FDC8:4080 EB21          JMP 40A3        ;   as single atomic operation: XCHG
        FDC8:4082 3D0300        CMP AX,0003 ; see if subfnc 5 (already subtracted 2)
        FDC8:4085 7506          JNZ 408D                               
        FDC8:4087 8A166900      MOV DL,[0069]   ; 21/3305 -- get startup drive
        FDC8:408B EB16          JMP 40A3
        FDC8:408D 3D0400        CMP AX,0004 ; see if subfnc 6 (already subtracted 2)
        FDC8:4090 7511          JNZ 40A3
        FDC8:4092 BB0600        MOV BX,0006     ; 21/3306 -- MS-DOS version 6.0
        FDC8:4095 B200          MOV DL,00
        FDC8:4097 32F6          XOR DH,DH                              
        FDC8:4099 803E111200    CMP BYTE PTR [1211],00  ; is DOS=HIGH?
        FDC8:409E 7403          JZ  40A3                               
        FDC8:40A0 80CE10        OR  DH,10       ; DOSINHMA flag
        FDC8:40A3 5E            POP SI          ; done: restore caller&#39;s regs
        FDC8:40A4 58            POP AX
        FDC8:40A5 1F            POP DS
        FDC8:40A6 CF            IRET            ; return to caller
        </pre>
    </code>
    <p>
        In addition to showing how DOS happens to handle function 33h, the code in figure 6-5 also provides many snippets of information than can be used to understand the disassembly listing of other parts of MS-DOS. For example, Microsoft documents INT 21h
        AX=3306h as returning the DOSINHMA flag in DH. The end of figure 6-5 shows DOS using the byte at DOS_DS:[1211h] to set DH. Therefore, DOS_DS:[1211h] must be the DOS=HIGH indicator. This is not important by itself, but you can use this factoid
        to help you understand other parts of the code: anywhere you see DOS:DS:[1211h], you now know that this is the DOSINHMA flag.
    </p>
    <p>
        Similarly, functions 3300h and 3301h are known to get and set the Ctrl-C flag; figure 6-5 shows these functions manipulating the byte at offset 0337h in the DOS data segment; this byte must then be the Ctrl-C (or break) flag. (Later on, at step in figure
        6-7, we&#39;ll see how DOS uses this flag.) Finally, Microsoft documents INT 21h AX=3305h as returning the startup drive in DL, and the code in figure 6-5 clearly shows DOS setting DL from DOS_DS:[0069h]. Therefore, anywhere else in the code where
        you see DOS_DS:[0069h], you can now translate this to STARTUP_DRIVE. Q.E.D.
    </p>
    <h3>Examining the Low-Memory Stub for DOS=HIGH</h3>
    <p>
        Another interesting location to examine is the function that DOS&#39;s low memory stub calls when DOS=HIGH, but the A20 line is disabled. The processor&#39;s A20 address line accesses memory above one megabyte. PCs based on 286 and higher processors disable A20
        in order to emulate address wraparound on 8088 PCs. If DOS=HIGH but A20 is off, DOS must  enable A20 before it can reach its code in HMA above one megabyte. But if DOS&#39;s code is located above one megabyte, how can it check A20 in the 
        place? With a function that it keeps in low memory when DOS=HIGH. Earlier (figure 6-3) you saw this was located at 0116:118E; figure 6-6 shows what this function actually does.
    </p>
    <h4>Figure 6-6: DOS Function Called When DOS=HIGH But A20 Is Off</h4>
<code>
    <pre>        -u 116:118e
        0116:118E 53            PUSH    BX
        0116:118F 50            PUSH    AX
        0116:1190 8CD0          MOV     AX,SS
        0116:1192 2E            CS:
        0116:1193 A38610        MOV     [1086],AX
        0116:1196 2E            CS:
        0116:1197 89268810      MOV     [1088],SP   ; save caller&#39;s stack
        0116:119B 8CC8          MOV     AX,CS       ; switch to a DOS stack; hmm, not
        0116:119D 8ED0          MOV     SS,AX       ;    reentrant at all if A20 off!
        0116:119F BCA007        MOV     SP,07A0     ; SDA+480h=end of Crit Err Stack
        0116:11A2 B405          MOV     AH,05       ; XMS func 5 = Local Enable A20
        0116:11A4 2E            CS:
        0116:11A5 FF1E6311      CALL    FAR [1163]  ; XMS address from 2F/4310
        0116:11A9 0BC0          OR      AX,AX
        0116:11AB 740F          JZ      11BC        ; failed: can&#39;t turn A20 on!!

        ;;; okay:
        0116:11AD 2E            CS:
        0116:11AE A18610        MOV AX,[1086]
        0116:11B1 8ED0          MOV SS,AX
        0116:11B3 2E            CS:
        0116:11B4 8B268810      MOV SP,[1088]   ; switch back to caller&#39;s stack
        0116:11B8 58            POP AX
        0116:11B9 5B            POP BX
        0116:11BA EBCB          JMP 1187  ; jump back into normal code (fig. 6-3)
                                    ; as if A20 had been enabled all along.

        ;;; fail:
        0116:11BC B40F          MOV AH,0F       ; come here if couldn&#39;t enable A20
        0116:11BE CD10          INT 10          ; get video mode
        0116:11C0 3C07          CMP AL,07
        0116:11C2 7406          JZ  11CA
        0116:11C4 32E4          XOR AH,AH
        0116:11C6 B002          MOV AL,02       ; set normal text mode
        0116:11C8 CD10          INT 10
        0116:11CA B405          MOV AH,05
        0116:11CC 32C0          XOR AL,AL       ; set display page 0
        0116:11CE CD10          INT 10
        0116:11D0 BEB812        MOV SI,12B8     ; 12B8 -&gt; &#34;\nA20 Hardware Error\n$&#34;
        0116:11D3 0E            PUSH    CS
        0116:11D4 1F            POP DS
        0116:11D5 FC            CLD
        0116:11D6 AC            LODSB
        0116:11D7 3C24          CMP AL,24       ; look for &#39;$&#39;
        0116:11D9 7409          JZ  11E4
        0116:11DB B40E          MOV AH,0E       ; write in TTY mode (use BIOS
        0116:11DD BB0700        MOV BX,0007     ;    since can&#39;t make DOS calls
        0116:11E0 CD10          INT 10          ;    here!)
        0116:11E2 EBF2          JMP 11D6
        0116:11E4 FB            STI
        0116:11E5 EBFD          JMP 11E4        ; tight little loop (INTs on)

        -d 116:12b8
        0116:12B0                         -0D 0A 41 32 30 20 48 61          ..A20 Ha
        0116:12C0  72 64 77 61 72 65 20 45-72 72 6F 72 0D 0A 24 36  rdware Error..$6
    </pre>
</code>
    <p>
        Notice, by the way, that DOS leaves the A20 line on. This reduces the overhead of keeping the DOS code in the HMA: DOS probably doesn&#39;t have to call the low-memory stub in figure 6-6 very often.
    </p>
    <p>
        That all <em>calls</em> to DOS in the HMA are guarded with this low- memory stub brings up an interesting question: what about <em>data</em> in the HMA? MS-DOS doesn&#39;t put internal data structures such as the Current Directory Structure (CDS)
        and System File Tables (SFT) up in the HMA, because this would break too many third-party applications that peek and poke these ostensibly-internal structures and that wouldn&#39;t know to  ensure that A20 is enabled. However, DOS does keep its
        BUFFERS in the HMA. If a program such as BUFFERS.C in chapter 8 (see listing 8-8) accesses the DOS sector buffers (&#34;or if some future version of DOS has FILESHIGH or LASTDRIVEHIGH statements that use HMA,&#34; adds one tech reviewer), the program
        would need to check and possible reenable A20, just like DOS does in figure 6-6. But since, from what we&#39;ve just seen, any trivial DOS call will ensure that A20 is turned on, perhaps a program that accesses data in the HMA merely needs to preface
        that access with a trivial DOS call: DOS will take care of checking the A20 state and, if necessary, calling XMS function 5 to enable A20. But any TSR could turn it off! How frequently should programs that access the HMA check the A20 state? How
        much of a problem is this? Is the extra few kbytes gained by putting data in the HMA worth this kind of uncertainty? (&#34;Ouch! This makes my head hurt,&#34; says one of the tech reviewers)
    </p>
    <h3>Examining the INT 21h Dispatch Function</h3>
    <p>
        Of all the addresses we found through tracing the INT 21h call, the most important is that of DOS&#39;s INT 21h handler, seen above in figure 6-3 at FDC8:40F8. This is really the piece of information we wanted all along. To see exactly what happens during
        an INT 21h call, we can now disassemble at this address. By tracing an INT 21h AH=62h, we only saw those snippets that happen to get executed when calling the Get PSP function; we can now look at the entire function. Here it is (figure 6-7), the
        DOS INT 21h handler (this time we&#39;ve used SYMDEB and added some labels as well as comments). In Microsoft&#39;s source code, this all important function, located in MSDISP.ASM, is called COMMAND.
    </p>
    <h4>Figure 6-7: MS-DOS 6.0 INT 21h Dispatch Function</h4>
    <code>
      <pre>        -u fdc8:40f8
        FDC8:40F8 FA             CLI                    ; disable interrupts
        FDC8:40F9 80FC6C         CMP    AH,6C
        FDC8:40FC 77D2           JA     40D0            ; invalid function number

        ; step 1
        FDC8:40FE 80FC33         CMP    AH,33
        FDC8:4101 7218           JB     411B            ; normal DOS function
        FDC8:4103 74A2           JZ     40A7            ; do 21/33 (fig. 6-5)
        FDC8:4105 80FC64         CMP    AH,64
        FDC8:4108 7711           JA     411B            ; normal DOS function
        FDC8:410A 74B5           JZ     40C1            ; do 21/64
        FDC8:410C 80FC51         CMP    AH,51
        FDC8:410F 74A4           JZ     40B5            ; do Get PSP
        FDC8:4111 80FC62         CMP    AH,62
        FDC8:4114 749F           JZ     40B5            ; do Get PSP (51==62)
        FDC8:4116 80FC50         CMP    AH,50
        FDC8:4119 748E           JZ     40A9            ; do Set PSP (fig. 6-4)

        normal_DOS:
        ; step 2
        ; caller&#39;s flags, CS, and IP of course already pushed on the stack by INT
        FDC8:411B 06             PUSH   ES   ; 10h   ; Save regs on caller&#39;s stack.
        FDC8:411C 1E             PUSH   DS   ; 0Eh   ; The order is important, as
        FDC8:411D 55             PUSH   BP   ; 0Ch   ; later on different INT 21h
        FDC8:411E 57             PUSH   DI   ; 0Ah   ; functions will access the
        FDC8:411F 56             PUSH   SI   ; 08h   ; caller&#39;s original registers
        FDC8:4120 52             PUSH   DX   ; 06h   ; by treating this stack frame
        FDC8:4121 51             PUSH   CX   ; 04h   ; as a structure. See 2f/1218.
        FDC8:4122 53             PUSH   BX   ; 02h   ; For example, caller&#39;s BX
        FDC8:4123 50             PUSH   AX   ; 00h   ; is at offset 2, ES at 10h.

        ; step 3
        FDC8:4124 8CD8           MOV    AX,DS
        FDC8:4126 2E8E1EE73D     MOV    DS,CS:[3DE7]       ; get DOS DS
        FDC8:412B A3EC05         MOV    [05EC],AX          ; save caller&#39;s DS
        FDC8:412E 891EEA05       MOV    [05EA],BX          ; save caller&#39;s BX
        FDC8:4132 A18405         MOV    AX,[0584]   ; SDA+264h = ptr to stack frame
        FDC8:4135 A3F205         MOV    [05F2],AX   ;    containing user registers
        FDC8:4138 A18605         MOV    AX,[0586]   ;    on INT 21h
        FDC8:413B A3F005         MOV    [05F0],AX

        ; step 4
        FDC8:413E 33C0           XOR    AX,AX              ; set AX=0
        FDC8:4140 A27205         MOV    [0572],AL
        FDC8:4143 F606301001     TEST   Byte Ptr [1030],01 ; Is Win3 Enh running?
        FDC8:4148 7503           JNZ    414D
        ; following line only if Windows 3 Enhanced mode not running!
        FDC8:414A A33E03         MOV    [033E],AX          ; set machine ID to zero

        ; step 5
        FDC8:414D FE062103       INC    Byte Ptr [0321]    ; increment InDOS flag

        ; step 6
        FDC8:4151 89268405       MOV    [0584],SP          ; SDA+264h
        FDC8:4155 8C168605       MOV    [0586],SS          ; save current stack ptr
        FDC8:4159 A13003         MOV    AX,[0330]          ; get current PSP
        FDC8:415C A33C03         MOV    [033C],AX          ; SDA+1Ch = SHARE, NET PSP
        FDC8:415F 8ED8           MOV    DS,AX              ; point DS at caller&#39;s PSP
        FDC8:4161 58             POP    AX
        FDC8:4162 50             PUSH   AX                 ; get back caller&#39;s AX 
        FDC8:4163 89262E00       MOV    [002E],SP          ; save current stack ptr
        FDC8:4167 8C163000       MOV    [0030],SS          ;    in caller&#39;s PSP
        FDC8:416B 2E8E16E73D     MOV    SS,CS:[3DE7]  
        ; INT 21h AX=5D00h (Server Function Call) jumps to here
                                                    ; switch stack to 07A0h-SDA =
        FDC8:4170 BCA007         MOV    SP,07A0  ;   SDA+480h=end of Crit Err Stk

        ; step 7
        FDC8:4173 FB             STI                        ; reenable interrupts
        FDC8:4174 8CD3           MOV    BX,SS
        FDC8:4176 8EDB           MOV    DS,BX               ; point DS at DOS_DS
        FDC8:4178 93             XCHG   AX,BX               ; caller&#39;s AX into BX
        FDC8:4179 33C0           XOR    AX,AX
        FDC8:417B 36A2F605       MOV    SS:[05F6],AL        ; extended open off?
        FDC8:417F 36812611060008 AND    Word Ptr SS:[0611],0800
        FDC8:4186 36A25703       MOV    SS:[0357],AL        ; set different vars to 0
        FDC8:418A 36A24C03       MOV    SS:[034C],AL
        FDC8:418E 36A24A03       MOV    SS:[034A],AL
        FDC8:4192 40             INC    AX
        FDC8:4193 36A25803       MOV    SS:[0358],AL        ; okay to do INT 28h

        ; step 8
        FDC8:4197 93             XCHG   AX,BX               ; get 
        back caller&#39;s AX
        FDC8:4198 8ADC           MOV    BL,AH               ; DOS 
        func num into BL
        FDC8:419A D1E3           SHL    BX,1    ; make DOS func number 
        into word ofs

        ; step 9
        FDC8:419C FC             CLD
        FDC8:419D 0AE4           OR     AH,AH
        FDC8:419F 7417           JZ     41B8            ; AH=0 (terminate process)
        FDC8:41A1 80FC59         CMP    AH,59
        ; if 21/59 (get critical error), bypass code that turns off critical error!
        FDC8:41A4 7444           JZ     41EA            ; AH=59h (get extended error)
        FDC8:41A6 80FC0C         CMP    AH,0C
        FDC8:41A9 770D           JA     41B8            ; AH &gt; 0Ch

        INT21_01_THRU_0C:
        ; step 10
        FDC8:41AB 36803E200300   CMP    Byte Ptr SS:[0320],00  ; critical error set?
        FDC8:41B1 7537           JNZ    41EA    ; if so, stay with crit error stack
        FDC8:41B3 BCA00A         MOV    SP,0AA0 ; SDA+780h=end of Char I/O Stack
        FDC8:41B6 EB32           JMP    41EA

        INT21_00:
        INT21_ABOVE_0C: ;;; except (normally) 33h, 50h, 51h, 59h, 62h, 64h
        ; step 11
        FDC8:41B8 36A33A03       MOV    SS:[033A],AX
        FDC8:41BC 36C606230301   MOV    Byte Ptr SS:[0323],01  ; crit err locus
        FDC8:41C2 36C606200300   MOV    Byte Ptr SS:[0320],00  ; turn off crit error
        FDC8:41C8 36C6062203FF   MOV    Byte Ptr SS:[0322],FF  ; crit err drive#

        ; Windows Enhanced mode patches next four lines into a far call!
        FDC8:41CE 50             PUSH   AX
        FDC8:41CF B482           MOV    AH,82
        FDC8:41D1 CD2A           INT    2A                    ; End crit section
        FDC8:41D3 58             POP    AX

        FDC8:41D4 36C606580300   MOV    Byte Ptr SS:[0358],00   ; no INT 28h
        FDC8:41DA BC2009         MOV    SP,0920        ; SDA+600h = end of Disk Stack
        FDC8:41DD 36F6063703FF   TEST   Byte Ptr SS:[0337],FF ; SDA+17h=break flag
        FDC8:41E3 7405           JZ     41EA
        FDC8:41E5 50             PUSH   AX                      ; BREAK=ON, so
        FDC8:41E6 E8964E         CALL   907F                    ; check ctrl-break
        FDC8:41E9 58             POP    AX

        ; step 12
        ;;; next four lines are the key; call through dispatch table
        ;;; BX holds caller&#39;s INT 21h function number SHL 1 (word offset)
        FDC8:41EA 2E8B9F9E3E     MOV    BX,CS:[BX+3E9E]  ; get func handler addr
        FDC8:41EF 36871EEA05     XCHG   BX,SS:[05EA]     ; move func ptr into var
        FDC8:41F4 368E1EEC05     MOV    DS,SS:[05EC]  ; switch to caller&#39;s saved DS
        FDC8:41F9 36FF16EA05     CALL   SS:[05EA]        ; call func handler addr!
        ;;; we&#39;ve just called the DOS function for the specific DOS function in AH

        ; step 13
        ;;; now into cleanup preparatory to returning to caller
        FDC8:41FE 3680268600FB   AND    Byte Ptr SS:[0086],FB
        FDC8:4204 FA             CLI
        FDC8:4205 2E8E1EE73D     MOV    DS,CS:[3DE7]     ; switch back to DOS DS
        FDC8:420A 803E850000     CMP    Byte Ptr [0085],00
        FDC8:420F 7527           JNZ    4238
        FDC8:4211 FE0E2103       DEC    Byte Ptr [0321]         ; decrement InDOS
        FDC8:4215 8E168605       MOV    SS,[0586]        ; switch back to caller&#39;s
        FDC8:4219 8B268405       MOV    SP,[0584]        ;   stack
        FDC8:421D 8BEC           MOV    BP,SP
        FDC8:421F 884600         MOV    [BP+00],AL
        FDC8:4222 A1F205         MOV    AX,[05F2]
        FDC8:4225 A38405         MOV    [0584],AX        ; caller&#39;s SP
        FDC8:4228 A1F005         MOV    AX,[05F0]
        FDC8:422B A38605         MOV    [0586],AX        ; caller&#39;s SS
        FDC8:422E 58             POP    AX               ; put back caller&#39;s
        FDC8:422F 5B             POP    BX               ; registers, including
        FDC8:4230 59             POP    CX               ; any changes the DOS
        FDC8:4231 5A             POP    DX               ; function made to them
        FDC8:4232 5E             POP    SI
        FDC8:4233 5F             POP    DI
        FDC8:4234 5D             POP    BP
        FDC8:4235 1F             POP    DS
        FDC8:4236 07             POP    ES
        FDC8:4237 CF             IRET
        
      </pre>    
    </code>
    <p>
        The dispatch function in figure 6-7 is the heart of DOS. It is executed every time a program issues an INT 21h call. The dispatch function is the DOS equivalent of the function syscall() in UNIX, which has been examined in books such as Bach&#39;s <em>Design of the UNIX Operating System</em>        (pp. 165-168) and Andleigh&#39;s <em>UNIX System Architecture</em> (pp. 21-23). The discussions of syscall() in these and other UNIX books provides a useful background for to understanding the INT 21h dispatch code. However, in UNIX there is a clear
        separation between applications and the operating system. The discussions of syscall() emphasize the transition from user mode to kernel mode. As you can see, there is nothing like this in DOS, though DOS extenders such as Windows do maintain
        a separation between the application running in protected mode and DOS running in real mode. Actually, there is one important separation. DOS usually switches from the application&#39;s stack to one of its own. This important aspect of DOS will be
        discussed in detail below.
    </p>
    <p>
        Near the top of the function (commented &#34;step 1&#34;), you see how DOS picks off a handful of special functions (33h, 64h, 51, 62h, and 50h). These of course are none other than what we&#39;ve been calling the reentrant DOS functions. Here, reentrancy simply
        means that, while the above code is executing—after it has passed the initial CLI, and before it has executed the closing IRET—it could be interrupted by an interrupt handler, and the interrupt handler could call one of these five
        functions. These five functions are reentrant simply in the sense that DOS handles them before switching stacks and incrementing the InDOS flag. Thus, an interrupt handler can call these functions, even if the InDOS or critical error flag is set.
    </p>
    <p>
        In a larger sense, of course, these functions aren&#39;t really reentrant, given the way that, for example, the Set PSP function writes to a global variable (see figure 6-4). MS-DOS&#39;s extensive reliance on global variables makes it completely non-reentrant.
        Furthermore, if DOS=HIGH and the A20 line is off, DOS, as figure 6-6 showed, has to switch stacks. But in any case, it should now be clear why we picked INT 21h AH=62h to trace with DEBUG and not, say, INT 21h AH=52h; DOS handles the latter function
        only after switching stacks.
    </p>
    <p>
        Next (step 2), the INT 21h dispatch code pushes the caller&#39;s registers on to the caller&#39;s stack. The caller is of course simply whatever program issued the INT 21h call. This can be slightly disorienting because, of course, we&#39;re used to thinking about
        INT 21h from the caller&#39;s perspective and now we&#39;re looking at it from DOS&#39;s point of view. These pushed registers form a structure that many DOS functions use later on. Undocumented INT 2Fh AX=1218 (Get Caller&#39;s Registers; see appendix) returns
        a pointer to this structure.
    </p>
    <p>
        At step 3 in figure 6-7, DOS saves away the caller&#39;s DS and BX again, and switches from the caller&#39;s DS to its own DS. DOS keeps DS in a variable accessible through DOS&#39;s CS. It also available by calling INT 2Fh AX=1203h (see get_dos_ds() in listing 6-2).
        Note that, even though DOS=HIGH and the DOS code is in the HMA, the data segment is still in low memory. This is necessary because many existing DOS programs rely on the ability to reach DOS internal data structures and wouldn&#39;t know to 
        check the status of the A20 line. Microsoft has to introduce improvements such as DOS=HIGH without breaking existing applications.
    </p>
    <p>
        The next interesting thing the code does (step 4) is check a variable at 1030h to see whether Windows 3.x Enhanced mode (or Windows/386 2.x) is running. Since most of us think of Windows as something that runs &#34;on top of&#34; DOS, it is a bit disconcerting
        at  to learn that DOS 5.0 and higher knows about Windows. As discussed in chapter 1, however, this part at least of the intricate DOS/Windows connection is implemented using documented functionality. In its INT 2Fh handler, MSDOS.SYS monitors
        the AX=1605h Windows initialization and AX=1606h exit broadcasts; the code for AX=1605h sets the variable at 1030h (actually, just the byte at 1031h), and the code for AX=1606h clears it. This variable thus serves as a kind of InWindows flag.
        It&#39;s important to underline that this is for Enhanced mode only; DOS doesn&#39;t care one way or the other about Standard mode.
    </p>
    <p>
        If Windows Enhanced mode is <em>not</em> running, then DOS zeroes out a variable at 033Eh (SDA+1Eh), used by DOS as the machine ID. If Windows Enhanced mode is running, the DOSMGR VxD (as explained in chapter 1) has smacked a virtual machine ID
        in here. DOS uses this VM ID to manage SFTs.
    </p>
    <p>
        Next (step 5), the code increments the InDOS flag, which is simply a variable at 0321h (SDA+1) in the DOS data segment. The until-recently-undocumented function INT 21h AH=34h (Get InDOS Flag Address) returns a pointer to this variable.
    </p>
    <p>
        The InDOS flag has been set, so we&#39;re now &#34;in DOS&#34;! Of course, we were in DOS before, but the significance of this spot is that DOS is about to switch stacks. Switching stacks requires a guard or semaphore, namely the InDOS flag. Notice, however, that
        while DOS increments the InDOS flag, it does not check it before proceeding. Thus, InDOS is not a true semaphore. If the processor is interrupted in the middle of this code (or, rather, a little further on when DOS reenables interrupts with an
        STI instruction), the code can be reentered.
    </p>
    <p>
        In other words, DOS does nothing to enforce its requirement that only one caller at a time execute inside the INT 21h code. Obeying the InDOS flag is merely a convention. But it is vital that programs do observe this convention, because making an INT
        21h call when InDOS is set will almost always cause problems. For one thing, DOS relies on many global variables. If, for example, DOS were working with a particular hard-disk cluster to service an INT 21h file I/O call, and an interrupt handler
        that ignored the InDOS flag made a file I/O call to DOS before DOS had finished with the  one, DOS would mistakenly use the second caller&#39;s cluster to satisfy (not!) the  caller&#39;s request. Global variables do not work like a last-in/-out
        stack. It is vital that interrupt handlers check InDOS before issuing INT 21h calls. (So why did it take Microsoft so long to document InDOS and the INT 21h AH=34h function that returns a pointer to it?)
    </p>
    <p>
        Ignoring InDOS can cause another problem. Because the code at step 5 in figure 6-7 increments InDOS, reentering DOS means that InDOS will take on a value of two or greater. This is bad, because the internal DOS function that checks for Ctrl-C only does
        so when CMP Byte Ptr IN_DOS, 01. Thus, if InDOS is 2 or greater, DOS won&#39;t check Ctrl-C, even if BREAK=ON.
    </p>
    <p>
        There is a method by which DOS can be safely reentered: if the entire DOS state (including all three DOS stacks) is saved and restored by each caller, and if each such caller observes the DOS critical sections by hooking INT 2Ah. The SDA TSR technique
        put forward in chapter 9 is an approximation to this method, though only an approximation because the SDA does not include the entire DOS state.
    </p>
    <p>
        Returning to step 6 in figure 6-7, you can see the beginnings of the stack switching code. How does DOS switch away from the user&#39;s stack to one of its own? , it saves away the caller&#39;s current SS:SP. Next, DOS gets the current PSP (at 0330h, or
        SDA+10h) and uses it to save the caller&#39;s SS:SP at offset 2Eh in the caller&#39;s PSP. Finally, it sets SS:SP to a DOS stack. Depending on the DOS function number, it may switch again to a different DOS stack; see below.
    </p>
    <p>
        What is the purpose of stack switching? Why not just use the caller&#39;s stack? Wouldn&#39;t that make DOS much more reentrant? Yes, it would. As it is, making an INT 21h call already uses 18h bytes on the caller&#39;s stack (see table 6-2). If the caller could
        be relied upon to provide a large enough stack, DOS could even be multithreaded. Unfortunately, DOS has to accommodate programs with unknown stack sizes. This complicates DOS tremendously and helps make it non-reentrant.
    </p>
    <p>
        At the very end of step 6, where DOS points SP at the Critical Error stack, is a location (called Redisp in the source code) to which undocumented INT 21h AX=5D00h (Server Function Call) jumps. This function is a backdoor into the INT 21h dispatcher.
        If a network-aware program hooks this call, it can be used by one machine to do remote INT 21h calls on another machine (or perhaps to another Windows virtual machine).
    </p>
    <p>
        Skipping over a bunch of the code in step 7, which zeroes out several variables in the DOS data segment, we come to step 8, where the code takes the caller&#39;s AH (with the crucial DOS function number) and turns it into a word offset in BX. This will be
        important later on.
    </p>
    <p>
        Next (step 9), DOS examines the function number in AH. If AH=59 (Get Extended Error) is being called, DOS proceeds directly to step 12, where the code for function 59h will be called. It stays on the Critical Error Stack, bypassing more stack-switching
        code in steps 10 and 11, and bypassing code that would obliterate information pertaining to any pending Critical Error.
    </p>
    <p>
        If one of the CP/M-based character I/O functions (INT 21h AH=1 through AH=0Ch) is being called, DOS (step 10) points SP at 0AA0h, which is the top of the character I/0 stack, located in the Swappable Data Area (see appendix). However, if there is a pending
        critical error, DOS stays with the Critical Error stack that was set initially. This is not surprising, since Microsoft documents these functions (<em>MS-DOS Programmer&#39;s Reference</em>) as callable from a critical error handler. Notice that DOS does not
      turn off critical error information for functions 1 through 0Ch. As you
      can see, much of the core DOS code accommodates critical errors.
    </p>
    <p>
      Finally, if the DOS function number is 0 (Terminate Program), or anything
      greater than 0Ch, but not 59h, and not one of the special functions that
      were picked off earlier in step 1 and which DOS already processed on the
      caller&#39;s stack, DOS (step 11) switches to the disk stack. Thus, there are
      three DOS stacks:
    </p>
    
      
        Critical Error (or auxiliary), used for function 59h and for functions 1
        through 0Ch when a critical error is pending, and used temporarily for
        any DOS function call if DOS=HIGH but A20 is off.
      </div>
  </body>
</html>
