<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://m1el.github.io/oculus-tls-extract/">Original</a>
    <h1>Extracting TLS keys from an unwilling application (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>I want to be able to inspect the traffic of programs running on my computer.
I don’t really trust those programs and ideally I’d like to put nearly all of them into a high security jail.</p>

<p>One of those programs is Oculus software.  There are a few reasons why I want to be cautious about Oculus software.</p>

<!-- more -->

<ol>
  <li>Oculus is owned by Facebook, which means Facebook <em>can</em> dictate what Oculus software does with user’s data.</li>
  <li>Oculus servers run on Facebook’s infrastructure, which means that Facebook <em>can</em> have access to any data uploaded to those servers.</li>
  <li>Oculus Headset has cameras and software that builds a 3D map of my room, which <em>can</em> be uploaded to the servers.</li>
  <li>Oculus <a href="https://www.oculus.com/legal/privacy-policy/" title="Oculus Privacy Policy (Last Updated: December 27, 2019)">Privacy Policy</a> explicitly states that Oculus automatically collects:
    <blockquote>
      <p>Information about your environment, physical movements, and dimensions when you use an XR device.  For example, when you set up the Oculus Guardian System to alert you when you approach a boundary, we receive information about the play area that you have defined;</p>
    </blockquote>
  </li>
</ol>

<p>Fortunately, I can use programs such as Wireshark or tcpdump to inspect traffic sent to the servers.</p>

<h2 id="things-that-didnt-work">Things that didn’t work</h2>

<ul>
  <li>Setting <a href="https://wiki.wireshark.org/TLS" title="Wireshark wiki: TLS"><code>SSLKEYLOGFILE</code></a> variable – Oculus Runtime is using a 1.0.2o version of OpenSSL where this is not supported.</li>
  <li><a href="https://security.stackexchange.com/questions/80158/extract-pre-master-keys-from-an-openssl-application" title="StackExchange: Extract pre-master keys from an OpenSSL application">Extracting OpenSSL keys using an automated debugger</a> – Oculus Runtime is using statically linked OpenSSL with no debug symbols.</li>
  <li>Substituting OpenSSL library with one that can log secret keys – it’s statically linked.</li>
  <li>I didn’t want to add extra root certificates and proxies to inspect all TLS traffic going on the machine.</li>
</ul>

<h2 id="doing-this-the-hard-way">Doing this the hard way</h2>

<p>So the plan forward was to:</p>

<ul>
  <li>Figure out a code location where secret keys for the session are available</li>
  <li>Patch or debug the program so that we can inspect and log those keys</li>
</ul>

<h2 id="a-bit-of-reverse-engineering">A bit of reverse engineering</h2>

<p>To figure out the code location some reverse-engineering was necessary.  The first step was to figure out which version does Oculus Runtime use.  Looking for strings in <code>OculusAppFramework.dll</code>, there was the following string: <code>Stack part of OpenSSL 1.0.2o-fb10  27 Mar 2018</code>, which means I have a specific version that I work off.</p>

<p>After reading <a href="https://www.linuxjournal.com/article/4822" title="An Introduction to OpenSSL Programming, Part I of II">Introduction to OpenSSL programming on Linux Journal</a>, I deduced that <code>SSL_connect</code> (and later <code>SSL_set_connect_state</code>) may be a good place to interject OpenSSL for key extraction.</p>

<p>I’ve loaded up Oculus Runtime into Ghidra, opened up source code that contains public interface of OpenSSL <code>ssl_lib.c</code> and attempted to find common ground between those.  The things of interest were integer and string constants which could be used as landmarks.</p>

<p>A particularly notable function is <code>SSL_get_version</code>, which contains references to multiple strings.  Looking for <code>TLSv1.2</code> yielded a few locations, particularly this one:</p>

<p><img src="http://m1el.github.io/oculus-tls-extract/inlined-ssl-get-version.png" alt=""/></p>

<p>It looks like <code>SSL_get_version</code> got inlined.  I suspected that this was not the only place where TLS connections are made, so I had to find a different place to work on.  The next notable thing was that near one of the SSL version strings I’ve noticed code paths and assertion strings:</p>

<p><img src="http://m1el.github.io/oculus-tls-extract/assertion-info.png" alt=""/></p>

<p>As it turns out, debug information such as source file names and assertion expressions, which can be used as landmarks too.
Now we have more landmarks to navigate OpenSSL binary code.</p>

<p>I’ve continued to label function as I inspected nearby references to <code>.\\ssl\ssl_lib.c</code> strings, and I’ve stumbled upon <a href="http://m1el.github.io/oculus-tls-extract/ssl-set-connect-ghidra.png"><code>SSL_set_connect_state</code> function</a>.  Using the same code pattern, <a href="http://m1el.github.io/oculus-tls-extract/code-pattern.png"><code>mov dword ptr [$register + 0x48], 0x5000</code></a>, I’ve found <a href="http://m1el.github.io/oculus-tls-extract/ssl-connect-ghidra.png"><code>SSL_connect</code></a> as well.  <code>SSL_connect</code> had an inlined call to <code>SSL_set_connect_state</code>.  I’ve decided to be cautious and interject both of these functions.</p>



<p>These functions already have pointers to <code>ssl_st</code> struct, so let’s extract the data from there.</p>

<p>There were a few options to do this:</p>
<ul>
  <li>Use/write a programmable debugger and breakpoint/inspect values on those functions</li>
  <li>Binary patch the DLL</li>
  <li>Use DLL injection and patching in-memory DLL code</li>
</ul>

<p>Since I’ve had poor experience with controlling debuggers programmatically, I didn’t want to go use the first option.  This is a potential thing that I might want to improve.
Since I didn’t want to invalidate a signed DLL, I didn’t binary patch it.
Last option it is.</p>

<h2 id="dll-injection">DLL injection</h2>

<p>To extract <em>all</em> TLS keys, we need to control the running process from the beginning of its execution.
One way to do this is to set <code>gflags</code> to use DLL injector program as a debugger for the process.
The program we want to debug is called <code>OVRServer_x64.exe</code>, so let’s create <code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\OVRServer_x64.exe</code> key in registry and set <code>Debugger</code> string value to command line of our injector.</p>

<p>The injector doesn’t have to <em>do</em> any debugging, but it needs to start a program with <code>DEBUG_ONLY_THIS_PROCESS</code> or <code>DEBUG_PROCESS</code> flag.  Otherwise, our debugger will be <a href="http://m1el.github.io/oculus-tls-extract/recursive-injector-spawn.png">spawned recursively</a>.</p>

<p>The <code>CreateRemoteThread</code> DLL injection is itself a simple technique on Windows, it’s consicely described in a <a href="https://wikileaks.org/ciav7p1/cms/page_3375330.html" title="CreateRemoteThread DLL Injection">WikiLeaks article</a> as well in other articles.</p>

<p>The code for <code>injector.exe</code> is <a href="https://github.com/m1el/oculus-tls-extractor/blob/master/injector.rs" title="Oculus TLS Extractor -- injector.rs">here</a>.</p>

<h2 id="running-from-inside-the-process">Running from inside the process</h2>

<p>After the DLL is injected, it can patch the code in-memory and log secret keys.</p>

<p>The architecture for <code>injectee.dll</code> is pretty simple – patch the code, create a channel, create writer thread with the receiving end of the channel, send keys from different threads using the other end.</p>

<p>Patching was done in assembly.  It can be visually explained like this:</p>

<p><img src="http://m1el.github.io/oculus-tls-extract/asm-patch.png" alt=""/></p>

<p>There are several ways to extract the keys given a pointer to <code>ssl_st</code> struct.</p>
<ul>
  <li>Implementing a C library</li>
  <li>Walking the pointers manually</li>
  <li>Porting OpenSSL structs to the used language</li>
</ul>

<p>Initially I’ve implemented walking the pointers by hand, but that is a very fragile approach.
Porting OpenSSL structs to Rust is quite cumbersome, so I’ve implemented a <a href="https://github.com/m1el/oculus-tls-extractor/blob/master/ssl_inspector.c" title="Oculus TLS Extractor -- ssl_inspector.c">miniature C library</a> to read secret keys given an <code>ssl_st</code> struct pointer.</p>

<p>The rest is plumbing, and we now can inspect TLS traffic in a running application:</p>

<p><img src="http://m1el.github.io/oculus-tls-extract/extracted-tls-keys.png" alt=""/></p>

<p>The code for <code>injectee.dll</code> is <a href="https://github.com/m1el/oculus-tls-extractor/blob/master/injectee.rs" title="Oculus TLS Extractor -- injectee.rs">here</a>.</p>

<p>If you’re interested, the entire code for the project is here: <a href="https://github.com/m1el/oculus-tls-extractor">github.com/m1el/oculus-tls-extractor</a></p>

<p>Analysis of the data being sent by Oculus Runtime to the mothership is <a href="http://m1el.github.io/oculus-tls-extract/results.html" title="What does Oculus Runtime send home?">in the follow-up post</a>.</p>


  </div></div>
  </body>
</html>
