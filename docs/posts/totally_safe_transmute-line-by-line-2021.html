<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yossarian.net/2021/03/16/totally_safe_transmute-line-by-line">Original</a>
    <h1>totally_safe_transmute, Line-by-Line (2021)</h1>
    
    <div id="readability-page-1" class="page">


<h2><em>Programming, philosophy, pedaling.</em></h2>

<ul>
    <li><a href="https://ivywong.dev/">Home</a></li>
    <li><a href="https://ivywong.dev/tags">Tags</a></li>
    <li><a href="https://ivywong.dev/series">Series</a></li>
    <li><a href="https://ivywong.dev/favorites">Favorites</a></li>
    <li><a href="https://ivywong.dev/archive">Archive</a></li>
    
      <li><a href="https://yossarian.net">Main Site</a></li>
    
</ul>

<hr/>



<h2>
  <p>
    <span><em>Mar 16, 2021</em></span>

       

    
      <span>
        Tags:
        
        
          <a href="https://ivywong.dev/tags#curiosity">curiosity</a>,
        
          <a href="https://ivywong.dev/tags#programming">programming</a>,
        
          <a href="https://ivywong.dev/tags#rust">rust</a>
        
      </span>
    

       

    
  </p>
</h2>






<p>
  This post is at least a year old.
  </p>


<p>A few weeks ago, Twitter deigned to share this with me:</p>

<p><a href="https://twitter.com/steveklabnik/status/1365763926831595523"><img src="https://ivywong.dev/assets/safe_transmute_tweet.png" alt=""/></a></p>

<p><a href="https://github.com/ben0x539/totally-safe-transmute/blob/e49ca4ea514b8d996a01f04697ccdd5940300312/src/lib.rs">The file linked</a>
(written by <a href="https://github.com/ben0x539">Benjamin Herr</a>) in the tweet purports to implement a
version of Rust’s <a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a>
without any use of <code>unsafe</code>. If you run it, you’ll find that it does indeed work!</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>#[test]</span>
<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>let</span> <span>v</span><span>:</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span> <span>=</span> <span>b&#34;foo&#34;</span><span>.to_vec</span><span>();</span>
    <span>let</span> <span>v</span><span>:</span> <span>String</span> <span>=</span> <span>totally_safe_transmute</span><span>(</span><span>v</span><span>);</span>
    <span>assert_eq!</span><span>(</span><span>&amp;</span><span>v</span><span>,</span> <span>&#34;foo&#34;</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Yields:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td><pre><span>$ </span>git clone https://github.com/ben0x539/totally-safe-transmute
<span>$ </span>cargo build
<span>$ </span>cargo <span>test
   </span>Compiling totally-safe-transmute v0.0.3 <span>(</span>/tmp/totally-safe-transmute<span>)</span>
    Finished <span>test</span> <span>[</span>unoptimized + debuginfo] target<span>(</span>s<span>)</span> <span>in </span>0.49s
     Running target/debug/deps/totally_safe_transmute-be2ea6d9a3f8d258

running 1 <span>test
test </span>main ... ok

<span>test </span>result: ok. 1 passed<span>;</span> 0 failed<span>;</span> 0 ignored<span>;</span> 0 measured<span>;</span> 0 filtered out<span>;</span> finished <span>in </span>0.00s

   Doc-tests totally-safe-transmute

running 0 tests

<span>test </span>result: ok. 0 passed<span>;</span> 0 failed<span>;</span> 0 ignored<span>;</span> 0 measured<span>;</span> 0 filtered out<span>;</span> finished <span>in </span>0.00s
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This blog post will go through that implementation, line-by-line, and explain
how it works. Nothing about it is especially complicated; I just got a huge
kick out of it and figured I’d provide a detailed explanation. Rust newcomers
are the intended audience.</p>

<h2 id="quick-background-transmutation">Quick background: transmutation</h2>

<p>Most unsafe languages have mechanisms for <em>transmuting</em> (or <em>reinterpreting</em>)
the data at some memory address as an <em>entirely new type</em>. C includes
reinterpretation under its casting syntax; C++
provides the more explicit <code>reinterpret_cast&lt;T&gt;</code>
(with <a href="https://en.cppreference.com/w/cpp/language/reinterpret_cast">plenty of warnings</a>
about <em>when</em> <code>reinterpret_cast</code> is well-defined).</p>

<p>Reinterpretation has plenty of use cases:</p>

<ul>
  <li>
    <p>C-style “generic” APIs typically produce results in the form of a <code>void *</code>,
with the caller being expected to cast the <code>void *</code> to a suitable type.
Callers are responsible for ensuring that the destination type
is identical to or compatible with the type that was initially cast to <code>void *</code>.</p>
  </li>
  <li>
    <p>C and C++ callback patterns frequently provide a <code>void *</code> parameter, allowing
users to supply additional data or context between callbacks. Each callback
is then responsible for casting to the appropriate type.</p>
  </li>
  <li>
    <p>Pointer values occasionally need<sup id="fnref:misdesign" role="doc-noteref"><a href="#fn:misdesign" rel="footnote">1</a></sup> to be round-tripped through an
integral type. C++ specifically allows this, so long as the destination integral
type has at least sufficient width to represent all possible pointer values.</p>
  </li>
  <li>
    <p>Polymorphism: the <a href="https://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley sockets</a> API
specifies <a href="https://man7.org/linux/man-pages/man2/connect.2.html"><code>connect(2)</code></a>
as accepting a <code>struct sockaddr *</code>, which is actually reinterpreted internally
as one of the family-specific <code>sockaddr</code> structures (like <code>sockaddr_in</code> for IPv4
sockets). C++ also explicitly allows this under its “similarity” rules.</p>
  </li>
  <li>
    <p>Cheap object serialization or conversion: related to the above, but slightly
different: both C and C++ are okay with you converting pretty much any object
to <code>char *</code><sup id="fnref:others" role="doc-noteref"><a href="#fn:others" rel="footnote">2</a></sup>. This allows objects to be treated as <em>bags of bytes</em>,
which is handy when writing a hash table (you don’t care <em>what</em> the contents
are, you just want to uniquely identify them) or when serializing structures
in a host-specific format<sup id="fnref:sin" role="doc-noteref"><a href="#fn:sin" rel="footnote">3</a></sup>.</p>
  </li>
</ul>

<p>Each of the above is useful, but <em>incredibly</em> unsafe: transmutation is not
an operation at runtime that turns one type into another, but rather a
<strong>directive</strong> at compile time to treat some position in memory as if its type
is different. The result: most possible transmutations between types
result in <em>undefined behavior</em>.</p>

<h2 id="transmutation-in-rust">Transmutation in Rust</h2>

<p>Rust needs to interface with C, so<sup id="fnref:among" role="doc-noteref"><a href="#fn:among" rel="footnote">4</a></sup> Rust supports transmutation. It does so via
<a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a>. But transmutation
is a fundamentally unsafe operation, so Rust forbids the use of <code>mem::transmute</code> except
for in explicitly <code>unsafe</code> contexts:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td><pre><span>use</span> <span>std</span><span>::</span><span>mem</span><span>;</span>

<span>#[repr(C)]</span>
<span>pub</span> <span>struct</span> <span>Foo</span> <span>{</span>
    <span>pub</span> <span>a</span><span>:</span> <span>u8</span><span>,</span>
    <span>pub</span> <span>b</span><span>:</span> <span>u8</span><span>,</span>
    <span>pub</span> <span>c</span><span>:</span> <span>u8</span><span>,</span>
    <span>pub</span> <span>d</span><span>:</span> <span>u8</span>
<span>}</span>

<span>#[repr(C)]</span>
<span>pub</span> <span>struct</span> <span>Bar</span> <span>{</span>
    <span>pub</span> <span>a</span><span>:</span> <span>u32</span>
<span>}</span>

<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>let</span> <span>foo</span> <span>=</span> <span>Foo</span> <span>{</span> <span>a</span><span>:</span> <span>0xaa</span><span>,</span> <span>b</span><span>:</span> <span>0xbb</span><span>,</span> <span>c</span><span>:</span> <span>0xcc</span><span>,</span> <span>d</span><span>:</span> <span>0xdd</span> <span>};</span>
    <span>let</span> <span>bar</span><span>:</span> <span>Bar</span> <span>=</span> <span>unsafe</span> <span>{</span> <span>mem</span><span>::</span><span>transmute</span><span>(</span><span>foo</span><span>)</span> <span>};</span>

    <span>// output (on x86-64): bar.a = 0xddccbbaa</span>
    <span>println!</span><span>(</span><span>&#34;bar.a = {:x}&#34;</span><span>,</span> <span>bar</span><span>.a</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><em>(View it on <a href="https://godbolt.org/z/vsdMKK">Godbolt</a>.)</em></p>

<p><code>transmute</code> can, of course, be wrapped into safe contexts. But the underlying operation
will always be fundamentally unsafe, and <strong>should not</strong> be possible in otherwise safe Rust code.</p>

<p>So, how does <code>totally_safe_transmute</code> do it?</p>

<h2 id="breakdown">Breakdown</h2>

<p>First, here’s the entirety of <code>totally_safe_transmute</code>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td><pre><span>#![forbid(unsafe_code)]</span>

<span>use</span> <span>std</span><span>::{</span><span>io</span><span>::{</span><span>self</span><span>,</span> <span>Write</span><span>,</span> <span>Seek</span><span>},</span> <span>fs</span><span>};</span>

<span>pub</span> <span>fn</span> <span>totally_safe_transmute</span><span>&lt;</span><span>T</span><span>,</span> <span>U</span><span>&gt;</span><span>(</span><span>v</span><span>:</span> <span>T</span><span>)</span> <span>-&gt;</span> <span>U</span> <span>{</span>
    <span>#[repr(C)]</span>
    <span>enum</span> <span>E</span><span>&lt;</span><span>T</span><span>,</span> <span>U</span><span>&gt;</span> <span>{</span>
        <span>T</span><span>(</span><span>T</span><span>),</span>
        <span>#[allow(dead_code)]</span> <span>U</span><span>(</span><span>U</span><span>),</span>
    <span>}</span>
    <span>let</span> <span>v</span> <span>=</span> <span>E</span><span>::</span><span>T</span><span>(</span><span>v</span><span>);</span>

    <span>let</span> <span>mut</span> <span>f</span> <span>=</span> <span>fs</span><span>::</span><span>OpenOptions</span><span>::</span><span>new</span><span>()</span>
        <span>.write</span><span>(</span><span>true</span><span>)</span>
        <span>.open</span><span>(</span><span>&#34;/proc/self/mem&#34;</span><span>)</span><span>.expect</span><span>(</span><span>&#34;welp&#34;</span><span>);</span>

    <span>f</span><span>.seek</span><span>(</span><span>io</span><span>::</span><span>SeekFrom</span><span>::</span><span>Start</span><span>(</span><span>&amp;</span><span>v</span> <span>as</span> <span>*</span><span>const</span> <span>_</span> <span>as</span> <span>u64</span><span>))</span><span>.expect</span><span>(</span><span>&#34;oof&#34;</span><span>);</span>
    <span>f</span><span>.write</span><span>(</span><span>&amp;</span><span>[</span><span>1</span><span>])</span><span>.expect</span><span>(</span><span>&#34;darn&#34;</span><span>);</span>

    <span>if</span> <span>let</span> <span>E</span><span>::</span><span>U</span><span>(</span><span>v</span><span>)</span> <span>=</span> <span>v</span> <span>{</span>
        <span>return</span> <span>v</span><span>;</span>
    <span>}</span>

    <span>panic!</span><span>(</span><span>&#34;rip&#34;</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Let’s go through it, (mostly) line-by-line.</p>

<h3 id="forbidunsafe_code"><code>#![forbid(unsafe_code)]</code></h3>

<p><code>forbid</code> is an attribute that controls the <code>rustc</code> linter (along with <code>allow</code>, <code>warn</code>, and <code>deny</code>).
In this case, we’re telling <code>rustc</code> to forbid anything that trips the
<a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#unsafe-code"><code>unsafe_code</code> lint</a>,
which does exactly what it says on the tin: catches use of <code>unsafe</code>.</p>

<p>In this case, forbidding use of <code>unsafe</code> doesn’t do anything: a quick read of the code shows
that <code>unsafe</code> never shows up. But it’s a top-level proof to the reader that, <strong>if</strong> <code>rustc</code> accepts
the code (and it does), <strong>then</strong> there is no use of <code>unsafe</code>.</p>

<h3 id="totally_safe_transmute"><code>totally_safe_transmute</code></h3>

<p>Here’s our signature:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>pub</span> <span>fn</span> <span>totally_safe_transmute</span><span>&lt;</span><span>T</span><span>,</span> <span>U</span><span>&gt;</span><span>(</span><span>v</span><span>:</span> <span>T</span><span>)</span> <span>-&gt;</span> <span>U</span> <span>{</span> <span>...</span> <span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In sum: <code>totally_safe_transmute</code> takes two type parameters: <code>T</code> and <code>U</code>.</p>

<p>It then takes one concrete parameter, <code>v</code>, which is of type <code>T</code>. Finally, it
returns a <code>U</code>.</p>

<p>We know that the job of a transmutation function is to reinterpret a type of some
value as some other type, so we can rewrite this signature as:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>pub</span> <span>fn</span> <span>totally_safe_transmute</span><span>&lt;</span><span>SrcTy</span><span>,</span> <span>DstTy</span><span>&gt;</span><span>(</span><span>v</span><span>:</span> <span>SrcTy</span><span>)</span> <span>-&gt;</span> <span>DstTy</span> <span>{</span> <span>...</span> <span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="enum-e"><code>enum E</code></h3>

<p>Our next bit is a terse <code>enum</code> with some funky attributes. Rewritten with our friendly type
parameters:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>#[repr(C)]</span>
<span>enum</span> <span>E</span><span>&lt;</span><span>SrcTy</span><span>,</span> <span>DstTy</span><span>&gt;</span> <span>{</span>
    <span>T</span><span>(</span><span>SrcTy</span><span>),</span>
    <span>#[allow(dead_code)]</span> <span>U</span><span>(</span><span>DstTy</span><span>),</span>
<span>}</span>
<span>let</span> <span>v</span> <span>=</span> <span>E</span><span>::</span><span>T</span><span>(</span><span>v</span><span>);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>First, we’re marking <code>E</code> as <code>repr(C)</code>. This is an
<em><a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>-modifying</em> attribute: it tells
<code>rustc</code> to lay <code>E</code> out using the platform’s C ABI rather than the (intentionally) unstable Rust ABI.</p>

<p>What does this actually <em>mean</em>? For enums with fields (like this one), Rust
<a href="https://doc.rust-lang.org/reference/type-layout.html#reprc-enums-with-fields">uses a “tagged union” representation</a>.
In effect, <code>E</code> becomes something like this (in C syntax):</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
</pre></td><td><pre><span>struct</span> <span>E</span> <span>{</span>
  <span>int</span> <span>discriminant</span><span>;</span>
  <span>union</span> <span>{</span>
    <span>SrcTy</span> <span>T</span><span>;</span>
    <span>DstTy</span> <span>U</span><span>;</span>
  <span>}</span> <span>data</span><span>;</span>
<span>};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We’ll see why that’s important in a bit.</p>

<p>Next: <code>E</code> has two variants: the first holds a value of type <code>SrcTy</code>, and the other holds a value
of <code>DstTy</code>.</p>

<p>But wait! Another <code>rustc</code> linter annotation: this time, we’re telling <code>rustc</code> that it’s okay
for the <code>U</code> variant to fail the
<a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#dead-code"><code>dead_code</code></a> lint.
Normally, <code>rustc</code> would warn us upon statically inferring that <code>U</code> is never used; with
<code>dead_code</code> enabled, it silences that warning. Like the ABI layout, we’ll see why that’s important
shortly.</p>

<p>Finally, we shadow our <code>v</code> parameter with a new binding. <code>v</code> was already of type <code>T</code>, so
creating an <code>E::T</code> from it is no problem at all.</p>

<h3 id="io">I/O</h3>

<p>This is where the (main) magic happens:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
</pre></td><td><pre><span>let</span> <span>mut</span> <span>f</span> <span>=</span> <span>fs</span><span>::</span><span>OpenOptions</span><span>::</span><span>new</span><span>()</span>
    <span>.write</span><span>(</span><span>true</span><span>)</span>
    <span>.open</span><span>(</span><span>&#34;/proc/self/mem&#34;</span><span>)</span><span>.expect</span><span>(</span><span>&#34;welp&#34;</span><span>);</span>

<span>f</span><span>.seek</span><span>(</span><span>io</span><span>::</span><span>SeekFrom</span><span>::</span><span>Start</span><span>(</span><span>&amp;</span><span>v</span> <span>as</span> <span>*</span><span>const</span> <span>_</span> <span>as</span> <span>u64</span><span>))</span><span>.expect</span><span>(</span><span>&#34;oof&#34;</span><span>);</span>
<span>f</span><span>.write</span><span>(</span><span>&amp;</span><span>[</span><span>1</span><span>])</span><span>.expect</span><span>(</span><span>&#34;darn&#34;</span><span>);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>First, we’re opening a file. Specifically, we’re opening <code>/proc/self/mem</code> in write mode.</p>

<p><code>/proc/self/mem</code> is a <em>very</em> special<sup id="fnref:linux" role="doc-noteref"><a href="#fn:linux" rel="footnote">5</a></sup> file: it presents a view of the current process’s
memory, sparsely mapped by virtual address ranges.</p>

<p>As a quick hack, we can prove this to ourselves in Python by checking out the
in-memory representation of a <code>str</code> object<sup id="fnref:pystr" role="doc-noteref"><a href="#fn:pystr" rel="footnote">6</a></sup>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span>x</span> <span>=</span> <span>&#34;</span><span>this string is long enough to prevent any string interning</span><span>&#34;</span>
<span>&gt;&gt;&gt;</span> <span># in cpython, an object&#39;s id is (usually) its pointer
</span><span>&gt;&gt;&gt;</span> <span>x_addr</span> <span>=</span> <span>id</span><span>(</span><span>x</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>hex</span><span>(</span><span>x_addr</span><span>)</span>
<span>&#39;</span><span>0x7ff1bc7cfce0</span><span>&#39;</span>
<span>&gt;&gt;&gt;</span> <span>mem</span> <span>=</span> <span>open</span><span>(</span><span>&#34;</span><span>/proc/self/mem</span><span>&#34;</span><span>,</span> <span>mode</span><span>=</span><span>&#34;</span><span>rb</span><span>&#34;</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>mem</span><span>.</span><span>seek</span><span>(</span><span>x_addr</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>mem</span><span>.</span><span>read</span><span>(</span><span>len</span><span>(</span><span>x</span><span>)</span> <span>*</span> <span>4</span><span>)</span>
<span>b</span><span>&#39;</span><span>[SNIP] </span><span>&#34;</span><span>thi</span><span>\x00\x00\x00\x00\x00\x00\x00\x00</span><span>this string is long enough to prevent any string interning</span><span>\x00</span><span>e</span><span>\&#39;</span><span>[SNIP]</span><span>&#39;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><em>(I trimmed the output a bit. You get the point.)</em></p>

<p>We can even poke memory by writing into <code>/proc/self/mem</code>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td><pre><span>&gt;&gt;&gt;</span> <span># using ctypes to avoid the layout muckery we saw above
</span><span>&gt;&gt;&gt;</span> <span>import</span> <span>ctypes</span>
<span>&gt;&gt;&gt;</span> <span>cstr</span> <span>=</span> <span>ctypes</span><span>.</span><span>c_char_p</span><span>(</span><span>b</span><span>&#34;</span><span>look ma, no hands</span><span>&#34;</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>cstr_addr</span> <span>=</span> <span>ctypes</span><span>.</span><span>cast</span><span>(</span><span>cstr</span><span>,</span> <span>ctypes</span><span>.</span><span>c_void_p</span><span>).</span><span>value</span>
<span>&gt;&gt;&gt;</span> <span>hex</span><span>(</span><span>cstr_addr</span><span>)</span>
<span>&#39;</span><span>0x7f47f3e9c790</span><span>&#39;</span>
<span>&gt;&gt;&gt;</span> <span>mem</span> <span>=</span> <span>open</span><span>(</span><span>&#34;</span><span>/proc/self/mem</span><span>&#34;</span><span>,</span> <span>mode</span><span>=</span><span>&#34;</span><span>r+b</span><span>&#34;</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>mem</span><span>.</span><span>seek</span><span>(</span><span>cstr_addr</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>mem</span><span>.</span><span>read</span><span>(</span><span>len</span><span>(</span><span>cstr</span><span>.</span><span>value</span><span>))</span>
<span>b</span><span>&#39;</span><span>look ma, no hands</span><span>&#39;</span>
<span>&gt;&gt;&gt;</span> <span>mem</span><span>.</span><span>seek</span><span>(</span><span>cstr_addr</span> <span>+</span> <span>5</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>mem</span><span>.</span><span>write</span><span>(</span><span>&#39;</span><span>p</span><span>&#39;</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>mem</span><span>.</span><span>seek</span><span>(</span><span>cstr_addr</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>mem</span><span>.</span><span>read</span><span>(</span><span>len</span><span>(</span><span>cstr</span><span>.</span><span>value</span><span>))</span>
<span>b</span><span>&#39;</span><span>look pa, no hands</span><span>&#39;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The next two pieces of <code>totally_safe_transmute</code> should now make sense: we seek
to the address of our <code>v</code> variable (which is now a variant of <code>E</code>) within <em>our own running process</em>,
and we write a single <code>u8</code> to it (<code>[1]</code>).</p>

<p>But why <code>1</code>? Recall our C ABI representation of <code>E</code> above! The first piece of <code>E</code> is our
union discriminator. When <code>data</code> is <code>SrcTy</code>, <code>discriminant</code> is <code>0</code>. When we forcefully
overwrite it to <code>1</code>, <code>data</code> is now interpreted as <code>DstTy</code>!</p>

<h3 id="the-last-bit">The last bit</h3>

<p>Okay, so we’ve poked memory and turned our <code>E::T</code> into an <code>E::U</code>. Let’s see how we get it out:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
</pre></td><td><pre><span>if</span> <span>let</span> <span>E</span><span>::</span><span>U</span><span>(</span><span>v</span><span>)</span> <span>=</span> <span>v</span> <span>{</span>
    <span>return</span> <span>v</span><span>;</span>
<span>}</span>

<span>panic!</span><span>(</span><span>&#34;rip&#34;</span><span>);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>At first glance, there’s nothing special about this: we’re simply discarding the enum wrapper
that we added earlier so that we can return our newly-minted value of <code>DstTy</code>.</p>

<p>But this is actually deceptively clever, and involves fooling the compiler:</p>

<ul>
  <li>The compiler knows that <code>totally_safe_transmute</code> <strong>must</strong> return <code>DstTy</code>.</li>
  <li>…but the only way to return a <code>DstTy</code> is for <code>v</code> to be an <code>E::U</code>.</li>
  <li>…<em>but</em> <code>v</code> was unconditionally initialized as an <code>E::T</code>, so that return is never reached.</li>
  <li>…<em>so</em>, as far as Rust is concerned, this function always unconditionally <code>panic!</code>s.</li>
</ul>

<p><em>This</em> is why we needed <code>allow(dead_code)</code> earlier: no <code>E::U</code> is ever constructed in a manner that
could possibly reach the <code>return</code> statement, so there’s simply no need for it as a variant.
And indeed, we can confirm this by removing the <code>allow</code> attribute:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td><pre><span>$ </span>cargo build
   Compiling totally-safe-transmute v0.0.3 <span>(</span>/tmp/totally-safe-transmute<span>)</span>
warning: variant is never constructed: <span>`</span>U<span>`</span>
 <span>--</span><span>&gt;</span> src/lib.rs:9:9
  |
9 |         U<span>(</span>U<span>)</span>,
  |         ^^^^
  |
  <span>=</span> note: <span>`</span><span>#[warn(dead_code)]` on by default</span>

warning: 1 warning emitted

    Finished dev <span>[</span>unoptimized + debuginfo] target<span>(</span>s<span>)</span> <span>in </span>0.15s
</pre></td></tr></tbody></table></code></pre></div></div>

<p>But alas: it’s not really dead code: the compiler is “wrong,” and we pop
an <code>E::U</code> into existence at runtime by modifying the program’s own memory. We then hit
our impossible condition, and return our transmuted value.</p>

<h2 id="wrapup">Wrapup</h2>

<p><code>totally_safe_transmute</code> is a delightful hack that demonstrates a key limitation when reasoning
about a program’s behavior: every behavior model is contingent on an <em>environmental model</em> and
how the program (or the program’s runtime, or the compiler, or whatever else) chooses (or doesn’t
choose) to handle seemingly impossible conditions in said environment.</p>

<p>The ability to do this doesn’t reflect fundamental unsafety in Rust, any more than it does
any safe language: from Rust’s perspective, what <code>totally_unsafe_transmute</code> does is impossible
and therefore undefined; there’s no point in in handling something that cannot happen.</p>

<p>Some other interesting bits:</p>

<ul>
  <li>As mentioned previously, this hack only works on Linux due to its dependency on <code>/proc/self/mem</code>.
Other OSes may have similar mechanisms.</li>
  <li>I haven’t tested this, but I’m pretty sure it only works on little-endian architectures (like x86).
On big-endian architectures, the <code>write</code> would probably need to be adjusted.</li>
  <li>If we’re being extremely pedantic: this <em>technically</em> isn’t a transmutation. Semantically,
transmutation is a operationless change in types at compile time; <code>totally_safe_transmute</code>
rewrites the in-memory representation of the program to accomplish equivalent behavior at runtime.
I don’t think this is a distinction that makes a difference.</li>
  <li>Because <code>totally_safe_transmute</code> relies on undefined behavior (an impossible program state),
Rust would be correct in erasing the <code>E::U</code> branch altogether and reducing the function to an
unconditional <code>panic!</code>. It doesn’t do that in my testing (even in release mode), but there’s
absolutely nothing in the program semantics that prevents it from doing so. But maybe
one day it will, and <code>totally_safe_transmute</code> will stop working!</li>
</ul>

<hr/>




<hr/>


<span>
  Discussions:
  
  <a href="https://www.reddit.com/r/enosuchblog/comments/m694hn/totally_safe_transmute_linebyline/">Reddit</a>
  
</span>
<hr/>



  


  





</div>
  </body>
</html>
