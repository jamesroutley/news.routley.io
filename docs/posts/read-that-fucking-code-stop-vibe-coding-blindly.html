<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://etsd.tech/posts/rtfc/">Original</a>
    <h1>Read That Fucking Code (Stop vibe-coding blindly)</h1>
    
    <div id="readability-page-1" class="page"><article id="article"> <p>If you’d told me 2–3 years ago that in 2025, one of my top pieces of advice for the new generation of developers would be “<em>read your code</em>” (we’re not even talking about re-reading it)… I’m not sure I would’ve believed you.</p>
<h2 id="what-this-article-covers">What This Article Covers</h2>
<p>I’m not here to lecture anyone, but <strong>if you’re aiming to build serious projects</strong> these days, it might be worth learning how to approach AI coding tools the right way.</p>
<p><strong>This post covers:</strong></p>
<ul>
<li>Three critical risks of poor <em>vibe-coding</em> practices</li>
<li>Two effective approaches for production-grade AI-assisted development</li>
<li>Practical tips to maintain code quality while leveraging AI speed</li>
</ul>
<p><strong>Vibe-Coding Refresh</strong></p>
<p>Maybe it’s time we take a fresh look at what vibe-coding actually is. It’s more than just hobby prompting to get code — it’s a practice that serious developers should learn to master. What it means to me:
<mark>Vibe-Coding is a dialogue-based coding process between a human and an AI where the human guides and the AI implements.</mark></p>
<h2 id="its-possible-to-ship-code-without-ever-reading-it">It’s possible to ship code without ever reading it.</h2>
<p>Since Claude Code and Windsurf arrived, it’s now totally possible to get working results without reading a single line of code. You can vibe-code without ever leaving your chat window and just operate based on outcomes - I’ve tried that, out of curiosity.</p>
<p>Even if it doesn’t work on the first try (though it often does), you just explain what’s wrong, and voilà — working result incoming.</p>
<h2 id="but-this-comes-with-three-critical-issues">But This Comes With Three Critical Issues</h2>
<h3 id="1-a-weakened-architecture">1. A Weakened Architecture</h3>
<p>Not reviewing AI-generated code <strong>will</strong> lead to serious problems.</p>
<p>First up: the slow but sure breakdown of your architecture… assuming you even took the time to plan one in the first place.</p>
<p>From experience, even with well-crafted prompts and clearly defined plans for a new feature, Claude Code (which I love, by the way) still sometimes goes off-script. Make sure to properly configure your @CLAUDE.md files to avoid this as much as possible.</p>
<p><strong>Example of architectural drift:</strong></p>
<pre tabindex="0" data-language="javascript"><code><span><span>// Your established pattern: services handle business logic</span></span>
<span><span>class</span><span> UserService</span><span> {</span></span>
<span><span>  async</span><span> getUserProfile</span><span>(</span><span>userId</span><span>)</span><span> {</span></span>
<span><span>    const</span><span> user</span><span> =</span><span> await</span><span> db</span><span>.</span><span>users</span><span>.</span><span>findById</span><span>(</span><span>userId</span><span>);</span></span>
<span><span>    return</span><span> this</span><span>.</span><span>formatUserData</span><span>(</span><span>user</span><span>);</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// What Claude might generate if unchecked:</span></span>
<span><span>// Business logic creeping into controllers</span></span>
<span><span>app</span><span>.</span><span>get</span><span>(</span><span>&#39;</span><span>/profile/:id</span><span>&#39;</span><span>,</span><span> async</span><span> (</span><span>req</span><span>,</span><span> res</span><span>)</span><span> =&gt;</span><span> {</span></span>
<span><span>  const</span><span> user</span><span> =</span><span> await</span><span> db</span><span>.</span><span>users</span><span>.</span><span>findById</span><span>(</span><span>req</span><span>.</span><span>params</span><span>.</span><span>id</span><span>);</span></span>
<span><span>  // Formatting logic that belongs in service layer</span></span>
<span><span>  const</span><span> formattedUser</span><span> =</span><span> {</span></span>
<span><span>    name</span><span>:</span><span> user</span><span>.</span><span>firstName</span><span> +</span><span> &#39;</span><span> &#39;</span><span> +</span><span> user</span><span>.</span><span>lastName</span><span>,</span></span>
<span><span>    memberSince</span><span>:</span><span> new</span><span> Date</span><span>(</span><span>user</span><span>.</span><span>createdAt</span><span>)</span><span>.</span><span>getFullYear</span><span>()</span></span>
<span><span>  }</span><span>;</span></span>
<span><span>  res</span><span>.</span><span>json</span><span>(</span><span>formattedUser</span><span>);</span></span>
<span><span>});</span></span></code></pre>
<p>If you don’t catch it early, those small inconsistencies become part of the codebase—and your favorite assistant will be tempted to follow those bad examples in the future.</p>
<p><mark>You’re still the architect!</mark></p>
<p>Everyone keeps saying it these days: treat your AI like a (brilliant) new junior dev<sup><a href="#user-content-fn-brillant-junior-dev" id="user-content-fnref-brillant-junior-dev" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>. And what does a junior dev do before starting a new feature? They read through the existing codebase. Which means any weak or messy design choices are likely to get repeated.</p>
<p>And by the way, you’d never push junior dev code without reviewing it.</p>
<p>Now more than ever, we’re all responsible for the architecture. We spend more time guiding the AI on how to code than writing the actual code ourselves.</p>
<h3 id="2-loss-of-implementation-knowledge">2. Loss of Implementation Knowledge</h3>
<blockquote>
<p>You cannot delegate the act of thinking.</p>
</blockquote>
<p><em>Alain (French philosopher, 19th century)</em></p>
<p><strong>If you’re only focused on the end result,</strong> you’ll soon know as little as your users about how things actually work. You may be the most advanced user of your own app — but <strong>you won’t own your domain anymore</strong>.</p>
<p><strong>Why does that matter?</strong></p>
<p>In every experience I’ve had — especially when building my latest startup<sup><a href="#user-content-fn-from-0-to-exit-in-2-years" id="user-content-fnref-from-0-to-exit-in-2-years" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup> — I’ve learned that apps and features don’t take shape at implementation time. They’re designed upstream: business rules, tech and infrastructure decisions all take form before you touch the keyboard. They come to you while commuting, while chatting, or—often—while in the shower.</p>
<p>Depending on your level of responsibility, you may or may not be involved outside of work. But you’ll probably agree that your best ‘Aha!’ moments didn’t happen in front of VS Code.</p>
<p>If you don’t have the structure of your domain — its concepts and abstractions — constantly simmering somewhere in the back of your mind, you won’t be able to fully leverage the creative potential of modern tech.</p>
<p><mark>If you really think you don’t need this knowledge, your business might not be all that “Tech” to begin with.</mark> In that case, use a well-structured Notion doc, or a no-code tool—you’ll save a ton of time and money.</p>
<p>And don’t hesitate to leave your code editor and chat with an AI that doesn’t have access to your codebase—our good old rubber duck didn’t either, and that’s precisely why it worked.</p>
<h3 id="3-security-vulnerabilities">3. Security Vulnerabilities</h3>
<p>Are you working on a production app? Then you must care about security. Most web security issues are avoided through knowledge and experience. But a lax implementation or fuzzy access scopes, and you’re in serious trouble.</p>
<p><strong>Example that happened to me last week:</strong></p>
<pre tabindex="0" data-language="javascript"><code><span><span>// What I asked for: &#34;List user&#39;s projects&#34;</span></span>
<span><span>// What Claude generated:</span></span>
<span><span>app</span><span>.</span><span>get</span><span>(</span><span>&#39;</span><span>/api/projects/:id</span><span>&#39;</span><span>,</span><span> async</span><span> (</span><span>req</span><span>,</span><span> res</span><span>)</span><span> =&gt;</span><span> {</span></span>
<span><span>  const</span><span> projectId</span><span> =</span><span> req</span><span>.</span><span>body</span><span>.</span><span>id</span><span>; </span><span>// From the client</span></span>
<span><span>  const</span><span> project</span><span> =</span><span> await</span><span> db</span><span>.</span><span>projects</span><span>.</span><span>find</span><span>(</span><span>{</span><span> id</span><span>:</span><span> projectId</span><span> }</span><span>);</span></span>
<span><span>  res</span><span>.</span><span>json</span><span>(</span><span>project</span><span>);</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// What it should have been:</span></span>
<span><span>app</span><span>.</span><span>get</span><span>(</span><span>&#39;</span><span>/api/projects/:id</span><span>&#39;</span><span>,</span><span> async</span><span> (</span><span>req</span><span>,</span><span> res</span><span>)</span><span> =&gt;</span><span> {</span></span>
<span><span>  const</span><span> projectId</span><span> =</span><span> req</span><span>.</span><span>body</span><span>.</span><span>id</span><span>;</span></span>
<span><span>  const</span><span> userId</span><span> =</span><span> req</span><span>.</span><span>authenticatedUser</span><span>.</span><span>id</span><span>; </span><span>// From auth middleware</span></span>
<span><span>  const</span><span> project</span><span> =</span><span> await</span><span> db</span><span>.</span><span>projects</span><span>.</span><span>find</span><span>(</span><span>{</span></span>
<span><span>    id</span><span>:</span><span> projectId</span><span>,</span></span>
<span><span>    where</span><span>:</span><span> {</span><span> userId</span><span>:</span><span> userId</span><span> }</span></span>
<span><span>  }</span><span>);</span></span>
<span><span>  res</span><span>.</span><span>json</span><span>(</span><span>project</span><span>);</span></span>
<span><span>});</span></span></code></pre>
<p>The AI, focused on the end goal, implemented exactly what I asked for… except that it never once verified whether the resource actually belonged to the current user. <strong>Classic mistake.</strong></p>
<p>Sure, you can tell me: “always include access control in your prompt”, but some flaws only become obvious during implementation. Ever had a security insight pop into your head while coding a feature?</p>
<p>You can’t be too careful. A misworded prompt, a misunderstood intention, an unreviewed commit—and bam, you’ve got a breach. I fear this will become more common with hastily vibe-coded projects.</p>
<p><mark>Security has always needed to be part of the implementation process. Why should that change now?</mark></p>
<h2 id="two-ways-to-vibe-code-responsibly">Two Ways to Vibe-Code Responsibly</h2>
<p>As stated in <a href="https://www-cdn.anthropic.com/58284b19e702b49db9302d5b6f135ad8871e7658.pdf">this great ressource</a> by Anthropic, there are two viable ways to vibe-code a production-ready project in 2025:</p>
<blockquote>
<p>Learn to distinguish between tasks that work well asynchronously (peripheral features, prototyping) versus those needing synchronous supervision (core business logic, critical fixes). Abstract tasks on the product’s edges can be handled with “auto-accept mode,” while core functionality requires closer oversight.</p>
</blockquote>
<h3 id="1-fast-prototyping-with-auto-accept-mode">1. Fast Prototyping with Auto-Accept Mode</h3>
<p>Here, you use the AI in auto-pilot mode. Describe the expected output, provide specs, and let it run. Before ending the session, <strong>you review what’s been done</strong>, and adjust as needed.</p>
<p>This works well when:</p>
<ul>
<li>You’re working on a topic you’re not familiar with</li>
<li>Generating test scaffolding (but still review the tests — a test that doesn’t test anything meaningful is just a green checkmark)</li>
<li>Exploring new libraries or frameworks</li>
</ul>
<h3 id="2-synchronous-coding-for-core-features">2. Synchronous Coding for Core Features</h3>
<p>This is where the real innovation is happening in our field. <strong>Pair-vibe-coding, without auto-accept</strong>, is the most effective way to ship quality features. Every suggestion is a chance to either accept or iterate.</p>
<p>And that changes everything: at every small step, you can correct direction before things drift. <mark>It’s always easier to straighten a sapling than a grown tree.</mark> The earlier you lock down good concepts and interfaces in your architecture, the better future suggestions from the AI will be.</p>
<p><strong>Plan your session:</strong> When you start a session, begin with a clear plan. Read it carefully, regardless of your approach, and don’t validate it unless you fully agree with it. The plan is to the session what the seed is to the tree: bad seed, bad soil, no fruit.</p>
<h2 id="the-vibe-coding-checklist">The Vibe-Coding Checklist</h2>
<p>Before pushing any AI-generated code:</p>
<ul>
<li> <strong>Architecture Check</strong>: Does this follow our established patterns?</li>
<li> <strong>Security Review</strong>: Are all resources properly scoped to users?</li>
<li> <strong>Tests</strong>: Do they actually test meaningful behavior?</li>
</ul>
<p>But also, do not forget to check:</p>
<ul>
<li> <strong>Documentation</strong>: Will <em>you</em> understand this in 6 months?</li>
<li> <strong>Error Handling</strong>: Are edge cases covered?</li>
<li> <strong>Performance</strong>: Any obvious N+1 queries or inefficiencies?</li>
</ul>
<p>And above all, make sure to:</p>
<ul>
<li> <mark>Leave with some <strong>knowledge</strong> of the new code</mark>.</li>
</ul>
<h2 id="to-wrap-it-up">To Wrap It Up</h2>
<p>AI coding assistants are powerful tools, but they’re amplifiers of your expertise, not replacements for it. The day you stop understanding your codebase is the day you stop being its architect.</p>
<p><strong>Teams:</strong> don’t cancel code reviews thinking Claude Code acts as a second dev alongside the one assigned to the feature. Bugs aren’t the biggest threat—losing mastery of your domain and architecture is. That’s the real roadblock to innovation.</p>
<p><strong>Engineers:</strong> you can usually let the AI <em>RTFM</em> but you: <mark>Read That F*cking Code</mark>!</p>
 </article></div>
  </body>
</html>
