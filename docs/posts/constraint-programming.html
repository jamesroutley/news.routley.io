<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://en.wikipedia.org/wiki/Constraint_programming">Original</a>
    <h1>Constraint Programming</h1>
    
    <div id="readability-page-1" class="page"><div id="mw-content-text" lang="en" dir="ltr"><div>

<p><b>Constraint programming (CP)</b><sup id="cite_ref-:0_1-0"><a href="#cite_note-:0-1">[1]</a></sup> is a paradigm for solving <a href="https://en.wikipedia.org/wiki/Combinatorial" title="Combinatorial">combinatorial</a> problems that draws on a wide range of techniques from <a href="https://en.wikipedia.org/wiki/Artificial_intelligence" title="Artificial intelligence">artificial intelligence</a>, <a href="https://en.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, and <a href="https://en.wikipedia.org/wiki/Operations_research" title="Operations research">operations research</a>. In constraint programming, users declaratively state the <a href="https://en.wikipedia.org/wiki/Constraint_(mathematics)" title="Constraint (mathematics)">constraints</a> on the feasible solutions for a set of decision variables. Constraints differ from the common <a href="https://en.wikipedia.org/wiki/Language_primitive" title="Language primitive">primitives</a> of <a href="https://en.wikipedia.org/wiki/Imperative_programming" title="Imperative programming">imperative programming</a> languages in that they do not specify a step or sequence of steps to execute, but rather the properties of a solution to be found. In addition to constraints, users also need to specify a method to solve these constraints. This typically draws upon standard methods like chronological <a href="https://en.wikipedia.org/wiki/Backtracking" title="Backtracking">backtracking</a> and <a href="https://en.wikipedia.org/wiki/Constraint_propagation" title="Constraint propagation">constraint propagation</a>, but may use customized code like a problem specific branching <a href="https://en.wikipedia.org/wiki/Heuristic_(computer_science)" title="Heuristic (computer science)">heuristic</a>.
</p><p>Constraint programming takes its root from and can be expressed in the form of <a href="https://en.wikipedia.org/wiki/Constraint_logic_programming" title="Constraint logic programming">constraint logic programming</a>, which embeds constraints into a <a href="https://en.wikipedia.org/wiki/Logic_program" title="Logic program">logic program</a>. This variant of logic programming is due to Jaffar and Lassez,<sup id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup> who extended in 1987 a specific class of constraints that were introduced in <a href="https://en.wikipedia.org/wiki/Prolog_II" title="Prolog II">Prolog II</a>. The first implementations of constraint logic programming were <a href="https://en.wikipedia.org/w/index.php?title=Prolog_III&amp;action=edit&amp;redlink=1" title="Prolog III (page does not exist)">Prolog III</a>, <a href="https://en.wikipedia.org/wiki/CLP(R)" title="CLP(R)">CLP(R)</a>, and <a href="https://en.wikipedia.org/wiki/CHIP_(programming_language)" title="CHIP (programming language)">CHIP</a>.
</p><p>Instead of logic programming, constraints can be mixed with <a href="https://en.wikipedia.org/wiki/Functional_programming" title="Functional programming">functional programming</a>, <a href="https://en.wikipedia.org/wiki/Term_rewriting" title="Term rewriting">term rewriting</a>, and <a href="https://en.wikipedia.org/wiki/Imperative_language" title="Imperative language">imperative languages</a>.
Programming languages with built-in support for constraints include <a href="https://en.wikipedia.org/wiki/Oz_programming_language" title="Oz programming language">Oz</a> (functional programming) and <a href="https://en.wikipedia.org/wiki/Kaleidoscope_programming_language" title="Kaleidoscope programming language">Kaleidoscope</a> (imperative programming). Mostly, constraints are implemented in imperative languages via <i>constraint solving toolkits</i>, which are separate libraries for an existing imperative language.
</p>


<h2><span id="Constraint_logic_programming">Constraint logic programming</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=1" title="Edit section: Constraint logic programming">edit</a><span>]</span></span></h2>

<p>Constraint programming is an embedding of constraints in a host language. The first host languages used were <a href="https://en.wikipedia.org/wiki/Logic_programming" title="Logic programming">logic programming</a> languages, so the field was initially called <i>constraint logic programming</i>. The two paradigms share many important features, like logical variables and <a href="https://en.wikipedia.org/wiki/Backtracking" title="Backtracking">backtracking</a>. Today most <a href="https://en.wikipedia.org/wiki/Prolog" title="Prolog">Prolog</a> implementations include one or more libraries for constraint logic programming.
</p><p>The difference between the two is largely in their styles and approaches to modeling the world. Some problems are more natural (and thus, simpler) to write as logic programs, while some are more natural to write as constraint programs.
</p><p>The constraint programming approach is to search for a state of the world in which a large number of constraints are satisfied at the same time. A problem is typically stated as a state of the world containing a number of unknown variables. The constraint program searches for values for all the variables.
</p><p>Temporal concurrent constraint programming (TCC) and non-deterministic temporal concurrent constraint programming (MJV) are variants of constraint programming that can deal with time.
</p>
<h2><span id="Constraint_satisfaction_problem">Constraint satisfaction problem</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=2" title="Edit section: Constraint satisfaction problem">edit</a><span>]</span></span></h2>

<p>A constraint is a relation between multiple variables which limits the values these variables can take simultaneously.
</p>
<div>
<p><strong>Definition</strong><span> — </span>A constraint satisfaction problem on finite domains (or CSP) is defined by a triplet <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3237213200e8e80327a2cb23f816fe23fc2b1758" aria-hidden="true" alt="{\displaystyle ({\mathcal {X}},{\mathcal {D}},{\mathcal {C}})}"/></span> where:
</p>

</div>
<p>Three categories of constraints exist:
</p>
<ul><li>extensional constraints: constraints are defined by enumerating the set of values that would satisfy them;</li>
<li>arithmetic constraints: constraints are defined by an arithmetic expression, i.e., using <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/eeaddf2fabe17a627fbecb6b7278cdf2949be72f" aria-hidden="true" alt="{\displaystyle &lt;,&gt;,\leq ,\geq ,=,\neq ,...}"/></span>;</li>
<li>logical constraints: constraints are defined with an explicit semantic, i.e., <i>AllDifferent</i>, <i>AtMost</i>,<i>...</i></li></ul>

<p>Assignment is the association of a variable to a value from its domain. A partial assignment is when a subset of the variables of the problem have been assigned. A total assignment is when all the variables of the problem have been assigned.
</p>
<p><strong>Property</strong><span> — </span>Given <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/34da36fc4fdbf77b012ac37ed7eb0a0a13e02c12" aria-hidden="true" alt="{\displaystyle {\mathcal {A}}=({\mathcal {X_{\mathcal {A}}}},{\mathcal {V_{\mathcal {A}}}})}"/></span> an assignation (partial or total) of a CSP <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/29b86d87be22c427cd9f926344de63e8086c8ac3" aria-hidden="true" alt="{\displaystyle P=({\mathcal {X}},{\mathcal {D}},{\mathcal {C}})}"/></span>, and <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/601ef4a2e073b8538ffe0f023b5e5ddd44583657" aria-hidden="true" alt="{\displaystyle C_{i}=({\mathcal {X}}_{i},{\mathcal {R}}_{i})}"/></span> a constraint of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4dc73bf40314945ff376bd363916a738548d40a" aria-hidden="true" alt="P"/></span> such as <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/daec046d65fb77f8bd30232a03ab484bd519463e" aria-hidden="true" alt="{\displaystyle {\mathcal {X}}_{i}\subset {\mathcal {X_{\mathcal {A}}}}}"/></span>, the assignation <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/280ae03440942ab348c2ca9b8db6b56ffa9618f8" aria-hidden="true" alt="{\mathcal {A}}"/></span> satisfies the constraint <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cc49dc02c0ec8c86b67e7d10518ac791eda0bf22" aria-hidden="true" alt="C_{i}"/></span> if and only if all the values <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f4a22569433beba1e34fc2140dca8379dea58f2f" aria-hidden="true" alt="{\displaystyle {\mathcal {V}}_{{\mathcal {A}}_{i}}=\{v_{i}\in {\mathcal {V}}_{\mathcal {A}}{\mbox{ tel que }}x_{i}\in {\mathcal {X}}_{i}\}}"/></span> of the variables of the constraint <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cc49dc02c0ec8c86b67e7d10518ac791eda0bf22" aria-hidden="true" alt="C_{i}"/></span> belongs to <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ea4e99f70ce55a732f202d636b5fdc6a28e13440" aria-hidden="true" alt="{\displaystyle {\mathcal {R}}_{i}}"/></span>.
</p>
<p><strong>Definition</strong><span> — </span>A solution of a CSP is a total assignation which satisfied all the constraints of the problem.
</p>
<p>During the search of the solutions of a CSP, a user can wish for:
</p>
<ul><li>finding a solution (satisfying all the constraints);</li>
<li>finding all the solutions of the problem;</li>
<li>proving the unsatisfiability of the problem.</li></ul>
<h2><span id="Constraint_optimization_problem">Constraint optimization problem</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=3" title="Edit section: Constraint optimization problem">edit</a><span>]</span></span></h2>

<p>A constraint optimization problem (COP) is a constraint satisfaction problem associated to an objective function.
</p><p>An <i>optimal solution</i> to a minimization (maximization) COP is a solution that minimizes (maximizes) the value of the <i>objective function</i>. 
</p><p>During the search of the solutions of a CSP, a user can wish for:
</p>
<ul><li>finding a solution (satisfying all the constraints);</li></ul>
<ul><li>finding the best solution with respect to the objective;</li>
<li>proving the optimality of the best found solution;</li>
<li>proving the unsatisfiability of the problem.</li></ul>
<h2><span id="Perturbation_vs_refinement_models">Perturbation vs refinement models</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=4" title="Edit section: Perturbation vs refinement models">edit</a><span>]</span></span></h2>
<p>Languages for constraint-based programming follow one of two approaches:<sup id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup>
</p>
<ul><li>Refinement model: variables in the problem are initially unassigned, and each variable is assumed to be able to contain any value included in its range or domain. As computation progresses, values in the domain of a variable are pruned if they are shown to be incompatible with the possible values of other variables, until a single value is found for each variable.</li>
<li>Perturbation model: variables in the problem are assigned a single initial value. At different times one or more variables receive perturbations (changes to their old value), and the system propagates the change trying to assign new values to other variables that are consistent with the perturbation.</li></ul>
<p><a href="https://en.wikipedia.org/wiki/Constraint_propagation" title="Constraint propagation">Constraint propagation</a> in <a href="https://en.wikipedia.org/wiki/Constraint_Satisfaction_Problems" title="Constraint Satisfaction Problems">constraint satisfaction problems</a> is a typical example of a refinement model, and <a href="https://en.wikipedia.org/wiki/Spreadsheet" title="Spreadsheet">spreadsheets</a> are a typical example of a perturbation model.
</p><p>The refinement model is more general, as it does not restrict variables to have a single value, it can lead to several solutions to the same problem. However, the perturbation model is more intuitive for programmers using mixed imperative constraint object-oriented languages.<sup id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup>
</p>
<h2><span id="Domains">Domains</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=5" title="Edit section: Domains">edit</a><span>]</span></span></h2>
<p>The constraints used in constraint programming are typically over some specific domains. Some popular domains for constraint programming are:
</p>
<ul><li><a href="https://en.wikipedia.org/wiki/Boolean_datatype" title="Boolean datatype">boolean</a> domains, where only true/false constraints apply (<a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem" title="Boolean satisfiability problem">SAT problem</a>)</li>
<li><a href="https://en.wikipedia.org/wiki/Integer" title="Integer">integer</a> domains, <a href="https://en.wikipedia.org/wiki/Rational_numbers" title="Rational numbers">rational</a> domains</li>
<li><a href="https://en.wikipedia.org/wiki/Interval_(mathematics)" title="Interval (mathematics)">interval</a> domains, in particular for scheduling problems</li>
<li><a href="https://en.wikipedia.org/wiki/Linear_algebra" title="Linear algebra">linear</a> domains, where only <a href="https://en.wikipedia.org/wiki/Linear" title="Linear">linear</a> functions are described and analyzed (although approaches to <a href="https://en.wikipedia.org/wiki/Non-linear" title="Non-linear">non-linear</a> problems do exist)</li>
<li><a href="https://en.wiktionary.org/wiki/finite" title="wiktionary:finite">finite</a> domains, where constraints are defined over <a href="https://en.wikipedia.org/wiki/Finite_set" title="Finite set">finite sets</a></li>
<li>mixed domains, involving two or more of the above</li></ul>
<p>Finite domains is one of the most successful domains of constraint programming. In some areas (like <a href="https://en.wikipedia.org/wiki/Operations_research" title="Operations research">operations research</a>) constraint programming is often identified with constraint programming over finite domains.
</p>
<h2><span id="Constraint_propagation">Constraint propagation</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=6" title="Edit section: Constraint propagation">edit</a><span>]</span></span></h2>

<p><b>Local consistency</b> conditions are properties of <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction_problem" title="Constraint satisfaction problem">constraint satisfaction problems</a> related to the <a href="https://en.wikipedia.org/wiki/Consistency" title="Consistency">consistency</a> of subsets of variables or constraints. They can be used to reduce the search space and make the problem easier to solve. Various kinds of local consistency conditions are leveraged, including <b>node consistency</b>, <b>arc consistency</b>, and <b>path consistency</b>.
</p><p>Every local consistency condition can be enforced by a transformation that changes the problem without changing its solutions. Such a transformation is called <b><a href="https://en.wikipedia.org/wiki/Constraint_propagation" title="Constraint propagation">constraint propagation</a></b>.<sup id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup> Constraint propagation works by reducing domains of variables, strengthening constraints, or creating new ones. This leads to a reduction of the search space, making the problem easier to solve by some algorithms. Constraint propagation can also be used as an unsatisfiability checker, incomplete in general but complete in some particular cases.
</p>
<h2><span id="Constraint_solving">Constraint solving</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=7" title="Edit section: Constraint solving">edit</a><span>]</span></span></h2>
<p>There are three main algorithmic techniques for solving constraint satisfaction problems: backtracking search, local search, and dynamic programming.<sup id="cite_ref-:0_1-1"><a href="#cite_note-:0-1">[1]</a></sup>
</p>
<h3><span id="Backtracking_search">Backtracking search</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=8" title="Edit section: Backtracking search">edit</a><span>]</span></span></h3>

<p><b>Backtracking search</b> is a general <a href="https://en.wikipedia.org/wiki/Algorithm" title="Algorithm">algorithm</a> for finding all (or some) solutions to some <a href="https://en.wikipedia.org/wiki/Computational_problem" title="Computational problem">computational problems</a>, notably <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction_problem" title="Constraint satisfaction problem">constraint satisfaction problems</a>, that incrementally builds candidates to the solutions, and abandons a candidate (&#34;backtracks&#34;) as soon as it determines that the candidate cannot possibly be completed to a valid solution.
</p>
<h3><span id="Local_Search">Local Search</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=9" title="Edit section: Local Search">edit</a><span>]</span></span></h3>

<p><b>Local search</b> is an incomplete method for finding a solution to a <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction_problem" title="Constraint satisfaction problem">problem</a>. It is based on iteratively improving an assignment of the variables until all constraints are satisfied. In particular, local search algorithms typically modify the value of a variable in an assignment at each step. The new assignment is close to the previous one in the space of assignment, hence the name <i>local search</i>.
</p>
<h3><span id="Dynamic_programming">Dynamic programming</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=10" title="Edit section: Dynamic programming">edit</a><span>]</span></span></h3>

<p><b>Dynamic programming</b> is both a <a href="https://en.wikipedia.org/wiki/Mathematical_optimization" title="Mathematical optimization">mathematical optimization</a> method and a computer programming method. It refers to simplifying a complicated problem by breaking it down into simpler sub-problems in a <a href="https://en.wikipedia.org/wiki/Recursion" title="Recursion">recursive</a> manner. While some decision problems cannot be taken apart this way, decisions that span several points in time do often break apart recursively. Likewise, in computer science, if a problem can be solved optimally by breaking it into sub-problems and then recursively finding the optimal solutions to the sub-problems, then it is said to have <a href="https://en.wikipedia.org/wiki/Optimal_substructure" title="Optimal substructure">optimal substructure</a>.
</p>
<h2><span id="Example">Example</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=11" title="Edit section: Example">edit</a><span>]</span></span></h2>
<p>The syntax for expressing constraints over finite domains depends on the host language. The following is a <a href="https://en.wikipedia.org/wiki/Prolog" title="Prolog">Prolog</a> program that solves the classical <a href="https://en.wikipedia.org/wiki/Alphametic" title="Alphametic">alphametic</a> puzzle <a href="https://en.wikipedia.org/wiki/Verbal_arithmetic" title="Verbal arithmetic">SEND+MORE=MONEY</a> in constraint logic programming:
</p>
<div dir="ltr"><pre><span></span><span>% This code works in both YAP and SWI-Prolog using the environment-supplied</span>
<span>% CLPFD constraint solver library.  It may require minor modifications to work</span>
<span>% in other Prolog environments or using other constraint solvers.</span>
<span>:-</span> <span>use_module</span><span>(</span><span>library</span><span>(</span><span>clpfd</span><span>)).</span>
<span>sendmore</span><span>(</span><span>Digits</span><span>)</span> <span>:-</span>
   <span>Digits</span> <span>=</span> <span>[</span><span>S</span><span>,</span><span>E</span><span>,</span><span>N</span><span>,</span><span>D</span><span>,</span><span>M</span><span>,</span><span>O</span><span>,</span><span>R</span><span>,</span><span>Y</span><span>],</span>   <span>% Create variables</span>
   <span>Digits</span> <span>ins</span> <span>0..9</span><span>,</span>                <span>% Associate domains to variables</span>
   <span>S</span> <span>#\=</span> <span>0</span><span>,</span>                        <span>% Constraint: S must be different from 0</span>
   <span>M</span> <span>#\=</span> <span>0</span><span>,</span>
   <span>all_different</span><span>(</span><span>Digits</span><span>),</span>          <span>% all the elements must take different values</span>
                <span>1000</span><span>*</span><span>S</span> <span>+</span> <span>100</span><span>*</span><span>E</span> <span>+</span> <span>10</span><span>*</span><span>N</span> <span>+</span> <span>D</span>     <span>% Other constraints</span>
              <span>+</span> <span>1000</span><span>*</span><span>M</span> <span>+</span> <span>100</span><span>*</span><span>O</span> <span>+</span> <span>10</span><span>*</span><span>R</span> <span>+</span> <span>E</span>
   <span>#=</span> <span>10000</span><span>*</span><span>M</span> <span>+</span> <span>1000</span><span>*</span><span>O</span> <span>+</span> <span>100</span><span>*</span><span>N</span> <span>+</span> <span>10</span><span>*</span><span>E</span> <span>+</span> <span>Y</span><span>,</span>
   <span>label</span><span>(</span><span>Digits</span><span>).</span>                  <span>% Start the search</span>
</pre></div>
<p>The interpreter creates a variable for each letter in the puzzle. The operator <code>ins</code> is used to specify the domains of these variables, so that they range over the set of values {0,1,2,3, ..., 9}. The constraints <code>S#\=0</code> and <code>M#\=0</code> means that these two variables cannot take the value zero. When the interpreter evaluates these constraints, it reduces the domains of these two variables by removing the value 0 from them. Then, the constraint <code>all_different(Digits)</code> is considered; it does not reduce any domain, so it is simply stored. The last constraint specifies that the digits assigned to the letters must be such that &#34;SEND+MORE=MONEY&#34; holds when each letter is replaced by its corresponding digit. From this constraint, the solver infers that M=1. All stored constraints involving variable M are awakened: in this case, <a href="https://en.wikipedia.org/wiki/Constraint_propagation" title="Constraint propagation">constraint propagation</a> on the <code>all_different</code> constraint removes value 1 from the domain of all the remaining variables. Constraint propagation may solve the problem by reducing all domains to a single value, it may prove that the problem has no solution by reducing a domain to the empty set, but may also terminate without proving satisfiability or unsatisfiability. The <b>label</b> literals are used to actually perform search for a solution.
</p>
<h2><span id="See_also">See also</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=12" title="Edit section: See also">edit</a><span>]</span></span></h2>
<ul><li><a href="https://en.wikipedia.org/wiki/Combinatorial_optimization" title="Combinatorial optimization">Combinatorial optimization</a></li>
<li><a href="https://en.wikipedia.org/wiki/Constraint_logic_programming" title="Constraint logic programming">Constraint logic programming</a></li>
<li><a href="https://en.wikipedia.org/wiki/Concurrent_constraint_logic_programming" title="Concurrent constraint logic programming">Concurrent constraint logic programming</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mathematical_optimization" title="Mathematical optimization">Mathematical optimization</a></li>
<li><a href="https://en.wikipedia.org/wiki/Heuristic_(computer_science)" title="Heuristic (computer science)">Heuristic algorithms</a></li>
<li><a href="https://en.wikipedia.org/wiki/Nurse_scheduling_problem" title="Nurse scheduling problem">Nurse scheduling problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/Regular_constraint" title="Regular constraint">Regular constraint</a></li>
<li><a href="https://en.wikipedia.org/wiki/Traveling_tournament_problem" title="Traveling tournament problem">Traveling tournament problem</a></li></ul>
<h2><span id="References">References</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=13" title="Edit section: References">edit</a><span>]</span></span></h2>
<div>
<div><ol>
<li id="cite_note-:0-1"><span>^ <a href="#cite_ref-:0_1-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-:0_1-1"><sup><i><b>b</b></i></sup></a></span> <span><cite id="CITEREFRossiBeekWalsh2006">Rossi, Francesca; Beek, Peter van; Walsh, Toby (2006-08-18). <a rel="nofollow" href="https://books.google.com/books?id=Kjap9ZWcKOoC&amp;q=handbook+of+constraint+programming&amp;pg=PP1"><i>Handbook of Constraint Programming</i></a>. Elsevier. <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)" title="ISBN (identifier)">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/9780080463803" title="Special:BookSources/9780080463803"><bdi>9780080463803</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Handbook+of+Constraint+Programming&amp;rft.pub=Elsevier&amp;rft.date=2006-08-18&amp;rft.isbn=9780080463803&amp;rft.aulast=Rossi&amp;rft.aufirst=Francesca&amp;rft.au=Beek%2C+Peter+van&amp;rft.au=Walsh%2C+Toby&amp;rft_id=https%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DKjap9ZWcKOoC%26q%3Dhandbook%2Bof%2Bconstraint%2Bprogramming%26pg%3DPP1&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AConstraint+programming"></span></span>
</li>
<li id="cite_note-2"><span><b><a href="#cite_ref-2">^</a></b></span> <span>Jaffar, Joxan, and J-L. Lassez. &#34;<a rel="nofollow" href="https://dl.acm.org/citation.cfm?id=41635">Constraint logic programming</a>.&#34; Proceedings of the 14th ACM SIGACT-SIGPLAN symposium on Principles of programming languages. ACM, 1987.</span>
</li>
<li id="cite_note-3"><span><b><a href="#cite_ref-3">^</a></b></span> <span><cite id="CITEREFMayohTyuguPenjam1993">Mayoh, Brian; Tyugu, Enn; Penjam, Jaan (1993). <a rel="nofollow" href="https://books.google.com/books?id=B0aqCAAAQBAJ"><i>Constraint Programming</i></a>. <a href="https://en.wikipedia.org/wiki/Springer_Science%2BBusiness_Media" title="Springer Science+Business Media">Springer Science+Business Media</a>. p. 76. <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)" title="ISBN (identifier)">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/9783642859830" title="Special:BookSources/9783642859830"><bdi>9783642859830</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Constraint+Programming&amp;rft.pages=76&amp;rft.pub=Springer+Science%2BBusiness+Media&amp;rft.date=1993&amp;rft.isbn=9783642859830&amp;rft.aulast=Mayoh&amp;rft.aufirst=Brian&amp;rft.au=Tyugu%2C+Enn&amp;rft.au=Penjam%2C+Jaan&amp;rft_id=https%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DB0aqCAAAQBAJ&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AConstraint+programming"></span></span>
</li>
<li id="cite_note-4"><span><b><a href="#cite_ref-4">^</a></b></span> <span>Lopez, G., Freeman-Benson, B., &amp; Borning, A. (1994, January). <a rel="nofollow" href="ftp://trout.cs.washington.edu/tr/1993/09/UW-CSE-93-09-04.pdf">Kaleidoscope: A constraint imperative programming language.</a> In <i>Constraint Programming</i> (pp. 313-329). Springer Berlin Heidelberg.</span>
</li>
<li id="cite_note-5"><span><b><a href="#cite_ref-5">^</a></b></span> <span><cite id="CITEREFBessiere2006">Bessiere, Christian (2006), &#34;Constraint Propagation&#34;, <i>Handbook of Constraint Programming</i>, Foundations of Artificial Intelligence, vol. 2, Elsevier, pp. 29–83, <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a rel="nofollow" href="https://doi.org/10.1016%2Fs1574-6526%2806%2980007-6">10.1016/s1574-6526(06)80007-6</a>, <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)" title="ISBN (identifier)">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/9780444527264" title="Special:BookSources/9780444527264"><bdi>9780444527264</bdi></a></cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Constraint+Propagation&amp;rft.btitle=Handbook+of+Constraint+Programming&amp;rft.series=Foundations+of+Artificial+Intelligence&amp;rft.pages=29-83&amp;rft.pub=Elsevier&amp;rft.date=2006&amp;rft_id=info%3Adoi%2F10.1016%2Fs1574-6526%2806%2980007-6&amp;rft.isbn=9780444527264&amp;rft.aulast=Bessiere&amp;rft.aufirst=Christian&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AConstraint+programming"></span></span>
</li>
</ol></div></div>
<h2><span id="External_links">External links</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Constraint_programming&amp;action=edit&amp;section=14" title="Edit section: External links">edit</a><span>]</span></span></h2>

<ul><li><a rel="nofollow" href="http://www.a4cp.org/">Association for Constraint Programming</a></li>
<li><a rel="nofollow" href="http://www.a4cp.org/events/cp-conference-series">CP Conference Series</a></li>
<li><a rel="nofollow" href="http://kti.ms.mff.cuni.cz/~bartak/constraints/index.html">Guide to Constraint Programming</a></li>
<li><a rel="nofollow" href="https://archive.today/20121205051244/http://www.mozart-oz.org/">The Mozart Programming System</a> at <a href="https://en.wikipedia.org/wiki/Archive.today" title="Archive.today">archive.today</a> (archived December 5, 2012), an <a href="https://en.wikipedia.org/wiki/Oz_programming_language" title="Oz programming language">Oz</a>-based free software (<a href="https://en.wikipedia.org/wiki/X11" title="X11">X11</a>-style)</li>
<li><a rel="nofollow" href="https://archive.today/20130107222548/http://4c.ucc.ie/web/index.jsp">Cork Constraint Computation Centre</a> at <a href="https://en.wikipedia.org/wiki/Archive.today" title="Archive.today">archive.today</a> (archived January 7, 2013)</li>
<li><a rel="nofollow" href="https://sofdem.github.io/gccat/index.html">Global Constraint Catalog</a></li></ul>


<!-- 
NewPP limit report
Parsed by mw1328
Cached time: 20220905194658
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.405 seconds
Real time usage: 0.568 seconds
Preprocessor visited node count: 976/1000000
Post‐expand include size: 48374/2097152 bytes
Template argument size: 3779/2097152 bytes
Highest expansion depth: 14/100
Expensive parser function count: 11/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 29753/5000000 bytes
Lua time usage: 0.225/10.000 seconds
Lua memory usage: 4360555/52428800 bytes
Number of Wikibase entities loaded: 1/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  408.993      1 -total
 26.27%  107.440      1 Template:Reflist
 19.73%   80.694      2 Template:Cite_book
 19.03%   77.822      1 Template:Original_research
 14.66%   59.939      1 Template:Ambox
 14.32%   58.550      1 Template:Commonscat
 13.43%   54.920      1 Template:Sister_project
 12.91%   52.819      1 Template:Side_box
 11.95%   48.877      1 Template:Programming_paradigms
 11.45%   46.848      1 Template:Sidebar
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:189899-0!canonical and timestamp 20220905194658 and revision id 1105971984.
 -->
</div>
</div></div>
  </body>
</html>
