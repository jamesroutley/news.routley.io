<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wunkolo.github.io/post/2024/09/gpu-debug-scopes/">Original</a>
    <h1>GPU Debug Scopes</h1>
    
    <div id="readability-page-1" class="page"><article><p><img src="https://wunkolo.github.io/post/2024/09/gpu-debug-scopes/raii-scopes.png" alt=""/></p><p>Rendering APIs these days tend to capture their gpu workloads into a serialized
form such as a command-buffer or command-list to be dispatched at a later time
into a work-queue.</p>
<p>Diagnostic tooling such as <a href="https://renderdoc.org/" target="_blank" rel="noopener noreferrer">RenderDoc</a> or
<a href="https://developer.nvidia.com/nsight-graphics" target="_blank" rel="noopener noreferrer">Nsight-Graphics</a> allows the disecting
of these command-buffers, but it’s not very obvious to determine what is
happening at a high level from the list of API commands alone:</p>
<table>
  <thead>
      <tr>
          <th>RenderDoc(Before)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><img src="https://wunkolo.github.io/post/2024/09/gpu-debug-scopes/renderdoc-raw.png" alt="RenderDoc"/></td>
      </tr>
  </tbody>
</table>
<table>
  <thead>
      <tr>
          <th>Nsight-Graphics(Before)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><img src="https://wunkolo.github.io/post/2024/09/gpu-debug-scopes/nsight-raw.png" alt="NSight"/></td>
      </tr>
  </tbody>
</table>
<p>Without any additional debugging information, RenderDoc and Nsight will show a
flat list of command-buffer API-calls and will provide some filtering and
categorization of these commands to help track down the ones that you care about.
This process is slow, especially when working with multiple captures and need
to draw some kind of comparisons between them.</p>
<ul>
<li>What if you want to ensure that some host-code ran?</li>
<li>What if you want to ensure Step 1 and Step 2 ran before some issue at Step 3?</li>
<li>Where did this extra API call come from?</li>
<li>How do I make sure my cool optimization ran here?</li>
<li>What if your host code made an opportunistic early-return and skipped some API
calls that you were expecting?</li>
</ul>
<p>It’s difficult to capture these kind of contexts with a flat list of API calls.</p>
<p>Thankfully, rendering APIs tend to allow the attaching of diagnostic data to
both command-buffers and objects to provide valuable diagnostic information to
your captures:</p>
<table>
  <thead>
      <tr>
          <th>RenderDoc(After)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><img src="https://wunkolo.github.io/post/2024/09/gpu-debug-scopes/renderdoc-debug.png" alt="RenderDoc"/></td>
      </tr>
  </tbody>
</table>
<table>
  <thead>
      <tr>
          <th>Nsight-Graphics(After)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><img src="https://wunkolo.github.io/post/2024/09/gpu-debug-scopes/nsight-debug.png" alt="NSight"/></td>
      </tr>
  </tbody>
</table>
<p>After adding some object names, and debugging scopes, both RenderDoc and Nsight
will interpret this data to have both readable object-names and allows groups
of command-buffer API-calls to be grouped and even
<span>c</span><span>o</span><span>l</span><span>o</span><span>r</span><span>i</span><span>z</span><span>e</span><span>d</span>
to your liking.
Above, I generated a color for the pipeline-syncing API-call based on
bits of the hash of the graphics-pipeline itself so I can identify if a pipeline
is being utilized repetitively at a glance.</p>
<p>I’ll talk about Vulkan and OpenGL’s particular implementation of such
features and how to utilize
RAII(<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization)
patterns to automatically maintain nested scopes to create a sort of
<em>call stack</em> within your command-buffers.</p>
<p>This is a pattern I’ve found myself utilizing quite a lot to help with debugging,
diagnosing issues, and profiling.</p>
<h2 id="raii">RAII</h2>
<h3 id="if-you-already-know-what-raii-is-you-can-just-skip-to-the-implementationimplementations">If you already know what RAII is, you can just <a href="#implementations">skip to the implementation</a></h3>
<p>Before we get to the Graphics-API specific implementation, here’s a quick rundown
on how
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" target="_blank" rel="noopener noreferrer">RAII</a>
looks like in C++, C#, and Rust as well.</p>
<p><strong>The final implementations will be provided in C++, but can be mapped to
C# and Rust through their various OpenGL and Vulkan bindings.</strong></p>
<h3 id="c">C++</h3>
<p>In C++, one simply has to implement code into the constructor and deconstructor
to achieve a <a href="https://en.cppreference.com/w/cpp/language" target="_blank" rel="noopener noreferrer">RAII</a> pattern.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>class</span> <span>DebugScope</span>
</span></span><span><span><span>{</span>
</span></span><span><span><span>public</span><span>:</span>
</span></span><span><span>	<span>// Constructor
</span></span></span><span><span><span></span>	<span>DebugScope</span><span>(</span><span>const</span> <span>char</span><span>*</span> <span>ScopeName</span><span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>// Begin scope
</span></span></span><span><span><span></span>		<span>// Graphics API code
</span></span></span><span><span><span></span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>// Deconstructor
</span></span></span><span><span><span></span>	<span>~</span><span>DebugScope</span><span>()</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>// End Scope
</span></span></span><span><span><span></span>		<span>// Graphics API code
</span></span></span><span><span><span></span>	<span>}</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div><p>Usage:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>void</span> <span>Work</span><span>();</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>DebugScope</span> <span>Scope</span><span>(</span><span>&#34;Work&#34;</span><span>);</span> <span>// Constructor called
</span></span></span><span><span><span></span>
</span></span><span><span>	<span>EvenMoreWork</span><span>();</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span><span>(</span> <span>error</span> <span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span><span>;</span> <span>// Deconstructor called
</span></span></span><span><span><span></span>	<span>}</span>
</span></span><span><span>
</span></span><span><span><span>}</span> <span>// Deconstructor called
</span></span></span><span><span><span></span>
</span></span><span><span><span>void</span> <span>ScopeTest</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>DebugScope</span> <span>Scope</span><span>(</span><span>&#34;ScopeTest&#34;</span><span>);</span> <span>// Constructor called
</span></span></span><span><span><span></span>
</span></span><span><span>	<span>Work</span><span>();</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span><span>(</span> <span>error</span> <span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span><span>;</span> <span>// Deconstructor called
</span></span></span><span><span><span></span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>MoreWork</span><span>();</span>
</span></span><span><span>
</span></span><span><span><span>}</span> <span>// Deconstructor called
</span></span></span></code></pre></div><h3 id="csharp">CSharp</h3>
<p>C# gets a bit more tricky.
C# as a language is
<a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" target="_blank" rel="noopener noreferrer">garbage-collected</a>
so the lifetime of an object is determined by the scheduling of the garbage collector.
So you cannot deterministically know when a class’s Deconstructor gets called or
resources get released.
Some additional work must be done to get C++’s behavior where the deconstructor
automatically gets called upon leaving the scope.
We’re trying to avoid having to manually call functions here!</p>
<p>C# exposes the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.idisposable" target="_blank" rel="noopener noreferrer">IDisposable</a>
interface for classes to implement for the releasing of unmanaged resources such
as file-objects, GPU-objects, Native-types, other IDisposable-types, or any
other type that is not handled by the garbage collector.
In this case though our neeeds are simpler.
We aren’t actually freeing any GPU resources, we just want to call some
Graphics-API calls for some automatic scope-management.</p>
<div><pre tabindex="0"><code data-lang="csharp"><span><span><span>using</span> <span>System</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>class</span> <span>DebugScope</span> <span>:</span> <span>IDisposable</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>// Constructor</span>
</span></span><span><span>	<span>public</span> <span>DebugScope</span><span>(</span><span>string</span> <span>ScopeName</span><span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>// Begin scope</span>
</span></span><span><span>		<span>// Graphics API code</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>// Implement IDisposable</span>
</span></span><span><span>	<span>public</span> <span>void</span> <span>Dispose</span><span>()</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>// End Scope</span>
</span></span><span><span>		<span>// Graphics API code</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The
<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/using" target="_blank" rel="noopener noreferrer">using</a>
keyword will also ensure that an object is valid during the scope of the
<code>using</code>-block and will automatically call <code>Dispose</code> upon leaving the scope.
There’s no <em>clean</em> way to enforce a class to only be utilized within a
<code>using</code>-block though, to ensure proper RAII-behavior.
This pattern will have to be a discretion of the code-base.</p>
<p>Usage:</p>
<div><pre tabindex="0"><code data-lang="csharp"><span><span><span>static</span> <span>void</span> <span>Work</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>// Constructor called</span>
</span></span><span><span>	<span>using</span><span>(</span> <span>DebugScope</span> <span>Scope</span> <span>=</span> <span>new</span> <span>DebugScope</span><span>(</span><span>&#34;Work&#34;</span><span>)</span> <span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>EvenMoreWork</span><span>();</span>
</span></span><span><span>
</span></span><span><span>		<span>if</span><span>(</span> <span>error</span> <span>)</span>
</span></span><span><span>		<span>{</span>
</span></span><span><span>			<span>return</span><span>;</span> <span>// Dispose called</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span> <span>// Dispose called</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>static</span> <span>void</span> <span>ScopeTest</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>// Constructor called</span>
</span></span><span><span>	<span>using</span><span>(</span> <span>DebugScope</span> <span>Scope</span> <span>=</span> <span>new</span> <span>DebugScope</span><span>(</span><span>&#34;ScopeTest&#34;</span><span>)</span> <span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>Work</span><span>();</span>
</span></span><span><span>
</span></span><span><span>		<span>if</span><span>(</span> <span>error</span> <span>)</span>
</span></span><span><span>		<span>{</span>
</span></span><span><span>			<span>return</span><span>;</span> <span>// Dispose called</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>
</span></span><span><span>		<span>MoreWork</span><span>();</span>
</span></span><span><span>	<span>}</span> <span>// Dispose called</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><ul>
<li>I have an <a href="https://github.com/Ryujinx/Ryujinx/pull/5671" target="_blank" rel="noopener noreferrer">old PR for Ryujinx</a> that implements this for their Vulkan backend!</li>
</ul>
<h3 id="rust">Rust</h3>
<p><a href="https://doc.rust-lang.org/rust-by-example/scope/raii.html" target="_blank" rel="noopener noreferrer">Rust implements RAII</a>
by implementing the
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html" target="_blank" rel="noopener noreferrer">Drop</a> trait.
By implementing <code>fn drop(&amp;mut self);</code>, code can now be ran when the struct leaves
a scope.</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>struct</span> <span>DebugScope</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>DebugScope</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// Constructor
</span></span></span><span><span><span></span><span>    </span><span>pub</span><span> </span><span>fn</span> <span>new</span><span>(</span><span>scope_name</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>Self</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// Begin scope
</span></span></span><span><span><span></span><span>        </span><span>// Graphics API code
</span></span></span><span><span><span></span><span>        </span><span>return</span><span> </span><span>DebugScope</span><span> </span><span>{};</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Implement Drop trait
</span></span></span><span><span><span></span><span>impl</span><span> </span><span>Drop</span><span> </span><span>for</span><span> </span><span>DebugScope</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// Deconstructor
</span></span></span><span><span><span></span><span>    </span><span>fn</span> <span>drop</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// End scope
</span></span></span><span><span><span></span><span>        </span><span>// Graphics API code
</span></span></span><span><span><span></span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Similar to C++, just defining the object is enough for our code to run when
defined within a scope and upon leaving the scope.
Since scope-objects don’t usually have to be touched after they are defined,
the object can be named with an underscore(<code>_</code>) before its name to avoid any
“unused variable”-warnings.</p>
<p>Usage:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>work</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// Constructor called
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>_scope</span><span> </span><span>=</span><span> </span><span>DebugScope</span>::<span>new</span><span>(</span><span>&#34;Work&#34;</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>even_more_work</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>(</span><span>error</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>return</span><span>;</span><span> </span><span>// Drop called
</span></span></span><span><span><span></span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span> </span><span>// Drop called
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span> <span>scope_test</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// Constructor called
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>_scope</span><span> </span><span>=</span><span> </span><span>DebugScope</span>::<span>new</span><span>(</span><span>&#34;ScopeTest&#34;</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>work</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>(</span><span>error</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>return</span><span>;</span><span> </span><span>// Drop called
</span></span></span><span><span><span></span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>more_work</span><span>();</span><span>
</span></span></span><span><span><span></span><span>}</span><span> </span><span>// Drop called
</span></span></span></code></pre></div><h2 id="implementations">Implementations</h2>
<h3 id="vulkan">Vulkan</h3>
<p>Vulkan provides the
<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_debug_utils.html" target="_blank" rel="noopener noreferrer">VK_EXT_debug_utils</a>
extension to allow attaching names to objects as well as <em>colored</em>
labels to spans of command-buffer commands and queue-operations.</p>
<p>The <code>vkCmd{Begin,End,Insert}DebugUtilsLabelEXT</code>-functions are utilized to group and label particular spans of command buffer operations with a
<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsLabelEXT.html" target="_blank" rel="noopener noreferrer">VkDebugUtilsLabelEXT</a> structure. This allows both a plaintext name(<code>const char*</code>) an RGBA
floating-point color(<code>float[4]</code>) to be correlated with command buffer operations:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// Provided by VK_EXT_debug_utils
</span></span></span><span><span><span></span><span>typedef</span> <span>struct</span> <span>VkDebugUtilsLabelEXT</span> <span>{</span>
</span></span><span><span>	<span>VkStructureType</span>    <span>sType</span><span>;</span>
</span></span><span><span>	<span>const</span> <span>void</span><span>*</span>        <span>pNext</span><span>;</span>
</span></span><span><span>	<span>const</span> <span>char</span><span>*</span>        <span>pLabelName</span><span>;</span>
</span></span><span><span>	<span>float</span>              <span>color</span><span>[</span><span>4</span><span>];</span>
</span></span><span><span><span>}</span> <span>VkDebugUtilsLabelEXT</span><span>;</span>
</span></span></code></pre></div><p><code>vkCmdInsertDebugUtilsLabelEXT</code> additionally allows the insertion of additional
one-off labels within a command buffer as well.
An additional function or operator-overload may be added to the <code>DebugScope</code>
object to insert these additional labels.</p>
<p>A minimally viable Vulkan implementation, ready for you to copy-paste,
could look like this:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>class</span> <span>DebugScope</span> <span>{</span>
</span></span><span><span><span>private</span><span>:</span>
</span></span><span><span>	<span>// Keep this command buffer around so that the deconstructor can properly
</span></span></span><span><span><span></span>	<span>// end the debug-scope
</span></span></span><span><span><span></span>	<span>const</span> <span>VkCommandBuffer</span> <span>commandBuffer</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>public</span><span>:</span>
</span></span><span><span>	<span>// Upon construction, begin the debug-scope
</span></span></span><span><span><span></span>	<span>DebugScope</span><span>(</span>
</span></span><span><span>		<span>VkCommandBuffer</span> <span>targetCommandBuffer</span><span>,</span>
</span></span><span><span>		<span>const</span> <span>char</span><span>*</span> <span>scopeName</span><span>,</span> <span>std</span><span>::</span><span>span</span><span>&lt;</span><span>const</span> <span>float</span><span>,</span> <span>4</span><span>&gt;</span> <span>scopeColor</span>
</span></span><span><span>	<span>)</span> <span>:</span> <span>commandBuffer</span><span>(</span><span>targetCommandBuffer</span><span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>VkDebugUtilsLabelEXT</span> <span>label</span> <span>=</span> <span>{};</span>
</span></span><span><span>		<span>label</span><span>.</span><span>sType</span> <span>=</span> <span>VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT</span><span>;</span>
</span></span><span><span>		<span>label</span><span>.</span><span>pLabelName</span> <span>=</span> <span>scopeName</span><span>;</span>
</span></span><span><span>		<span>std</span><span>::</span><span>copy_n</span><span>(</span><span>scopeColor</span><span>.</span><span>begin</span><span>(),</span> <span>4</span><span>,</span> <span>label</span><span>.</span><span>color</span><span>);</span>
</span></span><span><span>		<span>vkCmdBeginDebugUtilsLabelEXT</span><span>(</span><span>commandBuffer</span><span>,</span> <span>&amp;</span><span>label</span><span>);</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>// A bonus operator to insert plain labels within the command-buffer
</span></span></span><span><span><span></span>	<span>void</span> <span>operator</span><span>()(</span><span>const</span> <span>char</span><span>*</span> <span>scopeName</span><span>,</span> <span>std</span><span>::</span><span>span</span><span>&lt;</span><span>const</span> <span>float</span><span>,</span> <span>4</span><span>&gt;</span> <span>scopeColor</span><span>)</span> <span>const</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>VkDebugUtilsLabelEXT</span> <span>label</span> <span>=</span> <span>{};</span>
</span></span><span><span>		<span>label</span><span>.</span><span>sType</span> <span>=</span> <span>VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT</span><span>;</span>
</span></span><span><span>		<span>label</span><span>.</span><span>pLabelName</span> <span>=</span> <span>scopeName</span><span>;</span>
</span></span><span><span>		<span>std</span><span>::</span><span>copy_n</span><span>(</span><span>scopeColor</span><span>.</span><span>begin</span><span>(),</span> <span>4</span><span>,</span> <span>label</span><span>.</span><span>color</span><span>);</span>
</span></span><span><span>		<span>vkCmdInsertDebugUtilsLabelEXT</span><span>(</span><span>commandBuffer</span><span>,</span> <span>&amp;</span><span>label</span><span>);</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>// Upon deconstruction, begin the debug-scope
</span></span></span><span><span><span></span>	<span>~</span><span>DebugScope</span><span>()</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>vkCmdEndDebugUtilsLabelEXT</span><span>(</span><span>commandBuffer</span><span>);</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// Usage
</span></span></span><span><span><span></span><span>void</span> <span>DoThing</span><span>(</span><span>VkCommandBuffer</span> <span>commandBuffer</span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>static</span> <span>float</span> <span>thingColor</span><span>[</span><span>4</span><span>]</span> <span>=</span> <span>{</span><span>1.0f</span><span>,</span> <span>1.0f</span><span>,</span> <span>0.0f</span><span>,</span> <span>1.0f</span><span>};</span>
</span></span><span><span>	<span>DebugScope</span> <span>scope</span><span>(</span><span>commandBuffer</span><span>,</span> <span>&#34;DoThing&#34;</span><span>,</span> <span>thingColor</span><span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>scope</span><span>(</span><span>&#34;Step1&#34;</span><span>,</span> <span>thingColor</span><span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>vkCmd</span><span>...(</span><span>commandBuffer</span><span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>scope</span><span>(</span><span>&#34;Step2&#34;</span><span>,</span> <span>thingColor</span><span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>vkCmd</span><span>...(</span><span>commandBuffer</span><span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>scope</span><span>(</span><span>&#34;Step3&#34;</span><span>,</span> <span>thingColor</span><span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>vkCmd</span><span>...(</span><span>commandBuffer</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The basic pattern can be extended further to add even more conveniences such as
utilizing <a href="https://github.com/KhronosGroup/Vulkan-Hpp" target="_blank" rel="noopener noreferrer">Vulkan-Hpp</a> to help make
the code more concise and expressive or utilizing
<a href="https://github.com/fmtlib/fmt" target="_blank" rel="noopener noreferrer">fmt</a> to aid in scope and label name generation.
You could even put <code>__FILE__</code> or <code>__LINE__</code> or
<a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html" target="_blank" rel="noopener noreferrer">the calling function-name itself</a>
into the debug-scope name to be able to more easily “blame” each command buffer
scope to the exact host-code that emitted it.</p>
<p>To avoid additional overhead, you might choose to use something like
<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_tooling_info.html" target="_blank" rel="noopener noreferrer">VK_EXT_tooling_info</a> (Core in Vulkan 1.3)
to only conditionally insert these API commands if it detects that RenderDoc or
Nsight is attached to the Vulkan instance.</p>
<p>Scope and label coloration can either be manually decided at each call-site or
it can be generated to your choosing.</p>
<p>A simple one is to maintain a static <code>depth</code>-integer within the <code>DebugScope</code>-object
that increments/decrements in the ctor/dtor. Knowing what <em>depth</em> each scope is
at allows for procedural color-selection
such as utilizing something like
<a href="https://iquilezles.org/articles/palettes/" target="_blank" rel="noopener noreferrer">Inigo Quilez’s procedural color-palettes</a>.
<a href="https://github.com/stenzek/duckstation/pull/2438" target="_blank" rel="noopener noreferrer">A contribution I made to DuckStation</a>
utilized this pattern in particular.
This would work fine if you only ever operated upon a single recycled command buffer.
In a multi-threaded environment, you will probably want to maintain this
<code>depth</code>-variable in a per-command-buffer abstraction as opposed to having a
globally shared <code>depth</code>-variable between all command buffers.</p>
<table>
  <thead>
      <tr>
          <th>Before</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="https://wunkolo.github.io/post/2024/09/gpu-debug-scopes/duckstation-before.png"><img src="https://wunkolo.github.io/post/2024/09/gpu-debug-scopes/duckstation-before.png" alt="Before"/></a></td>
      </tr>
  </tbody>
</table>
<table>
  <thead>
      <tr>
          <th>After</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="https://wunkolo.github.io/post/2024/09/gpu-debug-scopes/duckstation-after.png"><img src="https://wunkolo.github.io/post/2024/09/gpu-debug-scopes/duckstation-after.png" alt="After"/></a></td>
      </tr>
  </tbody>
</table>
<p>Another option for coloration is to group certain operations by colors such as
making all “transfer” workloads yellow, all “graphics” workloads green,
all “compute” workloads orange, and all “present” operations magenta.</p>
<p>Some code-bases might further decide to color the labels based on the specific operation, such as coloring a label for a
<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdClearColorImage.html" target="_blank" rel="noopener noreferrer">vkCmdClearColorImage</a>
operation with the clear-color itself.
<a href="https://github.com/wheremyfoodat/Panda3DS/pull/48" target="_blank" rel="noopener noreferrer">A contribution I made to Panda3DS</a> utilized this pattern.</p>
<p><img src="https://wunkolo.github.io/post/2024/09/gpu-debug-scopes/vk-clear-color.png" alt="ClearColor"/></p>
<p>With this additional data in your command buffer, debug callbacks will also be
able to interpret this additional context within the
<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCallbackDataEXT.html" target="_blank" rel="noopener noreferrer">VkDebugUtilsMessengerCallbackDataEXT</a>
structure.</p>
<p>Each of the originally defined <code>VkDebugUtilsLabelEXT</code> structures for each label
can be derived by iterating with the <code>pCmdBufLabels</code> and <code>cmdBufLabelCount</code>
variables.</p>
<p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDebugUtilsMessengerCallbackDataEXT.html#_description" target="_blank" rel="noopener noreferrer">These labels are sorted from oldest to newest</a>.
So <code>pCmdBufLabels[0]</code> would be the oldest label that was set leading
into the current debug message, and <code>pCmdBufLabels[cmdBufLabelCount - 1]</code> would
be the most recent label.</p>
<p>This could provide valuable context around particular error messages to help
diagnose an issue.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>VKAPI_ATTR</span> <span>VkBool32</span> <span>VKAPI_CALL</span> <span>DebugMessageCallback</span><span>(</span>
</span></span><span><span>	<span>VkDebugUtilsMessageSeverityFlagBitsEXT</span>      <span>MessageSeverity</span><span>,</span>
</span></span><span><span>	<span>VkDebugUtilsMessageTypeFlagsEXT</span>             <span>MessageType</span><span>,</span>
</span></span><span><span>	<span>const</span> <span>VkDebugUtilsMessengerCallbackDataEXT</span><span>*</span> <span>CallbackData</span><span>,</span> <span>void</span><span>*</span> <span>UserData</span>
</span></span><span><span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>// Loop through all labels for this particular message
</span></span></span><span><span><span></span>	<span>for</span><span>(</span> <span>std</span><span>::</span><span>uint32_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>CallbackData</span><span>-&gt;</span><span>cmdBufLabelCount</span><span>;</span> <span>++</span><span>i</span> <span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>const</span> <span>VkDebugUtilsLabelEXT</span><span>&amp;</span> <span>CurLabel</span> <span>=</span> <span>CallbackData</span><span>-&gt;</span><span>pCmdBufLabels</span><span>[</span><span>i</span><span>];</span>
</span></span><span><span>		<span>std</span><span>::</span><span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;%u [%s]</span><span>\n</span><span>&#34;</span><span>,</span> <span>i</span><span>,</span> <span>CurLabel</span><span>.</span><span>pLabelName</span><span>);</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>switch</span><span>(</span> <span>vk</span><span>::</span><span>DebugUtilsMessageSeverityFlagBitsEXT</span><span>(</span><span>MessageSeverity</span><span>)</span> <span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>	<span>case</span> <span>vk</span><span>::</span><span>DebugUtilsMessageSeverityFlagBitsEXT</span><span>::</span><span>eError</span><span>:</span>
</span></span><span><span>	<span>case</span> <span>vk</span><span>::</span><span>DebugUtilsMessageSeverityFlagBitsEXT</span><span>::</span><span>eWarning</span><span>:</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>// Something bad happened!
</span></span></span><span><span><span></span>		<span>const</span> <span>char</span><span>*</span> <span>Message</span> <span>=</span> <span>CallbackData</span><span>-&gt;</span><span>pMessage</span><span>;</span>
</span></span><span><span>		<span>std</span><span>::</span><span>puts</span><span>(</span><span>Message</span><span>);</span>
</span></span><span><span>		<span>assert</span><span>(</span><span>0</span><span>);</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>...</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>return</span> <span>VK_FALSE</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>In this example output, I’ve artifically doubled the size of a pipeline barrier
within a scope named <code>Upload Data</code>:</p>
<pre tabindex="0"><code>0 [Download]
1 [Rendering]
2 [Upload Data]        &lt;&lt;&lt; This is the most-recent label reached before this error!
Validation Error: [ VUID-VkBufferMemoryBarrier-size-01189 ] Object 0: handle = 0xdb05ecf0, type = VK_OBJECT_TYPE_COMMAND_BUFFER; | MessageID = 0xb63479f2 | vkCmdPipelineBarrier(): pBufferMemoryBarriers[0].size VkBuffer 0xab64de0000000020[] has offset 0x0 and size 0x2f4400 whose sum is greater than total size 0x17a200. The Vulkan spec states: If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to than the size of buffer minus offset (https://vulkan.lunarg.com/doc/view/1.3.268.0/windows/1.3-extensions/vkspec.html#VUID-VkBufferMemoryBarrier-size-01189)
</code></pre><p>With this, I can now know exactly what part of the code-base to start looking
investigating the issue in.</p>
<h3 id="opengl">OpenGL</h3>
<p>OpenGL provides the
<a href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt" target="_blank" rel="noopener noreferrer">GL_KHR_debug</a>
extension for attaching diagnostic information to the rendering context.</p>
<p>Since OpenGL operates upon a global-state, <code>gl{Push,Pop}DebugGroup</code> will group
together API-calls at a global-scope.</p>
<p>I have yet to see any GPU tooling utilize the <code>id</code> parameter of
<code>glPushDebugGroup</code>, but I’ve assigned it to the global scope-depth to try and
keep this code future-facing to any diagnostic tooling that may eventually
decide to do something with it.
You could just statically provide it <code>0</code> if you wanted to.</p>
<p><img src="https://wunkolo.github.io/post/2024/09/gpu-debug-scopes/opengl-scope.png" alt="OpenGL"/></p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>class</span> <span>DebugScope</span> <span>{</span>
</span></span><span><span>	<span>inline</span> <span>static</span> <span>GLuint</span> <span>GlobalScopeDepth</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>	<span>const</span> <span>GLuint</span> <span>ScopeDepth</span><span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>public</span><span>:</span>
</span></span><span><span>	<span>DebugScope</span><span>(</span><span>std</span><span>::</span><span>string_view</span> <span>ScopeName</span><span>)</span>
</span></span><span><span>		<span>:</span> <span>ScopeDepth</span><span>(</span><span>GlobalScopeDepth</span><span>++</span><span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>glPushDebugGroup</span><span>(</span><span>GL_DEBUG_SOURCE_APPLICATION</span><span>,</span> <span>ScopeDepth</span><span>,</span> <span>ScopeName</span><span>.</span><span>size</span><span>(),</span> <span>ScopeName</span><span>.</span><span>data</span><span>());</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>~</span><span>DebugScope</span><span>()</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>glPopDebugGroup</span><span>();</span>
</span></span><span><span>		<span>GlobalScopeDepth</span><span>--</span><span>;</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div><ul>
<li><a href="https://love2d.org/forums/viewtopic.php?t=92481" target="_blank" rel="noopener noreferrer">An implementation within Lua provided for Love2D</a></li>
</ul>
<hr/>
</article></div>
  </body>
</html>
