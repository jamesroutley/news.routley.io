<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ctrl-alt-test.fr/2025/15-years-of-shader-minification/">Original</a>
    <h1>15 Years of Shader Minification</h1>
    
    <div id="readability-page-1" class="page"><div>
			
<p>How do demosceners create complex computer animations in just a few kilobytes? One of our secret weapons is <a href="https://github.com/laurentlb/shader-minifier">Shader Minifier</a>, a tool that minifies GLSL code. Over the years, it has evolved to pack more data into tiny executables, pushing the boundaries of what’s possible. In this blog post, we’ll go through its evolution.</p>



<figure><a href="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-1.png"><img decoding="async" width="992" height="1024" src="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-1-992x1024.png" alt="" srcset="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-1-992x1024.png 992w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-1-291x300.png 291w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-1-768x793.png 768w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-1-624x644.png 624w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-1.png 1238w" sizes="(max-width: 992px) 100vw, 992px"/></a><figcaption><a href="https://www.pouet.net/prod.php?which=97546">XO</a> by Nuance (4kB)</figcaption></figure>



<p>In 2010, I noticed a trend in the demoscene: creators were producing impressive 4k intros, but the process was incredibly manual and tedious. These intros relied on shader code to generate graphics, and optimizing this code was like a <a href="https://en.wikipedia.org/wiki/Code_golf">code golf</a> competition. As the existing tooling was poor, I decided to help. My goal was to automate the most boring tasks: removing unnecessary spaces and comments, and renaming variables to a single letter. This is how Shader Minifier was born.</p>



<h2>The compression paradox</h2>



<p>One of the first features I implemented was the insertion of preprocessor macros. This is a classic trick often used in code golf competitions and obfuscation contests:</p>





<p>By adding this line at the top of your code, you can replace every instance of “return” with “R”, saving 5 bytes per statement. This can quickly add up, especially if you apply it to other common keywords or standard function calls.</p>



<p>But someone once asked me: “Shader Minifier makes files small, but how many bytes does it actually save after compression with <a href="https://github.com/runestubbe/Crinkler">Crinkler</a>?” Crinkler is the most popular compression tool for small intros.</p>



<p>At first, I didn’t care much: if I make the code smaller, the compressed code will obviously get smaller too… right? Nope, I was wrong. I tested it and I found out that the output of Shader Minifier was compressing to something bigger than the non-minified code. Was it bad luck? I experimented and adjusted some heuristics in the code. Is it best to introduce more macros or fewer? After multiple iterations, I found that the best approach was… to do nothing. Do not replace code with macros.</p>



<p>Turns out, Crinkler is smarter than I thought, and my clever macros were getting in its way. Modern compressors are excellent at identifying redundant patterns. If the word “return” is repeated throughout the code, the compressor can handle it very efficiently. Using macros to eliminate these redundancies is counterproductive.</p>



<h2>Renaming: not as easy as ABC</h2>



<p>Renaming identifiers seems like an obvious feature for a minifier. Initially, the goal seemed simple: use a single letter for each identifier. After all, one letter per identifier is optimal, right? Yet again, I was mistaken. Not all letters are equal when it comes to compression.</p>



<p>A good name is one that you reuse. If multiple variables have the same name, the code will look more repetitive and compress better.</p>



<p>So our strategy is to be pretty aggressive in reusing names:</p>



<ul>
<li>Variables in two different functions can obviously use the same name.</li>



<li>If a global variable is not referenced within a function, we can also reuse its name thanks to variable shadowing.</li>



<li>We can even reuse function names. With function overloading, the compiler will distinguish them as long as they have different arguments.</li>
</ul>



<p>Yep. We’ve been so aggressive in reusing names that we’ve discovered bugs in glslang:</p>



<ul>
<li><a href="https://github.com/laurentlb/shader-minifier/issues/435">https://github.com/laurentlb/shader-minifier/issues/435</a></li>



<li><a href="https://github.com/KhronosGroup/glslang/issues/3931">https://github.com/KhronosGroup/glslang/issues/3931</a></li>
</ul>



<p>When a minifier breaks your compiler, you know you’re pushing boundaries.</p>



<p>Reducing the number of unique variable names is very effective. But you also have to pick good names. Should we name the variable “V” or “A”? Experiments show that picking one name or the other can affect the compressed size. It’s hard to know which name will perform better, but we compute the frequencies of letters and bigrams to guess which names are more likely to be better. The idea is to look at which characters appear more often in the rest of the code, and which pairs of characters are already common. In the end, it’s just a heuristic, and we could probably do better.</p>



<h2>8k is bigger than 4k</h2>



<figure><img decoding="async" width="1600" height="902" src="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/AD_4nXeDH_apXiJEOUlQcVcTTt74qQMnFPm4Rmow5JtXdSSIeH5S4qpg1Mv6roLVxNQPQcX016JTet7bWKRa14ZOzIdqT1CwOsifbRDRN1z2HsZH-nfSJsB1i7h7dZezhRj6htmX_qFVwg.png" alt="" srcset="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/AD_4nXeDH_apXiJEOUlQcVcTTt74qQMnFPm4Rmow5JtXdSSIeH5S4qpg1Mv6roLVxNQPQcX016JTet7bWKRa14ZOzIdqT1CwOsifbRDRN1z2HsZH-nfSJsB1i7h7dZezhRj6htmX_qFVwg.png 1600w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/AD_4nXeDH_apXiJEOUlQcVcTTt74qQMnFPm4Rmow5JtXdSSIeH5S4qpg1Mv6roLVxNQPQcX016JTet7bWKRa14ZOzIdqT1CwOsifbRDRN1z2HsZH-nfSJsB1i7h7dZezhRj6htmX_qFVwg-300x169.png 300w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/AD_4nXeDH_apXiJEOUlQcVcTTt74qQMnFPm4Rmow5JtXdSSIeH5S4qpg1Mv6roLVxNQPQcX016JTet7bWKRa14ZOzIdqT1CwOsifbRDRN1z2HsZH-nfSJsB1i7h7dZezhRj6htmX_qFVwg-1024x577.png 1024w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/AD_4nXeDH_apXiJEOUlQcVcTTt74qQMnFPm4Rmow5JtXdSSIeH5S4qpg1Mv6roLVxNQPQcX016JTet7bWKRa14ZOzIdqT1CwOsifbRDRN1z2HsZH-nfSJsB1i7h7dZezhRj6htmX_qFVwg-768x433.png 768w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/AD_4nXeDH_apXiJEOUlQcVcTTt74qQMnFPm4Rmow5JtXdSSIeH5S4qpg1Mv6roLVxNQPQcX016JTet7bWKRa14ZOzIdqT1CwOsifbRDRN1z2HsZH-nfSJsB1i7h7dZezhRj6htmX_qFVwg-1536x866.png 1536w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/AD_4nXeDH_apXiJEOUlQcVcTTt74qQMnFPm4Rmow5JtXdSSIeH5S4qpg1Mv6roLVxNQPQcX016JTet7bWKRa14ZOzIdqT1CwOsifbRDRN1z2HsZH-nfSJsB1i7h7dZezhRj6htmX_qFVwg-624x352.png 624w" sizes="(max-width: 1600px) 100vw, 1600px"/><figcaption><a href="https://www.ctrl-alt-test.fr/productions/the-sheep-and-the-biker/">The Sheep and the Biker</a>, by Ctrl-Alt-Test (8kB)</figcaption></figure>



<p>With these features implemented, my original goal was achieved. Many demosceners have been using Shader Minifier for years to create their mind-blowing 4k intros.</p>



<p>But one day, I decided to create my first 8k intro. The story behind The Sheep and the Flower was detailed in the blog post “<a href="https://www.ctrl-alt-test.fr/2024/how-we-made-an-animated-movie-in-8kb/">How we made an animated movie in 8kB</a>”.</p>



<p>Size-coding and code golfing are fun when there’s a small amount of code. But as the codebase grows beyond 1,000 lines, micro-optimizations become increasingly painful. The problem is that we also need to maintain and iterate on the code, so it needs to remain readable throughout the development of the intro. To be able to <em>sheep</em> my intro, more features were needed in Shader Minifier.</p>



<p>Here’s a graph showing the evolution:</p>



<figure><img loading="lazy" decoding="async" width="624" height="572" src="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/AD_4nXc_1tLQ026UN7gZAhaW24uYFPwqKygzFTUyHbOK5ajIkZEjxkGk2r-k0kqZigKG4naZEWs6GL1E5_iQTTl2KyeByk9V5OiaIdvY05aVuLCLc1KW-3BbZsaCf9iNbg0DxCe_PBRdSg.png" alt="" srcset="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/AD_4nXc_1tLQ026UN7gZAhaW24uYFPwqKygzFTUyHbOK5ajIkZEjxkGk2r-k0kqZigKG4naZEWs6GL1E5_iQTTl2KyeByk9V5OiaIdvY05aVuLCLc1KW-3BbZsaCf9iNbg0DxCe_PBRdSg.png 624w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/AD_4nXc_1tLQ026UN7gZAhaW24uYFPwqKygzFTUyHbOK5ajIkZEjxkGk2r-k0kqZigKG4naZEWs6GL1E5_iQTTl2KyeByk9V5OiaIdvY05aVuLCLc1KW-3BbZsaCf9iNbg0DxCe_PBRdSg-300x275.png 300w" sizes="auto, (max-width: 624px) 100vw, 624px"/></figure>



<p>This graph shows the evolution of Shader Minifier and how big my 47kB shader code will get after minification plus compression. Without minification, Crinkler compresses the code down to about 10kB. I compared around 20 different versions of Shader Minifier and compressed their output with Crinkler to track the tool’s evolution.</p>



<p>So the recent improvements to Shader Minifier have saved about 1kB on this specific shader (between version 1.3 and 1.5). But don’t focus too much on this number: some of the improvements are about quality-of-life, not raw size. For example, it’s nice that we no longer have to manually find and remove unused functions.</p>



<p>In case you wonder about the size regression in version 1.0.5: at that time, we lacked proper tests for compression, so it went unnoticed (it was something related to renaming heuristics). Testing infrastructure is something that we improved later. Anyway, the point is that 47kB became 5.2kB after minifier and compression magic. The rest of the 8kB are filled with the music and the setup code.</p>



<p>So, what have we done since version 1.3?</p>



<h2>Static analysis</h2>



<p>We used static analysis and implemented features commonly found in optimizing compilers.</p>



<p>The full list of optimizations is long, it includes many micro-optimizations and things like GLSL vectors and swizzles transformations. If you’re curious, check the documentation for a <a href="https://github.com/laurentlb/shader-minifier/blob/master/TRANSFORMATIONS.md">more detailed list of optimizations</a>.</p>



<p>Below are some of the most impactful optimizations. You’ll notice how they try to reduce the number of names we need. Whether it’s variables or functions, each time we can get rid of an identifier, we help make the code more compressible.</p>



<h3><strong>Inlining</strong></h3>



<p>If a variable is used only once, we can inline it and eliminate the declaration.</p>



<p>Even if used multiple times, trivial constants like 0.5 or vec3(1) are often better inlined.</p>



<figure><a href="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image.png"><img loading="lazy" decoding="async" width="1024" height="770" src="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-1024x770.png" alt="" srcset="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-1024x770.png 1024w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-300x226.png 300w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-768x577.png 768w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-1536x1155.png 1536w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-624x469.png 624w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image.png 1604w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></a></figure>



<h3><strong>Variables reuse</strong></h3>



<p>In some cases, we reuse a variable name instead of declaring a new one, assuming they don’t overlap.</p>



<p>For example, this code:</p>


<div><pre title="">vec3 x = vec3(.2);
# use x
# …
vec3 col=vec3(0,.04,.04);
</pre></div>


<p>Can be converted to:</p>


<div><pre title="">vec3 x = vec3(.2);
// use x
// …
x=vec3(0,.04,.04);
</pre></div>


<h3><strong>Functions</strong></h3>



<p>Shader Minifier can inline small functions and remove arguments that always receive the same value.</p>



<p>For example, Shader Minifier will detect that the <code>corner</code> argument is not really needed here:</p>


<div><pre title="">float Box3(vec3 p, vec3 size, float corner)
{
   p = abs(p) - size + corner;
   return length(max(p, 0.)) + min(max(max(p.x, p.y), p.z), 0.) - corner;
}

// …
float x = Box3(p, size, 0.2);
float y = Box3(p, size*2., 0.2);
</pre></div>


<p>So we can transform the piece of code to:</p>


<div><pre title="">float Box3(vec3 p, vec3 size)
{
   float corner = 0.2; // note that it can be further inlined
   p = abs(p) - size + corner;
   return length(max(p, 0.)) + min(max(max(p.x, p.y), p.z), 0.) - corner;
}

// …
float x = Box3(p, size);
float y = Box3(p, size*2.);
</pre></div>


<p>But if the Box3 function was called only once, Shader Minifier would instead remove the function declaration and inline the function at the call site.</p>



<h2>Still room to <s>grow</s> shrink</h2>



<figure><a href="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-2-scaled.png"><img loading="lazy" decoding="async" width="1024" height="611" src="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-2-1024x611.png" alt="" srcset="https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-2-1024x611.png 1024w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-2-300x179.png 300w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-2-768x458.png 768w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-2-1536x916.png 1536w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-2-2048x1222.png 2048w, https://www.ctrl-alt-test.fr/wp-content/uploads/2025/05/image-2-624x372.png 624w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></a><figcaption><a href="https://www.pouet.net/prod.php?which=96550">Once Upon A Time In A Datacenter</a>, by iapafoto (4kB)</figcaption></figure>



<p>What started as a simple tool 15 years ago has grown into something more sophisticated. In recent years, our goal has been to simplify the development of 8k intros and make the process more enjoyable. With Shader Minifier, you can achieve much more without spending countless hours on micro-optimizations.</p>



<p>I hope the graph above will encourage users to upgrade their version of Shader Minifier. Quite often, people will download it once and keep it for years. New versions can help you squeeze more into your executable. This is especially true when you have non-trivial amounts of code.</p>



<p>But it’s not over. How well does Shader Minifier perform when creating a 64k intro? These larger intros come with their own set of challenges, often involving multiple shaders that we have to minify together. While Shader Minifier can already save multiple kilobytes, there are still many opportunities for improvement…</p>



<p>We’ll look into this. There are bytes still waiting to be saved.</p>




					</div></div>
  </body>
</html>
