<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://internals-for-interns.com/posts/the-go-linker/">Original</a>
    <h1>Understanding the Go Compiler: The Linker</h1>
    
    <div id="readability-page-1" class="page"><div><p>In the <a href="https://internals-for-interns.com/posts/the-go-machine-code/">previous post</a>
, we watched the compiler transform optimized SSA into machine code bytes and package them into object files. Each <code>.o</code> file contains the compiled code for one package—complete with machine instructions, symbol definitions, and relocations marking addresses that need fixing.</p><p>But your program isn’t just one package. Even a simple “hello world” imports <code>fmt</code>, which imports <code>io</code>, <code>os</code>, <code>reflect</code>, and dozens of other packages. Each package is compiled separately into its own object file. None of these files can run on their own.</p><p>This is where the <strong>linker</strong> comes in. The linker’s job is to take all these separate object files and combine them into a single executable that your operating system can run.</p><p>Let me show you what the linker does and how it does it.</p><h2 id="what-the-linker-does">What the Linker Does</h2><p>At a high level, the linker performs four main tasks:</p><p><strong>1. Symbol Resolution</strong>: Your code calls <code>fmt.Println</code>, but that function is defined in a different object file. The linker finds all these cross-file references and connects them.</p><p><strong>2. Relocation</strong>: Remember those placeholder addresses in the machine code? The linker patches them with actual addresses now that it knows where everything will live in memory.</p><p><strong>3. Dead Code Elimination</strong>: If you import a package but only use one function, the linker removes all the unused functions. This keeps your binary small.</p><p><strong>4. Layout and Executable Generation</strong>: The linker decides where in memory each piece of code and data will live, then writes out an executable in the format your OS expects (ELF on Linux, Mach-O on macOS, PE on Windows).</p><p>Let’s walk through each of these steps, starting with how the linker figures out what symbols exist and where they live.</p><h2 id="symbol-resolution">Symbol Resolution</h2><p>Every object file contains <strong>symbols</strong>—names that identify functions, global variables, and other program elements. Some symbols are <strong>defined</strong> in a file (the actual code or data lives there), while others are just <strong>referenced</strong> (the code uses them, but they live somewhere else).</p><p>Let me show you what I mean:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// main.go</span><span>
</span></span></span><span><span><span></span><span>package</span><span> </span><span>main</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>import</span><span> </span><span>&#34;fmt&#34;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Hello&#34;</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>When compiled, your <code>main.o</code> contains <code>main.main</code>—that’s your function, complete with machine code. But it also references <code>fmt.Println</code>, and that code isn’t here. It’s just a name pointing somewhere else.</p><blockquote><p><strong>Note:</strong> In practice, <code>fmt.Println</code> gets inlined by the compiler, so there’s no actual cross-package reference in this case. But the concept holds for functions that don’t get inlined.</p></blockquote><p>Over in <code>fmt.o</code>, you’ll find the actual <code>fmt.Println</code> implementation. But that file references <code>io.Writer</code>, <code>os.Stdout</code>, and dozens more symbols from other packages.</p><p>Each package defines some symbols and references others. The linker needs to match all these references with their definitions. To do that, it first needs to build a complete picture of what exists.</p><h3 id="the-loader-building-a-global-symbol-index">The Loader: Building a Global Symbol Index</h3><p>Before the linker can do anything useful, it needs to know about every symbol in your program. That’s the job of the <strong>Loader</strong> (<a href="https://github.com/golang/go/blob/go1.25.3/src/cmd/link/internal/loader/" target="_blank" rel="noopener noreferrer"><code>src/cmd/link/internal/loader/</code></a>
).</p><p>The Loader reads object files and builds a unified index of all symbols. It starts with your main package, reads that object file, and discovers its imports. Your code uses <code>fmt</code>, so now <code>fmt</code> needs to be loaded. And <code>fmt</code> imports <code>io</code>, <code>os</code>, <code>reflect</code>, and others. The Loader keeps following imports until it has found every package your program depends on. The runtime package always gets loaded too, since every Go program needs it.</p><p>As it reads each file, the Loader records every symbol and connects references to definitions. When your code calls a function from another package, the object file just says “I need this symbol.” The Loader looks it up and records where it points. Most symbols are identified by name, but some—like string literals—are <strong>content-addressable</strong>, identified by a hash of their contents. If two packages both use <code>&#34;Hello&#34;</code>, they produce the same hash and share a single copy in the final binary.</p><p>The index itself is straightforward. Each symbol gets a unique integer ID. The Loader maintains a few key data structures: a mapping from symbol ID to its location (which object file, which local index within that file), lookup tables to go from a name like <code>fmt.Println</code> to its ID, and space for attributes like “is this symbol reachable?” that get filled in later. The actual code and data bytes stay in the object files—the Loader just records where to find them.</p><p>By the end, the Loader has a complete picture: every symbol indexed, every reference resolved. You can find the loading logic in <a href="https://github.com/golang/go/blob/go1.25.3/src/cmd/link/internal/loader/loader.go" target="_blank" rel="noopener noreferrer"><code>src/cmd/link/internal/loader/loader.go</code></a>
.</p><p>But having everything indexed doesn’t mean we need everything. Time to trim the fat.</p><h3 id="dead-code-elimination">Dead Code Elimination</h3><p>The Loader indexed every symbol from every package, but you probably don’t use all of them. If you import <code>fmt</code> just to call <code>Println</code>, you don’t need the dozens of other functions in that package.</p><p>The linker solves this with <strong>dead code elimination</strong>. Starting from <code>main.main</code>, it traces through every function call and every global variable access, setting that “is this symbol reachable?” attribute we mentioned earlier. When it’s done, anything not marked gets dropped. If you imported a package with fifty functions but only called one, the other forty-nine disappear.</p><p>This is why Go binaries stay reasonably small despite static linking. You can find this logic in <a href="https://github.com/golang/go/blob/go1.25.3/src/cmd/link/internal/ld/deadcode.go" target="_blank" rel="noopener noreferrer"><code>src/cmd/link/internal/ld/deadcode.go</code></a>
.</p><p>With symbols resolved and dead code eliminated, the linker knows exactly what needs to go into the final binary. But there’s a problem: the machine code still has placeholder addresses for symbols that live in other packages.</p><h2 id="relocation">Relocation</h2><p>When the compiler generated machine code for a package, it knew about symbols within that package but not about symbols defined elsewhere. Every call to a function in another package, every reference to a variable from an imported module—those are just placeholders saying “fill this in later.” The linker’s job now is to figure out where all these cross-package symbols actually go, and then patch those placeholders with real addresses.</p><p>This creates a chicken-and-egg situation: you can’t fill in the addresses until you know where everything is, but you need to lay out all the code and data first to know where everything is. The linker solves this in two passes: first assign addresses to everything, then go back and patch the code.</p><h3 id="address-assignment">Address Assignment</h3><p>The linker organizes memory into sections based on what each symbol contains and how it will be used:</p><p><img src="https://internals-for-interns.com/images/posts/the-go-linker-sections.webp" alt="Memory sections layout"/></p><p>The linker processes symbols one by one, placing each at the next available address in its section. Functions get aligned to appropriate boundaries (typically 16 or 32 bytes depending on the architecture) for cache efficiency. Read-only data gets grouped together so it can be protected from modification. The <code>.bss</code> section is special—it takes no space in the file since everything there is just zeros, but the OS allocates the memory when the program loads. By the end of this pass, every symbol has a concrete address.</p><p>Now that everything has an address, it’s time to fix up all those placeholders.</p><h3 id="patching-relocations">Patching Relocations</h3><p>Each placeholder has an associated <strong>relocation</strong> record saying what symbol’s address belongs there. The linker goes through every relocation, looks up the target’s address, and patches it in. For function calls, the CPU expects a relative offset (“jump forward 500 bytes”), so the linker computes the distance between the call site and the target. For global variable references, it writes the absolute address directly. When this pass finishes, the machine code is complete—every placeholder replaced with a real address.</p><p>The linker now has fully-linked machine code. All that’s left is packaging it into a file the operating system can actually run.</p><h2 id="generating-the-executable">Generating the Executable</h2><p>Finally, the linker organizes everything into sections, groups them into segments, and writes the executable file. Let’s look at how this organization works.</p><h3 id="sections">Sections</h3><p>The linker groups symbols into <strong>sections</strong> based on what they are and how they’ll be used:</p><ul><li><strong><code>.text</code></strong> holds executable code—your functions, marked read-execute</li><li><strong><code>.rodata</code></strong> holds read-only data—string literals, constants, type descriptors</li><li><strong><code>.data</code></strong> holds initialized global variables—read-write</li><li><strong><code>.bss</code></strong> holds zero-initialized globals—read-write, but takes no space in the file</li><li><strong><code>.noptrdata</code></strong> and <strong><code>.noptrbss</code></strong> hold data the garbage collector can ignore (no pointers)</li></ul><p>Go also generates special sections for runtime metadata. The <strong><code>.gopclntab</code></strong> section contains the PC-line table—the mapping from program counter values to source file and line numbers that makes stack traces work and enables reflection.</p><p>But sections are the linker’s internal organization. The operating system thinks in terms of segments.</p><h3 id="segments">Segments</h3><p>Sections get grouped into <strong>segments</strong> for loading. While sections are the linker’s view of the data, segments are the OS loader’s view. The OS doesn’t care about individual sections; it maps entire segments into memory with the right permissions.</p><p>A typical Go executable has a text segment (code + read-only data, mapped read-execute) and a data segment (writable data + BSS, mapped read-write). On some platforms there’s also a separate read-only data segment between them for <code>.rodata</code>.</p><p>The segment layout matters for security. Modern systems use W^X (write xor execute)—memory can be writable or executable, but not both. By separating code and data into different segments with different permissions, the linker enables this protection.</p><p>With segments defined, the linker writes everything to disk in a format the OS understands.</p><h3 id="file-format-and-loading">File Format and Loading</h3><p>Different operating systems use different executable formats—Linux uses ELF, macOS uses Mach-O, Windows uses PE. Despite the differences, they all contain:</p><ul><li>A <strong>header</strong> identifying the file format and architecture</li><li><strong>Program headers</strong> (or equivalent) describing segments to load</li><li><strong>Section headers</strong> describing the contents for debuggers and tools</li><li>The actual <strong>code and data bytes</strong></li><li>Optionally, <strong>debug information</strong> (DWARF format)</li></ul><p>One interesting detail: the header specifies an <strong>entry point</strong>—where the OS starts executing—and it’s not your <code>main</code> function. It’s Go runtime startup code like <code>_rt0_amd64_linux</code>, which sets up the stack, initializes the memory allocator, starts the garbage collector, and launches the scheduler before finally calling your <code>main.main</code>.</p><p>You can find the output code in <a href="https://github.com/golang/go/blob/go1.25.3/src/cmd/link/internal/ld/elf.go" target="_blank" rel="noopener noreferrer"><code>src/cmd/link/internal/ld/elf.go</code></a>
and similar files for other formats. If you want to explore the final structure of a Go binary in more detail, check out my talk <a href="https://www.youtube.com/watch?v=5VkYXgUqxcE" target="_blank" rel="noopener noreferrer">Deep dive into a Go binary</a>
from GopherCon UK.</p><p>Everything we’ve discussed so far assumes the default case: a standalone executable with everything bundled in. But the linker can produce other kinds of output too.</p><h3 id="static-linking-dynamic-linking-and-build-modes">Static Linking, Dynamic Linking, and Build Modes</h3><p>Go prefers <strong>static linking</strong>—bundling everything into one self-contained binary. The Go runtime, the standard library, all your dependencies: they’re all compiled in. No external dependencies means you can copy the binary to another machine and it just works.</p><p>When you use cgo, Go has to dynamically link against system libraries like libc. The linker adds a <code>.dynamic</code> section with symbol tables, library names, and relocation entries. It also specifies an <strong>interpreter</strong>—the path to the dynamic linker (<code>/lib64/ld-linux-x86-64.so.2</code> on Linux). When you run the program, the kernel loads the dynamic linker first, which resolves external symbols and loads shared libraries before jumping to your code.</p><p>With <code>-buildmode</code> flags, the linker can produce other output types: C-compatible static libraries (<code>c-archive</code>), shared libraries (<code>c-shared</code>), or Go plugins (<code>plugin</code>). Each mode changes what gets exported, how the runtime initializes, and what file format gets written.</p><p>Now that we’ve seen all the pieces, let’s watch them work together on a concrete example.</p><h2 id="walking-through-a-complete-example">Walking Through a Complete Example</h2><p>Let’s trace a simple program with two packages through the entire linking process.</p><p><strong>main.go:</strong></p><div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span><span> </span><span>main</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>import</span><span> </span><span>&#34;example/greeter&#34;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>greeter</span><span>.</span><span>Hello</span><span>()</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p><strong>greeter/greeter.go:</strong></p><div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span><span> </span><span>greeter</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>import</span><span> </span><span>&#34;fmt&#34;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>//go:noinline</span><span>
</span></span></span><span><span><span></span><span>func</span><span> </span><span>Hello</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Hello&#34;</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><blockquote><p><strong>Note:</strong> The <code>//go:noinline</code> directive prevents the compiler from inlining <code>Hello</code> into <code>main.main</code>. Without it, the compiler would inline the function and there would be no cross-package call for the linker to resolve.</p></blockquote><p>Let’s follow this program through each phase of linking.</p><h3 id="after-compilation">After Compilation</h3><p>The compiler produces separate object files. <code>main.o</code> contains <code>main.main</code> and has a reference to <code>example/greeter.Hello</code>—it calls that function but doesn’t have the code. There’s a relocation marking where the call address needs to be filled in.</p><p><code>greeter.o</code> contains <code>example/greeter.Hello</code>, which in turn references <code>fmt.Fprintln</code> (that’s what <code>fmt.Println</code> calls internally). And <code>fmt.a</code> (the archive for the fmt package) has the actual implementation, along with references to <code>io.Writer</code>, <code>os.Stdout</code>, and more.</p><p>The linker starts by loading all these pieces and figuring out what’s what.</p><h3 id="loading-and-resolving">Loading and Resolving</h3><p>The linker loads all these files and builds a symbol table. Note that symbol names include the full module path:</p><pre tabindex="0"><code>Symbol Table:
  main.main              → defined in main.o
  example/greeter.Hello  → defined in greeter.o
  fmt.Fprintln           → defined in fmt.a
  (plus hundreds more from runtime and std library)
</code></pre><p>Every reference can be matched to a definition. If something were missing, the linker would stop here with an undefined symbol error.</p><p>Next, the linker figures out what’s actually used.</p><h3 id="dead-code-elimination-1">Dead Code Elimination</h3><p>Starting from <code>main.main</code>, the linker traces through all the calls:</p><pre tabindex="0"><code>main.main → calls example/greeter.Hello
example/greeter.Hello → calls fmt.Fprintln
fmt.Fprintln → calls io.Writer methods, uses os.Stdout
...
</code></pre><p>Everything in this chain is marked reachable. Anything not in the chain—functions from packages you imported but never actually used—gets dropped.</p><p>With the set of reachable symbols determined, the linker assigns each one an address.</p><h3 id="assigning-addresses">Assigning Addresses</h3><p>Now the linker lays out all the reachable symbols in memory. Here’s what it looks like for our example (addresses from an actual build):</p><pre tabindex="0"><code>Text section (starting at 0x401000):
  0x46f1e0: _rt0_amd64_linux (entry point)
  0x439040: runtime.main
  0x491b20: main.main
  0x491ac0: example/greeter.Hello
  0x48cac0: fmt.Fprintln
  ...

Data section (starting at 0x554000):
  0x55e148: os.Stdout
  ...
</code></pre><p>Now the linker can patch all the placeholder addresses in the machine code.</p><h3 id="patching-relocations-1">Patching Relocations</h3><p>With addresses assigned, the linker goes back and fills in all the placeholders.</p><p>In <code>main.main</code>, there’s a call to <code>example/greeter.Hello</code>. We can see it in the disassembly:</p><pre tabindex="0"><code>TEXT main.main(SB)
  0x491b20  CMPQ SP, 0x10(R14)
  0x491b24  JBE 0x491b31
  0x491b26  PUSHQ BP
  0x491b27  MOVQ SP, BP
  0x491b2a  CALL example/greeter.Hello(SB)  ← patched with offset to 0x491ac0
  0x491b2f  POPQ BP
  0x491b30  RET
</code></pre><p>The <code>CALL</code> instruction at <code>0x491b2a</code> contains a relative offset that jumps to <code>example/greeter.Hello</code> at <code>0x491ac0</code>. Same thing for the call from <code>greeter.Hello</code> to <code>fmt.Fprintln</code>—the linker computes the offset and patches it in.</p><p>Now all the jumps and calls point to the right places.</p><p>All that’s left is writing the final file.</p><h3 id="writing-the-executable">Writing the Executable</h3><p>Finally, the linker writes everything out. On Linux, we can inspect the result with <code>readelf</code> (on macOS, use <code>otool -h</code>):</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ readelf -h ./example
</span></span><span><span>ELF Header:
</span></span><span><span>  Magic:   7f <span>45</span> 4c <span>46</span> <span>02</span> <span>01</span> <span>01</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span>
</span></span><span><span>  Class:                             ELF64
</span></span><span><span>  Data:                              2<span>&#39;</span>s complement, little endian
</span></span><span><span>  Type:                              EXEC <span>(</span>Executable file<span>)</span>
</span></span><span><span>  Machine:                           Advanced Micro Devices X86-64
</span></span><span><span>  Entry point address:               0x46f1e0
</span></span><span><span>  Number of program headers:         <span>6</span>
</span></span><span><span>  Number of section headers:         <span>25</span>
</span></span><span><span>  ...
</span></span></code></pre></div><p>There it is—a complete, standalone executable. The entry point <code>0x46f1e0</code> is <code>_rt0_amd64_linux</code>, the runtime startup code that will eventually call our <code>main.main</code>.</p><p>If you want to see this happening on your own code, there are some useful commands to explore.</p><h2 id="try-it-yourself">Try It Yourself</h2><p>If you want to peek behind the curtain, there are a few commands that let you see what the linker is doing.</p><p>To watch the linker work, pass <code>-v</code> through ldflags:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>$ go build -ldflags<span>=</span><span>&#34;-v&#34;</span> .
</span></span><span><span><span># example</span>
</span></span><span><span>build mode: exe, symbol table: on, DWARF: on
</span></span><span><span><span>HEADER</span> <span>=</span> -H5 -T0x401000 -R0x1000
</span></span><span><span><span>107437</span> symbols, <span>20441</span> reachable
</span></span><span><span>    <span>48122</span> package symbols, <span>39987</span> hashed symbols, <span>14790</span> non-package symbols, <span>4538</span> external symbols
</span></span><span><span><span>112153</span> liveness data
</span></span></code></pre></div><p>You’ll see how many symbols were loaded, how many are reachable after dead code elimination, and other build information.</p><p>Once you have a binary, you can inspect its symbol table with <code>nm</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>go tool nm ./example <span>|</span> less
</span></span></code></pre></div><p>This dumps every symbol in the executable along with its address. It’s a lot of output—even our simple program has over 2000 symbols from the runtime.</p><p>To see how the sections are laid out in memory, use your platform’s binary inspection tool:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>readelf -S ./example    <span># Linux</span>
</span></span><span><span>otool -l ./example      <span># macOS</span>
</span></span></code></pre></div><p>And if you want to see the entire build process, including the exact link command:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>go clean <span>&amp;&amp;</span> go build -x .
</span></span></code></pre></div><p>The <code>go clean</code> ensures you get the full output—without it, cached builds might skip steps.</p><p>This prints every command the go tool runs. You’ll see the compiler invocations, then the linker invocation with all its flags. It’s a good way to understand what’s happening under <code>go build</code>.</p><p>Let’s wrap up what we’ve learned.</p><h2 id="summary">Summary</h2><p>The linker is the final step in the compilation process. It takes separate object files and combines them into a single executable:</p><ul><li><p><strong>Symbol Resolution</strong>: The Loader builds a global index of every symbol in your program, following imports recursively and connecting references to definitions. Content-addressable symbols let identical data (like string literals) be shared across packages.</p></li><li><p><strong>Dead Code Elimination</strong>: Starting from <code>main.main</code>, the linker traces reachability and drops everything that isn’t used. This is why Go binaries stay reasonably small despite static linking.</p></li><li><p><strong>Relocation</strong>: The linker assigns each symbol a concrete address, organizing them into sections (<code>.text</code>, <code>.rodata</code>, <code>.data</code>, <code>.bss</code>), then patches all the placeholder addresses in the machine code.</p></li><li><p><strong>Executable Generation</strong>: Sections get grouped into segments with appropriate permissions (W^X), and the linker writes everything out in the OS-specific format (ELF, Mach-O, PE). The entry point isn’t your <code>main</code>—it’s runtime startup code that initializes the Go runtime before calling your code.</p></li></ul><p>Go’s linker also handles different build modes—from the default statically-linked executable to C archives, shared libraries, and plugins.</p><p>If you want to dive deeper into the linker, explore <a href="https://github.com/golang/go/blob/go1.25.3/src/cmd/link/internal/ld/" target="_blank" rel="noopener noreferrer"><code>src/cmd/link/internal/ld/</code></a>
. The code is well documented, and seeing how a real production linker works is fascinating.</p><p>And with that, we’ve completed our journey through the Go compiler! From source code through scanning, parsing, type checking, IR optimization, SSA transformation, code generation, and finally linking—your Go program is now a standalone executable ready to run.</p><p>But the story doesn’t end here. That executable contains the Go runtime: the scheduler that manages goroutines, the garbage collector that reclaims memory, the memory allocator, and all the machinery that makes Go’s concurrency model work. In the next series, we’ll explore how the runtime brings your program to life. Stay tuned!</p></div></div>
  </body>
</html>
