<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tratt.net/laurie/blog/2024/structured_editing_and_incremental_parsing.html">Original</a>
    <h1>Structured Editing and Incremental Parsing</h1>
    
    <div id="readability-page-1" class="page"><div id="article-body">





<p>As someone who has
<a href="https://tratt.net/laurie/blog/2023/why_split_lexing_and_parsing_into_two_separate_phases.html">from</a>
<a href="https://tratt.net/laurie/blog/2023/why_we_need_to_know_lr_and_recursive_descent_parsing_techniques.html">time</a>
<a href="https://tratt.net/laurie/blog/2020/which_parsing_approach.html">to</a>
<a href="https://tratt.net/laurie/blog/2011/parsing_the_solved_problem_that_isnt.html">time</a> written on
parsing, and even published some
<a href="https://soft-dev.org/pubs/html/diekmann_tratt__dont_panic/">parsing</a>
<a href="https://soft-dev.org/pubs/html/diekmann_tratt__default_disambiguation/">research</a>,
I get asked questions about parsing fairly regularly, some of which I’m even
capable of answering.</p>
<p>One thing that I’ve increasingly been made aware of is a widening interest in
“fancier” ways of editing text. In essence, most people who’ve been programming
for a while come to realise that having an editor that only thinks of a program
as a sequence of UTF-8 characters is rather limiting. I suspect the rapid
proliferation of the <a href="https://microsoft.github.io/language-server-protocol/">LSP (Language Server
Protocol)</a> has opened
even more people’s eyes to what the editing of programs could be.</p>
<p>One long-standing approach to better editing is <a href="https://en.wikipedia.org/wiki/Structure_editor">structured
editing</a> (sometimes called
“projectional editing”). The basic idea is to have an editor which fully
understands the syntactic structure of the language you’re editing. This has
various benefits: the editor can give instant feedback about what the next
thing the user can type is; it makes semantic-based feedback
(e.g. about the static typing of a program) much easier; it enables things
like “select this function so I can copy it” 100% accurate, instead of
using slightly dodgy heuristics; and so on.</p>
<p>To the best of my knowledge, the first structural editors were for Lisp
dialects in the late 1960s. The best modern structured editor I’ve used is
JetBrains’ <a href="https://www.jetbrains.com/mps/">MPS</a>. If you haven’t tried using a
structured editor, I’d encourage you to do so: it’s a much different experience
than using even an LSP-powered editor and can change how you view the editing
of programs.</p>
<p>However, there’s a reason why structured editors haven’t taken over the world:
most programmers find them so annoying to use in some situations that they
don’t view the pros as outweighing the cons. The basic problem is that most of us – even
though we tend not to realise we’re doing so – sometimes edit programs in
deliberate violation of their syntactic structure.</p>
<p>For example, I often use “square block” editing, where I edit characters at
(say) columns 3–5 on all of lines 7–10 in a way that can suddenly turn a
syntactically valid program into one with multiple, often bizarre, syntactic
invalidities. Many structured editors simply don’t allow this sort of editing
at all, because it doesn’t fit into the paradigm. Personally I do this sort of
thing so often that if my editor were to forbid me from doing so, I
would ditch it for a “more stupid” editor that does allow it — even if that
meant foregoing other, useful, cleverness.</p>
<p>I thus must admit to some frustration when I’m pointed at yet another attempt to make
structured editing work, that either doesn’t take this problem into account, or
does so in an hoc manner. Typically, especially as a tool matures, some
non-structural editing is allowed, but often only quite specific kinds, sometimes
requiring you telling the editor in advance that you want to temporarily do things
it rather you didn’t.</p>
<p>The reason I’m frustrated by this is that there is a published solution that
enables us, in many realistic situations, to get all the advantages of
structural editing while allowing non-structured editing: incremental parsing.
The basic idea of incremental parsing is to allow people to edit programs as if
they were sequences of UTF-8 characters but to maintain and update a parse tree
in the background. Crucially, that parse tree can be arbitrarily “broken” when
the user’s input is not syntactically correct, so users aren’t constrained by
the tree’s existence.</p>
<p>Specifically I have pointed many, many people over the years to <a href="https://web.archive.org/web/20150920220626/http://harmonia.cs.berkeley.edu/papers/twagner-thesis.pdf">Tim Wagner’s
thesis on incremental
parsing</a>.
Tim’s thesis is the culmination of many people’s efforts over many
years on this subject: it’s not quite the final word on the subject, but it’s
close enough to serve as a real basis for practical tooling. My simplified
explanation of it is that it contains three main algorithms: an incremental
lexing algorithm; an incremental LR parsing algorithm; and an incremental GLR
(i.e. all context-free grammars) parsing algorithm. Its algorithms are little
short of beautiful: it allows programs to go from syntactically valid to
invalid to valid (and so on) in a manner that is efficient, and which makes
great sense to the programmer.</p>
<p>If you think that Tim’s thesis looks too academic to be plausible, you might be
interested to know that you’re probably already using a real implementation of
it: Max Brunsfeld, the dynamo behind
<a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a>, has been clear about
<a href="https://news.ycombinator.com/item?id=24494756">the influence of Tim’s work on
Tree-sitter</a>. That’s not to say
that there is nothing more to be done in the area of incremental parsing. Lukas
Diekmann, who works in the same research group as me, <a href="https://diekmann.uk/diekmann_phd.pdf">extended and
fixed</a> Tim’s algorithms. We later pushed
that work even further, showing how it can serve as the basis for editing
“composed” (or “polyglot”) programs <a href="https://soft-dev.org/pubs/html/diekmann_tratt__default_disambiguation/">in a satisfying
manner</a>.
I’m sure much more can be done in this vein!</p>
<p>I know that some people who’ve worked on structured editing know and understand
incremental parsing, and specifically Tim’s work. They might not agree with me
on the practical utility of that work, which is totally fine – technically
informed disagreement of this kind is part of how our society makes progress.</p>
<p>However, it is now clear to me that there is ongoing work on structured editing which
either doesn’t know about incremental parsing in general, or Tim’s algorithms
specifically. I hope this post serves as a useful advert to such folk that
incremental parsing exists, and Tim’s and Lukas’s theses specifically, are
absolutely worth the investment of time in reading.</p>
<p>I would love to see more progress in this area, and the more that those working
on it know the breadth of our existing knowledge, the more likely we are to
make meaningful progress. I hope to see more such progress soon!</p>


<p>

2024-11-27 12:25

<a href="https://tratt.net/laurie/blog/2024/how_i_prepare_to_make_a_video_on_programming.html">Older</a>

</p>

<div id="article-updates"><p>
If you’d like updates on new blog posts: follow me on
<a href="https://mastodon.social/@ltratt">Mastodon</a>
or <a href="https://twitter.com/laurencetratt">Twitter</a>;
or <a href="https://tratt.net/laurie/blog/blog.rss">subscribe to the RSS feed</a>;
or <a href="https://tratt.net/laurie/newsletter/">subscribe to email updates</a>:

</p>

</div>



<h3>Comments</h3>







</div></div>
  </body>
</html>
