<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mattrighetti.com/2025/06/04/too-many-files-open">Original</a>
    <h1>Too Many Open Files</h1>
    
    <div id="readability-page-1" class="page"><div>
        <article>
  
  <p>
    Jun 4, 2025
    
  </p>
  
  <p>Recently I’ve been working on a pretty big rust project and to my surprise I
couldn’t get tests to work properly.</p>
<p>Running <code>cargo test</code> would start running all the tests in the repo and after a
couple of milliseconds every single test would start to fail because of an error
that I’m not very familiar with</p>
<div>
<div>
<pre><code data-lang="rust">Io(Os { code: 24, kind: Other, message: &#34;Too many open files&#34; })</code></pre>
</div>
</div>
<p>Fortunately, the error is pretty explicit and straightfoward so I was able to
understand what was going on in a reasonable time. I’ve started digging a bit
and learned some stuff along the way.</p>
<p>Ever wondered how your programs juggle multiple tasks - reading files, sending
data over the network, or even just displaying text on your screen - all at
once? File descriptors are what make this all possible (in Unix systems).</p>
<p>At its core, a file descriptor (often abbreviated as fd) is simply a positive
integer used by the operating system kernel to identify an open file. In Unix,
<a href="https://en.wikipedia.org/wiki/Everything_is_a_file">&#34;everything is a file.&#34;</a> Contrary to what the word says,
a file descriptor doesn’t just refer to regular files on your disk. It can
represent:</p>
<div>
<ul>
<li>
<p><strong>Regular files</strong>: The documents, images, and code files you interact with daily.</p>
</li>
<li>
<p><strong>Directories</strong>: Yes, even directories are treated like files to some extent,
allowing programs to list their contents.</p>
</li>
<li>
<p><strong>Pipes</strong>: Used for inter-process communication, allowing one program’s output to
become another’s input.</p>
</li>
<li>
<p><strong>Sockets</strong>: The endpoints for network communication, whether it’s talking to a
web server or another application on your local machine.</p>
</li>
<li>
<p><strong>Devices</strong>: Hardware devices like your keyboard, mouse, and printer are also
accessed via file descriptors.</p>
</li>
</ul>
</div>
<p>When a program wants to interact with any of these resources, it first asks the
kernel to &#34;open&#34; it. If successful, the kernel returns a file descriptor, which
the program then uses for all subsequent operations (reading, writing, closing,
etc.).</p>
<p>By convention, every Unix process starts with at least three standard file
descriptors automatically opened:</p>
<div>
<ul>
<li>
<p><code>0</code>: Standard Input (stdin) - Typically connected to your keyboard for user
input.</p>
</li>
<li>
<p><code>1</code>: Standard Output (stdout) - Usually connected to your terminal for
displaying normal program output.</p>
</li>
<li>
<p><code>2</code>: Standard Error (stderr) - Also usually connected to your terminal, but
specifically for displaying error messages.</p>
</li>
</ul>
</div>
<p>On macOS we can quickly check this, open your favorite terminal and run <code>ls
/dev/fd</code>.</p>
<div>
<div>
<pre><code data-lang="console">$ ls -lah /dev/fd
Permissions Size User         Date Modified Name
crw--w----  16,2 mattrighetti  4 Jun 00:44  0
crw--w----  16,2 mattrighetti  4 Jun 00:44  1
crw--w----  16,2 mattrighetti  4 Jun 00:44  2
dr--r--r--     - root         24 May 08:23  3</code></pre>
</div>
</div>
<p>On Linux we can do something similar but the repository is different and usually
follows the current pattern <code>/proc/&lt;pid&gt;/fd</code>. Running the same on Linux gives me this:</p>
<div>
<div>
<pre><code data-lang="console">$ echo $$ // prints the current process id
2806524

$ sudo ls -lah /proc/2806524/fd
total 0
dr-x------ 2 root root 11 Jun  4 00:40 .
dr-xr-xr-x 9 pi   pi    0 Jun  4 00:39 ..
lrwx------ 1 root root 64 Jun  4 00:40 0 -&gt; /dev/null
lrwx------ 1 root root 64 Jun  4 00:40 1 -&gt; /dev/null
lrwx------ 1 root root 64 Jun  4 00:40 10 -&gt; /dev/ptmx
lrwx------ 1 root root 64 Jun  4 00:40 11 -&gt; /dev/ptmx
lrwx------ 1 root root 64 Jun  4 00:40 2 -&gt; /dev/null
lrwx------ 1 root root 64 Jun  4 00:40 3 -&gt; &#39;socket:[14023056]&#39;
lrwx------ 1 root root 64 Jun  4 00:40 4 -&gt; &#39;socket:[14023019]&#39;
lrwx------ 1 root root 64 Jun  4 00:40 5 -&gt; &#39;socket:[14022300]&#39;
lrwx------ 1 root root 64 Jun  4 00:40 6 -&gt; &#39;socket:[14023037]&#39;
lrwx------ 1 root root 64 Jun  4 00:40 7 -&gt; /dev/ptmx
l-wx------ 1 root root 64 Jun  4 00:40 8 -&gt; /run/systemd/sessions/1501.ref</code></pre>
</div>
</div>
<p>As you can see, we have <code>0</code>, <code>1</code> and <code>2</code> as expected, but we also have a bunch of
other file descriptors.</p>
<p>Another useful command to check for open file descriptors is <code>lsof</code>, which
stands for &#34;list open files&#34;.</p>
<div>
<div>
<pre><code data-lang="console">$ lsof -p $(echo $$)
COMMAND   PID         USER   FD   TYPE DEVICE SIZE/OFF                NODE NAME
zsh     39367 mattrighetti  cwd    DIR   1,17     2496              250127 /Users/mattrighetti
zsh     39367 mattrighetti  txt    REG   1,17  1361200 1152921500312522433 /bin/zsh
zsh     39367 mattrighetti  txt    REG   1,17    81288 1152921500312535786 /usr/share/locale/en_US.UTF-8/LC_COLLATE
zsh     39367 mattrighetti  txt    REG   1,17   170960 1152921500312525313 /usr/lib/zsh/5.9/zsh/zutil.so
zsh     39367 mattrighetti  txt    REG   1,17   118896 1152921500312525297 /usr/lib/zsh/5.9/zsh/terminfo.so
zsh     39367 mattrighetti  txt    REG   1,17   171344 1152921500312525281 /usr/lib/zsh/5.9/zsh/parameter.so
zsh     39367 mattrighetti  txt    REG   1,17   135696 1152921500312525255 /usr/lib/zsh/5.9/zsh/datetime.so
zsh     39367 mattrighetti  txt    REG   1,17   135568 1152921500312525291 /usr/lib/zsh/5.9/zsh/stat.so
zsh     39367 mattrighetti  txt    REG   1,17   338592 1152921500312525247 /usr/lib/zsh/5.9/zsh/complete.so
zsh     39367 mattrighetti  txt    REG   1,17   136880 1152921500312525293 /usr/lib/zsh/5.9/zsh/system.so
zsh     39367 mattrighetti  txt    REG   1,17   593088 1152921500312525303 /usr/lib/zsh/5.9/zsh/zle.so
zsh     39367 mattrighetti  txt    REG   1,17   134928 1152921500312525287 /usr/lib/zsh/5.9/zsh/rlimits.so
zsh     39367 mattrighetti  txt    REG   1,17   117920 1152921500312525263 /usr/lib/zsh/5.9/zsh/langinfo.so
zsh     39367 mattrighetti  txt    REG   1,17  2289328 1152921500312524246 /usr/lib/dyld
zsh     39367 mattrighetti  txt    REG   1,17   208128 1152921500312525249 /usr/lib/zsh/5.9/zsh/complist.so
zsh     39367 mattrighetti  txt    REG   1,17   118688 1152921500312525285 /usr/lib/zsh/5.9/zsh/regex.so
zsh     39367 mattrighetti  txt    REG   1,17   118288 1152921500312525305 /usr/lib/zsh/5.9/zsh/zleparameter.so
zsh     39367 mattrighetti    0u   CHR   16,1  0t17672                1643 /dev/ttys001
zsh     39367 mattrighetti    1u   CHR   16,1  0t17672                1643 /dev/ttys001
zsh     39367 mattrighetti    2u   CHR   16,1  0t17672                1643 /dev/ttys001
zsh     39367 mattrighetti   10u   CHR   16,1   0t5549                1643 /dev/ttys001</code></pre>
</div>
</div>
<p>According to the lsof documentation:</p>
<div>
<ul>
<li>
<p><code>cwd</code>: The current working directory of the process.</p>
</li>
<li>
<p><code>txt</code>: Executable files or shared libraries loaded into memory (e.g.,
/bin/zsh, modules like zutil.so, or system libraries like /usr/lib/dyld).</p>
</li>
<li>
<p><code>0u</code>, <code>1u</code>, <code>2u</code>: Standard input (0), output (1), and error (2) streams,
respectively. The <code>u</code> means the descriptor is open for both reading and writing.
These are tied to <code>/dev/ttys001</code> (my current terminal device).</p>
</li>
<li>
<p><code>10u</code>: Another file descriptor (also tied to <code>/dev/ttys001`</code>), likely used for
additional terminal interactions.</p>
</li>
</ul>
</div>
        <div title="Matt">
          
          <p>We now know that file descriptors are a way for the operating system to keep track of open files and other resources, nice!</p>
        </div>
<p>Have you ever wondered how many file descriptors can be open at the same time?
The most common answer in software engineering applies here too: It depends.</p>
<p>Each operating system has its own limits on the number of file descriptors a
process can open simultaneously. These limits are in place to prevent a single
misbehaving program from hogging all available resources and crashing the
system.</p>
<p>On macOS, we can easily inspect these limits using the <code>sysctl</code> and
<a href="https://linuxcommand.org/lc3_man_pages/ulimith.html"><code>ulimit</code></a> commands in your terminal.</p>
<div>
<div>
<pre><code data-lang="console">$ sysctl kern.maxfiles
kern.maxfiles: 245760

$ sysctl kern.maxfilesperproc
kern.maxfilesperproc: 122880

$ ulimit -n
256</code></pre>
</div>
</div>
<div>
<ul>
<li>
<p><code>kern.maxfiles</code> represents the absolute maximum number of file descriptors that
can be open across the entire macOS system at any given moment. It’s a global
governor, preventing the system from running out of file descriptor resources,
even if many different applications are running.</p>
</li>
<li>
<p><code>kern.maxfilesperproc</code> is the hard limit on the number of file descriptors
that a single process can have open. Think of it as the ultimate ceiling for an
individual application. No matter what, a process cannot open more files than
this hard limit set by the kernel.</p>
</li>
<li>
<p><code>ulimit -n</code> is your shell’s &#34;soft&#34; limit for the number of open file
descriptors. If a process tries to open more files than its soft limit, the
operating system will typically return an error (e.g., &#34;Too many open files&#34;).
The good news is that a process can raise its own soft limit, but only up to its
hard limit.</p>
</li>
</ul>
</div>
<p>Enough with the theory, let’s get back to the problem I was having with my rust
tests.  My assumption was that since <code>cargo test</code> gets executed in my terminal,
it inevitably reaches a point where it tries to open more files than the soft
limit set by my shell, which is 256 in this case. When that happens, the
operating system screams at <code>cargo</code> and tells it that it can’t open any more
files, <code>cargo</code> then propagates that error to the tests and they all fail.</p>
<p>I wanted to confirm this hypothesis, so I created this monitoring script that
watches for <code>cargo test</code> PID and prints the number of open file descriptors at
different intervals.</p>
<div>
<div>
<pre><code data-lang="bash">#!/bin/bash

# This function exits the script gracefully
function cleanup() {
    echo -e &#34;\nstopping.&#34;
    exit 0
}

# This function encapsulates the logic for formatting and printing the monitoring output.
# Arguments:
#   $1: Initial PID
#   $2: Total number of open files
print_status() {
    local initial_pid=&#34;$1&#34;
    local total_open_files=&#34;$2&#34;
    echo &#34;$(date &#39;+%H:%M:%S&#39;) - Main PID ($initial_pid) - open: ${total_open_files}&#34;
}

PROCESS_NAME=&#34;cargo&#34;
COMMAND_ARGS=&#34;test&#34;

echo &#34;press ctrl+c to stop.&#34;

# Find the Process ID (PID) of the initial command.
INITIAL_PID=$(pgrep -f &#34;$PROCESS_NAME.*$COMMAND_ARGS&#34; | head -n 1)

if [ -z &#34;$INITIAL_PID&#34; ]; then
    echo &#34;waiting for &#39;$PROCESS_NAME $COMMAND_ARGS&#39; to start...&#34;
    # If the process isn&#39;t found immediately, loop and wait for it.
    sleep 0.01
    while [ -z &#34;$INITIAL_PID&#34; ]; do
        INITIAL_PID=$(pgrep -f &#34;$PROCESS_NAME.*$COMMAND_ARGS&#34; | head -n 1)
    done
fi

echo &#34;Found &#39;$PROCESS_NAME $COMMAND_ARGS&#39; with PID: $INITIAL_PID&#34;

# trap command catches the INT signal (triggered by Ctrl+C)
# and calls the cleanup function to exit gracefully.
trap cleanup INT

while true; do
    # check if the main process (INITIAL_PID) is still running.
    if ! ps -p &#34;$INITIAL_PID&#34; &gt; /dev/null; then
        echo &#34;PID $INITIAL_PID no longer running. bye!&#34;
        break
    fi

    # `sudo lsof -p &#34;$INITIAL_PID&#34;` lists all open files for this specific PID.
    # `2&gt;/dev/null` redirects stderr (errors like &#34;process not found&#34;) to null.
    # `grep -v &#34; txt &#34;` filters out loaded executable code and libraries for a more relevant count.
    # `wc -l` counts the lines, effectively the number of open files.
    # `tr -d &#39; &#39;` removes any leading/trailing spaces for clean arithmetic.
    OPEN_FILES_COUNT=$(sudo lsof -p &#34;$INITIAL_PID&#34; 2&gt;/dev/null | grep -v &#34; txt &#34; | wc -l | tr -d &#39; &#39;)

    # Ensure COUNT is not empty (it might be if lsof returns nothing)
    if [ -z &#34;$OPEN_FILES_COUNT&#34; ]; then
        OPEN_FILES_COUNT=0
    fi

    print_status &#34;$INITIAL_PID&#34; &#34;$TOTAL_OPEN_FILES&#34;
done</code></pre>
</div>
</div>
        <div title="Matt">
          
          <p>Note that usually to get an accurate count of open file descriptors you would also need to consider the entire process tree, not just the main process. This is because child processes can also open files, and their file descriptors contribute to the total count.  In my case, there was only one process (`cargo test`) running, so I didn&#39;t.</p>
        </div>
<p>I can now run this script in one terminal and run <code>cargo test</code> in another
terminal. I actually had to do this a couple of times to get a good sample of
data, rust runs pretty fast once the code is compiled and this monitor script
does not run fast enough to catch all the open file descriptors changes.</p>
<div>
<div>
<pre><code data-lang="console">$ sudo ./monitor.sh
press ctrl+c to stop.
waiting for &#39;cargo test&#39; to start...
Found &#39;cargo test&#39; with PID: 44152
01:46:21 - Main PID (44152) - open: 14
01:46:21 - Main PID (44152) - open: 32
01:46:21 - Main PID (44152) - open: 78
01:46:21 - Main PID (44152) - open: 155
01:46:21 - Main PID (44152) - open: 201
01:46:21 - Main PID (44152) - open: 228
01:46:21 - Main PID (44152) - open: 231
01:46:21 - Main PID (44152) - open: 237 # errors started happening here
01:46:21 - Main PID (44152) - open: 219
01:46:21 - Main PID (44152) - open: 205
01:46:21 - Main PID (44152) - open: 180
01:46:21 - Main PID (44152) - open: 110
01:46:21 - Main PID (44152) - open: 55
01:46:21 - Main PID (44152) - open: 28
01:46:21 - Main PID (44152) - open: 15
01:46:21 - Main PID (44152) - open: 0
PID 44152 no longer running. bye!</code></pre>
</div>
</div>
<p>I couldn’t get the script to catch the exact moment the process reached the soft
limits, but I can clearly see that the tests starts failing when the number of
open file descriptors reaches 237, which is pretty close to the soft limit of
256.</p>
<p>Time to fix this! This is a bit underwhelming, but the solution is to just bump
the soft limit of open file descriptors in my shell. I can do this by using the
<code>ulimit</code> command again.</p>
<div>
<div>
<pre><code data-lang="console">$ ulimit -n 8192
$ ulimit -n
8192</code></pre>
</div>
</div>
<p>Running <code>cargo test</code> now works as expected and no &#34;Too many open files&#34; error is thrown.</p>
<div id="chart">
    <h4>Open File Descriptors Over Time</h4>
    
</div>

<p>The above chart shows the number of open file descriptors with the new soft
limit. As you can see the max value reached is around 1600, which is way above
the previous limit of 256.</p>
<p>All in all, this was a fun exercise that taught me a lot about file descriptors
and how they work in Unix-like systems. Now you know how to troubleshoot this
error that might pop up in your own projects!</p>
</article>






    </div></div>
  </body>
</html>
