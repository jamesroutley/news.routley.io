<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nullprogram.com/blog/2025/12/23/">Original</a>
    <h1>Unix &#34;find&#34; expressions compiled to bytecode</h1>
    
    <div id="readability-page-1" class="page"><div lang="en">
<article>
  
  <time datetime="2025-12-23">
    December 23, 2025
  </time>
  <p>
    nullprogram.com/blog/2025/12/23/
  </p>

  <p>In preparation for a future project, I was thinking about at the <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/find.html">unix
<code>find</code> utility</a>. It operates a file system hierarchies, with basic
operations selected and filtered using a specialized expression language.
Users compose operations using unary and binary operators, grouping with
parentheses for precedence. <code>find</code> may apply the expression to a great
many files, so compiling it into a bytecode, resolving as much as possible
ahead of time, and minimizing the per-element work, seems like a prudent
implementation strategy. With some thought, I worked out a technique to do
so, which was simpler than I expected, and I’m pleased with the results. I
was later surprised all the real world <code>find</code> implementations I examined
use <a href="https://craftinginterpreters.com/a-tree-walk-interpreter.html">tree-walk interpreters</a> instead. This article describes how my
compiler works, with a runnable example, and lists ideas for improvements.</p>

<p>For a quick overview, the syntax looks like this:</p>

<div><div><pre><code>$ find [-H|-L] path... [expression...]
</code></pre></div></div>

<p>Technically at least one path is required, but most implementations imply
<code>.</code> when none are provided. If no expression is supplied, the default is
<code>-print</code>, e.g. print everything under each listed path. This prints the
whole tree, including directories, under the current directory:</p>



<p>To only print files, we could use <code>-type f</code>:</p>

<div><div><pre><code>$ find . -type f -a -print
</code></pre></div></div>

<p>Where <code>-a</code> is the logical AND binary operator. <code>-print</code> always evaluates
to true. It’s never necessary to write <code>-a</code>, and adjacent operations are
implicitly joined with <code>-a</code>. We can keep chaining them, such as finding
all executable files:</p>

<div><div><pre><code>$ find . -type f -executable -print
</code></pre></div></div>

<p>If no <code>-exec</code>, <code>-ok</code>, or <code>-print</code> (or similar side-effect extensions like
<code>-print0</code> or <code>-delete</code>) are present, the whole expression is wrapped in an
implicit <code>( expr ) -print</code>. So we could also write this:</p>

<div><div><pre><code>$ find . -type f -executable
</code></pre></div></div>

<p>Use <code>-o</code> for logical OR. To print all files with the executable bit <em>or</em>
with a <code>.exe</code> extension:</p>

<div><div><pre><code>$ find . -type f \( -executable -o -name &#39;*.exe&#39; \)
</code></pre></div></div>

<p>I needed parentheses because <code>-o</code> has lower precedence than <code>-a</code>, and
because parentheses are shell metacharacters I also needed to escape them
for the shell. It’s a shame <code>find</code> didn’t use <code>[</code> and <code>]</code> instead! There’s
also a unary logical NOT operator, <code>!</code>. To print all non-executable files:</p>

<div><div><pre><code>$ find . -type f ! -executable
</code></pre></div></div>

<p>Binary operators are short-circuiting, so this:</p>

<div><div><pre><code>$ find -type d -a -exec du -sh {} +
</code></pre></div></div>

<p>Only lists the sizes of directories, as the <code>-type d</code> fails causing the
whole expression to evaluate to false without evaluating <code>-exec</code>. Or
equivalently with <code>-o</code>:</p>

<div><div><pre><code>$ find ! -type d -o -exec du -sh {} +
</code></pre></div></div>

<p>If it’s not a directory then the left-hand side evaluates to true, and the
right-hand side is not evaluated. All three implementations I examined
(GNU, BSD, BusyBox) have a <code>-regex</code> extension, and eagerly compile the
regular expression even if the operation is never evaluated:</p>

<div><div><pre><code>$ find . -print -o -regex [
find: bad regex &#39;[&#39;: Invalid regular expression
</code></pre></div></div>

<p>I was surprised by this because it doesn’t seem to be in the spirit of the
original utility (“The second expression shall not be evaluated if the
first expression is true.”), and I’m used to the idea of short-circuit
validation for the right-hand side of a logical expression. Recompiling
for each evaluation would be unwise, but it could happen lazily such that
an invalid regular expression only causes an error if it’s actually used.
No big deal, just a curiosity.</p>

<h3 id="bytecode-design">Bytecode design</h3>

<p>A bytecode interpreter needs to track just one result at a time, making it
a single register machine, with a 1-bit register at that. I came up with
these five opcodes:</p>

<div><div><pre><code>halt
not
braf   LABEL
brat   LABEL
action NAME [ARGS...]
</code></pre></div></div>

<p>Obviously <code>halt</code> stops the program. While I could just let it “run off the
end” it’s useful to have an actual instruction so that I can attach a
label and jump to it. The <code>not</code> opcode negates the register. <code>braf</code> is
“branch if false”, jumping (via relative immediate) to the labeled (in
printed form) instruction if the register is false. <code>brat</code> is “branch if
true”. Together they implement the <code>-a</code> and <code>-o</code> operators. In practice
there are no loops and jumps are always forward: <code>find</code> is <a href="https://nullprogram.com/blog/2016/04/30/">not Turing
complete</a>.</p>

<p>In a real implementation each possible action (<code>-name</code>, <code>-ok</code>, <code>-print</code>,
<code>-type</code>, etc.) would get a dedicated opcode. This requires implementing
each operator, at least in part, in order to correctly parse the whole
<code>find</code> expression. For now I’m just focused on the bytecode compiler, so
this opcode is a stand-in, and it kind of pretends based on looks. Each
action sets the register, and actions like <code>-print</code> always set it to true.
My compiler is <a href="https://github.com/skeeto/scratch/blob/c142e729/parsers/findc.c">called <strong><code>findc</code> (“find compiler”)</strong></a>.</p>

<p><strong>Update</strong>: Or try <a href="https://nullprogram.com/scratch/findc/">the <strong>online demo</strong></a> via Wasm! This version
includes a peephole optimizer I wrote after publishing this article.</p>

<p>I assume readers of this program are familiar with <a href="https://nullprogram.com/blog/2025/01/19/"><code>push</code> macro</a>
and <a href="https://nullprogram.com/blog/2025/06/26/"><code>Slice</code> macro</a>. Because of the latter it requires a very
recent C compiler, like GCC 15 (e.g. via <a href="https://github.com/skeeto/w64devkit">w64devkit</a>) or Clang 22. Try
out some <code>find</code> commands and see how they appear as bytecode. The simplest
case is also optimal:</p>

<div><div><pre><code>$ findc
// path: .
        action  -print
        halt
</code></pre></div></div>

<p>Print the path then halt. Simple. Stepping it up:</p>

<div><div><pre><code>$ findc -type f -executable
// path: .
        action  -type f
        braf    L1
        action  -executable
L1:     braf    L2
        action  -print
L2:     halt
</code></pre></div></div>

<p>If the path is not a file, it skips over the rest of the program by way of
the second branch instruction. It’s correct, but already we can see room
for improvement. This would be better:</p>

<div><div><pre><code>        action  -type f
        braf    L1
        action  -executable
        braf    L1
        action  -print
L1:     halt
</code></pre></div></div>

<p>More complex still:</p>

<div><div><pre><code>$ findc -type f \( -executable -o -name &#39;*.exe&#39; \)
// path: .
        action  -type f
        braf    L1
        action  -executable
        brat    L1
        action  -name *.exe
L1:     braf    L2
        action  -print
L2:     halt
</code></pre></div></div>

<p>Inside the parentheses, if <code>-executable</code> succeeds, the right-hand side is
skipped. Though the <code>brat</code> jumps straight to a <code>braf</code>. It would be better
to jump ahead one more instruction:</p>

<div><div><pre><code>        action  -type f
        braf    L2
        action  -executable
        brat    L1
        action  -name *.exe
        braf    L2
L1      action  -print
L2:     halt
</code></pre></div></div>

<p>Silly things aren’t optimized either:</p>

<div><div><pre><code>$ findc ! ! -executable
// path: .
        action  -executable
        not
        not
        braf    L1
        action  -print
L1:     halt
</code></pre></div></div>

<p>Two <code>not</code> in a row cancel out, and so these instructions could be
eliminated. Overall this compiler could benefit from a <a href="https://en.wikipedia.org/wiki/Peephole_optimization">peephole
optimizer</a>, scanning over the program repeatedly, making small
improvements until no more can be made:</p>

<ul>
  <li>Delete <code>not</code>-<code>not</code>.</li>
  <li>A <code>brat</code> to a <code>braf</code> re-targets ahead one instruction, and vice versa.</li>
  <li>Jumping onto an identical jump adopts its target for itself.</li>
  <li>A <code>not</code>-<code>braf</code> might convert to a <code>brat</code>, and vice versa.</li>
  <li>Delete side-effect-free instructions before <code>halt</code> (e.g. <code>not</code>-<code>halt</code>).</li>
  <li>Exploit always-true actions, e.g. <code>-print</code>-<code>braf</code> can drop the branch.</li>
</ul>

<p>Writing a bunch of peephole pattern matchers sounds kind of fun. Though my
compiler would first need a slightly richer representation in order to
detect and fix up changes to branches. One more for the road:</p>

<div><div><pre><code>$ findc -type f ! \( -executable -o -name &#39;*.exe&#39; \)
// path: .
        action  -type f
        braf    L1
        action  -executable
        brat    L2
        action  -name *.exe
L2:     not
L1:     braf    L3
        action  -print
L3:     halt
</code></pre></div></div>

<p>The unoptimal jumps hint at my compiler’s structure. If you’re feeling up
for a challenge, pause here to consider how you’d build this compiler, and
how it might produce these particular artifacts.</p>

<h3 id="parsing-and-compiling">Parsing and compiling</h3>

<p>Before I even considered the shape of the bytecode I knew I needed to
convert <code>find</code> infix into a compiler-friendly postfix. That is, this:</p>

<div><div><pre><code>-type f -a ! ( -executable -o -name *.exe )
</code></pre></div></div>

<p>Becomes:</p>

<div><div><pre><code>-type f -executable -name *.exe -o ! -a
</code></pre></div></div>

<p>Which, importantly, erases the parentheses. This comes in as an <code>argv</code>
array, so it’s already tokenized for us by the shell <a href="https://nullprogram.com/blog/2022/02/18/">or runtime</a>. The
classic <a href="https://en.wikipedia.org/wiki/Shunting_yard_algorithm">shunting-yard algorithm</a> solves this problem easily enough.
We have an output queue that goes into the compiler, and a token stack for
tracking <code>-a</code>, <code>-o</code>, <code>!</code>, and <code>(</code>. Then we walk <code>argv</code> in order:</p>

<ul>
  <li>
    <p>Actions go straight into the output queue.</p>
  </li>
  <li>
    <p>If we see one of the special stack tokens we push it onto the stack,
first popping operators with greater precedence into the queue, stopping
at <code>(</code>.</p>
  </li>
  <li>
    <p>If we see <code>)</code> we pop the stack into the output queue until we see <code>(</code>.</p>
  </li>
</ul>

<p>When we’re out of tokens, pop the remaining stack into the queue. My
parser synthesizes <code>-a</code> where it’s implied, so the compiler always sees
logical AND. If the expression contains no <code>-exec</code>, <code>-ok</code>, or <code>-print</code>,
after processing is complete the parser puts <code>-print</code> then <code>-a</code> into the
queue, which effectively wraps the whole expression in <code>( expr ) -print</code>.
By clearing the stack first, the real expression is effectively wrapped in
parentheses, so no parenthesis tokens need to be synthesized.</p>

<p>I’ve used the shunting-yard algorithm many times before, so this part was
easy. The new part was coming up with an algorithm to convert a series of
postfix tokens into bytecode. My solution is the compiler <strong>maintains a
stack of bytecode fragments</strong>. That is, each stack element is a sequence
of one or more bytecode instructions. Branches use relative addresses, so
they’re position-independent, and I can concatenate code fragments without
any branch fix-ups. It takes the following actions from queue tokens:</p>

<ul>
  <li>
    <p>For an action token, create an <code>action</code> instruction, and push it onto
the fragment stack as a new fragment.</p>
  </li>
  <li>
    <p>For a <code>!</code> token, pop the top fragment, append a <code>not</code> instruction, and
push it back onto the stack.</p>
  </li>
  <li>
    <p>For a <code>-a</code> token, pop the top two fragments, join then with a <code>braf</code> in
the middle which jumps just beyond the second fragment. That is, if the
first fragment evaluates to false, skip over the second fragment into
whatever follows.</p>
  </li>
  <li>
    <p>For a <code>-o</code> token, just like <code>-a</code> but use <code>brat</code>. If the first fragment
is true, we skip over the second fragment.</p>
  </li>
</ul>

<p>If the expression is valid, at the end of this process the stack contains
exactly one fragment. Append a <code>halt</code> instruction to this fragment, and
that’s our program! If the final fragment contained a branch just beyond
its end, this <code>halt</code> is that branch target. A few peephole optimizations
and could probably be an optimal program for this instruction set.</p>



  
  <ol></ol>

  

  <nav>
  
    
  
  
  </nav>
</article>

</div></div>
  </body>
</html>
