<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://liquidbrain.net/blog/the-making-of-webinfokeeper/">Original</a>
    <h1>The making of WebInfoKeeper</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
            
<p>There are several pieces of information that I consistently want access to when browsing.</p>
<p>For instance, most job applications ask for my linkedin URL. My current workflow for getting that URL is to a) open linkedin.com, b) go to my profile, c) press <code>ctrl+l</code> to access the search bar, and d) press <code>ctrl+c</code> to copy the address. It&#39;s a bit unwieldy, and I&#39;d prefer a way to be able to easy access that information.</p>
<p>Another example is remembering good prompts for LLMs. With certain types of coding questions, I find it is helpful to ask Claude to not provide a working solution until I tell it to. There are a couple of phrases I like to use, but why should I have to type them out each time?<sup id="fnref:1"><a href="#fn:1">1</a></sup> It would be nicer if I had a quick way of storing and then accessing that information.</p>
<p>One solution would be to use a document of helpful information. If I had a functioning note-taking system, I could even use that! This could work, but still poses a good deal of friction. Every time I have piece of information I&#39;d like to store, I would have to remember about my paste sheet, open the document, and then paste the result. I&#39;d probably also need to add some context so that I could remember what this information is for.</p>
<p>Given that I primarily use my computer through the Internet, I figured that I could make a good browser extension for this.<sup id="fnref:2"><a href="#fn:2">2</a></sup> And so came <a href="https://addons.mozilla.org/en-US/firefox/addon/webinfokeeper/">WebInfoKeeper</a>! [I will eventually link to a less detailed project description].</p>
<p>In this post, I will break down my design and implementation process for the extension, as well what I learned.</p>

<p>I came to this idea right before my bedtime, so I furiously scrawled some notes for the basic design. The basic idea is to make a wrapper for the browser&#39;s <code>localStorage API</code>. The user can associate a value with a key, and later access the value through the key. (To complete the CRUD design, there is also a way to update and store values).</p>
<p>Throughout this, I set a guiding principle:</p>
<blockquote>
<p>&#34;Access should be easy and creation even easier.&#34;</p>
</blockquote>
<p>The rationale: the purpose of the extension is to reduce the friction of accessing stored information, but storing information has more default friction. When I am trying to accessing a piece of information, I have a strong motivation to find it. However, in order to efficiently store information, I need to remember that storage is a possibility. In the middle of a task, that should be as minimal a disruption as possible.</p>
<p>To make my access easier, my first priority was to include keyboard shortcuts (which are already part of my default workflow). I&#39;d add other modalities later, but the ultimate goal is to minimize friction.</p>

<p>Given the simplicity of the design, and a desire to build, my first goal was to get a working version in a day.</p>
<p>Overall, the process went quite smoothly. The primary decision I had to make was how I was going to create the input form. Without too much thought, I decided to go with a modal dialog box. I wanted to duplicate some of the design decision of Apple&#39;s <a href="https://en.wikipedia.org/wiki/Spotlight_(Apple)">Spotlight</a> system for switching between tabs. I also thought it would give me maximal flexibility to style the system.</p>
<p>Writing the wrapper proved quite simple; most of the storage is abtracted away using the Browser APIs.</p>
<p>This is what the popup initially looked like:</p>
<p><img alt="Version1.0_Screenshot.png" src="https://liquidbrain.mataroa.blog/images/d0a4852a.png"/></p>
<p>After pressing <code>alt+c</code>, any selected text was included as the &#34;copied value,&#34; and you were prompted to include a key.</p>
<p>Getting a value was similarly simple. One pressed <code>alt+c</code> (as <code>alt+v</code> is taken), and got a dialog. Unfortunately, you initially had to remember the exact key, but if you did, the eventual value was added to your clipboard.<sup id="fnref:3"><a href="#fn:3">3</a></sup></p>
<p><img alt="Version1.0_Screenshot_get.png" src="https://liquidbrain.mataroa.blog/images/54f0a6aa.png"/></p>

<p>While I was proud that the extension was now in working order, it wasn&#39;t particularly usable yet. There were two big issues:</p>
<ol>
<li>
<p>You had to remember your key exactly and type it in without any help</p>
</li>
<li>
<p>On pages where keyboard inputs affect the page (like any form), adding text into the popup still affected the underlying page.</p>
</li>
</ol>
<h2 id="remembering-your-key-exactly">Remembering your key exactly:</h2>
<p>I needed some way to get, sort, and display the keys. Luckily, this was quite straightfoward to do. To get the key value, I had been using an <code>&lt;input&gt;</code> html element; all I needed to do was include a <code>list=keystrs</code> keyword, and create a <code>datalist</code> element <code>keystrs</code>.</p>
<p>I ended up modifying my background script to include a method which passed all of the keys to the content script as an array. I then iterated through that array, and added datalist items:</p>
<div><pre><span></span><span>keys.forEach(</span><span>function</span><span>(key) {</span>
<span>    </span><span>const</span><span> option </span><span>=</span><span> </span><span>document</span><span>.createElement(</span><span>&#39;option&#39;</span><span>);</span>
<span>    </span><span>//confirm(`option is ${option}`)</span>
<span>    option.value </span><span>=</span><span> key;</span>
<span>    keyStrs.appendChild(option);</span>
<span>  });</span>
</pre></div>

<p>The end result was that a list of possible keys floated under your input!</p>
<p><img alt="Version1.1_Screenshot.png" src="https://liquidbrain.mataroa.blog/images/4b37348b.png"/></p>
<h2 id="preventing-keyboard-inputs-from-affecting-the-rest-of-the-webpage">Preventing keyboard inputs from affecting the rest of the webpage</h2>
<p>I was initially concerned that this was going to be quite difficult. It turned out to be an easy switch. I included a <code>eventListener</code> on my dialog element for keystrokes; all I needed to do was prevent keyboard events from propagating up the document tree!</p>
<h2 id="other-changes">Other changes</h2>
<p>I added the ability to access these function using the context window:</p>
<p><img alt="Version1.1_Screenshot_context.png" src="https://liquidbrain.mataroa.blog/images/9d776f47.png"/></p>
<p>I tried for a while to get my two commands to show up on the parent menu, but I don&#39;t think it&#39;s possible. That works against my goal of reducing the friction as much as possible, but given that the keyboard shortcut is the main show, I didn&#39;t worry about it too much.</p>
<p>I also switched from Manifest V2 to Manifest V3, in preparation for eventually adding Chrome support.</p>

<p>Version 1.1 was definitely in a much better state than Version 1.0. There were a couple of things that still bothered me though, which ended up prompting a major refactor of my code.</p>
<p>While injecting custom html into webpages gave me a lot of flexibility, it had a couple of downsides. First, there are some pages where it is impossible to inject html. The most important is the <code>about:new</code> page. That meant that my script just didn&#39;t work when I was in a new tab. Second, after I had completed getting a value, my cursor was not selected anywhere. This added a little bit of friction when trying to paste a value. Third, when I was on the navigation bar and triggered the shortcut, my cursor did not move to the dialog box (because it was already outside of the web page).</p>
<p>All three of these downsides are rather minor, but all three add friction to the storing and accessing information, especially for keyboard users. I needed a different way to query information.</p>
<h2 id="deciding-where-to-refactor">Deciding where to refactor</h2>
<p>As attached as I was to the modal dialog box, it wasn&#39;t a tractable option. Initially, I was split between using <code>query</code>, a browser method which displays a little popup to get information from a user, and creating a new window to overlay over the current webpage. Ultimately, however, <code>query</code> didn&#39;t have enough customization and creating a new window felt like overkill. After discussing the issue with Claude Sonnet, I ended up settling on a third solution: using the built-in browser popup.</p>
<h2 id="the-built-in-browser-popup">The built-in browser popup:</h2>
<p>I rewrote the extension so that when I pressed <code>alt+c</code> or <code>alt+g</code>, it opened the browser popup and then queried me for the requisite information. This required learning quite a bit more about html and CSS.</p>
<p>The first goal was to try to replicate the popup look. I looked through documentation, but there does not appear to be a way to make an extension popup act as a modal dialog. (In fact, there was a <a href="https://github.com/w3c/webextensions/issues/307">proposal</a> to add this capability to chrome, but it was rejected). My second attempt was to make the background of the extension transparent, and then place the text box at the center of the screen, simulating a modal dialog. While this is possible in chrome, it is not in Firefox, so I eventually gave up trying to simulate the popup experience.</p>
<p>Once I accepted that the popup would look different, I needed to set up the html. This required some refactoring: because I was not injecting html into an existing page, I had to set up the entire layout. The browser popup API gives a single html document, but I needed to represent at least three distinct pages. Given the small scope of the project, I decided to use <code>&lt;div&gt;</code> elements which I would make visible and invisible at will. The resulting structure looked like:</p>
<div><pre><span></span><span>&lt;</span><span>div</span> <span>id</span><span>=</span><span>&#34;input-mode&#34;</span> <span>style</span><span>=</span><span>&#34;display:none;&#34;</span><span>&gt;</span>
    Things for setting a value
<span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;</span><span>div</span> <span>id</span><span>=</span><span>&#34;output-mode&#34;</span> <span>style</span><span>=</span><span>&#34;display:none;&#34;</span><span>&gt;</span>
    Things for getting a value
<span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;</span><span>div</span> <span>id</span><span>=</span><span>&#34;default-mode&#34;</span><span>&gt;</span>
    Home page for the extension
<span>&lt;/</span><span>div</span><span>&gt;</span>
</pre></div>

<p>Using JavaScript, I change the display condition for the results as necessary. The remainder of the display code transferred line for line from the existing modal dialog.<sup id="fnref:4"><a href="#fn:4">4</a></sup> Later in the process, I am also adding pages for updates, as well as settings. But I have not implemented those yet. This proved a helpful exercise for using html.</p>
<p>The current UI:</p>
<p><img alt="Version1.2_Screenshot.png" src="https://liquidbrain.mataroa.blog/images/479a20cc.png"/></p>
<h2 id="dealing-with-the-clipboard">Dealing with the clipboard</h2>
<p>The popup works much closer to the low-friction spec. There&#39;s only one tradeoff: if I have selected text, there is no way for me to combine copying the text and adding the key. Previously, <code>alt+c</code> copied the text and added it to the &#34;Value&#34; textbox simultaneously. However, as I no longer have access to the underlying webpage, the best I can do is to take the current item on the clipboard and display it as a suggestion for the &#34;value.&#34;<sup id="fnref:5"><a href="#fn:5">5</a></sup></p>
<p>There was one subtlety. For security reasons, an extension cannot programmatically read from the browser clipboard OR open a popup <em>except</em> as the result of direct user action. I am not quite sure exactly how this works, but I had to play around with my code structure in order to let the extension both copy from the clipboard and open the popup simultaneously.</p>
<h2 id="refactoring-communication-between-popupjs-and-backgroundjs">Refactoring communication between popup.js and background.js</h2>
<p>The earlier versions used <code>browser.tabs.sendMessage()</code> in order to instruct a content script to display a popup. The content script would then return a promise object which eventually resolved with the user information (the key and value strings, when inputed).</p>
<p>This approach worked well when the only way to trigger a query was through the background script. However, with the addition of a popup, I decided to add the ability to input new key value pairs through the popup itself:</p>
<p><img alt="Version1.2_Screenshot_Popup.png" src="https://liquidbrain.mataroa.blog/images/9dd1bb2b.png"/></p>
<p>I switched to a &#34;fire and forget&#34; model. Any time the popup completed an action, it would send a message to <code>background.js</code> with the relevant information. In return, <code>background.js</code> could send messages to <code>popup.js</code> without worrying about recieving the response in the same code block. This ended up making the code much more modular, and the code deals with the three separate modalities (keyboard shortcut, context window, and popup) more smoothly now!</p>
<h2 id="other-changes_1">Other changes:</h2>
<p>These were the main changes. I have worked a little bit on styling the popup window, but have not settled on a final design yet.</p>

<p>Version 1.2 is almost ready to be distributed to Firefox. I need to implement the List Keys feature and add a small setting page, but it is mostly in working order.</p>
<p>I have learned a lot from this project, but I mostly want a working version now, so I don&#39;t see making a large number of improvements in the future. However, there are at least three things I would like to address:</p>
<ol>
<li>
<p>I would like to confirm that I am handling user inputs safely. I am displaying user inputs (from the clipboard) which might make me vulnerable to cross scripting attacks. I am doing some sanitation, but would like to learn more about cleaning inputs.</p>
</li>
<li>
<p>The extension is already written in Manifest V3; I would like to port a version to Chrome.</p>
</li>
<li>
<p>I need to write a better description for the extension, as well as create a small demo. Multiple people have expressed interest in the extension; I want to make sure it is easy to use and download!</p>
</li>
</ol>

        </div></div>
  </body>
</html>
