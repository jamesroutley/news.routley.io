<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://the-nerve-blog.ghost.io/to-be-a-better-programmer-write-little-proofs-in-your-head/">Original</a>
    <h1>To be a better programmer, write little proofs in your head</h1>
    
    <div id="readability-page-1" class="page"><div>

    <article>

        <header>

            <div>
                <div>
                    <p><time datetime="2025-07-14">14 Jul 2025</time>
                            <span><span>—</span> 14 min read</span>
                    </p>
                </div>
            </div>

            <!--  -->
            <!--     <a class="gh-article-tag" href="https://the-nerve-blog.ghost.io/tag/ideas/">ideas</a> -->
            <!--  -->
            

        </header>

        <section>
           
            <p>This is a brief write-up of a trick I learned that helps me write code faster and more accurately. I say &#34;trick&#34;, but it&#39;s really something I started to do without noticing  as I moved further into my career. </p><p>When you&#39;re working on something difficult, sketch a proof in your head as you go that your code will actually do what you want it to do. A simple idea, but easier said than done: doing this &#34;online&#34; without interrupting your flow takes a lot of practice. But once you get really good at it, you&#39;ll find that a surprising amount of the time your code will work on the first or  second try. It feels a little magical.</p><p>There are lots of ways to pull this off, and I don&#39;t want to be too prescriptive. I&#39;ll just list a few examples of the kinds of things I find myself reasoning about on the fly, so you get the general idea.</p><h2 id="monotonicity">Monotonicity</h2><p>Something to keep an eye out for when proving things to yourself about your code is which parts are <em>monotonic</em>. </p><p>You&#39;re probably familiar with monotonic functions from mathematics. Informally, they&#39;re functions that don&#39;t &#34;go backwards&#34; - i.e. an increasing monotonic function can only increase or stay the same, while a decreasing monotonic function can only decrease or stay the same (these are also known as <em>nondecreasing</em> and <em>nonincreasing</em> functions, respectively.)</p><p>The concept of monotonic <em>code</em> is a little more nebulous than the concept of a monotonic function, but it captures the same idea of a process that can only proceed in one direction. Check-pointing, for example, is a great example of monotonicity. If you have (say) a script that needs to perform multiple tasks in sequence, you can keep a bit of state around on disk that details how many tasks you have completed so far. If something goes wrong and your script crashes, it can check the on-disk state to figure out how far it got, then start again from the earliest state that hasn&#39;t been run yet.</p><p>Checkpointing means that the &#34;current step&#34; pointer in your script can only go forwards, since the script can&#39;t regress and re-run a step it&#39;s already done. In this sense the script progresses <em>monotonically</em>, and it&#39;s apparent that if the script ever completes successfully, it will have run every step exactly once.</p><blockquote>
<p>Keeping this kind of activity log is a simple idea that often pops up in surprising places, such as journaling file systems and database write-ahead logs. Another, more involved database example is an LSM tree. LSM trees are used in some databases to store rows in-memory and on-disk, and most of the time they are purely additive. Put loosely - an LSM tree keeps a log of all inserts, deletes, and updates, and scans the log to reconstruct the appropriate value of the row when the row is read. Stale operations are periodically discarded to save space in a process called compaction. The space taken by an LSM tree <em>only</em> grows (except during compaction, when it <em>only</em> shrinks.)</p>
</blockquote>
<p>It&#39;s worth keeping an eye out for monotonicity, because you can usually use it to rule out wide swaths of possible outcomes. Another variation on this theme is immutability (which in a lot of ways is monotonicity&#39;s cousin) - when you create an immutable object, that object cannot be modified. Values can be assigned to an immutable object exactly once, at the time of the object&#39;s construction; you can&#39;t &#34;back out&#34; or &#34;undo&#34; the assignments. This allows you to ignore, out of hand, all scenarios in which an object might change out from under your feet.</p><h2 id="preand-post-conditions">Pre- and post-conditions</h2><p>Pre-conditions and post-conditions are ways to specify constraints on the behavior of a function. A function&#39;s <em>pre-conditions </em>are the things that are assumed to be true just before the function runs. These can be conditions on the function&#39;s input, or more general claims about the program&#39;s state or environment. A function&#39;s <em>post-conditions</em> are things that are assumed to be true just after the function returns. As with pre-conditions, these claims can involve just about anything. If the pre-conditions of a function are true before the function runs, and the post-conditions are <em>not</em> true after the function finishes, then the function is not implemented correctly, at least according to the specified constraints.</p><p>These are simple (even obvious) concepts and not really proof techniques in and of themselves, but simply keeping track of what they are in formal terms can aid your reasoning. </p><p>(Sometimes you may come to find that your function does not have well-defined pre- and post-conditions, which is also good to know!)</p><p>Pinning down your post-conditions, in particular, is a good way to generate ideas for unit tests. It can also help to defensively add assertions that your preconditions and postconditions are true, and crash otherwise. This can make it easier to reason about what your code will do in the event it <em>doesn&#39;t </em>crash - this may sound like, at best, a neutral trade-off, but it&#39;s usually safer for code to crash early than to behave in unpredictable ways.</p><h2 id="invariants">Invariants</h2><p>The <em>invariants</em> of a piece of code are things that should always be true before, during, and after that code runs, no matter what. As with pre- and post-conditions,  an invariant can involve pretty much anything.</p><p> It can be handy to think about consistency in terms of an invariant - in these situations the invariant is &#34;this data structure is consistent/valid&#34;, and you need to prove to yourself that the code preserves that invariant at every point, no matter what happens. An easy way to do this to divide up your code into atomic &#34;steps&#34;, and to prove that each step preserves the invariant on its own. Then you can conclude that the invariant will hold no matter which steps run or the order that they run in. </p><p>One of the oldest and most famous examples of an invariant is the <a href="https://en.m.wikipedia.org/wiki/Accounting_equation?ref=the-nerve-blog.ghost.io" rel="noreferrer">accounting equation</a>, which is the foundation of double-entry accounting. The accounting equation says, loosely, that the total amount of debits on a company&#39;s ledger must equal the total amount of credits. It&#39;s easy to prove that double-entry accounting, when done correctly, preserves this invariant: for every transaction, all increases (or decreases) to credit accounts must be equal to all increases (or decreases) to debit accounts. It&#39;s easy to see that if debits and credits balance before a transaction, they balance after the transaction. Thus, the invariant is always preserved.</p><p>Another way to maintain certain kinds of invariants is to use a listener or lifecycle method to make sure that the invariant stays true at certain critical points. This technique is often used when multiple pieces of state need to be kept in sync - for example,   C++ uses <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization?ref=the-nerve-blog.ghost.io" rel="noreferrer">constructors and destructors</a> to ensure that any memory an object needs only remains allocated while the object actually exists. <a href="https://react.dev/learn/synchronizing-with-effects?ref=the-nerve-blog.ghost.io" rel="noreferrer">useEffect</a> does something similar for React components.</p><p>(Since invariants have to hold for every possible scenario, they&#39;re usually easier to reason about when making changes that introduce relatively few new execution paths.)</p><h2 id="isolation">Isolation</h2><p>I have a long-held conviction that a <em>lot</em> of the &#34;craft&#34; of software is (or ought to be) centered around modifying or augmenting an existing system without destabilizing anything. When making modifications to a codebase, it can be exceptionally useful to know how to prove that behaviors you <em>didn&#39;t</em> intend to change were, in fact, left unchanged.</p><p>There&#39;s a technique I rely on a lot to prove this to myself; I&#39;m not sure if there&#39;s a name for this, and I perhaps wouldn&#39;t even call it a technique as much as a pattern of thought. The best way I can describe it is this: every change has a &#34;blast radius&#34; - a change to one part of the code may necessitate a change to another part to ensure the consistency/correctness of the whole system. This second change might require a change to a third part, and so on. Nailing down what behaviors a change does/doesn&#39;t affect involves identifying structural &#34;firewalls&#34; that can prevent a change from propagating past a certain point. It&#39;s kind of like the conceptual cousin of encapsulation.</p><p>This idea is pretty abstract, so here&#39;s an example from Nerve:</p><hr/><p>Nerve is a query engine that lets users query many data sources as if they were a single huge API. The Nerve query pipeline consists of a <em>query planner</em>, which computes a specific step-by-step plan for running a query, and a <em>query executor</em>, which carries the plan out. A query in Nerve can contain both <em>material</em> fields and <em>virtual</em> fields. Virtual fields are basically derived fields - in other words, a material field is pulled directly from a source API, while a virtual field is computed at runtime from other virtual or material fields. </p><p>Material fields are pretty easy to handle - you just make the appropriate requests and pull data from the responses as needed. Virtual fields are a little trickier, because sometimes virtual fields <em>depend</em> on other fields. We need to ensure that we have all of the virtual field&#39;s prerequisites before we can calculate a virtual field. It&#39;s unnecessarily onerous to require the user to add these prerequisites to the query themselves. Instead, we should have some machinery that pulls a virtual field&#39;s dependencies before calculating it. But where should this machinery go?</p><p>One straightforward option is to modify both the query planner and the query executor to give them a concept of a material field that&#39;s pulled as a dependency instead of as something specified in the query. These &#34;dependency fields&#34; should be kept around so we can use them to calculate virtual fields, but they shouldn&#39;t be included in the final query results. There are other design considerations we need to keep in mind - for example, we probably want to find ways to pull these dependency fields in the same requests that we make when pulling &#34;normal&#34; material fields, etc. etc. </p><p>This is basically an expansion of the query pipeline: maybe a little involved, but certainly doable. There&#39;s a trick we can pull here though, which is to dodge the problem by <em>over</em>-<em>pulling</em> and cleaning up after the fact.</p><p>In this second approach we don&#39;t introduce any new concepts at all. Instead, during query planning, we calculate the dependencies of each virtual field and simply add them to the query, then hand them off the query executor. The query executor has no idea that the query it&#39;s getting is not the query the user wrote; it just runs the query as usual, first pulling all material fields, and then calculating any relevant virtual fields (and it never has to pull a virtual field&#39;s dependencies because somehow they&#39;re always magically there!)</p><p>After query execution is complete, we&#39;ll end up with query results that contain strictly more fields than the user asked for. So at the end, we add a <em>pruning </em>step that removes any fields that weren&#39;t in the user&#39;s query.</p><p>The main advantage of this solution is that the change is <em>completely</em> confined to two small layers and the beginning and end of the query pipeline - the stuff in the middle (the &#34;meat&#34; of the query engine) doesn&#39;t need to change at all. In particular, the boundary between the query planner and the query executor acts as a &#34;firewall&#34; that stops the change from propagating. This makes it trivially easy to prove that our changes won&#39;t cause regressions when we execute queries that don&#39;t need to pull any dependencies (since in that case we only run code that hasn&#39;t been touched!)</p><p>Sometimes this kind of approach is appropriate, and sometimes it isn&#39;t, but all else being equal it simply produces less cognitive load when you leave as much code untouched as you can. </p><p>(You may have heard this idea talked about in the context of the <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle?ref=the-nerve-blog.ghost.io" rel="noreferrer">Open-Closed Principle</a>. This principle encompasses a bunch of OOP particulars that aren&#39;t relevant here; what is relevant is the <a href="https://drive.google.com/file/d/0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1/view?resourcekey=0-FsS837CGML599A_o5D-nAw&amp;ref=the-nerve-blog.ghost.io" rel="noreferrer">philosophy</a> behind it, namely: &#34;When requirements change, you extend the behavior of [your program] by adding new code, not by changing old code that already works.&#34;)</p><h2 id="induction">Induction</h2><p>Lots of interesting programs involve recursive functions or recursive data structures (and in a certain theoretical sense recursion is central to the act of computation itself.) Depending on the area you&#39;re working in, you may come across recursion constantly or only occasionally, but in either case knowing how to reason about it can make your life a lot easier.</p><p>A recursive data structure is a structure that contains a copy of itself (not necessarily an exact copy, but an instance of the same &#34;type&#34; of structure.) This copy can contain a copy, and so on; the process either goes on forever or terminates at a &#34;base case.&#34; A fractal, for instance, is recursive.</p><p>In computer science, the classic example of a recursive data structures is a tree. A tree is a node with a certain number of children; each child is itself a tree. A tree with <em>no</em> children is called a leaf, which is the base case.</p><p>Lists can also be formulated recursively, although you may not usually think of them that way. Every recursive list consists of a <em>head</em>, which is the &#34;first&#34; or leftmost element of the list, along with a <em>tail</em>, which contains the remaining elements of the list. The tail is itself a  list, and the base case list is the empty list. (In a similar vein, you can think of the natural numbers as recursive - every natural number is 1 plus another, smaller, natural number, except for 0, which is the base case.)</p><p>A recursive <em>function</em> is a function that calls itself. Recursive functions are usually used to process recursive data structures, since they can call themselves on the recursive copies (for example, a function to process a tree can call itself on all of the child trees.)</p><p>There&#39;s also a proof technique that&#39;s tailor-made for handling recursive structures, which is called <em>induction</em>. The &#34;classical&#34; version of induction is used to prove that some proposition \(P(n)\) holds true for any natural number \(n\). There are two steps to proving this:</p><ul><li>Prove \(P(0)\) is true.</li><li>Prove that \(P(n)\) implies \(P(n+1)\).</li></ul><p>This second step is called the <em>inductive step</em>, and the assumption that \(P(n)\) holds is called the <em>inductive hypothesis</em>. The inductive step is where the real power of induction lies - \(P\) is often much easier to prove once you have the inductive hypothesis at your disposal. The point of induction is to write a &#34;incremental&#34; version of the proof instead of trying to simultaneously prove it for every number at once.</p><p>When you&#39;re writing a recursive function, try to prove its correctness to yourself using induction. Here&#39;s a simple example, loosely adapted from the Nerve codebase:</p><hr/><p>Without getting too deep in the weeds - there&#39;s a particular case in Nerve where we need to visualize an AST for the user. The full AST is pretty complex, so before displaying it we need to remove nodes that the user probably doesn&#39;t care about. When we remove a node, that node&#39;s parent should &#34;inherit all of its children&#34; (in technical terms, we need to <a href="https://en.wikipedia.org/wiki/Edge_contraction?ref=the-nerve-blog.ghost.io" rel="noreferrer">contract the edge</a> between the removed node and its parent.) </p><blockquote>A quick note on terminology: technically, contraction is a term that only applies to edges, but I&#39;m going to fudge things a little and talk about contracting nodes and trees as well. When I say &#34;contract a node&#34;, I mean &#34;contract the edge between the node and its parent&#34;. When I say &#34;contract a tree&#34;, I mean &#34;contract some edge in the tree.&#34;</blockquote><p>Here&#39;s the function we use in Nerve (not the exact function, but this gives you the idea):</p><pre><code>function simplifyTree(root: Node): Node {
  let newChildren = [] as Array&lt;Node&gt;;
  
  for (const child of root.children) {
    const simplifiedChild = simplifyGraph(child);
  
    if (shouldContract(simplifiedChild)) {
      for (const grandChild of simplifiedChild.children) {
        newChildren.push(grandChild);    
      }
    } else {
      newChildren.push(simplifiedChild);
    }
  }

  root.children = newChildren;

  return root;
}</code></pre><p>We want our function to simplify the provided AST as much as possible. In other words, the post-condition is this: the graph returned by <code>simplifyGraph</code> should be &#34;fully contracted&#34; - i.e. it should not be possible to contract any more edges. </p><p>Here&#39;s an inductive proof that this condition does, in fact hold:</p><ul>
<li>
<p>Let&#39;s start with the base case. By definition, a root node can&#39;t be contracted, because there&#39;s no parent to roll it up into. So the base case - a single leaf node - already satisfies the post-condition. If we pass <code>simplifyGraph</code> a leaf node, it just returns it as-is, so we can conclude it works correctly on the base case.</p>
</li>
<li>
<p>It&#39;s time for the magic: the inductive step. We need to prove that if <code>simplifyGraph</code> is correct for every subtree of a tree \(T\), it&#39;s correct for \(T\) as well. Crucially, we now have access to the inductive hypothesis, which means that we can assume each subtree (i.e. each tree rooted at a <code>simplifiedChild</code>) can&#39;t be contracted any further. </p>
</li>
</ul>
<hr/><p>If you can start to do this kind of inductive reasoning on instinct, you may find it easier to deal with recursive functions. </p><p>(If you want, try to convince yourself that <code>simplifyGraph</code> works correctly on every possible input by reasoning holistically, without using induction. Which approach feels more natural to you?)</p><h2 id="proof-affinity-as-a-quality-metric">Proof-affinity as a quality metric</h2><p>My thesis so far is something like &#34;you should try to write little proofs in your head about your code.&#34; But there&#39;s actually a secret dual version of this post, which says &#34;you should try to write your code in a form that&#39;s easy to write little proofs about.&#34; </p><p>Similarly, each section of this post has its own dual form:</p><ul>
<li>Look for monotonicity and immutability. → Write code that is monotonic and uses immutable data structures.</li>
<li>Keep track of your pre- and post-conditions. → <em>Start</em> with pre- and post-conditions and write your code around those. Structure your code so that the pre- and post-conditions are easy to conceptualize and verify.</li>
<li>You can prove a function maintains an invariant by proving each unit of work does. → You should subdivide your code into the smallest possible units that can maintain the invariant.</li>
<li>Pay attention to where component boundaries act as &#34;firewalls&#34; that prevent change propagation. → Do your best to build as many of these &#34;firewalls&#34; as possible, and take advantage of them when writing new features.</li>
<li>Use induction to prove things about recursive functions incrementally instead of all at once. Assume the inductive hypothesis is already proved, and use that to your advantage. → Write your recursive functions incrementally. Assume the recursive call is already implemented and write the part of the function that builds the \(n+1\) case from the \(n\) case. Then, separately, implement the base case.</li>
</ul>
<p>The idea is that you can judge the quality of your code by the ease with which you can reason about it. If it&#39;s easy for you to prove to yourself that your code is correct, it&#39;s probably pretty well-designed. On the other hand, if it&#39;s consistently frustrating or difficult, you should consider cleaning up or restructuring your code to make it more straightforward. </p><blockquote>I was tempted to call this quality &#34;provability&#34;, but that term exists and has a different meaning, so instead I&#39;ll call it &#34;proof-affinity.&#34;</blockquote><p>As the suggestions above show, it&#39;s possible to (at least subjectively) design  for maximum proof-affinity.</p><p>Proof-affinity is, of course, not the only dimension of software quality that matters (you also want your code to be correct, and fast, and as easy as possible to use), but I think it&#39;s a very important one; after all, in order to build, augment, improve, or test your code, you have to understand what it does, what it doesn&#39;t do, and what it <em>could</em> do. This may sound grandiose, but I think that in an important sense, proof-affinity is a catalyst for good programming!</p><h2 id="how-to-get-better-at-this">How to get better at this</h2><p>As I mentioned at the start, the type of micro-reasoning I&#39;ve talked out here only starts to pay off once you can do it without really thinking. It&#39;s a little like typing that way; knowing how to touch-type only saves you time over hunting and pecking when it&#39;s basically instinctual. In both cases, developing your intuition requires...practice! I don&#39;t think there are any shortcuts; you&#39;ve just gotta put in the hours. </p><p>I think the best way to do this is to write more (mathematical) proofs. Writing proofs about programs will definitely help, but I think the simple act of constructing proofs - on any topic - is a great way to hone the kind of logical thinking that will serve you well when working with complex systems (but you have to <em>write</em> them, and not just read them. Do the exercises!) For my own part, I started doing mathematics for fun a while ago, and I&#39;ve noticed that writing proofs has helped improve my clarity of thought in a broad array of settings.</p><p>If you don&#39;t know where to start, I&#39;ve been going through Stanford&#39;s <a href="https://www.edx.org/learn/algorithms/stanford-university-algorithms-design-and-analysis-part-1?ref=the-nerve-blog.ghost.io" rel="noreferrer">undergrad algorithms class</a> on EdX, which is a fun, proof-focused treatment with (imo) a great professor!</p><p>Another good place to train is - though it pains me to say it - Leetcode. Like many others, I think there are serious drawbacks to Leetcode <em>interviews</em>, but it can be useful for practicing on your own, since a lot of the problems are just difficult enough to exercise your proof-writing muscles. You don&#39;t have to time yourself (I usually don&#39;t.) Also, try to avoid <a href="https://leetcode.com/problems/single-number/description/?ref=the-nerve-blog.ghost.io" rel="noreferrer">problems</a> that have a &#34;trick&#34; to solving them;  instead, find <a href="https://leetcode.com/problems/lexicographical-numbers/description/?ref=the-nerve-blog.ghost.io" rel="noreferrer">problems</a> where at least some of the challenge is in formulating and implementing everything correctly. Focus on getting to a successful submission in as few tries as possible (if you run into little things like syntax errors that&#39;s ok.)</p><p>Happy coding/proving!</p>
        </section>

    </article>


</div></div>
  </body>
</html>
