<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.kyledunbar.dev/2026/02/05/Implementing-auto-tiling-with-just-5-tiles.html">Original</a>
    <h1>Implementing Auto Tiling with Just 5 Tiles</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2026-02-05T02:50:50+00:00">February 5, 2026</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          6 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        
        <figure><a href="https://www.kyledunbar.dev/assets/images/auto-tiling.gif"><img src="https://www.kyledunbar.dev/assets/images/auto-tiling.gif" alt="gif of auto-tiling"/></a></figure>

<p>Auto tiling is a powerful technique in 2D gamedev that allows you to build levels much easier by setting a tile as populated or not, and having the editor programmatically place the corresponding tile.</p>

<p>Typically this involves checking the 8 neighbours and choosing from <a href="https://manual.gamemaker.io/lts/en/The_Asset_Editors/Tile_Set_Editors/Auto_Tiles.htm">16 to ~47-56 Tiles</a>. In theory there are 256 permutations, but you can get away with creating much less. Of course you could create a world with just 1 tile, but we are after painted edges.</p>

<p>This post shows an implementation of a system I discovered from <a href="https://www.youtube.com/watch?v=aWcCNGen0cM">Nonsensical 2D</a>’s video that uses just 5 tiles. The concept is engine-agnostic but part 2 will be turning it into Godot specific tooling.</p>


<p>The core concept is to separate the tilemap into 2 tilemaps: one for physical tiles with colliders, and one for visuals. By separating the visuals from the physical, we can offset the visuals by -0.5 tiles and paint a tile by it’s corners, as shown below:</p>

<!-- Courtesy of embedresponsively.com -->

<p>
    <iframe src="https://www.youtube-nocookie.com/embed/pYXBdLZoRCU" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
  </p>

<p>This gives each tile 4 neighbouring tiles between the other tilemap or just 16 permutations. We can represent this as a 4-bit mask and map each permutation to a visual placement.</p>

<figure><a href="https://www.kyledunbar.dev/assets/images/bitmask_representation.webp" title="Bitmask representation of 4 neighbours
"><img src="https://www.kyledunbar.dev/assets/images/bitmask_representation.webp" alt="4 bit encoding of neighbour occupation states"/></a><figcaption>
      Bitmask representation of 4 neighbours

    </figcaption></figure>

<p>Then for each 4 visual neighbours of a physical tile, we check their physical neighbours to know which permutation to place.</p>

<!-- Courtesy of embedresponsively.com -->

<p>
    <iframe src="https://www.youtube-nocookie.com/embed/lRuu18n8Vm0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
  </p>

<p>Note: For corners you need to place the visual tile that opposes the occupation representation i.e. if there is a neighbour in the bottom-left, you will need to place the visual tile that occupies the top-right quadrant of the visual tile; for the physical tile it is the bottom-left,  but for the  visual tile it is the top-right*</p>

<p>Since we are painting visuals by their corners, we can reuse textures to compose other variants by rotating them in editor or in the placement script. This means we only need: a corner, a side, opposing corners, inwards corner, and a full / middle piece - 5 tiles.</p>

<figure><a href="https://www.kyledunbar.dev/assets/images/5_tiles_annotated.png" title="The 5 tiles needed
"><img src="https://www.kyledunbar.dev/assets/images/5_tiles_annotated.png" alt="5 necessary tile pieces"/></a><figcaption>
      The 5 tiles needed

    </figcaption></figure>

<p>From these 5 tiles, we can rotate or flip the tile programmatically, as needed, to create the 16 different tile pieces. I store the 16 pieces in an array which is accessed by index corresponding to the binary value of the bitmask - it is important to setup your array in this order. In Godot, we can create alternative tiles directly in the editor and they are given coordinates in the texture atlas so we can simply store the coordinates. For other implementations, you may want to store the tile atlas coordinate + rotation instructions.</p>

<div><div><pre><code><span>@</span><span>onready</span> <span>var</span> <span>tileArray</span><span>:</span> <span>Array</span><span>[</span><span>Vector2i</span><span>]</span> <span>=</span> <span>[</span> <span># Encodes 16 tile permutations as a u4 bitmask / index</span>
	<span>Vector2i</span><span>(</span><span>4</span><span>,</span><span>0</span><span>),</span> <span># 0000</span>
	<span>Vector2i</span><span>(</span><span>0</span><span>,</span><span>3</span><span>),</span> <span># 0001 TL</span>
	<span>Vector2i</span><span>(</span><span>0</span><span>,</span><span>1</span><span>),</span> <span># 0010 BL</span>
	<span>Vector2i</span><span>(</span><span>2</span><span>,</span><span>0</span><span>),</span> <span># 0011 BL TL</span>
	<span>Vector2i</span><span>(</span><span>0</span><span>,</span><span>2</span><span>),</span> <span># 0100 TR</span>
	<span>Vector2i</span><span>(</span><span>2</span><span>,</span><span>3</span><span>),</span> <span># 0101 TR TL</span>
	<span>Vector2i</span><span>(</span><span>1</span><span>,</span><span>0</span><span>),</span> <span># 0110 TR BL</span>
	<span>Vector2i</span><span>(</span><span>3</span><span>,</span><span>2</span><span>),</span> <span># 0111 TR BL TL</span>
	<span>Vector2i</span><span>(</span><span>0</span><span>,</span><span>0</span><span>),</span> <span># 1000 BR</span>
	<span>Vector2i</span><span>(</span><span>1</span><span>,</span><span>1</span><span>),</span> <span># 1001 BR TL</span>
	<span>Vector2i</span><span>(</span><span>2</span><span>,</span><span>4</span><span>),</span> <span># 1010 BR BL</span>
	<span>Vector2i</span><span>(</span><span>3</span><span>,</span><span>0</span><span>),</span> <span># 1011 BR BL TL</span>
	<span>Vector2i</span><span>(</span><span>2</span><span>,</span><span>2</span><span>),</span> <span># 1100 BR TR</span>
	<span>Vector2i</span><span>(</span><span>3</span><span>,</span><span>3</span><span>),</span> <span># 1101 BR TR TL</span>
	<span>Vector2i</span><span>(</span><span>3</span><span>,</span><span>1</span><span>),</span> <span># 1110 BR TR BL</span>
	<span>Vector2i</span><span>(</span><span>4</span><span>,</span><span>0</span><span>),</span> <span># 1111 BR TR BL TL</span>
<span>]</span>
</code></pre></div></div>
<p>Make sure to order your tiles in the binary order corresponding with the bitmask representations of neighbour occupation.</p>

<figure><a href="https://www.kyledunbar.dev/assets/images/tile_rotations.png" title="Alternative tiles in Godot.
"><img src="https://www.kyledunbar.dev/assets/images/tile_rotations.png" alt="alternative tiles with rotations applied in editor"/></a><figcaption>
      Alternative tiles in Godot.

    </figcaption></figure>

<p>To use the script at runtime we need a method of placing the physical tiles. Bind a mouse input event to get the global mouse position and map it to the tilemap coordinates. We can then set that cell as populated in the physical tilemap layer and call the function to place visual tiles as described above. To erase a tile, bind an opposing mouse event similarly but it should set the cell as unpopulated. We can then update the visual layer by removing the 4 neighbours and calling the visual placement function again.</p>

<p>I recommend to include another function to update all tiles’ visuals. This allows us to place just physical tiles outside of runtime and call the update_all function at runtime to place the visuals for all tiles; I have bound this to a UI button. It works by clearing the visual tilemap, iterating over all populated physical tiles and placing the visuals again.</p>

<p>The next step is to save the level at runtime so that it reflects back in the editor. In the next section, I will describe a Godot-specific implementation of the tooling to do so. You can access the full code for tile placement + level management tooling via my <a href="https://github.com/KyleDunbarDev/5-Tile-Auto-Tiling">GitHub</a>.</p>


<p>I have setup the dual <code>TileMapLayer</code>s as so:</p>

<figure><a href="https://www.kyledunbar.dev/assets/images/WorldMap_in_tree.png" title="Dual tilemap setup in Godot.
"><img src="https://www.kyledunbar.dev/assets/images/WorldMap_in_tree.png" alt="WorldMap is the parent of physical layer which is the parent of visual layer"/></a><figcaption>
      Dual tilemap setup in Godot.

    </figcaption></figure>

<p><code>WorldMap</code> is simply a container Node. My auto-tiling script is attached to my Physical Tiles layer. Create a separate node for level management and in a new script we can define our level saving logic.</p>

<h2 id="saving">Saving</h2>
<p>First, we need to find our <code>WorldMap</code> container Node in the tree and keep a reference to it. We can then do the same for our physical tile layer, and using the physical layer we can do the same for our visual tile layer. We now have 3 references to our container, physical tiles, and visual tiles.</p>

<p>For each of the tilemaps, we need to serialise them and we can store those results in a dict accessed via keys “Physical” or “Visual”. Serialisation works by iterating through all populated cells and appending to an array a dict containing it’s position, source_id, atlas_coords, and alternative_id. If you are adapting this to another engine, substitute alternative_id with your needs such as rotation instructions. To finish serialisation, we can return this array in a dict with a key of the path to the tileset and a value of the array of cells dicts. We model the data this way because every cell in a tilemap layer shares the same tileset, so storing it for every cell would be wasteful.</p>

<div><div><pre><code><span>var</span> <span>data</span> <span>:</span><span>=</span> <span>{</span>
		<span>&#34;physical&#34;</span><span>:</span> <span>_serialize_tilemap</span><span>(</span><span>physical</span><span>),</span>
		<span>&#34;visual&#34;</span><span>:</span> <span>_serialize_tilemap</span><span>(</span><span>visual</span><span>)</span>
	<span>}</span>
</code></pre></div></div>
<p>Generates data as such:</p>
<div><div><pre><code><span>data</span><span> </span><span>=</span><span>
</span><span>{</span><span>
  </span><span>&#34;physical&#34;</span><span>:</span><span> </span><span>{</span><span>
    </span><span>&#34;tile_set&#34;</span><span>:</span><span> </span><span>&#34;res://Tilesets/physical_tileset.tres&#34;</span><span>,</span><span>
    </span><span>&#34;cells&#34;</span><span>:</span><span> </span><span>[</span><span>
      </span><span>{</span><span> </span><span>pos</span><span>,</span><span> </span><span>source_id</span><span>,</span><span> </span><span>atlas_coords</span><span>,</span><span> </span><span>alt</span><span> </span><span>},</span><span>
      </span><span>{</span><span> </span><span>pos</span><span>,</span><span> </span><span>source_id</span><span>,</span><span> </span><span>atlas_coords</span><span>,</span><span> </span><span>alt</span><span> </span><span>},</span><span>
      </span><span>...</span><span>
  </span><span>]</span><span>
  </span><span>},</span><span>
  </span><span>&#34;visual&#34;</span><span>:</span><span> </span><span>{</span><span>
    </span><span>&#34;tile_set&#34;</span><span>:</span><span> </span><span>&#34;res://Tilesets/visual_tileset.tres&#34;</span><span>,</span><span>
    </span><span>&#34;cells&#34;</span><span>:</span><span> </span><span>[</span><span>
      </span><span>{</span><span> </span><span>pos</span><span>,</span><span> </span><span>source_id</span><span>,</span><span> </span><span>atlas_coords</span><span>,</span><span> </span><span>alt</span><span> </span><span>},</span><span>
      </span><span>{</span><span> </span><span>pos</span><span>,</span><span> </span><span>source_id</span><span>,</span><span> </span><span>atlas_coords</span><span>,</span><span> </span><span>alt</span><span> </span><span>},</span><span>
      </span><span>...</span><span>
  </span><span>]</span><span>
  </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre></div></div>

<p>Then save this data. In Godot, runtime data must be saved in <code>user://</code> rather than <code>res://</code> because res is read-only during runtime to prevent editor corruption. Attempts to save to res are blocked by Godot. Therefore, we must save the data to <code>user://</code> and later import the data as real <code>res://</code> scenes to reflect the changes into the editor.</p>

<h2 id="importing-with-editorplugin">Importing with EditorPlugin</h2>
<p>For a nice developer workflow I have created an EditorInspectorPlugin which adds an import button to the <code>WorldMap</code> inspector. When clicked, it reads the <code>WorldMap</code> data from <code>user://</code>, builds a duplicate <code>WorldMap</code> node with the data, overwrites the scene in <code>res://</code>, and refreshes the editor’s file system which updates the scene. This is a nice solution because the import button lives inside the <code>WorldMap</code> inspector for contextuality and to avoid clutter.</p>

<p>An important caveat is that we cannot load an EditorInspectorPlugin directly from plugin.cfg. Godot requires and EditorPlugin at the top level. However, we can use the EditorPlugin to create the InspectorPlugin.</p>

<div><div><pre><code><span>@</span><span>tool</span>
<span>extends</span> <span>EditorPlugin</span>

<span>func</span> <span>_enter_tree</span><span>():</span>
	<span>add_inspector_plugin</span><span>(</span>
		<span>preload</span><span>(</span><span>&#34;res://addons/```WorldMap```_importer/world_map_inspector.gd&#34;</span><span>)</span><span>.</span><span>new</span><span>()</span>
	<span>)</span>

<span>func</span> <span>_exit_tree</span><span>():</span>
	<span>remove_inspector_plugin</span><span>(</span>
		<span>preload</span><span>(</span><span>&#34;res://addons/```WorldMap```_importer/world_map_inspector.gd&#34;</span><span>)</span><span>.</span><span>new</span><span>()</span>
	<span>)</span>

</code></pre></div></div>

<p>For the InspectorPlugin, the script adds a button which connects to a function which imports the tilemap data, sets the tiles for the two tilemap layers, constructs a new <code>WorldMap</code> PackedScene using it, and saves it over the existing scene before refreshing the file system in the editor. Full code for this can be found on my <a href="https://github.com/KyleDunbarDev/5-Tile-Auto-Tiling">GitHub</a>.</p>


<ul>
  <li><a href="https://www.youtube.com/watch?v=Uxeo9c-PX-w">jess::codes</a></li>
  <li><a href="https://www.youtube.com/watch?v=aWcCNGen0cM">Nonsenical 2D</a></li>
  <li><a href="https://www.youtube.com/watch?v=Uxeo9c-PX-w">Oskar Stålberg</a></li>
</ul>

<p>That’s all! Thank you for reading my first blog post. Follow me on the platforms in the footer so I look cool online and subscribe via RSS if you want to catch the next one.</p>

        
      </section>

      

      


      

    </div></div>
  </body>
</html>
