<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://popovicu.com/posts/making-usb-devices/">Original</a>
    <h1>Making USB devices – end to end guide to your first gadget</h1>
    
    <div id="readability-page-1" class="page"><article id="article" role="article">
      <p><a href="https://twitter.com/popovicu94?ref_src=twsrc%5Etfw" data-show-count="false">Follow @popovicu94</a></p>
<p>Today we’ll build some USB devices. By this I mean devices that can be plugged into your computer and be recognized by them. The goal of this writeup is to be your first article to read when embarking on developing USB devices.</p>
<p><strong>A small disclaimer first: I do not consider myself an expert on USB. Please don’t consider this some sort of an authoritative guide, think of it more as a documentation of my little project towards building the simplest possible E2E USB device. It’s also an index to some really good material that other people have made that goes into a lot of detail.</strong></p>
<h2 id="table-of-contents">Table of contents</h2>
<details><summary>Open Table of contents</summary>
<ul>
<li>
<p><a href="#background">Background</a></p>
</li>
<li>
<p><a href="#what-is-usb">What is USB?</a></p>
</li>
<li>
<p><a href="#usb-wires">USB wires</a></p>
<ul>
<li><a href="#a-note-on-usb-c">A note on USB-C</a></li>
<li><a href="#data-over-a-differential-pair">Data over a differential pair</a></li>
</ul>
</li>
<li>
<p><a href="#usb-on-a-pcb">USB on a PCB</a></p>
</li>
<li>
<p><a href="#different-speeds-of-usb">Different speeds of USB</a></p>
<ul>
<li><a href="#a-quick-note-on-the-speeds-over-pcb">A quick note on the speeds over PCB</a></li>
</ul>
</li>
<li>
<p><a href="#protocol-and-software-layers">Protocol and software layers</a></p>
<ul>
<li><a href="#usb-device-classes-and-how-hosts-use-them">USB device classes and how hosts use them</a></li>
</ul>
</li>
<li>
<p><a href="#building-a-serial-port-device">Building a serial port device</a></p>
<ul>
<li><a href="#stm32-microcontroller-and-the-nucleo-board">STM32 microcontroller and the Nucleo board</a></li>
<li><a href="#setting-up-the-actual-usb-port">Setting up the actual USB port</a></li>
<li><a href="#writing-the-software">Writing the software</a></li>
<li><a href="#flashing-and-running">Flashing and running</a></li>
</ul>
</li>
<li>
<p><a href="#conclusion">Conclusion</a></p>
</li>
</ul>
</details>
<h2 id="background">Background</h2>
<p>I’m sure I don’t need to explain why USB devices are useful. They’re all around us and our daily computers have plenty of USB ports. Even if they don’t, USB hubs can open up the possibility of more ports. This is where we plug in various devices that <strong>extend</strong> the capabilities of our machines. I’ll refer to these USB devices simply as <em>devices</em>, while referring to the machines we’re extending as <em>hosts</em>.</p>
<p>The goal of this article is to give you the simplest end-to-end journey to a working USB device. We’ll cover everything from the physical connection between the USB device and the host, and developing a super sample application that interacts with our USB device (from the host).</p>
<h2 id="what-is-usb">What is USB?</h2>
<p>Let’s cover first what exactly is USB, and for that, I’ll quote the first paragraph from <a href="https://en.wikipedia.org/wiki/USB">Wikipedia</a>:</p>
<blockquote>
<p>Universal Serial Bus (USB) is an industry standard that allows data exchange and delivery of power between many types of electronics. It specifies its architecture, in particular its physical interface, and communication protocols for data transfer and power delivery to and from hosts, such as personal computers, to and from peripheral devices, e.g. displays, keyboards, and mass storage devices, and to and from intermediate hubs, which multiply the number of a host’s ports.</p>
</blockquote>
<p>The rest of this article will unpack this description piece by piece. To begin, though, we need to know first and foremost that USB is a <strong>serial</strong> bus. Bits go onto the bus one by one, in contrast to <strong>parallel</strong> buses. I don’t recall seeing a parallel bus for decades now. The last time I saw a parallel bus was to connect a hard disk to the motherboard with a ribbon cable. Those are outdated now, and modern buses are primarily serial. Again, this means bits go one by one, rather than in parallel. I won’t get into the details of this (mainly because I’m not an expert myself) — my understanding is that simply it’s really hard to make parallel transmission work efficiently in this context, so simple protocols end up in more elegant and faster devices. This mental model doesn’t capture nearly all the complexities, but still gives us enough to get started with USB: this is a way to exchange bits serially between the host and the device.</p>
<p>However, USB is more than just a spec on how to connect two devices and send bits back and forth. It also, per the quote above, captures some parts of the communication protocol. Let’s start unpacking, and we’ll focus on USB 2.0.</p>
<h2 id="usb-wires">USB wires</h2>
<p>You’ve likely seen different kinds of USB plugs and cables, but they all boil down to the same thing. Inside the connection are the wires to provide power from host to the device and to transfer the bits back and forth. Let’s focus on the typical USB 2.0 connection, these are the wires you’ll see inside:</p>
<ol>
<li>+5 V wire, this is where the device gets its power from, if powering from the host.</li>
<li><code>D-</code> and <code>D+</code> wires: I lump them together as one item here, since they jointly work to transfer <strong>1 bit</strong> (not 2!) as a differential pair. Much more info on that below.</li>
<li><code>GND</code> wire: unsurprisingly, this is ground.</li>
</ol>
<p>Some connections may have a few more pins, like the <code>ID</code> pin, but since this is the bare minimal writeup on USB, let’s skip that now. We’ll be working only with the 4 wires described above.</p>
<h3 id="a-note-on-usb-c">A note on USB-C</h3>
<p>USB-C is super common these days. What I wrote above for the USB wires still <em>somewhat</em> applies to USB-C, but it’s slightly different in that case. One of the main differences, obviously, is the fact that you can plug a USB-C device either way and things should work. At the core of it, there’s still a differential pair.</p>
<p>Let’s just focus on one very important thing here: if a device connects via USB-C, it still doesn’t mean anything when it comes to the speed, or even which USB version it is. It could still be a USB 2.0 device, or it could be a more modern USB 3.0 device.</p>
<p>With that out of the way, we won’t be discussing USB-C anymore here.</p>
<h3 id="data-over-a-differential-pair">Data over a differential pair</h3>
<p>If you’ve never seen differential pairs before, then having 2 wires somehow transmitting 1 bit may stump you. In the most basic computer architecture course, you learn that you only need one wire to signal a digital bit. The wire’s voltage (or should I say potential?), in relation to the ground (point of 0 volts) signals what is the value of the bit. If you’re playing with something like Raspberry Pi, you know that if you set a GPIO pin to logical 1, it gives you 3.3 V, 0 V otherwise.</p>
<p>And this is fine over something like super short distances, within a chip, or even within small traces on the PCB. However, we frequently have a need for longer distance wired connections. Your keyboard and mouse are at least a few feet away from your computer, for example.</p>
<p>This is where the differential pairs come in. Instead of having one wire at voltage <code>V</code>, in relation to <code>GND</code>, we now have <strong>two</strong> wires. One is still at voltage <code>V</code>, while the other one is the polar opposite at <code>-V</code>. When a differential pair comes out of one component into the other, what the other component considers is the voltage difference between these two wires. <code>V - (-V) = 2V</code>. There seems to be little benefit in this — we just got double the voltage we otherwise would, and that’s true in this model; however this model doesn’t paint the whole picture. We assumed our wires carry our voltage perfectly.</p>
<p>Let’s mark the voltages of these wires as <code>V+</code> and <code>V-</code>. If we use a more realistic model, <code>V+</code> isn’t simply equal to <code>V</code>, it’s equal to <code>V</code> plus some voltage noise, let’s mark it as <code>Vn</code>. Therefore <code>V+ = V + Vn</code>. Now, <code>V-</code> is similarly <code>V- = -V + Vn</code>. This time, when we calculate what the other device sees, it’s <code>V+ - V- = (V + Vn) - (-V + Vn) = 2V</code>. The voltage noise is gone! Now it’s a little clearer what the benefits of the differential pairs are.</p>
<p>Of course, this is a mega simplified view of things. For example, why do we treat the noise factor as the same for both wires here? For a more serious introduction to differential pairs, I’d recommend Zach Peterson’s videos on Altium YouTube channel, starting from this one:</p>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" loading="lazy" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/7DF25ohH8v4?si=qgSulBtaZC22ksJk" title="YouTube video player" width="560"></iframe>
<p>Now it should be clearer why I lumped <code>D+</code> and <code>D-</code> wires above as one item: these two wires carry one bit at the time. It should also be clearer why they’re identified as <code>D</code>, and what is plus and what is minus.</p>
<h2 id="usb-on-a-pcb">USB on a PCB</h2>
<p><em>If you don’t intend to make your own hardware for a USB device and instead want to use some existing development board, you can skip this altogether, but I’d still recommend quickly scanning through it.</em></p>
<p>When you add a USB connector to your PCB from some library, you should see the pins that I listed above, and you can route accordingly. Your PCB may have a microcontroller, or a more complex SoC onboard, and you’ll definitely need to run the differential pair to the relevant two neighboring pins on the chip. For routing differential pairs, there are a couple of basic things to keep in mind.</p>
<p>First, the trace from the <code>D+</code> pin on your USB connector to the plus pin for the differential pair on your chip should be of same length as the other trace for the differential pair.</p>
<p>Second, these traces should be very close to each other. For a graphical example, please check out <a href="https://resources.altium.com/p/what-are-differential-pairs-and-differential-signals">this article</a>, the graphic at the top should quickly illustrate what I’m talking about (again, great article by Zach Peterson).</p>
<p>These two principles should explain a little bit why in our (still simplistic) calculation, we assumed that the noise in our voltage is the same. The two wires are running in almost identical context and that’s how the noise ends up cancelling.</p>
<p>Third, and this is potentially very important, we should have a certain impedance for the signals. The calculations here are very complex and many factors go in. I recommend watching the following video for an introduction here:</p>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" loading="lazy" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/Itsrdc8tX7M?si=ODaZPMZtIUYz0vTq" title="YouTube video player" width="560"></iframe>
<p>tl;dr is that you’ll go to your fabricator’s website, put some parameters into the calculator, and it will calculate the missing parameters. For example, you’ll specify your target impedance for the differential pair running above a layer of ground plane, specify the distance between your differential pair lines, etc. and it will provide you with the trace width you should use in order to achieve that impedance.</p>
<p>I’ll link below to another great video by Zach Peterson about USB routing, but I think if you’re just getting started, the one above should be enough:</p>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" loading="lazy" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/4LwnEaNvG8I?si=MZNTZHSWDQgg3mGz" title="YouTube video player" width="560"></iframe>
<h2 id="different-speeds-of-usb">Different speeds of USB</h2>
<p>We said initially we’re focusing on USB 2.0, but that still doesn’t fully tell us what’s the speed we’re reaching here. Even within the same USB version, we can have different speed levels. For example, you can run USB 2.0 at <em>full speed</em>, which is 12 Mbit/s, but you could also run it at <em>high speed</em>, which is 480 Mbit/s. The device and the host need to figure out what’s the speed they’ll be utilizing when they connect.</p>
<h3 id="a-quick-note-on-the-speeds-over-pcb">A quick note on the speeds over PCB</h3>
<p>Again, you can skip this if you aren’t making your own PCB, but it still makes sense to try to parse through this, it could be useful.</p>
<p>While there seem to be many requirements for correctly routing USB over the PCB, the hardware you’re connecting on both ends, the host and the chip in your device, can be fairly forgiving, especially if you’re not going for the high speed (and at full speed, 12 Mbit/s should be more than enough for a basic prototype).</p>
<p>One of the big things about reaching high speeds is hitting the right impedance. Lots of thought needs to go into this, but from my understanding, if you’re going for full speed, you can get away with a lot (and we will in our working example below!). The trace widths don’t matter all that much, especially if your traces are short from the USB connector to your chip.</p>
<h2 id="protocol-and-software-layers">Protocol and software layers</h2>
<p>I think so far we’ve covered a decent chunk of hardware, and we should discuss what about the protocol itself and how does software (on both sides) use USB.</p>
<p>I’ll go ahead and simply recommend watching this video:</p>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" loading="lazy" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/lbmAn3b76rY?si=vZ_DfxFGssy8r5EJ" title="YouTube video player" width="560"></iframe>
<p>This video talks about USB from the Linux perspective, which is great, but we still haven’t covered Linux here. That said, the video also covers USB broadly, and is pretty well packed into ~45 minutes of content. For the purposes of this article, I’d recommend watching until the Linux example. There’s a lot of background on what the USB frames look like, how there are different endpoints involved and so on. There’s a great bit on configurations and how one device can fulfill multiple USB functionalities. I think if there is one thing to take away from that video, it’s to think about USB as a network of devices, and try to understand that. I won’t try to reproduce any of the details here, I highly recommend watching the video.</p>
<h3 id="usb-device-classes-and-how-hosts-use-them">USB device classes and how hosts use them</h3>
<p>Hosts obviously need drivers in order to abstract away the hardware and handle the interaction with their components. However, it would be unreasonable to expect that different kernels have drivers implemented for every single USB device. Instead, operating systems recognize different classes of devices.</p>
<p>Some classes are mass storage devices (probably the most common everyday use case), some are serial devices, and so on. Therefore, there is some level of uniformity across devices here. In our example below, we’ll build a sample device that’s simply a serial port from the host’s perspective.</p>
<h2 id="building-a-serial-port-device">Building a serial port device</h2>
<p>Our device will be very simple — we will have a USB-capable microcontroller that is powered by the host and serves the host by simply turning on an LED when requested. The host will see this device as a simple serial port device.</p>
<p>I see two main approaches in this kind of scenario: use a microcontroller or a Linux-ready SoC. In the latter case, the kernel itself can do a bulk of work and offer you a very clean Linux API for the functionality, but that is an overkill for this simple use case, and we’ll stick with the microcontroller. I’ll do a reflection on the state of software for this kind of a use case below.</p>
<h3 id="stm32-microcontroller-and-the-nucleo-board">STM32 microcontroller and the Nucleo board</h3>
<p>We’re opting for the first approach, which is using a USB-ready microcontroller and our development board of choice is <a href="https://www.st.com/en/evaluation-tools/nucleo-f103rb.html">NUCLEO-F103RB</a>. In the US, it can be bought on something like Digikey for a little over $10.</p>
<p><img alt="Photo of NUCLEO-F103RB" decoding="async" loading="lazy" src="https://www.st.com/bin/ecommerce/api/image.PF259875.en.feature-description-include-personalized-no-cpn-medium.jpg"/>
</p>
<p>When you look at this board, you can clearly see it consists of 2 pieces spliced together. The connection is almost like a perforation, and I’ve seen some videos on YouTube where people literally break this board in two along that connection by hand. I wouldn’t do it, though.</p>
<p>The smaller piece is the microcontroller programmer. This is where the USB connection with the computer also lies and that’s how you’ll be programming the board. Be careful though, that’s <strong>not the USB connection</strong> we’re looking for here, and this may stump you right now.</p>
<p>To be fully perfectly precise, there are 2 big chips on this Nucleo board. One lies on the programmer piece of the PCB, and the other one is the microcontroller you’re actually programming, and it lies on the bigger piece. The USB connection your computer establishes with the board is actually with the microcontroller on the programmer side. This programmer speaks the ST-LINK protocol, which to the best of my understanding, is just a protocol built on top of USB messaging. Your computer and the programmer MCU will exchange USB messages according to the ST-LINK protocol, and then that MCU will program your “main” MCU. How that happens on this board, I don’t know, nor should it matter for our experiment. It could happen over something like SPI, as far as we’re concerned, or maybe they could even have their own USB connection between themselves, who knows.</p>
<p>If you were to build your own PCB with an STM32 microcontroller, you could place one chip on the board, program it over USB and later use the same USB port for business logic between your device and the USB host. I’ll link to two videos from Phil’s Lab (fantastic materials) on building STM32-based PCBs, as well as how to do programming on these over USB. The first one is 20 minutes only, and absolutely worth your time.</p>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" loading="lazy" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/wLwKgMBWhpY?si=povLqEpKKugpvzQ9" title="YouTube video player" width="560"></iframe>
<hr/>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" loading="lazy" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/VlCYI2U-qyM?si=E7FUFkvW91nmEI67" title="YouTube video player" width="560"></iframe>
<h3 id="setting-up-the-actual-usb-port">Setting up the actual USB port</h3>
<p>Now that we’ve established that the USB connection we have on the Nucleo board indeed isn’t connected to the chip that we’re actually programming, we need to figure out a way to get that USB port from the “main” chip to work.</p>
<p>In this exercise, once we program the chip, we’ll disconnect the ST-LINK programmer piece from the computer, and power our main chip from the “real” USB port instead. Below is how we do it, step by step. We’ll be using STM32CubeIDE to write the software, and then use STM32CubeProgrammer to drop that software onto the board, in order to keep things simple.</p>
<p>The first thing we need to do is identify which pins on the MCU are able to work as the USB port. We’re making a USB 2.0 device, keeping things simple, and this is what we need:</p>
<ul>
<li>A pin to supply 5 V power from the host device.</li>
<li><code>GND</code> pin.</li>
<li><code>D+</code> and <code>D-</code> pins that can handle the USB differential pair data.</li>
</ul>
<p><code>GND</code> is trivial, and so should be the 5 V power. The only detail regarding powering this board over the “proper” USB port is that you need to change the pins on jumper <code>JP5</code> in order to configure the board to accept “external 5 V” supply. Check the board documentation for more details, but this is really all I had to do. With that, we’ve taken care of 2 pins.</p>
<p>In your STM32CubeIDE app, you should configure (through the UI) <code>PA12</code> to act as <code>USB_DP</code> and <code>PA11</code> to act as <code>USB_DM</code> (+ and -, respectively, of course). The end result should look like this:</p>
<p><img alt="Photo of the LED experiment" decoding="async" loading="lazy" src="https://popovicu.com/assets/cubeide_usb_ports.png.webp" height="319" width="781"/>
</p>
<p>Now, one important thing to note is that the chip on this board will expect an <strong>external</strong> 1.5 kΩ resistor to be present in the circuit for the USB connection to work. To make this simple, I just bought a pack of 1.5 kΩ resistors from Amazon (not the cheapest solution, though). That resistor should be pulling up the pin <code>PA12</code> to 3.3 V, which you can also find on the Nucleo board. I used a breadboard to wire this up, so nothing fancy is required.</p>
<p>Now that we have identified these 4 pins on the board (plus the 3.3 V for pull-up) and flipped the power supply jumper, we’re ready to make the physical connection to the host. In my case, this is a MacBook Pro running Mac OS. To be able to connect my MacBook to these individual pins, I used a <a href="https://www.amazon.com/dp/B07QQQZ1DV?th=1">breakout cable from Amazon</a>. For this particular cable that I linked, I popped off the terminal blocks (it’s all modular) and instead got the USB pins exposed. There were 5 pins, but you can ignore the S pin for this exercise. After that, I used regular jumper wires to connect these pins to my Nucleo board, as well as the breadboard where I handled the pull-up for the <code>PA12</code> pin.</p>
<p>I’d like to quickly point back to all the previous notes about length matching with differential pairs, impedance control and so on — as you can see, we’re super relaxed here, and we will be able to achieve the 12 Mbit/s connection regardless. This is what I meant when I said that the devices can be pretty forgiving, at least at some speed.</p>
<p>We’re now wired up and ready to go!</p>
<h3 id="writing-the-software">Writing the software</h3>
<p>Once you set up the USB pins in CubeIDE, you’ll get some notifications about the clock set up — go for the option where CubeIDE takes care of it for you, it should be able to fix things up. There are a few things to set up for the software part of the USB left.</p>
<p>In <code>Pinout &amp; Configuration</code> section, you will see a sub-menu called <code>Middleware and Software Packs</code>. In there, you should see a <code>USB_DEVICE</code> option, so let’s open that.</p>
<p><img alt="Photo of the LED experiment" decoding="async" loading="lazy" src="https://popovicu.com/assets/cubeide_usb_setup.png.webp" height="719" width="1886" sizes="100vw" srcset="/assets/cubeide_usb_setup.png.webp 1886w, /assets/cubeide_usb_setup@986w.webp 986w, /assets/cubeide_usb_setup@686w.webp 686w"/>
</p>
<p>What really matters for this exercise is to set up the mode of the device to:</p>
<pre is:raw="" tabindex="0"><code><span><span>Communication Device Class (Virtual Port Com)</span></span></code></pre>
<p>This will ensure that your Nucleo board behaves as a serial port device (CDC) from the host perspective. Thus, your host will be able to set up the correct drivers in order to work with your custom device.</p>
<p>At this point, CubeIDE will also generate some C code in your program. In my <code>main.c</code> file, I see a line that says:</p>
<pre is:raw="" tabindex="0"><code><span><span>MX_USB_DEVICE_Init</span><span>();</span></span></code></pre>
<p>For a more step-by-step guide on all this, if the above wasn’t enough, please take a look at this video:</p>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" loading="lazy" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/YZjnCOun1wU?si=i-Gr818H4iPckurV" title="YouTube video player" width="560"></iframe>
<p>We’ll do pretty much the same thing as in this video, in order to enable turning on of the LED (we’ll skip turning off in this exercise). The <code>CDC_Receive_FS</code> routine will have this snippet:</p>
<pre is:raw="" tabindex="0"><code><span><span>/* USER CODE BEGIN 6 */</span></span>
<span><span>if</span><span> (</span><span>Buf</span><span>[</span><span>0</span><span>] </span><span>==</span><span> </span><span>&#39;1&#39;</span><span>) {</span></span>
<span><span>	</span><span>HAL_GPIO_WritePin</span><span>(GPIOA, GPIO_PIN_5, </span><span>1</span><span>);</span></span>
<span><span>}</span></span></code></pre>
<p>This call to the HAL layer will switch on the onboard LED, which is connected to pin 5 of port A.</p>
<h3 id="flashing-and-running">Flashing and running</h3>
<p>You can go ahead and build the ELF file and use the CubeProgrammer to drop the code bytes onto the board. Once that is done, you can unplug the programmer and wire the board as we described above, powering it from “external 5 V” supply.</p>
<p>Once your board powers on, you should be able to see it in whatever device manager your operating system has. Unless you’re running something extremely exotic, I would expect your operating system to be able to recognize the device. In the USB section of your device manager, you should see something like a “COM port”, or a “Serial port” or something along those lines.</p>
<p>If you want to be extra cool, you can go back to CubeIDE, head over to the <code>USB_DEVICE</code> menu for the middleware where we previously set up the CDC class for our microcontroller software, and take a look at the bottom section. There, you are able to change the values in the <code>Device Descriptor</code> section, and set up a custom name for your device. That would be reflected in your operating system’s device manager.</p>
<p>And for the fun part, you need to connect to your serial port and send byte ‘1’ to make the LED flip on. On my Mac OS, I can find my new device under the <code>/dev</code> filesystem tree. It’s listed on my machine as <code>/dev/tty.usbmodem497A0F6739561</code>. If you’re on Linux, you should get something similar. You may see it listed as <code>/dev/ttyUSB0</code> or something like that. I’ll use Minicom to talk to this serial device, but you can do pretty much anything here, as long as it works with the serial ports on your device. I run something like this:</p>
<pre is:raw="" tabindex="0"><code><span><span>minicom --device /dev/tty.usbmodem497A0F6739561</span></span></code></pre>
<p>At this point, I can simply tap the number ‘1’ on my keyboard, and the green LED on the Nucleo board should go green.</p>
<p><img alt="Photo of the LED experiment" decoding="async" loading="lazy" src="https://popovicu.com/assets/usb_device.jpg" height="4080" width="3072" sizes="100vw" srcset="/assets/usb_device.jpg 3072w, /assets/usb_device@2772w.webp 2772w, /assets/usb_device@2472w.webp 2472w, /assets/usb_device@2172w.webp 2172w, /assets/usb_device@1872w.webp 1872w, /assets/usb_device@1572w.webp 1572w, /assets/usb_device@1272w.webp 1272w, /assets/usb_device@972w.webp 972w, /assets/usb_device@672w.webp 672w"/>
</p>
<h2 id="conclusion">Conclusion</h2>
<p>We’ve basically built a USB serial port device from scratch, and it’s recognized (hopefully) by any mainstream operating system. There’s a bit of theory in the beginning regarding building the PCBs that can do this, and I hope that was helpful as well.</p>
<p>I mentioned that from the software perspective, high level, there are 2 approaches: use a microcontroller or with a more complex system, let something like Linux kernel handle the software on the device side. The first approach was simpler for this exercise, but I will highlight that I’m not a huge fan of how things are with STM32 here.</p>
<p>This is mostly from a software engineering perspective, and I feel more comfortable sharing my opinions here, given that my professional background is mostly in software engineering. For a start, I don’t like how we have to generate a ton of boilerplate with the IDE after clicking through the UI menus. I wish that we had a library that was more flexible and parameterized in code, so that we can have something like <code>InitUsbDevice(UsbClass.CDC)</code>, instead of going through the UIs to generate the code. There’s also <strong>a lot</strong> of boilerplate with STM32, and it’s very tightly coupled with the user code. In my view, this makes code reviews very difficult. Additionally, how exactly do we update all this boilerplate when a new version is out? This seems a bit like an afterthought with the CubeIDE, and it’s not unheard of in the embedded world. I’ve read some research that says that an overwhelming majority of the embedded devices never see a software update (this can make a lot of software engineers recoil as they read it). There are also other things that are tricky here, for example, what if one day we wanted to change our microcontroller for something different? We’re super tied into the STM32 world with this current set up.</p>
<p>There’s a reason why I mentioned Linux being able to act as a USB device — I believe that’s a much cleaner approach. The Linux APIs are much more solid and standardized. Things with Linux would be based on interactions with the pseudo-files and some system calls. The user space is very cleanly separated from the kernel space. Additionally, I think of Linux as <em>the HAL</em> layer. If our microcontroller could run Linux, we’d see a very nice view of all these devices and there wouldn’t be a need for wonky HAL libraries and so on.</p>
<p>That said, obviously, sometimes we want lightweight and cheap USB devices that are easy to produce. Linux SoCs are more heavyweight, obviously, and may be an overkill for a lot of use cases. I guess my main point here is that I wish there were more portable and less opinionated frameworks for building bare metal USB devices than what’s available out there. There are things that drive me away from some of them that may be widely accepted: things like frameworks dictating a particular build system that should be used, etc.</p>
<p>All this may or may not be a big deal for your project, it’s ultimately for you to decide. I hope I’ll have some time in the near future to play around with this other variation, using Linux itself as the way to implement software on the USB device side, but that’s for another day. For now, let’s enjoy starting up our first custom USB devices that can cleanly integrate with our standard everyday machines like our laptops.</p>
<p>As always, I hope this was useful.</p>
<p>Please consider following on <a href="https://twitter.com/popovicu94">Twitter/X</a> and <a href="https://www.linkedin.com/in/upopovic/">LinkedIn</a> to stay updated.</p>
    </article></div>
  </body>
</html>
