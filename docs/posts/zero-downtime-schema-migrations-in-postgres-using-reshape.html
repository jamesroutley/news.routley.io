<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fabianlindfors.se/blog/schema-migrations-in-postgres-using-reshape/">Original</a>
    <h1>Zero-downtime schema migrations in Postgres using Reshape</h1>
    
    <div id="readability-page-1" class="page"><div>
          <p>About six months back, I wrote a <a href="https://fabianlindfors.se/blog/schema-migrations-in-postgres/">post</a> on how to use views in Postgres to encapsulate tables and create a versioned interface to a database. At the end of the post, I mentioned working on a tool to automate zero-downtime migrations using this technique and I’ve finally released something, albeit experimental. It’s open-source and called <a href="https://github.com/fabianlindfors/reshape">Reshape</a>.</p>

<p>Like many other migration tools, Reshape is a CLI tool which works with files that define changes to the database schema. The big difference is that Reshape makes non-destructive changes, ensuring that clients that still expect the old schema continue to work. This means that the database can be accessed in parallel using the old and the new schema, and application and database changes can be deployed gradually without any downtime.</p>

<p>That’s just about enough talk, let’s see an example!</p>

<h2 id="creating-a-table">Creating a table</h2>

<p>Say we need a table called <code>users</code> with two columns: <code>id</code> (auto-generated) and <code>name</code> which contains the full name of the user. With Reshape, we can create that table with a migration like this one:</p>

<figure><pre><code data-lang="toml"><span>[[actions]]</span>
<span>type</span> <span>=</span> <span>&#34;create_table&#34;</span>
<span>name</span> <span>=</span> <span>&#34;users&#34;</span>

	<span>[[actions.columns]]</span>
	<span>name</span> <span>=</span> <span>&#34;id&#34;</span>
	<span>type</span> <span>=</span> <span>&#34;INTEGER&#34;</span>
	<span>generated</span> <span>=</span> <span>&#34;ALWAYS AS IDENTITY&#34;</span>

	<span>[[actions.columns]]</span>
	<span>name</span> <span>=</span> <span>&#34;name&#34;</span>
	<span>type</span> <span>=</span> <span>&#34;TEXT&#34;</span></code></pre></figure>

<p>To apply it, we run <code>reshape migrate</code>. Reshape will create the table but it will also create a <a href="https://www.postgresql.org/docs/current/ddl-schemas.html">Postgres schema</a> for the migration. Inside of this schema, it will create a view which maps directly to the table. Our application will not be interacting with the actual table, instead it will perform all queries and updates against the view!</p>

<p>This also means that the application needs to tell the database which schema it wants to use, which can be done by setting the <code>search_path</code>. We only need to do this once when the application connects to the database, and Reshape can generate the query for us using <code>reshape generate-schema-query</code>. Thanks to this, our application can make queries just as if the schema didn’t exist.</p>

<h2 id="renaming-a-column">Renaming a column</h2>

<p>Our application is now running nicely, creating, reading and updating users, but then we realize something. <code>name</code> is a bad name for our column, it really should be called <code>full_name</code>. How are we supposed to change the name of the column without stopping our application and causing some downtime? That’s where Reshape helps.</p>

<p>We’ll create a new migration to change the name:</p>

<figure><pre><code data-lang="toml"><span>[[actions]]</span>
<span>type</span> <span>=</span> <span>&#34;alter_column&#34;</span>
<span>table</span> <span>=</span> <span>&#34;users&#34;</span>
<span>column</span> <span>=</span> <span>&#34;name&#34;</span>

	<span>[actions.changes]</span>
	<span>name</span> <span>=</span> <span>&#34;full_name&#34;</span></code></pre></figure>

<p>and then we run <code>reshape migrate</code> again. What happens now is that Reshape doesn’t actually change the name of the column, instead it creates a new schema and new views for the migration and changes the name inside the view. This means that the currently deployed application will continue to work and we can deploy our new application in parallel.</p>

<p>Once we are done deploying and have stopped the old application instances, we finish up the migration by running <code>reshape complete</code>. This will perform the actual rename of the column and remove any old schemas. If the deployment were to fail, we can run <code>reshape abort</code> which will non-destructively reset any changes.</p>

<h2 id="replacing-one-column-with-two">Replacing one column with two</h2>

<p>Changing the name of a column is a very basic change but what if we need to make more complex changes, like altering columms or adding new ones? Reshape automates that as well.</p>

<p>To illustrate this, let’s say we no longer want to store the full name but instead we want to store it separately as <code>first_name</code> and <code>last_name</code> (<a href="https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/">which is a bad idea</a>). Reshape makes this as simple as a single migration which creates two new columns and removes the old one. The trick is that we specify how to transform between the new and old schema using <code>up</code> and <code>down</code>.</p>

<figure><pre><code data-lang="toml"><span>[[actions]]</span>
<span>type</span> <span>=</span> <span>&#34;add_column&#34;</span>
<span>table</span> <span>=</span> <span>&#34;users&#34;</span>

<span># Extract the first name from the existing full_name column</span>
<span># This can be any valid SQL expression</span>
<span>up</span> <span>=</span> <span>&#34;(STRING_TO_ARRAY(full_name, &#39; &#39;))[1]&#34;</span>

	<span>[actions.column]</span>
	<span>name</span> <span>=</span> <span>&#34;first_name&#34;</span>
	<span>type</span> <span>=</span> <span>&#34;TEXT&#34;</span>


<span>[[actions]]</span>
<span>type</span> <span>=</span> <span>&#34;add_column&#34;</span>
<span>table</span> <span>=</span> <span>&#34;users&#34;</span>

<span># Extract the last name from the existing full_name column</span>
<span>up</span> <span>=</span> <span>&#34;(STRING_TO_ARRAY(full_name, &#39; &#39;))[2]&#34;</span>

	<span>[actions.column]</span>
	<span>name</span> <span>=</span> <span>&#34;last_name&#34;</span>
	<span>type</span> <span>=</span> <span>&#34;TEXT&#34;</span>


<span>[[actions]]</span>
<span>type</span> <span>=</span> <span>&#34;remove_column&#34;</span>
<span>table</span> <span>=</span> <span>&#34;users&#34;</span>
<span>column</span> <span>=</span> <span>&#34;full_name&#34;</span>

<span># Reconstruct column by concatenating first and last name</span>
<span>down</span> <span>=</span> <span>&#34;first_name || &#39; &#39; || last_name&#34;</span></code></pre></figure>

<p>If we run <code>reshape migrate</code> now, Reshape will once again not actually remove the <code>full_name</code> column. Instead, it will automatically set up triggers that transform between <code>first_name</code> and <code>last_name</code> columns and <code>full_name</code> depending on if the data is changed using the old or new schema. For any existing rows, the new columns will be automatically populated without locking up the database. Locking up the database for too long could also cause downtime, so Reshape makes sure that doesn’t happen.</p>

<p>Once again, we can deploy our new application which expects <code>first_name</code> and <code>last_name</code> in parallel with the old version. Once the deployment is finished, we run <code>reshape complete</code> which will delete <code>full_name</code> for real and remove the triggers.</p>

<h2 id="in-conclusion">In conclusion</h2>

<p>Reshape is still experimental and a proof-of-concept but there are some potential features I’m excited about. One is migrations involving changes to multiple tables. For example, splitting up an array column into a separate table. Thanks to the amazing support for transactions, triggers and views in Postgres, there are a lot of possibilities.</p>

<p>Check out the project on <a href="https://github.com/fabianlindfors/reshape">Github</a> and if you’d like to chat about Reshape, <a href="mailto:fabian@flapplabs.se">please reach out</a>!</p>

        </div></div>
  </body>
</html>
