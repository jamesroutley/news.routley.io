<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brandondong.github.io/blog/javascript_dates/">Original</a>
    <h1>Why are 2025/05/28 and 2025-05-28 different days in JavaScript?</h1>
    
    <div id="readability-page-1" class="page"><div> <article><header>  <time datetime="2025-05-28">2025-05-28</time> </header><p>While setting up this site itself, I ran into the following oddity:</p>
<pre><code><span>console</span>.<span>log</span>(<span>new</span> <span>Date</span>(<span>&#39;2025/05/28&#39;</span>).<span>toDateString</span>()); 
<span>console</span>.<span>log</span>(<span>new</span> <span>Date</span>(<span>&#39;2025-05-28&#39;</span>).<span>toDateString</span>()); 

<span>console</span>.<span>log</span>(<span>new</span> <span>Date</span>(<span>&#39;2025-5-28&#39;</span>).<span>toDateString</span>()); </code></pre>
<p>You may get different results on your machine!</p>
<section id="What&#39;s_going_on?"> <h2><a href="#What&#39;s_going_on?">What&#39;s going on?</a></h2> <p>A <code>Date</code> in JavaScript always represents a point in time (i.e. milliseconds since epoch). This is more apparent when printing out the full date string:</p><pre><code><span>const</span> date = <span>new</span> <span>Date</span>(<span>&#39;2025/05/28&#39;</span>);
<span>console</span>.<span>log</span>(date); 
<span>console</span>.<span>log</span>(date.<span>toDateString</span>()); </code></pre><p>In this case, the passed-in date string is being interpreted as a timestamp in my local time zone. <code>toDateString()</code> also operates relative to the local time and so we get the same day-of-the-month back out.</p><p>The difference with <code>&#39;2025-05-28&#39;</code> is in parsing behavior; the string is interpreted as UTC and so ends up at a different point in time:</p><pre><code><span>const</span> date = <span>new</span> <span>Date</span>(<span>&#39;2025-05-28&#39;</span>);
<span>console</span>.<span>log</span>(date); 
<span>console</span>.<span>log</span>(date.<span>toDateString</span>()); </code></pre><p>Why the discrepancy?</p> </section>
<section id="The_misadventures_of_browser_date-parsing"> <h2><a href="#The_misadventures_of_browser_date-parsing">The misadventures of browser date-parsing</a></h2> <p>After digging through the code and commit histories of Chrome/Firefox/Safari, I’ve reconstructed a timeline:</p><ol>
<li>In 2009, these browsers supported parsing a mishmash of date-time formats. When time zone offsets are not explicitly specified in the string, they all fall back to using local time, including for a date string like <code>&#39;2025/05/28&#39;</code>.</li>
<li><a href="https://ecma-international.org/wp-content/uploads/ECMA-262_5th_edition_december_2009.pdf" target="_blank">ES5</a>, to be released at the end of the year, includes a requirement for supporting a new standardized date-time format based heavily off of <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601</a>. This format is broken up into date-<em>only</em> forms like <code>&#39;2025-05-28&#39;</code> and date-<em>time</em> forms like <code>&#39;2025-05-27T17:00-07:00&#39;</code> where the ending UTC offset is optional.
<ul>
<li>What does the spec say about time zone interpretation for date-only forms (which never have an offset) or date-time forms missing an offset? Only that <q>The String may be interpreted as a local time, a UTC time, or a time in some other time zone, depending on the contents of the String.</q> (Gee, thanks…)</li>
</ul>
</li>
<li>Firefox is the first to <a href="https://github.com/mozilla-firefox/firefox/commit/b866df4f3680502a8e78e67bd495a96ea3d9c59e" target="_blank">implement this requirement</a>. They choose to interpret date-only forms as UTC and date-time forms missing an offset as local time. Not only is there now a discrepancy between <code>&#39;2025/05/28&#39;</code> and <code>&#39;2025-05-28&#39;</code>, but also surprising behavior like: <pre><code><span>console</span>.<span>log</span>(<span>new</span> <span>Date</span>(<span>&#39;2025-05-28&#39;</span>)); 
<span>console</span>.<span>log</span>(<span>new</span> <span>Date</span>(<span>&#39;2025-05-28T00:00&#39;</span>)); </code></pre></li>
<li>Chrome is <a href="https://chromium.googlesource.com/v8/v8.git/+/6ceb02e6eb791f837ed84b7ed41332058cd3f1dc" target="_blank">next</a>, choosing to use local time for both.</li>
<li>Safari is <a href="https://github.com/WebKit/WebKit/commit/d9bdbae4126006e130914e5ebe57a761d3ea19bb" target="_blank">next</a>, but its parsing logic incorrectly requires that all date, time, and offset fields be present.</li>
<li><a href="https://262.ecma-international.org/5.1/index.html#sec-15.9.4.2" target="_blank">ES5.1</a> releases in mid-2011 and now additionally mentions that <q>The value of an absent time zone offset is Z.</q></li>
<li>Chrome <a href="https://chromium.googlesource.com/v8/v8.git/+/ff9ce1abd4add01bbb3f1917bd72207e5ddd70b5" target="_blank">updates its implementation</a> to use UTC for both cases.</li>
<li>Safari <a href="https://github.com/WebKit/WebKit/commit/a841b97de44dbff4ecb30f62e984b1fc72493ac6" target="_blank">fixes the earlier bug</a> and uses UTC for both cases.</li>
<li>A <a href="https://web.archive.org/web/20141214115940/https://bugs.ecmascript.org/show_bug.cgi?id=112" target="_blank">bug</a> is filed against the spec itself, pointing out that ISO 8601 represents date-times without offsets as local time. <a href="https://262.ecma-international.org/6.0/index.html#sec-date-time-string-format" target="_blank">ES6</a> in 2015 replaces the ES5.1 addition with <q>If the time zone offset is absent, the date-time is interpreted as a local time.</q></li>
<li>Chrome <a href="https://chromium.googlesource.com/v8/v8.git/+/f06754a8e1d305a43560705f6c167d85d40e602d" target="_blank">switches back</a> to using local time for both cases.</li>
<li>A <a href="https://issues.chromium.org/issues/40440226" target="_blank">bug</a> is filed against Chrome for breaking backwards compatibility when parsing date-only forms. They <a href="https://chromium.googlesource.com/v8/v8.git/+/dd3f1ecf719afd21b4c695c776b4da2fb494ef92" target="_blank">revert the previous change</a>.</li>
<li>Chrome files an <a href="https://github.com/tc39/ecma262/issues/87" target="_blank">issue</a> against the spec and after discussion, it’s decided to switch date-only forms back to UTC but leave date-time forms without offset as local (i.e. Firefox’s behavior).</li>
<li><a href="https://262.ecma-international.org/7.0/index.html#sec-date.parse" target="_blank">ES7</a> releases with the updated requirement. Chrome <a href="https://chromium.googlesource.com/v8/v8.git/+/d31c5410c4fdfc5eb66582892d5e3ecd3706bd58" target="_blank">makes the change</a> and then eventually, <a href="https://github.com/WebKit/WebKit/commit/2148a43f377e67c60b167f5730c7b5c5c21b202d" target="_blank">Safari</a>.</li>
</ol><p>This behavior has been maintained to the present day where every possible string accepted by the <code>Date</code> constructor falls back to local time <em>except</em> valid ISO date-strings like <code>&#39;2025-05-28&#39;</code>.</p><p>What’s interesting looking at the timeline is that despite being designed as a standardized format, from its release in 2009 up until early 2020, there would never exist a point where the major browsers behaved consistently for missing offsets. Meanwhile, Chrome has flipped hilariously from <a href="https://chromium.googlesource.com/v8/v8.git/+/6ceb02e6eb791f837ed84b7ed41332058cd3f1dc" target="_blank">local</a> → <a href="https://chromium.googlesource.com/v8/v8.git/+/ff9ce1abd4add01bbb3f1917bd72207e5ddd70b5" target="_blank">UTC</a> → <a href="https://chromium.googlesource.com/v8/v8.git/+/f06754a8e1d305a43560705f6c167d85d40e602d" target="_blank">local</a> → <a href="https://chromium.googlesource.com/v8/v8.git/+/dd3f1ecf719afd21b4c695c776b4da2fb494ef92" target="_blank">UTC</a> → <a href="https://chromium.googlesource.com/v8/v8.git/+/d31c5410c4fdfc5eb66582892d5e3ecd3706bd58" target="_blank">local</a> when parsing <code>&#39;2025-05-28T00:00&#39;</code>. And all this just to settle at Firefox’s 2009 behavior which, in my opinion, is the most unintuitive of them all.</p> </section>
<section id="What_about_Temporal?"> <h2><a href="#What_about_Temporal?">What about Temporal?</a></h2> <p>For the unaware, <a href="https://developer.mozilla.org/en-US/blog/javascript-temporal-is-coming/" target="_blank">JavaScript Temporal is coming</a>: a new set of date and time APIs intended to replace the <code>Date</code> object.</p><p>Our whole original date parsing issue stemmed from time zone ambiguity but in many cases, the desire is to treat date-only strings as exactly that — dates only. For example, when I say that Christmas this year is <code>2025-12-25</code>, I don’t mean the universal instant in time that is <code>2025-12-25T00:00:00.000Z</code>.</p><p>While <code>Date</code> can only ever represent the latter, Temporal offers the option of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Temporal/PlainDate" target="_blank">plain dates</a> (i.e. a date without a time zone). <code>&#39;2025-12-25&#39;</code> is just <code>2025-12-25</code>, side-stepping the parsing ambiguity issue entirely.</p><p>But what if one really wants to parse a date-only string into an instant in time? What time zone will Temporal choose when absent in the string itself?</p><p>Answer: It’s a hard error; an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Temporal/Instant#z%C2%B1hhmm" target="_blank">offset</a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Temporal/ZonedDateTime#time_zone_id" target="_blank">time zone identifier</a> must be provided. No repeat mistakes here.</p> </section>
<section id="Bonus:_enter_the_cursed_zone"> <h2><a href="#Bonus:_enter_the_cursed_zone">Bonus: enter the cursed zone</a></h2> <p>One thing I never realized until reading browser date-parsing source code is just how lenient it can be.</p><p>Here’s a fun example for Chrome/Firefox: can you spot why this (valid!) date string is being parsed as the month of May?</p><pre><code><span>const</span> date = <span>&#39;it is wednesday, my dudes. 2025, April, maybe...28(?)&#39;</span>;
<span>console</span>.<span>log</span>(<span>new</span> <span>Date</span>(date)); </code></pre> </section></article> </div></div>
  </body>
</html>
