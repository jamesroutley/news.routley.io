<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tokern.io/blog/open-source-sql-parsers/">Original</a>
    <h1>Open Source SQL Parsers</h1>
    
    <div id="readability-page-1" class="page"><div><p>Parsing SQL queries provides superpowers for monitoring data health. This post describes how to get started on parsing
SQL for data observability.</p><p>Query history of a data warehouse is a rich source of information to glean how data is used in your organization.
Many aspects of data observability can be tracked by analyzing query history. For example, query history analysis can
extract:</p><ul><li>Popular tables and columns</li><li>Unused tables and columns</li><li>Column-level lineage</li><li>Freshness</li></ul><p><span>
      <span></span>
  <picture>
          <source srcset="/static/17e12892051c89fe6acfc87fc83d6395/e7e7a/plan.webp 208w,/static/17e12892051c89fe6acfc87fc83d6395/85983/plan.webp 415w,/static/17e12892051c89fe6acfc87fc83d6395/21ce6/plan.webp 773w" sizes="(max-width: 773px) 100vw, 773px" type="image/webp"/>
          <source srcset="/static/17e12892051c89fe6acfc87fc83d6395/7854c/plan.png 208w,/static/17e12892051c89fe6acfc87fc83d6395/554fc/plan.png 415w,/static/17e12892051c89fe6acfc87fc83d6395/dc084/plan.png 773w" sizes="(max-width: 773px) 100vw, 773px" type="image/png"/>
          <img src="https://tokern.io/static/17e12892051c89fe6acfc87fc83d6395/dc084/plan.png" alt="SQL Execution Plan" title="SQL Execution Plan" loading="lazy"/>
        </picture>
    </span></p><p>These statistics also help to automate common data engineering tasks like:</p><ul><li>Backup and Disaster Recovery</li><li>Triage Data Quality issues</li><li>Track sensitive data and how they are used.</li></ul><h2 id="challenges-and-approaches"><a href="#challenges-and-approaches" aria-label="challenges and approaches permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Challenges and Approaches</h2><p>SQL language is an ISO/IEC standard and the latest version is <a href="https://blog.ansi.org/2018/10/sql-standard-iso-iec-9075-2016-ansi-x3-135/" target="_blank" rel="nofollow noopener noreferrer">SQL2016</a>.
However, every database implements the standard
differently, uses different function names for the same operation, and has extensions to access specific custom features.
Therefore, there isnâ€™t one SQL parser for dialects of all popular databases and data warehouses.</p><p>Regular expressions is a popular approach to extract information from SQL statements. However, regular expressions quickly
become too complex to handle common features like WITH, sub-queries, windows clauses, aliases and quotes.
<a href="https://github.com/andialbrecht/sqlparse" target="_blank" rel="nofollow noopener noreferrer">sqlparse</a> is a popular Python package that uses regular expressions to parse
SQL.</p><p>An alternate approach is to implement the SQL grammar using parser generators like <a href="https://antlr.org" target="_blank" rel="nofollow noopener noreferrer">ANTLR</a>. There
are similar open source parser generators in other popular languages.</p><p>There are multiple projects that maintain parsers for popular open source databases like MySQL and Postgres. For other
open source databases, the grammar can be extracted from the open-source project. For commercial databases, the only
option is to reverse engineer the complete grammar. There are SQL parser/optimizer platforms like <a href="https://calcite.apache.org/" target="_blank" rel="nofollow noopener noreferrer">Apache Calcite</a>
that help to reduce the effort to implement the SQL dialect of your choice.</p><h2 id="open-source-parsers"><a href="#open-source-parsers" aria-label="open source parsers permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Open Source Parsers</h2><p>Some popular open source databases and data warehouses are:</p><h3 id="mysqlmariadb"><a href="#mysqlmariadb" aria-label="mysqlmariadb permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MySQL/MariaDB</h3><ul><li><a href="https://github.com/pingcap/parser" target="_blank" rel="nofollow noopener noreferrer">Pingcap</a> parser is a MySQL parser in Go.</li><li><a href="https://github.com/phpmyadmin/sql-parser" target="_blank" rel="nofollow noopener noreferrer">SQL Parser</a> in phpmyadmin is a validating SQL lexer and parser with a focus on MySQL dialect.</li></ul><h3 id="postgres"><a href="#postgres" aria-label="postgres permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Postgres</h3><p><a href="https://github.com/pganalyze/libpg_query" target="_blank" rel="nofollow noopener noreferrer">libpg_query</a> extracts the parser (written in C) from the postgres project and
packages it as a stand-alone library. This library is wrapped in other languages by other projects like:</p><ul><li><em>Python</em>: <a href="https://github.com/lelit/pglast" target="_blank" rel="nofollow noopener noreferrer">pglast</a></li><li><em>Ruby</em> : <a href="https://github.com/pganalyze/pg_query" target="_blank" rel="nofollow noopener noreferrer">pg_query</a></li><li><em>Golang</em>: <a href="https://github.com/pganalyze/pg_query_go" target="_blank" rel="nofollow noopener noreferrer">pg_query_go</a></li><li><em>JS</em>: <a href="https://github.com/pyramation/pgsql-parser" target="_blank" rel="nofollow noopener noreferrer">psql-parser</a> in Node and <a href="https://github.com/pganalyze/pg-query-emscripten" target="_blank" rel="nofollow noopener noreferrer">pg-query-emscripten</a> in the browser</li><li><em>Rust</em>: <a href="https://github.com/paupino/pg_query.rs" target="_blank" rel="nofollow noopener noreferrer">pg_query.rs</a></li></ul><h3 id="multiple-engines"><a href="#multiple-engines" aria-label="multiple engines permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Multiple Engines</h3><ul><li><a href="https://github.com/uber/queryparser" target="_blank" rel="nofollow noopener noreferrer">queryparser</a> implements Apache Hive, Presto/Trino and Vertica dialects.</li><li><a href="https://github.com/google/zetasql" target="_blank" rel="nofollow noopener noreferrer">zetasql</a> implements BigQuery, Spanner, and Dataflow dialects.</li></ul><h3 id="generic-parsers"><a href="#generic-parsers" aria-label="generic parsers permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generic Parsers</h3><ul><li><em>Python</em>: <a href="https://github.com/andialbrecht/sqlparse" target="_blank" rel="nofollow noopener noreferrer">sqlparse</a></li><li><em>Rust</em>: <a href="https://github.com/sqlparser-rs/sqlparser-rs" target="_blank" rel="nofollow noopener noreferrer">sqlparser-rs</a></li><li><em>Python</em>: <a href="https://github.com/klahnakoski/mo-sql-parsing" target="_blank" rel="nofollow noopener noreferrer">mo-sql-parsing</a></li></ul><h2 id="platforms"><a href="#platforms" aria-label="platforms permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Platforms</h2><p>Parser/Optimizer platforms implement the common SQL language features and allow customization as first-class feature
of the platform. Two popular open source projects are:</p><ul><li><a href="https://calcite.apache.org/" target="_blank" rel="nofollow noopener noreferrer">Apache Calcite</a> is a popular parser/optimizer that is used in popular databases and query engines
like <a href="https://hive.apache.org" target="_blank" rel="nofollow noopener noreferrer">Apache Hive</a>, <a href="https://www.blazingsql.com/" target="_blank" rel="nofollow noopener noreferrer">BlazingSQL</a> and <a href="https://calcite.apache.org/docs/powered_by.html" target="_blank" rel="nofollow noopener noreferrer">many others</a>.</li><li><a href="https://github.com/JSQLParser/JSqlParser" target="_blank" rel="nofollow noopener noreferrer">JSQLParser</a> can parse multiple SQL dialects like MySQL, Postgres and Oracle.
The grammar can be modified to support other SQL dialects.</li></ul><p>Apache Calcite allows customizations at various points of the parsing process.</p><ul><li>Parser rules can be <a href="https://stackoverflow.com/a/44467850" target="_blank" rel="nofollow noopener noreferrer">changed</a> to support custom syntax.</li><li>Conventions such as quotes vs double quotes, case sensitivity.</li><li>Add optimizer rules.</li></ul><p>Apache Calcite also provides visitors for traversing the SQL execution plan. A Visitor pattern is an algorithm to traverse
a SQL plan.</p><h2 id="practical-tips-to-getting-started"><a href="#practical-tips-to-getting-started" aria-label="practical tips to getting started permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Practical tips to Getting Started</h2><p>There are many abandoned open source SQL parsers. The first filter is to use a project that will be supported in the
future. For popular databases such as Postgres and MySQL/MariaDB, there are parsers available in multiple programming
languages.</p><p><strong>What if there is no parser for your database?</strong></p><p>Most teams do not create a parser from scratch. A popular option is to use the Postgres parser and then add custom
SQL syntax. AWS Redshift, Vertica and DuckDB are examples. Use a Postgres SQL parser to parse the query history of these
databases to parse the majority of the queries.</p><p>Many queries will fail to parse such as UNLOAD in AWS Redshift. If it is important to also parse the variants, consider
modifying the projects to accept the custom grammar OR use a platform like Apache Calcite.</p><h2 id="conclusion"><a href="#conclusion" aria-label="conclusion permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2><p>There is a demand for SQL parsers to build reports on database or data warehouse usage. There are a number of good
open-source projects. However, there is a steep learning curve to use these projects and in many cases a project may not
fit your specific requirements.</p><p>Struggling with parsing query history? <a href="https://rajatvenkatesh.typeform.com/to/VtzHo2qe" target="_blank" rel="nofollow noopener noreferrer">Get in touch</a></p></div></div>
  </body>
</html>
