<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.fb.com/2024/12/18/android/translating-java-to-kotlin-at-scale/">Original</a>
    <h1>Translating 10M lines of Java to Kotlin</h1>
    
    <div id="readability-page-1" class="page"><div>

		<ul>
<li>Meta has been on a years-long undertaking to translate our entire Android codebase from Java to Kotlin.</li>
<li>Today, despite having one of the largest Android codebases in the world, we’re well past the halfway point and still going.</li>
<li>We’re sharing some of the tradeoffs we’ve made to support automating our transition to Kotlin, seemingly simple transformations that are surprisingly tricky, and how we’re collaborating with other companies to capture hundreds more corner cases.</li>
</ul>
<p><span>Android development at Meta has been Kotlin-first since 2020, and developers have been saying they prefer Kotlin as a language for even longer.</span></p>
<p><span>But, adoption doesn’t necessarily entail translation. We could simply decide to write all new code in Kotlin and leave our existing Java code as is, just as many other companies have. Or we could take it a little further and translate just the most important files. Instead, we decided that the only way to leverage the full value of Kotlin was to go all in on conversion, even if it meant building our own infrastructure to automate translation at scale. So, a few years ago, engineers at Meta decided to take </span><a href="https://engineering.fb.com/2022/10/24/android/android-java-kotlin-migration/" target="_blank" rel="noopener"><span>roughly ten million lines of perfectly good Java code and rewrite them in Kotlin</span></a><span>.</span></p>
<p><span>Of course, we had to solve problems beyond translation, such as slow build speeds and insufficient linters</span><span>. To learn more about Meta’s broader adoption effort, see Omer Strulovich’s 2022 blog post on our </span><a href="https://engineering.fb.com/2022/10/24/android/android-java-kotlin-migration/" target="_blank" rel="noopener"><span>migration from Java to Kotlin</span></a><span> or Lisa Watkin’s talk about </span><a href="https://atscaleconference.com/videos/kotlin-instagram/" target="_blank" rel="noopener"><span>Kotlin adoption at Instagram</span></a><span>.</span></p>
<p><iframe title="Translating Java to Kotlin at Scale | Eve Matthaey" width="1778" height="1000" src="https://www.youtube.com/embed/zfnOjAYdWrc?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></p>

<p><span>To maximize our gains in developer productivity and null safety, we’re aiming to translate virtually all of our actively developed code, </span><i><span>plus</span></i><span> any code that’s central in the dependency graph. Not surprisingly, that’s most of our code, which adds up to tens of millions of lines, including some of the most complex files.</span></p>
<p><span>It’s pretty intuitive that if we want to maximize productivity gains, we should translate our actively developed code. It’s a little less obvious why translating beyond that provides incremental null-safety benefits. The short answer is that any remaining Java code can be an agent of nullability chaos, especially if it’s not null safe and even more so if it’s central to the dependency graph. (For a more detailed explanation, see the section below on null safety.)</span></p>
<p><span>We also want to minimize the drawbacks of a mixed codebase. As long as we have substantial amounts of Java, we need to continue supporting parallel tool chains. There’s also the much-lamented issue of slower build speeds: Compiling Kotlin is slower than compiling Java, but compiling both together is the slowest of all. </span></p>

<p><span>Like most folks in the industry, we started migrating incrementally by repeatedly clicking a button in the Intellij IDE. This button would trigger </span><a href="https://github.com/JetBrains/intellij-community/tree/master/plugins/kotlin/j2k" target="_blank" rel="noopener"><span>Intellij’s translation tool</span></a><span>, commonly known as J2K. It quickly became clear that this approach wasn’t going to scale for a codebase of our size: We would have to click that button—and then wait the couple of minutes it takes to run—almost 100,000 times to translate our Android codebase. </span></p>
<p><span>With this in mind, we set out to automate the conversion process and minimize interference with our developers’ daily work. The result was a tool we call the Kotlinator that we built around J2K. It’s now comprised of six phases:</span></p>
<ol>
<li aria-level="1"><b>“Deep” build:</b><span> Building the code we’re about to translate helps the IDE resolve all the symbols, especially when third-party dependencies or generated code are involved.</span></li>
<li aria-level="1"><b>Preprocessing:</b><span> This phase is built on top of our custom tool, Editus. It contains about 50 steps for nullability, J2K workarounds, changes to support our custom DI framework, and more.</span></li>
<li aria-level="1"><b>Headless J2K:</b><span> The J2K we know and love, but server-friendly!</span></li>
<li aria-level="1"><b>Postprocessing:</b><span> This phase is similar in architecture to our preprocessing. It consists of about 150 steps for Android-specific changes, as well as more nullability changes, and tweaks to make the resulting Kotlin more idiomatic.</span></li>
<li aria-level="1"><b>Linters:</b><span> Running our linters with autofixes allows us to implement perennial fixes in a way that benefits both conversion diffs and regular diffs going forward.</span></li>
<li aria-level="1"><b>Build error-based fixes:</b><span> Finally, the Kotlinator makes even more fixes based on build errors. After a failed build of the just-translated code, we parse the errors and apply further fixes (e.g., adding a missing import or inserting a </span><span>!!</span><span>).</span></li>
</ol>
<p><span>We’ll dive into more detail on the most interesting phases below.</span></p>
<h2><span>Going headless with J2K</span></h2>
<p><span>The first step was creating a headless version of J2K that could run on a remote machine—not easy, given how tightly coupled J2K and the rest of the Intellij IDE are. We considered a few approaches, including running J2K using a setup similar to Intellij’s testing environment, but after talking to JetBrains’ J2K expert, Ilya Kirillov, we eventually settled on something more like a headless inspection. To implement this approach, we created an Intellij plugin that includes a class extending </span><span>ApplicationStarter</span><span> and calling directly into the </span><span>JavaToKotlinConverter</span><span> class that’s also referenced by the IDE’s conversion button.</span></p>
<p><span>On top of not blocking developers’ local IDEs, the headless approach allowed us to translate multiple files at once, and it unblocked all sorts of helpful but time-consuming steps, like the “build and fix errors” process detailed below. Overall conversion time grew longer (a typical remote conversion now takes about 30 minutes to run), but time spent by the developers decreased substantially.</span></p>
<p><span>Of course, going headless presents another conundrum: If developers aren’t clicking the button themselves, who decides what to translate, and how does it get reviewed and shipped? The answer turned out to be pretty easy: Meta has an internal system that allows developers to set up what is essentially a cron job that produces a daily batch of </span><a href="https://engineering.fb.com/2024/10/25/developer-tools/diff-authoring-time-dat-measuring-developer-productivity-meta/"><span>diffs</span></a><span> (our version of pull requests) based on user-defined selection criteria. This system also helps choose relevant reviewers, ensures that tests and other validations pass, and ships the diff once it’s approved by a human. We also offer a web UI for developers to trigger a remote conversion of a specific file or module; behind the scenes, it runs the same process as the cron job.</span></p>
<p><span>As for choosing what and when to translate, we don’t enforce any particular order beyond prioritizing actively developed files. At this point, the Kotlinator is sophisticated enough to handle most compatibility changes required in external files (for example, changing Kotlin dependents’ references of </span><span>foo.getName()</span><span> to </span><span>foo.name</span><span><span>)</span>, so there’s no need to order our translations based on the dependency graph. </span></p>
<h2><span>Adding custom pre- and post-conversion steps</span></h2>
<p><span>Due to the size of our codebase and the custom frameworks we use, the vast majority of conversion diffs produced by the vanilla J2K would not build. To address this problem, we added two custom phases to our conversion process, preprocessing and postprocessing. Both phases contain dozens of steps that take in the file being translated, analyze it (and sometimes its dependencies and dependents, too), and perform a Java-&gt;Java or Kotlin-&gt;Kotlin transformation if needed. </span><a href="https://github.com/fbsamples/kotlin_ast_tools" target="_blank" rel="noopener"><span>A few of our postprocessing transformations have been open-sourced</span></a><span>.</span></p>
<p><span>These custom translation steps are built on top of an internal metaprogramming tool that leverages Jetbrains’ PSI libraries for both Java and Kotlin. Unlike most metaprogramming tools, it is very much </span><i><span>not</span></i><span> a compiler plugin, so it can analyze broken code across both languages, and does so very quickly. This is especially helpful for postprocessing because it’s often running on code with compilation errors, doing analysis that requires type information. Some postprocessing steps that deal with dependents may need to resolve symbols across several thousand unbuildable Java and Kotlin files. For example, one of our postprocessing steps helps translate interfaces by examining its Kotlin implementers and updating overridden getter functions to instead be overridden properties, like in the example below.</span></p>
<pre><code>interface JustConverted {
  val name: String // I used to be a method called `getName`
}
</code></pre>
<pre><code>class ConvertedAWhileAgo : JustConverted {
  override fun getName(): String = &#34;JustConvertedImpl&#34;
}</code></pre>
<pre><code>class ConvertedAWhileAgo : JustConverted {
  override val name: String = &#34;JustConvertedImpl&#34;
}</code></pre>
<p><span>The downside to this tool’s speed and flexibility is that it can’t always provide answers about type information, especially when symbols are defined in third-party libraries. In those cases, it bails quickly and obviously, so we don’t execute a transformation with false confidence. The resulting Kotlin code might not build, but the appropriate fix is usually pretty obvious to a human (if a little tedious).</span></p>
<p><span>We originally added these custom phases to reduce developer effort, but over time we also leveraged them to reduce developer unreliability. Contrary to popular belief, we’ve found it’s often safer to leave the most delicate transformations to bots. There are certain fixes we’ve automated as part of postprocessing, even though they aren’t strictly necessary, because we want to minimize the temptation for human (i.e., error-prone) intervention. One example is condensing long chains of null checks: The resulting Kotlin code isn’t more correct, but it’s less susceptible to a well-meaning developer accidentally dropping a negation. </span></p>
<h2><span>Leveraging build errors</span></h2>
<p><span>In the course of doing our own conversions, we noticed that we spent a lot of time at the end repeatedly building and fixing our code based on the compiler’s error messages. In theory, we could fix many of these problems in our custom postprocessing, but doing so would require us to reimplement a lot of complex logic that’s baked into the Kotlin compiler. </span></p>
<p><span>Instead, we added a new, final step in the Kotlinator that leverages the compiler’s error messages the same way a human would. Like postprocessing, these fixes are performed with a metaprogramming that can analyze unbuildable code.</span></p>
<h2><span>The limitations of custom tooling</span></h2>
<p><span>Between the preprocessing, postprocessing, and post-build phases, the Kotlinator contains well over 200 custom steps. Unfortunately, some conversion issues simply can’t be solved by adding even more steps.</span></p>
<p><span>Originally we treated J2K as a black box—even though it was open sourced—because its code was complex and not actively developed; diving in and submitting PRs didn’t seem worth the effort. That changed early in 2024, however, when JetBrains began work to make J2K compatible with the new Kotlin compiler, K2. We took the opportunity to work with JetBrains to improve J2K and address problems that had been plaguing us for years, such as disappearing </span><span>override</span><span> keywords.</span></p>
<p><span>Collaborating with JetBrains also gave us the opportunity to insert hooks into J2K that would allow clients like Meta to run their own custom steps directly in the IDE before and after conversion. This may sound strange, given the number of custom processing steps we’ve already written, but there are a couple of major benefits:</span></p>
<ol>
<li aria-level="1"><b>Improved symbol resolution</b><span>. Our custom symbol resolution is fast and flexible, but it’s less precise than J2K’s, especially when it comes to resolving symbols defined in third-party libraries. Porting some of our preprocessing and postprocessing steps over to leverage J2K’s extension points will make them more accurate, and allow us to use Intellij’s more sophisticated static-analysis tooling.</span></li>
<li aria-level="1"><b>Easier open sourcing and collaboration</b><span>. Some of our custom steps are too Android-specific to be incorporated into J2K but might still be useful to other companies. Unfortunately, most of them depend on our custom symbol resolution. Porting these steps over to instead rely on J2K’s symbol resolution gives us the option to open-source them and benefit from the community’s pooled efforts.</span></li>
</ol>

<p><span>In order to translate our code without spewing null-pointer exceptions (NPEs) everywhere, it first needs to be null safe (by “null safe” we mean code checked by a static analyzer such as </span><a href="https://github.com/facebook/infer/blob/main/infer/annotations/src/main/java/com/facebook/infer/annotation/Nullsafe.java" target="_blank" rel="noopener"><span>Nullsafe</span></a><span> or </span><a href="https://github.com/uber/NullAway" target="_blank" rel="noopener"><span>NullAway</span></a><span>). Null safety still isn’t sufficient to eliminate the possibility of NPEs, but it’s an excellent start. Unfortunately, making code null safe is easier said than done.</span></p>
<h2><span>Even null-safe Java throws NPEs sometimes</span></h2>
<p><span>Anyone who has worked with null-safe Java code long enough knows that while it’s more reliable than vanilla Java code, it’s still prone to NPEs. Unfortunately </span><a href="https://engineering.fb.com/2022/11/22/developer-tools/meta-java-nullsafe/" target="_blank" rel="noopener"><span>static analysis is only 100% effective for 100% code coverage</span></a><span>, which is simply not viable in any large mobile codebase that interacts with the server and third-party libraries.</span></p>
<p><span>Here’s a canonical example of a seemingly innocuous change that can introduce an NPE:</span></p>
<p><i><span>MyNullsafeClass.java</span></i></p>
<pre><code>@Nullsafe
public class MyNullsafeClass {

  void doThing(String s) {
    // can we safely add this dereference?
    // s.length;
  }
}</code></pre>
<p><span>Say there are a dozen dependents that call </span><span>MyNullsafeJava::doThing</span><span>. A single non-null-safe dependent could pass in a null argument (for example,  </span><span>MyNullsafeJava().doThing(null)</span><span>), which would lead to an NPE if a dereference is inserted in the body of </span><span>doThing</span><span>. </span></p>
<p><span>Of course, while we can’t </span><i><span>eliminate</span></i><span> NPEs in Java via null-safety coverage, we can greatly reduce their frequency. In the example above, NPEs are possible but fairly rare when there’s only one non-null-safe dependent. If multiple transitive dependents lacked null safety, or if one of the more central dependent nodes did, the NPE risk would be much higher.</span></p>
<h2><span>What makes Kotlin different</span></h2>
<p><span>The biggest difference between null-safe Java and Kotlin is the presence of </span><a href="https://kotlinlang.org/docs/java-interop.html#null-safety-and-platform-types" target="_blank" rel="noopener"><span>runtime validation in Kotlin bytecode</span></a><span> at the interlanguage boundary. This validation is invisible but powerful because it allows developers to trust the stated nullability annotations in any code they’re modifying or calling.</span></p>
<p><span>If we return to our earlier example, </span><span>MyNullsafeClass.java</span><span>, and translate it to Kotlin, we get something like:</span></p>
<p><i><span>MyNullsafeClass.kt</span></i></p>
<pre><code>class MyNullsafeClass {

  fun doThing(s: String) {
    // there&#39;s an invisible `checkNotNull(s)` here in the bytecode
    // so adding this dereference is now risk-free!
    // s.length
  }
}</code></pre>
<p><span>Now there’s an invisible </span><span>checkNotNull(s)</span><span> in the bytecode at the start of </span><span>doThing</span><span>’s body, so we can safely add a dereference to </span><span><span>s</span>,</span><span> because if </span><span>s</span> <i><span>were</span></i><span> nullable, this code would already be crashing. As you can imagine, this certainty makes for much smoother, safer development.</span></p>
<p><span>There are also some differences at the static analysis level: The Kotlin compiler enforces a slightly </span><a href="https://kotlinlang.org/docs/null-safety.html" target="_blank" rel="noopener"><span>stricter set of null safety rules</span></a><span> than Nullsafe does when it comes to concurrency. More specifically, the Kotlin compiler throws an error for </span><a href="https://discuss.kotlinlang.org/t/smartcast-for-nullable-variable-properties/8976" target="_blank" rel="noopener"><span>dereferences of class-level properties</span></a><span> that could have been set to null in another thread. This difference isn’t terribly important to us, but it does lead to more </span><span>!!</span><span> than one might expect when translating null-safe code.</span></p>
<h2><span>Great, let’s translate it all to Kotlin!</span></h2>
<p><span>Not so fast. As is always the case, going from more ambiguity to less ambiguity doesn’t come for free. For a case like </span><span><span>MyNullsafeClass</span>,</span><span> development is much easier after Kotlin translation, but someone has to take that initial risk of effectively inserting a nonnull assertion for its hopefully-really-not-nullable parameter </span><span>s</span><span>. That “someone” is whichever developer or bot ends up shipping the Kotlin conversion.</span></p>
<p><span>We can take a number of steps to minimize the risk of introducing new NPEs during conversion, the simplest of which is erring on the side of “more nullable” when translating parameters and return types. In the case of </span><span>MyNullsafeClass,</span><span> the Kotlinator would have used context clues (in this case, the absence of any dereferences in the body of </span><span>doThing</span><span>) to infer that </span><span><span>String</span> <span>s</span></span><span> should be translated to </span><span>s: String?</span><span>.</span></p>
<p><span>One of the changes we ask developers to scrutinize most when reviewing conversion diffs is the addition of </span><span>!!</span><span> outside of preexisting dereferences. Funnily enough, we’re not worried about an expression like </span><span>foo!!.name</span><span>,</span><span> because it’s not any more likely to crash in Kotlin than it was in Java. An expression such as </span><span>someMethodDefinedInJava(foo!!)</span><span> is much more concerning, however, because it’s possible that </span><span>someMethodDefinedInJava</span><span> is simply missing a </span><span>@Nullable</span><span> on its parameter, and so adding </span><span>!!</span><span> will introduce a very unnecessary NPE.</span></p>
<p><span>To avoid problems like adding unnecessary </span><span>!!</span><span> during conversion, we run over a dozen complementary codemods that comb through the codebase looking for parameters, return types, and member variables that might be missing </span><span>@Nullable</span><span>. More accurate nullability across the codebase—even in Java files that we may never translate—is not only safer, it’s also conducive to more successful conversions, especially as we approach the final stretch in this project.</span></p>
<p><span>Of course, the last remaining null safety issues in our Java code have usually stuck around because they’re very hard to solve. Previous attempts to resolve them relied mostly on static analysis, so we decided to borrow an idea from the Kotlin compiler and create a Java compiler plugin that helps us collect runtime nullability data. This plugin allows us to collect data on all return types and parameters that are receiving/returning a null value and are not annotated as such. Whether these are from Java/Kotlin interop or classes that were annotated incorrectly at a local level, we can determine ultimate sources of truth and use codemods to finally fix the annotations.</span></p>

<p><span>On top of the risks of regressing null safety, there are dozens of other ways to break your code during conversion. In the course of shipping over 40,000 conversions, we’ve learned about many of these the hard way and now have several layers of validation to prevent them. Here are a couple of our favorites:</span></p>
<h3><span>Confusing initialization with getters</span></h3>
<pre><code>// Incorrect!
val name: String = getCurrentUser().name

// Correct
val name: String
  get() = getCurrentUser().name</code></pre>
<h3><span>Nullable booleans</span></h3>
<pre><code>// Original
if (foo != null &amp;&amp; !foo.isEnabled) println(&#34;Foo is not null and disabled&#34;)

// Incorrect!
if (foo?.isEnabled != true) println(&#34;Foo is not null and disabled&#34;)

// Correct
if (foo?.isEnabled == false) println(&#34;Foo is not null and disabled&#34;)</code></pre>

<p><span>At this point, more than half of Meta’s Android Java code has been translated to Kotlin (or, more rarely, deleted). But that was the easy half! The </span><i><span>really</span></i><span> fun part lies ahead of us, and it’s a doozy. There are still thousands of fully automated conversions we hope to unblock by adding and refining custom steps and by contributing to J2K. And there are thousands more semi-automated conversions we hope to ship smoothly and safely as a result of other Kotlinator improvements.</span></p>
<p><span>Many of the problems we face also affect other companies translating their Android codebases. If this sounds like you, we’d love for you to leverage our </span><a href="https://github.com/fbsamples/kotlin_ast_tools"><span>fixes</span></a><span> and share some of your own. Come chat with us and others in the </span><a href="https://slack-chats.kotlinlang.org/c/j2k" target="_blank" rel="noopener"><span>#j2k channel of the Kotlinlang Slack</span></a><span>.</span></p>

		
	</div></div>
  </body>
</html>
