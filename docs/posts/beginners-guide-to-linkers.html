<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lurklurk.org/linkers/linkers.html">Original</a>
    <h1>Beginners Guide to Linkers</h1>
    
    <div id="readability-page-1" class="page">

<p>
This article is intended to help C &amp; C++ programmers understand the
essentials of what the linker does.  I&#39;ve explained this to a number
of colleagues over the years, so I decided it was time to write it
down so that it&#39;s more widely available (and so that I don&#39;t have to
explain it again).  <span>[Updated March 2009 to include
more information on the pecularities of linking on Windows, plus
some clarification on the one definition rule.]</span>
</p><p>
A typical example of what triggers this explanation is when I help
someone who  has a link error like:
</p><blockquote><div><pre>g++ -o test1 test1a.o test1b.o
test1a.o(.text+0x18): In function `main&#39;:
: undefined reference to `findmax(int, int)&#39;
collect2: ld returned 1 exit status
</pre></div></blockquote>
If your reaction to this is &#39;<a href="#namemangling">almost certainly
missing <code>extern &#34;C&#34;</code></a>&#39; then you probably already know everything in
this article.

<h2>Table of Contents</h2>

<ul>
  <li><a href="#cfile">Naming of Parts: What&#39;s in a C File</a></li>
  <li><a href="#ccompiler">What The C Compiler Does</a></li>
   <ul>
    <li><a href="#objfile">Dissecting An Object File</a></li>
   </ul>
  <li><a href="#linker1">What The Linker Does: Part 1</a></li>
   <ul>
    <li><a href="#dups">Duplicate Symbols</a></li>
   </ul>
  <li><a href="#os">What The Operating System Does</a></li>
  <li><a href="#linker2">What The Linker Does: Part 2</a></li>
  <ul>
    <li><a href="#staticlibs">Static Libraries</a></li>
    <li><a href="#sharedlibs">Shared Libraries</a></li>
    <li><a href="#windowsdlls">Windows DLLs</a> </li>
    <ul>
      <li><a href="#winexport">Exporting Symbols</a></li>
      <li><a href="#winlibfiles"><code>.LIB</code> and Other Library-Related Files</a></li>
      <li><a href="#winimport">Importing Symbols</a></li>
      <li><a href="#wincircular">Circular Dependencies</a></li>
    </ul>
  </ul>
  <li><a href="#cppcompiler">Adding C++ To The Picture</a></li>
  <ul>
    <li><a href="#namemangling">Function Overloading &amp; Name Mangling</a></li>
    <li><a href="#staticinit">Initialization of Statics</a></li>
    <li><a href="#templates">Templates</a></li>
  </ul>
  <li><a href="#dlopen">Dynamically Loaded Libraries</a></li>
  <ul>
    <li><a href="#dlopencpp">Interaction with C++ Features</a></li>
  </ul>
  <li><a href="#moredetails">More Details</a></li>
</ul>

<a name="cfile"><h2>Naming of Parts: What&#39;s in a C File</h2></a>
<p>
This section is a quick reminder of the different parts of a C
file. If everything in the <a href="#cfilelisting">sample C file listing
below</a> makes sense to you, you can probably skip to the
<a href="#ccompiler">next section</a>.
</p><p>
The first division to understand is between declarations and
definitions. <a name="definition">A <i>definition</i></a> associates a
name with an implementation of that name, which could be either data or code:
</p><ul>
  <li>A definition of a variable induces the compiler to reserve some
  space for that variable, and possibly fill that space with a
  particular value.</li>
  <li>A definition of a function induces the compiler to generate code for
  that function.</li>
</ul>
<a name="declaration">A <i>declaration</i></a> tells the C compiler that a
definition of something (with a particular name) exists elsewhere
in the program, probably in a different C file.  (Note that a
definition also counts as a declaration—it&#39;s a declaration that
also happens to fill in the particular &#34;elsewhere&#34;).
<p>
For variables, the definitions split into two sorts:
</p><ul>
  <li><i>global variables</i>, which exist for the whole lifetime of
  the program (&#34;static extent&#34;), and which are usually accessible in
  lots of different functions</li>
  <li><i>local variables</i>, which only exist while a particular
  function is being executed (&#34;local extent&#34;) and are only accessible
  within that function</li>
</ul>
To be clear, by &#34;accessible&#34; we mean &#34;can be referred to using the
name associated with the variable by its definition&#34;.
<p>
There are a couple of special cases where things aren&#39;t so immediately
obvious:
</p><ul>
  <li><code>static</code> local variables are actually global variables, because
  they exist for the lifetime of the program, even though they&#39;re only
  visible inside a single function</li>
  <li>likewise <code>static</code> global variables also count as global variables,
  even though they can only be accessed by the functions in the
  particular file where they were defined</li>
</ul>
While we&#39;re on the subject of the &#34;<code>static</code>&#34; keyword, it&#39;s
also worth pointing out that making a <i>function</i> static just
narrows down the number of places that are able to refer to that
function by name (specifically, to other functions in the same file).
<p>
For both global and local variable definitions, we can also make a distinction
between whether the variable is initialized or not—that is,
whether the space associated with the particular name is pre-filled
with a particular value.
</p><p>
Finally, we can store information in memory that is dynamically
allocated using <code>malloc</code> or <code>new</code>.  There is no
way to refer to the
space allocated by name, so we have to use pointers instead—a
named variable (the pointer) holds the address of the unnamed piece of
memory.   This piece of memory can also be deallocated with
<code>free</code> or <code>delete</code>, so the space is referred to as having &#34;dynamic
extent&#34;.
</p><p>
Let&#39;s put all that together:

<a name="ctable">
<table>
  <tbody><tr>
   <th></th>
   <th>Code</th>
   <th colspan="5">Data</th>
  </tr>
  <tr>
   <th></th>
   <th></th>
   <th colspan="2">Global</th>
   <th colspan="2">Local</th>
   <th>Dynamic</th>
  </tr>
  <tr>
   <th></th>
   <th></th>
   <th>Initialized</th>
   <th>Uninitialized</th>
   <th>Initialized</th>
   <th>Uninitialized</th>
   <th></th>
  </tr>
  <tr>
   <th>Declaration</th>
   <td><code>int fn(int x);</code></td>
   <td><code>extern int x;</code></td>
   <td><code>extern int x;</code></td>
   <td>N/A</td>
   <td>N/A</td>
   <td>N/A</td>
  </tr>
  <tr>
   <th>Definition</th>
   <td><code>int fn(int x) { ... }</code></td>
   <td><code>int x = 1;</code></td>
   <td><code>int x;</code></td>
   <td><code>int x = 1;</code></td>
   <td><code>int x;</code></td>
   <td>(<code>int* p = malloc(sizeof(int));</code>)</td>
  </tr>
</tbody></table>
</a>
</p><p>
<a name="cfilelisting">An easier way to follow this is probably just to
look at this sample program:</a>
</p><blockquote><div><pre>

/* This is the definition of a uninitialized global variable */
int x_global_uninit;

/* This is the definition of a initialized global variable */
int x_global_init = 1;

/* This is the definition of a uninitialized global variable, albeit
 * one that can only be accessed by name in this C file */
static int y_global_uninit;

/* This is the definition of a initialized global variable, albeit
 * one that can only be accessed by name in this C file */
static int y_global_init = 2;

/* This is a declaration of a global variable that exists somewhere
 * else in the program */
extern int z_global;

/* This is a declaration of a function that exists somewhere else in
 * the program (you can add &#34;extern&#34; beforehand if you like, but it&#39;s
 * not needed) */
int fn_a(int x, int y);

/* This is a definition of a function, but because it is marked as
 * static, it can only be referred to by name in this C file alone */
static int fn_b(int x)
{
  return x+1;
}

/* This is a definition of a function. */
/* The function parameter counts as a local variable */
int fn_c(int x_local)
{
  /* This is the definition of an uninitialized local variable */
  int y_local_uninit;
  /* This is the definition of an initialized local variable */
  int y_local_init = 3;

  /* Code that refers to local and global variables and other
   * functions by name */
  x_global_uninit = fn_a(x_local, x_global_init);
  y_local_uninit = fn_a(x_local, y_local_init);
  y_local_uninit += fn_b(z_global);
  return (y_global_uninit + y_local_uninit);
}
</pre></div></blockquote>


<a name="ccompiler"><h2>What The C Compiler Does</h2></a>
<p>
The C compiler&#39;s job is to convert a C file from text that the human can
(usually) understand, into stuff that the computer can
understand.  This output by the compiler as an
<i>object file</i>.  On UNIX platforms these object files normally
have a <code>.o</code> suffix; on Windows they have a
<code>.obj</code> suffix. The contents of an object file are
essentially two kinds of things:
</p><ul>
 <li><i>code</i>, corresponding to <a href="#definition">definitions</a>
 of functions in the C file</li>
 <li><i>data</i>, corresponding to <a href="#definition">definitions</a>
 of <b>global</b> variables in the C file (for an initialized global
 variable, the initial value of the variable also has to be stored in
 the object file).</li>
</ul>
Instances of either of these kinds of things will have names
associated with them—the names of the variables or
functions whose definitions generated them.
<p>
Object code is the sequence of (suitably encoded) machine
instructions that correspond to the C instructions that the programmer
has written—all of those <code>if</code>s and <code>while</code>s
and even <code>goto</code>s. All of these instructions need to
manipulate information of some sort, and that information needs to be
kept somewhere—that&#39;s the job of the variables.  The code can
also refer to other bits of code—specifically, to other C
functions in the program.
</p><p>
Wherever the code refers to a variable or function, the compiler only
allows this if it has previously seen a <a href="#declaration">declaration</a> for that variable or
function—the declaration is a promise that a definition exists
somewhere else in the whole program.
</p><p>
The job of the linker is to make good on these promises, but in the
meanwhile what does the compiler do with all of these promises when it
is generating an object file?
</p><p>
Basically, the compiler leaves a blank.  The blank (a &#34;reference&#34;) has
a name associated to it, but the value corresponding to that name is
not yet known.
</p><p>
With that in mind, we can depict the object file corresponding to <a href="#cfilelisting">the program given above</a> like this:
<a name="objpng"><img src="https://www.lurklurk.org/linkers/c_parts.png" alt="Schematic diagram of object file"/></a>
</p><h3><a name="objfile">Dissecting An Object File</a></h3>
<p>
We&#39;ve kept everything at a high level so far; it&#39;s useful to see how
this actually works in practice.  The key tool for this is the command
<b><code>nm</code></b>, which gives information about the symbols in an object
file on UNIX platforms. <span>On Windows, the
<a href="http://support.microsoft.com/kb/177429"><b><code>dumpbin</code></b>
command</a> with the <code>/symbols</code> option is roughly equivalent;
there is also
<a href="http://sourceforge.net/project/showfiles.php?group_id=2435&amp;package_id=11290">a
Windows port</a> of the
<a href="http://www.gnu.org/software/binutils">GNU binutils</a>
tools which includes an <code>nm.exe</code>.
</span>
</p><p>
Let&#39;s have a look at what <code>nm</code> gives on the object file
produced from the <a href="#cfilelisting">C file above</a>:
</p><blockquote><div><pre>


Symbols from c_parts.o:

Name                  Value   Class        Type         Size     Line  Section

fn_a                |        |   U  |            NOTYPE|        |     |*UND*
z_global            |        |   U  |            NOTYPE|        |     |*UND*
fn_b                |00000000|   t  |              FUNC|00000009|     |.text
x_global_init       |00000000|   D  |            OBJECT|00000004|     |.data
y_global_uninit     |00000000|   b  |            OBJECT|00000004|     |.bss
x_global_uninit     |00000004|   C  |            OBJECT|00000004|     |*COM*
y_global_init       |00000004|   d  |            OBJECT|00000004|     |.data
fn_c                |00000009|   T  |              FUNC|00000055|     |.text
</pre></div></blockquote>
<p>
The output on different platforms can vary a bit (check the
<code>man</code> pages to find out more on a particular version), but
the key information given is the class of each symbol, and its size
(when available).  The class can have a number of different values:
</p><ul>
  <li>A class of <b>U</b> indicates an undefined
  reference, one of the &#34;blanks&#34;
  mentioned previously.  For this object, there are two:
  &#34;<code>fn_a</code>&#34; and &#34;<code>z_global</code>&#34;. (Some versions
    of <code>nm</code> may also print out a <i>section</i>, which
    will be <b>*UND*</b> or <b>UNDEF</b> in this case)</li>

  <li>A class of <b>t</b> or <b>T</b> indicates where code is defined;
  the different classes indicate whether the function is local to this
  file (<b>t</b>) or not (<b>T</b>)—i.e. whether the function was
  originally declared with <code>static</code>.  Again, some systems
  may also show a section, something like <b>.text</b></li>

  <li>A class of <b>d</b> or <b>D</b> indicates an initialized global
  variable, and again the particular class indicates whether the
  variable is local (<b>d</b>) or not (<b>D</b>).  If there&#39;s a
  section, it will be something like <b>.data</b></li>

  <li>For an uninitialized global variable, we get <b>b</b> if it&#39;s
  static/local, and <b>B</b> or <b>C</b> when it&#39;s not.  The section in this case
  will probably be something like <b>.bss</b> or <b>*COM*</b>.</li>

</ul>
<p>
We may also get some symbols that weren&#39;t part of the original input
C file; we&#39;ll ignore these as they&#39;re typically part of the
compiler&#39;s nefarious internal mechanisms for getting your program to
link.
</p>
<a name="linker1"><h2>What The Linker Does: Part 1</h2></a>
<p>
We mentioned earlier that a declaration of a function or a variable is
a promise to the C compiler that somewhere else in the program is a
definition for that function or variable, and that the linker&#39;s jobs is
to make good on that promise.  With <a href="#objpng">the diagram of an
object file</a> in front of us, we can also describe this as &#34;filling
in the blanks&#34;.
</p><p>
To illustrate this, let&#39;s have a companion C file to the <a href="#cfilelisting">one given previously</a>:
</p><blockquote><div><pre>/* Initialized global variable */
int z_global = 11;
/* Second global named y_global_init, but they are both static */
static int y_global_init = 2;
/* Declaration of another global variable */
extern int x_global_init;

int fn_a(int x, int y)
{
  return(x+y);
}

int main(int argc, char *argv[])
{
  const char *message = &#34;Hello, world&#34;;

  return fn_a(11,12);
}

</pre></div></blockquote>
<img src="https://www.lurklurk.org/linkers/c_rest.png" alt="Schematic diagram of object file"/>
<p>
With these two diagrams, we can see that all of the dots can joined
up (if they couldn&#39;t be, then the linker would emit an error
message). Every thing has its place, and every place has its thing, and the
linker can fill in all of the blanks as shown (on a UNIX system, the
linker is typically invoked with <code><b>ld</b></code>).
</p><p>
<img src="https://www.lurklurk.org/linkers/sample1.png" alt="Schematic diagram of object file"/>
</p><p>
As for <a href="#objfile">object files</a>, we can use <code>nm</code> to
examine the resulting executable file:
</p><blockquote><div><pre>


Symbols from sample1.exe:

Name                  Value   Class        Type         Size     Line  Section

_Jv_RegisterClasses |        |   w  |            NOTYPE|        |     |*UND*
__gmon_start__      |        |   w  |            NOTYPE|        |     |*UND*
__libc_start_main@@GLIBC_2.0|        |   U  |              FUNC|000001ad|     |*UND*
_init               |08048254|   T  |              FUNC|        |     |.init
_start              |080482c0|   T  |              FUNC|        |     |.text
__do_global_dtors_aux|080482f0|   t  |              FUNC|        |     |.text
frame_dummy         |08048320|   t  |              FUNC|        |     |.text
fn_b                |08048348|   t  |              FUNC|00000009|     |.text
fn_c                |08048351|   T  |              FUNC|00000055|     |.text
fn_a                |080483a8|   T  |              FUNC|0000000b|     |.text
main                |080483b3|   T  |              FUNC|0000002c|     |.text
__libc_csu_fini     |080483e0|   T  |              FUNC|00000005|     |.text
__libc_csu_init     |080483f0|   T  |              FUNC|00000055|     |.text
__do_global_ctors_aux|08048450|   t  |              FUNC|        |     |.text
_fini               |08048478|   T  |              FUNC|        |     |.fini
_fp_hw              |08048494|   R  |            OBJECT|00000004|     |.rodata
_IO_stdin_used      |08048498|   R  |            OBJECT|00000004|     |.rodata
__FRAME_END__       |080484ac|   r  |            OBJECT|        |     |.eh_frame
__CTOR_LIST__       |080494b0|   d  |            OBJECT|        |     |.ctors
__init_array_end    |080494b0|   d  |            NOTYPE|        |     |.ctors
__init_array_start  |080494b0|   d  |            NOTYPE|        |     |.ctors
__CTOR_END__        |080494b4|   d  |            OBJECT|        |     |.ctors
__DTOR_LIST__       |080494b8|   d  |            OBJECT|        |     |.dtors
__DTOR_END__        |080494bc|   d  |            OBJECT|        |     |.dtors
__JCR_END__         |080494c0|   d  |            OBJECT|        |     |.jcr
__JCR_LIST__        |080494c0|   d  |            OBJECT|        |     |.jcr
_DYNAMIC            |080494c4|   d  |            OBJECT|        |     |.dynamic
_GLOBAL_OFFSET_TABLE_|08049598|   d  |            OBJECT|        |     |.got.plt
__data_start        |080495ac|   D  |            NOTYPE|        |     |.data
data_start          |080495ac|   W  |            NOTYPE|        |     |.data
__dso_handle        |080495b0|   D  |            OBJECT|        |     |.data
p.5826              |080495b4|   d  |            OBJECT|        |     |.data
x_global_init       |080495b8|   D  |            OBJECT|00000004|     |.data
y_global_init       |080495bc|   d  |            OBJECT|00000004|     |.data
z_global            |080495c0|   D  |            OBJECT|00000004|     |.data
y_global_init       |080495c4|   d  |            OBJECT|00000004|     |.data
__bss_start         |080495c8|   A  |            NOTYPE|        |     |*ABS*
_edata              |080495c8|   A  |            NOTYPE|        |     |*ABS*
completed.5828      |080495c8|   b  |            OBJECT|00000001|     |.bss
y_global_uninit     |080495cc|   b  |            OBJECT|00000004|     |.bss
x_global_uninit     |080495d0|   B  |            OBJECT|00000004|     |.bss
_end                |080495d4|   A  |            NOTYPE|        |     |*ABS*
</pre></div></blockquote>
This has all of the symbols from the two objects, and all of the
undefined references have vanished.  The symbols have also all been
reordered so that similar types of things are together, and there are
a few added extras to help the operating system deal with the whole
thing as an executable program.
<p>
<SPAN size="-1">There&#39;s also a fair number of complicating
details cluttering up the output, but if you filter out anything starting
with an underscore it gets a lot simpler.</SPAN>
</p><h3><a name="dups">Duplicate Symbols</a></h3>
<p>
The previous section mentioned that if the linker cannot find a
definition for a symbol to join to references to that symbol, then
it will give an error message.  So what happens if there are
<i>two</i> definitions for a symbol when it comes to link time?
</p><p>
<span>In C++, the situation is straightforward.</span>
 The language has a constraint known as the <i>one
definition rule</i>, which says that there has to be exactly one
definition for a symbol when it comes to link time, no more and no
less. (The relevant section of the C++ standard is 3.2, which
also mentions some exceptions that we&#39;ll
<a href="#templates">come to later on</a>.)
</p><p>
For C, things are slightly less clear.  There has to be exactly
one definition of any functions or initialized global variables,
but the definition of an uninitialized global variable
can be treated as a <i>tentative definition</i>. C then allows
(or at least does not forbid) different source files to have
tentative definitions for the same object.
</p>
<p>
However, linkers also have to cope with other programming languages than
just C and C++, and <span>the one definition rule</span> isn&#39;t always appropriate for them.
For example, the normal model for Fortran code is effectively to have
a copy of each global variable in every file that references it;
the linker is required to fold duplicates by picking one of the copies
(the largest version, if they are different sizes) and throw away the
rest. <span>(This model is sometimes known as the &#34;common model&#34;
of linking, after the Fortran <code>COMMON</code> keyword.)</span>
</p><p>
As a result, it&#39;s actually quite common for UNIX linkers <i>not</i> to
complain about duplicate definitions of symbols—at least, not
when the duplicate symbol is an uninitialized global variable
<span>(this is sometimes known as the &#34;relaxed ref/def model&#34; of linking).</span>
If this worries you (and it probably should), check the documentation for
your compiler linker—there may well be a <code>--work-properly</code>
option that tightens up the behavior.  For example, for the GNU
toolchain the <code>-fno-common</code> option to the compiler forces
it to put uninitialized variables into the BSS segment rather than
generating these <i>common blocks</i>.
</p><h2><a name="os">What The Operating System Does</a></h2>
<p>
Now that the linker has produced an executable program with all of the
references to symbols joined up to suitable definitions of those
symbols, we need to pause briefly to understand what the operating
system does when you run the program.
</p><p>
Running the program obviously involves executing the machine code, so the
operating system clearly has to transfer the machine code from the executable
file on the hard disk into the computer&#39;s memory, where the CPU can
get at it.  This chunk of the program&#39;s memory is known as the <i>code
segment</i> or <i>text segment</i>.
</p><p>
Code is nothing without data, so all of the global
variables need to have some space in the computer&#39;s memory too.
However, there&#39;s a difference between initialized and uninitialized
global variables.  Initialized variables have particular
values that need to be used to begin with, and these values are stored in the object
files and in the executable file.  When the program is started, the OS
copies these values into the program&#39;s memory in the <i>data segment</i>.
</p><p>
For uninitialized variables, the OS can assume that they all just
start with the initial value 0, so there&#39;s no need to copy any
values.  This chunk of memory, that gets initialized to 0, is known as
the <i>bss segment</i>.
</p><p>
This means that space can be saved in the executable file on disk; the
initial values of initialized variables have to be stored in the file,
but for the uninitialized variables we just need a count of how much
space is needed for them.
</p><p>
<img src="https://www.lurklurk.org/linkers/os_map1.png" alt="How the OS maps the executable file into memory"/>
</p><p>
You may have noticed that all of the discussion of object files and
linkers so far has only talked about global variables; there&#39;s been no
mention of the local variables and dynamically allocated memory
<a href="#ctable">mentioned earlier</a>.
</p><p>
These pieces of data don&#39;t need any linker involvement, because their
lifetime only occurs when the program is running—long after the
linker has finished its business.  However, for the sake of
completeness, we can quickly point out here that:
 </p><ul>
  <li>local variables are allocated on a piece of memory known as the
  <i>stack</i>, which grows and shrinks as different functions are
  called and complete</li>
  <li>dynamically allocated memory is taken from an area known as the
  <i>heap</i>, and the <code>malloc</code> function keeps track of
  where all the available space in this area is.</li>
 </ul>
<p>
We can add in these chunks of memory to complete our picture of what
the memory space of a running process looks like.  Because both the
heap and the stack can change size as the program runs, it&#39;s quite
common to arrange matters so that the stack grows in one direction
while the heap grows in the other.  That way, the program will only
run out of memory when they meet in the middle (and at that point, the
memory space really will be full).
</p><p>
<img src="https://www.lurklurk.org/linkers/os_map2.png" alt="How the OS maps the executable file into memory"/>
</p><h2><a name="linker2">What The Linker Does: Part 2</a></h2>
<p>
Now that we&#39;ve covered the <a href="#linker1">very basics</a> of the
operation of a linker, we can plough on to describe some more
complicating details—roughly in the order that these features
were historically added to linkers.
</p><p>
The main observation that affected the function of the linker is this:
if lots of different programs need to do the same
sorts of things (write output to the screen, read files from the hard
disk, etc), then it clearly makes sense to commonize this code in one
place and have lots of different programs use it.
</p><p>
This is perfectly feasible to do by just using the same object files
when linking different programs, but it makes life much easier if
whole collections of related object files are kept together in one
easily accessible place: a <i>library</i>
</p><p>
<a name="relocation"><SPAN size="-1">(Technical aside: This section completely skips a
major feature of the linker: <i>relocation</i>.  Different programs
will be different sizes, so when the shared library gets mapped into
the address space of different programs, it will be at different
addresses.  This in turn means that all of the functions and variables
in the library are in different places.  Now, if all of the ways of
referring to addresses are relative (&#34;the value +1020 bytes from
here&#34;) rather than absolute (&#34;the value at 0x102218BF&#34;) this is less
of a problem, but this isn&#39;t always possible.  If not, then all of
these absolute addresses need to have a suitable offset added to
them—this is relocation.  I&#39;m not going to mention this topic
again, though, because it&#39;s almost always invisible to the C/C++
programmer—it&#39;s very rare that a linking issue is because of
relocation problems)</SPAN></a>
</p><h3><a name="staticlibs">Static Libraries</a></h3>
<p>
The most basic incarnation of a library is a <i>static library</i>.
The previous section mentioned that you could share code by just
reusing object files; it turns out that static libraries really aren&#39;t
much more sophisticated than that.
</p><p>
On UNIX systems, the command to produce a static library is normally
<code><b>ar</b></code>, and the library file that it produces
typically has a <code>.a</code> extension.  These library files are
normally also prefixed with &#34;<code>lib</code>&#34; and passed to the
linker with a &#34;-l&#34; option followed by the name of the library, without
prefix or extension (so &#34;<code>-lfred</code>&#34; will pick
up &#34;<code>libfred.a</code>&#34;).
</p><p>
<SPAN size="-1">(Historically, a program called <code>ranlib</code> also
  used to be needed for static libraries, in order to build an index
  of symbols at the start of the library.  Nowadays the
  <code>ar</code> tool tends to do this itself.)</SPAN>
</p><p>
On Windows, static libraries have a <code>.LIB</code> extension
and are produced by the <code>LIB</code> tool,
but this can be confusing as the same extension is also used
for an &#34;<i>import library</i>&#34;, which just holds a list of the
things available in a DLL—see the
<a href="#winlibfiles">section on Windows DLLs</a>.
</p>
<p>
As the linker trundles through its collection of object files to be
joined together, it builds a list of the symbols it hasn&#39;t been able
to resolve yet.  When all of the explicitly specified objects are done
with, the linker now has another place to look for the symbols that
are left on this unresolved list—in the library.  If the unresolved
symbol is defined in one of the objects in the library, then that object is
added in, exactly as if the user had given it on the command line in the first
place, and the link continues.
</p><p>
Note the granularity of what gets pulled in from the library: if some
particular symbol&#39;s definition is needed, the <i>whole object</i> that contains
that symbol&#39;s definition is included.  This means that the process can
be one step forwards, one step back—the newly added object may
resolve one undefined reference, but it may well come with a whole
collection of new undefined references of its own for the linker to
resolve.
</p><p>
Another important detail to note is the <i>order</i> of events; the
libraries are consulted only when then the normal linking is done, and
they are processed <i>in order</i>, left to right.  This means that if
an object pulled in from a library late in the link line needs a
symbol from a library earlier in the link line, the linker won&#39;t
automatically find it.
</p><p>
An example should help to make this clearer; let&#39;s suppose we have the
following object files, and a link line that pulls in
<code>a.o</code>, <code>b.o</code>, <code>-lx</code> and
<code>-ly</code>.
</p><p>
<a name="samplelibs">
<table>
  <tbody><tr>
   <th>File</th>
   <th><code>a.o</code></th>
   <th><code>b.o</code></th>
   <th colspan="3"><code>libx.a</code></th>
   <th colspan="3"><code>liby.a</code></th>
  </tr>
  <tr>
   <th>Object</th>
   <th><code>a.o</code></th>
   <th><code>b.o</code></th>
   <th><code>x1.o</code></th>
   <th><code>x2.o</code></th>
   <th><code>x3.o</code></th>
   <th><code>y1.o</code></th>
   <th><code>y2.o</code></th>
   <th><code>y3.o</code></th>
  </tr>
  <tr>
   <th>Definitions</th>
   <th><code>a1, a2, a3</code></th>
   <th><code>b1, b2</code></th>
   <th><code>x11, x12, x13</code></th>
   <th><code>x21, x22, x23</code></th>
   <th><code>x31, x32</code></th>
   <th><code>y11, y12</code></th>
   <th><code>y21, y22</code></th>
   <th><code>y31, y32</code></th>
  </tr>
  <tr>
   <th>Undefined references</th>
   <th><code>b2, x12</code></th>
   <th><code>a3, y22</code></th>
   <th><code>x23, y12</code></th>
   <th><code>y11</code></th>
   <th><code></code></th>
   <th><code>y21</code></th>
   <th><code></code></th>
   <th><code>x31</code></th>
  </tr>
 </tbody></table>
 </a>
</p><p>
Once the linker has processed <code>a.o</code> and <code>b.o</code>,
it will have resolved the references to <code>b2</code> and
<code>a3</code>, leaving <code>x12</code> and <code>y22</code> as
still undefined.  At this point, the linker checks the first
library <code>libx.a</code> for these symbols, and finds that it can pull in
<code>x1.o</code> to satisfy the <code>x12</code> reference;
however, doing so also adds <code>x23</code> and <code>y12</code>
to the list of undefined references (so the list is now
<code>y22</code>, <code>x23</code> and <code>y12</code>).
</p><p>
The linker is still dealing with <code>libx.a</code>, so
the <code>x23</code> reference is easily satisfied, by also pulling in
<code>x2.o</code> from <code>libx.a</code>.  However, this also adds
<code>y11</code> to the list of undefineds (which is now <code>y22</code>,
<code>y12</code> and <code>y11</code>).  None of these can be resolved
further using <code>libx.a</code>, so the linker moves on to
<code>liby.a</code>.
</p><p>
Here, the same sort of process applies and the linker will pull in
both of <code>y1.o</code> and <code>y2.o</code>.  The first of these
adds a reference to <code>y21</code>, but since <code>y2.o</code> is
being pulled in anyway, that reference is easily resolved.  The net
of this process is that all of the undefined references have been
resolved, and some but not all of the objects in the libraries have
been included into the final executable.
</p><p>
Notice that the situation would have been a little different if (say)
<code>b.o</code> also had a reference to <code>y32</code>.  If this
had been the case, the linking of <code>libx.a</code> would have
worked the same, but the processing of <code>liby.a</code> would also
have pulled in <code>y3.o</code>.  Pulling in this object would have
added <code>x31</code> to the list of unresolved symbols, and the link would
have failed—by this stage the linker has already finished with
<code>libx.a</code> and would not find the definition (in <code>x3.o</code>)
for this symbol.
</p><p>
<SPAN size="-1">(By the way, this example has a cyclic dependency between the
two libraries <code>libx.a</code> and <code>liby.a</code>;  this is
typically a Bad Thing, <a href="#wincircular">particularly on Windows</a>)</SPAN>
</p><h3><a name="sharedlibs">Shared Libraries</a></h3>
<p>
For popular libraries like the C standard library (normally
<code>libc</code>), having a static library has an obvious
disadvantage—every executable program has a copy of the
same code.  This can take up a lot of unnecessary disk space, if every
single executable file has a copy of <code>printf</code> and
<code>fopen</code> and suchlike.
</p><p>
A slightly less obvious disadvantage is that once a program has been
statically linked, the code in it is fixed forever.  If someone finds
and fixes a bug in <code>printf</code>, then every program has to be
linked again in order to pick up the fixed code.
</p><p>
To get around these and other problems, <i>shared libraries</i> were
introduced (normally indicated by a <code>.so</code> extension, or
<code>.dll</code> on Windows machines<span> and
<code>.dylib</code> on Mac OS X</span>).  For these kinds of
libraries, the normal command line linker doesn&#39;t necessarily join up
all of the dots.  Instead, the regular linker takes a kind of &#34;IOU&#34;
note, and defers the payment of that note until the moment when the
program is actually run.
</p><p>
What this boils down to is this: if the linker finds that the
definition for a particular symbol is in a shared library, then it
doesn&#39;t include the definition of that symbol in the final
executable.  Instead, the linker records the name of symbol and which library
it is supposed to come from in the executable file instead.
</p><p>
When the program is run, the operating system arranges that these
remaining bits of linking are done &#34;just in time&#34; for the program to
run.  Before the <code>main</code> function is run, a smaller version
of the linker (often called <code>ld.so</code>) goes through these
promissory notes and does the last stage of the link there and
then—pulling in the code of the library and joining up all of the
dots.
</p><p>
This means that none of the executable files have a copy of the code
for <code>printf</code>. If a new, fixed, version of
<code>printf</code> is available, it can be slipped in just by
changing <code>libc.so</code>—it&#39;ll get picked up the next time
any program runs.
</p><p>
There&#39;s another big difference with how shared libraries work compared
to static libraries, and that shows up in the granularity of the
link.  If a particular symbol is pulled in from a particular shared library (say
<code>printf</code> in <code>libc.so</code>), then the <i>whole</i> of
that shared library is mapped into the address space of the program.
This is very different from the behavior of a static library, where
only the particular objects that held undefined symbols got pulled in.
</p><p>
Put another way, a shared library is itself produced as a result of a
run of the linker (rather than just forming a big pile of objects like
<code>ar</code> does), with references between objects in the same
library getting resolved.  Once again, <code>nm</code> is a useful
tool for illustrating this: for the <a href="#samplelibs">example
libraries above</a> it will produce sets of results for the individual object
files when run on a static version of the library, but for the shared
version of the library, <code>liby.so</code> has only <code>x31</code>
as an undefined symbol. Also, for the library-ordering example at the
end of the <a href="#staticlibs">previous section</a>, there wouldn&#39;t be a problem:
adding a reference to <code>y32</code> into <code>b.c</code> would
make no difference, as all of the contents of <code>y3.o</code> and
<code>x3.o</code> are already pulled in anyway.
</p><blockquote>
  <p>
    As an aside, another useful tool is <b><code>ldd</code></b>; on Unix platforms this
    shows the set of shared libraries that an executable (or a shared library) depends on,
    together with an indication of where those libraries are likely to be found.
    For the program to run successfully, the loader needs to be able to find all of these
    libraries, together with all of their dependencies in turn.  (Typically, the loader
    looks for libraries in the list of directories held in the <code>LD_LIBRARY_PATH</code>
    environment variable.)
  </p><blockquote><div><pre>/usr/bin:ldd xeyes
        linux-gate.so.1 =&gt;  (0xb7efa000)
        libXext.so.6 =&gt; /usr/lib/libXext.so.6 (0xb7edb000)
        libXmu.so.6 =&gt; /usr/lib/libXmu.so.6 (0xb7ec6000)
        libXt.so.6 =&gt; /usr/lib/libXt.so.6 (0xb7e77000)
        libX11.so.6 =&gt; /usr/lib/libX11.so.6 (0xb7d93000)
        libSM.so.6 =&gt; /usr/lib/libSM.so.6 (0xb7d8b000)
        libICE.so.6 =&gt; /usr/lib/libICE.so.6 (0xb7d74000)
        libm.so.6 =&gt; /lib/libm.so.6 (0xb7d4e000)
        libc.so.6 =&gt; /lib/libc.so.6 (0xb7c05000)
        libXau.so.6 =&gt; /usr/lib/libXau.so.6 (0xb7c01000)
        libxcb-xlib.so.0 =&gt; /usr/lib/libxcb-xlib.so.0 (0xb7bff000)
        libxcb.so.1 =&gt; /usr/lib/libxcb.so.1 (0xb7be8000)
        libdl.so.2 =&gt; /lib/libdl.so.2 (0xb7be4000)
        /lib/ld-linux.so.2 (0xb7efb000)
        libXdmcp.so.6 =&gt; /usr/lib/libXdmcp.so.6 (0xb7bdf000)
    </pre></div></blockquote>

</blockquote>
<p>
<SPAN size="-1">The reason for this larger granularity is because modern operating
systems are clever enough that you can save more than just the
duplicate disk space that happens with static libraries; different
running processes that use the same shared library can also share the
code segment (but not the data/bss segments—two different
processes could be in different places for their <code>strtok</code>
after all).  In order to do this, the whole library has to be mapped
in one go, so that the internal references all line up to the same
places—if one process pulled in <code>a.o</code> and
<code>c.o</code> and another pulled in
<code>b.o</code> and <code>c.o</code>, there wouldn&#39;t be any
commonality for the OS to leverage.</SPAN>
</p><h3><a name="windowsdlls">Windows DLLs</a></h3>
<div>
<p>
Although the general principles of shared libraries are roughly similar
on Unix platforms and Windows, that are a few details that can catch
out the unwary.
</p>
<a name="winexport"><h4>Exporting Symbols</h4></a>
<p>
The most major difference between the two is that symbols are not
automatically <i>exported</i> by Windows libraries.  On Unix, all
of the symbols from all of the object files that were linked into
the shared library are visible to users of the library.  On Windows,
the programmer has to explicitly choose to make particular symbols
visible—i.e. to export them.
</p><p>
There are three ways to export a symbol from a Windows DLL (and
all three ways can be mixed together in the same library).
</p><ul>
  <li>In the source code, <a href="http://msdn.microsoft.com/en-us/library/3y1sfaz2.aspx">declare the symbol
  as <code>__declspec(dllexport)</code></a>, thusly:</li>
  <li>On the invocation of the linker, use the <code>/export:<i>symbol_to_export</i></code>
    <a href="http://msdn.microsoft.com/en-us/library/y0zzbyt4.aspx">option to
      <code>LINK.EXE</code></a>.</li>
  <li>Get the linker to pull in a
    <a href="http://msdn.microsoft.com/en-us/library/28d6s79h.aspx"><i>module definition</i>
      (<code>.DEF</code>) file</a> (by using the <code>/DEF:<i>def_file</i></code> linker option),
    and in that file include an <code>EXPORTS</code> section that
    contains the symbols you want to export.
    <blockquote><div><pre>EXPORTS
  my_exported_function
  my_other_exported_function</pre></div></blockquote>
  </li>
</ul>
<p>
Once C++ is added in to the mix, the first of these options is the easiest because the
compiler takes care of the <a href="#namemangling">name mangling</a> for you.
</p>
<a name="winlibfiles"><h4><code>.LIB</code> and Other Library-Related Files</h4></a>
<p>
This neatly leads on to the second complication with Windows libraries: the information about
exported symbols that the linker needs to join things up is not held in the DLL itself.   Instead,
this information is held in a corresponding <code>.LIB</code> file.
</p><p>
The <code>.LIB</code> file associated with a DLL describes what (exported) symbols are present in the
DLL, together with their locations.  Any other binary that uses the DLL needs to look in the <code>.LIB</code>
file so that it can join up the symbols correctly.
</p><p>
<SPAN size="-1">To confuse things, the <code>.LIB</code> extension is also used for static libraries.</SPAN>
</p>
<p>
In fact, there are a wide variety of different files that can be relevant for Windows libraries.
As well as the <code>.LIB</code> file and the (optional) <code>.DEF</code> file mentioned in the previous
section, you might see all of the following files associated with your Windows library.
</p><ul>
  <li>Link <a href="http://msdn.microsoft.com/en-us/library/37b80k4a.aspx">output files</a>:<ul>
      <li><code><i>library</i>.DLL</code>: The library code itself; this is needed (at run-time) by any
        executable that uses the library.</li>
      <li><code><i>library</i>.LIB</code>: An &#34;import library&#34; file which describes what symbols are where in
        the output DLL.  This file is only produced if the DLL exports some symbols; if no symbols are
        exported, there is no point in having the <code>.LIB</code> file.  This file is needed at
        link-time by anything that uses this library.</li>
      <li><code><i>library</i>.EXP</code>: An &#34;export file&#34; for the library being linked, which is needed
        when <a href="#wincircular">linking binaries with circular dependencies</a>.</li>
      <li><code><i>library</i>.ILK</code>: If the <code>/INCREMENTAL</code> option was specified to the
        linker so that incremental linking is enabled, this file holds the status of the incremental
        linking.  Needed for any future incremental linking of this library.</li>
      <li><code><i>library</i>.PDB</code>: If the <code>/DEBUG</code> option was specified to the linker, this
        file is a <i>program database</i> containing debugging information for the library.</li>
      <li><code><i>library</i>.MAP</code>: If the <code>/MAP</code> option was specified to the linker, this
        file holds a description of the internal layout of the library.</li>
    </ul></li>
  <li>Link <a href="http://msdn.microsoft.com/en-us/library/hcce369f.aspx">input files</a>:<ul>
      <li><code><i>library</i>.LIB</code>: An &#34;import library&#34; file which describes what symbols are where in
        any other DLLs that are needed by the thing being linked.</li>
      <li><code><i>library</i>.LIB</code>: A static library file which contains a collection of object files
        that are needed by the thing being linked.  Note the ambiguous use of the <code>.LIB</code> extension.</li>
      <li><code><i>library</i>.DEF</code>: A &#34;module definition&#34; file which allows control of various details
        of the linked library, including the <a href="#winexport">export of symbols</a>.</li>
      <li><code><i>library</i>.EXP</code>: An &#34;export file&#34; for the library being linked, which can indicate
        that a previous run of <code>LIB.EXE</code> for the library has already created the <code>.LIB</code>
        file for the library.  Relevant when <a href="#wincircular">linking binaries with circular dependencies</a>.</li>
      <li><code><i>library</i>.ILK</code>: Incremental linking status file; see above.</li>
      <li><code><i>library</i>.RES</code>: Resource file that contains information about the various GUI
        widgets that the executable uses; these are included in the final binary file.</li>
  </ul></li>
</ul>
<p>
This is contrast to Unix, where most of the information held in these extra files is (usually) just included
in the library itself.
</p>
<a name="winimport"><h4>Importing Symbols</h4></a>
<p>
As well as requiring DLLs to explicitly declare which <a href="#winexport">symbols they export</a>, Windows
also allows binaries that use library code to explicitly declare which symbols they <i>import</i>.
This is optional, but gives a speed optimization due to some
<a href="http://support.microsoft.com/kb/132044">historical features of 16-bit windows</a>.
</p><p>
To do this, <a href="http://msdn.microsoft.com/en-us/library/8fskxacy.aspx">declare the symbol
as <code>__declspec(dllimport)</code></a> in the source code, thusly:<br/>
</p><blockquote><pre>__declspec(dllimport) int function_from_some_dll(int x, double y);
__declspec(dllimport) extern int global_var_from_some_dll;</pre></blockquote>
<p>
It&#39;s normal good practice in C to have a single declaration for any function or global variable, held in a
header file.  This leads to a bit of a conundrum: the code in the DLL that holds the definition of the
function/variable needs to <i>export</i> the symbol, but any code outside the DLL needs to <i>import</i> the
symbol.
</p><p>
A common way round this is to use a preprocessor macro in the header file.
</p><blockquote><div><pre>#ifdef EXPORTING_XYZ_DLL_SYMS
#define XYZ_LINKAGE __declspec(dllexport)
#else
#define XYZ_LINKAGE __declspec(dllimport)
#endif

XYZ_LINKAGE int xyz_exported_function(int x);
XYZ_LINKAGE extern int xyz_exported_variable;
</pre></div></blockquote>
<p>
The C file in the DLL which defines the function and variable ensures that
the preprocessor variable <code>EXPORTING_XYZ_DLL_SYMS</code>
is <code>#define</code>d before it includes this header file, and so does an export of the symbols.
Any other code that pulls in this header file doesn&#39;t define the symbol and so indicates an import of the symbols.
</p>
<a name="wincircular"><h4>Circular Dependencies</h4></a>
<p>
One final complication with DLLs is that Windows is stricter than Unix in requiring every symbol to
have a resolution at link time.  On Unix, it&#39;s possible to link a shared library that contains an
unresolved symbol that the linker has never seen; in this situation, any other code that pulls in this
shared library must provide that symbol, or the program will fail to load.  Windows doesn&#39;t allow this
sort of laxity.
</p><p>
In most systems this isn&#39;t a problem.  Executables rely on high-level libraries, the high-level libraries
rely on lower-level libraries, and everything gets linked in the opposite order—low-level libraries
first, then higher-level libraries, and finally the executables that rely on it all.
</p><p>
However, if there are circular dependencies between binaries, then things are trickier.  If <code>X.DLL</code>
needs a symbol from <code>Y.DLL</code>, and <code>Y.DLL</code> needs a symbol from <code>X.DLL</code>, then
there is a chicken-and-egg problem: whichever library is linked first won&#39;t be able to find all of its
symbols.
</p><p>
Windows does provide a <a href="http://msdn.microsoft.com/en-us/library/kkt2hd12.aspx">way around this</a>,
roughly as follows.
</p><ul>
  <li>First, fake a link of library <code>X</code>.  Run <code>LIB.EXE</code> (not <code>LINK.EXE</code>) to
    produce an <code>X.LIB</code> file that is the same as would have been produced by <code>LINK.EXE</code>.
    No <code>X.DLL</code> file is produced, but a <code>X.EXP</code> file does get emitted.</li>
  <li>Link library <code>Y</code> as normal; this pulls in the <code>X.LIB</code> file from the previous
    step, and outputs both a <code>Y.DLL</code> and a <code>Y.LIB</code> file.</li>
  <li>Finally link library <code>X</code> properly.  This is almost the same as normal, but it additionally
    includes the <code>X.EXP</code> file created in the first step.   As normal, this link will pull in the
    <code>Y.LIB</code> file from the previous step and will create a <code>X.DLL</code> file.  Unlike normal,
    the link will skip the process of creating an <code>X.LIB</code> file, because there one already there
    from the first step (which is what the <code>.EXP</code> file indicates).</li>
</ul>
<p>
Of course, a better idea is usually to re-organize the libraries so that there aren&#39;t any circular
dependencies….
</p></div>
<h2><a name="cppcompiler">Adding C++ To The Picture</a></h2>
<p>
C++ provides a number of extra features over and above what&#39;s
available in C, and a number of these features interact with the
operation of the linker.  This wasn&#39;t originally the case—the
first C++ implementations came as a front end to a C compiler, so the
back end of the linker didn&#39;t need to be changed—but as time went
on, sufficiently sophisticated features were added that the linker had
to be enhanced to support them.
</p><h3><a name="namemangling">Function Overloading &amp; Name Mangling</a></h3>
<p>
The first change that C++ allows is the ability to overload a
function, so there can be different versions of the same named
functions, differing in the types that the function accepts (the
function&#39;s <i>signature</i>):
<a name="maxfns">
</a></p><blockquote><div><pre>int max(int x, int y)
{
  if (x&gt;y) return x;
  else return y;
}
float max(float x, float y)
{
  if (x&gt;y) return x;
  else return y;
}
double max(double x, double y)
{
  if (x&gt;y) return x;
  else return y;
}
</pre></div></blockquote><a name="maxfns">
</a>
This obviously gives a problem for the linker: when some other code
refers to <code>max</code>, which one does it mean?
<p>
The solution that was adopted for this is called <i>name
mangling</i>, because all of the information about the function
signature is mangled into a textual form, and that becomes the actual
name of the symbol as seen by the linker.  Different signature
functions get mangled to different names, so the uniqueness problem
goes away.
</p><p>
I&#39;m not going to go into details of the schemes used (which vary from
platform to platform anyway), but a quick look at the object file
corresponding to the code above gives some hints (remember,
<code>nm</code> is your friend!):
</p><blockquote><div><pre>


Symbols from fn_overload.o:

Name                  Value   Class        Type         Size     Line  Section

__gxx_personality_v0|        |   U  |            NOTYPE|        |     |*UND*
_Z3maxii            |00000000|   T  |              FUNC|00000021|     |.text
_Z3maxff            |00000022|   T  |              FUNC|00000029|     |.text
_Z3maxdd            |0000004c|   T  |              FUNC|00000041|     |.text
</pre></div></blockquote>
Here we can see that our three functions called <code>max</code> all
get different names in the object files, and we can make a fairly
shrewd guess that the two letters after the &#34;max&#34; are encoding the
types of the parameters—&#34;i&#34; for <code>int</code>, &#34;f&#34; for
<code>float</code> and &#34;d&#34; for <code>double</code> (things get a lot
more complex when classes, namespaces, templates and overloaded
operators get added into the mangling mix, though!).
<p>
It&#39;s also worth noting that there will normally be some way of
converting between the user-visible names for things (the
<i>demangled</i> names) and the linker-visible names for things (the
<i>mangled</i> names).  This might be a separate program
(e.g. <code>c++filt</code>) or a command-line option
(e.g. <code>--demangle</code> as an option to GNU nm), which gives
results like:
</p><blockquote><div><pre>


Symbols from fn_overload.o:

Name                  Value   Class        Type         Size     Line  Section

__gxx_personality_v0|        |   U  |            NOTYPE|        |     |*UND*
max(int, int)            |00000000|   T  |              FUNC|00000021|     |.text
max(float, float)            |00000022|   T  |              FUNC|00000029|     |.text
max(double, double)            |0000004c|   T  |              FUNC|00000041|     |.text
</pre></div></blockquote>
<p>
The area where this mangling scheme most commonly trips people up is
when C and C++ code is intermingled.  All of the symbols produced by
the C++ compiler are mangled; all of the symbols produced by the C
compiler are just as they appear in the source file.  To get around
this, the C++ language allows you to put <b><code>extern
&#34;C&#34;</code></b> around the declaration &amp; definition of a function.
This basically tells the C++ compiler that this particular name should
not be mangled—either because it&#39;s the definition of a C++
function that some C code needs to call, or because it&#39;s a C function
that some C++ code needs to call.
</p><p>
For the example given right at the start of this page, it&#39;s easy to
see that there&#39;s a good chance someone has forgotten this <code>extern
&#34;C&#34;</code> declaration in their link of C and C++ together.
</p><blockquote><div><pre>g++ -o test1 test1a.o test1b.o
test1a.o(.text+0x18): In function `main&#39;:
: undefined reference to `findmax(int, int)&#39;
collect2: ld returned 1 exit status
</pre></div></blockquote>
The big hint here is that the error message includes a function
signature—it&#39;s not just complaining about plain old
<code>findmax</code> missing.  In other words, the C++ code is
actually looking for something like &#34;<code>_Z7findmaxii</code>&#34; but only finding
&#34;<code>findmax</code>&#34;, and so it fails to link.
<p>
<SPAN size="-1">By the way, note that an <code>extern
&#34;C&#34;</code> linkage declaration is ignored for member functions (7.5.4
of the C++ standard).</SPAN>
</p><h3><a name="staticinit">Initialization of Statics</a></h3>
<p>
The next feature that C++ has over C that affects the linker is the
ability to have object <i>constructors</i>.  A constructor is a piece
of code that sets up the contents of an object; as such it is
conceptually equivalent to an initializer value for a variable but
with the key practical difference that it involves arbitrary pieces of
code.
</p><p>
Recall from <a href="#cfile">an earlier section</a> that a global
variable can start off with a particular value.  In C, constructing the
initial value of such a global variable is easy: the particular value
is just <a href="#os">copied from the data segment</a> of the executable
file into the relevant place in the memory for the soon-to-be-running
program.
</p><p>
In C++, the construction process is allowed to be much more
complicated than just copying in a fixed value; all of the code in the
various constructors for the class hierarchy has to be run, before the
program itself starts running properly.
</p><p>
To deal with this, the compiler includes some extra information in the
object files for each C++ file; specifically, the list of constructors
that need to be called for this particular file.  At link time, the
linker combines all of these individual lists into one big list, and
includes code that goes through the list one by one, calling all of
these global object constructors.
</p><p>
Note that the <i>order</i> in which all of these constructors for
global objects get called is not defined—it&#39;s entirely at the
mercy of what the linker chooses to do. (See Scott Meyers&#39; Effective
C++ for more details—Item 47 in the
<a href="http://www.amazon.com/gp/product/0201924889">second
edition</a>, Item 4 in the
<a href="http://www.amazon.com/gp/product/0321334876">third edition</a>).
</p><p>
We can hunt down these lists by once again using <code>nm</code>.
Consider the following C++ file:
</p><blockquote><div><pre>

class Fred {
private:
  int x;
  int y;
public:
  Fred() : x(1), y(2) {}
  Fred(int z) : x(z), y(3) {}
};

Fred theFred;
Fred theOtherFred(55);
</pre></div>
For this code, the (demangled) output of <code>nm</code> gives:
<div><pre>


Symbols from global_obj.o:

Name                  Value   Class        Type         Size     Line  Section

__gxx_personality_v0|        |   U  |            NOTYPE|        |     |*UND*
__static_initialization_and_destruction_0(int, int)|00000000|   t  |              FUNC|00000039|     |.text
Fred::Fred(int)        |00000000|   W  |              FUNC|00000017|     |.text._ZN4FredC1Ei
Fred::Fred()        |00000000|   W  |              FUNC|00000018|     |.text._ZN4FredC1Ev
theFred             |00000000|   B  |            OBJECT|00000008|     |.bss
theOtherFred        |00000008|   B  |            OBJECT|00000008|     |.bss
global constructors keyed to theFred  |0000003a|   t  |              FUNC|0000001a|     |.text
</pre></div></blockquote>
<p>
There are various things here, but the one we&#39;re interested in is the
two entries with class as <b>W</b> (which indicates a &#34;weak&#34; symbol)
and with section names like
&#34;<code>.gnu.linkonce.t.<i>stuff</i></code>&#34;.  These are the markers
for global object constructors, and we can see that the corresponding
&#34;Name&#34; fields look sensible—one for each of the two constructors
used.
</p><h3><a name="templates">Templates</a></h3>
<p>
In an earlier section, we gave <a href="#maxfns">an example</a> of three
different versions of a <code>max</code> function, each of which took
different types of argument.  However, we can see that the lines of
source code for these three functions are absolutely identical, and it
seems a shame to have to copy and paste identical code.
</p><p>
C++ introduces the idea of <i>templates</i> to allow code like this to
be written once and for all.  We can create a header file
<code>max_template.h</code> with the single unique code for <code>max</code>:
</p><blockquote><div><pre>template &lt;class T&gt;
T max(T x, T y)
{
  if (x&gt;y) return x;
  else return y;
}
</pre></div>
and include this header file in C++ code to use the templated function:
<div><pre>#include &#34;max_template.h&#34;

int main()
{
  int a=1;
  int b=2;
  int c;
  c = max(a,b);  // Compiler automatically figures out that max&lt;int&gt;(int,int) is needed
  double x = 1.1;
  float y = 2.2;
  double z;
  z = max&lt;double&gt;(x,y); // Compiler can&#39;t resolve, so force use of max<double>(double,double)
  return 0;
}
</double></pre></div></blockquote>
<p>
This C++ file uses both
<code>max&lt;int&gt;(int,int)</code>
and <code>max&lt;double&gt;(double,double)</code>, but a different C++
file might use different instantiations of the template—say
<code>max&lt;float&gt;(float,float)</code>
or even
<code>max&lt;MyFloatingPointClass&gt;(MyFloatingPointClass,MyFloatingPointClass)</code>.
</p><p>
Each of these different instantiations of the template involves
different actual machine code, so by the time that the program is
finally linked, the compiler and linker need to make sure that
every instantiation of the template that is used has code included
into the program (and no unused template instantiations are included
to bloat the program size).
</p><p>
So how do they do this?  There are normally two ways of arranging
this: by folding duplicate instantiations, or by deferring
instantiation until link time (I like to refer to these as the sane
way and the Sun way).
</p><p>
For the duplicate instantiation approach, each object file contains
the code for all of the templates that it uses.  For the particular
example C++ file above, the contents of the object file are:
</p><blockquote><div><pre>


Symbols from max_template.o:

Name                  Value   Class        Type         Size     Line  Section

__gxx_personality_v0|        |   U  |            NOTYPE|        |     |*UND*
double max&lt;double&gt;(double, double)   |00000000|   W  |              FUNC|00000041|     |.text._Z3maxIdET_S0_S0_
int max&lt;int&gt;(int, int)   |00000000|   W  |              FUNC|00000021|     |.text._Z3maxIiET_S0_S0_
main                |00000000|   T  |              FUNC|00000073|     |.text
</pre></div></blockquote>
and we can see that both <code>max&lt;int&gt;(int,int)</code>
and <code>max&lt;double&gt;(double,double)</code> are present.
<p>
These definitions are listed as <i>weak symbols</i>, and this means
that when the linker produces the final executable program, it can
throw away all but one of these duplicate definitions (and if it&#39;s
feeling generous, it can check that all the duplicate definitions
actually look like they are the same code).  The most significant
downside of this approach is that all of the individual object files
take up much more room on the hard disk.
</p><p>
The other approach (which is used by the Solaris C++ compiler suite) is
to include none of the template definitions in the object files, but
instead to leave them all as undefined symbols.  When it comes to link
time, the linker can collect together all of the undefined symbols
that actually correspond to template instantiations, and go and
generate the machine code for these instantiations there and then.
</p><p>
This saves space in the individual object files, but has the
disadvantage that the linker needs to keep track of where the header
file containing the source code, and needs to be able to invoke the
C++ compiler at link time (which may slow down the link).
</p><h2><a name="dlopen">Dynamically Loaded Libraries</a></h2>
<p>
The last feature that we&#39;ll talk about on this page is the dynamic
loading of shared libraries. <a href="#sharedlibs">A previous section</a>
described how using shared libraries means that the
final link is deferred until the moment when the program is run.  On
modern systems, it&#39;s possible to defer linking to even later than that.
</p><p>
This is done with a pair of system calls, <code>dlopen</code> and
<code>dlsym</code> (the rough Windows equivalents of these are called
<code>LoadLibrary</code> and <code>GetProcAddress</code>).  The first
of these takes the name of a shared library and loads it into the
address space of the running process.  Of course, this extra library
may itself have undefined symbols, so this call to <code>dlopen</code>
may also trigger the loading of other shared libraries.
</p><p>
<SPAN size="-1">The <code>dlopen</code> also allows the choice of
whether to resolve all of these references at the instant that the
library is loaded (<code>RTLD_NOW</code>), or one by one as each
undefined reference is hit (<code>RTLD_LAZY</code>).  The first way
means that the <code>dlopen</code> call takes much longer, but the
second way involves the slight risk that sometime later the program
will discover that there is an undefined reference that can&#39;t be
resolved—at which point, the program will be terminated.</SPAN>
</p><p>
Of course, there&#39;s no way for a symbol from the dynamically loaded
library to have a name.  However, as ever with programming problems,
this is easily solved by adding an extra level of indirection—in
this case, by using a pointer to the space for the symbol, rather than
referring to it by name. The call <code>dlsym</code> takes a string
parameter that gives the name of the symbol to be found, and returns a
pointer to its location (or <code>NULL</code> if it can&#39;t be found).
</p><h3><a name="dlopencpp">Interaction with C++ Features</a></h3>
<p>
This dynamic loading feature is all very spangly, but how does it
interact with the various C++ features that affect the overall
behavior of linkers?
</p><p>
The first observation is that mangled names are a bit tricky. When
<code>dlsym</code> is called, it takes a string containing the name of
the symbol to be found.  This has to be the linker-visible version of
the name; in other words, the mangled version of the name.
</p><p>
Because the particular name mangling schemes can vary from platform to
platform and from compiler to compiler, this means that it&#39;s pretty
much impossible to dynamically locate a C++ symbol in a portable way.
Even if you&#39;re happy to stick to one particular compiler and delve
around in its internals, there are more problems in store—for
anything other than vanilla C-like functions, you have to worry about
pulling vtables and such like.
</p><p>
All in all, it&#39;s usually best to just stick to having a single, well
known <code>extern &#34;C&#34;</code> entrypoint that can be
<code>dlsym</code>ed; this entrypoint can be a factory method that
returns pointers to full instances of a C++ class, allowing all of the
C++ goodness to be accessed.
</p><p>
The compiler can sort out constructors for global objects in a
<code>dlopen</code>ed library because there are a couple of special
symbols that can be defined in the library and which
the linker (whether load-time or run-time) will call when the
library is dynamically loaded or unloaded—so the necessary
constructor and destructor calls can be put there.
<span>In Unix these are functions called <code>_init</code> and
<code>_fini</code>, or for more
recent systems using the GNU toolchain, these are any functions
marked with <code>__attribute__((constructor))</code> or
<code>__attribute__((destructor))</code>.  In Windows,
the relevant function is <code>DllMain</code>
with a reason parameter or <code>DLL_PROCESS_ATTACH</code>
or <code>DLL_PROCESS_DETACH</code>.</span>
</p><p>
Finally, dynamic loading works fine with the &#34;fold duplicates&#34;
approach to template instantiation, but is much trickier with the
&#34;compile templates at link time&#34; approach—in this case, &#34;link
time&#34; is after the program is running (and possibly on a different
machine than holds the source code).  Check the compiler &amp; linker
documentation for ways round this.
</p><h2><a name="moredetails">More Details</a></h2>
<p>
The contents of this page have deliberately skipped a lot of details
about how linkers work, because I&#39;ve found that the level of
description here covers 95% of the everyday problems that programmers
encounter with the link steps for their programs.
</p><p>
If you want to go further, some additional references are:
</p><ul>
 <li><a href="http://www.amazon.com/exec/obidos/tg/detail/-/1558604960">
 John Levine, <i>Linkers and Loaders</i></a>: contains lots and lots
 of information about the details of linkers and loaders work,
 including all the <a href="#relocation">things I&#39;ve skipped</a>
 here.  There also appears to be an online version of it (or an
 early draft of it) <a href="http://www.iecc.com/linker">here</a></li>
 <li><a href="http://0xfe.blogspot.com/2006/03/how-os-x-executes-applications.html">Excellent
 link</a> on the Mach-O format for binaries on Mac OS X [Added 27-Mar-06]</li>
 <li><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0131774298/">
 Peter Van Der Linden, <i>Expert C Programming</i></a>: excellent book
 which includes more information about how C code <a href="#os">transforms into a running program</a> than any other
 C text I&#39;ve encountered</li>
 <li><a href="http://www.amazon.com/exec/obidos/tg/detail/-/020163371X">
 Scott Meyers, <i>More Effective C++</i></a>: Item 34 covers the
 pitfalls of combining C and C++ in the same program (whether
 linker-related or not).</li>
 <li><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0201543303/">
 Bjarne Stroustrup, <i>The Design and Evolution of C++</i></a>:
 section 11.3 discusses <a href="#cppcompiler">linkage in C++</a> and
 how it came about</li>
 <li><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0201514591/">
 Margaret A. Ellis &amp; Bjarne Stroustrup, <i>The Annotated C++
 Reference Manual</i></a>: section 7.2c describes one
 <a href="#namemangling">particular name mangling scheme</a></li>
 <li><a href="http://www.skyfree.org/linux/references/ELF_Format.pdf">ELF format reference [PDF]</a></li>
 <li>Two interesting articles on
   <a href="http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html">creating
     tiny Linux executables</a> and a
   <a href="http://blog.ksplice.com/2010/03/libc-free-world/">minimal Hello World</a> in
   particular.</li>
 <li><a href="http://www.akkadia.org/drepper/dsohowto.pdf">&#34;How To Write Shared Libraries&#34; [PDF]</a> by
   <a href="http://www.akkadia.org/drepper/">Ulrich Drepper</a> has more details on ELF and relocation.</li>
</ul>
<p>
Many thanks to Mike Capp and Ed Wilson for useful suggestions about this page.
</p><hr/>
<p>Copyright (c) 2004-2005,<span>2009-2010</span> David Drysdale</p>

<p>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or any
later version published by the Free Software Foundation; with no Invariant
Sections, with no Front-Cover Texts, and with no Back-Cover Texts.  A copy
of the license is available
<a href="http://www.gnu.org/copyleft/fdl.html">here</a>.</p>
<hr/>
<p><a href="http://www.lurklurk.org/">Back to Home Page</a></p>
<hr/>
<p><a href="mailto:dmd at_sign_here lurklurk dot_here org">Contact me</a></p>


</div>
  </body>
</html>
