<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bitfieldconsulting.com/posts/constraints">Original</a>
    <h1>Constraints in Go</h1>
    
    <div id="readability-page-1" class="page"><div data-block-type="23" id="block-yui_3_17_2_1_1710022019086_133076"><div><blockquote>
<p><em>Design is the beauty of turning constraints into
advantages.</em></p>
</blockquote>
<p>This is the fourth in a four-part series of tutorials on generics in
Go.</p>
<ol type="1">
<li><a href="https://bitfieldconsulting.com/posts/generics">Generics</a></li>
<li><a href="https://bitfieldconsulting.com/posts/type-parameters">Type parameters</a></li>
<li><a href="https://bitfieldconsulting.com/posts/generic-types">Generic types</a></li>
<li><strong>Constraints</strong></li>
</ol>
<hr/>
<p>In my book <a href="https://bitfieldconsulting.com/books/generics">Know Go</a>, and in the previous
tutorials in this series, you’ll learn all about generic programming in
Go and the new universe of programs it opens up to us. Ironically, one
of the new features of Go that gives us the most freedom is
<em>constraints</em>. Let’s talk about that, and explain the
paradox.</p>
<p>We saw in the <a href="https://bitfieldconsulting.com/posts/generic-types">previous tutorial</a>
that when we’re writing generic functions that take any type, the range
of things we can <em>do</em> with values of that type is necessarily
rather limited. For example, we can’t add them together. For that, we’d
need to be able to prove to Go that they’re one of the types that
support the <code>+</code> operator.</p>
<h2 id="method-set-constraints">Method set constraints</h2>
<p>It’s the same with interfaces, as we discussed in the <a href="https://bitfieldconsulting.com/posts/generics">first post</a> in this series. The empty
interface, <code>any</code>, is implemented by every type, and so
knowing that something implements <code>any</code> tells you nothing
distinctive about it.</p>
<h3 id="limitations-of-the-any-constraint">Limitations of the
<code>any</code> constraint</h3>
<p>Similarly, in a generic function parameterised by some type T,
constraining T to <code>any</code> doesn’t give Go any information about
it. So it has no way to guarantee that a given operator, such as
<code>+</code>, will work with values of T.</p>
<p>A Go proverb says:</p>
<blockquote>
<p><em>The bigger the interface, the weaker the abstraction.</em></p>
</blockquote>
<p>And the same is true of constraints. The broader the constraint, and
thus the more types it allows, the less we can guarantee about what
operations we can do on them.</p>
<p>There <em>are</em> a few things we can do with <code>any</code>
values, as you already know, because we’ve done them. For example, we
can declare variables of that type, we can assign values to them, we can
return them from functions, and so on.</p>
<p>But we can’t really do a whole lot of <em>computation</em> with them,
because we can’t use operators like <code>+</code> or <code>-</code>. So
in order to be able to do something useful with values of T, such as
adding them, we need more restrictive constraints.</p>
<p>What kinds of constraints <em>could</em> there be on T? Let’s examine
the possibilities.</p>
<h3 id="basic-interfaces">Basic interfaces</h3>
<p>One kind of constraint that we’re already familiar with in Go is an
<em>interface</em>. In fact, all constraints are interfaces of a kind,
but let’s use the term <em>basic</em> interface here to avoid any
confusion. A basic interface, we’ll say, is one that contains only
method elements.</p>
<p>For example, the <code>fmt.Stringer</code> interface we saw in the <a href="https://bitfieldconsulting.com/posts/generics">first tutorial</a>:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Stringer <span>interface</span> <span>{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    String<span>()</span> <span>string</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>We’ve seen that we can write an ordinary, non-generic function that
takes a parameter of type <code>Stringer</code>. And we can also use
this interface as a type constraint for a generic function.</p>
<p>For example, we could write a generic function parameterised by some
type T, but this time T can’t be just any type. Instead, we’ll say that
whatever T turns out to be, it must implement the
<code>fmt.Stringer</code> interface:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>func</span> Stringify<span>[</span>T fmt<span>.</span>Stringer<span>](</span>s T<span>)</span> <span>string</span> <span>{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span>return</span> s<span>.</span>String<span>()</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>This is clear enough, and it works the same way as the generic
functions we’ve already written. The only new thing is that we used the
constraint <code>Stringer</code> instead of <code>any</code>. Now when
we actually call this function in a program, we’re only allowed to pass
it arguments that implement <code>Stringer</code>.</p>
<p>What would happen, then, if we tried to call <code>Stringify</code>
with an argument that <em>doesn’t</em> implement <code>Stringer</code>?
We feel instinctively that this shouldn’t work, and it doesn’t:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>fmt<span>.</span>Println<span>(</span>Stringify<span>(</span><span>1</span><span>))</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>// int does not implement Stringer (missing method String)</span></span></code></pre></div>
<p>That makes sense. It’s just the same as if we wrote an ordinary,
non-generic function that took a parameter of type
<code>Stringer</code>, as we did in the <a href="https://bitfieldconsulting.com/posts/generics">first
tutorial</a>.</p>
<p>There’s no advantage to writing a generic function in this case,
since we can use this interface type directly in an ordinary function.
All the same, a basic interface—one defined by a set of methods—is a
valid constraint for type parameters, and we can use it that way if we
want to.</p>
<h3 id="exercise-stringy-beans">Exercise: Stringy beans</h3>
<p>Flex your generics muscles a little now, by writing a generic
function constrained by <code>fmt.Stringer</code> to solve the <a href="https://github.com/bitfield/know-go/tree/main/exercises/stringy"><code>stringy</code></a>
exercise.</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>type</span> greeting <span>struct</span><span>{}</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>greeting<span>)</span> String<span>()</span> <span>string</span> <span>{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>&#34;Howdy!&#34;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span>func</span> TestStringifyTo_PrintsToSuppliedWriter<span>(</span>t <span>*</span>testing<span>.</span>T<span>)</span> <span>{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    t<span>.</span>Parallel<span>()</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    buf <span>:=</span> <span>&amp;</span>bytes<span>.</span>Buffer<span>{}</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    stringy<span>.</span>StringifyTo<span>[</span>greeting<span>](</span>buf<span>,</span> greeting<span>{})</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    want <span>:=</span> <span>&#34;Howdy!</span><span>\n</span><span>&#34;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    got <span>:=</span> buf<span>.</span>String<span>()</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span>if</span> want <span>!=</span> got <span>{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        t<span>.</span>Errorf<span>(</span><span>&#34;want %q, got %q&#34;</span><span>,</span> want<span>,</span> got<span>)</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>(<a href="https://github.com/bitfield/know-go/blob/main/exercises/stringy/stringy_test.go">Listing
<code>exercises/stringy</code></a>)</p>
<p><strong>GOAL:</strong> Your job here is to write a generic function
<code>StringifyTo[T]</code> that takes an <code>io.Writer</code> and a
value of some arbitrary type constrained by <code>fmt.Stringer</code>,
and prints the value to the writer.</p>
<hr/>
<p><strong>HINT:</strong> This is a bit like the
<code>PrintAnything</code> function we saw before, isn’t it? Actually,
it’s a “print anything stringable” function. We already know what the
constraint is (<code>fmt.Stringer</code>), and the rest is
straightforward.</p>
<hr/>
<p><strong>SOLUTION:</strong> Here’s a version that would work, for
example:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>func</span> StringifyTo<span>[</span>T fmt<span>.</span>Stringer<span>](</span>w io<span>.</span>Writer<span>,</span> p T<span>)</span> <span>{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    fmt<span>.</span>Fprintln<span>(</span>w<span>,</span> p<span>.</span>String<span>())</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>(<a href="https://github.com/bitfield/know-go/blob/main/solutions/stringy/stringy.go">Listing
<code>solutions/stringy</code></a>)</p>
<p>Strictly speaking, of course, we don’t really need to call the
<code>String</code> method: <code>fmt</code> already knows how to do
that automagically. But if we just passed <code>p</code> directly, we
wouldn’t need the <code>Stringer</code> constraint, and we could use
<code>any</code>… but what would be the fun in that?</p>
<h2 id="type-set-constraints">Type set constraints</h2>
<p>We’ve seen that one way an interface can specify an allowed range of
types is by including a <em>method element</em>, such as
<code>String() string</code>. That would be a basic interface, but now
let’s introduce another kind of interface. Instead of listing methods
that the type must have, it directly specifies a set of types that are
allowed.</p>
<h3 id="type-elements">Type elements</h3>
<p>For example, suppose we wanted to write some generic function
<code>Double</code> that multiplies a number by two, and we want a type
constraint that allows only values of type <code>int</code>. We know
that <code>int</code> has no methods, so we can’t use any basic
interface as a constraint. How can we write it, then?</p>
<p>Well, here’s how:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>type</span> OnlyInt <span>interface</span> <span>{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span>int</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Very straightforward! It looks just like a regular interface
definition, except that instead of method elements, it contains a single
<em>type element</em>, consisting of a named type. In this case, the
named type is <code>int</code>.</p>
<h3 id="using-a-type-set-constraint">Using a type set constraint</h3>
<p>How would we use a constraint like this? Let’s write
<code>Double</code>, then:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>func</span> Double<span>[</span>T OnlyInt<span>](</span>v T<span>)</span> T <span>{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span>return</span> v <span>*</span> <span>2</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>In other words, for some T that satisfies the constraint
<code>OnlyInt</code>, <code>Double</code> takes a T parameter and
returns a T result.</p>
<p>Note that we now have one answer to the sort of problem we
encountered with <code>AddAnything</code>: how to enable the
<code>*</code> operator (or any other arithmetic operator) in a
parameterised function. Since T can only be <code>int</code> (thanks to
the <code>OnlyInt</code> constraint), Go can guarantee that the
<code>*</code> operator will work with T values.</p>
<p>It’s not the complete answer, though, since there are other types
that support <code>*</code> that <em>wouldn’t</em> be allowed by this
constraint. And in any case, if we were only going to support
<code>int</code>, we could have just written an ordinary function that
took an <code>int</code> parameter.</p>
<p>So we’ll need to be able to expand the range of types allowed by our
constraint a little, but not beyond the types that support
<code>*</code>. How can we do that?</p>
<h3 id="unions">Unions</h3>
<p>What types <em>can</em> satisfy the constraint <code>OnlyInt</code>?
Well, only <code>int</code>! To broaden this range, we can create a
constraint specifying more than one named type:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Integer <span>interface</span> <span>{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span>int</span> <span>|</span> <span>int8</span> <span>|</span> <span>int16</span> <span>|</span> <span>int32</span> <span>|</span> <span>int64</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>The types are separated by the pipe character, <code>|</code>. You
can think of this as representing “or”. In other words, a type will
satisfy this constraint if it is <code>int</code> <em>or</em>
<code>int8</code> <em>or</em>… you get the idea.</p>
<p>This kind of interface element is called a <em>union</em>. The type
elements in a union can include any Go types, including interface
types.</p>
<p>It can even include other constraints. In other words, we can
<em>compose</em> new constraints from existing ones, like this:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Float <span>interface</span> <span>{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span>float32</span> <span>|</span> <span>float64</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span>type</span> Complex <span>interface</span> <span>{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span>complex64</span> <span>|</span> <span>complex128</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span>type</span> Number <span>interface</span> <span>{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    Integer <span>|</span> Float <span>|</span> Complex</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>We’re saying that <code>Integer</code>, <code>Float</code>, and
<code>Complex</code> are all unions of different built-in numeric types,
but we’re also creating a new constraint <code>Number</code>, which is a
union of those three <em>interface</em> types we just defined. If it’s
an integer, a float, or a complex number, then it’s a number!</p>
<h3 id="the-set-of-all-allowed-types">The set of all allowed types</h3>
<p>The <em>type set</em> of a constraint is the set of all types that
satisfy it. The type set of the empty interface (<code>any</code>) is
the set of all types, as you’d expect.</p>
<p>The type set of a union element (such as <code>Float</code> in the
previous example) is the union of the type sets of all its terms.</p>
<p>In the <code>Float</code> example, which is the union of
<code>float32 | float64</code>, its type set contains
<code>float32</code>, <code>float64</code>, and no other types.</p>
<h3 id="intersections">Intersections</h3>
<p>You probably know that with a basic interface, a type must have
<em>all</em> of the methods listed in order to implement the interface.
And if the interface contains other interfaces, a type must implement
<em>all</em> of those interfaces, not just one of them.</p>
<p>For example:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>type</span> ReaderStringer <span>interface</span> <span>{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    io<span>.</span>Reader</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    fmt<span>.</span>Stringer</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>If we were to write this as an <em>interface literal</em>, we would
separate the methods with a semicolon instead of a newline, but the
meaning is the same:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>interface</span> <span>{</span> io<span>.</span>Reader<span>;</span> fmt<span>.</span>Stringer <span>}</span></span></code></pre></div>
<p>To implement this interface, a type has to implement <em>both</em>
<code>io.Reader</code> <em>and</em> <code>fmt.Stringer</code>. Just one
or the other isn’t good enough.</p>
<p>Each line of an interface definition like this, then, is treated as a
distinct type element. The type set of the interface as a whole is the
<em>intersection</em> of the type sets of all its elements. That is,
only those types that all the elements have in common.</p>
<p>So putting interface elements on different lines has the effect of
requiring a type to implement <em>all</em> those elements. We don’t need
this kind of interface very often, but we can imagine cases where it
might be necessary.</p>
<h3 id="empty-type-sets">Empty type sets</h3>
<p>You might be wondering about what happens if we define an interface
whose type set is completely empty. That is, if there are no types that
can satisfy the constraint.</p>
<p>Well, that could happen with an intersection of two type sets that
have <em>no</em> elements in common. For example:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Unpossible <span>interface</span> <span>{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span>int</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span>string</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Clearly no type can be both <code>int</code> and <code>string</code>
at the same time! Or, to put it another way, this interface’s type set
is empty.</p>
<p>If we try to instantiate a function constrained by
<code>Unpossible</code>, we’ll find, naturally enough, that it can’t be
done:</p>
<pre><code>cannot implement Unpossible (empty type set)</code></pre>
<p>We probably wouldn’t do this on purpose, since an unsatisfiable
constraint doesn’t seem that useful. But with more sophisticated
interfaces, we might accidentally reduce the allowed type set to zero,
and it’s helpful to know what this error message means so that we can
fix the problem.</p>
<h2 id="composite-type-literals">Composite type literals</h2>
<p>A <em>composite</em> type is one that’s built up from other types. We
saw some composite types in the <a href="https://bitfieldconsulting.com/posts/generic-types">previous
tutorial</a>, such as <code>[]E</code>, which is a slice of some element
type E.</p>
<p>But we’re not restricted to defined types with names. We can also
construct new types on the fly, using a <em>type literal</em>: that is,
literally writing out the type definition as part of the interface.</p>
<h3 id="a-struct-type-literal">A struct type literal</h3>
<p>For example, this interface specifies a <em>struct</em> type
literal:</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Pointish <span>interface</span> <span>{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span>struct</span><span>{</span> X<span>,</span> Y <span>int</span> <span>}</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>A type parameter with this constraint would allow any instance of
such a struct. In other words, its type set contains exactly one type:
<code>struct{ X, Y int }</code>.</p>
<h3 id="access-to-struct-fields">Access to struct fields</h3>
<p>While we can write a generic function constrained by some struct type
such as <code>Pointish</code>, there are limitations on what that
function can do with that type. One is that it can’t access the struct’s
<em>fields</em>:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>func</span> GetX<span>[</span>T Pointish<span>](</span>p T<span>)</span> <span>int</span> <span>{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span>return</span> p<span>.</span>X</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span>// p.X undefined (type T has no field or method X)</span></span></code></pre></div>
<p>In other words, we can’t refer to a field on <code>p</code>, even
though the function’s constraint explicitly says that any <code>p</code>
is guaranteed to be a struct with at least the field <code>X</code>.
This is a limitation of the Go compiler that has not yet been overcome.
Sorry about that.</p>
<h2 id="some-limitations-of-type-sets">Some limitations of type
sets</h2>
<p>An interface containing type elements can <em>only</em> be used as a
constraint on a type parameter. It can’t be used as the type of a
variable or parameter declaration, like a basic interface can. That too
is something that might change in the future, but this is where we are
today.</p>
<h3 id="constraints-versus-basic-interfaces">Constraints versus basic
interfaces</h3>
<p>What exactly stops us from doing that, though? We already know that
we can write functions that take ordinary parameters of some basic
interface type such as <code>Stringer</code>. So what happens if we try
to do the same with an interface containing type elements, such as
<code>Number</code>?</p>
<p>Let’s see:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>func</span> Double<span>(</span>p Number<span>)</span> Number <span>{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span>// interface contains type constraints</span></span></code></pre></div>
<p>This doesn’t compile, for the reasons we’ve discussed. Some potential
confusion arises from the fact that a basic interface can be used as
both a regular interface type <em>and</em> a constraint on type
parameters. But interfaces that contain type elements can only be used
as constraints.</p>
<h3 id="constraints-are-not-classes">Constraints are not classes</h3>
<p>If you have some experience with languages that have <em>classes</em>
(hierarchies of types), then there’s another thing that might trip you
up with Go generics: constraints are not classes, and you can’t
instantiate a generic function or type on a constraint interface.</p>
<p>To illustrate, suppose we have some concrete types <code>Cow</code>
and <code>Chicken</code>:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Cow <span>struct</span><span>{</span> moo <span>string</span> <span>}</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span>type</span> Chicken <span>struct</span><span>{</span> cluck <span>string</span> <span>}</span></span></code></pre></div>
<p>And suppose we define some interface <code>Animal</code> whose type
set consists of <code>Cow</code> and <code>Chicken</code>:</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Animal <span>interface</span> <span>{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    Cow <span>|</span> Chicken</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>So far, so good, and suppose we now define a generic type
<code>Farm</code> as a slice of <code>T Animal</code>:</p>

<p>Since we know the type set of <code>Animal</code> contains exactly
<code>Cow</code> and <code>Chicken</code>, then either of those types
can be used to instantiate <code>Farm</code>:</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>dairy <span>:=</span> Farm<span>[</span>Cow<span>]{}</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>poultry <span>:=</span> Farm<span>[</span>Chicken<span>]{}</span></span></code></pre></div>
<p>What about <code>Animal</code> itself? Could we create a
<code>Farm[Animal]</code>? No, because there’s no such type as
<code>Animal</code>. It’s a type <em>constraint</em>, not a type, so
this gives an error:</p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>mixed <span>:=</span> Farm<span>[</span>Animal<span>]{}</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span>// interface contains type constraints</span></span></code></pre></div>
<p>And, as we’ve seen, we also couldn’t use <code>Animal</code> as the
type of some variable, or ordinary function parameter. Only basic
interfaces can be used this way, not interfaces containing type
elements.</p>
<h2 id="approximations">Approximations</h2>
<p>Let’s return to our earlier definition of an interface
<code>Integer</code>, consisting of a union of named types.
Specifically, the built-in signed integer types:</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Integer <span>interface</span> <span>{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span>int</span> <span>|</span> <span>int8</span> <span>|</span> <span>int16</span> <span>|</span> <span>int32</span> <span>|</span> <span>int64</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>We know that the type set of this interface contains all the types
we’ve named. But what about defined types whose <em>underlying</em> type
is one of the built-in types?</p>
<h3 id="limitations-of-named-types">Limitations of named types</h3>
<p>For example:</p>

<p>Is <code>MyInt</code> also in the type set of <code>Integer</code>?
Let’s find out. Suppose we write a generic function that uses this
constraint:</p>
<div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span>func</span> Double<span>[</span>T Integer<span>](</span>v T<span>)</span> T <span>{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span>return</span> v <span>*</span> <span>2</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Can we pass it a <code>MyInt</code> value? We’ll soon know:</p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>fmt<span>.</span>Println<span>(</span>Double<span>(</span>MyInt<span>(</span><span>1</span><span>)))</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span>// MyInt does not implement Integer</span></span></code></pre></div>
<p>No. That makes sense, because <code>Integer</code> is a list of named
types, and we can see that <code>MyInt</code> isn’t one of them.</p>
<p>How can we write an interface that allows not only a set of specific
named types, but also any other types <em>derived</em> from them?</p>
<h3 id="type-approximations">Type approximations</h3>
<p>We need a new kind of type element: a <em>type approximation</em>. We
write it using the tilde (<code>~</code>) character:</p>
<div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span>type</span> ApproximatelyInt <span>interface</span> <span>{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span>~</span><span>int</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>The type set of <code>~int</code> includes <code>int</code> itself,
but also any type whose underlying type is <code>int</code> (for
example, <code>MyInt</code>).</p>
<p>If we rewrite <code>Double</code> to use this constraint, we can pass
it a <code>MyInt</code>, which is good. Even better, it will accept
<em>any</em> type, now or in the future, whose underlying type is
<code>int</code>.</p>
<h3 id="derived-types">Derived types</h3>
<p>Approximations are especially useful with struct type elements.
Remember our <code>Pointish</code> interface?</p>
<div id="cb27"><pre><code><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Pointish <span>interface</span> <span>{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span>struct</span><span>{</span> x<span>,</span> y <span>int</span> <span>}</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Let’s write a generic function with this constraint:</p>
<div id="cb28"><pre><code><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span>func</span> Plot<span>[</span>T Pointish<span>](</span>p T<span>)</span> <span>{</span></span></code></pre></div>
<p>We can pass it values of type <code>struct{ x, y int }</code>, as
you’d expect:</p>
<div id="cb29"><pre><code><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>p <span>:=</span> <span>struct</span><span>{</span> x<span>,</span> y <span>int</span> <span>}{</span><span>1</span><span>,</span> <span>2</span><span>}</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>Plot<span>(</span>p<span>)</span></span></code></pre></div>
<p>But now comes a problem: we can’t pass values of any <em>named</em>
struct type, even if the struct definition itself matches the constraint
perfectly:</p>
<div id="cb30"><pre><code><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Point <span>struct</span> <span>{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    x<span>,</span> y <span>int</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>p <span>:=</span> Point<span>{</span><span>1</span><span>,</span> <span>2</span><span>}</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>Plot<span>(</span>p<span>)</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span>// Point does not implement Pointish (possibly missing ~ for</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span>// struct{x int; y int} in constraint Pointish)</span></span></code></pre></div>
<p>What’s the problem here? Our constraint allows
<code>struct{ x, y int }</code>, but <code>Point</code> is <em>not that
type</em>. It’s a type <em>derived</em> from it. And, just as with
<code>MyInt</code>, a derived type is distinct from its underlying
type.</p>
<p>You know now how to solve this problem: use a type approximation! And
Go is telling us the same thing: “Hint, hint: I think you meant to write
a <code>~</code> in your constraint.”</p>
<p>If we add that approximation, the type set of our interface expands
to encompass all types derived from the specified struct, including
<code>Point</code>:</p>
<div id="cb31"><pre><code><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Pointish <span>interface</span> <span>{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span>~</span><span>struct</span><span>{</span> x<span>,</span> y <span>int</span> <span>}</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<h3 id="exercise-a-first-approximation">Exercise: A first
approximation</h3>
<p>Can you use what you’ve just learned to solve the <a href="https://github.com/bitfield/know-go/tree/main/exercises/intish"><code>intish</code></a>
challenge?</p>
<p>Here you’re provided with a function <code>IsPositive</code>, which
determines whether a given value is greater than zero:</p>
<div id="cb32"><pre><code><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span>func</span> IsPositive<span>[</span>T Intish<span>](</span>v T<span>)</span> <span>bool</span> <span>{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span>return</span> v <span>&gt;</span> <span>0</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>(<a href="https://github.com/bitfield/know-go/blob/main/exercises/intish/intish.go">Listing
<code>exercises/intish</code></a>)</p>
<p>And there’s a set of accompanying tests that instantiate this
function on some derived type <code>MyInt</code>:</p>
<div id="cb33"><pre><code><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span>type</span> MyInt <span>int</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span>func</span> TestIsPositive_IsTrueFor1<span>(</span>t <span>*</span>testing<span>.</span>T<span>)</span> <span>{</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    t<span>.</span>Parallel<span>()</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    input <span>:=</span> MyInt<span>(</span><span>1</span><span>)</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>!</span>intish<span>.</span>IsPositive<span>(</span>input<span>)</span> <span>{</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>        t<span>.</span>Errorf<span>(</span><span>&#34;IsPositive(1): want true, got false&#34;</span><span>)</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span>func</span> TestIsPositive_IsFalseForNegative1<span>(</span>t <span>*</span>testing<span>.</span>T<span>)</span> <span>{</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    t<span>.</span>Parallel<span>()</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    input <span>:=</span> MyInt<span>(-</span><span>1</span><span>)</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    <span>if</span> intish<span>.</span>IsPositive<span>(</span>input<span>)</span> <span>{</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>        t<span>.</span>Errorf<span>(</span><span>&#34;IsPositive(-1): want false, got true&#34;</span><span>)</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a><span>func</span> TestIsPositive_IsFalseForZero<span>(</span>t <span>*</span>testing<span>.</span>T<span>)</span> <span>{</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>    t<span>.</span>Parallel<span>()</span></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>    input <span>:=</span> MyInt<span>(</span><span>0</span><span>)</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>    <span>if</span> intish<span>.</span>IsPositive<span>(</span>input<span>)</span> <span>{</span></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>        t<span>.</span>Errorf<span>(</span><span>&#34;IsPositive(0): want false, got true&#34;</span><span>)</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>(<a href="https://github.com/bitfield/know-go/blob/main/exercises/intish/intish_test.go">Listing
<code>exercises/intish</code></a>)</p>
<p><strong>GOAL:</strong> Your task here is to define the
<code>Intish</code> interface.</p>
<hr/>
<p><strong>HINT:</strong> A method set won’t work here, because the
<code>int</code> type <em>has</em> no methods! On the other hand, the
type literal <code>int</code> won’t work either, because
<code>MyInt</code> is not <code>int</code>, it’s a new type derived from
it.</p>
<p>What kind of constraint could you use instead? I think you know where
this is going, don’t you? If not, have another look at the previous
section on type approximations.</p>
<hr/>
<p><strong>SOLUTION:</strong> It’s not complicated, once you know that a
type approximation is required:</p>
<div id="cb34"><pre><code><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Intish <span>interface</span> <span>{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span>~</span><span>int</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>(<a href="https://github.com/bitfield/know-go/blob/main/solutions/intish/intish.go">Listing
<code>solutions/intish</code></a>)</p>
<h2 id="interface-literals">Interface literals</h2>
<p>Up to now, we’ve always used type parameters with a <em>named</em>
constraint, such as <code>Integer</code> (or even just
<code>any</code>). And we know that those constraints are defined as
interfaces. So could we use an <em>interface literal</em> as a type
constraint?</p>
<h3 id="syntax-of-an-interface-literal">Syntax of an interface
literal</h3>
<p>An interface literal, as you probably know, consists of the keyword
<code>interface</code> followed by curly braces containing (optionally)
some interface elements.</p>
<p>For example, the simplest interface literal is the empty interface,
<code>interface{}</code>, which is common enough to have its own
predeclared name, <code>any</code>.</p>
<p>We should be able to write this empty interface literal wherever
<code>any</code> is allowed as a type constraint, then:</p>
<div id="cb35"><pre><code><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span>func</span> Identity<span>[</span>T <span>interface</span><span>{}](</span>v T<span>)</span> T <span>{</span></span></code></pre></div>
<p>And so we can. But we’re not restricted to only <em>empty</em>
interface literals. We could write an interface literal that contains a
method element, for example:</p>
<div id="cb36"><pre><code><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span>func</span> Stringify<span>[</span>T <span>interface</span><span>{</span> String<span>()</span> <span>string</span> <span>}](</span>s T<span>)</span> <span>string</span> <span>{</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span>return</span> s<span>.</span>String<span>()</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>This is a little hard to read at first, perhaps. But we’ve already
seen this exact function before, only in that case it had a
<em>named</em> constraint <code>Stringer</code>. We’ve simply replaced
that name with the corresponding interface literal:</p>
<div id="cb37"><pre><code><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span>interface</span><span>{</span> String<span>()</span> <span>string</span> <span>}</span></span></code></pre></div>
<p>That is, the set of types that have a <code>String</code> method. We
don’t need to name this interface in order to use it as a constraint,
and sometimes it’s clearer to write it as a literal.</p>
<h3 id="omitting-the-interface-keyword">Omitting the
<code>interface</code> keyword</h3>
<p>And we’re not limited to just method elements in interface literals
used as constraints. We can use type elements too:</p>

<p>Conveniently, in this case we can omit the enclosing
<code>interface { ... }</code>, and write simply <code>~int</code> as
the constraint:</p>

<p>For example, we could write some function <code>Increment</code>
constrained to types derived from <code>int</code>:</p>
<div id="cb40"><pre><code><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span>func</span> Increment<span>[</span>T <span>~</span><span>int</span><span>](</span>v T<span>)</span> T <span>{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span>return</span> v <span>+</span> <span>1</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>However, we can only omit the <code>interface</code> keyword when the
constraint contains exactly one type element. Multiple elements wouldn’t
be allowed, so this doesn’t work:</p>
<div id="cb41"><pre><code><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span>func</span> Increment<span>[</span>T <span>~</span><span>int</span><span>;</span> <span>~</span><span>float64</span><span>](</span>v T<span>)</span> T <span>{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span>// syntax error: unexpected semicolon in parameter list; possibly </span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span>// missing comma or ]</span></span></code></pre></div>
<p>And we can’t omit <code>interface</code> with method elements
either:</p>
<div id="cb42"><pre><code><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span>func</span> Increment<span>[</span>T String<span>()</span> <span>string</span><span>](</span>v T<span>)</span> T <span>{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span>// syntax error: unexpected ( in parameter list; possibly </span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span>// missing comma or ]</span></span></code></pre></div>
<p>And we can only omit <code>interface</code> in a constraint
<em>literal</em>. We can’t omit it when defining a named constraint. So
this doesn’t work, for example:</p>
<div id="cb43"><pre><code><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Intish <span>~</span><span>int</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span>// syntax error: unexpected ~ in type declaration</span></span></code></pre></div>
<h3 id="referring-to-type-parameters">Referring to type parameters</h3>
<p>We’ve seen that in certain cases, instead of having to define it
separately, we can write a constraint directly as an interface literal.
So you might be wondering: can we refer to T inside the interface
literal itself? Yes, we can.</p>
<p>To see why we might need to do that, suppose we wanted to write a
generic function <code>Contains[T]</code>, that takes a slice of T and
tells you whether or not it contains a given value.</p>
<p>And suppose that we’ll determine this, for any particular element of
the slice, by calling some <code>Equal</code> method on the element.
That means we must constrain the function to only types that have a
suitable <code>Equal</code> method.</p>
<p>So the constraint for T is going to be an interface containing the
method <code>Equal(T) bool</code>, let’s say.</p>
<p>Can we do this? Let’s try:</p>
<div id="cb44"><pre><code><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span>func</span> Contains<span>[</span>T <span>interface</span><span>{</span> Equal<span>(</span>T<span>)</span> <span>bool</span> <span>}](</span>s <span>[]</span>T<span>,</span>  v T<span>)</span> <span>bool</span> <span>{</span></span></code></pre></div>
<p>Yes, this is fine. In fact, using an interface literal is the
<em>only</em> way to write this constraint. We couldn’t have created
some <em>named</em> interface type to do the same thing. Why not?</p>
<p>Let’s see what happens if we try:</p>
<div id="cb45"><pre><code><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span>type</span> Equaler <span>interface</span> <span>{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    Equal<span>(???)</span> <span>bool</span> <span>// we can&#39;t say &#39;T&#39; here</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Because the type parameter T is part of the <code>Equal</code> method
signature, and we don’t <em>have</em> T here. The only way to refer to T
is in an interface literal inside a type constraint:</p>
<div id="cb46"><pre><code><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span>[</span>T <span>interface</span><span>{</span> Equal<span>(</span>T<span>)</span> <span>bool</span> <span>}]</span></span></code></pre></div>
<p>At least, we can’t write a <em>specific</em> interface that mentions
T in its method set. What we’d need here, in fact, is a <em>generic</em>
interface, and you’ll learn how to define and use these in my book, <a href="https://bitfieldconsulting.com/posts/generics">Know Go</a>. If these tutorials have given you an
appetite for generic programming in Go, I think you’ll really enjoy the
book—check it out!</p>
<h3 id="exercise-greater-love">Exercise: Greater love</h3>
<p>Your turn now to see if you can solve the <a href="https://github.com/bitfield/know-go/tree/main/exercises/greater"><code>greater</code></a>
exercise.</p>
<p>You’ve been given the following (incomplete) function:</p>
<div id="cb47"><pre><code><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span>func</span> IsGreater<span>[</span>T <span>/* Your constraint here! */</span><span>](</span>x<span>,</span> y T<span>)</span> <span>bool</span> <span>{</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span>return</span> x<span>.</span>Greater<span>(</span>y<span>)</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>(<a href="https://github.com/bitfield/know-go/blob/main/exercises/greater/greater.go">Listing
<code>exercises/greater</code></a>)</p>
<p>This takes two values of some arbitrary type, and compares them by
calling the <code>Greater</code> method on the first value, passing it
the second value.</p>
<p>The tests exercise this function by calling it with two values of a
defined type <code>MyInt</code>, which has the required
<code>Greater</code> method.</p>
<div id="cb48"><pre><code><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span>type</span> MyInt <span>int</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>m MyInt<span>)</span> Greater<span>(</span>v MyInt<span>)</span> <span>bool</span> <span>{</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span>return</span> m <span>&gt;</span> v</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a><span>func</span> TestIsGreater_IsTrueFor2And1<span>(</span>t <span>*</span>testing<span>.</span>T<span>)</span> <span>{</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    t<span>.</span>Parallel<span>()</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>!</span>greater<span>.</span>IsGreater<span>(</span>MyInt<span>(</span><span>2</span><span>),</span> MyInt<span>(</span><span>1</span><span>))</span> <span>{</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>        t<span>.</span>Fatalf<span>(</span><span>&#34;IsGreater(2, 1): want true, got false&#34;</span><span>)</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a><span>func</span> TestIsGreater_IsFalseFor1And2<span>(</span>t <span>*</span>testing<span>.</span>T<span>)</span> <span>{</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>    t<span>.</span>Parallel<span>()</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    <span>if</span> greater<span>.</span>IsGreater<span>(</span>MyInt<span>(</span><span>1</span><span>),</span> MyInt<span>(</span><span>2</span><span>))</span> <span>{</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>        t<span>.</span>Fatalf<span>(</span><span>&#34;IsGreater(1, 2): want false, got true&#34;</span><span>)</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>(<a href="https://github.com/bitfield/know-go/blob/main/exercises/greater/greater_test.go">Listing
<code>exercises/greater</code></a>)</p>
<p><strong>GOAL:</strong> To make these tests pass, you’ll need to write
an appropriate type constraint for <code>IsGreater</code>. Can you see
what to do?</p>
<hr/>
<p><strong>HINT:</strong> Remember, we got here by talking about
constraints as interface literals, and in particular, interface literals
that refer to the type parameter.</p>
<p>If you try to define some <em>named</em> interface with the method
set containing <code>Greater</code>, for example, that won’t work. We
can’t do it for the same reason that we couldn’t define a named
interface with the method set <code>Equal</code>: we don’t know what
type of argument that method takes.</p>
<p>Just like <code>Equal</code>, <code>Greater</code> takes arguments of
some arbitrary type T, so we need an interface literal that can
<em>refer</em> to T in its definition. Does that help?</p>
<hr/>
<p><strong>SOLUTION:</strong> Here’s one way to do it:</p>
<div id="cb49"><pre><code><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span>func</span> IsGreater<span>[</span>T <span>interface</span><span>{</span> Greater<span>(</span>T<span>)</span> <span>bool</span> <span>}](</span>x<span>,</span> y T<span>)</span> <span>bool</span> <span>{</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span>return</span> x<span>.</span>Greater<span>(</span>y<span>)</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>(<a href="https://github.com/bitfield/know-go/blob/main/solutions/greater/greater.go">Listing
<code>solutions/greater</code></a>)</p>
<p>Like most things, it’s delightfully simple once you know. For a type
parameter T, the required interface is:</p>

<p>And that’s how we do that.</p>
<p>Well, I hope you enjoyed this tutorial series, and if so, why not
treat yourself to a copy of <a href="https://bitfieldconsulting.com/books/generics">Know Go</a>?
There’s much more to explore, so I’d love you to come along with me for
the ride.</p>
</div></div></div>
  </body>
</html>
