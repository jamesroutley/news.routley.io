<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jetpack.io/blog/why-did-nix-adopt-flakes/">Original</a>
    <h1>Why did Nix adopt Flakes?</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
    <article>

        <header>

            

            

            <p>Learn how Nix Flakes improve the composability and reproducibility of builds in Nix and Devbox.</p>

            <div>
                <section>

                    <ul>
                        <li>
                            <a href="http://harihareswara.net/blog/author/savil/">
                                <img src="https://res-1.cloudinary.com/jetpack-io/image/upload/q_auto/v1/blog/23_savil_photo-2.jpg" alt="Savil Vastava"/>
                            </a>
                        </li>
                    </ul>

                    <div>
                        
                        <p><time datetime=" 2023-06-16">Jun 16, 2023</time>
                            <span><span>•</span> 4 min read</span>
                        </p>
                    </div>

                </section>
            </div>

            <figure>
                <img srcset="https://images.unsplash.com/photo-1545858908-bc6fee2bd44d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fHNub3dmbGFrZXN8ZW58MHx8fHwxNjg2OTQwOTc0fDA&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000 300w, https://images.unsplash.com/photo-1545858908-bc6fee2bd44d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fHNub3dmbGFrZXN8ZW58MHx8fHwxNjg2OTQwOTc0fDA&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000 600w,
                    https://images.unsplash.com/photo-1545858908-bc6fee2bd44d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fHNub3dmbGFrZXN8ZW58MHx8fHwxNjg2OTQwOTc0fDA&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000 1000w, https://images.unsplash.com/photo-1545858908-bc6fee2bd44d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fHNub3dmbGFrZXN8ZW58MHx8fHwxNjg2OTQwOTc0fDA&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="https://images.unsplash.com/photo-1545858908-bc6fee2bd44d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fHNub3dmbGFrZXN8ZW58MHx8fHwxNjg2OTQwOTc0fDA&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" alt="Why did Nix adopt Flakes?"/>
                <figcaption>Photo by <a href="https://unsplash.com/@dariuscotoi?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit">Darius Cotoi</a> / <a href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit">Unsplash</a></figcaption>
            </figure>

        </header>

        <section>
            <p>When we first <a href="https://github.com/jetpack-io/devbox/">started work</a> on <a href="https://www.jetpack.io/devbox">Devbox</a>, we relied on the “stable” nix commands, but the documentation was full of these <a href="https://nixos.org/manual/nix/stable/command-ref/experimental-commands.html">experimental commands</a> that were dependent on something called Flakes. Our customers would also reach out for ways of integrating custom packages into their projects.  Upon investigating different approaches, we realized that Flakes provided a flexible solution.</p><p>But just what do Flakes do, and why were they introduced in the first place? Piecing this together from various sources took me some time. Hopefully, this first-principles approach helps you understand their motivation faster than I could.</p><p>First, we’ll need to learn about two Nix concepts and how they lead to two different problems that Flakes solve:</p><ol><li><strong>Nix derivations,</strong> which lead to composability problems</li><li><strong>Nix channels,</strong> which lead to composability and package version pinning problems</li></ol><h2 id="nix-derivations"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Nix Derivations</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></h2><p>To build a package with Nix, we start by defining a <strong><strong><strong><strong><strong>derivation</strong></strong></strong></strong></strong>. Think of a derivation as a build task, and we’ll gloss over the <a href="https://nixos.org/manual/nix/stable/language/derivations.html">details</a> for now.</p><h3 id="defining-derivations-in-defaultnix">Defining Derivations in <strong><strong><strong><strong><strong><strong><strong>default.nix</strong></strong></strong></strong></strong></strong></strong></h3><p>Most projects will define their derivations using a <code>default.nix</code> file, which Nix uses as the default instructions for building a package.</p><p>As an example, let’s look at the <code>hello</code> project’s <code>default.nix</code> <a href="https://github.com/NixOS/nixpkgs/blob/56904d7c423f2b13b37fbd29f39bbb4b52bc7824/pkgs/applications/misc/hello/default.nix">here</a>:</p><pre><code>{ stdenv, fetchurl }:

stdenv.mkDerivation rec {
  name = &#34;hello-2.10&#34;;

  src = fetchurl {
    url = &#34;mirror://gnu/hello/${name}.tar.gz&#34;;
    sha256 = &#34;0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i&#34;;
  };

  doCheck = true;

  meta = {
    description = &#34;A program that produces a familiar, friendly greeting&#34;;
    longDescription = &#39;&#39;
      GNU Hello is a program that prints &#34;Hello, world!&#34; when you run it.
      It is fully customizable.
    &#39;&#39;;
    homepage = http://www.gnu.org/software/hello/manual/;
    license = stdenv.lib.licenses.gpl3Plus;
    maintainers = [ stdenv.lib.maintainers.eelco ];
    platforms = stdenv.lib.platforms.all;
  };
}
</code></pre><p>To build this derivation, Nix will do:</p><ol><li><code>nix-instantiate</code>. This step translates a high-level nix expression into nix-store expressions.</li><li><code>nix-store --realize</code> where “realized” means “built”. It will build the store derivation and produce an output path like <code>/nix/store/giwwxmq37cvfanwlhz6k38793qmhxq76-hello-2.12.1</code>.</li></ol><p>The problem is that <code>default.nix</code> allows too much freedom for users. It can produce a derivation, a set, a function or maybe something else. This harms composability, since the build outputs from the <code>default.nix</code> are not standardized or deterministic. Another nix derivation will not know exactly how to consume an arbitrary <code>default.nix</code> that some external package has defined.</p><h2 id="nix-channels-and-version-pinning"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Nix Channels and Version Pinning</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></h2><p>The traditional way that users install Nix packages is through <em>channels</em>. Channels can be <a href="https://matthewbauer.us/blog/channel-changing.html">thought of</a> as “the CI-tested branch of NixOS/Nixpkgs”.</p><p>Nix Channels exist to distribute a <em>coherent</em> set of nix packages. By <em>coherent,</em> I mean that every package that depends on <code>openssl</code> has been updated to depend on the specific version of <code>openssl</code> in that nix channel distribution. The packages in a channel are expected to work together.</p><p>But Nix Channels have a few problems:</p><ul><li>Channels do not compose well. While one can have multiple channels active at the same time, doing so requires the user to download and evaluate the index of each channel they use. This can be tricky to manage, and often leads to poor performance and excessive disk usage. In other words, there isn’t an easy way to piecemeal update certain packages from the channel, while keeping the other packages stable.</li><li>Pinning a channel can lead to skew for packages that update frequently. For example, many users may choose to pin the <code>nixpkgs</code> stable channel, but this is infrequently updated and so may miss out on updates from packages that are faster moving.</li></ul><h2 id="so-why-nix-flakes"><strong>So, why Nix Flakes?</strong></h2><p>Summarizing from above, Flakes solve two critical problems:</p><ol><li>Nix flakes define a schema with standardized inputs and outputs to solve the <strong>composability</strong> problem that Nix Derivations have.</li><li>Nix flakes also introduce <strong><strong><strong><strong><strong><strong><strong>pinning</strong></strong></strong></strong></strong></strong></strong> for all dependencies by having a lockfile to solve the problem that Nix Channels have.</li></ol><p>Lets look at an example <code>flake.nix</code> file. This flake has a single input which is the latest <code>nixpkgs</code> . It also has two programs <code>hello</code> and <code>cowsay</code> which it exports as outputs.</p><pre><code>
{
  inputs = { nixpkgs.url = &#34;github:nixos/nixpkgs&#34;; };

  outputs = { self, nixpkgs }:

    let pkgs = nixpkgs.legacyPackages.x86_64-darwin;
    in {
      packages.x86_64-darwin.hello = pkgs.hello;
      packages.x86_64-darwin.cowsay = pkgs.cowsay;
      packages.x86_64-darwin.default = self.packages.x86_64-darwin.hello;
   };
}
</code></pre><p>To exercise this:</p><pre><code>&gt; nix run .#hello
Hello, world!

&gt; nix run .#cowsay -- flakes are neat
 _________________
&lt; flakes are neat &gt;
 -----------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||

# oh why not:
&gt; nix run .#cowsay -- $(nix run .#hello)
 _______________
&lt; Hello, world! &gt;
 ---------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
</code></pre><p>The <code>flake.nix</code> above can be imported into another consumer <code>flake.nix</code> which wants to <strong>compose</strong> its functionality of <code>hello</code> and <code>cowsay</code> with its own custom logic.</p><p>Exercising this flake also generates a <code>flake.lock</code> . This <strong>pins the exact version of nixpkgs</strong> that will run everytime this flake is subsequently exercised. As a result, <code>hello</code> and <code>cowsay</code> will also resolve to the very same binaries every time.</p><pre><code>&gt; cat flake.lock
{
  &#34;nodes&#34;: {
    &#34;nixpkgs&#34;: {
      &#34;locked&#34;: {
        &#34;lastModified&#34;: 1686862348,
        &#34;narHash&#34;: &#34;sha256-XcxE6PJ6OqtsC73J+D/N2qttW7x69zoKt9QbMQy3jSk=&#34;,
        &#34;owner&#34;: &#34;nixos&#34;,
        &#34;repo&#34;: &#34;nixpkgs&#34;,
        &#34;rev&#34;: &#34;6d402731689fbeb403b03a0f486b8c8a26530d5a&#34;,
        &#34;type&#34;: &#34;github&#34;
      },
      &#34;original&#34;: {
        &#34;owner&#34;: &#34;nixos&#34;,
        &#34;repo&#34;: &#34;nixpkgs&#34;,
        &#34;type&#34;: &#34;github&#34;
      }
    },
    &#34;root&#34;: {
      &#34;inputs&#34;: {
        &#34;nixpkgs&#34;: &#34;nixpkgs&#34;
      }
    }
  },
  &#34;root&#34;: &#34;root&#34;,
  &#34;version&#34;: 7
}
</code></pre><p>If a <code>flake.nix</code> imports a package using that package&#39;s flake, then the package&#39;s flake metadata will get added to the <code>flake.lock</code>. This provides a path beyond Nix Channels to track packages that update more frequently.</p><p>There’s a lot <a href="https://www.jetpack.io/blog/using-nix-flakes-with-devbox/">more</a> to Flakes, if you look under the hood. The awesome nix maintainers have exploited a lot of these properties for better performance, reproducibility, and composition. Thank you!</p><h2 id="more-reading"><strong>More Reading</strong></h2><p>There are several references on <em>using</em> Flakes out there. The references below are focussed on helping understand the <em>motivation</em> behind Flakes, Channels and related features of nix.</p><ol><li>Flakes MVP: <a href="https://gist.github.com/edolstra/40da6e3a4d4ee8fd019395365e0772e7">https://gist.github.com/edolstra/40da6e3a4d4ee8fd019395365e0772e7</a></li><li><a href="https://www.reddit.com/r/Nix/comments/u1psl5/differences_between_channels_and_flakes/">https://www.reddit.com/r/Nix/comments/u1psl5/differences_between_channels_and_flakes/</a></li><li><a href="https://serokell.io/blog/practical-nix-flakes">https://serokell.io/blog/practical-nix-flakes</a></li><li><a href="https://github.com/NixOS/nixpkgs/issues/93327">https://github.com/NixOS/nixpkgs/issues/93327</a> ← user was very confused about what channels are and what pinning is, but posted a good summary at the bottom.</li><li><a href="https://matthewbauer.us/blog/channel-changing.html">https://matthewbauer.us/blog/channel-changing.html</a></li><li><a href="https://matthewbauer.us/blog/all-the-versions.html">https://matthewbauer.us/blog/all-the-versions.html</a></li><li><a href="https://zimbatm.com/notes/summary-of-nix-flakes-vs-original-nix">https://zimbatm.com/notes/summary-of-nix-flakes-vs-original-nix</a></li></ol><h2 id="nix-flakes-at-devbox">Nix Flakes at Devbox</h2><p>Flakes have been transformational to the internals of how Devbox operates. Some of our prior posts delve into this:</p><ul><li><a href="https://www.jetpack.io/blog/using-nix-flakes-with-devbox/">Using Nix Flakes With Devbox</a></li><li><a href="https://www.jetpack.io/blog/0-5-0-install-nix-packages-by-version/">Find And Install Nix Packages by Version With Devbox</a></li></ul><p>We have more changes in the pipeline to make Devbox the most delightful package manager to use, while preserving the important properties of Nix. Stay tuned!</p><p>If you&#39;d like to keep up with our progress, you can follow us on <a href="https://twitter.com/jetpack_io">Twitter</a>, or chat with our developers on our <a href="https://discord.gg/jetpack-io">Discord Server</a>. We also welcome issues and pull requests on our <a href="https://github.com/jetpack-io/devbox">Github Repo</a></p>
        </section>


    </article>
    </div></div>
  </body>
</html>
