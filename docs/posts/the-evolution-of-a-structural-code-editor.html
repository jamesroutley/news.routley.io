<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://crowdhailer.me/2025-01-02/the-evolution-of-a-structural-code-editor/">Original</a>
    <h1>The evolution of a structural code editor</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>The top image shows the structural editor, and shell, for the <a href="https://eyg.run">eyg</a> programming language running on a phone.
Later on I‚Äôll show it running on a TV.
On both devices the structural editor is a better coding experience than a text editor would be.</p>

<p>This post outlines the evolution of the editor over several years, and highlights the major changes over time along with some design thoughts and implementation notes.
The web editor is built in <a href="https://gleam.run/">Gleam</a> and <a href="https://github.com/lustre-labs/lustre">Lustre</a>; originally it was <a href="https://gleam.run/">Gleam</a> and <a href="https://svelte.dev/">Svelte</a>. 
There also exists a terminal based structural <a href="https://vimeo.com/827006232">editor built in Go</a>.</p>

<p>Want to jump in and code with it? The latest version is at <a href="https://eyg.run">eyg</a>.</p>

<h2 id="why-build-a-structural-editor">Why build a structural editor?</h2>

<p>Structural editors, also known as projectional editors, enhance writing, editing and understanding code. Unlike traditional text-based editors, these tools treat code as a structured tree rather than a flat sequence of characters.</p>

<p><em>This structured data may be the Abstract Syntax Tree(AST) of the represented program, however it can also be a different structure.
For this post I won‚Äôt quibble over the differences.</em></p>

<p>Some traditional editors have tools that understand the code structure, for example autocomplete.
However in most cases these tools work as suggestions and a traditional text editor will accept any input.</p>

<p>I define a structural editor as one that does not accept invalid or arbitrary input.
Changes to the program always proceed through well known states.</p>

<p>This clarification is important because the editors I talk about here render the program to the user as text, but it‚Äôs important to note that there is no way to enter arbitrary text.</p>

<p>The benefits of a structural editor are:</p>

<ol>
  <li>
    <p><strong>No syntax errors.</strong>
  Zero time is spent on missing quotes, semi-colons or other details.</p>
  </li>
  <li>
    <p><strong>Better type information.</strong>
Because the program is always in a valid state the type checker can always run and give meaningful feedback.</p>
  </li>
  <li>
    <p><strong>No keywords</strong>
Variables can be called <code>var</code> and functions called <code>fn</code>. Either can also be called üß™ or <code>!_//</code> though maybe they shouldn‚Äôt be.</p>
  </li>
  <li>
    <p><strong>Rich visualisations</strong>
A program can be shown as box and wires, or boolean logic operators. On a smaller scale a record of latitude and longitude can be shown on a map.</p>
  </li>
  <li>
    <p><strong>Reduced complexity</strong>
There is no lexer or parser so issues like <a href="https://gleam.run/news/fault-tolerant-gleam/">fault tolerant parsing</a> are entirely circumvented.</p>
  </li>
</ol>

<p>Several other structed editor projects exist. Jetbrains has <a href="https://www.jetbrains.com/mps/">MPS</a> which targets creating your own domain specific languges.
<a href="https://tylr.fun/">Tylr</a> is a beautiful example but currently only good for one line of code at a time.</p>

<h2 id="an-adhoc-first-attempt">An adhoc first attempt</h2>

<p>This is my first recording of the structural editor - admire the minimalistic and clean look.</p>

<p><iframe src="https://player.vimeo.com/video/664401317?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write" title="Week 1"></iframe></p>

<p>The first generation editor worked by directly editing the AST with no effort to hide the details from the user.</p>

<p>Pressing <code>a</code> increased the selection by moving the current selection to the parent node, <code>j/k</code> moved to the previous/next node and
<code>i</code> entered insert mode on the current node. You might see the vim influence of these bindings.</p>

<p>This first version got a few things right.
The command pallet approach in particular is very nice.
It allows you to put a lot of help with certain actions. 
For example when creating a variable the pallet can show all the variables in scope at that position.</p>

<p>At the outset the AST design was driven by the development of the editor, one single enum represented all the expressions in the program.
This is the complete expression type from that time.</p>
<pre><code>pub type Node(m, g) {
  Binary(value: String)
  Tuple(elements: List(Expression(m, g)))
  Record(fields: List(#(String, Expression(m, g))))
  Access(value: Expression(m, g), key: String)
  Tagged(tag: String, value: Expression(m, g))
  Variable(label: String)
  Let(pattern: Pattern, value: Expression(m, g), then: Expression(m, g))
  Function(pattern: Pattern, body: Expression(m, g))
  Call(function: Expression(m, g), with: Expression(m, g))
  Case(
    value: Expression(m, g),
    branches: List(#(String, Pattern, Expression(m, g))),
  )
  Hole
  Provider(config: String, generator: Generator, generated: g)
}
</code></pre>

<p>The update function, called when you press a key in the editor,
was a huge case statement for each combination of key pressed and current position in the tree.
This approach although simple didn‚Äôt scale with complexity.
The AST was used by the editor, type checker and code generation so it was not possible to adapt it to the requirements of any particular use case.</p>

<p>In this first version too many concerns were rolled into one project.</p>

<p><em>The <code>Provider</code> node is my implementation of type providers and not part of this story.
But you can see other videos in my <a href="https://petersaxton.uk/log/">log</a> about them.</em></p>

<p>This first effort eventually ground to a halt under its complexity.</p>

<h2 id="a-simple-ast">A simple AST</h2>

<p>As a rich AST could not work for all usecases I focused on creating the simplest AST.
Complexity for type checking or editing would move to the appropriate modules.</p>

<pre><code>pub type Expression {
  Variable(label: String)
  Lambda(label: String, body: Expression)
  Apply(func: Expression, argument: Expression)
  Let(label: String, definition: Expression, body: Expression)
  Vacant(comment: String)
  Binary(value: BitArray)
  // .. other primitives for integer, string and builtins
  Empty
  Extend(label: String)
  Select(label: String)
  // .. other operators for lists, unions, effects and references
}
</code></pre>

<p>This AST was the result, it still looks almost <a href="https://github.com/CrowdHailer/eyg-lang/blob/8a2a5c0a82ea99a321cfe8e7a0f6cbecaac4f97a/eyg/src/eygir/expression.gleam#L22-L61">identical today</a></p>

<p>By making all features of the language first class, there is a minimal number of compound nodes in the tree. 
Only <code>Lambda</code>, <code>Apply</code> and <code>Let</code> contain child expressions.</p>

<p>To create the record literal <code>{name: &#34;Eve&#34;}</code> required the following expression</p>
<pre><code>Apply(Apply(Extend(label: &#34;name&#34;), String(&#34;Eve&#34;)), Empty)
</code></pre>

<p>This change makes interpretation and type checking much simpler, take my word for it.</p>

<p>It also simplifies several details of the editor for example:
Positions in the tree are denoted by a list of integers where each integer identifies the child node.
This path is followed from the root node until the required point in the tree.</p>

<p>This <code>step</code> function implements one step of following that path, it takes an expression and goes to n‚Äôth child.
Only the three nodes mentioned have to be taken into account by the <code>step</code> function.
It is known that asking for a child of any other kind of node is an error.
This means that variants can be added/removed to the <code>Expression</code> type without in any way modifying or moving around the tree.</p>

<pre><code>pub fn step(exp, n) {
  case exp, n {
    e.Lambda(param, body), 0 -&gt; Ok(#(body, e.Lambda(param, _)))
    e.Apply(func, arg), 0 -&gt; Ok(#(func, e.Apply(_, arg)))
    e.Apply(func, arg), 1 -&gt; Ok(#(arg, e.Apply(func, _)))
    e.Let(label, value, then), 0 -&gt; Ok(#(value, e.Let(label, _, then)))
    e.Let(label, value, then), 1 -&gt; Ok(#(then, e.Let(label, value, _)))
    _, _ -&gt; Error(&#34;invalid path&#34;)
  }
}
</code></pre>

<p>This change didn‚Äôt effect the external look of the editor but it did substantially clean up the implementation.</p>

<h2 id="text-editing-is-intuitive-familiar">Text editing is <del>intuitive</del> familiar</h2>

<p>Moving around the code was tricky in the previous editor. 
This was because the order of nodes in the tree might not match the order they were shown on screen.</p>

<p>For example selecting the field from a record.</p>

<pre><code>let x = user.name
</code></pre>
<p>If <code>user</code> is selected, to move to <code>name</code> required moving left and another move left would jump back to the <code>x</code> of the variable declaration.</p>

<p>This is because the <code>.</code> syntax is sugar for calling the select operator on the variable user. 
In all other cases arguments come after the function but, for select, reversing the order it‚Äôs projected to the user makes more sense.</p>

<pre><code>Apply(Select(&#34;name&#34;), Variable(&#34;user&#34;))
</code></pre>

<p>Making transformations directly on the AST felt powerful but there were too many occasions where an understanding of the AST was needed to know how to move.</p>

<p>The next version aimed to fix the navigation issue by keeping a cursor centric approach.
This means that one key press of left moves the cursor one position left and a key press of right moves the cursor one position right.</p>

<p>Even with moving back to a text based navigation I wanted a fully structural editor so that the program was always a valid structure.</p>

<p>Traditional editors have similar behaviour, for example: when typing <code>(</code> an automatic <code>)</code> is often placed.
In this way you don‚Äôt go through a state of having unmatched brackets. 
The main difference is in a text editor this bracket matching features are adhoc and many other ways exist to create a syntactically invalid program.</p>

<p>You can see this working here.</p>
<p><iframe src="https://player.vimeo.com/video/833330371?h=9aeaa64b46&amp;badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write" title="05/06/2023, Features of the structured editor"></iframe></p>

<p>This editor was actually quite short lived.
I liked that it showed the type of holes in the program directly in the editor.</p>

<p>However the editor was unintutive in many cases.
Keeping the editor structural but pretending it wasn‚Äôt led to too many inconsistencies.
There were places that typing certain characters would do nothing because the character was invalid.</p>

<p>Implementing this editor got complicated quickly.
Intercepting all keyboard events meant dropping out of Gleam and understanding the <a href="https://javascript.info/selection-range">range and selection</a> API‚Äôs in the browser. This resulted in a lot of <a href="https://github.com/CrowdHailer/eyg-lang/blob/40d1606d50292724970d79a6b1f61926294bc10f/eyg/src/easel_ffi.js">foreign function interface code</a></p>

<p>A positive aside of this effort to go text based meant I wanted better Gleam bindings to the browser API‚Äôs and that need kicked off building <a href="https://github.com/crowdhailer/plinth">plinth</a> a library to do just that.</p>

<h2 id="adding-sugar-and-projections">Adding sugar and projections</h2>

<p>The two previous editors were at opposing ends of a spectrum.
For the first, movement was entirely based on the layout of the AST.
For the second, movement was entirely based on the layout of the text.</p>

<p>I wrote approximately 10k ‚Äúlines‚Äù of EYG code, including a JSON parser and type checker, using the simple AST editor.
Transforming the AST felt very powerful when it worked. However, where the visuals did not match the AST representation navigation was unintuitive.
I eventually mastered it but it was clearly a blocker for anyone else picking up the editor.</p>

<p>This generation of the editor tries to find a middle ground one the spectrum from text to AST.
Navigation is always by whole AST nodes. In addition directions are always consistent with how the program is laid out on screen.</p>

<p>This was achieved by creating a representation of the program specifically for manipulation in the editor. There is:</p>

<ol>
  <li><a href="https://github.com/CrowdHailer/eyg-lang/blob/441e5686c6721373d6b66636c4f1ce73301d60d7/eyg/src/morph/editable.gleam#L11-L30"><code>Editable</code></a> a type which deals with larger code units than the basic AST</li>
  <li><a href="https://github.com/CrowdHailer/eyg-lang/blob/441e5686c6721373d6b66636c4f1ce73301d60d7/eyg/src/morph/projection.gleam#L234-L299"><code>Projection</code></a> a zipper into the <code>Editable</code> type that makes navigation and transforms more efficient.</li>
  <li><a href="https://github.com/CrowdHailer/eyg-lang/blob/441e5686c6721373d6b66636c4f1ce73301d60d7/eyg/src/morph/lustre/frame.gleam#L9-L17"><code>Frame</code></a> an intermediate representation for rendering expressions that track if they are single or multiple lines.</li>
</ol>

<p>The basic AST is still used by the interpreter and type checker so the complexity of presenting code to the user is only in the modules which deal with showing code to a user.</p>

<p><iframe src="https://player.vimeo.com/video/984437518?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write" title="7/15/2024, Structured editor in a code notebook."></iframe></p>

<h2 id="using-the-mouse">Using the mouse</h2>

<p>Working with a keyboard is efficient, but only if you know the key bindings to each action you need.
Which key to press to get a desired action is not discoverable from looking at the UI element.
After all the UI for keyboard actions is just a cursor somewhere in the page.</p>

<p>A user is required to consult a cheatsheet of keyboard actions and learn some before ever getting started.
This friction makes getting started very challenging.</p>

<p>Devices without keyboards have to show virtual keyboards to use keyboard shortcuts.
If the actions are being presented on screen they might as well be shown as something more relevant than the letter code corresponding to the short cut.</p>

<p>This latest iteration adds a menu and icon based UI for each transformation that is possible on the AST.
A question mark button at the top toggles showing text descriptions of each action but at the cost of less screen to work with.
The UI works with keyboard, mouse, touch or TV remote.</p>

<p><img src="https://crowdhailer.me/2025-01-02/the-evolution-of-a-structural-code-editor/tv.jpg" alt=""/></p>

<p>It also works great with a keyboard and if you forget the key, seemlessly switch to the visual.</p>

<p>Implementing the visual UI was simple with Lustre and the state and event approach it has.
Lustre is an implementation of the Elm architecture.</p>

<p>The state of the program works by <a href="https://github.com/CrowdHailer/eyg-lang/blob/441e5686c6721373d6b66636c4f1ce73301d60d7/website/src/website/components/snippet.gleam#L302-L352">switching on key press events</a>.</p>

<pre><code>pub fn update(state, message) {
  let Snippet(status: status, ..,) = state
  case message, status {
    UserPressedCommandKey(key), Editing(Command(_)) -&gt; {
      let state = Snippet(..state, using_mouse: False)
      case key {
        &#34;ArrowRight&#34; -&gt; move_right(state)
        &#34;ArrowLeft&#34; -&gt; move_left(state)
        &#34;ArrowUp&#34; -&gt; move_up(state)
        &#34;ArrowDown&#34; -&gt; move_down(state)
        &#34; &#34; -&gt; search_vacant(state)
        // Needed for my examples while Gleam doesn&#39;t have file embedding
        &#34;Q&#34; -&gt; copy_escaped(state)
        &#34;w&#34; -&gt; call_with(state)
        &#34;E&#34; -&gt; assign_above(state)
        &#34;e&#34; -&gt; assign_to(state)
        &#34;r&#34; -&gt; insert_record(state)
        &#34;t&#34; -&gt; insert_tag(state)
        &#34;y&#34; -&gt; copy(state)
        &#34;Y&#34; -&gt; paste(state)
        // &#34;u&#34; -&gt;
        &#34;i&#34; -&gt; insert_mode(state)
        &#34;o&#34; -&gt; overwrite_record(state)
        &#34;p&#34; -&gt; insert_perform(state)
        &#34;a&#34; -&gt; increase(state)
        &#34;s&#34; -&gt; insert_string(state)
        &#34;d&#34; | &#34;Delete&#34; -&gt; delete(state)
        &#34;f&#34; -&gt; insert_function(state)
        &#34;g&#34; -&gt; select_field(state)
        &#34;h&#34; -&gt; insert_handle(state)
        &#34;j&#34; -&gt; insert_builtin(state)
        &#34;k&#34; -&gt; toggle_open(state)
        &#34;l&#34; -&gt; insert_list(state)
        &#34;#&#34; -&gt; insert_reference(state)
        &#34;z&#34; -&gt; undo(state)
        &#34;Z&#34; -&gt; redo(state)
        // &#34;x&#34; -&gt;
        &#34;c&#34; -&gt; call_function(state)
        &#34;v&#34; -&gt; insert_variable(state)
        &#34;b&#34; -&gt; insert_binary(state)
        &#34;n&#34; -&gt; insert_integer(state)
        &#34;m&#34; -&gt; insert_case(state)
        &#34;M&#34; -&gt; insert_open_case(state)
        &#34;,&#34; -&gt; extend_before(state)
        &#34;EXTEND AFTER&#34; -&gt; extend_after(state)
        &#34;.&#34; -&gt; spread_list(state)
        &#34;TOGGLE SPREAD&#34; -&gt; toggle_spread(state)
        &#34;TOGGLE OTHERWISE&#34; -&gt; toggle_otherwise(state)

        &#34;?&#34; -&gt; #(state, ToggleHelp)
        &#34;Enter&#34; -&gt; execute(state)
        _ -&gt; show_error(state, NoKeyBinding(key))
      }
    }
  }
}
</code></pre>

<p>The UI buttons make use of the same events and update logic.
Each button in the visual UI consists of;</p>

<ul>
  <li>the icon to show (I use the heroicon library and the outline style)</li>
  <li>a text description of the action (which is shown when ‚Äúshow help‚Äù is on)</li>
  <li>the keypress event to dispatch.</li>
</ul>

<pre><code>fn cmd(x) {
  ShellMessage(snippet.UserPressedCommandKey(x))
}

fn item_before() {
  #(outline.arrow_turn_left_down(), &#34;item before&#34;, cmd(&#34;,&#34;))
}

fn item_after() {
  #(outline.arrow_turn_right_down(), &#34;item after&#34;, cmd(&#34;EXTEND AFTER&#34;))
}

fn undo() {
  #(outline.arrow_uturn_left(), &#34;undo&#34;, cmd(&#34;z&#34;))
}

fn redo() {
  #(outline.arrow_uturn_right(), &#34;redo&#34;, cmd(&#34;Z&#34;))
}
</code></pre>

<p><em>There are more actions than available keys so the <code>EXTEND AFTER</code> string value can be dispatched by clicking the correct button, but not by any keyboard binding.</em></p>

<p>Here is the final result, as of today.</p>

<p><iframe src="https://player.vimeo.com/video/1043702197?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write" title="1/3/2025, Fibonacci sequence in visual editor"></iframe></p>


<h2 id="whats-next">What‚Äôs next</h2>

<p>There will be more iterations of the editor but this one is interesting.
I want to see what other people make of the structured editor experience.
You can <a href="https://eyg.run/">try it out now</a> and if you have any opinions please get in touch. <em><a href="https://bsky.app/profile/crowdhailer.bsky.social">Bluesky</a> the best right now</em>.</p>

<p>The EYG language is still developing. References to external packages and better error messages based on effects will be coming soon.
To keep up with that progress join the newsletter.</p>

  <hr/>
  I&#39;m building EYG an experiment in a building better languages and tools; for some measure of better. </div></div>
  </body>
</html>
