<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.appsignal.com/2022/02/15/delayed-job-vs-sidekiq-which-is-better.html">Original</a>
    <h1>Delayed Job vs. Sidekiq</h1>
    
    <div id="readability-page-1" class="page"><p>Most applications need background jobs for mailers, regular clean-ups, or any other time-consuming operation that doesn&#39;t require a user to be present.</p><p>Several gems support job queues and background processing in the Rails world — <a href="https://github.com/collectiveidea/delayed_job">Delayed Job</a> and <a href="https://github.com/mperham/sidekiq">Sidekiq</a> being the two most popular ones.</p><p>In this post, we will take a detailed look at Delayed Job and Sidekiq, including how they fare against each other.</p><div><h2>A Quick Introduction to Delayed Job</h2><p>Delayed Job is a direct extraction from Shopify and uses a table to maintain all background jobs.
It follows a very simple pattern. Any Ruby object that responds to a <code>perform</code> method can be enqueued in the jobs table.</p><p>In addition, if you don&#39;t need to maintain special job objects (although this is highly recommended for testability and clear separation of long-running operations), it also allows you to call <code>.delay.method(params)</code> on any Ruby object. It will process the method in the background.</p><p>The <a href="https://github.com/collectiveidea/delayed_job#queuing-jobs">Delayed Job README</a> does a great job of explaining all common usage patterns.</p><p>Many teams choose Delayed Job because it is simple and uses their already existing database. They don&#39;t need to spend/maintain other resources.</p><p>However, it will still take up space in your database table. If you have too many jobs queued at the same time, you might need more disk space to accommodate them all.</p></div><div><h2>A Quick Introduction to Sidekiq</h2><p>Sidekiq, on the other hand, uses Redis as its data store to maintain all job metadata.
This comes with the obvious benefit of being much faster than the regular database systems Delayed Jobs uses.
In addition to this, each Sidekiq process spawns multiple threads to process the jobs even faster.</p><p>For each background job in Sidekiq, we need a specialized class that includes the <code>Sidekiq::Worker</code> concern and responds to the <code>perform</code> method.
To enqueue the job, we need to call <code>perform_async(arg1, arg2)</code> on the worker with the arguments.</p><p>The <a href="https://github.com/mperham/sidekiq/wiki/Getting-Started">Sidekiq &#39;Getting Started&#39; guide</a> explains this and other usage patterns in good detail.</p></div><div><h2>Using Active Job with Delayed Job or Sidekiq</h2><p>Rails already provides a mature job framework for top-level declaration and handling of jobs.
Both Delayed Job and Sidekiq support running jobs through ActiveJob&#39;s unified API.
Just inherit from <code>ApplicationJob</code> and call <code>perform_later</code> on your job class to enqueue the job to the configured queuing backend.</p><p>The advantage of running jobs with Active Job is that your application code becomes framework agnostic, and switching from Delayed Job to Sidekiq (or vice versa) becomes pretty easy. The <a href="https://edgeapi.rubyonrails.org/classes/ActiveJob/TestHelper.html"><code>ActiveJob::TestHelper</code></a> also makes testing enqueued jobs a breeze.</p><p>But the abstraction provided by Active Job also comes with a performance overhead, as job data has to be wrapped before it&#39;s pushed to the store.
Sidekiq claims that ActiveJob is about 2-20x slower when pushing to Redis, with ~3x the processing overhead.</p></div><div><h2>Delayed Jobs vs. Sidekiq</h2><p>Now that we know the basics of Delayed Jobs and Sidekiq, let&#39;s dive deeper into their differences and what each brings to the table.</p><div><h3>The Features</h3><p>For basic applications, both Sidekiq and Delayed Job provide a good set of features out of the box.
These include assigning job priorities, named queues, and auto-retry on failures.</p><p>Delayed Job also provides a way to configure max run time out of the box (Sidekiq does not).</p><p>Sidekiq, on the other hand, provides support for <a href="https://github.com/mperham/sidekiq/wiki/Middleware">Middleware</a> to update job metadata, skip queuing a job, or execute a job.
Sidekiq supports more callbacks, though <a href="https://github.com/collectiveidea/delayed_job/#hooks">some hooks are available for Delayed Job apps</a>. Instead of callbacks, you can use Delayed Job with Active Job (namely, the <code>before_enqueue</code> and <code>around_perform</code> callbacks inbuilt into Rails).</p><p>Web UI is another feature that comes out of the box with Sidekiq.
This provides historical statistics about jobs and information about workers, currently enqueued and dead jobs.
You can perform operations like deleting or running jobs immediately without going through the console.</p><p>Delayed Job does not have an inbuilt Web UI, but <a href="https://github.com/ejschmitt/delayed_job_web"><code>delayed_job_web</code></a> gives access to a basic Web UI with similar features to Sidekiq&#39;s.</p></div><div><h3>Sidekiq Wins at Performance</h3><p>Performance-wise, Sidekiq beats Delayed Job quite convincingly.
According to <a href="https://github.com/mperham/sidekiq#performance">Sidekiq&#39;s open-source benchmark</a>, it is approximately 30x faster than Delayed Job.
There are two major reasons for this:</p><ol><li>Redis is much faster at querying data than traditional databases like Postgres because it stores data in memory as opposed to the disk.</li><li>Delayed Job runs a single thread to process jobs, compared to Sidekiq, which uses multiple threads.</li></ol><p>While all of this looks great on paper, the differences do not matter much unless you work on a big scale (something like 10k jobs per minute).
The exact number also depends on the average run time of a job. The longer the run time, the less the performance overhead of Delayed Job matters.</p><p>If you&#39;re worried about the performance of Delayed Job, you can make some performance optimizations.
The exact indexes to use will depend on the statistics of your job system.
For example, if you use multiple queues and only one gets a major chunk of jobs, a simple index on the queue column (<code>add_index :delayed_jobs, :queue</code>) can significantly improve performance.</p></div><div><h3>Deployment</h3><p>Both Delayed Job and Sidekiq have a similar deployment strategy for workers.
Using Heroku, you just need to add entries inside your <code>Procfile</code> to start the job processor and run the workers.</p><p>For Sidekiq:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="sh" data-theme="default"><span><span>worker: bundle </span><span>exec</span><span> sidekiq -t 25 -c </span><span>${SIDEKIQ_CONCURRENCY</span><span>:-</span><span>5}</span><span> [-q name,priority [-q another_queue,another_priority]]</span></span></code></pre></div><p>For Delayed Job:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="sh" data-theme="default"><span><span>worker: [QUEUE</span><span>=</span><span>x,y,z] bundle </span><span>exec</span><span> rails jobs:work</span></span></code></pre></div></div><div><h3>Memory</h3><p>Here&#39;s where things start to get a bit more interesting. Sidekiq has a concurrency option to control how many threads it runs.
Most of the Sidekiq vs. Delayed Job benchmarks mention Sidekiq&#39;s very high concurrency of up to 25 threads, which contributes to its super-fast performance.</p><p>But in a real setting, you have to limit the threads to something more conservative.
The actual number depends on how heavy your application is and what kinds of jobs you perform.
What I have seen in practice is that if you run a worker on 512MB memory (equivalent to <code>standard-1x</code> on Heroku), the number of threads is somewhere between 2 and 5 instead of 25.</p><p><a href="https://www.mikeperham.com/2018/04/25/taming-rails-memory-bloat/">&#39;Taming Rails memory bloat&#39; by Mike Perham</a>, the creator of Sidekiq, discusses memory issues in more detail and is well worth a read.
I won&#39;t jump into the full discussion, but he recommends that you set <code>MALLOC_ARENA_MAX=2</code> on all workers that run Sidekiq.</p><p>Using <code>jemalloc</code> instead of regular <code>malloc</code> helps too. The exact way to do this depends on the platform you use, but it is pretty simple on Heroku. Just set <a href="https://github.com/gaffneyc/heroku-buildpack-jemalloc.git">heroku-buildpack-jemalloc</a> as the first buildpack (ahead of the <code>heroku/ruby</code> buildpack).</p></div><div><h3>Delayed Job Uses Simpler Resources</h3><p>As we discussed, Delayed Job runs on your existing database instance.
You might need to increase:</p><ul><li>the available memory</li><li>disk space</li><li>max connections</li></ul><p>depending on the job load or the number of workers you run. But the only resource you need is the job processor.</p><p>On the other hand, Sidekiq requires a Redis instance to handle jobs.
If you also use Redis as a cache store, it is recommended that you use a separate instance configured as a &#34;persistent store&#34; for Sidekiq jobs.</p><p>Since Redis works best when everything fits in memory, if you have too many jobs (for example, if Sidekiq stops processing them for some time due to an issue in the app), it might take some downtime to clear everything up.
This is especially troublesome if you have Redis on the same server as your app.
They will start competing for memory, leading to swapping and eventually destroying your app&#39;s performance.</p><p>One important point to note about Redis is that it has to be configured with <code>maxmemory-policy noeviction</code> to avoid silent drops of Sidekiq&#39;s data.
Otherwise, you will find yourself missing jobs that need to be performed, without any trace.</p><div><h4>A Side-Note: Paid Upgrades in Sidekiq</h4><p>If you need extra features, Sidekiq comes with <code>Pro</code> and <code>Enterprise</code> versions.</p><p>The most notable addition to Pro is <code>Batch Jobs</code> that can run in parallel, be monitored, and interact as a group, invoking a callback when all jobs are done. Pro also has improved reliability features to ensure that no jobs are dropped silently, even during network problems.</p><p>The Enterprise version comes with yet more features. If you are looking for something that a regular Sidekiq installation can&#39;t solve, <a href="https://sidekiq.org/">explore the paid Sidekiq features</a>.</p><p>In practice, the free version of Sidekiq still works great.
But it is good to know that there are paid options you can upgrade to as needed, instead of switching to a different solution.</p></div></div><div><h3>Community and Development Status: Sidekiq Has the Edge</h3><p>There is a huge community behind both Sidekiq and Delayed Job. However, it is not always easy to find quick answers to your questions in StackOverflow or the official documentation.</p><p>On the development side, things are not looking very bright for Delayed Job.
There was some minor work done on Delayed Job in December 2021 and January 2022, but it doesn&#39;t seem like it is getting any major developments going forward. It appears to be in maintenance-only mode, and there are a lot of open issues on Github.</p><p>In contrast, Sidekiq is still under active development, and its creator is working full time on it.
There are very few open issues, and they get addressed regularly.</p></div></div><div><h2>Wrap-up: Sidekiq or Delayed Job? It Depends on Your Needs</h2><p>In this post, we covered two major job processing systems for Rails applications — Sidekiq and Delayed Job — taking a look at some of their pros and cons.</p><p>There are different use cases for each. It all depends on the budget and scale of your operation.</p><p>If performance and long-term maintainability are of importance, Sidekiq is a no-brainer.
On the other hand, if running costs are a concern, Delayed Job can help you there.</p><p>Whether you choose Delayed Job or Sidekiq, good luck with your project and happy coding!</p><p><strong>P.S. If you&#39;d like to read Ruby Magic posts as soon as they get off the press, <a href="https://blog.appsignal.com/ruby-magic">subscribe to our Ruby Magic newsletter and never miss a single post</a>!</strong></p></div></div>
  </body>
</html>
