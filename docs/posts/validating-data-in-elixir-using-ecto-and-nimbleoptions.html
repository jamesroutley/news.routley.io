<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.appsignal.com/2023/11/07/validating-data-in-elixir-using-ecto-and-nimbleoptions.html">Original</a>
    <h1>Validating Data in Elixir: Using Ecto and NimbleOptions</h1>
    
    <div id="readability-page-1" class="page"><div><p>In the previous part of this series about validating data at the boundary of an Elixir application, we covered a few general programming tactics to try and reject invalid and unexpected data in our software.</p>
<p>Continuing with that subject, we&#39;ll now explore how two libraries, namely Ecto and NimbleOptions, can further assist us.</p>
<p>Let&#39;s get started!</p>
<h2 id="using-ecto">Using Ecto</h2>
<p>As we&#39;ve seen previously, Elixir provides many native techniques to help us guarantee data quality in our systems.</p>
<p>But it&#39;s also possible to leverage Ecto to cast, validate, and prune data even if there&#39;s no database interaction.</p>
<h3 id="schemaless-changesets-in-ecto">Schemaless Changesets in Ecto</h3>
<p><a href="https://hexdocs.pm/ecto/Ecto.Changeset.html#module-schemaless-changesets">Schemaless changesets</a> (basically Ecto changesets that aren&#39;t tied to a database table) are a convenient way to create data structures. They also prevent bad data from making its way into structs (this can happen when bad data makes it past constructors or is added directly to a struct).</p>
<p>This approach is typically helpful when dealing with untrusted input (e.g., from an API request or as part of a module&#39;s public API). We can expose a function that will accept a plain map and, after proper vetting, will yield a struct. Other functions in the same module can then accept such a struct instance (rather than a map) to indicate that the data has been vetted and is safe to consume.</p>
<p>Here&#39;s what that approach can look like:</p>

<p>Note that we&#39;re applying an <code>:insert</code> <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html#module-changeset-actions">action</a>, so we could even use our function&#39;s error to display directly in a Phoenix form: those require an <code>:insert</code> or <code>:update</code> action to render possible errors with the form&#39;s data.</p>
<h3 id="applying-this-to-phoenix-forms">Applying This To Phoenix Forms</h3>
<p>Indeed, <a href="https://hexdocs.pm/phoenix_html/Phoenix.HTML.Form.html#module-a-note-on-errors">Phoenix forms inspect the action</a> to determine whether error hints should be displayed: if no action is set, no errors will be rendered in the form. This is useful if an empty changeset is being used to render a Phoenix form: the changeset is invalid, but we don&#39;t want to berate the user with errors when they haven&#39;t (yet) made any actual errors. But this also means that if you want the validation errors resulting from <code>from_params</code> to show up in a Phoenix form, you need to set the <code>:action</code> value yourself, which is what we&#39;re accomplishing with our call to <code>apply_action</code>.</p>
<p>Of course, if you don&#39;t plan on using this with a Phoenix-rendered form, it won&#39;t be needed and can be safely skipped.</p>
<p>Creating a new validated account is now a simple matter of <code>Account.from_params(%{name: &#34;ACME&#34;, suspended: false})</code>.</p>
<p>And since the <code>types</code> are dynamic, they could also be passed in as arguments if your domain requires it.</p>
<h3 id="embedded-schemas-in-ecto">Embedded Schemas in Ecto</h3>
<p>Let&#39;s say you already have an <code>Account</code> struct that isn&#39;t persisted to a database but still want to use Ecto to validate the data. In that case, you can transition to using an <a href="https://hexdocs.pm/ecto/Ecto.Schema.html#embedded_schema/1">embedded schema</a> rather than a basic struct. The trade-off between a schemaless changeset and an embedded schema is that the latter provides a bit more convenience at the expense of flexibility.</p>
<p>Namely, embedded schemas require you to have a struct within which to define the schema. Schemaless changesets don&#39;t have that requirement since, as their name implies, they don&#39;t need a schema definition.</p>
<p>Also, the datatypes for attributes can be dynamic in the schemaless changeset case (and provided as an argument to a function call, for example). In contrast, embedded schema types cannot vary from their defined value. Here&#39;s the above example rewritten to use an embedded schema:</p>

<p>If you&#39;d like to dig deeper into how Ecto can <em>also</em> help you with your non-persisted data, I highly recommend reading Ecto&#39;s <a href="https://hexdocs.pm/ecto/data-mapping-and-validation.html">Data mapping and validation guide</a>.</p>
<h2 id="validating-options">Validating Options</h2>
<p>There are many circumstances where data is passed in as keyword lists (e.g., options given to OTP modules such as GenServers). These values need to be validated for conformity, but we also want that validation to be easy to understand and communicate. Enter NimbleOptions!</p>
<h3 id="the-nimbleoptions-library-for-elixir">The NimbleOptions Library for Elixir</h3>
<p><a href="https://hexdocs.pm/nimble_options/NimbleOptions.html">NimbleOptions</a> is a great tool for validating options, as it is a lightweight library that verifies keyword lists and returns errors on invalid data. Let&#39;s see how it can be used!</p>
<p>Say we want to email suspended <code>Account</code> records. The email template to use will be different if we email a corporate or personal account. Additionally, you want to specify which values to pass into the template.</p>
<p>We&#39;ll want to adapt the signature: corporate accounts, for example, should have an account manager&#39;s name attached, while private accounts can simply have a generic signature. We&#39;ll also specify which URL to include as the call to action:</p>

<p>This is a great start: we&#39;re enforcing the <code>:template</code> to be provided and the program will crash if the template isn&#39;t given. This keeps out bad data, but isn&#39;t a great experience for callers: if they make a mistake (even as simple as a typo on the template name!) everything is going to crash instead of just generating an error they can handle.</p>
<p>We could, of course, do something like this:</p>

<p>But that doesn&#39;t scale very well once the number of options grows: it gets pretty difficult to see what options are permitted, what their expected type is, and so on. Not to mention, this is going to get repetitive really fast.</p>

<h3 id="bringing-in-nimbleoptions">Bringing In NimbleOptions</h3>
<p>Let&#39;s try out NimbleOptions. We need to specify a schema that the options are expected to conform to:</p>

<p>Do note we&#39;ve specified <code>default: []</code> in the <code>values</code> configuration: that way, an empty list will be used as the default, enabling the cascading of default child values such as <code>landing_url</code> to be filled in. Without it, a default <code>landing_url</code> won&#39;t be filled in if a <code>values</code> keyword isn&#39;t present at all.</p>
<p>Here it is in action:</p>

<p>As we can see, default values are being filled in when required, and they won&#39;t overwrite any provided values.</p>
<p>Validation also works out of the box:</p>

<p>It will also verify that we&#39;re not passing in unexpected option keys, such as typos:</p>

<h3 id="allowing-strings-for-landing_page">Allowing Strings for <code>landing_page</code></h3>
<p>While having the <code>landing_page</code> as a URI ensures it at least looks right, having to provide it as a string is a bit of a pain. It would be nice to provide the option as a string, but here&#39;s how that currently behaves:</p>

<p>Luckily, there&#39;s an easy fix â€” we just have to tweak the type definition:</p>

<p>Strings are now accepted for the <code>landing_page</code> value:</p>

<p>While a step in the right direction, there are now two minor issues:</p>
<ul>
<li>Our code has to handle both string and URI data types (or we need to manually convert one to another after validation).</li>
<li>Leaving the value as a string doesn&#39;t indicate anything. In particular, there&#39;s no indication that the value is a valid URI &#34;safe&#34; to process.</li>
</ul>
<h3 id="elixirs-nimbleoptions-to-the-rescue">Elixir&#39;s NimbleOptions To the Rescue!</h3>
<p>Once again, NimbleOptions comes to our rescue: we can use a <a href="https://hexdocs.pm/nimble_options/NimbleOptions.html#module-types"><code>:custom</code> data type</a> that specifies a parser function. In our case, that parser function can simply be <code>URI.new/1</code>, as it already conforms to the expectation set by <code>:custom</code> (namely, returning <code>{:ok, value}</code> or <code>{:error, message}</code>):</p>

<p>Check it out:</p>

<p>We&#39;ve now got the best of both worlds: convenient argument types and a standardized representation post-validation!</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>I hope you&#39;ve enjoyed these two blog posts covering how you can keep bad data out of your Elixir applications while also making your code more expressive.</p>
<p>As we&#39;ve seen, there are both &#34;plain vanilla&#34; Elixir techniques as well as support you can get from libraries like NimbleOptions to help us reject invalid data from being processed in our code.</p>
<p>By introducing these approaches to our modules, we&#39;ll provide more immediate feedback to callers and also make our programs more resilient when faced with unexpected data.</p>
<p>Hopefully, you&#39;ve now got a few more tools in your belt to try out. Enjoy!</p>
<p><strong>P.S. If you&#39;d like to read Elixir Alchemy posts as soon as they get off the press, <a href="https://blog.appsignal.com/elixir-alchemy">subscribe to our Elixir Alchemy newsletter and never miss a single post</a>!</strong></p></div></div>
  </body>
</html>
