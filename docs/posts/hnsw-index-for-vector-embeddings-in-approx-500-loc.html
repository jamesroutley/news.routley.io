<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/dicroce/hnsw">Original</a>
    <h1>Show HN: HNSW index for vector embeddings in approx 500 LOC</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<div dir="auto"><h2 tabindex="-1" dir="auto">Nearest neighbor search for vector embeddings</h2><a id="user-content-nearest-neighbor-search-for-vector-embeddings" aria-label="Permalink: Nearest neighbor search for vector embeddings" href="#nearest-neighbor-search-for-vector-embeddings"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>Single header, modern C++.</li>
<li>Approximately 500 lines of code.</li>
<li>Fast (uses Eigen for SIMD acceleration of distance calculations).</li>
</ul>

<div data-snippet-clipboard-copy-content="// Level 2           *                    *        *                                        *
// Level 1        *  *              *     *        *        *          **                 * *
// Level 0  *     ** *     * * *    *    **   *  * *  * ** **          **     ** *    *   * *   * * *"><pre><code>// Level 2           *                    *        *                                        *
// Level 1        *  *              *     *        *        *          **                 * *
// Level 0  *     ** *     * * *    *    **   *  * *  * ** **          **     ** *    *   * *   * * *
</code></pre></div>
<p dir="auto">HNSW is a graph structure that consists of levels that are more sparsely populated at the top and more
densely populated at the bottom. Nodes within a layer have connections to other nodes that are near them
on the same level. When a node is inserted a random level is picked and the node is inserted there. It
is also inserted into all levels beneath that level down to 0.</p>
<p dir="auto">When searches arrive they start at the top and search that level (following connections) until they find
the closest node in the top level. The search then descends and keeps searching nearby nodes. As the
search progresses the code keeps track of the K nearest nodes it has seen. Eventually it either finds
the value OR it finds the closest value on level 0 and the K nearest nodes seen are returned.</p>

<div data-snippet-clipboard-copy-content="#include &#34;hnsw/hsnw.h&#34;

int main(int argc, char* argv[])
{
    // Create an index for 128-dimensional vectors
    dicroce::hnsw&lt;float&gt; index(128);
        
    const size_t num_vectors = 10000;
    std::vector&lt;std::vector&lt;float&gt;&gt; vectors(num_vectors) = generate_random_vv(num_vectors, 128);
    
    // Build the index    
    for (size_t i = 0; i &lt; vectors.size(); ++i)
        index.add_item(vectors[i]);
    
    // Search for nearest neighbors
    std::vector&lt;float&gt; query(128) = generate_random_v(128);
    
    const size_t k = 10;
    auto results = index.search(query, k);
    
    for (const auto&amp; result : results)
        printf(&#34;ID: %lu, Distance: %f\n&#34;, result.first, result.second);
}"><pre><code>#include &#34;hnsw/hsnw.h&#34;

int main(int argc, char* argv[])
{
    // Create an index for 128-dimensional vectors
    dicroce::hnsw&lt;float&gt; index(128);
        
    const size_t num_vectors = 10000;
    std::vector&lt;std::vector&lt;float&gt;&gt; vectors(num_vectors) = generate_random_vv(num_vectors, 128);
    
    // Build the index    
    for (size_t i = 0; i &lt; vectors.size(); ++i)
        index.add_item(vectors[i]);
    
    // Search for nearest neighbors
    std::vector&lt;float&gt; query(128) = generate_random_v(128);
    
    const size_t k = 10;
    auto results = index.search(query, k);
    
    for (const auto&amp; result : results)
        printf(&#34;ID: %lu, Distance: %f\n&#34;, result.first, result.second);
}
</code></pre></div>

<p dir="auto">mkdir build &amp;&amp; pushd build &amp;&amp; cmake .. &amp;&amp; make &amp;&amp; popd</p>
</article></div></div>
  </body>
</html>
