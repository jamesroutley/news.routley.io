<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chevyray.dev/blog/creating-175-fonts/">Original</a>
    <h1>I Created 175 Fonts Using Rust</h1>
    
    <div id="readability-page-1" class="page"><div><p>I decided not to support any Asian or non-Latin based languages because I am not as familiar with those character sets and not only would I not be able to achieve the quality I wanted, but it would also make the fonts take an order of magnitude longer to create. I would still like to create a pixel font family some day that has support for many, many more languages.</p><h3 id="style-variations">Style Variations</h3><p>One thing I noticed with the 40-pack was that people would mix and match the fonts a lot. Games often have a lot of UI, and good UI requires a lot of visual hierarchy. If all the text is the same size and weight, it&#39;s hard to make something stand out or recede, and readability suffers. This is more difficult with pixel fonts than regular fonts because they are not vectors and do not scale smoothly.</p><p>So this time around, I didn&#39;t just want a big variety of fonts, I also wanted each font to be a <em>family</em> of styles supporting different sizes and weights. So for example, the <a href="https://chevyray.itch.io/pixel-font-virtue" rel="noopener" target="_blank">Virtue</a> font family comes with a whopping 20 styles!</p><p><img alt="Cover image for the Virtue font, displaying its style variations" src="https://chevyray.dev/blog/creating-175-fonts/virtue_cover.webp"/></p><p>This way, rather than mixing fonts with completely different styles to add variation, developers could have the variation they wanted while remaining stylistically cohesive.</p><h3 id="kerning-completeness">Kerning Completeness</h3><p>Kerning was a big time hog when making my previous font packs. Because the tools I was using required every kerning pair to be manually entered, it was incredibly time consuming and also extremely error prone.</p><p>Look at it this way—if I have just three characters <code>A B C</code>, these are the following potential kerning pairs: <code>AA</code>, <code>AB</code>, <code>AC</code>, <code>BA</code>, <code>BB</code>, <code>BC</code>, <code>CA</code>, <code>CB</code>, and <code>CC</code>. That&#39;s 9 total entries! In fact, you can calculate how many entries you (may) need by just squaring the amount of characters you support.</p><p>My new fonts were going to support 176 characters, meaning I might have to enter as many as <code>176² = 37,976</code> kerning pairs... yeah not going to happen. So this time, since I was (spoiler alert) writing my own tool to generate the fonts, I decided to semi-automate this process to take care of a huge majority of the kerning, and do manual entry when the algorithm didn&#39;t suffice.</p><h3 id="better-quality-control">Better Quality Control</h3><p>With definitely only a hundred (<em>shh... he doesn&#39;t know yet</em>) fonts in the oven, managing them all was going to be a significant task. With the previous font packs, I did it manually. If I found a stray pixel or a bug in the kerning I would fix it, re-export the font, test that the re-export worked and the error was gone, and then re-upload the assets to itch manually.</p><p>Also, I just couldn&#39;t evaluate the overall quality of the fonts easily. So this time, I wanted to have a way to generate big sample texts of the font and visualizations of kerning pairs so that as I was working on the fonts I could preview them, easily spot problems, and see my fixes immediately.</p><h3 id="easier-deployment-maintenance">Easier Deployment &amp; Maintenance</h3><p>Making kerning and quality control faster and more automated lead to the obvious conclusion that I should also make the entire upload/deployment process automated as well. My goal was to have it so that adding improvements the fonts, fixing errors, and creating new ones in the future would be simple, painless, reliable, and automatic and error-proof as possible.</p><h2 id="raising-the-bar">Raising the Bar</h2><p>While my previous fonts were well-received and decent quality, if I wanted to produce something that was much more impressive, I had to sit down and improve.</p><h3 id="studying-font-design">Studying Font Design</h3><p>I&#39;ve been a pixel artist since I was a wee child, and made a lot of pixel fonts, but I hadn&#39;t actually <em>studied</em> typeface design before. Ultimately, I was fairly ignorant when it came to both the history and the nature of traditional typeface design. So while I was working on these fonts, I spent a lot of time studying and learning as much as I could about the craft.</p><p>A book that helped me a lot was <a href="https://www.richardpoulin.net/books/design-school-type" rel="noopener" target="_blank">Design School: Type</a> by Richard Poulin.</p><p><img alt="Cover and preview pages of &#34;Design School: Type&#34; by Richard Poulin" src="https://chevyray.dev/blog/creating-175-fonts/type_book.webp"/></p><p>This was a great guide for beginners and acts as a comprehensive dictionary for the huge amount of terminology and conventions that exist in typeface design.</p><h3 id="photo-references">Photo References</h3><p>Another thing I did was started taking and saving photos of text I saw out in the world. I found small shop signs, museums, art galleries, festivals, posters for local events, and book covers to be amazing sources of inspiration. Here&#39;s a tiny sample of photos from my reference folder:</p><p><img alt="Twelve reference photos of various signs, books, and other lettering" src="https://chevyray.dev/blog/creating-175-fonts/photo_refs.webp"/></p><p>These are not for copying, but rather for studying. Look at some of these shapes, how some of the letters hang below the baseline, how certain letters are really thin while others are wide.</p><p>One of my biggest takeaways from studying a lot of amazing fonts out in the wild is the realization that most &#34;fancy&#34; fonts actually don&#39;t go too crazy with all their letters. Usually fanciness is reserved for capital letters, and lowercase letters often get more subtle flair, with the occasional letter that jumps out at you.</p><p>To achieve these lofty goals, and because I wanted to and nobody could stop me, I wrote my own Rust program for creating pixel fonts: <code>pifo</code>!</p><h3 id="how-it-works">How It Works</h3><p>I like using my normal pixel art tools to actually design the fonts. When I make a font, I produce a PNG tilesheet and a config file to provide some metrics and settings to guide the tool. I can then feed these files into <code>pifo</code>:</p><pre data-lang="bat"><code data-lang="bat"><span>pifo --all --output </span><span>&#34;Faraway&#34;</span><span> --input </span><span>&#34;Faraway*&#34;
</span></code></pre><p>It then takes the image, chops it up into individual glyph tiles, generates contours for them, automatically calculates kerning pairs between them, and then gathers them all into a font and exports as a TTF file. It also exports the font in several other engine-ready formats.</p><p>All the work done on individual glyphs is parallelized, making it almost instant for a single font. Running this process on 175 fonts one-by-one takes only a couple of seconds. If these processes were to run in parallel, it would be almost instant again.</p><h3 id="crates-used">Crates Used</h3><p>I didn&#39;t need too many special crates for this, but the ones I used were very helpful.</p><ul><li><a href="https://crates.io/crates/clap" rel="noopener" target="_blank">clap</a> for command line argument parsing</li><li><a href="https://crates.io/crates/image" rel="noopener" target="_blank">image</a> for image decoding and encoding</li><li><a href="https://crates.io/crates/rayon" rel="noopener" target="_blank">rayon</a> for parallellization</li><li><a href="https://crates.io/crates/serde" rel="noopener" target="_blank">serde</a> for data serialization</li><li><a href="https://crates.io/crates/glyph-names" rel="noopener" target="_blank">glyph-names</a> which maps char to glyph names</li><li><a href="https://crates.io/crates/ab_glyph" rel="noopener" target="_blank">ab-glyph</a> for loading and rasterizing fonts</li><li><a href="https://crates.io/crates/crunch" rel="noopener" target="_blank">crunch</a> for rectangle packing</li></ul><h2 id="step-1-creating-font-sheets">Step 1: Creating Font Sheets</h2><p>Every font sheet has a tilesheet and config file that look like this:</p><p><img alt="A grid of characters for a pixel font" src="https://chevyray.dev/blog/creating-175-fonts/sheet.png"/></p><blockquote><p>TOML</p></blockquote><pre data-lang="toml"><code data-lang="toml"><span>version </span><span>= </span><span>&#34;1.0&#34;          </span><span># font version
</span><span>baseline </span><span>= </span><span>14            </span><span># baseline from the top of a tile
</span><span>line_gap </span><span>= </span><span>0             </span><span># gap between vertical lines of text
</span><span>spacing </span><span>= </span><span>3              </span><span># width of space character
</span><span>metrics </span><span>= []             </span><span># manually assign metrics for glyphs
</span><span>auto_kerning </span><span>= </span><span>true      </span><span># enable automatic kerning
</span><span>auto_kerning_min </span><span>= </span><span>-</span><span>1    </span><span># never kern farther than 1 pixel left
</span><span>manual_kerning </span><span>= []      </span><span># manually kern specific glyph pairs
</span><span>skip_kerning_left </span><span>= </span><span>&#34;&#34;   </span><span># don&#39;t kern when these glyphs are the L-pair
</span><span>skip_kerning_right </span><span>= </span><span>&#34;&#34;  </span><span># don&#39;t kern when these glyphs are the R-pair
</span></code></pre><p>The grid size can change, but it must always be a uniform grid and the characters must always be in those positions. Only 100% white pixels will be processed by the tool, so the checkered background and baseline are merely guides that will be discarded when the sheet is processed.</p><h2 id="step-2-contouring-glyphs">Step 2: Contouring Glyphs</h2><p>Once the sheet is ready, contouring can begin. This is the most complex part of the process, and so I&#39;ll go over all the steps of the algorithm here.</p><p>TrueType glyphs are created out of one or multiple <em>contours</em>, which are basically closed shapes made out of curves. So for example, the letter <code>i</code> would be one contour for the dot, and a second contour for the rest of the shape.</p><p>Because our fonts are pixel fonts, we need to create a contour for every connected group (or &#34;cluster&#34;) of pixels. Using this lowercase <code>t</code> as an example, we need the algorithm to turn it from pixels into two contours <span><strong><code>A</code></strong></span> and <span><strong><code>B</code></strong></span> like so:</p><p><img alt="The contours a pixelated letter should result in" src="https://chevyray.dev/blog/creating-175-fonts/pixels_to_contour.svg"/></p><p>It doesn&#39;t matter where the contour begins and ends, as long as it&#39;s a closed loop.</p><h3 id="gathering-the-pixels">Gathering the Pixels</h3><p>Starting with the glyph&#39;s image, we first need to separate out all the pixels of the bitmap, because that&#39;s all we&#39;ll really be operating on. Rather than working with the image directly, I found it easier to write the algorithms by working with collections of <code>Point</code> structs which look like this:</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>// these have a bunch of derives, methods, and
</span><span>// constructors, but I won&#39;t list them all here
</span><span>#</span><span>[</span><span>derive</span><span>]
</span><span>pub </span><span>struct </span><span>Point </span><span>{
</span><span>    </span><span>pub </span><span>x</span><span>: </span><span>i16</span><span>,
</span><span>    </span><span>pub </span><span>y</span><span>: </span><span>i16</span><span>,
</span><span>}
</span><span>
</span><span>impl </span><span>Point </span><span>{
</span><span>    </span><span>fn </span><span>new</span><span>(</span><span>x</span><span>: </span><span>i16</span><span>, </span><span>y</span><span>: </span><span>i16</span><span>) </span><span>-&gt; </span><span>Self </span><span>{
</span><span>        </span><span>Self </span><span>{</span><span> x</span><span>,</span><span> y </span><span>}
</span><span>    </span><span>}
</span><span>
</span><span>    </span><span>fn </span><span>right</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt; </span><span>Self </span><span>{
</span><span>        </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x </span><span>+ </span><span>1</span><span>, self</span><span>.</span><span>y</span><span>)
</span><span>    </span><span>}
</span><span>
</span><span>    </span><span>fn </span><span>left</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt; </span><span>Self </span><span>{
</span><span>        </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x </span><span>- </span><span>1</span><span>, self</span><span>.</span><span>y</span><span>)
</span><span>    </span><span>}
</span><span>
</span><span>    </span><span>fn </span><span>below</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt; </span><span>Self </span><span>{
</span><span>        </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x</span><span>, self</span><span>.</span><span>y </span><span>+ </span><span>1</span><span>)
</span><span>    </span><span>}
</span><span>
</span><span>    </span><span>fn </span><span>above</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt; </span><span>Self </span><span>{
</span><span>        </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x</span><span>, self</span><span>.</span><span>y </span><span>- </span><span>1</span><span>)
</span><span>    </span><span>}
</span><span>
</span><span>    </span><span>fn </span><span>left_edge</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt; </span><span>(</span><span>Point, Point</span><span>) {
</span><span>        </span><span>(</span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x</span><span>, self</span><span>.</span><span>y </span><span>+ </span><span>1</span><span>)</span><span>, </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x</span><span>, self</span><span>.</span><span>y</span><span>))
</span><span>    </span><span>}
</span><span>
</span><span>    </span><span>fn </span><span>right_edge</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt; </span><span>(</span><span>Point, Point</span><span>) {
</span><span>        </span><span>(
</span><span>            </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x </span><span>+ </span><span>1</span><span>, self</span><span>.</span><span>y</span><span>)</span><span>,
</span><span>            </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x </span><span>+ </span><span>1</span><span>, self</span><span>.</span><span>y </span><span>+ </span><span>1</span><span>)</span><span>,
</span><span>        </span><span>)
</span><span>    </span><span>}
</span><span>
</span><span>    </span><span>fn </span><span>top_edge</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt; </span><span>(</span><span>Point, Point</span><span>) {
</span><span>        </span><span>(</span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x</span><span>, self</span><span>.</span><span>y</span><span>)</span><span>, </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x </span><span>+ </span><span>1</span><span>, self</span><span>.</span><span>y</span><span>))
</span><span>    </span><span>}
</span><span>
</span><span>    </span><span>fn </span><span>bottom_edge</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt; </span><span>(</span><span>Point, Point</span><span>) {
</span><span>        </span><span>(
</span><span>            </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x </span><span>+ </span><span>1</span><span>, self</span><span>.</span><span>y </span><span>+ </span><span>1</span><span>)</span><span>,
</span><span>            </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x</span><span>, self</span><span>.</span><span>y </span><span>+ </span><span>1</span><span>)</span><span>,
</span><span>        </span><span>)
</span><span>    </span><span>}
</span><span>
</span><span>    </span><span>pub </span><span>fn </span><span>sign</span><span>(</span><span>self</span><span>) </span><span>-&gt; </span><span>Self </span><span>{
</span><span>        </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>self</span><span>.</span><span>x</span><span>.</span><span>signum</span><span>()</span><span>, self</span><span>.</span><span>y</span><span>.</span><span>signum</span><span>())
</span><span>    </span><span>}
</span><span>}
</span></code></pre><p>Given an <a href="https://docs.rs/image/latest/image/type.RgbaImage.html" rel="noopener" target="_blank"><code>RgbaImage</code></a>, we can collect all the white pixels into a <code>HashSet</code>:</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>const </span><span>WHITE</span><span>: </span><span>Rgba&lt;</span><span>u8</span><span>&gt; </span><span>=</span><span> Rgba</span><span>([</span><span>255</span><span>; </span><span>4</span><span>])</span><span>;
</span><span>let</span><span> pixels</span><span>: </span><span>HashSet&lt;Point&gt; </span><span>=</span><span> img
</span><span>    </span><span>.</span><span>enumerate_pixels</span><span>()
</span><span>    </span><span>.</span><span>filter</span><span>(|(</span><span>_</span><span>,</span><span> _</span><span>, </span><span>p</span><span>)| </span><span>*</span><span>p </span><span>== &amp;</span><span>WHITE</span><span>)
</span><span>    </span><span>.</span><span>map</span><span>(|(</span><span>x</span><span>, </span><span>y</span><span>,</span><span> _</span><span>)| </span><span>Point</span><span>::</span><span>new</span><span>(</span><span>x </span><span>as </span><span>i16</span><span>,</span><span> y </span><span>as </span><span>i16</span><span>))
</span><span>    </span><span>.</span><span>collect</span><span>()</span><span>;
</span></code></pre><h3 id="detecting-clusters">Detecting Clusters</h3><p>Now we need to group these pixels together into clusters so we can operate on and create a contour for them separately. So for our letter, we can identify that it should have two clusters.</p><p>To do this we start by choosing a random pixel and &#34;flood filling&#34; it, spreading out into every adjacent pixel until there are no more it can spread to, and then that produces a single cluster. Then, we take the remaining pixels and repeat again, continuing this loop until there are no more unvisited pixels.</p><p><img alt="A letter being divided into separate clusters" src="https://chevyray.dev/blog/creating-175-fonts/clusters.svg"/></p><p>The following algorithm does so:</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>// generate a list of &#34;clusters&#34; of pixels that are connected together
</span><span>let </span><span>mut</span><span> clusters</span><span>: </span><span>Vec</span><span>&lt;HashSet&lt;Point&gt;&gt; </span><span>= </span><span>Vec</span><span>::</span><span>new</span><span>()</span><span>;
</span><span>{
</span><span>    </span><span>// to find clusters, we flood-fill pixels in the image,
</span><span>    </span><span>// removing them, until there are none left
</span><span>    </span><span>let </span><span>mut</span><span> pixels </span><span>=</span><span> pixels</span><span>.</span><span>clone</span><span>()</span><span>;
</span><span>    </span><span>let </span><span>mut</span><span> to_process </span><span>= </span><span>Vec</span><span>::</span><span>new</span><span>()</span><span>;
</span><span>
</span><span>    </span><span>// while there are pixels left
</span><span>    </span><span>while </span><span>let </span><span>Some</span><span>(</span><span>&amp;</span><span>p</span><span>) </span><span>=</span><span> pixels</span><span>.</span><span>iter</span><span>()</span><span>.</span><span>next</span><span>() {
</span><span>        </span><span>// add the pixel to the process list
</span><span>        to_process</span><span>.</span><span>push</span><span>(</span><span>p</span><span>)</span><span>;
</span><span>
</span><span>        </span><span>// create a new cluster
</span><span>        </span><span>let </span><span>mut</span><span> cluster </span><span>= </span><span>HashSet</span><span>::</span><span>new</span><span>()</span><span>;
</span><span>
</span><span>        </span><span>// while there are pixels to be processed
</span><span>        </span><span>while </span><span>let </span><span>Some</span><span>(</span><span>p</span><span>) </span><span>=</span><span> to_process</span><span>.</span><span>pop</span><span>() {
</span><span>            </span><span>// remove the pixel and add it to the cluster
</span><span>            pixels</span><span>.</span><span>remove</span><span>(</span><span>&amp;</span><span>p</span><span>)</span><span>;
</span><span>            cluster</span><span>.</span><span>insert</span><span>(</span><span>p</span><span>)</span><span>;
</span><span>
</span><span>            </span><span>// queue processing for all adjacent pixels
</span><span>            </span><span>// that have not yet been processed
</span><span>            to_process</span><span>.</span><span>extend</span><span>(</span><span>p
</span><span>                </span><span>.</span><span>adjacent</span><span>()
</span><span>                </span><span>.</span><span>into_iter</span><span>()
</span><span>                </span><span>.</span><span>filter</span><span>(|</span><span>p</span><span>| </span><span>pixels</span><span>.</span><span>contains</span><span>(</span><span>p</span><span>))
</span><span>            </span><span>)</span><span>;
</span><span>        </span><span>}
</span><span>
</span><span>        clusters</span><span>.</span><span>push</span><span>(</span><span>cluster</span><span>)</span><span>;
</span><span>    </span><span>}
</span><span>}
</span></code></pre><h3 id="creating-the-edge-list">Creating the Edge List</h3><p>Now we have our clusters, each which represents one &#34;shape&#34; made out of contours. We now need to find the <em>outline</em> of each of them because that&#39;s what we&#39;ll be creating the contours out of.</p><p><img alt="Outlines around the previous two clusters" src="https://chevyray.dev/blog/creating-175-fonts/edge_lists1.svg"/></p><p>To do this, we first make a list of all the exposed edges of all pixels, where &#34;exposed&#34; means there is no adjacent pixel on that side. Just looking at one cluster, it looks like this:</p><p><img alt="Visualizing of all exposed cluster edges" src="https://chevyray.dev/blog/creating-175-fonts/edge_lists2.svg"/></p><p>The code to create this list of edges:</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>let </span><span>mut</span><span> edges</span><span>: </span><span>Vec</span><span>&lt;</span><span>(</span><span>Point, Point</span><span>)</span><span>&gt; </span><span>=</span><span> cluster
</span><span>    </span><span>.</span><span>iter</span><span>()
</span><span>    </span><span>.</span><span>map</span><span>(|</span><span>p</span><span>| {
</span><span>        </span><span>[
</span><span>            </span><span>(</span><span>!</span><span>cluster</span><span>.</span><span>contains</span><span>(</span><span>&amp;</span><span>p</span><span>.</span><span>above</span><span>()))</span><span>.</span><span>then</span><span>(|| </span><span>p</span><span>.</span><span>top_edge</span><span>())</span><span>,
</span><span>            </span><span>(</span><span>!</span><span>cluster</span><span>.</span><span>contains</span><span>(</span><span>&amp;</span><span>p</span><span>.</span><span>right</span><span>()))</span><span>.</span><span>then</span><span>(|| </span><span>p</span><span>.</span><span>right_edge</span><span>())</span><span>,
</span><span>            </span><span>(</span><span>!</span><span>cluster</span><span>.</span><span>contains</span><span>(</span><span>&amp;</span><span>p</span><span>.</span><span>below</span><span>()))</span><span>.</span><span>then</span><span>(|| </span><span>p</span><span>.</span><span>bottom_edge</span><span>())</span><span>,
</span><span>            </span><span>(</span><span>!</span><span>cluster</span><span>.</span><span>contains</span><span>(</span><span>&amp;</span><span>p</span><span>.</span><span>left</span><span>()))</span><span>.</span><span>then</span><span>(|| </span><span>p</span><span>.</span><span>left_edge</span><span>())</span><span>,
</span><span>        </span><span>]
</span><span>    </span><span>})
</span><span>    </span><span>.</span><span>flatten</span><span>()
</span><span>    </span><span>.</span><span>flatten</span><span>()
</span><span>    </span><span>.</span><span>collect</span><span>()</span><span>;
</span></code></pre><h3 id="chaining-edges">Chaining Edges</h3><p>The next part is tricky. We need to take that list of edges and build a <em>path</em> out of them by attaching them together. If we imagine each edge as a <code>(tail, head)</code> tuple of points, then we can write an algorithm that attaches all the overlapping heads to all the overlapping tails to create a contiguous path.</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>// each cluster will generate one or more contours
</span><span>let </span><span>mut</span><span> contours</span><span>: </span><span>Vec</span><span>&lt;</span><span>Vec</span><span>&lt;Point&gt;&gt; </span><span>= </span><span>Vec</span><span>::</span><span>new</span><span>()</span><span>;
</span><span>
</span><span>// if we have edges remaining, start a new path
</span><span>while </span><span>let </span><span>Some</span><span>((</span><span>a</span><span>,</span><span> b</span><span>)) </span><span>=</span><span> edges</span><span>.</span><span>pop</span><span>() {
</span><span>    </span><span>// the contour starts with the first edge
</span><span>    </span><span>let </span><span>mut</span><span> contour </span><span>= </span><span>vec!</span><span>[</span><span>a</span><span>,</span><span> b</span><span>]</span><span>;
</span><span>    </span><span>let </span><span>mut</span><span> end </span><span>=</span><span> b</span><span>;
</span><span>    </span><span>let </span><span>mut</span><span> i </span><span>= </span><span>0</span><span>;
</span><span>
</span><span>    </span><span>while</span><span> i </span><span>&lt;</span><span> edges</span><span>.</span><span>len</span><span>() {
</span><span>        </span><span>// check the portion after the last edge for a chain
</span><span>        </span><span>if </span><span>let </span><span>Some</span><span>((</span><span>j</span><span>, </span><span>(</span><span>_</span><span>,</span><span> b</span><span>))) </span><span>=</span><span> edges</span><span>[</span><span>i</span><span>..</span><span>]
</span><span>            </span><span>.</span><span>iter</span><span>()
</span><span>            </span><span>.</span><span>cloned</span><span>()
</span><span>            </span><span>.</span><span>enumerate</span><span>()
</span><span>            </span><span>.</span><span>find</span><span>(|(</span><span>_</span><span>,</span><span> (</span><span>a</span><span>,</span><span> _</span><span>))</span><span>|</span><span> a </span><span>== &amp;</span><span>end)
</span><span>        </span><span>{
</span><span>            edges</span><span>.</span><span>remove</span><span>(</span><span>i </span><span>+</span><span> j</span><span>)</span><span>;
</span><span>            contour</span><span>.</span><span>push</span><span>(</span><span>b</span><span>)</span><span>;
</span><span>            end </span><span>=</span><span> b</span><span>;
</span><span>            i </span><span>+=</span><span> j</span><span>;
</span><span>            </span><span>if</span><span> i </span><span>&gt;=</span><span> edges</span><span>.</span><span>len</span><span>() {
</span><span>                i </span><span>-=</span><span> edges</span><span>.</span><span>len</span><span>()</span><span>;
</span><span>            </span><span>}
</span><span>            </span><span>continue</span><span>;
</span><span>        </span><span>}
</span><span>
</span><span>        </span><span>// check the portion before the last edge for a chain
</span><span>        </span><span>if </span><span>let </span><span>Some</span><span>((</span><span>j</span><span>, </span><span>(</span><span>_</span><span>,</span><span> b</span><span>))) </span><span>=</span><span> edges</span><span>[</span><span>..</span><span>i</span><span>]
</span><span>            </span><span>.</span><span>iter</span><span>()
</span><span>            </span><span>.</span><span>cloned</span><span>()
</span><span>            </span><span>.</span><span>enumerate</span><span>()
</span><span>            </span><span>.</span><span>find</span><span>(|(</span><span>_</span><span>,</span><span> (</span><span>a</span><span>,</span><span> _</span><span>))</span><span>|</span><span> a </span><span>== &amp;</span><span>end)
</span><span>        </span><span>{
</span><span>            edges</span><span>.</span><span>remove</span><span>(</span><span>j</span><span>)</span><span>;
</span><span>            contour</span><span>.</span><span>push</span><span>(</span><span>b</span><span>)</span><span>;
</span><span>            end </span><span>=</span><span> b</span><span>;
</span><span>            i </span><span>=</span><span> j</span><span>;
</span><span>            </span><span>if</span><span> i </span><span>&gt;=</span><span> edges</span><span>.</span><span>len</span><span>() {
</span><span>                i </span><span>-=</span><span> edges</span><span>.</span><span>len</span><span>()</span><span>;
</span><span>            </span><span>}
</span><span>            </span><span>continue</span><span>;
</span><span>        </span><span>}
</span><span>
</span><span>        </span><span>break</span><span>;
</span><span>    </span><span>}
</span><span>
</span><span>    </span><span>// the end point is the same as the start point
</span><span>    contour</span><span>.</span><span>pop</span><span>()</span><span>;
</span><span>
</span><span>    </span><span>// add it to our contour list
</span><span>    contours</span><span>.</span><span>push</span><span>(</span><span>contour</span><span>)</span><span>;
</span><span>}
</span></code></pre><p>This will create the following contour from the cluster:</p><p><img alt="The list  of edges with edge vertices removed" src="https://chevyray.dev/blog/creating-175-fonts/chaining.svg"/></p><p>You may have noticed that this code assumes that each cluster can produce multiple contours. This is because if you have a cluster with a hole in the middle, that will in fact be the case:</p><p><img alt="A donut-shaped cluster with two contours, one for the cluster and one for the hole" src="https://chevyray.dev/blog/creating-175-fonts/multi_contour.svg"/></p><p>Also notice that whenever we have clusters with holes, the winding of the outside of the cluster is clockwise, but the winding of the holes is counter-clockwise. This is an artifact of how edges are provided in clockwise order, and is actually very lucky because that&#39;s exactly how TTF contours work! When you want to describe a hole in a glyph, you create an inner contour and wind it in the opposite direction of the outer contour.</p><h3 id="remove-non-corner-points">Remove Non-Corner Points</h3><p>While this will technically work, we can optimize this a bit more. When multiple edges connect in a line, we don&#39;t really need them all, do we? If we remove all non-corner points, we can shrink the file size and also increase rasterization speed.</p><p><img alt="The chained edges with non-corner points removed" src="https://chevyray.dev/blog/creating-175-fonts/repeat_sections.svg"/></p><p>We do this after chaining, right before adding our contour to the list:</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>// for every a→b→c sequence of points, if the normal of a→b is equal
</span><span>// to the normal of b→c, then we can remove b and link a→c directly
</span><span>let </span><span>mut</span><span> i </span><span>= </span><span>1</span><span>;
</span><span>while</span><span> i </span><span>&lt;=</span><span> contour</span><span>.</span><span>len</span><span>() {
</span><span>    </span><span>let</span><span> a </span><span>=</span><span> contour</span><span>[</span><span>i </span><span>- </span><span>1</span><span>]</span><span>;
</span><span>    </span><span>let</span><span> b </span><span>=</span><span> contour</span><span>[</span><span>i </span><span>%</span><span> contour</span><span>.</span><span>len</span><span>()]</span><span>;
</span><span>    </span><span>let</span><span> c </span><span>=</span><span> contour</span><span>[(</span><span>i </span><span>+ </span><span>1</span><span>) </span><span>%</span><span> contour</span><span>.</span><span>len</span><span>()]</span><span>;
</span><span>    </span><span>if </span><span>(</span><span>b </span><span>-</span><span> a</span><span>)</span><span>.</span><span>sign</span><span>() </span><span>== </span><span>(</span><span>c </span><span>-</span><span> b</span><span>)</span><span>.</span><span>sign</span><span>() {
</span><span>        contour</span><span>.</span><span>remove</span><span>(</span><span>i </span><span>%</span><span> contour</span><span>.</span><span>len</span><span>())</span><span>;
</span><span>    </span><span>} </span><span>else </span><span>{
</span><span>        i </span><span>+= </span><span>1</span><span>;
</span><span>    </span><span>}
</span><span>}
</span><span>
</span><span>// *now* we can add it to our contour list
</span><span>contours</span><span>.</span><span>push</span><span>(</span><span>contour</span><span>)</span><span>;
</span></code></pre><h2 id="step-3-kerning-tables">Step 3: Kerning Tables</h2><p>Once we have the contours done, we only need one more thing in order to produce our TTF file: kerning tables. This table tells fonts when they are allowed to shift characters left to fit words together more tightly.</p><figure><img alt="Example of the text &#39;Vault&#39; without and with kerning" src="https://chevyray.dev/blog/creating-175-fonts/kerning_example.svg"/><figcaption>Shifting the <b>Va</b> and the <b>lt</b> pairs left by just one pixel looks a lot nicer.</figcaption></figure><h3 id="manual-kerning-alts">Manual Kerning &amp; Alts</h3><p>Kerning can be manually assigned in the font&#39;s <code>TOML</code> file. So for the kerning pairs in the example above, we could do this:</p><blockquote><p>TOML</p></blockquote><pre data-lang="toml"><code data-lang="toml"><span>manual_kerning </span><span>= [
</span><span>    { </span><span>left </span><span>= </span><span>&#34;V&#34;</span><span>, </span><span>right </span><span>= </span><span>&#34;a&#34;</span><span>, </span><span>kern </span><span>= </span><span>-</span><span>1 </span><span>}</span><span>,
</span><span>    { </span><span>left </span><span>= </span><span>&#34;l&#34;</span><span>, </span><span>right </span><span>= </span><span>&#34;t&#34;</span><span>, </span><span>kern </span><span>= </span><span>-</span><span>1 </span><span>}</span><span>,
</span><span>]
</span></code></pre><p>But our fonts also support accents, so for the letter <code>a</code> we would have to consider all its accented variations..</p><blockquote><p>TOML</p></blockquote><pre data-lang="toml"><code data-lang="toml"><span>manual_kerning </span><span>= [
</span><span>    { </span><span>left </span><span>= </span><span>&#34;V&#34;</span><span>, </span><span>right </span><span>= </span><span>&#34;a&#34;</span><span>, </span><span>kern </span><span>= </span><span>-</span><span>1 </span><span>}</span><span>,
</span><span>    { </span><span>left </span><span>= </span><span>&#34;V&#34;</span><span>, </span><span>right </span><span>= </span><span>&#34;à&#34;</span><span>, </span><span>kern </span><span>= </span><span>-</span><span>1 </span><span>}</span><span>,
</span><span>    { </span><span>left </span><span>= </span><span>&#34;V&#34;</span><span>, </span><span>right </span><span>= </span><span>&#34;á&#34;</span><span>, </span><span>kern </span><span>= </span><span>-</span><span>1 </span><span>}</span><span>,
</span><span>    { </span><span>left </span><span>= </span><span>&#34;V&#34;</span><span>, </span><span>right </span><span>= </span><span>&#34;â&#34;</span><span>, </span><span>kern </span><span>= </span><span>-</span><span>1 </span><span>}</span><span>,
</span><span>    </span><span># ...etc.
</span></code></pre><p>To simplify this, I can use the <code>alts</code> parameter to achieve the same thing:</p><blockquote><p>TOML</p></blockquote><pre data-lang="toml"><code data-lang="toml"><span>manual_kerning </span><span>= [
</span><span>    { </span><span>left </span><span>= </span><span>&#34;V&#34;</span><span>, </span><span>right </span><span>= </span><span>&#34;a&#34;</span><span>, </span><span>kern </span><span>= </span><span>-</span><span>1</span><span>, </span><span>alts </span><span>= </span><span>true </span><span>}
</span><span>]
</span></code></pre><p>This is the map used to identify a character&#39;s alts:</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>// for manual kerning, copy settings for alts/diacritics
</span><span>let</span><span> alt</span><span>: </span><span>HashMap&lt;</span><span>char</span><span>, </span><span>&amp;</span><span>&#39;static </span><span>str</span><span>&gt; </span><span>= </span><span>HashMap</span><span>::</span><span>from_iter</span><span>([
</span><span>    </span><span>(</span><span>&#39;A&#39;</span><span>, </span><span>&#34;ÀÁÂÃÄÅ&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;a&#39;</span><span>, </span><span>&#34;àáâãäå&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;C&#39;</span><span>, </span><span>&#34;Ç&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;c&#39;</span><span>, </span><span>&#34;ç&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;E&#39;</span><span>, </span><span>&#34;ÈÉÊË&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;e&#39;</span><span>, </span><span>&#34;èéêë&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;I&#39;</span><span>, </span><span>&#34;ÌÍÎÏ&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;I&#39;</span><span>, </span><span>&#34;ÌÍÎÏ&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;i&#39;</span><span>, </span><span>&#34;ìíîï&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;N&#39;</span><span>, </span><span>&#34;Ñ&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;n&#39;</span><span>, </span><span>&#34;ñ&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;O&#39;</span><span>, </span><span>&#34;ÒÓÔÕÖ&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;o&#39;</span><span>, </span><span>&#34;òóôõö&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;U&#39;</span><span>, </span><span>&#34;ÙÚÛÜ&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;u&#39;</span><span>, </span><span>&#34;ùúûü&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;Y&#39;</span><span>, </span><span>&#34;Ÿ&#34;</span><span>)</span><span>,
</span><span>    </span><span>(</span><span>&#39;y&#39;</span><span>, </span><span>&#34;ÿ&#34;</span><span>)</span><span>,
</span><span>])</span><span>;
</span></code></pre><h3 id="automatic-kerning">Automatic Kerning</h3><p>But manually entering thousands of kerning values is exactly what I wanted to avoid. Instead, most kerning pairs will be automatically calculated, and the manual system is to override the automatic system when it doesn&#39;t suffice.</p><p>So how do we find a kerning offset for a pair of letters? Let&#39;s use <code>LV</code> as an example.</p><p><img alt="Example of the adjacent letters LV unkerned" src="https://chevyray.dev/blog/creating-175-fonts/kerning_bad.svg"/></p><p>To figure out their kerning value, we have to move <code>V</code> to the left pixel-by-pixel until it is as close to <code>L</code> as possible without touching it. So if we move it over one pixel...</p><p><img alt="The &#39;V&#39; is shifted over one pixel, sitting tidily next to the &#39;L&#39;" src="https://chevyray.dev/blog/creating-175-fonts/kerning_shift.svg"/></p><p><img alt="The &#39;V&#39; is shifted over one pixel, sitting tidily next to the &#39;L&#39;" src="https://chevyray.dev/blog/creating-175-fonts/kerning_fixed.svg"/></p><p>It&#39;s not touching, so a <code>-1</code> is good so far. What happens if we try moving it again?</p><p><img alt="The &#39;V&#39; is shifted too far, and one of its pixels is touching the T" src="https://chevyray.dev/blog/creating-175-fonts/kerning_overshot.svg"/></p><p>Nope! Because two pixels are touching (corners touching counts), <code>-2</code> is too far, so that means our calculated kerning for <code>LV</code> is <code>-1</code>!</p><p>The code to do this looks like so:</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>impl </span><span>Point </span><span>{
</span><span>    </span><span>fn </span><span>surrounding</span><span>(</span><span>&amp;</span><span>self</span><span>) </span><span>-&gt; </span><span>[</span><span>Self</span><span>; </span><span>8</span><span>] {
</span><span>        </span><span>let</span><span> Point </span><span>{</span><span> x</span><span>,</span><span> y </span><span>} </span><span>= *</span><span>self;
</span><span>        </span><span>[
</span><span>            </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>x </span><span>+ </span><span>1</span><span>,</span><span> y</span><span>)</span><span>,
</span><span>            </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>x </span><span>- </span><span>1</span><span>,</span><span> y</span><span>)</span><span>,
</span><span>            </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>x</span><span>,</span><span> y </span><span>+ </span><span>1</span><span>)</span><span>,
</span><span>            </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>x</span><span>,</span><span> y </span><span>- </span><span>1</span><span>)</span><span>,
</span><span>            </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>x </span><span>+ </span><span>1</span><span>,</span><span> y </span><span>+ </span><span>1</span><span>)</span><span>,
</span><span>            </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>x </span><span>- </span><span>1</span><span>,</span><span> y </span><span>- </span><span>1</span><span>)</span><span>,
</span><span>            </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>x </span><span>+ </span><span>1</span><span>,</span><span> y </span><span>- </span><span>1</span><span>)</span><span>,
</span><span>            </span><span>Self</span><span>::</span><span>new</span><span>(</span><span>x </span><span>- </span><span>1</span><span>,</span><span> y </span><span>+ </span><span>1</span><span>)</span><span>,
</span><span>        </span><span>]
</span><span>    </span><span>}
</span><span>}
</span><span>
</span><span>// calculate the kerning for this glyph and the right-hand glyph
</span><span>pub </span><span>fn </span><span>calculate_kerning</span><span>(
</span><span>    </span><span>left</span><span>: </span><span>&amp;</span><span>BitmapGlyph,
</span><span>    </span><span>right</span><span>: </span><span>&amp;</span><span>BitmapGlyph,
</span><span>    </span><span>min</span><span>: </span><span>i16
</span><span>) </span><span>-&gt; </span><span>Option</span><span>&lt;NonZero&lt;</span><span>i16</span><span>&gt;&gt; </span><span>{
</span><span>    </span><span>// the start position is 2 pixels after the first letter
</span><span>    </span><span>let </span><span>mut</span><span> kern</span><span>: </span><span>i16 </span><span>= </span><span>0</span><span>;
</span><span>    </span><span>let </span><span>mut</span><span> offset</span><span>: </span><span>i16 </span><span>=</span><span> left</span><span>.</span><span>max_pixel</span><span>.</span><span>x </span><span>+ </span><span>2</span><span>;
</span><span>
</span><span>    </span><span>// if the left letter has no pixels blocking, we don&#39;t want
</span><span>    </span><span>// to kern into infinity so we stop at zero
</span><span>    </span><span>while</span><span> offset </span><span>&gt; </span><span>0 </span><span>&amp;&amp;</span><span> kern </span><span>&gt;</span><span> min </span><span>{
</span><span>        offset </span><span>-= </span><span>1</span><span>;
</span><span>
</span><span>        </span><span>// translate every pixel in the right-side image by the offset
</span><span>        </span><span>// and then see if that shift would cause any pixels to touch
</span><span>        </span><span>if</span><span> right
</span><span>            </span><span>.</span><span>pixels
</span><span>            </span><span>.</span><span>iter</span><span>()
</span><span>            </span><span>.</span><span>map</span><span>(|</span><span>p</span><span>| </span><span>Point</span><span>::</span><span>new</span><span>(</span><span>p</span><span>.</span><span>x </span><span>+</span><span> offset</span><span>,</span><span> p</span><span>.</span><span>y</span><span>))
</span><span>            </span><span>.</span><span>any</span><span>(|</span><span>p</span><span>| {
</span><span>                </span><span>// after the pixel is translated, check all positions
</span><span>                </span><span>// surrounding it. if any of those positions touch any
</span><span>                </span><span>// pixels on the left glyph, we cannot kern here
</span><span>                p</span><span>.</span><span>surrounding</span><span>()
</span><span>                    </span><span>.</span><span>iter</span><span>()
</span><span>                    </span><span>.</span><span>any</span><span>(|</span><span>adj</span><span>| </span><span>left</span><span>.</span><span>pixels</span><span>.</span><span>contains</span><span>(</span><span>adj</span><span>))
</span><span>            </span><span>})
</span><span>        </span><span>{
</span><span>            </span><span>break</span><span>;
</span><span>        </span><span>}
</span><span>
</span><span>        </span><span>// this shift was safe, so increment the kerning
</span><span>        kern </span><span>-= </span><span>1</span><span>;
</span><span>    </span><span>}
</span><span>
</span><span>    </span><span>NonZero</span><span>::</span><span>new</span><span>(</span><span>kern</span><span>)
</span><span>}
</span></code></pre><p>Given our current manually assigned kerning list, we can now extend it with the automatically calculated ones.</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>// ignore manually assigned kerning
</span><span>let</span><span> ignore</span><span>: </span><span>HashSet&lt;</span><span>(</span><span>char</span><span>, </span><span>char</span><span>)</span><span>&gt; </span><span>=</span><span> kerning
</span><span>    </span><span>.</span><span>iter</span><span>()
</span><span>    </span><span>.</span><span>map</span><span>(|</span><span>k</span><span>| (</span><span>k</span><span>.</span><span>left</span><span>,</span><span> k</span><span>.</span><span>right</span><span>))
</span><span>    </span><span>.</span><span>collect</span><span>()</span><span>;
</span><span>let</span><span> skip_left</span><span>: </span><span>HashSet&lt;</span><span>char</span><span>&gt; </span><span>=</span><span> desc
</span><span>    </span><span>.</span><span>skip_kerning_left
</span><span>    </span><span>.</span><span>chars</span><span>()
</span><span>    </span><span>.</span><span>collect</span><span>()</span><span>;
</span><span>let</span><span> skip_right</span><span>: </span><span>HashSet&lt;</span><span>char</span><span>&gt; </span><span>=</span><span> desc
</span><span>    </span><span>.</span><span>skip_kerning_right
</span><span>    </span><span>.</span><span>chars</span><span>()
</span><span>    </span><span>.</span><span>collect</span><span>()</span><span>;
</span><span>
</span><span>// calculate automatic kerning
</span><span>let</span><span> min_kern </span><span>=</span><span> desc</span><span>.</span><span>auto_kerning_min</span><span>.</span><span>unwrap_or</span><span>(</span><span>i16</span><span>::</span><span>MIN</span><span>)</span><span>;
</span><span>kerning</span><span>.</span><span>par_extend</span><span>(
</span><span>    glyphs
</span><span>        </span><span>.</span><span>par_iter</span><span>()
</span><span>        </span><span>.</span><span>filter</span><span>(|</span><span>left</span><span>| </span><span>!</span><span>skip_left</span><span>.</span><span>contains</span><span>(</span><span>&amp;</span><span>left</span><span>.</span><span>chr</span><span>))
</span><span>        </span><span>.</span><span>map</span><span>(|</span><span>left</span><span>| {
</span><span>            glyphs
</span><span>                </span><span>.</span><span>par_iter</span><span>()
</span><span>                </span><span>.</span><span>filter</span><span>(|</span><span>right</span><span>| </span><span>!</span><span>skip_right</span><span>.</span><span>contains</span><span>(</span><span>&amp;</span><span>right</span><span>.</span><span>chr</span><span>))
</span><span>                </span><span>.</span><span>map</span><span>(</span><span>move </span><span>|</span><span>right</span><span>| </span><span>(</span><span>left</span><span>,</span><span> right</span><span>))
</span><span>        </span><span>})
</span><span>        </span><span>.</span><span>flatten</span><span>()
</span><span>        </span><span>.</span><span>filter</span><span>(|(</span><span>left</span><span>, </span><span>right</span><span>)| </span><span>!</span><span>ignore</span><span>.</span><span>contains</span><span>(</span><span>&amp;</span><span>(</span><span>left</span><span>.</span><span>chr</span><span>,</span><span> right</span><span>.</span><span>chr</span><span>)))
</span><span>        </span><span>.</span><span>filter_map</span><span>(|(</span><span>left</span><span>, </span><span>right</span><span>)| {
</span><span>            </span><span>calculate_kerning</span><span>(</span><span>left</span><span>,</span><span> right</span><span>,</span><span> min_kern</span><span>)
</span><span>                </span><span>.</span><span>map</span><span>(|</span><span>kern</span><span>| {
</span><span>                    KerningPair </span><span>{
</span><span>                        left</span><span>:</span><span> left</span><span>.</span><span>chr</span><span>,
</span><span>                        right</span><span>:</span><span> right</span><span>.</span><span>chr</span><span>,
</span><span>                        kern</span><span>:</span><span> kern</span><span>.</span><span>get</span><span>()</span><span>,
</span><span>                        alts</span><span>: </span><span>None</span><span>,
</span><span>                    </span><span>}
</span><span>                </span><span>})
</span><span>        </span><span>})</span><span>,
</span><span>)</span><span>;
</span></code></pre><p>I won&#39;t go over every line of this because it&#39;s interacting with several other parts of the codebase, and kind of doing a lot. But basically it respects the ignore settings in the font&#39;s TOML file, and also calculates all the kerning pairs in parallel using <a href="https://crates.io/crates/rayon" rel="noopener" target="_blank">rayon</a>.</p><p>With all the kerning calculated, we can now create the TTF files.</p><h2 id="step-5-exporting">Step 5: Exporting</h2><p>PIFO doesn&#39;t just generate TTF files, it also exports the fonts as tile sheets and packed texture atlases. With each of these, multiple data formats are provided, so you can use whichever you prefer.</p><h3 id="truetype-files">TrueType Files</h3><p>The <a href="https://learn.microsoft.com/en-us/typography/opentype/spec/" rel="noopener" target="_blank">OpenType format</a> is pretty involved, and has a huge amount of features that I do not need for these fonts.</p><p>TTF files are binary files made up of a bunch of blocks of data, called &#34;tables&#34;, that each contain different information about the font. The font starts with a table directory which provides the memory location for each table so that font parsers can easily jump around to access the information they want.</p><p>My exporter populates the following tables:</p><table><thead><tr><th>Table</th><th>Description</th></tr></thead><tbody><tr><td><code>head</code></td><td>Global font information</td></tr><tr><td><code>hhea</code></td><td>Horizontal layout information</td></tr><tr><td><code>maxp</code></td><td>Memory requirements</td></tr><tr><td><code>OS/2</code></td><td>OpenType font requirements</td></tr><tr><td><code>hmtx</code></td><td>Horizontal metrics</td></tr><tr><td><code>cmap</code></td><td>Maps characters to glyph index</td></tr><tr><td><code>loca</code></td><td>Maps index to <code>glyf</code> table location</td></tr><tr><td><code>glyf</code></td><td>Glyph data (contours)</td></tr><tr><td><code>kern</code></td><td>Kerning pairs</td></tr><tr><td><code>name</code></td><td>Strings for font, author, style, copyright, etc.</td></tr><tr><td><code>post</code></td><td>Required for valid TTF file</td></tr></tbody></table><p>I won&#39;t go over all of it here, but my code to write a table looks like this:</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>// `hmtx` table
</span><span>data</span><span>.</span><span>begin_table</span><span>(</span><span>Tag</span><span>::</span><span>Hmtx</span><span>)</span><span>;
</span><span>{
</span><span>    </span><span>// longHorMetric - hMetrics[numberOfHMetrics]
</span><span>    </span><span>for</span><span> g </span><span>in &amp;</span><span>font</span><span>.</span><span>glyphs </span><span>{
</span><span>        </span><span>// advanceWidth -  Advance width, in font design units.
</span><span>        data</span><span>.</span><span>write_u16</span><span>(</span><span>px_to_un</span><span>(</span><span>g</span><span>.</span><span>adv </span><span>as </span><span>i16</span><span>) </span><span>as </span><span>u16</span><span>)</span><span>;
</span><span>
</span><span>        </span><span>// lsb - Glyph left side bearing, in font design units.
</span><span>        data</span><span>.</span><span>write_i16</span><span>(</span><span>px_to_un</span><span>(</span><span>g</span><span>.</span><span>lsb</span><span>))</span><span>;
</span><span>    </span><span>}
</span><span>}
</span><span>data</span><span>.</span><span>end_table</span><span>()</span><span>;
</span></code></pre><p>Every table needs to record its position, length, and <a href="https://learn.microsoft.com/en-us/typography/opentype/spec/otff#calculating-checksums" rel="noopener" target="_blank">checksum</a>, so <code>begin_table()</code> and <code>end_table()</code> help do this.</p><p>The <code>px_to_un()</code> function converts pixels to font units, and looks like this:</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>let</span><span> fake_height </span><span>= </span><span>16</span><span>;
</span><span>let</span><span> units_per_em </span><span>= </span><span>(</span><span>2048 </span><span>/</span><span> fake_height</span><span>) </span><span>*</span><span> fake_height</span><span>;
</span><span>let</span><span> scale </span><span>=</span><span> units_per_em </span><span>/</span><span> fake_height</span><span>;
</span><span>let </span><span>px_to_un </span><span>= </span><span>|</span><span>x</span><span>: </span><span>i16</span><span>| </span><span>x </span><span>*</span><span> scale</span><span>;
</span></code></pre><p>Normal fonts can be displayed at any size because they&#39;re made of smooth curves, but pixel fonts don&#39;t have that luxury because pixels are discrete and so you must always render them at multiples of some base size or you&#39;ll get a <em>wobbling</em> effect that looks really bad.</p><p>So I decided that the <em>base size</em> for all my fonts is just <code>16</code>, meaning that rendering a pixel font at that size will always produce pixels that are exactly <code>1 px</code> in size. When you want to scale up the text without wobbling, you can just draw text at multiples of 16, so <code>32</code>, <code>48</code>, <code>64</code>, etc.</p><h3 id="tile-sheets">Tile Sheets</h3><p>Fonts are also exported as tile sheets. Unlike the input sheets that group characters of similarity together, these sheets are ordered by their unicode codepoints:</p><p><img alt="A tile sheet of pixel font characters" src="https://chevyray.dev/blog/creating-175-fonts/export_sheet.png"/></p><p>Each comes with a data file with font and glyph metrics:</p><blockquote><p>JSON</p></blockquote><pre data-lang="json"><code data-lang="json"><span>{
</span><span>  </span><span>&#34;cols&#34;</span><span>: </span><span>14</span><span>,
</span><span>  </span><span>&#34;rows&#34;</span><span>: </span><span>13</span><span>,
</span><span>  </span><span>&#34;tile_w&#34;</span><span>: </span><span>8</span><span>,
</span><span>  </span><span>&#34;tile_h&#34;</span><span>: </span><span>17</span><span>,
</span><span>  </span><span>&#34;baseline&#34;</span><span>: </span><span>14</span><span>,
</span><span>  </span><span>&#34;line_gap&#34;</span><span>: </span><span>0</span><span>,
</span><span>  </span><span>&#34;space_w&#34;</span><span>: </span><span>3</span><span>,
</span><span>  </span><span>&#34;glyphs&#34;</span><span>: </span><span>[
</span><span>        </span><span>{
</span><span>            </span><span>&#34;chr&#34;</span><span>: </span><span>&#34;</span><span>\u0000</span><span>&#34;</span><span>,
</span><span>            </span><span>&#34;lsb&#34;</span><span>: </span><span>0</span><span>,
</span><span>            </span><span>&#34;adv&#34;</span><span>: </span><span>8
</span><span>        </span><span>}</span><span>,
</span><span>        </span><span>{
</span><span>            </span><span>&#34;chr&#34;</span><span>: </span><span>&#34;!&#34;</span><span>,
</span><span>            </span><span>&#34;lsb&#34;</span><span>: </span><span>0</span><span>,
</span><span>            </span><span>&#34;adv&#34;</span><span>: </span><span>2
</span><span>        </span><span>}</span><span>,
</span><span>        </span><span>{
</span><span>            </span><span>&#34;chr&#34;</span><span>: </span><span>&#34;</span><span>\&#34;</span><span>&#34;</span><span>,
</span><span>            </span><span>&#34;lsb&#34;</span><span>: </span><span>0</span><span>,
</span><span>            </span><span>&#34;adv&#34;</span><span>: </span><span>4
</span><span>        </span><span>}</span><span>,
</span><span>        </span><span>{
</span><span>            </span><span>&#34;chr&#34;</span><span>: </span><span>&#34;#&#34;</span><span>,
</span><span>            </span><span>&#34;lsb&#34;</span><span>: </span><span>0</span><span>,
</span><span>            </span><span>&#34;adv&#34;</span><span>: </span><span>7
</span><span>        </span><span>}</span><span>,
</span></code></pre><p>This data file also contains a kerning table:</p><blockquote><p>JSON</p></blockquote><pre data-lang="json"><code data-lang="json"><span>    </span><span>&#34;kerning&#34;</span><span>: </span><span>[
</span><span>        </span><span>{
</span><span>            </span><span>&#34;left&#34;</span><span>: </span><span>&#34;i&#34;</span><span>,
</span><span>            </span><span>&#34;right&#34;</span><span>: </span><span>&#34;j&#34;</span><span>,
</span><span>            </span><span>&#34;kern&#34;</span><span>: </span><span>-3
</span><span>        </span><span>}</span><span>,
</span><span>        </span><span>{
</span><span>            </span><span>&#34;left&#34;</span><span>: </span><span>&#34;i&#34;</span><span>,
</span><span>            </span><span>&#34;right&#34;</span><span>: </span><span>&#34;ì&#34;</span><span>,
</span><span>            </span><span>&#34;kern&#34;</span><span>: </span><span>-1
</span><span>        </span><span>}</span><span>,
</span><span>        </span><span>{
</span><span>            </span><span>&#34;left&#34;</span><span>: </span><span>&#34;j&#34;</span><span>,
</span><span>            </span><span>&#34;right&#34;</span><span>: </span><span>&#34;j&#34;</span><span>,
</span><span>            </span><span>&#34;kern&#34;</span><span>: </span><span>-2
</span><span>        </span><span>}</span><span>,
</span></code></pre><p>To do this, I put this data into the following structs and use <code>serde</code> to serialize them into the various supported formats (JSON, XML, TOML, etc).</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>#</span><span>[</span><span>derive</span><span>(</span><span>Debug</span><span>,</span><span> Serialize</span><span>)]
</span><span>struct </span><span>Sheet </span><span>{
</span><span>    </span><span>cols</span><span>: </span><span>u32</span><span>,
</span><span>    </span><span>rows</span><span>: </span><span>u32</span><span>,
</span><span>    </span><span>tile_w</span><span>: </span><span>u32</span><span>,
</span><span>    </span><span>tile_h</span><span>: </span><span>u32</span><span>,
</span><span>    </span><span>baseline</span><span>: </span><span>i16</span><span>,
</span><span>    </span><span>line_gap</span><span>: </span><span>i16</span><span>,
</span><span>    </span><span>space_w</span><span>: </span><span>i16</span><span>,
</span><span>
</span><span>    #</span><span>[</span><span>serde</span><span>(</span><span>skip_serializing_if </span><span>= </span><span>&#34;Vec::is_empty&#34;</span><span>,</span><span> default</span><span>)]
</span><span>    </span><span>glyphs</span><span>: </span><span>Vec</span><span>&lt;Glyph&gt;,
</span><span>
</span><span>    #</span><span>[</span><span>serde</span><span>(</span><span>skip_serializing_if </span><span>= </span><span>&#34;Vec::is_empty&#34;</span><span>,</span><span> default</span><span>)]
</span><span>    </span><span>kerning</span><span>: </span><span>Vec</span><span>&lt;KerningPair&gt;,
</span><span>}
</span><span>
</span><span>#</span><span>[</span><span>derive</span><span>(</span><span>Debug</span><span>,</span><span> Serialize</span><span>)]
</span><span>struct </span><span>Glyph </span><span>{
</span><span>    </span><span>chr</span><span>: </span><span>char</span><span>,
</span><span>    </span><span>lsb</span><span>: </span><span>i16</span><span>,
</span><span>    </span><span>adv</span><span>: </span><span>i16</span><span>,
</span><span>}
</span><span>
</span><span>#</span><span>[</span><span>derive</span><span>(</span><span>Debug</span><span>,</span><span> Serialize</span><span>)]
</span><span>struct </span><span>KerningPair </span><span>{
</span><span>    </span><span>left</span><span>: </span><span>char</span><span>,
</span><span>    </span><span>right</span><span>: </span><span>char</span><span>,
</span><span>    </span><span>kern</span><span>: </span><span>i16</span><span>,
</span><span>}
</span></code></pre><h3 id="packed-atlases">Packed Atlases</h3><p>Versions with the glyphs tightly packed into a texture atlas are also exported:</p><p><img alt="Font characters packed tightly into a texture atlas" src="https://chevyray.dev/blog/creating-175-fonts/export_packed.png"/></p><p>I use my own rectangle packer crate <a href="https://crates.io/crates/crunch" rel="noopener" target="_blank">crunch</a> to do this:</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>let</span><span> PackedItems </span><span>{</span><span> w</span><span>,</span><span> h</span><span>, </span><span>mut</span><span> items </span><span>} </span><span>= </span><span>{
</span><span>    </span><span>let</span><span> items</span><span>: </span><span>Vec</span><span>&lt;Item&lt;</span><span>usize</span><span>&gt;&gt; </span><span>=</span><span> font
</span><span>        </span><span>.</span><span>glyphs
</span><span>        </span><span>.</span><span>iter</span><span>()
</span><span>        </span><span>.</span><span>enumerate</span><span>()
</span><span>        </span><span>.</span><span>filter</span><span>(|(</span><span>_</span><span>, </span><span>g</span><span>)| </span><span>g</span><span>.</span><span>pixels</span><span>.</span><span>len</span><span>() </span><span>&gt; </span><span>0</span><span>)
</span><span>        </span><span>.</span><span>map</span><span>(|(</span><span>i</span><span>, </span><span>g</span><span>)| {
</span><span>            </span><span>let</span><span> w </span><span>= </span><span>((</span><span>g</span><span>.</span><span>max_pixel</span><span>.</span><span>x </span><span>-</span><span> g</span><span>.</span><span>min_pixel</span><span>.</span><span>x</span><span>) </span><span>+ </span><span>2</span><span>) </span><span>as </span><span>usize</span><span>;
</span><span>            </span><span>let</span><span> h </span><span>= </span><span>((</span><span>g</span><span>.</span><span>max_pixel</span><span>.</span><span>y </span><span>-</span><span> g</span><span>.</span><span>min_pixel</span><span>.</span><span>y</span><span>) </span><span>+ </span><span>2</span><span>) </span><span>as </span><span>usize</span><span>;
</span><span>            </span><span>Item</span><span>::</span><span>new</span><span>(</span><span>i</span><span>,</span><span> w</span><span>,</span><span> h</span><span>, </span><span>Rotation</span><span>::</span><span>None</span><span>)
</span><span>        </span><span>})
</span><span>        </span><span>.</span><span>collect</span><span>()</span><span>;
</span><span>    </span><span>crunch</span><span>::</span><span>pack_into_po2</span><span>(</span><span>2048</span><span>,</span><span> items</span><span>)</span><span>.</span><span>unwrap</span><span>()
</span><span>}</span><span>;
</span></code></pre><p>Because positioning info is lost in a tightly packed atlas, the data files for these have a bit more information to help you render text correctly:</p><blockquote><p>JSON</p></blockquote><pre data-lang="json"><code data-lang="json"><span>{
</span><span>    </span><span>&#34;size&#34;</span><span>: </span><span>12</span><span>,
</span><span>    </span><span>&#34;line_gap&#34;</span><span>: </span><span>1</span><span>,
</span><span>    </span><span>&#34;space_w&#34;</span><span>: </span><span>3</span><span>,
</span><span>    </span><span>&#34;glyphs&#34;</span><span>: </span><span>[
</span><span>    </span><span>{
</span><span>        </span><span>&#34;chr&#34;</span><span>: </span><span>&#34;</span><span>\u0000</span><span>&#34;</span><span>,
</span><span>        </span><span>&#34;x&#34;</span><span>: </span><span>0</span><span>,
</span><span>        </span><span>&#34;y&#34;</span><span>: </span><span>0</span><span>,
</span><span>        </span><span>&#34;w&#34;</span><span>: </span><span>7</span><span>,
</span><span>        </span><span>&#34;h&#34;</span><span>: </span><span>9</span><span>,
</span><span>        </span><span>&#34;off_x&#34;</span><span>: </span><span>0</span><span>,
</span><span>        </span><span>&#34;off_y&#34;</span><span>: </span><span>-8</span><span>,
</span><span>        </span><span>&#34;adv&#34;</span><span>: </span><span>8
</span><span>    </span><span>}</span><span>,
</span><span>    </span><span>{
</span><span>        </span><span>&#34;chr&#34;</span><span>: </span><span>&#34;!&#34;</span><span>,
</span><span>        </span><span>&#34;x&#34;</span><span>: </span><span>118</span><span>,
</span><span>        </span><span>&#34;y&#34;</span><span>: </span><span>36</span><span>,
</span><span>        </span><span>&#34;w&#34;</span><span>: </span><span>1</span><span>,
</span><span>        </span><span>&#34;h&#34;</span><span>: </span><span>7</span><span>,
</span><span>        </span><span>&#34;off_x&#34;</span><span>: </span><span>0</span><span>,
</span><span>        </span><span>&#34;off_y&#34;</span><span>: </span><span>-7</span><span>,
</span><span>        </span><span>&#34;adv&#34;</span><span>: </span><span>2
</span><span>    </span><span>}</span><span>,
</span></code></pre><p>These are serialized and exported into different formats in the same way as sheets:</p><blockquote><p>Rust code</p></blockquote><pre data-lang="rust"><code data-lang="rust"><span>#</span><span>[</span><span>derive</span><span>(</span><span>Debug</span><span>,</span><span> Serialize</span><span>)]
</span><span>struct </span><span>Atlas </span><span>{
</span><span>    </span><span>size</span><span>: </span><span>u32</span><span>,
</span><span>    </span><span>line_gap</span><span>: </span><span>i16</span><span>,
</span><span>    </span><span>space_w</span><span>: </span><span>i16</span><span>,
</span><span>
</span><span>    #</span><span>[</span><span>serde</span><span>(</span><span>skip_serializing_if </span><span>= </span><span>&#34;Vec::is_empty&#34;</span><span>,</span><span> default</span><span>)]
</span><span>    </span><span>glyphs</span><span>: </span><span>Vec</span><span>&lt;Glyph&gt;,
</span><span>
</span><span>    #</span><span>[</span><span>serde</span><span>(</span><span>skip_serializing_if </span><span>= </span><span>&#34;Vec::is_empty&#34;</span><span>,</span><span> default</span><span>)]
</span><span>    </span><span>kerning</span><span>: </span><span>Vec</span><span>&lt;KerningPair&gt;,
</span><span>}
</span><span>
</span><span>#</span><span>[</span><span>derive</span><span>(</span><span>Debug</span><span>,</span><span> Serialize</span><span>)]
</span><span>struct </span><span>Glyph </span><span>{
</span><span>    </span><span>chr</span><span>: </span><span>char</span><span>,
</span><span>    </span><span>x</span><span>: </span><span>usize</span><span>,
</span><span>    </span><span>y</span><span>: </span><span>usize</span><span>,
</span><span>    </span><span>w</span><span>: </span><span>usize</span><span>,
</span><span>    </span><span>h</span><span>: </span><span>usize</span><span>,
</span><span>    </span><span>off_x</span><span>: </span><span>i16</span><span>,
</span><span>    </span><span>off_y</span><span>: </span><span>i16</span><span>,
</span><span>    </span><span>adv</span><span>: </span><span>i16</span><span>,
</span><span>}
</span><span>
</span><span>#</span><span>[</span><span>derive</span><span>(</span><span>Debug</span><span>,</span><span> Serialize</span><span>)]
</span><span>struct </span><span>KerningPair </span><span>{
</span><span>    </span><span>left</span><span>: </span><span>char</span><span>,
</span><span>    </span><span>right</span><span>: </span><span>char</span><span>,
</span><span>    </span><span>kern</span><span>: </span><span>i16</span><span>,
</span><span>}
</span></code></pre><h2 id="step-6-quality-testing">Step 6: Quality Testing</h2><p>If I wanted to achieve the quality of fonts I desired, I knew there would have to be some kind of system to make quality evaluation quick and easy. Once PIFO was up and running, I added one more feature to it: the ability to generate gigantic sample images.</p><p>First, I start with displaying all the letters and a few test sentences. The sentences are an excerpt from the short story <a href="https://www.mit.edu/people/dpolicar/writing/prose/text/thinkingMeat.html" rel="noopener" target="_blank">They&#39;re Made out of Meat</a> by Terry Bisson.</p><p><img alt="Sample text with test sentences" src="https://chevyray.dev/blog/creating-175-fonts/sample_start.webp"/></p><p>This is followed by a collection of test words. These words aren&#39;t random, and are taken from <a href="https://www.typography.com/blog/text-for-proofing-fonts" rel="noopener" target="_blank">Text for Proofing Fonts: A farewell to The Quick Brown Fox</a>, a very useful strategy for improving font quality testing.</p><p><img alt="Sample text with a bunch of random test words" src="https://chevyray.dev/blog/creating-175-fonts/sample_words.webp"/></p><p>I want all combinations of digits to look nice, so next up I render all possible pairings of those, as well as currency symbols:</p><p><img alt="Sample text with paired numbers and currency symbols" src="https://chevyray.dev/blog/creating-175-fonts/sample_numbers.webp"/></p><p>Then I render a huge row of uppercase, lowercase, and mixed-case kerning pairs:</p><p><img alt="Sample text of uppercase kerning pairs" src="https://chevyray.dev/blog/creating-175-fonts/sample_kerning1.webp"/></p><p><img alt="Sample text of lowercase kerning pairs" src="https://chevyray.dev/blog/creating-175-fonts/sample_kerning2.webp"/></p><p><img alt="Sample text of mixed-case kerning pairs" src="https://chevyray.dev/blog/creating-175-fonts/sample_kerning3.webp"/></p><p>This last one continues for awhile. Finally, I render a bunch of test punctuation:</p><p><img alt="Sample text of letter/punctuation combos" src="https://chevyray.dev/blog/creating-175-fonts/sample_punc1.webp"/></p><p><img alt="Sample text of letter/punctuation combos" src="https://chevyray.dev/blog/creating-175-fonts/sample_punc2.webp"/></p><p><img alt="Sample text of letter/punctuation combos" src="https://chevyray.dev/blog/creating-175-fonts/sample_punc3.webp"/></p><p>With PIFO immediately generating these sample images as I was working on the fonts, I was able to improve and tweak them very quickly, greatly increasing the overall quality and polish level of nearly 200 fonts!</p><h2 id="step-7-deployment">Step 7: Deployment</h2><p>With my original goal of 100 fonts massively overshot, I now had a whopping <strong>175 PIXEL FONTS</strong> to find a way to put up online for download. There are many places to sell things online, but I decided to stick to my tried-and-true, <a href="https://itch.io/" rel="noopener" target="_blank">itch.io</a>.</p><figure><img alt="Itch.io logo" src="https://chevyray.dev/blog/creating-175-fonts/itch_io.png"/><figcaption>itch.io is an open marketplace for indie creators</figcaption></figure><h3 id="creating-itch-io-projects">Creating itch.io Projects</h3><p>The most tedious part of deployment was having to create an individual itch project for each of the fonts.</p><p><img alt="A sample of my pixel font itch projects page" src="https://chevyray.dev/blog/creating-175-fonts/itch_projects.webp"/></p><p>Luckily, I only had to do this once for each font. Once it was done, uploading and maintaining them could be done completely via command line scripts.</p><h3 id="building-uploading">Building &amp; Uploading</h3><p>My deployment script has three steps:</p><ul><li>make sure PIFO itself is compiled</li><li>build the font assets</li><li>update each font&#39;s itch project with the new assets</li></ul><p>The first step is simple, I compile PIFO itself in release mode so it is as fast as possible:</p><blockquote><p>deploy.bat</p></blockquote><pre data-lang="bat"><code data-lang="bat"><span>cd</span><span> pifo
</span><span>cargo build --release </span><span>|| </span><span>exit</span><span> /b </span><span>%errorlevel%
</span></code></pre><p>Next, I use PIFO to build the font I want.</p><blockquote><p>deploy.bat</p></blockquote><pre data-lang="bat"><code data-lang="bat"><span>cd</span><span> ..\input
</span><span>..\pifo\target\release\pifo --output </span><span>&#34;../distro/faraway&#34;</span><span> --all --input </span><span>&#34;Faraway*&#34;
</span></code></pre><p>The <code>--input &#34;Faraway*&#34;</code> means that it will find <em>every</em> font that starts with that text and compile/package them all together. So in this example, there is <code>Faraway - Regular</code>, <code>Faraway - Bold</code>, etc. and they all get put together into a single package for the &#34;Faraway&#34; font family.</p><p>Finally, for deployment, I use <a href="https://itch.io/docs/butler/" rel="noopener" target="_blank"><code>butler</code></a>, which is a super handy command-line deployment tool provided by itch for exactly this purpose.</p><pre data-lang="bat"><code data-lang="bat"><span>butler push ../distro/faraway chevyray/pixel-font-faraway:assets
</span></code></pre><p>Butler tracks changed files and only updates the parts it needs to, so I don&#39;t have to do any file hashing or special versioning to save data.</p><h2 id="conclusion">Conclusion</h2><p>Phew, and that&#39;s how I shipped 175 pixel fonts on itch.io created using my own Rust tools!</p><p>I hope this was interesting, informative, or even helpful to people who are learning Rust or are curious about what might go into a project of this scale. I really wanted to start my new site off with a really high quality post, and I thought this would be a great subject.</p><p>If you&#39;d like to see more content like this, a great way to support me is to <a href="https://chevyray.itch.io/" rel="noopener" target="_blank">buy my pixel fonts</a> on itch.io, or share them around with others!</p><p><img alt="Preview of 40 of my pixel font families" src="https://chevyray.dev/blog/creating-175-fonts/families.png"/></p><p>If you find errors or have suggestions, you can visit the <a href="https://github.com/ChevyRay/chevyray.dev/tree/main/content/blog/2024-08-09-shipping-175-pixel-fonts/index.md" target="_blank"><i></i> source code for this post</a> directly to file an issue or submit a pull request.</p></div></div>
  </body>
</html>
