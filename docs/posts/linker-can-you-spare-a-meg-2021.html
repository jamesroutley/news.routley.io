<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tailscale.com/blog/go-linker/">Original</a>
    <h1>Linker, can you spare a meg? (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Tailscale on iOS runs as a special kind of app, a <a href="https://developer.apple.com/documentation/networkextension">Network Extension</a>. This lets us run in the background, so we can secure traffic from all of your applications, without them having to change anything. But with this power comes a memory straightjacket. Normal iOS apps can use 5GB or so of memory before iOS kills them. We get 15MB. With an “M”.</p>
<p>That has been a constant pain point for our users—and especially for us. When we use too much memory, iOS snipes our network extension, and your VPN access goes down. And the knowledge that doing more work caused more crashes caused us to leave important improvements out of the iOS app, like http2 and UPnP support. It was a constant low level drain on our engineering team and our product.</p>
<p>This blog post is about how we tackled the problem, with a bit of philosophizing and a surprise twist at the end.</p>
<h3 id="the-easy-stuff">The easy stuff</h3>
<p>The first step is to understand the problem. We added some logging about <a href="https://developer.apple.com/documentation/os/3191911-os_proc_available_memory">our memory usage</a>. This made it clear that baseline operation of Tailscale consumed 10-12MB, leaving only a few MB for anything else. The worst problems were for users with large tailnets: There was just more data. Plus, with many devices, we had to update that data more often. Still, with baseline operation taking 70-80% of the memory, we decided to start there.</p>
<p>The <a href="https://github.com/tailscale/tailscale/">core of the Tailscale VPN</a> is written in Go. So another obvious step is to bust out <a href="https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/">pprof</a> and optimize memory allocations. The internet has plenty of discussion of this kind of optimization, and they’re pretty standard stuff: eliminate <a href="https://github.com/tailscale/go/commit/f6fa4687a144cbfc8a8edcf2b7b35c38fda7eef6">per-packet</a> <a href="https://github.com/tailscale/go/commit/cff4b8d1c64767e8a888ad3da008c7b9a85afa0e">allocations</a>, <a href="https://github.com/tailscale/tailscale/commit/0c038b477ffce97c03664361663a68fd97b8a05a">re-use</a> <a href="https://github.com/tailscale/tailscale/commit/93284209bca3c63620b4f042d3dfd8d85af1ab94">buffers</a>, <a href="https://github.com/tailscale/tailscale/commit/a4e19f22339d9d618dcf459ca5709b2701aada56">break some layers</a>, and so on. That all helped, but not enough. Next topic.</p>
<h3 id="inside-the-go-runtime">Inside the Go runtime</h3>
<p>We made the Go garbage collector more aggressive, by calling <a href="https://pkg.go.dev/runtime/debug#SetGCPercent">debug.SetGCPercent</a>. This uses more CPU, but reduces memory usage by making it more likely that any given allocation can re-use freed memory. There’s an <a href="https://github.com/golang/go/issues/48409">exciting Go proposal</a> to make this kind of setup easier and more automatic, but even that is not a panacea. If you need more memory than you have, even a theoretically perfect garbage collector will not save you.</p>
<p>We also set <a href="https://pkg.go.dev/runtime#GOMAXPROCS">GOMAXPROCS=1</a> when starting the binary. This saves memory in two ways. First, it reduces the number of system threads. Each system thread takes hundreds of kilobytes of memory. Second, and less obvious, it reduces overhead from the Go memory allocator.</p>
<p>Go uses a slab allocator: It only allocates memory in specific sized chunks, or <a href="https://commaok.xyz/post/discovering-size-classes/">size classes</a>. And it requests memory from the OS in even larger chunks, or slabs. The first time a Go program allocates a single 24 byte struct, the allocator will ask the OS for 8KB, which it will use to satisfy other requests for 17-24 byte objects. After 341 such allocations, that 8KB has been used up, and the allocator will ask the OS for another 8KB, assuming the GC hasn’t freed anything in the meantime.</p>
<p>Allocations happen all the time. They need to be fast. And to avoid performance hits on a many-core machine, they need to avoid locking. So the Go runtime maintains a set of slabs per CPU. (Technically, <a href="https://morsmachine.dk/go-scheduler">per P</a>. Some things in this blog post have been intentionally simplified.) So on a 64 core machine, it is possible for the first 64 allocations of a 24 byte struct to each acquire a 8KB slab.</p>
<p>In a normal Go process, the slab overhead is negligible. But we were at a scale at which every 100KB really counted. The slab overhead from infrequently-allocated object sizes was enough to care about. Setting GOMAXPROCS to 1 cuts the potential slab overhead.</p>
<p>We considered <a href="https://github.com/tailscale/go/pull/18">changing the size classes to be coarser and the slabs to be smaller</a>. This is a balancing act. Fewer size classes means that allocations that might previously have been in separate slabs can end up in the same slab, leading to fewer slabs. But coarser slabs also means more waste: Allocating a 70 byte struct might suddenly use up 96 bytes instead of 80. Tweaking the size classes did in fact save memory, but it felt fragile and risky, so we didn’t move forward with it.</p>
<h3 id="ioss-memory-accounting">iOS’s memory accounting</h3>
<p>In practice, what mattered was not how much memory we used, but how much memory iOS thought we used. Trying to understand iOS’s memory accounting contained some <a href="https://github.com/golang/go/issues/47656">rabbit holes</a>, but ultimately provided some insights. (Hat tip to <a href="https://fr.linkedin.com/in/steevemorin">Steeve Morin</a>, who helped get us started on this front.)</p>
<p>Apple has a suite of tools for diagnosing memory usage and <a href="https://developer.apple.com/videos/play/wwdc2021/10180">pretty videos</a> explaining them. These tools provided a way to answer the key question: “How does iOS account for our memory usage?”</p>
<p>The simplest of these tools is <a href="https://www.unix.com/man-page/osx/1/footprint/">footprint</a>. You can run footprint on a running process or a memgraph file captured via Xcode, and it’ll spit out something like this (taken from a recent dev version of Tailscale on iOS):</p>
<pre tabindex="0"><code>======================================================================
IPNExtension [2921] (memgraph): 64-bit	Footprint: 13 MB (16384 bytes per page)
======================================================================

  Dirty      Clean  Reclaimable    Regions    Category
    ---        ---          ---        ---    ---
9040 KB        0 B       304 KB         36    untagged (&#34;VM_ALLOCATE&#34;)
1568 KB    1040 KB          0 B        131    __DATA_CONST
 514 KB      32 KB          0 B        123    __DATA
 416 KB        0 B          0 B          6    MALLOC_TINY
 416 KB        0 B          0 B         26    stack
 384 KB        0 B        16 KB          6    MALLOC_SMALL
 262 KB        0 B          0 B        104    __DATA_DIRTY
 257 KB        0 B          0 B        485    unused dyld shared cache area
 112 KB        0 B          0 B          9    malloc metadata
  85 KB        0 B          0 B         61    __AUTH
  80 KB        0 B          0 B          3    MALLOC_LARGE
  64 KB        0 B          0 B          1    libdispatch
  48 KB    4528 KB          0 B        157    __TEXT
  48 KB    1216 KB          0 B          5    mapped file
  32 KB        0 B          0 B          1    Activity Tracing
  27 KB        0 B          0 B        132    __AUTH_CONST
  16 KB        0 B          0 B          1    Foundation
  16 KB        0 B          0 B          1    os_alloc_once
  16 KB        0 B          0 B          1    __OBJC_RW
 7160 B        0 B          0 B         47    __OBJC_CONST
    0 B     256 KB          0 B          7    __LINKEDIT
    0 B        0 B          0 B          2    __OBJC_RO
    0 B        0 B          0 B          1    __UNICODE
    ---        ---          ---        ---    ---
  13 MB    7072 KB       320 KB       1347    TOTAL

Auxiliary data:
	phys_footprint_peak: 13 MB
	phys_footprint: 13 MB
</code></pre><p>According to iOS, this process is using 13MB, perilously close to our 15MB limit. Most of that is normal memory allocations requested by the Go runtime (VM_ALLOCATE). Another tool, <a href="https://www.unix.com/man-page/osx/1/vmmap/">vmmap</a> gives you a much more fine-grained look at your memory usage.</p>
<p>After (mostly) running out of runway changing our Go code and messing with the Go runtime, we gave up on shrinking VM_ALLOCATE and turned our attention to the second biggest entry above: __DATA_CONST.</p>
<h3 id="__data_const">__DATA_CONST</h3>
<p>What even is __DATA_CONST? And why would constant data have dirty pages? A dirty page in memory is a page that the OS can’t just throw away and recreate as needed; it must be stored somehow. But if a page contains constant data, it seems like iOS ought to be able to throw it away and grab that data from the executable again as needed.</p>
<p>To answer those questions requires a digression through <a href="https://en.wikipedia.org/wiki/Relocation_(computing)">relocations</a> and <a href="https://en.wikipedia.org/wiki/Position-independent_code">position-independent executables</a>.</p>
<p>When running an executable, the code has to live somewhere in memory. Each function has an address. If you know exactly where the code will be in memory, then when one function calls another, you can hard-code its address right in the binary.</p>
<p>But knowing in advance exactly where everything will be in memory makes an <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">attacker’s job much easier</a>, so iOS (among others) requires that an executable be able to function correctly no matter where in memory it is placed, that is, be position independent. This means that memory addresses cannot be hard-coded.</p>
<p>To make this work, executables contain relocations. These are instructions to the operating system telling it how to modify the executable based on its location in memory. A typical relocation might say: “change the 8 bytes at location X in the executable to be the base memory address of the executable plus offset Y, using little-endian encoding”. When iOS launches an executable, it picks a random base address, applies all relocations, and then runs the executable.</p>
<p>As another protection against attackers, memory can be marked as read-only. This can happen <a href="https://man7.org/linux/man-pages/man2/mprotect.2.html">at run time</a>, but you can also request that parts of the executable be marked as readonly at the time that the OS loads it into memory, before it starts running. As a special case, you can also request that the OS first apply all relocations, then mark the memory as read-only. And that memory is our __DATA_CONST category above. It is constant now, but it has been modified, and is thus dirty. (A sufficiently clever OS could still recreate it on demand by re-applying all relocations as needed, but iOS does not.)</p>
<h3 id="improving-the-go-linker">Improving the Go linker</h3>
<p>If we could get rid of those relocations, then those pages would never get dirtied, and we’d save some memory. You can use <a href="https://www.unix.com/man-page/osx/1/dyldinfo/">dyldinfo</a> tool to inspect the relocations in an executable. We wrote a <a href="https://gist.github.com/josharian/4ed18ab0c2dd84b51cb45de14e8be36c">quick script</a> to model the relocations in our executable, and it matched iOS’s accounting. We then sampled the relocations, comparing them to the output of <a href="https://pkg.go.dev/cmd/nm">go tool nm</a> to figure out what they were pointing to, and looked into whether we could get rid of any of them.</p>
<p>Our analysis suggested we could eliminate about half of them, which would generate memory savings of almost 1MB. And, just as importantly, would let us worry less about adding additional code to the app. The number of relocations scaled with the amount of code, so merely adding UPnP support would cost us precious memory right out of the gate. With fewer relocations, that cost would go down.</p>
<p>The relocations were in Go’s <a href="https://github.com/golang/go/blob/master/src/debug/gosym/pclntab.go">pclntab</a>, short for “PC line table”. It was originally used to associate parts of the executable code (program counters, or PCs) with the original lines of Go code, so that panics could print nice stack traces and you could use <a href="https://pkg.go.dev/runtime#Callers">runtime.Callers</a> and friends. It has since grown to include lots of runtime metadata, for use by the garbage collector, the scheduler, and more.</p>
<p>These relocations were all of the form “add X to the executable’s base address”. But we can do addition at runtime too. Instead of a relocation, we could write only the offset, and then do the math as needed at runtime.</p>
<p>We reached out to the Go team and learned that this was something that they also wanted, so we proceeded to <a href="https://github.com/tailscale/go/pull/20">make it so</a>. The work spanned multiple packages and dozens of commits, with the usual amount of build breakage and yak shave-age. (Big, big hat tip to <a href="https://github.com/cherrymui">Cherry Mui</a>, whose assistance was invaluable throughout this effort.)</p>
<p>The impact of removing these relocations was not limited to our iOS memory woes. It helped all builds for which Go produces position independent executables (such as darwin/arm64), and to a lesser extent even those that don’t (such as linux/amd64).</p>
<p>Relocations are larger than offsets. Binary sizes shrank almost 5% for darwin/arm64 and almost 3% for linux/amd64.</p>
<p>Constructing, tracking, and writing a relocation is more work than writing an offset. The linker itself got faster and uses less memory. Linking the compiler got 30% faster and used 55% less RAM for darwin/arm64, and 4% faster with 10% less RAM for linux/amd64.</p>
<p>These improvements should be generally available as part of the <a href="https://github.com/golang/go/wiki/Go%2DRelease%2DCycle">Go 1.18 release</a>.</p>
<h3 id="wait-you-did-what">Wait, you did what?</h3>
<p>Time for the philosophizing I promised.</p>
<p>People are often surprised and sometimes horrified when they learn that Tailscale maintains its own fork of the Go toolchain. Tailscale is a small startup. Isn’t that a horrible distraction, a flagrant burning of <a href="https://mcfunley.com/choose-boring-technology">innovation tokens</a>?</p>
<p>Maybe. But the thing is, you write code with the engineers you have.</p>
<p>We had a problem: We kept crashing on iOS, and in addition to being awful, it was preventing us from adding features.</p>
<p>Another team might have decided to cut even more features on iOS to try to achieve stability, or limited in some way the size of the tailnet that iOS could interact with.</p>
<p>Another team might have radically redesigned the data structures to squeeze every last drop out of them.</p>
<p>Another team might have rewritten the entire thing in Rust or C.</p>
<p>Another team might have decided to accept the crashes and attempted to mitigate the pain by making re-establishment of connections faster.</p>
<p>Another team might have decided to just live with it and put their focus elsewhere.</p>
<p>The Tailscale team has Go expertise, spanning the standard library to the toolchain to the runtime to the ecosystem. <a href="https://danluu.com/in-house/">It’s an asset</a>, and it would be foolish not to use it when the occasion arises. And the fun thing about working on low level, performance-sensitive code is that that occasion arises with surprising frequency.</p>
<p>Blog posts about how people solve their problems are fun and interesting, but they must always be taken with a healthy dose of context. There may be no other startups in existence for which working on the Go linker would be a sensible choice, but it was for us.</p>
<h3 id="surprise-twist-ending">Surprise twist ending</h3>
<p>With the Go linker work <a href="https://github.com/tailscale/go/pull/20">newly completed</a>, we set out to confirm our analysis. What would footprint say?</p>
<p>As expected, footprint approved:</p>
<pre tabindex="0"><code> 708 KB    1664 KB          0 B        218    __DATA_CONST
</code></pre><p>Down from 1568KB to 708KB. Not bad. And did footprint still match iOS’s opinion?</p>
<p>We expected to see our free memory reported go up by about 1MB. And instead it went up…36MB.</p>
<p>Huh?</p>
<p>While we were busy fixing the linker to save 1MB, iOS 15 launched and quietly gave us 35MB more.</p>
<p>Thanks, iOS!</p>
    </div></div>
  </body>
</html>
