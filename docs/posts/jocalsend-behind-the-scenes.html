<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://proclamations.nebcorp-hias.com/rnd/jocalsend-development/">Original</a>
    <h1>Jocalsend: behind the scenes</h1>
    
    <div id="readability-page-1" class="page"><section>
            <p>Recently, I released a piece of software called <a href="http://odb.ar/sundries/jocalsend/"><code>jocalsend</code></a>, to great
acclaim. In that post announcing it, I wrote,</p>
<blockquote>
<p>I plan on writing a follow-up about the design and implementation of jocalsend, but that&#39;s going
to be a much longer and even-more-niche-interest post, so I&#39;ll just skip that for now.</p>
</blockquote>
<p>It seems that now the time has come to fulfill that promise. If the nittty-gritty of the
implementation and design of terminal-UI async Rust programs is your jam, then today is your lucky
day.</p>
<h2 id="humble-beginnings">Humble beginnings</h2>
<p>Once I learned about the existence of LocalSend and had decided to write a TUI version, I looked
around for any existing Rust crates that might have already made some in-roads on that problem.
Right off the bat, I found <a href="https://github.com/wylited/localsend">this one, called <code>localsend</code></a>,
which sounded promising. I cloned the repo and took a look.</p>
<p>There wasn&#39;t any example code using it, but it wasn&#39;t too tough to <a href="https://git.kittencollective.com/nebkor/joecalsend/src/commit/c422bbcd00070140f77466ff576dbc1c37dce7e7/src/main.rs">whip up a simple
toy</a>
to try it out:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>joecalsend::{models::device::DeviceInfo, Client};
</span><span>
</span><span>#[</span><span>tokio</span><span>::</span><span>main</span><span>]
</span><span>async </span><span>fn </span><span>main</span><span>() {
</span><span>    </span><span>let</span><span> device = DeviceInfo::default();
</span><span>    dbg!(device);
</span><span>
</span><span>    </span><span>let</span><span> client = Client::with_config(
</span><span>        DeviceInfo::default(),
</span><span>        </span><span>53317</span><span>,
</span><span>        &#34;</span><span>/home/ardent/joecalsend</span><span>&#34;.</span><span>into</span><span>(),
</span><span>    )
</span><span>    .await
</span><span>    .</span><span>unwrap</span><span>();
</span><span>    </span><span>let </span><span>(h1, h2, h3) = client.</span><span>start</span><span>().await.</span><span>unwrap</span><span>();
</span><span>    tokio::join!(h1, h2, h3);
</span><span>}
</span></code></pre>
<p>Running it produced the following, including a log line from me sending a screenshot of LocalSend on
my phone to &#34;joecalsend&#34; on my desktop:</p>
<pre><code><span>[src/main.rs:6:5] device = DeviceInfo {
</span><span>    alias: &#34;RustSend&#34;,
</span><span>    version: &#34;2.1&#34;,
</span><span>    device_model: None,
</span><span>    device_type: Some(
</span><span>        Headless,
</span><span>    ),
</span><span>    fingerprint: &#34;01K43EBSN50004H9BRHK2AE45X&#34;,
</span><span>    port: 53317,
</span><span>    protocol: &#34;http&#34;,
</span><span>    download: false,
</span><span>    announce: Some(
</span><span>        true,
</span><span>    ),
</span><span>}
</span><span>Socket local addr: 0.0.0.0:53317
</span><span>Listening on multicast addr: 224.0.0.167:53317
</span><span>HTTP server listening on 0.0.0.0:53317
</span><span>Error during HTTP announcement: Request error: error sending request for url (http://192.168.1.110:53317/api/localsend/v2/register)
</span><span>Error during HTTP announcement: Request error: error sending request for url (http://192.168.1.110:53317/api/localsend/v2/register)
</span><span>Error during HTTP announcement: Request error: error sending request for url (http://192.168.1.110:53317/api/localsend/v2/register)
</span><span>Error during HTTP announcement: Request error: error sending request for url (http://192.168.1.110:53317/api/localsend/v2/register)
</span><span>Received upload request from alias: phone
</span></code></pre>
<p>On my phone, it showed up like this:</p>
<p><img src="https://proclamations.nebcorp-hias.com/rnd/jocalsend-development/./first_working_version_on_phone.png" alt="first version on the phone"/></p>
<p>When it came time to approve the send request, a GUI dialog popped up on my desktop:</p>
<p><img src="https://proclamations.nebcorp-hias.com/rnd/jocalsend-development/./rustsend_native_dialog.png" alt="native-dialog pop-up"/></p>
<p>This was a hugely validating step for me, since it showed that I could interact with the reference
LocalSend app <em>at all</em>. It gave me the confidence I needed to press forward with more, more
complicated, work. It&#39;s hard to overstate the benefit of this kind of early affirmation, which
proves out the fundamental assumptions, like, &#34;interoperating with the official implementation is
possible.&#34; I highly recommend getting something working as end to end as possible, as quickly as possible.</p>
<p>Since I wanted to make a terminal version, I knew I&#39;d need to get rid of that GUI piece of the
backend, which is a nice segue into...</p>
<h3 id="great-artists-steal-an-original-phrase-copyright-me"><em>Great artists steal</em> -- an original phrase, copyright: me</h3>
<p>The astute may have noticed that my toy program was not doing <code>use localsend::{...}</code>, but rather,
<code>use joecalsend::{...}</code>. This was because as convenient as just using <code>localsend</code> as a
3rd-party dependency would be, I knew I&#39;d need to change it so much that simply copying its source
code into my project would be much easier and faster than trying to get my changes accepted in a
stranger&#39;s project. Plus I&#39;m a fan in general of having as much control as possible
over your critical dependencies, and nothing is more controlled than simply inlining them into your
own stuff. Luckily, localsend was released under the terms of the <a href="https://git.kittencollective.com/nebkor/joecalsend/src/commit/c422bbcd00070140f77466ff576dbc1c37dce7e7/3P-LICENSE.txt">Apache
license</a>,
which permits this kind of chicanery.</p>
<p>In addition to needing to ditch the GUI dialog, I wanted to add support for HTTPS, as well as stuff
like persistent configuration files. The initial backend code from this first commit was 825 lines;
at the time of writing, the latest version of jocalsend&#39;s backend is 1252 lines, about
1.5x as long.</p>
<p>As it was, though, this initial version couldn&#39;t do much besides announce itself as a peer on the
local subnetwork, and receive files from other peers, saving them to a hard-coded location in my
homedir; the commit message from this first commit was simply: &#34;can receive text and files&#34;. It was
time to start thinking about an actual interactive user interface.</p>
<h2 id="cooking-up-a-terminal-ui-with-ratatui">Cooking up a terminal UI with Ratatui</h2>
<p>I knew that I wanted to use <a href="https://ratatui.rs/">ratatui</a> for my frontend. In its words, it&#39;s</p>
<blockquote>
<p>... a Rust library for cooking up delicious TUIs (terminal user interfaces). It is a
lightweight library that provides a set of widgets and utilities to build simple or complex rust
TUIs.</p>
</blockquote>
<p>I&#39;d had some previous exposure to <a href="https://github.com/fdehau/tui-rs/">tui-rs</a>, of which ratatui was
a blessed fork and continuation, but hadn&#39;t done too too much with it. Still, it was the framework
powering a few TUI apps I was already familiar with and a fan of, like <a href="https://atuin.sh/">Atuin</a>
and <a href="https://yazi-rs.github.io/">Yazi</a>, so it wasn&#39;t really a hard decision.</p>
<p>However, I didn&#39;t have <em>much</em> exposure to it, nor do I typically do much frontend development; I joke
that most of the software I write uses a network and logs as the UI. Another tiny thing is that most
of the Ratatui examples were not async, and jocalsend definitely was. I decided to get my feet wet
by opening a <a href="https://github.com/ratatui/crates-tui/pull/142">pull request</a> to do some code updates
for a Ratatui <a href="https://github.com/ratatui/crates-tui">example application</a> that used the
<a href="https://tokio.rs/">Tokio</a> async runtime, which jocalsend also used.</p>
<p>Once I had that merged, I finally got to work on the actual TUI portion of jocalsend, <a href="https://git.kittencollective.com/nebkor/joecalsend/src/commit/f7295233440567009a1b53ff358c6e1d566b49c1/src/main.rs#L48-L147">which started
out quite
humbly</a>;
it had been two days since I started the project. It didn&#39;t actually do anything except display a
frame with &#34;Counter App Tutorial&#34; (an artifact of stealing from a <a href="https://ratatui.rs/tutorials/counter-app/">Ratatui
tutorial</a>) and accept <code>q</code> as a way to quit the program,
but it was a start.</p>
<p>After about a week of banging on the frontend, I was <a href="https://git.kittencollective.com/nebkor/joecalsend/commit/5f2e2f3eb2ca359601ac2b23d94c73a4f327527f">able to
remove</a>
the dependency on the <code>native-dialog</code> GUI notification library, and rely solely on terminal
interaction. The look of it was very close to the final version, though functionality was still
limited:</p>
<p><img src="https://proclamations.nebcorp-hias.com/rnd/jocalsend-development/./no_more_gui_dialog.png" alt="first full tui"/></p>
<p>By this time, the lines of frontend code was just over half as many as backend; 497 vs. 943,
respectively. The greatest challenge I&#39;d faced and overcome with the frontend was getting the
&#34;Listeners&#34; widget to display text featuring both left AND right justification, <em>on the same line</em>
(the solution was to use a table).</p>
<p>After another five or so days, it was looking <em>very</em> close to its final form. I was able to send and
receive both files and text, with preview for text shown:</p>
<p><img src="https://proclamations.nebcorp-hias.com/rnd/jocalsend-development/./almost_1_dot_0.png" alt="almost 1.0"/></p>
<p>Around that time, I was chatting about it with some colleagues, and made a list of things I wanted
before 1.0:</p>
<blockquote>
<ul>
<li>https (self-signed certs)</li>
<li>persistent identity (currently it generates a new self-id every time its run, but it once there&#39;s https, the id will be the sha256 of the private key)</li>
<li>related to the above, configuration files and persistent ssl keys for identity</li>
<li>CLI flags to just invoke it with text or file already input or selected</li>
<li>filtering of files in the file browser, currently you need to navigate with arrows and enter key</li>
<li>readme/documentation</li>
<li>change name from joecalsend to jocalsend</li>
</ul>
</blockquote>
<p>and a few days after that, everything but file filtering was done, and I felt comfortable enough to
release the first version on <a href="https://crates.io/crates/jocalsend/1.0.0">crates.io</a>. For the 1.0
release, the amounts of backend and frontend code were nearly the same, at 1180 vs 919 lines
respectively.</p>
<h2 id="back-to-backend">Back to backend</h2>
<p>By now, the frontend was at least <em>looking</em> complete, so I turned most of my attention back to some
outstanding issues on the backend (though I did take a couple hours to <a href="https://git.kittencollective.com/nebkor/joecalsend/commit/8150bfacf24622cbbc501d2674554891ec601122">add fuzzy file
selection</a>
to the frontend).</p>
<h3 id="i-smell-trouble">I smell trouble...</h3>
<p>There was still something bothering me, though, and it turns out it was a pretty serious bug. Here&#39;s
a high-level diagram of the main application event loop:</p>
<p><img src="https://proclamations.nebcorp-hias.com/rnd/jocalsend-development/./jocalsend_application_runloop.png" alt="jocalsend frontend event loop"/></p>
<p>Shortly before the 1.0 release, here&#39;s what it looked like in code, roughly:</p>
<pre data-lang="rust"><code data-lang="rust"><span>    </span><span>loop </span><span>{
</span><span>        terminal.</span><span>draw</span><span>(|</span><span>frame</span><span>| app.</span><span>draw</span><span>(frame))?;
</span><span>
</span><span>        app.</span><span>handle_events</span><span>().await?;
</span><span>
</span><span>        </span><span>if</span><span> app.</span><span>screen</span><span>() == CurrentScreen::Stopping {
</span><span>            </span><span>break</span><span>;
</span><span>        }
</span><span>    }
</span></code></pre>
<p>Note that all the <code>handle_*()</code> methods are async; <code>handle_keyboard()</code> could potentially invoke a
number of actions, which are not shown for simplicity.</p>
<p>Following the chain from <code>handle_events()</code> to <code>prepare_upload()</code>, we have a sequence of async
calls until we finally get to the following in the <a href="https://git.kittencollective.com/nebkor/joecalsend/src/commit/d84a046ec9e745561d63a70298423b1498096e05/src/transfer.rs#L65-L79">backend
code</a>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>        </span><span>let</span><span> response = </span><span>self
</span><span>            .client
</span><span>            .</span><span>post</span><span>(format!(
</span><span>                &#34;</span><span>{}</span><span>://</span><span>{}</span><span>/api/localsend/v2/prepare-upload</span><span>&#34;,
</span><span>                device.protocol, addr
</span><span>            ))
</span><span>            .</span><span>json</span><span>(&amp;PrepareUploadRequest {
</span><span>                info: </span><span>self</span><span>.config.device.</span><span>clone</span><span>(),
</span><span>                files: files.</span><span>clone</span><span>(),
</span><span>            })
</span><span>            .</span><span>timeout</span><span>(Duration::from_secs(</span><span>30</span><span>)).</span><span>send</span><span>().await?;
</span></code></pre>
<p>What&#39;s happening there is that the backend is making an HTTP request to the peer in order to get
permission to upload files to that remote. This manifests on the remote (receiving) side as an
interactive dialog where the user approves or denies the request.</p>
<p>Meanwhile, the future from that request is just sitting there waiting for the remote peer to reply,
which means that <code>handle_events()</code> is <em>also</em> just sitting there waiting for <code>prepare_upload()</code>. This
blocked the main frontend application runloop, which was bad user experience.</p>
<p>For the 1.0 release, I changed the runloop to look like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>    </span><span>let mut</span><span> alarm = tokio::time::interval(Duration::from_millis(</span><span>200</span><span>));
</span><span>    </span><span>loop </span><span>{
</span><span>        terminal.</span><span>draw</span><span>(|</span><span>frame</span><span>| app.</span><span>draw</span><span>(frame))?;
</span><span>
</span><span>        tokio::select! {
</span><span>            res = app.</span><span>handle_events</span><span>() =&gt; {
</span><span>                res?;
</span><span>            }
</span><span>            _ = alarm.</span><span>tick</span><span>() =&gt; {}
</span><span>        }
</span><span>
</span><span>        </span><span>if</span><span> app.</span><span>screen</span><span>() == CurrentScreen::Stopping {
</span><span>            </span><span>break</span><span>;
</span><span>        }
</span><span>    }
</span></code></pre>
<p>The big difference there is that I&#39;ve introduced a timeout (&#34;alarm&#34;) that fires every 200
milliseconds, and put it into a
<a href="https://docs.rs/tokio/latest/tokio/macro.select.html"><code>tokio::select</code></a> branch along with the call
to <code>handle_events()</code>. <code>tokio::select</code> is a way to simultaneously wait on multiple futures; it
polls each future in a random order until one of them completes, and then cancels the rest.</p>
<p>This meant that it would only wait 200 milliseconds for the <code>prepare_upload()</code> future to complete,
and hence the <code>handle_events()</code> future to complete. Since it required a human person on the remote
side to see and respond to that request in that time, it meant that actually sending files was
completely broken.</p>
<p>At the time, I didn&#39;t quite realize this, because during my testing, I was using the text-sending
functionality rather than trying to send actual files. One quirk of the official LocalSend app is
that when it receives plain text, it does not offer you the ability to download it, or approve the
download; you can copy it to your clipboard or close the request, and that&#39;s it. So when the
<code>prepare_upload()</code> future was canceled, nothing seemed out of the ordinary on the remote side. Had
I tried sending a file, an error would have shown on the remote side when I tried to accept it.</p>
<p>Despite my blissful ignorance, I knew that this design was not correct, and a few days later I&#39;d
<a href="https://git.kittencollective.com/nebkor/joecalsend/src/commit/7eece474a326091c8d1ac354908aa2212a9ba024/src/transfer.rs#L103-L171">updated the <code>prepare_upload()</code>
code</a>
to spawn a separate <a href="https://docs.rs/tokio/latest/tokio/task/fn.spawn.html">Tokio task</a> that would
run on its own and communicate back to the frontend via a
<a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/fn.channel.html">channel</a>. The main app runloop was
changed back to the version without <code>tokio::select!</code>, and all was well.</p>
<h3 id="multi-woes">Multi-woes</h3>
<p>There were a couple other annoyances I&#39;d noticed but hadn&#39;t dug into, but the time had come to
vanquish them. Most notably, it would sometimes get confused about the IP of remote peers after
receiving a remote peer&#39;s multicast datagram <em>from its own IP</em>, and think that its own IP was the
peer&#39;s. This would cause it to be unable to send text or files, though it could still receive. The
official LocalSend app never had this issue, so I decided to see what it did differently.</p>
<p>I noticed that it was setting the TTL on its multicast packets, used for discovery, to 1:</p>
<p><img src="https://proclamations.nebcorp-hias.com/rnd/jocalsend-development/./localsend_multicast_packet.png" alt="LocalSend multicast packet dump"/></p>
<p>while jocalsend <a href="https://git.kittencollective.com/nebkor/joecalsend/src/commit/7eece474a326091c8d1ac354908aa2212a9ba024/src/lib.rs#L118">set the TTL to
8</a>.
While looking at that, I also noticed that multicast loopback <a href="https://git.kittencollective.com/nebkor/joecalsend/src/commit/7eece474a326091c8d1ac354908aa2212a9ba024/src/lib.rs#L117">was
enabled</a>.
And for that matter, it was <a href="https://git.kittencollective.com/nebkor/joecalsend/src/commit/7eece474a326091c8d1ac354908aa2212a9ba024/src/lib.rs#L119">using
<code>0.0.0.0</code></a>
as the interface joining the multicast group, which was probably more promiscuous than I wanted.</p>
<p>Ultimately, the multicast setup went from,</p>
<pre data-lang="rust"><code data-lang="rust"><span>    socket.</span><span>set_multicast_loop_v4</span><span>(</span><span>true</span><span>)?;
</span><span>    socket.</span><span>set_multicast_ttl_v4</span><span>(</span><span>8</span><span>)?; </span><span>// 8 hops out from localnet
</span><span>    socket.</span><span>join_multicast_v4</span><span>(</span><span>MULTICAST_IP</span><span>, Ipv4Addr::from_bits(</span><span>0</span><span>))?;
</span></code></pre>
<p>to,</p>
<pre data-lang="rust"><code data-lang="rust"><span>    socket.</span><span>set_multicast_loop_v4</span><span>(</span><span>false</span><span>)?;
</span><span>    socket.</span><span>set_multicast_ttl_v4</span><span>(</span><span>1</span><span>)?; </span><span>// local subnet only
</span><span>    socket.</span><span>join_multicast_v4</span><span>(</span><span>MULTICAST_IP</span><span>, local_ip_addr)?;
</span></code></pre>
<p>and that solved the issue where jocalsend would receive remote datagrams from its own IP.</p>
<h3 id="rust-too-fancy">Rust too fancy</h3>
<p>I&#39;d made a <a href="https://crates.io/crates/jocalsend/versions">few more releases</a> with the fixes outlined
above, but then I got some reports of people running into build issues when trying to install with a
reasonably up-to-date rustc:</p>
<pre><code><span>error[E0658]: let expressions in this position are unstable
</span><span>--&gt; /home/ygingras/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/jocalsend-1.6.18033/src/app/widgets.rs:415:12
</span><span>|
</span><span>415 | if let Some(md) = request.files.values().next()
</span><span>| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span>|
</span><span>= note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information
</span></code></pre>
<p>Visiting the <a href="https://github.com/rust-lang/rust/issues/53667">issue from the error message</a>, it
shows that the feature was stabilized in Rust version 1.88, one version behind the latest stable
version. The solution was to add a <a href="https://doc.rust-lang.org/cargo/reference/rust-version.html">minimum supported Rust
version</a> to jocalsend&#39;s <code>Cargo.toml</code>
file, like,</p>
<pre data-lang="toml"><code data-lang="toml"><span>[package]
</span><span>name </span><span>= &#34;</span><span>jocalsend</span><span>&#34;
</span><span>edition </span><span>= &#34;</span><span>2024</span><span>&#34;
</span><span>rust-version </span><span>= &#34;</span><span>1.89</span><span>&#34;
</span></code></pre>
<p>Once that was done, I <a href="https://crates.io/crates/jocalsend/1.6.180339">released a new version</a> with
it, and confirmed with the users that it was working correctly.</p>
<h2 id="summary-by-the-numbers">Summary, by the numbers</h2>
<p>As of writing this, on September 2, 2025, we have the following stats:</p>
<ul>
<li>2472 total lines of code
<ul>
<li>1252 in the backend</li>
<li>1220 in the frontend</li>
</ul>
</li>
<li>1575 downloads from <code>crates.io</code></li>
<li>122 commits on the <code>main</code> branch</li>
<li>7 published versions</li>
<li>5 pull requests merged in other projects&#39; repos:
<ul>
<li>update <a href="https://github.com/ratatui/crates-tui/pull/143"><code>ratatui/crates-tui</code></a> to edition2024</li>
<li>update code patterns in <a href="https://github.com/ratatui/crates-tui/pull/142"><code>ratatui/crates-tui</code></a></li>
<li>add methods to increment or decrement log levels in <a href="https://github.com/rust-lang/log/pull/692"><code>rust-lang/log</code></a> (merged while I was writing this post!)</li>
<li>upstream my backend changes to <a href="https://github.com/wylited/localsend/pull/1"><code>wylited/localsend</code></a></li>
<li>add method to reset the state of the fuzzy matcher in <a href="https://github.com/andylokandy/simsearch-rs/pull/17"><code>andylokandy/simsearch-rs</code></a></li>
</ul>
</li>
<li>1 developer</li>
</ul>
<h2 id="what-s-next">What&#39;s next?</h2>
<p>I believe in software being &#34;done&#34;, and this software is pretty close. There are a couple small QoL
features I want to add, like putting the CWD in the file picking widget, and I want to update some
of the deps to use newly-released functionality (like removing <a href="https://git.kittencollective.com/nebkor/joecalsend/src/commit/4d78d67abeeecd3b986b3b016ffac61761184778/src/app/mod.rs#L152">this bit of <code>unsafe</code>
code</a>
to change the log level in favor of using the methods I added in the PR linked above).</p>
<p>I&#39;m also aware that I&#39;m not validating the remote SSL certs, which are self-signed; I&#39;m not even
noting their fingerprints in some application storage so I can check that they don&#39;t change
unexpectedly. This means that someone could, with enough preparation or luck, do a
person-in-the-middle attack and defeat the point of using SSL in the first place. I&#39;m not sure what
the best thing to do here is, though I do want to do something.</p>
<p>But beyond those things, I don&#39;t think I&#39;ll be doing much more development on it. I&#39;ll continue to
use and enjoy it, though!</p>
<h3 id="ooooh-shiny">Ooooh, shiny</h3>
<p>That&#39;s not to say that I&#39;m done with this type of software. While I was writing jocalsend, I learned
about <a href="https://www.iroh.computer/">Iroh</a>, which is a Rust library that &#34;lets you establish direct
peer-to-peer connections whenever possible, falling back to relay servers if necessary. This gives
you fast, reliable connections that are authenticated and encrypted end-to-end using
<a href="https://en.wikipedia.org/wiki/QUIC">QUIC</a>.&#34;</p>
<p>It would be neat to build a version of jocalsend with Iroh; the frontend code from jocalsend should
work almost without modification. I even have a name ready: &#34;jirohsend&#34;.</p>
<p>Of course, I&#39;d need to build a mobile app for jirohsend, but I have a little bit of experience
building <a href="https://git.kittencollective.com/nebkor/cuttle">Flutter apps with Rust backends</a>, and I
don&#39;t think it would need a more complicated UI than the existing LocalSend Flutter app.</p>
<p>So if something like jirohsend sounds interesting to you, you know where to look for updates!</p>
<hr/>







        </section></div>
  </body>
</html>
