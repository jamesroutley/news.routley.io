<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://roguesecurity.dev/blog/systemd-hardening">Original</a>
    <h1>SystemD Service Hardening</h1>
    
    <div id="readability-page-1" class="page"><div><p>Controversy aside, systemd provides us a very complete, robust method of controlling services (amongst a multitude of other Linux things). For a lot of things though, this is optimized for success out of the box and not necessarily security. Such is the way of many IT endeavors. This doc though is meant to provide a snapshot of a number of hardening options that you can apply to systemd service units and podman quadlets to increase the overall security posture and reduce both the likelihood of compromise, as well as the blast radius post-exploitation.</p><div><p>By no means is this a prescriptive guide for securing systemd services. All services will require different configurations based on their required capabilities. You will have to experiment and review logs when things inevitably break to make corrections. Securing your infrastructure is your responsibility and this is meant to be a tool in your belt, not a guaranteed solution.</p></div><h2 id="systemd-security-analysis">SystemD Security Analysis</h2><p>Before we can decide how to increase our systemd unit’s security, we have to understand where we’re starting. There’s a tool for this. You can run it to analyze the entirety of the list of deployed units, or you can analyze one specific unit and all its details. The latter is the method that we’ll mostly focus on here, but for the sake of thoroughness I will show you both. The former is a good way of getting a high-level idea of your overall system’s security posture.</p><p>In a terminal, run the following…</p><pre data-language="bash" tabindex="0"><code><span><span>sudo</span><span> systemd-analyze</span><span> security</span></span></code></pre><p>You should see something like this…</p><p><img src="https://roguesecurity.dev/images/systemdsecurity1.png" alt="A service list with security ratings from the output of the systemd-analyze security command"/></p><astro-island await-children="" client="load" component-export="default" component-url="/_astro/Accordion.CLXFOusa.js" opts="{&#34;name&#34;:&#34;Accordion&#34;,&#34;value&#34;:true}" prefix="r71" props="{&#34;title&#34;:[0,&#34;BONUS: Trivia!&#34;]}" renderer-url="/_astro/client.D2WMwoKK.js" ssr="" uid="1dLeju"><div><div><astro-slot><p>Bonus points for anyone who can tell me what distribution I’m running based solely on the above content…</p></astro-slot></div></div><!--astro:end--></astro-island><p>So, that’s a lot of red… Is Linux inherently insecure…? Well, no, but also yes. Linux has lots of issues with it, just as any behemoth of an operating system, but we have a lot going for us too, and let’s talk about that.</p><p>And yes, for all the Stallman incarnates out there, I understand that Linux is a kernel and GNU corelibs and userspace all unite in some unholy ceremony to make a usable operating system. For the bulk of the userbase though, this ultimately doesn’t matter. Language also has the neat capability to evolve based on its accepted understanding. Everyone knows what is meant when an operating system is referred to as “Linux” and that’s what matters.</p><p>Systemd ships a lot of functionality, and a lot of services. Because having a usable operating system for most people means making a lot of these services work together, systemd has some loose security defaults. It also gives us a method to harden this up though, depending on our usecase! Let’s look at a specific example service.</p><p>Run the same command as before, but this time append a service name as the last argument. I’m choosing <code>sshd.service</code> as an example.</p><pre data-language="bash" tabindex="0"><code><span><span>sudo</span><span> systemd-analyze</span><span> security</span><span> sshd.service</span></span></code></pre><p><img src="https://roguesecurity.dev/images/systemdsecurity2.png" alt="The output of systemd-analyze security for a default sshd.service unit"/></p><p>…and that’s not even the end of the list. Yikes!</p><h4 id="what-it-means">What it Means</h4><p>So there are a few components in the table that we need to look at:</p><ol><li>Checkmark / X: This is a boolean indicator to tell you if a positive security measure in place for the given control.</li><li>Name: The capability name. This is what you’ll reference when changing these security settings in the unit file (or override stub)</li><li>Description: A plain-language description of what the capability provides</li><li><strong>Exposure: A quantitative metric that “scores” risk for the given control.</strong></li></ol><p>The last is the only quantitative value we have here, so use this to triage changes so you can get the most bang for your buck.</p><h4 id="how-to-change-it">How to Change It</h4><p>Okay, so we have an idea of where we’re starting as far as exposure, we have quantitative metrics for effect of certain keys, and we have a list of keys. What now?</p><p>All of these security key changes are placed into the <code>[Service]</code> section of a systemd unit file, or the <code>[Container]</code> section of a podman quadlet. These files will typically be found in <code>/etc/systemd/system/</code> and <code>/etc/containers/systemd/</code> for the system, and various other places if running as a user.</p><div><p>Systemd supports stub file configuration overrides. The daemon will handle creation of these automatically if you edit the file using <code>sudo systemctl edit ServiceName.service</code>. Prefix the command with the environment variable <code>EDITOR=nvim</code> to edit with a superior editor.</p></div><p>Time to make an educated guess and start playing whack-a-mole… The golden rule here is: if a service fails to start after a change, it probably needs the permissions/capabilities you just took away from it.</p><p>Alright, so what moles do we try and whack?</p><h2 id="systemd-service-security-options">SystemD Service Security Options</h2><p>Here’s a (likely incomplete) list of the various security options on a per-service level. The source of truth here are manpages. See: <code>man Capabilities 7</code> and <code>systemd-analyze capabilities</code> as well as <code>man systemd.exec 5</code> for the current list and explanations.</p><ul><li><code>AmbientCapabilities</code></li><li><code>AppArmorProfile</code></li><li><code>CapabilityBoundingSet</code></li><li><code>DeviceAllow</code></li><li><code>DynamicUser</code></li><li><code>Group</code></li><li><code>InaccessiblePaths</code></li><li><code>IPAddressAllow</code></li><li><code>IPAddressDeny</code></li><li><code>LockPersonality</code></li><li><code>MemoryDenyWriteExecute</code></li><li><code>NoExecPaths</code></li><li><code>NoNewPrivileges</code></li><li><code>PrivateDevices</code></li><li><code>PrivateIPC</code></li><li><code>PrivateNetwork</code></li><li><code>PrivateTmp</code></li><li><code>PrivateUsers</code></li><li><code>ProcSubset</code></li><li><code>ProtectClock</code></li><li><code>ProtectControlGroups</code></li><li><code>ProtectHome</code></li><li><code>ProtectHostname</code></li><li><code>ProtectKernelLogs</code></li><li><code>ProtectKernelModules</code></li><li><code>ProtectKernelTunables</code></li><li><code>ProtectProc</code></li><li><code>ProtectSystem</code></li><li><code>ReadOnlyPaths</code></li><li><code>ReadWritePaths</code></li><li><code>RemoveIPC</code></li><li><code>RestrictAddressFamilies</code></li><li><code>RestrictFileSystems</code></li><li><code>RestrictNamespaces</code></li><li><code>RestrictNetworkInterfaces</code></li><li><code>RestrictRealtime</code></li><li><code>RestrictSUIDSGID</code></li><li><code>AmbientCapabilities</code></li><li><code>SocketBindAllow</code></li><li><code>SupplementaryGroups</code></li><li><code>SystemCallArchitectures</code></li><li><code>SystemCallFilter</code></li><li><code>TemporaryFileSystem</code></li><li><code>UMask</code></li><li><code>User</code></li></ul><h3 id="some-explanations">Some Explanations</h3><ul><li><p><code>ProtectSystem</code> — <em>“If set to “<code>strict</code>” the entire file system hierarchy is mounted read-only, except for the API file system subtrees <code>/dev/</code>, <code>/proc/</code> and <code>/sys/</code> (protect these directories using <code>PrivateDevices=</code>, <code>ProtectKernelTunables=</code>, <code>ProtectControlGroups=</code>).”</em></p></li><li><p><code>ReadWritePaths</code> — makes particular paths writable again</p></li><li><p><code>ProtectHome</code> — makes <code>/home/</code>, <code>/root</code>, and <code>/run/user</code> inaccessible</p></li><li><p><code>PrivateDevices</code> — turns off access to physical devices, allows access only to pseudo devices like <code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/random</code></p></li><li><p><code>ProtectKernelTunables</code> — makes <code>/proc/</code> and <code>/sys/</code> read-only</p></li><li><p><code>ProtectControlGroups</code> — makes <code>cgroups</code>accessible read-only</p></li><li><p><code>ProtectKernelModules</code> — denies explicit module loading</p></li><li><p><code>ProtectKernelLogs</code> — restricts access to the kernel log buffer</p></li><li><p><code>ProtectProc</code> — <em>“When set to “invisible” processes owned by other users are hidden from /proc/.”</em></p></li><li><p><code>ProcSubset</code> — <em>“If “pid”, all files and directories not directly associated with process management and introspection are made invisible in the /proc/ file system configured for the unit’s processes.”</em></p></li><li><p><code>NoNewPrivileges</code> — ensures the process cannot gain new privileges through <code>setuid</code>, <code>setgid</code> bits and filesystem capabilities</p></li><li><p><code>ProtectClock</code> — denies writes to system and hardware clocks</p></li><li><p><code>SystemCallArchitectures</code> — if set to <code>native</code>, processes can make only native <code>syscalls</code> (in most cases <code>x86-64</code>)</p></li><li><p><code>RestrictNamespaces</code> — namespaces are mostly relevant to containers, therefore can be restricted for this unit</p></li><li><p><code>RestrictSUIDSGID</code> — prevents the process from setting <code>setuid</code> and <code>setgid</code> bits on files</p></li><li><p><code>LockPersonality</code> — prevents the execution domain from being changed, which could be useful only for running legacy applications or software designed for other Unix-like systems</p></li><li><p><code>RestrictRealtime</code> — realtime scheduling is relevant only to applications that require strict timing guarantees, such as industrial control systems, audio/video processing, and scientific simulations</p></li><li><p><code>RestrictAddressFamilies</code> — restricts socket address families that are available; can be set to <code>AF_(INET|INET6)</code> to allow only IPv4 and IPv6 sockets; some services will need <code>AF_UNIX</code> for internal communication and logging</p></li><li><p><code>MemoryDenyWriteExecute</code> — ensures that the process cannot allocate new memory regions that are both writable and executable, prevents some types of attacks where malicious code is injected into writable memory and then executed; may cause JIT compilers used by JavaScript, Java or .NET to fail</p></li><li><p><code>ProtectHostname</code> — prevents the process from using <code>syscalls</code> <code>sethostname()</code>, <code>setdomainname()</code></p></li><li><p><code>SystemCallFilter</code>: Limits syscall permitted by the service. This is a huge tunable, but can also break things very easily.</p><ul><li><p>Examples:</p><ul><li>Allow only syscalls in group <em>@system-service</em>: SystemCallFilter=@system-service</li><li>Allow syscalls in group <em>@system-service</em> and syscall <em>seccomp</em> except those in group <em>@chown</em>: SystemCallFilter=@system-service seccomp SystemCallFilter=~@chown</li><li>Deny syscalls in group <em>@chown</em> with error <em>EPERM</em> rather than terminating the process: SystemCallFilter=~@chown:EPERM</li></ul></li><li><p>A list of all known syscalls and groups can be obtained via: <code>systemd-analyze syscall-filter</code></p></li><li><p>Rather then killing the process, systemd can also be instructed to return an error code like EPERM for all violations. SystemCallErrorNumber=EPERM</p></li><li><p>See</p><ul><li><code>man systemd.exec(5) → SystemCallFilter</code> (includes a list of <strong>important syscall groups</strong>)</li><li><code>man systemd.exec(5) → SystemCallErrorNumber</code></li><li><code>man errno(3)</code> (available error codes)</li></ul></li></ul></li></ul><div><p>Prefixing the first value in a list with <code>~</code> will make the entire line a negative. For example <code>CapabilityBoundingSet=~CAP_SETUID CAP_SETPCAP</code> <em>REMOVES</em> the <code>setuid</code> and <code>setpcap</code> capabilities.</p></div><h4 id="troubleshooting-syscall-restrictions">Troubleshooting syscall restrictions</h4><p>Luckily, when tuning the <code>SystemCallFilter</code>, we can leverage some specific logs to help us determine what’s breaking. You will require <code>auditd</code> installed and running on your system for this.</p><ol><li>After experiencing a systemd service failure, run:</li></ol><pre data-language="bash" tabindex="0"><code><span><span>sudo</span><span> ausearch</span><span> -i</span><span> -m</span><span> SECCOMP</span><span> -ts</span><span> recent</span></span></code></pre><ol start="2"><li>Look for the line like:</li></ol><pre data-language="bash" tabindex="0"><code><span><span>type</span><span>=</span><span>SECCOMP</span><span> msg</span><span>=</span><span>audit</span><span>(</span><span>08/09/2025</span><span> 14:22:10.314:08</span><span>) </span><span>:</span><span> auid=user</span><span> uid=user</span><span> gid=user</span><span> ses=</span><span>1</span><span> subj==unconfined</span><span> pid=</span><span>42348</span><span> comm=ncat</span><span> exe=/usr/bin/ncat</span><span> sig=SIGSYS</span><span> arch=x86_64</span><span> syscall=socket</span><span> compat=</span><span>0</span><span> ip=</span><span>0x7b9e06e59477</span><span> code=kill</span></span></code></pre><p>and note the value of the <code>syscall</code> key.</p><ol start="3"><li>Add either that specific syscall, or the group to which it belongs into your <code>SystemCallFilter</code> and try again.</li></ol><h3 id="what-should-you-care-about">What should you care about?</h3><p>So this is definitely what some might call a futile process. I don’t entirely disagree. What matters is risk management and threat model. <em>What</em> are you trying to protect yourself against? I’d venture a guess that for most people, it’s not insiders who already have root access to the machine, it’s likely more focused on external threats. With that, I’d recommend starting with <strong>external</strong> facing services, like apache/httpd, nginx, caddy, traefik, ssh, <em>etc.</em></p><p>You don’t need to go through this process for every. single. service. I will say though, if you leverage systemd to run custom commands, like script bundles to leverage in a <code>.timer</code> unit instead of cron — <em>definitely</em> go through this process for them. You know very intimately what they require, they’re far less massive than most OS utilities, and they’re easy to tweak.</p><h4 id="the-cliffnotes">The Cliffnotes</h4><p>Okay, so here’s the list of tunables that I personally go for first:</p><ol><li><code>ProtectSystem=strict</code></li><li><code>PrivateTmp=yes</code></li><li><code>ProtectHome=yes</code> or <code>ProtectHome=tmpfs</code> for services that complain about R/W on an unnecessary home dir.</li><li><code>ProtectClock=yes</code></li><li><code>ProtectKernelLogs=yes</code></li><li><code>ProtectKernelModules=yes</code></li><li><code>RestrictSUIDGUID=yes</code></li><li><code>UMask=0077</code></li><li><code>LockPersonality=yes</code></li><li><code>RestrictRealtime=yes</code></li><li><code>MemoryDenyWriteExecute=yes</code></li><li><code>DynamicUser=yes</code> or <code>User=SOMETHINGOTHERTHANROOT</code></li></ol><p>After that it gets a little less certain on what might break things. Obviously the above won’t work for everything either, but those are the things I start with when tuning. Adding in syscall filtering takes a little longer.</p><h4 id="an-example">An Example</h4><p>Given that this blog runs behind Traefik, here’s an example for what I’ve configure my Traefik quadlet unit to look like. Some of these are specific because it is running in a container, which has its own benefits for security.</p><pre data-language="systemd" tabindex="0"><code><span><span>[Unit]</span></span>
<span><span>Description</span><span>=</span><span>Traefik Reverse Proxy with Socket Activation</span></span>
<span><span>Requires</span><span>=</span><span>http.socket https.socket</span></span>
<span></span>
<span><span>[Container]</span></span>
<span><span>ContainerName</span><span>=</span><span>traefik</span></span>
<span><span>HostName</span><span>=</span><span>traefik</span></span>
<span><span>Image</span><span>=</span><span>docker.io/traefik:v3</span></span>
<span><span>Network</span><span>=</span><span>traefik.network</span></span>
<span><span>Volume</span><span>=</span><span>traefik-config.volume:/etc/traefik/:Z</span></span>
<span><span>Volume</span><span>=</span><span>/var/log/traefik:/logs/:Z</span></span>
<span><span>AutoUpdate</span><span>=</span><span>registry</span></span>
<span><span>Notify</span><span>=</span><span>true</span></span>
<span></span>
<span><span>HealthCmd</span><span>=</span><span>CMD-SHELL traefik healthcheck --ping</span></span>
<span><span>HealthInterval</span><span>=</span><span>10s</span></span>
<span><span>HealthRetries</span><span>=</span><span>5</span></span>
<span><span>HealthStartPeriod</span><span>=</span><span>5s</span></span>
<span><span>HealthTimeout</span><span>=</span><span>3s</span></span>
<span><span>HealthOnFailure</span><span>=</span><span>kill</span></span>
<span></span>
<span></span>
<span><span>[Service]</span></span>
<span><span>Restart</span><span>=</span><span>always</span></span>
<span><span>MemoryMax</span><span>=</span><span>512M</span></span>
<span><span>Sockets</span><span>=</span><span>http.socket https.socket</span></span>
<span></span>
<span><span>## Security Tuning</span></span>
<span><span>ProtectHome</span><span>=</span><span>yes</span></span>
<span><span>ProtectClock</span><span>=</span><span>yes</span></span>
<span><span>ProtectKernelLogs</span><span>=</span><span>yes</span></span>
<span><span>ProtectKernelModules</span><span>=</span><span>yes</span></span>
<span><span>ProtectSystem</span><span>=</span><span>full</span></span>
<span><span>RestrictSUIDSGID</span><span>=</span><span>yes</span></span>
<span><span>UMask</span><span>=</span><span>0077</span></span>
<span><span>SystemCallArchitectures</span><span>=</span><span>native</span></span>
<span><span>SystemCallFilter</span><span>=</span><span>@system-service @mount @privileged</span></span>
<span><span>RestrictRealtime</span><span>=</span><span>yes</span></span>
<span><span>RestrictIPC</span><span>=</span><span>yes</span></span>
<span><span>LockPersonality</span><span>=</span><span>yes</span></span>
<span><span>RestrictAddressFamilies</span><span>=</span><span>AF_INET AF_INET6 AF_UNIX AF_NETLINK</span></span>
<span><span>#RestrictNamespaces=yes ### Doesn&#39;t work due to containerization</span></span>
<span><span>MemoryDenyWriteExecute</span><span>=</span><span>yes</span></span>
<span></span>
<span><span>#Needs CAPS: PTRACE</span></span>
<span><span>CapabilityBoundingSet</span><span>=</span><span>~</span><span>CAP_SETUID</span><span> CAP_SETPCAP</span></span>
<span><span>#####</span></span>
<span></span>
<span><span>[Install]</span></span>
<span><span>WantedBy</span><span>=</span><span>default.target</span></span></code></pre><h2 id="conclusion">Conclusion</h2><p>While you can go and tweak all your services, I am not saying it’s necessary. This is merely a tool in the belt of any linux admin worth their snuff, and <em>I personally believe</em> it to be underutilized. In the nature of public notes, as I have been cleaning up some servers and organizing my own messy documentation on them, I decided to put this little note sheet together for the community at large. In particular, I think this is something a lot of self-hosters can benefit from.</p><p>Don’t let perfect be the enemy of good, apply this where you can, and your lab (and the internet) will be a better place for it.</p></div></div>
  </body>
</html>
