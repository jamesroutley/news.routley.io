<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kevinlynagh.com/newsletter/2023_09_hardware_prototyping/">Original</a>
    <h1>Interfaces for prototyping hardware</h1>
    
    <div id="readability-page-1" class="page"><div><p>I’m traveling this month!
Hit me up for a coffee/beer conversation in:</p>

<ul>
<li>Budapest (Sept. 15–19)</li>
<li>St. Louis (Strange Loop conference, Sept 20–23)</li>
<li>Montreal (Sept 24–30)</li>
<li>San Francisco (Oct 3–?)</li>
</ul>

<p>This newsletter in two parts: software/UI, then hardware/electronics.</p>

<h2>Interfaces for prototyping hardware</h2>

<p>While prototyping scientific hardware, I often find myself simultaneously iterating on both the domain model and its corresponding user interface.</p>

<p>For example, a software-controlled pump might start with “on/off” control:</p>
<div><pre><span></span><span>struct</span> <span>Pump</span><span> </span><span>{</span><span></span>
<span>  </span><span>is_running</span>: <span>bool</span>
<span>}</span><span></span>
</pre></div>
<p>Exposing this data model with an HTML <code>&lt;button&gt;</code> or <code>&lt;input type=&#34;checkbox&#34;&gt;</code> is enough for initial hardware testing.</p>

<p>Say the first experiments show that switching the pump on/off is too violent (the sudden start/stop shears cells or explodes pipes or whatever), so we add target speed and acceleration parameters:</p>
<div><pre><span></span><span>struct</span> <span>Pump</span><span> </span><span>{</span><span></span>
<span>  </span><span>target_speed</span>: <span>Quantity</span><span>&lt;</span><span>AngularVelocity</span><span>&gt;</span><span>,</span><span></span>
<span>  </span><span>max_acceleration</span>: <span>Quantity</span><span>&lt;</span><span>AngularAcceleration</span><span>&gt;</span><span>,</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>These new fields can be exposed in the interface as numeric sliders or text inputs which accept exact values of various units, e.g., “600 rpm” or “5 radians/sec”.
This enables more quick benchtop experiments to determine reasonable pump speeds.</p>

<p>Perhaps we then add some sensors to our apparatus to measure the current pump speed and system pressure, which enable us to write closed-loop control algorithms.
Only a single control algorithm can be active at a time, so we model them as variants of an enumeration:</p>
<div><pre><span></span><span>struct</span> <span>Pump</span><span> </span><span>{</span><span></span>
<span>    </span><span>current_speed</span>: <span>Quantity</span><span>&lt;</span><span>AngularVelocity</span><span>&gt;</span><span>,</span><span></span>
<span>    </span><span>current_pressure</span>: <span>Quantity</span><span>&lt;</span><span>Pressure</span><span>&gt;</span><span>,</span><span></span>
<span>    </span><span>control</span>: <span>FlowControl</span><span>,</span><span></span>
<span>}</span><span></span>

<span>enum</span> <span>FlowControl</span><span> </span><span>{</span><span></span>
<span>    </span><span>ConstantSpeed</span><span> </span><span>{</span><span></span>
<span>        </span><span>target_speed</span>: <span>Quantity</span><span>&lt;</span><span>AngularVelocity</span><span>&gt;</span><span>,</span><span></span>
<span>        </span><span>max_acceleration</span>: <span>Quantity</span><span>&lt;</span><span>AngularAcceleration</span><span>&gt;</span><span>,</span><span></span>
<span>    </span><span>},</span><span></span>

<span>    </span><span>ConstantPressure</span><span> </span><span>{</span><span></span>
<span>        </span><span>max_pressure</span>: <span>Quantity</span><span>&lt;</span><span>Pressure</span><span>&gt;</span><span>,</span><span></span>
<span>    </span><span>},</span><span></span>

<span>    </span><span>ConstantFlow</span><span> </span><span>{</span><span></span>
<span>        </span><span>target_flow</span>: <span>Quantity</span><span>&lt;</span><span>VolumeRate</span><span>&gt;</span><span>,</span><span></span>
<span>    </span><span>},</span><span></span>

<span>    </span><span>Brake</span><span>,</span><span></span>

<span>    </span><span>FreeSpin</span><span>,</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>A user interface might show the read-only current speed and pressure as numbers, perhaps next to line charts visualizing the last few minutes.</p>

<p>The flow control mode could be specified via a drop down (<code>&lt;select&gt;</code>) or tabs, with the variant-specific fields appearing after selection.
Alternatively, if we prioritize discoverability over saving screen space, we could show all of the modes (and their associated field controls) at once, with radio buttons to select the active mode and gray out the others.</p>

<p>When I’ve done this sort of data model iteration in the past, I’ve just manually rewritten the UI to match.
That usually means duct-taping together something in a web browser to round-trip the appropriate <a href="https://serde.rs/json.html">Serde JSON representation</a> with the backend system.</p>

<p>Handwritten UIs allow for maximum flexibility: I can choose (or custom-build) the most appropriate input controls for each field, adding additional domain context like min/max speed validation, slider step sizes, etc.</p>

<p>However, such UI takes a ton of time to develop and usually incurs coordination costs (as the UI and data model are often implemented by separate people and across tech stacks / deployment mechanisms).</p>

<p>I’m curious about other points of the tradeoff space here, especially in the context of “internal tools” where the implementers are also the end-users.
Such author-operators are jointly optimizing “ease of use” with “ease of implementation”; they might prefer an ugly, “good enough” UI built in 10 minutes over a “bulletproof” one built over a week.</p>

<h2>Generating UI from a data model</h2>

<p>A potential approach to quick, “good enough” internal tools is to generate UI automatically from an underlying data model.</p>

<p>I’ve seen this done in a few places:</p>

<ul>
<li>CRUD frameworks like <a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Admin_site">Django Admin</a> use data models and SQL database tables to generate a full web interface for looking up, adding, deleting, etc. arbitrary records.</li>
<li>Tools like <a href="https://json-editor.github.io/json-editor/">JSON Editor</a> and <a href="https://jsonforms.io/examples/">JSON Forms</a> generate interactive controls based on a <a href="http://json-schema.org/understanding-json-schema/index.html">JSON schema</a>.</li>
<li>Python’s <a href="https://github.com/chriskiehl/Gooey">Gooey</a> library cleverly generates a native UI based on command line argument structure.</li>
</ul>

<p>However, while there’s plenty of prior art on the idea of generating UI from data definitions, empirically it’s not something I actually <em>do</em>.</p>

<p>What properties would I find compelling for prototyping scientific hardware?</p>

<ul>
<li><p>Developer ease of use: It should take less than 2 minutes to integrate a UI into an existing project.
A library that slots into existing toolchain (e.g., a Rust crate) would be ideal, but if other tools must be involved, they should be quickly installable and easily versionable on a project-by-project level.</p></li>
<li><p>Web UI: I haven’t found anything easier to distribute and use.
A web UI allows sharing links within a team, usage on Mac/Windows/Linux, simple dedicated hardware (Raspberry Pi + television, tablet, etc.), and ability to adjust zoom at runtime.</p></li>
<li><p>Units: These are essential and have a number of subtleties.</p>

<ul>
<li>Fields should indicate their default unit but allow operators to use alternatives. E.g., render <code>tare value: [ ] kg</code> but accept someone typing “11.3 oz”.</li>
<li>Units should be customizable on a per-field basis; the same interface may reasonably report volumes in one place as liters and another as microliters.</li>
<li>Custom units should be possible. SI and its prefixes are great, but there are lots of practical (er, historically contingent) reasons where entire subfields use units like mL/min (chromatography), millisiemens/centimeter (conductivity), or one of a gazillion units for pressure: bar, bar gauge, mmHg, psi, atmospheres, and (lol) Pascals.</li>
</ul></li>
<li><p>Validation: Simple “fat finger” checks (min/max limits) on a per-field level are table stakes.
Algebraic data types go a long way towards making <a href="https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/">illegal states unrepresentable</a>, but custom validation code may be required to enforce relationships between fields, so there should be a mechanism for this code to explain why it’s rejecting some input.</p></li>
<li><p>Data density: Author-operators will want to see as much system state at once as possible, so the UI should be much denser than typical casual, consumer-oriented designs.
Ideally many real-time readout fields would be visualized with charts.</p></li>
<li><p>Historical context: The system should default to storing all operator commands (how many inputs can a person click/type in a day anyway, a few hundred kB worth?).
Sensor output may be more voluminous (especially at 10 Hz or faster), but ideally the system could be configured with a space-bounded lookback window so that the default behavior for even the quickest of prototypes is “data are saved” rather than “data are discarded”.
There’s likely not a reliable way to handle schema changes across data model iterations, but ideally data would be consolidated across process restarts and deployments for a fixed schema.
This historical data should also be accessible as JSON and/or CSV, so that they can easily make their way into Jupyter Notebooks or Excel (those hallowed programs through which all True Scientific Data must transit).</p></li>
</ul>

<h2>UI implementation thoughts</h2>

<p>Most of my scientific hardware work has been in Rust, as it is suitable for full Mac/Windows/Linux systems, microcontrollers, and can be used for low-jitter applications like real-time control loops.</p>

<p>The standard Rust field definitions with the <a href="https://github.com/iliekturtles/uom">Units of Measurement</a> crate’s types:</p>
<div><pre><span></span><span>struct</span> <span>Apparatus</span><span> </span><span>{</span><span></span>
<span>    </span><span>current</span>: <span>Quantity</span><span>&lt;</span><span>Velocity</span><span>&gt;</span><span>,</span><span></span>
<span>    </span><span>target</span>: <span>Quantity</span><span>&lt;</span><span>Velocity</span><span>&gt;</span><span>,</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>don’t sufficiently specify the constraints and units our ideal UI would support.
We could try and encode such things with macros:</p>
<div><pre><span></span><span>struct</span> <span>Apparatus</span><span> </span><span>{</span><span></span>
<span>    </span><span>#[read_only, display(meters_per_second)]</span><span></span>
<span>    </span><span>current</span>: <span>Quantity</span><span>&lt;</span><span>Velocity</span><span>&gt;</span><span>,</span><span></span>

<span>    </span><span>#[min(</span><span>&#34;0 m/s&#34;</span><span>), max(</span><span>&#34;10 m/s&#34;</span><span>), display(meters_per_second)]</span><span></span>
<span>    </span><span>target</span>: <span>Quantity</span><span>&lt;</span><span>Velocity</span><span>&gt;</span><span>,</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>which is the approach taken by crates like <a href="https://docs.rs/serde_valid/latest/serde_valid/">serde_valid</a>.</p>

<p>The advantage of this approach is that it <em>might</em> neatly into Rust ecosystem tooling.
Ultimately that’s an empirical question, and I’m not sure whether one (read: me) could generate the validation and UI code at compile time without devolving into an mess of macro and <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build.rs</a> cleverness, with all the associated obtuse error messages and poor IDE support.</p>

<p>And macros strike me as the only sensible expressive-but-concise route within Rust’s code generation facilities — I shudder to think of designing generic-filled type machinery like <code>Quantity&lt;Dimension, MinValue, MaxValue, DisplayUnit&gt;</code> (and then asking people to use it!)</p>

<p>There may be a path using NewTypes — following “<a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">parse, don’t validate</a>” and replacing <code>Quantity&lt;Velocity&gt;</code> with some kind of <code>BoundedQuantity&lt;Velocity&gt;</code> that guarantees the 0–10m/s constraint, but it’s not clear to me exactly what that would look like.
I also worry about the compile-time costs (generating unique types per field) and backend ergonomics (having to write <code>state.some_field.value.0.get::&lt;Thing&gt;()</code> to extract the value you actually care about from the types).</p>

<p>We can, of course, step outside of Rust’s facilities and write a program that “compiles” our data model into the necessary Rust and UI (HTML/JavaScript) code.
Defining our own lil’ DSL would maximize expressiveness, though with some initial cognitive overhead compared to “vanilla” Rust.</p>

<p>In this case, I’d be inclined to explore building on something like Clojure’s <a href="https://github.com/metosin/malli">Malli</a> library, which does validation, error messages, and can even generate conforming data (useful for checking that a schema actually (dis)allows what you intended; not to mention load and visualization testing):</p>
<div><pre><span></span><span>(</span><span>-&gt; </span><span>[</span><span>:map</span>
     <span>[</span><span>:id</span> <span>int?</span><span>]</span>
     <span>[</span><span>:size</span> <span>[</span><span>:enum</span> <span>{</span><span>:error/message</span> <span>&#34;should be: S|M|L&#34;</span><span>}</span>
             <span>&#34;S&#34;</span> <span>&#34;M&#34;</span> <span>&#34;L&#34;</span><span>]]</span>
     <span>[</span><span>:age</span> <span>[</span><span>:fn</span> <span>{</span><span>:error/fn</span> <span>(</span><span>fn </span><span>[{</span><span>:keys</span> <span>[</span><span>value</span><span>]}</span> <span>_</span><span>]</span> <span>(</span><span>str </span><span>value</span> <span>&#34;, should be &gt; 18&#34;</span><span>))}</span>
            <span>(</span><span>fn </span><span>[</span><span>x</span><span>]</span> <span>(</span><span>and </span><span>(</span><span>int?</span> <span>x</span><span>)</span> <span>(</span><span>&gt; </span><span>x</span> <span>18</span><span>)))]]]</span>
    <span>(</span><span>m/explain</span> <span>{</span><span>:size</span> <span>&#34;XL&#34;</span>, <span>:age</span> <span>10</span><span>})</span>
    <span>(</span><span>me/humanize</span>
      <span>{</span><span>:errors</span> <span>(</span><span>-&gt; </span><span>me/default-errors</span>
                   <span>(</span><span>assoc </span><span>::m/missing-key</span> <span>{</span><span>:error/fn</span> <span>(</span><span>fn </span><span>[{</span><span>:keys</span> <span>[</span><span>in</span><span>]}</span> <span>_</span><span>]</span> <span>(</span><span>str </span><span>&#34;missing key &#34;</span> <span>(</span><span>last </span><span>in</span><span>)))}))}))</span>
<span>;{:id [&#34;missing key :id&#34;]</span>
<span>; :size [&#34;should be: S|M|L&#34;]</span>
<span>; :age [&#34;10, should be &gt; 18&#34;]}</span>
</pre></div>
<p>Beyond model and UI <em>definition</em>, there’s also a question about how this’ll work at runtime: Should it be more like a “library” (a pile of functions to be called by your code) or a “framework” (which defines an entire lifecycle that calls your code)?</p>

<p>Arduino sketches are a wonderful framework: You write <code>setup()</code> and <code>loop()</code> functions, then some Magic Arduino Stuff happens and your code is running on a microcontroller.</p>

<p>We’d need some kind of <code>start_webserver()</code> call to kick things off, with platform specific variations (threads vs. async runtime, std. vs. no-std, etc.).
Then maybe all we need are two channels (message queues): <code>Incoming&lt;Command&gt;</code> and <code>Outgoing&lt;Status&gt;</code>, with the Command and Status types being rendered in the UI as controls and data visualizations, respectively.
The API contract is essentially “we’ll render in the UI and log any statuses you give us, and we’ll pass along any valid commands from the UI”.</p>

<p>Having the author reify a distinct Command type (rather than generating such types automatically for every non-read-only struct field) may be a bit more verbose, but it strikes me as better to make things explicit using Rust’s existing concepts rather than introduce new options.
For example, one could specify whether the UI should support setting multiple fields at once by making all of the command fields optional:</p>
<div><pre><span></span><span>struct</span> <span>PumpCommand</span><span> </span><span>{</span><span></span>
<span>    </span><span>speed</span>: <span>Option</span><span>&lt;</span><span>Quantity</span><span>&lt;</span><span>AngularVelocity</span><span>&gt;&gt;</span><span>,</span><span></span>
<span>    </span><span>control</span>: <span>Option</span><span>&lt;</span><span>FlowControl</span><span>&gt;</span><span>,</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>or whether only a single field can be set at a time:</p>
<div><pre><span></span><span>enum</span> <span>PumpCommand</span><span> </span><span>{</span><span></span>
<span>    </span><span>SetSpeed</span><span>(</span><span>Quantity</span><span>&lt;</span><span>AngularVelocity</span><span>&gt;</span><span>),</span><span></span>
<span>    </span><span>SetControl</span><span>(</span><span>FlowControl</span><span>),</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>Having this level of detail may be required to appropriately expose the underlying hardware constraints.</p>

<p>Overall, while there are lots of details to sort out, I suspect this architecture would have been sufficient support all of the hardware prototyping needs I’ve run across so far in my career.</p>

<p>I’ll have a go at building something and let you know how it works out in practice.</p>

<h2>Other UI solutions</h2>

<ul>
<li><p><a href="https://learn.ni.com/learn/article/labview-tutorial">LabView</a> is a graphical (connect-the-boxes) programming environment with lots of charts, scientific functions, and certified hardware that “just works”.
I only briefly touched it in undergrad, and believe it’s expensive.</p></li>
<li><p>PLCs (<a href="https://en.wikipedia.org/wiki/Programmable_logic_controller">Programmable logic controllers</a>) have robust, plug ‘n play hardware and manufacturers have (usually Windows-only) GUIs for reading/writing values.
However, they are much more expensive compared to DIY Raspberry Pi and microcontroller hardware; even cheap families will cost a few hundred bucks for a few GPIO input/outputs.</p></li>
<li><p>An engineer friend recommended <a href="https://dewesoft.com/">Dewesoft</a>’s visualization and control software, which is free to use with their data acquisition hardware (presumably expensive — “contact us”).</p></li>
<li><p><a href="https://electricui.com/">Electric UI</a> looks like a hardware-focused, well-documented React.js framework that a pair of engineers in Australia have been working on the past few years.</p></li>
</ul>

<h2>On hardware</h2>

<p>The space of “prototyping hardware” ranges from:</p>

<ul>
<li><p><strong>Home Automation</strong>: off-the-shelf consumer products like switches, lights, motion sensors that communicate over wifi or <a href="https://zigbee.blakadder.com/index.html">Zigbee</a> and combined together with software like <a href="https://www.home-assistant.io/integrations/">Home Assistant</a>. 
Couldn’t build a high-speed robot, but could do motorized blinds and sensor readings at 1 Hz.</p></li>
<li><p><strong>PCB breakout boards</strong>: Dirt cheap (<a href="https://amzn.to/47Z2ZzN">37 sensor assortment</a> for $21) to merely inexpensive (<a href="https://www.sparkfun.com/qwiic">Sparkfun’s Qwiic</a>) modules wired to a $30 single board computer or $5 microcontroller, shipped next-day via Amazon and programmed via YouTube or Arduino forum copy/paste.</p></li>
<li><p><strong>PLCs</strong>: See <a href="https://controlledmold.com/industrial-computers-for-koji/">industrial computers for koji</a> for a great overview, but tl;dr; this is the stuff designed to mount on DIN-rail in an electrical cabinet.
Starts at a few hundred bucks for <a href="https://www.automationdirect.com/adc/shopping/catalog/programmable_controllers/click_plus_plcs_(stackable_micro_modular)#">Click PLC family</a> and <a href="https://www.seeedstudio.com/EdgeBox-ESP-100-p-5490.html">esp32-in-a-box</a> with a few simple input/outputs and quickly gets into “contact us”, $50k+ territory for the Western brands (Siemens, Beckhoff, etc.) that control your local factory or power plant.</p></li>
<li><p><strong>Custom PCBs</strong>: <a href="https://jlcpcb.com/">JLCPCB</a> can manufacture and ship something to you for $50, but unfortunately you’ve got to learn electrical engineering first.</p></li>
</ul>

<p>I’ve multiple friends wish for something between bare PCB breakout boards and full-on PLC hardware.
I’m sympathetic: It’d be great to have something more convenient and robust than a mess of wires on a breadboard without having to drop thousands of bucks for an electrical cabinet full of factory-grade components.
Especially since PLCs are “just” microcontrollers made robust in a plastic housing with extra protection circuitry, a bit of networking (fieldbus), and software.</p>

<p>Using the <a href="https://controlledmold.com/industrial-computers-for-koji/">koji fermentation controller</a> as an example, the author spent about $500 for a Click PLC with a few GPIOs and temperature sensors.
Why that instead of just reading an <a href="https://amzn.to/3Pk5DsG">$8 K-type thermocouple breakout</a> with a $5 microcontroller?
They write:</p>

<blockquote>
<p>In summary, we use PLCs because they are:</p>

<ol>
<li>Extremely rugged</li>
<li>Customizable, modular and easily repaired or replaced</li>
<li>Serviceable and programmable by any competent technician</li>
</ol>

<p>However, PLCs are no more than simple, real-time computing systems. Your average PLC is probably weaker in raw compute power than a Raspberry Pi, and multiple times the cost.</p>
</blockquote>

<p>How much of this physical robustness, modularity, and system-level convenience can be engineered at a cheaper price point?
Is it simply “wrapping” cheap breakout boards with:</p>

<ul>
<li>more electrically robust (opto-isolated or surge-protected) IO</li>
<li>nicer wire terminals (springs rather than screws or tiny JST connectors)</li>
<li>enclosures that snap together and onto DIN rails</li>
<li>a fieldbus interface that can be read over USB / Ethernet / WiFi / Bluetooth</li>
</ul>

<p>? </p>

<p>I mean, yeah, I’d love something convenient like Click or <a href="https://www.odotautomation.com">ODot</a> components for $10<sup>1</sup> rather than $10<sup>2</sup>.</p>

<p>If this were feasible, why haven’t SparkFun, SeeedStudio, or Adafruit done it?
Perhaps the hardware margins just aren’t there.
Or those companies aren’t interested in developing the fieldbus and UI necessary for the value proposition.</p>

<p>It may be doable as an open source labor of love — like a moth to the flame, I can’t help but sketch it out.</p>

<h2>Requirements for a “hobbyist PLC” system</h2>

<ul>
<li><p>Max $5 marginal BOM cost (i.e., adding whatever electrical components to turn an existing sensor breakout board into a PLC system “block” should cost no more than $5).</p></li>
<li><p>A robust and easy-to-setup GUI for debugging and manual control of individual blocks (I’ve already nerd-sniped myself with this one, thanks).</p></li>
<li><p>Reference interface libraries in C or no-std Rust suitable for embedded use.
On top of this should be built more accessible Python / Web libraries for folks without hard latency needs.</p></li>
<li><p>Blocks should reversably snap together, without tools, making robust power, data, and physical connections.</p></li>
<li><p>Blocks should have status LEDs.</p></li>
<li><p>Block enclosures should be 3D-printable on cheap FDM printers (Ender 3 clones) and should not require custom metal components.
(Ideally no screws or other components at all.)</p></li>
<li><p>Block PCBs should be manufacturable by hobbyist-accessible assemblers (JLCPCB, PCBWay, etc.), including spring terminals or other external connectors — the end-user shouldn’t need to do any soldering.</p></li>
<li><p>Open Source designs for both the interfaces (physical and electrical specifications) and reference block design files (KiCAD, Fusion360/STEP/STL/sliced, etc.); one should be able to “fork” the analog input block to use a higher-resolution ADC chip and submit that for manufacture in under an hour.</p></li>
<li><p>Fieldbus should have &lt; 10ms latency and &lt; 1ms jitter for a small system (e.g., 10 blocks).</p></li>
<li><p>Blocks should self-describe over the fieldbus and automatically address themselves based on physical connectivity, so one can print an ordered list of all attached devices.</p></li>
<li><p>It should be easy to run a “test suite” to check the entire bus performance and block conformance.</p></li>
<li><p>Reference blocks should exist for the usual needs: digital input/output, 0–20mA analog input, etc.</p></li>
</ul>

<h2>Nice to haves / open questions</h2>

<ul>
<li><p>Fieldbus support for communicating 100m with a single cable — perhaps (power over) Ethernet?</p></li>
<li><p>Sufficient power to drive smaller stepper motors.
A great demo would be a pen plotter or 3d printer built with the system.</p></li>
<li><p>Internal block firmware should be upgradable over the fieldbus.
Not clear to me how hard this is to do in a generic way, nor how useful it will be in practice (the whole point is that the blocks should Just Work, so it might not be great to encourage frequent block reprogramming).</p></li>
<li><p>Off-grid usage. It’d be very convenient if the system could be easily run from solar / cordless tool battery / usb powerbank but I don’t have a great sense of problem space and associated trade offs.
I.e., is a block sleep mode worth the extra protocol/software implementation complexity, hardware costs, etc.</p></li>
</ul>

<p>I’d be curious to hear about other prior art in this broad space.
I only learned about PLCs after years in Arduino “maker” world, and I wouldn’t be surprised if I’m missing entire other adjacent communities of practice.</p>

<p>There seem to be plenty of electrical engineers designing modular PCBs (e.g., <a href="https://hackaday.com/2018/06/20/hexabitz-modular-electronics-made-easier/">Hexabitz</a>, <a href="https://hackaday.io/project/12808-pure-modules">PURE modules</a>) but I’m not aware of any attempts that include PLC-like physical enclosure and fieldbus standards.</p>

<p>The closest “open source 3d-printable” physical standard I’ve seen is the <a href="https://www.reddit.com/r/gridfinity/top/?t=all">Gridfinity</a> storage system.</p>

<h2>Roadmap</h2>

<p>The ideas I’ve discussed above seem (to me, anyway) tantalizingly doable.
There’s still a ton of details to work out, but in broad strokes I suspect the technical core could be built in a month or two of focused work:</p>

<ul>
<li>design the fieldbus protocol</li>
<li>design minimal API on both sides (controller and blocks)</li>
<li>implement in Rust, test fieldbus using familiar microcontrollers (I have ESP32-C3s dev boards laying around with built in LEDs)</li>
<li>build basic control UI</li>
<li>find cheap, hobbyist-friendly spring terminals and bus connectors (pin headers? card edge? pogo pins? clever usage of SIM or SD card socket springs?); design prototype enclosures around &#39;em</li>
<li>iterate iterate iterate</li>
<li>profit! (er, bask in open source / public good glory)</li>
</ul>

<p>Please convince me not to start this.</p>

<h2>Misc. stuff</h2>

<ul>
<li><p><a href="https://parpa.substack.com/p/is-necessity-actually-the-mother">“Creating capabilities that don’t address an immediate problem while still setting them on a trajectory to solve a problem is incredibly hard.”</a></p></li>
<li><p><a href="https://ilyabirman.net/meanwhile/all/onboarding/">Onboarding</a></p></li>
<li><p>“<a href="https://www.theatlantic.com/magazine/archive/2023/05/ice-cream-bad-for-you-health-study/673487/">Nutrition Science’s Most Preposterous Result</a>: Studies show a mysterious health benefit to ice cream. Scientists don’t want to talk about it.”</p></li>
<li><p>The CIA deployed a <a href="https://www.cryptomuseum.com/spy/rs804/index.htm">19mm thick satellite text-messaging device</a> in the early 1980’s</p></li>
<li><p><a href="https://www.youtube.com/watch?v=BFld4EBO2RE">Painting a Landscape with Maths</a></p></li>
<li><p><a href="https://druglike.bio/artificial-wombs.html">Artificial Wombs</a></p></li>
<li><p>“Harvard <em>exists</em> to make society less meritocratic, and it does that while subsidized by everyone else. <a href="https://dynomight.net/harvard/">Give up</a>.”</p></li>
<li><p>“a recombinant form of the mechanosensitive protein talin was incorporated into a monomeric unit and crosslinked, resulting in a <a href="https://www.nature.com/articles/s41565-023-01431-1">talin shock-absorbing material (TSAM)</a>. When subjected to 1.5 km s−1 supersonic shots, TSAMs were shown to absorb the impact and capture and preserve the projectile.”</p></li>
<li><p><a href="https://max.levch.in/post/724289457144070144/shamir-secret-sharing">Shamir Secret Sharing</a></p></li>
<li><p>“<a href="https://www.squiggle-language.com/docs">Squiggle</a> is a minimalist programming language for probabilistic estimation. It’s meant for intuitively-driven quantitative estimation instead of data analysis or data-driven statistical techniques.”</p></li>
<li><p><a href="http://bactra.org/weblog/523.html"><em>g</em>, a Statistical Myth</a></p></li>
<li><p><a href="https://www.youtube.com/watch?v=aTqgzmhTQVA">skull rug</a></p></li>
<li><p>A longform audio interview with <a href="https://josephnoelwalker.com/147-katalin-kariko/">Katalin Karikó</a>, the mRNA technology pioneer</p></li>
<li><p><a href="https://www.youtube.com/watch?v=pkbQV71ZvK4">How the VIRAL AI Drake Song “Heart On My Sleeve” was Made</a></p></li>
<li><p><a href="https://computer.rip/2023-07-29-Free-Public-WiFi.html">Free Public WiFi</a></p></li>
<li><p><a href="http://toastermuseum.com/">Welcome to Toastermuseum.com - the world largest Online Toaster Exhibition…</a></p></li>
<li><p><a href="https://www.convergentresearch.org/about-fros">About Focused Research Organizations</a></p></li>
<li><p><a href="https://www.youtube.com/watch?v=WGccIFf6MF8">The Mathematics of String Art</a></p></li>
<li><p><a href="https://inkbit3d.com/packing/">Dense, Interlocking-Free and Scalable Spectral Packing of Generic 3D Objects</a></p></li>
<li><p><a href="https://jakeseliger.com/2023/07/22/i-am-dying-of-squamous-cell-carcinoma-and-the-treatments-that-might-save-me-are-just-out-of-reach/">I am dying of squamous cell carcinoma, and the treatments that might save me are just out of reach</a></p></li>
<li><p><a href="https://thebreakthrough.org/blog/learning-to-love-rbst">Learning to Love rbST: How a 30 year old synthetic hormone can cut the carbon footprint and land use of dairy production</a></p></li>
</ul>
</div></div>
  </body>
</html>
