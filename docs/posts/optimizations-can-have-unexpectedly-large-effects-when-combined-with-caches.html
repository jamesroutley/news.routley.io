<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justinblank.com/notebooks/performanceoptimizationscanhaveunexpectedlylargeeffectswhencombinedwithcaches.html">Original</a>
    <h1>Optimizations can have unexpectedly large effects when combined with caches</h1>
    
    <div id="readability-page-1" class="page"><article>
          
<p>This post is about a non-obvious interaction between performance optimizations and LRU/time limited caching.</p>
<p>In 2017, I was working a major performance issue. We were onboarding a large customer, and a batch process was taking 3 hours<a href="#fn1" id="fnref1"><sup>1</sup></a>, long enough to mean that trucks would be waiting at the dock, shipments would be fulfilled a day late, etc.</p>
<p>We were able to run the whole process under a sampling profiler, and found that the <code>foo</code> method was taking roughly 50% of the time. Fortunately, it wasn&#39;t hard to see room for improvement. The details were tricky, but after some work, I thought I had a solid improvement. I could avoid at least half of the work in the <code>foo</code> method, so perhaps I could shave 45 minutes off the whole process.</p>
<p>We uploaded code to the test environment, expecting to wait a few hours, but the entire process finished in 45 minutes. Instead of a 45 minute savings, we&#39;d shaved off 2 hours and 15 minutes. My first instinct was that we had a bug--nothing is faster than throwing an exception, or skipping all the real work.</p>
<p>In fact, the code was fine. What I didn&#39;t realize is that the code pulled data from caches that expired as time went on, and a significant portion of the original 3 hours was spent fetching data that had expired from the cache. After optimizing one slow portion of the code, other portions were reaching from the cache and the overall speedup was larger than seemed possible.</p>
<p>It&#39;s common wisdom that systems with caches can fail badly when the caches are cold. When every request misses the cache, the system is overloaded, and never recovers. What I observed was the mirror image.</p>
<p><em>Thanks to Stuart Cook for pointing out that I was describing the opposite of the familiar cold cache situation.</em></p>


	</article></div>
  </body>
</html>
