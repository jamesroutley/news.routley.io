<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2019/07/08/fuck-rsa/">Original</a>
    <h1>Seriously, Stop Using RSA (2019)</h1>
    
    <div id="readability-page-1" class="page"><article id="post-98915">
	<!-- .entry-header -->

	<div>
		<p>Here at Trail of Bits we review a lot of code. From major open source projects to exciting new proprietary software, we’ve seen it all. But one common denominator in all of these systems is that for some inexplicable reason people still seem to think RSA is a good cryptosystem to use. Let me save you a bit of time and money and just say outright—if you come to us with a codebase that uses RSA, you will be paying for the hour of time required for us to explain why you should stop using it.</p>
<p>RSA is an intrinsically fragile cryptosystem containing countless foot-guns which the average software engineer cannot be expected to avoid. Weak parameters can be difficult, if not impossible, to check, and its poor performance compels developers to take risky shortcuts. Even worse, padding oracle attacks remain rampant 20 years after they were discovered. While it may be theoretically possible to implement RSA correctly, decades of devastating attacks have proven that such a feat may be unachievable in practice.</p>
<p><span><iframe width="690" height="389" src="https://www.youtube.com/embed/lElHzac8DDI?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en-US&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation"></iframe></span></p>
<h2>What is RSA again?</h2>
<p>RSA is a public-key cryptosystem that has two primary use cases. The first is public key encryption, which lets a user, Alice, publish a public key that allows anyone to send her an encrypted message. The second use case is digital signatures, which allow Alice to “sign” a message so that anyone can verify the message hasn’t been tampered with. The convenient thing about RSA is that the signing algorithm is basically just the encryption algorithm run in reverse. Therefore for the rest of this post we’ll often refer to both as just RSA.</p>
<p>To set up RSA, Alice needs to choose two primes <code>p</code> and <code>q</code> that will generate the group of integers modulo <code>N = pq</code>. She then needs to choose a public exponent <code>e</code> and private exponent <code>d</code> such that <code>ed = 1 mod (p-1)(q-1)</code>. Basically, <code>e</code> and <code>d</code> need to be inverses of each other.</p>
<p>Once these parameters have been chosen, another user, Bob, can send Alice a message <code>M</code> by computing <code>C = M<sup>e</sup> (mod N)</code>. Alice can then decrypt the ciphertext by computing <code>M = C<sup>d</sup> (mod N)</code>. Conversely, if Alice wants to sign a message <code>M</code>, she computes <code>S = M<sup>d</sup> (mod N)</code>, which any user can verify was signed by her by checking <code>M = S<sup>e</sup> (mod N)</code>.</p>
<p>That’s the basic idea. We’ll get to padding—essential for both use cases—in a bit, but first let’s see what can go wrong during parameter selection.</p>
<h2>Setting yourself up for failure</h2>
<p>RSA requires developers to choose quite a few parameters during setup. Unfortunately, seemingly innocent parameter-selection methods degrade security in subtle ways. Let’s walk through each parameter choice and see what nasty surprises await those who choose poorly.</p>
<h3>Prime Selection</h3>
<p>RSA’s security is based off the fact that, given a (large) number N that’s the product of two primes p and q, factoring N is hard for people who don’t know p and q. Developers are responsible for choosing the primes that make up the RSA modulus. This process is extremely slow compared to key generation for other cryptographic protocols, where simply choosing some random bytes is sufficient. Therefore, instead of generating a truly random prime number, developers often attempt to generate one of a specific form. This almost always ends badly.</p>
<p>There are many ways to choose primes in such a way that factoring N is easy. For example, p and q must be <em>globally</em> unique. If p or q ever gets reused in another RSA moduli, then both can be easily factored using the GCD algorithm. Bad random number generators make this scenario somewhat common, and <a href="https://factorable.net/weakkeys12.conference.pdf">research has shown</a> that roughly 1% of TLS traffic in 2012 was susceptible to such an attack. Moreover, p and q must be chosen independently. If p and q share approximately half of their upper bits, then N can be factored using <a href="https://en.wikipedia.org/wiki/Fermat%27s_factorization_method">Fermat’s method</a>. In fact, even the choice of primality testing algorithm can have <a href="https://eprint.iacr.org/2018/749">security implications</a>.</p>
<p>Perhaps the most widely-publicized prime selection attack is the <a href="https://en.wikipedia.org/wiki/ROCA_vulnerability">ROCA</a> vulnerability in RSALib which affected many smartcards, trusted platform modules, and even Yubikeys. Here, key generation only used primes of a specific form to speed up computation time. Primes generated this way are trivial to detect using clever number theory tricks. Once a weak system has been recognized, the special algebraic properties of the primes allow an attacker to use <a href="https://en.wikipedia.org/wiki/Coppersmith%27s_attack">Coppersmith’s method</a> to factor N. More concretely, that means if the person sitting next to me at work uses a smartcard granting them access to private documents, and they leave it on their desk during lunch, I can clone the smartcard and give myself access to all their sensitive files.</p>
<p>It’s important to recognize that in none of these cases is it intuitively obvious that generating primes in such a way leads to complete system failure. Really subtle number-theoretic properties of primes have a substantial effect on the security of RSA. To expect the average developer to navigate this mathematical minefield severely undermines RSA’s safety.</p>
<h3>Private Exponent</h3>
<p>Since using a large private key negatively affects decryption and signing time, developers have an incentive to choose a small private exponent d, especially in low-power settings like smartcards. However, it is possible for an attacker to <a href="https://en.wikipedia.org/wiki/Wiener%27s_attack">recover the private key</a> when d is less than the 4th root of N. Instead, developers are encouraged to choose a large d such that <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Using_the_Chinese_remainder_algorithm">Chinese remainder theorem techniques</a> can be used to speed up decryption. However, this approach’s complexity increases the probability of subtle implementation errors, which <a href="https://www.cs.tau.ac.il/~tromer/courses/infosec11/Boneh%20DeMillo%20Lipton%201997%20---%20On%20the%20importance%20of%20eliminating%20errors%20in%20cryptographic%20protocols.pdf">can lead to key recovery</a>. In fact, one of our interns last summer <a href="https://blog.trailofbits.com/2018/08/14/fault-analysis-on-rsa-signing/">modelled this class of vulnerabilities</a> with our symbolic execution tool <a href="https://github.com/trailofbits/manticore">Manticore</a>.</p>
<p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image13-1.png?ssl=1"><img data-attachment-id="98920" data-permalink="https://blog.trailofbits.com/2019/07/08/fuck-rsa/image13-4/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image13-1.png?fit=992%2C962&amp;ssl=1" data-orig-size="992,962" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image13" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image13-1.png?fit=300%2C291&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image13-1.png?fit=690%2C669&amp;ssl=1" loading="lazy" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image13-1.png?resize=500%2C485&amp;ssl=1" alt="" width="500" height="485" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image13-1.png?resize=500%2C485&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></p>
<p>People might call me out here and point out that normally when setting up RSA you first generate a modulus, use a fixed public exponent, and then solve for the private exponent. This prevents low private exponent attacks because if you always use one of the recommended public exponents (discussed in the next section) then you’ll never wind up with a small private exponent. Unfortunately this assumes developers actually do that. In circumstances where people implement their own RSA, all bets are off in terms of using standard RSA setup procedures, and developers will frequently do strange things like choose the private exponent first and then solve for the public exponent.</p>
<h3>Public Exponent</h3>
<p>Just as in the private exponent case, implementers want to use small public exponents to save on encryption and verification time. It is common to use Fermat primes in this context, in particular e = 3, 17, and 65537. Despite cryptographers recommending the use of 65537, developers often choose e = 3 which introduces many vulnerabilities into the RSA cryptosystem.</p>
<div id="attachment_98921"><p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image12.png?ssl=1"><img aria-describedby="caption-attachment-98921" data-attachment-id="98921" data-permalink="https://blog.trailofbits.com/2019/07/08/fuck-rsa/image12-3/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image12.png?fit=1660%2C1384&amp;ssl=1" data-orig-size="1660,1384" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image12" data-image-description="" data-image-caption="&lt;p&gt;Developers have even used e = 1, which doesn’t actually encrypt the plaintext&lt;/p&gt;
" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image12.png?fit=300%2C250&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image12.png?fit=690%2C575&amp;ssl=1" loading="lazy" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image12.png?resize=690%2C575&amp;ssl=1" alt="" width="690" height="575" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image12.png?resize=690%2C575&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></p><p id="caption-attachment-98921">Developers have even used e = 1, which doesn’t actually encrypt the plaintext</p></div>
<p>When e = 3, or a similarly small number, many things can go wrong. Low public exponents often combine with other common mistakes to either allow an attacker to decrypt specific ciphertexts or factor N. For instance, <a href="https://en.wikipedia.org/wiki/Coppersmith%27s_attack#Franklin-Reiter_related-message_attack">the Franklin-Reiter attack</a> allows a malicious party to decrypt two messages that are related by a known, fixed distance. In other words, suppose Alice only sends “chocolate” or “vanilla” to Bob. These messages will be related by a known value and allow an attacker Eve to determine which are “chocolate” and which are “vanilla.” Some low public exponent attacks even lead to key recovery. If the public exponent is small (not just 3), an attacker who knows several bits of the secret key can recover the remaining bits and break the cryptosystem. While many of these e = 3 attacks on RSA encryption are mitigated by padding, developers who implement their own RSA fail to use padding at an alarmingly high rate.</p>
<p>RSA signatures are equally brittle in the presence of low public exponents. In 2006, Bleichenbacher found an <a href="https://www.imperialviolet.org/2014/09/26/pkcs1.html">attack</a> which allows attackers to forge arbitrary signatures in many RSA implementations, including the ones used by <a href="https://www.imperialviolet.org/2014/09/26/pkcs1.html">Firefox and Chrome</a>. This means that any TLS certificate from a vulnerable implementation could be forged. This attack takes advantage of the fact that many libraries use a small public exponent and omit a simple padding verification check when processing RSA signatures. Bleichenbacher’s signature forgery attack is so simple that it is a <a href="https://cryptopals.com/sets/6/challenges/42">commonly used exercise</a> in cryptography courses.</p>
<h3>Parameter Selection is Hard</h3>
<p>The common denominator in all of these parameter attacks is that the domain of possible parameter choices is much larger than that of secure parameter choices. Developers are expected to navigate this fraught selection process on their own, since all but the public exponent must be generated privately. There are no easy ways to check that the parameters are secure; instead developers need a depth of mathematical knowledge that shouldn’t be expected of non-cryptographers. While using RSA with padding may save you in the presence of bad parameters, many people still choose to use broken padding or no padding at all.</p>
<h2>Padding oracle attacks everywhere</h2>
<p>As we mentioned above, just using RSA out of the box doesn’t quite work. For example, the RSA scheme laid out in the introduction would produce identical ciphertexts if the same plaintext were ever encrypted more than once. This is a problem, because it would allow an adversary to infer the contents of the message from context without being able to decrypt it. This is why we need to pad messages with some random bytes. Unfortunately, the most widely used padding scheme, PKCS #1 v1.5, is often vulnerable to something called a padding oracle attack.</p>
<p>Padding oracles are pretty complex, but the high-level idea is that adding padding to a message requires the recipient to perform an additional check–whether the message is properly padded. When the check fails, the server throws an <em>invalid padding</em> error. That single piece of information is enough to slowly decrypt a chosen message. The process is tedious and involves manipulating the target ciphertext millions of times to isolate the changes which result in valid padding. But that one error message is all you need to eventually decrypt a chosen ciphertext. These vulnerabilities are particularly bad because attackers can use them to recover pre-master secrets for TLS sessions. For more details on the attack, check out <a href="https://crypto.stackexchange.com/questions/12688/can-you-explain-bleichenbachers-cca-attack-on-pkcs1-v1-5">this excellent explainer</a>.</p>
<p>The <a href="https://crypto.stackexchange.com/questions/12688/can-you-explain-bleichenbachers-cca-attack-on-pkcs1-v1-5">original attack</a> on PKCS #1 v1.5 was discovered way back in 1998 by Daniel Bleichenbacher. Despite being over 20 years old, this attack continues to <a href="https://www.ei.ruhr-uni-bochum.de/media/nds/veroeffentlichungen/2018/08/13/sec18-felsch.pdf">plague</a> <a href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-meyer.pdf">many</a> <a href="https://robotattack.org/">real-world</a> <a href="https://blog.cryptographyengineering.com/2016/03/01/attack-of-week-drown/">systems</a> <a href="https://eprint.iacr.org/2018/1173.pdf">today</a>. Modern versions of this attack often involves a padding oracle slightly more complex than the one originally described by Bleichenbacher, such as server response time or performing some sort of protocol downgrade in TLS. One particularly shocking example was <a href="https://robotattack.org/">the ROBOT attack</a>, which was so bad that a team of researchers were able to sign messages with Facebook’s and PayPal’s secret keys. Some might argue that this isn’t actually RSA’s fault – the underlying math is fine, people just messed up an important standard several decades ago. The thing is, we’ve had a standardized padding scheme with a rigorous security proof, OAEP, since 1998. But almost no one uses it. Even when they do, OAEP is notoriously difficult to implement and often is vulnerable to <a href="https://research.kudelskisecurity.com/2018/04/05/breaking-rsa-oaep-with-mangers-attack/">Manger’s attack</a>, which is <em>another</em> padding oracle attack that can be used to recover plaintext.</p>
<p>The fundamental issue here is that padding is <em>necessary</em> when using RSA, and this added complexity opens the cryptosystem up to a large attack surface. The fact that a single bit of information, whether the message was padded correctly, can have such a large impact on security makes developing secure libraries almost impossible. TLS 1.3 no longer supports RSA so we can expect to see fewer of these attacks going forward, but as long as developers continue to use RSA in their own applications there will be padding oracle attacks.</p>
<h2>So what should you use instead?</h2>
<p>People often prefer using RSA because they believe it’s conceptually simpler than the somewhat confusing DSA protocol or moon math elliptic curve cryptography (ECC). But while it may be easier to understand RSA intuitively, it lacks the misuse resistance of these other more complex systems.</p>
<p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image14.jpg?ssl=1"><img data-attachment-id="98922" data-permalink="https://blog.trailofbits.com/2019/07/08/fuck-rsa/image14-3/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image14.jpg?fit=523%2C500&amp;ssl=1" data-orig-size="523,500" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image14" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image14.jpg?fit=300%2C287&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image14.jpg?fit=523%2C500&amp;ssl=1" loading="lazy" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image14.jpg?resize=523%2C500&amp;ssl=1" alt="" width="523" height="500" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2019/07/image14.jpg?resize=523%2C500&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></p>
<p>First of all, a common misconception is that ECC is super dangerous because choosing a bad curve can totally sink you. While it is true that curve choice has a major impact on security, one benefit of using ECC is that parameter selection can be done publicly. Cryptographers make all the difficult parameter choices so that developers just need to generate random bytes of data to use as keys and nonces. Developers could theoretically build an ECC implementation with terrible parameters and fail to check for things like <a href="https://blog.trailofbits.com/2018/08/01/bluetooth-invalid-curve-points/">invalid curve points</a>, but they tend to not do this. A likely explanation is that the math behind ECC is so complicated that very few people feel confident enough to actually implement it. In other words, it intimidates people into using libraries built by cryptographers who know what they’re doing. RSA on the other hand is so simple that it can be (poorly) implemented in an hour.</p>
<p>Second, any Diffie-Hellman based key agreement or signature scheme (including elliptic curve variants) does not require padding and therefore completely sidesteps padding oracle attacks. This is a major win considering RSA has had a very poor track record avoiding this class of vulnerabilities.</p>
<p>Trail of Bits recommends using <a href="https://en.wikipedia.org/wiki/Curve25519">Curve25519</a> for key exchange and digital signatures. Encryption needs to be done using a protocol called <a href="https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme">ECIES</a> which combines an elliptic curve key exchange with a symmetric encryption algorithm. Curve25519 was designed to entirely prevent some of the things that can go wrong with other curves, and is very performant. Even better, it is implemented in <a href="https://libsodium.gitbook.io/doc/">libsodium</a>, which has <a href="https://libsodium.gitbook.io/doc/public-key_cryptography/sealed_boxes">easy-to-read documentation</a> and is <a href="https://libsodium.gitbook.io/doc/libsodium_users">available for most languages</a>.</p>
<h2>Seriously, stop using RSA</h2>
<p>RSA was an important milestone in the development of secure communications, but the last two decades of cryptographic research have rendered it obsolete. Elliptic curve algorithms for both key exchange and digital signatures were standardized back in 2005 and have since been integrated into intuitive and misuse-resistant libraries like libsodium. The fact that RSA is still in widespread use today indicates both a failure on the part of cryptographers for not adequately articulating the risks inherent in RSA, and also on the part of developers for overestimating their ability to deploy it successfully.</p>
<p>The security community needs to start thinking about this as a herd-immunity problem—while some of us might be able to navigate the extraordinarily dangerous process of setting up or implementing RSA, the exceptions signal to developers that it is in some way still advisable to use RSA. Despite the many caveats and warnings on StackExchange and Github READMEs, very few people believe that they are the ones who will mess up RSA, and so they proceed with reckless abandon. Ultimately, users will pay for this. This is why we all need to agree that it is flat out unacceptable to use RSA in 2019. No exceptions.</p>
			</div><!-- .entry-content -->

	
</article></div>
  </body>
</html>
