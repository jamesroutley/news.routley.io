<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://boxbase.org/entries/2020/aug/3/case-against-oop/">Original</a>
    <h1>Case against OOP is understated, not overstated (2020)</h1>
    
    <div id="readability-page-1" class="page"><article>
<p>Here&#39;s something for nobody. We&#39;ve been past this a long while ago now.
OOP is one of those substances that stick to the wall if you throw it.
Writing about it is almost always pointless because
people who should learn refuse to learn,
and everybody else has learnt their lesson.</p>
<p>I review and criticize
<a href="https://medium.com/young-coder/the-case-against-oop-is-wildly-overstated-572eae5ab495">&#34;The Case Against OOP is Wildly Overstated&#34;</a> by Matthew MacDonald.
The article itself references few other posts and I give the same treatment to those.
You may have seen these before:</p>
<ol>
<li><a href="https://medium.com/better-programming/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7">Object-Oriented Programming --- The Trillion Dollar Disaster</a> by Ilya SuzdaInitski</li>
<li><a href="https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53">Goodbye, Object Oriented Programming</a> by Charles Scalfani</li>
<li><a href="https://medium.com/@konradmusial/why-oop-is-bad-and-possibly-disastrous-e0844fa96c1f">Why OOP is bad</a> by Konrad Musial</li>
<li><a href="http://kawagner.blogspot.com/2006/08/oop-is-dead.html">OOP is dead</a> by Karsten Wagner</li>
</ol>
<p><em>I go through the main points of these posts so that you don&#39;t need to read them.</em>
<strong>Additionally we&#39;ll have</strong>:</p>
<ul>
<li>A peek into Grady Booch&#39;s book
from which &#34;4 pillars of OOP&#34; is claimed to originate from.</li>
<li>How the whole <em>OOP is a lauded proglang hack to a record datatype</em>.</li>
<li>Predictable alternative for polymorphism (parametric polymorphism).</li>
<li>Why pattern matching doesn&#39;t do dynamic dispatch but is instead a substitute for inheritance.</li>
<li>Misconceptions you might have about types.</li>
<li>Why &#34;no&#34; for multiple dispatch.</li>
<li>How <code>&#34;dog extends animal&#34;</code> is not evil because you got isomorphisms.</li>
<li>Logic programming hidden in sight at Haskell programming language.</li>
<li>Concluding with a methematical explanation why OOP sucks big time.</li>
</ul>
<p>Not every weekend you get to see such a jewel in the sewer that&#39;s the Internet.
Lets peek in!</p>
<h2>Micro-summaries/reviews of OOP posts</h2>
<p>On each post I&#39;ll go through the main points they had to say.
Ilya&#39;s post was largest of them all with 27min read,
the second largest was Karsten&#39;s post.</p>
<p>I&#39;ve got my opinions inserted in and the things I pick
up form the basis for subjects that the rest of this post covers.</p>
<h3>The trillion dollar disaster</h3>
<p>Ilya SuzdaInitski makes lot of claims but doesn&#39;t bother to present evidence.
He makes that up by doing a lot and lot of claims.
There are plenty of references to popular anti-OOP stuff so it&#39;s not a total loss.
Also it&#39;s a structured post that&#39;s easy to skim unlike the others in this bunch.</p>
<p>The high point in this post is Edsger W. Dijkstra&#39;s quote
&#34;Object oriented programs are offered as alternatives to correct ones...&#34;
I chuckled at that one, yeah Dijkstra obsessed over correctness and
I guess I&#39;ve ended up to doing that as well.</p>
<p><strong>All the claims:</strong></p>
<ol>
<li>There&#39;s no evidence that OOP is better than plain procedural programming.</li>
<li>Programming paradigms should constrain bad programmers from doing too much damage.</li>
<li>Object oriented programming was supposed to be about messages and actors,
rather than about objects and methods.</li>
<li>OOP fails to keep the complexity because of
shared mutable state, errorneous abstractions and low signal-to-noise ratio.</li>
<li>Shared mutable state is hard to track and causes concurrency issues.</li>
<li>Encapsulation is a trojan horse hiding mutable state.</li>
<li>OOP tries to model the real world as objects and class trees through inheritance.</li>
<li>OOP is difficult to unit test.</li>
<li>Forms heavy dependencies between classes unless
you create interfaces everywhere and then mock them.</li>
<li>Difficult to refactor without tools.</li>
<li>Mentions design patterns, SOLID, dependency injection as band-aids to OOP.</li>
<li>Mentions abstraction, inheritance, encapsulation, polymorphism
 as four pillars of OOP <em>with intent to refute these</em>.</li>
<li>OOP is popular due to Java.</li>
<li>It&#39;s time to move on.</li>
<li>You&#39;re already a functional programmer
 and learning functional programming makes you better.</li>
<li>Usual defensive arguments are weak and probably never met a true functional language.</li>
<li>Talks about Law of Demeter as useless under-the-rug-sweep.</li>
<li>People try to discredit anything that claim OOP sucks.</li>
</ol>
<p><strong>Notable references:</strong></p>
<ol>
<li>Mentions functional programming and Linus Tolvalds hating on C++ programming.</li>
<li>Alan Kay&#39;s famous quote and refers to Erlang as a &#34;pure form&#34; implementation of OOP. </li>
<li>Stevey Yegge&#39;s blogpost &#34;Execution in the Kingdom of Nouns&#34;.
I prefer the <a href="https://www.eecis.udel.edu/~decker/courses/280f07/paper/KingJava.pdf">PDF version of Yegge&#39;s post</a>.
It&#39;s criticizing Java programming language for sticking to OOP.
<em>I somehow remembered you could find it from the old <a href="https://wiki.c2.com/">WikiWikiWeb</a> but I didn&#39;t find it there. Just thought it might be fun to remember that site.</em></li>
<li>Reference to problem factory. I&#39;m sure this is a reference.
<em>I just don&#39;t know this one. Help welcome! Remind me where the problem factory -term originated from? Yes, there&#39;s a design pattern called &#39;factory&#39;, I don&#39;t ask about that.</em></li>
<li>Reference to Joe Armstrong&#39;s &#34;Banana, Gorilla, Jungle&#34; -quote.</li>
<li>Transition from horses to automobiles used as argumentation device.</li>
</ol>
<p>First of all, Alan Kay&#39;s remark about classes and objects cannot be used against OOP.
<em>Classes and objects were featured in Simula programming language and it went along from there.</em>
That it was inspired by something potentially better doesn&#39;t demerit it.
<em>OOP is a datatype customization feature with an overinflated ego.</em>
It exposes decades old implementation details and makes them a principal model where you do programming.</p>
<p>The conception that you discard shared mutable state
when you stop doing OOP is the thing that keeps people in.
<em>You can do &#34;immutable&#34; OOP and it&#39;s not any better!</em></p>
<p><em>Taxonomies and attempts to understand the world through them aren&#39;t OOP&#39;s problem.</em>
Besides when you pick this up they point out that you&#39;re not supposed
to write classes such as a &#34;Car&#34; or a &#34;Banana&#34;
and they&#39;re just as wrong as Ilya is wrong claiming the opposite.</p>
<p>OOP was verbose from the beginning and it didn&#39;t prevent it from going.
You&#39;re supposed to buy stuff with that verbosity so
bickering about &#34;low-signal-to-noise&#34; ratio receives eye rolls only.</p>
<p>They&#39;re going to tell you that they&#39;re using tools for refactoring
and just declare interfaces everywhere so that it can be unit tested.
IDE refactors the boilerplate code so they don&#39;t worry about it.
Interfaces and mocks just everywhere and it is not a problem.</p>
<p><strong>On claims of unit testing and OOP</strong>,
I&#39;m not going to go there much more because I still don&#39;t unit test my stuff.
I&#39;m currently not against it. I just don&#39;t know about it much.
I find it much easier to formally verify things correct
than to test that they&#39;re correct.</p>
<p><strong>OOP precedes Java.</strong>
<em>C++ was raging hot popular object oriented language before Java became popular.</em></p>
<h3>Goodbye, Object Oriented Programming</h3>
<p>Charles Scalfani was &#34;gung-ho to leverage
the benefits of Inheritance, Encapsulation and Polymorphism&#34;.
He was disappointed that the planes didn&#39;t land to his backyard.</p>
<ol>
<li>Half the post is about the banana-monkey-jungle problem.</li>
<li>Other half is about the fragile base class and contain-and-delegate as a solution to it.</li>
<li>Categorical hierarchies (taxonomies) don&#39;t work for programming?</li>
<li>Encapsulation doesn&#39;t work because it hides stateful variables.</li>
<li>You don&#39;t need object oriented programming for polymoprhism.
Presents interface-based polymorphism as an alternative.</li>
<li>Shills Elm. <em>Lol. (Scalfani&#39;s post is from 2006)</em></li>
</ol>
<p>These guys attack the pillars of OOP a lot.
This is why I did look into Grady Booch&#39;s book.</p>
<p><em>I guess it&#39;ll be also time to talk about these taxonomies and maps.</em>
Is this going to be the programmer equivalent of bees and flowers talk?</p>
<p><a href="https://en.wikipedia.org/wiki/Fragile_base_class">The fragile base class -problem</a>
seem to be well-covered and settled and has not affected the remaining discussion,
so I didn&#39;t cover that one here.
What it&#39;s about: Seemingly safe modifications to a base class may
cause the derived classes to malfunction.
The programmer cannot determine whether base class modification is safe
simply by examining the base class in isolation.</p>
<p>He mentions interface-based polymorphism as an alternative
<em>but doesn&#39;t say what it is or link to anything!</em></p>
<p><strong>Elm</strong> has become a laughing stock.
They skipped typeclasses in hopes that something better appears.
So far they&#39;re still waiting for it and they got full libraries.
They&#39;ve done plenty of things to make it simple for a beginner
but when it comes to retaining users, LOL.
The language enforces its own best practices and it&#39;s getting to your way
by limiting the size of tuples that you can make,
tripping your homogeneous coordinate construction,
and banning <code>undefined/absurd</code> in release.</p>
<p>Here&#39;s absurd from Idris, so you get some idea what they prevent in release.</p>
<pre><code>absurd : Uninhabited t =&gt; t -&gt; a</code></pre>
<p>Non-dependent languages don&#39;t have this,
but they got <code>undefined</code> for the same purpose.
Elm has this too but it&#39;s in debug module and prevents its use in release.
It&#39;s very fun to wrap the function into a maybe
and handle it without the maybe monad,
or come up with a placeholder value,
when you know for certain that it&#39;s something that
means the program has something very badly wrong if it happens.
Nah, it&#39;s <code>Nothing</code>, tells Elm!</p>
<h3>Why OOP is bad</h3>
<p>Konrad Musial tells how he used to be excited about OOP.
He learned about circles and ellipses as objects with properties.
This is a story about struggling to understand OOP.
As an example he throws in a bit of C#.
Glancing at this code, it&#39;s not particularly complex
but sprinkled with attributes like this <code>[Serializable]</code> here.</p>
<pre><code>[Serializable]
</code><code>public class SampleClass {}</code></pre>
<p><em>These aren&#39;t technically even OOP.</em>
They&#39;re C#&#39;s way to give code additional declarations and structure
that can be used for metaprogramming.
It&#39;s one of the flagship features of C#,
something you should definitely know how to use if you&#39;re going to use that language.</p>
<p>The post is filled with popular anti-OOP quotes and in the end
he tells us he figured it out and went back to doing OOP.
Week or two later he wrote &#34;Why OOP is Awesome&#34;.
<em>That you don&#39;t understand something doesn&#39;t mean it&#39;s flawed or bad.</em></p>
<p><em>This one is a prose-formed text and it&#39;s not the only.</em>
<em>I struggled to go through these despite them being shortest in the bunch.</em>
It requires that I read the whole text through in at an one throw.
I just recently figured out myself the pieces I was missing to writing
<a href="https://boxbase.org/entries/2020/jul/20/on-how-i-write/">effortlessly skimmable texts</a>.
I don&#39;t say that I perfected it but you&#39;re reading one text
that&#39;s been <em>almost</em> written in this style.</p>
<h3>OOP is dead</h3>
<p>Karsten Wagner thinks OOP reached its peak and is on the decline.
Interest is increasing toward functional programming languages
and concepts such as closures and continuations.
To respond, languages that used to be &#34;OO&#34; have
begun to integrate new features into themselves.</p>
<ol>
<li>States new features do not necessarily ease software development.</li>
<li>There will be too many features and mixing them up
will be worse than using handful of them consistently.</li>
<li>Functional programming is doing it better,
there pattern matching replaces multiple dispatch.</li>
<li>Thinks OOP failed to live up to its promise and lists few reasons.</li>
<li>Shills multiple dispatch as a solution to float~int conversion in addition.</li>
<li>You can use relational data models instead of wrapping things into objects.</li>
<li>Believes people start using OOP-languages in non-OOP way.</li>
<li>It&#39;s possible to write interactive programs without having mutation of data.
 Mentions Monads.</li>
<li>Boasts referential transparency as the important thing about functional programming.</li>
</ol>
<p><strong>List of reasons why he thinks OOP failed to live up to its promise:</strong></p>
<ol>
<li>&#34;this&#34; -parameter in the method call is too special.
Mentions problems that arise when you have to act on multiple parameters.</li>
<li>Points out you can&#39;t give your own <code>.trimLeft</code> to a <code>String</code> -class
when you don&#39;t implement the <code>String</code> class.
You got to create <code>String.trimLeft</code> instead.</li>
<li>Tells about monkey-dispatch in Python,
to add things into a class as an afterthought is bringing up its own problems.</li>
<li>Picks mutable state issues up.
Points out mishandling of mutable state doesn&#39;t happen often in OOP,
but when it does it&#39;s making up for that in how wrecking it is.</li>
<li>Optimization of OOP code increases it&#39;s complexity a lot.</li>
<li>Object-hierarchies may end up being cyclic,
forming structures that are very difficult to maintain.
States you can handle this with tooling but questions whether the complexity is necessary.</li>
</ol>
<p>I think in certain groups use of OOP has declined.
There are a lot more people who understand type theory
and formal verification than there were 14 years ago.
Haskell finally ranks #40 on TIOBE index!</p>
<p><em>In big scale OOP is doing just great because there are more programmers than ever!</em>
They&#39;re going through Uncle Bob&#39;s night reading,
learning about design patterns, SOLID and everything else OOP that sounds great.
It is also great time for OOP in programming languages.
Popular languages such as Javascript and Python are steered
by their communities in a democratic resolution that relies on dialogue.</p>
<p>I was also in belief that people would start using OOP languages in non-OOP way
but that hasn&#39;t entirely happened yet.
Here we are still discussing OOP and we haven&#39;t gotten over it yet..</p>
<p>The rigidity of methods given to a class is a real problem but it&#39;s usually ignored.
Maybe it&#39;s not seen as a big problem because you have to import your own
<code>trimLeft</code> from a module anyway.</p>
<p>When you write interactive programs with monads,
it doesn&#39;t go the way that mutation would disappear.
<em>Monadic IO pushes the mutable structures to the edges of the program but you still have them or something like it.</em>
I&#39;ve explained this in <a href="https://boxbase.org/entries/2020/may/18/diy-io-monad">&#34;Understand IO Monad and implement it yourself in Haskell&#34;</a>.</p>
<p>He seem to confuse that pattern matching would replace multiple dispatch
and it doesn&#39;t actually work that way.
Multiple dispatch also doesn&#39;t work and the worst thing it&#39;ll be only apparent
and gets worse after you rely on it more, I tried that in my lever programming language and it went badly.</p>
<p>At least we&#39;ve figured out already 14 years ago that referential transparency is important!
I&#39;m glad about that.
<em>Now we just need to get somebody to chant &#34;mathematical expressions!&#34; in front of developers.</em></p>
<h3>The Case Against OOP is Wildly Overstated</h3>
<p>Matthew MacDonald&#39;s take is that you can&#39;t rule without attracting enemies.
Just look at all these blog posts by various people and more behind the curtains.</p>
<ol>
<li>Doubts that sloppy design practices and fuzzy architectural thinking
would be unavoidable parts of OOP.</li>
<li>States, correctly, that OOP isn&#39;t supposed to model the real world.</li>
<li>Object-relational mapping is exemplified as an antipattern.</li>
<li>Eloquent Javascript advice: Pick the simplest approach that meets the need.</li>
<li>States that software design is hard to do right, no matter the tools.</li>
<li>Design patterns can result in a mess,
tells to instead focus on the Don&#39;t Repeat Yourself and You Ain&#39;t Gonna Need It,
Law of Demeter (restrict what classes must know about each other),
and valuing simplicity and readability above all else.</li>
<li>Points OOP inheritance is the weakest link and attacked often.
They&#39;re right, be careful of using it.</li>
<li>OOP doesn&#39;t prevent you from applying the wrong solution to a problem.</li>
<li>We&#39;ll see if Go and Rust steals the crown in the next decade.</li>
<li>Agrees that OOP is indeed fading in domination, probably.</li>
</ol>
<p>I got relatively little to say about this post itself.
The title has been chosen fairly well as it accurately presents author&#39;s opinion, sans wildly.
<em>The author actually seem to agree there&#39;s a case against OOP although says it&#39;s overstated.</em></p>
<p>I&#39;m glad people finally figured out that ORM sucks.</p>
<p>There&#39;s the usual claim that OOP isn&#39;t supposed to model the real world.
This came up into OOP/anti-OOP discussion when it became more apparent
that people followed up with what they were taught in a rather strict manner.
The pretense that you weren&#39;t supposed to follow up with what you were taught.
I still remember my own principled OOP-calculator written in C++. Hah.
I remember how somebody commended it in IRC.
They&#39;re all wrong about it either way.
<em>Forming a taxonomical model is ok if it participates to solving the problem at hand.</em></p>
<p><em>The advice about not blaming your tools is good advice, don&#39;t blame your tools... leave that to me. I am a professional tool-blamer!</em></p>
<h2>Grady Booch&#39;s book: Object-oriented Analysis and Design with Applications</h2>
<p>According to Quora, the 4 pillars of OOP are claimed to originate from the book
&#34;Object-oriented Analysis and Design with Applications&#34;
by Grady Booch, published by Addison-Wesley Professional in 1990.</p>
<p><strong>Highlights:</strong></p>
<ol>
<li>There are well-done comical illustrations sprinkled through.</li>
<li><em>He already addresses the thing about categorical hierarchies in this book.</em>
The book talks about <em>identifying key abstractions</em>.
It was already recognized here that plain taxonomies doesn&#39;t work for abstraction,
simply because there&#39;s multiple of them that are all valid.</li>
<li>Probably something else interesting would be in there if I bothered to read deeper.</li>
<li>It&#39;s better than many later OOP books.
It comes with a long references section and a large glossary.</li>
</ol>
<p>I got my hands on the second edition published in 1994 and
I looked in to see what Booch means with
abstraction, encapsulation, inheritance and polymorphism.</p>
<p>I&#39;m also interested about how the book treats class/object -structures
and programming languages..
If I were smarter than I am, I might have went deeper on this regard.</p>
<h3>4 pillars of OOP</h3>
<p>I don&#39;t bother to search deep into this book but at least there&#39;s a glossary.
It explains these terms!
We can&#39;t treat any book as a foundation anyway, but we get some reference points.</p>
<p><strong>abstraction</strong> &#34;&#34;The essential characteristics of an object that distinguish
it from all other kinds of objects and thus provide crisply-defined
conceptual boundaries relative to the perspective of the viewer;
the process of focusing upon the essential characteristics of an object.
Abstraction is one of the fundamental objects of the object model.&#34;&#34;</p>
<p><strong>encapsulation</strong> &#34;&#34;The process of compartmentalizing the elements of an abstraction
that constitute its structure and behavior; encapsulation serves to separate
the contractual interface of an abstraction and its implementation.&#34;&#34;</p>
<p><strong>inheritance</strong> &#34;&#34;A relationship among classes, wherein one class shares the
structure or behavior defined in one (single inheritance) or more
(multiple inheritance) other classes. Inheritance defines an &#34;is-a&#34; hierarchy
among classes in which a subclass inherits from one or more generalized
superclasses; a subclass typically specializes its superclasses by augmenting
or redefining existing structure and behavior.&#34;&#34;</p>
<p><strong>polymorphism</strong> &#34;&#34;A concept in type theory, according to which a name
(such as variable declaration) may denote objects of many different classes
that are related by some common superclass; thus, any object denoted by this name
is able to respond to some common set of operations in different ways.&#34;&#34;</p>
<p>What does Booch think of OOP these days?
There&#39;s a <a href="https://www.informit.com/articles/article.aspx?p=1405569">interview with Booch in 2009</a>.
Back then the guy still admitted to using Java and PHP with Eclipse.</p>
<h3>Booch&#39;s treatment of programming languages</h3>
<p>There&#39;s a list in the book:
Weigner&#39;s classification of more popular high-order programming languages
into generations arranged according to language features they first introduced:</p>
<p>First-Generation languages </p>
<ol>
<li>FORTRANI (mathematical expressions)</li>
<li>ALGOL 58 (mathematical expressions)</li>
<li>Flowmatic (mathematical expressions)</li>
<li>IPL V (mathematical expressions)</li>
</ol>
<p>Second-generation languages:</p>
<ol>
<li>FORTRANII (subroutines, separate compilation)</li>
<li>ALGOL 60 (Block structure, data types)</li>
<li>COBOL (Data description, file handling)</li>
<li>Lisp (List processing, pointers, garbage collection)</li>
</ol>
<p>Third-generation languages:</p>
<ol>
<li>PL/1 (FORTRAN + ALGOL + COBOL)</li>
<li>ALGOL 68 (Rigorous successor to ALGOL 60)</li>
<li>Pascal (Simple successor to ALGOL 60)</li>
<li>Simula (Classes, data abstraction)</li>
</ol>
<p>The generation gap (1970-1980)</p>
<ol>
<li>Many different languages were invented, but few endured. [2]</li>
</ol>
<p>I find the first-generation languages hilarious.
They&#39;re right on the money if I&#39;d believe this list was accurate.
The positioning of Lisp is pretty funny as well.</p>
<p>I&#39;m not sure, but perhaps Booch took the shape of the programming language as granted?
&#34;These are the means of abstraction I get and I better make best use of them&#34;.
Unfortunately I didn&#39;t find any support for this idea,
otherwise it&#39;d settle the whole debate around OOP.</p>
<p>Otherwise I really like how this book is structured.
It&#39;s a great example of a book
as the glossary and references section doesn&#39;t look like they were a Caecum.
I&#39;m likely returning to take more notes of how it delivers its content.</p>
<h2>The delusion is strong binding force in Nounland</h2>
<p>The whole point of this post is that hey,</p>
<ol>
<li>Inheritance was supposed to be an important pillar but now it&#39;s rolling on the floor?</li>
<li>Are you sure about polymorphism?
First of all you took it from type theory and that&#39;s itself getting popular
featuring stable forms of parametric polymorphism,
while your version of polymorphism is shifting shape like crazy.</li>
<li>With only two pillars standing,
OOP is seeming more of a balancing act
rather than an architectural wonder it was supposed to be.</li>
<li>There&#39;s a whole mobile phone software industry standing on Java
which has heavy object oriented foundations.</li>
</ol>
<p>When people start to move the poles you might be mistaken
that the whole object oriented programming is a circus performance.
It&#39;s like musical chairs but played with foundational pillars.</p>
<p>It&#39;d be a bit of irony to show the problems with examples from Booch&#39;s book,
therefore all of the OOP examples here are from that book.</p>
<p>2020-08-03 Addendum to above: [hwayne][hwayne] pointed out that
ML cited CLU&#39;s type system as inspiration,
which cited Simula as inspiration.
From a historical perspective polymorphism have migrated from OOP to FP.</p>
<p>[hwayne] : https://lobste.rs/s/bmzgvz/case<em>against</em>oop<em>is</em>wildly<em>overstated#c</em>f7arfr</p>
<h2>A record with an overinflated ego</h2>
<p>Object oriented programming started from
<em>the need of greater customization for datatypes.</em>
The only form of customization used to come in a form of a record datatype.</p>
<pre><code>struct PersonnelRecord
</code><code>{
</code><code>    char  name[100];
</code><code>    int   socialSecurityNumber;
</code><code>    char  department[10];
</code><code>    float salary;
</code><code>}</code></pre>
<p>When it was recognized that you would
want more abstraction and customization into datatypes, classes were born.
<em>Classes extend from records by letting you to define methods and structures that are shared between every object.</em></p>
<pre><code>class PersonnelRecord {
</code><code>public:
</code><code>  char* employeeName() const;
</code><code>  int   employeeSocialSecurityNumber() const;
</code><code>  char* employeeDepartment() const;
</code><code>protected:
</code><code>  char  name[100];
</code><code>  int   socialSecurityNumber;
</code><code>  char  department[10];
</code><code>  float salary;
</code><code>}</code></pre>
<p><em>It was considered good engineering practice to encapsulate the state of an object like this.</em>
When you separate the access to parameters like this,
you can now change the implementation of the record into something else
and nobody who is using this object needs to know how it&#39;s implemented.</p>
<p>The implementation of the feature was easy,
<code>karen.employeeName()</code> just calls some function
instead of really accessing a function in a record.
It was easy and much cheaper than other things you could do.</p>
<p>Very early on this also gave some namespace around the methods.
When you really had nothing else this all
must have been looked very great and minimal.</p>
<p>Today it&#39;s possible to give you far more distance between hardware
than it used to be 30 years ago.
Is there any reason why you should
build abstractions over flat record structures now?</p>
<h2>Inheritance &amp; Polymorphism</h2>
<p>I was going to write about inheritance and polymorphism entirely separately,
but they&#39;re actually provided by the same structure.
Inheritance enables the polymorphism.</p>
<p>A common use is to describe variance between different forms of records.
It&#39;s presented in this example of a base class.</p>
<pre><code>class TelemetryData {
</code><code>public:
</code><code>  TelemetryData();
</code><code>  virtual ~TelemetryData();
</code><code>  virtual void transmit();
</code><code>  Time currentTime() const;
</code><code>
</code><code>protected:
</code><code>  int id;
</code><code>  Time timeStamp;
</code><code>};</code></pre>
<p>The base class describes what you can do to the structure
as well as identifies things that every structure share. 
This structure is then extended to contain more information specific
to certain class of structures:</p>
<pre><code>class ElectricalData : public TelemetryData {
</code><code>public:
</code><code>  ElectricalData(float v1, float v2, float a1, float a2);
</code><code>  virtual ~ElectricalData();
</code><code>
</code><code>  virtual void transmit();
</code><code>
</code><code>  float currentPower() const;
</code><code>
</code><code>protected:
</code><code>  float fuelCell1Voltage, fuelCell2Voltage;
</code><code>  float fuelCell1Amperes, fuelCell2Amperes;
</code><code>}</code></pre>
<p>The &#34;virtual&#34; methods are accessed from a virtual method table associated to each class.
This results in a pointer that could be used to identify class
of an object so that it can be promoted.
Using the approach is considered a bad style
because classes are supposed to be extensible.
The pointer just cannot be used to identify a class directly
because you may subclass any class and extend it,
receiving a different vtable pointer for it.
To identify vtables you have to be able to chain them.</p>
<h3>What does it translate to?</h3>
<p>For curiosity somebody may ask, how were classes simple to implement?
There are several ways to implement classes/objects.
You can implement them as a very thin layer above records.</p>
<p>Classes translate down into structures
that each have a virtual table pointer in front of them.
Note that the pointer is needed because a class extending
from a structure may declare its own virtual methods.</p>
<pre><code>struct EmptyClass {
</code><code>    void *vtable;
</code><code>};
</code><code>
</code><code>struct TelemetryData {
</code><code>    struct EmptyClass super;
</code><code>    int id;
</code><code>    Time timeStamp;
</code><code>};
</code><code>
</code><code>struct ElectricalData {
</code><code>    struct TelemetryData super;
</code><code>    float fuelCell1Voltage, fuelCell2Voltage;
</code><code>    float fuelCell1Amperes, fuelCell2Amperes;
</code><code>};</code></pre>
<p>The static methods are referenced directly
and translate to plain procedures like these.</p>
<pre><code>TelemetryData_TelemetryData(TelemetryData*);
</code><code>Time TelemetryData_currentTime(TelemetryData*);
</code><code>
</code><code>ElectricalData_ElectricalData(ElectricalData*, float v1, float v2, float a1, float a2);
</code><code>float ElectricalData_currentPower();</code></pre>
<p>If something&#39;s declared virtual, it goes into a virtual method table.</p>
<pre><code>struct EmptyClass_vtable {
</code><code>    // void *vtableParent; /* If the dreaded &#39;instanceof&#39; is implemented. */
</code><code>};
</code><code>
</code><code>struct TelemetryData_vtable {
</code><code>    struct EmptyClass_vtable super;
</code><code>    void (*deconstruct)(TelemetryData*);
</code><code>    void (*transmit)(TelemetryData*);
</code><code>};
</code><code>
</code><code>struct ElectricalData_vtable {
</code><code>    struct TelemetryData_vtable super;
</code><code>};
</code><code>
</code><code>static TelemetryData_vtable  vtable_TelemetryData;
</code><code>static ElectricalData_vtable vtable_ElectricalData;</code></pre>
<p>It&#39;s easy to confuse the type of a vtable and the actual vtable,
though this itself is not a flaw of any kind
and you don&#39;t need to worry about how classes and objects are implemented
if they&#39;ve been implemented correctly.
Whenever the ElectricalData is constructed,
the vtable in it is set to point on <code>(&amp;vtable_ElectricalData)</code>.</p>
<h3>Closed/Open-definition structures and &#34;instanceof&#34;</h3>
<p>Inheritance allows you to build
both closed-definition and open-definition structures.</p>
<ol>
<li>Open-definition structures are structures that you can
extend by deriving from them.</li>
<li>Closed-definition structures are defined in a bunch,
and you assume it&#39;s only one of the possible options that you may receive.
No further extension of the base class is expected.</li>
</ol>
<p>These things should be separate because otherwise they tangle together.
To avoid this early OOP languages didn&#39;t have the &#34;instanceof&#34;
although they could have had that through vtables.</p>
<p>You create a closed structure by tagging it.</p>
<pre><code>enum {
</code><code>    t_ElectricalData = 0
</code><code>    t_LightTracking,
</code><code>    t_DoorLockData
</code><code>} TelemetryTag;</code></pre>
<p>Then you can require that when the telemetryTag is <code>t_ElectricalData</code>,
it&#39;s either the <code>ElectricalData</code> or some subclass of it.</p>
<pre><code>if (telem.tag == t_ElectricalData) {
</code><code>    ElectricalData* elec = (ElectricalData*)telem;
</code><code>    /* Do something with it.. */
</code><code>}</code></pre>
<p>This changed when Java introduced the <code>instanceof</code>,
it lets you to be convenient and do it like this:</p>
<pre><code>if (telem isinstanceof ElectricalData) {
</code><code>    ElectricalData elec = (ElectricalData)telem;
</code><code>    /* access elec */
</code><code>}</code></pre>
<p><code>instanceof</code> immediately became a dreaded and abused feature of object oriented programming.
I guess they did it because Java also introduced garbage collection
and this was an ancillary detail of an otherwise safer memory management
or a newly available object-introspection tool.
Ignorance of the problems introduced by this feature took care of the rest.</p>
<p><em>If you look this up, I could link it to here if you inform me why Java introduced instanceof?</em></p>
<h3>Fake abstraction</h3>
<p>That we&#39;re slapping features together like this
results in fragility on its own.
The way these structures are used are tightly wound to
how they&#39;re implemented by the compiler.
This is not how abstraction is supposed to work,
but I let you pretend it&#39;s intact for courtesy.</p>
<p>This tradition of fake abstraction is followed through in Java and C#.
They come up with their own virtual machines
and instead of translating across multiple platforms
like a well-typed and compiled language otherwise could,
<em>they refuse to work on anything else than their virtual machines provided along them.</em>
In this regard you find a typed, compiled language
but it behaves just like an untyped language such as Python or Javascript.</p>
<h2>Uncontrolled polymorphism</h2>
<p>Virtual class methods provide polymorphism
and allow you to select behavior at runtime.
There&#39;s bit of a problem because this form of polymorphism is arbitrary.
It means that you can do about anything without constraints.
This would be otherwise a good thing,
but you won&#39;t know which of them will result in good behavior of the program.
If you don&#39;t know that then you could as well not have it.</p>
<p>Besides the rules for building well-formed polymorphic programs in
object oriented programs are complex,
involving ideas such as <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">covariance and contravariance</a>
Turns out that often you, or neither often your superiors
know exactly how an OO-program should use polymorphism.
You still use this feature though!</p>
<h3>Covariance and Contravariance</h3>
<p>The object oriented programming builds on subtyping.
The subtyping means that when somebody asks for a Cat,
you can give him a CatDog and he gets to interface with the Cat -part.
You can pass more information in than is exactly required,
likewise you may be answered with more information than you requested.</p>
<p>Types get ordering based on how much &#34;information&#34; they contain.
When this ordering is preserved, the things are said to be covariant.
Eg. Somebody provides a Cat and you want an Animal.
If the ordering is reversed,
such as in you have to pass in an Animal and you provide in a Cat,
then it&#39;s contravariant.
It&#39;s bivariant if it needs to pass and receive Cats.
It&#39;s invariant if it&#39;s irrelevant whether it&#39;s a Cat.</p>
<p>These things are very easy to confuse to the point that I&#39;m not sure if I just did.
If you get them wrong then your polymorphism just blows up.</p>
<h3>Parametric polymorphism</h3>
<p>There&#39;s a fairly simple way to write well-behaving polymorphic programs. 
The trick is to enforce that polymorphic programs treat their polymorphic parts uniformly.
When polymorphic programs aren&#39;t allowed to look inside the structures they manipulate,
then it&#39;s well-defined how they&#39;re manipulating those structures.
This is known as parametric polymorphism
and it&#39;s a common style in functional programming languages for polymorphism.
For example, when you meet a function such as:</p>
<pre><code>a → a</code></pre>
<p>You know that the function cannot access the insides of <code>a</code> in any way,
it must go through the function.
However when you give in an additional function like this:</p>
<pre><code>(a → a) → (a → a)</code></pre>
<p>You know that a function of this type may send the <code>a</code> through the second
function zero or many times.
It&#39;s much less hard to operate and reason about objects
that are consistently what they need to be.</p>
<h3>Features that break parametric polymorphism</h3>
<p>The neat thing about parametric polymorphism is that it ends up being
programming language designer&#39;s fault if it ends up broken.
It&#39;s no longer programmers fault.</p>
<p>The easiest way to break parametric polymorphism is to
introduce an implicit Monad &#34;join&#34;,
this also destroys the monad -part of the construct.</p>
<pre><code>maybe (maybe a)     → maybe a
</code><code>promise (promise a) → promise a
</code><code>array (array a)     → array a</code></pre>
<p>The first one is often broken by introducing
a <code>Nothing</code> constant and leaving out the <code>Just(a)</code> for convenience,
or giving implicit <code>Null</code> to every structure constructed
with a pointer so that it&#39;s easy to initialize.
This results in being unable to distinguish between <code>Nothing</code>
and <code>Just Nothing</code>,
which breaks parametric polymorphism on the variables wrapped
with these structures. If <code>maybe a</code> or <code>a?</code> receives a &#34;null&#34;
and <code>a</code> happens to be <code>maybe something</code>,
then the higher-up structure catches the null.
This is akin to the problems of <code>isinstance</code> as the information in <code>a</code>
is suddenly being identified and interpreted in an unpredictable way.</p>
<p>It&#39;s lot more uncommon to see the latter two broken.
You might see the arrays being broken on some early programming languages.
The promise was broken in Javascript
and there&#39;s a whole issue for it, the dreaded <a href="https://github.com/promises-aplus/promises-spec/issues/94">issue 94</a>.</p>
<h2>Why pattern matching doesn&#39;t dynamic dispatch</h2>
<p>Since polymorphic programs aren&#39;t allowed to look inside their parameters
in functional programming, it also means that pattern matching
cannot be used to dispatch on structures.</p>
<p>Patterns in a functional programming language are structures
that have a closed definition.
This means that their definition completely determines how many ways
there are to construct them.</p>
<pre><code>data Form = A | B | C</code></pre>
<p>When the structure is examined,
well-formed program is required to handle every possible case that arises.</p>
<pre><code>case form of
</code><code>    A -&gt; 1
</code><code>    B -&gt; 2
</code><code>    C -&gt; 3</code></pre>
<p>This separation verifies that you have
a much simpler model for building programs.
It partially replaces the inheritance of object oriented programming though,
you&#39;ll be able to create those close-definition objects in this way.</p>
<h3>But how do they dynamic dispatch then?</h3>
<p>Dynamic dispatch actually resembles passing modules or functions
along the arguments.
Technically it&#39;s not any different to the OOP,
but the virtual table is an explicitly described construct.</p>
<p>You might have a record that provides you variety of ways to 
manipulate the structures,
the <code>a</code> is a parameter that can be chosen by the user:</p>
<pre><code>record Arithmetic a = {
</code><code>    show    : a → string,
</code><code>    (+)     : a → a → a,
</code><code>    (-)     : a → a → a,
</code><code>    literal : Integer → a }</code></pre>
<p>These records can be then passed around into a function
that does something abstracted over arithmetic that it does.</p>
<pre><code>Arithmetic a → a → a</code></pre>
<p>You may notice how it resembles the virtual table example earlier.</p>
<h2>Better ways to do it</h2>
<p>Functional programming is itself getting highjacked
by the same consultants who rode the wave and pushed OOP.
Things I&#39;m going to present here should instead be taken
as promotion or shilling of dependent type theory
and formal-logic-based programming.</p>
<p>I left mutability out of discussion because
there&#39;s no additional problems with mutability when it comes to functional programming.
The reason why this is perceived as a problem is due to precision functional programming
requires from the programmer.
Jean-Yves Girard and many other mathematicians took care of that a long while ago.
Besides if you immediately need what you already get from OOP,
then you can get such a similar mess with mutable references for instance in Haskell.</p>
<h2>(Mis?)conception about types</h2>
<p>There&#39;s an old conception around types that I were reminded of while
reading Grady Booch&#39;s book as I saw a picture of a dude
trying to plug a statue of number 3 into a hole.
The statue was labeled with what it was signifying,
and the hole signified something else.</p>
<p>The idea is that the use of types is to ensure you don&#39;t mix
up things such as eg. &#34;number of chicken&#34; to &#34;how much a chicken costs&#34;.
That&#39;s almost a type-theoretic idea though.
A better example would be mixing up 5 dollars and 5 euros.</p>
<p>The point of types according to this explanation
would be that it prevents from mixing things up.
It&#39;s almost correct but slightly wrong.
It also drives you to think of subtyping hierarchies like this:</p>
<pre><code>dollar extends money
</code><code>euro extends money</code></pre>
<p>The example isn&#39;t giving types the attention they deserve though.
It&#39;s awful lot of effort to build separate number types
just to verify that we don&#39;t mix money units.
Very few people are doing that.</p>
<p>Instead there&#39;s a thing you might do with types.
A type verifies that if you need some structure then the given structure is indeed what you&#39;re expecting.
We can exploit this property by asking for very fancy things and then demonstrate that you have them.</p>
<p>For example, you can construct a type that states that the sum of angles of a triangle is 180 degrees.
The structure would be a proof that proves the proposition.
Therefore when you have such a structure,
then you know that in your model of a triangle the angles sum to 180 degrees.</p>
<p>Both procedural and functional programming languages alike
allow some logical reasoning based on types.
The difference is that from functional programming languages
the step-up to type-theory is as easy as abc.</p>
<h2>Referential transparency</h2>
<p>Referential transparency is a potential property of a computer program.
A referentially transparent program can be replaced by it&#39;s value
without changing it&#39;s behavior.
Lets say that <code>x</code> and <code>y</code> are programs,
and you know they&#39;re equal, this is written as <code>x = y</code>.
The meaning of this is same as in mathematics.
It means that <code>x</code> and <code>y</code> have the same value.
If both of them are referentially transparent,
then you can rewrite <code>x</code> to <code>y</code> anywhere in the program and vice versa.</p>
<p>For a programmer this mainly means that you need to separate side effects,
or &#34;behavior&#34;, from the reduction rules.
It enables you to do equational reasoning though!
The equational reasoning is the thing where you equate things together
to walk a trail in order to verify something,
basically things that everybody learnt in schools.</p>
<h2>The multiple dispatch issues</h2>
<p>Karsten proposed you&#39;d do multiple dispatch.
This used to be a popular idea.
I think somebody figured it was bad but nobody listened that guy.
Anyway, if a programming language has a multiple dispatch
and it&#39;s used something like this:</p>
<pre><code>add(int, int)
</code><code>add(float, int)
</code><code>add(int, float)
</code><code>add(float, float)
</code><code>...</code></pre>
<p>I&#39;d advice you to stay far away from it for your own good,
unless you really know that it is extensible for real.
Dynamic dispatch is too limited and becomes difficult
with parametric types that are inevitable if you do
physics computations.
It&#39;s very likely it won&#39;t support the needs of a computer algebra system,
and it won&#39;t provide interoperability you need.</p>
<p>To see where the problem is, just think about this:
If int/float were separate modules that do not depend on each other,
where the <code>(int,float)</code> and <code>(float,int)</code> pairs should be defined?
Nowhere? Somewhere? In either one of the modules but why?</p>
<h2>Taxonomies, categorical hierarchies and maps</h2>
<p>Modern OOP texts demonize these categorical hierarchies
because they make the most embarrasing and entertaining counter-examples
for object oriented programming.
Taxonomies themselves aren&#39;t too bad.
They only become problematic when you pretend you only have one valid
way to group things together.
It&#39;s an unusual problem to have unless you do OOP.</p>
<p>It&#39;s really similar to mappings or projections in this sense.
A lot of effort has been spent to find different ways to flatten
a globe so that you could create maps for it.
Some projections preserve areas, others preserve distances or angles.
People generally, except very few of us,
do not have issues with interpreting maps.</p>
<p>Proper application of type theory doesn&#39;t prevent you from
picking only one when it comes to a taxonomy of some kind.
If a representation for something becomes inconvenient,
you can switch into an isomorphic representation.</p>
<p>Usually isomorphism relates two functions like this:</p>
<pre><code>f : a → b
</code><code>g : b → a</code></pre>
<p>They&#39;re made isomorphic by verifying that their compositions form functions
that do nothing.
That <code>g.f</code> is an identity for <code>a</code> and <code>f.g</code> is the identity for <code>b</code>.</p>
<p>Turns out, isomorhisms allow you to switch between equivalent definitions.
It means you don&#39;t need to stick to any specific categorization of things
and treat it as an absolute representation.
Putting a function in between that preserves the shape keeps it the same.
Type-checked value is like a cat, it sits if it fits.</p>
<h2>Logic programming hidden in sight</h2>
<p>This is here in case you still need some coinvincing
that it&#39;s the EOL for OOP paradigm.
If you stop subtyping then you lose the convenience of subtyping entirely.
Though, in return you get something even more convenient back.</p>
<p>The types-as-propositions -correspondence
means that types are valid terms in a logic programming environment.
This is already used in Haskell with typeclasses.
Instance declarations like these can be interpreted as logic programs.
It&#39;s similar to haskell&#39;s corresponding program,
except that there&#39;s a construction tied to it.
Above there&#39;s the haskell instance declaration
and below is the closest corresponding Prolog program.</p>
<pre><code>instance Show String
</code><code>instance Show Int
</code><code>instance (Show a, Show b) =&gt; Show (a,b)
</code><code>instance Show a =&gt; Show [a]
</code><code>
</code><code>show(string).
</code><code>show(int).
</code><code>show(pair(A,B)) :- show(A), show(B).
</code><code>show(list(A)) :- show(A).</code></pre>
<p>When something queries for a type constraint such as <code>(Show [(Int, String)])</code>,
the GHC compiler can be interpreted to run a proof search
where the returned &#34;proof&#34; is a fully constructed instance to satisfy the constraint.
The requirement for this kind of system to work well is that any result
produced by the inference is as acceptable as any other result it could produce.
To enforce this in Haskell functionality has been limited to something
that you can expect to produce an unique result.
Though there you see a computer building parts of the program for you
because they&#39;re obvious.</p>
<p>The similarity with Prolog and Haskell&#39;s type checker is not a new observation either.
Thomas Hallgren wrote a paper about it, <a href="http://cth.altocumulus.org/~hallgren/Papers/hallgren.pdf">&#34;Fun with Functional Dependencies&#34; [pdf]</a>,
20 years ago.
This paper illustrates how Haskell&#39;s type class system can be used
to express decidable computations at compile-time,
the most elaborate example given there is a static implementation of insertion-sort.</p>
<p>These features aren&#39;t easily &#34;ported&#34;
to procedural or object oriented programming environments
because they rely on the consistency
that comes with stricter application of type theory.</p>
<h2>Mathematical explanation for why OOP sucks a big time</h2>
<p>There&#39;s a potential mathematical reason for why OOP is
giving us such a bad time and we&#39;re writing about it every once and then.
It has to do with the open-ended rules left into popular languages.
When OOP languages come with a type system,
they prevent you from doing some dumb things
but still let you do whole lot of idiotic things.
It eventually results in code breaking when it&#39;s combined in different ways.
This elicites a response from a programmer to cope with it
and he writes code with the strictest possible interfaces
that you can come up with.</p>
<p>You&#39;ll see the Java and C# even support this and make it inconvenient to write
abstract variables and convenient to throw in few <code>int</code>s and <code>float</code>s,
although these are quite close to the machine implementation.
32bit IEEE754 floating points do not satisfy common algebraic laws
you&#39;d expect from real numbers for instance.
Integers are usually machine integers that have limits in their range
and they behave like modular arithmetic instead of the usual arithmetic.
When you&#39;ve selected a type like this,
often you&#39;ve closed off many other possible representations early on.</p>
<p>In functional programming you just say &#34;a&#34; if it&#39;s something that goes
through your system intact.
That&#39;s as abstract as it can be and allows many different variations
of the same program to be constructed for very little effort.</p>
</article></div>
  </body>
</html>
