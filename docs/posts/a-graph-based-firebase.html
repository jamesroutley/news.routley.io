<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stopa.io/post/296">Original</a>
    <h1>A Graph-Based Firebase</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><span><p>In <a href="https://stopa.io/post/279" target="_blank">A Database in the Browser</a>, I wrote that the schleps we face as UI engineers are actually database problems in disguise <sup>[<!-- -->1<!-- -->]</sup>. This begged the question: would a database-looking solution solve them?</p><p>A few months ago, my co-founder Joe and I decided to build one and find out. This became <a href="https://instantdb.com/" target="_blank">Instant</a>. I’d describe it as a graph-based successor to Firebase.</p><p>You have relational queries and basic auth. Optimistic updates come out of the box, and everything is reactive. It is an MVP you can play with today.</p><p>Working on Instant has felt like an evolutionary process. We picked constraints and followed the path that unfolded. This led us to places we would never have predicted. For example, we started with SQL but ended up with a triple store and a query language that transpiles to Datalog.</p><p>What were these constraints? Why triple store? What query language? In this essay, I’ll walk you through the design journey — from problems to solve, to choices made, to what’s next.</p><p>I hope by the end, you’re as excited as I am about what this could mean for building apps and the people who use them.</p><p>Our journey starts by looking at what exists today. Think about the most <em>delightful</em> apps you’ve tried. What comes to mind? To me, it’s apps like Figma, Linear, and Notion. And if you asked why, I’d say three reasons: Optimistic Updates, Multiplayer, and Offline-Mode.</p><h2 id="optimistic-updates">Optimistic Updates</h2><p>Once you’re in the flow of Figma or Notion, you rarely see a loading screen. This is because every change you make is applied instantly. It’s painful to do this well. You need a method for applying changes on the client and server. You need a queue to maintain order. You need undo. And the edge cases get daunting: if you have multiple changes waiting and the first one fails, what should happen? You need some way to cancel the dependents <sup>[<!-- -->2<!-- -->]</sup>.</p><p>Challenging to build but transformative once done. Interaction time changes how you use an application. Get fast enough, and your fingertips become your primary constraint. I think this is the key to unlocking flow. <sup>[<!-- -->3<!-- -->]</sup></p><h2 id="multiplayer">Multiplayer</h2><p>Speed itself is delightful, but it’s taken further with multiplayer. Every feature in Linear is collaborative by default. Assigned a task? All active sessions see your change. <sup>[<!-- -->4<!-- -->]</sup></p><p>There’s a pattern to multiplayer too. Developers think it’s a nice-to-have. But then some company builds it, and we’re stunned by the result. Figma did this for Sketch, and Notion did this for Evernote.</p><p>But most apps aren’t multiplayer. This isn’t because we’ve hit a sweet spot of text editors, task managers, and design tools. Multiplayer is just too hard to build. <sup>[<!-- -->5<!-- -->]</sup></p><h2 id="offline-mode">Offline-Mode</h2><p>Finally, delightful apps work offline. Some not <em>completely</em> offline, but they all handle spotty connections.</p><p>And offline-mode has the same pattern as multiplayer. It feels like a nice-to-have, but build it and you leap past your competitors. Why? Two reasons:</p><p>First, though internet connectivity is abundant, there’s a tail end. The subway, the airplane, the spotty cafe. Seems minor, but eliminating the tail-end can be transformative. When we know that an app will work no <em>matter what,</em> we use it differently. <sup>[<!-- -->6<!-- -->]</sup></p><p>Second, your app becomes <em>even faster</em>. Offline-mode amortizes read latency. For example, the first time you load Linear, it may take time to fetch everything. But then, subsequent loads feel instant; you’ll just see offline data first. <sup>[<!-- -->7<!-- -->]</sup></p><p>Combine these features, and you get an application available everywhere, as fast as your fingertips, and multiplayer by default.</p><p>Compared to the average web app, this is a difference in kind. Linear is so fast that you fall into flow states closing tasks. No one would say this about Jira. Notion’s offline-mode lets you store every note there. People don’t do this in Dropbox Paper. In Figma, two designers can collaborate on the same file. This was unheard of in the days of Sketch.</p><p>These applications let you work in new ways. They become tools that you can master. And I think this is how most apps will be in the future. We prefer the experience, and the Notions of the world teach us to expect it.</p><p>As an industry, we’ll need to find new abstractions that make building apps like this easy. I think it’s worth the effort to find them now.</p><p>So let’s try to discover this abstraction. What works today? Linear and Notion exist; how do they do it?</p><p>Thankfully there’s lots <sup>[<!-- -->8<!-- -->]</sup> of <sup>[<!-- -->9<!-- -->]</sup> interesting <sup>[<!-- -->10<!-- -->]</sup> work <sup>[<!-- -->11<!-- -->]</sup> that explains their architecture. Here’s a simplified view:</p><p><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE4NjcxMTQwOC0yN2RhMTEzYy0yY2E5LTRmZjAtOWNhZS05ODUwMzVlOWFmM2YucG5n" alt="The architecture"/></p></span></p><p>Let’s go bottom-up:</p><h2 id="a-db">A. DB</h2><p>On the backend we start with a database. Users want a live view of some subset of data. We can keep live views by either polling the database or leveraging a write-ahead log. <sup>[<!-- -->12<!-- -->]</sup></p><h2 id="b-permissions">B. Permissions</h2><p>The DB gives us a set of results, but we can’t just send this data up to users. We need to filter for what they are allowed to see.</p><p>So we build a permission layer. This starts simple. But as an app gets complex, permissions resemble their own language. Facebook had the best design I’ve seen. Here’s how it looked:</p><pre><code><span>function</span><span> </span><span>IDenyIfArchived</span><span>(</span><span>_user</span><span>, </span><span>task</span><span>) {</span>
<span>  </span><span>if</span><span> (</span><span>task</span><span>.</span><span>isArchived</span><span>) {</span>
<span>    </span><span>return</span><span> </span><span>deny</span><span>();</span>
<span>  }</span>
<span>  </span><span>return</span><span> </span><span>allow</span><span>();</span>
<span>}</span>
<span>// ...</span>
<span>{</span>
<span>  </span><span>&#34;task&#34;</span><span>: {</span>
<span>    read: [</span>
<span>      </span><span>IAllowIfTeamUser</span><span>,</span>
<span>    ],</span>
<span>    write: [</span>
<span>      </span><span>IDenyIfArchived</span><span>,</span>
<span>      </span><span>IAllowIfTeamUser</span><span>,</span>
<span>    ],</span>
<span>  }</span>
<span>}</span></code></pre><p>Developers write a set of IAllow or IDeny rules per model. Since all reads and writes go through this layer, engineers can be sure that their queries are safe. <sup>[<!-- -->13<!-- -->]</sup></p><h2 id="c-sockets">C. Sockets</h2><p>Now we reach the websocket layer. Clients subscribe to different topics. For Notion, it could be “documents and comments.” Or for Linear it could be “team, task, and users.”</p><p>Backend developers hand-craft live queries to satisfy these topics. There’s a balancing act to play here. The more complicated the query, the harder it is to keep a live view. <sup>[<!-- -->14<!-- -->]</sup> So we need to simplify queries as much as possible. Most often, this means we skip pagination and overfetch. <sup>[<!-- -->15<!-- -->]</sup></p><h2 id="d-in-memory-store">D. In-Memory Store</h2><p>Now we move to the frontend. Sockets funnel all this data into an in-memory store:</p><pre><code><span>const</span><span> </span><span>Store</span><span> </span><span>=</span><span> {</span>
<span>  teams: {</span>
<span>    teamIdA: {</span><span>...</span><span>}</span>
<span>  },</span>
<span>  users: {</span>
<span>    userIdA: {</span><span>...</span><span>}</span>
<span>  },</span>
<span>  tasks: {</span>
<span>    taskIdA: {</span><span>...</span><span>, teamId: </span><span>&#34;teamIdA&#34;</span><span>, ownerId: [</span><span>&#34;userIdA&#34;</span><span>]</span>
<span>  }</span>
<span>}</span></code></pre><p>We do this so all screens have consistent information. For example, if a user changes their profile picture, we should see updates everywhere. The best way to do that is to keep data normalized and in one place.</p><h2 id="e-indexeddb">E. IndexedDB</h2><p>But we need our app to work offline too. So we back our store with durable storage. For web this is IndexedDB. When our app loads, we hydrate the store with what was saved before. This is what enables offline-mode and amortizes read latency.</p><h2 id="f-screens">F. Screens</h2><p>Okay, time to paint screens. Right now we have a store with normalized data. But normalized data isn’t directly useful for rendering. What a screen wants is a graph. Say we show a “team tasks” page in Linear; we’d want team info, all the tasks for the team, and the owner for the task:</p><p><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE4NjcxMTUwNS1iMzY4YWI2YS1lOWVmLTRhOTctOTM2Mi04MTI2YzFhOTZjMGQucG5n" alt="Screens want graphs"/></p><p>We can build this with a javascript function:</p><pre><code><span>function</span><span> </span><span>dataForTaskPage</span><span>(</span><span>store</span><span>, </span><span>teamId</span><span>) {</span>
<span>  </span><span>return</span><span> {</span>
<span>    </span><span>...</span><span>store</span><span>.</span><span>teams</span><span>[</span><span>teamId</span><span>],</span>
<span>    tasks: </span><span>store</span><span>.tasksForTeam</span><span>(</span><span>teamId</span><span>)</span><span>.map</span><span>((</span><span>task</span><span>) </span><span>=&gt;</span><span> {</span>
<span>      </span><span>return</span><span> { </span><span>...</span><span>task</span><span>, owner: </span><span>store</span><span>.</span><span>users</span><span>[</span><span>task</span><span>.</span><span>ownerId</span><span>] };</span>
<span>    }),</span>
<span>  };</span>
<span>}</span></code></pre><p>If this causes too many re-renders, we can memoize it or use some kind of dirty-checking. With that, we have a page a user can interact with.</p><h2 id="g-mutations">G. Mutations</h2><p>Then users make changes. We want those changes to feel instant, so we support optimistic updates. This is how it usually looks:</p><p><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE4NjcxMTU4OS1mODc5MjQ5OS0zYjM2LTQ4YTctYTM3OS0xZjlhOTAwMzYxMGUucG5n" alt="Mutation system"/></p><p>Whatever mutation we make, our local store and server need to understand them. This way we can apply changes immediately.</p><p>To do this well, we need to support undo. We need to maintain order, and we need to be able to cancel dependent mutations. Hard stuff, but Linear, Figma, and Notion all go through the schlep.</p><p>Once this is done, we’ve got an application from the future on our hands.</p><p>Oof. Lots of custom work. Could these apps have used an existing tool instead?</p><h2 id="firebase">Firebase</h2><p>Firebase comes closest. It has optimistic updates out of the box. It supports offline mode and is reactive by default. But, I think Firebase has two show-stoppers: relations and permissions.</p><h3 id="relations">Relations</h3><p>The biggest show-stopper is Firebase’s query strength. You’re limited to document lookups. When Firebase was built, this was a great tradeoff to make. It’s simpler to support optimistic updates and offline mode for document stores. But for sophisticated apps, you <em>need</em> relations.</p><p>Figma, Notion, and Linear all have relations. Notion has a recursive model where blocks reference other blocks. Linear has users, tasks, and teams. Figma has documents, objects and properties.</p><p>If you need relations, document stores explode in complexity. You end up having to implement your own joins with hand-tuned caches. Another schlep.</p><h3 id="permissions">Permissions</h3><p>The second show-stopper is Firebase’s permission system. <sup>[<!-- -->16<!-- -->]</sup> Firebase Realtime has a language that looks like a long boolean expression:</p><pre><code><span>auth</span><span> </span><span>!=</span><span> </span><span>null</span><span> </span><span>&amp;&amp;</span><span> (</span><span>!</span><span>data</span><span>.exists</span><span>() </span><span>||</span><span> </span><span>data</span><span>.child</span><span>(</span><span>&#34;users&#34;</span><span>)</span><span>.hasChild</span><span>(</span><span>auth</span><span>.</span><span>id</span><span>));</span></code></pre><p>This gets unmaintainable fast <sup>[<!-- -->17<!-- -->]</sup>. It improved in Firestore — there’s now a function-like abstraction:</p><pre><code><span>function</span><span> </span><span>isAuthorOrAdmin</span><span>(</span><span>userId</span><span>, </span><span>article</span><span>) {</span>
<span>  </span><span>let</span><span> </span><span>isAuthor</span><span> </span><span>=</span><span> </span><span>article</span><span>.</span><span>author</span><span> </span><span>==</span><span> </span><span>userId</span><span>;</span>
<span>  </span><span>let</span><span> </span><span>isAdmin</span><span> </span><span>=</span><span> </span><span>exists</span><span>(</span><span>/</span><span>databases</span><span>/</span><span>$</span><span>(</span><span>database</span><span>)</span><span>/</span><span>documents</span><span>/</span><span>admins</span><span>/</span><span>$</span><span>(</span><span>userId</span><span>));</span>
<span>  </span><span>return</span><span> </span><span>isAuthor</span><span> </span><span>||</span><span> </span><span>isAdmin</span><span>;</span>
<span>}</span></code></pre><p>But again, this wasn’t built for complex use cases. There’s no way to write an early return statement for example. If we’re aiming for Linear, Figma, or Notion, we need a system that can scale to complex rules.</p><h2 id="supabase-hasura">Supabase, Hasura</h2><p>So Firebase won’t work. What about Supabase or Hasura?</p><p>They solve Firebase’s greatest show-stopper: relations. Both Supabase and Hasura support relations.</p><p>But they do this at the expense of a local abstraction. Neither support offline-mode or optimistic updates. Multiplayer is still crude. You write basic subscriptions and manage the client yourself.</p><p>Supabase and Hasura also don’t have a powerful permission system. They use Postgres’s Row-Level Security. Permissions are written as policies. But this won’t work for sophisticated apps. You’ll need to write so many policies, that it’ll be impossible to reason about. It’ll get slow too — the planner will struggle with them.</p><p>So Firebase has a great local abstraction, but no support for relations. Supabase and Hasura support relations, but have a poor local abstraction. Put this in a table and you have an interesting column to think about:</p><p><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE4NjcxMTY4MS0yOGIyMjRjYy00NmRmLTQzN2EtYjM3Yi02OTUyMGRhNDBhZTMucG5n" alt="Matrix"/></p><p>What if a tool could support relations and a local abstraction? You could write any query that a Figma, Linear, or Notion would need. And you could handle all of the hard work they do locally: optimistic updates, multiplayer, and offline-mode.</p><p>Add support for complex permissions, and you have a tool to build applications from the future!</p><p>A daunting column to satisfy. But again, if we look at how Figma, Linear, and Notion work, we find clues. Squint, and their architecture looks like a database!</p><p><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE4NjcxMTc4MS1lZGU1MzNlMy00NWU2LTRjNzItYmRlYS03YTc0YTlmYzdiMWUucG5n" alt="Generalization"/></p><p>Again, screens need consistent data. Previously, we wrote functions and got data from the store. Remember <code>dataForTasksPage</code>?</p><pre><code><span>function</span><span> </span><span>dataForTaskPage</span><span>(</span><span>store</span><span>, </span><span>teamId</span><span>) {</span>
<span>  </span><span>return</span><span> {</span>
<span>    </span><span>...</span><span>store</span><span>.</span><span>teams</span><span>[</span><span>teamId</span><span>],</span>
<span>    tasks: </span><span>store</span><span>.tasksForTeam</span><span>(</span><span>teamId</span><span>)</span><span>.map</span><span>((</span><span>task</span><span>) </span><span>=&gt;</span><span> {</span>
<span>      </span><span>return</span><span> { </span><span>...</span><span>task</span><span>, owner: </span><span>store</span><span>.</span><span>users</span><span>[</span><span>task</span><span>.</span><span>ownerId</span><span>] };</span>
<span>    }),</span>
<span>  };</span>
<span>}</span></code></pre><p>Well, this is just a query! If we had a local database — let’s call it Local DB — that understood some GraphQL-looking language, we could instead declare:</p><pre><code><span>teams {</span>
<span>  ...</span>
<span>  tasks: {</span>
<span>    ...</span>
<span>    owner: {</span>
<span>      ...</span>
<span>    }</span>
<span>  }</span>
<span>}</span></code></pre><p>And voila, we’d have data for our screens.</p><p>Next, we backed our data into IndexedDB. Well, databases are good at caching. Our Local DB could back itself up in IndexedDB!</p><p>And the mutation system? If our Local DB and Backend DB spoke the same language, both could understand and apply the same mutations. Local DB can handle undo/redo, and with that we have optimistic updates out of the box.</p><p>What about sockets? Databases handle replication. So what if we made the client a special node? The Local DB already knows the queries to satisfy. So it can talk to the backend and get the data it needs.</p><p>On the backend, what if we had the same kind of permission system that Facebook had? We’d have a fully expressive language that could scale to complex rules.</p><p>Make the Backend DB handle live queries, and we have all the pieces for our missing column!</p><p>Let’s dive into our Local DB first. This is what’s going to handle queries, caching, and talking to our server. If we do this right, we inform everything else.</p><h2 id="requirements">Requirements</h2><p>The minimum our Local DB needs is support for relations. Whatever we do, we should be able to express “Give me team info, related tasks, and the owner for each task”.</p><p>We should also support recursive queries. For Notion, we need to say “Give me a block and expand all children recursively”.</p><p>Our Local DB should also be easy to use. Firebase is famous for this. You can start working with a single index.html file. API calls are consistent and simple. You don’t need to specify a schema to get started. We should be just as easy to use. <sup>[<!-- -->18<!-- -->]</sup></p><p>And our Local DB should be light. At least on the client. Yes we can cache the download. But I don’t think developers will take you up on an offer that doubles their bundle.</p><p>Finally, our Local DB should be simple. Every feature in our Local DB needs to be supported by our multiplayer backend. This won’t ship if our spec is too large.</p><p>A SQL-based tool is closest at hand. I enjoyed looking at <a href="https://github.com/jlongster/absurd-sql" target="_blank">absurd-sql</a>. This uses sql.js (SQLLite compiled to webassembly) and persists state into IndexedDB.</p><p>SQL is battle tested and supports a wide array of features. But if you take the constraints we set out, you’ll see it’s a bad bet.</p><h2 id="schema-and-size">Schema and Size</h2><p>My investigation began with two light issues.</p><p>First, SQL has a schema. Schema is useful, but it make things less easy than Firebase. You can hack immediately in Firebase, but there’s upfront work with a schema. <sup>[<!-- -->19<!-- -->]</sup></p><p>Second, there’s size. sql.js is about 400KBs gzipped. Yes this can be cached, but I just don’t see most apps adopting a library that adds this overhead.</p><p>Both reservations have reasonable counters. We could infer a schema on our user’s behalf, or write a lighter implementation of SQL. With problems like this we could have moved forward.</p><h2 id="language">Language</h2><p>But SQL as a language turns out to be a show-stopper. SQL isn’t simple or easy. It’s a tough combination of lots of features, with little of it being useful for the frontend.</p><p>Consider the most common query for UIs: Fetch nested relations. Remember our <code>dataForTaskPage</code>?</p><pre><code><span>function</span><span> </span><span>dataForTaskPage</span><span>(</span><span>store</span><span>, </span><span>teamId</span><span>) {</span>
<span>  </span><span>return</span><span> {</span>
<span>    </span><span>...</span><span>store</span><span>.</span><span>teams</span><span>[</span><span>teamId</span><span>],</span>
<span>    tasks: </span><span>store</span><span>.tasksForTeam</span><span>(</span><span>teamId</span><span>)</span><span>.map</span><span>((</span><span>task</span><span>) </span><span>=&gt;</span><span> {</span>
<span>      </span><span>return</span><span> { </span><span>...</span><span>task</span><span>, owner: </span><span>store</span><span>.</span><span>users</span><span>[</span><span>task</span><span>.</span><span>ownerId</span><span>] };</span>
<span>    }),</span>
<span>  };</span>
<span>}</span></code></pre><p>This is one SQL query for it:</p><pre><code><span>SELECT</span>
<span>  teams.</span><span>*</span><span>, tasks.</span><span>*</span><span>, </span><span>owner</span><span>.</span><span>*</span>
<span>FROM</span><span> teams</span>
<span>JOIN</span><span> tasks </span><span>ON</span><span> tasks.team_id </span><span>=</span><span> teams.id</span>
<span>JOIN</span><span> users </span><span>as</span><span> </span><span>owner</span><span> </span><span>ON</span><span> tasks.owner_id </span><span>=</span><span> </span><span>owner</span><span>.id</span>
<span>WHERE</span><span> teams.id </span><span>=</span><span> ?</span></code></pre><p>And it works. But it’s inconvenient. Our query will return an exploded list of rows. Each row represents an owner, with tasks and teams duplicated. But what we actually wanted was a nested structure. Something like:</p><pre><code><span>{</span>
<span>  teams: [{id: </span><span>2</span><span>, name: </span><span>&#34;Awesome Team&#34;</span><span>, tasks: [{</span><span>...</span><span>, owner: {}}, </span><span>...</span><span>]}, </span><span>...</span><span>]</span>
<span>}</span></code></pre><p>To make this work, we could use a <code>GROUP BY</code> with <code>json_group_array</code> and <code>json_object</code>. Like this:</p><pre><code><span>SELECT</span>
<span>  teams.</span><span>*</span><span>,</span>
<span>  json_group_array(</span>
<span>    json_object(</span>
<span>      </span><span>&#39;id&#39;</span><span>, tasks.id,</span>
<span>      </span><span>&#39;title&#39;</span><span>, tasks.title,</span>
<span>      </span><span>&#39;owner&#39;</span><span>, json_object(</span><span>&#39;id&#39;</span><span>, </span><span>owner</span><span>.id, </span><span>&#39;name&#39;</span><span>, </span><span>owner</span><span>.</span><span>name</span><span>))</span>
<span>  ) </span><span>as</span><span> tasks</span>
<span>FROM</span><span> teams</span>
<span>JOIN</span><span> tasks </span><span>ON</span><span> tasks.team_id </span><span>=</span><span> teams.id</span>
<span>JOIN</span><span> users </span><span>as</span><span> </span><span>owner</span><span> </span><span>ON</span><span> </span><span>owner</span><span>.id </span><span>=</span><span> tasks.owner_id</span>
<span>GROUP BY</span><span> teams.id</span>
<span>WHERE</span><span> teams.id </span><span>=</span><span> ?</span></code></pre><p>
  <em>Try it <a href="https://sqlime.org/#gist:3e02f01fdc8a0d131a5a07ac7b4a6d70" target="_blank">here</a>.</em>
</p><p>But you can already see we’re going off the beaten path. What if we had subscribers for each task? We’d need at least two more joins. One more <code>GROUP BY</code>. Likely we’d want a subquery. And if we wanted to support the Notion case? We’d want a <code>WITH RECURSIVE</code> clause.</p><p>Now we’re in a tough spot. The frontend’s common case is SQL’s advanced case. We shouldn’t need advanced features for common cases.</p><p>Plus, what about all the SQL features we’d rarely use in the frontend? The spec for the core language is over 1700 pages long <sup>[<!-- -->20<!-- -->]</sup>. We’d have to implement reactivity for all 1700 pages. I don’t think the schlep is worth it.</p><p>SQL is out. Let’s start with a different question then: How do we make frontend queries easy?</p><p>The most common query is our “fetch nested relations”. For Linear it’s “team, with related tasks and their owners”. Or for Notion, we want “blocks, with child blocks expanded”. Or for Figma, “documents with their comments, layers, and properties”.</p><p>See a pattern here? They’re all graphs:</p><p><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE4NjcxMTg3Ny0zMzM2ZTE5ZC04OWY0LTRhMzUtODY0Yy0yNjhhZDIxNzdlYzIucG5n" alt="Graphs everywhere"/></p><p>And this pointed us to a question: would a graph database make frontend queries easy?</p><p>So we wrote a graph database to find out. We chose Triple Stores, one of the simplest kinds of graph databases. If you haven’t tried one, here’s a quick intuition:</p><p>Imagine we’re trying to express a graph with data structures. What do we need?</p><p>Well, we need to be able to express a node with attributes. To say:</p><pre><code><span>User with id 1 has name &#34;Joe&#34;</span>
<span>Team with id 2 has name &#34;Awesome Team&#34;</span>
<span>Task with id 3 has title &#34;Code&#34;</span></code></pre><p>These sentences translate to lists:</p><pre><code><span>[</span><span>1</span><span>, </span><span>&#34;name&#34;</span><span>, </span><span>&#34;Joe&#34;</span><span>]</span>
<span>[</span><span>2</span><span>, </span><span>&#34;name&#34;</span><span>, </span><span>&#34;Awesome Team&#34;</span><span>]</span>
<span>[</span><span>3</span><span>, </span><span>&#34;title&#34;</span><span>, </span><span>&#34;Code&#34;</span><span>]</span></code></pre><p>Then we want a way to describe references. To say:</p><pre><code><span>Task with id 3 has an &#34;owner&#34; reference to User with id 1</span>
<span>Team with id 2 has a &#34;task&#34; reference to Task with id 3</span></code></pre><p>Well...these translate to lists just as well:</p><pre><code><span>[</span><span>3</span><span>, </span><span>&#34;owner&#34;</span><span>, </span><span>1</span><span>]</span>
<span>[</span><span>2</span><span>, </span><span>&#34;tasks&#34;</span><span>, </span><span>3</span><span>]</span></code></pre><p>Put these lists in a table, and you have a triple store! <em>Triple</em> is the name of the list we’ve been writing:</p><pre><code><span>[</span><span>1</span><span>, </span><span>&#34;name&#34;</span><span>, </span><span>&#34;Joe&#34;</span><span>]</span></code></pre><p>The first item is always an <code>id</code>, the second the <code>attribute</code>, and the third, the <code>value</code>. Turns out triples are all we need to express a graph. Here’s a more fleshed out example:</p><p><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE4NjcxMjAyMS05NTI5MTM5Ni1iOTg4LTQyNTMtYmVmMC04MGE3ZWJkYWJiNjcucG5n" alt="Triple Store → Graph"/></p><p>And once you’ve expressed a graph, you can traverse it. Triple stores have interesting query languages. Here’s Datalog:</p><pre><code><span>(</span><span>pull</span><span> db &#39;[* {</span><span>:team/task</span><span> [* {</span><span>:task/owner</span><span> [*]}]}] team-id)</span></code></pre><p>With this we’ve replaced <code>dataForTasksPage</code>!</p><p>Triple stores felt like our rubicon moment. An entire architecture unravelled from our choice.</p><h2 id="schema-and-size">Schema and Size</h2><p>My investigation kicked off with two happy surprises.</p><p>First, I always assumed that if we wanted relations, we would need a schema. But it turns out triple stores don’t need one. <sup>[<!-- -->21<!-- -->]</sup> I think a schema is helpful. But to compete with Firebase, it’s a win that we can make this optional.</p><p>Then there’s size. Triple stores are notoriously light. Datascript is one of the most battle-tested triple stores. It’s transpiled from Clojurescript and carries the extra weight of Clojure. But even then, the bundle size is about 90KB.</p><h2 id="simple">Simple</h2><p>But the killer feature is how simple triple stores are. <strong>You can write a roughly complete implementation in less than a hundred lines of Javascript</strong> <sup>[<!-- -->22<!-- -->]</sup>.</p><p>The query planner uses 3 main indexes <sup>[<!-- -->23<!-- -->]</sup>. Datalog — the query language I mentioned — is so simple that there isn’t a spec <sup>[<!-- -->24<!-- -->]</sup>. The mutation system boils down two primitives <sup>[<!-- -->25<!-- -->]</sup>.</p><p>Even with the 100 LOC version, you can express a query like “Give me all the owners for the tasks where this person is a subscriber” <sup>[<!-- -->26<!-- -->]</sup></p><h2 id="8020-for-multiplayer">80/20 for Multiplayer</h2><p>Turns out triple stores are a great answer for muliplayer too. Once we make our Local DB collaborative, we’ll need to support conflicts. What should happen when two people change something at the same time?</p><p>Notion, Figma, and Linear all use last-write-wins. This means that whichever change reaches the server last wins.</p><p>This can work well, but we need to be creative about it. Imagine if two of us changed the same Figma Layer. One of us changed the font size, and the other changed the background color. If we’re creative about how we save things, there shouldn’t be a conflict in the first place.</p><p>How does Figma this? They store their properties in a special way. They store them as...triples! <sup>[<!-- -->27<!-- -->]</sup></p><pre><code><span>[</span><span>1</span><span>, </span><span>&#34;fontSize&#34;</span><span>, </span><span>20</span><span>]</span>
<span>[</span><span>1</span><span>, </span><span>&#34;backgroundColor&#34;</span><span>, </span><span>&#34;blue&#34;</span><span>]</span></code></pre><p>These triples say that the Layer with id 1 has a fontSize 20 and backgroundColor blue. Since they are different rows, there’s no conflict.</p><p>And voila, we have the same kind of conflict-resolution as Figma. <sup>[<!-- -->28<!-- -->]</sup></p><h2 id="but-speed-and-scale">But Speed and Scale?</h2><p>At this point, you may wonder: this is great and all, but what about speed and scale?</p><p>Well, the core technology is old <sup>[<!-- -->29<!-- -->]</sup>. Datalog and triple stores have been around for decades. This also means that people have built reactive implementations <sup>[<!-- -->30<!-- -->]</sup>.</p><p>But what makes me most optimistic about the answer here, is that Facebook runs on a graph database. Tao is facebook’s in-house data store. If you look at Tao, it’s not so different from a triple store! <sup>[<!-- -->31<!-- -->]</sup></p><h2 id="easy">Easy?</h2><p>This is getting exciting. But what about ease of use? This is how the “Give me all the owners for the tasks where this person is a subscriber” query looks in Datalog:</p><pre><code><span>{</span><span>:find</span><span> ?owner,</span>
<span>  </span><span>:where</span><span> [[?task </span><span>:task/owner</span><span> ?owner]</span>
<span>          [?task </span><span>:task/subscriber</span><span> sub-id]}</span></code></pre><p>Datalog as a language is elegant and simple. But it’s not easy the same way Firebase is. You need to learn a logic-based language. Then you get back triples. But in the UI you want typed objects.</p><p>This would be a deal-breaker. But here’s where Datalog’s strength comes in. <strong>It’s so small that we can just keep it as our base layer, and write a friendlier language on top.</strong></p><h2 id="instaql">InstaQL</h2><p>That’s how InstaQL was born. If you look at what’s intuitive for the UI, I think GraphQL syntax comes closest:</p><pre><code><span>teams {</span>
<span>  ...</span>
<span>  tasks: {</span>
<span>    ...</span>
<span>    owner: {</span>
<span>      ...</span>
<span>    }</span>
<span>  }</span>
<span>}</span></code></pre><p>You just declare what you want; the shape of the query looks like the result.</p><p>InstaQL was heavily inspired by GraphQL. It’s a similar-looking language and produces Datalog. Here’s how queries look:</p><pre><code><span>{</span>
<span>  teams: {</span>
<span>    $: {where: {id: </span><span>1</span><span>}},</span>
<span>    tasks: {owner: {}</span>
<span>  },</span>
<span>}</span></code></pre><p>You can see the first departure from GraphQL: InstaQL is written with plain javascript objects. This lets us avoid a build step; after all Firebase doesn’t need one. And there’s another win: if the language itself is written with objects and arrays, engineers can write functions that manipulate them.</p><p>The second departure is in the mutation system. In GraphQL you define mutations as functions in the backend. This is a problem because then you can’t do optimistic updates out of the box. Without talking to the server, there’s no way to know what a mutation does.</p><p>In InstaQL, mutations look like this:</p><pre><code><span>transact</span><span>([</span>
<span>  </span><span>tx</span><span>.</span><span>tasks</span><span>[</span><span>taskId</span><span>]</span>
<span>    </span><span>.update</span><span>({title: </span><span>&#34;New Task&#34;</span><span>})</span>
<span>    </span><span>.link</span><span>({owner: </span><span>ownerId</span><span>}}</span>
<span>])</span></code></pre><p>These mutations produce triple store assertions and retractions. So our Local DB can apply them, and we have optimistic updates out of the box again. <sup>[<!-- -->32<!-- -->]</sup></p><p>So we wrote a triple store, and Instant was born. Here’s roughly how it looks:</p><p><img src="https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE4NjcxMjExMi03ZTkwNDBlNC0zMDA5LTRjOGUtODM3YS0wN2RhOTNhNjc2OTUucG5n" alt="Today"/></p><p>We have a client-side implementation of InstaQL. You can write queries like:</p><pre><code><span>{</span>
<span>  teams: {</span>
<span>    $: {where: {id: </span><span>1</span><span>}},</span>
<span>    tasks: {owner: {}}</span>
<span>  },</span>
<span>}</span></code></pre><p>And get back objects:</p><pre><code><span>{</span>
<span>  teams: [{</span>
<span>    id: </span><span>1</span><span>,</span>
<span>    name: </span><span>&#39;Awesome Team&#39;</span><span>,</span>
<span>    tasks: [{id: </span><span>3</span><span>, title: </span><span>&#39;Code&#39;</span><span>, owner: [{id: </span><span>1</span><span>, name: </span><span>&#39;Joe&#39;</span><span>}]</span>
<span>  }]</span>
<span>}</span></code></pre><p>These are live queries that talk to the Local DB — a triple store. The Local DB then handles
optimistic updates and syncs with the backend server, sockets and all <sup>[<!-- -->33<!-- -->]</sup>.</p><p>When our early users wrote their first relational query, I saw delight in their eyes. And boy was that thrilling.</p><p>Right now we support email-only auth. But we don’t have permission system yet. Either data is anonymous and can be written by everyone, or users are logged in and can only read and write their own data.</p><p>This is limiting, but it’s in a state where you can play. Coming soon, we’re going to build an FB-like permission system. This way you can write expressive permissions like this:</p><pre><code><span>function</span><span> </span><span>IDenyIfArchived</span><span>(</span><span>_user</span><span>, </span><span>task</span><span>) {</span>
<span>  </span><span>if</span><span> (</span><span>task</span><span>.</span><span>isArchived</span><span>) {</span>
<span>    </span><span>return</span><span> </span><span>deny</span><span>();</span>
<span>  }</span>
<span>  </span><span>return</span><span> </span><span>allow</span><span>();</span>
<span>}</span>
<span>// ...</span>
<span>{</span>
<span>  </span><span>&#34;task&#34;</span><span>: {</span>
<span>    read: [</span>
<span>      </span><span>IAllowIfTeamUser</span><span>,</span>
<span>    ],</span>
<span>    write: [</span>
<span>      </span><span>IDenyIfArchived</span><span>,</span>
<span>      </span><span>IAllowIfTeamUser</span><span>,</span>
<span>    ],</span>
<span>  }</span>
<span>}</span></code></pre><p>Once we have permissions, we’ll be able to make sync more sophisticated. Right now Instant fetches the world. Shortly, Instant will fetch just the queries you need. This will start out simple, but will evolve towards incremental view maintenance.</p><p>It was obvious to me that the browser has been missing a database. With Instant, I see that a graph database is one of the best bets we have to make delightful apps easy to build.</p><p>If you’re excited about this stuff, <a href="https://instantdb.com" target="_blank">sign up and give us a try</a>. Joe and I will reach out to your personally for feedback.</p><p><em>Thanks Joe Averbukh, Alex Reichert, Mark Shlick, Slava Akhmechet, Nicole Garcia Fischer, Daniel Woelfel, Jake Teton‑Landis, Rudi Chen, Dan Vingo, Dennis Heihoff for reviewing drafts of this essay.</em></p></div></div></div></div>
  </body>
</html>
