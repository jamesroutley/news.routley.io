<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/xixixao/8e363dbd3663b6729cd5b6d74dbbf9d4">Original</a>
    <h1>From Languages to Language Sets</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-languages-md">
      
      <div id="file-languages-md-readme" tabindex="0" role="region" aria-label="languages.md content, created on 10:06PM on November 13, 2021.">
    <article itemprop="text">
<p dir="auto">After working with a lot of languages, writing my own, this is currently what I consider the most useful classification of programming languages, into 4 levels:</p>
<ul dir="auto">
<li>4: Interpreted, dynamically typed: JavaScript, Python, PHP</li>
<li>3: Interpreted, statically typed: Hack, Flow, TypeScript, mypy</li>
<li>2: Compiled with automatic memory management (statically typed): Go, Java (Kotlin), C#, Haskell, Objective-C, Swift</li>
<li>1: Compiled with manual memory management (statically typed): Rust, C, C++</li>
</ul>
<p dir="auto">There is a 0th level, assembly, but it’s not a practical choice for most programmers today.</p>
<p dir="auto">Now every language trades off “ease of use” with “performance”. On this hierarchy the higher numbered, “higher level”, languages are easier to use, while the lower numbered, “lower level”, languages are more performant.</p>
<p dir="auto">I postulate that for most programming, the “business logic” kind of programming, we want to use a language that sits right in the middle of that hierarchy. Looking at the languages listed that’s no revelation. One language could combine the 2nd and 3rd level though. A language that can be interpreted during development for fast iteration cycle, but compiled for better performance for deployment. There isn’t such a language popular today though.</p>
<p dir="auto">Now let’s address level 4. Big players sit at this level, perhaps the most popular languages by headcount of their programmers. The problem with a lack of static typing is that it’s hard to work on such code in groups and at scale. Every successful business started with those languages eventually rewrites their codebase to use one of the “lower level” languages because big codebases written by many people are hard to maintain and modify without the support of a static type-checker. They are still great languages for solo, small projects, especially if the code can be easily automatically tested.</p>
<p dir="auto">Now for level 1, Rust has done an amazing job bringing level 1 to a wider audience of programmers. By both being modern, and safe, it allows many more people to write code that requires best possible performance and resource utilization. In such scenarios Rust should be a clear choice. But coding in Rust is not easy, not in the way coding in JavaScript or Python is. The same solution, much more performant, might require many more lines of code.</p>
<p dir="auto">And so we come to the levels 2 and 3, where most professional programmers today spend their time. The tradeoff between them is clear: The interpreted languages have a faster development cycle because they don’t require the programmer to wait for a compilation step. But this comes at the cost of performance, as the interpreter in general cannot be as good at optimizing and executing the code as the compiler.</p>
<p dir="auto">The interesting thing is that these languages are almost identical in their expressive power. The only gap between them is that interpreted languages can include “eval” and dynamic meta-programming (modification of program structure at runtime). These features are usually shied away from in production code though, and are more helpful during development, especially for testing.</p>
<p dir="auto">The discussion here implies that companies need to use at least 3, often 4 different languages in their codebases. This means 4 different toolsets to maintain. Trainings to provide. Experts to hire. And usually disjoint sets of employee programmers who cannot easily jump from one language to the other.</p>
<p dir="auto">Clearly there will never be a single language that all programmers use. We need to take advantage of the tradeoffs laid out in this hierarchy. But what we could do is to build a language set, which would smooth out the transition between these levels.</p>
<p dir="auto">As the basis of this set I propose to use Rust. It is a solid low level foundation to build our language set on. It has modern, well thought out language tooling (including things like its syntax).</p>
<p dir="auto">There will be 3 languages in this set, besides Rust we want a level 2/3 hybrid and level 4 language.</p>
<p dir="auto">Let’s look at an example to make this concrete. First a program in Rust:</p>
<div dir="auto"><pre><span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> rect1 = <span>Rectangle</span> <span>{</span><span>width</span><span>:</span> <span>30</span><span>,</span> <span>height</span><span>:</span> <span>50</span><span>}</span><span>;</span>
    <span>println</span><span>!</span><span>(</span>“<span>The</span> area is <span>{</span><span>}</span><span>.</span>”<span>,</span> area<span>(</span><span>&amp;</span>rect1<span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>struct</span> <span>Rectangle</span> <span>{</span>
    <span>width</span><span>:</span> <span>u32</span><span>,</span>
    <span>height</span><span>:</span> <span>u32</span><span>,</span>
<span>}</span>

<span>fn</span> <span>area</span><span>(</span><span>rectangle</span><span>:</span> <span>&amp;</span><span>Rectangle</span><span>)</span> -&gt; <span>u32</span> <span>{</span>
    rectangle<span>.</span><span>width</span> <span>*</span> rectangle<span>.</span><span>height</span>
<span>}</span></pre></div>
<p dir="auto">Now a program in RustGC, our level 2/3 hybrid:</p>
<div dir="auto"><pre><span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> rect1 = <span>Rectangle</span> <span>{</span> <span>width</span><span>:</span> <span>30</span><span>,</span> <span>height</span><span>:</span> <span>50</span> <span>}</span><span>;</span>
    <span>println</span><span>!</span><span>(</span>“<span>The</span> area is <span>{</span><span>}</span><span>.</span>”<span>,</span> area<span>(</span>rect1<span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>struct</span> <span>Rectangle</span> <span>{</span>
    <span>width</span><span>:</span> <span>int</span><span>,</span>
    <span>height</span><span>:</span> <span>int</span><span>,</span>
<span>}</span>

<span>fn</span> <span>area</span><span>(</span><span>rectangle</span><span>:</span> <span>Rectangle</span><span>)</span> <span>{</span>
    rectangle<span>.</span><span>width</span> <span>*</span> rectangle<span>.</span><span>height</span>
<span>}</span></pre></div>
<p dir="auto">And now a program in RustScript, our level 4 language:</p>
<div dir="auto"><pre><span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> rect1 = <span>{</span> width<span>:</span> <span>30</span><span>,</span> height<span>:</span> <span>50</span> <span>}</span><span>;</span>
    <span>println</span><span>!</span><span>(</span>“<span>The</span> area is <span>{</span><span>}</span><span>.</span>”<span>,</span> area<span>(</span>rect1<span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>fn</span> <span>area</span><span>(</span><span>rectangle</span><span>)</span> <span>{</span>
    rectangle<span>.</span><span>width</span> <span>*</span> rectangle<span>.</span><span>height</span>
<span>}</span></pre></div>
<p dir="auto">RustScript can be used for heavy prototyping, especially for complicated stateful programming (interactive UIs). RustGC is our workhorse, with great async support, decent performance thanks to a modern garbage collector, but without the mental overhead of fighting the borrow checker. Finally we reach for Rust any time we need maximum performance and 0-cost abstractions.</p>
<p dir="auto">RustGC comes with a VM that allows instantenous save -&gt; execute dev cycle, but is compiled for deployment to a binary similar to the one that Rust would compile to, but with an accompanying GC runtime.</p>
<p dir="auto">The best part is that all three languages share pretty much the same syntax, and they are built so that calling from higher level to lower level variant is effortless. This gives us the ability to use the rich Rust ecosystem from a level 2/3 or even level 4 language.</p>
<p dir="auto">More examples. UI <a href="https://github.com/ahfarmer/calculator/blob/master/src/component/App.js">component</a> in RustScript:</p>
<div dir="auto"><pre><span>fn</span> <span>app</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> <span>(</span>state<span>,</span> setState<span>)</span> = <span>useState</span><span>(</span><span>{</span>
    total<span>:</span> <span>None</span><span>,</span>
    next<span>:</span> <span>None</span><span>,</span>
    operation<span>:</span> <span>None</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>

  <span>let</span> handleClick = |buttonName| =&gt; <span>{</span>
    <span>setState</span><span>(</span>|state| =&gt; <span>calculate</span><span>(</span>state<span>,</span> buttonName<span>)</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>let</span> value = state<span>.</span><span>next</span><span>.</span><span>or</span><span>(</span>state<span>.</span><span>total</span><span>)</span><span>.</span><span>unwrap_or</span><span>(</span><span>&#34;0&#34;</span><span>)</span><span>;</span>
  &lt;div className=&#34;component-<span>app</span>&#34;&gt;
    &lt;<span>Display</span> value=<span>{</span>value<span>}</span> /&gt;
    &lt;<span>ButtonPanel</span> clickHandler=<span>{</span>handleClick<span>}</span> /&gt;
  &lt;/div&gt;
<span>}</span></pre></div>
<p dir="auto">Async <a href="https://hacklang.org/" rel="nofollow">example</a> in RustGC:</p>
<div dir="auto"><pre><span>async</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> user_ids = <span>vec</span><span>!</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>
  <span>let</span> user_names = user_ids<span>.</span><span>iter</span><span>(</span><span>)</span><span>.</span><span>map_async</span><span>(</span>
    <span>async</span> |id| =&gt; <span>fetch_user_name</span><span>(</span>id<span>)</span><span>.</span><span>await</span><span>,</span>
  <span>)</span><span>.</span><span>await</span><span>;</span>
  <span>println</span><span>!</span><span>(</span>user_names<span>.</span>join<span>(</span><span>&#34;, &#34;</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>async</span> <span>fn</span> <span>fetch_user_name</span><span>(</span>_<span>:</span> <span>int</span><span>)</span> -&gt; <span>Future</span><span>&lt;</span><span>string</span><span>&gt;</span> <span>{</span>
  <span>// This could be a database request.</span>
  <span>&#34;&#34;</span>
<span>}</span></pre></div>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
