<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jcs.org/2023/07/12/api">Original</a>
    <h1>Advice for Operating a Public-Facing API</h1>
    
    <div id="readability-page-1" class="page"><article>
					<header>
						
						<p>
							posted on wednesday, july 12th, 2023
						</p>
					</header>
					<p>I&#39;ve been operating
						<a href="https://pushover.net/">Pushover</a>&#39;s
						public-facing
						<a href="https://pushover.net/api">API</a>
						for
						<a href="https://blog.pushover.net/posts/2022/3/ten">over a decade</a>
						now and I thought I&#39;d pass on some advice for those creating a new API.</p>
					<!-- SNIP -->
					<p>Pushover&#39;s API might be unusual in that it is used by a wide range of devices
						(embedded IoT things, legacy servers, security cameras, etc.) and HTTP
						libraries, rather than mostly being accessed from JavaScript in the latest web
						browsers.
						It also doesn&#39;t process sensitive financial information, so the advice given
						here may not be applicable to something operating like Stripe&#39;s API.</p>
					
					<h2 id="host-the-api-on-its-own-hostname">Host the API on its own hostname</h2>
					<p>Serve your API at <code>api.example.com</code>, never at <code>example.com/api</code>.
						As your API&#39;s usage grows, it will expand beyond your website/dashboard server
						and need to move to a separate server or many separate servers.
						You&#39;ll want to be able to move things around by just pointing its IP somewhere
						else rather than trying to proxy things from your dashboard server.</p>
					<p>Your API may also have more relaxed security restrictions in terms of TLS
						versions and ciphers accepted that you don&#39;t want to relax on your dashboard
						website that handles sensitive information.
						Having your API at its own hostname means it can have its own TLS certificate
						and TLS restrictions.</p>
					<p>Also, when it comes to
						<a href="#stay-on-top-of-failures">blocking bots</a>
						and poorly-written clients, a user should still be able to reach your main
						website for support even if their IP is blocked from reaching your API server.</p>
					<h2 id="dont-be-too-liberal-in-what-you-accept">Don&#39;t be too liberal in what you accept</h2>
					<p>Accepting a slightly non-conforming API request today from someone&#39;s
						ESP8266 buried in a forest might mean you&#39;ll have to keep accepting those same
						non-conforming requests being made years later, often at the cost of having to
						<a href="https://arstechnica.com/gadgets/2022/10/windows-95-went-the-extra-mile-to-ensure-compatibility-of-simcity-other-games/">implement workarounds</a>
						in your web framework or server code as it gets upgraded.</p>
					<p>A lot of users will hack something together until it works with your API and
						when it suddenly stops working months or years down the road, you&#39;re going to
						have to deal with the fallout.
						Rather than bending over backwards
						<a href="https://en.wikipedia.org/wiki/Robustness_principle">trying to support poorly written code</a>,
						don&#39;t let their bad code function properly in the first place so it doesn&#39;t get
						deployed.</p>
					<p>Though you don&#39;t have to be pedantic about it.
						Pushover&#39;s API has a message size limitation of 1,024 characters.
						If the message parameter is larger than that, I could reject the request because
						it&#39;s not correct, but then the user&#39;s message is lost and they may not have any
						error handling.
						In this case, I truncate the message to 1,024 characters and process it anyway
						(assuming it wasn&#39;t so large that it hit the web server&#39;s request message size
						limit).
						The user still receives <em>something</em>, and if they care that it&#39;s truncated, they
						can investigate why.</p>
					<h2 id="avoid-oauth-if-you-can">Avoid OAuth if you can</h2>
					<p>It&#39;s a confusing protocol that brings its
						<a href="https://portswigger.net/web-security/oauth">own security problems</a>
						and it introduces a lot of overhead for your users to get up and running.
						With OAuth your API can&#39;t be used from a
						<a href="https://pushover.net/splash#integration">simple curl request</a>
						but has to be a custom multi-step process pulling in a whole OAuth library.</p>
					<p>Use static API tokens if you can, but make it easy to rotate them.
						If possible, avoid using an authentication mechanism that requires custom HTTP
						headers (including basic auth) because some esoteric devices and plugins don&#39;t
						support them.
						Some don&#39;t even support HTTP <code>POST</code> properly and will only be able to put form
						parameters in the URL query string (though you still need to insist on requiring
						a proper <code>POST</code> method, don&#39;t be an animal).</p>
					<p>Remember, not everyone is going to be sending HTTP requests from the ideal code
						you would have written, they&#39;re using what they have available.</p>
					<h2 id="log-a-unique-id-with-every-request">Log a unique id with every request</h2>
					<p>This is probably done by your web framework, but if not, generate a unique ID or
						UUID with every request, return it to the user in the message body somewhere,
						log it, and ask for it on your support form.</p>
					<p>This will make your life much easier in the future when you need to track down
						requests in log files and correlate them to a user&#39;s support request.
						Often times the user won&#39;t know the IP they&#39;re sending API requests from or
						their parameters aren&#39;t getting parsed properly so you can&#39;t search your logs
						for their API token.</p>
					<p>Side note: you probably don&#39;t need a fancy centralized logging setup to capture
						every detail of every HTTP request.
						Filter out sensitive <code>POST</code> parameters (Pushover redacts <code>title</code> and <code>message</code>),
						log
						<a href="https://github.com/roidrage/lograge">one line per request</a> including the
						request&#39;s UUID to flat files, then rotate and compress the log daily and delete
						old ones according to your retention policy.
						In 99.9% of Pushover support requests where I needed to consult server logs,
						having the date/time, sending IP, method, timing information, and sanitized
						<code>POST</code> parameters logged was enough to resolve the issue for the user.</p>
					<pre><code>[2023-07-12 16:30:24] [62dd8009-3174-4b86-8078-18330a1e7b0e] [1.2.3.4] method=POST \
 path=/1/messages.json format=json controller=Api::One::MessagesController \
 action=create status=200 duration=66.14 view=0.1 db=14.73 \
 params={&#34;token&#34;=&gt;&#34;apn9u395cgrxxxxxxxxxxxxxxxxxxx&#34;, \
 &#34;user&#34;=&gt;&#34;uc65prcvfxxxxxxxxxxxxxxxxxxxxx&#34;, &#34;device&#34;=&gt;&#34;iphone&#34;, &#34;sound&#34;=&gt;&#34;carl&#34;, \
 &#34;message&#34;=&gt;&#34;[FILTERED]&#34;, &#34;monospace&#34;=&gt;&#34;1&#34;} cf_ray=7e5c6320196e0252-ORD \
 time0=0.05 time1=3.15 time2=4.78 time3=4.81 timebuild=16.65 timesave=59.43 \
 message_ids=m749182415778658654 queued=1 server=hippocampus
</code></pre>
					<h2 id="be-descriptive-in-your-error-responses">Be descriptive in your error responses</h2>
					<p>Assume a human will read them, even if it&#39;s unlikely.
						You might be surprised how error messages
						<a href="https://old.reddit.com/r/PBSOD/top/?sort=top&amp;t=all">propagate</a>
						but at least give the error a fighting chance to be seen.</p>
					<p>When applicable, have your API errors include URLs to documentation to avoid
						support requests rather than just responding with a minimal &#34;invalid xyz
						parameter&#34; that the user has to decode.</p>
					<h2 id="use-prefixed-tokens">Use prefixed tokens</h2>
					<p>This took me years to stumble upon, but use a short prefix for each type of
						random ID you create.
						Instead of generating an API token of <code>Mk7vuCg9eptiV8qid4mn</code>, make it
						<code>appMk7vuCg9eptiV8qid4mn</code>.
						Instead of a user key of <code>zo2iD3x3J9</code>, use <code>userzo2iD3x3J9</code>.
						Pushover uses <code>a</code> for API tokens, <code>u</code> for user keys, <code>g</code> for group keys, <code>s</code> for
						subscribed user keys, etc.
						This makes it easier for users to keep multiple keys/tokens straight when they
						all look like gibberish and it makes it possible to automate helpful API error
						responses like &#34;your token parameter has a user key instead of an API token&#34;.</p>
					<h2 id="stay-on-top-of-failures">Stay on top of failures</h2>
					<p>Reportedly <a href="https://www.statista.com/statistics/420400/spam-email-traffic-share-annual/">half of all e-mail processed is
							spam</a>.
						That means a lot of money, servers, and administrative overhead is wasted just
						scaling up resources to deal with junk that no one wants.
						If you don&#39;t stay on top of error responses from your API, they will
						accumulate and you&#39;ll end up wasting a lot of your own money constantly serving
						bad requests.</p>
					<p>Obviously you&#39;ll want instant alerts of <code>5xx</code> errors from your API when your
						database falls over, but here I&#39;m talking about the normal <code>4xx</code> client errors
						generated in response to missing required parameters, expired tokens, and other
						conditions that you don&#39;t normally need to worry about.</p>
					<p>Pushover&#39;s API generates about 1.5 million <code>4xx</code> errors every day and each one
						increments an expiring counter in its database for the sending IP (for IPv6,
						rounded off to the <code>/64</code>).
						When that count reaches a certain limit in a short amount of time, the IP is
						banned for one hour and subsequent requests short-circuit all of the API logic
						and are responded to with a descriptive error message.</p>
					<p>When an IP block can be mapped back to a user by way of an API token in the
						request, that user is sent an automated e-mail explaining why they were blocked
						and that they need to shut down whatever is continuing to send the failed
						requests.</p>
					<p>If that error count keeps increasing past another threshold, the IP is
						blocked harder by adding it to a
						<a href="https://www.openbsd.org/faq/pf/">pf</a>
						table, blocking it on the IP level.
						After 1 hour, the block is automatically removed.
						If the IP gets blocked again in a short amount of time, it is blocked for 2
						hours, then 4, then 8, etc.
						However, avoid doing this type of IP-level block too early or you&#39;ll get
						inundated with generic &#34;I can&#39;t connect&#34; complaints.
						Let the requests fail on the HTTP level with proper error responses for as long
						as possible so they
						<a href="#be-descriptive-in-your-error-responses">get seen</a>.</p>
					<p>Something I learned long ago is that
						<a href="https://jcs.org/2010/04/11/properly_stopping_a_sip_flood">automated things can have a hard time dealing with failure</a>.
						Many people are also bad programmers and their method for dealing with &#34;my
						HTTP query didn&#39;t get a 200 response&#34; is to immediately hammer the API server
						again until it does (or it crashes, causing it to be restarted over and over).
						So a user&#39;s script sends you normal API traffic all month until it gets to the
						final week, their API token reaches its monthly limit, and now the script is in
						a loop hitting your API with dozens of requests per second.</p>
					<p>My solution for this in Pushover&#39;s API was to add a step in between the soft and
						hard block.
						When a failure count is nearing the hard block limit, Pushover&#39;s API will
						respond with a <code>200</code> status code, but with a descriptive message in the body
						explaining that the message was ignored but the API is responding that way to
						avoid a catastrophe.
						The user&#39;s messages weren&#39;t going to go through anyway because they reached
						their API token usage limit, so responding with a <code>200</code> shouldn&#39;t cause too many
						problems and the descriptive error might possibly be seen by someone once they
						check why their messages aren&#39;t being processed.
						If this fails to slow down the client, they&#39;ll eventually run into the hard
						block limit and get cut off, but it was worth a try.</p>
				</article></div>
  </body>
</html>
