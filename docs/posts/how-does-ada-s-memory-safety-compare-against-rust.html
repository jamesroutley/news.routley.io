<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ajxs.me/blog/How_Does_Adas_Memory_Safety_Compare_Against_Rust.html">Original</a>
    <h1>How does Ada&#39;s memory safety compare against Rust?</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>
	This article takes a look at the most common memory-related errors, 
	and compares how well Rust and Ada 
	<u><em>prevent</em> you from making them in the first place</u>.
</p>

<p><span>TL;DR:</span> 
	Rust is better at outright preventing common memory-related errors,
	however Ada&#39;s avoidance of dynamic memory allocation 
	and support for formal proof of correctness 
	help you avoid many of the common errors altogether.
</p>



<h2 id="foreword">Foreword <a href="#foreword">#</a></h2>

<p>
	The Rust programming language has 
	<a href="https://github.blog/developer-skills/programming-languages-and-frameworks/why-rust-is-the-most-admired-language-among-developers/" target="_blank">exploded in popularity</a>
	in the last few years,
	consistently ranking as one of the 
	<a href="https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/" target="_blank">most loved languages</a>
	in Stack Overflow&#39;s
	<a href="https://survey.stackoverflow.co/2024/technology#admired-and-desired" target="_blank">Developer Survey</a>.
	Designed by Mozilla to be <i>memory-safe</i>,
	it&#39;s steadily gaining ground as a viable alternative to languages like C++.
	This focus on safety has invited comparisons with Ada;
	An older, but battle-tested language designed for safety-critical industries.
	Despite all the things they have in common, 
	a bitter 
	<a href="https://www.reddit.com/r/rust/comments/pm4k1f/rust_vs_ada_how_do_they_compare/" target="_blank">rivalry</a>
	has grown between the Ada and Rust communities.
	For years I&#39;ve been defending Ada online from a motley crew of 
	<a href="https://news.ycombinator.com/item?id=20935953" target="_blank">angry Rustaceans</a>,
	<a href="https://www.fulltextarchive.com/book/7625/#p203" target="_blank">crusty old greybeards</a>,
	and 
	<a href="https://news.ycombinator.com/item?id=20932467" target="_blank">bitter old haters</a>.
	Most of whom either haven&#39;t used it,
	or haven&#39;t used it since Reagan was in office.
	I&#39;ve been critical of Rust&#39;s design in the past,
	but have I actually given Rust a fair go?
	When it comes to <em>memory safety</em>, 
	how do the two languages <em>really</em> stack up?
	Does Rust offer us anything new that Ada doesn&#39;t?
	Let&#39;s find out!
</p>

<p>
	This article assumes you&#39;re already familiar with the basics of Rust.
	If you&#39;re not, the best place to start is 
	<a href="https://www.rust-lang.org/learn" target="_blank">Learn Rust</a>,
	particularly the
	<a href="https://doc.rust-lang.org/book/" target="_blank">Rust Book</a>.
	For an introduction to Ada,
	check out AdaCore&#39;s
	<a href="https://learn.adacore.com/courses/intro-to-ada/" target="_blank">Introduction to Ada</a>.
</p>

<p>
	Before we begin,
	it&#39;s worth noting that
	<u><em>you can do a lot in Ada without ever allocating heap memory</em></u>,
	or even using pointers at all.
	In fact, most guides on Ada programming recommend avoiding pointers altogether.
	Language constructs such as in/out parameter modes, 
	creating dynamically sized arrays at runtime,
	and the ability to return variable length arrays from functions 
	address many of the scenarios where pointers would be necessary in other languages.
	Keep this in mind when reading:
	<u><em>You can avoid many of these situations altogether in Ada</em></u>.
</p>

<p>
	All the examples in this article are tested on an x86-64 machine running Debian 12,
	with glibc 2.36;
	Compiled with GCC 12.2.0,
	GNAT native 14.2.1,
	and rustc 1.80.1.
</p>

<h2 id="common_Memory_errors">Common Memory Errors <a href="#common_Memory_errors">#</a></h2>

<h3 id="memory_leaks">Memory Leaks <a href="#memory_leaks">#</a></h3>
<p>
	<a href="https://cwe.mitre.org/data/definitions/401.html" target="_blank"><i>CWE-401: Memory Leak</i></a>
	refers to a program failing to release the memory that it&#39;s allocated.
	Left unchecked, a leaky program could drain all your system&#39;s memory.
	The most common cause of 
	<a href="https://devblogs.microsoft.com/oldnewthing/20180228-00/?p=98125" target="_blank">memory leaks</a> 
	in C is mismatched <code>malloc()</code>, and <code>free()</code> statements.
</p>

<p>
	While not impossible<sup><a href="#footnote_1" id="footnote_1_link">1</a></sup>, 
	Rust does actually make leaking memory pretty difficult.
	Variables in Rust are automatically deallocated when their <i>owner</i> goes out of scope.
	Most of the time this means a variable will be deallocated at the end of the scope it&#39;s declared in.
</p>
<p>
	For
	<a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank"><i>reference counted</i></a>
	smart pointers, like <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>,
	Rust will automatically deallocate the memory they point to when the reference count reaches zero. 
</p>

<p>
	In Ada, pointers are called <i>Access Types</i>.
	Like in C, they <i>point</i> at a memory location;
	However <em>unlike</em> C, they&#39;re <em>not</em> an address.
	This means you can&#39;t assign an address to an access variable, 
	or perform arithmetic on it.
</p>

<p>
	In Ada, dynamically allocated memory needs to be deallocated <em>manually</em> with the generic
	<code>Ada.Unchecked_Deallocation</code> procedure.
	With <i>unchecked</i> 
	referring to checking whether the variable being deallocated is still in use.
</p>
<p>
	While Ada&#39;s 
	<a href="https://learn.adacore.com/courses/advanced-ada/parts/resource_management/controlled_types.html" target="_blank"><i>controlled types</i></a>
	do support implementing RAII-like functionality,
	under normal circumstances forgetting to manually deallocate heap memory will cause it to leak.
</p>
<p> 
	The only scenario where Ada <em>will</em> automatically<sup><a href="#footnote_2" id="footnote_2_link">2</a></sup> 
	deallocate memory is when the user specifies a static size for an access type&#39;s <i>storage pool</i>
	using the <code>Storage_Size</code> aspect.
	This controls exactly how many bytes of heap memory can be allocated for variables of a particular type.
	If this is specified, the compiler automatically allocates all the required memory up front<sup><a href="#footnote_3" id="footnote_3_link">3</a></sup>,
	and automatically <em>deallocates</em> it when the type goes out of scope.
	If this pool is exhausted, the program will raise a <code>Storage_Error</code> exception.
</p>

<div><pre><span></span><span>procedure</span> <span>Access_Type_With_Explicit_Pool_Size</span> <span>is</span>
   <span>--  This sets aside a total of 128 bytes for the pool of Int_Access.</span>
   <span>--  Allocating more than 128 bytes will raise a Storage_Error exception.</span>
   <span>type</span> <span>Int_Access</span> <span>is</span> <span>access</span> <span>Integer</span>
   <span>with</span> <span>Storage_Size</span> <span>=&gt;</span> <span>128</span><span>;</span>
<span>begin</span>
   <span>for</span> <span>I</span> <span>in</span> <span>1</span> <span>..</span> <span>16</span> <span>loop</span>
      <span>declare</span>
         <span>Q</span> <span>:</span> <span>constant</span> <span>Int_Access</span> <span>:=</span> <span>new</span> <span>Integer</span><span>&#39;(</span><span>I</span><span>);</span>
      <span>begin</span>
         <span>Put_Line</span> <span>(</span><span>Q</span><span>.</span><span>all</span><span>&#39;</span><span>Image</span><span>);</span>
      <span>end</span><span>;</span>
   <span>end</span> <span>loop</span><span>;</span>
<span>end</span> <span>Access_Type_With_Explicit_Pool_Size</span><span>;</span>
</pre></div>
<p>
	Running Valgrind on the example above shows that the memory is indeed deallocated automatically.
</p>

<h3 id="buffer_overflow">Buffer Overflow <a href="#buffer_overflow">#</a></h3>
<p>
	<a href="https://cwe.mitre.org/data/definitions/119.html" target="_blank"><i>CWE-119: Buffer Overflow</i></a>
	refers to reading or writing past the end of an array, 
	and into adjacent memory.
	Buffer overflows are probably responsible for more 
	<a href="https://github.com/johnjhacking/Buffer-Overflow-Guide" target="_blank">security vulnerabilities</a>
	than any other kind of bug,
	and are a common technique for 
	<a href="https://cturt.github.io/ps4.html" target="_blank">jailbreaking</a>
	<a href="https://github.com/singi/oob_timestamp" target="_blank">hardware</a>.
	The infamous
	<a href="https://en.wikipedia.org/wiki/Morris_worm" target="_blank">Morris Worm</a>,
	and <a href="https://en.wikipedia.org/wiki/Heartbleed" target="_blank">Heartbleed</a>
	vulnerabilities both relied on buffer overflows.
</p>
<div><pre><span></span><span>void</span><span> </span><span>buffer_overflow</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>char</span><span> </span><span>email_address</span><span>[</span><span>10</span><span>];</span>

<span>  </span><span>printf</span><span>(</span><span>&#34;Please enter your email address:</span><span>\n</span><span>&#34;</span><span>);</span>
<span>  </span><span>// Modern versions of GCC will spew a litany of warnings about using &#39;gets&#39;.</span>
<span>  </span><span>gets</span><span>(</span><span>email_address</span><span>);</span>
<span>  </span><span>printf</span><span>(</span><span>&#34;Sending welcome email to %s</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>email_address</span><span>);</span>
<span>}</span>

<span>// $ gcc -o buffer_overflow buffer_overflow.c</span>
<span>// $ ./buffer_overflow</span>
<span>// $ Please enter your email address:</span>
<span>// $ anthony@this_will_overwrite_the_function&#39;s_return_address_on_the_stack.com</span>
<span>// $ Segmentation fault</span>
</pre></div>
<p>
	One of the few things that Rust and Ada agree on is
	<a href="https://shnatsel.medium.com/how-to-avoid-bounds-checks-in-rust-without-unsafe-f65e618b4c1e" target="_blank">runtime bounds checking</a>.
	Attempting to access an out-of-bounds array index will result in a &#39;panic&#39;.
</p>
<div><pre><span></span><span>fn</span><span> </span><span>overflow_this_buffer</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>buffer</span><span> </span><span>=</span><span> </span><span>[</span><span>0</span><span>;</span><span> </span><span>10</span><span>];</span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>raw_input</span><span> </span><span>=</span><span> </span><span>String</span><span>::</span><span>new</span><span>();</span>
<span>    </span><span>println!</span><span>(</span><span>&#34;What array index should be cleared? &#34;</span><span>);</span>
<span>    </span><span>io</span><span>::</span><span>stdin</span><span>()</span>
<span>        </span><span>.</span><span>read_line</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>raw_input</span><span>)</span>
<span>        </span><span>.</span><span>expect</span><span>(</span><span>&#34;Failed to read line&#34;</span><span>);</span>
<span>    </span><span>let</span><span> </span><span>index</span><span>:</span><span> </span><span>usize</span><span> </span><span>=</span><span> </span><span>raw_input</span>
<span>        </span><span>.</span><span>trim</span><span>()</span>
<span>        </span><span>.</span><span>parse</span><span>()</span>
<span>        </span><span>.</span><span>expect</span><span>(</span><span>&#34;Please enter a valid integer&#34;</span><span>);</span>

<span>    </span><span>buffer</span><span>[</span><span>index</span><span>]</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>}</span>

<span>// $ cargo run</span>
<span>// $ What array index should be cleared?</span>
<span>// $ 12</span>
<span>// $ thread &#39;main&#39; panicked at buffer_overflow.rs:14:5:</span>
<span>// $ index out of bounds: the len is 10 but the index is 12</span>
<span>// $ note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span>
<span>// $ ...</span>
</pre></div>

<p>
	Similar to Rust, 
	attempting to access an array index outside of its valid range will raise a
	<code>Constraint_Error</code> exception at runtime,
	which can be handled programmatically.
	This is the same type of exception raised in the case of a scalar range constraint violation,
	such as an integer overflow.
</p>
<div><pre><span></span><span>procedure</span> <span>Buffer_Overflow</span> <span>is</span>
   <span>Email_Address</span> <span>:</span> <span>String</span> <span>(</span><span>1</span> <span>..</span> <span>10</span><span>);</span>
<span>begin</span>
   <span>Put_Line</span> <span>(</span><span>&#34;Please enter your email address:&#34;</span><span>);</span>
   <span>Email_Address</span> <span>:=</span> <span>Get_Line</span><span>;</span>
   <span>Put_Line</span> <span>(</span><span>&#34;Sending welcome email to &#34;</span> <span>&amp;</span> <span>Email_Address</span><span>);</span>
<span>exception</span>
   <span>when</span> <span>Constraint_Error</span> <span>=&gt;</span>
      <span>Put_Line</span> <span>(</span><span>&#34;Buffer overflowed!&#34;</span><span>);</span>
<span>end</span> <span>Buffer_Overflow</span><span>;</span>

<span>--  $ alr run</span>
<span>--  $ Please enter your email address:</span>
<span>--  $ anthony@this_will_overflow_the_buffer.com</span>
<span>--  $ Buffer overflowed!</span>
</pre></div>

<h4>SPARK</h4>
<p>
	SPARK is a subset of Ada which can be 
	<a href="https://en.wikipedia.org/wiki/Formal_verification" target="_blank">formally verified</a>.
	Meaning that it&#39;s possible to verify the absence of runtime errors in your code using formal methods.
</p>

<p>
	All SPARK code is valid Ada,
	but to determine whether the Ada code is valid SPARK I&#39;m using
	<a href="https://docs.adacore.com/hilite-docs/html/ug/usage.html" target="_blank"><i>GNATprove</i></a>.
	GNATprove is a component of AdaCore&#39;s <i>GNAT</i> 
	Ada compiler used to formally verify the correctness of SPARK code.
	If you&#39;re using <i><a href="https://alire.ada.dev" target="_blank">Alire</a></i>,
	you can add GNATprove to your project by running <code>alr with gnatprove</code>.
</p>

<p>
	Let&#39;s see if we can reimplement the previous Rust example in SPARK,
	and prove that a buffer overflow can&#39;t occur.
</p>
<div><pre><span></span><span>procedure</span> <span>Overflow_This_Buffer</span>
   <span>with</span> <span>SPARK_Mode</span> <span>=&gt;</span> <span>On</span>
<span>is</span>
   <span>type</span> <span>Integer_Array</span> <span>is</span> <span>array</span> <span>(</span><span>Positive</span> <span>range</span> <span>&lt;&gt;)</span> <span>of</span> <span>Integer</span><span>;</span>
   <span>Int_Array</span> <span>:</span> <span>Integer_Array</span> <span>(</span><span>1</span> <span>..</span> <span>10</span><span>)</span> <span>:=</span> <span>[</span><span>others</span> <span>=&gt;</span> <span>1</span><span>];</span>
   <span>Index_To_Clear</span> <span>:</span> <span>Integer</span><span>;</span>
<span>begin</span>
   <span>Ada</span><span>.</span><span>Text_IO</span><span>.</span><span>Put</span> <span>(</span><span>&#34;What array index should be cleared? &#34;</span><span>);</span>
   <span>--  Read the new array size from stdin.</span>
   <span>Ada</span><span>.</span><span>Integer_Text_IO</span><span>.</span><span>Get</span> <span>(</span><span>Index_To_Clear</span><span>);</span>

   <span>Int_Array</span> <span>(</span><span>Index_To_Clear</span><span>)</span> <span>:=</span> <span>0</span><span>;</span>
<span>end</span> <span>Overflow_This_Buffer</span><span>;</span>
</pre></div>
<p>
	Attempting to prove the absence of runtime errors gives us the following warnings:
</p>

<div><pre><span></span>buffer_overflow.adb:162:26: medium: unexpected exception might be raised
  162 |      Ada.Integer_Text_IO.Get (Index_To_Clear);
      |      ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~

buffer_overflow.adb:164:18: medium: array index check might fail
  164 |      Int_Array (Index_To_Clear) := 0;
      |                 ^~~~~~~~~~~~~~
  reason for check: value must be a valid index into the array
  possible fix: postcondition of call at line 162 should mention Item 
  (for argument Index_To_Clear)
  162 |      Ada.Integer_Text_IO.Get (Index_To_Clear);
      |                         ^ here
</pre></div>
<p>
	The SPARK prover correctly notices that there&#39;s nothing stopping us
	from entering a value outside the array bounds. 
	It also points out that the <code>Get</code> 
	call we&#39;re using to read the integer from <code>stdin</code>
	can raise an <i>unexpected</i> <code>Constraint_Error</code>
	at runtime if you type in anything that can&#39;t be parsed as an integer.
	To keep this example simple, we&#39;ll ignore this warning and push on.
	We&#39;ll talk more about exceptions in SPARK 
	<a href="#use_after_free">later</a>
	in the article.
</p>
<p>
	If we wrap the <code>Get</code> call in a loop, 
	and <i>poll</i> the user continuously until we have a value within the array bounds,
	SPARK can actually prove that a buffer overflow can&#39;t occur.
	(Remember to initialise the <code>Index_To_Clear</code> 
	variable to something outside this range!)
</p>

<div><pre><span></span><span>procedure</span> <span>Overflow_This_Buffer</span>
   <span>with</span> <span>SPARK_Mode</span> <span>=&gt;</span> <span>On</span>
<span>is</span>
   <span>type</span> <span>Integer_Array</span> <span>is</span> <span>array</span> <span>(</span><span>Positive</span> <span>range</span> <span>&lt;&gt;)</span> <span>of</span> <span>Integer</span><span>;</span>
   <span>Int_Array</span> <span>:</span> <span>Integer_Array</span> <span>(</span><span>1</span> <span>..</span> <span>10</span><span>)</span> <span>:=</span> <span>[</span><span>others</span> <span>=&gt;</span> <span>1</span><span>];</span>
   <span>Index_To_Clear</span> <span>:</span> <span>Integer</span> <span>:=</span> <span>Int_Array</span><span>&#39;</span><span>First</span> <span>-</span> <span>1</span><span>;</span>
<span>begin</span>
   <span>while</span> <span>Index_To_Clear</span> <span>not</span> <span>in</span> <span>Int_Array</span><span>&#39;</span><span>Range</span> <span>loop</span>
      <span>Ada</span><span>.</span><span>Text_IO</span><span>.</span><span>Put</span> <span>(</span><span>&#34;What array index should be cleared? &#34;</span><span>);</span>
      <span>--  Read the new array size from stdin.</span>
      <span>Ada</span><span>.</span><span>Integer_Text_IO</span><span>.</span><span>Get</span> <span>(</span><span>Index_To_Clear</span><span>);</span>
   <span>end</span> <span>loop</span><span>;</span>

   <span>Int_Array</span> <span>(</span><span>Index_To_Clear</span><span>)</span> <span>:=</span> <span>0</span><span>;</span>
<span>end</span> <span>Overflow_This_Buffer</span><span>;</span>
</pre></div>

<h3 id="use_after_free">Use After Free <a href="#use_after_free">#</a></h3>

<p>
	<a href="https://cwe.mitre.org/data/definitions/416.html" target="_blank"><i>CWE-416: Use After Free</i></a>
	refers to 
	<a href="https://stackoverflow.com/a/14224977/5931673" target="_blank"><i>dereferencing</i></a>
	a pointer after the value it points to has been freed.
	The C standard specifies that doing so is 
	<a href="https://en.wikipedia.org/wiki/Undefined_behavior" target="_blank"><i>Undefined Behaviour</i></a>
	(ISO/IEC 9899:2018, Section J.2), 
	potentially leading to a variety of different stability and 
	<a href="https://www.youtube.com/watch?v=PKqMsaKGdlM" target="_blank">security issues</a>. 
	(ISO/IEC 9899:2018, Section 3.4.3).
</p>
<p>
	Most of the time this just results in unpredictable behaviour because the pointer 
	now points to memory reallocated to something else.
	But occasionally <i>use-after-free&#39;s</i>
	can be leveraged for <a href="https://en.wikipedia.org/wiki/BlueKeep" target="_blank">something more sinister</a>.
</p>
<p>
	Rust&#39;s borrow checker automatically prevents you from using a value after it&#39;s been freed.
	Calling <code>drop</code> to manually free a variable <i>moves</i> it,
	meaning that any attempt to use it afterwards will raise a compile-time error.
</p>

<div><pre><span></span><span>fn</span><span> </span><span>use_after_free</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>greeting</span><span> </span><span>=</span><span> </span><span>&#34;Hello, World!&#34;</span><span>.</span><span>to_string</span><span>();</span>
<span>    </span><span>drop</span><span>(</span><span>greeting</span><span>);</span>
<span>    </span><span>// This will trigger an error at compile-time, because the variable</span>
<span>    </span><span>// `something` was moved by the first call to `std::mem::drop`.</span>
<span>    </span><span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span><span> </span><span>greeting</span><span>);</span>
<span>}</span>
</pre></div>

<p>
	Nothing prevents you from writing Ada code that dereferences an access type after it&#39;s been freed;
	However any access dereference triggers a runtime check to ensure it&#39;s non-null.
	Unlike in C,
	freeing an access type in Ada automatically sets its value to <code>null</code>,
	and any subsequent attempt to dereference it will raise a 
	<code>Constraint_Error</code> exception,
	which can be caught and handled.
</p>

<div><pre><span></span><span>procedure</span> <span>Use_After_Free</span> <span>is</span>
   <span>type</span> <span>String_Access</span> <span>is</span> <span>access</span> <span>String</span><span>;</span>
   <span>Example_String</span> <span>:</span> <span>String_Access</span> <span>:=</span> <span>null</span><span>;</span>

   <span>--  The Ada.Unchecked_Deallocation package is a generic package, and</span>
   <span>--  needs to be instantiated for each type to be deallocated.</span>
   <span>procedure</span> <span>Free</span> <span>is</span> <span>new</span>
     <span>Ada</span><span>.</span><span>Unchecked_Deallocation</span> <span>(</span><span>String</span><span>,</span> <span>String_Access</span><span>);</span>
<span>begin</span>
   <span>Example_String</span> <span>:=</span> <span>new</span> <span>String</span><span>&#39;(</span><span>&#34;Hello, world!&#34;</span><span>);</span>
   <span>Free</span> <span>(</span><span>Example_String</span><span>);</span>

   <span>--  This will raise a Constraint_Error exception at runtime.</span>
   <span>Put_Line</span> <span>(</span><span>Example_String</span><span>.</span><span>all</span><span>);</span>
<span>exception</span>
   <span>when</span> <span>Constraint_Error</span> <span>=&gt;</span>
      <span>Put_Line</span> <span>(</span><span>&#34;Used after freed!&#34;</span><span>);</span>
<span>end</span> <span>Use_After_Free</span><span>;</span>
</pre></div>

<p>
	The GNAT Ada compiler allows you to 
	<a href="https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/building_executable_programs_with_gnat.html#run-time-checks" target="_blank">
		disable runtime checking</a>
	with the <code>-gnatp</code> compiler switch.
	In this case, dereferencing a null access type will result in the same kind of undefined behaviour you&#39;d get in C.
</p>

<p>
	Ada allows you to specify a <i>null-excluding</i> constraint on access types,
	This restricts assignment to only non-null values,
	and forbids any unchecked deallocation.
</p>

<div><pre><span></span><span>type</span> <span>Non_Null_String_Access</span> <span>is</span> <span>not</span> <span>null</span> <span>access</span> <span>String</span><span>;</span>
<span>--  Since this is a &#39;null-excluding&#39; access type, it must be initialised,</span>
<span>--  otherwise a Constraint_Error exception will occur immediately at runtime.</span>
<span>Example_String</span> <span>:</span> <span>Non_Null_String_Access</span> <span>:=</span> <span>new</span> <span>String</span><span>&#39;(</span><span>&#34;Hello, world!&#34;</span><span>);</span>
<span>--  This will raise a compile-time error. The compiler won&#39;t let us</span>
<span>--  create an instance of Ada.Unchecked_Deallocation for a</span>
<span>--  null-excluding access type.</span>
<span>procedure</span> <span>Free</span> <span>is</span>
  <span>new</span> <span>Ada</span><span>.</span><span>Unchecked_Deallocation</span> <span>(</span><span>String</span><span>,</span> <span>Non_Null_String_Access</span><span>);</span>
</pre></div>

<h4>SPARK</h4>
<p>
	GNATprove will detect the use-after-free error in the above code,
	and issue a warning<sup><a href="#footnote_4" id="footnote_4_link">4</a></sup>:
</p>

<div><pre><span></span><span>procedure</span> <span>Use_After_Free</span>
   <span>with</span> <span>SPARK_Mode</span> <span>=&gt;</span> <span>On</span>
<span>is</span>
   <span>type</span> <span>String_Access</span> <span>is</span> <span>access</span> <span>String</span><span>;</span>
   <span>Example_String</span> <span>:</span> <span>String_Access</span><span>;</span>

   <span>procedure</span> <span>Free</span> <span>is</span> <span>new</span> <span>Ada</span><span>.</span><span>Unchecked_Deallocation</span> <span>(</span><span>String</span><span>,</span> <span>String_Access</span><span>);</span>
<span>begin</span>
   <span>Example_String</span> <span>:=</span> <span>new</span> <span>String</span><span>&#39;(</span><span>&#34;Hello, world!&#34;</span><span>);</span>
   <span>Free</span> <span>(</span><span>Example_String</span><span>);</span>

   <span>--  This line will raise a warning during static analysis.</span>
   <span>Put_Line</span> <span>(</span><span>Example_String</span><span>.</span><span>all</span><span>);</span>
<span>end</span> <span>Use_After_Free</span><span>;</span>
</pre></div>
<div><pre><span></span>use_after_free.adb:13:32: medium: pointer dereference check might fail
  13  |      Put_Line (Example_String.all);
      |                ~~~~~~~~~~~~~~~^~~
</pre></div>

<p>
	Note the removal of the exception handling block.
	SPARK <em>does</em> technically allow run-time exception handling, 
	but only exceptions that are <em>explicitly</em> raised in the code.
	Exceptions in SPARK are
	<a href="https://docs.adacore.com/spark2014-docs/html/lrm/exceptions.html" target="_blank">complicated</a>:
	You <em>can</em> still explicitly raise exceptions with the <code>raise</code> statement,
	but to be valid SPARK, the flow analyser will need to prove that the statement raising the exception can never actually be reached;
	Making exceptions almost like a form of compile-time assertion.
	This means that our <code>Constraint_Error</code> exception handler is unreachable,
	and needs to be removed.
</p>

<h3 id="double_free">Double Free <a href="#double_free">#</a></h3>
<p>
	<a href="https://cwe.mitre.org/data/definitions/415.html" target="_blank"><i>CWE-415: Double Free</i></a>
	refers to freeing a heap allocated variable more than once.
	The C standard (as usual) specifies that doing so is <i>Undefined Behaviour</i> (ISO/IEC 9899:2018, Section J.2).
	Double frees can be exploited in
	<a href="https://book.hacktricks.xyz/binary-exploitation/libc-heap/double-free" target="_blank">various</a>
	<a href="https://heap-exploitation.dhavalkapil.com/attacks/double_free" target="_blank">ways</a>
	to cause all kinds of nonsense.
</p>
<p>
	On Linux,
	<a href="https://sourceware.org/glibc/wiki/MallocInternals" target="_blank">glibc</a>
	stores extra <i>metadata</i> about each allocated memory block right before the block&#39;s address,
	such as its size, and a <i>magic number</i> to identify it as a valid allocation.
	When you pass an address to <code>free</code>, 
	glibc uses this metadata to determine the amount of memory being freed.
	Freeing a small block of heap memory can place it in a <i>cache</i> of recently freed blocks,
	known as a <i>fast bin</i>.
	The next time you call <code>malloc</code> for a block of the same size,
	glibc will give you the recently deallocated block from the fast bin,
	rather than allocating new memory.
	This process is much quicker than allocating a new block, hence the <em>fast</em> in the name.
	Freeing the same address twice runs the risk of the same block being placed in the fast bin 
	<em>multiple times</em>.
	This could lead to multiple subsequent memory allocations pointing to the same address.
</p>
<p>
	<a href="https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/" target="_blank">This</a>
	article contains a great in-depth look at glibc&#39;s heap implementation.
</p>
<p>
	Rust&#39;s borrow checker effectively prevents you from freeing the same variable more than once.
	As mentioned <a href="#use_after_free">earlier</a>,
	calling <code>drop</code> to free a variable will <i>move</i> it out of scope forever.
</p>
<div><pre><span></span><span>fn</span><span> </span><span>double_free</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>something</span><span> </span><span>=</span><span> </span><span>&#34;Hello, World!&#34;</span><span>.</span><span>to_string</span><span>();</span>
<span>    </span><span>drop</span><span>(</span><span>something</span><span>);</span>
<span>    </span><span>// This will trigger an error at compile-time, because the variable</span>
<span>    </span><span>// `something` was moved by the first call to `std::mem::drop`.</span>
<span>    </span><span>drop</span><span>(</span><span>something</span><span>);</span>
<span>}</span>
</pre></div>
<p>
	According to
	<a href="https://www.adaic.org/resources/add_content/standards/05rm/html/RM-13-11-2.html" target="_blank">section 13.11.2</a>
	of the Ada Reference Manual, 
	freeing an access type with a <code>null</code> value has no effect,
	just like in C (ISO/IEC 9899:2018, Section 7.22.3.3).
	That&#39;s a relief!
	As mentioned earlier, freeing a pointer in Ada will automatically set its value to <code>null</code>,
	preventing most accidental double free errors from causing any serious issues.
</p>
<p>
	It&#39;s still possible to cause a double free in Ada by creating an alias to a pointer.
</p>
<div><pre><span></span><span>procedure</span> <span>Double_Free</span> <span>is</span>
   <span>type</span> <span>String_Access</span> <span>is</span> <span>access</span> <span>String</span><span>;</span>

   <span>Str_Acc</span>       <span>:</span> <span>String_Access</span><span>;</span>
   <span>Str_Acc_Alias</span> <span>:</span> <span>String_Access</span><span>;</span>

   <span>procedure</span> <span>Free</span> <span>is</span> <span>new</span> <span>Ada</span><span>.</span><span>Unchecked_Deallocation</span> <span>(</span><span>String</span><span>,</span> <span>String_Access</span><span>);</span>
<span>begin</span>
   <span>Str_Acc</span> <span>:=</span> <span>new</span> <span>String</span><span>&#39;(</span><span>&#34;Hello, world!&#34;</span><span>);</span>
   <span>Put_Line</span> <span>(</span><span>&#34;Pointer Address: &#34;</span> <span>&amp;</span> <span>Str_Acc</span><span>.</span><span>all</span><span>&#39;</span><span>Address</span><span>&#39;</span><span>Image</span><span>);</span>

   <span>Str_Acc_Alias</span> <span>:=</span> <span>Str_Acc</span><span>;</span>

   <span>Free</span> <span>(</span><span>Str_Acc</span><span>);</span>

   <span>Put_Line</span> <span>(</span><span>&#34;Pointer Alias Address: &#34;</span> <span>&amp;</span> <span>Str_Acc_Alias</span><span>.</span><span>all</span><span>&#39;</span><span>Address</span><span>&#39;</span><span>Image</span><span>);</span>
   <span>Free</span> <span>(</span><span>Str_Acc_Alias</span><span>);</span>
<span>exception</span>
   <span>when</span> <span>Program_Error</span> <span>=&gt;</span>
      <span>Put_Line</span> <span>(</span><span>&#34;Program Error!&#34;</span><span>);</span>
<span>end</span> <span>Double_Free</span><span>;</span>

<span>--  $ alr run</span>
<span>--  $ Pointer Address:  25715368</span>
<span>--  $ Pointer Alias Address:  25715368</span>
<span>--  $ free(): double free detected in tcache 2</span>
<span>--  $ Program Error!</span>
</pre></div>
<p>
	As you can see in the example above,
	actually freeing the same memory location twice<sup><a href="#footnote_5" id="footnote_5_link">5</a></sup> will raise a 
	<code>Program_Error</code> exception at runtime.
	The below example shows how you can corrupt the heap by double freeing a pointer in Ada.
	Again, Ada will raise a <code>Program_Error</code> exception when it gets the error signal from glibc,
	which can be handled at runtime.
</p>

<div><pre><span></span><span>procedure</span> <span>Double_Free</span> <span>is</span>
   <span>type</span> <span>String_Access</span> <span>is</span> <span>access</span> <span>String</span><span>;</span>
   <span>type</span> <span>String_Access_Array</span> <span>is</span> <span>array</span> <span>(</span><span>1</span> <span>..</span> <span>16</span><span>)</span> <span>of</span> <span>String_Access</span><span>;</span>

   <span>procedure</span> <span>Free</span> <span>is</span> <span>new</span> <span>Ada</span><span>.</span><span>Unchecked_Deallocation</span> <span>(</span><span>String</span><span>,</span> <span>String_Access</span><span>);</span>

   <span>Str_Acc_Array</span>   <span>:</span> <span>String_Access_Array</span><span>;</span>
   <span>Str_Acc_Array_2</span> <span>:</span> <span>String_Access_Array</span><span>;</span>

   <span>--  Create a pointer to alias one of the elements in the array.</span>
   <span>Str_Acc_Alias</span> <span>:</span> <span>String_Access</span><span>;</span>
<span>begin</span>
   <span>for</span> <span>I</span> <span>in</span> <span>Str_Acc_Array</span><span>&#39;</span><span>Range</span> <span>loop</span>
      <span>Str_Acc_Array</span> <span>(</span><span>I</span><span>)</span> <span>:=</span> <span>new</span> <span>String</span><span>&#39;(</span><span>&#34;Hello, world!&#34;</span><span>);</span>
   <span>end</span> <span>loop</span><span>;</span>

   <span>Str_Acc_Alias</span> <span>:=</span> <span>Str_Acc_Array</span> <span>(</span><span>8</span><span>);</span>

   <span>for</span> <span>I</span> <span>in</span> <span>Str_Acc_Array</span><span>&#39;</span><span>Range</span> <span>loop</span>
      <span>Free</span> <span>(</span><span>Str_Acc_Array</span> <span>(</span><span>I</span><span>));</span>
   <span>end</span> <span>loop</span><span>;</span>

   <span>--  Freeing the alias will add the same address to the fast bin twice,</span>
   <span>--  leading to a double free error.</span>
   <span>Free</span> <span>(</span><span>Str_Acc_Alias</span><span>);</span>

   <span>for</span> <span>I</span> <span>in</span> <span>Str_Acc_Array_2</span><span>&#39;</span><span>Range</span> <span>loop</span>
      <span>Str_Acc_Array_2</span> <span>(</span><span>I</span><span>)</span> <span>:=</span> <span>new</span> <span>String</span><span>&#39;(</span><span>&#34;Hello, again!&#34;</span><span>);</span>
   <span>end</span> <span>loop</span><span>;</span>

<span>exception</span>
   <span>when</span> <span>Program_Error</span> <span>=&gt;</span>
      <span>Put_Line</span> <span>(</span><span>&#34;Program Error!&#34;</span><span>);</span>
<span>end</span> <span>Double_Free</span><span>;</span>

<span>--  $ alr run</span>
<span>--  $ malloc(): unaligned fastbin chunk detected 3</span>
<span>--  $ Program Error!</span>
</pre></div>

<h4>SPARK</h4>
<p>
	Like Rust, SPARK has its own concept of 
	<a href="https://docs.adacore.com/spark2014-docs/html/ug/en/source/language_restrictions.html#memory-ownership-policy" target="_blank"><i>&#39;ownership&#39;</i></a>.
	Assignment between access objects creates a transfer of ownership, 
	with the source object losing permission to read or write to the underlying allocated memory.
</p>
<p>
	In this case, aliasing the string pointers in the examples above is not valid SPARK,
	preventing us from causing this particular double free error.
</p>
<div><pre><span></span>alr gnatprove
Phase 1 of 3: generation of data representation information ...
Phase 2 of 3: generation of Global contracts ...
Phase 3 of 3: flow analysis and proof ...

double_free.adb:14:13: error: &#34;Str_Acc&#34; is not readable
   14 |      Free (Str_Acc);
      |            ^~~~~~~
  object was moved at line 12 [E0010]
   12 |      Str_Acc_Alias := Str_Acc;
      |                       ^ here
  launch &#34;gnatprove --explain=E0010&#34; for more information
</pre></div>
<p>
	SPARK doesn&#39;t allow you to use <code>Unchecked_Deallocation</code>
	with a <em>general</em> access type (which we&#39;ll discuss in more detail <a href="#freeing_stack_memory">later</a>),
	so we can&#39;t try to sidestep SPARK&#39;s ownership system by doing something tricky like this:
</p>

<div><pre><span></span><span>procedure</span> <span>Double_Free</span>
   <span>with</span> <span>SPARK_Mode</span> <span>=&gt;</span> <span>On</span>
<span>is</span>
   <span>type</span> <span>String_Access</span> <span>is</span> <span>access</span> <span>all</span> <span>String</span><span>;</span>

   <span>Str_Acc</span>       <span>:</span> <span>String_Access</span><span>;</span>
   <span>Str_Acc_Alias</span> <span>:</span> <span>String_Access</span><span>;</span>

   <span>procedure</span> <span>Free</span> <span>is</span> <span>new</span> <span>Ada</span><span>.</span><span>Unchecked_Deallocation</span> <span>(</span><span>String</span><span>,</span> <span>String_Access</span><span>);</span>
<span>begin</span>
   <span>Str_Acc</span> <span>:=</span> <span>new</span> <span>String</span><span>&#39;(</span><span>&#34;Hello, world!&#34;</span><span>);</span>
   <span>Put_Line</span> <span>(</span><span>Str_Acc</span><span>.</span><span>all</span><span>);</span>

   <span>--  Here we create an access to the dereferenced value of Str_Acc.</span>
   <span>Str_Acc_Alias</span> <span>:=</span> <span>Str_Acc</span><span>.</span><span>all</span><span>&#39;</span><span>Access</span><span>;</span>

   <span>Free</span> <span>(</span><span>Str_Acc</span><span>);</span>

   <span>Free</span> <span>(</span><span>Str_Acc_Alias</span><span>);</span>
<span>end</span> <span>Double_Free</span><span>;</span>
</pre></div>

<p>
	SPARK sees what we&#39;re up to and stops us in our tracks:
</p>

<div><pre><span></span>double_free.adb:13:17: error: instance of Unchecked_Deallocation with a 
  general access type is not allowed in SPARK
   13 |      procedure Free is new Ada.Unchecked_Deallocation (String, String_Access);
      |                ^~~~
  violation of aspect SPARK_Mode at line 6
    6 |     with SPARK_Mode =&gt; On
      |          ^ here
</pre></div>

<h3 id="race_conditions">Race Conditions <a href="#race_conditions">#</a></h3>
<p>
	In a multi-threaded program, 
	a <i>Race condition</i> is a situation where the outcome of the program depends on the order in which the threads execute.
	Because an operating system can switch between threads at any time in any order,
	it&#39;s impossible to guarantee when threads will access shared resources.
	This really becomes a problem when two threads try to write to the same memory at the same time;
	Leading to some of the most 
	<a href="https://en.wikipedia.org/wiki/Meltdown_(security_vulnerability)" target="_blank">infuriating</a>, 
	<a href="https://en.wikipedia.org/wiki/Northeast_blackout_of_2003" target="_blank">time-consuming</a>, 
	and 
	<a href="https://en.wikipedia.org/wiki/Therac-25" target="_blank">hair-raising</a>
	bugs in software development.
</p>
<p>
	One common race condition is a
	<a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use" target="_blank"><i>Time-of-check to time-of-use</i></a>
	error, or <i>TOC/TOU</i>;
	In which a resource changes between the time it&#39;s checked for validity, and the time it&#39;s used.
	Maybe one thread checks to see if a file already exists before creating it,
	gets interrupted after the initial check, 
	and then another thread creates the new file before the first thread can.
	This has led to 
	<a href="https://www.bleepingcomputer.com/news/security/windows-11-tesla-ubuntu-and-macos-hacked-at-pwn2own-2023/" target="_blank">real world vulnerabilities</a>
	in the past.
</p>

<p>
	Consider the following example:
</p>

<div><pre><span></span><span>#define THREAD_COUNT 2</span>
<span>#define STARTING_BALANCE 10000</span>

<span>int</span><span> </span><span>balance</span><span> </span><span>=</span><span> </span><span>STARTING_BALANCE</span><span>;</span>
<span>int</span><span> </span><span>withdrawn_amounts</span><span>[</span><span>THREAD_COUNT</span><span>];</span>

<span>void</span><span> </span><span>update_account_balance</span><span>(</span><span>int</span><span> </span><span>new_balance</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>// Simulate a delay consistent with a real-world system.</span>
<span>  </span><span>nanosleep</span><span>(</span><span>&amp;</span><span>(</span><span>struct</span><span> </span><span>timespec</span><span>){</span><span>0</span><span>,</span><span> </span><span>rand</span><span>()</span><span> </span><span>%</span><span> </span><span>100000</span><span>},</span><span> </span><span>NULL</span><span>);</span>
<span>  </span><span>balance</span><span> </span><span>=</span><span> </span><span>new_balance</span><span>;</span>
<span>}</span>

<span>bool</span><span> </span><span>withdraw</span><span>(</span><span>int</span><span> </span><span>thread_id</span><span>,</span><span> </span><span>int</span><span> </span><span>amount</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>bool</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span>

<span>  </span><span>if</span><span> </span><span>(</span><span>balance</span><span> </span><span>&gt;=</span><span> </span><span>amount</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>update_account_balance</span><span> </span><span>(</span><span>balance</span><span> </span><span>-</span><span> </span><span>amount</span><span>);</span>
<span>    </span><span>withdrawn_amounts</span><span>[</span><span>thread_id</span><span>]</span><span> </span><span>+=</span><span> </span><span>amount</span><span>;</span>
<span>    </span><span>result</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span>
<span>  </span><span>}</span>

<span>  </span><span>return</span><span> </span><span>result</span><span>;</span>
<span>}</span>

<span>void</span><span> </span><span>*</span><span>spend_recklessly</span><span>(</span><span>void</span><span> </span><span>*</span><span>_thread_id</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>while</span><span>(</span><span>withdraw</span><span>((</span><span>long</span><span>)</span><span>_thread_id</span><span>,</span><span> </span><span>100</span><span> </span><span>+</span><span> </span><span>(</span><span>rand</span><span>()</span><span> </span><span>%</span><span> </span><span>5</span><span>)</span><span> </span><span>*</span><span> </span><span>200</span><span>));</span>
<span>  </span><span>return</span><span> </span><span>NULL</span><span>;</span>
<span>}</span>

<span>int</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>pthread_t</span><span> </span><span>threads</span><span>[</span><span>THREAD_COUNT</span><span>];</span>

<span>  </span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>THREAD_COUNT</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>withdrawn_amounts</span><span>[</span><span>i</span><span>]</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>    </span><span>pthread_create</span><span>(</span><span>&amp;</span><span>threads</span><span>[</span><span>i</span><span>],</span><span> </span><span>NULL</span><span>,</span><span> </span><span>spend_recklessly</span><span>,</span><span> </span><span>(</span><span>void</span><span> </span><span>*</span><span>)</span><span>i</span><span>);</span>
<span>  </span><span>}</span>

<span>  </span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>THREAD_COUNT</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>pthread_join</span><span>(</span><span>threads</span><span>[</span><span>i</span><span>],</span><span> </span><span>NULL</span><span>);</span>
<span>  </span><span>}</span>

<span>  </span><span>printf</span><span>(</span><span>&#34;Starting balance: %d</span><span>\n</span><span>Final balance: %d</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>STARTING_BALANCE</span><span>,</span><span> </span><span>balance</span><span>);</span>

<span>  </span><span>int</span><span> </span><span>total_withdrawn</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>  </span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>THREAD_COUNT</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>printf</span><span>(</span><span>&#34;Thread %d withdrew: %d</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>i</span><span>,</span><span> </span><span>withdrawn_amounts</span><span>[</span><span>i</span><span>]);</span>
<span>    </span><span>total_withdrawn</span><span> </span><span>+=</span><span> </span><span>withdrawn_amounts</span><span>[</span><span>i</span><span>];</span>
<span>  </span><span>}</span>

<span>  </span><span>printf</span><span>(</span><span>&#34;Total amount withdrawn: %d</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>total_withdrawn</span><span>);</span>

<span>  </span><span>return</span><span> </span><span>EXIT_SUCCESS</span><span>;</span>
<span>}</span>

<span>// $ gcc -o bank_race_condition bank_race_condition.c</span>
<span>// $ ./bank_race_condition</span>
<span>// $ Starting balance: 10000</span>
<span>// $ Final balance: 400</span>
<span>// $ Thread 0 withdrew: 9700</span>
<span>// $ Thread 1 withdrew: 7700</span>
<span>// $ Total amount withdrawn: 17400</span>
</pre></div>
<p>
	This example spawns two threads using the
	<a href="https://en.wikipedia.org/wiki/Pthreads" target="_blank">POSIX threads</a> API.
	Each thread withdraws money from a shared &#39;bank account&#39; until there&#39;s nothing left.
	I&#39;ve introduced an artificial delay when &#39;saving&#39; the new account balance to simulate real world conditions, 
	like communicating over a network, or writing to a database.
	Because of the delay between checking the available balance and updating it after a withdrawal,
	over time each thread will consistently withdraw much more than the account&#39;s total balance.
	This bank might have a hard time balancing its sheets.
</p>
<p>
	The most common way to resolve this problem is to use a 
	<a href="https://stackoverflow.com/a/34558/5931673" target="_blank"><i>mutex</i></a>.
	A mutex (from <i><b>Mut</b>ual <b>Ex</b>clusion</i>) 
	is a construct that restricts access to a certain section of code to only one thread at a time.
	The first thread to <i>acquire</i> the mutex gets access,
	other threads need to wait until the first thread <i>releases</i> it.
	This area of code protected by the mutex is known as a
	<a href="https://en.wikipedia.org/wiki/Critical_section" target="_blank"><i>critical section</i></a>
</p>
<p>
	Wrapping the <code>withdraw</code> 
	function in a mutex so that only one thread can withdraw at a time will prevent the race condition:
</p>

<div><pre><span></span><span>// ...</span>
<span>pthread_mutex_t</span><span> </span><span>bank_account_mutex</span><span> </span><span>=</span><span> </span><span>PTHREAD_MUTEX_INITIALIZER</span><span>;</span>
<span>// ...</span>

<span>bool</span><span> </span><span>withdraw</span><span>(</span><span>int</span><span> </span><span>thread_id</span><span>,</span><span> </span><span>int</span><span> </span><span>amount</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>pthread_mutex_lock</span><span>(</span><span>&amp;</span><span>bank_account_mutex</span><span>);</span>
<span>  </span><span>bool</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span>

<span>  </span><span>if</span><span> </span><span>(</span><span>balance</span><span> </span><span>&gt;=</span><span> </span><span>amount</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>update_account_balance</span><span> </span><span>(</span><span>balance</span><span> </span><span>-</span><span> </span><span>amount</span><span>);</span>
<span>    </span><span>withdrawn_amounts</span><span>[</span><span>thread_id</span><span>]</span><span> </span><span>+=</span><span> </span><span>amount</span><span>;</span>
<span>    </span><span>result</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span>
<span>  </span><span>}</span>

<span>  </span><span>pthread_mutex_unlock</span><span>(</span><span>&amp;</span><span>bank_account_mutex</span><span>);</span>
<span>  </span><span>return</span><span> </span><span>result</span><span>;</span>
<span>}</span>

<span>// ...</span>

<span>// $ gcc -o bank_race_condition bank_race_condition.c</span>
<span>// $ ./bank_race_condition</span>
<span>// $ Starting balance: 10000</span>
<span>// $ Final balance: 0</span>
<span>// $ Thread 0 withdrew: 4700</span>
<span>// $ Thread 1 withdrew: 5300</span>
<span>// $ Total amount withdrawn: 10000</span>
</pre></div>

<p>
	Out of the box,
	Rust supports two methods of synchronising threads:
	shared-state concurrency using 
	<a href="https://doc.rust-lang.org/book/ch16-03-shared-state.html" target="_blank"><i>Mutexes</i></a>,
	and message-passing using 
	<a href="https://doc.rust-lang.org/book/ch16-02-message-passing.html" target="_blank"><i>Channels</i></a>.
</p>
<p>
	When spawning a new thread,
	Rust&#39;s memory model guarantees that any memory it accesses lives at least as long as the thread itself,
	and that the data can&#39;t be <i>moved</i> into two threads at the same time.
	The Rust compiler prevents race conditions by enforcing that shared data access only takes place through Rust&#39;s concurrency primitives:
	The only way to actually share memory between threads is to wrap it in a Mutex,
	and access it using Rust&#39;s
	<i>Atomic Reference Counted</i> smart pointer type (<code>Arc&lt;T&gt;</code>).
</p>

<p>
	The below example demonstrates a simplified version of our &#39;bank&#39; program in Rust:
</p>
<div><pre><span></span><span>fn</span><span> </span><span>spending_safely</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>account_balance</span><span> </span><span>=</span><span> </span><span>Arc</span><span>::</span><span>new</span><span>(</span><span>Mutex</span><span>::</span><span>new</span><span>(</span><span>STARTING_BALANCE</span><span>));</span>
<span>    </span><span>let</span><span> </span><span>withdrawn_amounts</span><span> </span><span>=</span><span> </span><span>Arc</span><span>::</span><span>new</span><span>(</span><span>Mutex</span><span>::</span><span>new</span><span>(</span><span>vec!</span><span>[</span><span>0</span><span>;</span><span> </span><span>THREAD_COUNT</span><span>]));</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>thread_handles</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[];</span>

<span>    </span><span>for</span><span> </span><span>thread_id</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>THREAD_COUNT</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>balance_pointer</span><span> </span><span>=</span><span> </span><span>Arc</span><span>::</span><span>clone</span><span>(</span><span>&amp;</span><span>account_balance</span><span>);</span>
<span>        </span><span>let</span><span> </span><span>amounts_pointer</span><span> </span><span>=</span><span> </span><span>Arc</span><span>::</span><span>clone</span><span>(</span><span>&amp;</span><span>withdrawn_amounts</span><span>);</span>

<span>        </span><span>thread_handles</span><span>.</span><span>push</span><span>(</span><span>thread</span><span>::</span><span>spawn</span><span>(</span><span>move</span><span> </span><span>||</span><span> </span><span>{</span>
<span>            </span><span>let</span><span> </span><span>mut</span><span> </span><span>rng</span><span> </span><span>=</span><span> </span><span>rand</span><span>::</span><span>thread_rng</span><span>();</span>
<span>            </span><span>let</span><span> </span><span>amount</span><span> </span><span>=</span><span> </span><span>100</span><span> </span><span>+</span><span> </span><span>rng</span><span>.</span><span>gen_range</span><span>(</span><span>0</span><span>..</span><span>5</span><span>)</span><span> </span><span>*</span><span> </span><span>200</span><span>;</span>

<span>            </span><span>while</span><span> </span><span>(</span><span>*</span><span>balance_pointer</span><span>.</span><span>lock</span><span>().</span><span>unwrap</span><span>())</span><span> </span><span>&gt;=</span><span> </span><span>amount</span><span> </span><span>{</span>
<span>                </span><span>*</span><span>balance_pointer</span><span>.</span><span>lock</span><span>().</span><span>unwrap</span><span>()</span><span> </span><span>-=</span><span> </span><span>amount</span><span>;</span>
<span>                </span><span>amounts_pointer</span><span>.</span><span>lock</span><span>().</span><span>unwrap</span><span>()[</span><span>thread_id</span><span>]</span><span> </span><span>+=</span><span> </span><span>amount</span><span>;</span>
<span>                </span><span>std</span><span>::</span><span>thread</span><span>::</span><span>sleep</span><span>(</span><span>Duration</span><span>::</span><span>from_nanos</span><span>(</span><span>100</span><span>));</span>
<span>            </span><span>}</span>
<span>        </span><span>}));</span>
<span>    </span><span>}</span>

<span>    </span><span>for</span><span> </span><span>handle</span><span> </span><span>in</span><span> </span><span>thread_handles</span><span> </span><span>{</span>
<span>        </span><span>handle</span><span>.</span><span>join</span><span>().</span><span>unwrap</span><span>();</span>
<span>    </span><span>}</span>

<span>    </span><span>println!</span><span>(</span><span>&#34;Starting balance: {}&#34;</span><span>,</span><span> </span><span>STARTING_BALANCE</span><span>);</span>
<span>    </span><span>println!</span><span>(</span><span>&#34;Final balance: {}&#34;</span><span>,</span><span> </span><span>*</span><span>account_balance</span><span>.</span><span>lock</span><span>().</span><span>unwrap</span><span>());</span>

<span>    </span><span>let</span><span> </span><span>total_withdrawn</span><span>:</span><span> </span><span>i32</span><span> </span><span>=</span><span> </span><span>withdrawn_amounts</span><span>.</span><span>lock</span><span>().</span><span>unwrap</span><span>().</span><span>iter</span><span>().</span><span>sum</span><span>();</span>
<span>    </span><span>for</span><span> </span><span>(</span><span>thread_id</span><span>,</span><span> </span><span>&amp;</span><span>amount</span><span>)</span><span> </span><span>in</span><span> </span><span>withdrawn_amounts</span><span>.</span><span>lock</span><span>().</span><span>unwrap</span><span>().</span><span>iter</span><span>().</span><span>enumerate</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>println!</span><span>(</span><span>&#34;Thread {} withdrew: {}&#34;</span><span>,</span><span> </span><span>thread_id</span><span>,</span><span> </span><span>amount</span><span>);</span>
<span>    </span><span>}</span>

<span>    </span><span>println!</span><span>(</span><span>&#34;Total amount withdrawn: {}&#34;</span><span>,</span><span> </span><span>total_withdrawn</span><span>);</span>
<span>}</span>

<span>// $ cargo run</span>
<span>// $ Starting balance: 10000</span>
<span>// $ Final balance: 0</span>
<span>// $ Thread 0 withdrew: 7500</span>
<span>// $ Thread 1 withdrew: 2500</span>
<span>// $ Total amount withdrawn: 10000</span>
</pre></div>

<p>
	Ada has its own nomenclature for multithreading: <i>Tasks</i>,
	and provides its own built-in mechanism for preventing data races between them.
	Ada&#39;s <i>Protected Objects</i> encapsulate data inside an implicit mutex,
	allowing only one thread access at a time via a public interface.
</p>
<p>
	The following example builds on the previous one,
	showing two Ada &#39;tasks&#39; sharing access to a single, &#39;protected&#39; resource:
</p>

<div><pre><span></span><span>procedure</span> <span>Bank</span> <span>is</span>
   <span>Float_Generator</span> <span>:</span> <span>Ada</span><span>.</span><span>Numerics</span><span>.</span><span>Float_Random</span><span>.</span><span>Generator</span><span>;</span>

   <span>function</span> <span>Get_Random_Delay</span> <span>return</span> <span>Duration</span>
   <span>is</span> <span>(</span><span>Duration</span> <span>(</span><span>Ada</span><span>.</span><span>Numerics</span><span>.</span><span>Float_Random</span><span>.</span><span>Random</span> <span>(</span><span>Float_Generator</span><span>)));</span>

   <span>function</span> <span>Get_Random_Amount</span> <span>return</span> <span>Integer</span>
   <span>is</span> <span>(</span><span>Integer</span> <span>(</span><span>Ada</span><span>.</span><span>Numerics</span><span>.</span><span>Float_Random</span><span>.</span><span>Random</span> <span>(</span><span>Float_Generator</span><span>)</span> <span>*</span> <span>999.0</span><span>));</span>

   <span>protected</span> <span>Bank_Account</span> <span>is</span>
      <span>function</span> <span>Get_Balance</span> <span>return</span> <span>Integer</span><span>;</span>
      <span>procedure</span> <span>Withdraw</span> <span>(</span><span>Amount</span> <span>: </span><span>Integer</span><span>);</span>
   <span>private</span>
      <span>Balance</span> <span>:</span> <span>Integer</span> <span>:=</span> <span>10000</span><span>;</span>
   <span>end</span> <span>Bank_Account</span><span>;</span>

   <span>protected</span> <span>body</span> <span>Bank_Account</span> <span>is</span>
      <span>function</span> <span>Get_Balance</span> <span>return</span> <span>Integer</span>
      <span>is</span> <span>(</span><span>Balance</span><span>);</span>

      <span>procedure</span> <span>Withdraw</span> <span>(</span><span>Amount</span> <span>: </span><span>Integer</span><span>)</span> <span>is</span>
      <span>begin</span>
         <span>Balance</span> <span>:=</span> <span>Balance</span> <span>-</span> <span>Amount</span><span>;</span>
      <span>end</span> <span>Withdraw</span><span>;</span>
   <span>end</span> <span>Bank_Account</span><span>;</span>

   <span>task</span> <span>type</span> <span>Reckless_Spender_Task</span> <span>(</span><span>Id</span> <span>: </span><span>Integer</span><span>);</span>

   <span>task</span> <span>body</span> <span>Reckless_Spender_Task</span> <span>is</span>
      <span>Amount</span> <span>:</span> <span>Integer</span> <span>:=</span> <span>Get_Random_Amount</span><span>;</span>
      <span>Cash</span>   <span>:</span> <span>Integer</span> <span>:=</span> <span>0</span><span>;</span>
   <span>begin</span>
      <span>while</span> <span>not</span> <span>(</span><span>Bank_Account</span><span>.</span><span>Get_Balance</span> <span>&lt;</span> <span>Amount</span><span>)</span> <span>loop</span>
         <span>Bank_Account</span><span>.</span><span>Withdraw</span> <span>(</span><span>Amount</span><span>);</span>
         <span>Cash</span> <span>:=</span> <span>Cash</span> <span>+</span> <span>Amount</span><span>;</span>
         <span>Amount</span> <span>:=</span> <span>Get_Random_Amount</span><span>;</span>
         <span>delay</span> <span>Get_Random_Delay</span><span>;</span>
      <span>end</span> <span>loop</span><span>;</span>

      <span>Put_Line</span> <span>(</span><span>&#34;Spender&#34;</span> <span>&amp;</span> <span>Id</span><span>&#39;</span><span>Image</span> <span>&amp;</span> <span>&#34; withdrew&#34;</span> <span>&amp;</span> <span>Cash</span><span>&#39;</span><span>Image</span><span>);</span>
   <span>end</span> <span>Reckless_Spender_Task</span><span>;</span>

   <span>Spender_1</span> <span>:</span> <span>Reckless_Spender_Task</span> <span>(</span><span>1</span><span>);</span>
   <span>Spender_2</span> <span>:</span> <span>Reckless_Spender_Task</span> <span>(</span><span>2</span><span>);</span>
<span>begin</span>
   <span>null</span><span>;</span>
<span>end</span> <span>Bank</span><span>;</span>
</pre></div>
<p>
	Wrapping the <code>Balance</code> 
	variable inside the protected <code>Bank_Account</code> 
	object ensures that only the task holding the mutex can access it.
</p>

<p>
	Unfortunately, like in C,
	nothing actually prevents you from writing code that accesses shared memory from multiple tasks.
</p>
<div><pre><span></span><span>procedure</span> <span>Bank</span> <span>is</span>
   <span>Float_Generator</span> <span>:</span> <span>Ada</span><span>.</span><span>Numerics</span><span>.</span><span>Float_Random</span><span>.</span><span>Generator</span><span>;</span>

   <span>function</span> <span>Get_Random_Delay</span> <span>return</span> <span>Duration</span>
   <span>is</span> <span>(</span><span>Duration</span> <span>(</span><span>Ada</span><span>.</span><span>Numerics</span><span>.</span><span>Float_Random</span><span>.</span><span>Random</span> <span>(</span><span>Float_Generator</span><span>)));</span>

   <span>function</span> <span>Get_Random_Amount</span> <span>return</span> <span>Integer</span>
   <span>is</span> <span>(</span><span>Integer</span> <span>(</span><span>Ada</span><span>.</span><span>Numerics</span><span>.</span><span>Float_Random</span><span>.</span><span>Random</span> <span>(</span><span>Float_Generator</span><span>)</span> <span>*</span> <span>999.0</span><span>));</span>

   <span>Balance</span> <span>:</span> <span>Integer</span> <span>:=</span> <span>10000</span><span>;</span>

   <span>task</span> <span>type</span> <span>Reckless_Spender_Task</span> <span>(</span><span>Id</span> <span>: </span><span>Integer</span><span>);</span>

   <span>task</span> <span>body</span> <span>Reckless_Spender_Task</span> <span>is</span>
      <span>Amount</span> <span>:</span> <span>Integer</span> <span>:=</span> <span>Get_Random_Amount</span><span>;</span>
      <span>Cash</span>   <span>:</span> <span>Integer</span> <span>:=</span> <span>0</span><span>;</span>
   <span>begin</span>
      <span>while</span> <span>not</span> <span>(</span><span>Balance</span> <span>&lt;</span> <span>Amount</span><span>)</span> <span>loop</span>
         <span>Cash</span> <span>:=</span> <span>Cash</span> <span>+</span> <span>Amount</span><span>;</span>
         <span>delay</span> <span>Get_Random_Delay</span><span>;</span>
         <span>Amount</span> <span>:=</span> <span>Get_Random_Amount</span><span>;</span>
         <span>Balance</span> <span>:=</span> <span>Balance</span> <span>-</span> <span>Amount</span><span>;</span>
      <span>end</span> <span>loop</span><span>;</span>

      <span>Put_Line</span> <span>(</span><span>&#34;Spender&#34;</span> <span>&amp;</span> <span>Id</span><span>&#39;</span><span>Image</span> <span>&amp;</span> <span>&#34; withdrew&#34;</span> <span>&amp;</span> <span>Cash</span><span>&#39;</span><span>Image</span><span>);</span>
   <span>end</span> <span>Reckless_Spender_Task</span><span>;</span>

   <span>Spender_1</span> <span>:</span> <span>Reckless_Spender_Task</span> <span>(</span><span>1</span><span>);</span>
   <span>Spender_2</span> <span>:</span> <span>Reckless_Spender_Task</span> <span>(</span><span>2</span><span>);</span>
   <span>Spender_3</span> <span>:</span> <span>Reckless_Spender_Task</span> <span>(</span><span>3</span><span>);</span>
   <span>Spender_4</span> <span>:</span> <span>Reckless_Spender_Task</span> <span>(</span><span>4</span><span>);</span>
<span>begin</span>
   <span>null</span><span>;</span>
<span>end</span> <span>Bank</span><span>;</span>

<span>--  $ alr run</span>
<span>--  $ Spender 2 withdrew 1711</span>
<span>--  $ Spender 3 withdrew 3910</span>
<span>--  $ Spender 1 withdrew 2269</span>
<span>--  $ Spender 4 withdrew 2254</span>
</pre></div>

<h4>SPARK</h4>
<p>
	SPARK supports tasking when the
	<a href="https://en.wikipedia.org/wiki/Ravenscar_profile" target="_blank">Ravenscar profile</a>
	is used, 
	and is able to prove the absence of race conditions and other concurrency-related errors.
	Ravenscar is a build configuration designed for hard real-time, safety-critical systems.
	It restricts language features unsuitable for safe multi-threaded programming.
</p>
<p>
	Describing how to write formally verifiable concurrent code in SPARK would need an article all of its own.
	For a good starting point,
	check out AdaCore&#39;s 
	<a href="https://docs.adacore.com/spark2014-docs/html/lrm/tasks-and-synchronization.html" target="_blank">SPARK Reference Manual</a>,
	and their 
	<a href="https://learn.adacore.com/courses/spark-introduction/chapters/tasking.html" target="_blank">Introduction To SPARK</a> 
	course.
</p>

<p>
	This article only scratches the surface of concurrent programming in Ada and Rust.
	To learn more, check out the
	<a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html" target="_blank"><i>Fearless Concurrency</i></a>
	chapter in the <i>Rust Book</i>,
	and the 
	<a href="https://learn.adacore.com/courses/intro-to-ada/chapters/tasking.html" target="_blank"><i>Tasking</i></a>
	chapter in AdaCore&#39;s 
	<i>Introduction to Ada</i> course.
</p>

<h3 id="dangling_pointer">Dangling Pointer <a href="#dangling_pointer">#</a></h3>
<p>
	A pointer that still points to an object in memory after it&#39;s been deallocated is known as a <i>Dangling Pointer</i>.
</p>
<p>
	Try as I might, 
	I couldn&#39;t find a way to create a dangling pointer in <em>safe</em> Rust.
	The borrow-checker was way ahead of me.
</p>

<div><pre><span></span><span>fn</span><span> </span><span>create_dangling_pointer</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>&amp;</span><span>String</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>s</span><span> </span><span>=</span><span> </span><span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;hello&#34;</span><span>);</span>
<span>    </span><span>&amp;</span><span>s</span>
<span>}</span>

<span>// $ cargo run</span>
<span>// $    Compiling dangling_pointer v0.1.0 (/home/ajxs/src/rust_examples)</span>
<span>// $ error[E0106]: missing lifetime specifier</span>
<span>// $   --&gt; src/main.rs:10:33</span>
<span>// $    |</span>
<span>// $ 10 | fn create_dangling_pointer() -&gt; &amp;String {</span>
<span>// $    |                                 ^ expected named lifetime parameter</span>
<span>// $    |</span>
<span>// $    = help: this function&#39;s return type contains a borrowed value,</span>
<span>// $ but there is no value for it to be borrowed from</span>
<span>// $ ...</span>
</pre></div>
<p>
	I had to heavily abridge the avalanche of warnings the Rust compiler generated from this example.
</p>

<p>
	Ada has a mechanism for preventing dangling pointers, 
	called <i>accessibility levels</i>.
	An object&#39;s accessibility level reflects the nesting of the scope it&#39;s defined in,
	and determines what objects an access type is allowed to point to.
	For example, if <code>Procedure_B</code> is nested within <code>Procedure_A</code>,
	it&#39;s said to have a <i>deeper</i> accessibility level than its parent.
	An access type in Ada can only point to an object at the same accessibility level, 
	or <em>shallower</em>,
	ensuring that an object lives at least as long as any access types pointing to it.
	Every type has its own accessibility level, 
	and objects have the same accessibility level as their type.
</p>
<p>
	The following example illustrates how Ada&#39;s accessibility levels prevent dangling pointers.
</p>
<div><pre><span></span><span>procedure</span> <span>Accessibility_Levels</span> <span>is</span>
   <span>type</span> <span>Level_0_Integer_Access_T</span> <span>is</span> <span>access</span> <span>all</span> <span>Integer</span><span>;</span>

   <span>Level_0_Integer</span>        <span>:</span> <span>aliased</span> <span>Integer</span>          <span>:=</span> <span>0</span><span>;</span>
   <span>Level_0_Integer_Access</span> <span>:</span> <span>Level_0_Integer_Access_T</span> <span>:=</span> <span>Level_0_Integer</span><span>&#39;</span><span>Access</span><span>;</span>

   <span>procedure</span> <span>Level_1_Procedure</span> <span>is</span>
      <span>type</span> <span>Level_1_Integer_Access_T</span> <span>is</span> <span>access</span> <span>all</span> <span>Integer</span><span>;</span>

      <span>Level_1_Integer_Access</span> <span>:</span> <span>Level_1_Integer_Access_T</span> <span>:=</span> <span>null</span><span>;</span>
      <span>Level_1_Integer</span>        <span>:</span> <span>aliased</span> <span>Integer</span>          <span>:=</span> <span>1</span><span>;</span>
   <span>begin</span>
      <span>--  LEGAL: Level_1_Integer_Access is declared at the same</span>
      <span>--  accessibility level as Level_1_Integer.</span>
      <span>Level_1_Integer_Access</span> <span>:=</span> <span>Level_1_Integer</span><span>&#39;</span><span>Access</span><span>;</span>

      <span>--  LEGAL: Level_1_Integer_Access is declared at a deeper</span>
      <span>--  accessibility level as Level_0_Integer.</span>
      <span>--  An object of type Level_1_Integer_Access can&#39;t possibly outlive</span>
      <span>--  the Level_0_Integer object.</span>
      <span>Level_1_Integer_Access</span> <span>:=</span> <span>Level_0_Integer</span><span>&#39;</span><span>Access</span><span>;</span>

      <span>--  ILLEGAL: This will cause a compile-time error.</span>
      <span>--  The object Level_1_Integer is declared at a deeper accessibility</span>
      <span>--  level than Level_0_Integer_Access.</span>
      <span>--  The compiler can&#39;t be sure that the object would live as long as</span>
      <span>--  the access type pointing to it.</span>
      <span>Level_0_Integer_Access</span> <span>:=</span> <span>Level_1_Integer</span><span>&#39;</span><span>Access</span><span>;</span>
   <span>end</span> <span>Level_1_Procedure</span><span>;</span>
<span>begin</span>
   <span>Level_1_Procedure</span><span>;</span>
   <span>Put_Line</span> <span>(</span><span>&#34;Value: &#34;</span> <span>&amp;</span> <span>Level_0_Integer_Access</span><span>.</span><span>all</span><span>&#39;</span><span>Image</span><span>);</span>
<span>end</span> <span>Accessibility_Levels</span><span>;</span>
</pre></div>
<p>
	Ada allows developers to ignore the accessibility levels system with the
	<code>Unchecked_Access</code> <i>aspect</i>.
	The above code would compile without any errors if the failing line above was replaced with:
</p>
<div><pre><span></span><span>-- ...</span>
      <span>--  LEGAL: No problem! The compiler figures you know what you&#39;re doing...</span>
      <span>Level_0_Integer_Access</span> <span>:=</span> <span>Level_1_Integer</span><span>&#39;</span><span>Unchecked_Access</span><span>;</span>
   <span>end</span> <span>Level_1_Procedure</span><span>;</span>
<span>begin</span>
   <span>Level_1_Procedure</span><span>;</span>
   <span>--  Uh oh...</span>
   <span>Put_Line</span> <span>(</span><span>&#34;Value: &#34;</span> <span>&amp;</span> <span>Level_0_Integer_Access</span><span>.</span><span>all</span><span>&#39;</span><span>Image</span><span>);</span>
<span>end</span> <span>Accessibility_Levels</span><span>;</span>
</pre></div>

<h3 id="freeing_stack_memory">Freeing Stack Memory <a href="#freeing_stack_memory">#</a></h3>
<p>
	As mentioned earlier in the section on <a href="#double_free">double freeing</a> memory,
	glibc stores metadata about each allocated memory block right before the block&#39;s address.
	This lets it determine the amount of memory being freed,
	and 
	<a href="https://github.com/bminor/glibc/blob/3374de90386f1814cec58567248d43a4632b16f0/malloc/malloc-check.c#L211" target="_blank">check</a>
	whether the address actually points to something allocated on the heap.
</p>
<p>
	Attempting to free an object allocated on the stack will bring your program to a screeching halt once glibc figures out what you&#39;re upto.
</p>

<div><pre><span></span><span>void</span><span> </span><span>free_stack_memory</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>// Note that modern versions of gcc will issue a warning about this:</span>
<span>  </span><span>// warning: ‘free’ called on unallocated object ‘x’ [-Wfree-nonheap-object]</span>
<span>  </span><span>int</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>10</span><span>;</span>
<span>  </span><span>free</span><span>(</span><span>&amp;</span><span>x</span><span>);</span>
<span>  </span><span>printf</span><span>(</span><span>&#34;Phew! We made it!</span><span>\n</span><span>&#34;</span><span>);</span>
<span>}</span>

<span>// $ gcc -o free_stack_memory free_stack_memory.c</span>
<span>// $ ./free_stack_memory</span>
<span>// $ free(): invalid pointer</span>
<span>// $ Aborted</span>
</pre></div>

<p>
	As mentioned earlier, Rust automatically deallocates variables when they go out of scope;
	Calling their destructor when necessary.
	Calling <code>std::mem::drop</code> 
	on a stack allocated variable (that implements the <code>Drop</code> trait<sup><a href="#footnote_6" id="footnote_6_link">6</a></sup>) 
	will explicitly call its destructor, and deallocate the object.
	The fact that it was allocated in stack memory has no effect.
</p>
<p>
	In Ada, access types ordinarily only point to heap-allocated memory;
	However you can create a <i>general</i> access type by adding the 
	<code>all</code> keyword to its type declaration,
	which allows it to point to <em>any</em> object of its type, 
	including objects allocated on the stack, 
	provided they are <em>actually</em> addressable<sup><a href="#footnote_7" id="footnote_7_link">7</a></sup>.
</p>
<p>
	Freeing a general access type pointing to stack memory will raise a 
	<code>Program_Error</code> exception at runtime,
	which can be caught and handled in the normal way.
</p>

<div><pre><span></span><span>procedure</span> <span>Free_Stack_Memory</span> <span>is</span>
   <span>--  The &#39;all&#39; specifier here indicates that this is a &#39;general access type&#39;,</span>
   <span>--  which can point to objects allocated on the heap OR the stack.</span>
   <span>type</span> <span>String_Access</span> <span>is</span> <span>access</span> <span>all</span> <span>String</span><span>;</span>

   <span>String_On_Stack</span> <span>:</span> <span>aliased</span> <span>String</span> <span>:=</span> <span>&#34;Hello from the stack!&#34;</span><span>;</span>
   <span>Example_String</span> <span>:</span> <span>String_Access</span> <span>:=</span> <span>String_On_Stack</span><span>&#39;</span><span>Access</span><span>;</span>

   <span>procedure</span> <span>Free</span> <span>is</span> <span>new</span> <span>Ada</span><span>.</span><span>Unchecked_Deallocation</span> <span>(</span><span>String</span><span>,</span> <span>String_Access</span><span>);</span>
<span>begin</span>
   <span>--  Attempting to free this variable will raise a &#39;Program_Error&#39; exception.</span>
   <span>Free</span> <span>(</span><span>Example_String</span><span>);</span>
<span>exception</span>
   <span>when</span> <span>E</span> <span>:</span> <span>Program_Error</span> <span>=&gt;</span>
      <span>Put_Line</span> <span>(</span><span>&#34;Program_Error: &#34;</span> <span>&amp;</span> <span>Exception_Message</span> <span>(</span><span>E</span><span>));</span>
<span>end</span> <span>Free_Stack_Memory</span><span>;</span>
</pre></div>

<h2 id="am_i_being_unfair">Am I Being Unfair to Ada? <a href="#am_i_being_unfair">#</a></h2>
<p>
	Am I being unfair to Ada?
	Have I turned my back on the Ada community, betrayed my own kind?
	Have I been converted from an Ada zealot into a born-again Rustacean? Not quite.
</p>
<p>
	A comparison on memory safety might tilt slightly in Rust&#39;s favour,
	but Ada&#39;s real strengths 
	<a href="https://ajxs.me/blog/Giving_Ada_a_Chance.html" target="_blank">lie elsewhere</a>. 
	Its strong typing, intuitive low-level programming semantics, 
	and static analysis capability are still unmatched by other systems languages.
</p>
<p>
	As I stated earlier you can do a lot in Ada without ever needing to use pointers,
	or even using heap memory at all,
	sparing yourself the risk of most of these problems.
</p>
<p>
	Unlike Rust, Ada allows stack variables of statically unknown size.
	The <code>Vec<t></t></code> type in Rust&#39;s standard library is great,
	but it stores its contents on the heap, 
	and won&#39;t be suitable for all use-cases.
</p>

<div><pre><span></span><span>procedure</span> <span>Variable_Size_Stack_Array</span> <span>is</span>
   <span>Array_Size</span> <span>:</span> <span>Integer</span><span>;</span>
<span>begin</span>
   <span>Ada</span><span>.</span><span>Text_IO</span><span>.</span><span>Put</span> <span>(</span><span>&#34;What array size would you like? &#34;</span><span>);</span>
   <span>--  Read the new array size from stdin.</span>
   <span>Ada</span><span>.</span><span>Integer_Text_IO</span><span>.</span><span>Get</span> <span>(</span><span>Array_Size</span><span>);</span>

   <span>Integer_Array</span> <span>:</span> <span>array</span> <span>(</span><span>1</span> <span>..</span> <span>Array_Size</span><span>)</span> <span>of</span> <span>Integer</span> <span>:=</span> <span>[</span><span>others</span> <span>=&gt;</span> <span>0</span><span>];</span>
   <span>Ada</span><span>.</span><span>Text_IO</span><span>.</span><span>Put_Line</span> <span>(</span><span>&#34;Array Size: &#34;</span> <span>&amp;</span> <span>Integer_Array</span><span>&#39;</span><span>Length</span><span>&#39;</span><span>Image</span><span>);</span>
<span>end</span> <span>Variable_Size_Stack_Array</span><span>;</span>
</pre></div>

<p>
	In Ada, stack-allocated, variable length arrays are first-class values.
	You can return them from functions,
	and accept them as function parameters.
	They implicitly contain their bounds as part of their value.
	The following example builds on the code above.
	Note that everything here is happening on the stack.
</p>

<div><pre><span></span><span>procedure</span> <span>Stack_Allocated_Array_Examples</span> <span>is</span>
   <span>type</span> <span>Integer_Array</span> <span>is</span> <span>array</span> <span>(</span><span>Positive</span> <span>range</span> <span>&lt;&gt;)</span> <span>of</span> <span>Integer</span><span>;</span>

   <span>--  Ada has no problem returning a variable length, stack-allocated</span>
   <span>--  array from a function.</span>
   <span>function</span> <span>Create_Variable_Size_Stack_Array</span> <span>return</span> <span>Integer_Array</span> <span>is</span>
      <span>Array_Size</span> <span>:</span> <span>Integer</span><span>;</span>
   <span>begin</span>
      <span>Ada</span><span>.</span><span>Text_IO</span><span>.</span><span>Put</span> <span>(</span><span>&#34;What array size would you like? &#34;</span><span>);</span>
      <span>--  Read the new array size from stdin.</span>
      <span>Ada</span><span>.</span><span>Integer_Text_IO</span><span>.</span><span>Get</span> <span>(</span><span>Array_Size</span><span>);</span>

      <span>Int_Array</span> <span>:</span> <span>constant</span> <span>Integer_Array</span> <span>(</span><span>1</span> <span>..</span> <span>Array_Size</span><span>)</span> <span>:=</span> <span>[</span><span>others</span> <span>=&gt;</span> <span>0</span><span>];</span>

      <span>return</span> <span>Int_Array</span><span>;</span>
   <span>end</span> <span>Create_Variable_Size_Stack_Array</span><span>;</span>

   <span>--  Ada also has no problem accepting a variable length, stack-allocated</span>
   <span>--  array as a parameter.</span>
   <span>procedure</span> <span>Print_Variable_Length_Array</span> <span>(</span><span>Int_Array</span> <span>: </span><span>Integer_Array</span><span>)</span> <span>is</span>
   <span>begin</span>
      <span>for</span> <span>I</span> <span>in</span> <span>Int_Array</span><span>&#39;</span><span>Range</span> <span>loop</span>
         <span>Ada</span><span>.</span><span>Text_IO</span><span>.</span><span>Put_Line</span> <span>(</span><span>Int_Array</span> <span>(</span><span>I</span><span>)&#39;</span><span>Image</span><span>);</span>
      <span>end</span> <span>loop</span><span>;</span>
   <span>end</span> <span>Print_Variable_Length_Array</span><span>;</span>

<span>begin</span>
   <span>Int_Array</span> <span>:</span> <span>constant</span> <span>Integer_Array</span> <span>:=</span> <span>Create_Variable_Size_Stack_Array</span><span>;</span>
   <span>Print_Variable_Length_Array</span> <span>(</span><span>Int_Array</span><span>);</span>
<span>end</span> <span>Stack_Allocated_Array_Examples</span><span>;</span>
</pre></div>

<p>
	Ada&#39;s aversion to dynamic memory allocation is reminiscent of a 
	<a href="https://www.adahome.com/History/Steelman/intro.htm" target="_blank">different time</a>;
	When embedded systems ran on 16-bit microcontrollers,
	with no operating system, no heap memory,
	and memory fragmentation could —quite literally—
	send your program crashing down to earth.
</p>

<p>
	Despite this, 
	the <i>systems programming language</i>
	ecosystem is only just now catching up to where Ada has been since the 90s.
	That&#39;s not to say Ada has stood still!
	Under AdaCore&#39;s stewardship the language has moved forward in leaps and bounds,
	and the 
	<a href="https://alire.ada.dev/" target="_blank">Alire</a>
	package manager has made Ada more accessible than ever.
	Whether you&#39;re ever going to write Ada or not,
	there&#39;s a lot you can learn from it.
	If you&#39;re designing a modern systems language,
	understanding what makes Ada good is <em>essential</em><sup><a href="#footnote_8" id="footnote_8_link">8</a></sup>.
</p>

<h2 id="conclusions">Conclusions? <a href="#conclusions">#</a></h2>
<p>
	I actually came away from writing this article with more respect for Rust.
	It does a great job of preventing lots of common bugs entirely at compile-time.
	I still think Rust is clunky and frustrating at times,
	but all in all it&#39;s an impressive language that really advances the state of the art.
</p>
<p>
	A lot of people are put off by the excessive technicality of Rust&#39;s semantics. 
	Myself included.
	One thing Ada does really well is keeping a lot of its complicated machinery hidden. 
	That might sound a bit dangerous for a low-level programming language, 
	but Ada manages it perfectly,
	and has been battle-tested by 
	<a href="https://www.adacore.com/company/our-customers" target="_blank">decades of use</a>
	in safety-critical systems.
	You never miss worrying about whether a parameter is passed by value or reference,
	or envy Rust&#39;s 
	<a href="https://stackoverflow.com/questions/24158114/what-are-the-differences-between-rusts-string-and-str" target="_blank">confusing multitude</a>
	of <i>string</i> types.
</p>
<p>
	To give Rust its due, 
	I think its designers had the right idea. 
	For all its technicality,
	Rust&#39;s design is forward-thinking and modern.
	I hope the new programming languages of 2050 will look at 
	<a href="https://github.com/johnperry-math/AoC2023/blob/master/More_Detailed_Comparison.md" target="_blank">both Ada and Rust</a>,
	see what each of them did right, 
	and be better than both of them.
</p>

<h2 id="references">References <a href="#references">#</a></h2>
<ul id="references-list">
	<li>
		ISO/IEC 9899 (2018) <i>Information technology — Programming languages — C</i>
	</li>
</ul>

<hr/>


	</div></div>
  </body>
</html>
