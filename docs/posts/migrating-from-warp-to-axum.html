<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-2">Original</a>
    <h1>Migrating from Warp to Axum</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <div>
    <p><span>
      Nov 15, 2022
    </span>

    
    <span></span>
    <span>18 minute read</span>
    

    
    
      <span></span>
      
        
          <span><a href="https://fasterthanli.me/tags/rust">rust</a></span>
          
            <span>·</span>
          
        
      
        
          <span><a href="https://fasterthanli.me/tags/axum">axum</a></span>
          
        
      
    

    <span>
	
</span>
  </p></div>

  
    








    

    
        
        




  
</div><div>
  

  
    
      
    
  

  
                        <h2>
                            <a id="falling-out-of-love-with-warp" href="#falling-out-of-love-with-warp">
                                Falling out of love with <code>warp</code>
                            </a>
                        </h2>
                        
<p>Back when I wrote this codebase, <a href="https://lib.rs/crates/warp">warp</a> was the best
/ only alternative for something relatively high-level on top of
<a href="https://lib.rs/crates/hyper">hyper</a>.</p>
<p>I was never super fond of warp&#39;s model — it&#39;s a fine crate, just not for me.</p>
<p>The way routing works is essentially building a type that gets larger and
larger. One route might look like:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>let</i> bye = warp<i>::</i><i>path</i><i>(</i><i>&#34;bye&#34;</i><i>)</i>
        <i>.</i><i>and</i><i>(</i>warp<i>::</i>path<i>::</i><i>param</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>map</i><i>(</i>|<i>name</i>: <i>String</i>| <i>format</i><i>!</i><i>(</i><i>&#34;Good bye, {}!&#34;</i>, name<i>)</i><i>)</i><i>;</i>
</pre></div>
<p>And then all the routes combined might look like:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>let</i> routes = warp<i>::</i><i>get</i><i>(</i><i>)</i><i>.</i><i>and</i><i>(</i>
        hello_world
            <i>.</i><i>or</i><i>(</i>hi<i>)</i>
            <i>.</i><i>or</i><i>(</i>hello_from_warp<i>)</i>
            <i>.</i><i>or</i><i>(</i>bye<i>)</i>
            <i>.</i><i>or</i><i>(</i>math<i>)</i>
            <i>.</i><i>or</i><i>(</i>sum<i>)</i>
            <i>.</i><i>or</i><i>(</i>times<i>)</i>,
    <i>)</i><i>;</i>
</pre></div>
<p>That&#39;s from warp&#39;s <a href="https://github.com/seanmonstar/warp/blob/4e9c4fd6ce238197fd1088061bbc07fa2852cb0f/examples/routing.rs">routing example</a>.</p>
<p>We can look at the type of the whole <code>routes</code> expression with this simple trick:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>let</i> a: <i>(</i><i>)</i> = routes<i>;</i>
</pre></div>
<p>And as we see, it&#39;s fairly large:</p>
<div><p>sh</p><pre data-lang="sh">$ cargo check --examples
cargo check --examples        
    Checking warp v0.3.3 (/home/amos/bearcove/warp)
error[E0308]: mismatched types
   --&gt; examples/routing.rs:103:17
    (cut)
    = note: expected unit type `()`
                  found struct `warp::filter::and::And&lt;impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Rejection&gt;, warp::filter::or::Or&lt;warp::filter::or::Or&lt;warp::filter::or::Or&lt;warp::filter::or::Or&lt;warp::filter::or::Or&lt;warp::filter::or::Or&lt;warp::filter::map::Map&lt;impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Rejection&gt;, [closure@examples/routing.rs:13:45: 13:47]&gt;, warp::filter::map::Map&lt;Exact&lt;warp::path::internal::Opaque&lt;&amp;str&gt;&gt;, [closure@examples/routing.rs:16:35: 16:37]&gt;&gt;, warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Infallible&gt;, Exact&lt;warp::path::internal::Opaque&lt;main::{closure#0}::__StaticPath&gt;&gt;&gt;, Exact&lt;warp::path::internal::Opaque&lt;main::{closure#0}::__StaticPath&gt;&gt;&gt;, Exact&lt;warp::path::internal::Opaque&lt;main::{closure#0}::__StaticPath&gt;&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Rejection&gt;&gt;, [closure@examples/routing.rs:21:70: 21:72]&gt;&gt;, warp::filter::map::Map&lt;warp::filter::and::And&lt;Exact&lt;warp::path::internal::Opaque&lt;&amp;str&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (String,), Error = Rejection&gt;&gt;, [closure@examples/routing.rs:51:14: 51:28]&gt;&gt;, warp::filter::or::Or&lt;warp::filter::map::Map&lt;warp::filter::and::And&lt;Exact&lt;warp::path::internal::Opaque&lt;&amp;str&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Rejection&gt;&gt;, [closure@examples/routing.rs:70:14: 70:16]&gt;, warp::filter::and::And&lt;Exact&lt;warp::path::internal::Opaque&lt;&amp;str&gt;&gt;, warp::filter::or::Or&lt;warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Infallible&gt;, Exact&lt;warp::path::internal::Opaque&lt;main::{closure#0}::__StaticPath&gt;&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (u32,), Error = Rejection&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (u32,), Error = Rejection&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Rejection&gt;&gt;, [closure@examples/routing.rs:26:50: 26:56]&gt;, warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Infallible&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (u16,), Error = Rejection&gt;&gt;, Exact&lt;warp::path::internal::Opaque&lt;main::{closure#0}::__StaticPath&gt;&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (u16,), Error = Rejection&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Rejection&gt;&gt;, [closure@examples/routing.rs:32:46: 32:52]&gt;&gt;&gt;&gt;&gt;, warp::filter::map::Map&lt;warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Infallible&gt;, Exact&lt;warp::path::internal::Opaque&lt;main::{closure#0}::__StaticPath&gt;&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (u32,), Error = Rejection&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (u32,), Error = Rejection&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Rejection&gt;&gt;, [closure@examples/routing.rs:26:50: 26:56]&gt;, [closure@examples/routing.rs:74:23: 74:31]&gt;&gt;, warp::filter::map::Map&lt;warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Infallible&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (u16,), Error = Rejection&gt;&gt;, Exact&lt;warp::path::internal::Opaque&lt;main::{closure#0}::__StaticPath&gt;&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (u16,), Error = Rejection&gt;&gt;, impl warp::Filter + Copy + warp::filter::FilterBase&lt;Extract = (), Error = Rejection&gt;&gt;, [closure@examples/routing.rs:32:46: 32:52]&gt;, [closure@examples/routing.rs:76:19: 76:27]&gt;&gt;&gt;`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `warp` due to previous error
</pre></div>
<p>(In fact, it made the estimated reading time for this article jump from 8 to 13
minutes, all by itself).</p>
<p>This is an issue on several levels. First, that&#39;s a <em>lot</em> of work for the
compiler. &#34;My warp app takes forever to compile&#34; is the most active issue on the
issue tracker. In fact, I&#39;ve <a href="https://fasterthanli.me/articles/why-is-my-rust-build-so-slow">written about this specific problem
before</a>.</p>
<p>Second, the errors are awful. In your mind, I might be pretty good at Rust, but
facing those errors, even I recoiled in horror. I just had no idea what it
wanted me to do. So I ended up doing some... terrible, non-warpy things. This is
what my router ended up looking like:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>// this is a `ServerState` struct that has a cache, the config (including secrets)</i>
    <i>// stuff like that. we want that from any request handlers.</i>
    <i>let</i> with_state = warp<i>::</i><i>any</i><i>(</i><i>)</i><i>.</i><i>map</i><i>(</i><i>move</i> || server_state<i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i><i>;</i>

    <i>// because most of my website is dynamic and rendered from liquid templates,</i>
    <i>// (and those are cached), I need stuff like the full path, raw query string,</i>
    <i>// cookies (for login state), etc.</i>
    <i>let</i> with_cx = with_state
        <i>.</i><i>clone</i><i>(</i><i>)</i>
        <i>.</i><i>and</i><i>(</i>warp<i>::</i>filters<i>::</i>path<i>::</i><i>full</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>and</i><i>(</i>
            warp<i>::</i>filters<i>::</i>query<i>::</i><i>raw</i><i>(</i><i>)</i>
                <i>.</i><i>recover</i><i>(</i>|_| async {
                    <i>let</i> res: <i>Result</i><i>&lt;</i><i>String</i>, <i>Infallible</i><i>&gt;</i> = Ok<i>(</i><i>&#34;&#34;</i><i>.</i><i>to_string</i><i>(</i><i>)</i><i>)</i><i>;</i>
                    res
                }<i>)</i>
                <i>.</i><i>unify</i><i>(</i><i>)</i>,
        <i>)</i>
        <i>.</i><i>and</i><i>(</i>warp<i>::</i>filters<i>::</i>header<i>::</i><i>optional</i><i>(</i><i>&#34;cookie&#34;</i><i>)</i><i>)</i>
        <i>.</i><i>and</i><i>(</i>
            warp<i>::</i>filters<i>::</i>body<i>::</i><i>bytes</i><i>(</i><i>)</i>
                <i>.</i><i>recover</i><i>(</i>|rej| {
                    <i>warn</i><i>!</i><i>(</i><i>&#34;while getting body bytes: {:?}&#34;</i>, rej<i>)</i><i>;</i>
                    async {
                        <i>let</i> res: <i>Result</i><i>&lt;</i><i>Bytes</i>, <i>Infallible</i><i>&gt;</i> = Ok<i>(</i><i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>)</i><i>;</i>
                        res
                    }
                }<i>)</i>
                <i>.</i><i>unify</i><i>(</i><i>)</i>,
        <i>)</i>
        <i>.</i><i>map</i><i>(</i>
            |state,
             <i>full_path</i>: <i>FullPath</i>,
             <i>query</i>: <i>String</i>,
             <i>cookie_header</i>: <i>Option</i><i>&lt;</i><i>String</i><i>&gt;</i>,
             <i>body</i>: <i>Bytes</i>| {
                <i>let</i> <i>mut</i> cookies = <i>HashMap</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
                <i>if</i> <i>let</i> Some<i>(</i>ch<i>)</i> = cookie_header {
                    <i>for</i> cookie <i>in</i> ch
                        <i>.</i><i>split</i><i>(</i><i>&#39;;&#39;</i><i>)</i>
                        <i>.</i><i>map</i><i>(</i>|x| x<i>.</i><i>trim</i><i>(</i><i>)</i><i>)</i>
                        <i>.</i><i>filter_map</i><i>(</i>|x| <i>Cookie</i><i>::</i><i>parse_encoded</i><i>(</i>x<i>.</i><i>to_string</i><i>(</i><i>)</i><i>)</i><i>.</i><i>ok</i><i>(</i><i>)</i><i>)</i>
                    {
                        cookies<i>.</i><i>insert</i><i>(</i>cookie<i>.</i><i>name</i><i>(</i><i>)</i><i>.</i><i>to_string</i><i>(</i><i>)</i>, cookie<i>)</i><i>;</i>
                    }
                }
                <i>let</i> cx = <i>Context</i> {
                    state,
                    <i>raw_query</i>: <i>Arc</i><i>::</i><i>new</i><i>(</i><i>Query</i><i>::</i><i>new</i><i>(</i>query<i>)</i><i>)</i>,
                    <i>path</i>: full_path<i>.</i><i>as_str</i><i>(</i><i>)</i><i>.</i><i>to_string</i><i>(</i><i>)</i>,
                    cookies,
                    <i>raw_body</i>: body,
                }<i>;</i>
                cx
            },
        <i>)</i><i>;</i>

    <i>// I forget why this is needed 🙃 but it is.</i>
    <i>let</i> with_cx = <i>move</i> || with_cx<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>

    <i>// This is just how I did live-reloading.</i>
    <i>use</i> std<i>::</i>convert<i>::</i>Infallible<i>;</i>
    <i>use</i> warp<i>::</i>filters<i>::</i>sse<i>::</i>Event <i>as</i> ServerSentEvent<i>;</i>
    <i>// This is a free-standing function because it&#39;s the only reasonable way</i>
    <i>// to annotate the error type of the TryStream.</i>
    <i>fn</i> <i>sse_events</i><i>(</i><i>cx</i>: <i>Context</i><i>)</i> -&gt; <i>impl</i> <i>Stream</i><i>&lt;</i><i>Item</i> = <i>Result</i><i>&lt;</i><i>ServerSentEvent</i>, <i>Infallible</i><i>&gt;</i><i>&gt;</i> {
        <i>let</i> <i>mut</i> rx = cx<i>.</i><i>state</i><i>.</i><i>broadcast_rev</i><i>.</i><i>subscribe</i><i>(</i><i>)</i><i>;</i>
        <i>// cf. https://lib.rs/crates/async-stream</i>
        <i>// could be written without it, but I like that crate.</i>
        async_stream<i>::</i>try_stream! {
            yield ServerSentEvent::<i>default</i><i>(</i><i>)</i>.event<i>(</i><i>&#34;message&#34;</i><i>)</i>.data<i>(</i><i>&#34;Live reloading enabled&#34;</i><i>)</i>;

            <i>loop</i> {
                tokio::select! {
                    Ok<i>(</i>rev_id<i>)</i> = rx.recv<i>(</i><i>)</i> =&gt; {
                        yield ServerSentEvent::<i>default</i><i>(</i><i>)</i>.event<i>(</i><i>&#34;new-revision&#34;</i><i>)</i>.data<i>(</i>rev_id<i>)</i>;
                    },
                    _ = tokio::time::sleep<i>(</i>Duration::from_secs<i>(</i><i>1</i><i>)</i><i>)</i> =&gt; {
                        yield ServerSentEvent::<i>default</i><i>(</i><i>)</i>.event<i>(</i><i>&#34;ping&#34;</i><i>)</i>.data<i>(</i><i>&#34;Just keeping connections alive&#34;</i><i>)</i>;
                    },
                }
            }
        }
    }

    <i>let</i> livereload_route = method<i>::</i><i>get</i><i>(</i><i>)</i>
        <i>.</i><i>and</i><i>(</i>warp<i>::</i>path!<i>(</i><i>&#34;api&#34;</i> / <i>&#34;livereload&#34;</i><i>)</i><i>)</i>
        <i>.</i><i>and</i><i>(</i><i>with_cx</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>map</i><i>(</i>|<i>cx</i>: <i>Context</i>| warp<i>::</i>sse<i>::</i><i>reply</i><i>(</i>warp<i>::</i>sse<i>::</i><i>keep_alive</i><i>(</i><i>)</i><i>.</i><i>stream</i><i>(</i><i>sse_events</i><i>(</i>cx<i>)</i><i>)</i><i>)</i><i>)</i><i>;</i>

    <i>// uwu what&#39;s this? a single route? weird...</i>
    <i>let</i> catchall_get = method<i>::</i><i>get</i><i>(</i><i>)</i>
        <i>.</i><i>and</i><i>(</i><i>with_cx</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>and_then</i><i>(</i>|<i>cx</i>: <i>Context</i>| cx<i>.</i><i>handle</i><i>(</i>routes<i>::</i>serve_get<i>)</i><i>)</i><i>;</i>

    <i>let</i> catchall_head = method<i>::</i><i>head</i><i>(</i><i>)</i>
        <i>.</i><i>and</i><i>(</i><i>with_cx</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>and_then</i><i>(</i>|<i>cx</i>: <i>Context</i>| cx<i>.</i><i>handle</i><i>(</i>routes<i>::</i>serve_get<i>)</i><i>)</i><i>;</i>

    <i>let</i> catchall_post = method<i>::</i><i>post</i><i>(</i><i>)</i>
        <i>.</i><i>and</i><i>(</i><i>with_cx</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>and_then</i><i>(</i>|<i>cx</i>: <i>Context</i>| cx<i>.</i><i>handle</i><i>(</i>routes<i>::</i>serve_post<i>)</i><i>)</i><i>;</i>

    <i>let</i> all_routes = livereload_route
        <i>.</i><i>boxed</i><i>(</i><i>)</i>
        <i>.</i><i>or</i><i>(</i>catchall_get<i>.</i><i>boxed</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>or</i><i>(</i>catchall_head<i>.</i><i>boxed</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>or</i><i>(</i>catchall_post<i>.</i><i>boxed</i><i>(</i><i>)</i><i>)</i><i>;</i>
    <i>let</i> access_log = warp<i>::</i>filters<i>::</i>log<i>::</i><i>log</i><i>(</i><i>&#34;access&#34;</i><i>)</i><i>;</i>
</pre></div>
<p>It used to be much worse, because I used to use <code>warp</code> the way it&#39;s /meant/ to
be used... before I gave up and just started using handlers like <code>serve_get</code>:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>pub</i> async <i>fn</i> <i>serve_get</i><i>(</i><i>cx</i>: <i>Context</i><i>)</i> -&gt; <i>HttpResult</i> {
    <i>if</i> cx<i>.</i><i>path</i><i>.</i><i>ends_with</i><i>(</i><i>&#39;/&#39;</i><i>)</i> &amp;&amp; cx<i>.</i><i>path</i> != <i>&#34;/&#34;</i> {
        <i>return</i> <i>serve_redirect</i><i>(</i>cx<i>.</i><i>path</i><i>.</i><i>trim_end_matches</i><i>(</i><i>&#39;/&#39;</i><i>)</i><i>)</i><i>.</i>await<i>;</i>
    }

    <i>if</i> cx<i>.</i><i>path</i> == <i>&#34;/robots.txt&#34;</i> {
        <i>return</i> Ok<i>(</i><i>Box</i><i>::</i><i>new</i><i>(</i>
            <i>Response</i><i>::</i><i>builder</i><i>(</i><i>)</i>
                <i>.</i><i>status</i><i>(</i><i>StatusCode</i><i>::</i>OK<i>)</i>
                <i>.</i><i>body</i><i>(</i><i>Body</i><i>::</i><i>empty</i><i>(</i><i>)</i><i>)</i>,
        <i>)</i><i>)</i><i>;</i>
    }

    <i>if</i> cx<i>.</i><i>path</i> == <i>&#34;/tags&#34;</i> {
        <i>return</i> tags<i>::</i><i>serve_list</i><i>(</i>cx<i>)</i><i>.</i>await<i>;</i>
    } <i>else</i> <i>if</i> cx<i>.</i><i>path</i><i>.</i><i>starts_with</i><i>(</i><i>&#34;/tags/&#34;</i><i>)</i> {
        <i>return</i> tags<i>::</i><i>serve_single</i><i>(</i>cx<i>)</i><i>.</i>await<i>;</i>
    }

    <i>if</i> cx<i>.</i><i>path</i> == <i>&#34;/settings&#34;</i> {
        <i>return</i> settings<i>::</i><i>serve</i><i>(</i>cx<i>)</i><i>.</i>await<i>;</i>
    }

    <i>if</i> cx<i>.</i><i>path</i> == <i>&#34;/search&#34;</i> {
        <i>return</i> search<i>::</i><i>serve</i><i>(</i>cx<i>)</i><i>.</i>await<i>;</i>
    }

    <i>if</i> cx<i>.</i><i>path</i> == <i>&#34;/login&#34;</i> {
        <i>return</i> login<i>::</i><i>serve_login</i><i>(</i>cx<i>)</i><i>.</i>await<i>;</i>
    }

    <i>if</i> cx<i>.</i><i>path</i> == <i>&#34;/patreon/oauth&#34;</i> {
        <i>return</i> login<i>::</i><i>serve_patreon_oauth</i><i>(</i>cx<i>)</i><i>.</i>await<i>;</i>
    }

    <i>if</i> cx<i>.</i><i>path</i> == <i>&#34;/logout&#34;</i> {
        <i>return</i> login<i>::</i><i>serve_logout</i><i>(</i>cx<i>)</i><i>.</i>await<i>;</i>
    }

    <i>if</i> cx<i>.</i><i>path</i> == <i>&#34;/debug-credentials&#34;</i> {
        <i>return</i> login<i>::</i><i>serve_debug_credentials</i><i>(</i>cx<i>)</i><i>.</i>await<i>;</i>
    }

    <i>if</i> cx<i>.</i><i>path</i> == <i>&#34;/comments&#34;</i> {
        <i>return</i> comments<i>::</i><i>serve</i><i>(</i>cx<i>)</i><i>.</i>await<i>;</i>
    }

    <i>if</i> cx<i>.</i><i>path</i> == <i>&#34;/latest-video&#34;</i> {
        <i>return</i> latest_video<i>::</i><i>serve</i><i>(</i>cx<i>)</i><i>.</i>await<i>;</i>
    }

    <i>if</i> cx<i>.</i><i>path</i> == <i>&#34;/patron-list&#34;</i> {
        <i>return</i> patron_list<i>::</i><i>serve</i><i>(</i>cx<i>)</i><i>.</i>await<i>;</i>
    }

    <i>if</i> cx<i>.</i><i>path</i> == <i>&#34;/index.xml&#34;</i> {
        <i>return</i> cx
            <i>.</i><i>serve_template</i><i>(</i><i>&#34;index.xml&#34;</i>, <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i>, mime<i>::</i><i>atom</i><i>(</i><i>)</i><i>)</i>
            <i>.</i>await<i>;</i>
    }

    revision_routes<i>::</i><i>serve</i><i>(</i>cx<i>)</i><i>.</i>await
}
</pre></div>
<p>A single route would then look something like:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>pub</i> async <i>fn</i> <i>serve_login</i><i>(</i><i>cx</i>: <i>Context</i><i>)</i> -&gt; <i>HttpResult</i> {
    <i>#<i>[</i>derive<i>(</i>Deserialize<i>)</i><i>]</i></i>
    <i>struct</i> <i>QueryParams</i> {
        <i>#<i>[</i>serde<i>(</i>default<i>)</i><i>]</i></i>
        <i>return_to</i>: <i>Option</i><i>&lt;</i><i>String</i><i>&gt;</i>,
    }

    <i>let</i> location = <i>make_patreon_login_url</i><i>(</i>cx<i>.</i><i>config</i><i>(</i><i>)</i><i>)</i>?<i>;</i>

    <i>let</i> <i>mut</i> res = <i>Response</i><i>::</i><i>builder</i><i>(</i><i>)</i>
        <i>.</i><i>status</i><i>(</i><i>StatusCode</i><i>::</i>TEMPORARY_REDIRECT<i>)</i>
        <i>.</i><i>header</i><i>(</i><i>&#34;location&#34;</i>, location<i>)</i><i>;</i>
    <i>if</i> <i>let</i> Ok<i>(</i>params<i>)</i> = cx<i>.</i><i>query</i><i>::</i><i>&lt;</i><i>QueryParams</i><i>&gt;</i><i>(</i><i>)</i> {
        <i>if</i> <i>let</i> Some<i>(</i>return_to<i>)</i> = params<i>.</i><i>return_to</i> {
            <i>let</i> <i>mut</i> cookie = <i>Cookie</i><i>::</i><i>new</i><i>(</i><i>&#34;return_to&#34;</i>, return_to<i>)</i><i>;</i>
            cookie<i>.</i><i>set_path</i><i>(</i><i>&#34;/&#34;</i><i>)</i><i>;</i>
            cookie<i>.</i><i>set_expires</i><i>(</i>time<i>::</i><i>OffsetDateTime</i><i>::</i><i>now_utc</i><i>(</i><i>)</i> + time<i>::</i><i>Duration</i><i>::</i><i>minutes</i><i>(</i><i>30</i><i>)</i><i>)</i><i>;</i>
            res = res<i>.</i><i>insert_cookie</i><i>(</i>cookie<i>)</i><i>;</i>
        }
    }
    <i>let</i> res = res<i>.</i><i>body</i><i>(</i><i>&#34;Redirecting to Patreon login...&#34;</i><i>.</i><i>to_string</i><i>(</i><i>)</i><i>)</i>?<i>;</i>
    Ok<i>(</i><i>Box</i><i>::</i><i>new</i><i>(</i>res<i>)</i><i>)</i>
}
</pre></div>
<p>This is absolutely not the way <code>warp</code> was meant to be used, but this is what I
ended up doing, to survive the compile times + type spaghetti party.</p>
<p>The <code>HttpResult</code> type enforced boxed replies, to avoid the &#34;I&#39;m returning
different types from different codepaths and they won&#39;t unify&#34; problem:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>pub</i> <i>use</i> warp<i>::</i>Reply<i>;</i>
<i>pub</i> <i>type</i> <i>HttpResult</i> = color_eyre<i>::</i><i>Result</i><i>&lt;</i><i>Box</i><i>&lt;</i><i>dyn</i> <i>Reply</i><i>&gt;</i><i>&gt;</i><i>;</i>
</pre></div>
                        <h2>
                            <a id="the-opinions-of-axum-also-nice-error-handling" href="#the-opinions-of-axum-also-nice-error-handling">
                                The opinions of <code>axum</code>, also nice error handling
                            </a>
                        </h2>
                        
<p>One nice thing about <a href="https://lib.rs/crates/axum">axum</a> is that it defaults to
something simple. It provides its own <a href="https://docs.rs/axum/0.5.17/axum/body/type.BoxBody.html">BoxBody</a>
body type, and an <a href="https://docs.rs/axum/0.5.17/axum/body/fn.boxed.html">axum::body::boxed</a> function to
turn damn near anything into it.</p>
<p>It has an <a href="https://docs.rs/axum/0.5.17/axum/response/trait.IntoResponse.html">IntoResponse
trait</a>, which
lets your handlers look like:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>// basic handler that responds with a static string</i>
async <i>fn</i> <i>root</i><i>(</i><i>)</i> -&gt; <i>&amp;</i><i>&#39;</i><i>static</i> <i>str</i> {
    <i>&#34;Hello, World!&#34;</i>
}
</pre></div>
<p>(Because <code>IntoResponse</code> is implemented for <code>&amp;&#39;static str</code>)</p>
<p>Or like:</p>
<div><p>Rust code</p><pre data-lang="rust">async <i>fn</i> <i>create_user</i><i>(</i>
    <i>// this argument tells axum to parse the request body</i>
    <i>// as JSON into a `CreateUser` type</i>
    Json<i>(</i>payload<i>)</i>: <i>Json</i><i>&lt;</i><i>CreateUser</i><i>&gt;</i>,
<i>)</i> -&gt; <i>impl</i> <i>IntoResponse</i> {
    <i>// insert your application logic here</i>
    <i>let</i> user = <i>User</i> {
        <i>id</i>: <i>1337</i>,
        <i>username</i>: payload<i>.</i><i>username</i>,
    }<i>;</i>

    <i>// this will be converted into a JSON response</i>
    <i>// with a status code of `201 Created`</i>
    <i>(</i><i>StatusCode</i><i>::</i>CREATED, Json<i>(</i>user<i>)</i><i>)</i>
}
</pre></div>
<p>(Because <code>IntoResponse</code> is implemented for tuples like <code>(StatusCode, IntoResponse)</code>).</p>
<p>There&#39;s still the &#34;type unification&#34; footgun with that approach — if you
conditionally returned <code>(StatusCode::FORBIDDEN, &#34;nuh-huh&#34;)</code>, you&#39;d get a compile
error, and you&#39;d need to change the return type to <code>Response&lt;BoxBody&gt;</code>, and call
<code>.into_response()</code> on both these tuples.</p>
<p>It&#39;s also useful to be able to turn errors into HTTP responses, so, I came up
with my own <code>HttpResult</code> type:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>// in `crates/futile/src/serve/routes/response.rs`</i>

<i>use</i> std<i>::</i>borrow<i>::</i>Cow<i>;</i>

<i>use</i> axum<i>::</i>response<i>::</i>{IntoResponse, Response}<i>;</i>
<i>use</i> color_eyre<i>::</i>Report<i>;</i>
<i>use</i> futile_backtrace_printer<i>::</i>make_backtrace_printer<i>;</i>
<i>use</i> futile_config<i>::</i>is_production<i>;</i>
<i>use</i> http<i>::</i>{header, StatusCode}<i>;</i>
<i>use</i> time<i>::</i>format_description<i>::</i>well_known<i>::</i>Rfc3339<i>;</i>
<i>use</i> tracing<i>::</i>error<i>;</i>

<i>use</i> crate<i>::</i>serve<i>::</i>{
    html_color_output<i>::</i>HtmlColorOutput, routes<i>::</i>mime, template_renderer<i>::</i>inject_livereload,
}<i>;</i>

<i>pub</i> <i>type</i> <i>HttpResult</i> = <i>Result</i><i>&lt;</i><i>Response</i>, <i>HttpError</i><i>&gt;</i><i>;</i>

<i>pub</i> <i>trait</i> <i>IntoHttp</i> {
    <i>fn</i> <i>into_http</i><i>(</i><i>self</i><i>)</i> -&gt; <i>HttpResult</i><i>;</i>
}

<i>impl</i><i>&lt;</i><i>T</i>: <i>IntoResponse</i><i>&gt;</i> <i>IntoHttp</i> <i>for</i> <i>T</i> {
    <i>fn</i> <i>into_http</i><i>(</i><i>self</i><i>)</i> -&gt; <i>HttpResult</i> {
        Ok<i>(</i><i>self</i><i>.</i><i>into_response</i><i>(</i><i>)</i><i>)</i>
    }
}

<i>#<i>[</i>derive<i>(</i>Debug<i>)</i><i>]</i></i>
<i>pub</i> <i>enum</i> <i>HttpError</i> {
    NotFound { <i>msg</i>: <i>Cow</i><i>&lt;</i><i>&#39;</i><i>static</i>, <i>str</i><i>&gt;</i> },
    Internal { <i>err</i>: <i>String</i> },
}

<i>impl</i> <i>HttpError</i> {
    <i>fn</i> <i>from_report</i><i>(</i><i>err</i>: <i>Report</i><i>)</i> -&gt; <i>Self</i> {
        <i>error</i><i>!</i><i>(</i><i>&#34;HTTP handler error: {}&#34;</i>, err.root_cause<i>(</i><i>)</i><i>)</i><i>;</i>

        <i>let</i> bt_printer = <i>make_backtrace_printer</i><i>(</i><i>)</i><i>;</i>

        <i>let</i> maybe_bt = err
            <i>.</i><i>context</i><i>(</i><i>)</i>
            <i>.</i><i>downcast_ref</i><i>::</i><i>&lt;</i>color_eyre<i>::</i><i>Handler</i><i>&gt;</i><i>(</i><i>)</i>
            <i>.</i><i>and_then</i><i>(</i>|h| h<i>.</i><i>backtrace</i><i>(</i><i>)</i><i>)</i><i>;</i>
        <i>if</i> <i>let</i> Some<i>(</i>bt<i>)</i> = maybe_bt {
            <i>error</i><i>!</i><i>(</i><i>&#34;Backtrace:&#34;</i><i>)</i><i>;</i>
            <i>let</i> <i>mut</i> stream = termcolor<i>::</i><i>StandardStream</i><i>::</i><i>stderr</i><i>(</i>termcolor<i>::</i><i>ColorChoice</i><i>::</i>Always<i>)</i><i>;</i>
            bt_printer<i>.</i><i>print_trace</i><i>(</i>bt, <i>&amp;</i><i>mut</i> stream<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        } <i>else</i> {
            <i>error</i><i>!</i><i>(</i><i>&#34;No Backtrace&#34;</i><i>)</i><i>;</i>
        }

        <i>let</i> trace_content = <i>if</i> <i>is_production</i><i>(</i><i>)</i> {
            <i>&#34;&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i>
        } <i>else</i> {
            <i>let</i> <i>mut</i> err_string = <i>String</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
            <i>for</i> <i>(</i>i, e<i>)</i> <i>in</i> err<i>.</i><i>chain</i><i>(</i><i>)</i><i>.</i><i>enumerate</i><i>(</i><i>)</i> {
                <i>use</i> std<i>::</i>fmt<i>::</i>Write<i>;</i>
                <i>let</i> _ = <i>writeln</i><i>!</i><i>(</i>&amp;<i>mut</i> err_string, <i>&#34;{}. {}&#34;</i>, i + <i>1</i>, e<i>)</i><i>;</i>
            }

            <i>let</i> <i>mut</i> err_string_escaped = <i>String</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
            html_escape<i>::</i><i>encode_safe_to_string</i><i>(</i><i>&amp;</i>err_string, <i>&amp;</i><i>mut</i> err_string_escaped<i>)</i><i>;</i>

            <i>let</i> backtrace: <i>String</i> = <i>if</i> <i>let</i> Some<i>(</i>bt<i>)</i> = maybe_bt {
                <i>let</i> <i>mut</i> output = <i>HtmlColorOutput</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
                bt_printer<i>.</i><i>print_trace</i><i>(</i>bt, <i>&amp;</i><i>mut</i> output<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
                output<i>.</i><i>into</i><i>(</i><i>)</i>
            } <i>else</i> {
                <i>&#34;&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i>
            }<i>;</i>

            <i>format</i><i>!</i><i>(</i>
                <i>r#&#34;
&lt;pre class=&#34;trace&#34;&gt;{err_string_escaped}
{backtrace}&lt;/pre&gt;
                &#34;#</i>,
            <i>)</i>
        }<i>;</i>

        <i>let</i> date = time<i>::</i><i>OffsetDateTime</i><i>::</i><i>now_utc</i><i>(</i><i>)</i><i>.</i><i>format</i><i>(</i><i>&amp;</i>Rfc3339<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

        <i>let</i> body = <i>format</i><i>!</i><i>(</i>
            <i>r#&#34;
            &lt;html&gt;
            {padding}
            &lt;head&gt;
            &lt;style&gt;
                @import url(&#39;https://fonts.googleapis.com/css2?family=Alegreya+Sans&amp;family=Source+Code+Pro&amp;display=swap&#39;);

                body {{
                    font-family: &#34;Alegreya Sans&#34;, sans-serif;
                    max-width: 1200px;
                    margin: 20px auto;
                    line-height: 1.6;
                }}

                h2 {{
                    color: #b73535;
                }}

                pre.trace {{
                    font-family: &#34;Source Code Pro&#34;, monospace;
                    padding: 1em;
                    border: 2px solid #999;
                    font-size: 14px;
                    background: #212121;
                    color: #d9d9d9;
                    white-space: pre-wrap;
                    overflow-x: auto;
                }}
            &lt;/style&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;h1&gt;Something went terribly wrong ({date})&lt;/h1&gt;

                {trace_content}

                &lt;p&gt;
                    Try &lt;a href=&#34;/&#34;&gt;Going back to the homepage&lt;/a&gt;, maybe?
                &lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
            &#34;#</i>,
            padding = <i>&#34;&lt;!-- Padding to avoid browser 500 error --&gt;\n&#34;</i>.repeat<i>(</i><i>10</i><i>)</i>,
            trace_content = trace_content
        <i>)</i><i>;</i>

        HttpError<i>::</i><i>Internal</i> { <i>err</i>: body }
    }
}

<i>macro_rules!</i> impl_from {
    <i>(</i>$from:ty<i>)</i> =&gt; {
        <i>impl</i> From&lt;$from&gt; <i>for</i> HttpError {
            <i>fn</i> from<i>(</i>err: $from<i>)</i> -&gt; Self {
                Self::from_report<i>(</i>err.into<i>(</i><i>)</i><i>)</i>
            }
        }
    }<i>;</i>
}

<i>impl_from</i><i>!</i><i>(</i>std::io::Error<i>)</i><i>;</i>
<i>impl_from</i><i>!</i><i>(</i>color_eyre::Report<i>)</i><i>;</i>
<i>impl_from</i><i>!</i><i>(</i>http::Error<i>)</i><i>;</i>
<i>impl_from</i><i>!</i><i>(</i>http::header::InvalidHeaderValue<i>)</i><i>;</i>
<i>impl_from</i><i>!</i><i>(</i>http::uri::InvalidUri<i>)</i><i>;</i>
<i>impl_from</i><i>!</i><i>(</i>serde_json::Error<i>)</i><i>;</i>
<i>impl_from</i><i>!</i><i>(</i>url::ParseError<i>)</i><i>;</i>
<i>impl_from</i><i>!</i><i>(</i>liquid_core::Error<i>)</i><i>;</i>
<i>impl_from</i><i>!</i><i>(</i>sqlx::Error<i>)</i><i>;</i>
<i>impl_from</i><i>!</i><i>(</i>crate::cached::CachedError<i>)</i><i>;</i>
<i>impl_from</i><i>!</i><i>(</i>futile_patreon::PatreonError<i>)</i><i>;</i>

<i>impl</i> <i>IntoResponse</i> <i>for</i> <i>HttpError</i> {
    <i>fn</i> <i>into_response</i><i>(</i><i>self</i><i>)</i> -&gt; <i>Response</i> {
        <i>match</i> <i>self</i> {
            HttpError<i>::</i><i>NotFound</i> { msg } =&gt; <i>(</i><i>StatusCode</i><i>::</i>NOT_FOUND, msg<i>)</i><i>.</i><i>into_response</i><i>(</i><i>)</i>,
            HttpError<i>::</i><i>Internal</i> { err } =&gt; <i>(</i>
                <i>StatusCode</i><i>::</i>INTERNAL_SERVER_ERROR,
                <i>[</i><i>(</i>header<i>::</i>CONTENT_TYPE, mime<i>::</i><i>html</i><i>(</i><i>)</i><i>)</i><i>]</i>,
                <i>inject_livereload</i><i>(</i><i>&amp;</i>err<i>)</i><i>.</i><i>to_string</i><i>(</i><i>)</i>,
            <i>)</i>
                <i>.</i><i>into_response</i><i>(</i><i>)</i>,
        }
    }
}
</pre></div>
<p>There&#39;s a <em>lot</em> here, and I&#39;m not going to comment everything, but essentially,
by default, things like deserialization errors etc., get turned into 500
Internal Server Errors, with a nice (colored!) stack trace in development and an
opaque error in production.</p>

                        <h2>
                            
                        </h2>
                        
<p>That means my handlers can return that type, and use <code>?</code> (unless I want to map
those errors to more precise status codes with nicer error pages):</p>
<div><p>Rust code</p><pre data-lang="rust"><i>#<i>[</i>axum<i>::</i>debug_handler<i>(</i>state = crate<i>::</i>serve<i>::</i>ServerState<i>)</i><i>]</i></i>
<i>pub</i> async <i>fn</i> <i>serve_login</i><i>(</i>
    State<i>(</i>state<i>)</i>: <i>State</i><i>&lt;</i><i>ServerState</i><i>&gt;</i>,
    <i>cookies</i>: <i>Cookies</i>,
    <i>params</i>: <i>Option</i><i>&lt;</i><i>Form</i><i>&lt;</i><i>ReturnTo</i><i>&gt;</i><i>&gt;</i>,
<i>)</i> -&gt; <i>HttpResult</i> {
    <i>let</i> cookies = state<i>.</i><i>private_cookies</i><i>(</i>cookies<i>)</i><i>;</i>

    <i>if</i> <i>let</i> Some<i>(</i>params<i>)</i> = params {
        <i>if</i> <i>let</i> Some<i>(</i>return_to<i>)</i> = params<i>.</i><i>return_to</i><i>.</i><i>as_ref</i><i>(</i><i>)</i> {
            <i>let</i> <i>mut</i> cookie = <i>Cookie</i><i>::</i><i>new</i><i>(</i><i>&#34;return_to&#34;</i>, return_to<i>.</i><i>to_owned</i><i>(</i><i>)</i><i>)</i><i>;</i>
            cookie<i>.</i><i>set_path</i><i>(</i><i>&#34;/&#34;</i><i>)</i><i>;</i>
            cookie<i>.</i><i>set_expires</i><i>(</i>time<i>::</i><i>OffsetDateTime</i><i>::</i><i>now_utc</i><i>(</i><i>)</i> + time<i>::</i><i>Duration</i><i>::</i><i>minutes</i><i>(</i><i>30</i><i>)</i><i>)</i><i>;</i>
            cookies<i>.</i><i>add</i><i>(</i>cookie<i>)</i><i>;</i>
        }
    }

    <i>let</i> location = <i>make_patreon_login_url</i><i>(</i><i>&amp;</i>state<i>.</i><i>config</i><i>)</i>?<i>;</i>
    <i>Redirect</i><i>::</i><i>to</i><i>(</i><i>&amp;</i>location<i>)</i><i>.</i><i>into_http</i><i>(</i><i>)</i>
}
</pre></div>
<p>The <a href="https://docs.rs/axum/0.5.17/axum/attr.debug_handler.html">axum::debug_handler
macro</a> is invaluable to
debug type errors (there&#39;s some with axum too), like for example, accidentally
having <a href="https://octodon.social/@fasterthanlime/109304454114856561">a non-Send type slip in</a>.
It let you specify which state type you&#39;re using in that application, which is
actually unnecessary here since it&#39;s also specified as an extractor, in this
here line:</p>
<div><p>Rust code</p><pre data-lang="rust">    State<i>(</i>state<i>)</i>: State&lt;ServerState&gt;,
</pre></div>
<p>Cookies are extracted, too, via <a href="https://lib.rs/crates/tower-cookies">tower-cookies</a>:</p>
<div><p>Rust code</p><pre data-lang="rust">    cookies: Cookies,
</pre></div>
<p>Lastly, query parameters are extracted (optionally) via the <code>Form</code> extractor:</p>
<div><p>Rust code</p><pre data-lang="rust">    params: Option&lt;Form&lt;ReturnTo&gt;&gt;,
</pre></div>
<p>The <code>ReturnTo</code> type is a struct that derives serde&#39;s <code>Deserialize</code>:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>#<i>[</i>derive<i>(</i>Deserialize<i>)</i><i>]</i></i>
<i>pub</i> <i>struct</i> <i>ReturnTo</i> {
    <i>#<i>[</i>serde<i>(</i>default<i>)</i><i>]</i></i>
    <i>return_to</i>: <i>Option</i><i>&lt;</i><i>String</i><i>&gt;</i>,
}
</pre></div>
<p>And that lets us decode a URL like
<code>/login?return_to=articles%2Fupdating-my-website-for-2022</code> into something nice
and strongly typed.</p>
<p>Each of these extractors implement <code>FromRequestParts</code>, which is something you
can just do yourself, so I ended up making up a <code>TemplateRenderer</code> extractor,
since, again, a lot of my website is dynamic, and templates take a lot of state
as input.</p>
<p>A handler using it looks something like:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>#<i>[</i>axum<i>::</i>debug_handler<i>(</i>state = crate<i>::</i>serve<i>::</i>ServerState<i>)</i><i>]</i></i>
async <i>fn</i> <i>atom_feed</i><i>(</i><i>tr</i>: <i>TemplateRenderer</i><i>)</i> -&gt; <i>HttpResult</i> {
    tr<i>.</i><i>render_ex</i><i>(</i>
        <i>&#34;index.xml&#34;</i>,
        <i>TemplateCacheBehavior</i><i>::</i>Cache,
        <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i>,
        mime<i>::</i><i>atom</i><i>(</i><i>)</i>,
    <i>)</i>
    <i>.</i>await
}
</pre></div>
<p>Or, even simpler:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>#<i>[</i>axum<i>::</i>debug_handler<i>(</i>state = crate<i>::</i>serve<i>::</i>ServerState<i>)</i><i>]</i></i>
<i>pub</i> async <i>fn</i> <i>serve</i><i>(</i><i>tr</i>: <i>TemplateRenderer</i><i>)</i> -&gt; <i>HttpResult</i> {
    tr<i>.</i><i>render</i><i>(</i><i>&#34;settings.html&#34;</i><i>)</i><i>.</i>await
}
</pre></div>
<p>The live-reload stuff, using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">server-sent
events</a>,
looks very similar, since <code>warp</code> and <code>axum</code> are using the same underlying
crates:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>#<i>[</i>axum<i>::</i>debug_handler<i>(</i>state = crate<i>::</i>serve<i>::</i>ServerState<i>)</i><i>]</i></i>
async <i>fn</i> <i>livereload</i><i>(</i>State<i>(</i>state<i>)</i>: <i>State</i><i>&lt;</i><i>ServerState</i><i>&gt;</i><i>)</i> -&gt; <i>HttpResult</i> {
    <i>fn</i> <i>make_stream</i><i>(</i><i>state</i>: <i>&amp;</i><i>ServerState</i><i>)</i> -&gt; <i>impl</i> <i>Stream</i><i>&lt;</i><i>Item</i> = <i>Result</i><i>&lt;</i>sse<i>::</i><i>Event</i>, <i>Infallible</i><i>&gt;</i><i>&gt;</i> {
        <i>let</i> <i>mut</i> rx = state<i>.</i><i>broadcast_rev</i><i>.</i><i>subscribe</i><i>(</i><i>)</i><i>;</i>
        async_stream<i>::</i>try_stream! {
            yield sse::Event::<i>default</i><i>(</i><i>)</i>.event<i>(</i><i>&#34;message&#34;</i><i>)</i>.data<i>(</i><i>&#34;Live reloading enabled&#34;</i><i>)</i>;

            <i>while</i> <i>let</i> Ok<i>(</i>rev_id<i>)</i> = rx.recv<i>(</i><i>)</i>.await {
                yield sse::Event::<i>default</i><i>(</i><i>)</i>.event<i>(</i><i>&#34;new-revision&#34;</i><i>)</i>.data<i>(</i>rev_id<i>)</i>;
            }
        }
    }

    <i>Sse</i><i>::</i><i>new</i><i>(</i><i>make_stream</i><i>(</i><i>&amp;</i>state<i>)</i><i>)</i>
        <i>.</i><i>keep_alive</i><i>(</i><i>KeepAlive</i><i>::</i><i>default</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>into_http</i><i>(</i><i>)</i>
}
</pre></div>
<p>(I also discovered I didn&#39;t need to do my own keep-alive handling — it&#39;s built
right in there!)</p>

                        <h2>
                            <a id="routing-in-axum-0-6" href="#routing-in-axum-0-6">
                                Routing in <code>axum</code> 0.6
                            </a>
                        </h2>
                        
<p>How are these routes composed then? Up until axum 0.5, I was very sad, because
routes like <code>/fixed</code> and <code>/*splat</code> used to conflict (you&#39;d get a runtime error
too, yuck). But as of 0.6 (currently in release candidate) they don&#39;t anymore!
The fixed one takes priority, and it falls back to the splat.</p>
<p>So, my whole router looks like this:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>pub</i> <i>fn</i> <i>all_routes</i><i>(</i><i>state</i>: <i>ServerState</i><i>)</i> -&gt; <i>Router</i><i>&lt;</i><i>ServerState</i><i>&gt;</i> {
    <i>Router</i><i>::</i><i>with_state</i><i>(</i>state<i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/robots.txt&#34;</i>, <i>get</i><i>(</i>robots_txt<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/api/livereload&#34;</i>, <i>get</i><i>(</i>livereload<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/tags&#34;</i>, <i>get</i><i>(</i>tags<i>::</i>serve_list<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/tags/:tag&#34;</i>, <i>get</i><i>(</i>tags<i>::</i>serve_single<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/settings&#34;</i>, <i>get</i><i>(</i>settings<i>::</i>serve<i>)</i><i>.</i><i>post</i><i>(</i>settings<i>::</i>save<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/search&#34;</i>, <i>get</i><i>(</i>search<i>::</i>serve<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/login&#34;</i>, <i>get</i><i>(</i>login<i>::</i>serve_login<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/debug-credentials&#34;</i>, <i>get</i><i>(</i>login<i>::</i>serve_debug_credentials<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/patreon/oauth&#34;</i>, <i>get</i><i>(</i>login<i>::</i>serve_patreon_oauth<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/logout&#34;</i>, <i>get</i><i>(</i>login<i>::</i>serve_logout<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/comments&#34;</i>, <i>get</i><i>(</i>comments<i>::</i>serve<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/patron-list&#34;</i>, <i>get</i><i>(</i>patron_list<i>::</i>serve<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/index.xml&#34;</i>, <i>get</i><i>(</i>atom_feed<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/&#34;</i>, <i>get</i><i>(</i>revision_routes<i>::</i>serve<i>)</i><i>)</i>
        <i>.</i><i>route</i><i>(</i><i>&#34;/*path&#34;</i>, <i>get</i><i>(</i>revision_routes<i>::</i>serve<i>)</i><i>)</i>
}
</pre></div>
<p>Different handlers can be set with method functions/methods like <code>get</code> and
<code>post</code> — and you get <code>HEAD</code> support for free for <code>get</code> handlers, as expected. Oh
and that type never &#34;gets bigger&#34; in a way that would cause compile-time
explosions.</p>
<p>You can do a bunch of interesting stuff like &#34;nest&#34; sub-routers, that I haven&#39;t
shown here. You might be wondering how extracting path elements works and
it&#39;s... through extractors, as usual!</p>
<p>Here&#39;s both routes for <code>/tags</code> and <code>/tags/:tag</code>:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>#<i>[</i>axum<i>::</i>debug_handler<i>(</i>state = crate<i>::</i>serve<i>::</i>ServerState<i>)</i><i>]</i></i>
<i>pub</i> async <i>fn</i> <i>serve_list</i><i>(</i><i>tr</i>: <i>TemplateRenderer</i><i>)</i> -&gt; <i>HttpResult</i> {
    tr<i>.</i><i>render</i><i>(</i><i>&#34;tags.html&#34;</i><i>)</i><i>.</i>await
}

<i>#<i>[</i>axum<i>::</i>debug_handler<i>(</i>state = crate<i>::</i>serve<i>::</i>ServerState<i>)</i><i>]</i></i>
<i>pub</i> async <i>fn</i> <i>serve_single</i><i>(</i><i>tr</i>: <i>TemplateRenderer</i>, Path<i>(</i>tag<i>)</i>: <i>Path</i><i>&lt;</i><i>String</i><i>&gt;</i><i>)</i> -&gt; <i>HttpResult</i> {
    <i>let</i> <i>mut</i> globals = <i>Object</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
    globals<i>.</i><i>insert</i><i>(</i><i>&#34;tag_name&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i>, <i>to_value</i><i>(</i><i>&amp;</i>tag<i>)</i>?<i>)</i><i>;</i>

    tr<i>.</i><i>render_ex</i><i>(</i>
        <i>&#34;tag.html&#34;</i>,
        <i>TemplateCacheBehavior</i><i>::</i>Cache,
        globals,
        mime<i>::</i><i>html</i><i>(</i><i>)</i>,
    <i>)</i>
    <i>.</i>await
}
</pre></div>
<p>(Note: the name that <code>Path</code> is destructured into doesn&#39;t matter, only order
matters).</p>
<p>I haven&#39;t shown how the whole app was started - here it is with <code>warp</code>:</p>
<div><p>Rust code</p><pre data-lang="rust"> <i>let</i> addr: <i>SocketAddr</i> = config<i>.</i><i>address</i><i>.</i><i>parse</i><i>(</i><i>)</i>?<i>;</i>

    <i>let</i> conns_limit = <i>Semaphore</i><i>::</i><i>new</i><i>(</i><i>2048</i><i>)</i><i>;</i>
    <i>let</i> svc = <i>ServiceBuilder</i><i>::</i><i>new</i><i>(</i><i>)</i>
        <i>.</i><i>layer</i><i>(</i><i>GlobalConcurrencyLimitLayer</i><i>::</i><i>new</i><i>(</i><i>2048</i><i>)</i><i>)</i>
        <i>.</i><i>layer</i><i>(</i><i>BanUserAgents</i><i>::</i><i>new</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>layer</i><i>(</i>RequestIdLayer<i>)</i>
        <i>.</i><i>layer</i><i>(</i><i>IncomingHttpSpanLayer</i><i>::</i><i>default</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>service</i><i>(</i>warp<i>::</i><i>service</i><i>(</i>all_routes<i>.</i><i>with</i><i>(</i>access_log<i>)</i><i>)</i><i>)</i><i>;</i>

    <i>let</i> factory = <i>ServiceFactory</i> {
        <i>inner</i>: svc,
        <i>semaphore</i>: <i>PollSemaphore</i><i>::</i><i>new</i><i>(</i><i>Arc</i><i>::</i><i>new</i><i>(</i>conns_limit<i>)</i><i>)</i>,
        <i>permit</i>: None,
    }<i>;</i>

    <i>let</i> acceptor = <i>timeout_acceptor</i><i>(</i>addr<i>)</i><i>;</i>
    <i>let</i> server = hyper<i>::</i><i>Server</i><i>::</i><i>builder</i><i>(</i>acceptor<i>)</i><i>.</i><i>serve</i><i>(</i>factory<i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;Listening on http://{}&#34;</i>, addr<i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;Base URL is {}&#34;</i>, config.base_url<i>)</i><i>;</i>
    server<i>.</i>await?<i>;</i>
</pre></div>
<p>And here it is with <code>axum</code>:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>let</i> addr: <i>SocketAddr</i> = config<i>.</i><i>address</i><i>.</i><i>parse</i><i>(</i><i>)</i>?<i>;</i>

    <i>let</i> acceptor = <i>timeout_acceptor</i><i>(</i>addr<i>)</i><i>;</i>
    <i>let</i> app = routes<i>::</i><i>all_routes</i><i>(</i>server_state<i>)</i><i>.</i><i>layer</i><i>(</i>
        <i>ServiceBuilder</i><i>::</i><i>new</i><i>(</i><i>)</i>
            <i>.</i><i>layer</i><i>(</i><i>GlobalConcurrencyLimitLayer</i><i>::</i><i>new</i><i>(</i><i>2048</i><i>)</i><i>)</i>
            <i>.</i><i>layer</i><i>(</i><i>TraceLayer</i><i>::</i><i>new_for_http</i><i>(</i><i>)</i><i>)</i>
            <i>.</i><i>layer</i><i>(</i><i>BanUserAgents</i><i>::</i><i>new</i><i>(</i><i>)</i><i>)</i>
            <i>.</i><i>layer</i><i>(</i>RequestIdLayer<i>)</i>
            <i>.</i><i>layer</i><i>(</i><i>IncomingHttpSpanLayer</i><i>::</i><i>default</i><i>(</i><i>)</i><i>)</i>
            <i>.</i><i>layer</i><i>(</i><i>CookieManagerLayer</i><i>::</i><i>new</i><i>(</i><i>)</i><i>)</i>,
    <i>)</i><i>;</i>
    <i>let</i> server = hyper<i>::</i><i>Server</i><i>::</i><i>builder</i><i>(</i>acceptor<i>)</i><i>.</i><i>serve</i><i>(</i>app<i>.</i><i>into_make_service</i><i>(</i><i>)</i><i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;Listening on http://{}&#34;</i>, addr<i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;Base URL is {}&#34;</i>, config.base_url<i>)</i><i>;</i>
    server<i>.</i>await?<i>;</i>
</pre></div>
<p>That&#39;s right, I was able to re-use almost all my custom tower layers with almost
no changes (I had to make one accept different body types, an annoying ordeal
I&#39;ve become exceedingly efficient at).</p>

                        <h2>
                            <a id="using-tower-cookies-properly" href="#using-tower-cookies-properly">
                                Using tower-cookies (properly)
                            </a>
                        </h2>
                        
<p>In the previous iteration, I was using the
<a href="https://lib.rs/crates/cookie">cookie</a> crate to allow users to log in. But I
don&#39;t think I ever properly understood how it was supposed to be used, so... I
came up with my own signing scheme (I didn&#39;t need them to be tamper-proof).</p>
<p>And I had code of my own to extract/set cookies. You&#39;ve seen that bit from the
warp version:</p>
<div><p>Rust code</p><pre data-lang="rust">                <i>let</i> <i>mut</i> cookies = <i>HashMap</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
                <i>if</i> <i>let</i> Some<i>(</i>ch<i>)</i> = cookie_header {
                    <i>for</i> cookie <i>in</i> ch
                        <i>.</i><i>split</i><i>(</i><i>&#39;;&#39;</i><i>)</i>
                        <i>.</i><i>map</i><i>(</i>|x| x<i>.</i><i>trim</i><i>(</i><i>)</i><i>)</i>
                        <i>.</i><i>filter_map</i><i>(</i>|x| <i>Cookie</i><i>::</i><i>parse_encoded</i><i>(</i>x<i>.</i><i>to_string</i><i>(</i><i>)</i><i>)</i><i>.</i><i>ok</i><i>(</i><i>)</i><i>)</i>
                    {
                        cookies<i>.</i><i>insert</i><i>(</i>cookie<i>.</i><i>name</i><i>(</i><i>)</i><i>.</i><i>to_string</i><i>(</i><i>)</i>, cookie<i>)</i><i>;</i>
                    }
                }
</pre></div>
<p>(Again I&#39;m sure there&#39;s a warpier way to do that and I was just being silly).</p>
<p>But you haven&#39;t seen that part:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>pub</i> <i>trait</i> <i>HasCookies</i> {
    <i>fn</i> <i>insert_cookie</i><i>(</i><i>self</i>, <i>c</i>: <i>Cookie</i><i>&lt;</i><i>&#39;</i><i>static</i><i>&gt;</i><i>)</i> -&gt; <i>Self</i><i>;</i>
    <i>fn</i> <i>remove_cookie</i><i>(</i><i>self</i>, <i>c</i>: <i>Cookie</i><i>&lt;</i><i>&#39;</i><i>static</i><i>&gt;</i><i>)</i> -&gt; <i>Self</i><i>;</i>
    <i>fn</i> <i>apply_session_cookies</i><i>(</i><i>self</i>, <i>sc</i>: <i>SessionCookies</i><i>)</i> -&gt; <i>Self</i><i>;</i>
}

<i>impl</i> <i>HasCookies</i> <i>for</i> http<i>::</i>response<i>::</i><i>Builder</i> {
    <i>fn</i> <i>insert_cookie</i><i>(</i><i>self</i>, <i>c</i>: <i>Cookie</i><i>&lt;</i><i>&#39;</i><i>static</i><i>&gt;</i><i>)</i> -&gt; <i>Self</i> {
        <i>self</i><i>.</i><i>header</i><i>(</i><i>&#34;set-cookie&#34;</i>, c<i>.</i><i>encoded</i><i>(</i><i>)</i><i>.</i><i>to_string</i><i>(</i><i>)</i><i>)</i>
    }
    <i>fn</i> <i>remove_cookie</i><i>(</i><i>self</i>, <i>mut</i> <i>c</i>: <i>Cookie</i><i>&lt;</i><i>&#39;</i><i>static</i><i>&gt;</i><i>)</i> -&gt; <i>Self</i> {
        c<i>.</i><i>set_expires</i><i>(</i>Some<i>(</i>
            time<i>::</i><i>OffsetDateTime</i><i>::</i><i>now_utc</i><i>(</i><i>)</i> - time<i>::</i><i>Duration</i><i>::</i><i>days</i><i>(</i><i>1</i><i>)</i>,
        <i>)</i><i>)</i><i>;</i>
        <i>self</i><i>.</i><i>insert_cookie</i><i>(</i>c<i>)</i>
    }
    <i>fn</i> <i>apply_session_cookies</i><i>(</i><i>self</i>, <i>sc</i>: <i>SessionCookies</i><i>)</i> -&gt; <i>Self</i> {
        sc<i>.</i><i>apply</i><i>(</i><i>self</i><i>)</i>
    }
}
</pre></div>
<p>Or that part:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>#<i>[</i>derive<i>(</i>Debug, Serialize, Deserialize<i>)</i><i>]</i></i>
<i>pub</i> <i>struct</i> <i>SignedCookie</i> {
    <i>pub</i> <i>signature</i>: <i>String</i>,
    <i>pub</i> <i>payload</i>: <i>String</i>,
}

<i>impl</i> <i>SignedCookie</i> {
    <i>pub</i> <i>fn</i> <i>new</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>config</i>: <i>&amp;</i><i>Config</i>, <i>payload</i>: <i>&amp;</i><i>T</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>Self</i><i>&gt;</i>
    <i>where</i>
        <i>T</i>: <i>Serialize</i>,
    {
        <i>let</i> payload = serde_json<i>::</i><i>to_string</i><i>(</i>payload<i>)</i>?<i>;</i>
        <i>let</i> signature =
            hmac_sha256<i>::</i><i>HMAC</i><i>::</i><i>mac</i><i>(</i>payload<i>.</i><i>as_bytes</i><i>(</i><i>)</i>, config<i>.</i><i>secrets</i><i>.</i><i>cookie_sauce</i><i>.</i><i>as_bytes</i><i>(</i><i>)</i><i>)</i><i>;</i>
        <i>let</i> signature = <i>format</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, HexSlice<i>(</i>&amp;signature<i>)</i><i>)</i><i>;</i>
        Ok<i>(</i><i>Self</i> { signature, payload }<i>)</i>
    }

    <i>pub</i> <i>fn</i> <i>get</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>&amp;</i><i>self</i>, <i>config</i>: <i>&amp;</i><i>Config</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>T</i><i>&gt;</i>
    <i>where</i>
        <i>T</i>: <i>DeserializeOwned</i>,
    {
        <i>let</i> actual_sig = hmac_sha256<i>::</i><i>HMAC</i><i>::</i><i>mac</i><i>(</i>
            <i>self</i><i>.</i><i>payload</i><i>.</i><i>as_bytes</i><i>(</i><i>)</i>,
            config<i>.</i><i>secrets</i><i>.</i><i>cookie_sauce</i><i>.</i><i>as_bytes</i><i>(</i><i>)</i>,
        <i>)</i><i>;</i>
        <i>let</i> actual_sig = <i>format</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, HexSlice<i>(</i>&amp;actual_sig<i>)</i><i>)</i><i>;</i>
        <i>if</i> <i>self</i><i>.</i><i>signature</i> != actual_sig {
            <i>return</i> Err<i>(</i><i>SignedCookieError</i><i>::</i>InvalidSignature<i>.</i><i>into</i><i>(</i><i>)</i><i>)</i><i>;</i>
        }

        <i>let</i> res = serde_json<i>::</i><i>from_str</i><i>(</i><i>&amp;</i><i>self</i><i>.</i><i>payload</i><i>)</i>?<i>;</i>
        Ok<i>(</i>res<i>)</i>
    }
}

<i>#<i>[</i>derive<i>(</i>Debug, thiserror<i>::</i>Error<i>)</i><i>]</i></i>
<i>enum</i> <i>SignedCookieError</i> {
    <i>#<i>[</i>error<i>(</i><i>&#34;invalid cookie signature&#34;</i><i>)</i><i>]</i></i>
    InvalidSignature,
}
</pre></div>
<p>Well, turns out, none of that is needed. As shown earlier,
<a href="https://lib.rs/crates/tower-cookies">tower-cookies</a> works well with <code>axum</code> (I
had to <a href="https://github.com/imbolc/tower-cookies/pull/18">fork it for 0.6
support</a>, since it&#39;s not stable
yet, but it was a simple change).</p>
<p>With <code>tower-cookies</code>, you get a <code>Cookies</code> jar, and you can call <code>get</code> / <code>add</code> /
<code>remove</code> at any time, and by the time your HTTP handler returns, it sets the
right headers.</p>
<p>Also, from a <code>Cookies</code> jar, you can derive a <code>SignedCookies</code> jar or a
<code>PrivateCookies</code> jar (I ended up using the latter), if you have a <a href="https://docs.rs/cookie/latest/cookie/struct.Key.html">cryptographic
master key</a>, which you can
derive from another master key, or trust the cookie crate to <a href="https://docs.rs/cookie/0.16.1/cookie/struct.Key.html#method.generate">generate from a
secure source</a> for you.</p>
<p>I don&#39;t have much code to show you here — the diff is strictly negative, I just
got rid of all my ad-hoc stuff and things worked out of the box.</p>
<p>Here&#39;s what the &#34;loading credentials from cookies&#34; code looks like now, with the
shiny new <a href="https://rust-lang.github.io/rfcs/3137-let-else.html">let-else</a>
feature and all:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>impl</i> <i>FutileCredentials</i> {
    <i>pub</i> async <i>fn</i> <i>load_from_cookies</i><i>(</i><i>config</i>: <i>&amp;</i><i>Config</i>, <i>cookies</i>: <i>&amp;</i><i>PrivateCookies</i><i>&lt;</i><i>&#39;</i><i>_</i><i>&gt;</i><i>)</i> -&gt; <i>Option</i><i>&lt;</i><i>Self</i><i>&gt;</i> {
        <i>let</i> cookie = cookies<i>.</i><i>get</i><i>(</i><i>Self</i><i>::</i>COOKIE_NAME<i>)</i>?<i>;</i>

        <i>let</i> creds: <i>Self</i> = <i>match</i> serde_json<i>::</i><i>from_str</i><i>(</i>cookie<i>.</i><i>value</i><i>(</i><i>)</i><i>)</i> {
            Ok<i>(</i>v<i>)</i> =&gt; v,
            Err<i>(</i>e<i>)</i> =&gt; {
                <i>warn</i><i>!</i><i>(</i>?e, <i>&#34;Got undeserializable cookie, removing&#34;</i><i>)</i><i>;</i>
                cookies<i>.</i><i>remove</i><i>(</i>cookie<i>)</i><i>;</i>
                <i>return</i> None<i>;</i>
            }
        }<i>;</i>

        <i>let</i> now = <i>Utc</i><i>::</i><i>now</i><i>(</i><i>)</i><i>;</i>
        <i>if</i> now &lt; creds<i>.</i><i>expires_at</i> {
            <i>// credentials aren&#39;t expired yet</i>
            <i>return</i> Some<i>(</i>creds<i>)</i><i>;</i>
        }

        <i>let</i> Some<i>(</i>patreon_credentials<i>)</i> = <i>&amp;</i>creds<i>.</i><i>patreon_credentials</i><i></i> <i>else</i> {
            warn<i>!</i><i>(</i><i>&#34;Don&#39;t know how to renew non-Patreon credentials&#34;</i><i>)</i><i>;</i>
            <i>return</i> None<i>;</i>
        }<i>;</i>

        <i>info</i><i>!</i><i>(</i>
            <i>&#34;Refreshing patreon credentials (expired at {:?}, is now {now:?})&#34;</i>,
            creds.expires_at,
        <i>)</i><i>;</i>

        <i>let</i> <i>mut</i> refresh_creds = patreon_credentials<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
        if is_development<i>(</i><i>)</i> &amp;&amp; test_patreon_renewal<i>(</i><i>)</i> {
            refresh_creds<i>.</i>access_token = <i>&#34;bad-token-for-testing&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i>
        }

        <i>// async because this hits the Patreon API</i>
        <i>let</i> creds = <i>match</i> refresh_creds<i>.</i><i>to_futile_credentials</i><i>(</i>config<i>)</i><i>.</i>await {
            Ok<i>(</i>creds<i>)</i> =&gt; creds,
            Err<i>(</i>e<i>)</i> =&gt; {
                <i>warn</i><i>!</i><i>(</i>?e, <i>&#34;Could not renew patreon credentials, will log out&#34;</i><i>)</i><i>;</i>
                cookies<i>.</i><i>remove</i><i>(</i>cookie<i>)</i><i>;</i>
                <i>return</i> None<i>;</i>
            }
        }<i>;</i>

        cookies<i>.</i><i>add</i><i>(</i>creds<i>.</i><i>as_cookie</i><i>(</i>config<i>)</i><i>)</i><i>;</i>
        Some<i>(</i>creds<i>)</i>
    }
}
</pre></div>
</div><div>
  
    
    
      
  

  

  


  







<div>
    <h2>Latest video</h2>









<div>
    
        
        
        
            
        

        

        
        

        
        
        
        
        
            
        
        
         
        
            
        
        
        <div>
            <a href="https://fasterthanli.me/videos/how-does-the-detour-crate-work">
                
                    
                    <div>
                        <picture>
                            <source type="image/avif" srcset="https://tube.fasterthanli.me/covers/how-the-detour-crate-works/cover.avif"/>
                            <source type="image/webp" srcset="https://tube.fasterthanli.me/covers/how-the-detour-crate-works/cover.webp"/>
                            <img alt="video cover image" src="https://tube.fasterthanli.me/covers/how-the-detour-crate-works/cover.jpg"/>
                        </picture>
                    </div>
                

                <span>
                    
                        
                        How does the detour crate work?
                    
                </span>
            </a>
            <div>
                <div>
                    <div>
                        <p>Oct 19, 2022</p>
                        
                            
                                
                                    <p>
                                        20 minute watch
                                    </p>
                                
                            
                        

                        
                            
                            
                        

                        
                        
                        
                            
                        
                        

                        
                        
                    </div>
                </div>

                <div>
                    
                        
                            
                            <p>We want to hook a function, so that our code gets called... but we also want the original code to execute. How the heck does that work?</p>
                        
                    
                </div>

                
                    <p><a href="https://fasterthanli.me/videos/how-does-the-detour-crate-work">
                        <span>
                            
                                Watch now
                            
                        </span>
                    </a>
                
            </p></div>
        </div>
    
</div>


    <p>You can watch more videos <a href="https://fasterthanli.me/videos">over there</a></p>
</div> <!-- Latest video -->

  
</div></div>
  </body>
</html>
