<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakelazaroff.com/words/making-crdts-98-percent-more-efficient/">Original</a>
    <h1>Making CRDTs 98% More Efficient</h1>
    
    <div id="readability-page-1" class="page"><div data-content="" data-astro-cid-rnrqlda2="">
<p>This was supposed to be a two-part blog post, but I got inspired to write a part three!</p>
<p>At the end of <a href="https://jakelazaroff.com/words/building-a-collaborative-pixel-art-editor-with-crdts/" data-astro-cid-bi7aps5f="">Building a Collaborative Pixel Art Editor with CRDTs</a><a data-tooltip="" href="https://jakelazaroff.com/words/building-a-collaborative-pixel-art-editor-with-crdts/" data-astro-cid-bi7aps5f=""><img src="https://jakelazaroff.com/og/building-a-collaborative-pixel-art-editor-with-crdts.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">Building a Collaborative Pixel Art Editor with CRDTs | jakelazaroff.com</span><span data-astro-cid-bi7aps5f="">CRDTs sound cool, but how are they actually used? Let&#39;s learn by building a collaborative pixel art editor.</span><span data-astro-cid-bi7aps5f=""><img src="https://jakelazaroff.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">jakelazaroff.com/words/building-a-collaborative-pixel-art-editor-with-crdts/</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>, we had just that: a fully functional collaborative pixel editor using state-based CRDTs. The drawback to state-based CRDTs is that you need to transmit the full state between peers to sync up. And our CRDT’s full state is pretty big! For a 100x100 image, it’s around 648kb. Yikes!</p>
<p>I won’t bury the lede: we’re going to reduce that by almost 98% to around 14kb. For context, that’s around half as big as the uncompressed image without any CRDT metadata. While we’ll never beat PNG, we can still do pretty well.</p>
<p>The benchmarks I’ll cite in this article are all based on this image I drew, which was encoded here using the same format we’ll create by the end of the post:<sup><a href="#user-content-fn-louvre" id="user-content-fnref-louvre" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">1</a></sup></p>
<compression-table foreshadow="true" url="/public/_example.0525116f.crdt"></compression-table>
<p>This playground uses the same pixel editor we built in the last post. You can change the color and brush size by clicking on the buttons below the canvas. The table to the right shows the size of the data in kilobytes. Right now, it just shows the size of the uncompressed data and the final result in our mystery format. As we compress our data further, we’ll add rows to the table showing how each format stacks up against the others, and their relative sizes.</p>
<p>Currently, our data looks something like this:</p>
<pre><code><span>{</span>
  <span>&#34;0,0&#34;</span><span>:</span> <span>[</span><span>&#34;0442197c-8144-47f7-ae64-340a2df3d796&#34;</span><span>,</span> <span>3</span><span>,</span> <span>[</span><span>255</span><span>,</span> <span>255</span><span>,</span> <span>255</span><span>]</span><span>]</span><span>,</span>
  <span>&#34;1,0&#34;</span><span>:</span> <span>[</span><span>&#34;0442197c-8144-47f7-ae64-340a2df3d796&#34;</span><span>,</span> <span>4</span><span>,</span> <span>[</span><span>255</span><span>,</span> <span>255</span><span>,</span> <span>255</span><span>]</span><span>]</span><span>,</span>
  <span>&#34;2,0&#34;</span><span>:</span> <span>[</span><span>&#34;0442197c-8144-47f7-ae64-340a2df3d796&#34;</span><span>,</span> <span>2</span><span>,</span> <span>null</span><span>]</span><span>,</span>
  <span>&#34;0,1&#34;</span><span>:</span> <span>[</span><span>&#34;4ae8bd76-e84c-4652-bcd8-a5e339c574f3&#34;</span><span>,</span> <span>2</span><span>,</span> <span>[</span><span>108</span><span>,</span> <span>79</span><span>,</span> <span>255</span><span>]</span><span>]</span><span>,</span>
  <span>&#34;1,1&#34;</span><span>:</span> <span>[</span><span>&#34;4ae8bd76-e84c-4652-bcd8-a5e339c574f3&#34;</span><span>,</span> <span>3</span><span>,</span> <span>[</span><span>108</span><span>,</span> <span>79</span><span>,</span> <span>255</span><span>]</span><span>]</span>
<span>}</span></code></pre>
<p>It’s just the JSON state of our LWW Map CRDT.<sup><a href="#user-content-fn-minify" id="user-content-fnref-minify" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">2</a></sup> Each key is a string of the pixel’s <em>(x,y)</em> coordinates, and each value is a LWW Register state: a tuple of a peer ID, a timestamp and an RGB value. If a pixel has been erased, its RGB value is <code>null</code>.</p>
<p>Here’s a blank canvas so you can see how quickly the size increases as you draw. Pay attention to the different formats as we go through the article: some will actually start out larger than our uncompressed data, but quickly become smaller as more pixels are drawn!</p>
<compression-table rows="1"></compression-table>
<h3 id="hex-codes">Hex Codes</h3>
<p>The easiest change to make is storing colors as hex codes rather than RGB tuples. As a reminder, here’s the type of each color:</p>
<pre><code><span>type</span> <span><span>RGB</span></span> <span>=</span> <span>[</span>red<span>:</span> <span>number</span><span>,</span> green<span>:</span> <span>number</span><span>,</span> blue<span>:</span> <span>number</span><span>]</span><span>;</span></code></pre>
<p>Each channel has between one and three digits, so our color values look something like this:</p>
<pre><code><span>[</span><span>1</span><span>,</span> <span>234</span><span>,</span> <span>56</span><span>]</span></code></pre>
<p>That’s ten characters: six for the numbers, two for the commas and two for the brackets. If each number had three digits, it would take up a whole 13 characters.</p>
<p>Hex codes come in at eight characters, max. By using sixteen digits (A–F representing the numbers 10–15) instead of our usual ten, we can represent each channel with two characters instead of three. Plus, since we know that each channel is two characters long, we can omit the commas.</p>
<p>There’s one more trick: if both characters in each channel are the same, we can omit one, which takes us down to five characters (including quotes). Here’s what the data looks like now:</p>
<pre><code><span>{</span>
  <span>&#34;0,0&#34;</span><span>:</span> <span>[</span><span>&#34;0442197c-8144-47f7-ae64-340a2df3d796&#34;</span><span>,</span> <span>3</span><span>,</span> <span>&#34;fff&#34;</span><span>]</span><span>,</span>
  <span>&#34;1,0&#34;</span><span>:</span> <span>[</span><span>&#34;0442197c-8144-47f7-ae64-340a2df3d796&#34;</span><span>,</span> <span>4</span><span>,</span> <span>&#34;fff&#34;</span><span>]</span><span>,</span>
  <span>&#34;2,0&#34;</span><span>:</span> <span>[</span><span>&#34;0442197c-8144-47f7-ae64-340a2df3d796&#34;</span><span>,</span> <span>2</span><span>,</span> <span>null</span><span>]</span><span>,</span>
  <span>&#34;0,1&#34;</span><span>:</span> <span>[</span><span>&#34;4ae8bd76-e84c-4652-bcd8-a5e339c574f3&#34;</span><span>,</span> <span>2</span><span>,</span> <span>&#34;6c4fff&#34;</span><span>]</span><span>,</span>
  <span>&#34;1,1&#34;</span><span>:</span> <span>[</span><span>&#34;4ae8bd76-e84c-4652-bcd8-a5e339c574f3&#34;</span><span>,</span> <span>4</span><span>,</span> <span>&#34;6c4fff&#34;</span><span>]</span>
<span>}</span></code></pre>
<p>All in all, using hex codes rather than RGB tuples gets us down from 648kb to 606kb — a 6% improvement. It’s a start, but we’ll need much bigger improvements than that if we’re going to get all the way down to 14kb.</p>
<compression-table rows="2"></compression-table>
<h3 id="uuid-table">UUID Table</h3>
<p>The next things to look at are the UUIDs. They’re a whopping 38 characters each (including quotes) and they show up in every single pixel. We could — and should! — remove the hyphens, but that will only shave off four characters per pixel. We need something more substantial.</p>
<p>Instead of keeping the UUIDs directly in each pixel, we’ll store them in a table. That way, they only appear once in the document. In their place, each pixel will store a table key that maps to the full UUID. When we need the full state back, we perform the same process in reverse, replacing each pixel’s table key with its corresponding UUID.</p>
<p>Here’s what the data looks like now. The 0th element of each array in <code>data</code> represents an index in the <code>uuids</code> array:</p>
<pre><code><span>{</span>
  <span>&#34;uuids&#34;</span><span>:</span> <span>[</span><span>&#34;0442197c814447f7ae64340a2df3d796&#34;</span><span>,</span> <span>&#34;4ae8bd76e84c4652bcd8a5e339c574f3&#34;</span><span>]</span><span>,</span>
  <span>&#34;data&#34;</span><span>:</span> <span>{</span>
    <span>&#34;0,0&#34;</span><span>:</span> <span>[</span><span>0</span><span>,</span> <span>3</span><span>,</span> <span>&#34;fff&#34;</span><span>]</span><span>,</span>
    <span>&#34;1,0&#34;</span><span>:</span> <span>[</span><span>0</span><span>,</span> <span>4</span><span>,</span> <span>&#34;fff&#34;</span><span>]</span><span>,</span>
    <span>&#34;2,0&#34;</span><span>:</span> <span>[</span><span>0</span><span>,</span> <span>2</span><span>,</span> <span>null</span><span>]</span><span>,</span>
    <span>&#34;0,1&#34;</span><span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>&#34;6c4fff&#34;</span><span>]</span><span>,</span>
    <span>&#34;1,1&#34;</span><span>:</span> <span>[</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>&#34;6c4fff&#34;</span><span>]</span>
  <span>}</span>
<span>}</span></code></pre>
<p>Our UUID table uses an array rather than a map, which has implied keys: the index of the item in the array. Using numbers as keys also saves two characters every time we reference a UUID, since we don’t need quotation marks as we would with strings.</p>
<p>This turns out to be a substantial savings, taking us down to 236kb — a 63% improvement!</p>
<compression-table rows="3"></compression-table>
<h3 id="palette-table">Palette Table</h3>
<p>We can use the exact same technique for the colors. Rather than storing each color directly in each pixel, we build a table of all the colors used and replace the hex codes in each pixel with table keys.</p>
<p>The last element of each array in <code>data</code> now represents an index in the <code>palette</code> array:</p>
<pre><code><span>{</span>
  <span>&#34;uuids&#34;</span><span>:</span> <span>[</span><span>&#34;0442197c814447f7ae64340a2df3d796&#34;</span><span>,</span> <span>&#34;4ae8bd76e84c4652bcd8a5e339c574f3&#34;</span><span>]</span><span>,</span>
  <span>&#34;palette&#34;</span><span>:</span> <span>[</span><span>&#34;fff&#34;</span><span>,</span> <span>&#34;6c4fff&#34;</span><span>]</span><span>,</span>
  <span>&#34;data&#34;</span><span>:</span> <span>{</span>
    <span>&#34;0,0&#34;</span><span>:</span> <span>[</span><span>0</span><span>,</span> <span>3</span><span>,</span> <span>0</span><span>]</span><span>,</span>
    <span>&#34;1,0&#34;</span><span>:</span> <span>[</span><span>0</span><span>,</span> <span>4</span><span>,</span> <span>0</span><span>]</span><span>,</span>
    <span>&#34;2,0&#34;</span><span>:</span> <span>[</span><span>0</span><span>,</span> <span>2</span><span>,</span> <span>null</span><span>]</span><span>,</span>
    <span>&#34;0,1&#34;</span><span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>]</span><span>,</span>
    <span>&#34;1,1&#34;</span><span>:</span> <span>[</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>]</span>
  <span>}</span>
<span>}</span></code></pre>
<p>Using a table like this seems strictly better, but there are some pathological scenarios in which it actually wastes space. Consider the case in which each color only appears once: we’d have the same number of colors as we have pixels, <strong>plus</strong> the overhead of mapping each pixel to a color in the table. Our current strategy works for pixel art, which tends to have a limited palette — but if we were dealing with photographs, we might want to choose another way to compress the color data.</p>
<p>In this case, the palette table slims us down to 187kb — 71% smaller than our uncompressed data.</p>
<compression-table rows="4"></compression-table>
<h3 id="run-length-encoding">Run-Length Encoding</h3>
<p>The next big things are the pixel coordinates — the map keys of our data object. With x and y each between one and three digits, these can take up to ten characters each (including the quotes and colon).</p>
<p>Remember how, when we were drawing to the screen, we mapped indices in the buffer to coordinates? We went down the array four bytes at a time, drawing to each pixel in the first row and wrapping around when we reached the end.</p>
<buffer-diagram width="3" height="3"></buffer-diagram>
<p>Here we’ll do the same thing, but in reverse. We’ll make the data an array, setting the pixel at <code>&#34;0,0&#34;</code> as the first element, <code>&#34;1,0&#34;</code> as the second element, etc.</p>
<p>This raises a new issue: how do we represent blank pixels, where no user has drawn yet? Before, they would just be missing from the map. But now we have to represent them — otherwise, every pixel after a blank space would be in the wrong place!</p>
<p>We could just put some sort of “spacer” value like <code>null</code> in the array where blank pixels would be. That’d work, but it would also waste a lot of space.</p>
<p>Instead, we’ll use something called <a href="https://en.wikipedia.org/wiki/Run-length_encoding" data-astro-cid-bi7aps5f="">run-length encoding</a><a data-tooltip="" href="https://en.wikipedia.org/wiki/Run-length_encoding" data-astro-cid-bi7aps5f=""><span data-astro-cid-bi7aps5f="">Run-length encoding - Wikipedia</span><span data-astro-cid-bi7aps5f=""><img src="https://en.wikipedia.org/static/favicon/wikipedia.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">en.wikipedia.org/wiki/Run-length_encoding</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>. It’s a very simple compression algorithm: when the same item appears consecutively in a sequence, instead of storing each item, store one of the item and the number of repeated instances.</p>
<p>Let’s take <a href="https://en.wikipedia.org/wiki/James_while_John_had_had_had_had_had_had_had_had_had_had_had_a_better_effect_on_the_teacher" data-astro-cid-bi7aps5f="">this weird sentence</a><a data-tooltip="" href="https://en.wikipedia.org/wiki/James_while_John_had_had_had_had_had_had_had_had_had_had_had_a_better_effect_on_the_teacher" data-astro-cid-bi7aps5f=""><span data-astro-cid-bi7aps5f="">James while John had had had had had had had had had had had a better effect on the teacher - Wikipedia</span><span data-astro-cid-bi7aps5f=""><img src="https://en.wikipedia.org/static/favicon/wikipedia.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">en.wikipedia.org/wiki/James_while_John_had_had_had_had_had_had_had_had_had_had_had_a_better_effect_on_the_teacher</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a> as an example:</p>
<blockquote>
<p>James while John had had had had had had had had had had had a better effect on the teacher.</p>
</blockquote>
<p>There’s a lot of repetition there. The sentence has 92 characters, and the word “had” appears eleven times!</p>
<p>With run-length encoding, the sentence might look like this:</p>
<blockquote>
<p>1James 1while 1John 11had 1a 1better 1effect 1on 1the 1teacher.</p>
</blockquote>
<p>The idea is that before each word, we add a number indicating how many consecutive times it shows up. That lets us skip every consecutive occurrence after the first. If we omit the spaces, this sentence has 54 characters — a 42% reduction from the original!</p>
<p>It’s not an all sunshine and lollipops, though. Consider <a href="https://en.wikipedia.org/wiki/The_quick_brown_fox_jumps_over_the_lazy_dog" data-astro-cid-bi7aps5f="">this classic pangram</a><a data-tooltip="" href="https://en.wikipedia.org/wiki/The_quick_brown_fox_jumps_over_the_lazy_dog" data-astro-cid-bi7aps5f=""><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2c/MetalTypeZoomIn.JPG/1200px-MetalTypeZoomIn.JPG" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">The quick brown fox jumps over the lazy dog - Wikipedia</span><span data-astro-cid-bi7aps5f=""><img src="https://en.wikipedia.org/static/favicon/wikipedia.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">en.wikipedia.org/wiki/The_quick_brown_fox_jumps_over_the_lazy_dog</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>:</p>
<blockquote>
<p>The quick brown fox jumps over the lazy dog.</p>
</blockquote>
<p>That sentence is 44 characters and no words repeat consecutively. Here’s what it might look like with run-length encoding:</p>
<blockquote>
<p>1The 1quick 1brown 1fox 1jumps 1over 1the 1lazy 1dog.</p>
</blockquote>
<p>53 characters — a 20% <strong>increase</strong>! What gives?</p>
<p>The issue is that when you compress something, you need to add metadata so that you can figure out what it looked like originally. Compression algorithms make assumptions about what patterns will occur in the original data in order to optimize the metadata. If the assumptions are right, the compressed data (including the metadata) is much smaller than the original data. But if the assumptions are wrong, the “compressed” data can even end up bigger than it was before!</p>
<p>Our assumption here is that run-length encoding will not be a good fit for LWW Register states, since there are three separate pieces of data that can vary independently. All blank spaces are the same, though, which makes them an excellent candidate for run-length encoding!</p>
<p>Rather than somehow representing each individual blank space in the array, we’ll store a number indicating how many consecutive blank spaces we came across. That lets us know exactly which coordinates the next pixel will be at.</p>
<p>Now that we’re no longer storing the coordinates of each pixel, we also need to store the width of the image. That way, when we’re decompressing the data, we know when the pixels should wrap onto the next row.</p>
<p>Here’s what the data looks like now. Since we’re now using a lot of numbers without any labels, I added some comments so it’s clear what everything is referring to.</p>
<pre><code><span>{</span>
  <span>&#34;uuids&#34;</span><span>:</span> <span>[</span><span>&#34;0442197c814447f7ae64340a2df3d796&#34;</span><span>,</span> <span>&#34;4ae8bd76e84c4652bcd8a5e339c574f3&#34;</span><span>]</span><span>,</span>
  <span>&#34;palette&#34;</span><span>:</span> <span>[</span><span>&#34;fff&#34;</span><span>,</span> <span>&#34;6c4fff&#34;</span><span>]</span><span>,</span>
  <span>&#34;width&#34;</span><span>:</span> <span>100</span><span>,</span>
  <span>&#34;data&#34;</span><span>:</span> <span>[</span>
    <span>[</span><span>/* uuid index */</span> <span>0</span><span>,</span> <span>/* timestamp */</span> <span>3</span><span>,</span> <span>/** palette index */</span> <span>0</span><span>]</span><span>,</span>
    <span>[</span><span>/* uuid index */</span> <span>0</span><span>,</span> <span>/* timestamp */</span> <span>4</span><span>,</span> <span>/** palette index */</span> <span>0</span><span>]</span><span>,</span>
    <span>[</span><span>/* uuid index */</span> <span>0</span><span>,</span> <span>/* timestamp */</span> <span>2</span><span>,</span> <span>/** palette index */</span> <span>null</span><span>]</span><span>,</span>
    <span>97</span><span>,</span> <span>// run of blank pixels</span>
    <span>[</span><span>/* uuid index */</span> <span>1</span><span>,</span> <span>/* timestamp */</span> <span>2</span><span>,</span> <span>/** palette index */</span> <span>1</span><span>]</span><span>,</span>
    <span>[</span><span>/* uuid index */</span> <span>1</span><span>,</span> <span>/* timestamp */</span> <span>3</span><span>,</span> <span>/** palette index */</span> <span>1</span><span>]</span>
  <span>]</span>
<span>}</span></code></pre>
<p>Notice how the <code>data</code> array is not homogenous: it contains either a tuple of peer ID, timestamp and color ID <strong>or</strong> a number indicating how many consecutive blank spaces there are.</p>
<p>Using run-length encoding brings us to 129kb — just over 80% smaller than our uncompressed data. We’re doing pretty well, but those last few percentage points are the trickiest ones to eke out. We’re gonna need to try something new.</p>
<compression-table rows="5"></compression-table>
<h3 id="binary-encoding">Binary Encoding</h3>
<p>So far, we’re at just more than an 80% decrease. That’s pretty good, and we could probably get it even smaller if we stopped using JSON. But we’re running into a fundamental limit: it’s inefficient to store things as text. To get much further, we’ll need to use <a href="https://en.wikipedia.org/wiki/Binary_file" data-astro-cid-bi7aps5f="">binary encoding</a><a data-tooltip="" href="https://en.wikipedia.org/wiki/Binary_file" data-astro-cid-bi7aps5f=""><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/76/Wikipedia_favicon_hexdump.svg/1200px-Wikipedia_favicon_hexdump.svg.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">Binary file - Wikipedia</span><span data-astro-cid-bi7aps5f=""><img src="https://en.wikipedia.org/static/favicon/wikipedia.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">en.wikipedia.org/wiki/Binary_file</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>.</p>
<p>When we’re using a plain text format like JSON, we think in characters. When we’re using binary encoding, we think in bytes. A byte holds an integer from <code>0</code> to <code>255</code>. If we consider groups of bytes as a single unit, it can hold much higher numbers — for example, two bytes can hold up to <code>65535</code>.<sup><a href="#user-content-fn-uint8array" id="user-content-fnref-uint8array" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">3</a></sup></p>
<p>The numbers can represent anything we want them to. One common way to interpret them is as <a href="https://en.wikipedia.org/wiki/ASCII" data-astro-cid-bi7aps5f="">ASCII</a><a data-tooltip="" href="https://en.wikipedia.org/wiki/ASCII" data-astro-cid-bi7aps5f=""><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/USASCII_code_chart.png/1200px-USASCII_code_chart.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">ASCII - Wikipedia</span><span data-astro-cid-bi7aps5f=""><img src="https://en.wikipedia.org/static/favicon/wikipedia.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">en.wikipedia.org/wiki/ASCII</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>, meaning each number corresponds to an alphanumeric character. Another way is just as the number they hold, meaning a byte that holds <code>127</code> would represent the number 127. We’ll interpret bytes in a few different ways as we create our format.</p>
<p>We’ll define a format similar to <a href="https://en.wikipedia.org/wiki/Resource_Interchange_File_Format" data-astro-cid-bi7aps5f="">RIFF</a><a data-tooltip="" href="https://en.wikipedia.org/wiki/Resource_Interchange_File_Format" data-astro-cid-bi7aps5f=""><span data-astro-cid-bi7aps5f="">Resource Interchange File Format - Wikipedia</span><span data-astro-cid-bi7aps5f=""><img src="https://en.wikipedia.org/static/favicon/wikipedia.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">en.wikipedia.org/wiki/Resource_Interchange_File_Format</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>, which serves as the basis for file types like WAV and AVI. It’s made up of “chunks”, each of which has two sections: “data”, which is the actual information we need to store, and a “header” that identifies the chunk type and tells us how to actually parse the bytes in the data.</p>
<p>First, binary files usually have a <a href="https://en.m.wikipedia.org/wiki/File_format#Magic_number" data-astro-cid-bi7aps5f="">magic number</a><a data-tooltip="" href="https://en.m.wikipedia.org/wiki/File_format#Magic_number" data-astro-cid-bi7aps5f=""><span data-astro-cid-bi7aps5f="">File format - Wikipedia</span><span data-astro-cid-bi7aps5f=""><img src="https://en.m.wikipedia.org/static/favicon/wikipedia.ico#Magic_number" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">en.m.wikipedia.org/wiki/File_format#Magic_number</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a> that identifies the format. Ours will represent the ASCII text <code>CRDT</code>, so the first four bytes of the file will be <code>43 52 44 54</code>.<sup><a href="#user-content-fn-base16" id="user-content-fnref-base16" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">4</a></sup> That goes in the “info” chunk, along with the width of our artboard.</p>
<p>Here’s a diagram of the binary file. The first part contains a human-readable overview; all the data is labeled, and the values are in a format that makes sense to us (for example, you can see that the magic number reads “CRDT” and that the artboard is 100 pixels wide). The second column contains the raw bytes in the file; each byte shows its index in the file and the hex digits representing its number from <code>0</code> to <code>255</code> (or <code>00</code> to <code>ff</code> in hex). You can hover over data on the left and see the corresponding bytes highlighted, and vice versa.</p>
<binary-visualizer buffer="[[[[&#34;txt&#34;, &#34;magic number&#34;, &#34;CRDT&#34;], [&#34;u16&#34;, &#34;artboard width&#34;, 100]], []]]"></binary-visualizer>
<p>After the info chunk, the file has three more chunks: one to hold our UUID table, one to hold our palette table and one to hold our pixel data.</p>
<p>We’ll start with the UUID chunk. The header consists of two parts:</p>
<ol>
<li>Four bytes that read <code>UUID</code> in ASCII.</li>
<li>Two bytes that represent the length of the rest of the chunk in bytes.<sup><a href="#user-content-fn-bounds" id="user-content-fnref-bounds" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">5</a></sup></li>
</ol>
<binary-visualizer buffer="[[[[&#34;txt&#34;, &#34;chunk type&#34;, &#34;UUID&#34;], [&#34;u16&#34;, &#34;chunk length&#34;, 32]], []]]" chunk-start="1"></binary-visualizer>
<p>The UUID chunk’s data is just all the peer UUIDs, one after the other. These each took up 34 characters (including quotes) in our JSON, but here we can represent each of them in a mere 16 bytes. Just like before, the key will be the index of each UUID — so the first one in the chunk will be <code>0</code>, the second will be <code>1</code>, etc.</p>
<p>Here’s the full UUID chunk. Each white block represents one item in the chunk data — in this case, a UUID:</p>
<binary-visualizer buffer="[[[[&#34;txt&#34;, &#34;chunk type&#34;, &#34;UUID&#34;], [&#34;u16&#34;, &#34;chunk length&#34;, 32]], [[&#34;hex&#34;, &#34;uuid 0&#34;, &#34;0442197c814447f7ae64340a2df3d796&#34;], [&#34;hex&#34;, &#34;uuid 1&#34;, &#34;4ae8bd76e84c4652bcd8a5e339c574f3&#34;]]]]" chunk-start="1"></binary-visualizer>
<p>The next chunk is the palette chunk. The header looks similar to the UUID chunk header:</p>
<ol>
<li>Four bytes that read <code>PLTT</code> in ASCII.<sup><a href="#user-content-fn-missing" id="user-content-fnref-missing" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">6</a></sup></li>
<li>Two bytes that represent the length of the rest of the chunk in bytes.</li>
</ol>
<binary-visualizer buffer="[[[[&#34;txt&#34;, &#34;chunk type&#34;, &#34;PLTT&#34;], [&#34;u16&#34;, &#34;chunk length&#34;, 9]], []]]" chunk-start="2"></binary-visualizer>
<p>The palette chunk’s data is also similar to the UUID chunk’s data: all the colors, one after the other. When we represented these with hex codes, they took up either five or eight bytes, but here we can represent each one in a concise three bytes — one for each RGB color channel.<sup><a href="#user-content-fn-rgb" id="user-content-fnref-rgb" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">7</a></sup></p>
<p>This chunk has one extra quirk: when writing to the data, we skip the first item’s place (so the first color starts as the fourth byte of data, or tenth byte including the header). That might not make sense now, but we’ll learn why in a minute.</p>
<p>Here’s the full palette chunk:</p>
<binary-visualizer buffer="[[[[&#34;txt&#34;, &#34;chunk type&#34;, &#34;PLTT&#34;], [&#34;u16&#34;, &#34;chunk length&#34;, 9]], [[&#34;rgb&#34;, &#34;color 0&#34;, [0,0,0]], [&#34;rgb&#34;, &#34;color 1&#34;, [255,255,255]], [&#34;rgb&#34;, &#34;color 2&#34;, [108,79,255]]]]]" chunk-start="2"></binary-visualizer>
<p>The last chunk is the data chunk. You know the drill by now:</p>
<ol>
<li>Four bytes that read <code>DATA</code> in ASCII.</li>
<li>Two bytes that represent the length of the rest of the chunk in bytes.</li>
</ol>
<binary-visualizer buffer="[[[[&#34;txt&#34;, &#34;chunk type&#34;, &#34;DATA&#34;], [&#34;u16&#34;, &#34;chunk length&#34;, 23]], []]]" chunk-start="3"></binary-visualizer>
<p>That’s the header. There are two types of items that can appear in the data chunk: pixels and blanks. Each item will start with a single byte “tag” indicating which type it is — <code>0</code> for blank and <code>1</code> for pixel.</p>
<p>Blank items are easy. After the tag, they have two single bytes indicating how many consecutive blank spaces they represent.</p>
<binary-visualizer buffer="[[[], [[&#34;item&#34;, [&#34;u8&#34;, &#34;blank tag&#34;, &#34;0&#34;], [&#34;u16&#34;, &#34;run length&#34;, 97]]]]]" chunk-start="3"></binary-visualizer>
<p>There’s a tradeoff here: by using two bytes to indicate the run length, a single blank item can represent up to 65,535 blank spaces. But then every blank item needs to use two bytes to represent the number of spaces — even if none of them need the second byte. If we used one byte, it would mean each blank item is more compact, but if there are more than 255 blank pixels in a row we’d need to use two or more consecutive blank items to represent them.</p>
<p>Pixel items are a bit more complicated. Remember, each pixel is really a LWW Register, which has three pieces of information: the peer ID that last wrote to the register, the timestamp and the value. After the tag, a pixel item has a section for each one:</p>
<ol>
<li>A byte for the peer ID, indicating its index in the UUID chunk.</li>
<li>A byte for the timestamp.<sup><a href="#user-content-fn-maxtimestamp" id="user-content-fnref-maxtimestamp" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">8</a></sup></li>
<li>A byte for the color, indicating its index in the palette chunk.</li>
</ol>
<binary-visualizer buffer="[[[], [[&#34;item&#34;, [&#34;u8&#34;, &#34;pixel tag&#34;, &#34;1&#34;], [&#34;u8&#34;, &#34;uuid index&#34;, &#34;0&#34;], [&#34;u8&#34;, &#34;timestamp&#34;, 3], [&#34;u8&#34;, &#34;palette index&#34;, 1]]]]]" chunk-start="3"></binary-visualizer>
<p>We also need a way to store erased pixels. In the JSON format, we stored <code>null</code> as a way to indicate that the pixel had been added and then erased. In binary, there’s no <code>null</code> — all we have are bytes. That’s why we skipped the first three bytes when writing the palette chunk: we know that no color will use the <code>0</code> index. If any pixel has <code>0</code> as its index, that pixel was erased.</p>
<p>Here’s our full file. As you hover over pixel data that refers to items in the UUID and palette chunks, you’ll see arrows pointing back to the actual data in those chunks.</p>
<binary-visualizer buffer="[[[[&#34;txt&#34;,&#34;magic number&#34;,&#34;CRDT&#34;],[&#34;u16&#34;,&#34;artboard width&#34;,100]],[]],[[[&#34;txt&#34;,&#34;chunk tag&#34;,&#34;UUID&#34;],[&#34;u16&#34;,&#34;chunk length&#34;,32]],[[&#34;hex&#34;,&#34;uuid 0&#34;,&#34;0442197c814447f7ae64340a2df3d796&#34;,{&#34;id&#34;:&#34;uuid0&#34;}],[&#34;hex&#34;,&#34;uuid 1&#34;,&#34;4ae8bd76e84c4652bcd8a5e339c574f3&#34;,{&#34;id&#34;:&#34;uuid1&#34;}]]],[[[&#34;txt&#34;,&#34;chunk tag&#34;,&#34;PLTT&#34;],[&#34;u16&#34;,&#34;chunk length&#34;,9]],[[&#34;rgb&#34;,&#34;blank color&#34;,[0,0,0],{&#34;id&#34;:&#34;color0&#34;}],[&#34;rgb&#34;,&#34;color 1&#34;,[255,255,255],{&#34;id&#34;:&#34;color1&#34;}],[&#34;rgb&#34;,&#34;color 2&#34;,[108,79,255],{&#34;id&#34;:&#34;color2&#34;}]]],[[[&#34;txt&#34;,&#34;chunk type&#34;,&#34;DATA&#34;], [&#34;u16&#34;,&#34;chunk length&#34;,23]],[[&#34;item&#34;,[&#34;u8&#34;,&#34;pixel tag&#34;,1],[&#34;u8&#34;,&#34;uuid index&#34;,0,{&#34;target&#34;:&#34;uuid0&#34;}],[&#34;u8&#34;,&#34;timestamp&#34;,3],[&#34;u8&#34;,&#34;palette index&#34;,1,{&#34;target&#34;:&#34;color1&#34;}]],[&#34;item&#34;,[&#34;u8&#34;,&#34;pixel tag&#34;,1],[&#34;u8&#34;,&#34;uuid index&#34;,0,{&#34;target&#34;:&#34;uuid0&#34;}],[&#34;u8&#34;,&#34;timestamp&#34;,4],[&#34;u8&#34;,&#34;palette index&#34;,1,{&#34;target&#34;:&#34;color1&#34;}]],[&#34;item&#34;,[&#34;u8&#34;,&#34;pixel tag&#34;,1],[&#34;u8&#34;,&#34;uuid index&#34;,0,{&#34;target&#34;:&#34;uuid0&#34;}],[&#34;u8&#34;,&#34;timestamp&#34;,2],[&#34;u8&#34;,&#34;palette index&#34;,0,{&#34;target&#34;:&#34;color0&#34;}]],[&#34;item&#34;,[&#34;u8&#34;,&#34;blank tag&#34;,0],[&#34;u16&#34;,&#34;run length&#34;,97]],[&#34;item&#34;,[&#34;u8&#34;,&#34;pixel tag&#34;,1],[&#34;u8&#34;,&#34;uuid index&#34;,1,{&#34;target&#34;:&#34;uuid1&#34;}],[&#34;u8&#34;,&#34;timestamp&#34;,2],[&#34;u8&#34;,&#34;palette index&#34;,2,{&#34;target&#34;:&#34;color2&#34;}]],[&#34;item&#34;,[&#34;u8&#34;,&#34;pixel tag&#34;,1],[&#34;u8&#34;,&#34;uuid index&#34;,1,{&#34;target&#34;:&#34;uuid1&#34;}],[&#34;u8&#34;,&#34;timestamp&#34;,3],[&#34;u8&#34;,&#34;palette index&#34;,2,{&#34;target&#34;:&#34;color2&#34;}]]]]]"></binary-visualizer>
<p>This gets us down to just 40kb. An RGB color takes up three bytes, and at this size we’re representing it with only a single byte of overhead! At an almost 94% reduction from the uncompressed data, we’ve already done a great job and could probably stop here if we wanted. But we can take it even further.</p>
<compression-table rows="6"></compression-table>
<h3 id="run-length-binary-encoding">Run-Length Binary Encoding</h3>
<p>We’re in the home stretch now. The info, UUID and palette chunks are about as compact as can be, but we can save a bunch of space in the data chunk.</p>
<p>If you recall a couple sections ago, the reason we run-length encoded the only blank spaces was that each pixel had three pieces of information that could vary independently: the timestamp, the peer ID of the last writer and the color. We’re going to split those up into individual chunks — one for each piece of information. Within each chunk, there will be only one single thing that can vary between items, which will let us use run-length encoding on each individual piece of data. So instead of one data chunk, we’ll have three: a writer chunk, a color chunk and a timestamp chunk.</p>
<p>The writer and color chunks are very similar to each other. Their headers have four bytes that read <code>WRTR</code> (for the writer chunk) or <code>COLR</code> (for the color chunk) in ASCII and two bytes for the length of the rest of the chunk in bytes. Each item in these chunks takes up three bytes: one for the index of the corresponding item in the UUID or palette chunk, and two for the length of the run.</p>
<binary-visualizer buffer="[[[[&#34;txt&#34;,&#34;chunk type&#34;,&#34;WRTR&#34;],[&#34;u16&#34;,&#34;chunk length&#34;,6]],[[&#34;item&#34;,[&#34;u8&#34;,&#34;uuid index&#34;,0],[&#34;u16&#34;,&#34;run length&#34;,100]],[&#34;item&#34;,[&#34;u8&#34;,&#34;uuid index&#34;,1],[&#34;u16&#34;,&#34;run length&#34;,2]]]],[[[&#34;txt&#34;,&#34;chunk type&#34;,&#34;COLR&#34;],[&#34;u16&#34;,&#34;chunk length&#34;,9]],[[&#34;item&#34;,[&#34;u8&#34;,&#34;palette index&#34;,1],[&#34;u16&#34;,&#34;run length&#34;,2]],[&#34;item&#34;,[&#34;u8&#34;,&#34;palette index&#34;,0],[&#34;u16&#34;,&#34;run length&#34;,98]],[&#34;item&#34;,[&#34;u8&#34;,&#34;palette index&#34;,2],[&#34;u16&#34;,&#34;run length&#34;,2]]]]]" chunk-start="3"></binary-visualizer>
<p>You might notice that there are two items in the writer data, but three items in the color data. It means that — going from the top left pixel to the bottom right — the peer who wrote to each pixel changes twice, but the color changes three times. Because we’re now keeping track of each kind of data separately, we can compress them without worrying about the others.<sup><a href="#user-content-fn-confusing" id="user-content-fnref-confusing" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">9</a></sup></p>
<p>The final chunk is the timestamp chunk. The header has four bytes that read <code>TIME</code> in ASCII, and two bytes for the length of the data items in bytes. Each item in the timestamp chunk starts with a single byte representing the timestamp of that pixel. We can use a clever trick here to disambiguate blank pixels from drawn pixels. When we instantiate a LWW Register, the timestamp is set to <code>1</code>. There will never be a register with a timestamp of <code>0</code>, which means we can use that value to indicate a blank pixel.</p>
<p>We’ll use the same run-length encoding strategy from the previous binary format. If the timestamp is a positive number, the next byte will be the next timestamp. But if the timestamp is <code>0</code>, we’ll interpret the next two bytes as the length of the run of blank pixels.<sup><a href="#user-content-fn-porquenolosdos" id="user-content-fnref-porquenolosdos" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">10</a></sup></p>
<binary-visualizer buffer="[[[[&#34;txt&#34;,&#34;chunk type&#34;,&#34;TIME&#34;],[&#34;u16&#34;,&#34;chunk length&#34;,8]],[[&#34;u8&#34;,&#34;timestamp&#34;,3],[&#34;u8&#34;,&#34;timestamp&#34;,4],[&#34;u8&#34;,&#34;timestamp&#34;,2],[&#34;item&#34;,[&#34;u8&#34;,&#34;timestamp&#34;,0],[&#34;u16&#34;,&#34;run-length&#34;,97]],[&#34;u8&#34;,&#34;timestamp&#34;,2],[&#34;u8&#34;,&#34;timestamp&#34;,3]]]]" chunk-start="5"></binary-visualizer>
<p>That also lets us save a bit of space by ignoring runs of blank pixels in the writer and color chunks, by which I mean that a blank pixel doesn’t end the run of a UUID or color. Only when we see a different UUID or color do we start a new run. We consider the timestamp chunk to be the ultimate authority on whether a pixel is blank: if the timestamp is <code>0</code>, then it doesn’t matter what we think the UUID or color is.</p>
<p>Here’s the full file:</p>
<binary-visualizer buffer="[[[[&#34;txt&#34;,&#34;magic number&#34;,&#34;CRDT&#34;],[&#34;u16&#34;,&#34;artboard width&#34;,100]],[]],[[[&#34;txt&#34;,&#34;chunk tag&#34;,&#34;UUID&#34;],[&#34;u16&#34;,&#34;chunk length&#34;,32]],[[&#34;hex&#34;,&#34;uuid 0&#34;,&#34;0442197c814447f7ae64340a2df3d796&#34;,{&#34;id&#34;:&#34;uuid0&#34;}],[&#34;hex&#34;,&#34;uuid 1&#34;,&#34;4ae8bd76e84c4652bcd8a5e339c574f3&#34;,{&#34;id&#34;:&#34;uuid1&#34;}]]],[[[&#34;txt&#34;,&#34;chunk tag&#34;,&#34;PLTT&#34;],[&#34;u16&#34;,&#34;chunk length&#34;,9]],[[&#34;rgb&#34;,&#34;blank color&#34;,[0,0,0],{&#34;id&#34;:&#34;color0&#34;}],[&#34;rgb&#34;,&#34;color 1&#34;,[255,255,255],{&#34;id&#34;:&#34;color1&#34;}],[&#34;rgb&#34;,&#34;color 2&#34;,[108,79,255],{&#34;id&#34;:&#34;color2&#34;}]]],[[[&#34;txt&#34;,&#34;chunk type&#34;,&#34;WRTR&#34;],[&#34;u16&#34;,&#34;chunk length&#34;,6]],[[&#34;item&#34;,[&#34;u8&#34;,&#34;uuid index&#34;,0,{&#34;target&#34;:&#34;uuid0&#34;}],[&#34;u16&#34;,&#34;run length&#34;,100]],[&#34;item&#34;,[&#34;u8&#34;,&#34;uuid index&#34;,1,{&#34;target&#34;:&#34;uuid1&#34;}],[&#34;u16&#34;,&#34;run length&#34;,2]]]],[[[&#34;txt&#34;,&#34;chunk type&#34;,&#34;COLR&#34;],[&#34;u16&#34;,&#34;chunk length&#34;,9]],[[&#34;item&#34;,[&#34;u8&#34;,&#34;palette index&#34;,1,{&#34;target&#34;:&#34;color1&#34;}],[&#34;u16&#34;,&#34;run length&#34;,2]],[&#34;item&#34;,[&#34;u8&#34;,&#34;palette index&#34;,0,{&#34;target&#34;:&#34;color0&#34;}],[&#34;u16&#34;,&#34;run length&#34;,98]],[&#34;item&#34;,[&#34;u8&#34;,&#34;palette index&#34;,2,{&#34;target&#34;:&#34;color2&#34;}],[&#34;u16&#34;,&#34;run length&#34;,2]]]],[[[&#34;txt&#34;,&#34;chunk type&#34;,&#34;TIME&#34;],[&#34;u16&#34;,&#34;chunk length&#34;,8]],[[&#34;u8&#34;,&#34;timestamp&#34;,3],[&#34;u8&#34;,&#34;timestamp&#34;,4],[&#34;u8&#34;,&#34;timestamp&#34;,2],[&#34;item&#34;,[&#34;u8&#34;,&#34;timestamp&#34;,0],[&#34;u16&#34;,&#34;run-length&#34;,97]],[&#34;u8&#34;,&#34;timestamp&#34;,2],[&#34;u8&#34;,&#34;timestamp&#34;,3]]]]"></binary-visualizer>
<p>This version of our format comes in at 14kb. That’s a 98% decrease from our initial 648kb, and it’s 50% smaller than the uncompressed RGB data — we’re using less than one and a half bytes per pixel!</p>
<compression-table rows="7"></compression-table>
<p>If you’re curious how the formats stack up when the canvas isn’t blank, here’s the benchmark image with all compression formats compared:</p>
<compression-table rows="7" url="/public/_example.0525116f.crdt"></compression-table>
<h3 id="conclusion">Conclusion</h3>
<p>As you can see, even though state-based CRDTs require their whole state to be synced between peers, it’s possible to for the actual data transferred to be significantly more efficient. We took a CRDT state weighing in at 648kb and reduced its size by almost 98% to only 14kb!</p>
<p>The optimization techniques here are inspired by Martin Kleppmann’s video <a href="https://youtu.be/x7drE24geUw?si=9Z9Rl-wVwV2Hhj83&amp;t=3587" data-astro-cid-bi7aps5f="">CRDTs: The Hard Parts</a><a data-tooltip="" href="https://youtu.be/x7drE24geUw?si=9Z9Rl-wVwV2Hhj83&amp;t=3587" data-astro-cid-bi7aps5f=""><img src="https://i.ytimg.com/vi/x7drE24geUw/maxresdefault.jpg" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">CRDTs: The Hard Parts</span><span data-astro-cid-bi7aps5f="">A talk on the latest research on CRDTs, originally given at the Hydra distributed computing conference on 6 July 2020.References: https://martin.kleppmann.co...</span><span data-astro-cid-bi7aps5f=""><img src="https://www.youtube.com/s/desktop/cc87ee3e/img/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">youtu.be/x7drE24geUw?si=9Z9Rl-wVwV2Hhj83&amp;t=3587</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>. He and <a href="https://www.inkandswitch.com" data-astro-cid-bi7aps5f="">Ink and Switch</a><a data-tooltip="" href="https://www.inkandswitch.com" data-astro-cid-bi7aps5f=""><img src="https://www.inkandswitch.com/assets/logo-favicon-196x196.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">Ink &amp; Switch</span><span data-astro-cid-bi7aps5f="">Industrial research lab working on digital tools for creativity and productivity</span><span data-astro-cid-bi7aps5f=""><img src="https://www.inkandswitch.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">www.inkandswitch.com</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a> managed to reduce the gzipped size of a 100kb plain text file with CRDT metadata to only 114kb — less than a 10% increase over the uncompressed plain text data (and compressing text is significantly harder than the pixel data example we just went through).</p>
<p>This all might seem like a lot of busywork to get back to a reasonable baseline. But in practice, there are CRDT libraries available that have already made these or similar optimizations for you, including but not limited to:</p>

<p>There’s also a great website called <a href="https://crdt.tech/implementations" data-astro-cid-bi7aps5f="">crdt.tech</a><a data-tooltip="" href="https://crdt.tech/implementations" data-astro-cid-bi7aps5f=""><img src="https://crdt.tech/assets/img/crdt-favicon.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">Code • Conflict-free Replicated Data Types</span><span data-astro-cid-bi7aps5f="">Resources and community around CRDT technology — papers, blog posts, code and more.</span><span data-astro-cid-bi7aps5f=""><img src="https://crdt.tech/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">crdt.tech/implementations</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a> that has a list of CRDT libraries, as well as blog posts and academic papers.</p>
<p>CRDTs are awesome! Go forth and build something cool!</p>
<section data-footnotes="">
<ol>
<li id="user-content-fn-louvre">
<p>I’m imagining this picture hanging in the Louvre soon after this post is published. <a href="#user-content-fnref-louvre" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-minify">
<p>The JSON is formatted for easier reading, but when we’re talking about how much space it takes up, we’ll pretend it’s minified by omitting whitespace. <a href="#user-content-fnref-minify" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-uint8array">
<p>If this is too abstract, here’s how it works in JavaScript: a binary file is just a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" data-astro-cid-bi7aps5f=""><code>Uint8Array</code></a><a data-tooltip="" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">Uint8Array - JavaScript | MDN</span><span data-astro-cid-bi7aps5f="">The Uint8Array typed array represents an array of 8-bit unsigned integers. The contents are initialized to 0. Once established, you can reference elements in the array using the object&#39;s methods, or using standard array index syntax (that is, using bracket notation).</span><span data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/favicon-48x48.cbbd161b.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>. Each element of the array is a single byte. Using multiple bytes to represent numbers greater than 255 gets a little tricky, but this is the basic idea. <a href="#user-content-fnref-uint8array" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-base16">
<p>Note that this is in hexadecimal, so each of those numbers is base 16. In decimal, they come out to <code>67 82 68 84</code>. <a href="#user-content-fnref-base16" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-bounds">
<p>Why do we need to know the length in advance? With binary, we don’t usually use delimiters like quotes or brackets to indicate when things begin or end. Instead, we expect to know the size in bytes of each item in advance. That way, we can just go through the items that many bytes at a time, counting up until we’ve gone through the total number of bytes. <a href="#user-content-fnref-bounds" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-missing">
<p>Yeah, we’re missing a few letters, but we need each chunk name to fit in the same number of bytes. <a href="#user-content-fnref-missing" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-rgb">
<p>Remember how each RGB color channel is an integer between 0 and 255? It’s not a coincidence that those are the exact numbers you can fit in a single byte! <a href="#user-content-fnref-rgb" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-maxtimestamp">
<p>Using one byte for the timestamp makes each pixel smaller, but limits us to a maximum timestamp of 255. Lifting that limit would mean adding another byte to every pixel — even if every timestamp is below that amount. Since we know the maximum timestamp in advance, we could make an optimization here: use two bytes to store the timestamp if and only if one of the timestamps is above 255. Saving one byte per pixel sounds small, but that reduces the size of a 100x100 image by a full 10kb! <a href="#user-content-fnref-maxtimestamp" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-confusing">
<p>One downside is that our data is a bit more confusing: items at the same index in each category might not refer to the same pixel. This is a tradeoff of compressing data: the more we squeeze it into as little space as possible, the less it resembles the original thing we’re compressing. <a href="#user-content-fnref-confusing" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-porquenolosdos">
<p>Why not run-length encode all the timestamps? In my (very limited) testing, the timestamps varied enough that run-length encoding non-blank pixels wasted space. <a href="#user-content-fnref-porquenolosdos" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
</ol>
</section></div></div>
  </body>
</html>
