<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zayenz.se/blog/post/how-to-check-for-overlapping-intervals/">Original</a>
    <h1>How to check for overlapping intervals</h1>
    
    <div id="readability-page-1" class="page"><div> <p><time datetime="2025-10-10">2025-10-10</time> <span>•</span> <span>16 min read</span>  <span>•</span></p>  </div><div> <div>  <p>Working with intervals is a common task in programming, whether you’re dealing with time ranges, scheduling problems, or geometric computations.
A key insight when working with intervals is that checking for the absence of an overlap is often much simpler than checking for all the ways an overlap can occur.</p>
<p>This post will first cover how to represent intervals in code, then dive into the logic for detecting overlaps.</p>
<h2 id="what-are-intervals"><a href="#what-are-intervals" aria-label="Link to what-are-intervals">What are intervals?<span>#</span></a></h2>

<p>An interval represents a range between two points, and could be in a continuous or discrete domain.
A <a href="https://en.wikipedia.org/wiki/Interval_(mathematics)#Notations_for_intervals">common way to write an interval</a> is a pair of values <code>[start, end]</code> where <code>start ≤ end</code>.
This would be a so-called closed interval, where the end-value is included in the interval.
An alternative is <code>[start, end)</code>, which denotes a half-open interval where the <code>end</code> value is not included in the interval.<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>
Half-open intervals are very common in programming languages.</p>
<p>Some examples of intervals are</p>
<ul>
<li>Time intervals: <code>[9:00, 17:00]</code> (a work day)</li>
<li>Numeric ranges: <code>[1, 10)</code> (the digit 1, 2, 3, …, 9)</li>
<li>Date ranges: <code>[2025-01-01, 2025-12-31]</code> (all the days in the year 2025)</li>
<li>Temperature range: <code>[20°C, 25°C]</code></li>
<li>…</li>
</ul>
<h2 id="representing-an-interval"><a href="#representing-an-interval" aria-label="Link to representing-an-interval">Representing an interval<span>#</span></a></h2>
<p>We will use Python as an example language, and will use plain integers as the underlying type.
All the examples will use open intervals, as that is very common.</p>
<div><figure><pre data-language="python"><code><div><p><span>@dataclass</span></p></div><div><p><span>class</span><span> </span><span>Interval</span><span>:</span></p></div><div><p><span>  </span><span>&#34;&#34;&#34;Interval from start to end (exclusive)&#34;&#34;&#34;</span></p></div><div><p><span><span>  </span></span><span>start: </span><span>int</span></p></div><div><p><span><span>  </span></span><span>end: </span><span>int</span></p></div><div></div><div><p><span>  </span><span># Useful methods</span></p></div><div><p><span>  </span><span>...</span></p></div></code></pre></figure></div>
<p>For the purposes of this post, we will only consider integer valued intervals for simplicity.
In addition we require that intervals are non-empty.
In many real cases, real valued intervals approximated by floating points are needed as is the handling of empty intervals.</p>

<h2 id="detecting-overlap"><a href="#detecting-overlap" aria-label="Link to detecting-overlap">Detecting overlap<span>#</span></a></h2>
<p>One of the most common questions when working with intervals is: “Do these two intervals overlap?”
Lets implement a method for this</p>
<div><figure><pre data-language="python"><code><div><p><span>@dataclass</span></p></div><div><p><span>class</span><span> </span><span>Interval</span><span>:</span></p></div><div><p><span>  </span><span>...</span></p></div><div></div><div><p><span>  </span><span>def</span><span> </span><span>overlaps</span><span>(</span><span>self</span><span>, </span><span>other</span><span>:</span><span> Interval) </span><span>-&gt;</span><span> </span><span>bool</span><span>:</span></p></div><div><p><span>      </span><span>&#34;&#34;&#34; Return true iff the two intervals overlap. &#34;&#34;&#34;</span></p></div><div><p><span>      </span><span># How to implement?</span></p></div></code></pre></figure></div>
<h3 id="the-straight-forward-approach"><a href="#the-straight-forward-approach" aria-label="Link to the-straight-forward-approach">The straight-forward approach<span>#</span></a></h3>
<p>Whenever one needs to make a Boolean condition, the easiest way is often to consider all the cases.
So, let’s consider all the ways that two intervals may overlap.
There are four distinct cases.</p>
<div><div><p><strong>Case 1:</strong> self starts first, other overlaps end of self</p></div><div><p><strong>Case 2:</strong> other starts first, self overlaps end of other</p></div><div><p><strong>Case 3:</strong> self completely contains other</p></div><div><p><strong>Case 4:</strong> other completely contains self</p></div></div>
<p>In all these cases, we can see that the intervals share at least one point in common.
The challenge is to write a condition that captures all four cases correctly.
Let’s translate it into code straight from the case analysis.</p>
<div><figure><pre data-language="python"><code><div><p><span>@dataclass</span></p></div><div><p><span>class</span><span> </span><span>Interval</span><span>:</span></p></div><div><p><span>  </span><span>...</span></p></div><div><p><span>  </span><span>def</span><span> </span><span>overlaps</span><span>(</span><span>self</span><span>, </span><span>other</span><span>:</span><span> Interval) </span><span>-&gt;</span><span> </span><span>bool</span><span>:</span></p></div><div><p><span>      </span><span>&#34;&#34;&#34; Return true iff the two intervals overlap. &#34;&#34;&#34;</span></p></div><div><p><span>      </span><span>return</span><span> \</span></p></div><div><p><span>          </span><span># Case 1</span></p></div><div><p><span>          </span><span>self</span><span>.start </span><span>&lt;=</span><span> other.start </span><span>&lt;</span><span> </span><span>self</span><span>.end </span><span>or</span></p></div><div><p><span>          </span><span># Case 2</span></p></div><div><p><span>          </span><span>self</span><span>.start </span><span>&lt;</span><span> other.end </span><span>&lt;=</span><span> </span><span>self</span><span>.end </span><span>or</span></p></div><div><p><span>          </span><span># Case 3</span></p></div><div><p><span>          </span><span>self</span><span>.start </span><span>&lt;</span><span> other.end </span><span>&lt;=</span><span> other.end </span><span>&lt;</span><span> </span><span>self</span><span>.end </span><span>or</span></p></div><div><p><span>          </span><span># Case 4</span></p></div><div><p><span><span>          </span></span><span>other.start </span><span>&lt;=</span><span> </span><span>self</span><span>.start </span><span>&lt;=</span><span> </span><span>self</span><span>.end </span><span>&lt;</span><span> other.end</span></p></div></code></pre></figure></div>
<p>This is a straightforward translation of the cases,
where the most tricky thing is to make sure that the handling of the half-open property is correct.
One thing to note though, is that by checking the endpoints of the blue <code>other</code> interval in Case 1 and 2,
then we have also covered Case 3.
This means that due to short circuiting, we will never trigger Case 3.
In addition Case 4 is overly specific.
We only need to care about checking if the start-point of the green <code>self</code> interval is in the blue <code>other</code> interval.</p>
<p>Taking these observations into account, we can simplify the above condition to the following cases.</p>
<div><figure><pre data-language="python"><code><div><p><span>@dataclass</span></p></div><div><p><span>class</span><span> </span><span>Interval</span><span>:</span></p></div><div><p><span>  </span><span>...</span></p></div><div><p><span>  </span><span>def</span><span> </span><span>overlaps</span><span>(</span><span>self</span><span>, </span><span>other</span><span>:</span><span> Interval) </span><span>-&gt;</span><span> </span><span>bool</span><span>:</span></p></div><div><p><span>      </span><span>&#34;&#34;&#34; Return true iff the two intervals overlap. &#34;&#34;&#34;</span></p></div><div><p><span>      </span><span>return</span><span> \</span></p></div><div><p><span>          </span><span># Case 1</span></p></div><div><p><span>          </span><span>self</span><span>.start </span><span>&lt;=</span><span> other.start </span><span>&lt;</span><span> </span><span>self</span><span>.end </span><span>or</span></p></div><div><p><span>          </span><span># Case 2</span></p></div><div><p><span>          </span><span>self</span><span>.start </span><span>&lt;</span><span> other.end </span><span>&lt;=</span><span> </span><span>self</span><span>.end </span><span>or</span></p></div><div><p><span>          </span><span># Case 4 (simplified)</span></p></div><div><p><span><span>          </span></span><span>other.start </span><span>&lt;=</span><span> </span><span>self</span><span>.start </span><span>&lt;</span><span> other.end</span></p></div></code></pre></figure></div>
<p>With a case-analysis and some careful considerations, we have a nice expression that captures overlapping intervals.
But checking overlap feels like something that should be obvious, and this condition is not that obvious.
Checking for overlap of two intervals also feels like it shouldn’t reduce down to three cases.
From that argument, we can intuit that it should be possible to simplify this even more.</p>
<p>Can we make a simpler condition, that is also easy to find?</p>
<h3 id="flipping-the-script"><a href="#flipping-the-script" aria-label="Link to flipping-the-script">Flipping the script<span>#</span></a></h3>
<p>The core insight is that sometimes it is much easier to check for the negation of a property than the original property.
For overlap, the negation is checking if two intervals are not overlapping.
Let’s look at the cases we have now instead.</p>
<div><div><p><strong>Case 1:</strong> self is before other</p></div><div><p><strong>Case 2:</strong> other is before self</p></div></div>
<p>There are only two ways the two intervals are not overlapping, and this is much easier to translate into code.</p>
<div><figure><pre data-language="python"><code><div><p><span>@dataclass</span></p></div><div><p><span>class</span><span> </span><span>Interval</span><span>:</span></p></div><div><p><span>  </span><span>...</span></p></div><div><p><span>  </span><span>def</span><span> </span><span>overlaps</span><span>(</span><span>self</span><span>, </span><span>other</span><span>:</span><span> Interval) </span><span>-&gt;</span><span> </span><span>bool</span><span>:</span></p></div><div><p><span>      </span><span>&#34;&#34;&#34; Return true iff the two intervals overlap. &#34;&#34;&#34;</span></p></div><div><p><span>      </span><span>return</span><span> </span><span>not</span><span> (</span></p></div><div><p><span>          </span><span># Case 1</span></p></div><div><p><span>          </span><span>self</span><span>.end </span><span>&lt;=</span><span> other.start</span></p></div><div><p><span>          </span><span>or</span></p></div><div><p><span>          </span><span># Case 2</span></p></div><div><p><span><span>          </span></span><span>other.end </span><span>&lt;=</span><span> </span><span>self</span><span>.start</span></p></div><div><p><span><span>      </span></span><span>)</span></p></div></code></pre></figure></div>
<p>Using <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan’s law</a>
<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∨</mo><mi>B</mi><mo stretchy="false">)</mo><mstyle mathsize="1.2em"><mo>⊢</mo><mi mathvariant="normal">¬</mi><mi>A</mi><mo>∧</mo><mi mathvariant="normal">¬</mi><mi>B</mi></mstyle><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left( \lnot (A \lor B) \large\vdash \lnot A \land \lnot B \right)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>(</span></span><span>¬</span><span>(</span><span>A</span><span></span><span>∨</span><span></span><span>B</span><span>)</span><span></span><span>⊢</span><span></span><span>¬</span><span>A</span><span></span><span>∧</span><span></span><span>¬</span><span>B</span><span><span>)</span></span></span></span></span></span> it is possible to push the negation in.
In addition, negated comparisons can be flipped <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mi mathvariant="normal">¬</mi><mi>x</mi><mo>≤</mo><mi>y</mi><mstyle mathsize="1.2em"><mo>⊢</mo><mi>y</mi><mo>&lt;</mo><mi>x</mi></mstyle><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(\lnot x \leq y \large\vdash y &lt; x\right)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>(</span></span><span>¬</span><span>x</span><span></span><span>≤</span><span></span><span>y</span><span></span><span>⊢</span><span></span><span>y</span><span></span><span>&lt;</span><span></span><span>x</span><span><span>)</span></span></span></span></span></span> simplifying this even further.</p>
<div><figure><pre data-language="python"><code><div><p><span>@dataclass</span></p></div><div><p><span>class</span><span> </span><span>Interval</span><span>:</span></p></div><div><p><span>  </span><span>...</span></p></div><div><p><span>  </span><span>def</span><span> </span><span>overlaps</span><span>(</span><span>self</span><span>, </span><span>other</span><span>:</span><span> Interval) </span><span>-&gt;</span><span> </span><span>bool</span><span>:</span></p></div><div><p><span>      </span><span>&#34;&#34;&#34; Return true iff the two intervals overlap. &#34;&#34;&#34;</span></p></div><div><p><span>      </span><span>return</span><span> (</span></p></div><div><p><span><span>          </span></span><span>other.start </span><span>&lt;</span><span> </span><span>self</span><span>.end</span></p></div><div><p><span>          </span><span>and</span></p></div><div><p><span>          </span><span>self</span><span>.start </span><span>&lt;</span><span> other.end</span></p></div><div><p><span><span>      </span></span><span>)</span></p></div></code></pre></figure></div>
<p>This is finally a nice and simple expression that checks just two properties.
By changing our viewpoint from checking for an overlap to checking against one,
we deduced the correct expression much more easily.</p>
<h3 id="understanding-the-new-condition"><a href="#understanding-the-new-condition" aria-label="Link to understanding-the-new-condition">Understanding the new condition<span>#</span></a></h3>
<p>The new condition works, and we could derive it from a case analysis and using Boolean simplification.
But there is also a meaning to the expression that we can interpret geometrically.</p>
<div><div><p><strong>Case 1:</strong> start of other is before end of self</p></div><div><p><strong>Case 2:</strong> start of self is before end of other</p></div></div>
<p>The first case checks that it is not the case that <code>other</code> starts after <code>self</code> ends.
The second case checks that it is not the case that <code>self</code> starts after <code>other</code> ends.
These two conditions together gives us the result that there is some part that is overlapping.</p>
<p>It is of course possible to figure out this condition directly,
but making this intuitive leap is in my view harder than following the
case analysis from the negative case.<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup></p>
<h2 id="adding-a-second-dimension"><a href="#adding-a-second-dimension" aria-label="Link to adding-a-second-dimension">Adding a second dimension<span>#</span></a></h2>
<p>An interval is a one-dimensional property.
A very natural extension is to instead consider two-dimensional properties.
Representing a box is very similar to an interval, here we go from
top and left (inclusive) to bottom and right (exclusive).</p>
<div><figure><pre data-language="python"><code><div><p><span>@dataclass</span></p></div><div><p><span>class</span><span> </span><span>Box</span><span>:</span></p></div><div><p><span>  </span><span>&#34;&#34;&#34;Box from (left, top) to (right, bottom) (exclusive)&#34;&#34;&#34;</span></p></div><div><p><span><span>  </span></span><span>left: </span><span>int</span></p></div><div><p><span><span>  </span></span><span>right: </span><span>int</span></p></div><div><p><span><span>  </span></span><span>bottom: </span><span>int</span></p></div><div><p><span><span>  </span></span><span>top: </span><span>int</span></p></div><div></div><div><p><span>  </span><span># Useful methods</span></p></div><div><p><span>  </span><span>...</span></p></div></code></pre></figure></div>
<h3 id="case-analysis-for-overlap"><a href="#case-analysis-for-overlap" aria-label="Link to case-analysis-for-overlap">Case analysis for overlap<span>#</span></a></h3>
<p>Checking for overlap is equally important for boxes as it is for intervals.
Let’s start by making a full case analysis of all the variants for how two boxes can overlap.</p>
<div><div><p><strong>Case 1:</strong> other left+below, ends inside</p></div><div><p><strong>Case 2:</strong> other left, ends inside; contained vertically</p></div><div><p><strong>Case 3:</strong> other left+above, ends inside</p></div><div><p><strong>Case 4:</strong> other left, ends inside; contains vertically</p></div><div><p><strong>Case 5:</strong> other contained horizontally; starts below, ends inside</p></div><div><p><strong>Case 6:</strong> other fully contained in self</p></div><div><p><strong>Case 7:</strong> other contained horizontally; starts inside, ends above</p></div><div><p><strong>Case 8:</strong> other contains self horizontally; overlaps vertically</p></div><div><p><strong>Case 9:</strong> other right+below, starts inside</p></div><div><p><strong>Case 10:</strong> other right, starts inside; contained vertically</p></div><div><p><strong>Case 11:</strong> other right+above, starts inside</p></div><div><p><strong>Case 12:</strong> other right, starts inside; contains vertically</p></div><div><p><strong>Case 13:</strong> other contains horizontally; starts below, ends inside</p></div><div><p><strong>Case 14:</strong> other contains horizontally; contained vertically</p></div><div><p><strong>Case 15:</strong> other contains horizontally; starts inside, ends above</p></div><div><p><strong>Case 16:</strong> other completely contains self</p></div></div>
<p>This does not inspire confidence in getting understandable code, let’s not even attempt it.</p>
<h3 id="negation-to-the-rescue-again"><a href="#negation-to-the-rescue-again" aria-label="Link to negation-to-the-rescue-again">Negation to the rescue again<span>#</span></a></h3>
<p>Using the same idea as for intervals, let’s look at the cases where two boxes do not overlap.</p>
<div><div><p><strong>Case 1:</strong> other is to the left of self</p></div><div><p><strong>Case 2:</strong> other is to the right of self</p></div><div><p><strong>Case 3:</strong> other is above self</p></div><div><p><strong>Case 4:</strong> other is below self</p></div></div>
<p>This is quite easy, the other box can be to the left, right, above, or below.
If it is to the left, it does not matter how much (or at all) the box overlaps in the vertical direction.
Translating this into straightforward code as before.</p>
<div><figure><pre data-language="python"><code><div><p><span>@dataclass</span></p></div><div><p><span>class</span><span> </span><span>Box</span><span>:</span></p></div><div><p><span>  </span><span>...</span></p></div><div><p><span>  </span><span>def</span><span> </span><span>overlaps</span><span>(</span><span>self</span><span>, </span><span>other</span><span>:</span><span> Box) </span><span>-&gt;</span><span> </span><span>bool</span><span>:</span></p></div><div><p><span>      </span><span>&#34;&#34;&#34; Return true iff the two boxes overlap. &#34;&#34;&#34;</span></p></div><div><p><span>      </span><span>return</span><span> </span><span>not</span><span> (</span></p></div><div><p><span>          </span><span># Case 1</span></p></div><div><p><span>          </span><span>self</span><span>.right </span><span>&lt;=</span><span> other.left</span></p></div><div><p><span>          </span><span>or</span></p></div><div><p><span>          </span><span># Case 2</span></p></div><div><p><span><span>          </span></span><span>other.right </span><span>&lt;=</span><span> </span><span>self</span><span>.left</span></p></div><div><p><span>          </span><span>or</span></p></div><div><p><span>          </span><span># Case 3</span></p></div><div><p><span>          </span><span>self</span><span>.top </span><span>&lt;=</span><span> other.bottom</span></p></div><div><p><span>          </span><span>or</span></p></div><div><p><span>          </span><span># Case 4</span></p></div><div><p><span><span>          </span></span><span>other.bottom </span><span>&lt;=</span><span> </span><span>self</span><span>.top</span></p></div><div><p><span><span>      </span></span><span>)</span></p></div></code></pre></figure></div>
<p>Using the same analysis as before, we can use De Morgan’s laws to change the implementation to not start with a not.<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup></p>
<div><figure><pre data-language="python"><code><div><p><span>@dataclass</span></p></div><div><p><span>class</span><span> </span><span>Box</span><span>:</span></p></div><div><p><span>  </span><span>...</span></p></div><div><p><span>  </span><span>def</span><span> </span><span>overlaps</span><span>(</span><span>self</span><span>, </span><span>other</span><span>:</span><span> Box) </span><span>-&gt;</span><span> </span><span>bool</span><span>:</span></p></div><div><p><span>      </span><span>&#34;&#34;&#34; Return true iff the two boxes overlap. &#34;&#34;&#34;</span></p></div><div><p><span>      </span><span>return</span><span> (</span></p></div><div><p><span><span>          </span></span><span>other.left </span><span>&lt;</span><span> </span><span>self</span><span>.right</span></p></div><div><p><span>          </span><span>and</span></p></div><div><p><span>          </span><span>self</span><span>.left </span><span>&lt;</span><span> other.right</span></p></div><div><p><span>          </span><span>and</span></p></div><div><p><span><span>          </span></span><span>other.bottom </span><span>&lt;</span><span> </span><span>self</span><span>.top</span></p></div><div><p><span>          </span><span>and</span></p></div><div><p><span>          </span><span>self</span><span>.bottom </span><span>&lt;</span><span> other.top</span></p></div><div><p><span><span>      </span></span><span>)</span></p></div></code></pre></figure></div>
<p>This new expression can be interpreted as a two dimensional variant of the interval overlap check.
Two boxes overlap if there is overlap in both the horizontal and the vertical direction.</p>
<h2 id="conclusion"><a href="#conclusion" aria-label="Link to conclusion">Conclusion<span>#</span></a></h2>
<p>Figuring out the best way to express a property can be tricky.
For intervals, while one can sit down and think thoroughly to find the best way to express the overlaps property,
it is not easy.
Using case analysis is the straight-forward way to create these
but it can easily lead to an overly complicated and error-prone expression.
This is especially clear for the box case, where there are 16 different cases to handle.</p>
<p>Using negation as a trick to simplify the case analysis works really well here.
Naturally, it doesn’t always work out this well, but when it does it is a technique that is worth keeping in mind.</p>
  </div> </div></div>
  </body>
</html>
