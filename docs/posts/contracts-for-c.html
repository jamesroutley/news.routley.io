<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gustedt.wordpress.com/2025/03/10/contracts-for-c/">Original</a>
    <h1>Contracts for C</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>C++ seems to finally converge with their contracts proposal, <a href="https://wg21.link/p2900">https://wg21.link/p2900</a>. I decided to give it a try and come up with ideas how such a thing would look for C. This is in early stages, not a full proposal yet, and still would need implementation by some of the major compilers.</p>



<p>In particular, the C++ feature is full of sidetracks that I don’t like at all, such as user-defined global handlers and ignorability. But there is a core of ideas, syntax and semantics that I found interesting and that I think should be considered for C. The principal features are</p>



<ul>
<li>Contract pre- and postconditions add verifiable conditions that are added to function interfaces. They are checked on entry to a function call and provide knowledge that is valuable for the code following a call.</li>



<li>If the condition is an integer constant expression, a pre- or postcondition is similar to an invocation of <code>static_assert</code>. If the condition is false, compilation fails. In the following we will not illustrate this aspect to simplify the discourse.</li>



<li>They have no implications on ABI.</li>



<li>They can be made composable. If applied rigorously, such conditions can often be deduced from the context. They need not be checked dynamically.</li>



<li>Besides verified correctness, they offer optimization opportunities for the context of a function call and for the called function itself.</li>
</ul>



<p>To see how all of this works we first need understand two fundamental primitives, assertions and assumptions. Their syntax looks something like</p>


<div><pre title="">contract_assert(COND, &#34;some explanatory text&#34;);
contract_assume(COND, &#34;some explanatory text&#34;);
</pre></div>


<p>Here, in both cases <code>COND</code> is some condition that is supposed to be fulfilled. </p>



<p>The first, <code>contract_assert</code>, is quite similar to a feature that we already have in C namely the <code>assert</code> macro. Both test for the condition; if it is fulfilled nothing happens and execution goes on. If it is not fulfilled, a diagnostic is printed to <code>stderr</code> and <code>abort</code> is called to end the execution. The difference to <code>assert</code> is that <code>contract_assert</code> always has to be correct C code. There is no such thing as <code>NDEBUG</code> that pretends the assertion doesn’t even exist.</p>



<p>The other feature, <code>contract_assume</code>, is more subtle and actually quite dangerous if applied carelessly. It is as if defined as </p>


<div><pre title="">#define contract_assume(COND, ...) do { if (!(COND)) unreachable(); } while (false)
</pre></div>


<p>Here <code>unreacheable()</code> is the new macro from C23 (and C++23) that makes the behaviour undefined whenever the branch of the invocation is reached. So in general such a condition would not even be evaluated, but it would be taken for grated that it holds. (It would be evaluated for its side effects if it had any, but you shouldn’t do such things, anyhow.) Take an example</p>


<div><pre title="">contract_assume(p, &#34;pointer must never be null&#34;);
*p = 34.7;
</pre></div>


<p>Here we, the programmer, promise that the pointer is never null and the compiler can assume that for the following without checking.</p>



<p>With <code>contract_assert</code> we can give an idea what pre- and postconditions look like from outer space. Take a conventional C function with a declaration in a header file and a definition in a .c file:</p>


<div><pre title="">// .h header
void* my_malloc(size_t size);
</pre></div>

<div><pre title="">// .c definition
void* my_malloc(size_t size) {
   return malloc(size);
}
</pre></div>


<p>This function is admittedly a bit lame. It has just one function call in the body. However, please take this as a simple example for illustration. With contracts, the declaration could look something like</p>


<div><pre title="">void* my_malloc(size_t size) pre(size) post(r: r);
</pre></div>


<p>This declares that the argument to <code>size</code> of a call to <code>my_malloc</code> must always be checked to be non-zero and that the return value, here named <code>r</code>, will always be checked such that it is non-null. An implementation with current tools of that function that takes these conditions into account, but doesn’t reflect them in the declaration part could look as follows</p>


<div><pre title="">// .h header
inline
void* my_malloc(size_t size) {
   contracts_assert(size, &#34;can&#39;t allocate empty buffer&#34;);
   defer { contracts_assert(defer_return_value, &#34;allocation failed&#34;; };
   return malloc(size);
}
</pre></div>

<div><pre title="">// .c instantiation
extern void* my_malloc(size_t size);
</pre></div>


<p>Putting this as an inline function in the header ensures that the contracts are visible for all callers, and thus, when integrating this into the control flow, the conditions can either be deduced (e.g if we know that the argument is non-zero) or can be used to deduce properties in the caller (e.g the returned value is always non-null). </p>



<p>Note also, that here we use <code>defer</code> to ensure that the assertion triggers regardless on how we leave the function. This is probably not so interesting for this short example. However, if the function has complicated nesting with multiple returns, <code>defer</code> simplifies the process. It helps with code that we want to execute unconditionally on function return.</p>



<p>Changing all functions to inline functions would deviate much from the usual abstraction between interface and implementation in C (and C++). So contracts are an attempt to enrich the interface such that the core of the function stays in its own file and remains known only via the provided interface. A first advantage of <code>pre</code> and <code>post</code> should be obvious. Since it is part of the declaration, it helps people to understand what to expect of a function. It may also assist compilers in the same way. In particular the postcondition can help to take conditions ahead into the context of the caller:</p>


<div><pre title="">double* p = my_malloc(sizeof(*p));
*p = 34.7;
</pre></div>


<p>Here the call to <code>my_malloc</code>, instead of using <code>malloc</code> directly, ensures that the pointer is always checked. A sensible message is printed before the execution aborts, if necessary. For any implementation of postconditions we would want the compiler to deduce that property directly, only from the declaration.</p>



<p>Unfortunately, this simple top level view isn’t very satisfactory:</p>



<ul>
<li>A precondition that is hidden in a .c file is only checked when the function has already been entered. In the calling context it might already be known that <code>size</code> is not zero. This information is lost and the assertion has always to be checked at the start of the function.</li>



<li>If the postcondition is also checked within the function call, we have to come up with a mechanism that propagates the information to the calling context.</li>
</ul>



<p>To improve these aspects, the following observation about assertions and assumptions is key:</p>



<p><em>In a series of assertions and assumptions, if they check the same condition without an intermediate change of the execution state, only the first assertion or assumption is necessary. All subsequent assertions or assumptions are redundant.</em></p>



<p>Take the null pointer check from above. Repeating the assumption clearly does not add any new information for the compiler:</p>


<div><pre title="">contract_assume(p, &#34;pointer must never be null&#34;);
contract_assume(p, &#34;pointer must really not be null&#34;);
*p = 34.7;

</pre></div>


<p>Similarly, mixing an assertion and an assumption on the same condition does not achieve much:</p>


<div><pre title="">contract_assert(p, &#34;pointer must never be null&#34;);
contract_assume(p, &#34;pointer must really not be null&#34;);
*p = 34.7;

</pre></div>


<p>Here the compiler has to make sure that the assertion holds, so afterwards the condition can be assumed. If we invert the order:</p>


<div><pre title="">contract_assume(p, &#34;pointer must never be null&#34;);
contract_assert(p, &#34;pointer must really not be null&#34;);
*p = 34.7;

</pre></div>


<p>When reaching the assertion, the compiler knows that the condition has just been checked. Thus, the whole assertion can be omitted. This observation can help develop an execution model for function with contracts. It fits into C’s current execution model.</p>



<ul>
<li>A precondition <em>c</em> on a function <em>f</em> can be replaced by an assertion of <em>c</em> that is executed before any call to <em>f</em> that is combined with an assumption of <em>c</em> at the start of the execution of the function body.</li>



<li>A postcondition <em>c</em> on a function <em>f</em> can be replaced by an assertion of <em>c</em> at the end of the execution of the function body combined with an assumption of <em>c</em> that is placed after any call to <em>f</em>.</li>
</ul>



<p>Let’s visit this with our <code>my_malloc</code> example. If we want to execute the precondition before going into the real call of our function we can replace the declaration with the contracts by an inline function:</p>


<div><pre title="">/* in a .h header */
inline
void* my_malloc(size_t size) {
   contracts_assert(size, &#34;can&#39;t allocate empty buffer&#34;);
   defer { contracts_assume(defer_return_value, &#34;allocation failed&#34;; };
   return my_malloc_inner(size);
}
</pre></div>


<p>That inline function makes the necessary assertions and assumptions. If a call to it is inlined at some point, the compiler sees these and can use the information to check and optimize. Then it tail-calls another function <code>my_malloc_inner</code> that contains the code that otherwise would just have been the definition of <code>my_malloc</code>.</p>



<p>Then, in the .c file, we have to give the implementation of <code>my_malloc_intern</code> and the instantiation of the inline function.</p>


<div><pre title="">/* in a .c implementation file */
extern void* my_malloc(size_t); // instantiation of the inline function

void* my_malloc_intern(size_t size) {
   contracts_assume(size, &#34;can&#39;t allocate empty buffer&#34;);
   defer { contracts_assert(defer_return_value, &#34;allocation failed&#34;; };
   // now do everything we need to do
   return malloc(size);
}
</pre></div>


<p>This combination of an inline wrapper for the contracts and an auxiliary function for the inner workings of the functions guarantees the requested behaviour:</p>



<ul>
<li>the precondition is checked before entry of the auxiliary function</li>



<li>the precondition is known to hold on entry of the auxiliary function</li>



<li>the postcondition is checked at the end of the auxiliary function</li>



<li>the  postcondition is known to hold after a call to the auxiliary function.</li>
</ul>



<p>So this combination has the properties that we want from contracts: the calling context and the called context can deduce the information from the contracts to optimize. But this approach has still a major disadvantage, we have to repeat the conditions within the code of the auxiliary function. This is tedious and error-prone.</p>



<p>The latest release of  <a href="https://gustedt.gitlabpages.inria.fr/ellipsis">eĿlipsis</a> provides a mechanism that avoids that code duplication. The contracts are expressed basically as above with an inline function:</p>


<div><pre title="">/* in an -interface.h header */
inline
void* EXBINDING(my_malloc)(size_t size) {
   DEFER_TYPE(void*);
   ellipsis_precondition(size, &#34;can&#39;t allocate empty buffer&#34;);
   ellipsis_postcondition(defer_return_value, &#34;allocation failed&#34;; };
   // forward declare auxiliary function
   extern typeof(EXBINDING(my_malloc)) INBINDING(my_malloc);
   // call auxiliary function with same parameters
   return INBINDING(my_malloc)(size);
}
</pre></div>


<p>The difference here is that the conditions are expressed with special macros. These macros make it easier to place the right pairs of assertion/assumption inside the inline function. They also help with the implementation. Macros <code>EXBINDING/INBINDING</code> deal with the naming of auxiliary functions. The implementation file then looks very much like the original function definition from which we started.</p>


<div><pre title="">// -implementation.c definition
void* EXBINDING(my_malloc)(size_t size) {
   return malloc(size);
}
</pre></div>


<p>Only the <code>EXBINDING</code> macro is needed to get the name right. This approach expresses all the contracts in the header file. It also leaves the core of the implementation almost unaltered. If you are interested in the details of this approach please refer to the <a href="https://gustedt.gitlabpages.inria.fr/ellipsis/ellipsis-interface_8h.html">corresponding eĿlipsis documentation</a>.</p>



<p>All of this is unfortunately nothing that can be used easily, yet. A proper interface specification similar and compatible to the one used by C++ would be needed. Nevertheless this is a proof of concept of such an approach for C. The tools we needed are</p>



<ul>
<li><code>defer</code> together with <code>defer_return_value</code> to ease the expression of postconditions</li>



<li><code>typeof</code> to ease the forward declaration of functions with the same prototype</li>



<li><code>abort</code> to have a defined strategy for termination</li>



<li><code>unreachable</code> to express assumptions through control flow</li>



<li><code>inline</code> to place conditions into the vision of every user of a function </li>
</ul>




</div></div>
  </body>
</html>
