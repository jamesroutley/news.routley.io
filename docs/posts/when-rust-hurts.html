<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mmapped.blog/posts/15-when-rust-hurts.html">Original</a>
    <h1>When Rust hurts</h1>
    
    <div id="readability-page-1" class="page"><article>
<header>
  <nav>
    <ul>
      <li><a href="https://mmapped.blog/index.html">mmap(blog)</a></li>
      <li><a href="https://mmapped.blog/posts.html">Posts</a></li>
      <li><a href="https://mmapped.blog/about.html">About</a></li>
      <li><a href="https://mmapped.blog/feed.xml">Atom Feed</a></li>
    </ul>
  </nav>
</header>

<p>
  Published: <span itemprop="datePublished">2023-02-14</span>
   
  Last updated: <span itemprop="dateModified">2023-02-14</span>
</p>
<hr/>
<ul><li><a href="#intro">Introduction</a><ul></ul></li><li><a href="#objects-values-references">Objects, values, and references</a><ul></ul></li><li><a href="#abstraction-hurts">When abstraction hurts</a><ul><li><a href="#common-expression-elimination">Common expression elimination</a></li><li><a href="#monomorphism-restriction">Monomorphism restriction</a></li><li><a href="#functional-abstraction">Functional abstraction</a></li><li><a href="#newtype-abstrction">Newtype abstraction</a></li><li><a href="#views-and-bundles">Views and bundles</a></li></ul></li><li><a href="#composition-hurts">When composition hurts</a><ul><li><a href="#object-composition">Object composition</a></li><li><a href="#pattern-matching-boxes">Pattern matching cannot see through boxes</a></li><li><a href="#orphan-rules">Orphan rules</a></li></ul></li><li><a href="#fearless-concurrency">Fearless concurrency is a lie</a><ul><li><a href="#deadlocks">Deadlocks</a></li><li><a href="#filesystem-shared-resource">Filesystem is a shared resource</a></li><li><a href="#implicit-async-runtimes">Implicit async runtimes</a></li></ul></li><li><a href="#conclusion">Conclusion</a><ul></ul></li></ul>
<hr/>
<div><blockquote><p>Functional programming deals with values; imperative programming deals with objects.</p>
</blockquote></div>


<section><h2 id="intro"><a href="#intro">Introduction</a></h2>
<p><a href="https://www.rust-lang.org/">Rust</a> is in a sweet spot in the language design space.
It allows us to build efficient and memory-safe programs with concise, portable, and sometimes even pretty code.</p>
<p>However, it is not all roses and sunshine.
Memory management details often stay in your way and make the code uglier or more repetitive than it could be in a <span>“higher-level”</span> programming language, such as <a href="https://www.haskell.org/">Haskell</a> or <a href="https://ocaml.org">OCaml</a>.
In almost all cases, these issues are not defects of the compiler but direct consequences of the Rust&#39;s team design choices.</p>
<p>This article details on how frustrating Rust can be if you approach it with a functional programming mindset and why Rust has no choice but to frustrate you.</p></section>


<section><h2 id="objects-values-references"><a href="#objects-values-references">Objects, values, and references</a></h2>
<div><blockquote><p>Values and objects play complementary roles.
Values are unchanging and independent of any particular implementation in the computer.
Objects are changeable and have computer-specific implementations.</p>
</blockquote></div>

<p>Understanding the difference between objects, values, and references is helpful before diving deeper into Rust.</p>
<p>In the context of this article, <em>values</em> are entities with distinct identities, such as numbers and strings.
An <em>object</em> is a representation of a value in the computer memory.
A <em>reference</em> is the address of an object that we can use to access the object or its parts.</p>
<figure><label for="mn-objects-values-refs">⊕</label><span>A visualization of values, objects, and references on an example of an integer in a 16-bit computer.
The value is number five, which has no inherent type.
The object is a 16-bit integer stored at address <code>0x0300</code> (<a href="https://en.wikipedia.org/wiki/Endianness">little-endian</a>).
The memory contains a <em>reference</em> to the number, represented as a pointer to address <code>0x0300</code>.</span>
</figure>
<p>System programming languages, such as C++ and Rust, force the programmer to deal with the distinction between objects and references.
This distinction allows us to write blazingly fast code, but it comes with a high price: it is a never-ending source of bugs.
It is almost always a bug to modify the contents of an object if some other part of the program references that object.
There are multiple ways to address this issue:</p>
<ul><li>Ignore the problem and trust the programmer.
Most traditional system programming languages, such as C++, took this path.</li>
<li>Make all objects immutable.
This option is the basis for pure functional programming techniques in Haskell and <a href="https://clojure.org/">Clojure</a>.</li>
<li>Adopt a <a href="https://en.wikipedia.org/wiki/Substructural_type_system">type system</a> preventing modification of referenced objects.
Languages such as <a href="https://www.cs.bu.edu/~hwxi/atslangweb/">ATS</a> and Rust embarked on this journey.</li>
<li>Ban references altogether.
The <a href="https://www.val-lang.dev/">Val</a> language explores this style of programming.</li></ul>
<p>The distinction between objects and references is also a source of accidental complexity and choice explosion.
A language with immutable objects and automatic memory management allows us to stay ignorant of this distinction and treat everything as a value (at least in pure code).
A unified storage model frees up a programmer&#39;s mental resources and enables her to write more expressive and elegant code.
However, what we gain in convenience, we lose in efficiency: pure functional programs often require more memory, can become unresponsive, and are harder to optimize (your mileage may vary).</p></section>


<section><h2 id="abstraction-hurts"><a href="#abstraction-hurts">When abstraction hurts</a></h2>
<p>Manual memory management and the ownership-aware type system interfere with our ability to break down the code into smaller pieces.</p>

<h3 id="common-expression-elimination"><a href="#common-expression-elimination">Common expression elimination</a></h3>
<p>Extracting a common expression into a variable can pose unexpected challenges.
Let us start with the following snippet of code.</p>
<div><pre><code>f(compute_x());
g(compute_x());</code></pre></div>
<p>Look, <code>compute_x()</code> appears twice!
Our first instinct is to assign a name to the expression and use it twice:</p>
<div><pre><code>let <b>x</b> = compute_x();
f(<b>x</b>);
g(<b>x</b>);</code></pre></div>
<p>However, our first naive version will only compile if the type of x implements the <code>Copy</code> trait.
We must write the following expression instead:</p>
<div><pre><code>let x = compute_x();
f(x<b>.clone()</b>);
g(x);</code></pre></div>
<p>We can see the extra verbosity in a positive light if we care about extra memory allocations because copying memory became explicit.
But it can be quite annoying in practice, especially when you add <code>h(x)</code> two months later.</p>

<div><pre><code>let x = compute_x();
f(x.clone());
g(x);

// fifty lines of code...

h(x); // ← won’t compile, you need scroll up and update g(x).</code></pre></div>


<h3 id="monomorphism-restriction"><a href="#monomorphism-restriction">Monomorphism restriction</a></h3>
<p>In Rust, <code>let x = y;</code> does not always mean that <code>x</code> is the same thing as <code>y</code>.
One example of when this natural property breaks is when <code>y</code> is an overloaded function.</p>
<p>For example, let us define a short name for an overloaded function.</p>
<div><pre><code>// Do we have to type &#34;MyType::from&#34; every time?
// How about introducing an alias?
let x = MyType::from(b&#34;bytes&#34;);
let y = MyType::from(&#34;string&#34;);

// Nope, Rust won&#39;t let us.
let f = MyType::from;
let x = f(b&#34;bytes&#34;);
let y = f(&#34;string&#34;);
//      - ^^^^^^^^ expected slice `[u8]`, found `str`
//      |
//      arguments to this function are incorrect</code></pre></div>
<p>The snippet does not compile because the compiler will bind <code>f</code> to a particular instance of <code>MyType::from</code>, not to a polymorphic function.
We have to make <code>f</code> polymorphic explicitly.</p>

<div><pre><code>// Compiles fine, but is longer than the original.
fn f&lt;T: Into&lt;MyType&gt;&gt;(t: T) -&gt; MyType { t.into() }

let x = f(b&#34;bytes&#34;);
let y = f(&#34;string&#34;);</code></pre></div>

<p>Haskell programmers might find this problem familiar: it looks suspiciously similar to the dreaded <a href="https://wiki.haskell.org/Monomorphism_restriction">monomorphism restriction</a>!
Unfortunately, <code>rustc</code> does not have the <a href="https://typeclasses.com/ghc/no-monomorphism-restriction"><code>NoMonomorphismRestriction</code></a> pragma.</p>

<h3 id="functional-abstraction"><a href="#functional-abstraction">Functional abstraction</a></h3>
<p>Factoring code into a function might be harder than you expect because the compiler cannot reason about aliasing across function boundaries.
Let&#39;s say we have the following code.</p>
<div><pre><code>impl State {
  fn tick(&amp;mut self) {
    self.state = match self.state {
      Ping(s) =&gt; { self.x += 1; Pong(s) }
      Pong(s) =&gt; { self.x += 1; Ping(s) }
    }
  }
}</code></pre></div>
<p>The <code>self.x += 1</code> statement appears multiple times.
Why not extract it into a method…</p>
<div><pre><code>impl State {
  fn tick(&amp;mut self) {
    self.state = match self.state {
      Ping(s) =&gt; { self.inc(); Pong(s) } // ← compile error
      Pong(s) =&gt; { self.inc(); Ping(s) } // ← compile error
    }
  }

  fn inc(&amp;mut self) {
    self.x += 1;
  }
}</code></pre></div>
<p>Rust will bark at us because the method attempts to re-borrow <code>self</code> exclusively while the surrounding context still holds a mutable reference to <code>self.state</code>.</p>
<p>Rust 2021 edition implemented <a href="https://doc.rust-lang.org/edition-guide/rust-2021/disjoint-capture-in-closures.html">disjoint capture</a> to address a similar issue with closures.
Before Rust 2021, code that looked like <code>x.f.m(|| x.y)</code> might not compile but manually inlining <code>m</code> and the closure would resolve the error.
For example, imagine we have a struct that owns a map and a default value for map entries.</p>
<div><pre><code>struct S { map: HashMap&lt;i64, String&gt;, def: String }

impl S {
  fn ensure_has_entry(&amp;mut self, key: i64) {
    // Doesn&#39;t compile with Rust 2018:
    self.map.entry(key).or_insert_with(|| self.def.clone());
// |         ------            -------------- ^^ ---- second borrow occurs...
// |         |                 |              |
// |         |                 |              immutable borrow occurs here
// |         |                 mutable borrow later used by call
// |         mutable borrow occurs here
  }
}</code></pre></div>

<p>However, if we inline the definition of <code>or_insert_with</code> and the lambda function, the compiler can finally see that the borrowing rules hold.</p>

<div><pre><code>struct S { map: HashMap&lt;i64, String&gt;, def: String }

impl S {
  fn ensure_has_entry(&amp;mut self, key: i64) {
    use std::collections::hash_map::Entry::*;
    <em>// This version is more verbose, but it works with Rust 2018.</em>
    match self.map.entry(key) {
      Occupied(mut e) =&gt; e.get_mut(),
      Vacant(mut e) =&gt; e.insert(self.def.clone()),
    };
  }
}</code></pre></div>

<p>When someone asks you, <span>“what tricks can Rust closures do that named functions cannot?”</span> you will know the answer: they can capture only the fields they use.</p>

<h3 id="newtype-abstrction"><a href="#newtype-abstrction">Newtype abstraction</a></h3>

<p>The <a href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html">new type idiom</a><label for="sn-strong-typedef"></label><span>Folks in the C++ land call this idiom <a href="https://www.boost.org/doc/libs/1_42_0/boost/strong_typedef.hpp">strong typedef</a>.</span> in Rust allows the programmer to give a new identity to an existing type.
The idiom&#39;s name comes from Haskell&#39;s <a href="https://wiki.haskell.org/Newtype"><code>newtype</code></a> keyword.</p>
<p>One of the common uses of this idiom is to work around the <a href="#orphan-rules">orphan rules</a> and define trait implementation for the aliased type.
For example, the following code defines a new type that displays byte vectors in hex.</p>

<div><pre><code>struct Hex(Vec&lt;u8&gt;);

impl std::fmt::Display for Hex {
  fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
    self.0.iter().try_for_each(|b| write!(f, &#34;{:02x}&#34;, b))
  }
}

println!(&#34;{}&#34;, Hex((0..32).collect()));
<em>// =&gt; 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f</em></code></pre></div>

<p>The new type idiom is efficient: the representation of the <code>Hex</code> type in the machine&#39;s memory is identical to that of <code>Vec&lt;u8&gt;</code>.
However, despite the identical representation, the compiler does not treat our new type as a strong alias for <code>Vec&lt;u8&gt;</code>.
For example, we cannot safely transform <code>Vec&lt;Hex&gt;</code> to <code>Vec&lt;Vec&lt;u8&gt;&gt;</code> and back without reallocating the outer vector.
Also, without copying the bytes, we cannot safely coerce <code>&amp;Vec&lt;u8&gt;</code> to <code>&amp;Hex</code>.</p>

<div><pre><code>fn complex_function(bytes: &amp;Vec&lt;u8&gt;) {
  // … a lot of code …

  println!(&#34;{}&#34;, &amp;Hex(bytes));        // That does not work.
  println!(&#34;{}&#34;, Hex(bytes.clone())); // That works but is slow.

  // … a lot of code …
}</code></pre></div>

<p>Overall, the newtype idiom is a leaky abstraction because it is a convention, not a first-class language feature.
If you wonder how Haskell solved this problem, I recommend watching the <a href="https://www.youtube.com/watch?v=iLZdN-R1JGk">Safe, Zero-Cost Coercions in Haskell</a> talk by Simon Peyton Jones.</p>

<h3 id="views-and-bundles"><a href="#views-and-bundles">Views and bundles</a></h3>
<p>Each time the programmer describes a struct field or passes an argument to a function, she must decide whether the field/argument should be <a href="#objects-values-references">an object or a reference</a>.
Or maybe the best option is to <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html">decide at runtime</a>?
That is a lot of decision-making!
Unfortunately, sometimes there is no optimal choice.
On such occasions, we grit our teeth and define several versions of the same type with slightly different field types.</p>

<p>Most functions in Rust take arguments by reference and return results as a self-contained object<label for="sn-view-exceptions"></label><span>There are plenty of exceptions, of course.
Sometimes we pass arguments by value if making a copy is cheap or the function can efficiently reuse its input to produce the result.
Some functions return references to one of their arguments.</span>.
This pattern is so common that it might be helpful to define new terms.
I call input types with lifetime parameters <em>views</em> because they are optimal for inspecting data.
I call regular output types <em>bundles</em> because they are self-contained.</p>

<p>The following snippet comes from the (sunset) <a href="https://github.com/bytecodealliance/lucet">Lucet</a> WebAssembly runtime.</p>
<div><pre><code><em>/// A WebAssembly global along with its export specification.</em>
<em>/// The lifetime parameter exists to support zero-copy deserialization</em>
<em>/// for the `&amp;str` fields at the leaves of the structure.</em>
<em>/// For a variant with owned types at the leaves, see `OwnedGlobalSpec`.</em>
pub struct <a href="https://github.com/bytecodealliance/lucet/blob/51fb1ed414fe44f842db437d94abb6eb439d7c92/lucet-module/src/globals.rs#L8"><code>GlobalSpec</code></a>&lt;&#39;a&gt; {
    global: Global&lt;&#39;a&gt;,
    export_names: Vec&lt;&amp;&#39;a str&gt;,
}

…

<em>/// A variant of `GlobalSpec` with owned strings throughout.</em>
<em>/// This type is useful when directly building up a value to be serialized.</em>
pub struct <a href="https://github.com/bytecodealliance/lucet/blob/51fb1ed414fe44f842db437d94abb6eb439d7c92/lucet-module/src/globals.rs#L112"><code>OwnedGlobalSpec</code></a> {
    global: OwnedGlobal,
    export_names: Vec&lt;String&gt;,
}</code></pre></div>
<p>The authors duplicated the <code>GlobalSpec</code> data structure to support two use cases:</p>
<ul><li><code>GlobalSpec&lt;&#39;a&gt;</code> is a <em>view</em> object that the code authors parse from a byte buffer.
Individual fields of this view point back to the relevant regions of the buffer.
This representation is helpful for functions that need to inspect values of type <code>GlobalSpec</code> without modifying them.</li>
<li><code>OwnedGlobalSpec</code> is a <em>bundle</em>: it does not contain references to other data structures.
This representation is helpful for functions that construct values of type <code>GlobalSpec</code> and pass them around or put them into a container.</li></ul>
<p>In a language with automatic memory management, we can combine the efficiency of <code>GlobalSpec&lt;&#39;a&gt;</code> with the versatility of <code>OwnedGlobalSpec</code> in a single type declaration.</p></section>


<section><h2 id="composition-hurts"><a href="#composition-hurts">When composition hurts</a></h2>
<p>Building a working program from smaller pieces can be frustrating in Rust.</p>

<h3 id="object-composition"><a href="#object-composition">Object composition</a></h3>
<p>When programmers have two distinct objects, they often want to combine them into a single structure.
Sounds easy? Not in Rust.</p>
<p>Assume we have an object <code>Db</code> that has a method giving you another object, <code>Snapshot&lt;&#39;a&gt;</code>.
The lifetime of the snapshot depends on the lifetime of the database.</p>
<div><pre><code>struct Db { /* … */ }

struct Snapshot&lt;&#39;a&gt; { /* … */ }

impl Db { fn snapshot&lt;&#39;a&gt;(&amp;&#39;a self) -&gt; Snapshot&lt;&#39;a&gt;; }</code></pre></div>

<p>We might want to bundle<label for="sn-db-iterator"></label><span>If you wonder why we have this strange desire, you can read comments from the <a href="https://sourcegraph.com/github.com/dfinity/ic@d14361f9939baaeb899106b874851ad4a0ce928b/-/blob/rs/artifact_pool/src/rocksdb_iterator.rs?L153-164"><code>rocksdb_iterator.rs</code></a> module.</span> the database with its snapshot, but Rust will not let us.</p>

<div><pre><code><em>// There is no way to define the following struct without</em>
<em>// contaminating it with lifetimes.</em>
struct DbSnapshot {
  snapshot: Snapshot&lt;&#39;a&gt;, <em>// what should &#39;a be?</em>
  db: Arc&lt;Db&gt;,
}</code></pre></div>

<p>Rust folks call this arrangement <span>“sibling pointers”</span>.
Rust forbids sibling pointers in safe code because they undermine Rust&#39;s safety model.</p>
<p>As discussed in the <a href="#objects-values-references">Objects, values, and references</a> section, modifying a referenced object is usually a bug.
In our case, the <code>snapshot</code> object might depend on the physical location of the <code>db</code> object.
If we move the <code>DbSnapshot</code> as a whole, the physical location of the <code>db</code> field will change, corrupting references in the <code>snapshot</code> object.
We <em>know</em> that moving <code>Arc&lt;Db&gt;</code> will not change the location of the <code>Db</code> object, but there is no way to communicate this information to <code>rustc</code>.</p>
<p>Another issue with <code>DbSnapshot</code> is that the order of its field <a href="https://doc.rust-lang.org/stable/reference/destructors.html">destruction</a> matters.
If Rust allowed sibling pointers, changing the field order could introduce undefined behavior: the <code>snapshot</code>&#39;s destructor could try to access fields of a destroyed <code>db</code> object.</p>

<h3 id="pattern-matching-boxes"><a href="#pattern-matching-boxes">Pattern matching cannot see through boxes</a></h3>
<p>In Rust, we cannot pattern-match on boxed types such as <code>Box</code>, <code>Arc</code>, <code>String</code>, and <code>Vec</code>.
This restriction is often a deal-breaker because we cannot avoid boxing when we define recursive data types.</p>

<p>For example, let us try to match a vector of strings.</p>

<div><pre><code>let x = vec![&#34;a&#34;.to_string(), &#34;b&#34;.to_string()];
match x {
//    - help: consider slicing here: `x[..]`
    [&#34;a&#34;, &#34;b&#34;] =&gt; println!(&#34;OK&#34;),
//  ^^^^^^^^^^ pattern cannot match with input type `Vec&lt;String&gt;`
    _ =&gt; (),
}</code></pre></div>

<p>First, we can&#39;t match a vector, only on a slice.
Luckily, the compiler suggests an easy fix: we must replace <code>x</code> with <code>x[..]</code> in the <code>match</code> expression.
Let us give it a try.</p>

<div><pre><code>let x = vec![&#34;a&#34;.to_string(), &#34;b&#34;.to_string()];
match x[..] {
//    ----- this expression has type `[String]`
    [&#34;a&#34;, &#34;b&#34;] =&gt; println!(&#34;OK&#34;),
//   ^^^ expected struct `String`, found `&amp;str`
    _ =&gt; (),
}</code></pre></div>

<p>As you can see, removing one layer of boxes is not enough to make the compiler happy.
We also need to unbox the strings inside of the vector, which is not possible without allocating a new vector:</p>

<div><pre><code>let x = vec![&#34;a&#34;.to_string(), &#34;b&#34;.to_string()];
// We have to allocate new storage.
let x_for_match: Vec&lt;_&gt; = x.iter().map(|s| s.as_str()).collect();
match &amp;x_for_match[..] {
    [&#34;a&#34;, &#34;b&#34;] =&gt; println!(&#34;OK&#34;), // this compiles
    _ =&gt; (),
}</code></pre></div>
<p>Forget about <a href="https://www.cs.tufts.edu/comp/150FP/archive/chris-okasaki/redblack99.pdf">balancing Red-Black trees</a> in five lines of code in Rust.</p>

<h3 id="orphan-rules"><a href="#orphan-rules">Orphan rules</a></h3>
<p>Rust uses <a href="https://doc.rust-lang.org/reference/items/implementations.html?highlight=orphan#orphan-rules">orphan rules</a> to decide whether a type can implement a trait.
For non-generic types, these rules forbid implementing a trait for a type outside of crates defining the trait or the type.
In other words, the package defining the trait must depend on the package defining the type or vice versa.</p>
<figure><label for="mn-orphan-rules">⊕</label><span>Orphan rules in Rust demand that a trait implementation resides in the crate defining the trait or the crate defining the type.
Boxes represent separate crates, arrows—crate dependencies.</span>
</figure>
<p>These rules make it easy for the compiler to guarantee <em>coherence</em>, which is a smart way to say that all parts of your program see the same trait implementation for a particular type.
In exchange, this rule significantly complicates integrating traits and types from unrelated libraries.</p>
<p>One example is traits we want to use only in tests, such as <a href="https://altsysrq.github.io/rustdoc/proptest/1.0.0/proptest/arbitrary/trait.Arbitrary.html"><code>Arbitrary</code></a> from the <a href="https://crates.io/crates/proptest">proptest</a> package.
We can save a lot of typing if the compiler derives implementations for types from our package, but we want our production code to be independent of the <code>proptest</code> package.
In the perfect setup, all the <code>Arbitrary</code> implementations would go into a separate test-only package.
Unfortunately, orphan rules oppose this arrangement, forcing us to bite the bullet and write proptest strategies <a href="https://altsysrq.github.io/proptest-book/proptest/tutorial/macro-prop-compose.html">manually</a> instead<label for="sn-orphan-workaround"></label><span>There are workarounds for this issue, such as using <a href="https://doc.rust-lang.org/cargo/reference/features.html">cargo features</a> and conditional compilation, but they complicate the build setup so much that writing boilerplate is usually a better option.</span>.</p>

<p>Type conversion traits, such as <code>From</code> and <code>Into</code>, are also problematic under orphan rules.
I often see <code>xxx-types</code> packages that start small but end up as bottlenecks in the compilation chain.
Splitting such packages into smaller pieces is often daunting because of the intricate webs of type conversions connecting distant types together.
Orphan rules do not allow us to cut these packages on module boundaries and move all conversions into a separate package without doing a lot of tedious work.</p>

<p>Do not get me wrong: orphan rules are a great default.
Haskell allows you to define <a href="https://wiki.haskell.org/Orphan_instance">orphan instances</a>, but programmers frown upon this practice.
It is the inability to escape orphan rules that makes me sad.
In large codebases, decomposing large packages into smaller pieces and maintaining shallow dependencies graphs are the only path to acceptable compilation speed.
Orphan rules often stay in the way of trimming dependency graphs.</p></section>


<section><h2 id="fearless-concurrency"><a href="#fearless-concurrency">Fearless concurrency is a lie</a></h2>
<p>The Rust team coined the term <a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Fearless Concurrency</a> to indicate that Rust helps you avoid common pitfalls associated with parallel and concurrent programming.
Despite these claims, my <a href="https://en.wikipedia.org/wiki/Cortisol">cortisol</a> level goes up every time I introduce concurrency to my Rust programs.</p>

<h3 id="deadlocks"><a href="#deadlocks">Deadlocks</a></h3>
<div><blockquote><p>So it&#39;s perfectly <span>“fine”</span> for a Safe Rust program to get deadlocked or do something nonsensical with incorrect synchronization.
Obviously such a program isn&#39;t very good, but Rust can only hold your hand so far.</p>
</blockquote></div>
<p>Safe Rust prevents a specific type of concurrency bug called <em>data race</em>.
Concurrent Rust programs have plenty of other ways to behave incorrectly.</p>
<p>One class of concurrency bugs that I experienced firsthand is <a href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a>.
A typical explanation of this class of bugs involves two locks and two processes trying to acquire the locks in opposite orders.
However, if the locks you use are not <a href="https://stackoverflow.com/questions/1312259/what-is-the-re-entrant-lock-and-concept-in-general">re-entrant</a> (and Rust&#39;s locks are not), having a single lock is enough to cause a deadlock.</p>
<p>For example, the following code is buggy because it attempts to acquire the same lock twice.
The bug might be hard to spot if <code>do_something</code> and <code>helper_function</code> are large and live far apart in the source file or if we call <code>helper_function</code> on a rare execution path.</p>
<div><pre><code>impl Service {
  pub fn do_something(&amp;self) {
    let guard = self.lock.read();
    <em>// …</em>
    self.helper_function(); <em>// <b>BUG</b>: will panic or deadlock</em>
    <em>// …</em>
  }

  fn helper_function(&amp;self) {
    let guard = self.lock.read();
    <em>// …</em>
  }
}</code></pre></div>
<p>The documentation for <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html#method.read"><code>RwLock::read</code></a> mentions that the function <em>might</em> panic if the current thread already holds the lock.
All I got was a hanging program.</p>
<p>Some languages tried to provide a solution to this problem in their concurrency toolkits.
The Clang compiler has <a href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html">Thread safety annotations</a> enabling a form of static analysis that can detect race conditions and deadlocks.
However, the best way to avoid deadlocks is not to have locks.
Two technologies that approach the problem fundamentally are <a href="https://en.wikipedia.org/wiki/Software_transactional_memory">Software Transaction Memory</a> (implemented in <a href="https://wiki.haskell.org/Software_transactional_memory">Haskell</a>, <a href="https://clojure.org/reference/refs">Clojure</a>, and <a href="https://nbronson.github.io/scala-stm/">Scala</a>) and the <a href="https://en.wikipedia.org/wiki/Actor_model">actor model</a> (<a href="https://www.erlang.org/">Erlang</a> was the first language that fully embraced it).</p>


<div><blockquote><p>We can view a path as an <em>address</em>.
Then a string representing a path is a pointer, and accessing a file through a path is a pointer dereference.
Thus, component interference due to file overwriting can be viewed as an address collision problem: two components occupy overlapping parts of the address space.</p>
</blockquote></div>
<p>Rust gives us powerful tools to deal with shared memory.
However, once our programs need to interact with the outside world (e.g., use a network interface or a filesystem), we are on our own.
Rust is similar to most modern languages in this regard.
However, it can give you a false sense of security.</p>
<p>Remember that paths are raw pointers, even in Rust.
Most file operations are inherently unsafe and can lead to data races (in a broad sense) if you do not correctly synchronize file access.
For example, as of February 2023, I still experience a six-year-old <a href="https://github.com/rust-lang/rustup/issues/988">concurrency bug</a> in <a href="https://rustup.rs/">rustup</a>.</p>

<h3 id="implicit-async-runtimes"><a href="#implicit-async-runtimes">Implicit async runtimes</a></h3>
<div><blockquote><p>I cannot seriously believe in it because the theory cannot be reconciled with the idea that physics should represent a reality in time and space, free from spooky action at a distance.</p>
</blockquote></div>

<p>The value of Rust that I like the most is its focus on local reasoning.
Looking at the function&#39;s type signature often gives you a solid understanding of what the function can do.
State mutations are explicit thanks to mutability and lifetime annotations.
Error handling is explicit and intuitive thanks to the ubiquitous <code>Result</code> type.
When used correctly, these features often lead to the mystical <a href="https://wiki.haskell.org/Why_Haskell_just_works">if it compiles—it works</a> effect.
Asynchronous programming in Rust is different, however.</p>

<p>Rust supports the <a href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html"><code>async/.await</code></a> syntax for defining and composing asynchronous functions, but the runtime support is limited.
Several libraries (called <a href="https://ncameron.org/blog/what-is-an-async-runtime/">async runtimes</a>) define asynchronous functions to interact with the operating system.
The <a href="https://crates.io/crates/tokio">tokio</a> package is the most popular library.</p>
<p>One common issue with runtimes is that they rely on passing arguments implicitly.
For example, the tokio runtime allows you to <a href="https://docs.rs/tokio/latest/tokio/fn.spawn.html"><code>spawn</code></a> a concurrent task at any point in your program.
For this function to work, the programmer has to construct a runtime object in advance.</p>
<div><pre><code>fn innocently_looking_function() {
  <a href="https://docs.rs/tokio/1.25.0/tokio/fn.spawn.html"><code>tokio::spawn</code></a>(some_async_func());
  // ^
  // |
  // <em>This code will panic if we remove this line. Spukhafte Fernwirkung!</em>
} //                                     |
  //                                     |
fn main() { //                           v
  let _rt = <a href="https://docs.rs/tokio/1.25.0/tokio/runtime/struct.Runtime.html"><code>tokio::runtime::Runtime</code></a>::new().unwrap();
  innocently_looking_function();
}</code></pre></div>
<p>These implicit arguments turn compile-time errors into runtime errors.
What should have been a compile error turns into a debugging adventure:</p>
<ul><li>If the runtime were an explicit argument, the code would not compile unless the programmer constructed a runtime and passed it as an argument.
When the runtime is implicit, your code might compile fine but will crash at runtime if you forget to annotate your main function with a <a href="https://docs.rs/tokio/latest/tokio/attr.main.html">magical macro</a>.</li>
<li>Mixing libraries that chose different runtimes is <a href="https://www.ncameron.org/blog/portable-and-interoperable-async-rust/">complicated</a>.
The problem is even more confusing if it involves multiple major versions of the same runtime.
My experience writing async Rust code resonates with the <a href="https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo.html">Status Quo</a> stories collected by the <a href="https://rust-lang.github.io/wg-async/welcome.html">Async Working Group</a>.</li></ul>
<p>Some might argue that threading ubiquitous arguments through the entire call stack is unergonomic.
<a href="https://mmapped.blog/posts/03-rust-packages-crates-modules.html#explicit-dependencies">Explicitly passing all arguments</a> is the only approach that scales well.</p></section>

<section><h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2>
<div><blockquote cite="https://www.stroustrup.com/quotes.html"><p>There are only two kinds of languages: the ones people complain about and the ones nobody uses.</p>
</blockquote></div>
<p>Rust is a disciplined language that got many important decisions right, such as an uncompromising focus on safety, the trait system design<label for="sn-trait-system-cpp"></label><span>I&#39;m looking at you, <a href="https://en.cppreference.com/w/cpp/language/constraints">C++ Concepts</a>.</span>, the lack of implicit conversions, and a holistic approach to <a href="https://mmapped.blog/posts/12-rust-error-handling.html">error handling</a>.
It allows us to develop robust and memory-safe programs relatively quickly without compromising execution speed.</p>
<p>Yet, I often find myself overwhelmed with accidental complexity, especially when I care little about performance and want to get something working quickly (for example, in test code).
Rust can complicate <a href="#abstraction-hurts">decomposing</a> your program into smaller pieces and <a href="#composition-hurts">composing</a> it from smaller pieces.
Rust only partially eliminates the <a href="#fearless-concurrency">concurrency issues</a>.
Oh well, no language is perfect for every problem.</p>

<p>You can discuss this article on <a href="https://www.reddit.com/r/rust/comments/112hmga/blog_post_when_rust_hurts/">Reddit</a>.</p></section>

<hr/>

</article></div>
  </body>
</html>
