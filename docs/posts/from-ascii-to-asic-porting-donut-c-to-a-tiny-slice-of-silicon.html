<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.a1k0n.net/2025/01/10/tiny-tapeout-donut.html">Original</a>
    <h1>From ASCII to ASIC: Porting donut.c to a tiny slice of silicon</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        <p>Jan 10, 2025</p>
        <p>For many years after coming up with
<a href="https://www.a1k0n.net/2006/09/15/obfuscated-c-donut.html">donut.c</a>, I wondered in the back of my
mind if it could be simplified somehow, like maybe there was a way to raytrace a
donut with a small chunk of code. In October 2023, I tweeted
<a href="https://x.com/a1k0n/status/1716306717196030290" target="_blank">a dumb random epiphany</a> where I
figured out another way to do it which requires no memory, no sines or cosines,
no square roots, no divisions, and technically, not even any multiplications. The
whole thing can be rendered with just shifts and adds, and there&#39;s an <a href="https://www.a1k0n.net/code/donutbitops.c.html">updated C version here</a>.</p>

<p>It took almost another year to put this idea into action with an actual hardware
implementation.  In early September 2024, I submitted a 4-tile design to
<a href="https://tinytapeout.com/" target="_blank">Tiny Tapeout 8</a>, taking up 0.8% of a 130nm process
chip shared with many other designs. This chip is currently (as of January 2025)
being manufactured by SkyWater Technologies, and if my design works, it will
render this to a VGA monitor:</p>

<p><video playsinline="" autoplay="" muted="" loop="" poster="/img/tt08-vgadonut.png"><source src="/img/tt08-vgadonut.mp4"/> <i>video unavailable</i></video></p>

<p>This design is <em>not rendering polygons</em>! Instead, it&#39;s making an iterative
approximation of a ray-traced donut, and it is racing the VGA beam — every
39 nanoseconds, the monitor is going to show the next pixel, ready or not, practical
considerations limit us to a ~50MHz clock, and we have no memory buffer
whatsoever — so it doesn&#39;t have enough time to do a good job; the polygonal
appearance is a complete accident!</p>

<p>And no, I already know what you&#39;re going to ask: the actual silicon is not in
the shape of a donut. Maybe next time. It takes about 7000 standard cells (i.e., flip flops or logic gates), and you can
actually see a 3D view of the die <a href="https://gds-viewer.tinytapeout.com/?model=https://a1k0n.github.io/tt08-vga-donut/tinytapeout.gds.gltf" target="_blank">here</a> thanks to the amazing tools the Tiny Tapeout team has put together.</p>

<p>With more die area, and/or a faster clock (which would need something more
modern than the 130nm SkyWater process), this could be pipelined so that every
pixel was perfectly rendered, but the point was to make it as small as I could.</p>

<h2 id="source">Source</h2>

<p>The TinyTapeout Verilog project is <a href="https://github.com/a1k0n/tt08-vga-donut/" target="_blank">on github here</a> with a Verilator testbench which produced the above video and an <a href="https://orangecrab-fpga.github.io/orangecrab-hardware/" target="_blank">OrangeCrab FPGA</a> version I used to develop.</p>

<p>Because I developed it on an OrangeCrab, I ended up using its native 48MHz clock
for all timing; typically VGA would have a 25.175MHz clock, so I opted to use a
slighly strange VGA mode of 1220x480 in order to have the timing work out. This
looks great on an analog CRT, but LCD monitors can end up with weird aliasing
artifacts. Lesson learned.</p>

<p>I have this and two other designs (which deserve their own write-ups!) on Tiny
Tapeout 8 and they were my first real Verilog projects; the code is frankly
atrocious in order to get everything to fit under tight constraints.</p>

<h2 id="rendering-donuts-with-just-shifts-and-adds">Rendering donuts with just shifts and adds</h2>

<p>The trick is to represent the torus as a signed distance function and <a href="https://en.wikipedia.org/wiki/Ray_marching" target="_blank">&#34;raymarch&#34;</a>
it, which is a <a href="https://iquilezles.org/articles/raymarchingdf/" target="_blank">shockingly powerful technique popularized by Inigo
Quilez</a>, who does incredible
work.  His site is a treasure trove in general, but see this excerpt from his <a href="https://iquilezles.org/articles/distfunctions/" target="_blank">distance functions page</a>:</p>

<p><img src="https://www.a1k0n.net/img/iq-torus.png" alt="torus as signed distance function"/></p>

<p>The signed distance to a torus can be computed by two 2-dimensional length
operations in sequence. Guess how you can compute the length of a 2D vector?
With <a href="https://en.wikipedia.org/wiki/CORDIC" target="_blank">CORDIC</a>, a variation on the same
trick I used <a href="https://www.a1k0n.net/2021/01/13/optimizing-donut.html">last time</a>!</p>

<p>The implication of this is that you can find the intersection of a ray and a
donut by ray marching: starting at the 3D location of the screen, calculate the
above function to find the distance; then, move that distance along the ray
between the origin and the pixel you are rendering, and repeat the whole process
until the distance converges near 0.</p>

<p>That gives you the point, but what color do we actually render? We need the
surface normal to compute lighting, which requires rotating the light direction
vector along the two axes of the torus with whatever angle we happened to hit it
at. This seemed way too complicated at first.</p>

<p>The random epiphany I had was this: the amount we need to rotate the lighting
vector to find the surface normal is <em>exactly the same</em> as the rotations we
undid to find the distance to the torus in the first place! And furthermore, we
can do this rotation almost for free as a side effect of computing those
lengths.</p>

<p>Let me try to explain.</p>

<h3 id="vectoring-mode-cordic">Vectoring mode CORDIC</h3>

<p>There&#39;s a trick where you can compute <span data-katex="">\sqrt{x^2 + y^2}</span> using only shifts
and adds, a profoundly clever application of CORDIC: you iteratively rotate the
<span data-katex="">\overrightarrow{(x,y)}</span> vector toward the <span data-katex="">x</span> axis, one &#34;bit&#34; at a time (first by <span data-katex="">\arctan 1</span>=
45°, by <span data-katex="">\arctan \frac{1}{2}</span> = 26.5°, <span data-katex="">\arctan \frac{1}{4}</span> = 14.04°, etc). This not only allows you to recover the
length but also the angle, in effect transforming between Cartesian and polar
coordinates.</p>



<p>The above widget is running this code for eight iterations and drawing all the
intermediate steps in various colors, with the bold green line being the final
iteration:</p>
<pre><span><span><span>function</span> <span>cordicLength</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>n</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// x must be in right half-plane; since we only really care about distance, we
</span></span></span><span><span><span></span>    <span>// discard the fact that we did this, but we could set a flag to recover the
</span></span></span><span><span><span></span>    <span>// correct angle here.
</span></span></span><span><span><span></span>    <span>if</span> <span>(</span><span>x</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>x</span> <span>=</span> <span>-</span><span>x</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>for</span> <span>(</span><span>var</span> <span>i</span><span>=</span><span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>var</span> <span>t</span> <span>=</span> <span>x</span><span>;</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>y</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>x</span> <span>-=</span> <span>y</span><span>&gt;&gt;</span><span>i</span><span>;</span>
</span></span><span><span>            <span>y</span> <span>+=</span> <span>t</span><span>&gt;&gt;</span><span>i</span><span>;</span>
</span></span><span><span>        <span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>            <span>x</span> <span>+=</span> <span>y</span><span>&gt;&gt;</span><span>i</span><span>;</span>
</span></span><span><span>            <span>y</span> <span>-=</span> <span>t</span><span>&gt;&gt;</span><span>i</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>return</span> <span>x</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></pre>
<p>The way this works is that the shifts and adds here perform a rotation and scale; effectively doing this matrix multiplication:</p>
<p>
\left[\begin{matrix} x_{i+1} \\ y_{i+1} \end{matrix}\right] =

\left[\begin{matrix} 1 &amp; \mp 2^{-i} \\ \pm 2^{-i} &amp; 1\end{matrix}\right]
\left[\begin{matrix} x_i \\ y_i \end{matrix}\right]

= 
\left[\begin{matrix} 1 &amp; \mp \tan \theta_i \\ \pm \tan \theta_i &amp; 1\end{matrix}\right]
\left[\begin{matrix} x_i \\ y_i \end{matrix}\right]
</p><p>If the point is above the <span data-katex="">x</span>-axis, we rotate it clockwise, otherwise rotate it
counterclockwise, making smaller and smaller adjustments. The angles we&#39;re rotating by are <span data-katex="">\theta_i = \arctan 2^{-i}</span>.</p>

<p>The obvious problem, and you can see it in the iterations above, is that each
one of these operations isn&#39;t just rotating but also making the vector longer.
However, it always makes it longer by the same amount, because we&#39;re always
doing the same rotations (just changing the sign of them). This works out to a
scale factor of about 0.607. So if we keep track of how much we&#39;ve pre-scaled
the lengths by doing this operation, we can correct for it later.</p>



<p>By making a small tweak, we can rotate (and scale, by the same .607 factor) a
second vector by the angle of the original vector in the process of finding the
original vector&#39;s length.</p>

<canvas id="cordic-demo-2"></canvas>

<p>Now if blue vector <span data-katex="">\overrightarrow{(x_2, y_2)}</span> is our &#34;extra&#34; vector, the
black vector <span data-katex="">\overrightarrow{(x,y)}</span> is the one we want to find the length of,
and the green line finds the relative angle between the two vectors, independent
of the length of <span data-katex="">(x,y)</span>.</p>
<pre><span><span><span>function</span> <span>rotateCordic</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>x2</span><span>,</span> <span>y2</span><span>,</span> <span>n</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>xsign</span> <span>=</span> <span>1</span><span>;</span>
</span></span><span><span>    <span>// if we&#39;re in the left half-plane, then negating the input x, y and the
</span></span></span><span><span><span></span>    <span>// output x2, y2 will give the correct result
</span></span></span><span><span><span></span>    <span>if</span> <span>(</span><span>x</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>x</span> <span>=</span> <span>-</span><span>x</span><span>;</span>
</span></span><span><span>        <span>y</span> <span>=</span> <span>-</span><span>y</span><span>;</span>
</span></span><span><span>        <span>xsign</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>for</span> <span>(</span><span>var</span> <span>i</span><span>=</span><span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>var</span> <span>t</span> <span>=</span> <span>x</span><span>;</span>
</span></span><span><span>        <span>var</span> <span>t2</span> <span>=</span> <span>x2</span><span>;</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>y</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>x</span> <span>-=</span> <span>y</span><span>&gt;&gt;</span><span>i</span><span>;</span>
</span></span><span><span>            <span>y</span> <span>+=</span> <span>t</span><span>&gt;&gt;</span><span>i</span><span>;</span>
</span></span><span><span>            <span>x2</span> <span>-=</span> <span>y2</span><span>&gt;&gt;</span><span>i</span><span>;</span>
</span></span><span><span>            <span>y2</span> <span>+=</span> <span>t2</span><span>&gt;&gt;</span><span>i</span><span>;</span>
</span></span><span><span>        <span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>            <span>x</span> <span>+=</span> <span>y</span><span>&gt;&gt;</span><span>i</span><span>;</span>
</span></span><span><span>            <span>y</span> <span>-=</span> <span>t</span><span>&gt;&gt;</span><span>i</span><span>;</span>
</span></span><span><span>            <span>x2</span> <span>+=</span> <span>y2</span><span>&gt;&gt;</span><span>i</span><span>;</span>
</span></span><span><span>            <span>y2</span> <span>-=</span> <span>t2</span><span>&gt;&gt;</span><span>i</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>// x is now the length of x,y and [x2*xsign, y2*xsign] is the rotated vector
</span></span></span><span><span><span></span>    <span>return</span> <span>[</span><span>x</span><span>,</span> <span>x2</span><span>*</span><span>xsign</span><span>,</span> <span>y2</span><span>*</span><span>xsign</span><span>]</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></pre>
<p><em>tweaked CORDIC function to rotate an auxiliary vector</em></p>

<p>This is exactly what we need to compute lighting: if we feed in the lighting
direction unit vector and the surface normal, the <span data-katex="">x</span> coordinate of the green
line is the cosine of the angle between them; we&#39;ve managed to do a vector dot
product without any multiplications as a side effect while computing a distance.</p>

<p>How do we know what the surface normal is? Well, it turns out that when the
ray-marching converges, the points we&#39;re taking lengths of are relative to the
center ring of the torus, so they point in the direction of the surface normal
by definition.</p>

<p>Here&#39;s a little animation illustrating the process of finding the closest point
on a torus: first, you find the point in the center ring of the torus closest to
your point, which is equivalent to projecting your point onto the torus&#39;s x-z
plane and scaling the distance to <span data-katex="">r_1</span>. This new point is the center of a ring
of radius <span data-katex="">r_2</span> in the plane defined by that point, the original point, and the
center of the torus. Then, do another projection of the original point in that
plane out to a distance of <span data-katex="">r_2</span>.</p>

<p><video playsinline="" muted="" autoplay="" loop=""><source src="/img/TorusDistanceDemo.mp4"/> <i>video unavailable</i></video></p>
<pre><span><span><span>float</span> <span>distance_to_torus</span><span>(</span><span>float</span> <span>x</span><span>,</span> <span>float</span> <span>y</span><span>,</span> <span>float</span> <span>z</span><span>,</span> <span>float</span> <span>r1</span><span>,</span> <span>float</span> <span>r2</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>// First, we find the distance from point p to a circle of radius r1 on the x-z plane
</span></span></span><span><span><span></span>  <span>float</span> <span>dist_to_r1_circle</span> <span>=</span> <span>length</span><span>(</span><span>x</span><span>,</span> <span>z</span><span>)</span> <span>-</span> <span>r1</span><span>;</span>
</span></span><span><span>  <span>// Then, find the distance in the cross section of the torus from the center ring to point p
</span></span></span><span><span><span></span>  <span>return</span> <span>length</span><span>(</span><span>dist_to_r1_circle</span><span>,</span> <span>y</span><span>)</span> <span>-</span> <span>r2</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></pre>
<p>That last projection line drawn to calculate the final distance between the torus and the point is exactly the surface normal.</p>

<p>It is this two-2D length property of toruses that makes this whole technique
possible; I haven&#39;t been able to come up with a similar way to render a sphere
for instance, which you would think is easier!</p>

<h2 id="ray-marched-donut-c">Ray-marched donut.c</h2>

<p>With this technique in hand, I came up with yet another
donut.c (<a href="https://www.a1k0n.net/code/donutbitops.c.html">source here</a>), shifts and adds only.
It&#39;s not very compact as it takes a lot more C code, but it takes a lot
fewer logic gates.  Soon after I tweeted it out, <a href="https://x.com/BrunoLevy01/status/1718674786954399798" target="_blank">Bruno Levy replied with an
interesting discovery</a>: if
you restrict the number of CORDIC iterations, the donut renders with facets
instead of smoothly!</p>

<p><label for="r1iter">r<sub>1</sub> iterations: </label>
  
  <span id="r1iterval">8</span>
</p>

<p><label for="r2iter">r<sub>2</sub> iterations: </label>
  
  <span id="r2iterval">8</span>
</p>



<p>In the final ASIC version, I used 3 <span data-katex="">r_1</span> iterations and 2 for <span data-katex="">r_2</span>, because
that was as much combinational logic as I could unroll in a single cycle at
48MHz and still meet setup/hold time requirements. That&#39;s why the rendering
looks the way it does.</p>

<h3 id="compound-rotation-without-multiplication">Compound rotation without multiplication</h3>

<p>The rotation of the object as a whole is implemented by tracking eight
variables: sin/cos of angle A, sin/cos of angle B, and four specific products
thereof. In the C code, this is done towards the bottom with a rotation macro <code>R()</code>:</p>
<pre><span><span><span>// HAKMEM 149 - Minsky circle algorithm
</span></span></span><span><span><span></span><span>// Rotates around a point &#34;near&#34; the origin, without losing magnitude
</span></span></span><span><span><span></span><span>// over long periods of time, as long as there are enough bits of precision in x
</span></span></span><span><span><span></span><span>// and y. I use 14 bits here. Cheap way to compute approximate sines/cosines.
</span></span></span><span><span><span></span><span>#</span><span>define R(s,x,y) x-=(y&gt;&gt;s); y+=(x&gt;&gt;s)</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>R</span><span>(</span><span>5</span><span>,</span> <span>cA</span><span>,</span> <span>sA</span><span>)</span><span>;</span>
</span></span><span><span>    <span>R</span><span>(</span><span>5</span><span>,</span> <span>cAsB</span><span>,</span> <span>sAsB</span><span>)</span><span>;</span>
</span></span><span><span>    <span>R</span><span>(</span><span>5</span><span>,</span> <span>cAcB</span><span>,</span> <span>sAcB</span><span>)</span><span>;</span>
</span></span><span><span>    <span>R</span><span>(</span><span>6</span><span>,</span> <span>cB</span><span>,</span> <span>sB</span><span>)</span><span>;</span>
</span></span><span><span>    <span>R</span><span>(</span><span>6</span><span>,</span> <span>cAcB</span><span>,</span> <span>cAsB</span><span>)</span><span>;</span>
</span></span><span><span>    <span>R</span><span>(</span><span>6</span><span>,</span> <span>sAcB</span><span>,</span> <span>sAsB</span><span>)</span><span>;</span>
</span></span></pre>
<p>These are all the products necessary to reconstruct the camera origin and ray directions without explicitly constructing a matrix or direction vector.</p>

<p>Unfortunately, this can drift over time resulting in a very skewed looking
render, so there&#39;s a hack to reinitialize all of these to their zero-rotation
values when a full cycle through A and B complete.</p>

<h3 id="tinytapeout-considerations">TinyTapeout considerations</h3>

<p>TinyTapeout recommended using up to 50MHz for the clock, so I went with 48MHz
(the default clock of my FPGA dev board), giving me about 1220 clocks per
visible horizontal scanline. By cutting back on precision, I was able to stuff
all of the CORDIC iterations into one cycle, but ray-marching needs to iterate
until convergence, and any fewer than 8 iterations looked pretty bad, so I chose
to iterate 8 times, reading the output of the hardware ray marching unit and
loading new ray directions in every 8 clocks. But in order to keep it from
looking too blocky, the horizontal offset is dithered both in space and time,
which is what gives the glitchy/noisy appearance in the video.</p>

<p>Video output is provided through the <a href="https://github.com/mole99/tiny-vga" target="_blank">Tiny VGA Pmod</a>
which has only two bits per RGB channel. To deal with this I chose to do <a href="https://en.wikipedia.org/wiki/Ordered_dithering" target="_blank">ordered
dithering</a>, using 6 bits of internal color depth, and this turns out to be very
easy to do in Verilog. This generates a dithering matrix which alternates every
frame, yielding temporal dithering as well.</p>
<pre><span><span><span>// Bayer dithering
</span></span></span><span><span><span></span><span>// this is a 8x4 Bayer matrix which gets flipped every frame
</span></span></span><span><span><span></span><span>wire</span> <span>[</span><span>2</span><span>:</span><span>0</span><span>]</span> <span>bayer_i</span> <span>=</span> <span>h_count</span><span>[</span><span>2</span><span>:</span><span>0</span><span>]</span> <span>^</span> <span>{</span><span>3</span><span>{</span><span>frame</span><span>[</span><span>0</span><span>]</span><span>}</span><span>}</span><span>;</span>
</span></span><span><span><span>wire</span> <span>[</span><span>1</span><span>:</span><span>0</span><span>]</span> <span>bayer_j</span> <span>=</span> <span>v_count</span><span>[</span><span>1</span><span>:</span><span>0</span><span>]</span><span>;</span>
</span></span><span><span><span>wire</span> <span>[</span><span>2</span><span>:</span><span>0</span><span>]</span> <span>bayer_x</span> <span>=</span> <span>{</span><span>bayer_i</span><span>[</span><span>2</span><span>]</span><span>,</span> <span>bayer_i</span><span>[</span><span>1</span><span>]</span><span>^</span><span>bayer_j</span><span>[</span><span>1</span><span>]</span><span>,</span> <span>bayer_i</span><span>[</span><span>0</span><span>]</span><span>^</span><span>bayer_j</span><span>[</span><span>0</span><span>]</span><span>}</span><span>;</span>
</span></span><span><span><span>wire</span> <span>[</span><span>4</span><span>:</span><span>0</span><span>]</span> <span>bayer</span> <span>=</span> <span>{</span><span>bayer_x</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>bayer_i</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>bayer_x</span><span>[</span><span>1</span><span>]</span><span>,</span> <span>bayer_i</span><span>[</span><span>1</span><span>]</span><span>,</span> <span>bayer_x</span><span>[</span><span>2</span><span>]</span><span>}</span><span>;</span>
</span></span></pre>
<p>This generates a matrix that looks like this, and mirrors horizontally on alternating frames:</p>
<p>
\text{bayer}_{[4:3],[2:0]} =
\left[
\begin{matrix}
 0&amp; 24&amp;  6&amp; 30&amp;  1&amp; 25&amp;  7&amp; 31 \\
16&amp;  8&amp; 22&amp; 14&amp; 17&amp;  9&amp; 23&amp; 15 \\
 4&amp; 28&amp;  2&amp; 26&amp;  5&amp; 29&amp;  3&amp; 27 \\
20&amp; 12&amp; 18&amp; 10&amp; 21&amp; 13&amp; 19&amp; 11

\end{matrix}
\right]
</p><p>This is applied to the 6-bit color like so:</p>
<pre><span><span><span>// output dithered 2 bit color from 6 bit color and 5 bit Bayer matrix
</span></span></span><span><span><span></span><span>function</span> <span>[</span><span>1</span><span>:</span><span>0</span><span>]</span> <span>dither2</span><span>;</span>
</span></span><span><span>    <span>input</span> <span>[</span><span>5</span><span>:</span><span>0</span><span>]</span> <span>color6</span><span>;</span>
</span></span><span><span>    <span>input</span> <span>[</span><span>4</span><span>:</span><span>0</span><span>]</span> <span>bayer5</span><span>;</span>
</span></span><span><span>    <span>begin</span>
</span></span><span><span>        <span>dither2</span> <span>=</span> <span>(</span><span>{</span><span>1</span><span>&#39;b0</span><span>,</span> <span>color6</span><span>}</span> <span>+</span> <span>{</span><span>2</span><span>&#39;b0</span><span>,</span> <span>bayer5</span><span>}</span> <span>+</span> <span>color6</span><span>[</span><span>0</span><span>]</span> <span>+</span> <span>color6</span><span>[</span><span>5</span><span>]</span> <span>+</span> <span>color6</span><span>[</span><span>5</span><span>:</span><span>1</span><span>]</span><span>)</span> <span>&gt;</span><span>&gt;</span> <span>5</span><span>;</span>
</span></span><span><span>    <span>end</span>
</span></span><span><span><span>endfunction</span>
</span></span><span><span>
</span></span><span><span><span>wire</span> <span>[</span><span>1</span><span>:</span><span>0</span><span>]</span> <span>rdither</span> <span>=</span> <span>dither2</span><span>(</span><span>r</span><span>,</span> <span>bayer</span><span>)</span><span>;</span>
</span></span><span><span><span>wire</span> <span>[</span><span>1</span><span>:</span><span>0</span><span>]</span> <span>gdither</span> <span>=</span> <span>dither2</span><span>(</span><span>g</span><span>,</span> <span>bayer</span><span>)</span><span>;</span>
</span></span><span><span><span>wire</span> <span>[</span><span>1</span><span>:</span><span>0</span><span>]</span> <span>bdither</span> <span>=</span> <span>dither2</span><span>(</span><span>b</span><span>,</span> <span>bayer</span><span>)</span><span>;</span>
</span></span></pre>
<h3 id="avoiding-the-last-multiplication">Avoiding the last multiplication</h3>

<p>Another challenge was stepping a 3D unit vector along a specified distance in
order to do the ray-marching. Ideally this would have 3 parallel 14-bit
multiplies, but I was running out of gate area, and didn&#39;t want to unroll it
over multiple clock cycles. Seeing as the incoming distance was approximate
anyway, I opted for an <a href="https://github.com/a1k0n/tt08-vga-donut/blob/main/src/step3vec.v" target="_blank">approximate
multiplier</a>
which finds the leading 1 bit and returns a shifted copy of the unit vector as a
step direction.</p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>From obfuscated C code printing ASCII art, to bitwise operations rendering 3D
graphics, and finally to a tiny slice of silicon racing an electron beam, this
project shows how the same basic idea can be reimagined and refined. What
started as a fun programming puzzle led to discovering an elegant way to render
3D graphics with minimal computational resources. While the original donut.c was
an exercise in creative constraint — fitting a 3D renderer into as little
code as possible — this hardware implementation pushed different limits:
how few gates, how few operations per pixel could still produce a recognizable
rotating donut?</p>

<p>The polygonal appearance that emerged from limiting CORDIC iterations was a
happy accident, a reminder that sometimes the most interesting results come from
working within tight constraints.</p>

<p>Tiny Tapeout 8 is estimated to deliver chips in May 2025; it is currently
January and I cannot wait. This chip also hosts the inaugural <a href="https://tinytapeout.com/competitions/demoscene/" target="_blank">Tiny Tapeout Demoscene
Competition</a>; it may be the
coolest ASIC ever made. I also have a democompo entry which I will write about
once judging is done.</p>



    </div></div>
  </body>
</html>
