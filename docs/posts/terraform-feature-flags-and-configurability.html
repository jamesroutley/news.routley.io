<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ninad.pundaliks.in/blog/2026/02/terraform-and-feature-flags/">Original</a>
    <h1>Terraform, Feature Flags and Configurability</h1>
    
    <div id="readability-page-1" class="page"><div id="main" aria-label="Content">
  <article>
    

    <div>
      

      

      <div>
        <div>
          <p><a href="https://developer.hashicorp.com/terraform">Terraform</a> has been my bread and butter for the past few years as the tool for Infrastructure as Code. I’ve dealt with a variety of patterns while working with Terraform, and noticed one pattern that is rarely discussed, but super useful. <a href="https://martinfowler.com/articles/feature-toggles.html">Feature flags</a> are a way to write code that can behave differently based on how we configure things, and is as old as writing code for computers. It gives the author of the code flexibility to have different implementations, safely migrate systems from one approach or capability to a new one and choose behaviour based on the target context. Mature codebases find tooling or affordances that give them the ability to evolve and adapt, and feature flags are one pattern to achieve that. However, the public internet has very few examples about how to achieve this for Infrastructure as Code tools, including Terraform.</p>

<p>The best place to start is HashiCorp’s <a href="https://www.hashicorp.com/en/blog/terraform-feature-toggles-blue-green-deployments-canary-test">official post</a> about feature flags. All resources support a few basic arguments, including <code>count</code>. The main example from this post use nos <code>count</code>, coupled with a boolean variable to toggle the existence of a resource. This is a super basic example though, and it only <a href="https://knowyourmeme.com/memes/how-to-draw-an-owl">shows</a> how to draw the first two circles of an owl. How does one finish the drawing though? Let us work through some examples below to draw the rest of the owl.</p>

<div><div><pre><code># A basic example with count
locals {
    foo_enabled = true
    ...
}

resource &#34;provider_bar_foo&#34; &#34;foo_thing&#34; {
    count = local.foo_enabled ? 1 : 0
    ...
}
</code></pre></div></div>

<p>If you’ve been writing Terraform code for a while, then you’re definitely using <a href="https://developer.hashicorp.com/terraform/language/modules/develop">modules</a> to reduce repetition and to build reusable blocks. If you know what behaviors of the module need to be configurable, you can then define variables that enable or disable various resources. Due to their nature, booleans always limit us to off and on states. They don’t give us a lot of flexibility in expressing our intent through the codebase. If the modules you’re writing are meant for a wide and public distribution (like the <a href="https://github.com/orgs/cloudposse/repositories">Cloud Posse project</a>, or <a href="https://github.com/orgs/terraform-google-modules/repositories">Google Cloud’s Terraform modules</a>), it makes sense to follow this pattern of using boolean variables to manage features.</p>

<div><div><pre><code># An example of how some public modules have to be defined
locals {
    foo_enabled = true
    bar_enabled = false
    baz_enabled = false
    ...
}

module &#34;services_group_1&#34; {
    source = &#34;.../path/to/module&#34;
    region = &#34;abc-def-01&#34;
    foo_enabled = local.foo_enabled
    bar_enabled = local.bar_enabled
    baz_enabled = local.baz_enabled
}

module &#34;services_group_2&#34; {
    source = &#34;.../path/to/module&#34;
    region = &#34;xyz-tuv-02&#34;
    foo_enabled = local.foo_enabled
    bar_enabled = local.bar_enabled
    baz_enabled = local.baz_enabled
}
</code></pre></div></div>

<p>As you start writing modules with this approach, you realise that the conditionals start growing, and the right side of the <code>count</code> attribute starts becoming much more complex.</p>

<div><div><pre><code># A complex feature flag evaluation
locals {
    baz_enabled = true
    green_deployment = false
    blue_deployment = true
}

resource &#34;provider_bar_baz&#34; &#34;baz_green&#34; {
    count = (local.baz_enabled &amp;&amp; local.green_deployment) ? 1 : 0 
}

resource &#34;provider_bar_baz&#34; &#34;baz_blue&#34; {
    count = (local.baz_enabled &amp;&amp; local.blue_deployment) ? 1 : 0 
}
</code></pre></div></div>

<p>I’ve seen a great pattern that helps solve this complexity. You can write a Python or Golang script that can take a few parameters as an input, and emits a JSON object that can then be parsed by Terraform. This let’s you express your conditionals in a language that is more readable, maintainable, and frankly, friendlier than HCL. Your Terraform also stays relatively simple. In a previous team, a member wrote a module that managed a barebones container hosting platform via Terraform, and any product team could use it to run an application. Naturally, the matrix of choices required to support an app, blue green deployments, databases, and other features together made the module fairly large. By writing a Go script that accepted some parameters and translated them into a detailed configuration, the member made the module approachable to other engineers in the organization, and also gained a good amount of flexibility in deploying applications. And, the great thing about this approach is: any language or binary that can render a JSON object is supported. If you really wanted, you could write a bash script that uses <code>jq</code>, or even a Perl script! (Although, I’d highly question your sanity if you wrote Perl for this)</p>

<div><div><pre><code>#!/usr/bin/env python 3
# A sample Python script

import json
import sys

BASE_CONFIG = {
    &#34;foo_enabled&#34;: True,
    &#34;foo_a&#34;: &#34;bar&#34;,
    ...
}
ENV_CONFIG = {
    &#34;dev&#34;: {},
    &#34;staging&#34;: {
        &#34;foo_enabled&#34;: True,
    },
    &#34;production&#34;: {
        &#34;foo_enabled&#34;: False,
    },
}

# Super dumb implementation for illustration, needs more error handling
if __name__ == &#34;__main__&#34;:
    query = json.load(sys.stdin)
    environment = query.get(&#34;environment&#34;)
    
    merged_config = { **BASE_CONFIG, **ENV_CONFIG[environment]}
    print(json.dumps(merged_config))
</code></pre></div></div>

<div><div><pre><code># How to consume in TF
data &#34;external&#34; &#34;config&#34; {
    program = [&#34;python3&#34;, &#34;path/to/generate_config.py&#34;]
    
    query = {
        environment = &#34;production&#34;
    }
}

locals {
    cfg = data.external.config.result
}

resource &#34;provider_bar_foo&#34; &#34;foo_thing&#34; {
    count = local.cfg.foo_enabled ? 1 : 0
    parameter_a = local.cfg.foo_a
    ...
} 
</code></pre></div></div>

<p>However, if the Terraform you’re writing is meant for internal usage only, we can exploit this path further and gain a lot more flexibility. Feature flags do not need to only have a boolean shape. They can be an integer (e.g. a count of resources, to setup 2 nodes in staging and 5 in production), a list of strings (a list of buckets to create in a region), or a more complex object (a full specification of the firewall rules associated with a particular set of nodes). And, Terraform supports all these types! This lets us define a simple module, and have it iterate on a list of objects. It is now easier to reason about how rollouts progress, and also makes the module less brittle.  By shifting the creation/modification of resources out of the module, and into a configuration layer, the module has suddenly become a lot more flexible.</p>

<div><div><pre><code># A more complex object used to create N copies of the same resource/module
locals {
    foo_names = {
        &#34;abc&#34;: {},
        &#34;def&#34;: {},
        &#34;xyz&#34;: {}.
    }
}

module &#34;foo&#34; {
    source = &#34;../path/to/foo&#34;
    for_each = set(local.foo_names)
    
    name = each.key
}
</code></pre></div></div>

<p>My current team has taken this approach to the next logical step. Instead of generating a JSON file with a homebrew script that will, over time, become a fragile and unmaintainable mess, we’ve picked <a href="https://ninad.pundaliks.in/blog/2026/02/terraform-and-feature-flags/jsonnet.org">jsonnet</a>, a language that renders to JSON. Other formats like <code>ini</code>, <code>toml</code> and <code>yaml</code> are supported, but <code>json</code> is the primary target. Although slightly more limited in terms of language features, it has been designed explicitly as a configuration generator, making it well suited for this task. Create a base specification that describes what a region or cluster of services will look like, and use jsonnet to generate JSON configurations for each of them. You may choose to generate them at runtime by running the <code>jsonnet</code> command through Terraform, or you could check the generated configuration into your repo, either works. The moment you’re dealing with more than 5 clusters (e.g. dev, staging, prod, and/or regions distributed across the globe to serve multiple customers), the generated configuration becomes an invaluable tool in your belt. From safely releasing features, to dealing with quirks of cloud providers and regions, everything can be expressed as a flag. And, most importantly, the barrier to introduce risky changes lowers by a lot. This also gives the team a pathway to manage many kinds of tech debt at a much lower level of risk.</p>

<p>Jsonnet also allows you to write tests (although, to me, the ergonomics of tests in jsonnet feel a little clunky), which ensures that regressions and misconfigurations can be caught early. We configure multiple node pools per kubernetes cluster, and generate all the attributes via jsonnet. We also support a limited number of OS images (due to compliance/security reasons), so we wrote a test that checks each node pool’s OS image names, ensuring that match specific regex patterns. As this test is executed at build time, we can catch any errors (hey, we’re humans and typos are normal!) when we raise a PR, rather than attempting a Terraform apply and have it bail on us.</p>

<p>Another neat thing that you can try at this stage is, instead of passing in individual values and booleans of the feature flags through each abstraction layer of your Terraform modules, you can just pass in the entire configuration JSON block to everything. This simplifies adding a new feature flag, as you only need to change your jsonnet specification, and the final piece of Terraform that consumes that code.</p>

<div><div><pre><code># base.libsonnet
base_env:: {
    foo: {
        enabled: false,
        bar: &#34;baz&#34;,
        abc: &#34;def&#34;,
    }
},

dev:: self.base + { enabled: true, },
prod:: self.base,
</code></pre></div></div>

<div><div><pre><code># environments.jsoonnet
local base = import &#39;base.libsonnet&#39;;

{
    dev: base.dev,
    prod: base.prod,
}
</code></pre></div></div>

<div><div><pre><code>variable &#34;environment&#34; {
    type = &#34;string&#34;
}

locals {
    all_cfg = jsondecode(file(&#34;path/to/generated/environments.json&#34;))
    cfg = local.all_cfg[var.environment]
}

resource &#34;provider_bar_foo&#34; &#34;foo&#34; {
    count = local.cfg.foo.enabled ? 1 : 0
    bar = local.cfg.foo.bar
    ...
}
</code></pre></div></div>

<div><div><pre><code>jsonnet /path/to/environments.jsonnet
</code></pre></div></div>

<p>Some stuff to keep in mind when picking this path:</p>

<ul>
  <li>If your team has a well defined versioning and distribution system for Terraform modules, the module can evolve with product needs. A configuration object will still be valuable, but it solves the module brittleness problem I talked about before.</li>
  <li>Using <code>count</code> to manage objects is known to cause state churn as your infrastructure evolves. Hence, more teams have started to favour <code>for_each</code> instead. If the complexity of the confiugration choices is still not very high, a well designed <code>for_each</code> object will get you most of the benefits of feature flags and generated configuration without the additional overhead of having a pre-commit step to generate the JSON files.</li>
  <li>If you’re using an external script to generate configurations during each terraform plan/apply stage, you need to guarantee a stable execution environment for your chosen language. The same Python or Golang version needs to exist on your engineer’s machine, as well as the machines used to do your terraform applies (i.e. the Github Actions runners, or Terraform Cloud VMs).</li>
  <li>By sending the entire configuration object through various layers of Terraform modules, you do end up trading some level of strictness (which you would have if you validated every variable for type and structure at every abstraction layer) for speed, but it might be a trade off that makes sense to you.</li>
  <li>If you’re developing Terraform for target contexts that end up varying a lot from each other, and/or require enabling/disabling entire modules, this approach can be more clunky. Consider languages/frameworks like Pulumi and Terragrunt instead that give you more expressivity than HCL.</li>
</ul>

<p>Have I convinced you enough to experiment with feature flags for the next major Terraform change? If you’ve seen any other interesting, or similarly effective ways to manage Infrastructure as Code tools and codebases, ping me on Mastodon, I’d love to hear about them and learn from you!</p>

<p>Additional reading:</p>

<ul>
  <li><a href="https://adhoc.team/2019/09/24/feature-flags-dynamic-blocks-terraform/">https://adhoc.team/2019/09/24/feature-flags-dynamic-blocks-terraform/</a></li>
  <li><a href="https://medium.com/@leslie.alldridge/terraform-external-data-source-using-custom-python-script-with-example-cea5e618d83e">https://medium.com/@leslie.alldridge/terraform-external-data-source-using-custom-python-script-with-example-cea5e618d83e</a></li>
</ul>

        </div>

        

        

        

      </div>
    </div>
  </article>
</div></div>
  </body>
</html>
