<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://foon.uk/how-flash-2022/">Original</a>
    <h1>I still use Flash</h1>
    
    <div id="readability-page-1" class="page"><article>
        




<p>When Adobe killed Flash Player in 2020, I didn&#39;t want my Flash games to disappear forever.
</p>
<p>I&#39;ve been making games on and off my whole life, but people seemed to like the Hapland ones in particular, so I thought it might be nice to fix them up for a Steam release. I could draw some better graphics, improve the frame rate and resolution, and maybe add some extra secrets and such.</p>
<figure><a href="https://foon.uk/how-flash-2022/img/hap2c.png"><img src="https://foon.uk/how-flash-2022/thumbs/hap2c.png"/></a><figcaption>Hapland 2</figcaption></figure>
<p>The problem is, the Hapland games are very much Flash games. The graphics are drawn in Flash, the code was written in Flash, all the animations are done in the Flash timeline. These games have Flash in their bones.
</p>
<p>How was I going to do this?</p>
<h2>Failed attempt #1</h2><p>The first thing I tried was having Flash export the games as executables. This would have made this a very short article but it fails because performance is about as bad as it was in 2005. I want to make a good thing that runs at contemporary frame rates. I wanted to be free of Flash Player.
</p>
<h2>Failed attempt #2</h2><p>Secondly, I spent far too much time fiddling around with Adobe AIR, a desktop runtime for Flash, and Starling, a library that draws your Flash scene on the GPU.
</p>
<p>I gave up on this in the end, partly becase AIR is buggy and terrible, but also because I don&#39;t really want to end up with a weird Adobe thing at the end of all this; I want to have my own thing that I can do what I want with. What if I want to port to Linux? I don&#39;t want to have to care about Adobe&#39;s opinion about whether I should be able to do that or not.</p>
<p>The way forward was obvious; I&#39;d have to make my own Flash player.</p>
<h2>The plan</h2><p>Here&#39;s how Hapland works. There&#39;s a tree of sprites. In Flash, animated sprites can have code attached to certain frames, which runs when the playhead gets there. Hapland uses this a lot. The walk paths of the game characters are all just big long timeline animations, and characters often have frame actions saying, when you get to the door, open it if it&#39;s closed, or when you get to the landmine, trigger it if it hasn&#39;t exploded yet.
</p>
<figure><a href="https://foon.uk/how-flash-2022/img/action.png"><img src="https://foon.uk/how-flash-2022/thumbs/action.png"/></a><figcaption>The little “a”s in the timeline are frame actions.</figcaption></figure>
<p>Fortunately, .fla files are just XML. I just had to parse this, export the relevant data to a simple custom format<sup><a id="ref1" href="#note1">1</a></sup> and write a player to read it, draw the scene, handle input, and run the animations. I&#39;d also have to do something about the ActionScript.
</p>
<p>Hapland would stay a Flash project, written and maintained in the Flash editor; only Flash Player would be replaced.</p>
<h3>Rasterizing vectors</h3><p>Flash is all about vector graphics. It does support bitmaps, but it&#39;s really designed for vectors. That&#39;s how Flash movies managed to load so fast even on dialup connections, back in the day. All the Hapland graphics are vectors.
</p>
<p>GPUs don&#39;t really like drawing vector graphics. They like big batches of textured triangles. So, I needed to rasterize these vectors.</p>
<p>I decided to rasterize them offline and pack the raster files into the game. It would have been fun to have the game rasterize them at runtime, and have it be this tiny executable, but I didn&#39;t want to have those extra moving parts. I like having as much of my code as possible run on my own dev machine, where I can keep an eye on it.</p>
<p>Flash stores its vector graphics in XML format. You might argue that XML is a poor choice for graphics data, but you weren&#39;t a product manager at Macromedia. Behold:</p>
<figure><a href="https://foon.uk/how-flash-2022/img/guyxml.png"><img src="https://foon.uk/how-flash-2022/thumbs/guyxml.png"/></a><figcaption>Vector data as seen in a .fla file</figcaption></figure>
<p>Hey, I&#39;m not complaining, it makes my job easier.
</p>
<p>Even though I didn&#39;t have access to a spec, rasterizing this wasn&#39;t such a hard problem. The bezier-spline model of vector graphics is all-pervasive, ever since PostScript. All these APIs work the same way. After a bit of trial and error to figure out what <var>!</var> and <var>[</var> and so on meant<sup><a id="ref2" href="#note2">2</a></sup>, I wrote a program to parse these shape definitions and render them out to PNGs using the Mac&#39;s CoreGraphics library.</p>
<p>CoreGraphics was a dubious choice. I picked it because I was working on a Mac, and it was there, and dependencies are hard. But that did make it so I always had to rasterize the graphics on a Mac, even for Windows builds. If I do this kind of thing again I might pick a cross-platform library.</p>
<p>After rendering these PNGs, the exporter then assembles them into atlases, quite naively. It just sorts everything by height and lays it all out row by row like text in a document. This is far from optimal but it&#39;s good enough.</p>
<p>To keep things simple, the atlases are 2048×2048 pixels, the minimum required texture size that OpenGL 3.2 implementations have to support.</p>
<figure><a href="https://foon.uk/how-flash-2022/img/atlas.png"><img src="https://foon.uk/how-flash-2022/thumbs/atlas.png"/></a><figcaption>An atlas from Hapland 3</figcaption></figure>
<p>Rasterizing the shapes is pretty slow, so to keep build times reasonable I needed to skip rendering things that hadn&#39;t changed. The zipped XML format that Flash uses does have last-modified fields for each file, but Flash doesn&#39;t seem to use them properly and so you can&#39;t rely on them.<sup><a id="ref3" href="#note3">3</a></sup>
</p>
<p>Instead, I just hash the XML of each shape and only rebuild if it&#39;s changed. Even that fails, because Flash sometimes likes to rearrange the XML tags in objects that haven&#39;t changed, but again, it&#39;s good enough.</p>
<h3>Using an assembler to write binary files</h3><p>The exporter writes the animation data to a custom binary format<sup><a id="ref4" href="#note4">4</a></sup>. It just goes frame by frame through the timeline and writes out all the changes for each frame.
</p>
<p>One thing I came up with here, which I rather like, is the idea of writing to an assembly listing rather than straight to a binary file. There&#39;s no CPU instructions, just data. This makes debugging easier, because I can look through the assembly file to see what was generated, rather than picking through bytes in a hex editor.</p>

<figure>

<div>
<div>
<p>output.bin</p>
<div><center>
13 92 49 EC : BD 31 E8 FF </center></div>
</div>

<div>
<p>output.asm</p>
<p><code><span>; Left Side</span>
<var>timeline_132</var>:
<span>; --- Left Side, Frame 0 ---</span>
<var>.frame_0</var>:
<span>; --- Left Side, Frame 0, Layer 22 ---</span>
<em>db</em> <var>Quad</var>
<em>dd</em> 0.152926, 0.162029, 0.184475, 1.000000 <span>; color</span>
<em>dd</em> 799.599976, -20.950001
<em>dd</em> 799.599976, 556.650024
<em>dd</em> 46.000000, 556.650024
<em>dd</em> 46.000000, -20.950001
<span>; --- Left Side, Frame 0, Layer 21 ---</span>
<span>; instance of shape [Left Side] [Wall Shadows] [Frame 0]</span>
<em>dd</em> <var>Shape</var>
<em>dw</em> 1560 </code></p>
</div>
</div>
<figcaption>Which would you rather debug?</figcaption>
</figure>

<p>I could have just had the exporter write out the bytes to one file and a separate text listing to another file at the same time, without using the assembler, but I didn&#39;t do that because 1) assemblers already exist, 2) I don&#39;t have to debug them and 3) they support labels.<sup><a id="ref5" href="#note5">5</a></sup>
</p>
<p>The rest of the exporter is mostly not interesting; it just walks the tree and converts things like transformation matrices, colour effects, and so on as it finds them. Onward, then, to the game program itself. I chose to write this in C++ because I already know it and new things scare me.</p>
<h3>Scene graph</h3><p>Hapland is a great fit for a scene graph<sup><a id="ref6" href="#note6">6</a></sup>. This is the model that Flash used and Hapland was designed around it, so there was no sense in trying to use a different model.
</p>
<p>I store the scene in memory as a boring tree of Nodes, each of which has a transform and can draw itself and accept mouse clicks. Each game object with behaviour of its own is an instance of its own class, deriving from Node. Object-orientation is not fashionable right now in gamedev circles, but I&#39;m using Flash so I clearly don&#39;t care about that.</p>
<p>Flash features that Hapland used, like colour transforms and masking, are present, although instead of implementing arbitrary masking like Flash did, I just implemented rect clipping and edited all my graphics so all the masks were rectangles.</p>
<h3>Frame scripts</h3><p>Almost all of the Hapland logic is in bits of ActionScript attached to timeline frames. How was I going to export all this? I didn&#39;t want to include an ActionScript interpreter in my game.
</p>
<figure><a href="https://foon.uk/how-flash-2022/img/fa0.png"><img src="https://foon.uk/how-flash-2022/thumbs/fa0.png"/></a><figcaption>A simple frame action</figcaption></figure>
<p>In the end, I settled for a bit of a hack. My exporter reads the ActionScript from each frame and applies a bunch of regexes to attempt to turn it into C++. For instance, <var>crate.lid.play()</var> might become <var>crate()-&gt;lid()-&gt;play();</var>. The two languages are similar enough syntactically that this works out fine for a lot of the simpler frame actions, but it still left a fair bit of broken code, and there was nothing for it but to go in and manually rewrite all the remaining frame actions.
</p>
<p>With all the frame scripts in C++, they are extracted at build time and become methods on each symbol&#39;s Node subclass. A dispatch method is also generated to call them at the right time, which looks something like this:</p>
<code>void tick() override {</code>
<p>One last thing I&#39;ll call out here is that the scripting system ended up being sort of statically typed, which was kind of neat, since ActionScript wasn&#39;t<sup><a id="ref7" href="#note7">7</a></sup>. The game objects spit out by the exporter look like this:
</p>
<code>struct BigCrate: Node {</code>
<p>So, even though everything was still a sea of string name lookups under the hood, the type-safe veneer would stop you from calling the wrong functions on the wrong objects, saving you from that annoying class of bug you get in dynamic languages where you typo something and only find out about it at runtime.
</p>
<h3>Aspect ratios</h3><p>Ah, aspect ratios. Everybody who converts old media to new formats <a href="https://davidsimon.com/the-wire-hd-with-videos/">loves these</a>. The original games were browser games that weren&#39;t even designed to run in full screen, so they just used whatever aspect ratio I felt like. Each game was different, but they were all around 3:2.
</p>
<p>The most common aspect ratio today seems to be 16:9, with 16:10 also popular on laptops. I wanted the game to look good at either of these without any black bars or stretching. The only ways to do this are either to cut bits off the originals, or to add bits on.</p>
<p>So, I drew two rectangles in each game, one proportioned at 16:9 and the other at 16:10. The game then interpolates between them based on the screen&#39;s aspect ratio, and uses the interpolated rectangle as the camera view bounds. As long as all important game elements are inside the intersection of these rectangles, and their common bounding rectangle doesn&#39;t go off the edge of the scene, this works great.</p>
<figure><a href="https://foon.uk/how-flash-2022/img/arbox.png"><img src="https://foon.uk/how-flash-2022/thumbs/arbox.png"/></a><figcaption><span>16:10</span> and <span>16:9</span> boxes for Hapland 2, against the original <span>3:2</span>.</figcaption></figure>
<p>The only difficult part here was adapting the scenes themselves to accommodate the extra width; lots of things needed redrawing and rearranging to fit the new aspect ratios, which was a bit of a pain, but I got it all done in the end.
</p>
<h3>Colour space nightmare</h3><p>After a bit of testing, I discovered that Flash does its alpha blending and colour transforms in perceptual space, not linear space. This is mathematically dubious, but on the other hand I get it; a lot of drawing programs work like this, and you want your consumer tool to work the way people expect, even if it annoys those head-in-the-clouds mathematicians who don&#39;t know anything about business. But on the first hand again, it&#39;s wrong! It causes problems with things like antialiasing.
</p>
<p>When you rasterize vector graphics, and you ask for antialiased output, your rasterizer will output alpha values that are so-called “coverage values”. This means that if a given pixel is half-covered by the vector shape, that pixel will be output with alpha=0.5.</p>
<p>But in Flash, when something has alpha of 0.5, that means it is perceptually halfway between the foreground and background colours.</p>
<p>This is not the same thing!<sup><a id="ref8" href="#note8">8</a></sup></p>
<p>A half-coverage white pixel drawn on top of an opaque black pixel should not be a perceptual 50% grey. That isn&#39;t how light works, and it isn&#39;t how vector rasterization can ever work. (A rasterizer can&#39;t say “this pixel should be perceptually X% between background and foreground colour” without knowing the background colour.)</p>
<figure><a href="https://foon.uk/how-flash-2022/img/greys-srgb.png"><img src="https://foon.uk/how-flash-2022/thumbs/greys-srgb.png"/></a><figcaption>Blending done in perceptual (sRGB) space. Top: Transparent whites on black; Middle: Transparent blacks on white; Bottom: Greys</figcaption></figure>

<figure><a href="https://foon.uk/how-flash-2022/img/greys-linear.png"><img src="https://foon.uk/how-flash-2022/thumbs/greys-linear.png"/></a><figcaption>The same blending done in linear (physically accurate) space. Note that 50% coverage does not look the same as 50% grey.</figcaption></figure>
<p>So, we have our antialiased rasterized shapes using one definition of alpha, and our Flash-exported alpha transparency, gradients and colour transforms using another. But we only have one alpha channel in our rendering pipeline. So how should the renderer interpret alpha values? If it interprets them as perceptual blending factors, the semi-transparent objects will look right but the antialiased edges of everything will look wrong. If it interprets them as coverage values, the inverse will be true. Something will always look wrong!
</p>
<p>There are I think only two rigorous solutions here: 1) have two alpha channels, one for coverage and one for perceptual blending, or 2) rasterize all shapes without AA, draw everything to a very large framebuffer, and then scale it down with filtering.<sup><a id="ref9" href="#note9">9</a></sup></p>
<p>I must admit, I didn&#39;t do either of these. I just accepted that semi-transparent things look different in Flash and in the game, and tweaked the graphics incrementally until the game looked good. Transparent objects were never going to look exactly how I designed them in Flash, but there aren&#39;t very many of them and it just isn&#39;t a big problem.</p>
<p>To make sure I&#39;d got everything else right, I made a “colour test” graphic with a bunch of colours of different intensities, hue rotation effects<sup><a id="ref10" href="#note10">10</a></sup>, and so on, had the game show it, and made sure it looked the same in the game as in Flash.</p>
<figure><a href="https://foon.uk/how-flash-2022/img/ctest.png"><img src="https://foon.uk/how-flash-2022/thumbs/ctest.png"/></a><figcaption>It&#39;s a match!</figcaption></figure>

<h3>Frame rate</h3><p>The original Flash games run at a nominal 24FPS, but really, they run at whatever frame rate Flash Player feels like running them at. With Flash, you might ask for 24FPS and get 15FPS, so then you&#39;d ask for 30FPS and suddenly you&#39;d get 24FPS. It was kind of silly.
</p>
<p>I wanted 60FPS for the remake, which meant doing something about the fact that the Hapland animations were authored expecting to be played back at about 24FPS. (Flash&#39;s animation tools are based around discrete frames, not continuous time.)</p>
<p>I started by having my exporter double all the frames. So, for each timeline frame, it exports two frames<sup><a id="ref11" href="#note11">11</a></sup>. This gets us easily from 24FPS to 48FPS, but that still isn&#39;t quite 60, so animations were still going to run 25% faster. The solution was good old-fashioned elbow grease. I just played through the games and manually added in extra frames to animations that now seemed too quick.</p>
<p>I now had a pretty good C++ conversion of the Hapland games that would surely run on contemporary computers for at least another decade or two. But I just couldn&#39;t shake the feeling that I should try to deliver a bit of extra value, so I added a couple of things. Aside from redrawing a lot of the old graphics and animations, I made a couple of major changes.</p>
<h3>Save states</h3><p>This was an idea I came up with to make Hapland 3 a bit less overwhelming. The correct path in that game is quite long, and there are many ways to screw it up and have to start all over again. Maybe this was fun in 2006 but we&#39;re grownups now, we haven&#39;t got time for that.
</p>
<p>Save states are something that emulators have. You press “save state”, and it remembers the entire state of the game by dumping the console&#39;s memory to a file. Then, if you mess up, you press “load state” and you&#39;re back exactly where you were to try again.<sup><a id="ref12" href="#note12">12</a></sup></p>
<p>It wouldn&#39;t have been feasible to implement save states in the original Flash games, because Flash doesn&#39;t give the programmer access to its whole state. But since I&#39;m using all my own code this time, it is possible.</p>
<p>I have this thing called a Zone, which is just an allocator that allocates all its memory inside a fixed-size chunk. All scene nodes are allocated inside the current Zone.</p>
<p>To implement save and restore, I simply have two Zones, the active zone and a separate “save state zone”. To save a state, I memcpy the active zone to the save state zone. To load a state, I memcpy back the other way.</p>
<h3>Second Quests</h3><p>The Hapland games aren&#39;t particularly long, and although there are three of them, I still wanted to give people a few more hours of play time. I decided to give each game a “Second Quest”—a modified version of the game where the layout and puzzles are slightly different. Making such a Second Quest is less work than making a whole new game, but still delivers some extra value.
</p>
<p>Creating the second quests meant digging back into Flash puzzle game development for the first time in about fifteen years, and, honestly, I quite liked it.</p>
<p>The vintage Flash UI is great. Buttons have edges. Icons look like things. Space is well-used. It&#39;s amazing! Using old UIs makes me feel like an archaeologist discovering some sort of forgotten Roman technology. The lost art of UI design. It&#39;s neat.</p>
<figure><a href="https://foon.uk/how-flash-2022/img/tools.png"><img src="https://foon.uk/how-flash-2022/thumbs/tools.png"/></a><figcaption>What is this wizardry?</figcaption></figure>

<p>And although Flash is buggy, slow, and missing extremely basic features, I mostly didn&#39;t hate using it. I certainly don&#39;t know of a contemporary program that I&#39;d have preferred to use.</p>
<p>To stop the Second Quests looking too similar to the First Quests, they get new backgrounds, and the entire scene is also flipped horizontally.</p>
<figure><a href="https://foon.uk/how-flash-2022/img/hap3c.png"><img src="https://foon.uk/how-flash-2022/thumbs/hap3c.png"/></a><figcaption>Hapland 3</figcaption></figure>

<figure><a href="https://foon.uk/how-flash-2022/img/hap3c2.png"><img src="https://foon.uk/how-flash-2022/thumbs/hap3c2.png"/></a><figcaption>Hapland 3 Second Quest</figcaption></figure>

<h3>Music</h3><p>I knocked together a quick ambient soundtrack for each game, using stock sounds and a couple of recordings I made. Once when I was on holiday in Japan I took a field recording at the top of a hill for no reason in particular and it was nice to be able to use it for something. I hired a musician from the Internet to do the title screen music, and recorded some guitar chords myself for the end credits, drowned in effects so you can&#39;t tell I&#39;m bad at guitar.
</p>
<p>I use Logic or Live for music, depending. I find Logic better for recording, and Live better for sound design.</p>
<h3>Achievements</h3><p>I get the feeling players expect achievements in Steam games. This is annoying because it should be up to the game designer whether achievements are an appropriate grumble grumble, but it&#39;s not a big deal.
</p>
<p>Uploading achievements to Steam is a pain. You can&#39;t just define a list and give it to their command-line tools; you have to laboriously click through the slow, confusing miasma of PHP sadness that is the Steam partner site and add them one by one.</p>
<p>I think if you&#39;re a big important game studio you don&#39;t have to stand for that and they give you a bulk upload tool, but I&#39;m not one of those so I looked at the HTTP calls it was making, saved my login cookie to a file and wrote my own.</p>
<p>After changing my mind several times, I opted for a modest set of achievements: one for finishing each Hapland game, one for each Second Quest, and a couple for the bigger secrets. Any silly, obscure secrets that nobody will ever find do not have achievements; you just get the satisfaction of seeing what happens.</p>
<figure><a href="https://foon.uk/how-flash-2022/img/ach.png"><img src="https://foon.uk/how-flash-2022/thumbs/ach.png"/></a><figcaption>Achievements in the Steamworks UI</figcaption></figure>

<h3>Notarization</h3><p>Although I developed the game mostly on my Mac, during development Apple invented this thing called “Notarization” where if you run any app on a new version of MacOS, it&#39;ll make a network request to Apple to ask if the app&#39;s developer pays Apple a yearly fee. If the developer does not pay Apple a yearly fee, MacOS will pop up a dialog strongly implying the app is a virus and refuse to start it.
</p>
<p>For this reason, Windows will be the first and maybe only release platform for this game.</p>
<h3>Libraries used</h3><p>For software that I&#39;m shipping to end-users, I like to keep dependencies to a minimum, but I&#39;m happy to use a few high-quality ones. Other than OpenGL and standard operating system stuff, this is the full list of libraries that the Hapland Trilogy executable ended up linking to:
</p>
<ul>
<li>Steam SDK
</li><li><a href="https://github.com/RandyGaul/cute_headers/blob/master/cute_sound.h">cute_sound</a>
</li><li><a href="https://github.com/nothings/stb/blob/master/stb_vorbis.c">stb_vorbis</a>
</li><li><a href="https://github.com/nothings/stb/blob/master/stb_image.h">stb_image</a>
</li></ul>


<h3>The end</h3><p>And that&#39;s it! Thank you for coming on this blog post adventure with me. It&#39;s been fun. If you do the tech stuff right, players don&#39;t notice it at all, so sometimes you just want to say, hey, look, look what I made.
</p>
<p>If you&#39;d like to read other things I&#39;ve written, then you&#39;re out of luck because I don&#39;t tend to post much writing online. If you&#39;d like to support me, you could <a href="https://store.steampowered.com/app/1458090/Hapland_Trilogy/">buy Hapland Trilogy</a> or my other Steam game from 2020, <a href="https://store.steampowered.com/app/741110/Blackshift/">Blackshift</a>. If you want to play some of my games without paying, I have a bunch of free browser games on my website at <a href="https://foon.uk">foon.uk</a>. The newest ones are Javascript or WASM, and the oldest ones, including the original Haplands, are AS2 Flash, which runs pretty well thanks to Ruffle. The later Flash games are AS3 so they don&#39;t run anymore.</p>
<p>If you have any comments or just want to say hi you can email me at r@foon.uk, or if you&#39;re into Twitter, I&#39;m <a href="https://twitter.com/FoonGames">@FoonGames</a>.</p>
<p>Take care.</p>
<p>Robin Allen</p>
<p>2022</p>
        <div><p><a id="note1" href="#ref1">1</a>.  It was tempting to just use SWF, the format that Flash already knows how to export to, but this didn&#39;t work out because SWF is a vector format and I didn&#39;t want to do rasterization at runtime, and also because it limits your options for what to do with the scripts, and for other reasons that I can&#39;t remember.</p><p><a id="note2" href="#ref2">2</a>.  <var>!</var>: Move to point. <var>|</var> or <var>/</var>: Straight line to point. <var>[</var> Bezier segment to point. <var>S</var>: No idea.</p><p><a id="note3" href="#ref3">3</a>.  That figures, too — Flash takes an age to save large documents, even if you only changed a single thing, so it probably doesn&#39;t track last-modified times at all.</p><p><a id="note4" href="#ref4">4</a>.  I like to use binary formats where possible for end-user software; I don&#39;t believe in making customers&#39; computers chew through reams of XML.</p><p><a id="note5" href="#ref5">5</a>.  It&#39;s often the case when writing binary files that you need to write the location of one bit of data into another bit of data, and these two locations could be in either order in the file. It&#39;s just so easy to be able to write out <var>dd mylabel</var> at one end and <var>mylabel:</var> at the other and let the assembler deal with it.</p><p><a id="note6" href="#ref6">6</a>.  <a href="https://blog.blackshift.foon.uk/2016/05/why-i-dont-need-scene-graph.html">Blackshift was not.</a></p><p><a id="note7" href="#ref7">7</a>.  ActionScript 3 started moving in that direction, but the Haplands were ActionScript 2 games.</p><p><a id="note8" href="#ref8">8</a>.  Most other image editors also work the same way. Some now have a “do things correctly” button but it&#39;s rarely the default. If you want a fun rabbit-hole to go down, look up how most fonts are thinner than they should be because they&#39;re designed to be displayed by programs that do alpha blending wrong.</p><p><a id="note9" href="#ref9">9</a>.  This raises the question of what Flash does. The Flash renderer is working with the vector data directly, without a separate rasterization step, so it might be able to do antialiasing directly in perceptual space as it renders, since it can check the background colour. Or maybe it just uses full-screen supersampling.</p><p><a id="note10" href="#ref10">10</a>.  Flash&#39;s colour transform effects (hue rotations, brightness adjustments, etc.) are expressed as 5x4 matrices in sRGB space, and it&#39;s easy enough to sort out the sRGB/Linear problem for these. For simple matrices, you can just convert them, and for the others, simply export the sRGB matrix and have the game compute <var>srgb_to_linear(ctr * linear_to_srgb(c))</var> in a fragment shader. It&#39;s a few extra GPU cycles but it still all runs fine.</p><p><a id="note11" href="#ref11">11</a>.  The frame doubler is smart enough to interpolate object positions for frames that are part of motion tweens, so those stay smooth.</p><p><a id="note12" href="#ref12">12</a>.  Some people had asked for an “undo button” but, say you fire a projectile, then quickly knock it with something when it&#39;s flying, then hit undo, what should happen? It&#39;s a case-by-case design decision. And there are a lot of cases. With save states, I don&#39;t have to make this judgement call.</p></div>
    </article></div>
  </body>
</html>
