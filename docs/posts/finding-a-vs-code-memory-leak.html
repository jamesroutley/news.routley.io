<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://randomascii.wordpress.com/2025/10/09/finding-a-vs-code-memory-leak/">Original</a>
    <h1>Finding a VS Code Memory Leak</h1>
    
    <div id="readability-page-1" class="page"><div>
						
<p>In 2021 I found a huge memory leak in VS code, totalling around 64 GB when I first saw it, but with no actual limit on how high it could go. I found this leak despite two obstacles that should have made the discovery impossible:</p>



<ol>
<li>The memory leak didn’t show up in Task Manager – there was no process whose memory consumption was increasing.</li>



<li>I had never used VS Code. In fact, I have still never used it.</li>
</ol>



<p>So how did this work? How did I find an invisible memory leak in a tool that I have never used?</p>



<p>This was during lockdown and my whole team was working from home. In order to maintain connection between teammates and in order to continue transferring knowledge from senior developers to junior developers we were doing regular pair-programming sessions. I was watching a coworker use VS Code for… I don’t remember what… and I noticed something strange.</p>



<p>So many of my blog posts start this way. “This doesn’t look right”, or “huh – that’s weird”, or some variation on that theme. In this case I noticed that the process IDs on her system had seven digits.</p>



<p>That was it. And as soon as I saw that I knew that there was a process-handle leak on her system and I was pretty sure that I would find it. Honestly, the rest of this story is pretty boring because it was so easy.</p>



<p>You see, Windows process IDs are just numbers. For obscure technical reasons they are <a href="https://devblogs.microsoft.com/oldnewthing/20080228-00/?p=23283">always multiples of four</a>. When a process goes away its ID is eligible for reuse immediately. Even if there is a delay before the process ID (PID) is reused there is no reason for the highest PID to be much more than four times the maximum number of processes that were running at one time. If we assume a system with 2,000 processes running (according to pslist my system currently has 261) then PIDs should be four decimal digits. Five decimal digits would be peculiar. But seven decimal digits? That implies at least a quarter-million processes. The PIDs I was seeing on her system were mostly around four million, which implies a million processes. Nope. I do not believe that there were that many processes.</p>



<p>It turns out that “when a process goes away its ID is eligible for reuse” is not quite right. If somebody still has a handle to that process then its PID will be retained by the OS. Forever. So it was quite obvious what was happening. Somebody was getting a handle to processes and then wasn’t closing them. It was a handle leak.</p>



<p>The <a href="https://randomascii.wordpress.com/2018/02/11/zombie-processes-are-eating-your-memory/">first time I dealt with a process handle leak</a> it was a complicated investigation as I learned the necessary techniques. That time I only realized that it was a handle leak through pure luck. Since then I’ve shipped <a href="https://github.com/randomascii/blogstuff/tree/main/FindZombieHandles">tools to find process-handle and thread handle leaks</a>, and have documented the <a href="https://randomascii.wordpress.com/2021/07/25/finding-windows-handle-leaks-in-chromium-and-others/">techniques to investigate handle leaks of all kinds</a>. Therefore this time I just followed my own recipe and had a call stack for the leaking code within the hour (this image stolen from the <a href="https://github.com/microsoft/vscode/issues/134939">github issue</a>):</p>



<figure><a href="https://randomascii.wordpress.com/wp-content/uploads/2025/10/image.png"><img data-attachment-id="4159" data-permalink="https://randomascii.wordpress.com/2025/10/09/finding-a-vs-code-memory-leak/image/" data-orig-file="https://randomascii.wordpress.com/wp-content/uploads/2025/10/image.png" data-orig-size="2724,774" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://randomascii.wordpress.com/wp-content/uploads/2025/10/image.png?w=300" data-large-file="https://randomascii.wordpress.com/wp-content/uploads/2025/10/image.png?w=640" width="1024" height="290" src="https://randomascii.wordpress.com/wp-content/uploads/2025/10/image.png?w=1024" alt="" srcset="https://randomascii.wordpress.com/wp-content/uploads/2025/10/image.png?w=1024 1024w, https://randomascii.wordpress.com/wp-content/uploads/2025/10/image.png?w=1021 1021w, https://randomascii.wordpress.com/wp-content/uploads/2025/10/image.png?w=2041 2041w, https://randomascii.wordpress.com/wp-content/uploads/2025/10/image.png?w=150 150w, https://randomascii.wordpress.com/wp-content/uploads/2025/10/image.png?w=300 300w, https://randomascii.wordpress.com/wp-content/uploads/2025/10/image.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>The bug was pretty straightforward. A call to OpenProcess was made, and there was no corresponding call to CloseProcess. And because of this a boundless amount of memory – roughly 64 KiB for each missing CloseProcess call – was leaked. A tiny mistake, with consequences that could easily consume all of the memory on a high-end machine.</p>



<p><a href="https://github.com/microsoft/vscode-windows-process-tree/blob/bc0ee891ca3df19dad46b023e3bb1266dfd1a205/src/process.cc#L44-L58">This is the buggy code</a> (yay open source!):</p>



<pre><code>void GetProcessMemoryUsage(ProcessInfo process_info[1024], uint32_t* process_count) {
  DWORD pid = process_info[*process_count].pid;
  HANDLE hProcess;
  PROCESS_MEMORY_COUNTERS pmc;
  hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, pid);
  if (hProcess == NULL) {
    return;
  }
  if (GetProcessMemoryInfo(hProcess, &amp;pmc, sizeof(pmc))) {
    process_info[*process_count].memory = (DWORD)pmc.WorkingSetSize;
  }
}</code></pre>



<p>And this is the code with the fix – the bold-faced line was added to fix the leak:</p>



<pre><code>void GetProcessMemoryUsage(ProcessInfo&amp; process_info) {
  DWORD pid = process_info.pid;
  HANDLE hProcess;
  PROCESS_MEMORY_COUNTERS pmc;
  hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, pid);
  if (hProcess == NULL) {
    return;
  }
  if (GetProcessMemoryInfo(hProcess, &amp;pmc, sizeof(pmc))) {
    process_info.memory = (DWORD)pmc.WorkingSetSize;
  }
  <strong>CloseHandle(hProcess);</strong>
}</code></pre>



<p>That’s it. One missing line of code is all that it takes.</p>



<p>The bug was found back when I still used Twitter so I <a href="https://github.com/microsoft/vscode/issues/134939">reported my findings there</a> (broken link) and somebody else then filed a <a href="https://github.com/microsoft/vscode/issues/134939">github issue</a> based on my report. I stopped using twitter a couple of years later and then my account got banned (due to not being used?) and then deleted, so now that bug report along with everything else I ever posted is gone. That’s pretty sad actually. Yet another reason for me to dislike the owner of Twitter.</p>



<p>It looks like the bug was fixed within a day or two of the report. Maybe <a href="https://techtrenches.substack.com/p/the-great-software-quality-collapse">The Great Software Quality Collapse</a> hadn’t quite started then. Or maybe I got lucky.</p>



<p>Anyway, if you don’t want me posting embarrassing stories about your software on my blog or on <a href="https://bsky.app/profile/randomascii.bsky.social">bsky</a> then be sure to leave the Handles column open in Task Manager and pay attention if you ever see it getting too high in a process that you are responsible for.</p>



<p>Sometimes I think it would be nice to have limits on resources in order to more automatically find mistakes like this. If processes were automatically crashed (with crash dumps) whenever memory or handles exceeded some limit then bugs like this would be found during testing. The limits could be set higher for software that needs it, but 10,000 handles and 4 GiB RAM would be more than enough for most software when operating correctly. The tradeoff would be more crashes in the short term but fewer leaks in the long term. I doubt it will ever happen, but if this mode existed as a per-machine opt-in then I would enable it.</p>
											</div><div id="entry-author-info">
						<p><img referrerpolicy="no-referrer" alt="Unknown&#39;s avatar" src="https://2.gravatar.com/avatar/5046e4ce5e1de3d9e062e3ff22d7f3ba7a997c221a6b6d84a73194db7e0aa0d7?s=60&amp;d=identicon&amp;r=G" srcset="https://2.gravatar.com/avatar/5046e4ce5e1de3d9e062e3ff22d7f3ba7a997c221a6b6d84a73194db7e0aa0d7?s=60&amp;d=identicon&amp;r=G 1x, https://2.gravatar.com/avatar/5046e4ce5e1de3d9e062e3ff22d7f3ba7a997c221a6b6d84a73194db7e0aa0d7?s=90&amp;d=identicon&amp;r=G 1.5x, https://2.gravatar.com/avatar/5046e4ce5e1de3d9e062e3ff22d7f3ba7a997c221a6b6d84a73194db7e0aa0d7?s=120&amp;d=identicon&amp;r=G 2x, https://2.gravatar.com/avatar/5046e4ce5e1de3d9e062e3ff22d7f3ba7a997c221a6b6d84a73194db7e0aa0d7?s=180&amp;d=identicon&amp;r=G 3x, https://2.gravatar.com/avatar/5046e4ce5e1de3d9e062e3ff22d7f3ba7a997c221a6b6d84a73194db7e0aa0d7?s=240&amp;d=identicon&amp;r=G 4x" height="60" width="60" loading="lazy" decoding="async"/>						</p><!-- #author-avatar -->
						<div id="author-description">
							<h2>
							About brucedawson							</h2><p>
							I&#39;m a programmer, working for Google, focusing on optimization and reliability. Nothing&#39;s more fun than making code run 10x as fast. Unless it&#39;s eliminating large numbers of bugs.

I also unicycle. And play (ice) hockey. And sled hockey. And juggle. And worry about whether this blog should have been called randomutf-8.

2010s in review tells more: https://twitter.com/BruceDawson0xB/status/1212101533015298048							</p><!-- #author-link	-->
						</div><!-- #author-description -->
					</div></div>
  </body>
</html>
