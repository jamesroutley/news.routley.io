<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://modern-sql.com/blog/2023-12/curious-case-aggregation-query">Original</a>
    <h1>The curious case of the aggregation query</h1>
    
    <div id="readability-page-1" class="page"><div id="article"><p><a href="https://twitter.com/justinjaffray/status/1721606415888822588">An interesting query made the rounds recently</a>. <a href="https://buttondown.email/jaffray/archive/sql-scoping-is-surprisingly-subtle-and-semantic/">The related blog post by Justin Jaffray</a> compares four queries, one of them catching everybody’s attention. I invite you to have a look for yourself. First, the table definitions:</p><pre><code>CREATE TABLE aa (a INT);
INSERT INTO aa VALUES (1), (2), (3);
CREATE TABLE xx (x INT);
INSERT INTO xx VALUES (10), (20), (30);</code></pre><p>There is not trap in there: two tables containing <a href="https://modern-sql.com/feature/values">three rows each</a>. Just note that column <code>a</code> belongs to the table <code>aa</code> and <code>x</code> to <code>xx</code>. Now the mysterious query:</p><pre><code>SELECT (SELECT sum(a) FROM xx LIMIT 1) FROM aa</code></pre><p>What does it return?</p><p>Even if you look carefully, chances are that you’ll get it wrong—just like I did.</p><div><div><h4>Training Dates 2024</h4><p>I’ve set the dates for the first round of SQL trainings next year. Online, but personally. Limited to four participants per class. From SQL Reloaded via modern SQL to performance. <a href="https://winand.at/sql-training/open-online-class">Details and registration at winand.at</a>.</p></div></div><p>Later in the article we will see that SQL implementations don’t even agree about the correct result. Some return the values 3, 6 and 9 in a table of three rows. While this makes sense, it is not what the SQL standard says.</p><p>The standard-conforming result of the query is a single row with the value 6, and this is what most tested systems return. Surprised? You are not alone. To clarify how it works I will provide some quotes from the current SQL standard (<a href="https://modern-sql.com/standard/2023">SQL:2023</a>) as well as older releases to help us track down the origin of this behavior.</p><p>The bottom line is that aggregate functions (actually <em>set function specifications</em>) do not necessarily belong to the <code>select</code> in which are they written. In the example above, the expression <code>sum(a)</code> does not belong to the inner query, but to the outer one. The query actually means the following:</p><pre><code>SELECT (SELECT sum_a
          FROM xx
         LIMIT 1
       )
  FROM (SELECT sum(a) AS sum_a
          FROM aa
       ) nested</code></pre><p>The subquery in the <code>from</code> clause does the aggregation first. The <code>select</code> clause subquery just refers to the other query’s result. Now it is also clear why there is a <code>limit</code> clause: Without this clause, the subquery returns all three rows from <code>xx</code> so that the query fails—conforming systems do exactly that.</p><p>The striking question is of course: <em>What the heck is going on here?</em> This question is actually meant to be two questions in one: (1) What is the wording in the standard that leads to this behavior? (2) <em>Why</em> was it ever specified in this way?</p><p>The first question can be answered by looking into the current standard. Specifically, into ISO/IEC 9075-2:2023 §6.9 SR 6:</p><blockquote><p>The <em>aggregation query</em> of a &lt;set function specification&gt; SFS is determined as follows.</p><p>Case:</p><ol type="a"><li><p>If SFS has no aggregated column reference <span>[…]</span></p></li><li><p>Otherwise, the innermost qualifying query of the aggregated column references of SFS is the aggregation query of SFS.</p></li></ol></blockquote><p>The first sentence introduces the term <em>aggregation query</em>. This term is then used to specify which rows an aggregate function processes—and also where to add <code>group by ()</code> if needed.<a id="ref-0" href="#footnote-0" title="ISO/IEC 9075-2:2023 §7.16 GR 1bii and ISO/IEC 9075-2:2023 §7.16 SR 14 respectively. Adding GROUP BY ()—one group for everything—takes place if there is no GROUP BY clause but the query uses an aggregate function or a HAVING clause. As in SELECT COUNT(*) FROM XX">0</a> Case “a” does not apply to our example as there <em>is</em> an aggregated column reference in the <code>sum</code> function, namely <code>a</code>. Case “b” is what we’re here for: it defines the <em>innermost qualifying query</em> as the <em>aggregation query</em>. Qualifying queries are, in turn, those in which the <code>from</code>/<code>join</code> clause introduces a table that is referred to by an argument of the aggregate function.<a id="ref-1" href="#footnote-1" title="ISO/IEC 9075-2:2023 §6.7 SR 7a">1</a> Let’s have a look at the original query again.</p><pre><code>SELECT (SELECT <b>sum(a)</b> FROM xx LIMIT 1) <b>FROM aa</b></code></pre><p>The only column reference in the <code>sum</code> function refers to a column of the table <code>aa</code> introduced by the outer <code>from</code> clause. Thus, the <code>sum(a)</code> expression belongs to the outer <code>select</code>. Now that the outer query is an <em>aggregation query</em> that has no explicit <code>group by</code> clause, <code>group by ()</code> is effectively added so that the final result has a single row.</p><p>On the other hand, there is no aggregate function referring to the inner query. This means that the inner query is <em>not</em> an <em>aggregation query</em> and there is no <code>group by ()</code> implied! The inner query, which is supposed to return no more than one row, basically returns all three rows of the <code>xx</code> table. It is just the <code>limit</code> clause preventing it.<a id="ref-2" href="#footnote-2" title="Side note: SQLite effectively implies LIMIT 1. Quoting the documentation: “The value of a subquery expression is the first row of the result from the enclosed SELECT statement.”">2</a></p><p>Now, that we know how the standard specifies this behavior, let’s look which products follow the specification.</p><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 319"><text y="28"><tspan x="387" dy="28">Apache Derby</tspan><tspan x="387" dy="28">BigQuery</tspan><tspan x="387" dy="28">Db2 (LUW)</tspan><tspan x="387" dy="28">H2</tspan><tspan x="387" dy="28">MariaDB</tspan><tspan x="387" dy="28">MySQL</tspan><tspan x="387" dy="28">Oracle DB</tspan><tspan x="387" dy="28">PostgreSQL</tspan><tspan x="387" dy="28">SQL Server</tspan><tspan x="387" dy="28">SQLite</tspan></text><text x="0" y="0" transform="rotate(-45 44 6)"><tspan>2005</tspan><tspan y="29.3" x="29.3">2007</tspan><tspan y="58" x="58">2009</tspan><tspan y="86.7" x="86.7">2011</tspan><tspan y="115.3" x="115.3">2013</tspan><tspan y="144" x="144">2015</tspan><tspan y="172.7" x="172.7">2017</tspan><tspan y="201.3" x="201.3">2019</tspan><tspan y="230" x="230">2021</tspan><tspan y="258.6" x="258.6">2023</tspan></text><path d="M1,33v284 M21.3,33v284 M41.5,33v284 M61.8,33v284 M82.1,33v284 M102.3,33v284 M122.6,33v284 M142.8,33v284 M163.1,33v284 M183.4,33v284 M203.6,33v284 M223.9,33v284 M244.2,33v284 M264.4,33v284 M284.7,33v284 M304.9,33v284 M325.2,33v284 M345.5,33v284 M365.7,33v284 "></path><svg x="185.2" y="289" width="200.8" height="26"><path d="M0,0h198.8c6,8.7 -6,17.3 0,26h-198.8"></path><text x="1" y="10">✓ 3.8.3 - 3.44.0</text><g><path d="M1,14h11.3l-11.3,11.3zm12,12h-11.3l11.3,-11.3z"></path><text x="7" y="23">a</text></g></svg><svg x="71.8" y="289" width="112.4" height="26"><path d="M2,0h110.4v26h-110.4c-6,-8.7 6,-17.3 0,-26"></path><text x="5" y="10">⚡ 3.6.1 - 3.7.11</text><g><path d="M5,14h12v12h-12v12"></path><text x="11" y="23">a</text></g></svg><svg x="106.4" y="261" width="279.6" height="26"><path d="M2,0h275.6c6,8.7 -6,17.3 0,26h-275.6c-6,-8.7 6,-17.3 0,-26"></path><text x="5" y="10">⚠ 2008R2 - 2022</text><g><path d="M5,14h12v12h-12v12"></path><text x="11" y="23">b</text></g></svg><svg x="61.6" y="233" width="324.4" height="26"><path d="M2,0h320.4c6,8.7 -6,17.3 0,26h-320.4c-6,-8.7 6,-17.3 0,-26"></path><text x="5" y="10">✓ 8.3 - 16</text></svg><svg x="51.7" y="205" width="334.3" height="26"><path d="M2,0h330.3c6,8.7 -6,17.3 0,26h-330.3c-6,-8.7 6,-17.3 0,-26"></path><text x="5" y="10">⚡ 11gR1 - 23cFREE</text><g><path d="M5,14h12v12h-12v12"></path><text x="11" y="23">a</text></g></svg><svg x="79.4" y="177" width="306.6" height="26"><path d="M0,0h304.6c6,8.7 -6,17.3 0,26h-304.6"></path><text x="1" y="10">✓ 5.1 - 8.2.0</text><g><path d="M1,14h11.3l-11.3,11.3zm12,12h-11.3l11.3,-11.3z"></path><text x="7" y="23">a</text></g></svg><svg x="15.1" y="177" width="63.3" height="26"><path d="M2,0h61.3v26h-61.3c-6,-8.7 6,-17.3 0,-26"></path><text x="5" y="10">⚡ 5.0</text><g><path d="M5,14h12v12h-12v12"></path><text x="11" y="23">a</text></g></svg><svg x="102" y="149" width="284" height="26"><path d="M2,0h280c6,8.7 -6,17.3 0,26h-280c-6,-8.7 6,-17.3 0,-26"></path><text x="5" y="10">✓ 5.1 - 10.11</text></svg><svg x="230" y="121" width="156" height="26"><path d="M2,0h152c6,8.7 -6,17.3 0,26h-152c-6,-8.7 6,-17.3 0,-26"></path><text x="5" y="10">⚡ 1.4.192 - 2.2.224</text><g><path d="M5,14h12v12h-12v12"></path><text x="11" y="23">a</text></g></svg><svg x="93.3" y="93" width="292.7" height="26"><path d="M2,0h288.7c6,8.7 -6,17.3 0,26h-288.7c-6,-8.7 6,-17.3 0,-26"></path><text x="5" y="10">✓ 9.7 - 11.5.8</text></svg><svg x="382.2" y="65" width="1.8" height="26"><path d="M2,0h34.2c6,8.7 -6,17.3 0,26h-34.2c-6,-8.7 6,-17.3 0,-26"></path><text x="5" y="10">⚡ 2.0</text><g><path d="M5,14h12v12h-12v12"></path><text x="11" y="23">a</text></g></svg><svg x="286.7" y="37" width="97.3" height="26"><path d="M2,0h129.5c6,8.7 -6,17.3 0,26h-129.5c-6,-8.7 6,-17.3 0,-26"></path><text x="5" y="10">⚡ 10.15.1.3 - 10.17.1.0</text><g><path d="M5,14h12v12h-12v12"></path><text x="11" y="23">a</text></g></svg></svg><p>Only half of the tested products implement the <em>aggregation query</em> in a standard-conforming way. That makes me wonder if the standard should introduce an implementation defined item here. However, in the chart it is also notable that some systems changed their behavior in the past. I checked older releases of the standard and found that the current wording was apparently introduced in 2003. This is at least what <a href="https://bugs.mysql.com/bug.php?id=27333">MySQL bug 27333</a> suggests. The bug report complains about MySQL’s behavior and refers to “the SQL2003 draft: (section 6.9)”. The report also paraphrases the above-quoted specification of the <em>aggregation query</em>.</p><p>SQL:1999 was worded entirely differently in this regard. The term <em>aggregation query</em> did not exist. I couldn’t even find any other sections that would result in the behavior of the current standard. Going even further back in time, to the <a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">well-known draft of SQL-92 that can easily be found online</a>, there was yet another wording. The absence of an explicit <code>group by</code> clause did <em>not</em> imply <code>group by ()</code> if needed. Instead, there was a general rule—not a syntax rule—that took care of doing the implicit grouping if necessary. ISO/IEC 9075:1992 §7.9 GR 1ai says:</p><blockquote><p>If the &lt;select list&gt; <em>contains</em> a &lt;set function specification&gt; that contains a reference to a column of T <span>[or …]</span>, then <span>[… and]</span> the result of the &lt;query specification&gt; is a table consisting of 1 row.</p></blockquote><p>Emphasis and omissions are mine. Note that the outer <code>select</code> still <em>contains</em> the <code>sum</code> function because the term <em>contains</em> is defined recursively.<a id="ref-3" href="#footnote-3" title="ISO/IEC 9075:1992 §3.3.4.2">3</a> For your convenience, the query again.</p><pre><code>SELECT (SELECT <b>sum(a)</b> FROM xx LIMIT 1) <b>FROM aa</b></code></pre><p>As the outer <code>select</code> list <em>contains</em> a &lt;set function specification&gt;, namely <code>sum</code>, the result is a single row. So it seems that this behavior has been there since 1992 at least. As I don’t have access to any even older editions, my archaeological excursion ends here.</p><p>Oh, just one more thing…why is it that SQL Server is so picky about outer references in aggregates? Changing the query to <code>sum(a + x)</code> yields error message 8124: <em>Multiple columns are specified in an aggregated expression containing an outer reference. If an expression being aggregated contains an outer reference, then that outer reference must be the only column referenced in the expression.</em></p><p>After further review of the current standard, it turns out it has this limitation. However, implementing the optional feature F441 lifts it. Quoting ISO/IEC 9075-2:2023 §10.9 CR 8:</p><blockquote><p>Without Feature F441, “Extended set function support”, conforming SQL language shall not contain a &lt;value expression&gt; simply contained in a &lt;general set function&gt; that contains a column reference that is an outer reference where the &lt;value expression&gt; is not a column reference.</p></blockquote><p>The standards wording is even more restricting than SQL Server’s error message: in the presence of an outer reference, it rules out everything else—not just other column references. Out of curiosity I checked SQL:1992 again and found something interesting in ISO/IEC 9075:1992 §6.5 SR 4:</p><blockquote><p>If the &lt;value expression&gt; contains a &lt;column reference&gt; that is an outer reference, then that outer reference shall be the only &lt;column reference&gt; contained in the &lt;value expression&gt;.</p></blockquote><p>In SQL:1992, there was precisely the same limitation as expressed by SQL Server’s current error message.</p><p>Now, that the relation of SQL Server’s restriction to the standard is also clarified, there remains only one ultimate question: Why the heck was this behavior ever introduced?</p></div><div id="below-article"><p>You can’t catch up on 20 years of SQL evolution in one day. Subscribe the newsletter via <b><a href="https://winand.us7.list-manage.com/subscribe?u=0144e9d4699c960039a90ad24&amp;id=a88100f1ab&amp;group%5B441%5D%5B256%5D=true">E-Mail</a></b>, <b><a href="https://twitter.com/ModernSQL">Twitter</a></b> or <b><a href="https://modern-sql.com/feed">RSS</a></b> to gradually catch up and to keep <em>modern-⁠sql.com</em> on your radar.</p><h2>About the Author</h2><div id="authorsbio"><p><img width="110" height="110" src="https://modern-sql.com/static/markuswinand.JSEKkX8C.jpg" alt="Photo of Markus Winand"/></p><p>Markus Winand provides insights into SQL and shows how different systems support it at  <a href="https://modern-sql.com">modern-sql.com</a>. Previously he made <a href="https://use-the-index-luke.com">use-the-index-luke.com</a>, which is still actively maintained. Markus can be hired as trainer, speaker and consultant via <a href="https://winand.at">winand.at</a>.</p></div></div></div>
  </body>
</html>
