<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/">Original</a>
    <h1>Rendering like it&#39;s 1996 – Baby&#39;s first pixel</h1>
    
    <div id="readability-page-1" class="page"><div>



<div>



<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/quake.png"/>
	<span>There&#39;s absolutely no chance we&#39;ll get to this level of quality.</span>
</p>




<p>
	In 1996, I was a teen without a gaming console. While my friends enjoyed their Crash Bandicoots, Tekens, and Turoks, I had a beige 486 DX 2 with a turbo button, 16Mb of RAM, a 256Mb hard disk, and a 2x CD-ROM drive running DOS. And then I got a copy of Quake. Did it run great? No. But it did run! And to my young eyes, it was the most beautiful thing I&#39;ve ever seen on my computer screen. Ok, the most beautiful brown thing.
</p>

<p>
	3D accelerator graphics cards were in their <a href="https://www.techspot.com/article/650-history-of-the-gpu/">infancy</a>. Most DOS PC games around that time would render their glorious pixels via the CPU to a dedicated area in RAM, e.g. starting at segment address 0xa000. The (pretty dumb) graphics card would then read and display the contents of that memory area on your bulky CRT. This is known as <a href="https://en.wikipedia.org/wiki/Software_rendering">software rendering or software rasterization</a>.
</p>

<p>
	I did dabble in some graphics programming back then. I even managed to create a <a href="https://marioslab.io/projects/return-to-marchfeld">Wolfenstein style first person shooter</a> in QBasic with some assembly before the end of the century.
</p>


<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/rtm.png"/>
	<span>Actually not a ray casting engine, but a polygonal 3D engine with terrible affine texture mapping.</span>
</p>


<p>
	But I never really dove into the depths of contemporary graphics technology. And while my subsequent professional career featured plenty of graphics programming, it was mostly the GPU accelerated kind, not the &#34;worry about each cycle in your inner loops&#34; software rasterizer kind of type.
</p>

<h2>(Non-)Goals</h2>
<p>
	I want to explore the ins and outs of software rasterization, starting from first principles, i.e. getting a pixel on screen. From there, I want to delve into topics like simple demo effects, primitive rasterization, ray casting, voxel terrain, maybe even Quake-style 3D rendering, and whatever else comes to mind.
</p>

<p>
	Each blog post on a topic will lay out the theory the way I understand it in hopefully simple terms, discuss a naive practical implementation, and finally investigate ways to optimize the implementation until it is reasonably fast.
</p>

<p>
	The end product(s) should work on Windows, Linux, macOS, and common browsers. Ideally, a little software rasterizer library and demos will fall out at the end, that can serve both as an example implementation of common techniques, or as the basis for other demos or games with DOS game aesthetics.
</p>

<p>
	You&#39;ll be able to follow along both here, and by playing with the <a href="https://github.com/badlogic/r96">code on GitHub</a>. For each blog post, there will be one tagged commit in the <code>main</code> branch you can check out. In addition to the render-y bits, I&#39;ll also demonstrate how I set up a cross-platform C project and show you how I structure, build, and debug C code in such a project. I love seeing and learning from other people&#39;s workflows. Maybe that&#39;s true for you too.
</p>

<p>
	What I do not want to do is dabble in things like assembly or SIMD optimizations. While that can be fun too, it is unlikely to be necessary on today&#39;s hardware, given that I&#39;ll target common DOS resolutions like 320x240, or 640x480. I might however inspect and discuss the compiler&#39;s assembly output to identify areas that can be improved performance wise in the higher level code.
</p>

<h2>Tools of the trade</h2>
<p>
	The weapon of choice will be C99 for aesthetic and practical reasons. I want all the code produced throughout this series to compile anywhere. It should also be easy to re-use the code in other languages through an <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">FFI</a>. C99 is a good choice for both objectives.
</p>

<p>
	In terms of ompilers, I&#39;ll be using <a href="https://github.com/mstorsjo/llvm-mingw">Clang with MinGW headers and standard libraries</a> on Windows, Clang through Xcode on macOS, and GCC on Linux. Why Clang on Windows? Because Visual Studio is a multi-gigabyte download, and setting up builds for it is a terrible experience. Clang also generates better code.
</p>

<p>
	I&#39;ll use <a href="https://cmake.org/">CMake</a> as the meta build tool, not because I love it, but because my favorite C/C++ IDE <a href="https://www.jetbrains.com/clion/">CLion</a> has first class support for it. Other development environments understand CMake as well these days, including <a href="https://learn.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-170">Visual Studio</a> if that&#39;s your kink. For actually executing the builds, I&#39;ll use <a href="https://ninja-build.org/">Ninja</a>, which is wicked fast, especially compared to MSBuild and consorts.
</p>

<p>
	The pixels we&#39;ll generate need to be thrown up on the display somehow. On Windows, Linux, and macOS we&#39;ll use <a href="https://github.com/emoon/MiniFB">MiniFB</a>. In a few lines of code, we can open a window, process keyboard and mouse input, and give it a bunch of pixels to draw to the window. It can even upscale our low resolution output if needed. Since MiniFB does not have browser support, I&#39;ve written a web backend myself and submitted it as a <a href="https://github.com/emoon/MiniFB/pull/94">pull request</a> to the upstream repo. In the meantime, we&#39;ll use my <a href="https://github.com/badlogic/MiniFB/tree/web">MiniFB fork</a>, which has web support baked in.
</p>

<p>
	To get the code running in the browser, we&#39;ll use <a href="https://emscripten.org/">Emscripten</a> to compile the C code to <a href="https://developer.mozilla.org/en-US/docs/WebAssembly">WASM</a> and a small <code>.js</code> file, which loads the <code>.wasm</code> file and exposes our C functions to JavaScript.
</p>

<p>
	In terms of IDE, you are free to use whatever you want. You&#39;ll most likely want something that can ingest CMake builds. For this series, I choose VS Code, not because I love it, but because it&#39;s free. The project contains a bunch of VS Code specific settings that make working on the project super simple for all supported platforms.
</p>

<h2>Getting the source code and tools</h2>

<p>
	That&#39;s a lot of tools! I&#39;ve tried to make it as simple for you to follow along as possible. Here&#39;s what you need to install:
</p>

<ul>
	<li><a href="https://code.visualstudio.com/">Visual Studio Code</a></li>
		<ul><li>Make sure <code>code</code> can be called on the command line! Open VS Code, press <code>CTRL+SHIFT+P</code> (or <code>CMD+SHIFT+P</code> on macOS), type <code>Shell Command: Install &#39;code&#39; command in PATH</code> and hit enter.</li></ul>
	<li><strong>Windows:</strong>
		<ul>
			<li><a href="https://git-scm.com/download/win">Git for Windows</a>. Make sure its available on the command line via the system PATH.</li>			
		</ul>
	</li>
	<li><strong>Linux:</strong>
		<ul>
			<li>Git, <a href="https://gcc.gnu.org/">GCC</a>, <a href="https://www.sourceware.org/gdb">GDB</a>, Python, CMake, Curl, libx11-dev, libxkbcommon-dev, and libgl1-mesa-dev. On Ubuntu <code>sudo apt install build-essential git gdb python3.11 cmake curl libx11-dev libxkbcommon-dev libgl1-mesa-dev</code></li>			
		</ul>
	</li>
	<li><strong>macOS:</strong>
		<ul>
			<li><a href="https://developer.apple.com/xcode/">Xcode</a>. Make sure to also install the <a href="https://mac.install.guide/commandlinetools/4.html">command line tools</a></li>			
		</ul>
	</li>
</ul>

<p>
	Once you&#39;ve installed the above, clone the repository (on Windows, use Git Bash, which comes with Git for Windows):
</p>


<div>
	<pre><code>git clone https://github.com/badlogic/r96
cd r96</code></pre>
</div>


<p>
	Next, checkout the tag for the blog post you want to follow along with, execute the <code>tools/download-tools.sh</code> script:
</p>


<div>
	<pre><code>git checkout 01-babys-first-pixel
./tools/download-tools.sh</code></pre>
</div>


<p>
	The <code>download-tools.sh</code> script will download all remaining tools that are needed, like CMake, Ninja, Clang for Windows, Python, a small static file server, Emscripten, and Visual Studio Code extensions needed for C/C++ development. See the <a href="https://github.com/badlogic/r96/blob/main/README.md">README.md</a> for details.
</p>

<p>
	<strong>Note:</strong> we may add new tools in future blog posts. After checking out a tag for a blog post, make sure to run <code>tools/download-tools.sh</code> again.
</p>


<h2>The r96 project</h2>

<p>
	These are the goals for the project scaffold:
</p>

<ul>
	<li>Make building and debugging for the desktop and the web trivial.</li>
	<li>Allow adding new demo apps that work without code modification on both the desktop and in the browser</li>
	<li>Make creating re-usable code easy.</li>
</ul>

<p>
	Let&#39;s see how I tried to achieve the above. Open your clone of the <code>r96</code> Git repository in VS Code and have a look what&#39;s inside.
</p>

<p>
	<strong>Note:</strong> The first time you open the project in VS Code, you&#39;ll be asked to select a <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html">CMake configure preset</a>.
</p>

<p>
	<strong>Note:</strong> the first time you open a source file in VS Code, you will be asked if you want to install <code>clangd</code>. Click <code>Yes</code>.
</p>

<h3>File structure</h3>


<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/r96-files.png"/>
	<span></span>
</p>


<p>Let&#39;s start in the root folder.</p>

<p>
	The <code>.gitignore</code>, <code>LICENSE</code>, and <code>README.md</code> files are self-explanatory.
</p>

<p>
	The <code>CMakeLists.txt</code> and <code>CMakePresets.json</code> define our build. We&#39;ll look into these in a later section.
</p>
	
<p>
	The <code>.clang-format</code> file stores the formatting settings used to format the code via, you guessed it, <a href="https://clang.llvm.org/docs/ClangFormat.html">clang-format</a>. The VS Code C/C++ extension uses the settings in that file whenever you format a C/C++ source file. The file can also be used to format the entire code base from the command line.
</p>

<p>
	The <code>src/</code> folder contains our code. Re-usable code goes into <code>src/r96/</code>. Demo apps go into the root of the <code>src/</code> folder. There are two demo apps so far called <code>00_basic_window.c</code> and <code>01_drawing_a_pixel.c</code>. Any demo apps we write in subsequent blog posts will also go into <code>src/</code> and start with a sequential number, so we immediately see in which order they were written.
</p>

<p>
	The <code>src/web/</code> folder may be weird, even scary to seasoned C veterans. But we need it to run our demo apps on the web. A small price to pay. It contains one <code>.html</code> file per demo app. The purpose of that file is to:
</p>

<ul>
	<li>Load the <code>.js</code> and <code>.wasm</code> files generated by Emscripten for the demo app executable target</li>
	<li>Provide the demo app with a HTML5 canvas element to draw to</li>
	<li>Kick off the demo apps execution by calling its <code>main()</code> function</li>
</ul>
<p>
	For any demo app we write in the future, we&#39;ll add a source file to the <code>src/</code> folder, and a corresponding <code>.html</code> file to the <code>src/web/</code> folder.
</p>

<p>
	The <code>src/web/index.html</code> file is just a plain listing linking to all the <code>.html</code> files of our demo apps. The <code>src/web/r96.css</code> file is a CSS style sheet used to make the elements in the demo app <code>.html</code> files a little prettier.
</p>

<p>
	The <code>.vscode/</code> folder contains settings and launch configurations so working on the project is a nice experience in VS Code.
</p>

<p>
	Finally, the <code>tools/</code> folder contains scripts to download the necessary tools as well as configuration files for a few of those tools. When executing the <code>tools/download-tools.sh</code> script, some of the tools actually get installed in the <code>tools/</code> folder so they don&#39;t clog up your system. The folder also contains scripts and batch files used by the launch configurations to do their work.
</p>

<p>
	The details of the <code>.vscode</code> and <code>tools</code> folder are all gory and duct tape-y. You can have a look if you must. For the remained of the series, their content doesn&#39;t matter much. Just know that they are setup in a way to make our lives easy.
</p>

<h3>Building</h3><p>

The first time you open the project in VS Code, you&#39;re asked to select a configure preset.


</p><p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/preset.png"/>
	<span></span>
</p>


<p>
	A configure preset defines for what platform the code should be build and with what compiler and build flags that should happen. The presets are defined in <a href="https://github.com/badlogic/r96/blob/01-babys-first-pixel/CMakePresets.json">CMakePresets.json</a>.
</p>

<p>
	For each platform the <code>r96</code> project supports, there is a corresponding <code>debug</code> and <code>release</code> configure preset. To start, we&#39;ll select <code>Desktop debug</code>. You can also select the configure preset in the status bar at the bottom of VS Code.
</p>


<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/change-preset.png"/>
	<span></span>
</p>


<p>
	To build the project for the selected platform and build type (<code>debug</code> or <code>release</code>), click the <code>Build</code> button in the status bar.
</p>


<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/build.png"/>
	<span></span>
</p>


<p>
	Alternatively, you can open the VS Code command palette (<code>CTRL+SHIFT+P</code> or <code>CMD+SHIFT+P</code> on macOS), type <code>CMake: Build</code>, and hit enter.
</p>

<p>
	In both cases, the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">CMake Tools</a> extension, which was installed as part of <code>tools/download-tools.sh</code>, will configure the CMake build if necessary, then incrementally build the libraries and executables defined in <a href="https://github.com/badlogic/r96/blob/01-babys-first-pixel/CMakeLists.txt">CMakeLists.txt</a>.
</p>

<p>
	The resulting build output consisting of executables and assets can be found in <code>build/&lt;os&gt;-&lt;build-type&gt;</code>. E.g. for <code>Desktop debug</code>, the build output will be located in <code>build/windows-debug</code>, <code>build/linux-debug</code>, or <code>build/macos-debug</code> depending on what operating system you are on. For <code>Web release</code> the output will be in <code>build/web-output</code>, and so on.
</p>

<p>
	<strong>Note:</strong> To learn more about how to use VS Code CMake integration, check out the <a href="https://vector-of-bool.github.io/docs/vscode-cmake-tools/index.html">documentation</a>.
</p>

<p>
	You can of course also build the project on the command line:
</p>


<div>
	<pre><code># Configure a Windows debug build and execute the build
cmake --preset windows-debug
cmake --build build/windows-debug

# Configure a web release build and execute the build
cmake --preset web-release
cmake --build build/web-release</code></pre>
</div>


<h3>Debugging</h3>
<p>
	The <a href="https://github.com/badlogic/r96/blob/01-babies-first-pixel/.vscode/launch.json">launch.json</a> file in the <code>.vscode/</code> folder defines launch configurations for each platform. Click the launch button in the status bar to select the launch configuration and start a debugging session. 
</p>


<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/launch.png"/>
	<span></span>
</p>


<p>
	After clicking this status bar entry, you&#39;ll be asked to select a launch configuration:
</p>


<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/launch-configs.png"/>
	<span></span>
</p>


<p>
	When you first start a debugging session, you&#39;ll be asked to select a launch target, aka the executable you want to launch:
</p>


<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/launch-targets.png"/>
	<span></span>
</p>


<p>
	You can also change the launch target in the status bar:
</p>


<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/launch-target-status-bar.png"/>
	<span></span>
</p>


<p>
	After selecting the launch target, the code is incrementally rebuild, and the debugging session starts. 
</p>

<p>
	Instead of going through the status bar, you can also start a new debugging sessions by pressing `F5`. This will launch a session for the currently selected launch configuration, configure preset, and launch target.
</p>

<p>
	<strong>Important:</strong> the launch configuration MUST match the preset you selected:
</p><ul>
	<li><code>Desktop debug target</code>: select the <code>Desktop debug</code> or <code>Desktop release</code> preset.</li>
	<li><code>Web debug target</code>: select the <code>Web debug</code> or <code>Web release</code> preset.</li>
</ul>

<p>
	Debugging a desktop build is the standard experience you are used to. Set breakpoints and watches, interrupt the program at any time, and so on.
</p>

<p>
	Debugging the C code compiled to WASM directly in VS Code is not possible. When you start a web debugging session, the respective launch configuration starts a local <a href="https://github.com/badlogic/static-file-server">static file server</a> (downloaded via <code>tools/download-tools.sh</code>) and opens the <code>.html</code> file corresponding to the selected launch target in a browser tab.
</p>

<p>
	When you are done &#34;debugging&#34; a web build, close the browser tab, and close the debugging session in VS Code by clicking the &#34;Stop&#34; button in the debugger controls.
</p>

<p>
 If you feel adventurous: it is possible to <a href="https://developer.chrome.com/blog/wasm-debugging-2020/">debug the C and JavaScript code in Chrome.</a>. We&#39;ll look into that below.
</p>

<h3>Dissecting the CMakeLists.txt and CMakePresets.json files</h3>

<p>To understand how the build is setup, we need to understand the <a href="https://github.com/badlogic/r96/blob/01-babys-first-pixel/CMakeLists.txt">CMakeLists.txt</a> and <a href="https://github.com/badlogic/r96/blob/01-babys-first-pixel/CMakePresets.json">CMakePresets.json</a> files.</p>

<p>
	We&#39;ve already had a brief look at the <code>CMakePresets.json</code> file above. It defines a <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html">configure preset</a> for each operating system and build type combination. Let&#39;s have a look at one of the presets, specifically, the one used for Windows debug builds.
</p>


<div>
	<pre><code>{
	&#34;name&#34;: &#34;windows-debug&#34;,
	&#34;displayName&#34;: &#34;Desktop debug&#34;,
	&#34;description&#34;: &#34;&#34;,
	&#34;generator&#34;: &#34;Ninja&#34;,
	&#34;binaryDir&#34;: &#34;${sourceDir}/build/${presetName}&#34;,
	&#34;cacheVariables&#34;: {
		&#34;CMAKE_BUILD_TYPE&#34;: &#34;Debug&#34;,
		&#34;CMAKE_MAKE_PROGRAM&#34;: &#34;${sourceDir}/tools/desktop/ninja/ninja&#34;
	},
	&#34;toolchainFile&#34;: &#34;${sourceDir}/tools/desktop/toolchain-clang-mingw.cmake&#34;,
	&#34;condition&#34;: {
		&#34;type&#34;: &#34;equals&#34;,
		&#34;lhs&#34;: &#34;${hostSystemName}&#34;,
		&#34;rhs&#34;: &#34;Windows&#34;
	}
},</code></pre>
</div>


<p>
The important bits are:
</p>

<ul>
	<li><code>generator</code>: we tell CMake to generate a <a href="https://ninja-build.org">Ninja</a> build.</li>
	<li><code>binaryDir</code>: specifies the output directory for the build. In this case it maps to <code>build/windows-debug</code> through variable substitution.</li>
	<li><code>CMAKE_BUILD_TYPE</code>: tells CMake we want the binaries to include debugging information.</li>
	<li><code>CMAKE_MAKE_PROGRAM</code>: tells CMake were to find the Ninja executable. The <code>tools/download-tools.sh</code> script downloaded the executable to <code>tools/desktop/ninja/</code></li>
	<li><code>toolchainFile</code>: where to find the compiler and linker. On Windows, we use <a href="https://github.com/mstorsjo/llvm-mingw">Clang with MinGW headers and standard libraries.</a>, which the <code>tools/download-tools.sh</code> script downloads to <code>tools/desktop/clang</code>. The <a href="https://github.com/badlogic/r96/blob/01-babys-first-pixel/tools/desktop/toolchain-clang-mingw.cmake">toolchain file</a> references the compiler and linker in that location and sets up a few other CMake cache variables.</li>
	<li><code>condition</code>: tells CMake to only enable this configure preset if we&#39;re running on Windows.</li>
</ul>

<p>
	The other configure presets are pretty similar and only differ in what operating system they should be available on, as well as the toolchain being used. On macOS and Linux, the default toolchain is used (GCC or Xcode&#39;s Clang). For the web, the Emscripten toolchain is used through a toolchain file that ships with Emscripten.
</p>

<p>
	We could work without this presets file, but that would mean we&#39;d have to specify all these parameters manually every time we configure a CMake build. With the presets, this becomes <code>cmake --preset &lt;preset-name&gt;</code>. Much nicer!
</p>

<p>
	The <code>CMakeLists.txt</code> file defines the actual build itself, i.e. which source files make up which libraries and executables, and what compiler flags to use. Definitions of libraries and executables are called targets in CMake. Let&#39;s go through it section by section. We start out with this:
</p>


<div>
	<pre><code>cmake_minimum_required(VERSION 3.21.1)
project(r96)

set(CMAKE_C_STANDARD 99)
set(CMAKE_C_STANDARD_REQUIRED TRUE)
set(CMAKE_EXPORT_COMPILE_COMMANDS TRUE)</code></pre>
</div>


<p>
	We define the minimum CMake version and project name, and enable (and require) C99 support. The final line makes CMake generate a <code>compile_commands.json</code> file in the build folder. This is also known as a <a href="https://clang.llvm.org/docs/JSONCompilationDatabase.html">compilation database</a> and used by many IDEs to understand a CMake build. In our case, the file is used by the <a href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">clangd VS Code extension</a> to provide us with code completion and other niceities.
</p>


<div>
	<pre><code>include(FetchContent)
FetchContent_Declare(minifb GIT_REPOSITORY https://github.com/badlogic/minifb GIT_TAG dos-pr-master)
set(MINIFB_BUILD_EXAMPLES CACHE INTERNAL FALSE)
FetchContent_MakeAvailable(minifb)</code></pre>
</div>


<p>
	Next we pull in MiniFB via CMake&#39;s <a href="https://cmake.org/cmake/help/latest/module/FetchContent.html">FetchContent</a> mechanism. CMake veterans may sneer at this and rather use a Git submodule. But I like it that way, thank you very much. This magic incantation will clone my MiniFB fork with web support, disable the MiniFB example targets, and finally make the remaining MiniFB library target available to the targets defined in our own <code>CMakeLists.txt</code>. Nice.
</p>


<div>
	<pre><code>add_compile_options(-Wall -Wextra -Wpedantic -Wno-implicit-fallthrough)</code></pre>
</div>


<p>
	This section sets the &#34;pedantic warnings are errors&#34; compiler flags. We want the code to be reasonably clean and fail if a warning is generated.
</p>


<div>
	<pre><code>add_library(r96 &#34;src/r96/r96.c&#34;)</code></pre>
</div>


<p>
	Next we add a library target called <code>r96</code>. It&#39;s compiled from the <code>r96/r96.c</code> source file. Any re-usable code we write during the course of this blog post series will go in there. Any of our demo app executable targets can then depend on the <code>r96</code> library target to pull in its code.
</p>


<div>
	<pre><code>add_executable(r96_00_basic_window &#34;src/00_basic_window.c&#34;)
add_executable(r96_01_drawing_a_pixel &#34;src/01_drawing_a_pixel.c&#34;)</code></pre>
</div>


<p>
	We define two executable targets for the demos of this blog post.
</p>


<div>
	<pre><code>add_custom_target(r96_web_assets
    COMMAND ${CMAKE_COMMAND} -E copy_directory
    ${CMAKE_CURRENT_SOURCE_DIR}/src/web
    $&lt;TARGET_FILE_DIR:r96_00_basic_window&gt;
)</code></pre>
</div>


<p>
	We define a custom target that copies all the <code>.html</code> files from <code>src/web/</code> to the output folder. This target is needed for web builds.
</p>


<div>
	<pre><code>get_property(targets DIRECTORY &#34;${_dir}&#34; PROPERTY BUILDSYSTEM_TARGETS)
list(REMOVE_ITEM targets minifb r96 r96_assets r96_web_assets)
foreach(target IN LISTS targets)
    target_link_libraries(${target} LINK_PUBLIC minifb r96)    
    if(EMSCRIPTEN)
        add_dependencies(${target} r96_web_assets)
        target_link_options(${target} PRIVATE
                &#34;-sSTRICT=1&#34;
                &#34;-sENVIRONMENT=web&#34;
                &#34;-sLLD_REPORT_UNDEFINED&#34;
                &#34;-sMODULARIZE=1&#34;
                &#34;-sALLOW_MEMORY_GROWTH=1&#34;
                &#34;-sALLOW_TABLE_GROWTH&#34;
                &#34;-sMALLOC=emmalloc&#34;
                &#34;-sEXPORT_ALL=1&#34;
                &#34;-sEXPORTED_FUNCTIONS=[\&#34;_malloc\&#34;,\&#34;_free\&#34;,\&#34;_main\&#34;]&#34;
                &#34;-sASYNCIFY&#34;
                &#34;--no-entry&#34;
                &#34;-sEXPORT_NAME=${target}&#34;
        )
    endif()
endforeach()</code></pre>
</div>


<p>
	And then stuff gets crazy! The first two lines compiles a list of all demo executable targets. We then iterate through those executable targets and link the <code>r96</code> library target to each of them. If we build for the web, we also add the custom <code>r96_web_assets</code> target to the executable as a dependency, so the <code>.html</code> files get copied over to the output folder.
</p>

<p>
	Finally, we add a few Emscripten specific linker options. These are settings I arrived at after working with WASM for the last 2 years. They are all Emscripten specific and do things like allowing heap memory to grow. You can check out all the options in Emscripten&#39;s <a href="https://github.com/emscripten-core/emscripten/blob/main/src/settings.js"><code>settings.js</code></a> file. There&#39;s a lot.
</p>

<p>The purpose of this evil incantation is to reduce the amount of CMake spaghetti needed when adding a new demo. All we need to do is add a single <code>add_executable_target()</code> line, specifiyng the demo name and source files its composed of. The evil incantation will then link the new demo up with all the necessary bits automatically. Nice!</p>

<h2>The first demo app: 00_basic_window</h2>

<p>
	Before we can get our hands dirty with programmatically creating the most beautiful pixels in the world, we need to understand how MiniFB works and how a demo app is structured in terms of code. With no further ado, here&#39;s <a href="https://github.com/badlogic/r96/blob/01-babys-first-pixel/src/00_basic_window.c"><code>src/00_basic_window.c</code></a>:
</p>


<div>
	<pre><code>#include &lt;MiniFB.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
	const int res_x = 320, res_y = 240;
	struct mfb_window *window = mfb_open(&#34;00_basic_window&#34;, res_x, res_y);
	uint32_t *pixels = (uint32_t *) malloc(sizeof(uint32_t) * res_x * res_y);
	do {
		mfb_update_ex(window, pixels, res_x, res_y);
	} while (mfb_wait_sync(window));
	return 0;
}</code></pre>
</div>


<p>
	This is a minimal MiniFB app that opens a window with a drawing area of 320x240 pixels (line 6). It then allocates a buffer of 320x240 <code>unit32_t</code> elements (line 7). Each <code>uint32_t</code> element encodes the color of a pixel. Next, we keep drawing the contents of the buffer to the window via <code>mfb_update_ex()</code> (line 9) until <code>mfb_wait_sync()</code> returns false (line 10), e.g. because the user pressed the ESC key to quit the app. It can&#39;t get any simpler.
</p>

<p>
	MiniFB has a super minimal API. You can learn more about it <a href="https://github.com/emoon/minifb">here</a>.
</p>

<p>
	<strong>Note:</strong> The <code>mfb_update_ex()</code> function also returns a status code which can be used to decide if the app should be exited. We&#39;re not using this above for brevity&#39;s sake.
</p>

<h3>Running the demo app on the desktop</h3>

<p>
	To compile and run (or debug) our little demo app on the desktop, select the <code>Desktop debug</code> configure preset in the VS Code status bar, select the <code>r96_00_basic_window</code> target as the launch target, and the <code>Desktop debug target</code> launch configuration. Press <code>F5</code> and you&#39;ll get this:
</p>


<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/desktop.png"/>
	<span>r96_00_basic_window on the desktop.</span>
</p>


<p>
	Most impressive. You can make changes to the code and just hit <code>F5</code> again to incrementally rebuild and restart the demo app. You can also set breakpoints, inspect variables and call stacks, and so on.
</p>

<p>
	Now how do we run the same demo app in the browser?
</p>

<h3>Running the demo app on the web</h3>

<p>
	Select the <code>Web debug</code> configure preset, and the <code>Web debug target</code> launch configuraton and press <code>F5</code>. You&#39;ll see this:
</p>


<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/browser.png"/>
	<span>r96_00_basic_window running in the browser.</span>
</p>


<p>
	The launch configuration starts a static file server (<code>tools/web/static-server</code>) which serves the files in <code>build/web-debug/</code> on port <code>8123</code>. The static server will also automatically open a browser tab with the URL corresponding to the demo&#39;s <code>.html</code> file.
</p>

<p>When you&#39;re done being amazed by this, close the browser tab, and click the <code>Stop</code> button in the debugger controls in VS Code. If you want to be amazed again, just press <code>F5</code></p>

<h3>How the web version works</h3>

<p>
	It&#39;s kind of magic. Here&#39;s how the <a href="https://github.com/badlogic/r96/blob/01-babys-first-pixel/src/web/00_basic_window.html"><code>00_basic_window.html</code></a> file for the <code>00_basic_window.c</code> demo app looks like:
</p>


<div>
	<pre><code>&lt;html&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&#39;en&#39;&gt;
&lt;head&gt;
    &lt;meta charset=&#39;utf-8&#39;&gt;
    &lt;meta http-equiv=&#39;X-UA-Compatible&#39; content=&#39;IE=edge&#39;&gt;
    &lt;meta name=&#39;viewport&#39; content=&#39;width=device-width, initial-scale=1&#39;&gt;
    &lt;link rel=&#39;stylesheet&#39; href=&#39;r96.css&#39;&gt;
    &lt;script src=&#39;r96_00_basic_window.js&#39;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body class=&#39;r96_content&#39;&gt;
    &lt;h2&gt;Basic window&lt;/h2&gt;
    &lt;canvas id=&#39;00_basic_window&#39;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;script&gt;
    async function init() {
        await r96_00_basic_window()
    }

    init();
&lt;/script&gt;
&lt;/html&gt;</code></pre>
</div>


<p>
	Ignoring the boring HTML boilerplate, we see that the <code>r96_00_basic_window.js</code> file is loaded via a <code>&lt;script&gt;</code> tag. This file was generated as part of the build by Emscripten. It contains JavaScript code that loads the WebAssembly file that stores our compiled C code and exports functions with which we can interact with the WebAssembly code.
</p><p>
	Next we define a <code>&lt;canvas&gt;</code> with the id <code>00_basic_window</code>. Finally, a little JavaScript kicks of a call to <code>r96_00_basic_window()</code> (defined in <code>r96_00_basic_window.js</code>) in an asynchronous function. This call will load the <code>r96_00_basic_window.wasm</code> file and run its <code>main()</code> method.
</p>

<p>
	How does MiniFB know to render to the canvas? In our C code we have this line:
</p>


<div>
	<pre><code>struct mfb_window *window = mfb_open(&#34;00_basic_window&#34;, res_x, res_y);</code></pre>
</div>


<p>
	Instead of opening a window with &#34;00_basic_window&#34; as the title, the MiniFB web backend uses the first argument passed to <code>mfb_open()</code> to search a canvas element with that string as its id. Any calls to <code>mfb_update_ex()</code> will then draw the contents of the provided buffer to this canvas.
</p>

<p>
	Also of note: We didn&#39;t have to modify our C code at all, it just &#34;works&#34;. If you&#39;ve ever done any front-end development, that may be very weird to you. The app basically has an infinite loop! If you do that in JavaScript, the browser tab (or the whole browser) will freeze, because the browser engine&#39;s event loop will never get a chance to run and process events. How does this magic work?
</p>

<p>
	The MiniFB web backend I wrote uses an Emscripten feature called <a href="https://emscripten.org/docs/porting/asyncify.html">Asyncify</a>. In the implementation of <code>mfb_wait_sync()</code>, I call <code>emscripten_sleep(0)</code>. This gives back control to the browser engine, so it can process any DOM events and not freeze. Our native C code will then resume again, without our C code ever knowing that it was actually put to sleep. The Asyncify feature rewrites our C code (or rather its WASM representation) to use continuations. That allows pausing and resuming the C code transparently. Super cool!
</p>

<h3>Can I debug the C code in the browser?</h3>
<p>
	Yes, we can in Chrome. When we build using the <code>Web debug</code> configure preset, Emscripten will emit DWARF information in the resulting <code>.wasm</code> file. Chrome can use that information to provide native code debugging right in the developer tools. To get that working:
</p>

<ul>
	<li>Install Chrome</li>
	<li>Install the <a href="https://chrome.google.com/webstore/detail/cc%20%20-devtools-support-dwa/pdcpmagijalfljmkmjngeonclgbbannb">C/C++ DevTools Support (DWARF) extension</a> in Chrome</li>
	<li>Open Chrome Developer Tools, click the gear (⚙) icon in the top right corner of dev tools pane, go to the experiments panel and tick <code>WebAssembly Debugging: Enable DWARF support</code>
	
<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/chrome.png"/>
	<span></span>
</p>

	</li>
	<li>Restart Chrome</li>
</ul>

<p>
	 Launch the demo app using the <code>Web debug target</code> launch config in VS code, then open the dev tools in the browser, and click on the <code>Sources</code> tab. You can find all the <code>.c</code> files that make up our little demo app under the <code>file://</code> node, including the MiniFB sources. Open up <code>00_basic_window.c</code> and set a breakpoint inside the loop:
</p>


<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/chrome-debug.png"/>
	<span>C/C++ debugging in Chrome</span>
</p>


<p>
	And there you have it: C/C++ debugging in Chrome! Since the C code runs the same on both the desktop and in the browser, we&#39;ll likely never need this functionality, unless we implement web specific features.
</p>

<p>
	Speaking of features, let&#39;s add a second demo app and draw our first pixel! But first, some very practical &#34;theory&#34;.
</p>

<h2>Of colors, pixels, and rasters</h2>

<p>
	What&#39;s a pixel? Rumor has it that pixel is a stylized abbreviation of &#34;(pic)ture (el)ement&#34;. A precise answer is actually quite involved and may even depend on the decade you are living in.
</p>

<p>
	Here, we lazily and imprecisely define a pixel as the smallest &#34;atomic&#34; area within a raster for which we can define a color. A raster is a rectangular area made up  of pixels. Each pixel in the raster is assumed to have the same size. The width of a raster equals the number of pixels in a row, the height equals the number of pixels in a column.
</p>

<p>
	The below raster has a width of 23 pixels and a height of 20 pixels. To locate a pixel inside the raster, we use an integer coordinate system, with the x-axis pointing to the right, and the y-axis pointing down. The top left pixel in the raster is at coordinate <code>(0, 0)</code>, the top right pixel is at coordinate <code>(22, 0)</code> (or <code>(width - 1, 0)</code>), the bottom right pixel is at coordinate <code>(22, 19)</code> (or <code>(width - 1, height -1)</code>), and so on.
</p>





<p>
	A raster can be a display device&#39;s output area, a piece of grid paper, etc. The rasters we&#39;ll work with are two-dimensional arrays in memory. Each array element stores the color of the pixel in some encoding.
</p>

<h3>Color encodings</h3>

<p>
	We encode the color of a pixel using the <a href="https://en.wikipedia.org/wiki/RGBA_color_model">RGBA color model</a>, where a color is represented as an additive mix of its red, green, and blue components, and an additional alpha component specifying the pixel&#39;s opacity. The opacity comes into play when we blend pixels of one raster with pixels from another raster. That&#39;s a topic for another blog post.
</p>

<p>
	More specifically, we use an ARGB8888 encoding that fits in a 32-bit unsigned integer (or <code>uint32_t</code> in C). Each color component is encoded as an 8-bit integer in the range 0 (no contribution) to 255 (highest contribution). For the alpha component, 0 means &#34;fully transparent&#34; and 255 means &#34;fully opaque&#34;.
</p>

<p>
	Here&#39;s how the components are stored in a 32-bit unsigned integer. The most significant byte stores the alpha component, then come the red, green, and blue bytes.
</p>


<p><img src="https://marioslab.io/posts/rendering-like-its-1996/babys-first-pixel/argb8888.png"/>
	<span>Storage layout of an ARGB8888 color in a 32-bit unsigned integer. <a href="https://commons.wikimedia.org/wiki/File:PixelSamples32bppRGBA.png">Source: Wikipedia</a></span>
</p><p>


Here are a few colors in C:


</p><div>
	<pre><code>uint32_t red = 0xffff0000;
uint32_t green = 0xff00ff00;
uint32_t blue = 0xff0000ff;
uint32_t pink = 0xffff00ff;
uint32_t fifty_percent_transparent_white = 0x80ffffff;</code></pre>
</div>


<p>
	More generally, we can compose a color by bit shifting and or&#39;ing its individual components:
</p>


<div>
	<pre><code>uint8_t alpha = 255; // fully opaque
uint8_t red = 20;    // a little red
uint8_t green = 200; // a lot of green
uint8_t blue = 0;    // no blue
uint32_t color = (alpha &lt;&lt; 24) | (red &lt;&lt; 16) | (green &lt;&lt; 8) | blue;</code></pre>
</div>


<p>
	That looks like a great candidate for a re-usable macro! Why a macro? Because C99 support in Microsoft&#39;s C++ compiler is still meh and who knows how it does with inlined functions defined in a header. The macro guarantees that the code is inlined at the use site. Let&#39;s put the following in <code>src/r96/r96.h</code>
</p>


<div>
	<pre><code>#include &lt;stdint.h&gt;

#define R96_ARGB(alpha, red, green, blue) (uint32_t)(((uint8_t) (alpha) &lt;&lt; 24) | ((uint8_t) (red) &lt;&lt; 16) | ((uint8_t) (green) &lt;&lt; 8) | (uint8_t) (blue))</code></pre>
</div>


<p>
	Defining a color then becomes:
</p>


<div>
	<pre><code>uint32_t color = R96_ARGB(255, 20, 200, 0);</code></pre>
</div>


<h3>Adressing a pixel in a raster</h3>

<p>
	We now can define colors easily. But how do we work with rasters in code and manipulate the colors of its pixels? We already did! Remember this line from our <code>00_basic_window</code> demo app?
</p>


<div>
	<pre><code>const int res_x = 320, res_y = 240;
...
uint32_t *pixels = (uint32_t *)malloc(res_x * res_y * sizeof(uint32_t))</code></pre>
</div>


<p>
	This allocates memory to store a 320x240 raster where each pixel is stored in a <code>uint32_t</code>. Each row of pixels is stored after the other. We can think of it as a one-dimensional array storing a two-dimensional raster.
</p>

<p>
This raster is passed to <code>mfb_update_ex()</code> to be drawn to the window. The reason the window content remains black is that the pixels all have the color <code>0x00000000</code> aka black (at least when building the debug variant or for Emscripten).
</p>

<p>
	We can set the pixel in the top left corner at coordinate <code>(0, 0)</code> to the color red like this:
</p>


<div>
	<pre><code>pixels[0] = R96_ARGB(255, 255, 0, 0);</code></pre>
</div>


<p>
	OK, that was obvious. But how about a pixel at an arbitrary coordinate? Let&#39;s look at a smaller 4x3 pixel raster:
</p>




<p>
Our raster is a one dimensional block of memory. The pixel rows are stored one behind the other. The 4 pixels of the first pixel row with <code>y=0</code> are stored in <code>pixels[0]</code> to <code>pixels[3]</code>. The index of a pixel in the first row is simply its x-coordinate. E.g. the pixel at coordinate <code>(2, 0)</code> is stored in <code>pixels[2]</code>.
</p>

<p>The pixels of the second row with <code>y=1</code> are stored in <code>pixels[4]</code> to <code>pixels[7]</code>. The pixels of the third row with <code>y=2</code> are stored in <code>pixels[8]</code> to <code>pixels[11]</code>. In general, the first pixel of a row at y-coordinate <code>y</code> is located at <code>pixels[y * width]</code>. And to address any pixel inside a row, we just add its x-coordinate! The general formula to go from a pixel&#39;s <code>(x, y)</code> coordinate to an index in the one dimensional array representing the raster is thus <code>x + y * width</code>!
</p>

<p>
	<strong>Note:</strong> this is how C implements two-dimensional arrays under the hood as well. The principle also applies to higher dimensional arrays.
</p>

<p>
	If we want to set the color of the pixel at <code>(160, 120)</code> to red in our 320x240 pixel raster, we can do it like this:
</p>


<div>
	<pre><code>const int res_x = 320, res_y = 240;
...
pixels[160 + 120 * res_x] = R96_ARGB(255, 255, 0, 0);</code></pre>
</div>


<p>Alright, time to draw some pixels!</p>

<h3>Demo app: drawing a pixel</h3>
<p>
	Drawing a single pixel is a bit boring, so how about we flood the screen with a gazillion pixels instead?
</p>


<div>
	<pre><code>#include &lt;MiniFB.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &#34;r96/r96.h&#34;

int main(void) {
	const int res_x = 320, res_y = 240;
	struct mfb_window *window = mfb_open(&#34;01_drawing_a_pixel&#34;, res_x, res_y);
	uint32_t *pixels = (uint32_t *) malloc(sizeof(uint32_t) * res_x * res_y);
	do {
		for (int i = 0; i &lt; 200; i++) {
			int32_t x = rand() % res_x;
			int32_t y = rand() % res_y;
			uint32_t color = R96_ARGB(255, rand() % 255, rand() % 255, rand() % 255);
			pixels[x + y * res_x] = color;
		}

		if (mfb_get_mouse_button_buffer(window)[MOUSE_BTN_1]) {
			memset(pixels, 0, sizeof(uint32_t) * res_x * res_y);
		}

		mfb_update_ex(window, pixels, res_x, res_y);
	} while (mfb_wait_sync(window));
	return 0;
}</code></pre>
</div>


<p>
	The interesting bit happens in lines 11 to 15. Each frame, we generate 200 pixels at random coordinates with random colors. We ensure that the coordinates are within the raster bounds by <code>% res_x</code> and <code>% res_y</code>. We also clamp the color components to the range 0-255 via modulo.
</p>

<p>
	We also introduce some light input handling by checking if the left mouse button is pressed. If so, we set all pixels to the color black, giving the &#34;user&#34; a way to restart the glorious demo.
</p>

<p>
	Finally, we pass the pixels to <code>mfb_update_ex()</code>, which will draw them to the window.
</p>

<p>
	And here it is live in your browser, because why would we spend so much time getting the WASM build to work so nicely. Click/touch to start!
</p>





<p>
	I sure feel all this build up paid off, don&#39;t you?
</p>

<h2>Mario, WTF</h2>
<p>
	Yeah, I&#39;m sorry. I sometimes just drift off. But we learned a lot! Next time I likely won&#39;t be so wordy. We&#39;ll have a looksy at how to draw rectangles. Exciting!
</p>

<p>
	Read the <a href="https://marioslab.io/posts/rendering-like-its-1996/dont-be-square/">the next article in the series</a>.
</p>

<p>
	Discuss this post on <a href="https://twitter.com/badlogicgames/status/1598843445472550912">Twitter</a> or <a href="https://mastodon.social/@badlogicgames/109447021267948993">Mastodon</a>.
</p>



</div>

</div></div>
  </body>
</html>
