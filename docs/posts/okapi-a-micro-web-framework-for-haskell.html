<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.okapi.wiki/">Original</a>
    <h1>Okapi â€“ A micro web framework for Haskell</h1>
    
    <div id="readability-page-1" class="page"><div><p>Learn how to get Okapi set up in your project and start building for the Web. </p><hr/><h2 id="project-setup">Project setup</h2><p>You can bring Okapi into your Haskell project using Stack, Cabal, or Nix. Here are the directions for each method.</p><h3 id="stack">Stack</h3><ol><li><p>Add <code>okapi</code> to your project&#39;s <code>package.yaml</code> file:</p><pre><code><span>dependencies</span><span>:</span><span></span>
<span></span><span>-</span><span> base </span><span>&gt;</span><span>= 4.7 </span><span>&amp;&amp;</span><span> &lt; 5</span>
<span></span><span>-</span><span> aeson</span>
<span></span><span>-</span><span> text</span>
<span></span><span>-</span><span> okapi</span>
</code></pre></li><li><p>(Optional) Add the latest commit hash of the Okapi GitHub repo to your <code>stack.yaml</code> file, under <code>extra-deps</code>:</p><pre><code><span>extra-deps</span><span>:</span><span></span>
<span></span><span>-</span><span> </span><span>git</span><span>:</span><span> https</span><span>:</span><span>//github.com/monadicsystems/okapi.git</span>
<span>  </span><span>commit</span><span>:</span><span> 826225af458d5e9c28d6e6eed5df468489638a3a</span>
</code></pre><div><svg aria-hidden="true" viewBox="0 0 32 32" fill="none"><defs><radialGradient cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" id=":R3k3pn6:-gradient" gradientTransform="rotate(65.924 1.519 20.92) scale(25.7391)"><stop stop-color="#FDE68A" offset=".08"></stop><stop stop-color="#F59E0B" offset=".837"></stop></radialGradient><radialGradient cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" id=":R3k3pn6:-gradient-dark" gradientTransform="matrix(0 24.5 -24.5 0 16 5.5)"><stop stop-color="#FDE68A" offset=".08"></stop><stop stop-color="#F59E0B" offset=".837"></stop></radialGradient></defs><g><circle cx="20" cy="20" r="12" fill="url(#:R3k3pn6:-gradient)"></circle><path d="M3 16c0 7.18 5.82 13 13 13s13-5.82 13-13S23.18 3 16 3 3 8.82 3 16Z" fill-opacity="0.5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="m15.408 16.509-1.04-5.543a1.66 1.66 0 1 1 3.263 0l-1.039 5.543a.602.602 0 0 1-1.184 0Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M16 23a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" fill-opacity="0.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></g><g><path fill-rule="evenodd" clip-rule="evenodd" d="M2 16C2 8.268 8.268 2 16 2s14 6.268 14 14-6.268 14-14 14S2 23.732 2 16Zm11.386-4.85a2.66 2.66 0 1 1 5.228 0l-1.039 5.543a1.602 1.602 0 0 1-3.15 0l-1.04-5.543ZM16 20a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z" fill="url(#:R3k3pn6:-gradient-dark)"></path></g></svg><div><p>Warning</p><p>The commit hash used in the example above will be outdated. Make sure you check for the correct commit hash <a href="">here</a>.</p></div></div></li><li><p>Run the command <code>stack build</code> to make sure your project builds.</p></li><li><p>Add an <code>import Okapi</code> statement to your modules:</p><pre><code><span>module</span><span> </span><span>MyModule</span><span> </span><span>where</span><span></span>
<!-- -->
<span></span><span>import</span><span> Okapi</span><span></span>
<!-- -->
<span></span><span>...</span>
</code></pre></li></ol><h3 id="cabal">Cabal</h3><p>Coming soon</p><h3 id="nix">Nix</h3><p>Coming soon</p><hr/><h2 id="basic-usage">Basic usage</h2><p>A server takes a request and returns the appropriate response. In Okapi, the correct response for any<!-- --> <!-- -->given request is decided by <em>extracting data from</em> or <em>verifying properties of</em> the request using <strong>parsers</strong>.</p><h3 id="types">Types</h3><p>The core type of the Okapi library is <code>OkapiT m a</code>.</p><pre><code><span>newtype</span><span> </span><span>OkapiT</span><span> </span><span>m</span><span> </span><span>a</span><span> </span><span>=</span><span> </span><span>OkapiT</span><span> </span><span>{</span><span>unOkapiT</span><span> </span><span>::</span><span> </span><span>Except</span><span>.</span><span>ExceptT</span><span> </span><span>Failure</span><span> </span><span>(</span><span>State</span><span>.</span><span>StateT</span><span> </span><span>State</span><span> </span><span>m</span><span>)</span><span> </span><span>a</span><span>}</span><span></span>
<span>  </span><span>deriving</span><span> </span><span>newtype</span><span></span>
<span>    </span><span>(</span><span> </span><span>Except</span><span>.</span><span>MonadError</span><span> </span><span>Failure</span><span>,</span><span></span>
<span>      </span><span>State</span><span>.</span><span>MonadState</span><span> </span><span>State</span><span></span>
<span>    </span><span>)</span>
</code></pre><p>Okapi also exports the type constraint <code>MonadOkapi m</code>, which is the abstract interface of <code>OkapiT m</code>.</p><pre><code><span>type</span><span> </span><span>MonadOkapi</span><span> </span><span>m</span><span> </span><span>=</span><span></span>
<span>  </span><span>(</span><span> </span><span>Functor</span><span> </span><span>m</span><span>,</span><span></span>
<span>    </span><span>Applicative</span><span> </span><span>m</span><span>,</span><span></span>
<span>    </span><span>Applicative</span><span>.</span><span>Alternative</span><span> </span><span>m</span><span>,</span><span></span>
<span>    </span><span>Monad</span><span> </span><span>m</span><span>,</span><span></span>
<span>    </span><span>Monad</span><span>.</span><span>MonadPlus</span><span> </span><span>m</span><span>,</span><span></span>
<span>    </span><span>Except</span><span>.</span><span>MonadError</span><span> </span><span>Failure</span><span> </span><span>m</span><span>,</span><span></span>
<span>    </span><span>State</span><span>.</span><span>MonadState</span><span> </span><span>State</span><span> </span><span>m</span><span></span>
<span>  </span><span>)</span>
</code></pre><p>We recommend using the type constraint instead of the concrete type to annotate your parsers.</p><pre><code><span>myParser</span><span> </span><span>::</span><span> </span><span>OkapiT</span><span> </span><span>(</span><span>ReaderT</span><span> </span><span>AppConfig</span><span> </span><span>IO</span><span>)</span><span> </span><span>(</span><span>Int</span><span>,</span><span> </span><span>Char</span><span>)</span><span></span>
<span></span><span>myParser</span><span> </span><span>=</span><span> </span><span>...</span><span> </span><span></span>
<!-- -->
<span></span><span>myParser&#39;</span><span> </span><span>::</span><span> </span><span>(</span><span>MonadOkapi</span><span> </span><span>m</span><span>,</span><span> </span><span>MonadIO</span><span> </span><span>m</span><span>,</span><span> </span><span>MonadReader</span><span> </span><span>AppConfig</span><span> </span><span>m</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>m</span><span> </span><span>(</span><span>Int</span><span>,</span><span> </span><span>Char</span><span>)</span><span></span>
<span></span><span>myParser&#39;</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>...</span><span> </span>
</code></pre><p>Your top level parser definition will probably need a concrete type annotation for your program to compile. To start, we recommend just using <code>IO</code>.</p><pre><code><span>module</span><span> </span><span>Main</span><span> </span><span>where</span><span></span>
<!-- -->
<span></span><span>import</span><span> Okapi</span><span></span>
<!-- -->
<span></span><span>type</span><span> </span><span>Server</span><span> </span><span>=</span><span> </span><span>OkapiT</span><span> </span><span>IO</span><span> </span><span></span>
<!-- -->
<span></span><span>main</span><span> </span><span>::</span><span> </span><span>IO</span><span> </span><span>(</span><span>)</span><span></span>
<span></span><span>main</span><span> </span><span>=</span><span></span>
<span>  </span><span>run</span><span></span>
<span>    </span><span>id</span><span></span>
<span>    </span><span></span>
<span>    </span><span></span>
<span>    </span><span>myServer</span><span></span>
<!-- -->
<span></span><span>myServer</span><span> </span><span>::</span><span> </span><span>Server</span><span> </span><span>Response</span><span></span>
<span></span><span>myServer</span><span> </span><span>=</span><span> </span><span>myParser1</span><span> </span><span>&lt;|&gt;</span><span> </span><span>myParser2</span><span></span>
<!-- -->
<span></span><span>myParser1</span><span> </span><span>::</span><span> </span><span>(</span><span>MonadOkapi</span><span> </span><span>m</span><span>,</span><span> </span><span>MonadIO</span><span> </span><span>m</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>m</span><span> </span><span>Response</span><span></span>
<span></span><span>myParser1</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>logIO</span><span> </span><span>&#34;Using handler 1&#34;</span><span></span>
<span>  </span><span>...</span><span></span>
<!-- -->
<span></span><span>myParser2</span><span> </span><span>::</span><span> </span><span>MonadOkapi</span><span> </span><span>m</span><span> </span><span>=&gt;</span><span> </span><span>m</span><span> </span><span>Response</span><span></span>
<span></span><span>myParser2</span><span> </span><span>=</span><span> </span><span>...</span><span></span>
<!-- -->
<span></span><span>logIO</span><span> </span><span>::</span><span> </span><span>MonadIO</span><span> </span><span>m</span><span> </span><span>=&gt;</span><span> </span><span>String</span><span> </span><span>-&gt;</span><span> </span><span>m</span><span> </span><span>(</span><span>)</span><span></span>
<span></span><span>logIO</span><span> </span><span>msg</span><span> </span><span>=</span><span> </span><span>...</span>
</code></pre><p>See <a href="">Custom monad stack</a> for more information on how to integrate your custom monad stack with<!-- --> <!-- -->this library.</p><h3 id="parsers">Parsers</h3><p>Okapi provides <strong>parsers</strong> to extract data from or verify properties of HTTP requests. They all have a<!-- --> <!-- -->return type of <code>MonadOkapi m =&gt; m a</code>, where <code>a</code> is some value.</p><p>Parsers can either <strong>succeed</strong> or <strong>fail</strong>.</p><p>For example, the <code>methodGET</code> parser succeeds if the HTTP request has the GET method, otherwise it fails.</p><p>Parsers in Okapi are analagous to what most other web frameworks would call <em>routes</em>, but parsers are more granular and modular.</p><p>There is a category of parsers for each component of an HTTP request:</p><ol><li><p>Method parsers</p><p>These parsers are for parsing the request method and are prefixed with <code>method-</code>.</p><p>Examples: <code>method</code>, <code>methodGET</code>, <code>methodPOST</code>, <code>methodPATCH</code>, <code>methodOPTIONS</code></p></li><li><p>Path parsers</p><p>These parsers are for parsing the request path (excluding the query string) and are prefixed with <code>path-</code>.</p><p>Examples: <code>path</code>, <code>pathParam</code></p></li><li><p>Query parsers</p><p>These parsers are for parsing the request query and are prefixed with <code>query-</code>.</p><p>Examples: <code>query</code>, <code>queryParam</code>, <code>queryFlag</code></p></li><li><p>Body parsers</p><p>These parsers are for parsing the request body and are prefixed with <code>body-</code>.</p><p>Examples: <code>body</code>, <code>bodyJSON</code>, <code>bodyURLEncoded</code></p></li><li><p>Header parsers</p><p>These parsers are for parsing the request headers and are prefixed with <code>header-</code> or <code>cookie-</code>.</p><p>Examples: <code>headers</code>, <code>header</code>, <code>cookie</code>, <code>cookieCrumb</code></p></li></ol><p>To learn more about each parser, I recommend reading the <a href="">haddock documentation</a> for each parser and looking at the examples.</p><h3 id="combining-parsers">Combining Parsers</h3><p>There are two ways to combine parsers and create more complex ones:</p><ol><li><p>Sequencing</p><p>You can execute one parser after another parser using <code>do</code> notation:</p><pre><code><span>getUser</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>methodGET</span><span>                 </span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;users&#34;</span><span>    </span><span></span>
<span>  </span><span>uid</span><span> </span><span>&lt;-</span><span> </span><span>pathParam</span><span> </span><span>@</span><span>UserID</span><span>  </span><span></span>
<span>  </span><span>return</span><span> </span><span>$</span><span> </span><span>setJSON</span><span> </span><span>uid</span><span> </span><span>$</span><span> </span><span>ok</span><span> </span>
</code></pre><p>You can also use <code>&gt;&gt;</code> and <code>&gt;&gt;=</code>:</p><pre><code><span>getUser</span><span> </span><span>=</span><span> </span><span>methodGET</span><span> </span><span>&gt;&gt;</span><span> </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;user&#34;</span><span> </span><span>&gt;&gt;</span><span> </span><span>pathParam</span><span> </span><span>@</span><span>UserID</span><span> </span><span>&gt;&gt;=</span><span> </span><span>\</span><span>uid</span><span> </span><span>-&gt;</span><span> </span><span>return</span><span> </span><span>$</span><span> </span><span>setJSON</span><span> </span><span>uid</span><span> </span><span>$</span><span> </span><span>ok</span>
</code></pre><p>A parser composed of a sequence of other parsers ONLY succeeds if all of the parsers in the sequence succeed. If any one of the parsers in the sequence fails, the entire parser fails.</p><p>For example, the <code>getUser</code> parser defined above would fail if the HTTP request was <code>POST /users/5</code>, because the <code>methodGET</code> parser would fail. If the HTTP request was <code>GET /guests/9</code>, <code>getUser</code> would fail because the <code>pathParam `is` &#34;users&#34;</code> parser would fail.</p><p>In summary, given parsers <code>p1</code> and <code>p2</code>, the parser <code>p3</code> defined as:</p><pre><code><span>p3</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>p1</span><span></span>
<span>  </span><span>p2</span>
</code></pre><p>succeeds if <code>p1</code> AND <code>p2</code> succeed. <code>p1</code> and <code>p2</code> MAY be different types.</p></li><li><p>Branching</p><p>You can create a parser that tries multiple parsers using the <code>&lt;|&gt;</code> operator from <code>Control.Applicative.Alternative</code>:</p><pre><code><span>pingpong</span><span> </span><span>=</span><span> </span><span>ping</span><span> </span><span>&lt;|&gt;</span><span> </span><span>pong</span><span></span>
<!-- -->
<span></span><span>ping</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>methodGET</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;ping&#34;</span><span></span>
<span>  </span><span>return</span><span> </span><span>$</span><span> </span><span>setJSON</span><span> </span><span>&#34;pong&#34;</span><span> </span><span>$</span><span> </span><span>ok</span><span></span>
<!-- -->
<span></span><span>pong</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>methodGET</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;pong&#34;</span><span></span>
<span>  </span><span>return</span><span> </span><span>$</span><span> </span><span>setJSON</span><span> </span><span>&#34;ping&#34;</span><span> </span><span>$</span><span> </span><span>ok</span>
</code></pre><p>A parser composed of a set of parsers using the <code>&lt;|&gt;</code> operator succeeds if ANY of the parsers succeed.</p><p>If all of the parsers in the composition fail, the entire parser fails.</p><p>Using the <code>pingpong</code> parser as an example, if the incoming HTTP request was <code>GET /ping</code>, <code>pingpong</code> would succeed because the <code>ping</code> parser in <code>ping &lt;|&gt; pong</code> succeeds. If the incoming request was <code>GET /pong</code>, <code>pingpong</code> would still succeed. Eventhough <code>ping</code> in <code>ping &lt;|&gt; pong</code> would fail, <code>pong</code> would succeed, so <code>pingpong = ping &lt;|&gt; pong</code> succeeds.</p><p>In summary, given parsers <code>p1</code> and <code>p2</code>, the parser <code>p3</code> defined as:</p><pre><code><span>p3</span><span> </span><span>=</span><span> </span><span>p1</span><span> </span><span>&lt;|&gt;</span><span> </span><span>p2</span>
</code></pre><p>succeeds if <code>p1</code> OR <code>p2</code> succeed. <code>p1</code> and <code>p2</code> MUST be the same type.</p></li></ol><h3 id="failure">Failure</h3><p>There are two functions that you can use to throw an error and terminate the parser: <code>next</code> and <code>throw</code>.<!-- --> <!-- -->The difference between the two mainly has to do with how they affect the behavior of the <code>&lt;|&gt;</code> operator.</p><p>In short, given parsers <code>p1</code> and <code>p2</code>, and a parser <code>p3</code> defined as <code>p3 = p1 &lt;|&gt; p2</code>:</p><ol><li>If <code>p1</code> fails with <code>next</code>, <code>p2</code> is tried next.</li><li>If <code>p1</code> fails with <code>throw</code>, <code>p2</code> isn&#39;t tried. Instead a response is returned immediately.</li></ol><p>As an example, let&#39;s say we have a simple calculator API defined like so:</p><pre><code><span>getXY</span><span> </span><span>::</span><span> </span><span>Okapi</span><span> </span><span>(</span><span>Int</span><span>,</span><span> </span><span>Int</span><span>)</span><span>    </span><span></span>
<span></span><span>getXY</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>x</span><span> </span><span>&lt;-</span><span> </span><span>pathParam</span><span></span>
<span>  </span><span>y</span><span> </span><span>&lt;-</span><span> </span><span>pathParam</span><span></span>
<span>  </span><span>pure</span><span> </span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span></span>
<!-- -->
<span></span><span>divide</span><span> </span><span>::</span><span> </span><span>Okapi</span><span> </span><span>Response</span><span>     </span><span></span>
<span></span><span>divide</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;div&#34;</span><span></span>
<span>  </span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>&lt;-</span><span> </span><span>getXY</span><span></span>
<span>  </span><span>if</span><span> </span><span>y</span><span> </span><span>==</span><span> </span><span>0</span><span></span>
<span>    </span><span>then</span><span> </span><span>next</span><span></span>
<span>    </span><span>else</span><span> </span><span>return</span><span> </span><span>$</span><span> </span><span>setJSON</span><span> </span><span>(</span><span>x</span><span> </span><span>/</span><span> </span><span>y</span><span>)</span><span> </span><span>$</span><span> </span><span>ok</span><span></span>
<!-- -->
<span></span><span>multiply</span><span> </span><span>::</span><span> </span><span>Okapi</span><span> </span><span>Response</span><span>   </span><span></span>
<span></span><span>multiply</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;mul&#34;</span><span></span>
<span>  </span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>&lt;-</span><span> </span><span>getXY</span><span></span>
<span>  </span><span>return</span><span> </span><span>$</span><span> </span><span>setJSON</span><span> </span><span>(</span><span>x</span><span> </span><span>*</span><span> </span><span>y</span><span>)</span><span> </span><span>$</span><span> </span><span>ok</span><span></span>
<!-- -->
<span></span><span>calculator</span><span> </span><span>::</span><span> </span><span>Okapi</span><span> </span><span>Response</span><span> </span><span></span>
<span></span><span>calculator</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>methodGET</span><span></span>
<span>  </span><span>divide</span><span> </span><span>&lt;|&gt;</span><span> </span><span>multiply</span>
</code></pre><p>If the path parameter assigned to <code>y</code> is equal to <code>0</code>, then the <code>divide</code> parser will fail and the <code>multiply</code> parser is tried next because <code>next</code> is used.</p><p>If the <code>divide</code> parser was defined like this,</p><pre><code><span>divide</span><span> </span><span>::</span><span> </span><span>Okapi</span><span> </span><span>Response</span><span></span>
<span></span><span>divide</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;div&#34;</span><span></span>
<span>  </span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>&lt;-</span><span> </span><span>getXY</span><span></span>
<span>  </span><span>if</span><span> </span><span>y</span><span> </span><span>==</span><span> </span><span>0</span><span></span>
<span>    </span><span>then</span><span> </span><span>throw</span><span> </span><span>$</span><span> </span><span>setJSON</span><span> </span><span>&#34;Dividing by 0 is forbidden&#34;</span><span> </span><span>$</span><span> </span><span>forbidden</span><span></span>
<span>    </span><span>else</span><span> </span><span>return</span><span> </span><span>$</span><span> </span><span>setJSON</span><span> </span><span>(</span><span>x</span><span> </span><span>/</span><span> </span><span>y</span><span>)</span><span> </span><span>$</span><span> </span><span>ok</span><span></span>
<!-- -->
<span></span><span>calculator</span><span> </span><span>::</span><span> </span><span>Okapi</span><span> </span><span>Response</span><span></span>
<span></span><span>calculator</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>methodGET</span><span></span>
<span>  </span><span>divide</span><span> </span><span>&lt;|&gt;</span><span> </span><span>multiply</span>
</code></pre><p>the <code>calculator</code> parser would immediately return a <code>forbidden</code> error response if the path parameter assigned to <code>y</code> was equal 0. The <code>multiply</code> parser isn&#39;t tried.</p><p>Notice how <code>throw</code> takes a <code>Response</code> value as an argument. This is the response that is immediately returned by the parser when <code>throw</code> is called. No other parsers are tried.</p><p>If you want to try the next parser, even if <code>throw</code> is used in the first branch, you can use the <code>&lt;!&gt;</code> operator.</p><pre><code><span>divide</span><span> </span><span>::</span><span> </span><span>Okapi</span><span> </span><span>Response</span><span></span>
<span></span><span>divide</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;div&#34;</span><span></span>
<span>  </span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>)</span><span> </span><span>&lt;-</span><span> </span><span>getXY</span><span></span>
<span>  </span><span>if</span><span> </span><span>y</span><span> </span><span>==</span><span> </span><span>0</span><span></span>
<span>    </span><span>then</span><span> </span><span>throw</span><span> </span><span>$</span><span> </span><span>setJSON</span><span> </span><span>&#34;Dividing by 0 is forbidden&#34;</span><span> </span><span>$</span><span> </span><span>forbidden</span><span></span>
<span>    </span><span>else</span><span> </span><span>return</span><span> </span><span>$</span><span> </span><span>setJSON</span><span> </span><span>(</span><span>x</span><span> </span><span>/</span><span> </span><span>y</span><span>)</span><span> </span><span>$</span><span> </span><span>ok</span><span></span>
<!-- -->
<span></span><span>calculator</span><span> </span><span>::</span><span> </span><span>Okapi</span><span> </span><span>Response</span><span></span>
<span></span><span>calculator</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>methodGET</span><span></span>
<span>  </span><span>divide</span><span> </span><span>&lt;!&gt;</span><span> </span><span>multiply</span>
</code></pre><p>If we feed the request <code>GET /div/5/0</code> to this definition of <code>calculator</code>, both <code>div</code> and <code>multiply</code> would be tried. <code>calculator</code> is defined using <code>&lt;!&gt;</code> instead of <code>&lt;|&gt;</code>, so even though <code>divide</code> calls <code>throw</code> when <code>y == 0</code>, the next parser <code>multiply</code> is tried anyway!</p><p>See <a href="">Error handling</a> for more information on errors and how to handle them.</p><h3 id="combinators">Combinators</h3><p>Combinators are functions that modify parsers. They are higher order parsers, meaning they take a parser as an argument and give you back a parser. Most of these combinators can be found in the <code>parser-combinators</code> library. To use it, just add <code>parser-combinators</code> to your dependencies and import<!-- --> <code>Control.Monad.Combinators</code> into your modules. There are several, but the most used ones are <code>is</code>, <code>optional</code>, and <code>option</code> so let&#39;s cover those.</p><p><code>is</code> is for comparing some data in the request to a value. It&#39;s mostly used for matching on the request path</p><pre><code><span></span>
<span></span><span>bookstore</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>methodGET</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;books&#34;</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;fiction&#34;</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;sci-fi&#34;</span><span></span>
<span>  </span><span>sciFiBooks</span><span> </span><span>&lt;-</span><span> </span><span>execDBQuery</span><span> </span><span>...</span><span></span>
<span>  </span><span>return</span><span> </span><span>$</span><span> </span><span>setJSON</span><span> </span><span>sciFiBooks</span><span> </span><span>$</span><span> </span><span>ok</span>
</code></pre><p>, but can be used with any parser.</p><pre><code><span></span>
<span></span><span>bookstore</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>methodGET</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;books&#34;</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>`is`</span><span> </span><span>&#34;fiction&#34;</span><span></span>
<span>  </span><span>queryParam</span><span> </span><span>&#34;subgenre&#34;</span><span> </span><span>`is`</span><span> </span><span>&#34;sci-fi&#34;</span><span></span>
<span>  </span><span>sciFiBooks</span><span> </span><span>&lt;-</span><span> </span><span>execDBQuery</span><span> </span><span>...</span><span></span>
<span>  </span><span>return</span><span> </span><span>$</span><span> </span><span>setJSON</span><span> </span><span>sciFiBooks</span><span> </span><span>$</span><span> </span><span>ok</span>
</code></pre><p>Another important combinator is <code>optional</code>. <code>optional</code> allows you to handle a parser that fails, in your own way by turning the result of type <code>a</code> in to a result of type <code>Maybe a</code>. If the parser fails, it returns a <code>Nothing</code>. If it succeeds, it returns <code>Just x</code> where <code>x :: a</code>. Let&#39;s look at the example used<!-- --> <!-- -->in the hero of this page, the <code>greet</code> server:</p><pre><code><span></span>
<span></span><span>greet</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>methodGET</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>@</span><span>Text</span><span> </span><span>`is`</span><span> </span><span>&#34;greet&#34;</span><span></span>
<span>  </span><span>maybeName</span><span> </span><span>&lt;-</span><span> </span><span>optional</span><span> </span><span>(</span><span>pathParam</span><span> </span><span>&lt;|&gt;</span><span> </span><span>queryParam</span><span> </span><span>&#34;name&#34;</span><span>)</span><span></span>
<span>  </span><span>pathEnd</span><span></span>
<span>  </span><span>let</span><span> </span><span>greeting</span><span> </span><span>=</span><span> </span><span>case</span><span> </span><span>maybeName</span><span> </span><span>of</span><span></span>
<span>        </span><span>Nothing</span><span>   </span><span>-&gt;</span><span> </span><span>&#34;Hello there.&#34;</span><span></span>
<span>        </span><span>Just</span><span> </span><span>name</span><span> </span><span>-&gt;</span><span> </span><span>&#34;Hello, &#34;</span><span> </span><span>&lt;&gt;</span><span> </span><span>name</span><span> </span><span>&lt;&gt;</span><span> </span><span>&#34;.&#34;</span><span></span>
<span>   </span><span>return</span><span> </span><span>$</span><span> </span><span>setPlainText</span><span> </span><span>greeting</span><span> </span><span>$</span><span> </span><span>ok</span>
</code></pre><p>Thanks to <code>optional</code>, if <code>pathParam &lt;|&gt; queryParam &#34;name&#34;</code> fails, we can provide a default value. In this case, we assign <code>greeting</code> to <code>&#34;Hello there.&#34;</code> because we have no <code>name</code>.</p><p>Another way to catch failures and use a default value is by using <code>option</code>. Using <code>option</code>, we can modify the <code>greet</code> server defined above like this:</p><pre><code><span></span>
<span></span><span>greet</span><span> </span><span>=</span><span> </span><span>do</span><span></span>
<span>  </span><span>methodGET</span><span></span>
<span>  </span><span>pathParam</span><span> </span><span>@</span><span>Text</span><span> </span><span>`is`</span><span> </span><span>&#34;greet&#34;</span><span></span>
<span>  </span><span>name</span><span> </span><span>&lt;-</span><span> </span><span>option</span><span> </span><span>&#34;Stranger&#34;</span><span> </span><span>(</span><span>pathParam</span><span> </span><span>&lt;|&gt;</span><span> </span><span>queryParam</span><span> </span><span>&#34;name&#34;</span><span>)</span><span></span>
<span>  </span><span>pathEnd</span><span></span>
<span>  </span><span>let</span><span> </span><span>greeting</span><span> </span><span>=</span><span> </span><span>&#34;Hello, &#34;</span><span> </span><span>&lt;&gt;</span><span> </span><span>name</span><span> </span><span>&lt;&gt;</span><span> </span><span>&#34;.&#34;</span><span></span>
<span>   </span><span>return</span><span> </span><span>$</span><span> </span><span>setPlainText</span><span> </span><span>greeting</span><span> </span><span>$</span><span> </span><span>ok</span>
</code></pre><p><code>option</code> takes a default value as its first argument, and a parser. If the parser passed into <code>option</code> succeeds, a value is returned as usual. If the parser fails then no value can be returned by the parser, so the default value passed into <code>option</code> is used instead. For example, if we sent the request <code>GET /greet</code> <!-- -->to the <code>greet</code> server defined using <code>option</code>, we&#39;d get <code>&#34;Hello, Stranger.&#34;</code> because we don&#39;t give it a <code>name</code> parameter and it uses the default <code>&#34;Stranger&#34;</code>.</p><p>See <a href="">Parser combinators</a> for more information on combinators and how to use them.</p><hr/><h2 id="getting-help">Getting help</h2><p>Click on the GitHub icon in the upper right corner to go to the repository and submit an issue.<!-- --> <!-- -->You should be able to get someone to help you out this way.<!-- --> <!-- -->A Discord channel, or probably some other communication channel, is coming soon.</p></div></div>
  </body>
</html>
