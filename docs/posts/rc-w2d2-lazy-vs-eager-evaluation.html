<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://payments.posthaven.com/rc-w2d2-lazy-vs-eager-evaluation">Original</a>
    <h1>RC W2D2 - Lazy vs eager evaluation</h1>
    
    <div id="readability-page-1" class="page"><div id="post_body_1944068">
    
      <div><p>In a previous <a href="https://payments.posthaven.com/rc-w1d5-haskell">post</a>, I shared how my plan at RC was inspired by the courses I did with David Beazley. I wasn’t sure then if I was paraphrasing him accurately, but yesterday he wrote in his newsletter:</p><blockquote><p>Meanwhile, I&#39;ve managed to dig myself into a pretty deep rabbit hole as a result of the month-long courses I offered back in January. The extra time allowed me to make an attempt at writing the compiler project in Haskell, which to be honest, kind of blew my mind and exposed a totally different way of doing things in Python. I&#39;ll have more to say about that once I finish putting the pieces of my brain back together.</p></blockquote><p>Learning a new language usually starts off a little painful but you feel a bit better once you start to string words together - this applies to both natural and programming languages. Haskell is not only in the functional paradigm but also has an expressive type system. It takes a bit getting used to, so far so good.</p><p>Chapter 4 of SICP involves writing a Scheme interpreter in Scheme, the so-called <a href="https://sarabander.github.io/sicp/html/4_002e1.xhtml#g_t4_002e1">metacircular evaluator</a>. This exercise also introduces the notion that you can make the language do what you want, for example make Scheme use lazy evaluation instead of eager (SICP uses the terms ‘applicative’ vs ’normal’ order, discussion <a href="https://ezzeriesa.notion.site/1-week-with-David-Beazley-and-SICP-4c440389cf1e43f48fe67c969967f655#6581d3a517324e3abcf1004af115976b" title="Link: https://ezzeriesa.notion.site/1-week-with-David-Beazley-and-SICP-4c440389cf1e43f48fe67c969967f655#6581d3a517324e3abcf1004af115976b">here</a>). I was intrigued. What else do you need to couple with lazy evaluation to make the language ‘work’?</p><blockquote><p>Lazy evaluation makes it hard to reason about when things will be evaluated; hence including side effects in a lazy language would be extremely unintuitive. Historically, this is the reason Haskell is pure: initially, the designers of Haskell wanted to make a lazy functional language, and quickly realized it would be impossible unless it also disallowed side effects.</p></blockquote><p>I assumed Haskell was intended to be pure from the start. TIL it’s a corollary of wanting the language be lazy.</p><p>An exercise in SICP involves representing map and filter operations as special cases of reduce. In fact SICP uses the term ‘accumulate’ for reduce, while Haskell uses ‘fold’ - we’ll use the latter term from here onwards. What I discovered in Haskell that I didn’t cover in SICP is the practical implications of left fold (`foldl`) vs right fold (`foldr`).</p><p>First, a more illustrative explanation. Fold lets you apply an operation successively over a list, here we sum up values in a list using left fold.</p><p><code>foldl (+) 0 [1, 2, 3]</code></p><p><code>= foldl (+) (0 + 1) [2,3]</code></p><p><code>= foldl (+) ((0 + 1) + 2) [3]</code></p><p><code>= foldl (+) (((0 + 1) + 2) + 3) []</code></p><p><code>= (((0 + 1) + 2) + 3)</code></p><p><code>= ((1 + 2) + 3)</code></p><p><code>= (3 + 3)</code></p><p><code>= 6</code></p><p>This is in contrast with right folds.<br/>
</p><p><code>foldr (+) 0 [1, 2, 3]</code></p><p><code>= foldr (+) (3+0) [1, 2]</code></p><p><code>= foldr (+) (2 + (3+0)) [1]</code></p><p><code>= foldr (+) (1 + (2 + (3+0))) []</code></p><p><code>= (1 + (2 + (3+0)))</code></p><p><code>= (1 + (2 + 3))</code></p><p><code>= (1 + 5)</code></p><p><code>= 6</code></p><p>In an eager language, left folds are memory-efficient because we can use constant space to do each successive evaluation i.e. `0+1`, `1+2`, `3+3` etc; this is usually referred to as the tail call optimization. In right folds, we need to build up each successive operation in a stack frame.</p><p>In a lazy language, however, expressions are only evaluated as needed. This means that for left folds, we end up with unevaluated expressions (called ’thunks’) as large as the size of the list. This is in contrast with right folds, where the expansion can happen once and then evaluation be ’suspended’.</p><p>A key difference is right folds can work on infinite lists, whereas as left ones don’t. Mind blown.</p><p>The best explanation I found is a <a href="https://github.com/hasura/graphql-engine/pull/2933#discussion_r328821960">comment</a> in a Github PR. This Stack Overflow <a href="https://stackoverflow.com/questions/3429634/foldl-is-tail-recursive-so-how-come-foldr-runs-faster-than-foldl">post</a> has a performance comparison between the two (spoiler: right fold is faster). This Haskell <a href="https://wiki.haskell.org/Foldr_Foldl_Foldl%27">wiki</a> expands a bit more on the eager version of folds.</p><p>Next question - what explains the coupling between the functional paradigm and an expressive type system?</p></div>
    
  </div></div>
  </body>
</html>
