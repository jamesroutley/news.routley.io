<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kreya.app/blog/grpc-deep-dive/">Original</a>
    <h1>gRPC: From service definition to wire format</h1>
    
    <div id="readability-page-1" class="page"><div id="__blog-post-container"><p>In our previous posts (<a href="https://kreya.app/blog/protocolbuffers-wire-format/">part 1</a> and <a href="https://kreya.app/blog/protocolbuffers-wire-format-part-2/">part 2</a>), we demystified Protocol Buffers and learned how data is encoded into compact binary.</p>
<p>But Protobuf is just the payload. To send this data between microservices, we need a transport protocol. Enter <strong>gRPC</strong>.</p>
<p>While many developers use gRPC daily, few look under the hood to see how it actually works. In this post, we’ll go beyond the basics and explore the full gRPC protocol stack: from the high-level service architecture and streaming models down to the low-level HTTP/2 framing and byte-level wire format.</p>
<h2 id="the-contract-first-philosophy">The contract-first philosophy<a href="#the-contract-first-philosophy" aria-label="Direct link to The contract-first philosophy" title="Direct link to The contract-first philosophy">​</a></h2>
<p>At the heart of gRPC lies the contract-first approach. Unlike REST, where API documentation (like OpenAPI) is often an afterthought, gRPC enforces the structure upfront using Protocol Buffers (<code>.proto</code> files).</p>
<p>This contract defines not just the data structures (Messages), but the service capabilities (RPCs):</p>
<div><div><pre tabindex="0"><code><span><span>package</span><span> fruit</span><span>.</span><span>v1</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>service</span><span> </span><span>FruitService</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>    </span><span>rpc</span><span> </span><span>GetFruit</span><span>(</span><span>GetFruitRequest</span><span>)</span><span> </span><span>returns</span><span> </span><span>(</span><span>Fruit</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>    </span><span>rpc</span><span> </span><span>ListFruits</span><span>(</span><span>ListFruitsRequest</span><span>)</span><span> </span><span>returns</span><span> </span><span>(</span><span>stream</span><span> </span><span>Fruit</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>    </span><span>rpc</span><span> </span><span>Upload</span><span>(</span><span>stream</span><span> </span><span>Fruit</span><span>)</span><span> </span><span>returns</span><span> </span><span>(</span><span>UploadSummary</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>    </span><span>rpc</span><span> </span><span>Chat</span><span>(</span><span>stream</span><span> </span><span>ChatMessage</span><span>)</span><span> </span><span>returns</span><span> </span><span>(</span><span>stream</span><span> </span><span>ChatMessage</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div>
<p>This definition is the source of truth.
From this single file, the protobuf compiler (<code>protoc</code>) generates client stubs and server boilerplate in almost any language (Go, Java, C#, Python, etc.),
ensuring that the client and server always agree on the API shape.</p>
<h2 id="streaming-models">Streaming models<a href="#streaming-models" aria-label="Direct link to Streaming models" title="Direct link to Streaming models">​</a></h2>
<p>One of the biggest differentiators of gRPC is its native support for streaming.
This isn&#39;t just &#34;chunked transfer encoding&#34;, it&#39;s first-class API semantics.</p>
<ul>
<li><strong>Unary</strong>: Looks like a standard function call or REST request. The client sends one message, the server sends one back.</li>
<li><strong>Server streaming</strong>: Perfect for subscriptions or large datasets. The client sends a query, and the server returns multiple results over time.</li>
<li><strong>Client streaming</strong>: Useful for sending a stream of data (like telemetry from an IoT device) where the server processes messages as they arrive.</li>
<li><strong>Bidirectional streaming</strong>: True real-time communication. Both sides can send messages independently. This is often used for chat apps or multiplayer games.</li>
</ul>

<p>In addition to the actual data, gRPC allows sending metadata.
Metadata is a list of key-value pairs (like HTTP headers) that provide information about the call.
Keys are strings, and values are typically strings, but can also be binary data.
The key names are case-insensitive and must not start with <code>grpc-</code> (reserved for gRPC internals).
The keys of binary values must end with <code>-bin</code>.</p>
<p>Metadata is essential for cross-cutting concerns that shouldn&#39;t be part of the business logic payload:</p>
<ul>
<li><strong>Authentication</strong>: Usage of Bearer tokens (e.g., <code>Authorization: Bearer &lt;token&gt;</code>).</li>
<li><strong>Tracing</strong>: Passing trace IDs (e.g., <code>transport-id: 12345</code>) to track requests across microservices.</li>
<li><strong>Infrastructure</strong>: Hints for load balancers or proxies.</li>
</ul>
<p>Metadata can be sent by both the client (at the start of the call) and the server (at the start as headers, or at the end as trailers).</p>
<h2 id="under-the-hood-the-transport-layer">Under the hood: the transport layer<a href="#under-the-hood-the-transport-layer" aria-label="Direct link to Under the hood: the transport layer" title="Direct link to Under the hood: the transport layer">​</a></h2>
<p>So how does this contract map to the network? gRPC is built on top of HTTP/2,
leveraging its advanced features to make these streaming models possible.</p>
<p>The most important concept is streams.
Every gRPC call, whether it&#39;s a simple unary request or a long-lived bidirectional stream,
is mapped to a single HTTP/2 stream.
This allows multiplexing: you can have thousands of active gRPC calls on a single TCP connection,
with their frames interleaved.
This prevents opening thousands of connections that would be needed with HTTP/1.1.
While it solves the HTTP/1.1 &#34;head-of-line blocking&#34; issue,
TCP-level blocking remains a concern if packets are lost.</p>
<h3 id="constructing-the-url">Constructing the URL<a href="#constructing-the-url" aria-label="Direct link to Constructing the URL" title="Direct link to Constructing the URL">​</a></h3>
<p>Before we send any bytes, we need to address the resource. In gRPC, the URL is generated automatically from the <code>.proto</code> definition: <code>/{Package}.{Service}/{Method}</code>.</p>
<p>For <code>GetFruit</code>, the path becomes:
<code>/fruit.v1.FruitService/GetFruit</code></p>
<p>This standardization means clients and servers never argue about URL paths.</p>
<h3 id="the-http2-frames">The HTTP/2 frames<a href="#the-http2-frames" aria-label="Direct link to The HTTP/2 frames" title="Direct link to The HTTP/2 frames">​</a></h3>
<p>A gRPC call typically consists of three stages, each mapping to HTTP/2 frames:</p>
<ol>
<li><strong>Request headers and metadata</strong> (<code>HEADERS</code> frame): contains metadata like <code>:path</code>, <code>:method</code> (<code>POST</code>), and <code>content-type</code> (<code>application/grpc</code>).</li>
<li><strong>Data messages</strong> (<code>DATA</code> frames): the actual application data.</li>
<li><strong>Response trailers</strong> (<code>HEADERS</code> frame): the final status of the call.</li>
</ol>
<h3 id="metadata-on-the-wire">Metadata on the wire<a href="#metadata-on-the-wire" aria-label="Direct link to Metadata on the wire" title="Direct link to Metadata on the wire">​</a></h3>
<p>Since gRPC is built on HTTP/2, metadata is simply mapped to HTTP/2 headers.
String values are sent as-is (e.g. <code>user-agent: grpc-kreya/1.18.0</code>).</p>
<p>Binary values are base64-encoded and the key must end with <code>-bin</code>.
Libraries usually handle this encoding/decoding transparently.</p>
<h3 id="the-length-prefixed-message">The length-prefixed message<a href="#the-length-prefixed-message" aria-label="Direct link to The length-prefixed message" title="Direct link to The length-prefixed message">​</a></h3>
<p>Inside the HTTP/2 <code>DATA</code> frame, gRPC wraps your protobuf message with a mechanism called length-prefixed framing.
Even in a streaming call, every single message is independent and prefixed with a 5-byte header:</p>
<table><thead><tr><th>Byte</th><th>Purpose</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>Compression Flag</td><td>0 = Uncompressed</td></tr><tr><td>1-4</td><td>Message Length</td><td>4-byte big-endian integer indicating the size of the payload</td></tr></tbody></table>
<h4 id="visualizing-the-bytes">Visualizing the bytes<a href="#visualizing-the-bytes" aria-label="Direct link to Visualizing the bytes" title="Direct link to Visualizing the bytes">​</a></h4>
<p>Let&#39;s reuse the fruit message from our <a href="https://kreya.app/blog/protocolbuffers-wire-format/">previous post</a></p>

<p>which encodes to 10 bytes of protobuf data: <code>08 96 01 12 05 41 70 70 6c 65</code>.</p>
<p>When sending this over gRPC, we prepend the header:</p>
<ul>
<li><strong>Compression</strong>: <code>0</code> (no compression)</li>
<li><strong>Length</strong>: <code>10</code> (<code>0x0A</code>)</li>
</ul>
<p>The final 15-byte gRPC message looks like this:</p>
<pre><span>00 </span><span>00 00 00 0a </span><span>08 96 01 12 05 41 70 70 6c 65</span><span>│</span><span>  │</span><span>           └─ The protobuf payload (10 bytes)</span><span>│</span><span>  └───────────── Payload message length (0xA = 10 bytes)</span><span>└──────────────── Compression flag (0 = false)</span></pre>
<p>This simple framing allows the receiver to read exactly the right number of bytes for the next message, decode it, and repeat, enabling fluid streaming.</p>
<h3 id="status-and-trailers">Status and trailers<a href="#status-and-trailers" aria-label="Direct link to Status and trailers" title="Direct link to Status and trailers">​</a></h3>
<p>In REST, you check the HTTP status code (200, 404, 500).
In gRPC, the HTTP status is almost always <code>200 OK</code>, even if the logic failed!</p>
<p>The actual application status is sent in the trailers (the very last HTTP/2 header frame).
This separation is crucial: it allows a server to successfully stream 100 items and then report an error on the 101st processing step.</p>
<p>A typical trailer block looks like this:</p>
<div><div><pre tabindex="0"><code><span><span>grpc-status: 0</span><br/></span><span><span>grpc-message: OK</span><br/></span></code></pre></div></div>
<p>(Status <code>0</code> is OK. Non-zero values represent errors like <code>NOT_FOUND</code>, <code>UNAVAILABLE</code>, etc.)</p>
<h3 id="rich-errors">Rich errors<a href="#rich-errors" aria-label="Direct link to Rich errors" title="Direct link to Rich errors">​</a></h3>
<p>Sometimes, a simple status code and a string message aren&#39;t enough.
You might want to return validation errors for specific fields or other error details.
The rich error model (specifically <code>google.rpc.Status</code>) solves this.</p>
<p>Instead of just <code>grpc-status</code> and <code>grpc-message</code>,
the server returns a detailed protobuf message serialized as base64 into the <code>grpc-status-details-bin</code> trailer.
This standard message contains:</p>
<ol>
<li><strong>Code</strong>: The gRPC status code.</li>
<li><strong>Message</strong>: The developer-facing error message.</li>
<li><strong>Details</strong>: A list of <code>google.protobuf.Any</code> messages containing arbitrary error details (e.g., <code>BadRequest</code>, <code>PreconditionFailure</code>, <code>DebugInfo</code>).</li>
</ol>
<div><div><pre tabindex="0"><code><span><span>message</span><span> </span><span>Status</span><span> </span><span>{</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>int32</span><span> code </span><span>=</span><span> </span><span>1</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>string</span><span> message </span><span>=</span><span> </span><span>2</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span>repeated</span><span> </span><span>google</span><span>.</span><span>protobuf</span><span>.</span><span>Any</span><span> details </span><span>=</span><span> </span><span>3</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div>
<p>Clients can decode this trailer to get structured, actionable error information.</p>
<h3 id="compression">Compression<a href="#compression" aria-label="Direct link to Compression" title="Direct link to Compression">​</a></h3>
<p>Depending on the environment, bandwidth can be precious,
especially on mobile networks.
gRPC has built-in support for compression to reduce the payload size.</p>
<h4 id="how-it-works">How it works<a href="#how-it-works" aria-label="Direct link to How it works" title="Direct link to How it works">​</a></h4>
<ol>
<li><strong>Negotiation</strong>: The client sends a <code>grpc-accept-encoding</code> header (e.g., <code>br, gzip, identity</code>) to tell the server which algorithms it supports.</li>
<li><strong>Encoding</strong>: If the server decides to compress the response, it sets the <code>grpc-encoding</code> header (e.g., <code>br</code>).</li>
<li><strong>Flagging</strong>: For each message, the <strong>compression flag</strong> (byte 0 of the 5-byte header) is set to <code>1</code>.</li>
<li><strong>Payload</strong>: The message payload is compressed using the selected algorithm.</li>
</ol>
<p>Let&#39;s look at how the wire format changes when compression is enabled.
Note that compressing our tiny &#34;Apple&#34; message with brotli results in a larger size due to overhead,
but the structure remains the same:</p>
<pre><span>01 </span><span>00 00 00 0e </span><span>8f 04 80 08 96 01 12 05 41 70 70 6c 65 03</span><span>│</span><span>  │</span><span>           └─ The compressed payload</span><span>│</span><span>  └───────────── Length of compressed message (0xE = 14 bytes)</span><span>└──────────────── Compression flag (1 = true)</span></pre>
<p>This happens per-message.
It is even possible to have different compression settings for the request and the response (asymmetric compression).</p>
<h2 id="alternative-transports">Alternative transports<a href="#alternative-transports" aria-label="Direct link to Alternative transports" title="Direct link to Alternative transports">​</a></h2>
<p>While gRPC usually runs over TCP/IP with HTTP/2, the protocol is agnostic enough to run elsewhere.</p>
<ul>
<li><strong>Unix Domain Sockets</strong>: Perfect for local IPC. It bypasses the TCP network stack for maximum efficiency.</li>
<li><strong>Named Pipes</strong>: The equivalent on Windows.</li>
</ul>
<p>This flexibility allows gRPC to be the universal glue between components,
whether they are on different continents or on the same chip.</p>
<h2 id="the-browser-gap-grpc-web">The browser gap (gRPC-Web)<a href="#the-browser-gap-grpc-web" aria-label="Direct link to The browser gap (gRPC-Web)" title="Direct link to The browser gap (gRPC-Web)">​</a></h2>
<p>There is one place gRPC struggles: <strong>the Browser</strong>.
Web browsers do not expose the low-level HTTP/2 framing controls required for gRPC (specifically, reading trailers and granular stream control).</p>
<p>This challenge is addressed by gRPC-Web, a protocol adaptation that:</p>
<ol>
<li>Encodes trailers inside the data stream body (so the browser doesn&#39;t need to read HTTP trailers).</li>
<li>Supports text-based application-layer encoding (base64) to bypass binary constraints.</li>
</ol>
<p>We will cover more on how exactly gRPC-Web works in a future post.</p>
<h2 id="closing">Closing<a href="#closing" aria-label="Direct link to Closing" title="Direct link to Closing">​</a></h2>
<p>gRPC is more than just a serialization format, it&#39;s a complete ecosystem that standardizes how we define, generate, and consume APIs.
By understanding the layers, from the <code>.proto</code> contract to the 5-byte header on the wire,
you can debug issues more effectively and design better systems.</p>
<p>Tools like <a href="https://kreya.app" target="_blank" rel="noopener noreferrer">Kreya</a> abstract this complexity away for daily testing,
but knowing what happens under the hood puts you in control when things get tricky.</p>
<h2 id="further-reading">Further Reading<a href="#further-reading" aria-label="Direct link to Further Reading" title="Direct link to Further Reading">​</a></h2>
<ul>
<li><a href="https://kreya.app/blog/grpc-best-practices/">gRPC Best Practices</a>: Learn about API design, versioning, and performance tips.</li>
<li><a href="https://grpc.io/docs/what-is-grpc/core-concepts/" target="_blank" rel="noopener noreferrer">gRPC Core concepts, architecture and lifecycle</a>: Official gRPC documentation on core concepts.</li>
<li><a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md" target="_blank" rel="noopener noreferrer">gRPC HTTP/2 specification</a>: Official gRPC HTTP/2 transport specification.</li>
<li>Protobuf (<a href="https://kreya.app/blog/protocolbuffers-wire-format/">part 1</a> and <a href="https://kreya.app/blog/protocolbuffers-wire-format-part-2/">part 2</a>): Deep dives into the protocol buffers format.</li>
</ul></div></div>
  </body>
</html>
