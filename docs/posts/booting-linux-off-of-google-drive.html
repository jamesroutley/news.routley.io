<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ersei.net/en/blog/fuse-root">Original</a>
    <h1>Booting Linux off of Google Drive</h1>
    
    <div id="readability-page-1" class="page"><div id="main"><article><p>Competitiveness is a vice of mine. When I heard that a friend got Linux to <a href="https://www.kernel.org/doc/html/latest/admin-guide/nfs/nfsroot.html">boot off of NFS</a>, I had to one-up her. I had to prove that I could create something <em>harder</em>, something <em>better</em>, <em>faster</em>, <em>stronger</em>.</p><p>Like all good projects, this began with an Idea.</p><p>My mind reached out and grabbed wispy tendrils from the æther, forcing the disparate concepts to coalesce. The Mass gained weight in my hands, and a dark, swirling colour promising doom to those who gazed into it for long.</p><p>On the brink of insanity, my tattered mind unable to comprehend the twisted interplay of millennia of arcane programmer-time and the ragged screech of madness, I reached into the Mass and steeled myself to the ground lest I be pulled in, and found my <em>magnum opus</em>.</p><p>Booting Linux off of a Google Drive root.</p><h2 id="but-how">But How?<a href="#but-how" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>I wanted this to remain self-contained, so I couldn&#39;t have a second machine act as a &#34;helper&#34;. My mind went immediately to <a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE</a>—a program that acts as a filesystem driver in userspace (with cooperation from the kernel).</p><p>I just had to get FUSE programs installed in the Linux kernel <a href="https://www.kernel.org/doc/html/latest/filesystems/ramfs-rootfs-initramfs.html">initramfs</a> and configure networking. How bad could it be?</p><h2 id="the-linux-boot-process">The Linux Boot Process<a href="#the-linux-boot-process" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>The Linux boot process is, technically speaking, very funny. Allow me to pretend I understand for a moment<sup id="fnref1:1"><a href="#fn:1">1</a></sup>:</p><ol><li>The firmware (BIOS/UEFI) starts up and loads the bootloader</li><li>The bootloader loads the kernel</li><li>The kernel unpacks a temporary filesystem into RAM which has the tools to mount the real filesystem</li><li>The kernel mounts the real filesystem and switches the process to the init system running on the new filesystem</li></ol><p>As strange as the third step may seem, it&#39;s very helpful! We can mount a FUSE filesystem in that step and boot normally.</p><h2 id="a-proof-of-concept">A Proof of Concept<a href="#a-proof-of-concept" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>The initramfs needs to have both network support as well as the proper FUSE binaries. Thankfully, <a href="https://github.com/dracutdevs/dracut">Dracut</a> makes it easy enough to build a custom initramfs.</p><p>I decide to build this on top of Arch Linux because it&#39;s relatively lightweight and I&#39;m familiar with how it works, as opposed to something like Alpine.</p><pre><code><span>$</span><span> git <span>clone</span> https://github.com/dracutdevs/dracut</span>
<span>$</span><span> podman run -it --name arch -v ./dracut:/dracut docker.io/archlinux:latest bash</span></code></pre><p>In the container, I installed some packages (including the <code>linux</code> package because I need a functioning kernel), compiled <code>dracut</code> from source, and wrote a simple module script in <code>modules.d/90fuse/module-setup.sh</code>:</p><pre><code><span>#!/bin/bash</span>
<span><span>check</span></span>() {
    require_binaries fusermount fuseiso mkisofs || <span>return</span> 1
    <span>return</span> 0
}

<span><span>depends</span></span>() {
    <span>return</span> 0
}

<span><span>install</span></span>() {
    inst_multiple fusermount fuseiso mkisofs
    <span>return</span> 0
}</code></pre><p>That&#39;s it. That&#39;s all the code I had to write. Buoyed by my newfound confidence, I powered ahead, building the EFI image.</p><pre><code><span>$</span><span> ./dracut.sh --kver 6.9.6-arch1-1 \</span>
    --uefi efi_firmware/EFI/BOOT/BOOTX64.efi \
    --force -l -N --no-hostonly-cmdline \
    --modules &#34;base bash fuse shutdown network&#34; \
    --add-drivers &#34;target_core_mod target_core_file e1000&#34; \
    --kernel-cmdline &#34;ip=dhcp rd.shell=1 console=ttyS0&#34;
<span>$</span><span> qemu-kvm -bios ./FV/OVMF.fd -m 4G \</span>
    -drive format=raw,file=fat:rw:./efi_firmware \
    -netdev user,id=network0 -device e1000,netdev=network0 -nographic
...
...
dracut Warning: dracut: FATAL: No or empty root= argument
dracut Warning: dracut: Refusing to continue

Generating &#34;/run/initramfs/rdsosreport.txt&#34;
You might want to save &#34;/run/initramfs/rdsosreport.txt&#34; to a USB stick or /boot
after mounting them and attach it to a bug report.

To get more debug information in the report,
reboot with &#34;rd.debug&#34; added to the kernel command line.

Dropping to debug shell.

dracut:/#</code></pre><p><em>Hacker voice</em> I&#39;m in. Now to enable networking and mount a test root. I have already extracted an Arch Linux root into a S3 bucket running locally, so this should be pretty easy, right? I just have to manually set up networking routes and load the drivers.</p><pre><code>dracut:/# modprobe fuse
dracut:/# modprobe e1000
dracut:/# ip link set lo up
dracut:/# ip link set eth0 up
dracut:/# dhclient eth0
dhcp: PREINIT eth0 up
dhcp: BOUND setting up eth0
dracut:/# ip route add default via 10.0.2.2 dev eth0 proto dhcp src 10.0.2.15
dracut:/# s3fs -o url=http://192.168.2.209:9000 -o use_path_request_style fuse /sysroot
dracut:/# ls /sysroot
bin   dev  home  lib64  opt   root  sbin  sys  usr
boot  etc  lib   mnt    proc  run   srv   tmp  var
dracut:/# switch_root /sysroot /sbin/init
switch_root: failed to execute /lib/systemd/systemd: Input/output error
dracut:/# ls
sh: ls: command not found</code></pre><p>Honestly, I don&#39;t know what I expected. Seems like everything is just... <em>gone</em>. Alas, not even tab completion can save me. At this point, I was stuck. I had no idea what to do. I spent days just looking around, poking at the <code>switch_root</code> source code, all for naught. Until I remembered a link <a href="https://a.exozy.me">Anthony</a> had sent me: <a href="https://unix.stackexchange.com/questions/226872/how-to-shrink-root-filesystem-without-booting-a-livecd/227318#227318">How to shrink root filesystem without booting a livecd</a>. In there, there was a command called <code>pivot_root</code> that <code>switch_root</code> seems to call internally. Let&#39;s try that out.</p><pre><code>dracut:/# logout
...
[  430.817269] ---[ end Kernel panic - not syncing: Attempted to kill init! exitcode=0x00000100 ]---
...
dracut:/# cd /sysroot
dracut:/sysroot# mkdir oldroot
dracut:/sysroot# pivot_root . oldroot
pivot_root: failed to change root from `.&#39; to `oldroot&#39;: Invalid argument</code></pre><p>Apparently, <code>pivot_root</code> is <a href="https://unix.stackexchange.com/a/455224">not allowed</a> to pivot roots if the root being switched is in the initramfs. Unfortunate. The Stack Exchange answer tells me to use <code>switch_root</code>, which doesn&#39;t work either. However, part of that answer sticks out to me:</p><blockquote><p>initramfs is rootfs: you can neither pivot_root rootfs, nor unmount it. Instead delete everything out of rootfs to free up the space (find -xdev / -exec rm &#39;{}&#39; &#39;;&#39;), overmount rootfs with the new root (cd /newmount; mount --move . /; chroot .), attach stdin/stdout/stderr to the new /dev/console, and exec the new init.</p></blockquote><p>Would it be possible to manually switch the root <em>without</em> a specialized system call? What if I just chroot?</p><pre><code>...
dracut:/# mount --rbind /sys /sysroot/sys
dracut:/# mount --rbind /dev /sysroot/dev
dracut:/# mount -t proc /proc /sysroot/proc
dracut:/# chroot /sysroot /sbin/init
Explicit --user argument required to run as user manager.</code></pre><p>Oh, I need to run the <code>chroot</code> command as PID 1 so Systemd can start up properly. I can actually tweak the initramfs&#39;s init script and just put my startup commands in there, and replace the <code>switch_root</code> call with <code>exec chroot /sbin/init</code>.</p><p>I put this in <code>modules.d/99base/init.sh</code> in the Dracut source after the udev rules are loaded and bypassed the <code>root</code> variable checks earlier.</p><pre><code>modprobe fuse
modprobe e1000
ip link <span>set</span> lo up
ip link <span>set</span> eth0 up
dhclient eth0
ip route add default via 10.0.2.2 dev eth0 proto dhcp src 10.0.2.15
s3fs -o url=http://192.168.2.209:9000 -o use_path_request_style fuse /sysroot
mount --rbind /sys /sysroot/sys
mount --rbind /dev /sysroot/dev
mount -t proc /proc /sysroot/proc</code></pre><p>I also added <code>exec chroot /sysroot /sbin/init</code> at the end instead of the <code>switch_root</code> command.</p><p>Rebuilding the EFI image and...</p><p><img alt="A screenshot of a Linux login screen" src="https://ersei.net/user/pages/03.blog/40.fuse-root/itworks.png"/></p><p>I sit there, in front of my computer, staring. It can&#39;t have been that easy, can it? Surely, this is a profane act, and the spirit of Dennis Ritchie ought&#39;t&#39;ve stopped me, right?</p><p>Nobody stopped me, so I kept going.</p><p>I log in with the very secure password <code>root</code> as <code>root</code>, and it unceremoniously drops me into a shell.</p><pre><code>[root@archlinux ~]# mount
s3fs on / type fuse.s3fs (rw,nosuid,nodev,relatime,user_id=0,group_id=0)
...
[root@archlinux ~]#</code></pre><p>At last, Linux booted off of an S3 bucket. I was compelled to share my achievement with others—all I needed was a fetch program to include in the screenshot:</p><pre><code>[root@archlinux ~]# pacman -Sy fastfetch
:: Synchronizing package databases...
 core.db failed to download
error: failed retrieving file &#39;core.db&#39; from geo.mirror.pkgbuild.com : Could not resolve host: geo.mirror.pkgbuild.com
warning: fatal error from geo.mirror.pkgbuild.com, skipping for the remainder of this transaction
error: failed retrieving file &#39;core.db&#39; from mirror.rackspace.com : Could not resolve host: mirror.rackspace.com
warning: fatal error from mirror.rackspace.com, skipping for the remainder of this transaction
error: failed retrieving file &#39;core.db&#39; from mirror.leaseweb.net : Could not resolve host: mirror.leaseweb.net
warning: fatal error from mirror.leaseweb.net, skipping for the remainder of this transaction
error: failed to synchronize all databases (invalid url for server)
[root@archlinux ~]#</code></pre><p>Uh, seems like DNS isn&#39;t working, and I&#39;m missing <code>dig</code> and other debugging tools.</p><p>Wait a minute! My root filesystem is on S3! I can just mount it somewhere else with functional networking, <code>chroot</code> in, and install all my utilities!</p><p>Some debugging later, it seems like systemd-resolved doesn&#39;t want to run because it <code>Failed to connect stdout to the journal socket, ignoring: Permission denied</code>. I&#39;m not about to try to debug systemd because it&#39;s too complicated and I&#39;m lazy, so instead I&#39;ll just use Cloudflare&#39;s.</p><pre><code>[root@archlinux ~]# echo &#34;nameserver 1.1.1.1&#34; &gt; /etc/resolv.conf
[root@archlinux ~]# pacman -Sy fastfetch
:: Synchronizing package databases...
 core is up to date
 extra is up to date
...
[root@archlinux ~]# fastfetch</code></pre><p><img alt="Fastfetch showing the system running in QEMU" src="https://ersei.net/user/pages/03.blog/40.fuse-root/fastfetch.png"/></p><p>I look around, making sure that nobody had tried to stop me. My window was intact, my security system had not tripped, the various canaries I had set up around the house had not been touched. I was safe to continue.</p><p>I was ready to have it run on Google Drive.</p><h2 id="google-gets-involved">Google Gets Involved<a href="#google-gets-involved" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>There&#39;s a project already that does Google Drive over FUSE for me already: <a href="https://github.com/astrada/google-drive-ocamlfuse">google-drive-ocamlfuse</a>. Thankfully, I have a Google account lying around that I haven&#39;t touched in years ready to go! I follow the instructions, accept the terms of service I didn&#39;t read, create all the oauth2 secrets, enable the APIs, install <code>google-drive-ocamlfuse</code> from the AUR into my Arch Linux VM, patch some <code>PKGBUILD</code>s (it&#39;s been a while), and lo and behold! I have mounted Google Drive! Mounting Drive and a few <em>very long</em><code>rsync</code> runs later, I have Arch Linux on Google Drive.</p><p>Just kidding, it&#39;s never that easy. Here&#39;s a non-exhausive list of problems I ran into:</p><ol><li>Symlinks to symlinks don&#39;t work (very important for stuff in <code>/usr/lib</code>)</li><li>Hardlinks don&#39;t work</li><li>It&#39;s so slowwwww</li><li>Relative symlinks don&#39;t work at all</li><li>No dangling symlinks (important for stuff that links to <code>/proc</code> and isn&#39;t mounted, or stuff that just hasn&#39;t copied over yet)</li><li>Symlinks outside of Google Drive don&#39;t work</li><li>Permissions don&#39;t work (neither do attributes)</li><li>Did I mention it&#39;s SLOW</li></ol><p>With how many problems there are with symlinks, I have half a mind to change the FUSE driver code to just create a file that ends in <code>.internalsymlink</code> to fix all of that, Google Drive compatibility be damned.</p><p>But, I have challenged myself to do this without modifying anything important (no kernel tweaking, no FUSE driver tweaking), so I&#39;ll just have to live with it and manually create the symlinks that <code>rsync</code> fails to make with a hacky <code>sed</code> command to the <code>rsync</code> error logs.</p><p>In the meantime, I added the token files generated from my laptop into the initramfs, as well as the Google Drive FUSE binary and SSL certificates, and tweaked a few settings<sup id="fnref1:2"><a href="#fn:2">2</a></sup> to make my life slighty easier.</p><pre><code>...
inst ./gdfuse-config /.gdfuse/default/config
inst ./gdfuse-state /.gdfuse/default/state
find /etc/ssl -<span>type</span> f -or -<span>type</span> l | <span>while</span> <span>read</span> file; <span>do</span> inst <span>&#34;<span>$file</span>&#34;</span>; <span>done</span>
find /etc/ca-certificates -<span>type</span> f -or -<span>type</span> l | <span>while</span> <span>read</span> file; <span>do</span> inst <span>&#34;<span>$file</span>&#34;</span>; <span>done</span>
...</code></pre><p><img alt="A screenshot of Google Drive showing the root of a typical Linux filesystem" src="https://ersei.net/user/pages/03.blog/40.fuse-root/google-drive-root.png"/></p><p>It&#39;s nice to see that timestamps kinda work, at least. Now all that&#39;s left is to wait for the agonizingly slow boot!</p><pre><code>chroot: /sbin/init: File not found</code></pre><p>Perhaps they did not bother to stop me because they knew I would fail. </p><p>I know the file exists since, well, it <em>exists</em>, so why is it not found? Simple: Linux is kinda weird and if the binary you call depends on a library that&#39;s not found, then you&#39;ll get &#34;File not found&#34;.</p><pre><code>dracut:/# ldd /sysroot/bin/bash
    linux-vdso.so.1 (0x00007e122b196000)
    libreadline.so.8 =&gt; /usr/lib/libreadline.so.8 (0x00007e122b01a000)
    libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007e122ae2e000)
    libncursesw.so.6 =&gt; /usr/lib/libncursesw.so.6 (0x00007e122adbf000)
    /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007e122b198000)</code></pre><p>However, these symlinks don&#39;t actually exist! Remember how earlier we noted that relative symlinks don&#39;t work? Well, that&#39;s come back to bite me. The Kernel is looking for files in <code>/sysroot</code> inside <code>/sysroot/sysroot</code>. Luckily, this is an easy enough fix: we just need to have <code>/sysroot</code> linked to <code>/sysroot/sysroot</code> without links:</p><pre><code>dracut:/# mkdir /sysroot/sysroot
dracut:/# mount --rbind /sysroot /sysroot/sysroot</code></pre><p>Now time to boot!</p><p>It took five minutes for Arch to rebuild the dynamic linker cache, another minute per systemd unit, and then, nothing. The startup halted in its tracks.</p><pre><code>[ TIME ] Timed out waiting for device /dev/ttyS0.
[DEPEND] Dependency failed for Serial Getty on ttyS0.</code></pre><p>Guess I have to increase the timeout and reboot. In <code>/etc/systemd/system/dev-ttyS0.device</code>, I put:</p><pre><code>[Unit]
Description=Serial device ttyS0
DefaultDependencies=no
Before=sysinit.target
JobTimeoutSec=infinity</code></pre><p>Luckily, it did not take infinite time to boot.</p><p><img alt="A Linux login prompt" src="https://ersei.net/user/pages/03.blog/40.fuse-root/gdrive-booted.png"/></p><p>I&#39;m so close to victory I can <em>taste</em> it! I just have to increase <em>another</em> timeout. I set <code>LOGIN_TIMEOUT</code> to <code>0</code> in <code>/etc/login.defs</code> in Google Drive, and tried logging in again.</p><p>Thankfully, there&#39;s a cache, so subsequent file reads aren&#39;t nearly as slow.</p><p><img alt="Fastfetch in Google Drive root, showing that the root partition is mounted as fuse.google-drive-ocaml" src="https://ersei.net/user/pages/03.blog/40.fuse-root/gdrive-fastfetch.png"/></p><p>Here I am, laurel crown perched upon my head, my chimera of Linux and Google Drive lurching around.</p><p>But I&#39;m not satisfied yet. Nobody had stopped me because they <em>want</em> me to succeed. I have to take this further. I need this to work on <em>real hardware</em>.</p><h2 id="now-do-it-on-real-hardwar">Now Do It On Real Hardware<a href="#now-do-it-on-real-hardwar" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>Fortunately for me, I <a href="https://ersei.net/en/blog/updates-2024-02">switched servers</a> and now have an extra laptop with no storage just lying around! A wonderful victim<sup id="fnref1:3"><a href="#fn:3">3</a></sup> for my test!</p><p>There are a few changes I&#39;ll have to make:</p><ol><li>Use the right ethernet driver and not the default <code>e1000</code></li><li>Do not use a serial display</li><li>Change the network settings to match my house&#39;s network topology</li></ol><p>All I need is the <code>r8169</code> driver for my ethernet port, and let&#39;s throw in a <a href="https://en.wikipedia.org/wiki/Power-line_communication">Powerline</a> into the mix, because it&#39;s not going to impact the performance in any way that matters, and I don&#39;t have an ethernet cord that can reach my room.</p><p>I build the unified EFI file, throw it on a USB drive under <code>/BOOT/EFI</code>, and stick it in my old server. Despite my best attempts, I couldn&#39;t figure out what the modprobe directive is for the laptop&#39;s built-in keyboard, so I just modprobed <code>hid_usb</code> and used an external keyboard to set up networking.</p><p><img alt="A screenshot of fastfetch and mount on bare metal showing that we&#39;re booted off of Google Drive" src="https://ersei.net/user/pages/03.blog/40.fuse-root/bare-metal-gdrive.png"/></p><p>This is my <em>magnum opus</em>. My Great Work. This is the mark I will leave on this planet long after I am gone: The Cloud Native Computer.</p><p>Nice thing is, I can just grab the screenshot<sup id="fnref1:screenshot"><a href="#fn:screenshot">4</a></sup> from Google Drive and put it here!</p><h2 id="woe-cloud-native-computer">Woe! Cloud Native Computer Be Upon Ye<a href="#woe-cloud-native-computer" data-anchor-icon="#" aria-label="Anchor"></a></h2><p>Despite how silly this project is, there are a few less-silly uses I can think of, like booting Linux off of <a href="https://github.com/libfuse/sshfs">SSH</a>, or perhaps booting Linux off of a Git repository and tracking every change in Git using <a href="https://wiki.archlinux.org/title/Gitfs">gitfs</a>. The possibilities are endless, despite the middling usefulness.</p><p>If there is anything I know about technology, it&#39;s that moving everything to The Cloud is the current trend. As such, I am prepared to commercialize this for any company wishing to leave their unreliable hardware storage behind and move entirely to The Cloud. Please <a href="https://ersei.net/en/contact-me">request a quote</a> if you are interested in True Cloud Native Computing.</p><p>Unfortunately, I don&#39;t know what to do next with this. Maybe I should install Nix?</p><hr/><p>Thoughts? Comments? Opinions? Feel free to share (relevant) ones with me! <a href="https://ersei.net/en/contact-me">Contact me here if you want.</a></p></article></div></div>
  </body>
</html>
