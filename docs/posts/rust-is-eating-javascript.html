<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://leerob.com/n/rust">Original</a>
    <h1>Rust Is Eating JavaScript</h1>
    
    <div id="readability-page-1" class="page"><div>
<a href="https://leerob.com/">Lee Robinson</a>
<!-- -->
<p><a href="https://www.rust-lang.org/" target="_blank" rel="noopener noreferrer">Rust</a> is a fast, reliable, and memory-efficient programming language. It&#39;s been voted the most loved programming language <a href="https://insights.stackoverflow.com/survey/2016#technology-most-loved-dreaded-and-wanted" target="_blank" rel="noopener noreferrer">six</a> <a href="https://insights.stackoverflow.com/survey/2017#most-loved-dreaded-and-wanted" target="_blank" rel="noopener noreferrer">years</a> <a href="https://insights.stackoverflow.com/survey/2018#technology-_-most-loved-dreaded-and-wanted-languages" target="_blank" rel="noopener noreferrer">in</a> <a href="https://insights.stackoverflow.com/survey/2019#technology-_-most-loved-dreaded-and-wanted-languages" target="_blank" rel="noopener noreferrer">a</a> <a href="https://insights.stackoverflow.com/survey/2020#most-loved-dreaded-and-wanted" target="_blank" rel="noopener noreferrer">row</a> (<a href="https://insights.stackoverflow.com/survey/2021/#technology-most-loved-dreaded-and-wanted" target="_blank" rel="noopener noreferrer">survey</a>). Created by Mozilla, it&#39;s now used at <a href="https://engineering.fb.com/2021/04/29/developer-tools/rust/" target="_blank" rel="noopener noreferrer">Facebook</a>, <a href="https://twitter.com/oskargroth/status/1301502690409709568" target="_blank" rel="noopener noreferrer">Apple</a>, <a href="https://aws.amazon.com/blogs/opensource/why-aws-loves-rust-and-how-wed-like-to-help/" target="_blank" rel="noopener noreferrer">Amazon</a>, <a href="https://twitter.com/ryan_levick/status/1171830191804551168" target="_blank" rel="noopener noreferrer">Microsoft</a>, and <a href="https://security.googleblog.com/2021/04/rust-in-android-platform.html" target="_blank" rel="noopener noreferrer">Google</a> for systems infrastructure, encryption, virtualization, and more low-level programming.</p>
<p>Why is Rust now being used to replace parts of the JavaScript web ecosystem like minification (Terser), transpilation (Babel), formatting (Prettier), bundling (webpack), linting (ESLint), and more?</p>
<h2>What is Rust?</h2>
<p>Rust helps developers write fast software that&#39;s memory-efficient. It&#39;s a modern replacement for languages like C++ or C with a focus on code safety and concise syntax.</p>
<p>Rust is quite different than JavaScript. JavaScript tries to find variables or objects not in use and automatically clears them from memory. This is called <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener noreferrer">Garbage Collection</a>. The language abstracts the developer from thinking about manual memory management.</p>
<p>With Rust, developers have more control over memory allocation, without it being as painful as C++.</p>
<blockquote>
<p>Rust uses a relatively unique memory management approach that incorporates the idea of memory “ownership”. Basically, Rust keeps track of who can read and write to memory. It knows when the program is using memory and immediately frees the memory once it is no longer needed. It enforces memory rules at compile time, making it virtually impossible to have runtime memory bugs. You do not need to manually keep track of memory. The compiler takes care of it. – <a href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f" target="_blank" rel="noopener noreferrer">Discord</a></p>
</blockquote>
<h2>Adoption</h2>
<p>On top of the companies mentioned above, Rust is also being used for popular open-source libraries like:</p>
<ul>
<li><a href="https://github.com/firecracker-microvm/firecracker" target="_blank" rel="noopener noreferrer">Firecracker</a> (AWS)</li>
<li><a href="https://github.com/bottlerocket-os/bottlerocket" target="_blank" rel="noopener noreferrer">Bottlerocket</a> (AWS)</li>
<li><a href="https://github.com/cloudflare/quiche" target="_blank" rel="noopener noreferrer">Quiche</a> (Cloudflare)</li>
<li><a href="https://github.com/mozilla/neqo" target="_blank" rel="noopener noreferrer">Neqo</a> (Mozilla)</li>
</ul>
<blockquote>
<p>Rust has been a force multiplier for our team, and betting on Rust was one of the best decisions we made. More than performance, its ergonomics and focus on correctness has helped us tame sync&#39;s complexity. We can encode complex invariants about our system in the type system and have the compiler check them for us. – <a href="https://dropbox.tech/infrastructure/rewriting-the-heart-of-our-sync-engine" target="_blank" rel="noopener noreferrer">Dropbox</a></p>
</blockquote>
<h2>From JavaScript to Rust</h2>
<p>JavaScript is the most widely used programming language, operating on every device with a web browser. Over the past ten years, a massive ecosystem has been built around JavaScript:</p>
<ul>
<li><strong>Webpack:</strong> bundle multiple JavaScript files into one.</li>
<li><strong>Babel:</strong> write modern JavaScript while supporting older browsers.</li>
<li><strong>Terser:</strong> generate the smallest possible file sizes.</li>
<li><strong>Prettier:</strong> format code in an opinionated way.</li>
<li><strong>ESLint:</strong> find issues with their code before deploying.</li>
</ul>
<p>Millions of lines of code have been written and even more bugs have been fixed to create the bedrock for shipping web applications of today. All of these tools are written with JavaScript or TypeScript. This has worked well, but we&#39;ve reached peak optimization with JS. This has inspired a new class of tools, designed to drastically improve the performance of building for the web.</p>
<h3>SWC</h3>
<p><a href="http://swc.rs/" target="_blank" rel="noopener noreferrer">SWC</a>, created in 2017, is an extensible Rust-based platform for the next generation of fast developer tools. It&#39;s used by tools like Next.js, Parcel, and Deno, as well as companies like Vercel, ByteDance, Tencent, Shopify, and more.</p>
<p>SWC can be used for compilation, minification, bundling, and more – and is designed to be extended. It&#39;s something you can call to perform code transformations (either built-in or custom). Running those transformations happens through higher-level tools like Next.js.</p>
<h3>Deno</h3>
<p><a href="https://deno.land/" target="_blank" rel="noopener noreferrer">Deno</a>, created in 2018, is a simple, modern, and secure runtime for JavaScript and TypeScript that uses <a href="https://v8.dev/" target="_blank" rel="noopener noreferrer">V8</a> and is built with Rust. It&#39;s an attempt to replace Node.js, written by the original creators of Node.js. While it was created in 2018, it didn&#39;t hit <a href="https://deno.com/blog/v1" target="_blank" rel="noopener noreferrer">v1.0 until May 2020</a>.</p>
<p>Deno&#39;s linter, code formatter, and docs generator are <a href="https://twitter.com/devongovett/status/1369033422002389000" target="_blank" rel="noopener noreferrer">built using SWC</a>.</p>
<h3>esbuild</h3>
<p><a href="https://esbuild.github.io/" target="_blank" rel="noopener noreferrer">esbuild</a>, created in January 2020, is a JavaScript bundler and minifier 10-100x faster than existing tools, written in Go.</p>
<blockquote>
<p>I&#39;m trying to create a build tool that A) works well for a given sweet spot of use cases (bundling JavaScript, TypeScript, and maybe CSS) and B) <strong>resets the expectations of the community for what it means for a JavaScript build tool to be fast</strong>. Our current tools are way too slow in my opinion. – Evan, Creator of esbuild (<a href="https://news.ycombinator.com/item?id=22336334" target="_blank" rel="noopener noreferrer">Source</a>)</p>
</blockquote>
<p>Building JavaScript tooling with systems programming languages, like Go and Rust, was fairly niche until esbuild was released. In my opinion, esbuild sparked a wider interest in trying to make developer tools faster. Evan chose to use Go:</p>
<blockquote>
<p>The Rust version probably could be made to work at an equivalent speed with enough effort. But at a high level, Go was much more enjoyable to work with. This is a side project and it has to be fun for me to work on it. – Evan, Creator of esbuild (<a href="https://news.ycombinator.com/item?id=22336284" target="_blank" rel="noopener noreferrer">Source</a>)</p>
</blockquote>
<p>Some argue Rust could perform better, but both could achieve Evan&#39;s original goal of influencing the community:</p>
<blockquote>
<p>Even with just basic optimization, Rust was able to outperform the hyper hand-tuned Go version. This is a huge testament to how easy it is to write efficient programs with Rust compared to the deep dive we had to do with Go. – <a href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f" target="_blank" rel="noopener noreferrer">Discord</a></p>
</blockquote>
<h3>Rome</h3>
<p><a href="https://rome.tools/blog/2020/08/08/introducing-rome" target="_blank" rel="noopener noreferrer">Rome</a>, created in August 2020, is a linter, compiler, bundler, test runner, and more, for JavaScript, TypeScript, HTML, JSON, Markdown, and CSS. They aim to replace and unify the entire frontend development toolchain. It&#39;s created by <a href="https://twitter.com/sebmck" target="_blank" rel="noopener noreferrer">Sebastian</a>, who also created Babel.</p>
<p>Why rewrite everything, then?</p>
<blockquote>
<p>Making the necessary modifications to Babel to allow for it to be a reliable base for other tools would have required changes to absolutely everything. The architecture is bound to the initial design choices I made in 2014 when I was learning about parsers, ASTs, and compilers. - Sebastian (<a href="https://rome.tools/blog/2020/08/08/introducing-rome" target="_blank" rel="noopener noreferrer">Source</a>)</p>
</blockquote>
<p>Rome is currently written in TypeScript and runs on Node.js. But they&#39;re now working on <a href="https://rome.tools/blog/2021/09/21/rome-will-be-rewritten-in-rust" target="_blank" rel="noopener noreferrer">rewriting in Rust</a> using RSLint parser and their own visitor system for AST traversal.</p>
<h3>NAPI</h3>
<p>Rust&#39;s integration with Node.js is better than other low-level languages.</p>
<p><a href="https://napi.rs/" target="_blank" rel="noopener noreferrer">napi-rs</a> allows you to build pre-compiled Node.js add-ons with Rust. It provides an out-of-the-box solution for cross-compilation and publishing native binaries to NPM, without needing <code><span><span>node</span><span>-</span><span>gyp</span></span></code> or <code><span><span>postinstall</span></span></code> scripts.</p>
<p>You can build a Rust module that can be called directly from Node.js, without needing to create a child process like esbuild.</p>
<h2>Rust + WebAssembly</h2>
<p><a href="https://webassembly.org/docs/use-cases/" target="_blank" rel="noopener noreferrer">WebAssembly</a> (WASM) is a portable low-level language that Rust can compile to. It runs in the browser, is interoperable with JavaScript, and is supported in all major modern browsers.</p>
<blockquote>
<p>WASM is definitely a lot faster than JS, but not quite native speed. In our tests, Parcel runs 10-20x slower when compiled to WASM than with native binaries. – <a href="https://twitter.com/devongovett" target="_blank" rel="noopener noreferrer">Devon Govett</a></p>
</blockquote>
<p>While WASM isn&#39;t the perfect solution yet, it <em>can</em> help developers create extremely fast web experiences. The Rust team is <a href="https://www.rust-lang.org/what/wasm" target="_blank" rel="noopener noreferrer">committed</a> to a high-quality and cutting-edge WASM implementation. For developers, this means you could have the performance advantages of Rust (vs. Go) while still compiling for the web (using WASM).</p>
<p>Some early libraries and frameworks in this space:</p>

<p>These Rust-based web frameworks that compile to WASM aren&#39;t trying to replace JavaScript, but work alongside it. While we aren&#39;t there yet, it&#39;s interesting to see Rust coming after the web on both sides: <strong>making existing JavaScript tooling faster</strong> <em>and</em> <strong>future-forward ideas for <a href="https://rustwasm.github.io/docs/book/introduction.html" target="_blank" rel="noopener noreferrer">compiling to WASM</a></strong>.</p>
<p>It&#39;s Rust all the way down.</p>
<h2>Why Not Rust?</h2>
<p>Rust has a steep learning curve. It&#39;s a lower level of abstraction than what most web developers are used to.</p>
<p>Once you&#39;re on native code (through Rust, Go, Zig, or other low-level languages),
the algorithms and data structures are <a href="https://twitter.com/devongovett/status/1457945506332692482" target="_blank" rel="noopener noreferrer">more important</a> than the language choice. It&#39;s not a silver bullet.</p>
<blockquote>
<p>Rust makes you think about dimensions of your code that matter tremendously for systems programming. It makes you think about how memory is shared or copied. It makes you think about real but unlikely corner cases and make sure that they&#39;re handled. It helps you write code that&#39;s incredibly efficient in every possible way. – Tom MacWright (<a href="https://macwright.com/2021/01/15/rust.html" target="_blank" rel="noopener noreferrer">Source</a>)</p>
</blockquote>
<p>Further, Rust&#39;s usage in the web community is still niche. It hasn&#39;t reached critical adoption. Even though learning Rust for JavaScript tooling will be a barrier to entry, interestingly developers would rather have a <a href="https://twitter.com/devongovett/status/1261379312898306048" target="_blank" rel="noopener noreferrer">faster tool that&#39;s harder to contribute to</a>. <a href="https://craigmod.com/essays/fast_software/" target="_blank" rel="noopener noreferrer">Fast software wins</a>.</p>
<p>Currently, it&#39;s hard to find a Rust library or framework for your favorite services (things like working with authentication, databases, payments, and more). I do think that once Rust and WASM reach critical adoption, this will resolve itself. But not yet. <strong>We need existing JavaScript tools to help us bridge the gap and incrementally adopt performance improvements</strong>.</p>
<h2>The Future of JavaScript Tooling</h2>
<p>I believe Rust is the future of JavaScript tooling. <a href="http://nextjs.org/12" target="_blank" rel="noopener noreferrer">Next.js 12</a> started our transition to fully replace Babel (transpilation) and Terser (minification) with SWC and Rust. Why?</p>
<ul>
<li><strong>Extensibility:</strong> SWC can be used as a Crate inside Next.js, without having to fork the library or workaround design constraints.</li>
<li><strong>Performance:</strong> We were able to achieve ~3x faster Fast Refresh and ~5x faster builds in Next.js by switching to SWC, with more room for optimization still in progress.</li>
<li><strong>WebAssembly:</strong> Rust&#39;s support for WASM is essential for supporting all possible platforms and taking Next.js development everywhere.</li>
<li><strong>Community:</strong> The Rust community and ecosystem are amazing and only growing.</li>
</ul>
<p>It&#39;s not just Next.js adopting SWC, either:</p>
<ul>
<li><a href="https://deno.land/" target="_blank" rel="noopener noreferrer">Deno&#39;s</a> linter, code formatter, and docs generator are <a href="https://twitter.com/devongovett/status/1369033422002389000" target="_blank" rel="noopener noreferrer">built using SWC</a>.</li>
<li><a href="https://github.com/devongovett/dprint-node" target="_blank" rel="noopener noreferrer">dprint</a>, built on SWC, is a <a href="https://twitter.com/devongovett/status/1400138335721455617" target="_blank" rel="noopener noreferrer">30x faster</a> code formatting replacement for Prettier.</li>
<li><a href="https://parceljs.org/" target="_blank" rel="noopener noreferrer">Parcel</a> improved overall build performance by <a href="https://v2.parceljs.org/blog/beta3/" target="_blank" rel="noopener noreferrer">up to 10x</a> with SWC.</li>
</ul>
<blockquote>
<p>Parcel uses SWC like a library. Before we used Babel&#39;s parser and custom transforms written in JS. Now, we use SWC&#39;s parser and <a href="https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/js/core/src" target="_blank" rel="noopener noreferrer">custom transforms in Rust</a>. This includes a full scope hoisting implementation, dependency collection, and more. It&#39;s similar in scope to how Deno built on top of SWC. – <a href="https://twitter.com/devongovett" target="_blank" rel="noopener noreferrer">Devon Govett</a></p>
</blockquote>
<p>It&#39;s early days for Rust – a few important pieces are still being figured out:</p>
<ul>
<li><strong>Plugins:</strong> Writing plugins in Rust isn&#39;t as approachable for many JavaScript developers. At the same time, exposing a plugin system in JavaScript could negate performance gains. A definitive solution hasn&#39;t emerged yet. Ideally, the future combines both JavaScript and Rust. If you want to write a plugin with JavaScript, it&#39;s possible with a tradeoff for speed. Need more performance? Use the Rust plugin API.</li>
<li><strong>Bundling:</strong> One interesting area of development is <code><span><span>swcpack</span></span></code>, which is SWC&#39;s replacement for Webpack. It&#39;s still under development but could be very promising.</li>
<li><strong>WebAssembly:</strong> As mentioned above, the prospect of writing Rust and compiling to WASM is enticing, but there&#39;s still work to be done.</li>
</ul>
<p>Regardless, I&#39;m confident Rust will continue to have a major impact on the JavaScript ecosystem for the next 1-2 years and into the future. Imagine a world where all of the build tools used in Next.js are written in Rust, giving you optimal performance. Then, Next.js could be distributed as a <a href="https://en.wikipedia.org/wiki/Static_build" target="_blank" rel="noopener noreferrer">static binary</a> you&#39;d download from NPM.</p>
<p>That&#39;s the world I want to live (and develop) in.</p>
<h2>Update: 2023</h2>
<p>Since this post was written in 2021, there&#39;s been even more investment into new Rust tooling in the JavaScript ecosystem. A few notable Rust projects include:</p>
<ul>
<li><strong><a href="https://biomejs.dev/" target="_blank" rel="noopener noreferrer">Biome</a></strong>: Rome, previously mentioned in this post, has became Biome</li>
<li><strong><a href="https://www.rspack.dev/" target="_blank" rel="noopener noreferrer">Rspack</a></strong>: New bundler with webpack compat</li>
<li><strong><a href="https://github.com/pnpm/pacquet" target="_blank" rel="noopener noreferrer">Pacquet (pnpm)</a></strong>: Experimental package manager for Node.js</li>
<li><strong><a href="https://twitter.com/youyuxi/status/1709943106215530867" target="_blank" rel="noopener noreferrer">Rolldown</a></strong>: New bundler for Vite (replacing esbuild and rollup)</li>
<li><strong><a href="https://github.com/oxc-project/oxc" target="_blank" rel="noopener noreferrer">Oxc</a></strong>: Similar to Biome: parser, linter, formatter, transpiler, minifier, etc</li>
<li><strong><a href="https://turbo.build/pack" target="_blank" rel="noopener noreferrer">Turbopack</a></strong>: New bundler powering the Next.js Compiler (<a href="https://areweturboyet.com/" target="_blank" rel="noopener noreferrer">status</a>)</li>
<li><strong><a href="https://lightningcss.dev/" target="_blank" rel="noopener noreferrer">Lightning CSS</a></strong>: New CSS parser, transformer, bunder, and minifier.</li>
</ul>
<p>Further, <a href="https://bun.sh/" target="_blank" rel="noopener noreferrer">Bun 1.0</a> was released, putting Zig on the map and working to speed up the entire JavaScript ecosystem.</p></div></div>
  </body>
</html>
