<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ianthehenry.com/posts/delaunay/">Original</a>
    <h1>Visualizing Delaunay Triangulation</h1>
    
    <div id="readability-page-1" class="page"><article>

<div><p>Take a look at this:</p>
<p><canvas id="bad-triangulation" width="384" height="256"><a href="https://ianthehenry.com/posts/delaunay/preview.e48ae4ff4031e60ea3a2ff790d6225cee4f48afb22940bb559d5d0276c3e4eb0.png"><picture>
<img src="https://ianthehenry.com/posts/delaunay/preview.e48ae4ff4031e60ea3a2ff790d6225cee4f48afb22940bb559d5d0276c3e4eb0.png" width="768" height="512"/></picture></a>
</canvas></p>
<p>This is a triangulation of a set of random points, such that all the points are connected to one another, all of the faces are triangles, and the edges include the convex hull of the points.</p>
<p>I would like to claim that this is not a very “good” triangulation. This algorithm tends to produce lots of long, slivery triangles, and a really uneven distribution of edge counts across different vertices – some vertices have <em>way</em> more edges than they need to.</p>
<p>Here’s a different triangulation. These are the exact same points, but I triangulated them smarter:</p>

<p>Isn’t that better? (Click to compare!)</p>
<p>Depending on your dice rolls you might still have a few slivers, usually around the outer perimeter, but I’m willing to bet that it’s a noticeable improvement over the first attempt.</p>
<p>This triangulation is called the <em>Delaunay triangulation</em>, and I would like to claim that it is a <em>very good</em> triangulation. It is, in fact, the <em>best possible</em> triangulation, for some definitions of “best.”</p>

<p>Okay, right, good question. You’ve made it this far in life without triangulating anything; why should you start now?</p>
<p>There are some obvious applications of triangulation algorithms in computer graphics, where everything is made out of triangles, but you knew that already and you are still <em>unmoved</em>.</p>
<p>Let’s try something else.</p>
<p>One textbook example of a non-graphics application of the Delaunay triangulation is <em>interpolating spatial data</em>.</p>
<p>Pretend, for a moment, that you’re a surveyor, and you’ve just finished measuring the elevation of a bunch of discrete points in some area. You sling your weird tripod thingy over your shoulder, and get ready to leave for the first vacation you’ve been able to take with your son since Terence left – when your boss appears at your door.</p>
<p>“What’s the elevation three clicks south of the north ridge, or however surveyor’s talk?” she asks.</p>
<p>You glance down at the oversized roll of mapping paper (?) on your desk, but you already know what you’ll find: you didn’t take a measurement three clicks south of the north ridge. But you <em>did</em> measure a few points nearby. <em>Perhaps</em>, you think, <em>I can construct a triangulation of these points, and then map it to a three-dimensional mesh, and use that to interpolate the elevations between nearby points.</em></p>
<p>You call your son to tell him that you’ll be a little late – it’s 1998 in this situation; texting isn’t a thing yet – and get to work.</p>
<p>But after the montage ends, you look upon your work, and find… oh.</p>

<p>Well that’s not going to work.</p>
<p>You pick up the phone to make another difficult call, but as your finger hovers over the rotary dial, you suddenly remember an incredibly long blog post that you read once – or that you will read; it’s 1998 still; this blog post hasn’t been published yet; it’s too late to change it now; just go with it – and you put the receiver back on the cradle.</p>
<p>And then you construct the <em>Delaunay</em> triangulation of the exact same points:</p>

<p>You shoot your boss a quick fax and get ready to hit the road. But as you stand up to leave, you see her standing in your doorway yet again.</p>
<p>“I just got off the corded phone with President Clinton,” she says. “Your triangles are so good that he’s appointing you Surveyor General. When you get back from vacation, <em>I’ll</em> be reporting to <em>you</em>.”</p>
<p>So that’s the first reason to learn about Delaunay triangulation.</p>
<p>Here’s another one: did this idea of interpolating “nearby” points remind you of anything else? Perhaps… the <a href="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi diagram</a>? If so, you are smart and attractive: one easy way to construct the Voronoi diagram is to calculate the Delaunay triangulation, because the Delaunay triangulation is the <em>dual</em> of the Voronoi diagram.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> Which is neat if you know what “dual” means. If you don’t know what dual means, keep reading! We’re going to talk about duals a lot later on.</p>
<p>So those are like… some <em>good</em> reasons to learn about Delaunay triangulations.</p>
<p>But I did not learn about Delaunay triangulations for a good reason.</p>
<p>I learned about Delaunay triangulations for the dumbest reason you can possibly imagine.</p>
<p>Here, it’s easier if I just show you.</p>

<p>I heard the phrase “smash that subscribe button” once, and after a brief moment’s existential crisis as I realized that I am now old enough that I recoil from the parlance of youth, I thought it would be funny to make a subscribe button that you could smash.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p>
<p>In case you already smashed that one, here’s another:</p>

<p>It’s kinda fun, right?</p>
<p>I’ve been meaning to add an email subscription button to my website for a while, and the thought of implementing this visual gag was enough of an incentive for me to actually get around to it.</p>
<p>I thought that a decent way to randomly fracture a shape into polygons would be to compute the <a href="https://en.wikipedia.org/wiki/Gabriel_graph">Gabriel graph</a> of a set of random points inside the button.<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> And the easiest way to compute the Gabriel graph is to compute the Delaunay triangulation and then remove a few edges from it. So that’s why I started looking into this in the first place.</p>

<p>But it was pretty hard! Although it’s easy to find explanations of Delaunay triangulation algorithms in vague, mathematical terms, I couldn’t find very many resources describing how to actually <em>implement</em> them. Like, I’m <em>trying</em> to construct an infinitely large triangle, but my computer keeps catching on fire – what do I do now, Professor Triangle?</p>
<p>So this is going to be an explanation for the “working programmer.” I’m going to describe a deceptively simple algorithm for Delaunay triangulation, and then the actual <em>edge</em>-cases that you have to think about when you try to implement it. And I’m going to do it without ever using the word “manifold.”</p>
<p>Starting… now.</p>

<p>The Delaunay triangulation is the triangulation that “maximizes the minimum angle in all of the triangles.”</p>
<p>Here’s, it’s easier if we look at an example:</p>
<a href="https://ianthehenry.com/posts/delaunay/fig1_hu39647200ef58c71feda4cd0ee9e9b4ef_120237_1536x1536_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/fig1_hu39647200ef58c71feda4cd0ee9e9b4ef_120237_768x768_fit_q75_h3_box_3.webp 768w,
/posts/delaunay/fig1_hu39647200ef58c71feda4cd0ee9e9b4ef_120237_1536x1536_fit_q75_h3_box_3.webp 1536w,
/posts/delaunay/fig1_hu39647200ef58c71feda4cd0ee9e9b4ef_120237_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/fig1_hu39647200ef58c71feda4cd0ee9e9b4ef_120237_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 768px"/><img srcset="/posts/delaunay/fig1_hu39647200ef58c71feda4cd0ee9e9b4ef_120237_768x768_fit_box_3.png 768w,
/posts/delaunay/fig1_hu39647200ef58c71feda4cd0ee9e9b4ef_120237_1536x1536_fit_box_3.png 1536w,
/posts/delaunay/fig1_hu39647200ef58c71feda4cd0ee9e9b4ef_120237_375x375_fit_box_3.png 375w,
/posts/delaunay/fig1_hu39647200ef58c71feda4cd0ee9e9b4ef_120237_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 768px" width="768" height="233"/></picture></a>
<p>Obviously all the angles of a triangle add up to 180°, but the triangles on the left get there with two very acute angles and one obtuse angle, while the triangles on the right have only acute angles – but they are not <em>as</em> acute as the acute angles on the left.</p>
<p>These are the only two triangulations of these four points, so the one on the right is the <em>optimal</em> triangulation according to our criteria – in other words, it is the <em>Delaunay triangulation</em> of this point set.</p>
<p>Here’s an equivalent, but more useful definition: the Delaunay triangulation is the triangulation such that, if you circumscribe a circle around every triangle, none of those circles will contain any other points.</p>

<p>(Click or tap to pause that, if the flashing is distracting.)</p>
<p>I’m going to make a potentially surprising claim: this is the <em>only</em> such triangulation of these points that satisfies that property. If you were to change any single edge – rearrange any of these triangles in <em>any</em> way – you would have at least one point inside another triangle’s circle territory.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></p>
<p>It’s worth noting that this is a <em>global</em> property of the triangulation – it’s a statement about every triangle and every point at the same time. Global properties are expensive to check and expensive to change, so we’d much rather focus on <em>local</em> property during our algorithm.</p>
<p>So let’s consider a single edge on the triangulation. Specifically an interior edge, not an edge around the perimeter.</p>
<a href="https://ianthehenry.com/posts/delaunay/fig2_hudc9ece0c9ae65c64fec5e1fa0ddcd5cc_164727_1536x1536_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/fig2_hudc9ece0c9ae65c64fec5e1fa0ddcd5cc_164727_768x768_fit_q75_h3_box_3.webp 768w,
/posts/delaunay/fig2_hudc9ece0c9ae65c64fec5e1fa0ddcd5cc_164727_1536x1536_fit_q75_h3_box_3.webp 1536w,
/posts/delaunay/fig2_hudc9ece0c9ae65c64fec5e1fa0ddcd5cc_164727_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/fig2_hudc9ece0c9ae65c64fec5e1fa0ddcd5cc_164727_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 768px"/><img srcset="/posts/delaunay/fig2_hudc9ece0c9ae65c64fec5e1fa0ddcd5cc_164727_768x768_fit_box_3.png 768w,
/posts/delaunay/fig2_hudc9ece0c9ae65c64fec5e1fa0ddcd5cc_164727_1536x1536_fit_box_3.png 1536w,
/posts/delaunay/fig2_hudc9ece0c9ae65c64fec5e1fa0ddcd5cc_164727_375x375_fit_box_3.png 375w,
/posts/delaunay/fig2_hudc9ece0c9ae65c64fec5e1fa0ddcd5cc_164727_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 768px" width="768" height="384"/></picture></a>
<p>There are two triangles on either side of this edge. Pick one at random, and draw a circle around it.</p>
<a href="https://ianthehenry.com/posts/delaunay/fig3_hu9dc11d71013b93ca08e26f3f42246ce6_230970_1536x1536_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/fig3_hu9dc11d71013b93ca08e26f3f42246ce6_230970_768x768_fit_q75_h3_box_3.webp 768w,
/posts/delaunay/fig3_hu9dc11d71013b93ca08e26f3f42246ce6_230970_1536x1536_fit_q75_h3_box_3.webp 1536w,
/posts/delaunay/fig3_hu9dc11d71013b93ca08e26f3f42246ce6_230970_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/fig3_hu9dc11d71013b93ca08e26f3f42246ce6_230970_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 768px"/><img srcset="/posts/delaunay/fig3_hu9dc11d71013b93ca08e26f3f42246ce6_230970_768x768_fit_box_3.png 768w,
/posts/delaunay/fig3_hu9dc11d71013b93ca08e26f3f42246ce6_230970_1536x1536_fit_box_3.png 1536w,
/posts/delaunay/fig3_hu9dc11d71013b93ca08e26f3f42246ce6_230970_375x375_fit_box_3.png 375w,
/posts/delaunay/fig3_hu9dc11d71013b93ca08e26f3f42246ce6_230970_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 768px" width="768" height="384"/></picture></a>
<p>Now check if the tip of the other triangle adjacent to this edge lies inside or outside of this circle. If it lies outside the circle, then this <em>edge</em> is “locally Delaunay.” If it lies inside the circle, then the edge is not “locally Delaunay.”</p>
<a href="https://ianthehenry.com/posts/delaunay/fig4_hu9dc11d71013b93ca08e26f3f42246ce6_238759_1536x1536_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/fig4_hu9dc11d71013b93ca08e26f3f42246ce6_238759_768x768_fit_q75_h3_box_3.webp 768w,
/posts/delaunay/fig4_hu9dc11d71013b93ca08e26f3f42246ce6_238759_1536x1536_fit_q75_h3_box_3.webp 1536w,
/posts/delaunay/fig4_hu9dc11d71013b93ca08e26f3f42246ce6_238759_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/fig4_hu9dc11d71013b93ca08e26f3f42246ce6_238759_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 768px"/><img srcset="/posts/delaunay/fig4_hu9dc11d71013b93ca08e26f3f42246ce6_238759_768x768_fit_box_3.png 768w,
/posts/delaunay/fig4_hu9dc11d71013b93ca08e26f3f42246ce6_238759_1536x1536_fit_box_3.png 1536w,
/posts/delaunay/fig4_hu9dc11d71013b93ca08e26f3f42246ce6_238759_375x375_fit_box_3.png 375w,
/posts/delaunay/fig4_hu9dc11d71013b93ca08e26f3f42246ce6_238759_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 768px" width="768" height="384"/></picture></a>
<p>In this case, the point is very much inside the circle, so we know that this is a <em>bad</em> edge. But if we then <em>flip</em> the edge so that it connects the other two points of our quadrangle, then this flipped edge is guaranteed to be locally Delaunay:</p>
<a href="https://ianthehenry.com/posts/delaunay/fig5_hucb02c66aee6f1a234ef86502f7cbc8bd_206555_1536x1536_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/fig5_hucb02c66aee6f1a234ef86502f7cbc8bd_206555_768x768_fit_q75_h3_box_3.webp 768w,
/posts/delaunay/fig5_hucb02c66aee6f1a234ef86502f7cbc8bd_206555_1536x1536_fit_q75_h3_box_3.webp 1536w,
/posts/delaunay/fig5_hucb02c66aee6f1a234ef86502f7cbc8bd_206555_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/fig5_hucb02c66aee6f1a234ef86502f7cbc8bd_206555_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 768px"/><img srcset="/posts/delaunay/fig5_hucb02c66aee6f1a234ef86502f7cbc8bd_206555_768x768_fit_box_3.png 768w,
/posts/delaunay/fig5_hucb02c66aee6f1a234ef86502f7cbc8bd_206555_1536x1536_fit_box_3.png 1536w,
/posts/delaunay/fig5_hucb02c66aee6f1a234ef86502f7cbc8bd_206555_375x375_fit_box_3.png 375w,
/posts/delaunay/fig5_hucb02c66aee6f1a234ef86502f7cbc8bd_206555_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 768px" width="768" height="384"/></picture></a>
<p>Notice that there might be <em>other</em> points that lie inside this circle that we <em>didn’t</em> check.</p>
<a href="https://ianthehenry.com/posts/delaunay/fig6_hucb02c66aee6f1a234ef86502f7cbc8bd_225291_1536x1536_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/fig6_hucb02c66aee6f1a234ef86502f7cbc8bd_225291_768x768_fit_q75_h3_box_3.webp 768w,
/posts/delaunay/fig6_hucb02c66aee6f1a234ef86502f7cbc8bd_225291_1536x1536_fit_q75_h3_box_3.webp 1536w,
/posts/delaunay/fig6_hucb02c66aee6f1a234ef86502f7cbc8bd_225291_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/fig6_hucb02c66aee6f1a234ef86502f7cbc8bd_225291_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 768px"/><img srcset="/posts/delaunay/fig6_hucb02c66aee6f1a234ef86502f7cbc8bd_225291_768x768_fit_box_3.png 768w,
/posts/delaunay/fig6_hucb02c66aee6f1a234ef86502f7cbc8bd_225291_1536x1536_fit_box_3.png 1536w,
/posts/delaunay/fig6_hucb02c66aee6f1a234ef86502f7cbc8bd_225291_375x375_fit_box_3.png 375w,
/posts/delaunay/fig6_hucb02c66aee6f1a234ef86502f7cbc8bd_225291_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 768px" width="768" height="384"/></picture></a>
<p>Because we only checked <em>local</em> Delaunayness, which is only concerned with this one particular point on the other side of the edge.</p>
<p>But here’s the trick: as long as <em>every edge</em> of the triangulation is locally Delaunay, the <em>entire triangulation</em> is a Delaunay triangulation. If this were a computational geometry class we’d spend the next ten minutes proving that statement, but for now I’ll just ask you to trust me on it.</p>
<p>Okay. So now that we know these things, we can start to imagine an algorithm. We want to make a triangulation such that all edges are “locally Delaunay.” If we started with <em>any</em> triangulation, we could just loop over all the edges, flipping any edges that are not locally Delaunay, and repeat until we don’t find any edges that need to be flipped.</p>
<p>Would that work? Or is there a chance that we’d get into an infinite loop, repeatedly flipping and un-flipping edges due to some weird complicated cycle? It’s not obvious to me that this is the case, but apparently it <em>does</em> work – but only in two dimensions! – and will eventually terminate after O(n<sup>2</sup>) flips.</p>
<p>But we can do better.</p>

<p>There are several “better” algorithms, but the one I’m going to describe comes from Guibas &amp; Stolfi’s seminal 1985 page-turner <a href="https://dl.acm.org/doi/10.1145/282918.282923">“Primitives for the Manipulation of General Subdivisions and the Computation of Voronoi Diagrams.&#34;</a></p>
<p>It’s an incremental algorithm, which means that you can start triangulating something even if you don’t know all of the points up-front, or you can use it to add new points to an existing Delaunay triangulation without having to re-triangulate it from scratch.</p>
<p>It’s the most popular algorithm that I came across, probably because it’s conceptually very easy to understand it.<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> But for all the explanations of it that exist on The Internet, I could not find a <em>single</em> resource that actually explains it in sufficient detail that you could go write the code for it! I had to cobble an understanding together from the original paper, lecture notes, actual lectures on YouTube – and ultimately by sitting down and working out some details myself.</p>
<p>So I’m going to try to correct that here.</p>
<p>But before I describe the algorithm, let me show it to you. You already know about “locally Delaunay” edges, which is the only real trick here – see if that’s sufficient to work out what the algorithm is doing.</p>
<p>Click to start/stop the animation, or drag the scrubber to move frame-by-frame.</p>


<p>Okay, so at a high level, the algorithm is deceptively simple:</p>
<p>Start with a single “infinitely large” triangle – although note that, in tonight’s performance, infinitely large triangle will be portrayed by appropriately-sized finite triangle, in order to make the visualization easier to understand.</p>
<p>Next, loop through your points, and add them into the triangulation one-by-one. Notice that our single giant triangle is, trivially, a valid Delaunay triangulation, which is a precondition that will hold at the beginning of every iteration.</p>
<p>Every time you add a point, split the triangle that contains it into three new triangles, and then check the locally Delaunay condition. You know that you <em>started</em> with a valid Delaunay triangulation, so you only have to look at the edges immediately surrounding the point that you added – the rest of the edges are already good. Flip any edges that are not locally Delaunay, and then check the edges adjacent to those flipped edges, because the act of flipping might have made them invalid. Then once you’re done checking and potentially flipping all of the “dirty” edges, you’re done! You have a valid Delaunay triangulation once again, and you’re ready for the next point.</p>
<p>Once you run out of points, just remove the infinitely large outer triangle – and the edges connected to it – and you have your final triangulation.</p>
<p>Easy, right?</p>

<p>Right. So that explanation might be sufficient if you’re a mathemetician, but if you actually tried to write the code for this, you’ll quickly run into questions like the following:</p>
<ol>
<li>I can’t actually construct an infinitely large bounding triangle – is it okay if I just construct a triangle large enough that it contains all of my points?</li>
<li>How am I supposed to find the triangle that contains my new point?</li>
<li>What if the new point lies on the edge of an existing triangle?</li>
<li>How am I supposed to do this “circle test” in the first place?</li>
<li>What edges do I actually need to check, once I’ve added my new edges?</li>
<li>Wait, how do I “flip” edges?</li>
<li>Wait, how do I even <em>model</em> edges? How do you even represent triangulations on a computer? I thought I could just model this as a graph, with vertices and edges and pointers, but it seems like I need to keep track of faces as well, and somehow this is a fundamentally different sort of thing than I’ve ever encountered before?</li>
</ol>
<p>Well, those were the questions I had, anyway.</p>
<p>And now I have the answers.</p>
<p>Let’s start with (3) because (3) is easy: if a point falls on an existing edge, you want to delete the edge, then create <em>four</em> new triangles instead of the normal three. The odds of this happening in a randomly generated point set is astronomically low, so here’s a hand-picked example that demonstrates what this looks like:<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup></p>


<p>This prompts a new question – “how do I delete an edge?” – but we’ll answer that at the same time we figure out how to flip edges.</p>
<p>The rest of the questions have… slightly more involved answers.</p>
<p>So let’s start with a fun one.</p>

<p>It’s very easy to check if a point is in a circle if you know the circle’s radius and center – you compare the distance from the point to the center of the circle against the circle’s radius.<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup> But we don’t know the circle’s center or radius; we only know these three points on its circumference.</p>
<p>Now, we could solve for the circle’s center and radius. There are <a href="https://math.stackexchange.com/questions/213658">many techniques for doing this</a>, but it’s relatively expensive – we don’t want to be taking square roots or doing any floating-point division here, because we’re going to be doing this point-in-circle test a lot.</p>
<p>Instead, Guibas &amp; Stolfi describe a really interesting technique that, when I first encountered it, made <em>absolutely no sense to me</em>.</p>
<p>Their technique is to calculate the determinant of this 4x4 matrix:</p>
<div>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>A<sub>x</sub></td>
<td>A<sub>y</sub></td>
<td>A<sub>x</sub><sup>2</sup> + A<sub>y</sub><sup>2</sup></td>
<td>1</td>
</tr>
<tr>
<td>B<sub>x</sub></td>
<td>B<sub>y</sub></td>
<td>B<sub>x</sub><sup>2</sup> + B<sub>y</sub><sup>2</sup></td>
<td>1</td>
</tr>
<tr>
<td>C<sub>x</sub></td>
<td>C<sub>y</sub></td>
<td>C<sub>x</sub><sup>2</sup> + C<sub>y</sub><sup>2</sup></td>
<td>1</td>
</tr>
<tr>
<td>P<sub>x</sub></td>
<td>P<sub>y</sub></td>
<td>P<sub>x</sub><sup>2</sup> + P<sub>y</sub><sup>2</sup></td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>(Where (A, B, C) are the points that define the circle, and P is the point to test.)</p>
<p>If the determinant is positive, the point is inside the circle. If it’s negative, the point is outside of the circle. If the determinant is zero, the point also lies on the circle.</p>
<p>Okay <em>what</em>.</p>
<p>So I don’t expect this to make sense to you. It didn’t make sense to me when I first heard it. But I’m going to try to explain it, in a little more detail than Guibas &amp; Stolfi explain it.</p>
<p>First off: we have a bunch of 2D points. We’re going to transform them into 3D points, by saying:</p>
<p>z = x<sup>2</sup> + y<sup>2</sup></p>
<p>This gives us a bunch of points in 3D. Specifically, it projects these points upwards onto this weird parabaloid shape:</p>

<p>(Click and drag the points to move them around.)</p>
<p>Okay. So that’s… something.</p>
<p>We know that three points in 3D space uniquely determine a plane (unless the points are co-linear). Planes seem simpler than circles. So you can maybe see how this is a step in the right direction. Let’s draw the plane:</p>

<p>Now, there’s something very interesting about this plane: if we look at the points where it intersects our parabaloid, we can see that it forms some kind of ellipse shape.</p>
<p>But if we look at it straight down from the top, we can see that the ellipse projects a perfect circle onto the XY plane.</p>


<p>Specifically, the circle that passes through all of our original points. So if we project the intersection of this plane with the parabaloid back down onto the XY plane, we get the circle that we actually care about:</p>

<p>Okaaaaay. So we’ve established a correspondence between this weird parabaloid shape and the circle in question. But let’s not forget why we’re doing this: we want to check if a point is inside this circle.</p>
<p>So let’s add another point.</p>

<p>Drag it around a little bit, and hopefully you can see where we’re going with this.</p>
<p>When we project that point upwards to the parabaloid, the point where it hits is either going to lie “under” or “over” our plane. And you can see that it’s going to hit “under” the plane <em>exactly</em> when the point is in the circle.</p>
<p>Okay! So this is interesting. This already suggests a very simple circle test algorithm: instead of finding the equation for the <em>circle</em>, find the equation for <em>this plane</em>. Then project our point upwards to both the plane and the parabaloid. If the projection up to the parabaloid is lower than the projection to the plane, then it’s inside the circle.</p>
<p>It’s easy to find the equation for a plane. Given three points (A, B, C), all we have to do is find any vector orthogonal to the plane, which we can do by taking the cross product of any two vectors on the plane:</p>
<p>N = (B - A) ⨯ (C - A)</p>
<p>And that, combined with any one of our original points, gives us an equation for the plane:</p>
<p>N<sub>x</sub>(x - A<sub>x</sub>) + N<sub>y</sub>(y - A<sub>y</sub>) + N<sub>z</sub>(z - A<sub>z</sub>) = 0</p>
<p>Which we can use to solve for z, giving us a function of x and y:</p>
<p>plane(x, y) = -(N<sub>x</sub>(x - A<sub>x</sub>) + N<sub>y</sub>(y - A<sub>y</sub>)) / N<sub>z</sub> + A<sub>z</sub></p>
<p>Okay, neat. Now if you recall our parabaloid equation:</p>
<p>parabaloid(x, y) = x<sup>2</sup> + y<sup>2</sup></p>
<p>Then all we have to do is compare the value of these two functions, and we have our circle test:</p>
<p>contains(x, y) = parabaloid(x, y) &lt; plane(x, y)</p>
<p>Okay. That makes sense, right?</p>
<p>But that’s <em>not</em> what Guibas &amp; Stolfi did.</p>
<p>Notice how there are no weird complicated matrices involved in that calculation. Yes, I did take a cross product, but that’s a pretty small amount of linear algebra to stomach compared to the determinant of a 4x4 matrix.</p>
<p>So.</p>
<p>Let’s return to Guibas &amp; Stolfi’s solution. Remember that they propose calculating the determinant of this matrix:</p>
<div>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>A<sub>x</sub></td>
<td>A<sub>y</sub></td>
<td>A<sub>x</sub><sup>2</sup> + A<sub>y</sub><sup>2</sup></td>
<td>1</td>
</tr>
<tr>
<td>B<sub>x</sub></td>
<td>B<sub>y</sub></td>
<td>B<sub>x</sub><sup>2</sup> + B<sub>y</sub><sup>2</sup></td>
<td>1</td>
</tr>
<tr>
<td>C<sub>x</sub></td>
<td>C<sub>y</sub></td>
<td>C<sub>x</sub><sup>2</sup> + C<sub>y</sub><sup>2</sup></td>
<td>1</td>
</tr>
<tr>
<td>P<sub>x</sub></td>
<td>P<sub>y</sub></td>
<td>P<sub>x</sub><sup>2</sup> + P<sub>y</sub><sup>2</sup></td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>Hmm.</p>
<p>I can understand 3x3 matrices. I’ve made my peace with them. I can think of them as transformations of 3D points to other 3D points. I’ve even almost, sort of, reluctantly made peace with determinants: I can understand the determinant of a 3x3 matrix as the rate by which it scales <em>volumes</em> when you transform shapes with it.</p>
<p>4x4 matrices… I have no intuition for them. I would expect the determinant of a 4x4 matrix to be some kind of scaler of hypervolumes. But since it’s only <em>barely</em> four-dimensional – all values on the “W axis” are 1 – we can intuit that we’re probably just dealing with plain volumes again.</p>
<p>And in fact that’s correct: this determinant is, in fact, the (oriented!) volume of the <a href="https://en.wikipedia.org/wiki/Parallelepiped">parallelepiped</a> that has these four points as corners.</p>

<p>Whoa, that’s… a lot. That’s kind of hard for me to parse. But in the same way that a parallelogram consists of (2! = 2) identical triangles, a parallelepiped consists of (3! = 6) identical tetrahedra. Let’s focus on just one of them:</p>

<p>So I have two things to say about this.</p>
<p>First off: notice that sometimes the tetrahedron is “inside out:” it has a negative volume, which I represent by changing the color of the wireframe. The crux of the point-in-circle test is checking the sign of that volume, and you can see if you move the free point around that it does invert when the free point passes into or out of the circle.</p>
<p>But! If you move the <em>other</em> points around, you can change whether positive or negative means “point in circle” or “point outside of circle.” Try it: swap the location of any two points on the circle, and watch as the sign flips, even though the circle remains the same.</p>
<p>This is because the orientation of the tetrahedron depends not only on the position of the free point relative to the three circle points, but <em>also</em> the orientation of the three circle points relative to one another. So this test <em>only works</em> if you make sure that you list the points (A, B, C) in a clockwise order. If you list them in counterclockwise order, the circle will be “inside out,” and the test will give you the wrong answer.</p>
<p>Which is pretty annoying.</p>
<p>So… I don’t like this test as much as the plane test <em>in general</em>. It seems more expensive<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup> to calculate the determinant than to calculate the equation of the plane, and it seems really annoying that you have to be careful that you provide the points in the right order or you’ll get the wrong result.</p>
<p>This isn’t actually a problem for us, because we’ll be use a fancy data structure for storing edges that ensures we can only provide points in the correct order.</p>
<p>Anyway.</p>
<p>Second thing:</p>
<p>A more obvious way to calculate the volume of a parallelepiped is to pick one point as the origin, and then to write the other three points relative to this origin. Then we have three points in three dimensions, which we can express as a square matrix:</p>
<div>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>A<sub>x</sub> - P<sub>x</sub></td>
<td>A<sub>y</sub> - P<sub>y</sub></td>
<td>(A<sub>x</sub><sup>2</sup> + A<sub>y</sub><sup>2</sup>) - (P<sub>x</sub><sup>2</sup> + P<sub>y</sub><sup>2</sup>)</td>
</tr>
<tr>
<td>B<sub>x</sub> - P<sub>x</sub></td>
<td>B<sub>y</sub> - P<sub>y</sub></td>
<td>(B<sub>x</sub><sup>2</sup> + B<sub>y</sub><sup>2</sup>) - (P<sub>x</sub><sup>2</sup> + P<sub>y</sub><sup>2</sup>)</td>
</tr>
<tr>
<td>C<sub>x</sub> - P<sub>x</sub></td>
<td>C<sub>y</sub> - P<sub>y</sub></td>
<td>(C<sub>x</sub><sup>2</sup> + C<sub>y</sub><sup>2</sup>) - (P<sub>x</sub><sup>2</sup> + P<sub>y</sub><sup>2</sup>)</td>
</tr>
</tbody>
</table>
</div>
<p>And the determinant of this matrix gives us the volume of the same parallelepiped as before, but in the simple straightforward way that we remember from that one linear algebra class we almost passed.</p>
<p>Now, the determinant of this matrix is exactly equal to the determinant of the 4x4 matrix that you get by padding each point with a 1. They’re just two ways of saying the same thing. You could verify that algebraically, but I feel like there’s probably some intuitive explanation of this fact, and understanding why this is would lead to a better understanding of determinants in general and maybe teach me how to use higher dimensional matrices to more easily perform calculations in lower dimensions. Like in some way the fourth point we added sort of acts as a new origin? At least in this particular case?</p>
<p>But look: I have to stop somewhere, or I’m never going to finish this blog post. And this is the place I decided to stop exploring Guibas &amp; Stolfi’s point-in-circle test.</p>
<p>For now.</p>

<p>Where were we?</p>
<ol>
<li>I can’t actually construct an infinitely large bounding triangle – is it okay if I just construct a triangle large enough to contain all of my points?</li>
<li>How am I supposed to find the triangle that contains my new point?</li>
<li><del>What if the new point lies on the edge of an existing triangle?</del></li>
<li><del>How am I supposed to do this circle test in the first place?</del></li>
<li>What edges do I actually need to check, once I’ve added my new edges?</li>
<li>Wait, how do I “flip” edges?</li>
<li>Wait, how do I even <em>model</em> edges? How do you even represent triangulations on a computer? I thought I could just model this as a graph, with vertices and edges and pointers, but it seems like I need to keep track of faces as well, and somehow this is a fundamentally different sort of thing than I’ve ever encountered before?</li>
</ol>
<p>Okay. Let’s talk about (7) next, because you’re losing steam and it’s very interesting. The other questions are pretty specific to this one algorithm that you don’t actually care about – although I appreciate how polite you are being – but this one is broadly applicable to lots of graph-related, mesh-related, and computational geometry-related problems.</p>

<p>Okay, so you know how to represent a graph, right? You have some <code>Node</code> or <code>Vertex</code> objects, and you have some <code>Edge</code> objects, and vertices have pointers to their edges and edges have pointers to their vertices. Or you store an adjacency matrix; that’s a thing I’ve heard of.</p>
<p>This works great when you’re dealing with graphs in the abstract – if all you’re doing is Dijkstra’s algorithm or finding biconnected components or whatever, this simple representation works fine.</p>
<p>But in this case we’re also concerned with <em>faces</em> – when we flip an edge, we need to know the specific faces we’re flipping it on, so we don’t do something illegal:</p>
<a href="https://ianthehenry.com/posts/delaunay/fig7_hu1956f63c751c3fbd837aeea7394512b2_127528_1536x1536_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/fig7_hu1956f63c751c3fbd837aeea7394512b2_127528_768x768_fit_q75_h3_box_3.webp 768w,
/posts/delaunay/fig7_hu1956f63c751c3fbd837aeea7394512b2_127528_1536x1536_fit_q75_h3_box_3.webp 1536w,
/posts/delaunay/fig7_hu1956f63c751c3fbd837aeea7394512b2_127528_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/fig7_hu1956f63c751c3fbd837aeea7394512b2_127528_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 768px"/><img srcset="/posts/delaunay/fig7_hu1956f63c751c3fbd837aeea7394512b2_127528_768x768_fit_box_3.png 768w,
/posts/delaunay/fig7_hu1956f63c751c3fbd837aeea7394512b2_127528_1536x1536_fit_box_3.png 1536w,
/posts/delaunay/fig7_hu1956f63c751c3fbd837aeea7394512b2_127528_375x375_fit_box_3.png 375w,
/posts/delaunay/fig7_hu1956f63c751c3fbd837aeea7394512b2_127528_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 768px" width="768" height="384"/></picture></a>
<p>The obvious-to-me way to do this is to add another object to the mix: model <code>Face</code>s explicitly, and have edges keep track of the faces they’re a part of, and every time you change anything about the graph you have to make sure to keep the faces and edges and vertices all in sync. I actually tried this, during my first forays into triangulation. It was awful. Just a case study on how denormalization will ruin your day. We’re not going to do that.</p>
<p>Fortunately, Guibas &amp; Stolfi describe a <em>very clever</em> alternate representation called the “quad-edge” data structure.</p>
<p>To understand the quad-edge structure, you first have to understand the idea of the <a href="https://en.wikipedia.org/wiki/Dual_graph">dual</a> of a graph. Very loosely, if you take a drawing of a graph<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup> and put a vertex in the middle of every face, and then connect all of the adjacent “face-vertices” with edges, you’ll have the dual graph. It’s easier to understand with a picture:</p>
<a href="https://ianthehenry.com/posts/delaunay/duals_hu2c428b58352ac6a41586acbeaea16ef5_180889_1536x1536_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/duals_hu2c428b58352ac6a41586acbeaea16ef5_180889_768x768_fit_q75_h3_box_3.webp 768w,
/posts/delaunay/duals_hu2c428b58352ac6a41586acbeaea16ef5_180889_1536x1536_fit_q75_h3_box_3.webp 1536w,
/posts/delaunay/duals_hu2c428b58352ac6a41586acbeaea16ef5_180889_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/duals_hu2c428b58352ac6a41586acbeaea16ef5_180889_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 768px"/><img srcset="/posts/delaunay/duals_hu2c428b58352ac6a41586acbeaea16ef5_180889_768x768_fit_box_3.png 768w,
/posts/delaunay/duals_hu2c428b58352ac6a41586acbeaea16ef5_180889_1536x1536_fit_box_3.png 1536w,
/posts/delaunay/duals_hu2c428b58352ac6a41586acbeaea16ef5_180889_375x375_fit_box_3.png 375w,
/posts/delaunay/duals_hu2c428b58352ac6a41586acbeaea16ef5_180889_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 768px" width="768" height="384"/></picture></a>
<p>That’s actually a simplification – I’m missing one face from all of those graphs: the outer face, the inside-out face bounded by the outside of the graphs. Here are the <em>actual</em> duals:</p>
<a href="https://ianthehenry.com/posts/delaunay/full-duals_hu2f11216529d2062c89f8f5bbd7bc723a_298626_1536x1536_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/full-duals_hu2f11216529d2062c89f8f5bbd7bc723a_298626_768x768_fit_q75_h3_box_3.webp 768w,
/posts/delaunay/full-duals_hu2f11216529d2062c89f8f5bbd7bc723a_298626_1536x1536_fit_q75_h3_box_3.webp 1536w,
/posts/delaunay/full-duals_hu2f11216529d2062c89f8f5bbd7bc723a_298626_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/full-duals_hu2f11216529d2062c89f8f5bbd7bc723a_298626_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 768px"/><img srcset="/posts/delaunay/full-duals_hu2f11216529d2062c89f8f5bbd7bc723a_298626_768x768_fit_box_3.png 768w,
/posts/delaunay/full-duals_hu2f11216529d2062c89f8f5bbd7bc723a_298626_1536x1536_fit_box_3.png 1536w,
/posts/delaunay/full-duals_hu2f11216529d2062c89f8f5bbd7bc723a_298626_375x375_fit_box_3.png 375w,
/posts/delaunay/full-duals_hu2f11216529d2062c89f8f5bbd7bc723a_298626_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 768px" width="768" height="384"/></picture></a>
<p>But since that is a <em>mess</em> to look at, I will instead adapt the following shorthand, and trust that you can imagine the outer face:</p>
<a href="https://ianthehenry.com/posts/delaunay/short-duals_hu2f11216529d2062c89f8f5bbd7bc723a_212628_1536x1536_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/short-duals_hu2f11216529d2062c89f8f5bbd7bc723a_212628_768x768_fit_q75_h3_box_3.webp 768w,
/posts/delaunay/short-duals_hu2f11216529d2062c89f8f5bbd7bc723a_212628_1536x1536_fit_q75_h3_box_3.webp 1536w,
/posts/delaunay/short-duals_hu2f11216529d2062c89f8f5bbd7bc723a_212628_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/short-duals_hu2f11216529d2062c89f8f5bbd7bc723a_212628_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 768px"/><img srcset="/posts/delaunay/short-duals_hu2f11216529d2062c89f8f5bbd7bc723a_212628_768x768_fit_box_3.png 768w,
/posts/delaunay/short-duals_hu2f11216529d2062c89f8f5bbd7bc723a_212628_1536x1536_fit_box_3.png 1536w,
/posts/delaunay/short-duals_hu2f11216529d2062c89f8f5bbd7bc723a_212628_375x375_fit_box_3.png 375w,
/posts/delaunay/short-duals_hu2f11216529d2062c89f8f5bbd7bc723a_212628_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 768px" width="768" height="384"/></picture></a>
<p>Okay, so duals. Neat. Who cares?</p>
<p>Well, the high level idea of the “quad-edge” structure is that you break every undirected edge <code>A &lt;-&gt; B</code> of your mesh into four separate <em>directed</em> edges: one that represents <code>A -&gt; B</code>, one that represents <code>B -&gt; A</code>, and two others that represent the directed <em>dual</em> edges of the faces on either side of the edge. So for each undirected edge on our graph, we would have four directed edges like so:</p>
<a href="https://ianthehenry.com/posts/delaunay/quad-edge_hudc65ac562d632b0fedef557017d3acae_129840_1536x1536_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/quad-edge_hudc65ac562d632b0fedef557017d3acae_129840_768x768_fit_q75_h3_box_3.webp 768w,
/posts/delaunay/quad-edge_hudc65ac562d632b0fedef557017d3acae_129840_1536x1536_fit_q75_h3_box_3.webp 1536w,
/posts/delaunay/quad-edge_hudc65ac562d632b0fedef557017d3acae_129840_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/quad-edge_hudc65ac562d632b0fedef557017d3acae_129840_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 768px"/><img srcset="/posts/delaunay/quad-edge_hudc65ac562d632b0fedef557017d3acae_129840_768x768_fit_box_3.png 768w,
/posts/delaunay/quad-edge_hudc65ac562d632b0fedef557017d3acae_129840_1536x1536_fit_box_3.png 1536w,
/posts/delaunay/quad-edge_hudc65ac562d632b0fedef557017d3acae_129840_375x375_fit_box_3.png 375w,
/posts/delaunay/quad-edge_hudc65ac562d632b0fedef557017d3acae_129840_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 768px" width="768" height="384"/></picture></a>
<p>So the quad-edge structure represents the structure of a graph <em>and its dual</em> at the same time: a quad-edge is just a list of these four directed edges.</p>
<p>I was very confused about this when I was reading Guibas &amp; Stolfi.<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup> They never give a type definition for quad-edges, and they describe operations on quad-edges that don’t <em>actually</em> apply to quad-edges – they apply to the directed edges that comprise quad-edges. Guibas &amp; Stolfi call these “quad-edge refs,” but because that is confusing and clumsy I will call them “quarter-edges” from here on out.</p>
<p>The paper is hard to follow sometimes because it uses the term “edge” a lot, which could mean one of <em>three different things:</em></p>
<ul>
<li>A logical edge on a graph – that is, the normal sense of the word.</li>
<li>A “quad-edge,” which <em>represents</em> a single logical edge, and consists of four individual parts.</li>
<li>A “quarter-edge” (my term) or “quad-edge ref” (their term), which is one of the individual parts of a quad-edge.</li>
</ul>
<p>Now here’s the trick: whenever they say “edge” or “quad-edge,” they <em>actually</em> mean “quarter-edge.” For example:</p>
<blockquote>
<p>The second operator is denoted by <code>Splice[a, b]</code> and takes as parameters two edges <code>a</code> and <code>b</code>, returning no value.</p>
</blockquote>
<p>Splice is actually an operation on <em>quarter-edges</em>. If you try to make sense of it as an operation on <em>quad-edges</em>, you will have a bad time and be very confused.</p>
<p>Anyway.</p>
<p>Digression over.</p>
<p>Guibas &amp; Stolfi don’t prescribe a concrete representation, but here’s a straightforward way<sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup> to represent the quad-edge as they describe it:</p>
<div><pre tabindex="0"><code data-lang="c"><span>typedef</span> <span>struct</span> <span>{</span>
    <span>quarter_edge</span> <span>refs</span><span>[</span><span>4</span><span>];</span>
<span>}</span> <span>quad_edge</span><span>;</span>

<span>typedef</span> <span>struct</span> <span>{</span>
    <span>quad_edge</span> <span>*</span><span>my_quad_edge</span><span>;</span>
    <span>int</span> <span>my_index</span><span>;</span>

    <span>quad_edge</span> <span>*</span><span>next_quad_edge</span><span>;</span>
    <span>int</span> <span>next_index</span><span>;</span>

    <span>void</span> <span>*</span><span>data</span><span>;</span>
<span>}</span> <span>quarter_edge</span><span>;</span>

<span>quarter_edge</span> <span>*</span><span>rot</span><span>(</span><span>quarter_edge</span> <span>*</span><span>edge</span><span>)</span> <span>{</span>
    <span>return</span> <span>edge</span><span>-&gt;</span><span>my_quad_edge</span><span>-&gt;</span><span>refs</span><span>[(</span><span>edge</span><span>-&gt;</span><span>my_index</span> <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>4</span><span>];</span>
<span>}</span>

<span>quarter_edge</span> <span>*</span><span>sym</span><span>(</span><span>quarter_edge</span> <span>*</span><span>edge</span><span>)</span> <span>{</span>
    <span>return</span> <span>edge</span><span>-&gt;</span><span>my_quad_edge</span><span>-&gt;</span><span>refs</span><span>[(</span><span>edge</span><span>-&gt;</span><span>my_index</span> <span>+</span> <span>2</span><span>)</span> <span>%</span> <span>4</span><span>];</span>
<span>}</span>

<span>quarter_edge</span> <span>*</span><span>tor</span><span>(</span><span>quarter_edge</span> <span>*</span><span>edge</span><span>)</span> <span>{</span>
    <span>return</span> <span>edge</span><span>-&gt;</span><span>my_quad_edge</span><span>-&gt;</span><span>refs</span><span>[(</span><span>edge</span><span>-&gt;</span><span>my_index</span> <span>+</span> <span>3</span><span>)</span> <span>%</span> <span>4</span><span>];</span>
<span>}</span>

<span>quarter_edge</span> <span>*</span><span>next</span><span>(</span><span>quarter_edge</span> <span>*</span><span>edge</span><span>)</span> <span>{</span>
    <span>return</span> <span>edge</span><span>-&gt;</span><span>next_quad_edge</span><span>-&gt;</span><span>refs</span><span>[</span><span>edge</span><span>-&gt;</span><span>next_index</span><span>];</span>
<span>}</span>
</code></pre></div><p><code>rot</code> (“rotate”), <code>sym</code> (“symmetric edge”), and <code>tor</code> (“rotate the other way”) are functions that bring you to the other three quarter-edges on the same <code>QuadEdge</code>. <code>next</code> is a pointer that allows you to navigate around to adjacent <code>QuadEdge</code>s in the structure. (We’ll come back to this in a minute.)</p>
<p>So you can see that a quad-edge isn’t really a thing; it’s just a bundle of four other things. And in fact I think it’s <em>much simpler</em> if we just pretend that quad-edges don’t exist, and define everything in terms of quarter edges:</p>
<div><pre tabindex="0"><code data-lang="c"><span>typedef</span> <span>struct</span> <span>{</span>
    <span>void</span> <span>*</span><span>data</span><span>;</span>
    <span>quarter_edge</span> <span>*</span><span>next</span><span>;</span>
    <span>quarter_edge</span> <span>*</span><span>rot</span><span>;</span>
<span>}</span> <span>quarter_edge</span><span>;</span>

<span>quarter_edge</span> <span>*</span><span>rot</span><span>(</span><span>quarter_edge</span> <span>*</span><span>edge</span><span>)</span> <span>{</span>
    <span>return</span> <span>edge</span><span>-&gt;</span><span>rot</span><span>;</span>
<span>}</span>

<span>quarter_edge</span> <span>*</span><span>sym</span><span>(</span><span>quarter_edge</span> <span>*</span><span>edge</span><span>)</span> <span>{</span>
    <span>return</span> <span>edge</span><span>-&gt;</span><span>rot</span><span>-&gt;</span><span>rot</span><span>;</span>
<span>}</span>

<span>quarter_edge</span> <span>*</span><span>tor</span><span>(</span><span>quarter_edge</span> <span>*</span><span>edge</span><span>)</span> <span>{</span>
    <span>return</span> <span>edge</span><span>-&gt;</span><span>rot</span><span>-&gt;</span><span>rot</span><span>-&gt;</span><span>rot</span><span>;</span>
<span>}</span>
</code></pre></div><p>Whenever we create these, we can just create four of them at a time, and set their <code>rot</code> pointers in a cycle such that <code>edge == edge-&gt;rot-&gt;rot-&gt;rot-&gt;rot</code>. This representation is slightly less efficient, but it’s <em>much</em> simpler, especially when we start manipulating it.</p>
<p>Okay, with that out of the way: what is <code>next</code>?</p>
<p><code>next</code> points to a quarter-edge that:</p>
<ol>
<li>Has the same starting point (be it a vertex or a face) as this quarter-edge.</li>
<li>Lies immediately counter-clockwise of this quarter-edge.</li>
</ol>
<p>This is all a little abstract, so let’s make it concrete. This is a little demo that lets you play with the quad-edge structure: the “current” edge is highlighted in yellow, and you can traverse the structure by pressing WASD (if you have a keyboard).</p>
<ul>
<li><code>W</code> <code>sym</code></li>
<li><code>A</code> <code>tor</code></li>
<li><code>S</code> <code>next</code></li>
<li><code>D</code> <code>rot</code></li>
</ul>
<p>Notice that the <code>WAD</code> keys will only move you between each of the four quarter-edges of the current quad-edge, while <code>S</code> will allow you to move to other edges.</p>


<p>(Notice that, because the outer face is “inside out,” pressing <code>S</code> while on the outer face will actually move <em>clockwise</em> around the perimeter.)</p>
<p>You can compose these operations predictably to navigate around. For example, to go to the “previous” edge that shares the same point – to navigate clockwise, in other words – press <code>DSD</code>. To navigate around the triangle to the left of the current edge, press <code>ASD</code> repeatedly. To navigate around the triangle to the right of the edge, press <code>WS</code>.</p>
<p>We’ll be doing some of these a lot, so we’ll give them names:</p>
<pre><code>prev = rot.next.rot
lnext = tor.next.rot
</code></pre>
<p>The last thing that I didn’t explain is the <code>data</code> pointer.</p>
<p>The <code>data</code> pointer stores arbitrary information about the vertex <em>or face</em> at the beginning of each directed quarter-edge. For our purposes, we’ll use <code>data</code> to store the actual location in space of each vertex, and we won’t store anything on faces. So note that, since there are multiple directed edges out of each vertex, all quarter-edges that you reach by traversing the <code>next</code> pointers – by pressing <code>S</code>, in the demo – will have identical <code>data</code> pointers.</p>
<p>One thing that’s a little weird about this representation is that each “directed edge” doesn’t actually store anything about its destination. Its <code>data</code> pointer only contains its origin, and the destination of the edge is implicit from its sibling quarter-edges. Specifically, each quarter-edge represents a directed edge from <code>edge.data</code> to <code>edge.sym.data</code>.</p>
<p>We’ll refer to <code>edge.sym.data</code> a lot, so I’m going to give it a shorthand as well:</p>
<pre><code>dest = sym.data
</code></pre>
<p>So: that’s it! That’s the structure.</p>
<p>How do we… use it?</p>
<p>Well first we need to be able to create quarter-edges – which we always do in groups of four:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>function</span> <span>makeQuadEdge</span><span>(</span><span>start</span><span>,</span> <span>end</span><span>)</span> <span>{</span>
  <span>const</span> <span>startEnd</span> <span>=</span> <span>new</span> <span>QuarterEdge</span><span>();</span>
  <span>const</span> <span>leftRight</span> <span>=</span> <span>new</span> <span>QuarterEdge</span><span>();</span>
  <span>const</span> <span>endStart</span> <span>=</span> <span>new</span> <span>QuarterEdge</span><span>();</span>
  <span>const</span> <span>rightLeft</span> <span>=</span> <span>new</span> <span>QuarterEdge</span><span>();</span>

  <span>startEnd</span><span>.</span><span>data</span> <span>=</span> <span>start</span><span>;</span>
  <span>endStart</span><span>.</span><span>data</span> <span>=</span> <span>end</span><span>;</span>

  <span>startEnd</span><span>.</span><span>rot</span> <span>=</span> <span>leftRight</span><span>;</span>
  <span>leftRight</span><span>.</span><span>rot</span> <span>=</span> <span>endStart</span><span>;</span>
  <span>endStart</span><span>.</span><span>rot</span> <span>=</span> <span>rightLeft</span><span>;</span>
  <span>rightLeft</span><span>.</span><span>rot</span> <span>=</span> <span>startEnd</span><span>;</span>

  <span>// normal edges are on different vertices,
</span><span></span>  <span>// and initially they are the only edges out
</span><span></span>  <span>// of each vertex
</span><span></span>  <span>startEnd</span><span>.</span><span>next</span> <span>=</span> <span>startEnd</span><span>;</span>
  <span>endStart</span><span>.</span><span>next</span> <span>=</span> <span>endStart</span><span>;</span>

  <span>// but dual edges share the same face,
</span><span></span>  <span>// so they point to one another
</span><span></span>  <span>leftRight</span><span>.</span><span>next</span> <span>=</span> <span>rightLeft</span><span>;</span>
  <span>rightLeft</span><span>.</span><span>next</span> <span>=</span> <span>leftRight</span><span>;</span>

  <span>return</span> <span>startEnd</span><span>;</span>
<span>}</span>
</code></pre></div><p>That represents a single edge that cuts through a single face – the face on the left and right of it are the same, and it exists on its own, connected to nothing. Guibas &amp; Stolfi have a nice illustration of what this means topologically:</p>
<figure>
<a href="https://ianthehenry.com/posts/delaunay/make-edge_hu98aad74021586d460597b88bf4cc6098_38299_1502x1502_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/make-edge_hu98aad74021586d460597b88bf4cc6098_38299_751x751_fit_q75_h3_box_3.webp 751w,
/posts/delaunay/make-edge_hu98aad74021586d460597b88bf4cc6098_38299_1502x1502_fit_q75_h3_box_3.webp 1502w,
/posts/delaunay/make-edge_hu98aad74021586d460597b88bf4cc6098_38299_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/make-edge_hu98aad74021586d460597b88bf4cc6098_38299_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 751px"/><img srcset="/posts/delaunay/make-edge_hu98aad74021586d460597b88bf4cc6098_38299_751x751_fit_box_3.png 751w,
/posts/delaunay/make-edge_hu98aad74021586d460597b88bf4cc6098_38299_1502x1502_fit_box_3.png 1502w,
/posts/delaunay/make-edge_hu98aad74021586d460597b88bf4cc6098_38299_375x375_fit_box_3.png 375w,
/posts/delaunay/make-edge_hu98aad74021586d460597b88bf4cc6098_38299_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 751px" width="751" height="249"/></picture></a>
<figcaption>
© 1985 ACM 0730-0301/85/0400-0074 — ACM Transactions on Graphics, Vol. 4, No. 2, April 1985</figcaption>
</figure>
<p>Simple.</p>
<p>The next operation lets us connect edges together, or tear them apart. It’s called <code>splice</code>, and it’s probably just as simple. Let’s see how Guibas &amp; Stolfi explain it:</p>
<figure>
<a href="https://ianthehenry.com/posts/delaunay/splice_hud5797dc177ab7bdd451c0078f297cf83_112422_1430x1430_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/splice_hud5797dc177ab7bdd451c0078f297cf83_112422_715x715_fit_q75_h3_box_3.webp 715w,
/posts/delaunay/splice_hud5797dc177ab7bdd451c0078f297cf83_112422_1430x1430_fit_q75_h3_box_3.webp 1430w,
/posts/delaunay/splice_hud5797dc177ab7bdd451c0078f297cf83_112422_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/splice_hud5797dc177ab7bdd451c0078f297cf83_112422_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 715px"/><img srcset="/posts/delaunay/splice_hud5797dc177ab7bdd451c0078f297cf83_112422_715x715_fit_box_3.png 715w,
/posts/delaunay/splice_hud5797dc177ab7bdd451c0078f297cf83_112422_1430x1430_fit_box_3.png 1430w,
/posts/delaunay/splice_hud5797dc177ab7bdd451c0078f297cf83_112422_375x375_fit_box_3.png 375w,
/posts/delaunay/splice_hud5797dc177ab7bdd451c0078f297cf83_112422_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 715px" width="715" height="350"/></picture></a>
<figcaption>
© 1985 ACM 0730-0301/85/0400-0074 — ACM Transactions on Graphics, Vol. 4, No. 2, April 1985</figcaption>
</figure>
<p>Aaaah! Oh dear. Topology is happening to us, and it doesn’t feel good.</p>
<p>But the implementation is so simple:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>function</span> <span>splice</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span>
  <span>swapNexts</span><span>(</span><span>a</span><span>.</span><span>next</span><span>.</span><span>rot</span><span>,</span> <span>b</span><span>.</span><span>next</span><span>.</span><span>rot</span><span>);</span>
  <span>swapNexts</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>);</span>
<span>}</span>

<span>function</span> <span>swapNexts</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span>
  <span>const</span> <span>anext</span> <span>=</span> <span>a</span><span>.</span><span>next</span><span>;</span>
  <span>a</span><span>.</span><span>next</span> <span>=</span> <span>b</span><span>.</span><span>next</span><span>;</span>
  <span>b</span><span>.</span><span>next</span> <span>=</span> <span>anext</span><span>;</span>
<span>}</span>
</code></pre></div><p>We’re just swapping a couple of pointers – it <em>seems</em> like it should be simple to understand. But it’s very difficult to intuit the effect that this actually has on our mesh.</p>
<p>Let’s use it in a sentence. <code>splice</code> is a low-level primitive operation, and we’ll never actually call it directly in our algorithm. Instead, we’ll use it to build higher-level operations, and seeing how these operations use <code>splice</code> under the hood is probably the best way to gain intuition for how it works.</p>
<p>So the first thing we’ll need to do is construct a bounding triangle:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>function</span> <span>makeTriangle</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>)</span> <span>{</span>
  <span>const</span> <span>ab</span> <span>=</span> <span>makeQuadEdge</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>);</span>
  <span>const</span> <span>bc</span> <span>=</span> <span>makeQuadEdge</span><span>(</span><span>b</span><span>,</span> <span>c</span><span>);</span>
  <span>const</span> <span>ca</span> <span>=</span> <span>makeQuadEdge</span><span>(</span><span>c</span><span>,</span> <span>a</span><span>);</span>

  <span>splice</span><span>(</span><span>ab</span><span>.</span><span>sym</span><span>,</span> <span>bc</span><span>);</span>
  <span>splice</span><span>(</span><span>bc</span><span>.</span><span>sym</span><span>,</span> <span>ca</span><span>);</span>
  <span>splice</span><span>(</span><span>ca</span><span>.</span><span>sym</span><span>,</span> <span>ab</span><span>);</span>

  <span>return</span> <span>ab</span><span>;</span>
<span>}</span>
</code></pre></div><p>Then we’ll need to know how to add new edges:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>function</span> <span>connect</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span>
  <span>const</span> <span>newEdge</span> <span>=</span> <span>makeQuadEdge</span><span>(</span><span>a</span><span>.</span><span>dest</span><span>,</span> <span>b</span><span>.</span><span>data</span><span>);</span>
  <span>splice</span><span>(</span><span>newEdge</span><span>,</span> <span>a</span><span>.</span><span>lnext</span><span>);</span>
  <span>splice</span><span>(</span><span>newEdge</span><span>.</span><span>sym</span><span>,</span> <span>b</span><span>);</span>
  <span>return</span> <span>newEdge</span><span>;</span>
<span>}</span>
</code></pre></div><p>And how to remove edges:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>function</span> <span>sever</span><span>(</span><span>edge</span><span>)</span> <span>{</span>
  <span>splice</span><span>(</span><span>edge</span><span>,</span> <span>edge</span><span>.</span><span>prev</span><span>);</span>
  <span>splice</span><span>(</span><span>edge</span><span>.</span><span>sym</span><span>,</span> <span>edge</span><span>.</span><span>sym</span><span>.</span><span>prev</span><span>);</span>
<span>}</span>
</code></pre></div><p>And lastly we’ll need to “flip” the diagonal edge of a quadrangle.</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>function</span> <span>flip</span><span>(</span><span>edge</span><span>)</span> <span>{</span>
  <span>const</span> <span>a</span> <span>=</span> <span>edge</span><span>.</span><span>prev</span><span>;</span>
  <span>const</span> <span>b</span> <span>=</span> <span>edge</span><span>.</span><span>sym</span><span>.</span><span>prev</span><span>;</span>
  <span>splice</span><span>(</span><span>edge</span><span>,</span> <span>a</span><span>);</span>
  <span>splice</span><span>(</span><span>edge</span><span>.</span><span>sym</span><span>,</span> <span>b</span><span>);</span>
  <span>splice</span><span>(</span><span>edge</span><span>,</span> <span>a</span><span>.</span><span>lnext</span><span>);</span>
  <span>splice</span><span>(</span><span>edge</span><span>.</span><span>sym</span><span>,</span> <span>b</span><span>.</span><span>lnext</span><span>);</span>
  <span>edge</span><span>.</span><span>data</span> <span>=</span> <span>a</span><span>.</span><span>dest</span><span>;</span>
  <span>edge</span><span>.</span><span>dest</span> <span>=</span> <span>b</span><span>.</span><span>dest</span><span>;</span>
<span>}</span>
</code></pre></div><p>And that’s it! Those are the only operations we need.</p>
<p>I think the easiest way to understand <code>splice</code> is to work through these high-level operations and convince yourself that this series of pointer updates gives you the <code>QuarterEdge</code> structure that you want. But also: you can just trust me. You aren’t actually trying to implement this.</p>

<p>Almost!</p>
<ol>
<li>I can’t actually construct an infinitely large bounding triangle – is it okay if I just construct a triangle large enough to contain all of my points?</li>
<li>How am I supposed to find the triangle that contains my new point?</li>
<li><del>What if the new point lies on the edge of an existing triangle?</del></li>
<li><del>How am I supposed to do this circle test in the first place?</del></li>
<li>What edges do I actually need to check, once I’ve added my new edges?</li>
<li><del>Wait, how do I “flip” edges?</del></li>
<li><del>Wait, how do I even <em>model</em> edges? How do you even represent triangulations on a computer? I thought I could just model this as a graph, with vertices and edges and pointers, but it seems like I need to keep track of faces as well, and somehow this is a fundamentally different sort of thing than I’ve ever encountered before?</del></li>
</ol>
<p>Now that you understand the quad-edge/quarter-edge structure, we can talk about (2). It’s clever! It’s not what you’re expecting!</p>

<p>So in order to add a new point to your mesh, you first need to locate the triangle that contains that point.</p>
<p>There’s an easy, inefficient way to do this: loop through every triangle, check if your point is inside this triangle, and return as soon as you find one. We’re not going to do that, but it’s useful to talk about <em>how</em> to do it. Specifically: how do you determine if a point lies inside a triangle?</p>
<p>The trick we’re going to use is another linear algebra thing. If you could follow the point-in-circle test, this is going to be easy.</p>
<p>Given a triangle <code>ABC</code>, and another point <code>P</code> that you want to test, construct three new triangles: <code>ABP</code>, <code>BCP</code>, and <code>CAP</code>. Then calculate the sign of the oriented area of each of these new triangles. You can find the oriented area of a triangle <code>ABC</code> by taking the determinant of this matrix:</p>

<p>(That actually gives you the area of the parallelogram consisting of two copies of the triangle, but since we only care about the sign, we won’t bother to divide it by two.)</p>
<p>The sign of the oriented area tells you whether your triangle’s vertices are listed in clockwise (negative) or counter-clockwise (positive) order. If all three of <code>ABP</code>, <code>BCP</code>, and <code>CAP</code> are counter-clockwise, then the point is inside the triangle.<sup id="fnref:12"><a href="#fn:12" role="doc-noteref">12</a></sup></p>
<a href="https://ianthehenry.com/posts/delaunay/winding-test_hud3a68137b279523b9858e27bdd6d6f7c_105986_1384x1384_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/winding-test_hud3a68137b279523b9858e27bdd6d6f7c_105986_692x692_fit_q75_h3_box_3.webp 692w,
/posts/delaunay/winding-test_hud3a68137b279523b9858e27bdd6d6f7c_105986_1384x1384_fit_q75_h3_box_3.webp 1384w,
/posts/delaunay/winding-test_hud3a68137b279523b9858e27bdd6d6f7c_105986_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/winding-test_hud3a68137b279523b9858e27bdd6d6f7c_105986_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 692px"/><img srcset="/posts/delaunay/winding-test_hud3a68137b279523b9858e27bdd6d6f7c_105986_692x692_fit_box_3.png 692w,
/posts/delaunay/winding-test_hud3a68137b279523b9858e27bdd6d6f7c_105986_1384x1384_fit_box_3.png 1384w,
/posts/delaunay/winding-test_hud3a68137b279523b9858e27bdd6d6f7c_105986_375x375_fit_box_3.png 375w,
/posts/delaunay/winding-test_hud3a68137b279523b9858e27bdd6d6f7c_105986_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 692px" width="692" height="293"/></picture></a>
<p>Another, simpler interpretation: given a directed edge <code>AB</code> of a triangle, this test tells you if point <code>P</code> lies “to the left” of the line crossing <code>AB</code> (counter-clockwise) or “to the right” of it (clockwise).</p>
<a href="https://ianthehenry.com/posts/delaunay/left-right_hu984b6b8b18c534e976a5febb4ffb102f_71310_1002x1002_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/left-right_hu984b6b8b18c534e976a5febb4ffb102f_71310_501x501_fit_q75_h3_box_3.webp 501w,
/posts/delaunay/left-right_hu984b6b8b18c534e976a5febb4ffb102f_71310_1002x1002_fit_q75_h3_box_3.webp 1002w,
/posts/delaunay/left-right_hu984b6b8b18c534e976a5febb4ffb102f_71310_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/left-right_hu984b6b8b18c534e976a5febb4ffb102f_71310_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 501px"/><img srcset="/posts/delaunay/left-right_hu984b6b8b18c534e976a5febb4ffb102f_71310_501x501_fit_box_3.png 501w,
/posts/delaunay/left-right_hu984b6b8b18c534e976a5febb4ffb102f_71310_1002x1002_fit_box_3.png 1002w,
/posts/delaunay/left-right_hu984b6b8b18c534e976a5febb4ffb102f_71310_375x375_fit_box_3.png 375w,
/posts/delaunay/left-right_hu984b6b8b18c534e976a5febb4ffb102f_71310_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 501px" width="501" height="312"/></picture></a>
<p>If the point is “to the left of” every (directed, counter-clockwise) edge, then the point is inside the triangle.</p>


<p>So: now we know how to check if a point is inside a triangle. But! We actually get more than one bit of information when we do that test – we get <em>three</em> bits of information. Instead of <code>AND</code>ing them down to a single boolean value, we can instead use all of the information at our disposal to do something smarter.</p>
<p>So Guibas &amp; Stolfi describe a technique that they credit to Green &amp; Sibson:<sup id="fnref:13"><a href="#fn:13" role="doc-noteref">13</a></sup> traverse the mesh one triangle at a time, always moving “towards” the target point, using the information we learned during the triangle test to decide what “towards” means.</p>
<p>If we find that the point is not “to the left of” one particular edge, then we know that it’s to the right of that edge. And since we know the whole mesh, we know exactly which triangle lies to the right of that edge, and we can check that triangle next.</p>
<p>The triangle immediately to the right of that edge may not contain our point either, but it’s going to be <em>closer</em> to the triangle that does, and if we repeat this enough we will <em>eventually</em> find a home for our point.</p>
<p>Here, let’s take a look at this in action. I omitted the locating step from my first visualization of the triangulation algorithm, but we can add it back in to see the full story:</p>



<p>This algorithm is nice because we <em>probably</em> won’t need to traverse the entire graph, but in the worst case we’ll still have to check every single triangle. Guibas &amp; Stolfi claim that for a set of “reasonably uniform” random points, this search will only take O(√n) tests on average, and you can reduce that to roughly constant time if your newly inserted points are “close” to the previously inserted point. So it’s a bit data-dependent, but worst-case linear.<sup id="fnref:14"><a href="#fn:14" role="doc-noteref">14</a></sup></p>

<p>We’re so close!</p>
<ol>
<li>I can’t actually construct an infinitely large bounding triangle – is it okay if I just construct a triangle large enough to contain all of my points?</li>
<li><del>How am I supposed to find the triangle that contains my new point?</del></li>
<li><del>What if the new point lies on the edge of an existing triangle?</del></li>
<li><del>How am I supposed to do this circle test in the first place?</del></li>
<li>What edges do I actually need to check, once I’ve added my new edges?</li>
<li><del>Wait, how do I “flip” edges?</del></li>
<li><del>Wait, how do I even <em>model</em> edges? How do you even represent triangulations on a computer? I thought I could just model this as a graph, with vertices and edges and pointers, but it seems like I need to keep track of faces as well, and somehow this is a fundamentally different sort of thing than I’ve ever encountered before?</del></li>
</ol>
<p>The last two questions are very specific to this particular algorithm, and the answers won’t really make you a smarter person. So if you aren’t <em>actually</em> trying to implement this algorithm, you can safely <a href="#are-we-there-yet">skip to the end</a>.</p>
<p>Whenever you add a new point, and connect it to the points of its enclosing triangle or quadrangle, you’ll have a point at the middle of a spoke. Like this:</p>
<a href="https://ianthehenry.com/posts/delaunay/spokes_hufa198a314e148a89be0a4e16c6e1e9db_107561_848x848_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/spokes_hufa198a314e148a89be0a4e16c6e1e9db_107561_424x424_fit_q75_h3_box_3.webp 424w,
/posts/delaunay/spokes_hufa198a314e148a89be0a4e16c6e1e9db_107561_848x848_fit_q75_h3_box_3.webp 848w,
/posts/delaunay/spokes_hufa198a314e148a89be0a4e16c6e1e9db_107561_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/spokes_hufa198a314e148a89be0a4e16c6e1e9db_107561_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 424px"/><img srcset="/posts/delaunay/spokes_hufa198a314e148a89be0a4e16c6e1e9db_107561_424x424_fit_box_3.png 424w,
/posts/delaunay/spokes_hufa198a314e148a89be0a4e16c6e1e9db_107561_848x848_fit_box_3.png 848w,
/posts/delaunay/spokes_hufa198a314e148a89be0a4e16c6e1e9db_107561_375x375_fit_box_3.png 375w,
/posts/delaunay/spokes_hufa198a314e148a89be0a4e16c6e1e9db_107561_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 424px" width="424" height="297"/></picture></a>
<p>All of those newly created edges are <em>already fine</em>. We don’t have to check them. But we do have to check the edges adjacent to them – the edges that form a ring around the newly inserted point.</p>
<a href="https://ianthehenry.com/posts/delaunay/ring_hudd67548716ad4f8181d256be6dfe8a4f_112678_848x848_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/ring_hudd67548716ad4f8181d256be6dfe8a4f_112678_424x424_fit_q75_h3_box_3.webp 424w,
/posts/delaunay/ring_hudd67548716ad4f8181d256be6dfe8a4f_112678_848x848_fit_q75_h3_box_3.webp 848w,
/posts/delaunay/ring_hudd67548716ad4f8181d256be6dfe8a4f_112678_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/ring_hudd67548716ad4f8181d256be6dfe8a4f_112678_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 424px"/><img srcset="/posts/delaunay/ring_hudd67548716ad4f8181d256be6dfe8a4f_112678_424x424_fit_box_3.png 424w,
/posts/delaunay/ring_hudd67548716ad4f8181d256be6dfe8a4f_112678_848x848_fit_box_3.png 848w,
/posts/delaunay/ring_hudd67548716ad4f8181d256be6dfe8a4f_112678_375x375_fit_box_3.png 375w,
/posts/delaunay/ring_hudd67548716ad4f8181d256be6dfe8a4f_112678_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 424px" width="424" height="297"/></picture></a>
<p>Whenever you flip an edge, you make this ring bigger, effectively adding two new segments to the ring.</p>
<a href="https://ianthehenry.com/posts/delaunay/ring-flipped_hu2e063f25857b0bc063eec050de13d9e5_115321_848x848_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/ring-flipped_hu2e063f25857b0bc063eec050de13d9e5_115321_424x424_fit_q75_h3_box_3.webp 424w,
/posts/delaunay/ring-flipped_hu2e063f25857b0bc063eec050de13d9e5_115321_848x848_fit_q75_h3_box_3.webp 848w,
/posts/delaunay/ring-flipped_hu2e063f25857b0bc063eec050de13d9e5_115321_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/ring-flipped_hu2e063f25857b0bc063eec050de13d9e5_115321_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 424px"/><img srcset="/posts/delaunay/ring-flipped_hu2e063f25857b0bc063eec050de13d9e5_115321_424x424_fit_box_3.png 424w,
/posts/delaunay/ring-flipped_hu2e063f25857b0bc063eec050de13d9e5_115321_848x848_fit_box_3.png 848w,
/posts/delaunay/ring-flipped_hu2e063f25857b0bc063eec050de13d9e5_115321_375x375_fit_box_3.png 375w,
/posts/delaunay/ring-flipped_hu2e063f25857b0bc063eec050de13d9e5_115321_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 424px" width="424" height="297"/></picture></a>
<p>You then have to check those new edges. But notice that they’re still a part of the same ring! And in fact as you flip these edges, they will add new segments to the ring as well.</p>
<p>So you don’t need to store a list of “dirty edges” or recurse to clean up all of these edges. You can just store a specific edge on the ring, check it, and then either move “forward” (if the edge passed) or “backwards” (if you had to flip it).</p>
<p>So the number of edges that you have to check depends on the number of triangles that have the newly inserted point as one of their corners. In the worst case this means means doing O(n) work, but <em>on average</em> across every point insertion this will net out to constant time, apparently, although I can’t find a proof of that.<sup id="fnref:15"><a href="#fn:15" role="doc-noteref">15</a></sup> But we’re already doing worst-case O(n) work to find the triangle, so the total runtime of the algorithm remains O(n<sup>2</sup>).</p>
<p>Easy! Okay. Which brings us to the last question: what do we do about the “infinite bounding triangle?”</p>
<p>There is no triangle you can construct that will be “big enough” to pass for infinite when we do the point-in-circle test – as three points get closer to being colinear, the radius circle they define will approach infinity – so we just won’t do the point-in-circle test. Whenever a point on our boundary triangle is involved, we’ll instead check a series of conditions:</p>
<ol>
<li>
<p>If the edge in question is a boundary edge, do not flip it. This one is easy so I’m not going to draw it for you.</p>
</li>
<li>
<p>If the edge contains a boundary vertex, flip it, <em>unless doing so would create an inside-out triangle</em>.</p>
</li>
</ol>
<a href="https://ianthehenry.com/posts/delaunay/edge-case-2_hu5c9ca0611e60e4307091b662fc270cdd_306048_1536x1536_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/edge-case-2_hu5c9ca0611e60e4307091b662fc270cdd_306048_768x768_fit_q75_h3_box_3.webp 768w,
/posts/delaunay/edge-case-2_hu5c9ca0611e60e4307091b662fc270cdd_306048_1536x1536_fit_q75_h3_box_3.webp 1536w,
/posts/delaunay/edge-case-2_hu5c9ca0611e60e4307091b662fc270cdd_306048_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/edge-case-2_hu5c9ca0611e60e4307091b662fc270cdd_306048_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 768px"/><img srcset="/posts/delaunay/edge-case-2_hu5c9ca0611e60e4307091b662fc270cdd_306048_768x768_fit_box_3.png 768w,
/posts/delaunay/edge-case-2_hu5c9ca0611e60e4307091b662fc270cdd_306048_1536x1536_fit_box_3.png 1536w,
/posts/delaunay/edge-case-2_hu5c9ca0611e60e4307091b662fc270cdd_306048_375x375_fit_box_3.png 375w,
/posts/delaunay/edge-case-2_hu5c9ca0611e60e4307091b662fc270cdd_306048_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 768px" width="768" height="461"/></picture></a>
<ol start="3">
<li>If an edge separates our newly inserted point from a boundary vertex, do not flip it.</li>
</ol>
<a href="https://ianthehenry.com/posts/delaunay/edge-case-3_huca4a1b7fc304ce20231275d7c77e6d41_59182_788x788_fit_box_3.png"><picture><source type="image/webp" srcset="/posts/delaunay/edge-case-3_huca4a1b7fc304ce20231275d7c77e6d41_59182_394x394_fit_q75_h3_box_3.webp 394w,
/posts/delaunay/edge-case-3_huca4a1b7fc304ce20231275d7c77e6d41_59182_788x788_fit_q75_h3_box_3.webp 788w,
/posts/delaunay/edge-case-3_huca4a1b7fc304ce20231275d7c77e6d41_59182_375x375_fit_q75_h3_box_3.webp 375w,
/posts/delaunay/edge-case-3_huca4a1b7fc304ce20231275d7c77e6d41_59182_750x750_fit_q75_h3_box_3.webp 750w" sizes="(max-width: 400px) 375px, 394px"/><img srcset="/posts/delaunay/edge-case-3_huca4a1b7fc304ce20231275d7c77e6d41_59182_394x394_fit_box_3.png 394w,
/posts/delaunay/edge-case-3_huca4a1b7fc304ce20231275d7c77e6d41_59182_788x788_fit_box_3.png 788w,
/posts/delaunay/edge-case-3_huca4a1b7fc304ce20231275d7c77e6d41_59182_375x375_fit_box_3.png 375w,
/posts/delaunay/edge-case-3_huca4a1b7fc304ce20231275d7c77e6d41_59182_750x750_fit_box_3.png 750w" alt="" title="" sizes="(max-width: 400px) 375px, 394px" width="394" height="289"/></picture></a>
<p>That’s it! Those conditions will give you answers consistent with the answers you would get if your boundary vertices really were infinitely far from the rest of your points. Now all you need to do is to construct a triangle large enough to contain all of your points so that your “point in triangle” test works correctly, and you’re done. (If you don’t know all your points ahead of time, you can make any triangle and resize it as you learn points.)</p>

<p>Yes! We did it. That’s the algorithm. And the data structure. Two for the price of one.</p>
<p>Now that you understand how it works, in far more detail than you ever wanted to, let’s watch the visualization again. I’m exluding the boundary triangle this time so we can zoom in a bit and just bask in the trianglular glow.</p>


<p>Well, that’s it. From here it’s a short, linear-time jaunt to computing the Voronoi diagram, the Gabriel graph, and probably some other interesting stuff. But that’ll have to wait for the next post.</p>
<p><em>Speaking of next posts,</em> if you enjoyed this one, don’t forget to…</p>
<p>No. I can’t actually say it.</p>
</div>
</article></div>
  </body>
</html>
