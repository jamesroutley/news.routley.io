<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.metaobject.com/2023/06/mojo-is-much-better-without-c-than.html">Original</a>
    <h1>Mojo is a much better “Objective-C without the C” than Swift ever was</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-3855381838083330293" itemprop="description articleBody"><p>
One of the primary things that people don&#39;t understand about Objective-C is that it is a solution of
the <a href="https://thebottomline.as.ucsb.edu/2018/10/julia-a-solution-to-the-two-language-programming-problem">two language problem</a>, or more precisely a generalisation of the two language problem to
the scripted component pattern.</p><p>

The scripted component pattern itself is a (common) solution to the problem, first identified in the
70s that <a href="https://dl.acm.org/doi/10.1145/390016.808431">programming-in-the-large is not the same as programming-in-the-small</a>, that module implementation
languages are not necessarily suitable as module interconnection languages.</p><p>

And so we have all sorts of flexible connection languages, often interpreted (aka glue, scripting, and orchestration languages),
starting with the Unix shell, in addition to fast, compiled component languages such as C, C++ and
Rust, and a system will usually incorporate at least one of each kind.</p><p>

But then you run into the two language problem:  you have to deal with these two distinct languages, with
how they integrate, and with the boundaries of the integration often not matching up very well with the
boundaries of the problem you&#39;re trying to solve.</p><p>

Objective-C <a href="https://blog.metaobject.com/2019/03/software-ics-binary-compatibility-and.html">solved</a> the two language problem by just jamming the two languages into one:  Smalltalk for the
scripting/integration and C for the component language.  Interoperability is smooth and at the statement
level, thougha there is some
friction due to overlaps caused by integrating two existing languages that were not designed to be
integrated.</p><p>

<a href="https://www.modular.com/mojo">Mojo</a> essentially uses the Objective-C approach of jamming the two languages into one.  Except it 
doesn&#39;t repeat Objective-C&#39;s mistake of using the component language as the base (which, inexplicably,
Swift didn&#39;t just repeat, but actually doubled down on by largely deprecating objects).  The reason this 
is a mistake is that it turns out that the connection language is actually the more general one, the
component language is a specialisation of the connection language.</p><p>

With this realisation, Mojo&#39;s approach of making the connection language the base language make sense.
In addition, the fact that the component language is a specialisation also means that you don&#39;t
actually need to jam a full second language into your base, a few syntactic markers to to indicate
the specialisations are sufficient.</p><p>

This is pretty much exactly stage 2 of <a href="https://blog.metaobject.com/2019/12/the-4-stages-of-objective-smalltalk.html">the 4 stages of Objective-S</a>,  so I think they are using exactly the right approach for this.  Except of course for the use of Python as the base instead of Smalltalk, which is a pragmatic 
choice given what they are trying to accomplish, but means your connection language is unduly limited.</p><p>

<a href="https://objective.st/">Objective-S</a> has the same basic structure, but with a much more
capable connection language as the base.</p>
</div></div>
  </body>
</html>
