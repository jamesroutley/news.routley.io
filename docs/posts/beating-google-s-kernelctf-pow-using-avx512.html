<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://anemato.de/blog/kctf-vdf">Original</a>
    <h1>Beating Google&#39;s kernelCTF PoW using AVX512</h1>
    
    <div id="readability-page-1" class="page"><section><header><a aria-label="anematode" href="https://anemato.de/"></a></header><main><section><article><div><header><div><dl><p><dt>Published on</dt><dd><time datetime="2025-05-29T00:00:00.000Z">Wednesday, May 28, 2025</time></dd></p></dl></div></header><div><dl><dt>Authors</dt><dd><ul><li><img alt="avatar" loading="lazy" width="38" height="38" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fstatic%2Fimages%2Favatar.png&amp;w=48&amp;q=75 1x, /_next/image?url=%2Fstatic%2Fimages%2Favatar.png&amp;w=96&amp;q=75 2x" src="https://anemato.de/_next/image?url=%2Fstatic%2Fimages%2Favatar.png&amp;w=96&amp;q=75"/><dl><dt>Name</dt><dd>Timothy Herchen</dd><dt>Twitter</dt><dd></dd></dl></li></ul></dd></dl><div><div><p>In May 2025, my <a target="_blank" rel="noopener noreferrer" href="https://cor.team">Crusaders of Rust</a> teammates William Liu (<a target="_blank" rel="noopener noreferrer" href="https://willsroot.io">FizzBuzz101</a>) and Savy Dicanosa (<a target="_blank" rel="noopener noreferrer" href="https://syst3mfailure.io">Syst3mFailure</a>) discovered and developed an exploit of a use-after-free bug in Linux&#39;s packet scheduler. <a target="_blank" rel="noopener noreferrer" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ac9fe7dd8e730a103ae4481147395cc73492d786">The bugfix patch</a> contains additional details. William found this bug while fuzzing Linux for his master&#39;s thesis, which I will link here upon its publication. (Congratulations, William!)</p><p>They wanted to submit the bug to Google&#39;s <a target="_blank" rel="noopener noreferrer" href="https://google.github.io/security-research/kernelctf/rules.html">kernelCTF</a> competition for an anticipated $51,000 bounty.<sup><a href="#user-content-fn-bounty" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-bounty">1</a></sup> Unfortunately, finding the bug and writing the exploit was only the first part of the battle. This post documents my small but unique contribution to our ultimately winning the bounty.</p><p>To avoid paying out lots of money, kernelCTF organizers limit the number of submissions eligible for a bounty. Every two weeks at noon UTC, the submission window opens. Only the first team who is able to connect to and exploit the server, and submit the flag to a Google Form, receives a payout; any subsequent submissions are marked as duplicates. Furthermore, to prevent excessive submissions, the connecting to kernelCTF server requires solving a &#34;proof of work&#34;—a function which, by design, takes a few seconds to evaluate.</p><p>In summary, <strong>the submission process has these steps</strong>:</p><ol><li>At 12:00:00 UTC, connect to the kernelCTF server.</li><li>Solve the proof of work, which takes roughly 4 seconds.</li><li>Wait for the instance to boot. (Roughly 2.5 seconds.)</li><li>Upload the exploit and run it to secure the flag. (Time elapsed depends on the exploit. Savy optimized this one to take roughly 0.55 seconds without sacrificing reliability. Wow!)</li><li>Submit the flag to a Google Form. The submission timestamp determines the winner of the &#34;slot&#34;.</li></ol><p>Our goal was to complete all these steps in sequence, faster than all the other teams.</p><p>Because of the large bounties, over time professional vulnerability research teams have aggressively optimized their submission process. For the May 2, 2025, submission window preceding ours, the first team to submit the flag <a target="_blank" rel="noopener noreferrer" href="https://docs.google.com/spreadsheets/d/e/2PACX-1vS1REdTA29OJftst8xN5B5x8iIUcxuK6bXdzF8G1UXCmRtoNsoQ9MbebdRdFnj6qZ0Yd7LwQfvYC2oF/pubhtml">did so 4.5 seconds after noon</a>!</p><p><img alt="kernelCTF submission time" loading="lazy" width="1518" height="156" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fstatic%2Fimages%2Fkctf-fast-submissions.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fstatic%2Fimages%2Fkctf-fast-submissions.png&amp;w=3840&amp;q=75 2x" src="https://anemato.de/_next/image?url=%2Fstatic%2Fimages%2Fkctf-fast-submissions.png&amp;w=3840&amp;q=75"/></p><p>The numbers don&#39;t seem to add up: even assuming an instant exploit and form submission, the VM boot time and proof of work already take 6.5 seconds. Looking closer, we see that the time at which the winning submission&#39;s flag was generated (highlighted in red) is one second <em>before</em> noon UTC. Yet, the timestamp is generated <em>after</em> the proof of work is solved. Did sweaty CTFers invent time travel?</p><p>Alas! Because of a rounding quirk in the kernelCTF server code (<a target="_blank" rel="noopener noreferrer" href="https://github.com/google/security-research/blob/90cc1d1fe4d4626d4c0aba4a78c02fc72fe18ac7/kernelctf/server/server.py#L192">here</a>), the VM instance actually boots at 11:59:59—so no time travel. Still, the timestamp indicates that the winning team solved the proof of work in less than a second! How could this be?</p><p>We don&#39;t know for certain, but one kernelCTF organizer postulated that they were using <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">field-programmable gate arrays</a> (FPGAs). FPGAs are custom silicon that can perform specific tasks extremely quickly, to the exclusion of general-purpose tasks. They are not only fairly expensive, but also tricky to program. If the professional team had access to an FPGA programmed to perform the proof of work, a sub-second proof of work time was conceivable.</p><p>On May 13, William messaged me on Discord seeking advice on how to optimize the proof of work so that we could preempt the competition. I had to act fast: The next submission window would open at 5 a.m. PST, May 16.<sup><a href="#user-content-fn-thesis" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-thesis">2</a></sup></p><p>The proof of work (<a target="_blank" rel="noopener noreferrer" href="https://github.com/google/kctf/blob/v1/docker-images/challenge/pow.py">implemented here</a>) is a certain <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/Verifiable_delay_function">verifiable delay function</a> (VDF) known as &#34;sloth&#34;. VDFs are cryptographic primitives which prove that a nontrivial amount of time has passed by requiring a long, serial computation. This computation outputs a proof which can be (relatively) quickly verified. Because the computation is serial, scaling to more computational resources (such as more CPU or GPU cores) does not reduce the runtime.<sup><a href="#user-content-fn-hash" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-hash">3</a></sup></p><p>The sloth VDF was introduced by <a target="_blank" rel="noopener noreferrer" href="https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session1-wesolowski-paper.pdf">Lenstra and Wesolowski (2015)</a>. I won&#39;t reproduce the number theory behind sloth (see page 4 of the paper for that), but to summarize matters, the function we must optimize boils down to:</p><div><pre><code><span><span>def</span> <span>sloth_root</span><span>(</span>x<span>,</span> difficulty<span>=</span><span>7337</span><span>)</span><span>:</span>
</span><span>    <span>for</span> i <span>in</span> <span>range</span><span>(</span>difficulty<span>)</span><span>:</span>             
</span><span>        <span>for</span> j <span>in</span> <span>range</span><span>(</span><span>1277</span><span>)</span><span>:</span>               
</span><span>            x <span>=</span> <span>(</span>x <span>*</span> x<span>)</span> <span>%</span> <span>(</span><span>2</span> <span>**</span> <span>1279</span> <span>-</span> <span>1</span><span>)</span>   
</span><span>        x <span>=</span> x<span>.</span>bit_flip<span>(</span><span>0</span><span>)</span>                   
</span><span>    <span>return</span> <span>int</span><span>(</span>x<span>)</span>
</span></code></pre></div><p>where <em>x</em> is a supplied 1280-bit integer. The <em>difficulty</em> variable linearly controls how long the VDF takes to solve.</p><p>Google&#39;s reference implementation uses gmpy, which is a Python binding to the venerable <a target="_blank" rel="noopener noreferrer" href="https://gmplib.org">GNU Multiprecision Library</a> (GMP). GMP&#39;s addition and multiplication kernels are handwritten in assembly for each target platform (<a target="_blank" rel="noopener noreferrer" href="https://github.com/gmp-mirror/gmp/blob/master/mpn/x86_64/mulx/adx/addmul_1.asm">example</a>). The loop-carried dependency of <em>x</em> means that the computation is inherently serial, so throwing more cores at the problem—at least in a naïve way—is unhelpful. Meaningfully speeding up this function was going to be <em>tough</em>.</p><p>I set out on the obvious goal of optimizing the 1280-bit modular squaring (line 4 in the code above). The first success was mathematical: Because the modulus is a Mersenne number of length 1279 bits, and the intermediate product is 2 · 1280 = 2560 bits, computing the residue actually corresponds to a handful of cheaper operations:</p><div><pre><code><span><span>def</span> <span>mod_2_1279_minus_1</span><span>(</span>x<span>)</span><span>:</span>    
</span><span>    p <span>=</span> <span>2</span> <span>**</span> <span>1279</span> <span>-</span> <span>1</span>
</span><span>    r <span>=</span> <span>(</span>x <span>&amp;</span> p<span>)</span> <span>+</span> <span>(</span>x <span>&gt;&gt;</span> <span>1279</span><span>)</span>
</span><span>    <span>if</span> r <span>&gt;=</span> p<span>:</span>
</span><span>        r <span>-=</span> p
</span><span>    <span>return</span> r
</span></code></pre></div><p>I also translated the function to C++ to remove FFI overhead. The newly optimized code:</p><div><pre><code><span><span>constexpr</span> <span>int</span> MERSENNE_EXP <span>=</span> <span>1279</span><span>;</span>
</span><span>
</span><span>mpz_t low<span>,</span> high<span>,</span> p<span>;</span>
</span><span>
</span><span><span>void</span> <span>mpz_mod_mersenne</span><span>(</span>mpz_t r<span>,</span> <span>const</span> mpz_t x<span>)</span> <span>{</span>
</span><span>    
</span><span>    <span>mpz_mod_2exp</span><span>(</span>low<span>,</span> x<span>,</span> MERSENNE_EXP<span>)</span><span>;</span>
</span><span>    <span>mpz_fdiv_q_2exp</span><span>(</span>high<span>,</span> x<span>,</span> MERSENNE_EXP<span>)</span><span>;</span>
</span><span>    <span>mpz_add</span><span>(</span>r<span>,</span> low<span>,</span> high<span>)</span><span>;</span>
</span><span>    <span>if</span> <span>(</span><span>mpz_cmp</span><span>(</span>r<span>,</span> p<span>)</span> <span>&gt;=</span> <span>0</span><span>)</span> <span>{</span>
</span><span>        <span>mpz_sub</span><span>(</span>r<span>,</span> r<span>,</span> p<span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span><span>
</span><span><span>bool</span> <span>init</span><span>(</span><span>)</span> <span>{</span>
</span><span>    <span>mpz_inits</span><span>(</span>low<span>,</span> high<span>,</span> p<span>,</span> <span>NULL</span><span>)</span><span>;</span>
</span><span>    <span>mpz_ui_pow_ui</span><span>(</span>p<span>,</span> <span>2</span><span>,</span> MERSENNE_EXP<span>)</span><span>;</span>
</span><span>    <span>mpz_sub_ui</span><span>(</span>p<span>,</span> p<span>,</span> <span>1</span><span>)</span><span>;</span>
</span><span>    <span>return</span> <span>true</span><span>;</span>
</span><span><span>}</span>
</span><span><span>bool</span> _unused <span>=</span> <span>init</span><span>(</span><span>)</span><span>;</span>
</span><span>
</span><span><span>void</span> <span>the_powmod</span><span>(</span>mpz_t x<span>)</span> <span>{</span>
</span><span>    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1277</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>        <span>mpz_mul</span><span>(</span>x<span>,</span> x<span>,</span> x<span>)</span><span>;</span>
</span><span>        <span>mpz_mod_mersenne</span><span>(</span>x<span>,</span> x<span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span><span>
</span><span><span>int</span> <span>main</span><span>(</span><span>)</span>
</span><span><span>{</span>
</span><span>    <span>const</span> <span>int</span> diff <span>=</span> <span>7337</span><span>;</span>
</span><span>    mpz_t x<span>,</span> r<span>;</span>
</span><span>    <span>mpz_inits</span><span>(</span>x<span>,</span> r<span>,</span> <span>NULL</span><span>)</span><span>;</span>
</span><span>    <span>mpz_set_str</span><span>(</span>x<span>,</span> <span>&#34;96729140485950483920373592475530255430&#34;</span><span>,</span> <span>10</span><span>)</span><span>;</span>
</span><span>    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> diff<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>        <span>the_powmod</span><span>(</span>x<span>)</span><span>;</span>
</span><span>        <span>mpz_combit</span><span>(</span>x<span>,</span> <span>0</span><span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span>    <span>char</span> <span>*</span>str <span>=</span> <span>mpz_get_str</span><span>(</span><span>NULL</span><span>,</span> <span>10</span><span>,</span> x<span>)</span><span>;</span>
</span><span>    std<span>::</span>cout <span>&lt;&lt;</span> <span>&#34;x: &#34;</span> <span>&lt;&lt;</span> str <span>&lt;&lt;</span> std<span>::</span>endl<span>;</span>
</span><span>    <span>return</span> <span>0</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div><p>This code ran in 1.9 seconds on my M1 Macbook Pro—a substantial improvement, and faster than similarly optimized solvers like <a target="_blank" rel="noopener noreferrer" href="https://github.com/Aplet123/kctf-pow">this one written in Rust</a>.<sup><a href="#user-content-fn-rust" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-rust">4</a></sup> William linked GMP statically, which would presumably allow some inlining, and reported a further speedup—roughly 1.4 seconds on a fancy Intel Ice Lake laptop. Not bad, but still not a guaranteed win.</p><p>The modulus no longer being a bottleneck, I considered handwriting multiplication kernels in assembly to take advantage of the multiplication being a fixed width of 1280-bit × 1280-bit → 2560-bit; the factors fit neatly into twenty 64-bit limbs, and the product fits in forty limbs.<sup><a href="#user-content-fn-limbs" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-limbs">5</a></sup> GMP&#39;s assembly kernels are generic in the bitwidth, which introduces some overhead. Unfortunately, at 1.4 seconds we were approaching the theoretical limit of multiplication throughput, which is one 64-bit × 64-bit → 128-bit multiplication per cycle on all recent hardware.<sup><a href="#user-content-fn-uops" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-uops">6</a></sup></p><p><a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/AVX-512">AVX512</a> is Intel&#39;s extension to the x86 ISA, first made available in 2016. It is a comprehensive overhaul of x86 SIMD programming, doubling the number and width of vector registers, adding <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Scalable_Vector_Extension">Scalable Vector Extension</a>–style mask predication, and hundreds of new instructions. It also has a troubled history: Linus Torvalds <a target="_blank" rel="noopener noreferrer" href="https://www.realworldtech.com/forum/?threadid=193189&amp;curpostid=193190">famously</a> wished it to &#34;die a horrible death&#34;, and despite supporting it on consumer CPUs for several generations, Intel disabled support for it starting with the Alder Lake µarch (2021); support continues in the server space. Meanwhile, AMD implemented AVX512 in their Zen 4 (2022) and Zen 5 µarches for both consumer and server CPUs.</p><p>Of present interest is the AVX512 Integer Fused Multiply–Add extension (AVX512IFMA), which was introduced specifically to speed up big-integer arithmetic—see, <em>e.g.</em>, <a target="_blank" rel="noopener noreferrer" href="https://builders.intel.com/docs/networkbuilders/intel-avx-512-fast-modular-multiplication-technique-technology-guide-1710916893.pdf">Ozturk, Kantecki &amp; Yap (2024)</a>. I learned about AVX512IFMA during my competitive programming arc, optimizing submissions for <a target="_blank" rel="noopener noreferrer" href="https://judge.yosupo.jp">judge.yosupo.jp</a>. The extension introduces two new instructions which operate on vector registers:</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://www.felixcloutier.com/x86/vpmadd52luq">vpmadd52luq</a> – Packed Multiply of Unsigned 52-Bit Unsigned Integers and Add Low 52-Bit Products to 64-Bit Accumulators</li><li><a target="_blank" rel="noopener noreferrer" href="https://www.felixcloutier.com/x86/vpmadd52huq">vpmadd52huq</a> – Packed Multiply of Unsigned 52-Bit Unsigned Integers and Add High 52-Bit Products to 64-Bit Accumulators</li></ul><p>Essentially, the instructions perform the following operation (assuming the high 12 bits of each element in <em>a</em> and <em>b</em> are zero):</p><div><pre><code><span>
</span><span><span>void</span> <span>vpmadd52luq</span><span>(</span><span>uint64_t</span> dst<span>[</span><span>8</span><span>]</span><span>,</span> <span>uint64_t</span> a<span>[</span><span>8</span><span>]</span><span>,</span> <span>uint64_t</span> b<span>[</span><span>8</span><span>]</span><span>)</span> <span>{</span>
</span><span>    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>8</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>        dst<span>[</span>i<span>]</span> <span>+=</span> <span>(</span>a<span>[</span>i<span>]</span> <span>*</span> b<span>[</span>i<span>]</span><span>)</span> <span>&amp;</span> <span>(</span><span>1ULL</span> <span>&lt;&lt;</span> <span>52</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span><span>
</span><span>
</span><span><span>void</span> <span>vpmadd52huq</span><span>(</span><span>uint64_t</span> dst<span>[</span><span>8</span><span>]</span><span>,</span> <span>uint64_t</span> a<span>[</span><span>8</span><span>]</span><span>,</span> <span>uint64_t</span> b<span>[</span><span>8</span><span>]</span><span>)</span> <span>{</span>
</span><span>    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>8</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>        dst<span>[</span>i<span>]</span> <span>+=</span> <span>(</span><span>(</span>__uint128_t<span>)</span>a<span>[</span>i<span>]</span> <span>*</span> b<span>[</span>i<span>]</span><span>)</span> <span>&gt;&gt;</span> <span>52</span><span>;</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span></code></pre></div><p>In simpler terms, the instructions perform the low and high halves of a 52 × 52 → 104 multiplication, and accumulate the result into the destination register. At the execution unit level, the instructions reuse the multipliers used for double-precision floating point, and thus don&#39;t necessitate much extra silicon. They also have fantastic throughput: on Zen 5, which has a full 512-bit datapath, we can execute two of these instructions per clock!</p><p>At this point I was confident that I could make an extraordinarily fast VDF solver. All that was left was to implement it in two days....</p><p><img src="https://anemato.de/static/images/pow-is-broken.png" alt="yapping" width="500"/></p><p>The natural radix for the AVX512IFMA extensions is 2<sup>52</sup>, <em>i.e.</em> 52-bit limbs stored in 64-bit words, so I let ChatGPT write a simple converter between GMP&#39;s representation and the 52-bit representation. We need ⌈1280 / 52⌉ = 25 limbs, which requires four 512-bit &#34;zmm&#34; registers (each register can store eight limbs, so the last register will only store one).</p><p>The first step is squaring the integer into a 50-limb intermediate product. We use a simple symmetry to almost halve the number of required multiplications, breaking up the desired value into two terms:</p><p>(a<sub>24</sub>2<sup>52·24</sup> + a<sub>23</sub>2<sup>52·23</sup> + ... + a<sub>0</sub>)<sup>2</sup> = (<span>a<sub>24</sub><sup>2</sup></span>2<sup>52·48</sup> + <span>a<sub>23</sub><sup>2</sup></span>2<sup>52·46</sup> + ... + <span>a<sub>0</sub><sup>2</sup></span>) + 2 <span><small>i,j≤24</small><span>∑</span><small>i=0,j&gt;i</small></span><span>a<sub>i</sub>a<sub>j</sub></span> 2<sup>52·(i + j)</sup></p><p>Each of the yellow-highlighted multiplications produces a low term (furnished by <em>vpmadd52luq</em>) and a high term (furnished by <em>vpmadd52huq</em>).</p><p>First consider the <em>second</em> term above, the double summation highlighted in red. We want to reduce the number of shuffles necessary to get all the terms in the correct place, and use the &#34;free&#34; 64-bit accumulation as much as possible. One way to do this is to multiply a sliding window of 8 contiguous limbs by a single multiplier limb; all the output words, for both the low and high halves, will also be contiguous in the output. We can also use the merge masking feature to prevent accumulation of products that shouldn&#39;t be in the final sum, <em>e.g.</em>, pairs where i = j. By selecting these windows and multipliers correctly, we can minimize the number of wasted multiplications.</p><div><pre><code><span>
</span><span>
</span><span><span>_Alignas</span><span>(</span><span>64</span><span>)</span> <span>uint64_t</span> padded_data<span>[</span><span>8</span> <span>*</span> <span>6</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>}</span><span>;</span>  
</span><span><span>uint64_t</span> <span>*</span>data <span>=</span> padded_data <span>+</span> <span>8</span><span>;</span>
</span><span>
</span><span>__m512i clumps<span>[</span><span>4</span><span>]</span> <span>=</span> <span>{</span>
</span><span>    <span>_mm512_loadu_si512</span><span>(</span>input<span>)</span><span>,</span>
</span><span>    <span>_mm512_loadu_si512</span><span>(</span>input <span>+</span> <span>8</span><span>)</span><span>,</span>
</span><span>    <span>_mm512_loadu_si512</span><span>(</span>input <span>+</span> <span>16</span><span>)</span><span>,</span>
</span><span>    <span>_mm512_loadu_si512</span><span>(</span>input <span>+</span> <span>24</span><span>)</span>
</span><span><span>}</span><span>;</span>
</span><span>
</span><span><span>_mm512_store_si512</span><span>(</span>data<span>,</span> clumps<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
</span><span><span>_mm512_store_si512</span><span>(</span>data <span>+</span> <span>8</span><span>,</span> clumps<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
</span><span><span>_mm512_store_si512</span><span>(</span>data <span>+</span> <span>16</span><span>,</span> clumps<span>[</span><span>2</span><span>]</span><span>)</span><span>;</span>
</span><span><span>_mm512_store_si512</span><span>(</span>data <span>+</span> <span>24</span><span>,</span> clumps<span>[</span><span>3</span><span>]</span><span>)</span><span>;</span>
</span><span>
</span><span><span><span>#</span><span>define</span> <span>ZERO</span> <span><span>_mm512_setzero_si512</span><span>(</span><span>)</span></span></span>
</span><span>
</span><span>
</span><span>__m512i accum<span>[</span><span>7</span><span>]</span> <span>=</span> <span>{</span> ZERO <span>,</span> ZERO <span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO <span>}</span><span>;</span>
</span><span><span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>-</span><span>7</span><span>;</span> i <span>&lt;=</span> <span>24</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>    
</span><span>    __m512i m1 <span>=</span> <span>_mm512_loadu_si512</span><span>(</span>data <span>+</span> i<span>)</span><span>;</span> 
</span><span>    <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>,</span> k <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>7</span><span>;</span> <span>++</span>j<span>,</span> k <span>+=</span> <span>8</span><span>)</span> <span>{</span>
</span><span>        
</span><span>        
</span><span>        <span>int</span> lo <span>=</span> k <span>-</span> i<span>;</span>
</span><span>        <span>int</span> hi <span>=</span> k <span>-</span> i <span>-</span> <span>1</span><span>;</span>
</span><span>        
</span><span>        <span>if</span> <span>(</span>lo <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> lo <span>&lt;=</span> <span>24</span><span>)</span> <span>{</span>
</span><span>            
</span><span>            __mmask8 sel <span>=</span> <span>(</span><span>uint8_t</span><span>)</span><span>(</span>lo <span>&lt;</span> i <span>?</span> <span>-</span><span>1ULL</span> <span>:</span> <span>(</span><span>-</span><span>1ULL</span> <span>&lt;&lt;</span> <span>(</span>lo <span>-</span> i <span>+</span> <span>1</span><span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>            <span>if</span> <span>(</span>sel<span>)</span> <span>{</span>
</span><span>                accum<span>[</span>j<span>]</span> <span>=</span> <span>_mm512_mask_madd52lo_epu64</span><span>(</span>accum<span>[</span>j<span>]</span><span>,</span> sel<span>,</span> m1<span>,</span> <span>_mm512_set1_epi64</span><span>(</span>data<span>[</span>lo<span>]</span><span>)</span><span>)</span><span>;</span>
</span><span>            <span>}</span>
</span><span>        <span>}</span>
</span><span>        
</span><span>        <span>if</span> <span>(</span>hi <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> hi <span>&lt;=</span> <span>24</span><span>)</span> <span>{</span>
</span><span>            
</span><span>            __mmask8 sel <span>=</span> <span>(</span><span>uint8_t</span><span>)</span><span>(</span>hi <span>&lt;</span> i <span>?</span> <span>-</span><span>1ULL</span> <span>:</span> <span>(</span><span>-</span><span>1ULL</span> <span>&lt;&lt;</span> <span>(</span>hi <span>-</span> i <span>+</span> <span>1</span><span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>            <span>if</span> <span>(</span>sel<span>)</span> <span>{</span>
</span><span>                accum<span>[</span>j<span>]</span> <span>=</span> <span>_mm512_mask_madd52hi_epu64</span><span>(</span>accum<span>[</span>j<span>]</span><span>,</span> sel<span>,</span> m1<span>,</span> <span>_mm512_set1_epi64</span><span>(</span>data<span>[</span>hi<span>]</span><span>)</span><span>)</span><span>;</span>
</span><span>            <span>}</span>
</span><span>        <span>}</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span></code></pre></div><p>As an example, accumulator <em>accum[1]</em> contains output limbs 8 through 15, inclusive, and the following accumulations are executed (in this order):</p><div><pre><code><span><span>Accumulating</span> low halves<span>:</span> <span>window</span> <span>1</span> by limb <span>7</span> <span>with</span> mask <span>10000000</span>
</span><span><span>Accumulating</span> high halves<span>:</span> <span>window</span> <span>1</span> by limb <span>6</span> <span>with</span> mask <span>11000000</span>
</span><span><span>Accumulating</span> low halves<span>:</span> <span>window</span> <span>2</span> by limb <span>6</span> <span>with</span> mask <span>11100000</span>
</span><span><span>Accumulating</span> high halves<span>:</span> <span>window</span> <span>2</span> by limb <span>5</span> <span>with</span> mask <span>11110000</span>
</span><span><span>Accumulating</span> low halves<span>:</span> <span>window</span> <span>3</span> by limb <span>5</span> <span>with</span> mask <span>11111000</span>
</span><span><span>Accumulating</span> high halves<span>:</span> <span>window</span> <span>3</span> by limb <span>4</span> <span>with</span> mask <span>11111100</span>
</span><span><span>Accumulating</span> low halves<span>:</span> <span>window</span> <span>4</span> by limb <span>4</span> <span>with</span> mask <span>11111110</span>
</span><span><span>Accumulating</span> high halves<span>:</span> <span>window</span> <span>4</span> by limb <span>3</span> <span>with</span> mask <span>11111111</span>
</span><span><span>Accumulating</span> low halves<span>:</span> <span>window</span> <span>5</span> by limb <span>3</span> <span>with</span> mask <span>11111111</span>
</span><span><span>Accumulating</span> high halves<span>:</span> <span>window</span> <span>5</span> by limb <span>2</span> <span>with</span> mask <span>11111111</span>
</span><span><span>Accumulating</span> low halves<span>:</span> <span>window</span> <span>6</span> by limb <span>2</span> <span>with</span> mask <span>11111111</span>
</span><span><span>Accumulating</span> high halves<span>:</span> <span>window</span> <span>6</span> by limb <span>1</span> <span>with</span> mask <span>11111111</span>
</span><span><span>Accumulating</span> low halves<span>:</span> <span>window</span> <span>7</span> by limb <span>1</span> <span>with</span> mask <span>11111111</span>
</span><span><span>Accumulating</span> high halves<span>:</span> <span>window</span> <span>7</span> by limb <span>0</span> <span>with</span> mask <span>11111111</span>
</span><span><span>Accumulating</span> low halves<span>:</span> <span>window</span> <span>8</span> by limb <span>0</span> <span>with</span> mask <span>11111111</span>
</span></code></pre></div><p>Here, window <em>i</em> contains limbs <em>i</em> through <em>i+7</em> inclusive. Note that the masks mostly contain ones, indicating that we are not wasting too much multiplication throughput on masked-out elements.</p><p>Computing the first term is easier. We just square each element and interleave the low and high words:</p><div><pre><code><span><span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>    __m512d diag_lo <span>=</span> <span>_mm512_castsi512_pd</span><span>(</span><span>_mm512_madd52lo_epu64</span><span>(</span>ZERO<span>,</span> clumps<span>[</span>i<span>]</span><span>,</span> clumps<span>[</span>i<span>]</span><span>)</span><span>)</span><span>;</span>
</span><span>    __m512d diag_hi <span>=</span> <span>_mm512_castsi512_pd</span><span>(</span><span>_mm512_madd52hi_epu64</span><span>(</span>ZERO<span>,</span> clumps<span>[</span>i<span>]</span><span>,</span> clumps<span>[</span>i<span>]</span><span>)</span><span>)</span><span>;</span>
</span><span>    __m512i shuf_lo <span>=</span> <span>_mm512_set_epi64</span><span>(</span><span>11</span><span>,</span> <span>3</span><span>,</span> <span>10</span><span>,</span> <span>2</span><span>,</span> <span>9</span><span>,</span> <span>1</span><span>,</span> <span>8</span><span>,</span> <span>0</span><span>)</span><span>;</span>
</span><span>    __m512i shuf_hi <span>=</span> <span>_mm512_set_epi64</span><span>(</span><span>15</span><span>,</span> <span>7</span><span>,</span> <span>14</span><span>,</span> <span>6</span><span>,</span> <span>13</span><span>,</span> <span>5</span><span>,</span> <span>12</span><span>,</span> <span>4</span><span>)</span><span>;</span>
</span><span>        accum<span>[</span><span>2</span> <span>*</span> i<span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span>accum<span>[</span><span>2</span><span>*</span>i<span>]</span><span>,</span> <span>_mm512_castpd_si512</span><span>(</span><span>_mm512_permutex2var_pd</span><span>(</span>diag_lo<span>,</span> shuf_lo<span>,</span> diag_hi<span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>    <span>if</span> <span>(</span>i <span>!=</span> <span>3</span><span>)</span> <span>{</span>
</span><span>        accum<span>[</span><span>2</span> <span>*</span> i <span>+</span> <span>1</span><span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span>accum<span>[</span><span>2</span><span>*</span>i<span>+</span><span>1</span><span>]</span><span>,</span> <span>_mm512_castpd_si512</span><span>(</span><span>_mm512_permutex2var_pd</span><span>(</span>diag_lo<span>,</span> shuf_hi<span>,</span> diag_hi<span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span></code></pre></div><p>Finally, we need to implement the reduction modulo 2<sup>1279</sup>-1. This is just a matter of selecting the upper 1279 bits and adding them to the lower 1279 bits. It&#39;s worth noting that at this point, the accumulator elements may exceed 2<sup>52</sup>-1, but we can delay carry propagation until after the addition.</p><div><pre><code><span>__m512i low_52_bits <span>=</span> <span>_mm512_set1_epi64</span><span>(</span><span>(</span><span>1ULL</span> <span>&lt;&lt;</span> <span>52</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
</span><span>__m512i hi_12_bits <span>=</span> <span>_mm512_set1_epi64</span><span>(</span><span>~</span><span>(</span><span>(</span><span>1ULL</span> <span>&lt;&lt;</span> <span>52</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
</span><span>
</span><span>__m512i high_1279<span>[</span><span>4</span><span>]</span><span>;</span>
</span><span><span>shift_down_1279</span><span>(</span>accum<span>,</span> high_1279<span>)</span><span>;</span>
</span><span><span>filter_low_1279</span><span>(</span>accum<span>)</span><span>;</span>
</span><span>
</span><span><span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>    accum<span>[</span>i<span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span>accum<span>[</span>i<span>]</span><span>,</span> high_1279<span>[</span>i<span>]</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>{</span>
</span><span>carry2<span>:</span><span>;</span>
</span><span>__m512i carry_test <span>=</span> <span>_mm512_setzero_si512</span><span>(</span><span>)</span><span>;</span>
</span><span>__m512i group_out <span>=</span> <span>_mm512_setzero_si512</span><span>(</span><span>)</span><span>;</span>
</span><span><span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>    __m512i carries <span>=</span> <span>_mm512_srli_epi64</span><span>(</span>accum<span>[</span>i<span>]</span><span>,</span> <span>52</span><span>)</span><span>;</span>
</span><span>    __m512i carries_into <span>=</span> <span>_mm512_alignr_epi64</span><span>(</span>carries<span>,</span> group_out<span>,</span> <span>7</span><span>)</span><span>;</span>
</span><span>    accum<span>[</span>i<span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span><span>_mm512_and_si512</span><span>(</span>accum<span>[</span>i<span>]</span><span>,</span> low_52_bits<span>)</span><span>,</span> carries_into<span>)</span><span>;</span>
</span><span>    group_out <span>=</span> carries<span>;</span>
</span><span>    carry_test <span>=</span> <span>_mm512_and_si512</span><span>(</span>carry_test<span>,</span> accum<span>[</span>i<span>]</span><span>)</span><span>;</span> 
</span><span><span>}</span>
</span><span>
</span><span><span>if</span> <span>(</span><span>__builtin_expect</span><span>(</span><span>_mm512_test_epi64_mask</span><span>(</span>carry_test<span>,</span> hi_12_bits<span>)</span><span>,</span> <span>0</span><span>)</span><span>)</span> <span>{</span>
</span><span>    <span>goto</span> carry2<span>;</span>
</span><span><span>}</span>
</span><span><span>}</span>
</span></code></pre></div><p>We then need to subtract the Mersenne modulus if the addition is too large, but this is easy to check: we perform the subtraction <em>iff</em> the 1280th bit is 1. Subtracting 2<sup>1279</sup>-1 is equivalent to subtracting 2<sup>1279</sup> (<em>i.e.</em>, zeroing the 1280th bit) followed by adding 1 to the least-significant limb. Because the subtraction occurs with 50% probability, we do it in a branchless manner:</p><div><pre><code><span>
</span><span>__m512i bit_1279 <span>=</span> <span>_mm512_set_epi64</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> 1ULL <span>&lt;&lt;</span> <span>31</span><span>)</span><span>;</span>
</span><span>__m512i mask_off <span>=</span> <span>_mm512_set_epi64</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>(</span>1ULL <span>&lt;&lt;</span> <span>31</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
</span><span>
</span><span>
</span><span>__m512i cmp <span>=</span> <span>_mm512_and_epi64</span><span>(</span>accum<span>[</span><span>3</span><span>]</span><span>,</span> bit_1279<span>)</span><span>;</span>
</span><span>accum<span>[</span><span>0</span><span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span>accum<span>[</span><span>0</span><span>]</span><span>,</span> <span>_mm512_srli_epi64</span><span>(</span>cmp<span>,</span> <span>31</span><span>)</span><span>)</span><span>;</span>  
</span><span>accum<span>[</span><span>3</span><span>]</span> <span>=</span> <span>_mm512_and_si512</span><span>(</span>mask_off<span>,</span> accum<span>[</span><span>3</span><span>]</span><span>)</span><span>;</span>
</span><span>
</span><span>
</span></code></pre></div><p>There is a tiny chance that an overflow occurs in this last step: if the last limb happened to be exactly 2<sup>52</sup>-1, then we&#39;d need to propagate the carry. However, because PoWs are randomly generated, the probability this happens on any given run is about 2 in a billion—so I just ignored it.</p><p>At this point, the PoW was taking about <strong>0.45 seconds</strong> on a rented Ryzen 9950X, which is a fast Zen 5 chip. Very promising!</p><p>The multiply–add instructions have a latency of 4 cycles, and 2 can start every cycle. Thus, we need at least eight accumulators to fully saturate the multipliers instead of bottlenecking on latency, but we only have seven (and some of them are only used occasionally). The solution is to have fourteen accumulators—one set for the low halves and one set for the high halves—then merge them at the end:</p><div><pre><code><span>__m512i accum<span>[</span><span>7</span><span>]</span> <span>=</span> <span>{</span> ZERO <span>,</span> ZERO <span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO <span>}</span><span>;</span>
</span><span>__m512i accum_hi<span>[</span><span>7</span><span>]</span> <span>=</span> <span>{</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO <span>}</span><span>;</span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span><span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>7</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>    accum<span>[</span>i<span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span>accum<span>[</span>i<span>]</span><span>,</span> accum_hi<span>[</span>i<span>]</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div><p>This brought the PoW down to roughly <strong>0.32 seconds</strong>. The expanded AVX512 register file, with 32 zmm registers, came in clutch here.</p><p>Inspecting the assembly revealed that both GCC and clang were unrolling the loop, converting the <em>_mm512_set1_epi64</em> instructions into <em>vbroadcastsd zmm, m64</em> instructions—one per limb—and then running out of vector registers during regalloc. Instead of rematerializing the values, they would stack-spill and reload the broadcasted vectors, causing considerable overhead.<sup><a href="#user-content-fn-numberworld" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-numberworld">7</a></sup></p><p>My solution was to use inline assembly to force the <em>vpmadd52luq</em>/<em>vpmadd52huq</em> instructions to use a <em>memory broadcast operand</em> for the multiplier limb. Instructions encoded with such an operand copy a single 32- or 64-bit element from memory to all elements of a vector operand, without consuming an architectural register. Moreover, this broadcast load does not consume any vector ALU resources: it is handled entirely by the load unit!</p><p>Now that we&#39;re using asm, the compiler can&#39;t remove masks of all 1s, so for optimal encoding we need separate asm for the all 1s case. Finally, when the multiplier limb happens to be at index zero in one of the zmm registers (<em>i.e.</em>, multiples of 8), we use <em>vpbroadcastq</em> to splat it from register to register, which I measured to be a performance improvement over loading it from memory. The accumulation sequence is now:</p><div><pre><code><span><span>if</span> <span>(</span>lo <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> lo <span>&lt;=</span> <span>24</span><span>)</span> <span>{</span>
</span><span>    
</span><span><span><span>#</span><span>define</span> <span>FOR_EACH_OFFS</span> <span><span>X</span><span>(</span><span>1</span><span>)</span> <span>X</span><span>(</span><span>2</span><span>)</span> <span>X</span><span>(</span><span>3</span><span>)</span> <span>X</span><span>(</span><span>4</span><span>)</span> <span>X</span><span>(</span><span>5</span><span>)</span> <span>X</span><span>(</span><span>6</span><span>)</span> <span>X</span><span>(</span><span>7</span><span>)</span> <span>X</span><span>(</span><span>9</span><span>)</span> <span>X</span><span>(</span><span>10</span><span>)</span> <span>X</span><span>(</span><span>11</span><span>)</span> <span>X</span><span>(</span><span>12</span><span>)</span> <span>X</span><span>(</span><span>13</span><span>)</span> <span>X</span><span>(</span><span>14</span><span>)</span> <span>X</span><span>(</span><span>15</span><span>)</span> <span>X</span><span>(</span><span>17</span><span>)</span> <span>X</span><span>(</span><span>18</span><span>)</span> <span>X</span><span>(</span><span>19</span><span>)</span> <span>X</span><span>(</span><span>20</span><span>)</span> <span>X</span><span>(</span><span>21</span><span>)</span> <span>X</span><span>(</span><span>22</span><span>)</span> <span>X</span><span>(</span><span>23</span><span>)</span></span></span>
</span><span>    __mmask8 sel <span>=</span> <span>(</span><span>uint8_t</span><span>)</span><span>(</span>lo <span>&lt;</span> i <span>?</span> <span>-</span><span>1ULL</span> <span>:</span> <span>(</span><span>-</span><span>1ULL</span> <span>&lt;&lt;</span> <span>(</span>lo <span>-</span> i <span>+</span> <span>1</span><span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>    <span>if</span> <span>(</span>sel <span>==</span> <span>(</span><span>uint8_t</span><span>)</span><span>-</span><span>1</span> <span>&amp;&amp;</span> ELIDE_MASKS_IF_POSSIBLE<span>)</span> <span>{</span>
</span><span><span><span>#</span><span>define</span> <span>X</span><span><span>(</span>n<span>)</span> <span>case</span> n<span>:</span> <span>asm</span> <span>volatile</span> <span>(</span></span><span>&#34;vpmadd52luq %0, %1, %2%{1to8%}&#34;</span> <span><span>:</span> </span><span>&#34;+v&#34;</span><span><span>(</span>accum<span>[</span>j<span>]</span><span>)</span> <span>:</span>  </span><span>&#34;v&#34;</span><span><span>(</span>m1<span>)</span><span>,</span> </span><span>&#34;m&#34;</span><span><span>(</span>data<span>[</span>n<span>]</span><span>)</span><span>)</span><span>;</span> <span>break</span><span>;</span></span></span>
</span><span>        <span>switch</span> <span>(</span>lo<span>)</span> <span>{</span>
</span><span>            FOR_EACH_OFFS
</span><span>            <span>default</span><span>:</span>
</span><span>            accum<span>[</span>j<span>]</span> <span>=</span> <span>_mm512_madd52lo_epu64</span><span>(</span>accum<span>[</span>j<span>]</span><span>,</span> m1<span>,</span> <span>_mm512_broadcast_i32x2</span><span>(</span><span>_mm512_castsi512_si128</span><span>(</span>clumps<span>[</span>lo<span>/</span> <span>8</span><span>]</span><span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>        <span>}</span>
</span><span>
</span><span>    <span>}</span> <span>else</span> <span>if</span> <span>(</span>sel<span>)</span> <span>{</span>
</span><span><span><span>#</span><span>define</span> <span>X</span><span><span>(</span>n<span>)</span> <span>case</span> n<span>:</span> <span>asm</span> <span>volatile</span> <span>(</span></span><span>&#34;vpmadd52luq %0 %{%1%}, %2, %3%{1to8%}&#34;</span> <span><span>:</span> </span><span>&#34;+v&#34;</span><span><span>(</span>accum<span>[</span>j<span>]</span><span>)</span> <span>:</span> </span><span>&#34;Yk&#34;</span><span><span>(</span>sel<span>)</span><span>,</span> </span><span>&#34;v&#34;</span><span><span>(</span>m1<span>)</span><span>,</span> </span><span>&#34;m&#34;</span><span><span>(</span>data<span>[</span>n<span>]</span><span>)</span><span>)</span><span>;</span> <span>break</span><span>;</span></span></span>
</span><span>        <span>switch</span> <span>(</span>lo<span>)</span> <span>{</span>
</span><span>            FOR_EACH_OFFS
</span><span>            <span>default</span><span>:</span>
</span><span>            accum<span>[</span>j<span>]</span> <span>=</span> <span>_mm512_mask_madd52lo_epu64</span><span>(</span>accum<span>[</span>j<span>]</span><span>,</span> sel<span>,</span> m1<span>,</span> <span>_mm512_broadcast_i32x2</span><span>(</span><span>_mm512_castsi512_si128</span><span>(</span>clumps<span>[</span>lo<span>/</span><span>8</span><span>]</span><span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>        <span>}</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span></code></pre></div><p>(This is just for the low set of accumulators; the high set is nearly identical.) At this point, the PoW was taking roughly <strong>0.23 seconds</strong>.</p><p>To compute the &#34;windows&#34;, we are storing the integer to memory in an aligned fashion, then loading from it in an unaligned fashion. This is a classic situation that causes a <a target="_blank" rel="noopener noreferrer" href="https://easyperf.net/blog/2018/03/09/Store-forwarding"><em>store-forwarding stall</em></a>, which further lengthens the critical path (the multiplications cannot commence until a window is loaded from memory). A better solution is to use the <em>valignq</em> instruction, which lets us simulate an unaligned load from the <em>clumps</em> array containing our integer.</p><div><pre><code><span>__m512i m1<span>;</span>
</span><span><span>if</span> <span>(</span><span>(</span>i <span>&amp;</span> <span>7</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
</span><span>    m1 <span>=</span> clumps<span>[</span>i <span>/</span> <span>8</span><span>]</span><span>;</span>
</span><span><span>}</span> <span>else</span> <span>{</span>
</span><span><span><span>#</span><span>define</span> <span>UNALIGNED</span><span><span>(</span>S<span>)</span> <span>case</span> S<span>:</span> <span>{</span> m1 <span>=</span> <span>_mm512_alignr_epi64</span><span>(</span>clumps<span>[</span><span>(</span>i<span>+</span><span>8</span><span>)</span><span>/</span><span>8</span><span>]</span><span>,</span> i <span>&lt;</span> <span>0</span> <span>?</span> <span>_mm512_setzero_si512</span><span>(</span><span>)</span> <span>:</span> clumps<span>[</span><span>(</span>i<span>+</span><span>8</span><span>)</span><span>/</span><span>8</span><span>-</span><span>1</span><span>]</span><span>,</span> S<span>)</span><span>;</span> <span>break</span><span>;</span> <span>}</span></span></span>
</span><span>    <span>switch</span> <span>(</span>i <span>&amp;</span> <span>7</span><span>)</span> <span>{</span>
</span><span>        <span>UNALIGNED</span><span>(</span><span>1</span><span>)</span>
</span><span>        <span>UNALIGNED</span><span>(</span><span>2</span><span>)</span>
</span><span>        <span>UNALIGNED</span><span>(</span><span>3</span><span>)</span>
</span><span>        <span>UNALIGNED</span><span>(</span><span>4</span><span>)</span>
</span><span>        <span>UNALIGNED</span><span>(</span><span>5</span><span>)</span>
</span><span>        <span>UNALIGNED</span><span>(</span><span>6</span><span>)</span>
</span><span>        <span>UNALIGNED</span><span>(</span><span>7</span><span>)</span>
</span><span>        <span>default</span><span>:</span> <span>abort</span><span>(</span><span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span></code></pre></div><p>This brought the PoW down to <strong>0.21 seconds</strong>. At this point, I decided to call it quits and sent my teammates the final C code.</p><p>My friends got up at 4:30 a.m. PST, May 16, to prepare for the final submission; I couldn&#39;t be assed to be awake, so I slept until 6:30. They spun up a Zen 5 Google Cloud server in the Netherlands, geographically closest to the Google Form submission server, to minimize latency. A few minutes before 5:00, they recorded an intercepted POST request submitting the Google form, but with a dummy flag. The form submission program was devised and optimized by Bryce Casaje (<a target="_blank" rel="noopener noreferrer" href="https://brycec.me/">strellic</a>) and Larry Yuan (<a target="_blank" rel="noopener noreferrer" href="https://larry.sh/">ehhthing</a>). <a target="_blank" rel="noopener noreferrer" href="https://max.xz.ax/">Max Cai</a> also assisted in development and submission. Then at 5:00, the server connected to the kernelCTF server, solved the proof of work, ran Savy&#39;s optimized exploit, inserted the flag into the POST request, and sent it off....</p><p><img alt="lol" loading="lazy" width="1526" height="94" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fstatic%2Fimages%2Four-kctf-submission.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fstatic%2Fimages%2Four-kctf-submission.png&amp;w=3840&amp;q=75 2x" src="https://anemato.de/_next/image?url=%2Fstatic%2Fimages%2Four-kctf-submission.png&amp;w=3840&amp;q=75"/></p><p>We got it in 3.6 seconds—the fastest-ever kernelCTF submission! Later that day, the kernelCTF organizers confirmed our eligibility for the bounty and we all breathed a collective sigh of relief. Again, congratulations to Savy and William for discovering and exploiting this bug! Thanks to them for presenting me with the challenge, and thanks to my CSE 260 professor Bryan Chin (<a target="_blank" rel="noopener noreferrer" href="https://sites.google.com/ucsd.edu/bryan-chin/home">website</a>) for what he taught us about program optimization.</p><p>On May 28, kernelCTF organizer koczkatamas announced that the proof of work was being removed:</p><p><img src="https://anemato.de/static/images/pow-is-gone.png" alt="PoW is gone" width="400"/></p><p>On the one hand, it&#39;s sad that we no longer have a competitive advantage, and the slot race becomes purely about exploit duration and network latency. On the other hand, at least people don&#39;t need to buy expensive FPGAs, or pull out their inline asm knowledge, to be on equal footing with the professionals. It also frees me to release this post!</p><p>Please message me on Discord (@forevermilk) if you have any comments or questions. I am also researching VDFs that are more resilient to assembly-level optimizations; if you have any ideas or would like to collaborate, I&#39;m all ears.</p><p>This code is the product (ha!) of about 12 hours of work across May 14 and 15, and it is correspondingly unclean. Consider it released under the GNU AGPL 3.0.</p><div><pre><code><span>
</span><span>
</span><span><span><span>#</span><span>include</span> <span>&lt;immintrin.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;gmp.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;string.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;stdlib.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;stdio.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;stdint.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;stddef.h&gt;</span></span>
</span><span>
</span><span><span><span>#</span><span>define</span> <span>uint128_t</span> <span>__uint128_t</span></span>
</span><span>
</span><span><span>void</span> <span>gmp_to_array</span><span>(</span><span>mpz_t</span> mpz<span>,</span> <span>uint64_t</span> <span>*</span>array<span>)</span> <span>{</span>
</span><span>    <span>size_t</span> N<span>;</span>
</span><span>    <span>mpz_export</span><span>(</span>array<span>,</span> <span>&amp;</span>N<span>,</span> <span>1</span><span>,</span> <span>sizeof</span><span>(</span><span>uint64_t</span><span>)</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> mpz<span>)</span><span>;</span>
</span><span>    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> N <span>-</span> <span>1</span><span>;</span> i <span>&lt;</span> j<span>;</span> <span>++</span>i<span>,</span> <span>--</span>j<span>)</span> <span>{</span>
</span><span>	    <span>uint64_t</span> temp <span>=</span> array<span>[</span>i<span>]</span><span>;</span>
</span><span>	    array<span>[</span>i<span>]</span> <span>=</span> array<span>[</span>j<span>]</span><span>;</span>
</span><span>	    array<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span><span>
</span><span>
</span><span><span>void</span> <span>array_to_gmp</span><span>(</span><span>uint64_t</span> <span>*</span>array<span>,</span> <span>mpz_t</span> mpz<span>,</span> <span>uint64_t</span> words<span>)</span> <span>{</span>
</span><span>    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> j <span>=</span> words <span>-</span> <span>1</span><span>;</span> i <span>&lt;</span> j<span>;</span> <span>++</span>i<span>,</span> <span>--</span>j<span>)</span> <span>{</span>
</span><span>	    <span>uint64_t</span> temp <span>=</span> array<span>[</span>i<span>]</span><span>;</span>
</span><span>	    array<span>[</span>i<span>]</span> <span>=</span> array<span>[</span>j<span>]</span><span>;</span>
</span><span>	    array<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>
</span><span>    <span>}</span>
</span><span>    <span>mpz_import</span><span>(</span>mpz<span>,</span> words<span>,</span> <span>1</span><span>,</span> <span>sizeof</span><span>(</span><span>uint64_t</span><span>)</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> array<span>)</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>size_t</span> <span>convert_radix_64_to_52</span><span>(</span><span>uint64_t</span> <span>*</span>limbs<span>,</span> <span>uint64_t</span> <span>*</span>out<span>,</span> <span>size_t</span> count<span>)</span> <span>{</span>
</span><span>    <span>size_t</span> out_index <span>=</span> <span>0</span><span>;</span>
</span><span>    <span>int</span> bits_in_buffer <span>=</span> <span>0</span><span>;</span>
</span><span>    <span>uint128_t</span> buffer <span>=</span> <span>0</span><span>;</span>
</span><span>
</span><span>    <span>for</span> <span>(</span><span>size_t</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> count<span>;</span> i<span>++</span><span>)</span> <span>{</span>
</span><span>        buffer <span>|=</span> <span>(</span><span>(</span><span>uint128_t</span><span>)</span>limbs<span>[</span>i<span>]</span><span>)</span> <span>&lt;&lt;</span> bits_in_buffer<span>;</span>
</span><span>        bits_in_buffer <span>+=</span> <span>64</span><span>;</span>
</span><span>
</span><span>        <span>while</span> <span>(</span>bits_in_buffer <span>&gt;=</span> <span>52</span><span>)</span> <span>{</span>
</span><span>            out<span>[</span>out_index<span>++</span><span>]</span> <span>=</span> <span>(</span><span>uint64_t</span><span>)</span><span>(</span>buffer <span>&amp;</span> <span>(</span><span>(</span><span>1ULL</span> <span>&lt;&lt;</span> <span>52</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
</span><span>            buffer <span>&gt;&gt;=</span> <span>52</span><span>;</span>
</span><span>            bits_in_buffer <span>-=</span> <span>52</span><span>;</span>
</span><span>        <span>}</span>
</span><span>    <span>}</span>
</span><span>
</span><span>    
</span><span>    <span>if</span> <span>(</span>bits_in_buffer <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
</span><span>        out<span>[</span>out_index<span>++</span><span>]</span> <span>=</span> <span>(</span><span>uint64_t</span><span>)</span><span>(</span>buffer <span>&amp;</span> <span>(</span><span>(</span><span>1ULL</span> <span>&lt;&lt;</span> bits_in_buffer<span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span>
</span><span>    <span>return</span> out_index<span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>size_t</span> <span>convert_radix_52_to_64</span><span>(</span><span>uint64_t</span> <span>*</span>in<span>,</span> <span>uint64_t</span> <span>*</span>out<span>,</span> <span>size_t</span> count<span>)</span> <span>{</span>
</span><span>    <span>size_t</span> out_index <span>=</span> <span>0</span><span>;</span>
</span><span>    <span>int</span> bits_in_buffer <span>=</span> <span>0</span><span>;</span>
</span><span>    <span>uint128_t</span> buffer <span>=</span> <span>0</span><span>;</span>
</span><span>
</span><span>    <span>for</span> <span>(</span><span>size_t</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> count<span>;</span> i<span>++</span><span>)</span> <span>{</span>
</span><span>        buffer <span>|=</span> <span>(</span><span>(</span><span>uint128_t</span><span>)</span>in<span>[</span>i<span>]</span><span>)</span> <span>&lt;&lt;</span> bits_in_buffer<span>;</span>
</span><span>        bits_in_buffer <span>+=</span> <span>52</span><span>;</span>
</span><span>
</span><span>        <span>while</span> <span>(</span>bits_in_buffer <span>&gt;=</span> <span>64</span><span>)</span> <span>{</span>
</span><span>            out<span>[</span>out_index<span>++</span><span>]</span> <span>=</span> <span>(</span><span>uint64_t</span><span>)</span><span>(</span>buffer <span>&amp;</span> <span>(</span><span>(</span><span>(</span><span>uint128_t</span><span>)</span><span>1ULL</span> <span>&lt;&lt;</span> <span>64</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
</span><span>            buffer <span>&gt;&gt;=</span> <span>64</span><span>;</span>
</span><span>            bits_in_buffer <span>-=</span> <span>64</span><span>;</span>
</span><span>        <span>}</span>
</span><span>    <span>}</span>
</span><span>
</span><span>    
</span><span>    <span>if</span> <span>(</span>bits_in_buffer <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
</span><span>        out<span>[</span>out_index<span>++</span><span>]</span> <span>=</span> <span>(</span><span>uint64_t</span><span>)</span><span>(</span>buffer <span>&amp;</span> <span>(</span><span>(</span><span>1ULL</span> <span>&lt;&lt;</span> bits_in_buffer<span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span>
</span><span>    <span>return</span> out_index<span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>__attribute__</span><span>(</span><span>(</span>always_inline<span>)</span><span>)</span> <span>void</span> <span>shift_down_1279</span><span>(</span>__m512i accum<span>[</span><span>7</span><span>]</span><span>,</span> __m512i high_1279<span>[</span><span>4</span><span>]</span><span>)</span> <span>{</span>
</span><span>	__m512i p <span>=</span> <span>_mm512_setzero_si512</span><span>(</span><span>)</span><span>;</span>
</span><span><span><span>#</span><span>pragma</span> <span>GCC unroll <span>4</span></span></span>
</span><span>	<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>3</span><span>;</span> i <span>&gt;=</span> <span>0</span><span>;</span> <span>--</span>i<span>)</span> <span>{</span>
</span><span>		__m512i down_31 <span>=</span> <span>_mm512_srli_epi64</span><span>(</span>accum<span>[</span>i <span>+</span> <span>3</span><span>]</span><span>,</span> <span>31</span><span>)</span><span>;</span>
</span><span>		__m512i higher_21 <span>=</span> <span>_mm512_slli_epi64</span><span>(</span><span>_mm512_and_si512</span><span>(</span>accum<span>[</span>i <span>+</span> <span>3</span><span>]</span><span>,</span> <span>_mm512_set1_epi64</span><span>(</span><span>(</span><span>1ULL</span> <span>&lt;&lt;</span> <span>31</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>,</span> <span>21</span><span>)</span><span>;</span>
</span><span>		high_1279<span>[</span>i<span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span><span>_mm512_alignr_epi64</span><span>(</span>p<span>,</span> higher_21<span>,</span> <span>1</span><span>)</span><span>,</span> down_31<span>)</span><span>;</span>
</span><span>		p <span>=</span> higher_21<span>;</span>
</span><span>	<span>}</span>
</span><span><span>}</span>
</span><span>
</span><span><span>__attribute__</span><span>(</span><span>(</span>always_inline<span>)</span><span>)</span> <span>void</span> <span>filter_low_1279</span><span>(</span>__m512i accum<span>[</span><span>7</span><span>]</span><span>)</span> <span>{</span>
</span><span>	accum<span>[</span><span>3</span><span>]</span> <span>=</span> <span>_mm512_and_si512</span><span>(</span>accum<span>[</span><span>3</span><span>]</span><span>,</span> <span>_mm512_set_epi64</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>(</span><span>1ULL</span> <span>&lt;&lt;</span> <span>31</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span>
</span><span>
</span><span><span>void</span> <span>the_powmod</span><span>(</span><span>uint64_t</span> <span>*</span> __restrict__ input<span>,</span> <span>uint64_t</span> <span>*</span> __restrict__ result<span>)</span> <span>{</span>
</span><span>	<span>_Alignas</span><span>(</span><span>64</span><span>)</span> <span>uint64_t</span> padded_data<span>[</span><span>8</span> <span>*</span> <span>6</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>}</span><span>;</span>
</span><span>	<span>uint64_t</span> <span>*</span>data <span>=</span> padded_data <span>+</span> <span>8</span><span>;</span>
</span><span>
</span><span>	__m512i clumps<span>[</span><span>4</span><span>]</span> <span>=</span> <span>{</span>
</span><span>		<span>_mm512_loadu_si512</span><span>(</span>input<span>)</span><span>,</span>
</span><span>		<span>_mm512_loadu_si512</span><span>(</span>input <span>+</span> <span>8</span><span>)</span><span>,</span>
</span><span>		<span>_mm512_loadu_si512</span><span>(</span>input <span>+</span> <span>16</span><span>)</span><span>,</span>
</span><span>		<span>_mm512_loadu_si512</span><span>(</span>input <span>+</span> <span>24</span><span>)</span>
</span><span>	<span>}</span><span>;</span>
</span><span>
</span><span>	<span>for</span> <span>(</span><span>int</span> pow_i <span>=</span> <span>0</span><span>;</span> pow_i <span>&lt;</span> <span>1277</span><span>;</span> <span>++</span>pow_i<span>)</span> <span>{</span>
</span><span>		
</span><span>		<span>_mm512_store_si512</span><span>(</span>data<span>,</span> clumps<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
</span><span>		<span>_mm512_store_si512</span><span>(</span>data <span>+</span> <span>8</span><span>,</span> clumps<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
</span><span>		<span>_mm512_store_si512</span><span>(</span>data <span>+</span> <span>16</span><span>,</span> clumps<span>[</span><span>2</span><span>]</span><span>)</span><span>;</span>
</span><span>		<span>_mm512_store_si512</span><span>(</span>data <span>+</span> <span>24</span><span>,</span> clumps<span>[</span><span>3</span><span>]</span><span>)</span><span>;</span>
</span><span>
</span><span>	
</span><span><span><span>#</span><span>define</span> <span>ZERO</span> <span><span>_mm512_setzero_si512</span><span>(</span><span>)</span></span></span>
</span><span>
</span><span><span><span>#</span><span>define</span> <span>ELIDE_MASKS_IF_POSSIBLE</span> <span><span>1</span></span></span>
</span><span>
</span><span>	__m512i accum<span>[</span><span>7</span><span>]</span> <span>=</span> <span>{</span> ZERO <span>,</span> ZERO <span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO <span>}</span><span>;</span>
</span><span>	
</span><span>	__m512i accum_hi<span>[</span><span>7</span><span>]</span> <span>=</span> <span>{</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO<span>,</span> ZERO <span>}</span><span>;</span>
</span><span>	
</span><span><span><span>#</span><span>pragma</span> <span>GCC unroll <span>100</span></span></span>
</span><span>	<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>24</span><span>;</span> i <span>&gt;=</span> <span>-</span><span>7</span><span>;</span> <span>--</span>i<span>)</span> <span>{</span>
</span><span>		
</span><span>		__m512i m1<span>;</span>
</span><span>		<span>if</span> <span>(</span><span>(</span>i <span>&amp;</span> <span>7</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
</span><span>			m1 <span>=</span> clumps<span>[</span>i <span>/</span> <span>8</span><span>]</span><span>;</span>
</span><span>		<span>}</span> <span>else</span> <span>{</span>
</span><span>			
</span><span><span><span>#</span><span>define</span> <span>UNALIGNED</span><span><span>(</span>S<span>)</span> <span>case</span> S<span>:</span> <span>{</span> m1 <span>=</span> <span>_mm512_alignr_epi64</span><span>(</span>clumps<span>[</span><span>(</span>i<span>+</span><span>8</span><span>)</span><span>/</span><span>8</span><span>]</span><span>,</span> i <span>&lt;</span> <span>0</span> <span>?</span> <span>_mm512_setzero_si512</span><span>(</span><span>)</span> <span>:</span> clumps<span>[</span><span>(</span>i<span>+</span><span>8</span><span>)</span><span>/</span><span>8</span><span>-</span><span>1</span><span>]</span><span>,</span> S<span>)</span><span>;</span> <span>break</span><span>;</span> <span>}</span></span></span>
</span><span>			<span>switch</span> <span>(</span>i <span>&amp;</span> <span>7</span><span>)</span> <span>{</span>
</span><span>				<span>UNALIGNED</span><span>(</span><span>1</span><span>)</span>
</span><span>				<span>UNALIGNED</span><span>(</span><span>2</span><span>)</span>
</span><span>				<span>UNALIGNED</span><span>(</span><span>3</span><span>)</span>
</span><span>				<span>UNALIGNED</span><span>(</span><span>4</span><span>)</span>
</span><span>				<span>UNALIGNED</span><span>(</span><span>5</span><span>)</span>
</span><span>				<span>UNALIGNED</span><span>(</span><span>6</span><span>)</span>
</span><span>				<span>UNALIGNED</span><span>(</span><span>7</span><span>)</span>
</span><span>				<span>default</span><span>:</span> <span>abort</span><span>(</span><span>)</span><span>;</span>
</span><span>			<span>}</span>
</span><span>		<span>}</span>
</span><span>
</span><span><span><span>#</span><span>pragma</span> <span>GCC unroll <span>100</span></span></span>
</span><span>		<span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>,</span> k <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>7</span><span>;</span> <span>++</span>j<span>,</span> k <span>+=</span> <span>8</span><span>)</span> <span>{</span>
</span><span>			
</span><span>			
</span><span>			<span>int</span> lo <span>=</span> k <span>-</span> i<span>;</span>
</span><span>			<span>int</span> hi <span>=</span> k <span>-</span> i <span>-</span> <span>1</span><span>;</span>
</span><span>			<span>if</span> <span>(</span>lo <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> lo <span>&lt;=</span> <span>24</span><span>)</span> <span>{</span>
</span><span>				
</span><span><span><span>#</span><span>define</span> <span>FOR_EACH_OFFS</span> <span><span>X</span><span>(</span><span>1</span><span>)</span> <span>X</span><span>(</span><span>2</span><span>)</span> <span>X</span><span>(</span><span>3</span><span>)</span> <span>X</span><span>(</span><span>4</span><span>)</span> <span>X</span><span>(</span><span>5</span><span>)</span> <span>X</span><span>(</span><span>6</span><span>)</span> <span>X</span><span>(</span><span>7</span><span>)</span> <span>X</span><span>(</span><span>9</span><span>)</span> <span>X</span><span>(</span><span>10</span><span>)</span> <span>X</span><span>(</span><span>11</span><span>)</span> <span>X</span><span>(</span><span>12</span><span>)</span> <span>X</span><span>(</span><span>13</span><span>)</span> <span>X</span><span>(</span><span>14</span><span>)</span> <span>X</span><span>(</span><span>15</span><span>)</span> <span>X</span><span>(</span><span>17</span><span>)</span> <span>X</span><span>(</span><span>18</span><span>)</span> <span>X</span><span>(</span><span>19</span><span>)</span> <span>X</span><span>(</span><span>20</span><span>)</span> <span>X</span><span>(</span><span>21</span><span>)</span> <span>X</span><span>(</span><span>22</span><span>)</span> <span>X</span><span>(</span><span>23</span><span>)</span></span></span>
</span><span>				
</span><span>				__mmask8 sel <span>=</span> <span>(</span><span>uint8_t</span><span>)</span><span>(</span>lo <span>&lt;</span> i <span>?</span> <span>-</span><span>1ULL</span> <span>:</span> <span>(</span><span>-</span><span>1ULL</span> <span>&lt;&lt;</span> <span>(</span>lo <span>-</span> i <span>+</span> <span>1</span><span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>				
</span><span>				<span>if</span> <span>(</span>sel <span>==</span> <span>(</span><span>uint8_t</span><span>)</span><span>-</span><span>1</span> <span>&amp;&amp;</span> ELIDE_MASKS_IF_POSSIBLE<span>)</span> <span>{</span>
</span><span><span><span>#</span><span>define</span> <span>X</span><span><span>(</span>n<span>)</span> <span>case</span> n<span>:</span> <span>asm</span> <span>volatile</span> <span>(</span></span><span>&#34;vpmadd52luq %0, %1, %2%{1to8%}&#34;</span> <span><span>:</span> </span><span>&#34;+v&#34;</span><span><span>(</span>accum<span>[</span>j<span>]</span><span>)</span> <span>:</span>  </span><span>&#34;v&#34;</span><span><span>(</span>m1<span>)</span><span>,</span> </span><span>&#34;m&#34;</span><span><span>(</span>data<span>[</span>n<span>]</span><span>)</span><span>)</span><span>;</span> <span>break</span><span>;</span></span></span>
</span><span>					<span>switch</span> <span>(</span>lo<span>)</span> <span>{</span>
</span><span>						FOR_EACH_OFFS
</span><span>						<span>default</span><span>:</span>
</span><span>						accum<span>[</span>j<span>]</span> <span>=</span> <span>_mm512_madd52lo_epu64</span><span>(</span>accum<span>[</span>j<span>]</span><span>,</span> m1<span>,</span> <span>_mm512_broadcast_i32x2</span><span>(</span><span>_mm512_castsi512_si128</span><span>(</span>clumps<span>[</span>lo<span>/</span> <span>8</span><span>]</span><span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>					<span>}</span>
</span><span>
</span><span>				<span>}</span> <span>else</span> <span>if</span> <span>(</span>sel<span>)</span> <span>{</span>
</span><span><span><span>#</span><span>define</span> <span>X</span><span><span>(</span>n<span>)</span> <span>case</span> n<span>:</span> <span>asm</span> <span>volatile</span> <span>(</span></span><span>&#34;vpmadd52luq %0 %{%1%}, %2, %3%{1to8%}&#34;</span> <span><span>:</span> </span><span>&#34;+v&#34;</span><span><span>(</span>accum<span>[</span>j<span>]</span><span>)</span> <span>:</span> </span><span>&#34;Yk&#34;</span><span><span>(</span>sel<span>)</span><span>,</span> </span><span>&#34;v&#34;</span><span><span>(</span>m1<span>)</span><span>,</span> </span><span>&#34;m&#34;</span><span><span>(</span>data<span>[</span>n<span>]</span><span>)</span><span>)</span><span>;</span> <span>break</span><span>;</span></span></span>
</span><span>					<span>switch</span> <span>(</span>lo<span>)</span> <span>{</span>
</span><span>						FOR_EACH_OFFS
</span><span>						<span>default</span><span>:</span>
</span><span>						accum<span>[</span>j<span>]</span> <span>=</span> <span>_mm512_mask_madd52lo_epu64</span><span>(</span>accum<span>[</span>j<span>]</span><span>,</span> sel<span>,</span> m1<span>,</span> <span>_mm512_broadcast_i32x2</span><span>(</span><span>_mm512_castsi512_si128</span><span>(</span>clumps<span>[</span>lo<span>/</span><span>8</span><span>]</span><span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>					<span>}</span>
</span><span>				<span>}</span>
</span><span>			<span>}</span>
</span><span>
</span><span>			<span>if</span> <span>(</span>hi <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> hi <span>&lt;=</span> <span>24</span><span>)</span> <span>{</span>
</span><span><span><span>#</span><span>undef</span> <span>X</span></span>
</span><span>				__mmask8 sel <span>=</span> <span>(</span><span>uint8_t</span><span>)</span><span>(</span>hi <span>&lt;</span> i <span>?</span> <span>-</span><span>1ULL</span> <span>:</span> <span>(</span><span>-</span><span>1ULL</span> <span>&lt;&lt;</span> <span>(</span>hi <span>-</span> i <span>+</span> <span>1</span><span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>				
</span><span>				<span>if</span> <span>(</span>sel <span>==</span> <span>(</span><span>uint8_t</span><span>)</span><span>-</span><span>1</span> <span>&amp;&amp;</span> ELIDE_MASKS_IF_POSSIBLE<span>)</span> <span>{</span>
</span><span><span><span>#</span><span>define</span> <span>X</span><span><span>(</span>n<span>)</span> <span>case</span> n<span>:</span> <span>asm</span> <span>volatile</span> <span>(</span></span><span>&#34;vpmadd52huq %0, %1, %2%{1to8%}&#34;</span> <span><span>:</span> </span><span>&#34;+v&#34;</span><span><span>(</span>accum_hi<span>[</span>j<span>]</span><span>)</span> <span>:</span> </span><span>&#34;v&#34;</span><span><span>(</span>m1<span>)</span><span>,</span> </span><span>&#34;m&#34;</span><span><span>(</span>data<span>[</span>n<span>]</span><span>)</span><span>)</span><span>;</span> <span>break</span><span>;</span></span></span>
</span><span>				<span>switch</span> <span>(</span>hi<span>)</span> <span>{</span>
</span><span>					FOR_EACH_OFFS
</span><span>					<span>default</span><span>:</span>
</span><span>					accum_hi<span>[</span>j<span>]</span> <span>=</span> <span>_mm512_madd52hi_epu64</span><span>(</span>accum_hi<span>[</span>j<span>]</span><span>,</span> m1<span>,</span> <span>_mm512_broadcast_i32x2</span><span>(</span><span>_mm512_castsi512_si128</span><span>(</span>clumps<span>[</span>hi <span>/</span> <span>8</span><span>]</span><span>)</span><span>)</span> <span>)</span><span>;</span>
</span><span>				<span>}</span>
</span><span>				<span>}</span> <span>else</span> <span>if</span> <span>(</span>sel<span>)</span> <span>{</span>
</span><span>
</span><span><span><span>#</span><span>define</span> <span>X</span><span><span>(</span>n<span>)</span> <span>case</span> n<span>:</span> <span>asm</span> <span>volatile</span> <span>(</span></span><span>&#34;vpmadd52huq %0 %{%1%}, %2, %3%{1to8%}&#34;</span> <span><span>:</span> </span><span>&#34;+v&#34;</span><span><span>(</span>accum_hi<span>[</span>j<span>]</span><span>)</span> <span>:</span> </span><span>&#34;Yk&#34;</span><span><span>(</span>sel<span>)</span><span>,</span> </span><span>&#34;v&#34;</span><span><span>(</span>m1<span>)</span><span>,</span> </span><span>&#34;m&#34;</span><span><span>(</span>data<span>[</span>n<span>]</span><span>)</span><span>)</span><span>;</span> <span>break</span><span>;</span></span></span>
</span><span>				<span>switch</span> <span>(</span>hi<span>)</span> <span>{</span>
</span><span>					FOR_EACH_OFFS
</span><span>					<span>default</span><span>:</span>
</span><span>					accum_hi<span>[</span>j<span>]</span> <span>=</span> <span>_mm512_mask_madd52hi_epu64</span><span>(</span>accum_hi<span>[</span>j<span>]</span><span>,</span> sel<span>,</span> m1<span>,</span><span>_mm512_broadcast_i32x2</span><span>(</span><span>_mm512_castsi512_si128</span><span>(</span>clumps<span>[</span>hi <span>/</span> <span>8</span><span>]</span><span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>				<span>}</span>
</span><span>				<span>}</span>
</span><span>			<span>}</span>
</span><span>
</span><span>		<span>}</span>
</span><span>	<span>}</span>
</span><span>
</span><span>	
</span><span><span><span>#</span><span>pragma</span> <span>GCC unroll <span>7</span></span></span>
</span><span>	<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>7</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>		accum<span>[</span>i<span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span>accum<span>[</span>i<span>]</span><span>,</span> accum_hi<span>[</span>i<span>]</span><span>)</span><span>;</span>
</span><span>		accum<span>[</span>i<span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span>accum<span>[</span>i<span>]</span><span>,</span> accum<span>[</span>i<span>]</span><span>)</span><span>;</span>
</span><span>	<span>}</span>
</span><span>
</span><span>	
</span><span><span><span>#</span><span>pragma</span> <span>GCC unroll <span>4</span></span></span>
</span><span>	<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>		__m512d diag_lo <span>=</span> <span>_mm512_castsi512_pd</span><span>(</span><span>_mm512_madd52lo_epu64</span><span>(</span>ZERO<span>,</span> clumps<span>[</span>i<span>]</span><span>,</span> clumps<span>[</span>i<span>]</span><span>)</span><span>)</span><span>;</span>
</span><span>		__m512d diag_hi <span>=</span> <span>_mm512_castsi512_pd</span><span>(</span><span>_mm512_madd52hi_epu64</span><span>(</span>ZERO<span>,</span> clumps<span>[</span>i<span>]</span><span>,</span> clumps<span>[</span>i<span>]</span><span>)</span><span>)</span><span>;</span>
</span><span>		__m512i shuf_lo <span>=</span> <span>_mm512_set_epi64</span><span>(</span><span>11</span><span>,</span> <span>3</span><span>,</span> <span>10</span><span>,</span> <span>2</span><span>,</span> <span>9</span><span>,</span> <span>1</span><span>,</span> <span>8</span><span>,</span> <span>0</span><span>)</span><span>;</span>
</span><span>		__m512i shuf_hi <span>=</span> <span>_mm512_set_epi64</span><span>(</span><span>15</span><span>,</span> <span>7</span><span>,</span> <span>14</span><span>,</span> <span>6</span><span>,</span> <span>13</span><span>,</span> <span>5</span><span>,</span> <span>12</span><span>,</span> <span>4</span><span>)</span><span>;</span>
</span><span>	        accum<span>[</span><span>2</span> <span>*</span> i<span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span>accum<span>[</span><span>2</span><span>*</span>i<span>]</span><span>,</span> <span>_mm512_castpd_si512</span><span>(</span><span>_mm512_permutex2var_pd</span><span>(</span>diag_lo<span>,</span> shuf_lo<span>,</span> diag_hi<span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>		<span>if</span> <span>(</span>i <span>!=</span> <span>3</span><span>)</span> <span>{</span>
</span><span>			accum<span>[</span><span>2</span> <span>*</span> i <span>+</span> <span>1</span><span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span>accum<span>[</span><span>2</span><span>*</span>i<span>+</span><span>1</span><span>]</span><span>,</span> <span>_mm512_castpd_si512</span><span>(</span><span>_mm512_permutex2var_pd</span><span>(</span>diag_lo<span>,</span> shuf_hi<span>,</span> diag_hi<span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>		<span>}</span>
</span><span>	<span>}</span>
</span><span>
</span><span>	
</span><span>	__m512i low_52_bits <span>=</span> <span>_mm512_set1_epi64</span><span>(</span><span>(</span><span>1ULL</span> <span>&lt;&lt;</span> <span>52</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
</span><span>	__m512i hi_12_bits <span>=</span> <span>_mm512_set1_epi64</span><span>(</span><span>~</span><span>(</span><span>(</span><span>1ULL</span> <span>&lt;&lt;</span> <span>52</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
</span><span>
</span><span>	
</span><span>	__m512i high_1279<span>[</span><span>4</span><span>]</span><span>;</span>
</span><span>	<span>shift_down_1279</span><span>(</span>accum<span>,</span> high_1279<span>)</span><span>;</span>
</span><span>	<span>filter_low_1279</span><span>(</span>accum<span>)</span><span>;</span>
</span><span>
</span><span><span><span>#</span><span>pragma</span> <span>GCC unroll <span>4</span></span></span>
</span><span>	<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>		accum<span>[</span>i<span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span>accum<span>[</span>i<span>]</span><span>,</span> high_1279<span>[</span>i<span>]</span><span>)</span><span>;</span>
</span><span>	<span>}</span>
</span><span>
</span><span>	<span>{</span>
</span><span>carry2<span>:</span><span>;</span>
</span><span>	__m512i carry_test <span>=</span> <span>_mm512_setzero_si512</span><span>(</span><span>)</span><span>;</span>
</span><span>	__m512i group_out <span>=</span> <span>_mm512_setzero_si512</span><span>(</span><span>)</span><span>;</span>
</span><span><span><span>#</span><span>pragma</span> <span>GCC unroll <span>7</span></span></span>
</span><span>	<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>		__m512i carries <span>=</span> <span>_mm512_srli_epi64</span><span>(</span>accum<span>[</span>i<span>]</span><span>,</span> <span>52</span><span>)</span><span>;</span>
</span><span>		__m512i carries_into <span>=</span> <span>_mm512_alignr_epi64</span><span>(</span>carries<span>,</span> group_out<span>,</span> <span>7</span><span>)</span><span>;</span>
</span><span>		accum<span>[</span>i<span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span><span>_mm512_and_si512</span><span>(</span>accum<span>[</span>i<span>]</span><span>,</span> low_52_bits<span>)</span><span>,</span> carries_into<span>)</span><span>;</span>
</span><span>		group_out <span>=</span> carries<span>;</span>
</span><span>		carry_test <span>=</span> <span>_mm512_and_si512</span><span>(</span>carry_test<span>,</span> accum<span>[</span>i<span>]</span><span>)</span><span>;</span> 
</span><span>	<span>}</span>
</span><span>
</span><span>	<span>if</span> <span>(</span><span>__builtin_expect</span><span>(</span><span>_mm512_test_epi64_mask</span><span>(</span>carry_test<span>,</span> hi_12_bits<span>)</span><span>,</span> <span>0</span><span>)</span><span>)</span> <span>{</span>
</span><span>		<span>goto</span> carry2<span>;</span>
</span><span>	<span>}</span>
</span><span>	<span>}</span>
</span><span>
</span><span>	
</span><span>	__m512i bit_1279 <span>=</span> <span>_mm512_set_epi64</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>1ULL</span> <span>&lt;&lt;</span> <span>31</span><span>)</span><span>;</span>
</span><span>	__m512i mask_off <span>=</span> <span>_mm512_set_epi64</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>(</span><span>1ULL</span> <span>&lt;&lt;</span> <span>31</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
</span><span>
</span><span>	
</span><span>	__m512i cmp <span>=</span> <span>_mm512_and_epi64</span><span>(</span>accum<span>[</span><span>3</span><span>]</span><span>,</span> bit_1279<span>)</span><span>;</span>
</span><span>	accum<span>[</span><span>0</span><span>]</span> <span>=</span> <span>_mm512_add_epi64</span><span>(</span>accum<span>[</span><span>0</span><span>]</span><span>,</span> <span>_mm512_srli_epi64</span><span>(</span>cmp<span>,</span> <span>31</span><span>)</span><span>)</span><span>;</span>  
</span><span>	accum<span>[</span><span>3</span><span>]</span> <span>=</span> <span>_mm512_and_si512</span><span>(</span>mask_off<span>,</span> accum<span>[</span><span>3</span><span>]</span><span>)</span><span>;</span>
</span><span>
</span><span>	
</span><span>
</span><span><span><span>#</span><span>pragma</span> <span>GCC unroll <span>4</span></span></span>
</span><span>	<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
</span><span>		clumps<span>[</span>i<span>]</span> <span>=</span> accum<span>[</span>i<span>]</span><span>;</span>
</span><span>	<span>}</span>
</span><span>	<span>}</span>
</span><span>
</span><span>	<span>_mm512_storeu_si512</span><span>(</span>result<span>,</span> clumps<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
</span><span>	<span>_mm512_storeu_si512</span><span>(</span>result <span>+</span> <span>8</span><span>,</span> clumps<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
</span><span>	<span>_mm512_storeu_si512</span><span>(</span>result <span>+</span> <span>16</span><span>,</span> clumps<span>[</span><span>2</span><span>]</span><span>)</span><span>;</span>
</span><span>	<span>_mm512_storeu_si512</span><span>(</span>result <span>+</span> <span>24</span><span>,</span> clumps<span>[</span><span>3</span><span>]</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>int</span> <span>main</span><span>(</span><span>int</span> argc<span>,</span> <span>char</span> <span>*</span><span>*</span>argv<span>)</span> <span>{</span>
</span><span>	<span>if</span> <span>(</span>argc <span>&lt;</span> <span>3</span><span>)</span> <span>{</span>
</span><span>		<span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Usage: %s &lt;y&gt; &lt;difficulty&gt;&#34;</span><span>,</span> argv<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
</span><span>		<span>return</span> <span>1</span><span>;</span>
</span><span>	<span>}</span>
</span><span>
</span><span>	<span>mpz_t</span> x<span>,</span> r<span>;</span>
</span><span>	<span>mpz_inits</span><span>(</span>x<span>,</span> r<span>,</span> <span>NULL</span><span>)</span><span>;</span>
</span><span>	<span>mpz_set_str</span><span>(</span>x<span>,</span> argv<span>[</span><span>1</span><span>]</span><span>,</span> <span>10</span><span>)</span><span>;</span>
</span><span>	<span>int</span> difficulty <span>=</span> <span>atoi</span><span>(</span>argv<span>[</span><span>2</span><span>]</span><span>)</span><span>;</span>
</span><span>
</span><span>	<span>uint64_t</span> abc<span>[</span><span>400</span><span>]</span><span>;</span>
</span><span>	<span>_Alignas</span><span>(</span><span>64</span><span>)</span> <span>uint64_t</span> poop<span>[</span><span>32</span><span>]</span><span>;</span>
</span><span>
</span><span>	<span>gmp_to_array</span><span>(</span>x<span>,</span> abc<span>)</span><span>;</span>
</span><span>
</span><span>	<span>size_t</span> N <span>=</span> <span>convert_radix_64_to_52</span><span>(</span>abc<span>,</span> poop<span>,</span> <span>20</span><span>)</span><span>;</span>
</span><span>
</span><span>	<span>uint64_t</span> squared<span>[</span><span>1000</span><span>]</span><span>;</span>
</span><span>	<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> difficulty<span>;</span> <span>++</span>i<span>)</span> <span>{</span> 
</span><span>		<span>the_powmod</span><span>(</span>poop<span>,</span> squared<span>)</span><span>;</span>
</span><span>		squared<span>[</span><span>0</span><span>]</span> <span>^=</span> <span>1</span><span>;</span>
</span><span>		<span>memcpy</span><span>(</span>poop<span>,</span> squared<span>,</span> <span>25</span> <span>*</span> <span>sizeof</span><span>(</span><span>uint64_t</span><span>)</span><span>)</span><span>;</span>
</span><span>	<span>}</span>
</span><span>	<span>convert_radix_52_to_64</span><span>(</span>squared<span>,</span> abc<span>,</span> <span>48</span><span>)</span><span>;</span>
</span><span>	<span>array_to_gmp</span><span>(</span>abc<span>,</span> r<span>,</span> <span>1280</span><span>/</span><span>64</span><span>)</span><span>;</span>
</span><span>
</span><span>	<span>char</span> <span>*</span>str <span>=</span> <span>mpz_get_str</span><span>(</span><span>NULL</span><span>,</span> <span>10</span><span>,</span> r<span>)</span><span>;</span>
</span><span>	<span>printf</span><span>(</span><span>&#34;%s&#34;</span><span>,</span> str<span>)</span><span>;</span>
</span><span>	<span>return</span> <span>0</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div><p>I hope you enjoyed my first-ever blog post. Hopefully there will be many more.</p></div></div></div></div></article></section></main></section></div>
  </body>
</html>
