<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codestyleandtaste.com/globals-are-not-the-problem.html">Original</a>
    <h1>Global variables are not the problem</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<div>
	
	<p>A blog where I share thoughts on code and practices</p>
</div>
</div>

<p>In this article I&#39;ll show an example where avoiding a global variable has led to a bug, I&#39;ll define what global variables are, explain the problem, and then give examples where I have used them successfully.</p>

<h2 id="title">Global Variables Are Not the Problem</h2>

<div>

<p>We&#39;re all taught that global variables are bad. They can be modified from anywhere, sometimes force functions to be called in a specific order, and can be impossible to debug if the program is large enough or the state is random enough. We&#39;re usually taught not to use them within the first year of programming, but many of us never figure out when we should.</p>

<p>First, we&#39;ll look at code without globals. Here we want to see how many times the &#39;simple&#39; function is entered before it throws an exception (not shown) so we can set a breakpoint at the top of the function. There&#39;s a bug in our counter logic. If the problem isn&#39;t obvious you may find this frustrating.
</p>

<pre><code>let counter = { count:0 }
let obj = { counter:counter };
function simple(obj) { 
	console.log(++obj.counter.count) 
	if (obj.counter.count == 123) {
		//let&#39;s set a breakpoint before the exception
	}
	/* rest of func with buggy logic */
}
function complex(obj) {
	let temp = structuredClone(obj)
	simple(temp)
	simple(temp)		
}
simple(obj)
simple(obj)
complex(obj)
simple(obj)
</code></pre>

<p>If you run the code you&#39;ll see 1 2 3 4 3 printed instead of 5. Before I tell you the problem let&#39;s look at the version that uses a global variable, which runs correctly.</p>
<pre><code>let count = 0 //global
let obj = { };
function simple(obj) { 
	console.log(++count) 
	if (count == 123) {
		//let&#39;s set a breakpoint before the exception
	}
	/* rest of func with buggy logic */
}
function complex(obj) {
	let temp = structuredClone(obj)
	simple(temp)
	simple(temp)		
}
simple(obj)
simple(obj)
complex(obj)
simple(obj)
</code></pre>

<p><span>The problem is that structuredClone made a deep copy of our object. When the complex function executed the simple function, the wrong counter was modified, causing us to see repeating numbers and making us unsure of the correct time to breakpoint.</span></p>
<p>Now that we can see avoiding globals can still be problematic let&#39;s define what a global variable is and what counts as using one.</p>

</div>
<h2 id="defining">Defining Global Variables</h2>

<p>My definition of a global variable is any variable that isn&#39;t passed in as an argument or defined within the function, Here are some types of variables across different languages.</p>

<ul>
<li>Global: These are defined outside of a class and function and visible to other files. I rarely use these.</li>
<li>Private/Static: These are global variables that are not visible outside of the file. I primarily use this.</li>
<li>Thread Local: These are global variables (may be static) that have a unique instance on a per-thread basis. When I work with threads I&#39;ll avoid all types of global and use thread local instead.</li>
<li>Static Member: A variable you have one of. In some languages, you may use this to have a read-only &#39;empty&#39;, &#39;min&#39;, &#39;max&#39;, and other variables. I generally avoid this when possible.</li>
<li>Static Function Variable: In C inside a function, you can declare a static variable. You could consider this as a local variable but I don&#39;t since it&#39;s on the heap, and can be returned and modified outside of the functions. I absolutely avoid this except as a counter whose address I never return.</li>
</ul>
<p>Would you consider the below as using a global variable?</p>
<ul>
	<li>Calling a function that uses a global internally. As an example instead of ++count in our code above, we could call inc() which increments a counter and returns the value.</li>
	<li>Calling a function that has side effects that we can&#39;t easily see. For example, print, writing to a file, and writing to an audio device.</li>
	<li>Mutating variables that don&#39;t change the state of our program. Such as a logger verbosity level, or a variable to enable recalculation of some data so we can detect if logic is wrong.</li>
</ul>

<h2 id="problem">The Problem?</h2>
<p>The problem is data access. Nothing more, nothing less. There&#39;s a term for this that has nothing to do with global variables: &#34;<a href="https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)">action at a distance</a>.&#34; If a program keeps copies of a pointer you passed in, you may have objects that affect another when you had no idea they had any association. One reason people like to clone objects is to avoid unexpected mutations. However, in the example code above, a clone actually causes the problem.</p>
<p>When you make a mistake with global variables it&#39;s pretty easy to blame the fact that it&#39;s global. People usually don&#39;t recover from mistakes by cloning the global and restoring the value. It&#39;s also easy to have bad habits when using them. Beginners might be lazy and use a global variable instead of changing the signature of a dozen functions, which blows up in their faces when they overwrite a value they need.</p>

<h2 id="UseCase">Global Variable Use Cases</h2>
<p>I try not to write long posts. If you&#39;d like code samples let me know and I may write a follow-up article. Here are some cases where I like to use globals.</p>


<p>With a little encapsulation, you can make globals error-proof, after all, no one ever complains about print or memory allocations except for having too much of them. As an example of encapsulation the global counter in our original example could be an inc() function. The append-only worklist could either be accessed behind a function or a type that only allows append operations.</p>
</div></div>
  </body>
</html>
