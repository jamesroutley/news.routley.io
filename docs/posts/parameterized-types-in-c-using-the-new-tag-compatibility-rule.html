<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nullprogram.com/blog/2025/06/26/">Original</a>
    <h1>Parameterized types in C using the new tag compatibility rule</h1>
    
    <div id="readability-page-1" class="page"><div lang="en">
<article>
  
  <time datetime="2025-06-26">
    June 26, 2025
  </time>
  <p>
    nullprogram.com/blog/2025/06/26/
  </p>

  <p>C23 has <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3037.pdf">a new rule for struct, union, and enum compatibility</a>
finally appearing in compilers starting with GCC 15, released this past
April, and Clang later this year. The same struct defined in different
translation units (TU) has always been compatible — essential to how they
work. Until this rule change, each such definition within a TU was a
distinct, incompatible type. The new rule says that, <em>ackshually</em>, they
are compatible! This unlocks some type parameterization using macros.</p>

<p>How can a TU have multiple definitions of a struct? Scope. Prior to C23
this wouldn’t compile because the compound literal type and the return
type were distinct types:</p>

<div><div><pre><code><span>struct</span> <span>Example</span> <span>{</span> <span>int</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>;</span> <span>};</span>

<span>struct</span> <span>Example</span> <span>example</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>Example</span> <span>{</span> <span>int</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>;</span> <span>};</span>
    <span>return</span> <span>(</span><span>struct</span> <span>Example</span><span>){</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>};</span>
<span>}</span>
</code></pre></div></div>

<p>Otherwise the definition of <code>struct Example</code> within <code>example</code> was fine, if
strange. At first this may not seem like a big deal, but let’s <a href="https://nullprogram.com/blog/2025/01/19/">revisit my
technique for dynamic arrays</a>:</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>{</span>
    <span>T</span>        <span>*</span><span>data</span><span>;</span>
    <span>ptrdiff_t</span> <span>len</span><span>;</span>
    <span>ptrdiff_t</span> <span>cap</span><span>;</span>
<span>}</span> <span>SliceT</span><span>;</span>
</code></pre></div></div>

<p>Where I write out one of these for each <code>T</code> that I might want to put into
a slice. With the new rule we can change it slightly, taking note of the
introduction of a tag (the name after <code>struct</code>):</p>

<div><div><pre><code><span>#define Slice(T)        \
    struct Slice##T {   \
        T        *data; \
        ptrdiff_t len;  \
        ptrdiff_t cap;  \
    }
</span></code></pre></div></div>

<p>This makes the “write it out ahead of time” thing simpler, but with the
new rule we can skip the “ahead of time” part and conjure slice types on
demand. Each declaration with the same <code>T</code> is compatible with the others
due to matching tags and fields. So, for example, with this macro we can
declare functions using slices parameterized for different element types.</p>

<div><div><pre><code><span>Slice</span><span>(</span><span>int</span><span>)</span> <span>range</span><span>(</span><span>int</span><span>,</span> <span>Arena</span> <span>*</span><span>);</span>

<span>float</span> <span>mean</span><span>(</span><span>Slice</span><span>(</span><span>float</span><span>));</span>

<span>Slice</span><span>(</span><span>Str</span><span>)</span> <span>split</span><span>(</span><span>Str</span><span>,</span> <span>char</span> <span>delim</span><span>,</span> <span>Arena</span> <span>*</span><span>);</span>
<span>Str</span> <span>join</span><span>(</span><span>Slice</span><span>(</span><span>Str</span><span>),</span> <span>char</span> <span>delim</span><span>,</span> <span>Arena</span> <span>*</span><span>);</span>
</code></pre></div></div>

<p>Or using it with <a href="https://nullprogram.com/blog/2025/03/02/">our model parser</a>:</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>{</span>
    <span>float</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>;</span>
<span>}</span> <span>Vec3</span><span>;</span>

<span>typedef</span> <span>struct</span> <span>{</span>
    <span>int32_t</span> <span>v</span><span>[</span><span>3</span><span>];</span>
    <span>int32_t</span> <span>n</span><span>[</span><span>3</span><span>];</span>
<span>}</span> <span>Face</span><span>;</span>

<span>typedef</span> <span>struct</span> <span>{</span>
    <span>Slice</span><span>(</span><span>Vec3</span><span>)</span> <span>verts</span><span>;</span>
    <span>Slice</span><span>(</span><span>Vec3</span><span>)</span> <span>norms</span><span>;</span>
    <span>Slice</span><span>(</span><span>Face</span><span>)</span> <span>faces</span><span>;</span>
<span>}</span> <span>Model</span><span>;</span>

<span>typedef</span> <span>Slice</span><span>(</span><span>Vec3</span><span>)</span> <span>Polygon</span><span>;</span>
</code></pre></div></div>

<p>I worried these macros might confuse my tools, particularly <a href="https://github.com/universal-ctags/ctags">Universal
Ctags</a> because <a href="https://github.com/skeeto/w64devkit">it’s important to me</a>. Everything handles
prototypes better than expected, but ctags doesn’t see fields with slice
types. Overall they’re like a very limited form of C++ templates. Though
only the types are parameterized, not the functions operating on those
types. Outside of unwarranted macro abuse, this new technique does nothing
regarding generic functions. On the other hand, my generic slice function
complements the new technique, especially with the help of C23’s new
<code>typeof</code> to mitigate <code>_Alignof</code>’s limitations:</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>{</span> <span>char</span> <span>*</span><span>beg</span><span>,</span> <span>*</span><span>end</span><span>;</span> <span>}</span> <span>Arena</span><span>;</span>
<span>void</span> <span>*</span><span>alloc</span><span>(</span><span>Arena</span> <span>*</span><span>,</span> <span>ptrdiff_t</span> <span>count</span><span>,</span> <span>int</span> <span>size</span><span>,</span> <span>int</span> <span>align</span><span>);</span>

<span>#define push(a, s)                          \
  ((s)-&gt;len == (s)-&gt;cap                     \
    ? (s)-&gt;data = push_(                    \
        (a),                                \
        (s)-&gt;data,                          \
        &amp;(s)-&gt;cap,                          \
        sizeof(*(s)-&gt;data),                 \
        _Alignof(typeof(*(s)-&gt;data))        \
      ),                                    \
      (s)-&gt;data + (s)-&gt;len++                \
    : (s)-&gt;data + (s)-&gt;len++)
</span>
<span>void</span> <span>*</span><span>push_</span><span>(</span><span>Arena</span> <span>*</span><span>a</span><span>,</span> <span>void</span> <span>*</span><span>data</span><span>,</span> <span>ptrdiff_t</span> <span>*</span><span>pcap</span><span>,</span> <span>int</span> <span>size</span><span>,</span> <span>int</span> <span>align</span><span>)</span>
<span>{</span>
    <span>ptrdiff_t</span> <span>cap</span> <span>=</span> <span>*</span><span>pcap</span><span>;</span>

    <span>if</span> <span>(</span><span>a</span><span>-&gt;</span><span>beg</span> <span>!=</span> <span>(</span><span>char</span> <span>*</span><span>)</span><span>data</span> <span>+</span> <span>cap</span><span>*</span><span>size</span><span>)</span> <span>{</span>
        <span>void</span> <span>*</span><span>copy</span> <span>=</span> <span>alloc</span><span>(</span><span>a</span><span>,</span> <span>cap</span><span>,</span> <span>size</span><span>,</span> <span>align</span><span>);</span>
        <span>memcpy</span><span>(</span><span>copy</span><span>,</span> <span>data</span><span>,</span> <span>cap</span><span>*</span><span>size</span><span>);</span>
        <span>data</span> <span>=</span> <span>copy</span><span>;</span>
    <span>}</span>

    <span>ptrdiff_t</span> <span>extend</span> <span>=</span> <span>cap</span> <span>?</span> <span>cap</span> <span>:</span> <span>4</span><span>;</span>
    <span>alloc</span><span>(</span><span>a</span><span>,</span> <span>extend</span><span>,</span> <span>size</span><span>,</span> <span>align</span><span>);</span>
    <span>*</span><span>pcap</span> <span>=</span> <span>cap</span> <span>+</span> <span>extend</span><span>;</span>
    <span>return</span> <span>data</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>This exploits the fact that implementations adopting the new tag rule also
have <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3322.pdf">the upcoming C2y null pointer rule</a> (note: also requires a
cooperating libc). Putting it together, now I can write stuff like this:</p>

<div><div><pre><code><span>Slice</span><span>(</span><span>int64_t</span><span>)</span> <span>generate_primes</span><span>(</span><span>int64_t</span> <span>limit</span><span>,</span> <span>Arena</span> <span>*</span><span>a</span><span>)</span>
<span>{</span>
    <span>Slice</span><span>(</span><span>int64_t</span><span>)</span> <span>primes</span> <span>=</span> <span>{};</span>

    <span>if</span> <span>(</span><span>limit</span> <span>&gt;</span> <span>2</span><span>)</span> <span>{</span>
        <span>*</span><span>push</span><span>(</span><span>a</span><span>,</span> <span>&amp;</span><span>primes</span><span>)</span> <span>=</span> <span>2</span><span>;</span>
    <span>}</span>

    <span>for</span> <span>(</span><span>int64_t</span> <span>n</span> <span>=</span> <span>3</span><span>;</span> <span>n</span> <span>&lt;</span> <span>limit</span><span>;</span> <span>n</span> <span>+=</span> <span>2</span><span>)</span> <span>{</span>
        <span>bool</span> <span>valid</span> <span>=</span> <span>true</span><span>;</span>
        <span>for</span> <span>(</span><span>ptrdiff_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>valid</span> <span>&amp;&amp;</span> <span>i</span><span>&lt;</span><span>primes</span><span>.</span><span>len</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
            <span>valid</span> <span>=</span> <span>n</span> <span>%</span> <span>primes</span><span>.</span><span>data</span><span>[</span><span>i</span><span>];</span>
        <span>}</span>
        <span>if</span> <span>(</span><span>valid</span><span>)</span> <span>{</span>
            <span>*</span><span>push</span><span>(</span><span>a</span><span>,</span> <span>&amp;</span><span>primes</span><span>)</span> <span>=</span> <span>n</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>return</span> <span>primes</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>But it doesn’t take long to run into limitations. It makes little sense to
define, say, a <code>Map(K, V)</code> without a generic function to manipulate it.
This also doesn’t work:</p>

<div><div><pre><code><span>typedef</span> <span>struct</span> <span>{</span>
    <span>Slice</span><span>(</span><span>Str</span><span>)</span>          <span>names</span><span>;</span>
    <span>Slice</span><span>(</span><span>Slice</span><span>(</span><span>float</span><span>))</span> <span>edges</span><span>;</span>
<span>}</span> <span>Graph</span><span>;</span>
</code></pre></div></div>

<p>Due to <code>Slice##T</code> in the macro, required to establish a unique tag for
each element type. The parameter to the macro must be an identifier, so
you have to build up to it (or define another macro), which sort of
defeats the purpose, which was entirely about convenience.</p>

<div><div><pre><code><span>typedef</span> <span>Slice</span><span>(</span><span>float</span><span>)</span> <span>Edges</span><span>;</span>

<span>typedef</span> <span>struct</span> <span>{</span>
    <span>Slice</span><span>(</span><span>Str</span><span>)</span>   <span>names</span><span>;</span>
    <span>Slice</span><span>(</span><span>Edges</span><span>)</span> <span>edges</span><span>;</span>
<span>}</span> <span>Graph</span><span>;</span>
</code></pre></div></div>

<p>The benefits are small enough that perhaps it’s not worth the costs, but
it’s been at least worth investigating. I’ve written a small demo of the
technique if you’d like to see it in action, or test the abilities of your
local C implementation: <a href="https://gist.github.com/skeeto/3fe27cd81ca5bdb4926b12e03bdfbc62"><code>demo.c</code></a></p>



  
  <ol></ol>

  

  <nav>
  
    
  
  
  </nav>
</article>

</div></div>
  </body>
</html>
