<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://computerhistory.org/blog/the-apl-programming-language-source-code/">Original</a>
    <h1>The APL Programming Language Source Code (2012)</h1>
    
    <div id="readability-page-1" class="page"><div>
	<h3><em>Software Gems: The Computer History Museum Historical Source Code Series</em></h3>

<div id="attachment_22068"><p><img aria-describedby="caption-attachment-22068" src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_Ken_Iverson-728x1024.jpg" alt="" width="728" height="1024"/></p><p id="caption-attachment-22068">Ken Iverson at Harvard University</p></div>

<p>Thousands of programming languages were invented in the first 50 years of the age of computing. Many of them were similar, and many followed a traditional, evolutionary path from their predecessors.</p>
<p>But some revolutionary languages had a slant that differentiated them from their more general-purpose brethren. LISP was for list processing. SNOBOL was for string manipulation. SIMSCRIPT was for simulation. And APL was for mathematics, with an emphasis on array processing.</p>
<p>What eventually became APL was first invented by Harvard professor Kenneth E. Iverson in 1957 as a mathematical notation, not as a computer programming language. Although other matrix-oriented symbol systems existed, including the concise tensor notation invented by Einstein, they were oriented more towards mathematical analysis and less towards synthesis of algorithms. Iverson, who was a student of Howard Aiken’s, taught what became known as “Iverson Notation” to his Harvard students to explain algorithms.</p>
<p>Iverson was hired by IBM in 1960 to work with Adin Falkoff and others on his notation. In his now famous 1962 book “A Programming Language” <sup><a href="#1">1</a></sup>, he says the notation is for the description of “procedures…called algorithms or programs”, and that it is a language because it “exhibits considerable syntactic structure”. But at that point it was just a notation for people to read, not a language for programming computers. The book gives many examples of its use both as a descriptive tool (such as for documenting the definition of computer instruction sets) and as a means for expressing general algorithms (such as for sorting and searching). Anticipating resistance to something so novel, he says in the preface, “It is the central thesis of this book that the descriptive and analytical power of an adequate programming language amply repays the considerable effort required for its mastery.” Perhaps he was warning that mastering the language wasn’t trivial. Perhaps he was also signaling that, in his view, other notational languages were less than “adequate”.</p>
<p>The team, of course, soon saw that the notation could be turned into a language for programming computers. That language, which was called APL starting in 1966, emphasized array manipulation and used unconventional symbols. It was like no other computer program language that had been invented.</p>
<p>APL became popular when IBM introduced “APL\360” for their System/360 mainframe computer. Unlike most other languages at the time, APL\360 was also a complete interactive programming environment. The programmer, sitting at an electromechanical typewriter linked to a timeshared computer, could type APL statements and get an immediate response. Programs could be defined, debugged, run, and saved on a computer that was simultaneously being used by dozens of other people.</p>
<p>Written entirely in 360 assembly language, this version of APL took control of the whole machine. It implemented a complete timesharing operating system in addition to a high-level language.</p>
<p>With the permission of IBM, the Computer History Museum is pleased to make available the source code to the 1969-1972 “XM6” version of APL for the System/360 for non-commercial use.</p>
<p>The text file contains 37,567 lines, which includes code, macros, and global definitions. The 90 individual files are separated by ‘./ ADD” commands. To access this material, you must agree to the terms of the license displayed here, which permits only non-commercial use and does not give you the right to license it to third parties by posting copies elsewhere on the web.</p>
<p><a href="https://computerhistory.org/blog/apl360-software-license-agreement/">Download APL\360 Source Code</a></p>
<p>Jürgen Winkelmann at ETH Zürich has done an amazing job of turning this source code into a runnable system. For more information, see <a href="http://wotho.ethz.ch/mvt4apl-2.00/">MVT for APL Version 2.00</a>.</p>
<h2>Creating the APL Programming Language</h2>
<p>Iverson’s book “A Programming Language” <sup><a href="#1">1</a></sup> uses a graphical notation that would have been difficult to directly use as a programming language for computers. He considered it an extension of matrix algebra, and used common mathematical typographic conventions like subscripts, superscripts, and distinctions based on the weight or font of characters. Here, for example, is a program for sorting numbers:</p>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_bubble_sort.jpg" alt="" width="600" height="424"/></p>
<p>To linearize the notation for use as a computer programming language typed at a keyboard, the APL implementers certainly had to give up the use of labeled arrows for control transfers. But one feature that they were able to retain, to some extent, was the use of special symbols for primitive functions, as illustrated in this program that creates Huffman codes:</p>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_huffman_codes.jpg" alt="" width="430" height="262"/></p>
<p>APL uses symbols that are closer to standard mathematics than programming. For example, the symbol for division is ÷, not /. To support the unconventional symbols, APL\360 used a custom-designed keyboard with special symbols in the upper case.</p>

<div id="attachment_22083"><p><img aria-describedby="caption-attachment-22083" src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_Custom-designed-keyboard.jpg" alt="" width="644" height="205"/></p><p id="caption-attachment-22083">APL\360 used a custom-designed keyboard</p></div>

<p>Even so, there were more special characters than could fit on the keyboard, so some were typed by overstriking two characters. For example, the “grade up” character ⍋, a primitive operator used for sorting, was created by typing ∆ (shift H), then backspace, then ∣ (shift M). There was no room left for both upper- and lower-case letters, so APL supported only capital letters.</p>
<p>For printing programs, Iverson and Falkoff got IBM to design a special type ball for their 1050 and 2741 terminals, which used the IBM Selectric typewriter mechanism.</p>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_terminal.jpg" alt="" width="378" height="252"/><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_golfball.jpg" alt="" width="318" height="255"/></p>
<p>Now programs could be both typed in and printed. Here, for example, is the printed version a program from the APL Language manual <sup><a href="#2">2</a></sup> that computes the mathematical determinant of a matrix:</p>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_matrix.jpg" alt="" width="493" height="340"/></p>
<h2>A Taste of APL</h2>
<p>APL is a concise high-level programming language that differs from most others developed in the 1960s in several respects:</p>
<p><strong>Order of evaluation:</strong> Expressions in APL are evaluated right-to-left, and there is no hierarchy of function precedence. For example, typing the expression</p>
<p><strong>2×4+3</strong></p>
<p>causes the computer to immediately type the resulting value</p>
<p><strong>14</strong></p>
<p>The value is not, as in many other languages that have operator precedence, 11. Of course, parentheses can be used to group a subexpression to change the evaluation order. The general rule is that the right argument of any function is the value of the expression to its right.</p>
<p><strong>Automatic creation of vectors and arrays:</strong> A higher-dimensional structure is automatically created by evaluating an expression that returns it, and scalars can be freely mixed. For example,</p>
<p><strong>A ← 2 + 1 2 3</strong></p>
<p>creates the vector “1 2 3”, add the scalar 2 to it, and creates the variable A to hold the vector whose value is</p>
<p><strong>3 4 5</strong></p>
<p>Variables are never declared; they are created automatically and assume the size and shape of whatever expression is assigned to them.</p>
<p><strong>A plethora of primitives:</strong> APL has a rich set of built-in functions (and “operators” that are applied to functions to yield different functions) that operate on scalar, vectors, arrays, even higher-dimensional objects, and combinations of them. For example, the expression to sum the numbers in the vector “A” created above is simply</p>
<p><strong>+/A</strong></p>
<p>where / is the “reduction” operator that causes the function to the left to be applied successively to all the elements of the operand to the right. The expression to compute the average of the numbers in A also uses the primitive function ρ to determine how many elements there are in A:</p>
<p><strong>(+/A) ÷ ρA</strong></p>
<p>Here are some tables from the 1970 “APL\360 User’s Manual” <sup><a href="#3">3</a></sup> that give a flavor of the power and sophistication of the built-in APL functions and operators. </p>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_Tables1.jpg" alt="" width="800" height="968"/></p>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_table2-745x1024.jpg" alt="" width="745" height="1024"/></p>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_table3.jpg" alt="" width="800" height="412"/></p>
<p>APL encourages you to think differently about programming, and to use temporary high-dimensional data structures as intermediate values that are then reduced using the powerful primitives. A famous example is the following short but complete program to compute all the prime numbers up to R.</p>
<p><strong>(~T∊T∘.×T)/T←1↓⍳R</strong></p>
<p>Here is how this expression is evaluated:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>subexpression</strong></p>
</td>
<td>
<p><strong>meaning</strong></p>
</td>
<td>
<p><strong>value if R is 6</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong><em>⍳R</em></strong></p>
</td>
<td>
<p>Generate a vector of numbers from 1 to R.</p>
</td>
<td>
<p> 1 2 3 4 5 6</p>
</td>
</tr>
<tr>
<td>
<p><strong><em>T</em></strong><em>←</em><strong><em>1↓</em></strong></p>
</td>
<td>
<p>Drop the first element of the vector and assign the rest to the temporary vector T.</p>
</td>
<td>
<p>2 3 4 5 6</p>
</td>
</tr>
<tr>
<td>
<p><strong><em>T</em></strong><strong><em>∘</em></strong><strong><em>.×T</em></strong></p>
</td>
<td>
<p>Create the multiplication outer product: a table that holds the result of multiplying each element of T by each element of T.</p>
</td>
<td>
<table>
<tbody>
<tr>
<td>
<p>4</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>8</p>
</td>
<td>
<p>10</p>
</td>
<td>
<p>12</p>
</td>
</tr>
<tr>
<td>
<p>6</p>
</td>
<td>
<p>9</p>
</td>
<td>
<p>12</p>
</td>
<td>
<p>15</p>
</td>
<td>
<p>18</p>
</td>
</tr>
<tr>
<td>
<p>8</p>
</td>
<td>
<p>12</p>
</td>
<td>
<p>16</p>
</td>
<td>
<p>20</p>
</td>
<td>
<p>24</p>
</td>
</tr>
<tr>
<td>
<p>10</p>
</td>
<td>
<p>15</p>
</td>
<td>
<p>20</p>
</td>
<td>
<p>25</p>
</td>
<td>
<p>30</p>
</td>
</tr>
<tr>
<td>
<p>12</p>
</td>
<td>
<p>18</p>
</td>
<td>
<p>24</p>
</td>
<td>
<p>30</p>
</td>
<td>
<p>36</p>
</td>
</tr>
</tbody>
</table>

</td>
</tr>
<tr>
<td>
<p><strong><em>T</em></strong><strong><em>∊</em></strong></p>
</td>
<td>
<p>Use the “set membership” operator to find which elements of T are in the table.</p>
</td>
<td>
<p>0 0 1 0 1</p>
</td>
</tr>
<tr>
<td>
<p><strong><em>~</em></strong></p>
</td>
<td>
<p>Negate the result to identify which elements of T are <span>not</span> in the table.  These are the integers which do not have any multiples in the table.</p>
</td>
<td>
<p>1 1 0 1 0</p>
</td>
</tr>
<tr>
<td>
<p><strong><em>( )/T</em></strong></p>
</td>
<td>
<p>Select the elements of T which we have identified.    These are all the primes less than R.</p>
</td>
<td>
<p>2 3 5</p>
</td>
</tr>
</tbody>
</table>
<p>Note that there are no loops in this program. The power of APL expressions means that conditional branches and loops are required far less often than in more traditional programming languages.</p>
<p>APL operators can be used in easy ways for all sorts of computations that would usually require loops. For example, an expression that computes the number of elements of the vector X that are greater than 100 is</p>
<p><strong>+/X&gt;100</strong></p>
<p>It works because <strong>X&gt;100</strong> returns a bit vector of 0’s and 1’s showing which elements of <strong>X</strong> are greater than 100, and +/ adds up all the bits in that vector.</p>
<p>But conditional execution and loops are, of course, sometimes needed. In the light of later developments in structured programming, APL’s only primitive for control transfer, the “GO TO LINE x” statement →, is particularly weak. Here is an example of a function that computes the greatest common divisor of its two arguments. The last statement creates a loop by branching to the beginning. In line 2, conditional transfer of control to line 0 causes the function to exit and return the value last assigned to G.</p>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_GCD-300x178.jpg" alt="" width="300" height="178"/></p>
<p>To learn more about the 1960’s APL language, see the “APL Language” reference manual <sup><a href="#2">2</a></sup> and Paul Berry’s 1969 “APL\360 Primer” <sup><a href="#4">4</a></sup>.</p>
<p>The language has of course evolved over the years, and more recent versions include control structures such as IF-THEN-ELSE.</p>
<h2>How APL was Implemented</h2>
<p>The first computer implementation of APL notation was a batch-oriented language interpreter written in FORTRAN in 1965 for the IBM 7090 mainframe computer, by Larry Breed at the IBM Research Center in Yorktown Heights NY and Philip Abrams, then a graduate student at Stanford University.</p>
<p>The first interactive version was written soon after for the 7093 (an experimental 7090 with virtual memory) by Larry Breed and Roger Moore. It ran under the TSM timesharing system and was whimsically called “IVSYS”, which rhymes with “IBSYS”, the name for the standard 7090 operating system. In a 2012 email Breed says,</p>
<div><h3> IVSYS provided login, logout, immediate execution and function definition; it provided workspaces, both active and stored. Implementation of these was rudimentary; mostly we used whatever the TSM project offered us for login/logout/saving files. We had only a few weeks to use the 7093 before it was decommissioned and Roger and I started planning for a standalone system on System/360. In those weeks, Ken and his group saw for the first time what executable APL would be like. </h3></div>
<p>Another implementation of a subset of the language was done in 1967 for the IBM 1130 minicomputer.</p>
<p>The first implementation of APL to get widespread use outside of IBM was for the IBM System/360. Called “APL\360”, it went into service first within IBM in November 1966. (The notation “APL\360″, since the backslash was the APL “expansion” operator, also had a hidden meaning: “APL expands the 360″).</p>
<p>Breed says of the time just before,</p>
<div><h3> This period, early 1966, was the transitional time from Iverson Notation to APL. (Indeed, Adin [Falkoff] came up with “APL” in Spring ’66.) Refinement and extension of the language and the environment continued for many years. There was next to no code added to make a commercial version, just paperwork. </h3></div>
<p>By August 1968 APL\360 was available to IBM customers as an unsupported (“Type III”) program in IBM’s “Contributed Program Library” <sup><a href="#5">5</a></sup>. The principal implementers were Larry Breed, Dick Lathwell, and Roger Moore; others who had contributed were Adin Falkoff and Luther Woodrum.</p>

<div id="attachment_22087"><p><img aria-describedby="caption-attachment-22087" src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_iverson_team-1.jpg" alt="" width="951" height="509"/></p><p id="caption-attachment-22087">Early APL developers, from left to right: Dick Lathwell, Ken Iverson, Roger Moore, Adin Falkoff, Phil Abrams, Larry Breed. The photo was taken about 1983.</p></div>

<p>Because of the dynamic nature of APL variables, APL\360 was implemented as an interpreter, not as a compiler that generated machine code. Programs were stored in an internal form called a “codestring” that directly corresponded to what the user had typed. The interpreter would then examine the codestring as the program executed, and dynamically allocate and reconfigure variables as expressions were evaluated.</p>
<p>The first versions of APL\360 took control of the entire machine. It was thus a combination operating system, file system, timesharing monitor, command interpreter, and programming language. Given the limited main memory, user workspaces were swapped out to drum or disk as needed. Performance was impressive, which Larry Breed attributes, in his clear and succinct description of the implementation <sup><a href="#6">6</a></sup>, to the ability to tailor the operating system to the requirements of the language.</p>
<p>APL\360 was a conversational language that provided fast response and efficient execution for as many as 50 simultaneous users. Each user had an “active workspace” that held programs, variables, and the state of suspended program execution. System commands like “)LOAD”, “)SAVE”, and “)COPY” maintained the user’s library of stored workspaces. Other system commands controlled language features; for example, with “)ORIGIN” the programmer could control whether vectors and arrays are numbered starting with 0 or 1.</p>
<p>APL was the first introduction to interactive timesharing for many in the generation of programmers who had suffered through batch programming with punched cards.</p>
<h2>Applications of APL</h2>
<p>Even before it was a computer programming language, Iverson Notation was useful as a language for documenting algorithms for people. The classic example is the formal definition of the instruction-set architecture of the new IBM System/360 computer, which was published in an article in the IBM Systems Journal by Adin Falkoff, Ken Iverson, and Ed Sussenguth in 1965 <sup><a href="#7">7</a></sup>.</p>
<div><h3> The description, which is formal rather than verbal, is accomplished by a set of programs, interacting through common variables, used in conjunction with auxiliary tables… Although the formal description is complete and self-contained, text is provided as an aid to initial study. </h3></div>
<div>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_memory_access_operation.jpg" alt="" width="851" height="944"/>But the text provided in the paper is much more than that. It is a line-by-line explanation of the formal description, which means that it is also a demonstration and explanation of APL’s descriptive power.</p>
<p>The notation used the graphical style for control transfers that was in Iverson’s book. Here, for example, is the description of a memory access operation.</p>
<p>It was the transition of APL from a notation for publication into an interactive computer programming language that made it flourish. When the APL\360 implementation was available, IBM and others stimulated use by producing diverse applications such as these:</p>
</div>
<ul>
	<li><strong>Starmap:</strong> A set of APL functions to calculate and plot the positions of the stars and planets. <sup><a href="#8">8</a></sup> <sup><a href="#9">9</a></sup> It was written in 1973 by Paul Berry of IBM and John Thorstensen, then an astronomy student at Bryn Mawr college, now Professor of Physics and Astronomy at Dartmouth College. It uses classical solutions to Kepler’s equations for a particular date and time and a series of rotations of coordinates to show where the planets and the stars would appear in the bowl of the sky.</li>
	<li><strong>IBGS: Interactive Business Game Simulation:</strong> “A general computer management simulation involving decision making and planning in the functional areas of production, marketing and finance.”</li>
	<li><strong>Zeros and Integrals in APL:</strong> “Using both classical methods such as Newton’s and Muller’s and recently developed methods such as Jenkins and Traub’s, it finds reals zeros of a real function, real and complex zeros of a polynomial with real of complex coefficients, and complex zeros of a complex function.”</li>
	<li><strong>Graphpak – Interactive Graphics Package for APL\360:</strong> “…capabilities which range from graphics interface support at the lowest level to several application areas at higher levels…A plotting component…linear or logarithmic…curve-fitting… A descriptive geometry component allows definition, scaling, magnification, translation, rotation, and projected display of three-dimensional objects.”</li>
	<li><strong>Graphs and Histograms in APL:</strong> “produces curves and barcharts at a typewriter terminal”.</li>
	<li><strong>APL Coordinate Geometry System:</strong> “solves coordinate geometry problems interactively at a terminal…for use by surveyors, civil engineers, urban planners…”</li>
	<li><strong>APL/PDTS – Programming Development Tracking System:</strong> “…to assist managers and planners in monitoring performance against plan on programming development projects.”</li>
	<li><strong>MINIPERT:</strong> “A Critical Path Method (CPM) system for Project Management”</li>
	<li><strong>APL Econometric Planning Language:</strong> “The practicing economist, business forecaster or teacher is provided with easy-to-use tools for interactive model building and model solving.”</li>
	<li><strong>APL Financial Planning System:</strong> “lets the financial analyst and planner design reports, specify calculation statements, enter and change data, and obtain printed reports with immediate turnaround.”</li>
	<li><strong>APL Text Editor and Composer:</strong> “This program is designed to process text interactively at a terminal…Functions are included for entering, revising, composing, printing, and storing text…for use by secretaries, scientists, engineers, administrators or any others who produce papers, letters, reports or specifications.”</li>
</ul>
<p>Many of these applications emphasized interactivity, which provided a huge productivity increase compared to the batch-job processing more typical at the time. In addition, APL allowed applications to be developed much more quickly. In a 2012 email, Larry Breed noted,</p>
<div><h3> Across all fields, the speed at which APL programs can be written makes it valuable for modeling and prototyping . … One example: Around 1973, Continental Can needed an inventory system for its 21 manufacturing plants. Their team of FORTRAN programmers had worked for a year, with no success in sight. One STSC salesman, in one weekend, built a usable working model in APL Plus. </h3></div>
<p>The areas in which APL had the greatest penetration were in scientific, actuarial, statistical, and financial applications. For details about the progression of APL in its first 25 years, see the special 1991 issue of the IBM System Journal <sup><a href="#10">10</a></sup> with 12 papers and one essay on the subject.</p>
<h2>APL Praise and Criticism</h2>
<p>APL was not originally designed as a programming language. As Iverson said,</p>
<div><h3> The initial motive for developing APL was to provide a tool for writing and teaching. Although APL has been exploited mostly in commercial programming, I continue to believe that its most important use remains to be exploited: as a simple, precise, executable notation for the teaching of a wide range of subjects. </h3></div>
<p>With so many terse and unusual symbols, APL computer programs, like the mathematical notation that inspired it, has a conciseness and elegance many find appealing. APL attracts fanatic adherents. Alan Perlis (the first recipient of the ACM’s Turing Award, in 1966) was one:</p>
<div><h3> The sweep of the eye across a single sentence can expose an intricate, ingenious and beautiful interplay of operation and control that in other programming languages is observable only in several pages of text. One begins to appreciate the emergence and significance of style. 12 </h3></div>
<p>Many find the freedom of expression in APL liberating.</p>
<div><h3> I used to describe [Pascal] as a ‘fascist programming language’, because it is dictatorially rigid. …If Pascal is fascist, APL is anarchist. 13 </h3></div>
<p>But APL programs are often cryptic and hard to decode. Some have joked that it is a “write-only language” because even the author of a program might have trouble understanding it later. It inspires programming trickery. The challenge of writing an APL “one-liner” to implement a complete complex algorithm is hard to resist. Here, for example, are two different APL one-liners that implement versions of John Conway’s “<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a>“:</p>
<p><strong>life←{↑1 ω∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂ω}</strong></p>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_apl_life3-1024x38.jpg" alt="" width="1024" height="38"/></p>
<p>Not for the faint-hearted, clearly. Dutch computer scientist Edsger Dijkstra said,</p>
<div><h3> APL is a mistake, carried through to perfection. It is the language of the future for the programming techniques of the past: it creates a new generation of coding bums. 14 </h3></div>
<p>But fans of APL would say that cryptic APL coding is a bad programming style that can be an affliction with any language. APL provides a richer palette for expressing algorithms, the argument goes, so you can solve harder problems faster and with less irrelevant syntactic clutter.</p>
<p>Whatever your view, APL and the languages it inspired, such as <a href="https://www.ibm.com/us-en/marketplace/apl2">APL2</a> and <a href="https://en.wikipedia.org/wiki/J_(programming_language">J</a>, are still an active part of the diverse programming language universe.</p>
<h2>A Short Biography of Ken Iverson</h2>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_ken_iverson1.jpg" alt="" width="192" height="192"/></p>
<p>Kenneth Eugene Iverson was born on December 17, 1920 on a farm near Camrose, Alberta, Canada. He was educated in rural one-room schools until the end of 9th grade, when he dropped out of school because it was the height of the Depression and there was work to do on the family farm. He later said the only purpose of continuing his schooling would have been to become a schoolteacher, and that was a profession he decidedly did not want. During the long winter months he studied calculus on his own.</p>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_Ken_Iverson2.jpg" alt="" width="221" height="398"/></p>
<p>He was drafted in 1942, and during his service he took enough correspondence courses to almost complete high school. After the military service he earned a B.A. in both mathematics and physics from Queen’s University in Kingston Ontario, and then an M.A. in physics from Harvard University. In 1954 he completed a PhD under computer pioneer Howard Aiken, with a thesis titled “Machine Solutions of Linear Differential Equations: Applications to a Dynamic Economic Model”.</p>
<p>After completing his doctorate, Iverson joined the Harvard faculty to teach in Aiken’s new automatic data processing program. He was there for one year as an Instructor, and for five years as an Assistant Professor. He became increasingly frustrated with the inadequacy of conventional mathematical notation for expressing algorithms, so he began to invent his own.</p>
<p>In 1960 Iverson joined the new IBM Research Center in Yorktown Heights, New York, on the advice of Frederick Brooks, who had been one of his teaching fellows at Harvard and was now at IBM. The two collaborated on the continuing development of the new notation. In 1962 Ken published the now-classic book “A Programming Language” <sup><a href="#1">1</a></sup>, the title of which gave the name APL to the notation which had up until then been informally called “Iverson’s notation”.</p>
<p>Iverson continued to work on the development of APL throughout his tenure at IBM. In 1980 he left IBM and returned to Canada to work for I.P. Sharp Associates, which had established an APL-based timesharing service.</p>
<p><img src="https://computerhistory.org/wp-content/uploads/2012/10/APLSC_Ken_Iverson3.jpg" alt="" width="251" height="237"/></p>
<p>In 1987 he “retired from paid employment” and turned his full attention to the development of a more modern dialect of APL. APL was successfully being used for commercial purposes, but Iverson wanted to develop a new simple executable notation more suitable for teaching, which would be available at low cost. The first implementation of this language, called J, was announced at the APL90 Users’ Conference.</p>
<p>Iverson’s ability to create such languages came from his “sheer enjoyment of language and words,” recalls his daughter Janet Cramer. “He read dictionaries like people read novels.” Iverson thought it was important that language, both English and mathematics, communicate clearly and concisely.</p>
<p>With collaborators that included his son Eric, Iverson continued to work on the development of J, and he continued to publish prolifically. On Saturday, October 16, 2004 he suffered a stroke –while working on a J tutorial — and died three days later on October 19, at the age of 83.</p>
<p>There are many stories about Ken Iverson. Here are a few:</p>
<div><h3> Ken didn’t get tenure at Harvard. He did his five years as an assistant professor and the Faculty decided not to put him up for promotion. I asked him what went wrong and he said, “Well, the Dean called me in and said, ‘the trouble is, you haven’t published anything but the one little book’”. The one little book later got [him] the Turing Award. I think that is a comment on the conventional mindset of promotion procedures rather than a comment on Ken; it’s a comment on academic procedure and on Harvard. </h3><h4>— Fred Brooks, A Celebration of Kenneth Iverson, 2004-11-30</h4></div> <div><h3> In an early talk Ken was explaining the advantages of tolerant comparison. A member of the audience asked incredulously, “Surely you don’t mean that when A=B and B=C, A may not equal C?” Without skipping a beat, Ken replied, “Any carpenter knows that!” and went on to the next question. </h3><h4>— Paul Berry</h4></div> <div><h3> In a social conversation with Ken, I said, “You know, Ken, you are my favorite language designer and Don Knuth is my favorite programmer.” And Ken said immediately, “What’s wrong with my programming?” </h3><h4>— Joey Tuttle, A Celebration of Kenneth Iverson, 2004-11-30</h4></div> <div><h3> In 1973 or 1974 Ken and I gave a talk at Kodak in Rochester to a group of 40 to 50 programmers who were required to work in PL/I. In the question period a senior staff member said, “If I understand what you people are saying, you are suggesting that we should adopt a new way of thinking.” And Ken jumped up out of his chair and said, “Yes! That’s exactly what I am saying!” </h3><h4>— Joey Tuttle, A Celebration of Kenneth Iverson, 2004-11-30</h4></div>
<h2>Acknowledgements</h2>
<div><h3> Thanks to Michael Karasick, Yvonne Perkins, Steve Selbst, and Ken Edwards of IBM for ending my ten-year odyssey to get permission to release the APL source code. Thanks to Curtis Jones, Larry Breed, Paul Berry, and Roy Sykes for their comments on an early draft of this article. </h3><h4>— Len Shustek</h4></div>

<h2>Bibliography</h2>
<ol>
	<li><a id="2"></a><a id="3"></a>K. E. Iverson, A Programming Language, John Wiley and Sons, Inc., 1962.</li>
	<li><a id="4"></a><a href="https://archive.org/stream/bitsavers_ibmaplGC2675_6717824/GC26-3847-0_APL_Language_Mar75_djvu.txt">IBM, “APL Language,” March 1975.</a></li>
	<li><a id="5"></a><a href="https://archive.org/details/bitsavers_ibmaplGH20ualMar70_7246596">IBM, “APL\360 User’s Manual,” March 1970.</a></li>
	<li><a id="6"></a><a href="https://archive.org/details/bitsavers_ibmaplC2019_13626230">IBM, Paul Berry, “APL\360 Primer – Student Text,” 1969.</a></li>
	<li><a href="https://archive.org/details/bitsavers_ibmapl360D_7227158">L. M. Breed and R. H. Lathwell, “APL\360,” 1968.</a><a id="7"></a></li>
	<li>L. M. Breed and R. H. Lathwell, “The Implementation of APL\360,”<a id="8"></a> in ACM Symposium on Experimental Systems for Interactive Applied Mathematics, 1967.</li>
	<li>A. D. Falkoff, K. E. Iverson and E. H. Sussenguth, <a id="9"></a>“A Formal Description of SYSTEM/360,” IBM Systems Journal, vol. 3, no. 3, pp. 198-261, 1964.</li>
	<li>P. C. Berry and J. R. Thorstensen, “Starmap,” 1978.</li>
	<li><a id="10"></a>P. C. Berry and J. R. Thorstensen, “Starmap,” IBM Systems Development Division, 1975.</li>
	<li><a id="11"></a>IBM Systems Journal, vol. 30, no. 4, 1991.</li>
	<li><a id="12"></a>K. E. Iverson, “A Personal View of APL,” IBM Systems Journal, vol. 30, no. 4, 1991.</li>
	<li><a id="13"></a>A. J. Perlis, “In Praise of APL: A Language for Lyrical Programming,” SIAM News, June 1977.</li>
	<li><a id="14"></a>B. McCormick, “A Programming Language,” 2000,2002.</li>
	<li><a id="15"></a> E. W. Dijkstra, “How Do We Tell Truths That Might Hurt?”,” SIGPLAN Notices, vol. 17, no. 5, May 1982.</li>
	<li><a id="16"></a>A. D. Falkoff and K. E. Iverson, “The Design of APL,” IBM Journal of Research and Development, vol. 17, no. 4, 1973.</li>
	<li><a id="17"></a>A. D. Falkoff and K. E. Iversion, “The Evolution of APL,” SIGPLAN Notices, vol. 13, no. 8, pp. 45-57, August 1978.</li>
	<li><a id="18"></a><a href="https://archive.computerhistory.org/resources/text/2009/102636222.05.01.acc.pdf">L. Breed, “How We Got to APL1130,” 10 May 2004.</a></li>
	<li><a id="19"></a>ACM, “Proceedings of the APL’69 Conference on APL,” SUNY Binghamton, NY, 1969.</li>
	<li><a id="20"></a>“<a href="https://www.myspace.com/video/vid/60771080">The Origins of APL – 1974</a>“; a wonderful interview with the original developers of APL.</li>
</ol>
<h2>Historical Source Code Releases</h2>
<ul>
	<li><a href="https://computerhistory.org/blog/macpaint-and-quickdraw-source-code">MacPaint and QuickDraw Source Code</a>, July 18, 2010</li>
	<li><a href="https://computerhistory.org/blog/the-apl-programming-language-source-code/">APL Programming Language Source Code</a>, October 10, 2012</li>
	<li><a href="https://computerhistory.org/blog/adobe-photoshop-source-code/">Adobe Photoshop Source Code</a>, February 13, 2013</li>
	<li><a href="https://computerhistory.org/blog/apple-ii-dos-source-code/">Apple II DOS Source Code</a>, November 12, 2013</li>
	<li><a href="https://computerhistory.org/blog/microsoft-ms-dos-early-source-code/">Microsoft MS-DOS Early Source Code</a>, March 25, 2014</li>
	<li><a href="https://computerhistory.org/blog/microsoft-word-for-windows-1-1a-source-code/">Microsoft Word for Windows Version 1.1a Source Code</a>, March 25, 2014</li>
	<li><a href="https://computerhistory.org/blog/early-digital-research-cpm-source-code/">Early Digital Research CP/M Source Code</a>, October 1, 2014</li>
	<li><a href="https://computerhistory.org/blog/xerox-alto-source-code/">Xerox Alto Source Code</a>, October 21, 2014</li>
	<li><a href="https://computerhistory.org/blog/electronic-arts-deluxepaint-early-source-code/">Electronic Arts DeluxePaint Early Source Code</a>, July 22, 2015</li>
</ul>
</div></div>
  </body>
</html>
