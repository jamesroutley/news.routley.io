<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.edward-li.com/tech/advanced-python-features/">Original</a>
    <h1>Advanced Python Features</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      <p>Python is one of the <a href="https://survey.stackoverflow.co/2024/technology#most-popular-technologies">most widely adopted programming languages</a> in the world. Yet, because of it’s ease and simplicity to just “get <em>something</em> working”, it’s also one of the most underappreciated.</p>
<p>If you search for <a href="https://www.google.com/search?q=Top+10+Advanced+Python+Tricks"><code>Top 10 Advanced Python Tricks</code></a> on Google or any other search engine, you’ll find tons of blogs or LinkedIn articles going over trivial (but still useful) things like <code>generators</code> or <code>tuples</code>.</p>
<p><em><strong>However</strong></em>, as someone who’s written Python for the past 12 years, I’ve come across a lot of really interesting, underrated, unique, or (as some might say) “un-pythonic” tricks to <em>really</em> level up what Python can do.</p>
<p>That’s why I decided to compile the top 14 of said features alongside examples and additional resources if you want to dive deeper into any of them.</p>
<blockquote>
<p>These tips &amp; tricks were originally featured as part of a 14-day series on X/Twitter between March 1st and March 14th (pi-day, hence why there are 14 topics in the article).</p>
<p>All X/Twitter links will also be accompanied with a Nitter counterpart. Nitter is a privacy-abiding open source Twitter frontend. Learn more about the project <a href="https://github.com/zedeus/nitter">here</a>.</p></blockquote>

<ul>
<li><a href="#1-typing-overloads">1. Typing Overloads</a></li>
<li><a href="#2-keyword-only-and-positional-only-arguments">2. Keyword-only and Positional-only Arguments</a></li>
<li><a href="#3-future-annotations">3. Future Annotations</a></li>
<li><a href="#4-generics">4. Generics</a></li>
<li><a href="#5-protocols">5. Protocols</a></li>
<li><a href="#6-context-managers">6. Context Managers</a></li>
<li><a href="#7-structural-pattern-matching">7. Structural Pattern Matching</a></li>
<li><a href="#8-python-slots">8. Python Slots</a></li>
<li><a href="#9-python-nitpicks">9. Python Nitpicks</a></li>
<li><a href="#10-advanced-f-string-string-formatting">10. Advanced f-string String Formatting</a></li>
<li><a href="#11-cache--lru_cache">11. Cache / lru_cache</a></li>
<li><a href="#12-python-futures">12. Python Futures</a></li>
<li><a href="#13-proxy-properties">13. Proxy Properties</a></li>
<li><a href="#14-metaclasses">14. Metaclasses</a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1895937864527192320">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1895937864527192320">Nitter Mirror</a></strong></p></blockquote>
<p><strong><code>@overload</code></strong> is a decorator from Python’s <code>typing</code> module that lets you define multiple signatures for the same function. Each overload tells the type checker exactly what types to expect when specific parameters are passed in.</p>
<p>For example, the code below dictates that <em>only</em> <code>list[str]</code> can be returned if <code>mode=split</code>, and <em>only</em> <code>str</code> can be returned if <code>mode=upper</code>. (The <code>Literal</code> type also forces mode to be either one of <code>split</code> or <code>upper</code>)</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> typing <span>import</span> Literal, overload
</span></span><span><span>
</span></span><span><span><span>@overload</span>
</span></span><span><span><span>def</span> <span>transform</span>(data: str, mode: Literal[<span>&#34;split&#34;</span>]) <span>-&gt;</span> list[str]:
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span><span>@overload</span>
</span></span><span><span><span>def</span> <span>transform</span>(data: str, mode: Literal[<span>&#34;upper&#34;</span>]) <span>-&gt;</span> str:
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>transform</span>(data: str, mode: Literal[<span>&#34;split&#34;</span>, <span>&#34;upper&#34;</span>]) <span>-&gt;</span> list[str] <span>|</span> str:
</span></span><span><span>    <span>if</span> mode <span>==</span> <span>&#34;split&#34;</span>:
</span></span><span><span>        <span>return</span> data<span>.</span>split()
</span></span><span><span>    <span>else</span>:
</span></span><span><span>        <span>return</span> data<span>.</span>upper()
</span></span><span><span>
</span></span><span><span>split_words <span>=</span> transform(<span>&#34;hello world&#34;</span>, <span>&#34;split&#34;</span>)  <span># Return type is list[str]</span>
</span></span><span><span>split_words[<span>0</span>]  <span># Type checker is happy</span>
</span></span><span><span>
</span></span><span><span>upper_words <span>=</span> transform(<span>&#34;hello world&#34;</span>, <span>&#34;upper&#34;</span>)  <span># Return type is str</span>
</span></span><span><span>upper_words<span>.</span>lower()  <span># Type checker is happy</span>
</span></span><span><span>
</span></span><span><span>upper_words<span>.</span>append(<span>&#34;!&#34;</span>)  <span># Cannot access attribute &#34;append&#34; for &#34;str&#34;</span>
</span></span></code></pre></div><p>Overloads can do more than just change return type based on arguments! In another example, we use typing overloads to ensure that either one of <code>id</code> OR <code>username</code> are passed in, but <em><strong>never both</strong></em>.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>@overload</span>
</span></span><span><span><span>def</span> <span>get_user</span>(id: int <span>=</span> <span>...</span>, username: <span>None</span> <span>=</span> <span>None</span>) <span>-&gt;</span> User:
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span><span>@overload</span>
</span></span><span><span><span>def</span> <span>get_user</span>(id: <span>None</span> <span>=</span> <span>None</span>, username: str <span>=</span> <span>...</span>) <span>-&gt;</span> User:
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>get_user</span>(id: int <span>|</span> <span>None</span> <span>=</span> <span>None</span>, username: str <span>|</span> <span>None</span> <span>=</span> <span>None</span>) <span>-&gt;</span> User:
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span>get_user(id<span>=</span><span>1</span>)  <span># Works!</span>
</span></span><span><span>get_user(username<span>=</span><span>&#34;John&#34;</span>)  <span># Works!</span>
</span></span><span><span>get_user(id<span>=</span><span>1</span>, username<span>=</span><span>&#34;John&#34;</span>)  <span># No overloads for &#34;get_user&#34; match the provided arguments</span>
</span></span></code></pre></div><blockquote>
<p>The <code>...</code> is a special value often used in overloads to indicate that a parameter is optional, but still requires a value.</p></blockquote>
<p><strong>✨ Quick bonus trick:</strong> As you probably saw, Python also has support for <strong>String Literals</strong>. These help assert that only specific string values can be passed to a parameter, giving you even more type safety. Think of them like a lightweight form of Enums!</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>set_color</span>(color: Literal[<span>&#34;red&#34;</span>, <span>&#34;blue&#34;</span>, <span>&#34;green&#34;</span>]) <span>-&gt;</span> <span>None</span>:
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span>set_color(<span>&#34;red&#34;</span>)
</span></span><span><span>set_color(<span>&#34;blue&#34;</span>)
</span></span><span><span>set_color(<span>&#34;green&#34;</span>)
</span></span><span><span>set_color(<span>&#34;fuchsia&#34;</span>)  <span># Argument of type &#34;Literal[&#39;fuchsia&#39;]&#34; cannot be assigned to parameter &#34;color&#34;</span>
</span></span></code></pre></div><h3 id="additional-resources">Additional Resources</h3>
<ul>
<li><a href="https://adamj.eu/tech/2021/05/29/python-type-hints-how-to-use-overload/">Python Type Hints: How to use <code>@overload</code></a></li>
<li><a href="https://peps.python.org/pep-3124/">PEP 3124 – Overloading, Generic Functions, Interfaces, and Adaptation</a></li>
<li><a href="https://docs.python.org/3/library/typing.html#overload">Python Docs - Overloads</a></li>
<li><a href="https://peps.python.org/pep-0586/">PEP 586 – Literal Types</a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1896257050147246306">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1896257050147246306">Nitter Mirror</a></strong></p></blockquote>
<p>By default, both required parameters and optional parameters can be assigned with both positional and keyword syntax. However, what if you <em>don’t</em> want that to happen? <strong>Keyword-only and Positional-only args</strong> let you control that.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>foo</span>(a, b, <span>/</span>, c, d, <span>*</span>, e, f):
</span></span><span><span>	<span>#         ^        ^</span>
</span></span><span><span>	<span># Ever seen these before?</span>
</span></span><span><span>	<span>...</span>
</span></span></code></pre></div><p><strong><code>*</code> (asterisk)</strong> marks keyword-only parameters. Arguments <em>after</em> <code>*</code> <em>must</em> be passed as keyword arguments.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>#   KW+POS | KW ONLY</span>
</span></span><span><span><span>#       vv | vv</span>
</span></span><span><span><span>def</span> <span>foo</span>(a, <span>*</span>, b):
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span><span># == ALLOWED ==</span>
</span></span><span><span>foo(a<span>=</span><span>1</span>, b<span>=</span><span>2</span>)  <span># All keyword</span>
</span></span><span><span>foo(<span>1</span>, b<span>=</span><span>2</span>)  <span># Half positional, half keyword</span>
</span></span><span><span>
</span></span><span><span><span># == NOT ALLOWED ==</span>
</span></span><span><span>foo(<span>1</span>, <span>2</span>)  <span># Cannot use positional for keyword-only parameter</span>
</span></span><span><span><span>#      ^</span>
</span></span></code></pre></div><p><strong><code>/</code> (forward slash)</strong> marks positional-only parameters. Arguments <em>before</em> <code>/</code> <em>must</em> be passed positionally and cannot be used as keyword arguments.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># POS ONLY | KW POS</span>
</span></span><span><span><span>#       vv | vv</span>
</span></span><span><span><span>def</span> <span>bar</span>(a, <span>/</span>, b):
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span><span># == ALLOWED ==</span>
</span></span><span><span>bar(<span>1</span>, <span>2</span>)  <span># All positional</span>
</span></span><span><span>bar(<span>1</span>, b<span>=</span><span>2</span>)  <span># Half positional, half keyword</span>
</span></span><span><span>
</span></span><span><span><span># == NOT ALLOWED ==</span>
</span></span><span><span>bar(a<span>=</span><span>1</span>, b<span>=</span><span>2</span>)  <span># Cannot use keyword for positional-only parameter</span>
</span></span><span><span><span>#   ^</span>
</span></span></code></pre></div><p>Keyword-only and Positional-only arguments are especially helpful for API developers to enforce how their arguments may be used and passed in.</p>
<h3 id="additional-resources-1">Additional Resources</h3>
<ul>
<li><a href="https://thepythoncodingbook.com/2022/12/11/positional-only-and-keyword-only-arguments-in-python/">Using Positional-Only And Keyword-Only Arguments in Python</a></li>
<li><a href="https://stackoverflow.com/questions/58477827/why-use-positional-only-parameters-in-python-3-8">Stack Overflow: Why use positional-only parameters in Python 3.8+?</a></li>
<li><a href="https://peps.python.org/pep-3102/">PEP 3102 – Keyword-Only Arguments</a></li>
<li><a href="https://peps.python.org/pep-0570/">PEP 570 – Python Positional-Only Parameters</a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1896667340777091212">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1896667340777091212">Nitter Mirror</a></strong></p></blockquote>
<p>A quick history lesson into Python’s typing:</p>
<blockquote>
<p>This is less of a “Python Feature” and more of a history lesson into Python’s type system, and what <code>from __future__ import annotations</code> does if you ever encounter it in production code.</p></blockquote>
<p><em>Python’s typing system started off as a hack</em>. Function annotation syntax was first introduced with <a href="https://peps.python.org/pep-3107/">PEP 3107</a> back in Python 3.0 as purely an extra way to decorate functions with no actual type-checking functionality.</p>
<p>Proper specifications for type annotations were later added in Python 3.5 through <a href="https://peps.python.org/pep-0484/">PEP 484</a>, but they were designed to be evaluated at bound / definition time. This worked great for simple cases, but it increasingly caused headaches with one type of problem: <strong>forward references</strong>.</p>
<p>This meant that forward references (using a type before it gets defined) required falling back to string literals, making the code less elegant and more error-prone.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># This won&#39;t work</span>
</span></span><span><span><span>class</span> <span>Foo</span>:
</span></span><span><span>    <span>def</span> <span>action</span>(self) <span>-&gt;</span> Foo:
</span></span><span><span>        <span># The `-&gt; Foo` return annotation is evaluated immediately during definition,</span>
</span></span><span><span>        <span># but the class `Foo` is not yet fully defined at that point,</span>
</span></span><span><span>        <span># causing a NameError during type checking.</span>
</span></span><span><span>        <span>...</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># This is the workaround -&gt; Using string types</span>
</span></span><span><span><span>class</span> <span>Bar</span>:
</span></span><span><span>    <span>def</span> <span>action</span>(self) <span>-&gt;</span> <span>&#34;Bar&#34;</span>:
</span></span><span><span>        <span># Workaround with string literals, but ugly and error-prone</span>
</span></span><span><span>        <span>...</span>
</span></span></code></pre></div><p>Introduced as a PEP (Python Enhancement Proposal), <a href="https://peps.python.org/pep-0563/">PEP 563: Postponed Evaluation of Annotations</a> aimed to fix this by changing when type annotations were evaluated. Instead of evaluating annotations at definition time, PEP 563 “<em>string-ifies</em>” types behind the scenes and postpones evaluation until they’re actually needed, typically during static analysis. This allows for cleaner forward references without explicitly defining string literals and reduces the runtime overhead of type annotations.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> __future__ <span>import</span> annotations
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Foo</span>:
</span></span><span><span>    <span>def</span> <span>bar</span>(self) <span>-&gt;</span> Foo:  <span># Works now!</span>
</span></span><span><span>        <span>...</span>
</span></span></code></pre></div><p><strong>So what was the problem?</strong></p>
<p>For type checkers, this change is largely transparent. But because PEP 563 implements this by essentially treating all types as strings behind the scenes, anything that relies on accessing return types at runtime (i.e., ORMs, serialization libraries, validators, dependency injectors, etc.) will have compatibility issues with the new setup.</p>
<p>That’s why even after ten years after the initial proposal, modern Python (3.13 as of writing this) still relies on the same hacked-together type system introduced in Python 3.5.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># ===== Regular Python Typing =====</span>
</span></span><span><span><span>def</span> <span>foobar</span>() <span>-&gt;</span> int:
</span></span><span><span>    <span>return</span> <span>1</span>
</span></span><span><span>
</span></span><span><span>ret_type <span>=</span> foobar<span>.</span>__annotations__<span>.</span>get(<span>&#34;return&#34;</span>)
</span></span><span><span>ret_type
</span></span><span><span><span># Returns: &lt;class &#39;int&#39;&gt;</span>
</span></span><span><span>new_int <span>=</span> ret_type()
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># ===== With Postponed Evaluation =====</span>
</span></span><span><span><span>from</span> __future__ <span>import</span> annotations
</span></span><span><span>
</span></span><span><span><span>def</span> <span>foobar</span>() <span>-&gt;</span> int:
</span></span><span><span>    <span>return</span> <span>1</span>
</span></span><span><span>
</span></span><span><span>ret_type <span>=</span> foobar<span>.</span>__annotations__<span>.</span>get(<span>&#34;return&#34;</span>)
</span></span><span><span>ret_type
</span></span><span><span><span># &#34;int&#34; (str)</span>
</span></span><span><span>new_int <span>=</span> ret_type()  <span># TypeError: &#39;str&#39; object is not callable</span>
</span></span></code></pre></div><p>Recently, <a href="https://peps.python.org/pep-0649/">PEP 649</a> proposes a new method to handle Python function and class annotations through deferred, or “lazy,” evaluation. Instead of evaluating annotations at the time of function or class definition, as is traditionally done, this approach delays their computation until they are actually accessed.</p>
<p>This is achieved by compiling the annotation expressions into a separate function, stored in a special <code>__annotate__</code> attribute. When the <code>__annotations__</code> attribute is accessed for the first time, this function is invoked to compute and cache the annotations, making them readily available for subsequent accesses.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># Example code from the PEP 649 proposal</span>
</span></span><span><span>
</span></span><span><span><span>class</span> <span>function</span>:
</span></span><span><span>    <span># __annotations__ on a function object is already a</span>
</span></span><span><span>    <span># &#34;data descriptor&#34; in Python, we&#39;re just changing</span>
</span></span><span><span>    <span># what it does</span>
</span></span><span><span>    <span>@property</span>
</span></span><span><span>    <span>def</span> <span>__annotations__</span>(self):
</span></span><span><span>        <span>return</span> self<span>.</span>__annotate__()
</span></span><span><span>
</span></span><span><span><span># ...</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>annotate_foo</span>():
</span></span><span><span>    <span>return</span> {<span>&#39;x&#39;</span>: int, <span>&#39;y&#39;</span>: MyType, <span>&#39;return&#39;</span>: float}
</span></span><span><span>
</span></span><span><span><span>def</span> <span>foo</span>(x <span>=</span> <span>3</span>, y <span>=</span> <span>&#34;abc&#34;</span>):
</span></span><span><span>    <span>...</span>
</span></span><span><span>
</span></span><span><span>foo<span>.</span>__annotate__ <span>=</span> annotate_foo
</span></span><span><span>
</span></span><span><span><span>class</span> <span>MyType</span>:
</span></span><span><span>   <span>...</span>
</span></span><span><span>
</span></span><span><span>foo_y_annotation <span>=</span> foo<span>.</span>__annotations__[<span>&#39;y&#39;</span>]
</span></span></code></pre></div><p>This deferred evaluation strategy addresses issues like forward references and circular dependencies, as annotations are only evaluated when needed. Moreover, it enhances performance by avoiding the immediate computation of annotations that might not be used, and maintains full semantic information, supporting introspection and runtime type-checking tools.</p>
<p><strong>✨ Bonus Fact:</strong> Since Python 3.11, Python now supports a “Self” type (<a href="https://peps.python.org/pep-0673/">PEP 673</a>) that allows for proper typing of methods that return instances of their own class, solving this particular example of self-referential return types.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> typing <span>import</span> Self
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Foo</span>:
</span></span><span><span>    <span>def</span> <span>bar</span>(self) <span>-&gt;</span> Self:
</span></span><span><span>        <span>...</span>
</span></span></code></pre></div><h3 id="additional-resources-2">Additional Resources</h3>
<ul>
<li><a href="https://peps.python.org/pep-0649/#a-history-of-annotations">A History Of Annotations</a></li>
<li><a href="https://blog.derlin.ch/python-type-hints-and-future-annotations">Python, Type Hints, and Future Annotations</a></li>
<li><a href="https://docs.python.org/3/library/__future__.html"><code>__future__</code> — Future Statement Definitions</a></li>
<li><a href="https://peps.python.org/pep-0484/">PEP 484 – Type Hints</a></li>
<li><a href="https://peps.python.org/pep-0563/">PEP 563 – Postponed Evaluation of Annotations</a></li>
<li><a href="https://peps.python.org/pep-0649/">PEP 649 – Deferred Evaluation Of Annotations Using Descriptors</a></li>
<li><a href="https://peps.python.org/pep-0749/">PEP 749 – Implementing PEP 649</a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1896994839516020825">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1896994839516020825">Nitter Mirror</a></strong></p></blockquote>
<p>Did you know that Python has <strong>Generics</strong>? In fact, <a href="https://docs.python.org/3/whatsnew/3.12.html">since Python 3.12</a>, a newer, sleeker, and sexier syntax for Generics was introduced.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>KVStore</span>[K: str <span>|</span> int, V]:
</span></span><span><span>    <span>def</span> __init__(self) <span>-&gt;</span> <span>None</span>:
</span></span><span><span>        self<span>.</span>store: dict[K, V] <span>=</span> {}
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>get</span>(self, key: K) <span>-&gt;</span> V:
</span></span><span><span>        <span>return</span> self<span>.</span>store[key]
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>set</span>(self, key: K, value: V) <span>-&gt;</span> <span>None</span>:
</span></span><span><span>        self<span>.</span>store[key] <span>=</span> value
</span></span><span><span>
</span></span><span><span>kv <span>=</span> KVStore[str, int]()
</span></span><span><span>kv<span>.</span>set(<span>&#34;one&#34;</span>, <span>1</span>)
</span></span><span><span>kv<span>.</span>set(<span>&#34;two&#34;</span>, <span>2</span>)
</span></span><span><span>kv<span>.</span>set(<span>&#34;three&#34;</span>, <span>3</span>)
</span></span></code></pre></div><p>Python 3.5 initially introduced Generics through the <code>TypeVar</code> syntax. However, <a href="https://peps.python.org/pep-0695/">PEP 695</a> for Python 3.12 revamped type annotations with native syntax for generics, type aliases, and more.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># OLD SYNTAX - Python 3.5 to 3.11</span>
</span></span><span><span><span>from</span> typing <span>import</span> Generic, TypeVar
</span></span><span><span>
</span></span><span><span>UnBounded <span>=</span> TypeVar(<span>&#34;UnBounded&#34;</span>)
</span></span><span><span>Bounded <span>=</span> TypeVar(<span>&#34;Bounded&#34;</span>, bound<span>=</span>int)
</span></span><span><span>Constrained <span>=</span> TypeVar(<span>&#34;Constrained&#34;</span>, int, float)
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Foo</span>(Generic[UnBounded, Bounded, Constrained]):
</span></span><span><span>    <span>def</span> __init__(self, x: UnBounded, y: Bounded, z: Constrained) <span>-&gt;</span> <span>None</span>:
</span></span><span><span>        self<span>.</span>x <span>=</span> x
</span></span><span><span>        self<span>.</span>y <span>=</span> y
</span></span><span><span>        self<span>.</span>z <span>=</span> z
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># NEW SYNTAX - Python 3.12+</span>
</span></span><span><span><span>class</span> <span>Foo</span>[UnBounded, Bounded: int, Constrained: int <span>|</span> float]:
</span></span><span><span>    <span>def</span> __init__(self, x: UnBounded, y: Bounded, z: Constrained) <span>-&gt;</span> <span>None</span>:
</span></span><span><span>        self<span>.</span>x <span>=</span> x
</span></span><span><span>        self<span>.</span>y <span>=</span> y
</span></span><span><span>        self<span>.</span>z <span>=</span> z
</span></span></code></pre></div><p>This change also introduces an even more powerful version of <strong>variadic generics</strong>. Meaning you can have an arbitrary number of type parameters for complex data structures and operations.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>Tuple</span>[<span>*</span>Ts]:
</span></span><span><span>    <span>def</span> __init__(self, <span>*</span>args: <span>*</span>Ts) <span>-&gt;</span> <span>None</span>:
</span></span><span><span>        self<span>.</span>values <span>=</span> args
</span></span><span><span>
</span></span><span><span><span># Works with any number of types!</span>
</span></span><span><span>pair <span>=</span> Tuple[str, int](<span>&#34;hello&#34;</span>, <span>42</span>)
</span></span><span><span>triple <span>=</span> Tuple[str, int, bool](<span>&#34;world&#34;</span>, <span>100</span>, <span>True</span>)
</span></span></code></pre></div><p>Finally, as part of the 3.12 typing changes, Python also introduced a new concise syntax for type aliases!</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># OLD SYNTAX - Python 3.5 to 3.9</span>
</span></span><span><span><span>from</span> typing <span>import</span> NewType
</span></span><span><span>Vector <span>=</span> NewType(<span>&#34;Vector&#34;</span>, list[float])
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># OLD-ish SYNTAX - Python 3.10 to 3.11</span>
</span></span><span><span><span>from</span> typing <span>import</span> TypeAlias
</span></span><span><span>Vector: TypeAlias <span>=</span> list[float]
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># NEW SYNTAX - Python 3.12+</span>
</span></span><span><span>type Vector <span>=</span> list[float]
</span></span></code></pre></div><h3 id="additional-resources-3">Additional Resources</h3>
<ul>
<li><a href="https://arjancodes.com/blog/python-generics-syntax/">Blog on Python 3.12 Generics</a></li>
<li><a href="https://realpython.com/python312-typing/">Python 3.12 Preview: Static Typing Improvements</a></li>
<li><a href="https://typing.python.org/en/latest/spec/generics.html">Python Docs - Generics</a></li>
<li><a href="https://peps.python.org/pep-0695/">PEP 695 – Type Parameter Syntax</a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1897373856475836829">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1897373856475836829">Nitter Mirror</a></strong></p></blockquote>
<p>One of Python’s major features (and also major complaints) is its support for <a href="https://realpython.com/duck-typing-python/"><strong>Duck Typing</strong></a>. There’s a saying that goes:</p>
<p><q>
    “If it walks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.”
</q></p><p>However, that raises the question: <em>How do you <strong>type</strong> duck typing?</em></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>Duck</span>:
</span></span><span><span>    <span>def</span> <span>quack</span>(self): print(<span>&#39;Quack!&#39;</span>)
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Person</span>:
</span></span><span><span>    <span>def</span> <span>quack</span>(self): print(<span>&#34;I&#39;m quacking!&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Dog</span>:
</span></span><span><span>    <span>def</span> <span>bark</span>(self): print(<span>&#39;Woof!&#39;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>run_quack</span>(obj):
</span></span><span><span>    obj<span>.</span>quack()
</span></span><span><span>
</span></span><span><span>run_quack(Duck())  <span># Works!</span>
</span></span><span><span>run_quack(Person())  <span># Works!</span>
</span></span><span><span>run_quack(Dog())  <span># Fails with AttributeError</span>
</span></span></code></pre></div><p>That’s where <strong>Protocols</strong> come in. Protocols (also known as <strong>Structural Subtyping</strong>) are typing classes in Python defining the structure or behavior that classes can follow <strong>without</strong> the use of interfaces or inheritance.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> typing <span>import</span> Protocol
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Quackable</span>(Protocol):
</span></span><span><span>    <span>def</span> <span>quack</span>(self) <span>-&gt;</span> <span>None</span>:
</span></span><span><span>        <span>...</span>  <span># The ellipsis indicates this is just a method signature</span>
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Duck</span>:
</span></span><span><span>    <span>def</span> <span>quack</span>(self): print(<span>&#39;Quack!&#39;</span>)
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Dog</span>:
</span></span><span><span>    <span>def</span> <span>bark</span>(self): print(<span>&#39;Woof!&#39;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>run_quack</span>(obj: Quackable):
</span></span><span><span>    obj<span>.</span>quack()
</span></span><span><span>
</span></span><span><span>run_quack(Duck())  <span># Works!</span>
</span></span><span><span>run_quack(Dog())  <span># Fails during TYPE CHECKING (not runtime)</span>
</span></span></code></pre></div><p>In essence, Protocols check what your object <em><strong>can</strong></em> do, not what it <em><strong>is</strong></em>. They simply state that as long as an object implements certain methods or behaviors, it qualifies, regardless of its actual type or inheritance.</p>
<p><strong>✨ Additional quick tip:</strong>  Add the <code>@runtime_checkable</code> decorator if you want <code>isinstance()</code> checks to work alongside your Protocols!</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>@runtime_checkable</span>
</span></span><span><span><span>class</span> <span>Drawable</span>(Protocol):
</span></span><span><span>    <span>def</span> <span>draw</span>(self) <span>-&gt;</span> <span>None</span>:
</span></span><span><span>        <span>...</span>
</span></span></code></pre></div><h3 id="additional-resources-4">Additional Resources</h3>
<ul>
<li><a href="https://realpython.com/python-protocol/">Python Protocols: Leveraging Structural Subtyping</a></li>
<li><a href="https://mypy.readthedocs.io/en/stable/protocols.html">MyPy: Protocols and structural subtyping</a></li>
<li><a href="https://typing.python.org/en/latest/spec/protocol.html">Python Docs - Protocols</a></li>
<li><a href="https://peps.python.org/pep-0544/">PEP 544 – Protocols: Structural subtyping</a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1897714940297068624">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1897714940297068624">Nitter Mirror</a></strong></p></blockquote>
<p><strong>Context Managers</strong> are objects that define the methods: <code>__enter__()</code> and <code>__exit__()</code>. The <code>__enter__()</code> method runs when you enter the <code>with</code> block, and the <code>__exit__()</code> method runs when you leave it (even if an exception occurs).</p>
<p><strong><code>Contextlib</code></strong> simplifies this process by wrapping all that boilerplate code in a single easy-to-use decorator.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># OLD SYNTAX - Traditional OOP-style context manager</span>
</span></span><span><span><span>class</span> <span>retry</span>:
</span></span><span><span>    <span>def</span> __enter__(self):
</span></span><span><span>        print(<span>&#34;Entering Context&#34;</span>)
</span></span><span><span>
</span></span><span><span>    <span>def</span> __exit__(self, exc_type, exc_val, exc_tb):
</span></span><span><span>        print(<span>&#34;Exiting Context&#34;</span>)
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># NEW SYNTAX - New contextlib-based context manager</span>
</span></span><span><span><span>import</span> contextlib
</span></span><span><span>
</span></span><span><span><span>@contextlib.contextmanager</span>
</span></span><span><span><span>def</span> <span>retry</span>():
</span></span><span><span>    print(<span>&#34;Entering Context&#34;</span>)
</span></span><span><span>    <span>yield</span>
</span></span><span><span>    print(<span>&#34;Exiting Context&#34;</span>)
</span></span></code></pre></div><p>To create your own, write a function with the <code>@contextlib.contextmanager</code> decorator. Add setup code before <code>yield</code>, cleanup code after it. Any variables on yield will be passed in as additional context. That’s it.</p>
<p>The <code>yield</code> statement instructs the context manager to pause your function and lets content within the <code>with</code> block run.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> contextlib
</span></span><span><span>
</span></span><span><span><span>@contextlib.contextmanager</span>
</span></span><span><span><span>def</span> <span>context</span>():
</span></span><span><span>    <span># Setup code here</span>
</span></span><span><span>    setup()
</span></span><span><span>    <span>yield</span> (<span>...</span>)  <span># Any variables you want to be passed to the with block</span>
</span></span><span><span>    <span># Teardown code here</span>
</span></span><span><span>    takedown()
</span></span></code></pre></div><p>Overall, this is a much more concise and readable way of creating and using context managers in Python.</p>
<h3 id="additional-resources-5">Additional Resources</h3>
<ul>
<li><a href="https://realpython.com/python-with-statement/">Context Managers and Python’s with Statement</a></li>
<li><a href="https://book.pythontips.com/en/latest/context_managers.html">Python Tips: Context Manager</a></li>
<li><a href="https://docs.python.org/3/library/contextlib.html">Python Docs: <code>contextlib</code> — Utilities for with-statement contexts</a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1898065958578929801">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1898065958578929801">Nitter Mirror</a></strong></p></blockquote>
<p>Introduced in <a href="https://docs.python.org/3/whatsnew/3.10.html">Python 3.10</a>, <strong>Structural Pattern Matching</strong> gives Python developers a powerful alternative to traditional conditional logic. At its most basic, the syntax looks like this:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>match</span> value:
</span></span><span><span>    <span>case</span> pattern1:
</span></span><span><span>        <span># code if value matches pattern1</span>
</span></span><span><span>    <span>case</span> pattern2:
</span></span><span><span>        <span># code if value matches pattern2</span>
</span></span><span><span>    <span>case</span> _:
</span></span><span><span>        <span># wildcard case (default)</span>
</span></span></code></pre></div><p>The real power comes with <strong>destructuring</strong>! Match patterns break down complex data structures and extract values in a single step.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># Destructuring and matching tuples</span>
</span></span><span><span><span>match</span> point:
</span></span><span><span>    <span>case</span> (<span>0</span>, <span>0</span>):
</span></span><span><span>        <span>return</span> <span>&#34;Origin&#34;</span>
</span></span><span><span>    <span>case</span> (<span>0</span>, y):
</span></span><span><span>        <span>return</span> <span>f</span><span>&#34;Y-axis at </span><span>{</span>y<span>}</span><span>&#34;</span>
</span></span><span><span>    <span>case</span> (x, <span>0</span>):
</span></span><span><span>        <span>return</span> <span>f</span><span>&#34;X-axis at </span><span>{</span>x<span>}</span><span>&#34;</span>
</span></span><span><span>    <span>case</span> (x, y):
</span></span><span><span>        <span>return</span> <span>f</span><span>&#34;Point at (</span><span>{</span>x<span>}</span><span>, </span><span>{</span>y<span>}</span><span>)&#34;</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># Using OR pattern (|) to match multiple patterns</span>
</span></span><span><span><span>match</span> day:
</span></span><span><span>    <span>case</span> (<span>&#34;Monday&#34;</span>
</span></span><span><span>          <span>|</span> <span>&#34;Tuesday&#34;</span>
</span></span><span><span>          <span>|</span> <span>&#34;Wednesday&#34;</span>
</span></span><span><span>          <span>|</span> <span>&#34;Thursday&#34;</span>
</span></span><span><span>          <span>|</span> <span>&#34;Friday&#34;</span>):
</span></span><span><span>        <span>return</span> <span>&#34;Weekday&#34;</span>
</span></span><span><span>    <span>case</span> <span>&#34;Saturday&#34;</span> <span>|</span> <span>&#34;Sunday&#34;</span>:
</span></span><span><span>        <span>return</span> <span>&#34;Weekend&#34;</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># Guard clauses with inline &#39;if&#39; statements</span>
</span></span><span><span><span>match</span> temperature:
</span></span><span><span>    <span>case</span> temp <span>if</span> temp <span>&lt;</span> <span>0</span>:
</span></span><span><span>        <span>return</span> <span>&#34;Freezing&#34;</span>
</span></span><span><span>    <span>case</span> temp <span>if</span> temp <span>&lt;</span> <span>20</span>:
</span></span><span><span>        <span>return</span> <span>&#34;Cold&#34;</span>
</span></span><span><span>    <span>case</span> temp <span>if</span> temp <span>&lt;</span> <span>30</span>:
</span></span><span><span>        <span>return</span> <span>&#34;Warm&#34;</span>
</span></span><span><span>    <span>case</span> _:
</span></span><span><span>        <span>return</span> <span>&#34;Hot&#34;</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># Capture entire collections using asterisk (*)</span>
</span></span><span><span><span>match</span> numbers:
</span></span><span><span>    <span>case</span> [f]:
</span></span><span><span>        <span>return</span> <span>f</span><span>&#34;First: </span><span>{</span>f<span>}</span><span>&#34;</span>
</span></span><span><span>    <span>case</span> [f, l]:
</span></span><span><span>        <span>return</span> <span>f</span><span>&#34;First: </span><span>{</span>f<span>}</span><span>, Last: </span><span>{</span>l<span>}</span><span>&#34;</span>
</span></span><span><span>    <span>case</span> [f, <span>*</span>m, l]:
</span></span><span><span>        <span>return</span> <span>f</span><span>&#34;First: </span><span>{</span>f<span>}</span><span>, Middle: </span><span>{</span>m<span>}</span><span>, Last: </span><span>{</span>l<span>}</span><span>&#34;</span>
</span></span><span><span>    <span>case</span> []:
</span></span><span><span>        <span>return</span> <span>&#34;Empty list&#34;</span>
</span></span></code></pre></div><p>You can also combine match-case with other Python features like <strong><a href="https://realpython.com/python-walrus-operator/">walrus operators</a></strong> to create even more powerful patterns.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># Check if a packet is valid or not</span>
</span></span><span><span>packet: list[int] <span>=</span> [<span>0x01</span>, <span>0x02</span>, <span>0x03</span>, <span>0x04</span>, <span>0x05</span>, <span>0x06</span>, <span>0x07</span>]
</span></span><span><span>
</span></span><span><span><span>match</span> packet:
</span></span><span><span>    <span>case</span> [c1, c2, <span>*</span>data, footer] <span>if</span> (  <span># Deconstruct packet into header, data, and footer</span>
</span></span><span><span>        (checksum <span>:=</span> c1 <span>+</span> c2) <span>==</span> sum(data) <span>and</span>  <span># Check that the checksum is correct</span>
</span></span><span><span>        len(data) <span>==</span> footer  <span># Check that the data length is correct</span>
</span></span><span><span>    ):
</span></span><span><span>        print(<span>f</span><span>&#34;Packet received: </span><span>{</span>data<span>}</span><span> (Checksum: </span><span>{</span>checksum<span>}</span><span>)&#34;</span>)
</span></span><span><span>    <span>case</span> [c1, c2, <span>*</span>data]:  <span># Failure case where structure is correct but checksum is wrong</span>
</span></span><span><span>        print(<span>f</span><span>&#34;Packet received: </span><span>{</span>data<span>}</span><span> (Checksum Failed)&#34;</span>)
</span></span><span><span>    <span>case</span> [_, <span>*</span>__]:  <span># Failure case where packet is too short</span>
</span></span><span><span>        print(<span>&#34;Invalid packet length&#34;</span>)
</span></span><span><span>    <span>case</span> []:  <span># Failure case where packet is empty</span>
</span></span><span><span>        print(<span>&#34;Empty packet&#34;</span>)
</span></span><span><span>    <span>case</span> _:  <span># Failure case where packet is invalid</span>
</span></span><span><span>        print(<span>&#34;Invalid packet&#34;</span>)
</span></span></code></pre></div><h3 id="additional-resources-6">Additional Resources</h3>
<ul>
<li><a href="https://realpython.com/structural-pattern-matching/">Structural Pattern Matching in Python</a></li>
<li><a href="https://benhoyt.com/writings/python-pattern-matching/">Structural pattern matching in Python 3.10</a></li>
<li><a href="https://stackoverflow.com/questions/70815197/how-to-do-structural-pattern-matching-in-python-3-10-with-a-type-to-match">Good StackOverflow Thread</a></li>
<li><a href="https://docs.python.org/3/reference/compound_stmts.html#match">Python Docs: The match statement</a></li>
<li><a href="https://peps.python.org/pep-0634/">PEP 634 – Structural Pattern Matching: Specification</a></li>
<li><a href="https://peps.python.org/pep-0636/">PEP 636 – Structural Pattern Matching: Tutorial</a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1898596367045640193">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1898596367045640193">Nitter Mirror</a></strong></p></blockquote>
<p><strong>Slots</strong> are a way to potentially speed up the creation and access of any Python class.</p>
<p><strong>TLDR:</strong> They define a fixed set of attributes for classes, optimizing and speeding up accesses during runtime.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>Person</span>:
</span></span><span><span>    __slots__ <span>=</span> (<span>&#39;name&#39;</span>, <span>&#39;age&#39;</span>)
</span></span><span><span>
</span></span><span><span>    <span>def</span> __init__(self, name, age):
</span></span><span><span>        self<span>.</span>name <span>=</span> name
</span></span><span><span>        self<span>.</span>age <span>=</span> age
</span></span></code></pre></div><p>Under the hood, Python classes store instance attributes in an internal dictionary called <code>__dict__</code>, meaning a hash table lookup is required each time you want to access a value.</p>
<p>In contrast, <code>__slots__</code> uses an array-like structure where attributes can be looked up in true O(1) time, bringing a minor overall speed bump to Python.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># Without __slots__</span>
</span></span><span><span><span>class</span> <span>FooBar</span>:
</span></span><span><span>    <span>def</span> __init__(self):
</span></span><span><span>        self<span>.</span>a <span>=</span> <span>1</span>
</span></span><span><span>        self<span>.</span>b <span>=</span> <span>2</span>
</span></span><span><span>        self<span>.</span>c <span>=</span> <span>3</span>
</span></span><span><span>
</span></span><span><span>f <span>=</span> FooBar()
</span></span><span><span>print(f<span>.</span>__dict__)  <span># {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># With __slots__</span>
</span></span><span><span><span>class</span> <span>FooBar</span>:
</span></span><span><span>    __slots__ <span>=</span> (<span>&#39;a&#39;</span>, <span>&#39;b&#39;</span>, <span>&#39;c&#39;</span>)
</span></span><span><span>
</span></span><span><span>    <span>def</span> __init__(self):
</span></span><span><span>        self<span>.</span>a <span>=</span> <span>1</span>
</span></span><span><span>        self<span>.</span>b <span>=</span> <span>2</span>
</span></span><span><span>        self<span>.</span>c <span>=</span> <span>3</span>
</span></span><span><span>
</span></span><span><span>f <span>=</span> FooBar()
</span></span><span><span>print(f<span>.</span>__dict__)  <span># AttributeError</span>
</span></span><span><span>print(f<span>.</span>__slots__)  <span># (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</span>
</span></span></code></pre></div><p>There is still debate about whether <code>__slots__</code> is worth using, as it complicates class definitions with very marginal or no performance benefits at all. However, it is a useful tool to have in your arsenal if you ever need it.</p>
<h3 id="additional-resources-7">Additional Resources</h3>
<ul>
<li><a href="https://wiki.python.org/moin/UsingSlots">Using Slots - Python Wiki</a></li>
<li><a href="https://medium.com/@apps.merkurev/dont-forget-about-slots-in-python-c397f414c490">Don’t forget about <code>__slots__</code> in Python!</a></li>
<li><a href="https://stackoverflow.com/questions/472000/usage-of-slots">StackOverflow - Usage of <code>__slots__</code></a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1898934432939290658">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1898934432939290658">Nitter Mirror</a></strong></p></blockquote>
<blockquote>
<p>This is not a Python “feature” or “tip” per se, but instead a handful of quick syntax tips to really clean up your Python codebase.</p>
<p>As someone who’s seen a lot of Python code.</p></blockquote>
<h2 id="91-for-else-statements">9.1 For-else statements</h2>
<p>If you ever need to check if a for loop completes without a break, <strong>for-else statements</strong> are a great way to accomplish this <strong>without</strong> using a temporary variable.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># ===== Don&#39;t write this =====</span>
</span></span><span><span>found_server <span>=</span> <span>False</span>  <span># Keep track of whether we found a server</span>
</span></span><span><span><span>for</span> server <span>in</span> servers:
</span></span><span><span>    <span>if</span> server<span>.</span>check_availability():
</span></span><span><span>        primary_server <span>=</span> server
</span></span><span><span>        found_server <span>=</span> <span>True</span>  <span># Set the flag to True</span>
</span></span><span><span>        <span>break</span>
</span></span><span><span><span>if</span> <span>not</span> found_server:
</span></span><span><span>    <span># Use the backup server if no server was found</span>
</span></span><span><span>    primary_server <span>=</span> backup_server
</span></span><span><span>
</span></span><span><span><span># Continue execution with whatever server we found</span>
</span></span><span><span>deploy_application(primary_server)
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># ===== Write this instead =====</span>
</span></span><span><span><span>for</span> server <span>in</span> servers:
</span></span><span><span>    <span>if</span> server<span>.</span>check_availability():
</span></span><span><span>        primary_server <span>=</span> server
</span></span><span><span>        <span>break</span>
</span></span><span><span><span>else</span>:
</span></span><span><span>    <span># Use the backup server if no server was found</span>
</span></span><span><span>    primary_server <span>=</span> backup_server
</span></span><span><span>
</span></span><span><span><span># Continue execution with whatever server we found</span>
</span></span><span><span>deploy_application(primary_server)
</span></span></code></pre></div><h2 id="92-walrus-operator">9.2 Walrus Operator</h2>
<p>If you need to define and evaluate a variable all in one expression, the <strong>Walrus Operator</strong> (new in Python 3.8 with <a href="https://peps.python.org/pep-0572/">PEP 572</a>) is a quick way to accomplish just that.</p>
<blockquote>
<p>Walrus operators are really useful for using a value right after checking if it is <strong><code>not None</code></strong>!</p></blockquote>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># ===== Don&#39;t write this =====</span>
</span></span><span><span>response <span>=</span> get_user_input()
</span></span><span><span><span>if</span> response:
</span></span><span><span>    print(<span>&#39;You pressed:&#39;</span>, response)
</span></span><span><span><span>else</span>:
</span></span><span><span>    print(<span>&#39;You pressed nothing&#39;</span>)
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># ===== Write this instead =====</span>
</span></span><span><span><span>if</span> response <span>:=</span> get_user_input():
</span></span><span><span>    print(<span>&#39;You pressed:&#39;</span>, response)
</span></span><span><span><span>else</span>:
</span></span><span><span>    print(<span>&#39;You pressed nothing&#39;</span>)
</span></span></code></pre></div><h2 id="93-short-circuit-evaluation">9.3 Short Circuit Evaluation</h2>
<p><strong>Short-circuit Evaluation</strong> is a shortcut for getting the “next available” or “next truthy” value in a list of expressions. It turns out you can simply chain <code>or</code> statements!</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># ===== Don&#39;t write this =====</span>
</span></span><span><span>username, full_name, first_name <span>=</span> get_user_info()
</span></span><span><span>
</span></span><span><span><span>if</span> username <span>is</span> <span>not</span> <span>None</span>:
</span></span><span><span>    display_name <span>=</span> username
</span></span><span><span><span>elif</span> full_name <span>is</span> <span>not</span> <span>None</span>:
</span></span><span><span>    display_name <span>=</span> full_name
</span></span><span><span><span>elif</span> first_name <span>is</span> <span>not</span> <span>None</span>:
</span></span><span><span>    display_name <span>=</span> first_name
</span></span><span><span><span>else</span>:
</span></span><span><span>    display_name <span>=</span> <span>&#34;Anonymous&#34;</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># ===== Write this instead =====</span>
</span></span><span><span>username, full_name, first_name <span>=</span> get_user_info()
</span></span><span><span>
</span></span><span><span>display_name <span>=</span> username <span>or</span> full_name <span>or</span> first_name <span>or</span> <span>&#34;Anonymous&#34;</span>
</span></span></code></pre></div><h2 id="94-operator-chaining">9.4 Operator Chaining</h2>
<p>Finally, Python lets you <strong>chain comparison operators</strong> together to shorten up integer range comparisons, making them more readable than the equivalent boolean expressions.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># ===== Don&#39;t write this =====</span>
</span></span><span><span><span>if</span> <span>0</span> <span>&lt;</span> x <span>and</span> x <span>&lt;</span> <span>10</span>:
</span></span><span><span>    print(<span>&#34;x is between 0 and 10&#34;</span>)
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># ===== Write this instead =====</span>
</span></span><span><span><span>if</span> <span>0</span> <span>&lt;</span> x <span>&lt;</span> <span>10</span>:  <span># Instead of if 0 &lt; x and x &lt; 10</span>
</span></span><span><span>    print(<span>&#34;x is between 0 and 10&#34;</span>)
</span></span></code></pre></div><h3 id="additional-resources-8">Additional Resources</h3>
<ul>
<li><a href="https://book.pythontips.com/en/latest/for_-_else.html"><code>for/else</code> - Python Tips</a></li>
<li><a href="https://realpython.com/python-walrus-operator/">The Walrus Operator: Python’s Assignment Expressions</a></li>
<li><a href="https://peps.python.org/pep-0572/">PEP 572 – Assignment Expressions</a></li>
<li><a href="https://realpython.com/python-or-operator/#default-values-for-variables">Using the “or” Boolean Operator in Python</a></li>
<li><a href="https://mathspp.com/blog/pydonts/chaining-comparison-operators">Chaining Comparison Operators</a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1899162302131122430">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1899162302131122430">Nitter Mirror</a></strong></p></blockquote>
<p>Python’s <strong>f-strings</strong> are no secret by now. Introduced in Python 3.6 with <a href="https://peps.python.org/pep-0498/">PEP 498</a>, they are a better, cleaner, faster, and safer method of interpolating variables, objects, and expressions into strings.</p>
<p>But did you know there is more to f-strings than just inserting variables? There exists a hidden formatting syntax called the <strong>Format Mini-Language</strong> that allows you to have much greater control over string formatting.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>print(<span>f</span><span>&#34;</span><span>{</span><span>&#39; [ Run Status ] &#39;</span><span>:</span><span>=^50</span><span>}</span><span>&#34;</span>)
</span></span><span><span>print(<span>f</span><span>&#34;[</span><span>{</span>time<span>:</span><span>%H:%M:%S</span><span>}</span><span>] Training Run </span><span>{</span>run_id<span>=}</span><span> status: </span><span>{</span>progress<span>:</span><span>.1%</span><span>}</span><span>&#34;</span>)
</span></span><span><span>print(<span>f</span><span>&#34;Summary: </span><span>{</span>total_samples<span>:</span><span>,</span><span>}</span><span> samples processed&#34;</span>)
</span></span><span><span>print(<span>f</span><span>&#34;Accuracy: </span><span>{</span>accuracy<span>:</span><span>.4f</span><span>}</span><span> | Loss: </span><span>{</span>loss<span>:</span><span>#.3g</span><span>}</span><span>&#34;</span>)
</span></span><span><span>print(<span>f</span><span>&#34;Memory: </span><span>{</span>memory <span>/</span> <span>1e9</span><span>:</span><span>+.2f</span><span>}</span><span> GB&#34;</span>)
</span></span></code></pre></div><p><strong>Output:</strong></p>
<pre tabindex="0"><code>=================== [ Run Status ] ===================
[11:16:37] Training Run run_id=42 status: 87.4%
Summary: 12,345,678 samples processed
Accuracy: 0.9876 | Loss: 0.0123
Memory: +2.75 GB
</code></pre><p>You can do things like enable debug expressions, apply number formatting (similar to <code>str.format</code>), add string padding, format datetime objects, and more! All within f-string format specifiers.</p>
<h2 id="regular-f-strings">Regular f-strings</h2>
<pre tabindex="0"><code>Hello World!
</code></pre><h2 id="debug-expressions">Debug Expressions</h2>
<div><pre tabindex="0"><code data-lang="python"><span><span>print(<span>f</span><span>&#34;</span><span>{</span>name<span>=}</span><span>, </span><span>{</span>age<span>=}</span><span>&#34;</span>)
</span></span></code></pre></div><pre tabindex="0"><code>name=&#39;Claude&#39;, age=3
</code></pre><h2 id="number-formatting">Number Formatting</h2>
<div><pre tabindex="0"><code data-lang="python"><span><span>print(<span>f</span><span>&#34;Pi: </span><span>{</span>pi<span>:</span><span>.2f</span><span>}</span><span>&#34;</span>)
</span></span><span><span>print(<span>f</span><span>&#34;Avogadro: </span><span>{</span>avogadro<span>:</span><span>.2e</span><span>}</span><span>&#34;</span>)
</span></span><span><span>print(<span>f</span><span>&#34;Big Number: </span><span>{</span>big_num<span>:</span><span>,</span><span>}</span><span>&#34;</span>)
</span></span><span><span>print(<span>f</span><span>&#34;Hex: </span><span>{</span>num<span>:</span><span>#0x</span><span>}</span><span>&#34;</span>)
</span></span><span><span>print(<span>f</span><span>&#34;Number: </span><span>{</span>num<span>:</span><span>09</span><span>}</span><span>&#34;</span>)
</span></span></code></pre></div><pre tabindex="0"><code>Pi: 3.14
Avogadro: 6.02e+23
Big Number: 1,000,000
Hex: 0x1a4
Number: 000000420
</code></pre><h2 id="string-padding">String Padding</h2>
<div><pre tabindex="0"><code data-lang="python"><span><span>print(<span>f</span><span>&#34;Left: |</span><span>{</span>word<span>:</span><span>&lt;10</span><span>}</span><span>|&#34;</span>)
</span></span><span><span>print(<span>f</span><span>&#34;Right: |</span><span>{</span>word<span>:</span><span>&gt;10</span><span>}</span><span>|&#34;</span>)
</span></span><span><span>print(<span>f</span><span>&#34;Center: |</span><span>{</span>word<span>:</span><span>^10</span><span>}</span><span>|&#34;</span>)
</span></span><span><span>print(<span>f</span><span>&#34;Center *: |</span><span>{</span>word<span>:</span><span>*^10</span><span>}</span><span>|&#34;</span>)
</span></span></code></pre></div><pre tabindex="0"><code>Left: |Python    |
Right: |    Python|
Center: |  Python  |
Center *: |**Python**|
</code></pre><h2 id="date-formatting">Date Formatting</h2>
<div><pre tabindex="0"><code data-lang="python"><span><span>print(<span>f</span><span>&#34;Date: </span><span>{</span>now<span>:</span><span>%Y-%m-%d</span><span>}</span><span>&#34;</span>)
</span></span><span><span>print(<span>f</span><span>&#34;Time: </span><span>{</span>now<span>:</span><span>%H:%M:%S</span><span>}</span><span>&#34;</span>)
</span></span></code></pre></div><pre tabindex="0"><code>Date: 2025-03-10
Time: 14:30:59
</code></pre><h2 id="percentage-formatting">Percentage Formatting</h2>
<div><pre tabindex="0"><code data-lang="python"><span><span>print(<span>f</span><span>&#34;Progress: </span><span>{</span>progress<span>:</span><span>.1%</span><span>}</span><span>&#34;</span>)
</span></span></code></pre></div><pre tabindex="0"><code>Progress: 75.0%
</code></pre><h3 id="additional-resources-9">Additional Resources</h3>
<ul>
<li><a href="https://realpython.com/python-f-strings/">Python’s F-String for String Interpolation and Formatting</a></li>
<li><a href="https://realpython.com/python-format-mini-language/">Python’s Format Mini-Language for Tidy Strings</a></li>
<li><a href="https://docs.python.org/3/tutorial/inputoutput.html">Python Docs - Input and Output</a></li>
<li><a href="https://peps.python.org/pep-0498/">PEP 498 – Literal String Interpolation</a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1899571802873135208">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1899571802873135208">Nitter Mirror</a></strong></p></blockquote>
<p>You can use the built-in <strong><code>@cache</code></strong> decorator to dramatically speed up recursive functions and expensive calculations! (which superseded <code>@lru_cache</code> in Python 3.9!)</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> functools <span>import</span> cache
</span></span><span><span>
</span></span><span><span><span>@cache</span>
</span></span><span><span><span>def</span> <span>fib</span>(n):
</span></span><span><span>    <span>return</span> n <span>if</span> n <span>&lt;</span> <span>2</span> <span>else</span> fib(n<span>-</span><span>1</span>) <span>+</span> fib(n<span>-</span><span>2</span>)
</span></span></code></pre></div><p>Since Python 3.2, <code>@lru_cache</code> was introduced as part of the <code>functools</code> module for quick &amp; clean function memoization. Starting with Python 3.9, <code>@cache</code> was added for the same effect with less code. <code>lru_cache</code> still exists if you want explicit control of the cache size.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>FIB_CACHE <span>=</span> {}
</span></span><span><span>
</span></span><span><span><span># With Manual Caching :(</span>
</span></span><span><span><span>def</span> <span>fib</span>(n):
</span></span><span><span>    <span>if</span> n <span>in</span> FIB_CACHE:
</span></span><span><span>        <span>return</span> FIB_CACHE[n]
</span></span><span><span>    <span>if</span> n <span>&lt;=</span> <span>2</span>:
</span></span><span><span>        <span>return</span> <span>1</span>
</span></span><span><span>    FIB_CACHE[n] <span>=</span> fib(n <span>-</span> <span>1</span>) <span>+</span> fib(n <span>-</span> <span>2</span>)
</span></span><span><span>    <span>return</span> FIB_CACHE[n]
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> functools <span>import</span> lru_cache
</span></span><span><span>
</span></span><span><span><span># Same code with lru_cache :)</span>
</span></span><span><span><span>@lru_cache</span>(maxsize<span>=</span><span>None</span>)
</span></span><span><span><span>def</span> <span>fib</span>(n):
</span></span><span><span>    <span>return</span> n <span>if</span> n <span>&lt;</span> <span>2</span> <span>else</span> fib(n<span>-</span><span>1</span>) <span>+</span> fib(n<span>-</span><span>2</span>)
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> functools <span>import</span> cache
</span></span><span><span>
</span></span><span><span><span># Same code with new Python 3.9&#39;s cache :D</span>
</span></span><span><span><span>@cache</span>
</span></span><span><span><span>def</span> <span>fib</span>(n):
</span></span><span><span>    <span>return</span> n <span>if</span> n <span>&lt;</span> <span>2</span> <span>else</span> fib(n<span>-</span><span>1</span>) <span>+</span> fib(n<span>-</span><span>2</span>)
</span></span></code></pre></div><h3 id="additional-resources-10">Additional Resources</h3>
<ul>
<li><a href="https://www.datacamp.com/tutorial/python-cache-introduction">Python Cache: Two Simple Methods</a></li>
<li><a href="https://realpython.com/lru-cache-python/">(outdated) Caching in Python Using the LRU Cache Strategy</a></li>
<li><a href="https://docs.python.org/3/library/functools.html#functools.cache">Python Docs - <code>@functools.cache</code></a></li>
<li><a href="https://docs.python.org/3/library/functools.html#functools.lru_cache">Python Docs - <code>@functools.lru_cache</code></a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1899900763977228374">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1899900763977228374">Nitter Mirror</a></strong></p></blockquote>
<p>Did you know that Python has native <code>Promise</code>-like concurrency control?</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> concurrent.futures <span>import</span> Future
</span></span><span><span>
</span></span><span><span><span># Manually create a Future Object</span>
</span></span><span><span>future <span>=</span> Future()
</span></span><span><span>
</span></span><span><span><span># Set its result whenever you want</span>
</span></span><span><span>future<span>.</span>set_result(<span>&#34;Hello from the future!&#34;</span>)
</span></span><span><span>
</span></span><span><span><span># Get the result</span>
</span></span><span><span>print(future<span>.</span>result())  <span># &#34;Hello from the future!&#34;</span>
</span></span></code></pre></div><p>Python’s <strong><code>concurrent.futures</code></strong> module gives you direct control over async operations, just like JS Promises. For example, they let you attach callbacks that run when the result is ready (just like JS’s <code>.then()</code>).</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> concurrent.futures <span>import</span> Future
</span></span><span><span>
</span></span><span><span>future <span>=</span> Future()
</span></span><span><span>
</span></span><span><span><span># Add callbacks BEFORE or AFTER completion!</span>
</span></span><span><span>future<span>.</span>add_done_callback(<span>lambda</span> f: print(<span>f</span><span>&#34;Got: </span><span>{</span>f<span>.</span>result()<span>}</span><span>&#34;</span>))
</span></span><span><span>
</span></span><span><span>future<span>.</span>set_result(<span>&#34;Async result&#34;</span>)
</span></span><span><span><span># Prints: &#34;Got: Async result&#34;</span>
</span></span><span><span>
</span></span><span><span>future<span>.</span>add_done_callback(<span>lambda</span> f: print(<span>f</span><span>&#34;After: </span><span>{</span>f<span>.</span>result()<span>}</span><span>&#34;</span>))
</span></span><span><span><span># Prints: &#34;After: Async result&#34;</span>
</span></span></code></pre></div><p>Python Futures also come with primitives to handle exceptions, set timeouts, or stop tasks completely.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> concurrent.futures <span>import</span> Future
</span></span><span><span><span>import</span> time<span>,</span> threading
</span></span><span><span>
</span></span><span><span><span># Create and manage a future manually</span>
</span></span><span><span>future <span>=</span> Future()
</span></span><span><span>
</span></span><span><span><span># Background task function</span>
</span></span><span><span><span>def</span> <span>background_task</span>():
</span></span><span><span>    time<span>.</span>sleep(<span>2</span>)
</span></span><span><span>    future<span>.</span>set_result(<span>&#34;Done!&#34;</span>)
</span></span><span><span>
</span></span><span><span>thread <span>=</span> threading<span>.</span>Thread(target<span>=</span>background_task)
</span></span><span><span>thread<span>.</span>daemon <span>=</span> <span>True</span>
</span></span><span><span>thread<span>.</span>start()
</span></span><span><span>
</span></span><span><span><span># Try all control operations</span>
</span></span><span><span>print(<span>f</span><span>&#34;Cancelled: </span><span>{</span>future<span>.</span>cancel()<span>}</span><span>&#34;</span>)  <span># Likely False if started</span>
</span></span><span><span>
</span></span><span><span><span>try</span>:
</span></span><span><span>    <span># Wait at most 0.5 seconds</span>
</span></span><span><span>    result <span>=</span> future<span>.</span>result(timeout<span>=</span><span>0.5</span>)
</span></span><span><span><span>except</span> <span>TimeoutError</span>:
</span></span><span><span>    print(<span>&#34;Timed out!&#34;</span>)
</span></span><span><span>
</span></span><span><span><span># Create failed future</span>
</span></span><span><span>err_future <span>=</span> Future()
</span></span><span><span>err_future<span>.</span>set_exception(<span>ValueError</span>(<span>&#34;Failed&#34;</span>))
</span></span><span><span>print(<span>f</span><span>&#34;Has error: </span><span>{</span>bool(err_future<span>.</span>exception())<span>}</span><span>&#34;</span>)
</span></span></code></pre></div><p>Just like modern JS, the <code>asyncio</code> module has its own Future that works seamlessly with Python’s <code>async/await</code> syntax:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> asyncio
</span></span><span><span>
</span></span><span><span><span>async</span> <span>def</span> <span>main</span>():
</span></span><span><span>    future <span>=</span> asyncio<span>.</span>Future()
</span></span><span><span>
</span></span><span><span>    <span># Set result after delay</span>
</span></span><span><span>    asyncio<span>.</span>create_task(set_after_delay(future))
</span></span><span><span>
</span></span><span><span>    <span># Await just like a JS Promise!</span>
</span></span><span><span>    result <span>=</span> <span>await</span> future
</span></span><span><span>    print(result)  <span># &#34;Worth the wait!&#34;</span>
</span></span><span><span>
</span></span><span><span><span>async</span> <span>def</span> <span>set_after_delay</span>(future):
</span></span><span><span>    <span>await</span> asyncio<span>.</span>sleep(<span>1</span>)
</span></span><span><span>    future<span>.</span>set_result(<span>&#34;Worth the wait!&#34;</span>)
</span></span><span><span>
</span></span><span><span>asyncio<span>.</span>run(main())
</span></span></code></pre></div><p>Finally, for CPU or I/O bound tasks, Python’s <code>ThreadPoolExecutor</code> can automatically create and manage futures for you.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> concurrent.futures <span>import</span> ThreadPoolExecutor
</span></span><span><span><span>import</span> time
</span></span><span><span>
</span></span><span><span><span>def</span> <span>slow_task</span>():
</span></span><span><span>    time<span>.</span>sleep(<span>1</span>)
</span></span><span><span>    <span>return</span> <span>&#34;Done!&#34;</span>
</span></span><span><span>
</span></span><span><span><span>with</span> ThreadPoolExecutor() <span>as</span> executor:
</span></span><span><span>    <span># Returns a Future immediately</span>
</span></span><span><span>    future <span>=</span> executor<span>.</span>submit(slow_task)
</span></span><span><span>
</span></span><span><span>    <span># Do other work while waiting...</span>
</span></span><span><span>    print(<span>&#34;Working...&#34;</span>)
</span></span><span><span>
</span></span><span><span>    <span># Get result when needed</span>
</span></span><span><span>    print(future<span>.</span>result())
</span></span></code></pre></div><h3 id="additional-resources-11">Additional Resources</h3>
<ul>
<li><a href="https://medium.com/@smrati.katiyar/introduction-to-concurrent-futures-in-python-009fe1d4592c">Introduction to <code>concurrent.futures</code> in Python</a></li>
<li><a href="https://alexwlchan.net/2019/adventures-with-concurrent-futures/">Adventures in Python with <code>concurrent.futures</code></a></li>
<li><a href="https://docs.python.org/3/library/asyncio-future.html">Python Docs - Futures</a></li>
<li><a href="https://docs.python.org/3/library/concurrent.futures.html">Python Docs - <code>concurrent.futures</code></a></li>
</ul>

<blockquote>
<p><strong><a href="https://x.com/edwardjxli/status/1900316544066007332">Original X/Twitter Thread</a>  |  <a href="https://nitter.hydranet.dev/edwardjxli/status/1900316544066007332">Nitter Mirror</a></strong></p></blockquote>
<p>Did you know you can make class attributes act as <strong>BOTH</strong> methods <strong>AND</strong> properties?!? <em>This isn’t a built-in feature of Python</em>, but instead a demonstration of what you can do with clever use of Python’s dunder (magic) methods and descriptors.</p>
<blockquote>
<p>(Note that this is very much an example implementation and should not be used in production)</p></blockquote>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> typing <span>import</span> Callable, Generic, TypeVar, ParamSpec, Self
</span></span><span><span>
</span></span><span><span>P <span>=</span> ParamSpec(<span>&#34;P&#34;</span>)
</span></span><span><span>R <span>=</span> TypeVar(<span>&#34;R&#34;</span>)
</span></span><span><span>T <span>=</span> TypeVar(<span>&#34;T&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>class</span> <span>ProxyProperty</span>(Generic[P, R]):
</span></span><span><span>    func: Callable[P, R]
</span></span><span><span>    instance: object
</span></span><span><span>
</span></span><span><span>    <span>def</span> __init__(self, func: Callable[P, R]) <span>-&gt;</span> <span>None</span>:
</span></span><span><span>        self<span>.</span>func <span>=</span> func
</span></span><span><span>
</span></span><span><span>    <span>def</span> __get__(self, instance: object, _<span>=</span><span>None</span>) <span>-&gt;</span> Self:
</span></span><span><span>        self<span>.</span>instance <span>=</span> instance
</span></span><span><span>        <span>return</span> self
</span></span><span><span>
</span></span><span><span>    <span>def</span> __call__(self, <span>*</span>args: P<span>.</span>args, <span>**</span>kwargs: P<span>.</span>kwargs) <span>-&gt;</span> R:
</span></span><span><span>        <span>return</span> self<span>.</span>func(self<span>.</span>instance, <span>*</span>args, <span>**</span>kwargs)
</span></span><span><span>
</span></span><span><span>    <span>def</span> __repr__(self) <span>-&gt;</span> str:
</span></span><span><span>        <span>return</span> self<span>.</span>func(self<span>.</span>instance)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>proxy_property</span>(func: Callable[P, R]) <span>-&gt;</span> ProxyProperty[P, R]:
</span></span><span><span>    <span>return</span> ProxyProperty(func)
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Container</span>:
</span></span><span><span>    <span>@proxy_property</span>
</span></span><span><span>    <span>def</span> <span>value</span>(self, val: int <span>=</span> <span>5</span>) <span>-&gt;</span> str:
</span></span><span><span>        <span>return</span> <span>f</span><span>&#34;The value is: </span><span>{</span>val<span>}</span><span>&#34;</span>
</span></span><span><span>
</span></span><span><span><span># Example usage</span>
</span></span><span><span>c <span>=</span> Container()
</span></span><span><span>print(c<span>.</span>value)      <span># Returns: The value is: 5</span>
</span></span><span><span>print(c<span>.</span>value(<span>7</span>))   <span># Returns: The value is: 7</span>
</span></span></code></pre></div><p><em>How does this work under the hood?</em> It comes down to Python’s <strong><a href="https://docs.python.org/3/howto/descriptor.html">Descriptor Protocol</a></strong>:</p>
<ol>
<li>
<p>The <code>__get__</code> method transforms the <code>ProxyProperty</code> object into a <strong>descriptor</strong>.</p>
</li>
<li>
<p>When you access <code>c.value</code>, Python calls <code>__get__</code> which returns <code>self</code> (the descriptor instance).</p>
</li>
<li>
<p>The <code>__repr__</code> method handles property access (returning default values).</p>
</li>
<li>
<p>The <code>__call__</code> method handles method calls with parameters.</p>
</li>
</ol>
<p>This creates a dual-purpose attribute that can be both read directly AND called like a function!</p>
<p>The benefit of this class is that it allows you to create intuitive APIs where a property might need configuration, or properties that should have sensible defaults but still allow for customization.</p>
<blockquote>
<p>If you want to look at a proper production-ready implementation of <strong>proxy properties</strong>, check out Codegen’s implementation of <code>ProxyProperty</code> here: <a href="https://github.com/codegen-sh/codegen/blob/590ce812c08d973d8f2c22795ab3e5055cea6b1e/src/codegen/sdk/_proxy.py#L5">codegen/src/codegen/sdk/_proxy.py</a></p></blockquote>
<h3 id="additional-resources-12">Additional Resources</h3>
<ul>
<li><a href="https://realpython.com/python-descriptors/">Python Descriptors: An Introduction</a></li>
<li><a href="https://deepsource.com/blog/demystifying-python-descriptor-protocol">Demystifying Python’s Descriptor Protocol</a></li>
<li><a href="https://docs.python.org/3/howto/descriptor.html">Descriptor Guide - Python Wiki</a></li>
<li><a href="https://wrapt.readthedocs.io/en/latest/wrappers.html">Proxies and Wrappers</a></li>
</ul>

<p>Finally, introducing one of Python’s most powerful yet mysterious features: <strong>Metaclasses</strong></p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>MyMetaclass</span>(type):
</span></span><span><span>    <span>def</span> __new__(cls, name, bases, namespace):
</span></span><span><span>        <span># Magic happens here</span>
</span></span><span><span>        <span>return</span> super()<span>.</span>__new__(cls, name, bases, namespace)
</span></span><span><span>
</span></span><span><span><span>class</span> <span>MyClass</span>(metaclass<span>=</span>MyMetaclass):
</span></span><span><span>    <span>pass</span>
</span></span><span><span>
</span></span><span><span>obj <span>=</span> MyClass()
</span></span></code></pre></div><p>Classes in Python aren’t just blueprints for objects. They’re objects too! And every object needs a class that created it. So what creates class objects? <strong>Metaclasses</strong>.</p>
<p>By default, Python uses the <code>type</code> metaclass to create all classes. For example, these two are equivalent to each other:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># Create a MyClass object</span>
</span></span><span><span><span>class</span> <span>MyClass</span>:
</span></span><span><span>    <span>...</span>
</span></span><span><span>obj <span>=</span> MyClass()
</span></span><span><span>
</span></span><span><span><span># Also creates a MyClass object</span>
</span></span><span><span>obj2 <span>=</span> type(<span>&#34;MyClass&#34;</span>, (), {})
</span></span></code></pre></div><p>To break down what those arguments mean, here is an example that creates a class with an attribute <code>x</code> and a method <code>say_hi</code>, that also subclasses off <code>object</code>.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># type(</span>
</span></span><span><span><span>#     name,</span>
</span></span><span><span><span>#     bases,</span>
</span></span><span><span><span>#     attributes</span>
</span></span><span><span><span># )</span>
</span></span><span><span>CustomClass <span>=</span> type(
</span></span><span><span>    <span>&#39;CustomClass&#39;</span>,
</span></span><span><span>    (object,),
</span></span><span><span>    {<span>&#39;x&#39;</span>: <span>5</span>, <span>&#39;say_hi&#39;</span>: <span>lambda</span> self: <span>&#39;Hello!&#39;</span>}
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span>obj <span>=</span> CustomClass()
</span></span><span><span>print(obj<span>.</span>x)  <span># 5</span>
</span></span><span><span>print(obj<span>.</span>say_hi())  <span># Hello!</span>
</span></span></code></pre></div><p>In essence, Metaclasses let you customize and modify these arguments during class creation. For example, here is a metaclass that doubles every integer attribute for a class:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>class</span> <span>DoubleAttrMeta</span>(type):
</span></span><span><span>    <span>def</span> __new__(cls, name, bases, namespace):
</span></span><span><span>        new_namespace <span>=</span> {}
</span></span><span><span>        <span>for</span> key, val <span>in</span> namespace<span>.</span>items():
</span></span><span><span>            <span>if</span> isinstance(val, int):
</span></span><span><span>                val <span>*=</span> <span>2</span>
</span></span><span><span>            new_namespace[key] <span>=</span> val
</span></span><span><span>        <span>return</span> super()<span>.</span>__new__(cls, name, bases, new_namespace)
</span></span><span><span>
</span></span><span><span><span>class</span> <span>MyClass</span>(metaclass<span>=</span>DoubleAttrMeta):
</span></span><span><span>    x <span>=</span> <span>5</span>
</span></span><span><span>    y <span>=</span> <span>10</span>
</span></span><span><span>
</span></span><span><span>print(MyClass<span>.</span>x)  <span># 10</span>
</span></span><span><span>print(MyClass<span>.</span>y)  <span># 20</span>
</span></span></code></pre></div><p>Here is another example of a metaclass that registers every class created into a registry.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># ===== Metaclass Solution =====</span>
</span></span><span><span><span>class</span> <span>RegisterMeta</span>(type):
</span></span><span><span>    registry <span>=</span> []
</span></span><span><span>    <span>def</span> __new__(mcs, name, bases, attrs):
</span></span><span><span>        cls <span>=</span> super()<span>.</span>__new__(mcs, name, bases, attrs)
</span></span><span><span>        mcs<span>.</span>registry<span>.</span>append(cls)
</span></span><span><span>        <span>return</span> cls
</span></span></code></pre></div><p><em>The problem is</em>, decorators could achieve this same goal without the use of black magic (and it’s often cleaner too).</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># ===== Decorator Solution =====</span>
</span></span><span><span><span>def</span> <span>register</span>(cls):
</span></span><span><span>    registry<span>.</span>append(cls)
</span></span><span><span>    <span>return</span> cls
</span></span><span><span>
</span></span><span><span><span>@register</span>
</span></span><span><span><span>class</span> <span>MyClass</span>:
</span></span><span><span>    <span>pass</span>
</span></span></code></pre></div><p>And that kind of brings to light the biggest problem with metaclasses:</p>
<p><strong>Almost 100% of the time, you will never need to touch them.</strong></p>
<p>In your day-to-day development, 99% of your code won’t ever hit a use case where metaclasses could be useful. And of that 1%, 95% of those cases could just be solved with regular decorators, dunder methods, or just plain inheritance.</p>
<p>That’s why there is that one famous Python quote that goes:</p>
<p><q>
    Metaclasses are deeper magic than 99% of users should ever worry about. If you wonder whether you need them, you don’t. - Tim Peters
</q></p><p>But if you are that 1% which has a unique enough problem that only metaclasses can solve, they are a powerful tool that lets you tinker with the internals of the Python object system.</p>
<blockquote>
<p><strong>As for some real-world examples of metaclasses:</strong></p>
<ul>
<li>Python’s “ABC” implementation uses metaclasses to implement abstract classes.</li>
<li>Python’s “Enum” implementation uses it to create enumeration types.</li>
<li>A bunch of 3rd party libraries like Django, SQLAlchemy, Pydantic, and Pytest use metaclasses for a variety of purposes.</li>
</ul></blockquote>
<h3 id="additional-resources-13">Additional Resources</h3>
<ul>
<li><a href="https://realpython.com/python-metaclasses/">Python Metaclasses</a></li>
<li><a href="https://sentry.io/answers/what-are-Python-metaclasses/">What are Python Metaclasses?</a></li>
<li><a href="https://medium.com/@miguel.amezola/demystifying-python-metaclasses-understanding-and-harnessing-the-power-of-custom-class-creation-d7dff7b68de8">Demystifying Python Metaclasses</a></li>
<li><a href="https://s3.dualstack.us-east-2.amazonaws.com/pythondotorg-assets/media/files/meta-vladimir.txt">Re: The metaclass saga using Python</a></li>
</ul>

<p><strong>And that’s it folks!</strong> 14 of some of the most interesting &amp; underrated Python features that I’ve encountered in my Python career.</p>
<p>If you’ve made it this far, shoot me a quick message as to which ones you’ve seen before and which ones you haven’t! I’d love to hear from you.</p>
<p>Happy Python-ing, y’all 🐍!</p>

    </div></div>
  </body>
</html>
