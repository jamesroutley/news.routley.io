<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/continuedev/continue">Original</a>
    <h1>Show HN: Continue – Open-source coding autopilot</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p><a href="https://github.com/kofigumbs/multi">Multi</a> is a macOS app for creating native wrappers around your favorite websites.
Since Multi apps use Apple’s WebKit engine, they are generally less resource-intensive than their Electron equivalents.
The Multi runtime also connects web platform APIs to macOS native widgets, like notifications—the little feature that turned the 3.0 release into a complete rewrite.</p>

<p>Prior to this release, Multi used the deprecated <code>NSUserNotification</code> to show banner alerts.
These APIs still seem to work OK, but fixing some of the long-standing GitHub issues would have required me to invest further into a sinking ship.
I figured migrating to the newer <code>UNNotification</code> might magically solve some of those issues, but even if it didn’t I’d still be in a better position for researching solutions.
At a surface level the APIs work similarly, and it was simple to get the new code compiling;
but when I went to test my Multi app, no notifications appeared.</p>

<p>Eventually I discovered that <code>UNUserNotificationCenter</code> automatically denies notification permission requests unless the app is codesigned.
This restriction was a problem for Multi because <code>codesign</code> requires that an apps bundle contains no references to external artifacts.
In the old architecture, creating a Multi app would add a symlink in the place where macOS expected the main executable.
That symlink pointed to an executable runtime within Multi itself, which meant that updating Multi automatically updates any wrapper apps.
<code>codesign</code> complains (rightfully so) with this setup since the executable artifact lives outside of the signed bundle.</p>

<p>The solution: I now ship the runtime as a dynamic library instead of an executable, and Multi wrapper apps contain a small initializer binary that loads it.
<code>codesign</code> is happy because the resulting bundle is statically self-contained.
And users are happy because updating Multi still updates behavior in existing wrapper apps.
The initializer binary itself should only need to change if I’ve done something tragically wrong in <a href="https://github.com/kofigumbs/multi/blob/main/Sources/MultiStub/main.swift">these 10 lines of Swift</a>.</p>

</div></div>
  </body>
</html>
