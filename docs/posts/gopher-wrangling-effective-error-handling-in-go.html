<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stephenn.com/2023/06/gopher-wrangling.-effective-error-handling-in-go/">Original</a>
    <h1>Gopher Wrangling: Effective error handling in Go</h1>
    
    <div id="readability-page-1" class="page"><div><p>When programming in Go, the amount of error handling is something that slaps you in the face. Most API‚Äôs you deal with will expose errors. It can become overwhelming, but with a few tips and a guiding principle we can make handling errors easy, keep our code clean and give you the confidence that nothing is breaking in production.</p><p><img loading="lazy" src="https://stephenn.com/assets/2023-06-gopher-wrangling-go-errors.jpg" alt="A cartoon of a crazy stressed programmer pulling their hair out in front of lots of screens showing a error exclamation marks"/></p><blockquote><p>A cartoon of a crazy stressed programmer pulling their hair out in front of lots of screens showing a error exclamation marks</p></blockquote><h3 id="guiding-principle">Guiding principle</h3><p>The goal for our error handling strategy is that it should require minimal effort and provide an easy way to debug any errors that do occur.</p><p>We wont cover strategies like retrying because they are less common and also expose errors.</p><h2 id="1-always-handle-errors">1. Always handle errors</h2><p>Always handle errors. Sometimes it‚Äôs tempting to skip one, you might not expect that error to ever happen. But that‚Äôs why it‚Äôs an exception! You need to handle it so that you can find out clearly if it ever does happen.</p><p>If you don‚Äôt handle the error, the expected value will be something else and just lead to another error that will be harder to debug, or worse it could lead to data corruption.</p><p>In most cases to handle the error all you need to do is return it to the caller of your method, where they can log it.</p><p>For example, when refreshing some data you might load it, then save it. If you skip the error handling it could overwrite potentially useful data with corrupt data.</p><p>üëé Bad error handling</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>refresh</span>() {
</span></span><span><span>    bytes, _ <span>:=</span> <span>loadData</span>()
</span></span><span><span>    <span>saveData</span>(bytes)
</span></span><span><span>}
</span></span></code></pre></div><p>üëç Good error handling</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>refresh</span>() <span>error</span> {
</span></span><span><span>    bytes, err <span>:=</span> <span>loadData</span>()
</span></span><span><span>    <span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>        <span>return</span> err
</span></span><span><span>    }
</span></span><span><span>    <span>saveData</span>(bytes)
</span></span><span><span>}
</span></span></code></pre></div><h2 id="2-log-errors-in-one-layer">2. Log errors in one layer</h2><p>You always want to log your errors, ideally to something that will notify you about the error, so you can fix it. There is no point logging the error multiple times at every layer. Make it the top layer‚Äôs responsibility and don‚Äôt log in any services or lower level code.</p><p>Make sure your logging framework is including stack traces so you can trace the error to its cause.</p><p>For example in a web app you would log the error in the http handler when returning the Internal Server status code.</p><p>üëç Good error handling</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>refresh</span>() <span>error</span> {
</span></span><span><span>    bytes, err <span>:=</span> <span>loadData</span>()
</span></span><span><span>    <span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>        <span>return</span> err
</span></span><span><span>    }
</span></span><span><span>    <span>saveData</span>(bytes)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (h <span>*</span>handlers) <span>handleRefreshRequest</span>(w http.ResponseWriter, r <span>*</span>http.Request) {
</span></span><span><span>    err <span>:=</span> <span>refresh</span>()
</span></span><span><span>    <span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>        log.<span>Error</span>(<span>&#34;unexpected error processing request %w&#34;</span>, err)
</span></span><span><span>        w.<span>WriteHeader</span>(http.StatusInternalServerError)
</span></span><span><span>        <span>return</span>
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    w.<span>WriteHeader</span>(http.StatusOK)
</span></span><span><span>}
</span></span></code></pre></div><h2 id="3-returning-async-errors">3. Returning async errors</h2><p>When processing data concurrently using a go-func‚Äôs, it can be annoying to return the error. But if you don‚Äôt your app will be less maintainable. To handle async errors, return them via a channel to the calling thread.</p><p>üëé Bad error handling</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>refreshManyConcurrently</span>() {
</span></span><span><span>    <span>go</span> <span>func</span>(){
</span></span><span><span>        <span>refresh</span>(<span>1</span>)
</span></span><span><span>    }()
</span></span><span><span>
</span></span><span><span>    <span>go</span> <span>func</span>(){
</span></span><span><span>        <span>refresh</span>(<span>2</span>)
</span></span><span><span>    }()
</span></span><span><span>}
</span></span></code></pre></div><p>üëç Good error handling</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>refreshManyConcurrently</span>() <span>error</span> {
</span></span><span><span>    errors <span>:=</span> <span>make</span>(<span>chan</span> <span>error</span>, <span>2</span>)
</span></span><span><span>    <span>go</span> <span>func</span>(){
</span></span><span><span>        errors <span>&lt;-</span> <span>refresh</span>(<span>1</span>)
</span></span><span><span>    }()
</span></span><span><span>
</span></span><span><span>    <span>go</span> <span>func</span>(){
</span></span><span><span>        errors <span>&lt;-</span> <span>refresh</span>(<span>2</span>)
</span></span><span><span>    }()
</span></span><span><span>    <span>return</span> multierror.<span>Combine</span>(<span>&lt;-</span>errors, <span>&lt;-</span> errors)
</span></span><span><span>}
</span></span></code></pre></div><p>When calling functions that return a value and a possible error using a type like <code>Result[T]</code>, to wrap the response to pass on the channel.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> Result[T any] <span>struct</span> {
</span></span><span><span>    Value T
</span></span><span><span>    Error <span>error</span>
</span></span><span><span>}
</span></span></code></pre></div><h2 id="4-wrapping-errors">4. Wrapping errors</h2><p>Sometimes you want to add additional context to an error message. Eg to include the id of the request that caused the error. You can use <code>fmt.error</code> for this.</p><div><pre tabindex="0"><code data-lang="go"><span><span>err <span>:=</span> <span>saveToDb</span>(user)
</span></span><span><span><span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>    <span>return</span> fmt.<span>errorf</span>(<span>&#34;unexpected error saving user. userId=%v error=%w&#34;</span>, user.Id, err)
</span></span><span><span>}
</span></span></code></pre></div><p>Usually this isn‚Äôt necessary and its better to just return the error unwrapped.</p><h2 id="5-downgrade-errors-warnings">5. Downgrade errors Warnings</h2><p>There are types of errors that regularly occur during normal operation. The system might not be able to prevent them all the time, but they don‚Äôt need to investigate every time. It is better to treat them as warnings rather than errors. These might be for things like timeouts or intermittent connection errors.</p><p>üëç Good error handling</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> (h <span>*</span>handlers) <span>handleRefreshRequest</span>(w http.ResponseWriter, r <span>*</span>http.Request) {
</span></span><span><span>    err <span>:=</span> <span>refresh</span>()
</span></span><span><span>    <span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>        <span>if</span> err <span>==</span> context.DeadlineExceeded {
</span></span><span><span>            log.<span>Warn</span>(<span>&#34;Timeout error processing request %w&#34;</span>, err)
</span></span><span><span>        } <span>else</span> {
</span></span><span><span>            log.<span>Error</span>(<span>&#34;unexpected error processing request %w&#34;</span>, err)
</span></span><span><span>        }
</span></span><span><span>
</span></span><span><span>        w.<span>WriteHeader</span>(http.StatusInternalServerError)
</span></span><span><span>        <span>return</span>
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    w.<span>WriteHeader</span>(http.StatusOK)
</span></span><span><span>}
</span></span></code></pre></div></div></div>
  </body>
</html>
