<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://csvbase.com/blog/6">Original</a>
    <h1>DuckDB Isn&#39;t Just Fast</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <!-- DuckDB is more than just fast -->
<p>DuckDB is a single file SQL database.  It&#39;s designed for data analysis and so,
probably because of the bent of people who are into that sort of thing, a lot
of the evaluations of it end up being quantitative.  This isn&#39;t just true of
DuckDB - most comparisons of most data tools tend to focus on the measureable.</p>
<p>That means they
<a href="https://medium.com/@kayrnt/how-duckdb-can-be-up-to-1000x-more-efficient-than-bigquery-36bab2405259">mainly</a>
<a href="https://github.com/prrao87/duckdb-study">look</a>
<a href="https://www.fivetran.com/blog/how-fast-is-duckdb-really">at</a>
<a href="https://duckdblabs.github.io/db-benchmark/">speed</a>.  And DuckDB generally does
well.</p>
<p>The notes on benchmark performance graphs often read &#34;higher is better&#34; and
performance improvements are even called &#34;optimisations&#34;.  But the truth is, at
least as a user, once performance reaches a satisfactory level - enough for
your own data analysis to complete in a reasonable about of time - there is no
further benefit from increased speed.  Instead of being called &#34;performance
optimisation&#34; it should probably be called &#34;performance satisfaction&#34; as once
it is satisfactory you have finished.</p>
<p>Usability is different.  The whole point of computers is as an aid to
productivity so user-friendliness is actually the bit you want to optimise.
Unlike speed, being easier to use is always better and there is very little
limit to that.  So it&#39;s &#34;usability improvements&#34; that should be called
&#34;optimisations&#34; but perhaps the relevant ships on all of these terms have
sailed.</p>
<p>Anyway to balance out the force out I want to demonstrate some usability
benefits of DuckDB.  Mostly, they cannot be measured:</p>
<ol>
<li>Good developer ergonomics</li>
<li>It handles larger than memory (&#34;out of core&#34;) datasets</li>
<li>Easy to install &amp; run</li>
</ol>
<h2>Ergonomics</h2>
<p>DuckDB takes care to make the common stuff straightward.  For example, you can
create tables (including inferring the table schema) straight from <a href="https://csvbase.com/meripaterson/stock-exchanges">input
files</a>:</p>
<div><pre><span></span><span>-- loading a table from a parquet file</span>
<span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>stock_exchanges</span><span> </span><span>AS</span><span></span>
<span>FROM</span><span></span>
<span>    </span><span>read_parquet</span><span>(</span><span></span>
<span>        </span><span>&#34;https://csvbase.com/meripaterson/stock-exchanges.parquet&#34;</span><span></span>
<span>);</span><span></span>
</pre></div>
<p>Looking at the schema of that table:</p>
<div><pre><span></span><span>-- the output of: .schema stock_exchanges</span>
<span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>stock_exchanges</span><span> </span><span>(</span><span></span>
<span>    </span><span>csvbase_row_id</span><span> </span><span>bigint</span><span>,</span><span></span>
<span>    </span><span>Continent</span><span> </span><span>varchar</span><span>,</span><span></span>
<span>    </span><span>Country</span><span> </span><span>varchar</span><span>,</span><span></span>
<span>    </span><span>&#34;Name&#34;</span><span> </span><span>varchar</span><span>,</span><span></span>
<span>    </span><span>MIC</span><span> </span><span>varchar</span><span>,</span><span></span>
<span>    </span><span>&#34;Last changed&#34;</span><span> </span><span>date</span><span></span>
<span>);</span><span></span>
</pre></div>
<p>DuckDB has inferred all the columns, including their types, from the Parquet
file.  Brill.  And as you can see, that Parquet file can come from anywhere on
the web, it need not be local.  That&#39;s perhaps not a big advance on some of the
common dataframe libraries, but it is a big advance in the world of SQL-based
tools, most of which can only read CSV (not Parquet) and then also require the
schema to be created beforehand.</p>
<p>And you don&#39;t actually have to create a table first in order to query the data.
The <code>read_parquet</code> function returns a relation and so can act as a sub-query.
A specific example of that, this time with a csv file:</p>
<div><pre><span></span><span>-- pulling down the most recent EUR:USD exchange rate</span>
<span>SELECT</span><span></span>
<span>    </span><span>rate</span><span></span>
<span>FROM</span><span></span>
<span>    </span><span>read_csv_auto</span><span>(</span><span>&#34;https://csvbase.com/table-munger/eurofxref.csv&#34;</span><span>)</span><span></span>
<span>WHERE</span><span></span>
<span>    </span><span>currency</span><span> </span><span>=</span><span> </span><span>&#39;USD&#39;</span><span>;</span><span></span>
</pre></div>
<p>So you can freely query parquet and csv files on the web with the minimum of
fuss.</p>
<p>But how much of SQL does DuckDB support?  A very wide swathe.  I haven&#39;t done
any comprehensive analysis but of the stuff I use in Postgres I haven&#39;t found
much if anything that isn&#39;t also implemented in DuckDB.</p>
<p>For example, window functions are fully supported:</p>
<div><pre><span></span><span>-- smoothed history of the eur:usd exchange rate</span>
<span>SELECT</span><span></span>
<span>    </span><span>date</span><span>,</span><span></span>
<span>    </span><span>avg</span><span>(</span><span>rate</span><span>)</span><span> </span><span>OVER</span><span> </span><span>(</span><span></span>
<span>        </span><span>ORDER</span><span> </span><span>BY</span><span> </span><span>date</span><span></span>
<span>        </span><span>ROWS</span><span> </span><span>BETWEEN</span><span> </span><span>100</span><span> </span><span>PRECEDING</span><span> </span><span>AND</span><span> </span><span>CURRENT</span><span> </span><span>ROW</span><span></span>
<span>    </span><span>)</span><span> </span><span>AS</span><span> </span><span>rolling</span><span></span>
<span>FROM</span><span></span>
<span>    </span><span>read_parquet</span><span>(</span><span>&#39;https://csvbase.com/table-munger/eurofxref-hist.parquet&#39;</span><span>)</span><span></span>
<span>WHERE</span><span></span>
<span>    </span><span>currency</span><span> </span><span>=</span><span> </span><span>&#39;USD&#39;</span><span>;</span><span></span>
</pre></div>
<p>And that&#39;s not the end of DuckDB making the simple stuff easy.  I did the above
query at the library on a slow internet connection and DuckDB helpfully started
to display a progress bar, which even Postgres doesn&#39;t have.</p>
<p>Then, when the query was done it politely avoided swamping my terminal with the
6500 lines of output by abbreviating them, just like Pandas does.</p>
<h2>Datasets larger than memory</h2>
<p>One of the problems that arises with more than a few data tools is that once
the dataset gets bigger than the computer memory (or gets within 50%) the tool
breaks down.</p>
<p>This is an underrated source of pain.  Sometimes I&#39;ve seen someone write
something quickly with one tool as a quick prototype.  The prototype works
great and you want to run it on the full dataset - but wait - you can&#39;t.
You&#39;re getting memory errors, heavy swapping, etc.  The problem is that the
tool was loading the whole dataset into memory and so suddenly you have to
change technology.  Always an unpleasant discovery.</p>
<p>DuckDB fully supports datasets larger than memory.  That&#39;s in contrast to
Pandas, which starts to struggle once your dataframe is &gt;50% of system memory.
The majority of dataframe libraries do not support datasets larger than memory
or require <a href="https://docs.pola.rs/user-guide/concepts/streaming/">alternate, more limited, modes of
operation</a> when using
them - but in DuckDB everything works.</p>
<h2>Single file, single machine model - and the magic of WASM</h2>
<p>DuckDB (which, like <a href="https://github.com/calpaterson/csvbase">csvbase</a>, is <a href="https://github.com/duckdb/duckdb/">an
open source project</a>) gets compiled to a
single executable file, <code>duckdb</code>.  That means trying it out just means copying
<code>duckdb</code> onto your computer and running it.  Find the right executable for your
machine <a href="https://duckdb.org/docs/installation/">here</a>.</p>
<p>But it actually gets even easier than that.  Through the magic of
<a href="https://en.wikipedia.org/wiki/WebAssembly">WASM</a> you can experience the full
majesty of DuckDB directly in your browser on
<a href="https://shell.duckdb.org/">shell.duckdb.org</a>!</p>
<p><img src="https://csvbase.com/blog-static/shelldotduckdbdotorg.png" alt="screenshot of shell.duckdb.org in a web browser"/></p>
<p><code>shell.duckdb.org</code> is an based on the <a href="https://en.wikipedia.org/wiki/WebAssembly">WASM (aka
WebAssembly)</a> target of the <code>duckdb</code>
build.  WASM is a newish binary format that allows you to run native code
(think: <code>.exe</code> files) inside a web browser.  It&#39;s <a href="https://www.usenix.org/conference/atc19/presentation/jangda">not quite as fast as real
native code</a>, but
it&#39;s usually close enough and has the key advantage that you can execute random
binaries in a sandboxed virtual machine - mostly without rewriting them.</p>
<p>As a result <code>shell.duckdb.org</code> is fully powered - it can be because everything
is running in your browser, not on a server.  You can use <code>shell.duckdb.org</code> to
import files off the web, you have the full SQL dialect, you can execute
long-running queries, whatever you want.  And you can even share sessions as
links.  Try this one:</p>
<p><a href="https://shell.duckdb.org/#queries=v0,select-*-from-read_parquet(%22https%3A%2F%2Fcsvbase.com%2Fmeripaterson%2Fstock%20exchanges.parquet%22)~">https://shell.duckdb.org/#queries=v0,select-*-from-read_parquet(%22https%3A%2F%2Fcsvbase.com%2Fmeripaterson%2Fstock%20exchanges.parquet%22)~</a></p>
<h2>DuckDB as a lo-fi dataframe library</h2>
<p>DuckDB also has good quality integration with the lingua franca of data
analysis.  For better or worse that means: Python.</p>
<p>First, install the DuckDB python library (and csvbase&#39;s client, which I will
use later).</p>
<div><pre><span></span>pip install duckdb csvbase-client
</pre></div>
<p>Now you can execute queries inside Python:</p>
<div><pre><span></span><span>import</span> <span>duckdb</span>

<span>duckdb</span><span>.</span><span>sql</span><span>(</span><span>&#34;select 1&#34;</span><span>)</span>
</pre></div>
<p>Easy enough.  But there is one more trick: you can query return values.</p>
<p>That means you you can start to do imperative-style programming to build up a
bigger data operation step by step - in an analogous way to how you would write
dataframe code.  A worked example:</p>
<div><pre><span></span><span># get all stock exchanges</span>
<span>stock_exchanges</span> <span>=</span> <span>duckdb</span><span>.</span><span>sql</span><span>(</span><span>&#39;&#39;&#39;</span>
<span>    SELECT</span>
<span>        *</span>
<span>    FROM</span>
<span>        read_parquet(</span>
<span>            &#34;https://csvbase.com/meripaterson/stock-exchanges.parquet&#34;</span>
<span>        )</span>
<span>&#39;&#39;&#39;</span><span>)</span>

<span># exclude non-North American exchanges</span>
<span>na_stock_exchanges</span> <span>=</span> <span>duckdb</span><span>.</span><span>sql</span><span>(</span><span>&#34;&#34;&#34;</span>
<span>    SELECT</span>
<span>        *</span>
<span>    FROM</span>
<span>        stock_exchanges -- a variable reference to the above</span>
<span>    WHERE</span>
<span>        &#34;Continent&#34; = &#39;North America&#39;</span>
<span>&#34;&#34;&#34;</span><span>)</span>

<span># get the MIC codes as a Python set</span>
<span>na_mic_codes</span> <span>=</span> <span>{</span>
    <span>t</span><span>[</span><span>0</span><span>]</span> <span>for</span> <span>t</span> <span>in</span> <span>duckdb</span><span>.</span><span>sql</span><span>(</span><span>&#34;&#34;&#34;</span>
<span>        SELECT</span>
<span>            &#34;MIC&#34;</span>
<span>        FROM</span>
<span>            na_stock_exchanges</span>
<span>    &#34;&#34;&#34;</span><span>)</span><span>.</span><span>fetchall</span><span>()</span> <span>if</span> <span>t</span> <span>is</span> <span>not</span> <span>None</span>
<span>}</span>
</pre></div>
<p>Allowing for dataframe-style programming starts to bridge the benefits of SQL
with the benefits of dataframes.  You get all the benefits of SQL:</p>
<ol>
<li>Lazy evaluation</li>
<li>The query planner (ie: an optimising compiler)</li>
<li>That SQL is already very well known</li>
</ol>
<p>And then you also get the benefits of dataframes</p>
<ol start="4">
<li>
Easy to write larger programs by doing larger operations step-by-step<ul>
<li><em>without</em> resorting to string concat tricks or sprocs</li>
</ul>
</li>
<li>
Can use an imperative language to build up your data operation<ul>
<li>and wrap it</li>
</ul>
</li>
</ol>
<p>That&#39;s not to say that this is a fully developed replacement for Pandas.
Pandas&#39; API still does a lot more than just this.  But being able to build up
larger programs using the dataframe-style of programming certainly makes them
easier to write.</p>
<h2>Saving your game with csvbase (fsspec)</h2>
<p>I <a href="https://csvbase.com/blog/7">wrote before</a> about how csvbase&#39;s client library
is designed to slot in to anything by being written against a standard API
called &#34;fsspec&#34;.  I gave <a href="https://csvbase.com/faq/pandas">Pandas</a>, Polars and Dask as examples but
the same is true for <a href="https://csvbase.com/faq/duckdb">DuckDB</a>:</p>
<div><pre><span></span><span>import</span> <span>duckdb</span><span>,</span> <span>fsspec</span>

<span># you&#39;d put this bit into __init__.py</span>
<span>duckdb</span><span>.</span><span>register_filesystem</span><span>(</span><span>fsspec</span><span>.</span><span>filesystem</span><span>(</span><span>&#39;csvbase&#39;</span><span>))</span>

<span>duckdb</span><span>.</span><span>sql</span><span>(</span><span>&#34;&#34;&#34;</span>
<span>    COPY stock_exchanges TO</span>
<span>    &#39;csvbase://calpaterson/duckdb-example?public=true&#39; (HEADER, DELIMITER &#39;,&#39;)</span>
<span>&#34;&#34;&#34;</span><span>)</span>
</pre></div>
<p>And it&#39;s not just csvbase that implements fsspec but plenty of others like
Google Drive, SFTP, HFDS - there are lots and lots of implementations.  Find a
list of them this way:</p>
<div><pre><span></span><span>from</span> <span>fsspec.registry</span> <span>import</span> <span>known_implementations</span><span>;</span> <span>import</span> <span>pprint</span>

<span>pprint</span><span>.</span><span>pprint</span><span>(</span><span>known_implementations</span><span>)</span>
</pre></div>
<p>The majority of Python-based data libraries have support for fsspec so this is
nothing particularly special - but it&#39;s just nice to know that DuckDB can
easily plug into anything that already has an fsspec implementation.</p>
<h2>Scale - &#34;lower is better&#34;</h2>
<p>After speed, the next much-discussed quantitative dimension is &#34;scalability&#34;.
Scale is probably an even more vexed topic than speed because while more speed
is not always better it at least does no harm.  Greater scale though, usually
comes with greater complexity.</p>
<p>DuckDB does not scale to thousands of machines.  Apache Spark does though, and
is now the established &#34;big tech company&#34; way to do larger data analyses.  But
the hassle involved in Spark is actually considerable.  Even the cloud services
that take a huge bite out of your team&#39;s monthly budget don&#39;t really make all
of the hassle go away.</p>
<p>In my view, scale is not just a one-way road.  Scaling <em>down</em> is just as
important - perhaps more - than scaling <em>up</em>.  Down, down, down - to a single
person trying to get stuff done, not an uncommon scale in the field of data
analysis.</p>
<p>DuckDB operates on this scale and it requires very little of you.  If you&#39;re
doing data analysis you probably already know SQL.  DuckDB supports
larger-than-memory data. And there isn&#39;t a lot to install.  That makes it a
highly desirable alternative to full blown Spark code for many many cases.</p>
<h2>See also</h2>
<p>csvbase now supports <a href="https://csvbase.com/faq/git">tables backed by git
repos</a>.  It&#39;s a nice way to get both easy reads
and writes as well as change history of git.  You can also use it to publish csv
files from repos onto the web (including private repos).</p>
<p>As I mentioned, <code>csvbase-client</code> <a href="https://csvbase.com/faq/duckdb">works with
DuckDB</a> via <a href="https://csvbase.com/blog/7">the magic of
fsspec</a>.  That includes the
<a href="https://csvbase.com/faq/csvbase-client-cache">cache</a> - so repeated references to a table don&#39;t
pointlessly re-download it each time.</p>
<p>I&#39;m pretty interested in WASM.  Perhaps it would be possible to allow people to
upload their data cleanup/transformation scripts as wasm binaries and run them
on csvbase each time an upstream dataset changed?  <a href="mailto:cal@calpaterson.com">Write to
me</a> if you&#39;re interested in this.</p>
<p>DuckDB seems to have come out of the Netherland&#39;s national computer science and
maths institute,
<a href="https://en.wikipedia.org/wiki/Centrum_Wiskunde_%26_Informatica">CWI</a>.  Many
other columar databases have links with CWI, including
<a href="https://en.wikipedia.org/wiki/MonetDB">MonetDB</a> as well as
<a href="https://www.cwi.nl/en/news/cwi-born-technology-behind-record-ipo-company-snowflake/">Snowflake</a>.
Clearly there is something in the water at CWI.</p>
<p>DuckDB is obviously influenced by SQLite.  What&#39;s the difference?  SQLite uses a
<a href="https://calpaterson.com/how-a-sql-database-works.html">more traditional &#34;row store&#34; storage
system</a> which is ideal
for transaction-heavy workloads but less amenable to data analysis workloads
then the columnar form of DuckDB.</p>

      </div>
    </div></div>
  </body>
</html>
