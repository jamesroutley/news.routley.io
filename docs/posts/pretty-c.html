<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/aartaka/pretty.c">Original</a>
    <h1>Pretty.c</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Pretty C is a new scripting language compatible with C. Pretty C
  boosts your programs with dynamic typing, generic iteration, resource
  tracking and other niceties. And it’s backwards-compatible with C and
  all of its libraries! Inspired by Lua, Python, JavaScript, and
  Lisp. Here’s how a naive re-implementation of <code>head</code> utility might
  look like with Pretty C:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &#34;pretty.h&#34;

int main (int argc, string argv[])
{
    if (argc above 1)
        with (f, fclose, fopen(argv[1], &#34;r&#34;))
            fortimes (line, 10)
                with (buf, free, vector(200, char, 0))
                    when (fgets(buf, 200, f))
                        then print(buf)
                        otherwise 0;
    else
        println(&#34;Please provide an input file&#34;);
    return EXIT_SUCCESS;
}"><pre><span>#include</span> <span>&#34;pretty.h&#34;</span>

<span>int</span> <span>main</span> (<span>int</span> <span>argc</span>, <span>string</span> <span>argv</span>[])
{
    <span>if</span> (<span>argc</span> <span>above</span> <span>1</span>)
        <span>with</span> (<span>f</span>, <span>fclose</span>, <span>fopen</span>(<span>argv</span>[<span>1</span>], <span>&#34;r&#34;</span>))
            <span>fortimes</span> (<span>line</span>, <span>10</span>)
                <span>with</span> (<span>buf</span>, <span>free</span>, <span>vector</span>(<span>200</span>, <span>char</span>, <span>0</span>))
                    <span>when</span> (<span>fgets</span>(<span>buf</span>, <span>200</span>, <span>f</span>))
                        <span>then</span> <span>print</span>(<span>buf</span>)
                        <span>otherwise</span> <span>0</span>;
    <span>else</span>
        <span>println</span>(<span>&#34;Please provide an input file&#34;</span>);
    <span>return</span> <span>EXIT_SUCCESS</span>;
}</pre></div>
<p dir="auto">The goals for Pretty C are:</p>
<ul dir="auto">
  <li>Provide so much syntactic sugar as to cause any C developer a
    diabetes-induced heart attack.</li>
  <li>Deprecate Lua, Python, JavaScript, Ruby and a dozen other languages,
    because Pretty C is the ultimate scripting language, but
    lightning-fast and strongly typed!</li>
  <li>Including only one header (yes, Pretty C is a header-only library
    <code>#include</code>-able from arbitrary C file!)  to turn any codebase into a
    beginner friendly one.</li>
</ul>

<p dir="auto">Checkout the repository</p>
<div dir="auto" data-snippet-clipboard-copy-content="git clone https://github.com/aartaka/pretty.c"><pre>git clone https://github.com/aartaka/pretty.c</pre></div>
<p dir="auto">Or simply copy the <code>pretty.h</code> file—Pretty C is a header-only
  library, so you can</p>

<p dir="auto">from any file in the directory you drop <code>pretty.h</code> to. Or from any
  file really, if you specify the path to Pretty C as an include (<code>-I</code>)
  path.</p>

<p dir="auto">Here are all the pretty changes making C hip again.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Included Standard Headers</h2><a id="user-content-included-standard-headers" aria-label="Permalink: Included Standard Headers" href="#included-standard-headers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
  <li><a href="https://en.cppreference.com/w/c/types/boolean" rel="nofollow">stdbool.h</a> for pretty booleans: <code>true</code>, <code>false</code>, and <code>bool</code>.</li>
  <li><a href="https://en.cppreference.com/w/c/types/integer" rel="nofollow">stdint.h</a> for fixed-width integer types like <code>uint64_t</code>.</li>
  <li><a href="https://en.cppreference.com/w/c/language/operator_alternative#Operator_macros.28C95.29" rel="nofollow">iso646.h</a> for readable alternatives to regular operators,
    including <code>and</code> for <code>&amp;&amp;</code> and <code>or</code> for <code>||</code>. Neat!</li>
</ul>

<p dir="auto">Everyone defines these, so why not provide them?</p>
<ul dir="auto">
  <li><code>max</code> and <code>min</code> of two numbers.</li>
  <li><code>len</code> for array length.</li>
  <li><code>default</code> for providing a fallback value.</li>
  <li><code>limit</code> to ensure proper value range.</li>
  <li><code>between</code> to check whether the number falls in a range.</li>
  <li><code>divisible</code> to check whether a number is modulo divisible by another number.</li>
</ul>

<p dir="auto">Type aliases:</p>
<ul dir="auto">
  <li><code>string</code> == <code>char*</code>.</li>
  <li><code>byte</code> == <code>char</code>.</li>
  <li><code>bytes</code> == <code>char*</code>.</li>
  <li><code>any</code> == <code>void*</code>.</li>
  <li>Integer shortcuts:
    <ul dir="auto">
      <li><code>uchar</code>.</li>
      <li><code>ushort</code>.</li>
      <li><code>uint</code>.</li>
      <li><code>ulong</code>.</li>
    </ul>
  </li>
</ul>

<p dir="auto">Mainly modeled after Lua and Lisp:</p>
<ul dir="auto">
  <li><code>eq</code>, because <code>iso646.h</code> only has <code>not_eq</code>.
    <ul dir="auto">
      <li><code>is</code> means <code>==</code> too.</li>
    </ul>
  </li>
  <li><code>bitnot</code> and <code>bitxor</code> for operations that used to be called
    inconsistently (<code>compl</code> and <code>xor</code> respectively) in <code>iso646.h</code>.</li>
  <li><code>below</code>, <code>above</code>, <code>upto</code>, and <code>downto</code> comparison operators.</li>
  <li><code>even</code>, <code>odd</code>, <code>positive</code>, <code>negative</code>, <code>zero</code>, and <code>empty</code> as predicates for numbers/data.</li>
  <li><code>nil</code> for <code>NULL</code>.</li>
  <li><code>until</code> for negated <code>while</code>.</li>
  <li><code>elif</code> for <code>else if</code>.</li>
  <li><code>ifnt</code> for <code>if(!...)</code>.</li>
  <li><code>repeat</code> from Lua as an alias for <code>do</code>.</li>
  <li><code>done~/~finish</code> and <code>pass</code> as aliases for <code>break</code> and <code>continue</code>, respectively.</li>
  <li><code>always</code>, <code>forever</code>, <code>loop</code>, and <code>indefinitely</code> so that you can make infinite (event? server?) loops</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="always println(&#34;After all this time?&#34;);"><pre><span>always</span> <span>println</span>(<span>&#34;After all this time?&#34;</span>);</pre></div>
<ul dir="auto">
  <li>and <code>never</code> and <code>comment</code> to comment out some code with just one
    keyword, while still allowing the compiler to analyze/optimize it
    (similar to <a href="https://clojuredocs.org/clojure.core/comment" rel="nofollow">Clojure <code>comment</code> form</a>):</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="never println(&#34;This never runs, but never gets outdated, because compiler will shout at you if it does.&#34;);"><pre><span>never</span> <span>println</span>(<span>&#34;This never runs, but never gets outdated, because compiler will shout at you if it does.&#34;</span>);</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Type inference (GCC, Clang, or C23+)</h2><a id="user-content-type-inference-gcc-clang-or-c23" aria-label="Permalink: Type inference (GCC, Clang, or C23+)" href="#type-inference-gcc-clang-or-c23"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Yes, you can do</p>
<div dir="auto" data-snippet-clipboard-copy-content="var t = time(0);
let lt = localtime(&amp;t);
local at = asctime(lt);
println(at);"><pre><span>var</span> <span>t</span> <span>=</span> <span>time</span>(<span>0</span>);
<span>let</span> <span>lt</span> <span>=</span> <span>localtime</span>(<span>&amp;</span><span>t</span>);
<span>local</span> <span>at</span> <span>=</span> <span>asctime</span>(<span>lt</span>);
<span>println</span>(<span>at</span>);</pre></div>
<p dir="auto">With Pretty C.</p>

<p dir="auto"><code>print</code> prints whatever you feed it. <code>println</code> adds a newline after it.</p>
<div dir="auto" data-snippet-clipboard-copy-content="println(3.1);
print(&#34;Hello world!\n&#34;);"><pre><span>println</span>(<span>3.1</span>);
<span>print</span>(<span>&#34;Hello world!\n&#34;</span>);</pre></div>

<p dir="auto">Compare all the things!</p>
<div dir="auto" data-snippet-clipboard-copy-content="equal(&#34;NA&#34;, line); // true
equal(0.3, 0.2 + 0.1); // true"><pre><span>equal</span>(<span>&#34;NA&#34;</span>, <span>line</span>); <span>// true</span>
<span>equal</span>(<span>0.3</span>, <span>0.2</span> <span>+</span> <span>0.1</span>); <span>// true</span></pre></div>

<p dir="auto">Ternaries are frightening, so it won’t hurt to add some plain
  text. <code>if</code> and <code>else</code> are taken, but there are proper linguistic
  alternatives that look quite Python/Lisp-like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="return when some_condition
       then do_something()
       other do_something_else();"><pre><span>return</span> <span>when</span> <span>some_condition</span>
       <span>then</span> <span>do_something</span>()
       <span>other</span> <span>do_something_else</span>();</pre></div>
<p dir="auto">It’s ternaries underneath:</p>
<ul dir="auto">
  <li><code>when</code> expands to empty string and is only provided for readability.
    <ul dir="auto">
      <li><code>unless</code> expands to <code>not</code> to be a negative version of <code>when</code>.</li>
    </ul>
  </li>
  <li><code>then</code> expands to <code>?</code>.</li>
  <li><code>other</code> / <code>otherwise</code> expands to <code>:</code>.</li>
</ul>
<p dir="auto">There’s also <code>only</code> for when the <code>otherwise</code> clause is
  unnecessary:</p>
<div dir="auto" data-snippet-clipboard-copy-content="return when done()
       then 42 only;"><pre><span>return</span> <span>when</span> <span>done</span>()
       <span>then</span> <span>42</span> <span>only</span>;</pre></div>
<p dir="auto">and <code>otherwhen</code> for the next condition</p>
<div dir="auto" data-snippet-clipboard-copy-content="return when c is &#39;A&#39;
       then &#39;a&#39;
       otherwhen c is &#39;B&#39;
       then &#39;b&#39; only;"><pre><span>return</span> <span>when</span> <span>c</span> <span>is</span> <span>&#39;A&#39;</span>
       <span>then</span> <span>&#39;a&#39;</span>
       <span>otherwhen</span> <span>c</span> <span>is</span> <span>&#39;B&#39;</span>
       <span>then</span> <span>&#39;b&#39;</span> <span>only</span>;</pre></div>

<p dir="auto">These macros are aliases for certain <code>for</code> loop pattern, each
  abstracting away some of the frequent <code>for</code> loop uses.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto"><code>foreach (var, type, length, ...)</code></h3><a id="user-content-foreach-var-type-length-" aria-label="Permalink: foreach (var, type, length, ...)" href="#foreach-var-type-length-"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This one walks an array or memory region initialized to the vararg
  expression. Every time it iterates, <code>var</code> is set to a pointer to the
  respective array element. Yes, pointer—so that you can modify the
  element in place if you have to.</p>
<div dir="auto" data-snippet-clipboard-copy-content="foreach (i, int, 10, vector(10, int, 1, 2, 3, 3, 4, 5))
        println(*i);"><pre><span>foreach</span> (<span>i</span>, <span>int</span>, <span>10</span>, <span>vector</span>(<span>10</span>, <span>int</span>, <span>1</span>, <span>2</span>, <span>3</span>, <span>3</span>, <span>4</span>, <span>5</span>))
        <span>println</span>(<span>*</span><span>i</span>);</pre></div>
<p dir="auto">Also shows the use of <code>vector</code>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto"><code>forthese (var, type, ...)</code></h3><a id="user-content-forthese-var-type-" aria-label="Permalink: forthese (var, type, ...)" href="#forthese-var-type-"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Iterates over the provided varargs, binding each of these to <code>type</code>-d
  <code>var</code>. The loop above can be translated as:</p>
<div dir="auto" data-snippet-clipboard-copy-content="forthese (i, int, 1, 2, 3, 3, 4, 5)
        println(i);"><pre><span>forthese</span> (<span>i</span>, <span>int</span>, <span>1</span>, <span>2</span>, <span>3</span>, <span>3</span>, <span>4</span>, <span>5</span>)
        <span>println</span>(<span>i</span>);</pre></div>

<p dir="auto">A frequent case of going from 0 to some positive number. Saves you
  quite some time for your</p>
<div dir="auto" data-snippet-clipboard-copy-content="for (int i = 0; i &lt; 28; i++)
        println(i+1);"><pre><span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>28</span>; <span>i</span><span>++</span>)
        <span>println</span>(<span>i</span><span>+</span><span>1</span>);</pre></div>
<p dir="auto">turning it into a simple</p>
<div dir="auto" data-snippet-clipboard-copy-content="fortimes (i, 28)
        println(i+1);
println(&#34;28 stab wounds, you didn&#39;t want to leave him a chance, huh?&#34;);"><pre><span>fortimes</span> (<span>i</span>, <span>28</span>)
        <span>println</span>(<span>i</span><span>+</span><span>1</span>);
<span>println</span>(<span>&#34;28 stab wounds, you didn&#39;t want to leave him a chance, huh?&#34;</span>);</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto"><code>forrange (var, init, target)</code></h3><a id="user-content-forrange-var-init-target" aria-label="Permalink: forrange (var, init, target)" href="#forrange-var-init-target"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Iterate over a range of numbers from <code>init</code> to
  <code>target</code>. Pythonesque. Here’s Celsius to Fahrenheit conversion loop
  with <code>forrange</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="forrange (c, -10, 20)
        printf(&#34;Celsius %i = Fahrenheit %f\n&#34;, c, (32 + (c * 1.8)));"><pre><span>forrange</span> (<span>c</span>, <span>-10</span>, <span>20</span>)
        <span>printf</span>(<span>&#34;Celsius %i = Fahrenheit %f\n&#34;</span>, <span>c</span>, (<span>32</span> <span>+</span> (<span>c</span> <span>*</span> <span>1.8</span>)));</pre></div>
<p dir="auto">Note that <code>init</code> and <code>target</code> are arbitrary integers, signed and
  unsigned. And <code>init</code> might be greater than <code>target</code> in which case the
  iteration step decreases the variable.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto"><code>forrangeby (var, type, init, target, by)</code></h3><a id="user-content-forrangeby-var-type-init-target-by" aria-label="Permalink: forrangeby (var, type, init, target, by)" href="#forrangeby-var-type-init-target-by"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Iterate <code>type</code>-d <code>var</code> from <code>iter</code> to <code>target</code>, stepping by <code>by</code> every
  time. Pythonesque.</p>
<div dir="auto" data-snippet-clipboard-copy-content="forrangeby (x, double, 1.0, 10.0, 0.5)
        println(x);"><pre><span>forrangeby</span> (<span>x</span>, <span>double</span>, <span>1.0</span>, <span>10.0</span>, <span>0.5</span>)
        <span>println</span>(<span>x</span>);</pre></div>

<p dir="auto">These allow quick-and-dirty allocation for typical patterns. Mostly
  modeled after C++.</p>

<p dir="auto">C++ <code>new</code> operator is nice, so it won’t hurt having something similar
  in C, right? Ask no more:</p>
<div dir="auto" data-snippet-clipboard-copy-content="struct ListNode {
        int val;
        struct ListNode *next;
};

struct ListNode *node = new(struct ListNode, 2, new(struct ListNode, 1, nil));"><pre><span>struct</span> <span>ListNode</span> {
        <span>int</span> <span>val</span>;
        <span>struct</span> <span>ListNode</span> <span>*</span><span>next</span>;
};

<span>struct</span> <span>ListNode</span> <span>*</span><span>node</span> <span>=</span> <span>new</span>(<span>struct</span> <span>ListNode</span>, <span>2</span>, <span>new</span>(<span>struct</span> <span>ListNode</span>, <span>1</span>, <span>nil</span>));</pre></div>
<p dir="auto">Or, if you fancy, you can add even more syntax on top:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define cons(val, ...) new(struct ListNode, val, __VA_ARGS__)
cons(2, cons(1, nil));"><pre><span>#define</span> <span>cons</span>(<span>val</span>, ...) new(struct ListNode, val, __VA_ARGS__)
<span>cons</span>(<span>2</span>, <span>cons</span>(<span>1</span>, <span>nil</span>));</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto"><code>vector (length, type, ...)</code></h3><a id="user-content-vector-length-type-" aria-label="Permalink: vector (length, type, ...)" href="#vector-length-type-"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">C++ again. <code>std::vector</code> is an extremely useful and versatile data
  structure that’s easy to reason about. While this macro is not even
  remotely as featureful as C++ counterpart, it simplifies a frequent
  pattern of “allocate an array of that much elements and with these
  contents”:</p>
<div dir="auto" data-snippet-clipboard-copy-content="double *vec = vector(10, double, 1, 2, 3, 4, 5);"><pre><span>double</span> <span>*</span><span>vec</span> <span>=</span> <span>vector</span>(<span>10</span>, <span>double</span>, <span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>);</pre></div>

<p dir="auto">In case you don’t like <code>free</code>-ing the resources and prefer a fancier C++ name.</p>
<p dir="auto">Otherwise the same as <code>free</code>.</p>

<p dir="auto">These establish new local bindings, ensure deferred computations, or
  otherwise act on the block after them.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto"><code>lambda (ret, name, ...)</code> (GCC, Clang, or C++)</h3><a id="user-content-lambda-ret-name--gcc-clang-or-c" aria-label="Permalink: lambda (ret, name, ...) (GCC, Clang, or C++)" href="#lambda-ret-name--gcc-clang-or-c"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Nested functions/lambdas/closures, now in C!</p>
<div dir="auto" data-snippet-clipboard-copy-content="int *arr = vector(10, int, 23423, 23423, 234, 5233, 6, 4, 34, 643, 3, 9);
lambda (int, cmp, int *a, int *b) {
        return *a - *b;
};
qsort(arr, 10, sizeof(int), cmp);
// arr becomes {3, 4, 6, 9, 34, 234, 643, 5233, 23423, 23423}"><pre><span>int</span> <span>*</span><span>arr</span> <span>=</span> <span>vector</span>(<span>10</span>, <span>int</span>, <span>23423</span>, <span>23423</span>, <span>234</span>, <span>5233</span>, <span>6</span>, <span>4</span>, <span>34</span>, <span>643</span>, <span>3</span>, <span>9</span>);
<span>lambda</span> (<span>int</span>, <span>cmp</span>, <span>int</span> <span>*</span><span>a</span>, <span>int</span> <span>*</span><span>b</span>) {
        <span>return</span> <span>*</span><span>a</span> <span>-</span> <span>*</span><span>b</span>;
};
<span>qsort</span>(<span>arr</span>, <span>10</span>, <span>sizeof</span>(<span>int</span>), <span>cmp</span>);
<span>// arr becomes {3, 4, 6, 9, 34, 234, 643, 5233, 23423, 23423}</span></pre></div>

<p dir="auto">This ensures that you never have use-after-free, because you provide
  the freeing procedure (<code>close</code>) upfront. Especially useful for
  dynamically allocated objects and file designators.</p>
<div dir="auto" data-snippet-clipboard-copy-content="with (file, fclose, fopen(&#34;hello.txt&#34;, &#34;w&#34;))
        fprintf(file, &#34;Hello world!\n&#34;);"><pre><span>with</span> (<span>file</span>, <span>fclose</span>, <span>fopen</span>(<span>&#34;hello.txt&#34;</span>, <span>&#34;w&#34;</span>))
        <span>fprintf</span>(<span>file</span>, <span>&#34;Hello world!\n&#34;</span>);</pre></div>
<p dir="auto">One of the downsides is that the bound <code>var</code> is a <code>void *</code>, so you
  might need to coerce it to your type before using it.</p>

<p dir="auto">Offloads the code to be executed after the following block. Not at the
  end of function as in Go, because that’s <del>impossible</del> hard to
  implement in C. Still, Pretty C <code>defer</code> is useful enough.</p>

<p dir="auto">Fancy error handling, now in C. Refactored example from <a href="https://en.cppreference.com/w/c/error/errno" rel="nofollow">errno reference</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="try log(0.0);
catch (NOERR)
        println(&#34;No error.&#34;);
catch (EDOM, ERANGE)
        println(&#34;Math error!&#34;);"><pre><span>try</span> <span>log</span>(<span>0.0</span>);
<span>catch</span> (<span>NOERR</span>)
        <span>println</span>(<span>&#34;No error.&#34;</span>);
<span>catch</span> (<span>EDOM</span>, <span>ERANGE</span>)
        <span>println</span>(<span>&#34;Math error!&#34;</span>);</pre></div>
<p dir="auto"><code>NOERR</code> and <code>NOERROR</code> are also provided by Pretty C, for convenience
  of error switch-casing.</p>
</article></div></div>
  </body>
</html>
