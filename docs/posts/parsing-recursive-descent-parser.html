<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.huy.rocks/everyday/05-08-2022-parsing-recursive-descent-parser">Original</a>
    <h1>Parsing / Recursive Descent Parser</h1>
    
    <div id="readability-page-1" class="page"><div><div><p><span>«</span> <a href="https://thewitchofendor.com/everyday">All posts</a></p>
<p>A parser is a program that usually takes a stream of lexical tokens and transforms them into another data structure, usually in the form of a parse tree that satisfies the language’s grammar rules.</p>
<h2><a name="what-is-a-recursive-descent-parser-" href="#what-is-a-recursive-descent-parser-">What is a Recursive Descent Parser?</a></h2><p><strong>Recursive Descent Parser</strong> is a top-down parser <em>where every non-terminal in the BNF grammar is a subroutine</em>. The parser works by <em>recursively calling each subroutine to construct the parsed output</em>. It’s not the only algorithm to implement a parser, but it’s one of the most simple ones that are very easy to understand and implement.</p>
<p>For example, let’s say we have a grammar to parse money amount in <code>USD</code>, <code>GBP</code>, and <code>EUR</code>. The money amount should be written in the form of <code>&lt;currency_symbol&gt; &lt;amount&gt;</code>, like <code>$100</code>:</p>
<pre><code><span>money           = currency_symbol amount ;</span>
<span>currency_symbol = &#39;$&#39; | &#39;£&#39; | &#39;€&#39; ;</span>
<span>amount          = INTEGER ;</span>
</code></pre>
<p>The grammar has three <em>non-terminals</em>: <code>money</code>, <code>currency_symbol</code>, and <code>amount</code>. When implemented, we should also implement three parsing methods: <code>parse_money()</code>, <code>parse_currency_symbol()</code>, and <code>parse_amount()</code>. Each of the parsing methods will call each other just like how they’re related in the grammar rules:</p>
<pre><code><span><span>type</span> <span>ParseResult</span>&lt;T&gt; = <span>Result</span>&lt;T, ParseError&gt;;</span>
<span> </span>
<span><span>impl</span>&lt;<span>&#39;a</span>&gt; Parser&lt;<span>&#39;a</span>&gt; {</span>
<span>    </span>
<span>    <span>fn</span> <span>parse_amount</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> ParseResult&lt;<span>i32</span>&gt; {</span>
<span>        ...</span>
<span>    }</span>
<span> </span>
<span>    </span>
<span>    <span>fn</span> <span>parse_currency_symbol</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> ParseResult&lt;Currency&gt; {</span>
<span>        ...</span>
<span>    }</span>
<span> </span>
<span>    </span>
<span>    <span>fn</span> <span>parse_money</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> ParseResult&lt;MoneyNode&gt; {</span>
<span>        <span>let</span> <span>currency</span> = <span>self</span>.<span>parse_currency_symbol</span>()?;</span>
<span>        <span>let</span> <span>amount</span> = <span>self</span>.<span>parse_amount</span>()?;</span>
<span>        <span>return</span> <span>Ok</span>(MoneyNode { currency, amount });</span>
<span>    }</span>
<span>}</span>
</code></pre>
<h2><a name="implementing-a-money-parser" href="#implementing-a-money-parser">Implementing a Money Parser</a></h2><p>Let’s dig deeper into the above example. We will focus on the parser. Let’s assume that we already have a lexer that converts an input string like <code>&#34;$100&#34;</code> into a list of tokens.</p>
<h3><a name="data-structures" href="#data-structures">Data Structures</a></h3><p>In this program, we have two types of tokens: the <code>CurrencySymbol</code> token and the <code>Number</code> token:</p>
<pre><code><span><span>#[derive(Debug, PartialEq, Clone, Copy)]</span></span>
<span><span>enum</span> <span>TokenType</span> {</span>
<span>    CurrencySymbol,</span>
<span>    Number</span>
<span>}</span>
<span> </span>
<span><span>#[derive(Debug)]</span></span>
<span><span>struct</span> <span>Token</span>&lt;<span>&#39;a</span>&gt; {</span>
<span>    token_type: TokenType,</span>
<span>    content: &amp;<span>&#39;a</span> <span>str</span></span>
<span>}</span>
<span> </span>
<span><span>impl</span>&lt;<span>&#39;a</span>&gt; Token&lt;<span>&#39;a</span>&gt; {</span>
<span>    <span>pub</span> <span>fn</span> <span>new</span>(token_type: TokenType, content: &amp;<span>&#39;a</span> <span>str</span>) <span>-&gt;</span> <span>Self</span> {</span>
<span>        <span>Self</span> {</span>
<span>            token_type,</span>
<span>            content</span>
<span>        }</span>
<span>    }</span>
<span>}</span>
</code></pre>
<p>The <strong>input</strong> for our parser is a <code>Vec&lt;Token&gt;</code> that looks like this:</p>
<pre><code><span></span>
<span><span>let</span> <span>tokens</span> = <span>vec!</span>[</span>
<span>    Token::<span>new</span>(TokenType::CurrencySymbol, <span>&#34;£&#34;</span>),</span>
<span>    Token::<span>new</span>(TokenType::Number, <span>&#34;128&#34;</span>)</span>
<span>];</span>
</code></pre>
<p>The <strong>output</strong> of our parser is a data structure called <code>MoneyNode</code>:</p>
<pre><code><span><span>#[derive(Debug, PartialEq)]</span></span>
<span><span>enum</span> <span>Currency</span> {</span>
<span>    USD,</span>
<span>    GBP,</span>
<span>    EUR</span>
<span>}</span>
<span> </span>
<span><span>#[derive(Debug, PartialEq)]</span></span>
<span><span>struct</span> <span>MoneyNode</span> {</span>
<span>    currency: Currency,</span>
<span>    amount: <span>i32</span></span>
<span>}</span>
</code></pre>
<h3><a name="error-handling" href="#error-handling">Error Handling</a></h3><p>For this grammar, there are two types of errors that could happen during parsing:</p>
<ol>
<li><strong>Unexpected token error</strong>: when the parser found a token that was misplaced.</li>
<li><strong>Invalid amount error</strong>: when the parser could not parse the amount number.</li>
</ol>
<p>We will create a custom error type and a <code>Result&lt;T&gt;</code> type to handle these two errors:</p>
<pre><code><span><span>#[derive(Debug, PartialEq)]</span></span>
<span><span>enum</span> <span>ParseError</span> {</span>
<span>    <span>UnexpectedToken</span>(TokenType, TokenType),</span>
<span>    InvalidAmount</span>
<span>}</span>
<span> </span>
<span><span>impl</span> <span>Display</span> <span>for</span> <span>ParseError</span> {</span>
<span>    <span>fn</span> <span>fmt</span>(&amp;<span>self</span>, f: &amp;<span>mut</span> std::fmt::Formatter&lt;<span>&#39;_</span>&gt;) <span>-&gt;</span> std::fmt::<span>Result</span> {</span>
<span>        <span>match</span> <span>self</span> {</span>
<span>            <span>Self</span>::<span>UnexpectedToken</span>(expected, found) =&gt;</span>
<span>                <span>write!</span>(f, <span>&#34;Unexpected Token: Expected {:?}. Found {:?}.&#34;</span>, expected, found),</span>
<span>            <span>Self</span>::InvalidAmount =&gt;</span>
<span>                <span>write!</span>(f, <span>&#34;Invalid Amount!&#34;</span>),</span>
<span>        }</span>
<span>    }</span>
<span>}</span>
<span> </span>
<span><span>type</span> <span>ParseResult</span>&lt;T&gt; = <span>Result</span>&lt;T, ParseError&gt;;</span>
</code></pre>
<h3><a name="the-parser-and-some-utility-methods" href="#the-parser-and-some-utility-methods">The Parser and some utility methods</a></h3><p>Now, let’s create the parser. It takes a list of input tokens and uses a <code>pos</code> variable to keep track of the current token.</p>
<pre><code><span><span>struct</span> <span>Parser</span>&lt;<span>&#39;a</span>&gt; {</span>
<span>    tokens: <span>Vec</span>&lt;Token&lt;<span>&#39;a</span>&gt;&gt;,</span>
<span>    pos: <span>usize</span></span>
<span>}</span>
</code></pre>
<p>We will implement some utility methods to control the input token stream, like:</p>
<ol>
<li><strong>is_eof()</strong>: to check if we’re at the end of the token stream or not</li>
<li><strong>peek()</strong>: to get the current token</li>
<li><strong>is_match()</strong>: to check if the current token matched the expected type or not</li>
<li><strong>advance()</strong>: to consume the current token and move on to the next</li>
</ol>
<p>These methods are not exclusive to a recursive descent parser, but they’re very helpful, as they keep the actual parsing code looks clean:</p>
<pre><code><span><span>impl</span>&lt;<span>&#39;a</span>&gt; Parser&lt;<span>&#39;a</span>&gt; {</span>
<span>    <span>pub</span> <span>fn</span> <span>new</span>(tokens: <span>Vec</span>&lt;Token&lt;<span>&#39;a</span>&gt;&gt;) <span>-&gt;</span> <span>Self</span> {</span>
<span>        <span>Self</span> {</span>
<span>            tokens,</span>
<span>            pos: <span>0</span></span>
<span>        }</span>
<span>    }</span>
<span> </span>
<span>    <span>fn</span> <span>is_eof</span>(&amp;<span>self</span>) <span>-&gt;</span> <span>bool</span> {</span>
<span>        <span>self</span>.pos &gt;= <span>self</span>.tokens.<span>len</span>()</span>
<span>    }</span>
<span> </span>
<span>    <span>fn</span> <span>peek</span>(&amp;<span>self</span>) <span>-&gt;</span> &amp;Token {</span>
<span>        &amp;<span>self</span>.tokens[<span>self</span>.pos]</span>
<span>    }</span>
<span> </span>
<span>    <span>fn</span> <span>is_match</span>(&amp;<span>self</span>, token_type: TokenType) <span>-&gt;</span> <span>bool</span> {</span>
<span>        !<span>self</span>.<span>is_eof</span>() &amp;&amp; <span>self</span>.<span>peek</span>().token_type == token_type</span>
<span>    }</span>
<span> </span>
<span>    <span>fn</span> <span>advance</span>(&amp;<span>mut</span> <span>self</span>) {</span>
<span>        <span>self</span>.pos += <span>1</span>;</span>
<span>    }</span>
<span>}</span>
</code></pre>
<h3><a name="the-recursive-descent-parser" href="#the-recursive-descent-parser">The Recursive Descent Parser</a></h3><p>Now, the main part of the parser that we are waiting for. First, let’s write a parser for the <code>amount</code> rule of the grammar:</p>
<pre><code><span></span>
<span></span>
<span><span>fn</span> <span>parse_amount</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> ParseResult&lt;<span>i32</span>&gt; {</span>
<span>    <span>let</span> <span>token</span> = <span>self</span>.<span>peek</span>();</span>
<span>    <span>if</span> <span>self</span>.<span>is_match</span>(TokenType::Number) {</span>
<span>        <span>let</span> <span>result</span> = token.content.parse::&lt;<span>i32</span>&gt;()</span>
<span>                          .<span>map_err</span>(|_| ParseError::InvalidAmount);</span>
<span>        <span>self</span>.<span>advance</span>();</span>
<span>        <span>return</span> result;</span>
<span>    }</span>
<span>    <span>Err</span>(ParseError::<span>UnexpectedToken</span>(</span>
<span>            TokenType::Number,</span>
<span>            token.token_type</span>
<span>        )</span>
<span>    )</span>
<span>}</span>
</code></pre>
<p>We simply check if the current token is a <code>Number</code> token or not and parse the content of this token into an <code>i32</code> number. In this method, we can see the usage of both the <code>InvalidAmount</code> and the <code>UnexpectedToken</code> errors.</p>
<p>Next, we will write the parser for the <code>currency_symbol</code> rule:</p>
<pre><code><span></span>
<span></span>
<span><span>fn</span> <span>parse_currency_symbol</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> ParseResult&lt;Currency&gt; {</span>
<span>    <span>let</span> <span>token</span> = <span>self</span>.<span>peek</span>();</span>
<span>    <span>if</span> <span>self</span>.<span>is_match</span>(TokenType::CurrencySymbol) {</span>
<span>        <span>let</span> <span>currency_symbol</span> = <span>match</span> token.content {</span>
<span>            <span>&#34;$&#34;</span> =&gt; Currency::USD,</span>
<span>            <span>&#34;£&#34;</span> =&gt; Currency::GBP,</span>
<span>            _ =&gt; Currency::EUR</span>
<span>        };</span>
<span>        <span>self</span>.<span>advance</span>();</span>
<span>        <span>return</span> <span>Ok</span>(currency_symbol);</span>
<span>    }</span>
<span>    <span>Err</span>(ParseError::<span>UnexpectedToken</span>(</span>
<span>            TokenType::CurrencySymbol,</span>
<span>            token.token_type</span>
<span>        )</span>
<span>    )</span>
<span>}</span>
</code></pre>
<p>Now that we have the parser for both the <code>currency_symbol</code> and <code>amount</code> rules. The last step is to write the parser for the <code>money</code> rule, it is implemented the same way the <code>money</code> rule is written. We will call the <code>currency_symbol</code> parser, then call the <code>amount</code> parser.</p>
<p>None of the above parsers will return any error value for valid input. Their return value can be combined to create the output <code>MoneyNode</code> object:</p>
<pre><code><span></span>
<span></span>
<span><span>fn</span> <span>parse_money</span>(&amp;<span>mut</span> <span>self</span>) <span>-&gt;</span> ParseResult&lt;MoneyNode&gt; {</span>
<span>    <span>let</span> <span>currency</span> = <span>self</span>.<span>parse_currency_symbol</span>()?;</span>
<span>    <span>let</span> <span>amount</span> = <span>self</span>.<span>parse_amount</span>()?;</span>
<span>    <span>return</span> <span>Ok</span>(MoneyNode {</span>
<span>        currency,</span>
<span>        amount</span>
<span>    });</span>
<span>}</span>
</code></pre>
<p>And that’s it! We have already finished our parser!</p>
<h3><a name="test-the-parser" href="#test-the-parser">Test the parser</a></h3><p>Now, let’s write some tests to see if the parser works or not. First, in a happy path, we will pass a valid token list and expect to see a valid output:</p>
<pre><code><span><span>#[test]</span></span>
<span><span>fn</span> <span>test_parse_usd</span>() {</span>
<span>    <span>let</span> <span>tokens</span> = <span>vec!</span>[</span>
<span>        Token::<span>new</span>(TokenType::CurrencySymbol, <span>&#34;$&#34;</span>),</span>
<span>        Token::<span>new</span>(TokenType::Number, <span>&#34;512&#34;</span>)</span>
<span>    ];</span>
<span>    <span>let</span> <span>mut </span><span>parser</span> = Parser::<span>new</span>(tokens);</span>
<span>    <span>assert_eq!</span>(parser.<span>parse_money</span>(), <span>Ok</span>(MoneyNode {</span>
<span>        currency: Currency::USD,</span>
<span>        amount: <span>512</span></span>
<span>    }))</span>
<span>}</span>
</code></pre>
<p>Of course, if the input currency is EUR instead of USD, the parser should return the correct value:</p>
<pre><code><span><span>#[test]</span></span>
<span><span>fn</span> <span>test_parse_eur</span>() {</span>
<span>    <span>let</span> <span>tokens</span> = <span>vec!</span>[</span>
<span>        Token::<span>new</span>(TokenType::CurrencySymbol, <span>&#34;€&#34;</span>),</span>
<span>        Token::<span>new</span>(TokenType::Number, <span>&#34;9372&#34;</span>)</span>
<span>    ];</span>
<span>    <span>let</span> <span>mut </span><span>parser</span> = Parser::<span>new</span>(tokens);</span>
<span>    <span>assert_eq!</span>(parser.<span>parse_money</span>(), <span>Ok</span>(MoneyNode {</span>
<span>        currency: Currency::EUR,</span>
<span>        amount: <span>9372</span></span>
<span>    }))</span>
<span>}</span>
</code></pre>
<p>Don’t forget some unhappy paths, the parser should return an <code>Err</code> value if any of the parsing steps fails:</p>
<pre><code><span><span>#[test]</span></span>
<span><span>fn</span> <span>test_parse_unexpected_token</span>() {</span>
<span>    <span>let</span> <span>tokens</span> = <span>vec!</span>[</span>
<span>        Token::<span>new</span>(TokenType::Number, <span>&#34;512&#34;</span>),</span>
<span>        Token::<span>new</span>(TokenType::CurrencySymbol, <span>&#34;$&#34;</span>),</span>
<span>    ];</span>
<span>    <span>let</span> <span>mut </span><span>parser</span> = Parser::<span>new</span>(tokens);</span>
<span>    <span>assert_eq!</span>(parser.<span>parse_money</span>(), <span>Err</span>(</span>
<span>        ParseError::<span>UnexpectedToken</span>(</span>
<span>            TokenType::CurrencySymbol,</span>
<span>            TokenType::Number</span>
<span>        )</span>
<span>    ))</span>
<span>}</span>
<span> </span>
<span><span>#[test]</span></span>
<span><span>fn</span> <span>test_parse_invalid_amount</span>() {</span>
<span>    <span>let</span> <span>tokens</span> = <span>vec!</span>[</span>
<span>        Token::<span>new</span>(TokenType::CurrencySymbol, <span>&#34;$&#34;</span>),</span>
<span>        Token::<span>new</span>(TokenType::Number, <span>&#34;3rr0r&#34;</span>),</span>
<span>    ];</span>
<span>    <span>let</span> <span>mut </span><span>parser</span> = Parser::<span>new</span>(tokens);</span>
<span>    <span>assert_eq!</span>(parser.<span>parse_money</span>(), <span>Err</span>(ParseError::InvalidAmount))</span>
<span>}</span>
</code></pre>
<p>Run the test with the <code>cargo test</code> command, and you should see all tests are passed:</p>
<pre><code><span><span>running</span> <span>5</span> tests</span>
<span>test test_parse_eur ... ok</span>
<span>test test_parse_gbp ... ok</span>
<span>test test_parse_invalid_amount ... ok</span>
<span>test test_parse_usd ... ok</span>
<span>test test_parse_unexpected_token ... ok</span>
<span> </span>
<span>test result: ok. <span>5</span> passed; <span>0</span> failed; <span>0</span> ignored; <span>0</span> measured; <span>0</span> filtered out; finished <span>in</span> <span>0.00</span>s</span>
</code></pre>
<p>You can see the complete source code of the parser in <a href="https://gist.github.com/huytd/2ca7d9b25f539cbcf549f4bd2a19bcca" target="_blank" rel="noopener">this gist</a><sup>◹</sup>.</p>
<hr/>
<p>In this article, we learned what a Recursive Descent Parser is and how to implement the parser for each grammar rule, which serves as building blocks for each other. In the next article, we will look at a more complex parser for solving arithmetic expressions, which will give us a better look at the recursive characteristics of the Recursive Descent Parsing technique.</p>
<h2>Read more</h2>

<ul>
<li><a href="https://thewitchofendor.com/everyday/04-24-2022-compilers-virtual-stack-machine-variable-declaration">04.24.2022 - Compilers/Virtual Stack Machine/Variable declaration</a></li>
<li><a href="https://thewitchofendor.com/everyday/04-21-2022-compilers-how-virtual-stack-machines-executed">04.21.2022 - Compilers/How Virtual Stack Machines Executed</a></li>
<li><a href="https://thewitchofendor.com/everyday/04-20-2022-typescript-building-an-event-system-using-the-browser-s-customevent">04.20.2022 - TypeScript/Building an Event System using the browser’s CustomEvent</a></li>
<li><a href="https://thewitchofendor.com/everyday/04-19-2022-algorithms-extract-digits-of-a-number-from-both-ends">04.19.2022 - Algorithms/Extract digits of a number from both ends</a></li>
<li><a href="https://thewitchofendor.com/everyday/04-18-2022-algorithms-detect-chess-piece-movement-with-bitboard">04.18.2022 - Algorithms/Detect chess piece movement with Bitboard</a></li>
</ul>
</div></div></div>
  </body>
</html>
