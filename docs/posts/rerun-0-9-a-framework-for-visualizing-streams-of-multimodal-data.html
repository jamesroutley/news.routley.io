<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.rerun.io/blog/release-0.9">Original</a>
    <h1>Rerun 0.9 – a framework for visualizing streams of multimodal data</h1>
    
    <div id="readability-page-1" class="page"><div id="__next"><div><div><div><p>We’re building a fast and easy to use general framework for handling and visualizing streams of multimodal data. This is a big undertaking, and the way we’re getting there is by starting with a fast and easy to use visualizer for computer vision, and then making it more capable and extensible piece by piece.</p>
<p>Rerun 0.9.0 is released two months after 0.8.0, but it’s been even longer coming. It includes the foundation of the coming C++ SDK, our most asked for feature by far. In order to maintain great and consistent APIs across Rust, Python, C++, and any future languages, we’ve rebuilt much of Rerun&#39;s data infrastructure around a new code generation framework.</p>
<p>0.9 also adds support for logging markdown, a new in-viewer getting started experience, and as always, a bunch of performance improvements.</p>
<p><iframe src="https://player.vimeo.com/video/870834549?autoplay=1&amp;loop=1&amp;autopause=0&amp;background=1&amp;muted=1&amp;ratio=1440:1080&amp;transparent=false&amp;dnt=1" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen=""></iframe></p>
<p><em>Load example recordings, including descriptions of how they were made, directly in the viewer.</em></p>
<p>This has all been a huge lift, but what I’m most excited about are our redesigned APIs and what they pave the way for in future releases.
From this release on, we’ll start to expose more and more of Rerun&#39;s underlying infrastructure, starting with the core data model, a hierarchical and time varying Entity Component System (ECS).</p>
<p>To ease the transition for Python users, we&#39;ve marked the old APIs as deprecated in 0.9 with migration instructions in the warning messages. The old API will be removed completely in 0.10. Check out the <a href="https://www.rerun.io/docs/reference/migration-0-9">migration guide</a> for more details on updating your code.</p>
<h2 id="a-more-type-centric-logging-api">A more type centric logging API<!-- --> <a href="#a-more-type-centric-logging-api"></a></h2>
<p>At the heart of Rerun is the ability to handle streams of multimodal data, e.g. images, tensors, point clouds, and text. To get data out of your programs and ready to be visualized, you log it with the Rerun SDK. Rerun handles everything needed to make that work. It doesn&#39;t matter if the data source and visualization are in the same process or the data is coming in real-time from multiple devices.</p>
<p>The ease of use, expressiveness, and extensibility of these APIs are core to the usefulness of Rerun. On a first glance, the API changes introduced in 0.9 are very small. For example, here is how you might log a single colored point cloud, represented by two 3xN numpy arrays of positions and colors.</p>
<p>Old Python API</p>
<pre><p><code>rr<span>.</span><span>log_points</span><span>(</span><span>&#34;example/points&#34;</span><span>,</span> positions<span>,</span> colors<span>=</span>colors<span>)</span>
</code></p></pre>
<p>New Python API</p>
<pre><p><code>rr<span>.</span><span>log</span><span>(</span><span>&#34;example/points&#34;</span><span>,</span> rr<span>.</span><span>Points3D</span><span>(</span>positions<span>,</span> colors<span>=</span>colors<span>)</span><span>)</span>
</code></p></pre>
<p>Both these log calls take the same user data. The difference is in the data type information, which is moved from the function name <code>rr.log_points</code> to a type, <code>rr.Points3D</code> that wraps the logged data. This new structure both opens up for more direct control of the underlying ECS and for more ergonomic logging of your own objects.</p>
<h2 id="lower-level-control-of-entity-components">Lower level control of Entity Components<!-- --> <a href="#lower-level-control-of-entity-components"></a></h2>
<p>Rerun comes with a set of <a href="https://www.rerun.io/docs/reference/types/archetypes">built in archetypes</a> like <code>rr.Points3D</code> , <code>rr.Image</code>, and <code>rr.Tensor</code>. An archetype defines a bundle of component batches that the Rerun Viewer knows how to interpret, such that Rerun will just <strong><em>do the right thing™️</em></strong> when you log it. In this case, that’s one component batch for positions and one for colors.</p>
<pre><p><code>rr<span>.</span><span>log</span><span>(</span><span>&#34;example/points&#34;</span><span>,</span> rr<span>.</span><span>Points3D</span><span>(</span>positions<span>,</span> colors<span>=</span>colors<span>)</span><span>)</span>

rr<span>.</span><span>log</span><span>(</span><span>&#34;example/points&#34;</span><span>,</span> rr<span>.</span><span>Points3D</span><span>(</span>positions<span>,</span> colors<span>=</span>colors<span>)</span><span>.</span>as_component_batches<span>(</span><span>)</span><span>)</span>

rr<span>.</span><span>log</span><span>(</span><span>&#34;example/points&#34;</span><span>,</span> <span>[</span>rr<span>.</span><span>Points3D</span><span>.</span>indicator<span>(</span><span>)</span><span>,</span>
                          rr<span>.</span><span>components</span><span>.</span>Position3DBatch<span>(</span>positions<span>)</span><span>,</span>
                          rr<span>.</span><span>components</span><span>.</span>ColorBatch<span>(</span>rgb<span>=</span>colors<span>)</span><span>]</span><span>)</span>
</code></p></pre>
<h3 id="partial-updates-using-the-component-level-api">Partial updates using the component level API<!-- --> <a href="#partial-updates-using-the-component-level-api"></a></h3>
<p>In most cases, you’ll want to stick to the high level archetype API, but directly setting single components gives a lot of control, which can matter. For instance, a common use case is meshes where only the vertex positions change over time.
Logging the whole mesh for each change adds a lot of overhead. For example:</p>
<pre><p><code><span>import</span> numpy <span>as</span> np
<span>import</span> rerun <span>as</span> rr  

rr<span>.</span><span>init</span><span>(</span><span>&#34;rerun_example_mesh3d_partial_updates&#34;</span><span>,</span> spawn<span>=</span><span>True</span><span>)</span>

vertex_positions <span>=</span> np<span>.</span>array<span>(</span><span>[</span><span>[</span><span>-</span><span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>]</span><span>,</span> <span>[</span><span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>]</span><span>,</span> <span>[</span><span>0.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>]</span><span>]</span><span>,</span> dtype<span>=</span>np<span>.</span>float32<span>)</span>


rr<span>.</span><span>set_time_sequence</span><span>(</span><span>&#34;frame&#34;</span><span>,</span> <span>0</span><span>)</span>
rr<span>.</span><span>log</span><span>(</span>
    <span>&#34;triangle&#34;</span><span>,</span>
    rr<span>.</span><span>Mesh3D</span><span>(</span>
        vertex_positions<span>,</span>
        vertex_normals<span>=</span><span>[</span><span>0.0</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>]</span><span>,</span>
        vertex_colors<span>=</span><span>[</span><span>[</span><span>255</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>]</span><span>,</span> <span>[</span><span>0</span><span>,</span> <span>255</span><span>,</span> <span>0</span><span>]</span><span>,</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>255</span><span>]</span><span>]</span><span>,</span>
    <span>)</span><span>,</span>
<span>)</span>


factors <span>=</span> np<span>.</span><span>abs</span><span>(</span>np<span>.</span>sin<span>(</span>np<span>.</span>arange<span>(</span><span>1</span><span>,</span> <span>300</span><span>,</span> dtype<span>=</span>np<span>.</span>float32<span>)</span> <span>*</span> <span>0.04</span><span>)</span><span>)</span>
<span>for</span> i<span>,</span> factor <span>in</span> <span>enumerate</span><span>(</span>factors<span>)</span><span>:</span>
    rr<span>.</span><span>set_time_sequence</span><span>(</span><span>&#34;frame&#34;</span><span>,</span> i<span>)</span>
    rr<span>.</span><span>log</span><span>(</span><span>&#34;triangle&#34;</span><span>,</span> <span>[</span>rr<span>.</span><span>components</span><span>.</span>Position3DBatch<span>(</span>vertex_positions <span>*</span> factor<span>)</span><span>]</span><span>)</span>
</code></p></pre>
<p><iframe src="https://player.vimeo.com/video/866772278?autoplay=1&amp;loop=1&amp;autopause=0&amp;background=1&amp;muted=1&amp;ratio=1440:1080&amp;transparent=false&amp;dnt=1" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen=""></iframe></p>
<h3 id="interpret-the-same-data-in-several-ways-using-the-component-level-api">Interpret the same data in several ways using the component level API<!-- --> <a href="#interpret-the-same-data-in-several-ways-using-the-component-level-api"></a></h3>
<p>The component level API gives you the ability to interpret the same data as multiple types.
We do that by logging multiple indicator components, which tell the Rerun Viewer &#34;hey, this entity should be interpreted as type X&#34;.
In this example we interpret an entity as bott a colored triangle and as three colored points.</p>
<pre><p><code><span>import</span> rerun <span>as</span> rr

rr<span>.</span><span>init</span><span>(</span><span>&#34;rerun_example_manual_indicator&#34;</span><span>,</span> spawn<span>=</span><span>True</span><span>)</span>



rr<span>.</span><span>log</span><span>(</span>
    <span>&#34;points_and_mesh&#34;</span><span>,</span>
    <span>[</span>
        rr<span>.</span><span>Points3D</span><span>.</span>indicator<span>(</span><span>)</span><span>,</span>
        rr<span>.</span><span>Mesh3D</span><span>.</span>indicator<span>(</span><span>)</span><span>,</span>
        rr<span>.</span><span>components</span><span>.</span>Position3DBatch<span>(</span><span>[</span><span>[</span><span>0.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>]</span><span>,</span> <span>[</span><span>10.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>]</span><span>,</span> <span>[</span><span>0.0</span><span>,</span> <span>10.0</span><span>,</span> <span>0.0</span><span>]</span><span>]</span><span>)</span><span>,</span>
        rr<span>.</span><span>components</span><span>.</span>ColorBatch<span>(</span><span>[</span><span>[</span><span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>]</span><span>,</span> <span>[</span><span>0.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>]</span><span>,</span> <span>[</span><span>0.0</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>]</span><span>]</span><span>)</span><span>,</span>
        rr<span>.</span><span>components</span><span>.</span>RadiusBatch<span>(</span><span>[</span><span>1.0</span><span>]</span><span>)</span><span>,</span>
    <span>]</span><span>,</span>
<span>)</span>
</code></p></pre>
<p><iframe src="https://player.vimeo.com/video/870604519?autoplay=1&amp;loop=1&amp;autopause=0&amp;background=1&amp;muted=1&amp;ratio=1440:1080&amp;transparent=false&amp;dnt=1" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen=""></iframe></p>
<h2 id="using-your-own-types-with-rerun">Using your own types with Rerun<!-- --> <a href="#using-your-own-types-with-rerun"></a></h2>
<p>The new type oriented API also makes logging data from your own objects more ergonomic. For example, you might have your very own point cloud class.</p>
<pre><p><code><span>@dataclass</span>
<span>class</span> <span>LabeledPoints</span><span>:</span>
    points<span>:</span> np<span>.</span>ndarray
    labels<span>:</span> List<span>[</span><span>str</span><span>]</span><span>)</span>
</code></p></pre>
<p>All you need to do is implement <code>as_component_batches()</code> and you can pass them directly to <code>rr.log</code>. The simplest possible way is to use the matching Rerun archetype’s <code>as_component_batches</code> method like below but you can also get as fancy as you like with custom components and archetypes. Check out the guide on <a href="https://www.rerun.io/blog/docs/howto/extend/custom-data">using Rerun with custom data</a> for more details.</p>
<pre><p><code><span>@dataclass</span>
<span>class</span> <span>LabeledPoints</span><span>:</span>
    points<span>:</span> np<span>.</span>ndarray
    labels<span>:</span> List<span>[</span><span>str</span><span>]</span><span>)</span>
    
    <span>def</span> <span>as_component_batches</span><span>(</span>self<span>)</span> <span>-</span><span>&gt;</span> Iterable<span>[</span>rr<span>.</span><span>ComponentBatch</span><span>]</span><span>:</span>
        <span>return</span> rr<span>.</span><span>Points3D</span><span>(</span>positions<span>=</span>self<span>.</span>points<span>,</span> labels<span>=</span>self<span>.</span>labels<span>)</span><span>.</span>as_component_batches<span>(</span><span>)</span>
<span>.</span><span>.</span><span>.</span>

classified <span>=</span> my_points_classifier<span>(</span><span>.</span><span>.</span><span>.</span><span>)</span>  
rr<span>.</span><span>log</span><span>(</span><span>&#34;points/classified&#34;</span><span>,</span> classified<span>)</span>
</code></p></pre>
<p>The main takeaway here is that with 0.9 and the new type oriented API,
it becomes a lot easier to use Rerun with your own data types.</p>
<h2 id="how-it-paves-the-way-for-the-future">How it paves the way for the future<!-- --> <a href="#how-it-paves-the-way-for-the-future"></a></h2>
<p>Although this release brings a lot of great updates, it&#39;s perhaps the future features it paves the way for that are the most exciting.</p>
<h3 id="c-sdk">C++ SDK<!-- --> <a href="#c-sdk"></a></h3>
<p>Getting data from C++ environments into Rerun was the motivating factor behind
the move to our own code generation framework. A large amount of
production systems in robotics, computer vision and gaming are built in C++ and we&#39;re
incredibly excited to soon bring Rerun to all those developers.</p>
<h3 id="building-visualizations-inline">Building visualizations inline<!-- --> <a href="#building-visualizations-inline"></a></h3>
<p>Rerun started out making the hard case, where you stream data out of multiple processes and visualize it live, easy.
The downside so far has been that in simpler cases, like in jupyter notebooks, using Rerun is more convoluted than it should be.</p>
<p>Even when time is not a factor and you have all your data right there and just want to draw it,
you currently have to go through the indirection of logging it first.</p>
<p>The new APIs introduced in 0.9, pave the way for a clean way of just drawing data inline without logging.
We&#39;ll start rolling that out together with the ability to control layout and visualization options
from the SDK later in the year once C++ has landed.</p>
<h3 id="generating-your-own-rerun-sdk-extensions">Generating your own Rerun SDK extensions<!-- --> <a href="#generating-your-own-rerun-sdk-extensions"></a></h3>
<p>Our new code generation framework is still a bit immature, but it&#39;s been a design goal from the start
to let users use it to generate their own stand alone extensions to the Rerun SDK.
We hope once it&#39;s had time to mature, it will
be useful to both teams with their own proprietary data formats and for other projects
that want to make interfacing with Rerun as easy as possible for their users.</p>
<h2 id="let-us-know-what-you-think">Let us know what you think<!-- --> <a href="#let-us-know-what-you-think"></a></h2>
<p>We&#39;re incredibly excited to hear what you think about these changes.
Join us on <a href="https://github.com/rerun-io/rerun">Github</a> or <a href="https://discord.gg/PXtCgFBSmH">Discord</a>
and let us know how 0.9 works for you and what you&#39;d like to see in the future.</p>
<p>If you&#39;re an existing Rerun user and have any questions or need any help migrating to the new APIs,
send us a ping on Discord or elsewhere and we&#39;ll be happy to get on a call and help you out.</p></div></div></div></div></div>
  </body>
</html>
