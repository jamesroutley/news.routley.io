<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/piercefreeman/gpt-json">Original</a>
    <h1>Show HN: GPT-JSON â€“ Structured and typehinted GPT responses in Python</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><code>gpt-json</code> is a wrapper around GPT that allows for declarative definition of expected output format. Set up a schema, write a prompt, and get results back as beautiful typehinted objects.</p>
<p dir="auto">Specifically this library:</p>
<ul dir="auto">
<li>Utilizes Pydantic schema definitions for type casting and validations</li>
<li>Adds typehinting for both the API and the output schema</li>
<li>Allows GPT to respond with both single-objects and lists of objects</li>
<li>Includes some lightweight transformations of the output to remove superfluous context and fix broken json</li>
<li>Includes retry logic for the most common API failures</li>
<li>Formats the JSON schema as a flexible prompt that can be added into any message</li>
<li>Supports templating of prompts to allow for dynamic content</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-getting-started" aria-hidden="true" href="#getting-started"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Getting Started</h2>

<p dir="auto">Here&#39;s how to use it to generate a schema for simple tasks:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import asyncio

from gpt_json import GPTJSON, GPTMessage, GPTMessageRole
from pydantic import BaseModel

class SentimentSchema(BaseModel):
    sentiment: str

SYSTEM_PROMPT = &#34;&#34;&#34;
Analyze the sentiment of the given text.

Respond with the following JSON schema:

{json_schema}
&#34;&#34;&#34;

async def runner():
    gpt_json = GPTJSON[SentimentSchema](API_KEY)
    response, _ = await gpt_json.run(
        messages=[
            GPTMessage(
                role=GPTMessageRole.SYSTEM,
                content=SYSTEM_PROMPT,
            ),
            GPTMessage(
                role=GPTMessageRole.USER,
                content=&#34;Text: I love this product. It&#39;s the best thing ever!&#34;,
            )
        ]
    )
    print(response)
    print(f&#34;Detected sentiment: {response.sentiment}&#34;)

asyncio.run(runner())"><pre><span>import</span> <span>asyncio</span>

<span>from</span> <span>gpt_json</span> <span>import</span> <span>GPTJSON</span>, <span>GPTMessage</span>, <span>GPTMessageRole</span>
<span>from</span> <span>pydantic</span> <span>import</span> <span>BaseModel</span>

<span>class</span> <span>SentimentSchema</span>(<span>BaseModel</span>):
    <span>sentiment</span>: <span>str</span>

<span>SYSTEM_PROMPT</span> <span>=</span> <span>&#34;&#34;&#34;</span>
<span>Analyze the sentiment of the given text.</span>
<span></span>
<span>Respond with the following JSON schema:</span>
<span></span>
<span>{json_schema}</span>
<span>&#34;&#34;&#34;</span>

<span>async</span> <span>def</span> <span>runner</span>():
    <span>gpt_json</span> <span>=</span> <span>GPTJSON</span>[<span>SentimentSchema</span>](<span>API_KEY</span>)
    <span>response</span>, <span>_</span> <span>=</span> <span>await</span> <span>gpt_json</span>.<span>run</span>(
        <span>messages</span><span>=</span>[
            <span>GPTMessage</span>(
                <span>role</span><span>=</span><span>GPTMessageRole</span>.<span>SYSTEM</span>,
                <span>content</span><span>=</span><span>SYSTEM_PROMPT</span>,
            ),
            <span>GPTMessage</span>(
                <span>role</span><span>=</span><span>GPTMessageRole</span>.<span>USER</span>,
                <span>content</span><span>=</span><span>&#34;Text: I love this product. It&#39;s the best thing ever!&#34;</span>,
            )
        ]
    )
    <span>print</span>(<span>response</span>)
    <span>print</span>(<span>f&#34;Detected sentiment: <span><span>{</span><span>response</span>.<span>sentiment</span><span>}</span></span>&#34;</span>)

<span>asyncio</span>.<span>run</span>(<span>runner</span>())</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="sentiment=&#39;positive&#39;
Detected sentiment: positive"><pre>sentiment=<span><span>&#39;</span>positive<span>&#39;</span></span>
Detected sentiment: positive</pre></div>
<p dir="auto">The <code>json_schema</code> is a special keyword that will be replaced with the schema definition at runtime. You should always include this in your payload to ensure the model knows how to format results. However, you can play around with <em>where</em> to include this schema definition; in the system prompt, in the user prompt, at the beginning, or at the end.</p>
<p dir="auto">You can either typehint the model to return a BaseSchema back, or to provide a list of Multiple BaseSchema. Both of these work:</p>
<div dir="auto" data-snippet-clipboard-copy-content="gpt_json_single = GPTJSON[SentimentSchema](API_KEY)
gpt_json_single = GPTJSON[list[SentimentSchema]](API_KEY)"><pre><span>gpt_json_single</span> <span>=</span> <span>GPTJSON</span>[<span>SentimentSchema</span>](<span>API_KEY</span>)
<span>gpt_json_single</span> <span>=</span> <span>GPTJSON</span>[<span>list</span>[<span>SentimentSchema</span>]](<span>API_KEY</span>)</pre></div>
<p dir="auto">If you want to get more specific about how you expect the model to populate a field, add hints about the value through the &#34;description&#34; field. This helps the model understand what you&#39;re looking for, and will help it generate better results.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from pydantic import BaseModel, Field

class SentimentSchema(BaseModel):
    sentiment: int = Field(description=&#34;Either -1, 0, or 1.&#34;)"><pre><span>from</span> <span>pydantic</span> <span>import</span> <span>BaseModel</span>, <span>Field</span>

<span>class</span> <span>SentimentSchema</span>(<span>BaseModel</span>):
    <span>sentiment</span>: <span>int</span> <span>=</span> <span>Field</span>(<span>description</span><span>=</span><span>&#34;Either -1, 0, or 1.&#34;</span>)</pre></div>
<div data-snippet-clipboard-copy-content="sentiment=1
Detected sentiment: 1"><pre><code>sentiment=1
Detected sentiment: 1
</code></pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-prompt-variables" aria-hidden="true" href="#prompt-variables"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Prompt Variables</h2>
<p dir="auto">In addition to the <code>json_schema</code> template keyword, you can also add arbitrary variables into your messages. This allows you to more easily insert user generated content or dynamically generate prompts based on the results of previous messages.</p>
<div dir="auto" data-snippet-clipboard-copy-content="class QuoteSchema(BaseModel):
    quotes: list[str]

SYSTEM_PROMPT = &#34;&#34;&#34;
Generate fictitious quotes that are {sentiment}.

{json_schema}
&#34;&#34;&#34;

gpt_json = GPTJSON[QuoteSchema](API_KEY)
response, _ = await gpt_json.run(
    messages=[
        GPTMessage(
            role=GPTMessageRole.SYSTEM,
            content=SYSTEM_PROMPT,
        ),
    ],
    format_variables={&#34;sentiment&#34;: &#34;happy&#34;},
)"><pre><span>class</span> <span>QuoteSchema</span>(<span>BaseModel</span>):
    <span>quotes</span>: <span>list</span>[<span>str</span>]

<span>SYSTEM_PROMPT</span> <span>=</span> <span>&#34;&#34;&#34;</span>
<span>Generate fictitious quotes that are {sentiment}.</span>
<span></span>
<span>{json_schema}</span>
<span>&#34;&#34;&#34;</span>

<span>gpt_json</span> <span>=</span> <span>GPTJSON</span>[<span>QuoteSchema</span>](<span>API_KEY</span>)
<span>response</span>, <span>_</span> <span>=</span> <span>await</span> <span>gpt_json</span>.<span>run</span>(
    <span>messages</span><span>=</span>[
        <span>GPTMessage</span>(
            <span>role</span><span>=</span><span>GPTMessageRole</span>.<span>SYSTEM</span>,
            <span>content</span><span>=</span><span>SYSTEM_PROMPT</span>,
        ),
    ],
    <span>format_variables</span><span>=</span>{<span>&#34;sentiment&#34;</span>: <span>&#34;happy&#34;</span>},
)</pre></div>
<p dir="auto">When calling the <code>.run()</code> function you can pass it the values that should be filled in this template. This also extends to field descriptions as well, so you can specify custom behavior on a per-field basis.</p>
<div dir="auto" data-snippet-clipboard-copy-content="class QuoteSchema(BaseModel):
    quotes: list[str] = Field(description=&#34;Max quantity {max_items}.&#34;)

SYSTEM_PROMPT = &#34;&#34;&#34;
Generate fictitious quotes that are {sentiment}.

{json_schema}
&#34;&#34;&#34;

gpt_json = GPTJSON[QuoteSchema](API_KEY)
response, _ = await gpt_json.run(
    messages=[
        GPTMessage(
            role=GPTMessageRole.SYSTEM,
            content=SYSTEM_PROMPT,
        ),
    ],
    format_variables={&#34;sentiment&#34;: &#34;happy&#34;, &#34;max_items&#34;: 5},
)"><pre><span>class</span> <span>QuoteSchema</span>(<span>BaseModel</span>):
    <span>quotes</span>: <span>list</span>[<span>str</span>] <span>=</span> <span>Field</span>(<span>description</span><span>=</span><span>&#34;Max quantity {max_items}.&#34;</span>)

<span>SYSTEM_PROMPT</span> <span>=</span> <span>&#34;&#34;&#34;</span>
<span>Generate fictitious quotes that are {sentiment}.</span>
<span></span>
<span>{json_schema}</span>
<span>&#34;&#34;&#34;</span>

<span>gpt_json</span> <span>=</span> <span>GPTJSON</span>[<span>QuoteSchema</span>](<span>API_KEY</span>)
<span>response</span>, <span>_</span> <span>=</span> <span>await</span> <span>gpt_json</span>.<span>run</span>(
    <span>messages</span><span>=</span>[
        <span>GPTMessage</span>(
            <span>role</span><span>=</span><span>GPTMessageRole</span>.<span>SYSTEM</span>,
            <span>content</span><span>=</span><span>SYSTEM_PROMPT</span>,
        ),
    ],
    <span>format_variables</span><span>=</span>{<span>&#34;sentiment&#34;</span>: <span>&#34;happy&#34;</span>, <span>&#34;max_items&#34;</span>: <span>5</span>},
)</pre></div>
<h2 tabindex="-1" dir="auto"><a id="user-content-other-configurations" aria-hidden="true" href="#other-configurations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Other Configurations</h2>
<p dir="auto">The <code>GPTJSON</code> class supports other configuration parameters at initialization.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>model</td>
<td>GPTModelVersion | str</td>
<td>(default: GPTModelVersion.GPT_4) - For convenience we provide the currently supported GPT model versions in the <code>GPTModelVersion</code> enum. You can also pass a string value if you want to use another more specific architecture.</td>
</tr>
<tr>
<td>auto_trim</td>
<td>bool</td>
<td>(default: False) - If your input prompt is too long, perhaps because of dynamic injected content, will automatically truncate the text to create enough room for the model&#39;s response.</td>
</tr>
<tr>
<td>auto_trim_response_overhead</td>
<td>int</td>
<td>(default: 0) - If you&#39;re using auto_trim, configures the max amount of tokens to allow in the model&#39;s response.</td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any</td>
<td>Any other parameters you want to pass to the underlying <code>GPT</code> class, will just be a passthrough.</td>
</tr>
</tbody>
</table>
<h2 tabindex="-1" dir="auto"><a id="user-content-transformations" aria-hidden="true" href="#transformations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Transformations</h2>
<p dir="auto">GPT (especially GPT-4) is relatively good at formatting responses at JSON, but it&#39;s not perfect. Some of the more common issues are:</p>
<ul dir="auto">
<li><em>Response truncation</em>: Since GPT is not internally aware of its response length limit, JSON payloads will sometimes exhaust the available token space. This results in a broken JSON payload where much of the data is valid but the JSON object is not closed, which is not valid syntax. There are many cases where this behavior is actually okay for production applications - for instance, if you list 100 generated strings, it&#39;s sometimes okay for you to take the 70 that actually rendered. In this case, <code>gpt-json</code> will attempt to fix the truncated payload by recreating the JSON object and closing it.</li>
<li><em>Boolean variables</em>: GPT will sometimes confuse valid JSON boolean values with the boolean tokens that are used in other languages. The most common is generating <code>True</code> instead of <code>true</code>. <code>gpt-json</code> will attempt to fix these values.</li>
</ul>
<p dir="auto">When calling <code>gpt_json.run()</code>, we return a tuple of values:</p>
<div dir="auto" data-snippet-clipboard-copy-content="response, transformations = await gpt_json.run(...)

print(transformations)"><pre><span>response</span>, <span>transformations</span> <span>=</span> <span>await</span> <span>gpt_json</span>.<span>run</span>(...)

<span>print</span>(<span>transformations</span>)</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="FixTransforms(fixed_truncation=True, fixed_bools=False)"><pre>FixTransforms(fixed_truncation=True, fixed_bools=False)</pre></div>
<p dir="auto">The first object is your generated Pydantic model. The second object is our correction storage object <code>FixTransforms</code>. This dataclass contains flags for each of the supported transformation cases that are sketched out above. This allows you to determine whether the response was explicitly parsed from the GPT JSON, or was passed through some middlelayers to get a correct output. From there you can accept or reject the response based on your own business logic.</p>
<p dir="auto"><em>Where you can help</em>: There are certainly more areas of common (and not-so-common failures). If you see these, please add a test case to the unit tests. If you can write a handler to help solve the general case, please do so. Otherwise flag it as a <code>pytest.xfail</code> and we&#39;ll add it to the backlog.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-testing" aria-hidden="true" href="#testing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Testing</h2>
<p dir="auto">We use poetry for package management. To run the bundled tests, clone the package from github.</p>
<div dir="auto" data-snippet-clipboard-copy-content="poetry install
poetry run pytest ."><pre>poetry install
poetry run pytest <span>.</span></pre></div>
<p dir="auto">Our focus is on making unit tests as robust as possible. The variability with GPT should be in its language model, not in its JSON behavior! This is still certainly a work in progress. If you see an edge case that isn&#39;t covered, please add it to the test suite.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-comparison-to-other-libraries" aria-hidden="true" href="#comparison-to-other-libraries"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Comparison to Other Libraries</h2>
<p dir="auto">A non-exhaustive list of other libraries that address the same problem. None of them were fully compatible with my deployment (hence this library), but check them out:</p>
<p dir="auto"><a href="https://github.com/1rgs/jsonformer">jsonformer</a> - Works with any Huggingface model, whereas <code>gpt-json</code> is specifically tailored towards the GPT-X family. GPT doesn&#39;t output logit probabilities or allow fixed decoder templating so the same approach can&#39;t apply.</p>
</article>
          </div></div>
  </body>
</html>
