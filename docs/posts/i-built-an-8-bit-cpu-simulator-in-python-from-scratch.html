<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/sql-hkr/tiny8">Original</a>
    <h1>Show HN: I built an 8-bit CPU simulator in Python from scratch</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7eb111f3bed4eca529a73f38cf001931116baf2a37c17548af3965b7684a3e62/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f74696e7938"><img src="https://camo.githubusercontent.com/7eb111f3bed4eca529a73f38cf001931116baf2a37c17548af3965b7684a3e62/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f74696e7938" alt="PyPI version" data-canonical-src="https://img.shields.io/pypi/v/tiny8"/></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/94bab256436b38f067aa89d59d403f1bbe5eb0a7cecf25115e4f536932359c7d/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f73716c2d686b722f74696e7938"><img src="https://camo.githubusercontent.com/94bab256436b38f067aa89d59d403f1bbe5eb0a7cecf25115e4f536932359c7d/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f73716c2d686b722f74696e7938" alt="License" data-canonical-src="https://img.shields.io/github/license/sql-hkr/tiny8"/></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/69860052145b463843266ed4f2b56dc277d1561bc8c223d0a5dd34ceeb9d8dcf/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f74696e7938"><img src="https://camo.githubusercontent.com/69860052145b463843266ed4f2b56dc277d1561bc8c223d0a5dd34ceeb9d8dcf/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f74696e7938" alt="Python versions" data-canonical-src="https://img.shields.io/pypi/pyversions/tiny8"/></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e50145279c50715fcc6fa3bc8ad47b9387af4823e370f2c307b03a9a47a0b49e/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f616374696f6e732f776f726b666c6f772f7374617475732f73716c2d686b722f74696e79382f63692e796d6c3f6c6162656c3d4349"><img src="https://camo.githubusercontent.com/e50145279c50715fcc6fa3bc8ad47b9387af4823e370f2c307b03a9a47a0b49e/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f616374696f6e732f776f726b666c6f772f7374617475732f73716c2d686b722f74696e79382f63692e796d6c3f6c6162656c3d4349" alt="CI" data-canonical-src="https://img.shields.io/github/actions/workflow/status/sql-hkr/tiny8/ci.yml?label=CI"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/sql-hkr/tiny8/blob/main/docs/_static/examples/bubblesort.gif"><img src="https://github.com/sql-hkr/tiny8/raw/main/docs/_static/examples/bubblesort.gif" alt="bubblesort" data-animated-image=""/></a></p>
<p dir="auto">Tiny8 is a lightweight toolkit that allows you to explore how computers work at their core through small-scale memory models, handcrafted assembly, and lightweight in-memory data structures.
Designed for rapid experimentation, Tiny8 embraces minimalism with zero unnecessary dependencies, a clean design, and intuitive visualization tools that make learning, debugging, and tinkering enjoyable.</p>
<p dir="auto">Why Tiny8?</p>
<ul dir="auto">
<li>Lightweight: tiny install footprint and no heavy runtime dependencies.</li>
<li>Educational: clear primitives and examples that demonstrate CPU concepts, memory layout, and algorithms.</li>
<li>Fast feedback loop: assemble, run, and visualize within seconds to iterate on ideas.</li>
<li>Extensible: meant for experiments, teaching, demos, and small tools that benefit from a predictable, tiny VM.</li>
</ul>
<p dir="auto">Who should use it?</p>
<ul dir="auto">
<li>Students learning low-level programming, assembly, or computer architecture who want hands-on examples.</li>
<li>Educators building demos and interactive lessons that visualize how registers and memory change.</li>
<li>Hobbyists and hackers experimenting with toy CPUs, compact data layouts, or custom instruction ideas.</li>
<li>Developers who want a tiny, readable simulator to prototype algorithms that manipulate memory directly.</li>
</ul>
<p dir="auto">Get started</p>
<ul dir="auto">
<li>Follow the Installation section below to install from PyPI or set up a development environment.</li>
<li>See the Examples section (like the bubble sort demo) to run real programs and watch the visualizer in action.</li>
<li>Dive into the API Reference for details on the CPU, assembler, and visualization helpers.</li>
</ul>

<p dir="auto">Tiny8 supports Python 3.11 and newer. It has no heavy external dependencies and is suitable for inclusion in virtual environments. Follow the steps below to prepare your environment and install from source or PyPI.</p>

<ul dir="auto">
<li>Python 3.11+</li>
<li>Git (for installing from the repository)</li>
<li>Recommended: create and use a virtual environment</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">From source (development)</h3><a id="user-content-from-source-development" aria-label="Permalink: From source (development)" href="#from-source-development"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="git clone https://github.com/sql-hkr/tiny8.git
cd tiny8
uv venv
source .venv/bin/activate
uv sync"><pre>git clone https://github.com/sql-hkr/tiny8.git
<span>cd</span> tiny8
uv venv
<span>source</span> .venv/bin/activate
uv sync</pre></div>
<div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p><p dir="auto"><a href="https://docs.astral.sh/uv/" rel="nofollow">uv</a> is an extremely fast Python package and project manager, written in Rust. To install it, run:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# On macOS and Linux.
curl -LsSf https://astral.sh/uv/install.sh | sh

# On Windows.
powershell -ExecutionPolicy ByPass -c &#34;irm https://astral.sh/uv/install.ps1 | iex&#34;"><pre><span><span>#</span> On macOS and Linux.</span>
curl -LsSf https://astral.sh/uv/install.sh <span>|</span> sh

<span><span>#</span> On Windows.</span>
powershell -ExecutionPolicy ByPass -c <span><span>&#34;</span>irm https://astral.sh/uv/install.ps1 | iex<span>&#34;</span></span></pre></div>
</div>
<p dir="auto">This flow sets up a development virtual environment, installs development requirements, and prepares the project for local editing and testing.</p>




<p dir="auto">This example demonstrates a simple bubble sort algorithm implemented in assembly language for the Tiny8 CPU. The program first fills a section of RAM with pseudo-random bytes, then sorts those bytes using the bubble sort algorithm. Finally, a Python script runs the assembly program and visualizes the sorting process.</p>
<p dir="auto">bubblesort.asm:</p>
<div dir="auto" data-snippet-clipboard-copy-content="; Bubble sort using RAM (addresses 100..131) - 32 elements
; Purpose: fill RAM[100..131] with pseudo-random bytes and sort them
; Registers (use R16..R31 for LDI immediates):
;   R16 - base address (start = 100)
;   R17 - index / loop counter for initialization
;   R18 - PRNG state (seed)
;   R19..R24 - temporary registers used in loops and swaps
;   R25 - PRNG multiplier (kept aside to avoid clobber in MUL)
;
; The code below is split into two phases:
; 1) init_loop: generate and store 32 pseudo-random bytes at RAM[100..131]
; 2) outer/inner loops: perform a simple bubble sort over those 32 bytes

    ; initialize pointers and PRNG
    ldi r16, 100    ; base address
    ldi r17, 0      ; index = 0
    ldi r18, 123    ; PRNG seed
    ldi r25, 75     ; PRNG multiplier (kept in r25 so mul doesn&#39;t clobber it)

init_loop:
    ; PRNG step: r2 := lowbyte(r2 * 75), then tweak
    mul r18, r25     ; r18 = low byte of (r18 * 75)
    inc r18           ; small increment to avoid repeating patterns
    ; store generated byte into memory at base + index
    st r16, r18       ; RAM[base] = r18
    inc r16           ; advance base pointer
    inc r17           ; increment index
    ldi r23, 32
    cp r17, r23
    brne init_loop

; Bubble sort for 32 elements (perform passes until i == 31)
    ldi r18, 0      ; i = 0 (outer loop counter)
outer_loop:
    ldi r19, 0      ; j = 0 (inner loop counter)
inner_loop:
    ; compute address of element A = base + j
    ldi r20, 100
    add r20, r19
    ld r21, r20      ; r21 = A
    ; compute address of element B = base + j + 1
    ldi r22, 100
    add r22, r19
    ldi r23, 1
    add r22, r23
    ld r24, r22      ; r24 = B
    ; compare A and B (we&#39;ll swap if A &lt; B)
    cp r21, r24      ; sets carry if r21 &lt; r24
    brcs no_swap
    ; swap A and B: store B into A&#39;s address, A into B&#39;s address
    st r20, r24
    st r22, r21
no_swap:
    inc r19
    ldi r23, 31
    cp r19, r23
    breq end_inner
    jmp inner_loop
end_inner:
    inc r18
    ldi r23, 31
    cp r18, r23
    breq done
    jmp outer_loop

done:
    jmp done"><pre><span>; Bubble sort using RAM (addresses 100..131) - 32 elements</span>
<span>; Purpose: fill RAM[100..131] with pseudo-random bytes and sort them</span>
<span>; Registers (use R16..R31 for LDI immediates):</span>
<span>;   R16 - base address (start = 100)</span>
<span>;   R17 - index / loop counter for initialization</span>
<span>;   R18 - PRNG state (seed)</span>
<span>;   R19..R24 - temporary registers used in loops and swaps</span>
<span>;   R25 - PRNG multiplier (kept aside to avoid clobber in MUL)</span>
<span>;</span>
<span>; The code below is split into two phases:</span>
<span>; 1) init_loop: generate and store 32 pseudo-random bytes at RAM[100..131]</span>
<span>; 2) outer/inner loops: perform a simple bubble sort over those 32 bytes</span>

<span>    ; initialize pointers and PRNG</span>
<span>    ldi r16</span><span>,</span><span> </span><span>100</span><span>    ; base address</span>
<span>    ldi r17</span><span>,</span><span> </span><span>0</span><span>      ; index = 0</span>
<span>    ldi r18</span><span>,</span><span> </span><span>123</span><span>    ; PRNG seed</span>
<span>    ldi r25</span><span>,</span><span> </span><span>75</span><span>     ; PRNG multiplier (kept in r25 so mul doesn&#39;t clobber it)</span>

<span>init_loop:</span>
<span>    ; PRNG step: r2 := lowbyte(r2 * 75), then tweak</span>
<span>    </span><span>mul</span><span> r18</span><span>,</span><span> r25</span><span>     ; r18 = low byte of (r18 * 75)</span>
<span>    </span><span>inc</span><span> r18</span><span>           ; small increment to avoid repeating patterns</span>
<span>    ; store generated byte into memory at base + index</span>
<span>    st r16</span><span>,</span><span> r18</span><span>       ; RAM[base] = r18</span>
<span>    </span><span>inc</span><span> r16</span><span>           ; advance base pointer</span>
<span>    </span><span>inc</span><span> r17</span><span>           ; increment index</span>
<span>    ldi r23</span><span>,</span><span> </span><span>32</span>
<span>    cp r17</span><span>,</span><span> r23</span>
<span>    brne init_loop</span>

<span>; Bubble sort for 32 elements (perform passes until i == 31)</span>
<span>    ldi r18</span><span>,</span><span> </span><span>0</span><span>      ; i = 0 (outer loop counter)</span>
<span>outer_loop:</span>
<span>    ldi r19</span><span>,</span><span> </span><span>0</span><span>      ; j = 0 (inner loop counter)</span>
<span>inner_loop:</span>
<span>    ; compute address of element A = base + j</span>
<span>    ldi r20</span><span>,</span><span> </span><span>100</span>
<span>    </span><span>add</span><span> r20</span><span>,</span><span> r19</span>
<span>    ld r21</span><span>,</span><span> r20</span><span>      ; r21 = A</span>
<span>    ; compute address of element B = base + j + 1</span>
<span>    ldi r22</span><span>,</span><span> </span><span>100</span>
<span>    </span><span>add</span><span> r22</span><span>,</span><span> r19</span>
<span>    ldi r23</span><span>,</span><span> </span><span>1</span>
<span>    </span><span>add</span><span> r22</span><span>,</span><span> r23</span>
<span>    ld r24</span><span>,</span><span> r22</span><span>      ; r24 = B</span>
<span>    ; compare A and B (we&#39;ll swap if A &lt; B)</span>
<span>    cp r21</span><span>,</span><span> r24</span><span>      ; sets carry if r21 &lt; r24</span>
<span>    brcs no_swap</span>
<span>    ; swap A and B: store B into A&#39;s address, A into B&#39;s address</span>
<span>    st r20</span><span>,</span><span> r24</span>
<span>    st r22</span><span>,</span><span> r21</span>
<span>no_swap:</span>
<span>    </span><span>inc</span><span> r19</span>
<span>    ldi r23</span><span>,</span><span> </span><span>31</span>
<span>    cp r19</span><span>,</span><span> r23</span>
<span>    breq end_inner</span>
<span>    </span><span>jmp</span><span> inner_loop</span>
<span>end_inner:</span>
<span>    </span><span>inc</span><span> r18</span>
<span>    ldi r23</span><span>,</span><span> </span><span>31</span>
<span>    cp r18</span><span>,</span><span> r23</span>
<span>    breq done</span>
<span>    </span><span>jmp</span><span> outer_loop</span>

<span>done:</span>
<span>    </span><span>jmp</span><span> done</span></pre></div>
<p dir="auto">Python Code:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from tiny8 import CPU, Visualizer, assemble_file

prog, labels = assemble_file(&#34;examples/bubblesort.asm&#34;)
cpu = CPU()
cpu.load_program(prog, labels)
cpu.run(max_cycles=15000)

print([cpu.read_ram(i) for i in range(100, 132)])

viz = Visualizer(cpu)
base = 100
viz.animate_combined(
    interval=1,
    mem_addr_start=base,
    mem_addr_end=base + 31,
    plot_every=100,
    # filename=&#34;bubblesort.gif&#34;,
    # fps=60,
)"><pre><span>from</span> <span>tiny8</span> <span>import</span> <span>CPU</span>, <span>Visualizer</span>, <span>assemble_file</span>

<span>prog</span>, <span>labels</span> <span>=</span> <span>assemble_file</span>(<span>&#34;examples/bubblesort.asm&#34;</span>)
<span>cpu</span> <span>=</span> <span>CPU</span>()
<span>cpu</span>.<span>load_program</span>(<span>prog</span>, <span>labels</span>)
<span>cpu</span>.<span>run</span>(<span>max_cycles</span><span>=</span><span>15000</span>)

<span>print</span>([<span>cpu</span>.<span>read_ram</span>(<span>i</span>) <span>for</span> <span>i</span> <span>in</span> <span>range</span>(<span>100</span>, <span>132</span>)])

<span>viz</span> <span>=</span> <span>Visualizer</span>(<span>cpu</span>)
<span>base</span> <span>=</span> <span>100</span>
<span>viz</span>.<span>animate_combined</span>(
    <span>interval</span><span>=</span><span>1</span>,
    <span>mem_addr_start</span><span>=</span><span>base</span>,
    <span>mem_addr_end</span><span>=</span><span>base</span> <span>+</span> <span>31</span>,
    <span>plot_every</span><span>=</span><span>100</span>,
    <span># filename=&#34;bubblesort.gif&#34;,</span>
    <span># fps=60,</span>
)</pre></div>
<p dir="auto">Example Output:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[247, 243, 239, 238, 227, 211, 210, 195, 190, 187, 186, 171, 167, 159, 155, 150, 142, 139, 135, 130, 127, 106, 102, 94, 54, 50, 34, 26, 23, 15, 10, 6]"><pre>[247, 243, 239, 238, 227, 211, 210, 195, 190, 187, 186, 171, 167, 159, 155, 150, 142, 139, 135, 130, 127, 106, 102, 94, 54, 50, 34, 26, 23, 15, 10, 6]</pre></div>

<p dir="auto">Below is a concise, categorized summary of the Tiny8 instruction set (mnemonics are case-insensitive). This is a quick reference — for implementation details see <code>src/tiny8/cpu.py</code>.</p>
<ul dir="auto">
<li>
<p dir="auto">Data transfer</p>
<ul dir="auto">
<li>LDI Rd, K — load immediate into register</li>
<li>MOV Rd, Rr — copy register</li>
<li>LD Rd, Rr_addr — load from RAM at address in register</li>
<li>ST Rr_addr, Rr — store register into RAM at address in register</li>
<li>IN Rd, port — read byte from RAM/IO into register</li>
<li>OUT port, Rr — write register to RAM/IO</li>
<li>PUSH Rr / POP Rd — stack push/pop</li>
</ul>
</li>
<li>
<p dir="auto">Arithmetic</p>
<ul dir="auto">
<li>ADD Rd, Rr — add registers</li>
<li>ADC Rd, Rr — add with carry</li>
<li>SUB Rd, Rr / SUBI Rd, K — subtraction</li>
<li>SBC Rd, Rr / SBCI Rd, K — subtract with carry/borrow</li>
<li>INC Rd / DEC Rd — increment / decrement</li>
<li>MUL Rd, Rr — 8x8 -&gt; 16 multiply (low/high in Rd/Rd+1)</li>
<li>DIV Rd, Rr — unsigned divide (quotient-&gt;Rd, remainder-&gt;Rd+1)</li>
<li>NEG Rd — two&#39;s complement negate</li>
<li>CLR Rd / SER Rd — clear or set register to all ones</li>
</ul>
</li>
<li>
<p dir="auto">Logical and bit ops</p>
<ul dir="auto">
<li>AND Rd, Rr / ANDI Rd, K — bitwise AND</li>
<li>OR Rd, Rr / ORI Rd, K — bitwise OR</li>
<li>EOR Rd, Rr / EORI Rd, K — exclusive OR</li>
<li>COM Rd — one&#39;s complement</li>
<li>SWAP Rd — swap nibbles</li>
<li>TST Rd — test for zero or minus</li>
<li>SBI/CBI / SBIS/SBIC / SBRS/SBRC — set/clear/test single bits and conditional skips</li>
</ul>
</li>
<li>
<p dir="auto">Shifts &amp; rotates</p>
<ul dir="auto">
<li>LSL Rd / LSR Rd — logical shift left/right</li>
<li>ROL Rd / ROR Rd — rotate through carry</li>
</ul>
</li>
<li>
<p dir="auto">Word (16-bit) ops</p>
<ul dir="auto">
<li>SBIW / ADIW — simplified word add/subtract helpers for register pairs</li>
</ul>
</li>
<li>
<p dir="auto">Control flow</p>
<ul dir="auto">
<li>JMP label / RJMP offset — unconditional jump</li>
<li>CALL label / RCALL offset — call subroutine (push return address)</li>
<li>RET / RETI — return from subroutine / return from interrupt (sets I)</li>
<li>BRNE / BREQ / BRCS / BRCC — conditional branches based on flags</li>
<li>CP Rd, Rr / CPI Rd, K — compare (sets flags)</li>
<li>CPSE Rd, Rr — compare and skip if equal</li>
</ul>
</li>
</ul>
<p dir="auto">Use the assembler in <code>src/tiny8/assembler.py</code> (or <code>parse_asm</code>) to write programs — register operands are specified as R0..R31 and immediates accept decimal, $hex, 0x, or 0b binary notation.</p>

<p dir="auto">The API section documents the public modules, classes, functions, and configuration options. See:</p>
<ul dir="auto">
<li><a href="https://sql-hkr.github.io/tiny8/api/tiny8.html" rel="nofollow">tiny8 package</a></li>
</ul>

<p dir="auto">Tiny8 is licensed under the MIT License. See <a href="https://github.com/sql-hkr/tiny8/blob/main/LICENSE">LICENSE</a> for details.</p>
<p dir="auto">Contributions, bug reports, and pull requests are welcome; please follow the repository&#39;s CONTRIBUTING guidelines.</p>
</article></div></div>
  </body>
</html>
