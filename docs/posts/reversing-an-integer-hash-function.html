<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://taxicat1.github.io/hash6432shift_inversion.html">Original</a>
    <h1>Reversing an integer hash function</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      
      

      






<p>This is an integer hash function <a href="https://gist.github.com/badboy/6267743">written by Thomas Wang</a>:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>hash6432shift</span><span>(</span><span>uint64_t</span> <span>key</span><span>)</span> <span>{</span>
    <span>key</span> <span>=</span> <span>(</span><span>~</span><span>key</span><span>)</span> <span>+</span> <span>(</span><span>key</span> <span>&lt;&lt;</span> <span>18</span><span>);</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>31</span><span>;</span>
    <span>key</span> <span>*=</span> <span>21</span><span>;</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>11</span><span>;</span>
    <span>key</span> <span>+=</span> <span>key</span> <span>&lt;&lt;</span> <span>6</span><span>;</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>22</span><span>;</span>
    <span>return</span> <span>0xFFFFFFFF</span> <span>&amp;</span> <span>key</span><span>;</span>
<span>}</span></code></pre></figure>

<p>It hashes down a 64-bit input to a 32-bit output. It has good mixing: basic statistical analysis can show that it has reasonably good avalanche effect if lacking in bit independence (certain pairs of bits of the output like to flip at the same time when the input changes in a specific way, in some cases more than 99% of the time). However this hash function has a more glaring flaw which is the lack of fan-out.</p>

<p>Fan-out is necessary for a hash algorithm, otherwise you could simply trace backwards and generate an input that produces a specific hash (this is called a preimage). To visualize fan-out, imagine a hash function $H$ that uses three smaller independent functions $A$, $B$, and $C$ to produce a hash like so:</p><p>

\[H(i) = A(i) + B(i) + C(i)\]

</p><p>If an attacker wanted to manipulate the output value $H(i)$, they may start by tweaking $i$ to output a specific value in $A(i)$. However in doing so $B(i)$ and $C(i)$ now also produce different values. It is very difficult to control the outputs of all three of these functions at once (unless perhaps they are not so independent). The input value has “fanned out” into several functions, which come together at the end.</p>

<p>A common pattern is to use some invertible convolution $C$ and compute $C(i) + i$. This way, reversing the algorithm requires first taking a guess at what $i$ may have been, then calculating $C^{-1}(h - i)$ for the given output $h$. This value then must match the guessed $i$, but it all likelihood it will not. Algorithms like MD5, SHA1 and SHA2, and Salsa20/ChaCha20 use this pattern.</p>

<p>In this algorithm, the input value is only used once; it therefore can be traced backwards from the output without any issues. The only thing needed is to take a guess at what the 32 bits truncated at the last step may have been. Conveniently, each of the steps taken to mix the input are fully invertible, and so <em>every single output hash</em> coupled with <em>all possible truncated bits</em> can each be traced back to a <em>single</em> valid preimage.</p>

<p>In this article we will step through the process of writing an inversion of this hash function capable of generating preimages extremely quickly.</p>

<h2 id="inverting-xor-s-of-shifts">Inverting xor-s of shifts</h2>
<p>So let’s look at the next line before the truncation:</p>

<figure><pre><code data-lang="c"><span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>22</span><span>;</span></code></pre></figure>

<p>Looking at it, we can see that the uppermost 22 bits of <code>key</code> are unaffected by the operation. Consider a visualization of a simpler example, say <code>x ^ (x &gt;&gt; 7)</code> for some 16-bit wide string <code>x</code>:</p>

<div><div><pre><code>  1011101011010010  - Some input value
^        101110101  - Shifted right by 7
 -----------------
  1011101110100111  - Output value
  *******  - Unaffected bits
</code></pre></div></div>

<p>Therefore, those upper 22 bits can be xor-ed against bits 22-44 to obtain another group of 22 bits (remember xor is its own inverse). And then those 44 bits can be xor-ed against the next bits, and so on to the end of any length bitstring with any right shift amount. In the simpler example:</p>

<div><div><pre><code>  1011101110100111
^        1011101    - Upper bits shifted right
  -----------------
  10111010110100    - Now 14 bits recovered


  1011101110100111
^        101110101  - Known 14 bits shifted right
  -----------------
  1011101011010010  - Fully recovered input!
</code></pre></div></div>

<p>This also works when you try to analyze it algebraically. Let’s say instead of <code>key = key ^ (key &gt;&gt; a)</code>, we create a new variable key2 and <code>key2 = key ^ (key &gt;&gt; a)</code>, to make it easier to see what’s going on, using $\oplus$ to denote xor:</p><p>

\[k_2 = k_1 \oplus (k_1 \gg a)\]

</p><p>In order to invert this, we must remove the $k_1 \gg a$ term by xor-ing it again. So, since $k_2$ contains a $k_1$ term:</p><p>

\[k_3 = k_2 \oplus (k_2 \gg a)\]

</p><p>This works because shifts (in either direction) distribute with xor:</p><p>

\[(x \oplus y) \gg a = (x \gg a) \oplus (y \gg a)\]

</p><p>Or visually with some 8-bit strings:</p>

<div><div><pre><code> - Xor then shift    - Shift then xor
    10011010            100110(10)
  ^ 01111001          ^ 011110(01)
    --------            ------
    11100011            111000
        &gt;&gt; 2
    --------
      111000(11)
</code></pre></div></div>

<p>Now we have xor-ed another copy of $k_1 \gg a$ against the xor-sum. This can be seen by substituting $k_2$ for its value as defined in terms of $k_1$:</p><p>

\[\begin{align*}
k_3 &amp;= k_2 \oplus (k_2 \gg a)\\
    &amp;= k_1 \oplus (k_1 \gg a) \oplus ((k_1 \oplus (k_1 \gg a)) \gg a)\\
    &amp;= k_1 \oplus (k_1 \gg a) \oplus (k_1 \gg a) \oplus (k_1 \gg 2a)\\
    &amp;= k_1 \oplus (k_1 \gg 2a)
\end{align*}\]

</p><p>However now we have added another term to the sum, but with a doubled shift amount. This is good, though, as this process can be repeated until the shift amount exceeds the width of the bitstring, at which point the extra xor-ed term becomes zero. That is, for a 16-bit string, a shift of 16 or greater results in a value of zero regardless of the input.</p>

<p>We can try this in code and see that it works:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>k</span> <span>=</span> <span>0xdeadbeef</span><span>;</span>

<span>/* Forwards */</span>
<span>k</span> <span>^=</span> <span>k</span> <span>&gt;&gt;</span> <span>3</span><span>;</span>

<span>/* Backwards */</span>
<span>k</span> <span>^=</span> <span>k</span> <span>&gt;&gt;</span> <span>3</span><span>;</span> <span>// Starting at 3 and doubling each time
</span>
<span>k</span> <span>^=</span> <span>k</span> <span>&gt;&gt;</span> <span>6</span><span>;</span>
<span>k</span> <span>^=</span> <span>k</span> <span>&gt;&gt;</span> <span>12</span><span>;</span>
<span>k</span> <span>^=</span> <span>k</span> <span>&gt;&gt;</span> <span>24</span><span>;</span>
<span>//k ^= k &gt;&gt; 48; // We can stop, 48 is larger than the width of 32
</span>

<span>printf</span><span>(</span><span>&#34;%08x</span><span>\n</span><span>&#34;</span><span>,</span> <span>k</span><span>);</span> <span>// deadbeef !</span></code></pre></figure>

<p>This method can be applied to all of the lines of the function that xor shifts:</p>

<figure><pre><code data-lang="c"><span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>31</span><span>;</span>
<span>...</span>
<span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>11</span><span>;</span>
<span>...</span>
<span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>22</span><span>;</span></code></pre></figure>

<p>Although the function only uses xor with right shifts, this same method works just the same for left shifts. Consider reversing the order of the bits of a string, then xor-ing a right shift, and then restoring the original order. Since xor has no borrow or carry out, it is agnostic to shift direction.</p>

<h2 id="inverting-addition-of-shifts">Inverting addition of shifts</h2>
<p>The xor method does not extend to addition (or subtraction) of a right shift. Something like <code>k += (k &gt;&gt; 7)</code> is not invertible, because it’s not even bijective.</p>

<p>This makes sense, because in this context a right shift is equivalent to taking the floor of a division by a power of 2, which of course does not distribute over addition:</p><p>

\[\begin{align*}
\left\lfloor \frac{3}{4} \right\rfloor + \left\lfloor \frac{2}{4} \right\rfloor &amp;= 0 + 0 &amp;= 0\\
\left\lfloor \frac{3 + 2}{4} \right\rfloor &amp;= \left\lfloor \frac{5}{4} \right\rfloor &amp;= 1
\end{align*}\]

</p><p>More practically, addition can be viewed as just xor with carry out. So looking at a particular example of 8-bit <code>k + (k &gt;&gt; 4)</code> :</p>

<div><div><pre><code>   11111111
+      1111
   --------
   00001110
</code></pre></div></div>

<p>If we try to do the same trick of extracting the upper 4 bits, assuming they have not been touched by the operation, we find that it is possible for the carry out of the addition to flip bits there. Given only <code>00001110</code> as the output value, we could assume that the upper 4 bits are either <code>0000</code> or
<code>1111</code>, since 1 could’ve been added from the carry out of the addition to the lower bits. We can then subtract this upper half from the lower half to recover it, and:</p>

<div><div><pre><code>   00001110        00001110
 -     1111       -    0000
   --------        --------
   11111111        00001110
</code></pre></div></div>

<p>We now get two different answers. Which is the correct one? When you compute <code>k + (k &gt;&gt; 4)</code> for each of those answers:</p>

<div><div><pre><code>   11111111        00001110
+      1111      +     0000
   --------        --------
   00001110        00001110
</code></pre></div></div>

<p>They’re both correct. This is not always the case, but this function is no longer one-to-one and so this operation is not (or at least shouldn’t be) commonly included in algorithms as it will pigeonhole the value passing through it. In this specific operation, 15 outputs can be produced by two different inputs, and correspondingly 15 other outputs cannot be produced no matter what the input.</p>

<p>However, <em>left</em> shifts do distribute, being equivalent to multiplication of $2^a$ for shift amount $a$, modulo $2^N$. As seen in this next line from the initial hashing function:</p>

<figure><pre><code data-lang="c"><span>key</span> <span>+=</span> <span>key</span> <span>&lt;&lt;</span> <span>6</span><span>;</span></code></pre></figure>

<p>This can be modeled algebraically in the same way:</p><p>

\[k_2 = k_1 + (k_1 \ll 6)\]

</p><p>We now must subtract the $k_1 \ll 6$ term to remove it from the sum, so:</p><p>

\[k_3 = k_2 - (k_2 \ll 6)\]

</p><p>And substituting the value for $k_2$:</p><p>

\[\begin{align*}
k_3 &amp;= k_2 - (k_2 \ll 6)\\
    &amp;= k_1 + (k_1 \ll 6) - ((k_1 + (k_1 \ll 6)) \ll 6)\\
    &amp;= k_1 + (k_1 \ll 6) - (k_1 \ll 6) - (k_1 \ll 12)\\
    &amp;= k_1 - (k_1 \ll 12)
\end{align*}\]

</p><p>As a side effect of the subtraction, the negative distributes and we now are
left with a subtraction of a doubled shift amount at the end.</p>

<p>When this operation is repeated to remove it, we switch to adding again:</p><p>

\[\begin{align*}
k_4 &amp;= k_3 + (k_3 \ll 12)\\
    &amp;= k_1 - (k_1 \ll 12) + ((k_1 - (k_1 \ll 12)) \ll 12)\\
    &amp;= k_1 - (k_1 \ll 12) + (k_1 \ll 12) - (k_1 \ll 24)\\
    &amp;= k_1 - (k_1 \ll 24)
\end{align*}\]

</p><p>The remaining term remains negative from here, having been propagated down from
the initial subtraction. As earlier, we continue doing this until the magnitude of the shift exceeds the bitwidth of <code>k</code>, and thus the value being shifted becomes zero. Doing this in code:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>k</span> <span>=</span> <span>0xdeadbeef</span><span>;</span>

<span>/* Forwards */</span>
<span>k</span> <span>+=</span> <span>k</span> <span>&lt;&lt;</span> <span>3</span><span>;</span>

<span>/* Backwards */</span>
<span>k</span> <span>-=</span> <span>k</span> <span>&lt;&lt;</span> <span>3</span><span>;</span> <span>// Starting at subtracting 3 and doubling each time
</span>
<span>k</span> <span>+=</span> <span>k</span> <span>&lt;&lt;</span> <span>6</span><span>;</span> <span>// Adding going forward
</span>
<span>k</span> <span>+=</span> <span>k</span> <span>&lt;&lt;</span> <span>12</span><span>;</span>
<span>k</span> <span>+=</span> <span>k</span> <span>&lt;&lt;</span> <span>24</span><span>;</span>

<span>printf</span><span>(</span><span>&#34;%08x</span><span>\n</span><span>&#34;</span><span>,</span> <span>k</span><span>);</span> <span>// deadbeef !</span></code></pre></figure>

<p>This also works the same for subtraction of a left shift, where the subtraction itself propagates through the iterations:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>k</span> <span>=</span> <span>0xdeadbeef</span><span>;</span>

<span>/* Forwards */</span>
<span>k</span> <span>-=</span> <span>k</span> <span>&lt;&lt;</span> <span>3</span><span>;</span>

<span>/* Backwards */</span>
<span>k</span> <span>+=</span> <span>k</span> <span>&lt;&lt;</span> <span>3</span><span>;</span> <span>// Starting at adding 3 and doubling each time
</span>
<span>k</span> <span>+=</span> <span>k</span> <span>&lt;&lt;</span> <span>6</span><span>;</span>
<span>k</span> <span>+=</span> <span>k</span> <span>&lt;&lt;</span> <span>12</span><span>;</span>
<span>k</span> <span>+=</span> <span>k</span> <span>&lt;&lt;</span> <span>24</span><span>;</span>

<span>printf</span><span>(</span><span>&#34;%08x</span><span>\n</span><span>&#34;</span><span>,</span> <span>k</span><span>);</span> <span>// deadbeef !</span></code></pre></figure>

<p>However, since a left shift is multiplication modulo $2^N$, we can instead invert this by multiplying by the multiplicative inverse, modulo $2^N$:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>k</span> <span>=</span> <span>0xdeadbeef</span><span>;</span>

<span>/* Forwards */</span>
<span>k</span> <span>+=</span> <span>k</span> <span>&lt;&lt;</span> <span>3</span><span>;</span> <span>// Same k += 8 * k, so same as k *= 9
</span>

<span>/* Backwards  */</span>
<span>k</span> <span>*=</span> <span>954437177</span><span>;</span> <span>// Inverse of 9 modulo 2^32
</span>

<span>printf</span><span>(</span><span>&#34;%08x</span><span>\n</span><span>&#34;</span><span>,</span> <span>k</span><span>);</span> <span>// deadbeef !</span></code></pre></figure>

<p>And of course this also works the same for subtraction of a left shift, where <code>k - (k &lt;&lt; 3)</code> is equal to <code>k * -7</code>:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>k</span> <span>=</span> <span>0xdeadbeef</span><span>;</span>

<span>/* Forwards */</span>
<span>k</span> <span>-=</span> <span>k</span> <span>&lt;&lt;</span> <span>3</span><span>;</span> <span>// Same as k *= -7 (= 2^32 - 7)
</span>

<span>/* Backwards */</span>
<span>k</span> <span>*=</span> <span>1227133513</span><span>;</span> <span>// Inverse of 2^32 - 7 modulo 2^32
</span>

<span>printf</span><span>(</span><span>&#34;%08x</span><span>\n</span><span>&#34;</span><span>,</span> <span>k</span><span>);</span> <span>// deadbeef !</span></code></pre></figure>

<p>At this point I have to say thanks to <a href="https://planetcalc.com/3298/">this extended Euclidean algorithm calculator</a> which happily deals with numbers exceeding $2^{64}$ and I used for every multiplicative inverse here.</p>

<p>Note that to have a multiplicative inverse modulo $2^N$, the multiplier number must be coprime with $2^N$— that is, odd. For <code>k += k &lt;&lt; a</code> and <code>k -= k &lt;&lt; a</code> this is always the case, as the initial <code>k</code> is adding or subtracting 1 to the multiplier of $2^a$. Multiplying by an even number would be written as such with shifts:</p>

<figure><pre><code data-lang="c"><span>/* REPLACING k here, not adding to it */</span>
<span>k</span> <span>=</span> <span>k</span> <span>&lt;&lt;</span> <span>2</span><span>;</span>               <span>// k *= 4
</span>
<span>k</span> <span>=</span> <span>(</span><span>k</span> <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>+</span> <span>(</span><span>k</span> <span>&lt;&lt;</span> <span>3</span><span>);</span>  <span>// k *= 10
</span>
<span>k</span> <span>=</span> <span>0</span> <span>-</span> <span>(</span><span>k</span> <span>&lt;&lt;</span> <span>4</span><span>);</span>         <span>// k *= -16</span></code></pre></figure>

<p>This is obviously uninvertible because the shifts remove bits with no trace of the original <code>k</code> value. For instance an 8-bit <code>k</code> value of <code>10001100</code> when replaced with a left shift of itself deletes the high bit, and has the same result as shifting the value <code>00001100</code>.</p>
<h2 id="code-so-far">Code so far</h2>
<p>Looking back at the original hash function, it’s clear how to proceed with inverting most of it:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>hash6432shift</span><span>(</span><span>uint64_t</span> <span>key</span><span>)</span> <span>{</span>
    <span>key</span> <span>=</span> <span>(</span><span>~</span><span>key</span><span>)</span> <span>+</span> <span>(</span><span>key</span> <span>&lt;&lt;</span> <span>18</span><span>);</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>31</span><span>;</span>
    <span>key</span> <span>*=</span> <span>21</span><span>;</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>11</span><span>;</span>
    <span>key</span> <span>+=</span> <span>key</span> <span>&lt;&lt;</span> <span>6</span><span>;</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>22</span><span>;</span>
    <span>return</span> <span>0xFFFFFFFF</span> <span>&amp;</span> <span>key</span><span>;</span>
<span>}</span></code></pre></figure>

<p>Our code so far might look like this:</p>

<figure><pre><code data-lang="c"><span>uint64_t</span> <span>inv_hash6432shift</span><span>(</span><span>uint32_t</span> <span>hash</span><span>,</span> <span>uint32_t</span> <span>trunc</span><span>)</span> <span>{</span>
    <span>/* Invert: 0xFFFFFFFF &amp; key */</span>
    <span>uint64_t</span> <span>key</span> <span>=</span> <span>hash</span> <span>|</span> <span>((</span><span>uint64_t</span><span>)</span><span>trunc</span> <span>&lt;&lt;</span> <span>32</span><span>);</span>
    
    <span>/* Invert: key ^= key &gt;&gt; 22 */</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>22</span><span>;</span> <span>// Starting at 22 and doubling
</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>44</span><span>;</span>
    
    <span>/* Invert: key += key &lt;&lt; 6 (key *= 65) */</span>
    <span>key</span> <span>*=</span> <span>1135184250689818600U</span><span>;</span> <span>// Inverse of 65 modulo 2^64
</span>
    
    <span>/* Invert: key ^= key &gt;&gt; 11 */</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>11</span><span>;</span> <span>// Starting at 11 and doubling
</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>22</span><span>;</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>44</span><span>;</span>
    
    <span>/* Invert: key *= 21 */</span>
    <span>key</span> <span>*=</span> <span>14933078535860113000U</span><span>;</span> <span>// Inverse of 21 modulo 2^64
</span>
    
    <span>/* Invert: key ^= key &gt;&gt; 31 */</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>31</span><span>;</span> <span>// Starting at 31 and doubling
</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>62</span><span>;</span>
    
    <span>/* Invert: key = (~key) + (key &lt;&lt; 18) */</span>
    <span>// ... ?
</span>
    
    <span>return</span> <span>key</span><span>;</span>
<span>}</span></code></pre></figure>

<h2 id="inverting-addition-to-complement">Inverting addition to complement</h2>
<p>The last thing to do is invert the addition of a left shift to the complement. This is a bit tricky, now we have two transformations of the data instead of one. Intuitively complementing does not  distribute with addition like it does with xor, because it changes where the carry-outs are occurring.</p>

<p>However, we can still do the trick of looking at the least significant 18 bits, which are unaffected by the entire operation. If we complement these bits, then subtract them from the next 18 bits, and then complement the result, we can extract another 18 bits, and then repeat this process until the entire input is recovered.</p>

<p>Looking at a simpler example of 8-bit <code>k = ~k + &lt;&lt; 3</code>:</p>

<div><div><pre><code>- Forward:

   11010100  - Input value
   
   00101011  - Complement of input
 + 10100     - Input shifted left
   --------
   11001011  - Output value
        ***  - Unaffected bits


- Reverse:
   - First iteration:
   
   11001011  - Output value
 -   100     - Subtract complement of lowest 3 bits, shifted left
   --------
 ~ 10101011  - Undo complement of input
   01010100
     ******  - Correct input bits

   - Second iteration:
 
   11001011  - Output value
 - 10100     - Subtract known 6 bits, shifted left
   --------
 ~ 00101011  - Undo complement of input
   11010100  - Recovered input value!
</code></pre></div></div>

<p>This must be done in pieces while slowly assembling the original input, because otherwise the partial subtraction could cause borrowing in upper bits that could taint them for later iterations.</p>

<p>The code to do this might look like this:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>k</span> <span>=</span> <span>0xdeadbeef</span><span>;</span>

<span>/* Forwards */</span>
<span>k</span> <span>=</span> <span>~</span><span>k</span> <span>+</span> <span>(</span><span>k</span> <span>&lt;&lt;</span> <span>9</span><span>);</span>

<span>/* Backwards */</span>
<span>uint32_t</span> <span>ktmp</span> <span>=</span> <span>0</span><span>;</span> <span>// Temp variable to hold build-up of bits
</span>
<span>ktmp</span> <span>=</span> <span>~</span><span>(</span><span>k</span> <span>-</span> <span>(</span><span>ktmp</span> <span>&lt;&lt;</span> <span>9</span><span>));</span> <span>// Must run ceil(32/9) = 4 iterations
</span>
<span>ktmp</span> <span>=</span> <span>~</span><span>(</span><span>k</span> <span>-</span> <span>(</span><span>ktmp</span> <span>&lt;&lt;</span> <span>9</span><span>));</span>
<span>ktmp</span> <span>=</span> <span>~</span><span>(</span><span>k</span> <span>-</span> <span>(</span><span>ktmp</span> <span>&lt;&lt;</span> <span>9</span><span>));</span>
<span>ktmp</span> <span>=</span> <span>~</span><span>(</span><span>k</span> <span>-</span> <span>(</span><span>ktmp</span> <span>&lt;&lt;</span> <span>9</span><span>));</span>
<span>k</span> <span>=</span> <span>ktmp</span><span>;</span>

<span>printf</span><span>(</span><span>&#34;%08x</span><span>\n</span><span>&#34;</span><span>,</span> <span>k</span><span>);</span> <span>// deadbeef !</span></code></pre></figure>

<p>This also works just the same for subtraction by changing to adding in the iterations:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>k</span> <span>=</span> <span>0xdeadbeef</span><span>;</span>

<span>/* Forwards */</span>
<span>k</span> <span>=</span> <span>~</span><span>k</span> <span>-</span> <span>(</span><span>k</span> <span>&lt;&lt;</span> <span>9</span><span>);</span>

<span>/* Backwards */</span>
<span>uint32_t</span> <span>ktmp</span> <span>=</span> <span>0</span><span>;</span> <span>// Temp variable to hold build-up of bits
</span>
<span>ktmp</span> <span>=</span> <span>~</span><span>(</span><span>k</span> <span>+</span> <span>(</span><span>ktmp</span> <span>&lt;&lt;</span> <span>9</span><span>));</span> <span>// Must run ceil(32/9) = 4 iterations
</span>
<span>ktmp</span> <span>=</span> <span>~</span><span>(</span><span>k</span> <span>+</span> <span>(</span><span>ktmp</span> <span>&lt;&lt;</span> <span>9</span><span>));</span>
<span>ktmp</span> <span>=</span> <span>~</span><span>(</span><span>k</span> <span>+</span> <span>(</span><span>ktmp</span> <span>&lt;&lt;</span> <span>9</span><span>));</span>
<span>ktmp</span> <span>=</span> <span>~</span><span>(</span><span>k</span> <span>+</span> <span>(</span><span>ktmp</span> <span>&lt;&lt;</span> <span>9</span><span>));</span>
<span>k</span> <span>=</span> <span>ktmp</span><span>;</span>

<span>printf</span><span>(</span><span>&#34;%08x</span><span>\n</span><span>&#34;</span><span>,</span> <span>k</span><span>);</span> <span>// deadbeef !</span></code></pre></figure>

<p>Printing the value of <code>ktmp</code> after each iteration shows how it is extracting bits in groups of 9:</p>

<pre>00000000  00000000000000000000000000000000
832fe0ef  10000011001011111110000<span>011101111</span>
e2f1beef  11100010111100<span>011011111011101111</span>
66adbeef  01100<span>110101011011011111011101111</span>
deadbeef  <span>11011110101011011011111011101111</span>
</pre>

<p>The bits higher than the ones extracted so far are essentially garbage from the previous iteration being incorrect, and can be ignored. These bits could be masked out at each iteration, but it’s equally correct to just ignore them.</p>

<p>Another interesting thing about this solution is the initialization to 0 is not necessary. What is happening here is 0 correct bits are turned into 9, which are then turned into 18, and then into 27, and finally into all 32. Because of the left shift, we know that the rightmost 9 bits are 0 and so each iteration “corrects” 9 bits of ktmp which is a “guess” as to the input. Picking any other
value for the initialization changes only the garbage data:</p>

<pre>abcdef97  10101011110011011110111110010111
1f0f0eef  00011111000011110000111<span>011101111</span>
a14dbeef  10100001010011<span>011011111011101111</span>
1eadbeef  00011<span>110101011011011111011101111</span>
deadbeef  <span>11011110101011011011111011101111</span>
</pre>

<p>Should some of the bits of the “guess” in ktmp already be correct, even fewer iterations are needed:</p>

<pre>0000beef  0000000000000000<span>1011111011101111</span>
84adbeef  1000010<span>0101011011011111011101111</span>
deadbeef  <span>11011110101011011011111011101111</span>
deadbeef  <span>11011110101011011011111011101111</span>
deadbeef  <span>11011110101011011011111011101111</span>
</pre>

<p>Despite how interesting this solution is, like before with multiplicative inverses, it’s simpler to just solve this mathematically. Note that:</p><p>

\[\overline{x} = -x - 1\]

</p><p>Where here $\overline{x}$ denotes C <code>~x</code> and for unsigned values $-x$ means multiplying $x$ by $2^N - 1$ for bit width $N$. This is true for unsigned integers as well as two’s complement signed ones, where most people would be familiar with this equation.</p>

<p>Substituted into the full line:</p><p>

\[\begin{align*}
key &amp;= \overline{key} + (key \ll 18)\\
    &amp;= -key - 1 + (key * 2^{18})\\
    &amp;= key * \left(2^{18} - 1\right) - 1
\end{align*}\]

</p><p>So while complementing as a black box does not distribute with addition, all that needs to be done to resolve this is to add one. Then what is necessary for the code is:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>k</span> <span>=</span> <span>0xdeadbeef</span><span>;</span>

<span>/* Forwards */</span>
<span>k</span> <span>=</span> <span>~</span><span>k</span> <span>+</span> <span>(</span><span>k</span> <span>&lt;&lt;</span> <span>9</span><span>);</span> <span>// Same as k = (k * ((1&lt;&lt;9) - 1)) - 1
</span>

<span>/* Backwards */</span>
<span>k</span><span>++</span><span>;</span>
<span>k</span> <span>*=</span> <span>4160486911</span><span>;</span> <span>// Inverse of 2^9 - 1 modulo 2^32
</span>

<span>printf</span><span>(</span><span>&#34;%08x</span><span>\n</span><span>&#34;</span><span>,</span> <span>k</span><span>);</span> <span>// deadbeef !</span></code></pre></figure>

<p>Likewise with subtraction, where the multiplier becomes $-(2^a + 1)$:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>k</span> <span>=</span> <span>0xdeadbeef</span><span>;</span>

<span>/* Forwards */</span>
<span>k</span> <span>=</span> <span>~</span><span>k</span> <span>-</span> <span>(</span><span>k</span> <span>&lt;&lt;</span> <span>9</span><span>);</span> <span>// Same as k = (k * -1 * ((1&lt;&lt;9) + 1)) - 1
</span>

<span>/* Backwards */</span>
<span>k</span><span>++</span><span>;</span>
<span>k</span> <span>*=</span> <span>133956095</span><span>;</span> <span>// Inverse of -(2^9 + 1) modulo 2^32
</span>

<span>printf</span><span>(</span><span>&#34;%08x</span><span>\n</span><span>&#34;</span><span>,</span> <span>k</span><span>);</span> <span>// deadbeef !</span></code></pre></figure>

<p>The clever bit-extracting solution is not necessary for xor-ing shifts against the complement, either. Complements do distribute with xor, so all that is needed is to re-flip the complemented bits, and then proceed as normal with shift inversion, like so:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>k</span> <span>=</span> <span>0xdeadbeef</span><span>;</span>
    
<span>/* Forward */</span>
<span>k</span> <span>=</span> <span>~</span><span>k</span> <span>^</span> <span>(</span><span>k</span> <span>&lt;&lt;</span> <span>9</span><span>);</span>

<span>/* Reverse */</span>
<span>k</span> <span>^=</span> <span>0xfffffe00</span><span>;</span> <span>// All bits high except lowest 9
</span>
<span>k</span> <span>^=</span> <span>k</span> <span>&lt;&lt;</span> <span>9</span><span>;</span>     <span>// Starting at 9 and doubling
</span>
<span>k</span> <span>^=</span> <span>k</span> <span>&lt;&lt;</span> <span>18</span><span>;</span>
<span>k</span> <span>=</span> <span>~</span><span>k</span><span>;</span>          <span>// Recomplement to get original k
</span>

<span>printf</span><span>(</span><span>&#34;%08x</span><span>\n</span><span>&#34;</span><span>,</span> <span>k</span><span>);</span> <span>// deadbeef !</span></code></pre></figure>

<h2 id="final-code">Final code</h2>
<p>And so the final inversion of the hash function is:</p>

<figure><pre><code data-lang="c"><span>uint64_t</span> <span>inv_hash6432shift</span><span>(</span><span>uint32_t</span> <span>hash</span><span>,</span> <span>uint32_t</span> <span>trunc</span><span>)</span> <span>{</span>
    <span>uint64_t</span> <span>key</span> <span>=</span> <span>hash</span> <span>|</span> <span>((</span><span>uint64_t</span><span>)</span><span>trunc</span> <span>&lt;&lt;</span> <span>32</span><span>);</span>
    
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>22</span><span>;</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>44</span><span>;</span>
    
    <span>key</span> <span>*=</span> <span>1135184250689818600U</span><span>;</span>
    
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>11</span><span>;</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>22</span><span>;</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>44</span><span>;</span>
    
    <span>key</span> <span>*=</span> <span>14933078535860113000U</span><span>;</span>
    
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>31</span><span>;</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>62</span><span>;</span>
    
    <span>key</span><span>++</span><span>;</span>
    <span>key</span> <span>*=</span> <span>18428729606480330751U</span><span>;</span>
    
    <span>return</span> <span>key</span><span>;</span>
<span>}</span></code></pre></figure>

<p>This code can churn through every single possible preimage for a given hash in about ~19 minutes. If you want to play with the C code, <a href="https://taxicat1.github.io/inv_hash6432shift.c">here is a download to the file</a>.</p>

<h2 id="improvements-to-the-function">Improvements to the function</h2>
<p>The original hash function could be improved drastically by applying the $C(i) + i$ structure mentioned at the start, like so:</p>

<figure><pre><code data-lang="c"><span>uint32_t</span> <span>hash6432shift</span><span>(</span><span>uint64_t</span> <span>key</span><span>)</span> <span>{</span>
    <span>uint64_t</span> <span>in</span> <span>=</span> <span>key</span><span>;</span>  <span>// Make a copy of the input
</span>
    
    <span>// Run the hash function as normal
</span>
    <span>key</span> <span>=</span> <span>(</span><span>~</span><span>key</span><span>)</span> <span>+</span> <span>(</span><span>key</span> <span>&lt;&lt;</span> <span>18</span><span>);</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>31</span><span>;</span>
    <span>key</span> <span>*=</span> <span>21</span><span>;</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>11</span><span>;</span>
    <span>key</span> <span>+=</span> <span>key</span> <span>&lt;&lt;</span> <span>6</span><span>;</span>
    <span>key</span> <span>^=</span> <span>key</span> <span>&gt;&gt;</span> <span>22</span><span>;</span> 
    
    <span>key</span> <span>+=</span> <span>in</span><span>;</span> <span>// Add the original input back to key
</span>
    
    <span>return</span> <span>0xFFFFFFFF</span> <span>&amp;</span> <span>key</span><span>;</span> <span>// Then finally truncate
</span>
<span>}</span></code></pre></figure>

<p>Just doing this modification I can no longer see an easy way (faster than $2^{32}$ work) to generate preimages and so this is “left as an exercise to the reader”.</p>

<h2 id="good-wikipedia-further-reading">Good Wikipedia further reading</h2>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/Hash_function">Hash functions</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Avalanche_effect">Avalanche effect and bit independence</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Xorshift">Xorshift generators</a></li>
</ul>


      
    </div></div>
  </body>
</html>
