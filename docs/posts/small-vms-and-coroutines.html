<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.dziban.net/coroutines/">Original</a>
    <h1>Small VMs and Coroutines</h1>
    
    <div id="readability-page-1" class="page"><div>

<article>
   
  <div>
<p>In this post I’ll talk about the implementation of the coroutine system in x64 asm for a game I’m writing.</p>
<p>(Disclaimer: I’m very new at x64 assembly programming, so I may be doing some very stupid things)</p>

<p>I’ve had this idea for a while of a programmable game. I’m not gonna go into details for now but the main idea
is a Real-time strategy game (RTS) where you can program every unit. The code of the units runs in a very simple
fantasy stack virtual machine, and every tick each unit gets to execute a certain amount of instructions</p>
<p>As this is an RTS, lots of units are running at the same time and so we need a way to efficiently run all of these
units at a speed reasonable for an interactive videogame (60fps). Some years ago I did some tests around this idea and the VMs
I came up with were underperforming messes of either rust or C. There was no way I could deliver the performance I
had in mind with that.</p>
<p>Recently while reading the first volume of <a href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html">The Art of Computer Programming</a>
I came across a section when Knuth implements coroutines in his MIX machine. And, while I had heard and used
coroutines informaly all the time in my career I had never seen it like this. For those who don’t know, a coroutine
is a kind of subroutine that can be suspended and resumed, they are like concurrent-less threads. Each coroutine
has it’s own stack and instruction pointer. You may have encountered asymmetrical coroutines in the form of python
generators for example. If you need more context please check the <a href="https://en.wikipedia.org/wiki/Coroutine">coroutine page at wikipedia</a></p>
<p>So I had two ideas at about the same time, convert the code of the Fantasy VM to x64 asm code and run to the code for the
unit VMs as tiny individual coroutines. This both avoids expensive thread context switches, and completely removes the need for
coordinating. I still have to run some benchmarks but I believe splitting the VMs by power (lots of small units in a thread,
some powerful units in another) may bring the best performance results. I may create a separate blogpost once I benchmark this
properly.</p>
<p>So let’s get started!</p>

<p>The first one seems very obvious in hindsight, why spend time implementing the VM when the CPU it is running on already
implements most of the things I want? With some simple macros I can even mostly feed the Fantasy ISA program into an assembler and it
will come out as expected.</p>
<p>Let’s work with a very reduced version of the VM instruction set, just three simple instructions:</p>
<table>
<thead>
<tr>
<th>Instr</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>PUSH</td>
<td>Push immediate to stack</td>
</tr>
<tr>
<td>ADD</td>
<td>Add the top two items of the stack. Place result on stack</td>
</tr>
<tr>
<td>JMP</td>
<td>Jump to label</td>
</tr>
</tbody>
</table>
<p>Let’s create a very dumb program with this:</p>
<div><pre tabindex="0"><code data-lang="ASM"><span><span>_co_start:
</span></span><span><span>	<span>PUSH</span> <span>0x01</span>
</span></span><span><span>loop:
</span></span><span><span>	<span>PUSH</span> <span>0x01</span>
</span></span><span><span>	<span>ADD</span>
</span></span><span><span>	<span>JMP</span> <span>loop</span>
</span></span></code></pre></div><p>It basically adds <code>0x01</code> constantly to a value on the stack, forever. It’s an infinite loop.</p>
<p>Now we can use an assembler with macro support to implement these operations in x64. I’ll be using <a href="https://flatassembler.net/">fasm</a> for this.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>macro</span> <span>JMP</span> <span>target</span> <span>{</span>
</span></span><span><span>	<span>inc</span> <span>rax</span>
</span></span><span><span>	<span>jmp</span> <span>target</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>macro</span> <span>ADD</span> <span>{</span>
</span></span><span><span>	<span>inc</span> <span>rax</span>
</span></span><span><span>	<span>pop</span> <span>WORD</span> <span>bx</span>
</span></span><span><span>	<span>add</span> <span>WORD</span> [<span>rsp</span>], <span>bx</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>macro</span> <span>PUSH</span> <span>number</span> <span>{</span>
</span></span><span><span>	<span>inc</span> <span>rax</span>
</span></span><span><span>	<span>push</span> <span>WORD</span> <span>number</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Several things to note, I’m using <code>inc rax</code> in every instruction because I want a way to know how many virtual instructions have executed in order
to impose limits on number of instructions per tick. <code>rax</code> holds this counter. <code>JMP</code> and <code>PUSH</code> are exactly the same instruction as the x64 counterpart, they map 1 to 1.
<code>ADD</code> is very simple as well: use <code>bx</code> as a temporary storage for the top value of the stack, add the top value of the stack with <code>bx</code> and store in
back to the top of the stack.</p>
<p>With these macros in place, passing the Fantasy ISA input to fasm already gives us a valid x64 program. The result of the macro expansion would look
like this:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span>_co_start:
</span></span><span><span>	<span>inc</span> <span>rax</span>
</span></span><span><span>	<span>push</span> <span>WORD</span> <span>0x01</span>
</span></span><span><span>loop:
</span></span><span><span>	<span>inc</span> <span>rax</span>
</span></span><span><span>	<span>push</span> <span>WORD</span> <span>0x01</span>
</span></span><span><span>	<span>inc</span> <span>rax</span>
</span></span><span><span>	<span>pop</span> <span>WORD</span> <span>bx</span>
</span></span><span><span>	<span>add</span> <span>WORD</span> [<span>rsp</span>], <span>bx</span>
</span></span><span><span>	<span>inc</span> <span>rax</span>
</span></span><span><span>	<span>jmp</span> <span>target</span>
</span></span></code></pre></div><p>In very few lines we have an assembler for our fantasy VM to native x64 code! Now, currently this will loop forever and we don’t want that, this is where
coroutines come and save the day.</p>

<p>How do we make sure that the unit vm only executes N instructions before it suspends itself? A pretty lightweight solution that requires very little setup
is to insert a check that we haven’t exceeded the number of operations every <code>K</code> ops and after every label (in the unit VM you can only jump to labels,
so we catch all loops, branches and sketchy stuff with this).</p>
<blockquote>
<p>I know that this doesn’t ensure that the VMs execute exactly N operations, but I think it is a pretty good tradeoff between code size, execution
overhead and constraining the number of ops. I’ll show one possible mitigation further down.</p>
</blockquote>
<p>So how do we implement these lightweight unit coroutines?</p>
<p>First we need to save several things per coroutine:</p>
<ul>
<li>current stack pointer (<code>rsp</code>)</li>
<li>current instruction pointer (<code>rip</code>)</li>
<li>current <code>rax</code> where we save the amount of instructions executed</li>
<li>current <code>rbx</code> that is used for some temporal values, this one is not strictly needed and there is a chance I remove it in the future</li>
</ul>
<p>Usually these things are saved in the stack with normal coroutines but we don’t want to taint the stack of the unit vms with unrelated data.
First because that means their stack gets reduced for reasons unrelated to their code, second because they may be able to manipulate the stack
to the point where they override the values, and then all hell breaks loose.</p>
<p>Let’s start with a simple example where we have 10 units, so let’s allocate 40 (4 fields * 10 coroutines) 64-bit values and 800 bytes of
total stack (80 per coroutine).</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>; co-routine data, 40 quad-word sized (8 bytes), zeroed buffer
</span></span></span><span><span><span></span>_co_data:	<span>dq</span> <span>40</span> <span>dup</span> <span>0</span>
</span></span><span><span>
</span></span><span><span>data_stack:
</span></span><span><span>	<span>; Allocate 400 word sized (2 bytes), zeroed buffer
</span></span></span><span><span><span></span>	<span>dw</span> <span>400</span> <span>dup</span> <span>0</span>
</span></span><span><span>end_data_stack:
</span></span></code></pre></div><p>and initialize the data in them:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span>_start:         <span>; Main VM start
</span></span></span><span><span><span></span>	<span>xor</span> <span>rax</span>, <span>rax</span>                <span>; Initialize rax to 0
</span></span></span><span><span><span></span>	<span>; Set rdx to the end of the stack, we will use this to 
</span></span></span><span><span><span></span>	<span>; assign stacks to each coroutine, we start from the end
</span></span></span><span><span><span></span>	<span>mov</span> <span>rdx</span>, <span>end_unit_stack</span>     
</span></span><span><span>	<span>; rcx will be the moving pointer through the _co_data 
</span></span></span><span><span><span></span>	<span>; structure as we save the data
</span></span></span><span><span><span></span>	<span>mov</span> <span>rcx</span>, <span>_co_data</span>           
</span></span><span><span>	<span>; Loop over all 10 coroutines to...
</span></span></span><span><span><span></span>init_co_loop:
</span></span><span><span>	<span>; Initialize the rsp
</span></span></span><span><span><span></span>	<span>mov</span> <span>QWORD</span> [<span>rcx</span>], <span>rdx</span>
</span></span><span><span>	<span>; Initialize the rip
</span></span></span><span><span><span></span>	<span>mov</span> <span>QWORD</span> [<span>rcx</span> <span>+</span> <span>24</span>], <span>_co_start</span>
</span></span><span><span>	<span>; Move to the next structure in _co_data
</span></span></span><span><span><span></span>	<span>add</span> <span>rcx</span>, <span>32</span>
</span></span><span><span>	<span>; Move back to the next coroutine start of the stack
</span></span></span><span><span><span></span>	<span>; Each coroutine in this example gets 80 bytes
</span></span></span><span><span><span></span>	<span>sub</span> <span>rdx</span>, <span>80</span>
</span></span><span><span>	<span>; Loop stuff
</span></span></span><span><span><span></span>	<span>inc</span> <span>rax</span>
</span></span><span><span>	<span>cmp</span> <span>rax</span>, <span>10</span>
</span></span><span><span>	<span>jl</span> <span>init_co_loop</span>
</span></span></code></pre></div><p>Now let’s loop over the coroutines, when we <code>yield</code> to the first one we will wait until it <code>yield</code>s control back to the main loop, then it will
continue on to the second, and so on. While you read the next code fragment, always keep in mind that all across the execution <em><code>rcx</code> always points to the
currently active coroutine data.</em></p>
<div><pre tabindex="0"><code data-lang="asm"><span><span>co_initialized:
</span></span><span><span>	<span>; i = 0
</span></span></span><span><span><span></span>	<span>xor</span> <span>rax</span>, <span>rax</span>
</span></span><span><span>	<span>; we will start with the first co-routine
</span></span></span><span><span><span></span>	<span>mov</span> <span>QWORD</span> <span>rcx</span>, <span>_co_data</span>
</span></span><span><span>_loop:
</span></span><span><span>	<span>; yield to the coroutine
</span></span></span><span><span><span></span>	<span>YIELD</span>
</span></span><span><span>	<span>; i += 1
</span></span></span><span><span><span></span>	<span>inc</span> <span>rax</span>
</span></span><span><span>	<span>; move onto the next coroutine
</span></span></span><span><span><span></span>	<span>add</span> <span>rcx</span>, <span>32</span>
</span></span><span><span>	<span>; Loop things
</span></span></span><span><span><span></span>	<span>cmp</span> <span>rax</span>, <span>10</span>
</span></span><span><span>	<span>jl</span> <span>_loop</span>
</span></span><span><span>	<span>jmp</span> <span>_exit</span>
</span></span></code></pre></div><p>Now all the magic seems to happen in this <code>YIELD</code> macro, let’s take a look:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>macro</span> <span>YIELD</span> <span>reset_rax</span> <span>{</span>
</span></span><span><span>	<span>; local turns these labels into local labels, so multiple uses of
</span></span></span><span><span><span></span>	<span>; YIELD don&#39;t create repeated labels.
</span></span></span><span><span><span></span>	<span>local</span> <span>next_inst</span>, <span>after_yield</span>
</span></span><span><span>	<span>; swap rsp, by the stored value in rsp (this means we just saved
</span></span></span><span><span><span></span>	<span>; the value of the main program rsp to the co_data structure pointed
</span></span></span><span><span><span></span>	<span>; by rcx)
</span></span></span><span><span><span></span>	<span>xchg</span> <span>rsp</span>, <span>QWORD</span> [<span>rcx</span>]
</span></span><span><span>	<span>; swap rax, same as above
</span></span></span><span><span><span></span>	<span>xchg</span> <span>rax</span>, <span>QWORD</span> [<span>rcx</span> <span>+</span> <span>8</span>]
</span></span><span><span>	<span>; swap rbx, same as above
</span></span></span><span><span><span></span>	<span>xchg</span> <span>rbx</span>, <span>QWORD</span> [<span>rcx</span> <span>+</span> <span>16</span>]
</span></span><span><span>	<span>; now we push onto the stack the instruction pointer for the coroutine
</span></span></span><span><span><span></span>	<span>; which will be used by the &#34;ret&#34; instruction further down
</span></span></span><span><span><span></span>	<span>push</span> <span>QWORD</span> [<span>rcx</span> <span>+</span> <span>24</span>]	
</span></span><span><span>	<span>; we call next_inst to get the instruction pointer of this coroutine.
</span></span></span><span><span><span></span>	<span>; We don&#39;t wanna return to the next &#34;pop&#34; so we will need to increment
</span></span></span><span><span><span></span>	<span>; this value so that a yield to this coroutine returns right after the
</span></span></span><span><span><span></span>	<span>; &#34;ret&#34;. The call will put this rip into the stack
</span></span></span><span><span><span></span>	<span>call</span> <span>next_inst</span>
</span></span><span><span>next_inst:
</span></span><span><span>	<span>; move the just save rip into the rip of the _co_data[coroutine_id]
</span></span></span><span><span><span></span>	<span>pop</span> <span>QWORD</span> [<span>rcx</span> <span>+</span> <span>24</span>]
</span></span><span><span>	<span>; increment it so a yield from the other coroutine continues from right
</span></span></span><span><span><span></span>	<span>; after the ret
</span></span></span><span><span><span></span>	<span>add</span> <span>QWORD</span> [<span>rcx</span> <span>+</span> <span>24</span>], (<span>after_yield</span> - <span>next_inst</span>)
</span></span><span><span>	<span>; jump, using the value pushed 4 instructions above, into the coroutine
</span></span></span><span><span><span></span>	<span>ret</span>
</span></span><span><span>after_yield:
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>There are probably some better ways to implement this, but this is what I came up with. Each call into a coroutine saves the main coroutine state
into the <code>_co_data</code> of the coroutine you <code>YIELD</code> into. Once <code>YIELD</code> is called from the other coroutine the same thing will happen, the values for
the main one will be restored and the execution will continue right after the <code>ret</code>. This works very well for our case of a main coroutine coordinating
other coroutines.</p>
<p>There is one last piece left, injecting some instructions to check if we’ve exhausted our instruction limit this tick. To do so I created this macro:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>macro</span> <span>CHECK_LIMITS</span> <span>{</span>
</span></span><span><span>	<span>local</span> <span>no_yield</span>
</span></span><span><span>	<span>; in this case the 15k instruction limit is hardcoded, it could
</span></span></span><span><span><span></span>	<span>; be passed as an argument to the macro as when you generate the
</span></span></span><span><span><span></span>	<span>; code, you can set a limit per unit depending on their virtual cpu
</span></span></span><span><span><span></span>	<span>cmp</span> <span>rax</span>, <span>15000</span>		
</span></span><span><span>	<span>jl</span> <span>no_yield</span>
</span></span><span><span>	<span>; If we are above, YIELD
</span></span></span><span><span><span></span>	<span>YIELD</span> 
</span></span><span><span>	<span>; Initialize rax to 0 to reset the counter, here is where the mitigation
</span></span></span><span><span><span></span>	<span>; that I talked about before could happen, here you could subtract by 15k
</span></span></span><span><span><span></span>	<span>; and you&#39;d compensate going over the instruction limit last iteration
</span></span></span><span><span><span></span>	<span>; by having less instructions this loop. This is still not perfect but I
</span></span></span><span><span><span></span>	<span>; think it&#39;s mostly fine. If people found a way to exploit this, I&#39;d
</span></span></span><span><span><span></span>	<span>; be happy to let them.
</span></span></span><span><span><span></span>	<span>xor</span> <span>rax</span>, <span>rax</span>
</span></span><span><span>no_yield:
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>and we can modify the original program like so:</p>
<div><pre tabindex="0"><code data-lang="ASM"><span><span>_co_start:
</span></span><span><span>	<span>PUSH</span> <span>0x01</span>
</span></span><span><span>loop:
</span></span><span><span>	<span>; On every loop start, check if we&#39;ve exceeded the max
</span></span></span><span><span><span></span>	<span>CHECK_LIMITS</span>
</span></span><span><span>	<span>PUSH</span> <span>0x01</span>
</span></span><span><span>	<span>ADD</span>
</span></span><span><span>	<span>JMP</span> <span>loop</span>
</span></span></code></pre></div>
<p>This coroutine implementation is very specific. For general purpose coroutines you’d have to save some more registers than <code>rip</code>, <code>rsp</code>, <code>rax</code> and <code>rbx</code>.
This works in this case because I’ve assigned a very specific meaning to each register that works all across the implementation, this allows for a smaller
and faster switching between coroutines than a general version.</p>
<p>Another thing is that right now this is very static, but I think it’s fairly simple to see how to make it dynamic on the number of coroutines and having
different starting labels for each coroutine.</p>
<p>Right now with the implementation I’ve shown there is no stack security to simplify the idea, but of course the <code>PUSH</code> and <code>POP</code> instructions should have
boundary checks.</p>
<p>Another point is that the <code>inc rax</code> for every operation may add too much overhead, another option that I need to explore is adding an <code>add rax, &lt;immediate&gt;</code>
right before any jump operation. I believe this should be enough to reduce the overhead and it should cover all cases but I need to investigate further.</p>

<p>Hope this was informative and clear, if you have any question or you wanna talk, please let me know at <code>marce [at] dziban.net</code>.</p>


  </div>

  
</article>
    </div></div>
  </body>
</html>
