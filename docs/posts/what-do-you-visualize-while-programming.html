<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dillonshook.com/what-do-you-visualize-while-programming/">Original</a>
    <h1>What do you visualize while programming?</h1>
    
    <div id="readability-page-1" class="page"><div data-pagefind-body=""><p>I’ve been thinking a bit about thinking while programming lately. A bit confusing I know, but hear me out.</p><p>Programming is one of the few occupations that occurs inside our heads so it’s a little funny we don’t talk more about what actually goes on inside those heads.</p><p>As a primer for the rest of the post, take 5 minutes to watch this video from Richard Feynman:</p><p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/Cj4y0EUlU-Y?si=uBbRryURKfVvpJG3&amp;start=48" title="YouTube video player"></iframe></p><blockquote><p>That’s where I discovered, at least in this very simple operation of counting, the great difference in what goes on in the head when people think they’re doing the same thing!</p><p>And so it struck me therefore if that’s already true at the most elementary level, that when we learn the mathematics and the Bessel functions and the exponentials and the electric fields and all these things, that the imageries and method by which we’re storing it all and the way we think about it could be really, if we could get into each other’s heads, entirely different.</p><p>And in fact why somebody sometimes has a great deal of difficulty understanding a point which you see as obvious and vice versa it may be because it’s a little hard to translate what you just said into his particular framework and so on.</p></blockquote><p>Hopefully that gets you thinking about what’s going on in your head while you’re working on a problem. There is a small chance you <a href="https://www.reddit.com/r/tifu/comments/c4i94n/tifu_by_explaining_my_synesthesia_to_my_boyfriend/?ref=dillonshook.com" target="_blank" rel="noopener">don’t visualize</a> <a href="https://www.reddit.com/r/tifu/comments/c4lzwm/tifu_by_reading_a_reddit_post_and_learning_that_i/?ref=dillonshook.com" target="_blank" rel="noopener">anything in your head</a> which is a condition called aphantasia. There’s a bit of confusion around what visualizing in your head actually means in those threads but here’s a <a href="https://youtu.be/RQbSQgfbwvg?t=113&amp;ref=dillonshook.com" target="_blank" rel="noopener">good explainer video on it.</a></p><p><img alt="Minds Eye" decoding="async" height="1196" loading="lazy" src="https://dillonshook.com/_astro/minds-eye.C35VDfZ2_Z1KUyj5.webp" width="1788"/></p><p>In a nutshell, when I’m visualizing something I’m seeing it in my mind’s eye inside my head and not actually seeing it with my eyes (or on the back of my eyelids as talked about in the video). It’s definitely connected to the brain’s visual system, but seemingly something along the lines of an <a href="https://en.wikipedia.org/wiki/Electromagnetic_induction?ref=dillonshook.com" target="_blank" rel="noopener">induced</a> noisy signal, versus a clear image perceived by the eyes with the direct optic nerve path. I don’t think this is unique to me but I can visualize while my eyes are open as long as there’s not too much visual stimulation.</p><p>Going back to the Feynman video though, I’m super curious what goes on in your head while programming and how it might be different than what happens in mine. I’m convinced that <strong>a big part of gaining (good) programming experience is developing the right mental models to visualize while problem solving.</strong></p><h2 id="context-matters">Context matters<a href="#context-matters"><span data-pagefind-ignore="">#</span></a></h2><p>What you’re seeing in your head is of course very dependent on the exact task at hand as well as the environment you’re in. Programming is not a monotonic activity. Working on an algorithm by yourself in an IDE is different than working collaboratively with a teammate on a system design at a whiteboard which is also different than designing a database schema in an interview. However, in all these cases having the right images in your head to guide you will help.</p><p>Hopefully in the process you can get the images out of your head and in front of your eyes to continue the process. I can only speak for myself here, but what I can visualize in my head is capped at about 4Mb of RAM. Anything too complex or detailed I need to get the first part out of my head into the world to look at so I can then visualize the next step and iterate.</p><p><strong>What I visualize is closely tied to the best UI or diagram I’ve found for each task</strong>. It’s like I can use the tool in my head to accomplish the task without actually looking at it.</p><h2 id="programming-task-visualizations">Programming Task Visualizations<a href="#programming-task-visualizations"><span data-pagefind-ignore="">#</span></a></h2><p>So to break it down more specifically I want you to think about what your ideal visualizations are for each of the different tasks here and then compare it to what I’ve found works best for me.</p><h3 id="1-systems-design">1. Systems Design<a href="#1-systems-design"><span data-pagefind-ignore="">#</span></a></h3><p>Let’s start with an easy warmup, designing a system with multiple components. The actual design might not be easy but the tools to visualize it should be. This is the classic “draw boxes on a whiteboard with arrows” trope of CS.</p><p><img alt="Systems Diagram" decoding="async" height="683" loading="lazy" src="https://dillonshook.com/_astro/system-diagram.BSA2Ider_Z2lY7MC.webp" width="1030"/></p><p>Start with by drawing/visualizing each component, then connect the ones that communicate with arrows, and finally layer on any groupings with surrounding boxes.</p><h3 id="2-designing-a-database-schema">2. Designing a Database Schema<a href="#2-designing-a-database-schema"><span data-pagefind-ignore="">#</span></a></h3><p>Similar to the systems design, the standard ER diagram is the go to here with the properties listed for each table and connected by their foreign key relationships.</p><p><img alt="Entity Relation Diagram" decoding="async" height="666" loading="lazy" src="https://dillonshook.com/_astro/er-diagram.CZeEPDeg_ZTvEUp.webp" width="1024"/></p><p>Tools like <a href="https://dbeaver.com/2022/06/30/two-ways-to-use-erd-in-dbeaver/?ref=dillonshook.com" target="_blank" rel="noopener">DBeaver</a> can also generate these diagrams for you.</p><h3 id="3-optimization">3. Optimization<a href="#3-optimization"><span data-pagefind-ignore="">#</span></a></h3><p>For anything execution related I would always like to start with a (distributed if needed) trace along the lines of how <a href="https://www.elastic.co/guide/en/observability/current/observability-introduction.html?ref=dillonshook.com" target="_blank" rel="noopener">Elastic APM</a> shows them.</p><p><img alt="APM Trace" decoding="async" height="1838" loading="lazy" src="https://dillonshook.com/_astro/apm-distributed-tracing.BXMrdeRZ_Z2oOceA.webp" width="2586"/></p><p>This makes it very easy to see in a glance what’s taking the most amount of time, if there’s a bunch of waterfall requests going on that need to be parallelized, and if there’s too much cross service chatter going on. <a href="https://brendangregg.com/flamegraphs.html?ref=dillonshook.com" target="_blank" rel="noopener">Flamegraphs</a> are also helpful for optimizing a single process but they really need to be zoomable and have colored groupings to be maximally useful.</p><p>For optimizing anything space related like memory usage or disk space a treemap is invaluable to quickly see what the biggest hogs are at multiple nesting levels.</p><p><img alt="Wiztree treemap" decoding="async" height="665" loading="lazy" src="https://dillonshook.com/_astro/wiztree-treemap.yHOOCCs0_Z25QNt3.webp" width="1197"/></p><h3 id="4-writing-an-algorithm">4. Writing an Algorithm<a href="#4-writing-an-algorithm"><span data-pagefind-ignore="">#</span></a></h3><p>When writing an algorithm working on a data structure I try to go step by step through the code an visualize the data at its current state as the code proceeds each line. This can easily exceed my working memory capacity though so if you don’t have access to a debugger to record the state at each step it’s a good idea to take notes.</p><p><img alt="Algorithm step by step" decoding="async" height="1006" loading="lazy" src="https://dillonshook.com/_astro/algorithm.DrFdHvZm_mvuFB.webp" width="2288"/></p><p>There’s also tools like <a href="https://pythontutor.com/render.html#mode=display?ref=dillonshook.com" target="_blank" rel="noopener">this code visualizer</a> where the image is from that let you step through code and see a visual representation of your data and the pointers to it.</p><h3 id="5-writing-a-recursive-function">5. Writing a Recursive Function<a href="#5-writing-a-recursive-function"><span data-pagefind-ignore="">#</span></a></h3><p>This specialized case of writing an algorithm benefits from using a bit of a different technique. In addition to the step by step visualization above you also need to keep track of the call stack as you recurse further and further. Before researching this article I used to a sort of stair stacking diagram with each level being an instance of the function with its state and the next recursive level on top of it. However after finding a few <a href="https://dmytrobaida.github.io/recursion-viewer/?ref=dillonshook.com" target="_blank" rel="noopener">recursion visualization tools online</a> I’m going to try and switch to the tree representation as my default.</p><p><img alt="Recursion tree" decoding="async" height="505" loading="lazy" src="https://dillonshook.com/_astro/recursion.vM5saoc7_1bUGBf.webp" width="1123"/></p><p>When reading and writing recursive algorithms it’s especially important to start by thinking through the easiest (base) cases first to understand the call flow before increasing the complexity of the example.</p><h2 id="bring-your-visualization-into-focus">Bring Your Visualization Into Focus<a href="#bring-your-visualization-into-focus"><span data-pagefind-ignore="">#</span></a></h2><p>When you’re just starting to learn programming you’ll likely be too focused on the minutia of fixing syntax errors, learning your editor, tools, and how computer languages work to really have much of a chance to visualize. But as you advance <strong>visualization is a great technique to improve your skills</strong>. Like any skill it takes time and effort to gain familiarity and proficiency, but you can improve by setting aside some time to introspect how the visualizations in your head can be optimized to help you think more clearly.</p><p>Since the main things I visualize are tools/UI’s/diagrams, the best way for me to improve a visualization is to research all the different tools and diagrams out there for a problem and get familiar with the one that resonates the most so it becomes the de facto image in my head for that particular problem.</p><p><strong>What other tools and diagrams do you know of that help you think in more efficient ways? Please let us all know in the comments!</strong></p><h2 id="additional-reading">Additional Reading<a href="#additional-reading"><span data-pagefind-ignore="">#</span></a></h2><p><a href="https://blog.sbensu.com/posts/demand-for-visual-programming/?ref=dillonshook.com" target="_blank" rel="noopener">Sebastian Bensusan: We need visual programming. No, not like that.</a></p><p><a href="https://alexanderell.is/posts/visualizing-code/?ref=dillonshook.com" target="_blank" rel="noopener">Alex Ellis: How do you visualize code?</a></p><p><a href="https://medium.com/la-vie-en-code/visualization-techniques-for-programmers-and-why-you-should-be-using-them-ed9cfba062da?ref=dillonshook.com" target="_blank" rel="noopener">Nicole Archambault: Visualization Techniques for Programmers (and Why You Should Be Using Them)</a></p><p><a href="https://worrydream.com/MediaForThinkingTheUnthinkable/?ref=dillonshook.com" target="_blank" rel="noopener">Bret Victor: Media for Thinking the Unthinkable</a></p><p><a href="https://www.youtube.com/watch?v=fnIFVYFspfc&amp;ref=dillonshook.com" target="_blank" rel="noopener">Eberhard Gräther: The Untapped Potential of Software Visualization</a></p></div><div><h3>Want the inside scoop?</h3><h4>Sign up and be the first to see new posts</h4><p>No spam, just the inside scoop and $10 off any <a href="https://dillonshook.com/photos/prints">photo print!</a></p></div></div>
  </body>
</html>
