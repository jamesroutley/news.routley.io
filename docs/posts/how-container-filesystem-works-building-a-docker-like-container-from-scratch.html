<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://labs.iximiuz.com/tutorials/container-filesystem-from-scratch">Original</a>
    <h1>How Container Filesystem Works: Building a Docker-Like Container from Scratch</h1>
    
    <div id="readability-page-1" class="page"><div data-v-feb472d7=""><!----><div data-v-feb472d7=""><div data-v-feb472d7=""><p data-v-f4353d2d=""><!--[-->One of the superpowers of containers is their isolated <strong data-v-849f2d6a=""><!--[-->filesystem view<!--]--></strong> -
from inside a container it can look like a full Linux distro, often different from the host.
Run <code data-v-e8db53fc=""><!--[-->docker run nginx<!--]--></code>, and Nginx lands in its familiar Debian userspace no matter what Linux flavor your host runs.
But how is that illusion built?<!--]--></p><p data-v-f4353d2d=""><!--[-->In this post, we&#39;ll assemble a tiny but realistic, Docker-like container using only stock Linux tools: <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code>, <code data-v-e8db53fc=""><!--[-->mount<!--]--></code>, and <code data-v-e8db53fc=""><!--[-->pivot_root<!--]--></code>.
No runtime magic and (almost) no cut corners.
Along the way, you&#39;ll see why the <strong data-v-849f2d6a=""><!--[-->mount namespace<!--]--></strong> is the bedrock of container isolation,
while other namespaces, such as <strong data-v-849f2d6a=""><!--[-->PID<!--]--></strong>, <strong data-v-849f2d6a=""><!--[-->cgroup<!--]--></strong>, <strong data-v-849f2d6a=""><!--[-->UTS<!--]--></strong>, and even <strong data-v-849f2d6a=""><!--[-->network<!--]--></strong>, play rather complementary roles.<!--]--></p><p data-v-f4353d2d=""><!--[-->By the end - especially if you pair this with the <a href="https://labs.iximiuz.com/tutorials/container-networking-from-scratch" rel="noopener noreferrer" target="_blank" data-v-6d75e4e7=""><!--[-->container networking tutorial<!--]--><!----></a> -
you&#39;ll be able to spin up fully featured, Docker-style containers using nothing but standard Linux commands.
The ultimate goal of every aspiring container guru.<!--]--></p><h2 id="prerequisites" data-v-2d6287ef=""><!--[-->Prerequisites<!--]--><!----></h2><ul data-v-80af725d=""><!--[--><li data-v-05c6bdd9=""><!--[-->Some prior familiarity with Docker (or Podman, or the like) containers<!--]--></li><li data-v-05c6bdd9=""><!--[-->Basic Linux knowledge (shell scripting, general namespace awareness)<!--]--></li><li data-v-05c6bdd9=""><!--[-->Filesystem fundamentals (single directory hierarchy, mount table, bind mount, etc.)<!--]--></li><!--]--></ul><h2 id="visualizing-the-end-result" data-v-2d6287ef=""><!--[-->Visualizing the end result<!--]--><!----></h2><p data-v-f4353d2d=""><!--[-->The diagram below shows what filesystem isolation looks like when Docker creates a new container.
It&#39;s all right if the drawing feels overwhelming.
With the help of the hands-on exercises in this tutorial,
we&#39;ll build a comprehensive mental model of how containers work,
so when we revisit the diagram in the closing section,
it&#39;ll look much more digestible.<!--]--></p><div><div><p><img src="https://labs.iximiuz.com/content/files/tutorials/container-filesystem-from-scratch/__static__/container-rootfs-full-rev2.png" alt="Container rootfs isolation is a collective work of several namespaces simultaneously: mount, PID, cgroup, UTS, and network (with the mount namespace laying the foundation)."/></p><!--[--><p data-v-f4353d2d=""><!--[--><i>Click to enlarge</i><!--]--></p><!--]--></div><!----></div><h2 id="what-exactly-does-mount-namespace-isolate" data-v-2d6287ef=""><!--[-->What exactly does Mount Namespace isolate?<!--]--><!----></h2><p data-v-f4353d2d=""><!--[-->Let&#39;s do a quick experiment.
In <span data-v-0921d991="">Terminal 1</span>, start a new shell session in its own mount namespace:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>sudo</span><span> unshare</span><span> --mount</span><span> bash
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Now in <span data-v-0921d991="">Terminal 2</span>, create a file somewhere on the host&#39;s filesystem:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>echo</span><span> &#34;Hello from host&#39;s mount namespace&#34;</span><span> |</span><span> sudo</span><span> tee</span><span> /opt/marker.txt
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Surprisingly or not, when you try locating this file in the newly created mount namespace using the <span data-v-0921d991="">Terminal 1</span> tab, it&#39;ll be there:<!--]--></p><p data-v-f4353d2d=""><!--[-->So what exactly did we just isolate with <code data-v-e8db53fc=""><!--[-->unshare --mount<!--]--></code>? ü§î<!--]--></p><p data-v-f4353d2d=""><!--[-->The answer is - a <strong data-v-849f2d6a=""><!--[-->mount table<!--]--></strong>. Here is how to verify it.
From <span data-v-0921d991="">Terminal 1</span>, mount something:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>sudo</span><span> mount</span><span> --bind</span><span> /tmp</span><span> /mnt
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->üí° The above command uses a <a href="https://labs.iximiuz.com/challenges/storage-bind-mount" rel="noopener noreferrer" target="_blank" data-v-6d75e4e7=""><!--[-->bind mount<!--]--><!----></a> for simplicity,
but a <a href="https://labs.iximiuz.com/challenges/storage-simple-mount" rel="noopener noreferrer" target="_blank" data-v-6d75e4e7=""><!--[-->regular mount<!--]--><!----></a> (of a block device) would do, too.<!--]--></p><p data-v-f4353d2d=""><!--[-->Now if you list the contents of the <code data-v-e8db53fc=""><!--[-->/mnt<!--]--></code> folder in <span data-v-0921d991="">Terminal 1</span>,
you should see the files of the <code data-v-e8db53fc=""><!--[-->/tmp<!--]--></code> folder:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code>total 12
drwx------ 3 root root 4096 Sep 11 14:16 file1
drwx------ 3 root root 4096 Sep 11 14:16 file2
...
</code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->But at the same time, the <code data-v-e8db53fc=""><!--[-->/mnt<!--]--></code> folder remained empty in the host mount namespace.
If you run the same <code data-v-e8db53fc=""><!--[-->ls<!--]--></code> command from <span data-v-0921d991="">Terminal 2</span>,
you&#39;ll see no files:<!--]--></p><p data-v-f4353d2d=""><!--[-->Finally, the filesystem &#34;views&#34; started diverging between namespaces.
However, we could only achieve it by creating a new mount point.<!--]--></p><div><div><p><img src="https://labs.iximiuz.com/content/files/tutorials/container-filesystem-from-scratch/__static__/mount-namespaces.png" alt="Linux mount namespaces isolate the list of mount points (mount table) seen by the processes in each namespace."/></p><!--[--><p data-v-f4353d2d=""><!--[--><i>Mount namespaces, visualized</i><!--]--></p><!--]--></div><!----></div><p data-v-f4353d2d=""><!--[-->From <a href="https://man7.org/linux/man-pages/man7/mount_namespaces.7.html" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->the mount namespace man page<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>:<!--]--></p><blockquote data-v-3d119438=""><!--[--><p data-v-f4353d2d=""><!--[-->Mount namespaces provide isolation of the list of mounts seen by the processes in each namespace instance.
Thus, the processes in each of the mount namespace instances will see distinct single directory hierarchies.<!--]--></p><!--]--></blockquote><p data-v-f4353d2d=""><!--[-->Compare the mount tables by running <code data-v-e8db53fc=""><!--[-->findmnt<!--]--></code> from <span data-v-0921d991="">Terminal 1</span> and <span data-v-0921d991="">Terminal 2</span>:<!--]--></p><div><div><!--[--><p>Host namespace</p><p>New namespace</p><!--]--></div><div><!--[--><div><!--[--><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>TARGET                         SOURCE         FSTYPE      OPTIONS
</span></span><span line="2"><span>/                              /dev/vda       ext4        rw,...
</span></span><span line="3"><span>‚îú‚îÄ/dev                         devtmpfs       devtmpfs    rw,...
</span></span><span line="4"><span>‚îÇ ‚îú‚îÄ/dev/shm                   tmpfs          tmpfs       rw,...
</span></span><span line="5"><span>‚îÇ ‚îú‚îÄ/dev/pts                   devpts         devpts      rw,...
</span></span><span line="6"><span>‚îÇ ‚îî‚îÄ/dev/mqueue                mqueue         mqueue      rw,...
</span></span><span line="7"><span>‚îú‚îÄ/proc                        proc           proc        rw,...
</span></span><span line="8"><span>‚îú‚îÄ/sys                         sysfs          sysfs       rw,...
</span></span><span line="9"><span>‚îÇ ‚îú‚îÄ/sys/kernel/security       securityfs     securityfs  rw,...
</span></span><span line="10"><span>‚îÇ ‚îú‚îÄ/sys/fs/cgroup             cgroup2        cgroup2     rw,...
</span></span><span line="11"><span>‚îÇ ...
</span></span><span line="12"><span>‚îî‚îÄ/run                         tmpfs          tmpfs       rw,...
</span></span><span line="13"><span>  ‚îú‚îÄ/run/lock                  tmpfs          tmpfs       rw,...
</span></span><span line="14"><span>  ‚îî‚îÄ/run/user/1001             tmpfs          tmpfs       rw,...
</span></span></code><!--]--></pre><!--]--></div><!--]--></div><!--]--></div></div><p data-v-f4353d2d=""><!--[-->In hindsight, it should probably make sense -
after all, we are playing with a <em data-v-bddc49f6=""><!--[-->mount<!--]--></em> namespace
(and there is no such thing as <em data-v-bddc49f6=""><!--[-->filesystem<!--]--></em> namespaces, for better or worse).<!--]--></p><p data-v-f4353d2d=""><!--[-->üí° <strong data-v-849f2d6a=""><!--[-->Interesting fact:<!--]--></strong> Mount namespaces were the first namespace type added to Linux, appearing in Linux 2.4, ca. 2002.<!--]--></p><div><!--[--><p data-v-f4353d2d=""><!--[-->üí° <strong data-v-849f2d6a=""><!--[-->Pro Tip:<!--]--></strong> You can quickly check the current mount namespace of a process using the following command:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>readlink</span><span> /proc/</span><span>$PID</span><span>/ns/mnt
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Different inode numbers in the output will indicate different namespaces.
Try running <code data-v-e8db53fc=""><!--[-->readlink /proc/self/ns/mnt<!--]--></code> from <span data-v-0921d991="">Terminal 1</span> and <span data-v-0921d991="">Terminal 2</span>.<!--]--></p><!--]--></div><h2 id="what-the-heck-is-mount-propagation" data-v-2d6287ef=""><!--[-->What the heck is Mount Propagation?<!--]--><!----></h2><p data-v-f4353d2d=""><!--[-->Before we jump to how exactly mount namespaces are applied by <del>Docker</del> an OCI runtime
(e.g., <a href="https://labs.iximiuz.com/challenges/start-container-with-runc" rel="noopener noreferrer" target="_blank" data-v-6d75e4e7=""><!--[-->runc<!--]--><!----></a>) to create containers,
we need to learn about one more important (and related) concept - <strong data-v-849f2d6a=""><!--[-->mount propagation<!--]--></strong>.<!--]--></p><p data-v-f4353d2d=""><!--[-->‚ö†Ô∏è Make sure to exit the namespaced shell in <span data-v-0921d991="">Terminal 1</span>
before proceeding with the commands in this section.<!--]--></p><p data-v-f4353d2d=""><!--[-->If you tried to re-do the experiment from the previous section using the <code data-v-e8db53fc=""><!--[-->unshare()<!--]--></code> system call instead of the <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code> CLI command,
the results might look different.<!--]--></p><div meta="" data-v-c399e391=""><p><span data-v-c399e391="">unshare_lite.go</span></p><!--[--><pre><!--[--><code><span line="1"><span>package</span><span> main
</span></span><span line="2"><span emptylineplaceholder="true">
</span></span><span line="3"><span>import</span><span> &#34;os&#34;
</span></span><span line="4"><span>import</span><span> &#34;os/exec&#34;
</span></span><span line="5"><span>import</span><span> &#34;syscall&#34;
</span></span><span line="6"><span emptylineplaceholder="true">
</span></span><span line="7"><span>func</span><span> main</span><span>() {
</span></span><span line="8"><span>  if</span><span> err</span><span> :=</span><span> syscall</span><span>.</span><span>Unshare</span><span>(</span><span>syscall</span><span>.</span><span>CLONE_NEWNS</span><span>); </span><span>err</span><span> !=</span><span> nil</span><span> {
</span></span><span line="9"><span>    panic</span><span>(</span><span>err</span><span>)
</span></span><span line="10"><span>  }
</span></span><span line="11"><span emptylineplaceholder="true">
</span></span><span line="12"><span>  cmd</span><span> :=</span><span> exec</span><span>.</span><span>Command</span><span>(</span><span>&#34;bash&#34;</span><span>)
</span></span><span line="13"><span>  cmd</span><span>.</span><span>Stdin</span><span> =</span><span> os</span><span>.</span><span>Stdin
</span></span><span line="14"><span>  cmd</span><span>.</span><span>Stdout</span><span> =</span><span> os</span><span>.</span><span>Stdout
</span></span><span line="15"><span>  cmd</span><span>.</span><span>Stderr</span><span> =</span><span> os</span><span>.</span><span>Stderr
</span></span><span line="16"><span>  cmd</span><span>.</span><span>Env</span><span> =</span><span> os</span><span>.</span><span>Environ</span><span>()
</span></span><span line="17"><span emptylineplaceholder="true">
</span></span><span line="18"><span>  cmd</span><span>.</span><span>Run</span><span>()
</span></span><span line="19"><span>}
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Build the above improvised <code data-v-e8db53fc=""><!--[-->unshare_lite<!--]--></code> program with:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>go</span><span> build</span><span> -o</span><span> unshare_lite</span><span> unshare_lite.go
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->And run it from <span data-v-0921d991="">Terminal 1</span>:<!--]--></p><p data-v-f4353d2d=""><!--[-->Then mount something:<!--]--></p><p data-v-f4353d2d=""><!--[-->This time, the results of the <code data-v-e8db53fc=""><!--[-->ls -l /mnt<!--]--></code> will look identical in <span data-v-0921d991="">Terminal 1</span> and <span data-v-0921d991="">Terminal 2</span>.
<strong data-v-849f2d6a=""><!--[-->Thus, the mount namespace alone may not be enough to provide the mount table isolation.<!--]--></strong><!--]--></p><p data-v-f4353d2d=""><!--[-->If you compare the mount tables by running <code data-v-e8db53fc=""><!--[-->findmnt<!--]--></code> from <span data-v-0921d991="">Terminal 1</span> and <span data-v-0921d991="">Terminal 2</span>,
they will look the same:<!--]--></p><div><div><!--[--><p>Host namespace</p><p>New namespace</p><!--]--></div><div><!--[--><div><!--[--><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>TARGET                         SOURCE         FSTYPE      OPTIONS
</span></span><span line="2"><span>/                              /dev/vda       ext4        rw,...
</span></span><span line="3"><span>‚îú‚îÄ/dev                         devtmpfs       devtmpfs    rw,...
</span></span><span line="4"><span>‚îÇ ‚îú‚îÄ/dev/shm                   tmpfs          tmpfs       rw,...
</span></span><span line="5"><span>‚îÇ ‚îú‚îÄ/dev/pts                   devpts         devpts      rw,...
</span></span><span line="6"><span>‚îÇ ‚îî‚îÄ/dev/mqueue                mqueue         mqueue      rw,...
</span></span><span line="7"><span>‚îú‚îÄ/proc                        proc           proc        rw,...
</span></span><span line="8"><span>‚îú‚îÄ/sys                         sysfs          sysfs       rw,...
</span></span><span line="9"><span>‚îÇ ‚îú‚îÄ/sys/kernel/security       securityfs     securityfs  rw,...
</span></span><span line="10"><span>‚îÇ ‚îú‚îÄ/sys/fs/cgroup             cgroup2        cgroup2     rw,...
</span></span><span line="11"><span>‚îÇ ...
</span></span><span line="12"><span>‚îú‚îÄ/run                         tmpfs          tmpfs       rw,...
</span></span><span line="13"><span>‚îÇ ‚îú‚îÄ/run/lock                  tmpfs          tmpfs       rw,...
</span></span><span line="14"><span>‚îÇ ‚îî‚îÄ/run/user/1001             tmpfs          tmpfs       rw,...
</span></span><span line="15"><span>‚îî‚îÄ/mnt                         /dev/vda[/tmp] ext4        rw,...
</span></span></code><!--]--></pre><!--]--></div><!--]--></div><!--]--></div></div><p data-v-f4353d2d=""><!--[-->When you <em data-v-bddc49f6=""><!--[-->unshare<!--]--></em> a new mount namespace, it gets a full copy of the mount table of the caller process.
However, changes to the caller&#39;s mount table <em data-v-bddc49f6=""><!--[-->may be propagated<!--]--></em> to the new mount table and vice versa.<!--]--></p><p data-v-f4353d2d=""><!--[-->But why? ü§î<!--]--></p><p data-v-f4353d2d=""><!--[-->Today, containers can easily be the main &#34;consumer&#34; of mount namespaces.
However, the applicability of mount namespaces is not limited to containerization use cases.
For example, they can be used to provide per-user views of the filesystem.<!--]--></p><p data-v-f4353d2d=""><!--[-->The original implementation of mount namespaces came out too strict, and <a href="https://lwn.net/Articles/689856/" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->it led to tedious repetitive work for system administrators<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>.
To alleviate the problem, the kernel was extended with the mechanism of <a href="https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->shared subtrees<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>,
which in particular introduced <strong data-v-849f2d6a=""><!--[-->mount event propagation<!--]--></strong> between <em data-v-bddc49f6=""><!--[-->peer groups<!--]--></em> (of mount points).<!--]--></p><div><div><p><img src="https://labs.iximiuz.com/content/files/tutorials/container-filesystem-from-scratch/__static__/mount-event-propagation.png" alt="Mount event propagation is a kernel mechanism of replicating mount and umount operations between peer groups (of mount points)."/></p><!--[--><p data-v-f4353d2d=""><!--[--><i>Mount event propagation, visualized</i><!--]--></p><!--]--></div><!----></div><p data-v-f4353d2d=""><!--[-->For instance, if multiple users on the system were using separate mount namespaces to isolate their root filesystems,
<strong data-v-849f2d6a=""><!--[-->without mount event propagation<!--]--></strong>, mounting a new shared volume would require N <code data-v-e8db53fc=""><!--[-->mount<!--]--></code> operations, where N is equal to the number of users.
While <strong data-v-849f2d6a=""><!--[-->with mount event propagation<!--]--></strong>, system administrators need to mount the volume only once,
and the change will be replicated in all <em data-v-bddc49f6=""><!--[-->peer groups<!--]--></em>, even across different mount namespaces.<!--]--></p><p data-v-f4353d2d=""><!--[-->ü§ì Neither kernel documentation nor the mount namespace man page use the term <strong data-v-849f2d6a=""><!--[-->mount propagation<!--]--></strong> -
instead, they refer to it as <strong data-v-849f2d6a=""><!--[-->propagation type<!--]--></strong> (of a mount point).
However, the term <strong data-v-849f2d6a=""><!--[-->mount propagation<!--]--></strong> seems to be <a href="https://lwn.net/Articles/690679/" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->commonly used in the industry<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>,
including in the Docker (<a href="https://docs.docker.com/engine/storage/bind-mounts/#configure-bind-propagation" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->example<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>) and Kubernetes (<a href="https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->example<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>) documentation.<!--]--></p><p data-v-f4353d2d=""><!--[-->Mount event propagation is exactly what we&#39;ve just observed when we tried using the <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code> system call directly from a Go program:
when the <code data-v-e8db53fc=""><!--[-->/tmp<!--]--></code> folder was bind-mounted to the <code data-v-e8db53fc=""><!--[-->/mnt<!--]--></code> folder in the new mount namespace,
the original namespace received a <em data-v-bddc49f6=""><!--[-->mount event<!--]--></em> and replicated the change creating a similar <code data-v-e8db53fc=""><!--[-->/tmp:/mnt<!--]--></code> mount.<!--]--></p><p data-v-f4353d2d=""><!--[-->Hmm... Why didn&#39;t it happen when we used the standard <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code> command-line tool? ü§î<!--]--></p><p data-v-f4353d2d=""><!--[-->The <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code> CLI tool does slightly more than just the <code data-v-e8db53fc=""><!--[-->unshare()<!--]--></code> system call.
You can sneak a peek under the hood of the <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code> CLI with the following <code data-v-e8db53fc=""><!--[-->strace<!--]--></code> trick (from a <span data-v-0921d991="">fresh terminal</span>):<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>sudo</span><span> strace</span><span> unshare</span><span> --mount</span><span> bash
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->When you cut through the noise of the trace, you&#39;ll spot these three important system calls done in a sequence:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>...
</span></span><span line="2"><span>unshare(CLONE_NEWNS)                    = 0
</span></span><span line="3"><span>mount(&#34;none&#34;, &#34;/&#34;, NULL, MS_REC|MS_PRIVATE, NULL) = 0
</span></span><span line="4"><span>execve(&#34;/usr/bin/bash&#34;, [&#34;bash&#34;], 0x7fff03d0e038 /* 19 vars */) = 0
</span></span><span line="5"><span>...
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Right <em data-v-bddc49f6=""><!--[-->after<!--]--></em> creating a new mount namespace and <em data-v-bddc49f6=""><!--[-->before<!--]--></em> executing the <code data-v-e8db53fc=""><!--[-->bash<!--]--></code> binary,
the <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code> command also changed the mount propagation type of the root mount point.
The above <code data-v-e8db53fc=""><!--[-->mount()<!--]--></code> call is equivalent to the following <code data-v-e8db53fc=""><!--[-->mount<!--]--></code> command:<!--]--></p><p data-v-f4353d2d=""><!--[-->...which means that in the new mount namespace, the root mount and <em data-v-bddc49f6=""><!--[-->all its sub-mounts<!--]--></em> (<code data-v-e8db53fc=""><!--[-->MS_REC<!--]--></code> and <code data-v-e8db53fc=""><!--[-->r<!--]--></code> in <code data-v-e8db53fc=""><!--[-->rprivate<!--]--></code> stand for <em data-v-bddc49f6=""><!--[-->recursive<!--]--></em>) become completely isolated from the outside world -
mounting new filesystems inside the mount namespace won&#39;t be noticeable in the caller&#39;s (i.e., the host&#39;s, in our case) mount namespace and vice versa.<!--]--></p><p data-v-f4353d2d=""><!--[-->üí° Mount propagation type is a property of a mount point.
Since each mount point belongs to the corresponding mount namespace,
the mount propagation type is also a namespace-specific property.
For instance, the root mount <code data-v-e8db53fc=""><!--[-->/<!--]--></code> can have a <code data-v-e8db53fc=""><!--[-->shared<!--]--></code> mount propagation type in one namespace
and <code data-v-e8db53fc=""><!--[-->private<!--]--></code> in another.<!--]--></p><div><div><!--[--><div><!--[--><p data-v-f4353d2d=""><!--[-->No mount event propagation between namespaces:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>sudo</span><span> unshare</span><span> --mount</span><span> --propagation</span><span> private
</span></span><span line="2"><span>findmnt</span><span> -o</span><span> TARGET,SOURCE,FSTYPE,PROPAGATION
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code>TARGET                         SOURCE      FSTYPE      PROPAGATION
/                              /dev/vda    ext4        private
‚îú‚îÄ/dev                         devtmpfs    devtmpfs    private
‚îÇ ‚îú‚îÄ/dev/shm                   tmpfs       tmpfs       private
‚îÇ ‚îú‚îÄ/dev/pts                   devpts      devpts      private
‚îÇ ‚îî‚îÄ/dev/mqueue                mqueue      mqueue      private
‚îú‚îÄ/proc                        proc        proc        private
‚îÇ ‚îî‚îÄ/proc/sys/fs/binfmt_misc   systemd-1   autofs      private
‚îÇ   ‚îî‚îÄ/proc/sys/fs/binfmt_misc binfmt_misc binfmt_misc private
‚îú‚îÄ/sys                         sysfs       sysfs       private
‚îÇ ‚îú‚îÄ/sys/kernel/security       securityfs  securityfs  private
‚îÇ ‚îú‚îÄ/sys/fs/selinux            selinuxfs   selinuxfs   private
‚îÇ ...
‚îî‚îÄ/run                         tmpfs       tmpfs       private
  ‚îú‚îÄ/run/lock                  tmpfs       tmpfs       private
  ‚îî‚îÄ/run/user/1001             tmpfs       tmpfs       private
</code><!--]--></pre><!--]--></div><!--]--></div><!--]--></div></div><p data-v-f4353d2d=""><!--[-->Why does mount propagation matter for us? Two reasons:<!--]--></p><ul data-v-80af725d=""><!--[--><li data-v-05c6bdd9=""><!--[--><code data-v-e8db53fc=""><!--[-->pivot_root<!--]--></code>, the modern <code data-v-e8db53fc=""><!--[-->chroot<!--]--></code> alternative most container runtimes rely on,
comes with its own requirements for the mount propagation type of the involved mount points (we&#39;ll see it in the next section).<!--]--></li><li data-v-05c6bdd9=""><!--[-->Some applications may want to mount filesystems on the host while running in a container and some others may need to spot the host (or peer containers) mounting filesystems in runtime (e.g., <a href="https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[--><code data-v-e8db53fc=""><!--[-->HostToContainer<!--]--></code> and <code data-v-e8db53fc=""><!--[-->Bidirectional<!--]--></code> mount propagations in Kubernetes<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>). More on it later.<!--]--></li><!--]--></ul><h2 id="a-naive-attempt-to-isolate-container-filesystem" data-v-2d6287ef=""><!--[-->A naive attempt to isolate container filesystem<!--]--><!----></h2><p data-v-f4353d2d=""><!--[-->Mount namespaces and propagation are great, but how is all this stuff used in containers?
Let&#39;s try creating a simple container to see this machinery in action.<!--]--></p><p data-v-f4353d2d=""><!--[-->‚ö†Ô∏è Make sure to exit the namespaced shell in <span data-v-0921d991="">Terminal 1</span>
before proceeding with the commands in this section.<!--]--></p><h3 id="preparing-container-rootfs" data-v-796c1f0b=""><!--[-->Preparing container rootfs<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->First off, we&#39;ll need to prepare the future root filesystem.
From the host&#39;s standpoint, each container&#39;s rootfs is just a regular folder with some files inside:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>sudo</span><span> mkdir</span><span> -p</span><span> /opt/container-1/rootfs
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->For this experiment, we can &#34;borrow&#34; the Alpine filesystem <a href="https://labs.iximiuz.com/tutorials/extracting-container-image-filesystem" rel="noopener noreferrer" target="_blank" data-v-6d75e4e7=""><!--[-->by extracting the <code data-v-e8db53fc=""><!--[-->alpine:3<!--]--></code> image<!--]--><!----></a> into the directory we just created:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>crane</span><span> export</span><span> alpine:3</span><span> |</span><span> sudo</span><span> tar</span><span> -xvC</span><span> /opt/container-1/rootfs
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->If you compare the contents of the <code data-v-e8db53fc=""><!--[-->/opt/container-1/rootfs<!--]--></code> and the host&#39;s <code data-v-e8db53fc=""><!--[-->/<!--]--></code> folders, they will look surprisingly similar:<!--]--></p><div><div><!--[--><div><!--[--><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>tree</span><span> -L</span><span> 1</span><span> /opt/container-1/rootfs
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code>/opt/container-1/rootfs/
‚îú‚îÄ‚îÄ bin
‚îú‚îÄ‚îÄ dev
‚îú‚îÄ‚îÄ etc
‚îú‚îÄ‚îÄ home
‚îú‚îÄ‚îÄ lib
...
‚îú‚îÄ‚îÄ tmp
‚îú‚îÄ‚îÄ usr
‚îî‚îÄ‚îÄ var

18 directories, 0 files
</code><!--]--></pre><!--]--></div><!--]--></div><!--]--></div></div><p data-v-f4353d2d=""><!--[-->However, upon closer inspection, you&#39;ll see that it&#39;s two different Linux distributions:<!--]--></p><div><div><!--[--><div><!--[--><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>cat</span><span> /opt/container-1/rootfs/etc/os-release
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code>NAME=&#34;Alpine Linux&#34;
ID=alpine
VERSION_ID=3.22.1
PRETTY_NAME=&#34;Alpine Linux v3.22&#34;
HOME_URL=&#34;https://alpinelinux.org/&#34;
BUG_REPORT_URL=&#34;https://gitlab.alpinelinux.org/alpine/aports/-/issues&#34;
</code><!--]--></pre><!--]--></div><!--]--></div><!--]--></div></div><h3 id="switching-to-new-rootfs-pivot_root" data-v-796c1f0b=""><!--[-->Switching to new rootfs (pivot_root)<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->The <a href="https://man7.org/linux/man-pages/man2/pivot_root.2.html" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[--><code data-v-e8db53fc=""><!--[-->pivot_root(new_root, put_old)<!--]--></code> syscall<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a> changes the root mount <strong data-v-849f2d6a=""><!--[-->in the mount namespace of the calling process<!--]--></strong>.
More precisely, it moves the current root mount of the caller to the directory <code data-v-e8db53fc=""><!--[-->put_old<!--]--></code> and makes <code data-v-e8db53fc=""><!--[-->new_root<!--]--></code> the new root mount.<!--]--></p><p data-v-f4353d2d=""><!--[-->What it practically means is that by calling <code data-v-e8db53fc=""><!--[-->pivot_root(&#34;/opt/container-1/rootfs&#34;)<!--]--></code> in a new mount namespace,
we&#39;ll switch to the new root filesystem.<!--]--></p><div><p><img src="https://labs.iximiuz.com/content/files/tutorials/container-filesystem-from-scratch/__static__/pivot-root.png" alt="pivot_root changes the root mount in the mount namespace of the calling process."/></p><!----></div><p data-v-f4353d2d=""><!--[-->üí° From a layman&#39;s standpoint, <code data-v-e8db53fc=""><!--[-->pivot_root<!--]--></code> is a safer version of <code data-v-e8db53fc=""><!--[-->chroot<!--]--></code> - similar effect but no risk of breakouts via forgotten symlinks to the old root filesystem or the double-chroot trick.<!--]--></p><p data-v-f4353d2d=""><!--[-->The <code data-v-e8db53fc=""><!--[-->pivot_root()<!--]--></code> call comes with a number of restrictions, in particular:<!--]--></p><ul data-v-80af725d=""><!--[--><li data-v-05c6bdd9=""><!--[-->The <code data-v-e8db53fc=""><!--[-->new_root<!--]--></code> path must be a mount point, but can&#39;t be <code data-v-e8db53fc=""><!--[-->/<!--]--></code> (well, attempting <code data-v-e8db53fc=""><!--[-->pivot_root(&#34;/&#34;)<!--]--></code> wouldn&#39;t make much sense anyway).<!--]--></li><li data-v-05c6bdd9=""><!--[-->The <strong data-v-849f2d6a=""><!--[-->propagation type<!--]--></strong> of the parent mount of <code data-v-e8db53fc=""><!--[-->new_root<!--]--></code> and the parent mount of the current root directory must not be <code data-v-e8db53fc=""><!--[-->shared<!--]--></code>.<!--]--></li><li data-v-05c6bdd9=""><!--[-->If <code data-v-e8db53fc=""><!--[-->put_old<!--]--></code> is an existing mount point, its <strong data-v-849f2d6a=""><!--[-->propagation type<!--]--></strong> must not be <code data-v-e8db53fc=""><!--[-->shared<!--]--></code>.<!--]--></li><!--]--></ul><p data-v-f4353d2d=""><!--[-->Expectedly, we only want to perform such a disruptive operation from a separate mount namespace (otherwise, we&#39;d damage the host),
and the last two restrictions ensure that <code data-v-e8db53fc=""><!--[-->pivot_root<!--]--></code> never propagates any mount table changes to another mount namespace:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>sudo</span><span> unshare</span><span> --mount</span><span> bash
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Now let&#39;s try satisfying the <code data-v-e8db53fc=""><!--[-->pivot_root<!--]--></code>&#39;s requirements.
The propagation type of the <code data-v-e8db53fc=""><!--[-->/<!--]--></code> mount (the parent mount of the current root directory) should not be <code data-v-e8db53fc=""><!--[-->shared<!--]--></code>.
The above <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code> command has likely already set it to <code data-v-e8db53fc=""><!--[-->private<!--]--></code> but being explicit won&#39;t hurt:<!--]--></p><p data-v-f4353d2d=""><!--[-->üí° <strong data-v-849f2d6a=""><!--[-->Interesting fact:<!--]--></strong> runc uses <code data-v-e8db53fc=""><!--[-->rslave<!--]--></code> instead of <code data-v-e8db53fc=""><!--[-->rprivate<!--]--></code> <a href="https://github.com/opencontainers/runc/blob/b27d6f3f1af9a56f2770c8ec6e1a1ff986ca9c09/libcontainer/rootfs_linux.go#L1112" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->citing a possibility of a race condition<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>. But both values should be good enough for our demo example.<!--]--></p><p data-v-f4353d2d=""><!--[-->In our case, the <code data-v-e8db53fc=""><!--[-->/opt/container-1/rootfs<!--]--></code> folder is not a mount point (it&#39;s a regular folder somewhere in the host&#39;s filesystem),
but we can easily make it a mount point by bind mounting the path onto itself (using a recursive bind mount because hypothetically the container rootfs folder itself can contain sub-mounts):<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mount</span><span> --rbind</span><span> /opt/container-1/rootfs</span><span> /opt/container-1/rootfs
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Lastly, ensuring that the propagation type of the <code data-v-e8db53fc=""><!--[-->new_root<!--]--></code> itself isn&#39;t <code data-v-e8db53fc=""><!--[-->shared<!--]--></code>:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mount</span><span> --make-rprivate</span><span> /opt/container-1/rootfs
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Now we&#39;re ready to <del>choort</del> pivot the root filesystem:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>cd</span><span> /opt/container-1/rootfs
</span></span><span line="2"><span>mkdir</span><span> .oldroot
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->...and immediately after that, switch to a shell from the new rootfs because the current <code data-v-e8db53fc=""><!--[-->bash<!--]--></code> process may get broken in subtle ways after a <code data-v-e8db53fc=""><!--[-->pivot_root<!--]--></code> into a completely different Linux distro (this part is only needed for our demo example -
real-world container runtimes usually don&#39;t have this issue because they communicate with the kernel directly, using syscalls instead of shell commands):<!--]--></p><p data-v-f4353d2d=""><!--[-->Interestingly, after the <code data-v-e8db53fc=""><!--[-->pivot_root<!--]--></code> operation,
<a href="https://github.com/opencontainers/runtime-spec/blob/main/config-linux.md#rootfs-mount-propagation" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->container runtimes are free to set the propagation type of the new root filesystem to pretty much any value<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>
(<code data-v-e8db53fc=""><!--[-->shared<!--]--></code>, <code data-v-e8db53fc=""><!--[-->slave<!--]--></code>, <code data-v-e8db53fc=""><!--[-->private<!--]--></code>, and even <code data-v-e8db53fc=""><!--[-->unbindable<!--]--></code>):<!--]--></p><p data-v-f4353d2d=""><!--[-->üí° Propagation type of the container root filesystem should not be confused with the propagation type of bind mounts and volumes in Docker and Kubernetes respectively (see below).
This is an advanced setting that is often not even exposed through the user-facing APIs of the higher-level container runtimes,
and the most typical use case for it is nested containers (e.g., <a href="https://hub.docker.com/_/docker" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->DinD<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>).<!--]--></p><p data-v-f4353d2d=""><!--[-->Finally, since you probably don&#39;t want the original root filesystem to be accessible in the container,
the <code data-v-e8db53fc=""><!--[-->.oldroot<!--]--></code> can (and should) be removed right after the <code data-v-e8db53fc=""><!--[-->pivot_root<!--]--></code> call:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>umount</span><span> -l</span><span> .oldroot</span><span>  # -l stands for &#34;lazy&#34; because the fs can be busy
</span></span><span line="2"><span>rm</span><span> -rf</span><span> .oldroot
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Yay! We&#39;ve just pivoted into a new container. Let&#39;s look around:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code>ls -l /
total 68
drwxr-xr-x    2 root     root          4096 Jul 15 10:42 bin
drwxr-xr-x    2 root     root          4096 Sep  7 12:40 dev
drwxr-xr-x   17 root     root          4096 Jul 15 10:42 etc
drwxr-xr-x    2 root     root          4096 Jul 15 10:42 home
...
drwxr-xr-x   11 root     root          4096 Jul 15 10:42 var
</code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code>NAME=&#34;Alpine Linux&#34;
ID=alpine
VERSION_ID=3.22.1
PRETTY_NAME=&#34;Alpine Linux v3.22&#34;
HOME_URL=&#34;https://alpinelinux.org/&#34;
BUG_REPORT_URL=&#34;https://gitlab.alpinelinux.org/alpine/aports/-/issues&#34;
</code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->So far so good! But if you try listing processes, the output will be empty (which of course can&#39;t be true):<!--]--></p><p data-v-f4353d2d=""><!--[-->And the <code data-v-e8db53fc=""><!--[-->df<!--]--></code> command also seems broken:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code>Filesystem                Size      Used Available Use% Mounted on
df: /proc/mounts: No such file or directory
</code><!--]--></pre><!--]--></div><h2 id="preparing-a-complete-container-filesystem" data-v-2d6287ef=""><!--[-->Preparing a complete container filesystem<!--]--><!----></h2><p data-v-f4353d2d=""><!--[-->The <code data-v-e8db53fc=""><!--[-->df<!--]--></code>&#39;s error message contained a hint - the <code data-v-e8db53fc=""><!--[-->/proc<!--]--></code> folder is empty in the new mount namespace:<!--]--></p><p data-v-f4353d2d=""><!--[-->Hmm... How come?<!--]--></p><p data-v-f4353d2d=""><!--[-->Well, apparently, not every part of the container root filesystem comes from its image!<!--]--></p><p data-v-f4353d2d=""><!--[-->Similarly to the host, where <a href="https://docs.kernel.org/filesystems/proc.html" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[--><code data-v-e8db53fc=""><!--[-->/proc<!--]--></code> is populated by the corresponding kernel pseudo filesystem<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>,
container&#39;s <code data-v-e8db53fc=""><!--[-->/proc<!--]--></code> needs to be set up separately. And the same goes for <code data-v-e8db53fc=""><!--[-->/dev<!--]--></code> and <code data-v-e8db53fc=""><!--[-->/sys<!--]--></code> virtual filesystems.<!--]--></p><p data-v-f4353d2d=""><!--[-->On top of that, some special files like <code data-v-e8db53fc=""><!--[-->/etc/hosts<!--]--></code>, <code data-v-e8db53fc=""><!--[-->/etc/hostname<!--]--></code>, or <code data-v-e8db53fc=""><!--[-->/etc/resolv.conf<!--]--></code> should be crafted for each container individually
because the corresponding files in the image (if present) can only contain generic values (e.g., <code data-v-e8db53fc=""><!--[-->localhost<!--]--></code>) while Docker typically sets the hostname of a container to a prefix of its random ID and derives the <code data-v-e8db53fc=""><!--[-->resolv.conf<!--]--></code> from the eponymous file on the host.<!--]--></p><h3 id="populating-proc-pseudo-filesystem" data-v-796c1f0b=""><!--[-->Populating /proc pseudo filesystem<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->Populating the <code data-v-e8db53fc=""><!--[-->/proc<!--]--></code> pseudo filesystem is as simple as:<!--]--></p><p data-v-f4353d2d=""><!--[-->üí° In reality, container runtimes usually populate the <code data-v-e8db53fc=""><!--[-->/proc<!--]--></code> filesystem <em data-v-bddc49f6=""><!--[-->before<!--]--></em> the <code data-v-e8db53fc=""><!--[-->pivot_root<!--]--></code> call,
so the command would look like <code data-v-e8db53fc=""><!--[-->mount -t proc proc $ROOTFS/proc<!--]--></code>.<!--]--></p><p data-v-f4353d2d=""><!--[-->However, if you run the above command right away, the <code data-v-e8db53fc=""><!--[-->/proc<!--]--></code> filesystem in the container will look exactly the same as the one on the host.
In particular, it means that the <code data-v-e8db53fc=""><!--[-->ps<!--]--></code> command will start showing the full list of processes on the server,
which is usually undesirable in a container.<!--]--></p><p data-v-f4353d2d=""><!--[-->This is where the <strong data-v-849f2d6a=""><!--[-->PID namespace<!--]--></strong> comes into play.
We need to go a few steps back and adjust the <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code> command to create not just the mount but also a new PID namespace,
so that the container&#39;s topmost process would become PID 1 and the process hierarchy in the container would start from it:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span># DO NOT RUN ME
</span></span><span line="2"><span>sudo</span><span> unshare</span><span> --mount</span><span> --pid</span><span> --fork</span><span> bash
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->But let&#39;s not do it just yet...<!--]--></p><p data-v-f4353d2d=""><!--[-->üí° The extra <code data-v-e8db53fc=""><!--[-->--fork<!--]--></code> flag above doesn&#39;t create any new namespaces, but rather makes <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code> create a new process instead of exec&#39;ing the <code data-v-e8db53fc=""><!--[-->bash<!--]--></code> command directly.
This is a requirement to make the <code data-v-e8db53fc=""><!--[-->--pid<!--]--></code> flag actually have the effect on the unshared command
because it&#39;s the first child that gets placed into the new PID namespace, not the process that called <code data-v-e8db53fc=""><!--[-->unshare(CLONE_NEWPID)<!--]--></code> itself.<!--]--></p><h3 id="populating-dev-pseudo-filesystem" data-v-796c1f0b=""><!--[-->Populating /dev pseudo filesystem<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->Another special folder is <code data-v-e8db53fc=""><!--[-->/dev<!--]--></code>. On the host, it&#39;s typically provided by the <code data-v-e8db53fc=""><!--[-->devtmpfs<!--]--></code> and a number of subordinate virtual filesystems
(from a <span data-v-0921d991="">fresh terminal</span>):<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code>TARGET            SOURCE   FSTYPE   OPTIONS
/                 /dev/vda ext4     rw,relatime,stripe=4
‚îú‚îÄ/dev            devtmpfs devtmpfs rw,relatime,size=4068368k,nr_inodes=1017092,mode=755
‚îÇ ‚îú‚îÄ/dev/shm      tmpfs    tmpfs    rw,nosuid,nodev
‚îÇ ‚îú‚îÄ/dev/pts      devpts   devpts   rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000
‚îÇ ‚îú‚îÄ/dev/mqueue   mqueue   mqueue   rw,nosuid,nodev,noexec,relatime
...
</code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->However, containers usually get a more limited version of the <code data-v-e8db53fc=""><!--[-->/dev<!--]--></code> folder, backed by a regular <code data-v-e8db53fc=""><!--[-->tmpfs<!--]--></code>.
Here is how it can be populated from inside the new mount namespace (back from <span data-v-0921d991="">Terminal 1</span>):<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mkdir</span><span> -p</span><span> /dev
</span></span><span line="2"><span>mount</span><span> -t</span><span> tmpfs</span><span> -o</span><span> nosuid,strictatime,mode=0755,size=65536k</span><span> tmpfs</span><span> /dev
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->üí° In reality, container runtimes usually populate the <code data-v-e8db53fc=""><!--[-->/dev<!--]--></code> filesystem <em data-v-bddc49f6=""><!--[-->before<!--]--></em> the <code data-v-e8db53fc=""><!--[-->pivot_root<!--]--></code> call,
so the command would look like <code data-v-e8db53fc=""><!--[-->mount -t tmpfs ... $ROOTFS/dev<!--]--></code>.<!--]--></p><p data-v-f4353d2d=""><!--[-->After mounting the <code data-v-e8db53fc=""><!--[-->/dev<!--]--></code> tmpfs,
you&#39;d need to create special character devices such as <code data-v-e8db53fc=""><!--[-->/dev/null<!--]--></code>, <code data-v-e8db53fc=""><!--[-->/dev/zero<!--]--></code>, <code data-v-e8db53fc=""><!--[-->/dev/random<!--]--></code>, etc.
Here is how you can do it using the <code data-v-e8db53fc=""><!--[-->mknod<!--]--></code> command:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mknod</span><span> -m</span><span> 666</span><span> /dev/null</span><span>    c</span><span> 1</span><span> 3
</span></span><span line="2"><span>chown</span><span> root:root</span><span> /dev/null
</span></span><span line="3"><span emptylineplaceholder="true">
</span></span><span line="4"><span>mknod</span><span> -m</span><span> 666</span><span> /dev/zero</span><span>    c</span><span> 1</span><span> 5
</span></span><span line="5"><span>chown</span><span> root:root</span><span> /dev/zero
</span></span><span line="6"><span emptylineplaceholder="true">
</span></span><span line="7"><span># etc.
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Then, mount the subordinate filesystems (<code data-v-e8db53fc=""><!--[-->/dev/shm<!--]--></code>, <code data-v-e8db53fc=""><!--[-->/dev/pts<!--]--></code>, and <code data-v-e8db53fc=""><!--[-->/dev/mqueue<!--]--></code>):<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mkdir</span><span> -p</span><span> /dev/shm
</span></span><span line="2"><span>mount</span><span> -t</span><span> tmpfs</span><span> -o</span><span> nosuid,nodev,noexec,mode=1777,size=</span><span>67108864</span><span> tmpfs</span><span> /dev/shm
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mkdir</span><span> -p</span><span> /dev/pts
</span></span><span line="2"><span>mount</span><span> -t</span><span> devpts</span><span> -o</span><span> newinstance,ptmxmode=0666,mode=</span><span>0620</span><span> devpts</span><span> /dev/pts
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mkdir</span><span> -p</span><span> /dev/mqueue
</span></span><span line="2"><span>mount</span><span> -t</span><span> mqueue</span><span> -o</span><span> nosuid,nodev,noexec</span><span> mqueue</span><span> /dev/mqueue
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->And lastly, set up some well-known symlinks:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>ln</span><span> -sf</span><span> /proc/self/fd</span><span>   /dev/fd
</span></span><span line="2"><span>ln</span><span> -sf</span><span> /proc/self/fd/0</span><span> /dev/stdin
</span></span><span line="3"><span>ln</span><span> -sf</span><span> /proc/self/fd/1</span><span> /dev/stdout
</span></span><span line="4"><span>ln</span><span> -sf</span><span> /proc/self/fd/2</span><span> /dev/stderr
</span></span><span line="5"><span>ln</span><span> -sf</span><span> /proc/kcore</span><span>     /dev/core
</span></span></code><!--]--></pre><!--]--></div><h3 id="populating-sys-pseudo-filesystem" data-v-796c1f0b=""><!--[-->Populating /sys pseudo filesystem<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->The most limited of the containers&#39; pseudo filesystems is probably <a href="https://www.kernel.org/doc/Documentation/filesystems/sysfs.txt" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[--><code data-v-e8db53fc=""><!--[-->/sys<!--]--></code><!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>.
It&#39;s usually mounted read-only and contains only a few nodes:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mount</span><span> -t</span><span> sysfs</span><span> -o</span><span> ro,nosuid,nodev,noexec</span><span> sysfs</span><span> /sys
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->üí° In reality, container runtimes usually populate the <code data-v-e8db53fc=""><!--[-->/sys<!--]--></code> filesystem <em data-v-bddc49f6=""><!--[-->before<!--]--></em> the <code data-v-e8db53fc=""><!--[-->pivot_root<!--]--></code> call,
so the command would look like <code data-v-e8db53fc=""><!--[-->mount -t sysfs ... $ROOTFS/sys<!--]--></code>.<!--]--></p><p data-v-f4353d2d=""><!--[-->A prominent part of the <code data-v-e8db53fc=""><!--[-->/sys<!--]--></code> filesystem is the <a href="https://labs.iximiuz.com/tutorials/controlling-process-resources-with-cgroups/" rel="noopener noreferrer" target="_blank" data-v-6d75e4e7=""><!--[-->virtual cgroup filesystem<!--]--><!----></a>.
Since a few years ago, Docker and other popular container runtimes started fully isolating the container&#39;s cgroup hierarchy by default.
Similarly to the <code data-v-e8db53fc=""><!--[-->/proc<!--]--></code> filesystem that works best in combination with a new PID namespace,
a new <strong data-v-849f2d6a=""><!--[-->cgroup namespace<!--]--></strong> can be used to make the <code data-v-e8db53fc=""><!--[-->cgroup2<!--]--></code> mount rooted at the host&#39;s cgroupfs node that corresponds to the container&#39;s topmost process.
Thus, the <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code> command <strong data-v-849f2d6a=""><!--[-->would need<!--]--></strong> one more flag, <code data-v-e8db53fc=""><!--[-->--cgroup<!--]--></code>:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span># DO NOT RUN ME
</span></span><span line="2"><span>sudo</span><span> unshare</span><span> --mount</span><span> --pid</span><span> --fork</span><span> --cgroup</span><span> bash
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->To mount the <code data-v-e8db53fc=""><!--[-->cgroup2<!--]--></code> filesystem, you can use the following command:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mkdir</span><span> -p</span><span> /sys/fs/cgroup
</span></span><span line="2"><span>mount</span><span> -t</span><span> cgroup2</span><span> -o</span><span> ro,nosuid,nodev,noexec</span><span> cgroup2</span><span> /sys/fs/cgroup
</span></span></code><!--]--></pre><!--]--></div><h3 id="hardening-pseudo-filesystems" data-v-796c1f0b=""><!--[-->Hardening pseudo filesystems<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->While it is not strictly necessary for a demo, real-world container root filesystems usually go through an extra round of hardening.
For instance, Docker typically marks a few parts of the <code data-v-e8db53fc=""><!--[-->/proc<!--]--></code> filesystem as <em data-v-bddc49f6=""><!--[-->read-only<!--]--></em> and <em data-v-bddc49f6=""><!--[-->masks<!--]--></em> others, making them completely inaccessible to the containerized app.<!--]--></p><p data-v-f4353d2d=""><!--[-->Here is how you can get a list of sensitive locations that are made read-only by Docker
(from a <span data-v-0921d991="">fresh terminal</span>):<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>docker</span><span> container</span><span> inspect</span><span> \
</span></span><span line="2"><span>    $(</span><span>docker</span><span> run</span><span> --rm</span><span> -d</span><span> alpine:3</span><span> sleep</span><span> 5</span><span>) </span><span>\
</span></span><span line="3"><span>    --format</span><span> &#39;{{join .HostConfig.ReadonlyPaths &#34;\n&#34;}}&#39;
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code>/proc/bus
/proc/fs
/proc/irq
/proc/sys
/proc/sysrq-trigger
</code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->You can make any file or folder read-only by binding it to itself and remounting it using the <code data-v-e8db53fc=""><!--[-->ro<!--]--></code> option:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>RO_PATH</span><span>=</span><span>/proc/bus</span><span> # or /proc/fs, /proc/irq, etc.
</span></span><span line="2"><span emptylineplaceholder="true">
</span></span><span line="3"><span>if</span><span> [ </span><span>-e</span><span> &#34;</span><span>$RO_PATH</span><span>&#34;</span><span> ]; </span><span>then
</span></span><span line="4"><span>  mount</span><span> --bind</span><span> &#34;</span><span>$RO_PATH</span><span>&#34;</span><span> &#34;</span><span>$RO_PATH</span><span>&#34;
</span></span><span line="5"><span>  mount</span><span> -o</span><span> remount,bind,ro</span><span> &#34;</span><span>$RO_PATH</span><span>&#34;
</span></span><span line="6"><span>fi
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Similarly, here is how you can get a list of locations that are typically made completely inaccessible (through masking) to the containerized app:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>docker</span><span> container</span><span> inspect</span><span> \
</span></span><span line="2"><span>    $(</span><span>docker</span><span> run</span><span> --rm</span><span> -d</span><span> alpine:3</span><span> sleep</span><span> 5</span><span>) </span><span>\
</span></span><span line="3"><span>    --format</span><span> &#39;{{join .HostConfig.MaskedPaths &#34;\n&#34;}}&#39;
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code>/proc/asound
/proc/acpi
/proc/interrupts
/proc/kcore
/proc/keys
/proc/latency_stats
/proc/timer_list
/proc/timer_stats
/proc/sched_debug
/proc/scsi
/sys/firmware
/sys/devices/virtual/powercap
</code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Masking of folders and regular files differs. To mask a folder, a read-only <code data-v-e8db53fc=""><!--[-->tmpfs<!--]--></code> filesystem can be mounted over it,
and to mask a regular file, the <code data-v-e8db53fc=""><!--[-->/dev/null<!--]--></code> device can be bound to its path.<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>MASKED_FILE</span><span>=</span><span>/proc/asound</span><span>  # or /proc/interrupts, /proc/kcore, etc.
</span></span><span line="2"><span>mount</span><span> --bind</span><span> /dev/null</span><span> $MASKED_FILE
</span></span><span line="3"><span emptylineplaceholder="true">
</span></span><span line="4"><span>MASKED_DIR</span><span>=</span><span>/proc/acpi</span><span>    # or /proc/scsi, etc.
</span></span><span line="5"><span>mount</span><span> -t</span><span> tmpfs</span><span> -o</span><span> ro</span><span> tmpfs</span><span> $MASKED_DIR
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->üí°
The above read-only and masked paths are Docker&#39;s <strong data-v-849f2d6a=""><!--[-->defaults for non-privileged containers<!--]--></strong>,
while the OCI Runtime Spec defines only the hardening mechanism and not the exact locations
(see <a href="https://github.com/opencontainers/runtime-spec/blob/e3c8d12d94cdd269a145a263ace7457f56c74eff/config-linux.md#masked-paths" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Masked Paths<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a> and <a href="https://github.com/opencontainers/runtime-spec/blob/e3c8d12d94cdd269a145a263ace7457f56c74eff/config-linux.md#readonly-paths" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Readonly Paths<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>).<!--]--></p><h3 id="preparing-special-etc-files" data-v-796c1f0b=""><!--[-->Preparing special /etc files<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->Some of the regular files in the container rootfs also require special treatment:<!--]--></p><ul data-v-80af725d=""><!--[--><li data-v-05c6bdd9=""><!--[--><code data-v-e8db53fc=""><!--[-->/etc/hosts<!--]--></code><!--]--></li><li data-v-05c6bdd9=""><!--[--><code data-v-e8db53fc=""><!--[-->/etc/hostname<!--]--></code><!--]--></li><li data-v-05c6bdd9=""><!--[--><code data-v-e8db53fc=""><!--[-->/etc/resolv.conf<!--]--></code><!--]--></li><!--]--></ul><p data-v-f4353d2d=""><!--[-->Inspecting these files in the <code data-v-e8db53fc=""><!--[-->/opt/container-1/rootfs<!--]--></code> folder right after extracting the Alpine rootfs into it would reveal why:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>cat</span><span> /opt/container-1/rootfs/etc/{hosts,hostname,resolv.conf}
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code># -- /opt/container-1/rootfs/etc/hosts
127.0.0.1       localhost localhost.localdomain
::1             localhost localhost.localdomain

# -- /opt/container-1/rootfs/etc/hostname
localhost

# -- /opt/container-1/rootfs/etc/resolv.conf
cat: /opt/container-1/rootfs/resolv.conf: No such file or directory
</code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->The above are some generic values that come directly from the <code data-v-e8db53fc=""><!--[-->alpine:3<!--]--></code> image,
which wouldn&#39;t make much sense in any particular container.
At the same time, these files would look very different when inspected from a running <code data-v-e8db53fc=""><!--[-->alpine:3<!--]--></code> container:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>docker</span><span> run</span><span> --rm</span><span> alpine:3</span><span> cat</span><span> /etc/{hosts,hostname,resolv.conf}
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code># -- /etc/hosts
127.0.0.1       localhost
::1             localhost ip6-localhost ip6-loopback
172.17.0.2      2f26e97ae70c

# -- /etc/hostname
2f26e97ae70c

# -- /etc/resolv.conf
# Generated by Docker Engine.
# This file can be edited; Docker Engine will not make further changes once it
# has been modified.

nameserver 168.119.149.157
nameserver 8.8.8.8
nameserver 1.1.1.1

# Based on host file: &#39;/etc/resolv.conf&#39; (legacy)
# Overrides: []
</code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Thus, Docker (or one of its underlying runtimes) replaces the generic <code data-v-e8db53fc=""><!--[-->/etc/hosts<!--]--></code>,
<code data-v-e8db53fc=""><!--[-->/etc/hostname<!--]--></code>, and <code data-v-e8db53fc=""><!--[-->/etc/resolv.conf<!--]--></code> files from the image with container-specific variants.<!--]--></p><p data-v-f4353d2d=""><!--[-->We can do it, too! Our container has no network interfaces (modulo <code data-v-e8db53fc=""><!--[-->loopback<!--]--></code>),
but it can still have a proper hostname set (from the host&#39;s <span data-v-0921d991="">terminal</span>):<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>cat</span><span> &lt;&lt;</span><span>EOF</span><span> |</span><span> sudo</span><span> tee</span><span> /opt/container-1/hosts
</span></span><span line="2"><span>127.0.0.1       localhost container-1
</span></span><span line="3"><span>::1             localhost ip6-localhost ip6-loopback
</span></span><span line="4"><span>EOF
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>cat</span><span> |</span><span> sudo</span><span> tee</span><span> /opt/container-1/hostname</span><span> &lt;&lt;</span><span>EOF
</span></span><span line="2"><span>container-1
</span></span><span line="3"><span>EOF
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>sudo</span><span> cp</span><span> /etc/resolv.conf</span><span> /opt/container-1/resolv.conf
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->üí° The <code data-v-e8db53fc=""><!--[-->/etc/resolv.conf<!--]--></code> file is usually based on the host&#39;s <code data-v-e8db53fc=""><!--[-->/etc/resolv.conf<!--]--></code> file,
and then potentially adjusted to the container&#39;s needs.<!--]--></p><p data-v-f4353d2d=""><!--[-->The most interesting part is how these files are placed into the container&#39;s rootfs.
Instead of just overwriting the files from the image,
container runtimes usually mount the container-specific variants of these files on top of the original ones,
effectively masking them:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>sudo</span><span> mount</span><span> --bind</span><span> /opt/container-1/hosts</span><span> /opt/container-1/rootfs/etc/hosts
</span></span><span line="2"><span>sudo</span><span> mount</span><span> --bind</span><span> /opt/container-1/hostname</span><span> /opt/container-1/rootfs/etc/hostname
</span></span><span line="3"><span>sudo</span><span> mount</span><span> --bind</span><span> /opt/container-1/resolv.conf</span><span> /opt/container-1/rootfs/etc/resolv.conf
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Last but not least, for the container to have its own hostname,
the container needs to use a new <strong data-v-849f2d6a=""><!--[-->network<!--]--></strong> and <strong data-v-849f2d6a=""><!--[-->UTS namespaces<!--]--></strong>,
so the <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code> command would need to have two more flags (<code data-v-e8db53fc=""><!--[-->--uts<!--]--></code> and <code data-v-e8db53fc=""><!--[-->--net<!--]--></code>):<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span># DO NOT RUN ME
</span></span><span line="2"><span>sudo</span><span> unshare</span><span> --mount</span><span> --pid</span><span> --fork</span><span> --cgroup</span><span> --uts</span><span> --net</span><span> bash
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->üí° If we forget to use a new <strong data-v-849f2d6a=""><!--[-->UTS namespace<!--]--></strong>, setting the hostname in the new container will overwrite the host&#39;s hostname,
which is something we definitely don&#39;t want.
And without a new <strong data-v-849f2d6a=""><!--[-->network namespace<!--]--></strong>, the container simply cannot have its own hostname,
because then it technically <a href="https://labs.iximiuz.com/tutorials/container-networking-from-scratch" rel="noopener noreferrer" target="_blank" data-v-6d75e4e7=""><!--[-->has the same network stack as the host (which in particular includes the hostname)<!--]--><!----></a>.<!--]--></p><p data-v-f4353d2d=""><!--[-->Finally, we&#39;re ready to prepare a fully isolated container filesystem!<!--]--></p><h2 id="creating-a-container-from-scratch-end-to-end-example" data-v-2d6287ef=""><!--[-->Creating a container from scratch (end-to-end example)<!--]--><!----></h2><p data-v-f4353d2d=""><!--[-->With all the above lessons learned, let&#39;s try creating our second container,
this time applying all the necessary namespaces and rootfs adjustments.<!--]--></p><div><!--[--><p data-v-f4353d2d=""><!--[-->üí° The below commands are based on the <a href="https://github.com/opencontainers/runc/blob/b27d6f3f1af9a56f2770c8ec6e1a1ff986ca9c09/libcontainer/rootfs_linux.go" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->real container preparation steps taken by the runc runtime<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>
obtained with the following <code data-v-e8db53fc=""><!--[-->strace<!--]--></code> trick:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span># Terminal 1
</span></span><span line="2"><span>sudo</span><span> strace</span><span> -f</span><span> -qqq</span><span> -e</span><span> \
</span></span><span line="3"><span>    trace=/clone,/exec,/unshare,/mount,/mknod,/mkdir,/link,/chdir,/root</span><span> \
</span></span><span line="4"><span>    -p</span><span> $(</span><span>pgrep</span><span> containerd</span><span>)
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span># Terminal 2
</span></span><span line="2"><span>docker</span><span> run</span><span> alpine:3</span><span> sleep</span><span> 9999
</span></span></code><!--]--></pre><!--]--></div><!--]--></div><h3 id="step-1-prepare-rootfs-files" data-v-796c1f0b=""><!--[-->Step 1: Prepare rootfs files<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->‚ö†Ô∏è Make sure to exit the namespaced shell in <span data-v-0921d991="">Terminal 1</span>
before proceeding with the commands in this section.<!--]--></p><p data-v-f4353d2d=""><!--[-->The second container will be stored in the <code data-v-e8db53fc=""><!--[-->/opt/container-2<!--]--></code> directory:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>CONTAINER_DIR</span><span>=</span><span>/opt/container-2
</span></span><span line="2"><span>ROOTFS_DIR</span><span>=</span><span>${</span><span>CONTAINER_DIR</span><span>}</span><span>/rootfs
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Similar to the first container, we&#39;ll use the <code data-v-e8db53fc=""><!--[-->alpine:3<!--]--></code> image to &#34;borrow&#34; the rootfs files:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>sudo</span><span> mkdir</span><span> -p</span><span> $ROOTFS_DIR
</span></span><span line="2"><span>crane</span><span> export</span><span> alpine:3</span><span> |</span><span> sudo</span><span> tar</span><span> -xvC</span><span> $ROOTFS_DIR
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->This time, we&#39;ll create the <code data-v-e8db53fc=""><!--[-->/etc/hosts<!--]--></code>, <code data-v-e8db53fc=""><!--[-->/etc/hostname<!--]--></code>, and <code data-v-e8db53fc=""><!--[-->/etc/resolv.conf<!--]--></code> files beforehand
(but store them outside of the rootfs dir for now):<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>cat</span><span> &lt;&lt;</span><span>EOF</span><span> |</span><span> sudo</span><span> tee</span><span> $CONTAINER_DIR</span><span>/hosts
</span></span><span line="2"><span>127.0.0.1       localhost container-2
</span></span><span line="3"><span>::1             localhost ip6-localhost ip6-loopback
</span></span><span line="4"><span>EOF
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>cat</span><span> &lt;&lt;</span><span>EOF</span><span> |</span><span> sudo</span><span> tee</span><span> $CONTAINER_DIR</span><span>/hostname
</span></span><span line="2"><span>container-2
</span></span><span line="3"><span>EOF
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>sudo</span><span> cp</span><span> /etc/resolv.conf</span><span> $CONTAINER_DIR</span><span>/resolv.conf
</span></span></code><!--]--></pre><!--]--></div><h3 id="step-2-create-namespaces" data-v-796c1f0b=""><!--[-->Step 2: Create namespaces<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->Create all the required namespaces with the <code data-v-e8db53fc=""><!--[-->unshare<!--]--></code> command (<strong data-v-849f2d6a=""><!--[-->mount<!--]--></strong>, <strong data-v-849f2d6a=""><!--[-->PID<!--]--></strong>, <strong data-v-849f2d6a=""><!--[-->cgroup<!--]--></strong>, <strong data-v-849f2d6a=""><!--[-->UTS<!--]--></strong>, and <strong data-v-849f2d6a=""><!--[-->network<!--]--></strong>):<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>sudo</span><span> unshare</span><span> --mount</span><span> --pid</span><span> --fork</span><span> --cgroup</span><span> --uts</span><span> --net</span><span> bash
</span></span></code><!--]--></pre><!--]--></div><div><!--[--><p data-v-f4353d2d=""><!--[-->üí° <a href="https://man7.org/linux/man-pages/man7/namespaces.7.html" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Other possible namespaces are<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>:<!--]--></p><ul data-v-80af725d=""><!--[--><li data-v-05c6bdd9=""><!--[--><code data-v-e8db53fc=""><!--[-->ipc<!--]--></code> - this namespace has no impact on the rootfs creation, so we&#39;re skipping it for brevity<!--]--></li><li data-v-05c6bdd9=""><!--[--><code data-v-e8db53fc=""><!--[-->time<!--]--></code> - (optional) not used by Docker or other mainstream container runtimes yet<!--]--></li><li data-v-05c6bdd9=""><!--[--><code data-v-e8db53fc=""><!--[-->user<!--]--></code> - (optional) rootless containers is an advanced topic that deserves its own tutorial<!--]--></li><!--]--></ul><!--]--></div><h3 id="step-3-isolate-new-mount-namespace" data-v-796c1f0b=""><!--[-->Step 3: Isolate new mount namespace<!--]--><!----></h3><div><!--[--><p data-v-f4353d2d=""><!--[-->From now on, all commands are executed as <code data-v-e8db53fc=""><!--[-->root<!--]--></code> and in the new namespaces, so we&#39;re skipping the <code data-v-e8db53fc=""><!--[-->sudo<!--]--></code> prefix,
and the <code data-v-e8db53fc=""><!--[-->CONTAINER_DIR<!--]--></code> and <code data-v-e8db53fc=""><!--[-->ROOTFS_DIR<!--]--></code> variables may need to be re-set:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>CONTAINER_DIR</span><span>=</span><span>/opt/container-2
</span></span><span line="2"><span>ROOTFS_DIR</span><span>=</span><span>${</span><span>CONTAINER_DIR</span><span>}</span><span>/rootfs
</span></span></code><!--]--></pre><!--]--></div><!--]--></div><p data-v-f4353d2d=""><!--[-->First, we need to make sure that no mount events are propagated back to the host&#39;s mount namespace:<!--]--></p><p data-v-f4353d2d=""><!--[-->Then, we need to make sure that the root filesystem itself is a mount point:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mount</span><span> --rbind</span><span> $ROOTFS_DIR</span><span> $ROOTFS_DIR
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->...and that the propagation type of the root filesystem isn&#39;t <code data-v-e8db53fc=""><!--[-->shared<!--]--></code>:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mount</span><span> --make-private</span><span> $ROOTFS_DIR
</span></span></code><!--]--></pre><!--]--></div><h3 id="step-4-prepare-proc-pseudo-filesystem" data-v-796c1f0b=""><!--[-->Step 4: Prepare /proc pseudo filesystem<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->Mount <code data-v-e8db53fc=""><!--[-->/proc<!--]--></code> pseudo filesystem:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mkdir</span><span> -p</span><span> $ROOTFS_DIR</span><span>/proc
</span></span><span line="2"><span>mount</span><span> -t</span><span> proc</span><span> proc</span><span> $ROOTFS_DIR</span><span>/proc
</span></span></code><!--]--></pre><!--]--></div><div><!--[--><p data-v-f4353d2d=""><!--[-->‚ö†Ô∏è <strong data-v-849f2d6a=""><!--[-->Security Caveat:<!--]--></strong> In untrusted rootfs, <code data-v-e8db53fc=""><!--[-->$ROOTFS_DIR/&lt;path&gt;<!--]--></code> can be a symlink pointing outside of <code data-v-e8db53fc=""><!--[-->$ROOTFS_DIR<!--]--></code>.
This can make the above and many of the below operations corrupt the host system.<!--]--></p><p data-v-f4353d2d=""><!--[-->Real-world container runtimes typically use the <a href="https://man7.org/linux/man-pages/man2/openat2.2.html" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[--><code data-v-e8db53fc=""><!--[-->openat2()<!--]--></code> syscall with the <code data-v-e8db53fc=""><!--[-->RESOLVE_NO_SYMLINKS<!--]--></code> flag<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a> to first open the target file or directory ensuring it&#39;s not a symlink,
and then use <code data-v-e8db53fc=""><!--[-->mount<!--]--></code> (or other filesystem operations) on an open file descriptor instead of a textual filename.
The latter helps to avoid <a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->TOCTTOU vulnerabilities<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>
when the <code data-v-e8db53fc=""><!--[-->$ROOTFS_DIR<!--]--></code> contents are changed <em data-v-bddc49f6=""><!--[-->while<!--]--></em> the container is being created.<!--]--></p><p data-v-f4353d2d=""><!--[-->However, in a demo context it should be relatively safe to operate with regular filenames.
So, we&#39;ll do it the simpler way for brevity.<!--]--></p><!--]--></div><h3 id="step-5-prepare-dev-pseudo-filesystem" data-v-796c1f0b=""><!--[-->Step 5: Prepare /dev pseudo filesystem<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->Mount <code data-v-e8db53fc=""><!--[-->/dev<!--]--></code> pseudo filesystem as a regular <code data-v-e8db53fc=""><!--[-->tmpfs<!--]--></code>:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mount</span><span> -t</span><span> tmpfs</span><span> \
</span></span><span line="2"><span>    -o</span><span> nosuid,strictatime,mode=0755,size=65536k</span><span> tmpfs</span><span> \
</span></span><span line="3"><span>    $ROOTFS_DIR</span><span>/dev
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Create the standard character devices (<code data-v-e8db53fc=""><!--[-->/dev/null<!--]--></code>, <code data-v-e8db53fc=""><!--[-->/dev/zero<!--]--></code>, <code data-v-e8db53fc=""><!--[-->/dev/random<!--]--></code>, etc.):<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mknod</span><span> -m</span><span> 666</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/null&#34;</span><span>    c</span><span> 1</span><span> 3
</span></span><span line="2"><span>mknod</span><span> -m</span><span> 666</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/zero&#34;</span><span>    c</span><span> 1</span><span> 5
</span></span><span line="3"><span>mknod</span><span> -m</span><span> 666</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/full&#34;</span><span>    c</span><span> 1</span><span> 7
</span></span><span line="4"><span>mknod</span><span> -m</span><span> 666</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/random&#34;</span><span>  c</span><span> 1</span><span> 8
</span></span><span line="5"><span>mknod</span><span> -m</span><span> 666</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/urandom&#34;</span><span> c</span><span> 1</span><span> 9
</span></span><span line="6"><span>mknod</span><span> -m</span><span> 666</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/tty&#34;</span><span>     c</span><span> 5</span><span> 0
</span></span><span line="7"><span emptylineplaceholder="true">
</span></span><span line="8"><span>chown</span><span> root:root</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/&#34;{null,zero,full,random,urandom,tty}
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Create typical symlinks:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>ln</span><span> -sf</span><span> /proc/self/fd</span><span>   &#34;</span><span>$ROOTFS_DIR</span><span>/dev/fd&#34;
</span></span><span line="2"><span>ln</span><span> -sf</span><span> /proc/self/fd/0</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/stdin&#34;
</span></span><span line="3"><span>ln</span><span> -sf</span><span> /proc/self/fd/1</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/stdout&#34;
</span></span><span line="4"><span>ln</span><span> -sf</span><span> /proc/self/fd/2</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/stderr&#34;
</span></span><span line="5"><span>ln</span><span> -sf</span><span> /proc/kcore</span><span>     &#34;</span><span>$ROOTFS_DIR</span><span>/dev/core&#34;
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Create subordinate filesystems (<code data-v-e8db53fc=""><!--[-->/dev/pts<!--]--></code>, <code data-v-e8db53fc=""><!--[-->/dev/shm<!--]--></code>, <code data-v-e8db53fc=""><!--[-->/dev/mqueue<!--]--></code>):<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mkdir</span><span> -p</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/pts&#34;
</span></span><span line="2"><span emptylineplaceholder="true">
</span></span><span line="3"><span>mount</span><span> -t</span><span> devpts</span><span> \
</span></span><span line="4"><span>    -o</span><span> newinstance,ptmxmode=0666,mode=</span><span>0620</span><span> devpts</span><span> \
</span></span><span line="5"><span>    $ROOTFS_DIR</span><span>/dev/pts
</span></span><span line="6"><span emptylineplaceholder="true">
</span></span><span line="7"><span>ln</span><span> -sf</span><span> /dev/pts/ptmx</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/ptmx&#34;
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mkdir</span><span> -p</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/mqueue&#34;
</span></span><span line="2"><span emptylineplaceholder="true">
</span></span><span line="3"><span>mount</span><span> -t</span><span> mqueue</span><span> \
</span></span><span line="4"><span>    -o</span><span> nosuid,nodev,noexec</span><span> mqueue</span><span> \
</span></span><span line="5"><span>    $ROOTFS_DIR</span><span>/dev/mqueue
</span></span></code><!--]--></pre><!--]--></div><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mkdir</span><span> -p</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/dev/shm&#34;
</span></span><span line="2"><span emptylineplaceholder="true">
</span></span><span line="3"><span>mount</span><span> -t</span><span> tmpfs</span><span> \
</span></span><span line="4"><span>    -o</span><span> nosuid,nodev,noexec,mode=1777,size=</span><span>67108864</span><span> tmpfs</span><span> \
</span></span><span line="5"><span>    $ROOTFS_DIR</span><span>/dev/shm
</span></span></code><!--]--></pre><!--]--></div><h3 id="step-6-prepare-sys-pseudo-filesystem" data-v-796c1f0b=""><!--[-->Step 6: Prepare /sys pseudo filesystem<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->Mount a read-only <code data-v-e8db53fc=""><!--[-->/sys<!--]--></code> pseudo filesystem:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mkdir</span><span> -p</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/sys&#34;
</span></span><span line="2"><span emptylineplaceholder="true">
</span></span><span line="3"><span>mount</span><span> -t</span><span> sysfs</span><span> \
</span></span><span line="4"><span>    -o</span><span> ro,nosuid,nodev,noexec</span><span> sysfs</span><span> \
</span></span><span line="5"><span>    $ROOTFS_DIR</span><span>/sys
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Mount the subordinate <code data-v-e8db53fc=""><!--[-->cgroup2<!--]--></code> filesystem as <code data-v-e8db53fc=""><!--[-->/sys/fs/cgroup<!--]--></code>:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>mkdir</span><span> -p</span><span> &#34;</span><span>$ROOTFS_DIR</span><span>/sys/fs/cgroup&#34;
</span></span><span line="2"><span emptylineplaceholder="true">
</span></span><span line="3"><span>mount</span><span> -t</span><span> cgroup2</span><span> \
</span></span><span line="4"><span>    -o</span><span> ro,nosuid,nodev,noexec</span><span> cgroup2</span><span> \
</span></span><span line="5"><span>    $ROOTFS_DIR</span><span>/sys/fs/cgroup
</span></span></code><!--]--></pre><!--]--></div><h3 id="step-7-bind-hostname-hosts-and-resolvconf-files" data-v-796c1f0b=""><!--[-->Step 7: Bind hostname, hosts, and resolv.conf files<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->Bind the container-specific <code data-v-e8db53fc=""><!--[-->hostname<!--]--></code>, <code data-v-e8db53fc=""><!--[-->hosts<!--]--></code>, and <code data-v-e8db53fc=""><!--[-->resolv.conf<!--]--></code> files from <code data-v-e8db53fc=""><!--[-->/opt/container-2<!--]--></code>,
masking the original files in the rootfs&#39; <code data-v-e8db53fc=""><!--[-->/etc<!--]--></code> directory:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>for</span><span> p</span><span> in</span><span> hostname</span><span> hosts</span><span> resolv.conf
</span></span><span line="2"><span>do
</span></span><span line="3"><span>  touch</span><span> $ROOTFS_DIR</span><span>/etc/</span><span>$p
</span></span><span line="4"><span>  mount</span><span> --bind</span><span> &#34;</span><span>$CONTAINER_DIR</span><span>/</span><span>$p</span><span>&#34;</span><span> $ROOTFS_DIR</span><span>/etc/</span><span>$p
</span></span><span line="5"><span>done
</span></span></code><!--]--></pre><!--]--></div><h3 id="step-8-pivot-into-the-new-rootfs" data-v-796c1f0b=""><!--[-->Step 8: Pivot into the new rootfs<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->Finally, pivot into the fully prepared root filesystem:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>cd</span><span> $ROOTFS_DIR
</span></span><span line="2"><span>mkdir</span><span> -p</span><span> .oldroot
</span></span><span line="3"><span emptylineplaceholder="true">
</span></span><span line="4"><span>pivot_root</span><span> .</span><span> .oldroot
</span></span></code><!--]--></pre><!--]--></div><div><!--[--><p data-v-f4353d2d=""><!--[-->This is not something a real runtime would do, but since we use a shell,
it&#39;s better to exec into the target container&#39;s shell
as soon as possible after the <code data-v-e8db53fc=""><!--[-->pivot_root<!--]--></code> call:<!--]--></p><!--]--></div><p data-v-f4353d2d=""><!--[-->Configure the propagation type of the container&#39;s root filesystem
(setting it arbitrarily to <code data-v-e8db53fc=""><!--[-->slave<!--]--></code>, <a href="https://github.com/opencontainers/runtime-spec/blob/383cadbf08c0be925b62a4532e99a538249797e6/config-linux.md#rootfs-mount-propagation" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->but the OCI Runtime Specification supports <code data-v-e8db53fc=""><!--[-->private<!--]--></code> and even <code data-v-e8db53fc=""><!--[-->shared<!--]--></code><!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>):<!--]--></p><p data-v-f4353d2d=""><!--[-->And lastly, getting rid of the link to the old root filesystem:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>umount</span><span> -l</span><span> .oldroot
</span></span><span line="2"><span>rmdir</span><span> .oldroot
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Set the hostname of the container using the value from the container&#39;s <code data-v-e8db53fc=""><!--[-->/etc/hostname<!--]--></code> file:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>hostname</span><span> $(</span><span>cat</span><span> /etc/hostname</span><span>)
</span></span></code><!--]--></pre><!--]--></div><h3 id="step-9-harden-container-filesystem" data-v-796c1f0b=""><!--[-->Step 9: Harden container filesystem<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->Making a good part of the <code data-v-e8db53fc=""><!--[-->/proc<!--]--></code> filesystem read-only:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>for</span><span> d</span><span> in</span><span> bus</span><span> fs</span><span> irq</span><span> sys</span><span> sysrq-trigger
</span></span><span line="2"><span>do
</span></span><span line="3"><span>  if</span><span> [ </span><span>-e</span><span> &#34;/proc/</span><span>$d</span><span>&#34;</span><span> ]; </span><span>then
</span></span><span line="4"><span>    mount</span><span> --bind</span><span> &#34;/proc/</span><span>$d</span><span>&#34;</span><span> &#34;/proc/</span><span>$d</span><span>&#34;
</span></span><span line="5"><span>    mount</span><span> -o</span><span> remount,bind,ro</span><span> &#34;/proc/</span><span>$d</span><span>&#34;
</span></span><span line="6"><span>  fi
</span></span><span line="7"><span>done
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Masking sensitive paths in the <code data-v-e8db53fc=""><!--[-->/proc<!--]--></code> and <code data-v-e8db53fc=""><!--[-->/sys<!--]--></code> filesystems:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>for</span><span> p</span><span> in</span><span> \
</span></span><span line="2"><span>  /proc/asound</span><span> \
</span></span><span line="3"><span>  /proc/interrupts</span><span> \
</span></span><span line="4"><span>  /proc/kcore</span><span> \
</span></span><span line="5"><span>  /proc/keys</span><span> \
</span></span><span line="6"><span>  /proc/latency_stats</span><span> \
</span></span><span line="7"><span>  /proc/timer_list</span><span> \
</span></span><span line="8"><span>  /proc/timer_stats</span><span> \
</span></span><span line="9"><span>  /proc/sched_debug</span><span> \
</span></span><span line="10"><span>  /proc/acpi</span><span> \
</span></span><span line="11"><span>  /proc/scsi</span><span> \
</span></span><span line="12"><span>  /sys/firmware
</span></span><span line="13"><span>do
</span></span><span line="14"><span>  if</span><span> [ </span><span>-d</span><span> &#34;</span><span>$p</span><span>&#34;</span><span> ]; </span><span>then
</span></span><span line="15"><span>    # Masking a folder
</span></span><span line="16"><span>    mount</span><span> -t</span><span> tmpfs</span><span> -o</span><span> ro</span><span> tmpfs</span><span> $p
</span></span><span line="17"><span>  elif</span><span> [ </span><span>-f</span><span> &#34;</span><span>$p</span><span>&#34;</span><span> ]; </span><span>then
</span></span><span line="18"><span>    # Masking a regular file
</span></span><span line="19"><span>    mount</span><span> --bind</span><span> /dev/null</span><span> $p
</span></span><span line="20"><span>  fi
</span></span><span line="21"><span>done
</span></span></code><!--]--></pre><!--]--></div><h3 id="step-10-execute-target-application" data-v-796c1f0b=""><!--[-->Step 10: Execute target application<!--]--><!----></h3><p data-v-f4353d2d=""><!--[-->At this point, the containerized environment is ready to be used.
Feel free to look around using the <code data-v-e8db53fc=""><!--[-->ps<!--]--></code>, <code data-v-e8db53fc=""><!--[-->ls<!--]--></code>, <code data-v-e8db53fc=""><!--[-->mount<!--]--></code>, <code data-v-e8db53fc=""><!--[-->df<!--]--></code>, <code data-v-e8db53fc=""><!--[-->hostname<!--]--></code>,
and any other commands you can think of, and then <code data-v-e8db53fc=""><!--[-->exec<!--]--></code> the containerized application:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>APP</span><span>=</span><span>${</span><span>APP</span><span>:-/</span><span>bin</span><span>/</span><span>sh</span><span>}
</span></span><span line="2"><span>exec</span><span> $APP
</span></span></code><!--]--></pre><!--]--></div><h2 id="bonus-sharing-host-files-and-folders-with-containers" data-v-2d6287ef=""><!--[-->Bonus: Sharing host files and folders with containers<!--]--><!----></h2><p data-v-f4353d2d=""><!--[-->One of the very common Docker use cases, especially during local development,
is sharing files and folders from the host into the container via <a href="https://docs.docker.com/engine/storage/bind-mounts/" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->bind mounts<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a> like this:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span># Traditional -v|--volume flag
</span></span><span line="2"><span>docker</span><span> run</span><span> -v</span><span> ./data:/data</span><span> redis
</span></span><span line="3"><span emptylineplaceholder="true">
</span></span><span line="4"><span># More modern but equivalent --mount form
</span></span><span line="5"><span>docker</span><span> run</span><span> --mount</span><span> type=&#39;bind,src=./data,dst=/data&#39;</span><span> redis
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->In the previous section(s), we saw that regular files located on the host can be bind mounted into the future container&#39;s root filesystem.
This is exactly how <del>Docker</del> runc and similar container runtimes inject the customized <code data-v-e8db53fc=""><!--[-->/etc/hosts<!--]--></code>, <code data-v-e8db53fc=""><!--[-->/etc/hostname<!--]--></code>, and <code data-v-e8db53fc=""><!--[-->/etc/resolv.conf<!--]--></code> files.<!--]--></p><p data-v-f4353d2d=""><!--[-->But the exact same technique can be used to inject any other files or folders from the host into the container.<!--]--></p><p data-v-f4353d2d=""><!--[-->The <code data-v-e8db53fc=""><!--[-->strace -p $(pgrep containerd)<!--]--></code> command that we used to reverse engineer the rootfs preparation steps
will reveal that the bind mounts of the <code data-v-e8db53fc=""><!--[-->-v|--volume<!--]--></code> flag happen right after the pseudo filesystems preparation
and just before the mounts of the <code data-v-e8db53fc=""><!--[-->/etc/hosts<!--]--></code>, <code data-v-e8db53fc=""><!--[-->/etc/hostname<!--]--></code>, and <code data-v-e8db53fc=""><!--[-->/etc/resolv.conf<!--]--></code> files.<!--]--></p><p data-v-f4353d2d=""><!--[-->And it&#39;s a good thing we invested some time in learning about the <em data-v-bddc49f6=""><!--[-->mount event propagation<!--]--></em> mechanism -
Docker allows <a href="https://docs.docker.com/engine/storage/bind-mounts/#configure-bind-propagation" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->configuring the propagation type for bind mounts<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>,
so the following command should not look like a magic spell anymore:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span>docker</span><span> run</span><span> -v</span><span> .:/project:ro,rshared</span><span> ...
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->In the above example, if the containerized application would mount a sub-folder under <code data-v-e8db53fc=""><!--[-->/project<!--]--></code>,
it would be visible on the host as well (and vice versa).
However, the default propagation type of a Docker bind mount is <code data-v-e8db53fc=""><!--[-->rprivate<!--]--></code>,
so don&#39;t be surprised if you don&#39;t see sub-mounts showing up.<!--]--></p><h2 id="bonus-adding-support-for-data-volumes" data-v-2d6287ef=""><!--[-->Bonus: Adding support for data volumes<!--]--><!----></h2><p data-v-f4353d2d=""><!--[-->While Docker docs position <a href="https://docs.docker.com/engine/storage/volumes/" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->volumes<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a> as a distinct concept,
under the hood, they are just bind mounts,
but with a few extra features like naming, lifecycle management, and various data source drivers support:<!--]--></p><div meta="" data-v-c399e391=""><!----><!--[--><pre><!--[--><code><span line="1"><span># Traditional -v|--volume flag
</span></span><span line="2"><span>docker</span><span> run</span><span> --volume</span><span> redis-data:/data</span><span> redis
</span></span><span line="3"><span emptylineplaceholder="true">
</span></span><span line="4"><span># More modern but equivalent --mount form
</span></span><span line="5"><span>docker</span><span> run</span><span> --mount</span><span> type=&#39;volume,src=redis-data,dst=/data&#39;</span><span> redis
</span></span></code><!--]--></pre><!--]--></div><p data-v-f4353d2d=""><!--[-->Instead of arbitrary folders on the host, volume data is always stored in <code data-v-e8db53fc=""><!--[-->/var/lib/docker/volumes/CONTAINER_ID/_data<!--]--></code>,
and you can list all existing volumes with the <code data-v-e8db53fc=""><!--[-->docker volume ls<!--]--></code> command, or create new ones with <code data-v-e8db53fc=""><!--[-->docker volume create<!--]--></code>,
or even purge them with <code data-v-e8db53fc=""><!--[-->docker volume rm<!--]--></code>.
But at the end of the day, you&#39;re just listing, creating, or removing <code data-v-e8db53fc=""><!--[-->_data<!--]--></code> folders in the <code data-v-e8db53fc=""><!--[-->/var/lib/docker/volumes<!--]--></code> directory.<!--]--></p><p data-v-f4353d2d=""><!--[-->Interesting that Docker always sets mount propagation for volumes to <code data-v-e8db53fc=""><!--[-->rprivate<!--]--></code> (for bind mounts you could tweak it),
while Kubernetes, despite relying on the exact same runc (or the like) runtime under the hood,
allows more flexible mount propagation configuration (<a href="https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[--><code data-v-e8db53fc=""><!--[-->HostToContainer<!--]--></code>, <code data-v-e8db53fc=""><!--[-->Bidirectional<!--]--></code>, etc.<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>).<!--]--></p><p data-v-f4353d2d=""><!--[-->So, in Docker, <strong data-v-849f2d6a=""><!--[-->bind mounts vs. volumes<!--]--></strong> is more of a semantic difference
(and induced artificial constraints on the data location and propagation type)
than an actual technical difference.<!--]--></p><h2 id="where-do-union-filesystems-come-into-play" data-v-2d6287ef=""><!--[-->Where do union filesystems come into play?<!--]--><!----></h2><p data-v-f4353d2d=""><!--[-->One of the things we didn&#39;t talk about in this article is <em data-v-bddc49f6=""><!--[-->union filesystems<!--]--></em> like <code data-v-e8db53fc=""><!--[-->overlayfs<!--]--></code> -
simply because despite popular belief, <strong data-v-849f2d6a=""><!--[-->they&#39;re not mandatory for containers.<!--]--></strong><!--]--></p><p data-v-f4353d2d=""><!--[-->As we just proved with the above demo, it&#39;s possible to create a fully-fledged container without relying on a union filesystem at all.
Docker uses <a href="https://docs.docker.com/engine/storage/drivers/overlayfs-driver/" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[--><code data-v-e8db53fc=""><!--[-->overlay2<!--]--></code><!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a> (or <a href="https://docs.docker.com/engine/storage/drivers/" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->an alternative<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a>) storage driver to unpack layered container images into &#34;flat&#34; local folders.
However, this is only an optimization, mainly focused on the disk space efficiency -
as we just saw, it&#39;s possible to extract a container image filesystem into a regular folder with <code data-v-e8db53fc=""><!--[-->crane export<!--]--></code> (or a similar command),
and the container runtime (e.g., runc) will happily use it as a root filesystem.<!--]--></p><h2 id="summarizing" data-v-2d6287ef=""><!--[-->Summarizing<!--]--><!----></h2><p data-v-f4353d2d=""><!--[-->At the heart of containers lies the <strong data-v-849f2d6a=""><!--[-->mount namespace<!--]--></strong>.
That&#39;s not an accident - Linux has long treated the filesystem as the central interface for managing processes, devices, and resources.
Once you start assembling a root filesystem for a container, it quickly becomes clear that other namespaces -
<strong data-v-849f2d6a=""><!--[-->PID<!--]--></strong>, <strong data-v-849f2d6a=""><!--[-->cgroup<!--]--></strong>, <strong data-v-849f2d6a=""><!--[-->UTS<!--]--></strong>, and <strong data-v-849f2d6a=""><!--[-->network<!--]--></strong> - are interconnected and much needed to complete the task.<!--]--></p><p data-v-f4353d2d=""><!--[-->This is why walking through the rootfs exercise isn&#39;t just an impressive low-level demo you could give at a conference.
It&#39;s a way to build a comprehensive mental model of how containers work.
And with that model in place, higher-level topics like bind mounts, volumes, mount propagation,
and persistence in Docker or Kubernetes stop feeling like special cases - they become natural extensions of the same foundation.<!--]--></p><p data-v-f4353d2d=""><!--[-->Ah, and if you made it this far, take another look at the diagram from the opening part -
it should make much more sense now!<!--]--></p><div><div><p><img src="https://labs.iximiuz.com/content/files/tutorials/container-filesystem-from-scratch/__static__/container-rootfs-full-rev2.png" alt="Container rootfs isolation is a collective work of several namespaces simultaneously: mount, PID, cgroup, UTS, and network (with the mount namespace laying the foundation)."/></p><!--[--><p data-v-f4353d2d=""><!--[--><i>Click to enlarge</i><!--]--></p><!--]--></div><!----></div><h2 id="resources" data-v-2d6287ef=""><!--[-->Resources<!--]--><!----></h2><ul data-v-80af725d=""><!--[--><li data-v-05c6bdd9=""><!--[--><a href="https://man7.org/linux/man-pages/man7/namespaces.7.html" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->namespaces(7) ‚Äî Linux manual page<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://man7.org/linux/man-pages/man7/mount_namespaces.7.html" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->mount_namespaces(7) ‚Äî Linux manual page<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://man7.org/linux/man-pages/man2/mount.2.html" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->mount(2) ‚Äî Linux manual page<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://man7.org/linux/man-pages/man2/pivot_root.2.html" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->pivot_root(2) ‚Äî Linux manual page<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Shared Subtrees - Linux kernel documentation<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://lwn.net/Articles/689856/" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Mount namespaces and shared subtrees - LWN.net<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://lwn.net/Articles/690679/" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Mount namespaces, mount propagation, and unbindable mounts - LWN.net<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://github.com/opencontainers/runtime-spec/blob/383cadbf08c0be925b62a4532e99a538249797e6/config.md#mounts" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Mounts - OCI Runtime Specification<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://github.com/opencontainers/runc/blob/b27d6f3f1af9a56f2770c8ec6e1a1ff986ca9c09/libcontainer/rootfs_linux.go" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->rootfs_linux.go - runc source code<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://docs.docker.com/engine/storage/bind-mounts/" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Bind mounts - Docker documentation<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://docs.docker.com/engine/storage/volumes/" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Volumes - Docker documentation<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://docs.docker.com/engine/storage/drivers/overlayfs-driver/" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->OverlayFS storage driver - Docker documentation<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Mount propagation - Kubernetes documentation<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://brauner.io/2023/02/28/mounting-into-mount-namespaces.html" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Mounting into mount namespaces - Christian Brauner&#39;s blog<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://jpetazzo.github.io/2015/01/13/docker-mount-dynamic-volumes/" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Attach a volume to a container while it is running - J√©r√¥me Petazzoni&#39;s blog<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><li data-v-05c6bdd9=""><!--[--><a href="https://sid-agrawal.ca/linux,/docker,/mount,/namespaces,/mount_namespaces/2024/11/26/docker-mounts.html" rel="nofollow" target="_blank" data-v-6d75e4e7=""><!--[-->Understanding the various mounts setup by a Docker container - Sid Agrawal&#39;s blog<!--]--><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" data-v-6d75e4e7=""><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"></path></svg></a><!--]--></li><!--]--></ul><h2 id="practice" data-v-2d6287ef=""><!--[-->Practice<!--]--><!----></h2><!--[--><!--]--><!--[--><!--]--><!--[--><!--]--><!--[--><!--]--></div><!----></div></div></div>
  </body>
</html>
