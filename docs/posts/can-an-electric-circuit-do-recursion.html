<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://electronics.stackexchange.com/a/158915/331615">Original</a>
    <h1>Can an electric circuit do recursion?</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
<p>First we need to decide what recursion really is. When you take a recursive function, there may exist a transformation that gets rid of the recursion, but introduces <em>state</em>. In other cases, the transformation will have to introduce <em>both</em> state <em>and</em> iteration. So, writing a function out recursively is a way of making state and possibly iteration <em>implicit</em>, as opposed to <em>explicit</em>. In other words, recursion is just a way of writing out the thing.</p>

<p>The state <em>is there anyway</em>, you&#39;re just not explicitly putting it down on paper. In languages such as C, recursive function calls usually store their state on the stack.</p>

<p>Now, any circuit that has <em>state</em> (stored charge, energy, etc.) - and that will be all of them, really - is, by definition, recursive. No iteration necessary :)</p>

<p>Concretely, let&#39;s work on a first-order IIR filter. Its output can be given by a recursive function. Given an input signal <code>x(t)</code>, the output <code>y(x(t), t) =  a1*y(x(t-1), t-1) + b0*x(t)</code>, where <code>a1</code> and <code>b0</code> are constants that parametrize the response. This is in discrete time - <code>t</code> is an integer with the unit of a number of clock cycles.</p>

<p>The C implementation, assuming <code>t&gt;=0</code> and <code>x(-1) == 0</code>, would be:</p>

<pre><code>float a1, b0;

// Recursive, Implicit State
float y(float (*x)(int), int t) {
  return t != 0 ? a1 * y(x(t-1), t-1) + b0 * x(t) : b0 * x(t);
}

// Non-Recursive, Explicit State
float y(float (*x)(int), int t) {
  static float y_prev = 0.0;
  if (1) { // optional to ensure correct use only
    static int t_prev = 0;
    assert(t_prev == t-1 || t == 0);
  }
  return y_prev = a1 * y_prev + b0 * x(t);
}
</code></pre>

<p>The code can be also be implemented as a first order switched-capacitor infinite impulse response filter.  You can certainly <em>build</em> such a system:</p>



<p><img src="https://i.stack.imgur.com/yXdNd.png" alt="schematic"/></p>



<p><sup><a href="https://medium.com/plugins/schematics?image=http%3a%2f%2fi.stack.imgur.com%2fyXdNd.png">simulate this circuit</a> â€“ Schematic created using <a href="https://www.circuitlab.com/" rel="noreferrer">CircuitLab</a></sup></p>

<p>SW1 flips twice in each clock cycle. With values shown, for 12 bit accuracy the clock is limited to 10kHz due to R4-C1 time constant. U1, U2, U3 are voltage followers - say op-amps configured for gain=1.</p>

<p>If we set <code>a1=(1-b0)</code>, and transform this to a continuous time differential equation, we can get the &#34;same&#34; (continuous) response with an RC circuit:</p>



<p><img src="https://i.stack.imgur.com/CwPHv.png" alt="schematic"/></p>



<p><sup><a href="https://medium.com/plugins/schematics?image=http%3a%2f%2fi.stack.imgur.com%2fCwPHv.png">simulate this circuit</a></sup></p>

<p>Here, T is the clock period of the clock feeding the switched capacitor circuit above, and U1 is a voltage follower.</p>

<p>When the frequencies of interest are limited to ~1/10th of the clock frequency, both the continuous-time and the discrete-time (switched capacitor) circuits respond the same.</p>

<p>Both circuits, and the code, can be modeled by a recursive function, also known as <a href="http://www.wikiwand.com/en/Low-pass_filter#/Discrete-time_realization" rel="noreferrer"><em>a recurrence relation</em></a>.</p>
    </div></div>
  </body>
</html>
