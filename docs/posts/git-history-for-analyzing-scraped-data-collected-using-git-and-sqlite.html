<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simonwillison.net/2021/Dec/7/git-history/">Original</a>
    <h1>Show HN: git-history, for analyzing scraped data collected using Git and SQLite</h1>
    
    <div id="readability-page-1" class="page"><div id="primary">

<div>




<p>I described <a href="https://simonwillison.net/2020/Oct/9/git-scraping/">Git scraping</a> last year: a technique for writing scrapers where you periodically snapshot a source of data to a Git repository in order to record changes to that source over time.</p>
<p>The open challenge was how to analyze that data once it was collected. <a href="https://datasette.io/tools/git-history">git-history</a> is my new tool designed to tackle that problem.</p>
<h4>Git scraping, a refresher</h4>
<p>A neat thing about scraping to a Git repository is that the scrapers themselves can be really simple. I demonstrated how to run scrapers for free using GitHub Actions in this <a href="https://simonwillison.net/2021/Mar/5/git-scraping/">five minute lightning talk</a> back in March.</p>
<p>Here’s a concrete example: California’s state fire department, Cal Fire, maintain an incident map at <a href="https://www.fire.ca.gov/incidents/">fire.ca.gov/incidents</a> showing the status of current large fires in the state.</p>
<p>I found the underlying data here:</p>
<pre><code>curl https://www.fire.ca.gov/umbraco/Api/IncidentApi/GetIncidents
</code></pre>
<p>Then I built <a href="https://github.com/simonw/ca-fires-history/blob/main/.github/workflows/scrape.yml">a simple scraper</a> that grabs a copy of that every 20 minutes and commits it to Git. I’ve been running that for 14 months now, and it’s collected <a href="https://github.com/simonw/ca-fires-history">1,559 commits</a>!</p>
<p>The thing that excites me most about Git scraping is that it can create truly unique datasets. It’s common for organizations not to keep detailed archives of what changed and where, so by scraping their data into a Git repository you can often end up with a more detailed history than they maintain themselves.</p>
<p>There’s one big challenge though; having collected that data, how can you best analyze it? Reading through thousands of commit differences and eyeballing changes to JSON or CSV files isn’t a great way of finding the interesting stories that have been captured.</p>
<h4>git-history</h4>
<p><a href="https://datasette.io/tools/git-history">git-history</a> is the new CLI tool I’ve built to answer that question. It reads through the entire history of a file and generates a SQLite database reflecting changes to that file over time. You can then use <a href="https://datasette.io/">Datasette</a> to explore the resulting data.</p>
<p>Here’s <a href="https://git-history-demos.datasette.io/ca-fires">an example database</a> created by running the tool against my <code>ca-fires-history</code> repository. I created the SQLite database by running this in the repository directory:</p>
<div><pre>git-history file ca-fires.db incidents.json \
  --namespace incident \
  --id UniqueId \
  --convert <span><span>&#39;</span>json.loads(content)[&#34;Incidents&#34;]<span>&#39;</span></span></pre></div>
<p><img alt="Animated gif showing the progress bar" src="https://static.simonwillison.net/static/2021/ca-fires-progress.gif"/></p>
<p>In this example we are processing the history of a single file called <code>incidents.json</code>.</p>
<p>We use the <code>UniqueId</code> column to identify which records are changed over time as opposed to newly created.</p>
<p>Specifying <code>--namespace incident</code> causes the created database tables to be called <code>incident</code> and <code>incident_version</code> rather than the default of <code>item</code> and <code>item_version</code>.</p>
<p>And we have a fragment of Python code that knows how to turn each version stored in that commit history into a list of objects compatible with the tool, see <a href="https://github.com/simonw/git-history/blob/0.6/README.md#custom-conversions-using---convert">--convert in the documentation</a> for details.</p>
<p>Let’s use the database to answer some questions about fires in California over the past 14 months.</p>
<p>The <code>incident</code> table contains a copy of the latest record for every incident. We can use that to see <a href="https://git-history-demos.datasette.io/ca-fires/incident">a map of every fire</a>:</p>
<p><img alt="A map showing 250 fires in California" src="https://static.simonwillison.net/static/2021/ca-fires-map.png"/></p>
<p>This uses the <a href="https://datasette.io/plugins/datasette-cluster-map">datasette-cluster-map</a> plugin, which draws a map of every row with a valid latitude and longitude column.</p>
<p>Where things get interesting is the <a href="https://git-history-demos.datasette.io/ca-fires/incident_version">incident_version</a> table. This is where changes between different scraped versions of each item are recorded.</p>
<p>Those 250 fires have 2,060 recorded versions. If we <a href="https://git-history-demos.datasette.io/ca-fires/incident_version?_facet=_item">facet by _item</a> we can see which fires had the most versions recorded. Here are the top ten:</p>
<ul>
<li>
<a href="https://git-history-demos.datasette.io/ca-fires/incident_version?_facet=_item&amp;_item__exact=174">Dixie Fire</a> 268</li>
<li>
<a href="https://git-history-demos.datasette.io/ca-fires/incident_version?_facet=_item&amp;_item__exact=209">Caldor Fire</a> 153</li>
<li>
<a href="https://git-history-demos.datasette.io/ca-fires/incident_version?_facet=_item&amp;_item__exact=197">Monument Fire</a> 65</li>
<li>
<a href="https://git-history-demos.datasette.io/ca-fires/incident_version?_facet=_item&amp;_item__exact=1">August Complex (includes Doe Fire)</a> 64</li>
<li>
<a href="https://git-history-demos.datasette.io/ca-fires/incident_version?_facet=_item&amp;_item__exact=2">Creek Fire</a> 56</li>
<li>
<a href="https://git-history-demos.datasette.io/ca-fires/incident_version?_facet=_item&amp;_item__exact=213">French Fire</a> 53</li>
<li>
<a href="https://git-history-demos.datasette.io/ca-fires/incident_version?_facet=_item&amp;_item__exact=32">Silverado Fire</a> 52</li>
<li>
<a href="https://git-history-demos.datasette.io/ca-fires/incident_version?_facet=_item&amp;_item__exact=240">Fawn Fire</a> 45</li>
<li>
<a href="https://git-history-demos.datasette.io/ca-fires/incident_version?_facet=_item&amp;_item__exact=34">Blue Ridge Fire</a> 39</li>
<li>
<a href="https://git-history-demos.datasette.io/ca-fires/incident_version?_facet=_item&amp;_item__exact=190">McFarland Fire</a> 34</li>
</ul>
<p>This looks about right—the larger the number of versions the longer the fire must have been burning. The Dixie Fire <a href="https://en.wikipedia.org/wiki/Dixie_Fire">has its own Wikipedia page</a>!</p>
<p>Clicking through to <a href="http://127.0.0.1:8334/ca-fires/incident_version?_facet=_item&amp;_item__exact=174">the Dixie Fire</a> lands us on a page showing every “version” that we captured, ordered by version number.</p>
<p><code>git-history</code> only writes values to this table that have changed since the previous version. This means you can glance at the table grid and get a feel for which pieces of information were updated over time:</p>
<p><img alt="The table showing changes to that fire over time" src="https://static.simonwillison.net/static/2021/ca-fires-incident-versions.png"/></p>
<p>The <code>ConditionStatement</code> is a text description that changes frequently, but the other two interesting columns look to be <code>AcresBurned</code> and <code>PercentContained</code>.</p>
<p>That <code>_commit</code> table is a foreign key to <a href="https://git-history-demos.datasette.io/ca-fires/commits">commits</a>, which records commits that have been processed by the tool— mainly so that when you run it a second time it can pick up where it finished last time.</p>
<p>We can join against <code>commits</code> to see the date that each version was created. Or we can use the <a href="https://git-history-demos.datasette.io/ca-fires/incident_version_detail">incident_version_detail</a> view which performs that join for us.</p>
<p>Using that view, we can filter for just rows where <code>_item</code> is 174 and <code>AcresBurned</code> is not blank, then use the <a href="">datasette-vega</a> plugin to visualize the <code>_commit_at</code> date column against the <code>AcresBurned</code> numeric column... and we get a graph of <a href="https://git-history-demos.datasette.io/ca-fires/incident_version_detail?_item__exact=174&amp;AcresBurned__notblank=1#g.mark=line&amp;g.x_column=_commit_at&amp;g.x_type=temporal&amp;g.y_column=AcresBurned&amp;g.y_type=quantitative">the growth of the Dixie Fire over time</a>!</p>
<p><img alt="The chart plugin showing a line chart" src="https://static.simonwillison.net/static/2021/ca-fires-chart.png"/></p>
<p>To review: we started out with a GitHub Actions scheduled workflow grabbing a copy of a JSON API endpoint every 20 minutes. Thanks to <code>git-history</code>, Datasette and <code>datasette-vega</code> we now have a chart showing the growth of the longest-lived California wildfire of the last 14 months over time.</p>
<h4>A note on schema design</h4>
<p>One of the hardest problems in designing <code>git-history</code> was deciding on an appropriate schema for storing version changes over time.</p>
<p>I ended up with the following (edited for clarity):</p>
<div><pre>CREATE TABLE [commits] (
   [id] <span>INTEGER</span> <span>PRIMARY KEY</span>,
   [hash] <span>TEXT</span>,
   [commit_at] <span>TEXT</span>
);
CREATE TABLE [item] (
   [_id] <span>INTEGER</span> <span>PRIMARY KEY</span>,
   [_item_id] <span>TEXT</span>,
   [IncidentID] <span>TEXT</span>,
   [Location] <span>TEXT</span>,
   [Type] <span>TEXT</span>,
   [_commit] <span>INTEGER</span>
);
CREATE TABLE [item_version] (
   [_id] <span>INTEGER</span> <span>PRIMARY KEY</span>,
   [_item] <span>INTEGER</span> <span>REFERENCES</span> [item]([_id]),
   [_version] <span>INTEGER</span>,
   [_commit] <span>INTEGER</span> <span>REFERENCES</span> [commits]([id]),
   [IncidentID] <span>TEXT</span>,
   [Location] <span>TEXT</span>,
   [Type] <span>TEXT</span>
);
CREATE TABLE [columns] (
   [id] <span>INTEGER</span> <span>PRIMARY KEY</span>,
   [namespace] <span>INTEGER</span> <span>REFERENCES</span> [namespaces]([id]),
   [name] <span>TEXT</span>
);
CREATE TABLE [item_changed] (
   [item_version] <span>INTEGER</span> <span>REFERENCES</span> [item_version]([_id]),
   [column] <span>INTEGER</span> <span>REFERENCES</span> [columns]([id]),
   <span>PRIMARY KEY</span> ([item_version], [column])
);</pre></div>
<p>As shown earlier, records in the <code>item_version</code> table represent snapshots over time—but to save on database space and provide a neater interface for browsing versions, they only record columns that had changed since their previous version. Any unchanged columns are stored as <code>null</code>.</p>
<p>There’s one catch with this schema: what do we do if a new version of an item sets one of the columns to <code>null</code>? How can we tell the difference between that and a column that didn’t change?</p>
<p>I ended up solving that with an <code>item_changed</code> many-to-many table, which uses pairs of integers (hopefully taking up as little space as possible) to record exactly which columns were modified in which <code>item_version</code> records.</p>
<p>The <code>item_version_detail</code> view displays columns from that many-to-many table as JSON—here’s <a href="https://git-history-demos.datasette.io/ca-fires/incident_version_detail?_version__gt=1&amp;_col=_changed_columns&amp;_col=_item&amp;_col=_version">a filtered example</a> showing which columns were changed in which versions of which items:</p>
<p><img alt="This table shows a JSON list of column names against items and versions" src="https://static.simonwillison.net/static/2021/ca-fires-changed-columns.png"/></p>
<p>Here’s <a href="https://git-history-demos.datasette.io/ca-fires?sql=select+columns.name%2C+count%28*%29%0D%0Afrom+incident_changed%0D%0A++join+incident_version+on+incident_changed.item_version+%3D+incident_version._id%0D%0A++join+columns+on+incident_changed.column+%3D+columns.id%0D%0Awhere+incident_version._version+%3E+1%0D%0Agroup+by+columns.name%0D%0Aorder+by+count%28*%29+desc">a SQL query</a> that shows, for <code>ca-fires</code>, which columns were updated most often:</p>
<div><pre><span>select</span> <span>columns</span>.<span>name</span>, <span>count</span>(<span>*</span>)
<span>from</span> incident_changed
  <span>join</span> incident_version <span>on</span> <span>incident_changed</span>.<span>item_version</span> <span>=</span> <span>incident_version</span>.<span>_id</span>
  <span>join</span> columns <span>on</span> <span>incident_changed</span>.<span>column</span> <span>=</span> <span>columns</span>.<span>id</span>
<span>where</span> <span>incident_version</span>.<span>_version</span> <span>&gt;</span> <span>1</span>
<span>group by</span> <span>columns</span>.<span>name</span>
<span>order by</span> <span>count</span>(<span>*</span>) <span>desc</span></pre></div>
<ul>
<li>Updated: 1785</li>
<li>PercentContained: 740</li>
<li>ConditionStatement: 734</li>
<li>AcresBurned: 616</li>
<li>Started: 327</li>
<li>PersonnelInvolved: 286</li>
<li>Engines: 274</li>
<li>CrewsInvolved: 256</li>
<li>WaterTenders: 225</li>
<li>Dozers: 211</li>
<li>AirTankers: 181</li>
<li>StructuresDestroyed: 125</li>
<li>Helicopters: 122</li>
</ul>
<p>Helicopters are exciting! Let’s find all of the fires which had at least one record where the number of helicopters changed (after the first version). We’ll use a nested SQL query:</p>
<div><pre><span>select</span> <span>*</span> <span>from</span> incident
<span>where</span> _id <span>in</span> (
  <span>select</span> _item <span>from</span> incident_version
  <span>where</span> _id <span>in</span> (
    <span>select</span> item_version <span>from</span> incident_changed <span>where</span> column <span>=</span> <span>15</span>
  )
  <span>and</span> _version <span>&gt;</span> <span>1</span>
)</pre></div>
<p>That returned 19 fires that were significant enough to involve helicopters—<a href="https://git-history-demos.datasette.io/ca-fires?sql=select+*+from+incident%0D%0Awhere+_id+in+%28%0D%0A++select+_item+from+incident_version%0D%0A++where+_id+in+%28%0D%0A++++select+item_version+from+incident_changed+where+column+%3D+15%0D%0A++%29%0D%0A++and+_version+%3E+1%0D%0A%29">here they are on a map</a>:</p>
<p><img alt="A map of 19 fires that involved helicopters" src="https://static.simonwillison.net/static/2021/ca-fire-helicopter-map.png"/></p>
<h4>Advanced usage of --convert</h4>
<p>Drew Breunig has been running a Git scraper for the past 8 months in <a href="https://github.com/dbreunig/511-events-history">dbreunig/511-events-history</a> against <a href="https://511.org/">511.org</a>, a site showing traffic incidents in the San Francisco Bay Area. I loaded his data into this example <a href="https://git-history-demos.datasette.io/sf-bay-511">sf-bay-511 database</a>.</p>
<p>The <code>sf-bay-511</code> example is useful for digging more into the <code>--convert</code> option to <code>git-history</code>.</p>
<p><code>git-history</code> requires recorded data to be in a specific shape: it needs a JSON list of JSON objects, where each object has a column that can be treated as a unique ID for purposes of tracking changes to that specific record over time.</p>
<p>The ideal tracked JSON file would look something like this:</p>
<div><pre>[
  {
    <span>&#34;IncidentID&#34;</span>: <span><span>&#34;</span>abc123<span>&#34;</span></span>,
    <span>&#34;Location&#34;</span>: <span><span>&#34;</span>Corner of 4th and Vermont<span>&#34;</span></span>,
    <span>&#34;Type&#34;</span>: <span><span>&#34;</span>fire<span>&#34;</span></span>
  },
  {
    <span>&#34;IncidentID&#34;</span>: <span><span>&#34;</span>cde448<span>&#34;</span></span>,
    <span>&#34;Location&#34;</span>: <span><span>&#34;</span>555 West Example Drive<span>&#34;</span></span>,
    <span>&#34;Type&#34;</span>: <span><span>&#34;</span>medical<span>&#34;</span></span>
  }
]</pre></div>
<p>It’s common for data that has been scraped to not fit this ideal shape.</p>
<p>The <code>511.org</code> JSON feed <a href="https://backend-prod.511.org/api-proxy/api/v1/traffic/events/?extended=true">can be found here</a>—it’s a pretty complicated nested set of objects, and there’s a bunch of data in there that’s quite noisy without adding much to the overall analysis—things like a <code>updated</code> timestamp field that changes in every version even if there are no changes, or a deeply nested <code>&#34;extension&#34;</code> object full of duplicate data.</p>
<p>I wrote a snippet of Python to transform each of those recorded snapshots into a simpler structure, and then passed that Python code to the <code>--convert</code> option to the script:</p>
<pre><code>#!/bin/bash
git-history file sf-bay-511.db 511-events-history/events.json \
  --repo 511-events-history \
  --id id \
  --convert &#39;
data = json.loads(content)
if data.get(&#34;error&#34;):
    # {&#34;code&#34;: 500, &#34;error&#34;: &#34;Error accessing remote data...&#34;}
    return
for event in data[&#34;Events&#34;]:
    event[&#34;id&#34;] = event[&#34;extension&#34;][&#34;event-reference&#34;][&#34;event-identifier&#34;]
    # Remove noisy updated timestamp
    del event[&#34;updated&#34;]
    # Drop extension block entirely
    del event[&#34;extension&#34;]
    # &#34;schedule&#34; block is noisy but not interesting
    del event[&#34;schedule&#34;]
    # Flatten nested subtypes
    event[&#34;event_subtypes&#34;] = event[&#34;event_subtypes&#34;][&#34;event_subtype&#34;]
    if not isinstance(event[&#34;event_subtypes&#34;], list):
        event[&#34;event_subtypes&#34;] = [event[&#34;event_subtypes&#34;]]
    yield event
&#39;
</code></pre>
<p>The single-quoted string passed to <code>--convert</code> is compiled into a Python function and run against each Git version in turn. My code loops through the nested <code>Events</code> list, modifying each record and then outputting them as an iterable sequence using <code>yield</code>.</p>
<p>A few of the records in the history were server 500 errors, so the code block knows how to identify and skip those as well.</p>
<p>When working with <code>git-history</code> I find myself spending most of my time iterating on these conversion scripts. Passing strings of Python code to tools like this is a pretty fun pattern—I also used it <a href="https://simonwillison.net/2021/Aug/6/sqlite-utils-convert/">for sqlite-utils convert</a> earlier this year.</p>
<h4>Trying this out yourself</h4>
<p>If you want to try this out for yourself the <code>git-history</code> tool has <a href="https://github.com/simonw/git-history/blob/main/README.md">an extensive README</a> describing the other options, and the scripts used to create these demos can be found in the <a href="https://github.com/simonw/git-history/tree/main/demos">demos folder</a>.</p>
<p>The <a href="https://github.com/topics/git-scraping">git-scraping topic</a> on GitHub now has over 200 repos now built by dozens of different people—that’s a lot of interesting scraped data sat there waiting to be explored!</p>




</div>

</div></div>
  </body>
</html>
