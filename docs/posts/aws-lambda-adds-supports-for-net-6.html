<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aws.amazon.com/blogs/compute/introducing-the-net-6-runtime-for-aws-lambda/">Original</a>
    <h1>AWS Lambda adds supports for .NET 6</h1>
    
    <div id="readability-page-1" class="page"><section property="articleBody"> 
       <p><em>This is written by Norm Johanson, Senior Software Dev Engineer.</em></p> 
       <p>You can now use the <a href="https://dotnet.microsoft.com/en-us/download" target="_blank" rel="noopener noreferrer">.NET 6</a> runtime to build <a href="https://aws.amazon.com/lambda/" target="_blank" rel="noopener noreferrer">AWS Lambda</a> functions. The new managed runtime supports both <strong>x86</strong> and <strong>Arm/Graviton2</strong> processors. You can get started with .NET 6 and Lambda using your tool of choice, including Visual Studio 2022 with the <a href="https://marketplace.visualstudio.com/items?itemName=AmazonWebServices.AWSToolkitforVisualStudio2022" target="_blank" rel="noopener noreferrer">AWS Toolkit for Visual Studio</a>, the .NET CLI with the <a href="https://github.com/aws/aws-extensions-for-dotnet-cli/#aws-lambda-amazonlambdatools" target="_blank" rel="noopener noreferrer">Amazon.Lambda.Tools</a> global tool, and the <a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html" target="_blank" rel="noopener noreferrer">AWS Serverless Application Model CLI (AWS SAM CLI</a>).</p> 
       <p>.NET 6 has many new <a href="https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-6" target="_blank" rel="noopener noreferrer">features</a> for .NET developers including support for <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10" target="_blank" rel="noopener noreferrer">C# 10</a> and <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/whats-new/fsharp-6" target="_blank" rel="noopener noreferrer">F# 6</a>. In addition to these features in .NET 6, this blog post explains new features added to the .NET Lambda experience. You can use these to improve diagnostics and performance and use new coding patterns.</p> 
       <h2>Improved logging</h2> 
       <p>Logging in .NET Lambda functions has been improved for .NET 6, providing better traceability, and control of what is being logged. If you prefer the style of logging in previous .NET managed runtimes, set the environment variable <code>AWS_LAMBDA_HANDLER_LOG_FORMAT</code> to <code>Unformatted</code>.</p> 
       <h3>Request ID</h3> 
       <p>One of the common requested features for the previous .NET Lambda runtime is adding the Lambda request ID to logs for better traceability. This is available in the .NET 6 runtime, making the .NET logging format similar to other Lambda runtimes.</p> 
       <h3>Log levels</h3> 
       <p>.NET 6 logging uses log levels. The <code>ILambdaLogger</code> is accessed from the <code>ILambdaContext</code> and has the following new logging APIs:</p> 
       <ul> 
        <li>LogCritical(string message)</li> 
        <li>LogError(string message)</li> 
        <li>LogWarning(string message)</li> 
        <li>LogInformation(string message)</li> 
        <li>LogDebug(string message)</li> 
        <li>LogTrace(string message)</li> 
        <li>Log(LogLevel level, string message)</li> 
       </ul> 
       <p>Levels for log messages are visible in <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/WhatIsCloudWatchLogs.html" target="_blank" rel="noopener noreferrer">Amazon CloudWatch Logs</a>, like the request id. This makes it easier to filter and search the logs for particular types of messages, such as errors or warnings.</p> 
       <p><code>Console.WriteLine</code> calls are written to CloudWatch Logs as an info level message; <code>Console.Error.WriteLine</code> calls are written as error level.</p> 
       <p>The following example shows using info messages for logging the fetched user object. It writes a warning message if the user is not found:</p> 
       <pre><code>public APIGatewayProxyResponse Get(APIGatewayProxyRequest request, ILambdaContext context)
{
    User user = null;
    try
    {
        var id = request.PathParameters[&#34;id&#34;];

        context.Logger.LogInformation($&#34;Loading user {id}&#34;);
        user = FetchUser(id);
        context.Logger.LogInformation($&#34;User: {user.Name}&#34;);
    }
    catch(Exception e)
    {
        context.Logger.LogWarning($&#34;Unable to find user: {e.Message}&#34;);
    }

    ...

}
</code></pre> 
       <p>When the user cannot be fetched, this is the resulting log messages showing the log level and request id:</p> 
       <p><a href="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2022/01/04/net-1.png"><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2022/01/04/net-1-1024x263.png" alt="Log messages" width="1024" height="263"/></a></p> 
       <p>By default, <strong>info</strong> level messages or higher are written to CloudWatch Logs. You can adjust the level written to CloudWatch Logs using the <code>AWS_LAMBDA_HANDLER_LOG_LEVEL</code> environment variable. The value of the environment variable is set to the values of the <a href="https://github.com/aws/aws-lambda-dotnet/blob/master/Libraries/src/Amazon.Lambda.Core/ILambdaLogger.cs#L7" target="_blank" rel="noopener noreferrer">LogLevel</a> enum.</p> 
       <p>With this new filtering, you can instrument Lambda functions with additional logging using the<strong> debug</strong> and <strong>trace </strong>log levels. This allows you to turn on additional logging from Lambda functions for troubleshooting, without redeploying new code.</p> 
       <h2>Using source generator for JSON serialization</h2> 
       <p>C# 9 provides source generators, which allow code generation during compilation. This can reduce the use of reflection APIs and improve application startup time. .NET 6 updated the native JSON library <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-source-generation" target="_blank" rel="noopener noreferrer">System.Text.Json to use source generators</a>, allowing JSON parsing without requiring reflection APIs.</p> 
       <p>When targeting .NET 6 support, you can take advantage of System.Text.Json’s source generator support to improve cold start performance. This is done using the <strong>Amazon.Lambda.Serialization.SystemTextJson</strong> package that handles the serialization of Lambda events and responses to .NET types.</p> 
       <p>To use the source generator, you must define a new empty class in your project that derives from <code>System.Text.Json.Serialization.JsonSerializerContext</code>. This class must be a partial class because the source generator adds code to this class to handle serialization. On the empty partial class, add the <code>JsonSerializable</code> attribute for each .NET type the source generator must generate the serialization code for.</p> 
       <p>Here is an example called <code>HttpApiJsonSerializerContext</code> that registers the <a href="https://aws.amazon.com/api-gateway/" target="_blank" rel="noopener noreferrer">Amazon API Gateway</a> HTTP API event and response types to have the serialization code generated:</p> 
       <pre><code>[JsonSerializable(typeof(APIGatewayHttpApiV2ProxyRequest))]
[JsonSerializable(typeof(APIGatewayHttpApiV2ProxyResponse))]
public partial class HttpApiJsonSerializerContext : JsonSerializerContext
{
}
</code></pre> 
       <p>Lambda functions using <strong>Amazon.Lambda.Serialization.SystemTextJson</strong> use the <code>Amazon.Lambda.Core.LambdaSerializer</code> attribute to register the serializer. Most commonly the <code>DefaultLambdaJsonSerializer</code> type is specified. To use the source generator, you must register <code>SourceGeneratorLambdaJsonSerializer</code>, passing the previously defined JsonSerializerContext subclass as the generic parameter.</p> 
       <p>Here is an example of registering the serializer using the <code>HttpApiJsonSerializerContext</code> type:</p> 
       <pre><code>[assembly: LambdaSerializer(typeof(SourceGeneratorLambdaJsonSerializer&lt;APIGatewayExampleImage.HttpApiJsonSerializerContext&gt;))]</code></pre> 
       <p>After these steps, Lambda uses the source-generated JSON serialization code to handle all of the serialization of Lambda events and responses. Reflection API calls are not used for serialization, improving the Lambda function’s cold start performance.</p> 
       <p>Below is a full example of an API Gateway-based Lambda function using the source generator.</p> 
       <pre><code>using System.Collections.Generic;
using System.Net;
using System.Text.Json.Serialization;


using Amazon.Lambda.Core;
using Amazon.Lambda.APIGatewayEvents;
using Amazon.Lambda.Serialization.SystemTextJson;

[assembly: LambdaSerializer(typeof(SourceGeneratorLambdaJsonSerializer&lt;SourceGeneratorExample.HttpApiJsonSerializerContext&gt;))]

namespace SourceGeneratorExample;

[JsonSerializable(typeof(APIGatewayHttpApiV2ProxyRequest))]
[JsonSerializable(typeof(APIGatewayHttpApiV2ProxyResponse))]
public partial class HttpApiJsonSerializerContext : JsonSerializerContext
{
}


public class Functions
{
    public APIGatewayProxyResponse Get(APIGatewayHttpApiV2ProxyRequest request, ILambdaContext context)
    {
        context.Logger.LogInformation(&#34;Get Request&#34;);

        var response = new APIGatewayHttpApiV2ProxyResponse
        {
            StatusCode = (int)HttpStatusCode.OK,
            Body = &#34;Hello AWS Serverless&#34;,
            Headers = new Dictionary&lt;string, string&gt; { { &#34;Content-Type&#34;, &#34;text/plain&#34; } }
        };

        return response;
    }
}
</code></pre> 
       <h2>Top-level statements</h2> 
       <p>The new .NET 6 Lambda runtime adds support for writing Lambda functions using C# 9’s <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/top-level-statements" target="_blank" rel="noopener noreferrer">top-level statements</a> feature. Top-level statements allow you to remove much of the initial boilerplate code for a .NET project.</p> 
       <p>In a typical hello world example:</p> 
       <pre><code>using System;

namespace Application
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(“Enjoying .NET 6 in AWS Lambda”);
        }
    }
}
</code></pre> 
       <p>With top-level statements, you can write this in one line, removing brackets, indentations, namespaces, and type declarations:</p> 
       <pre><code>Console.WriteLine(“Enjoying .NET 6 in AWS Lambda”);</code></pre> 
       <p>At a high level, the C# compiler generates the .NET assembly’s Main() method, with your top-level code within it.</p> 
       <h3>Executable assemblies</h3> 
       <p>With top-level statements, the Main() method has been generated by the compiler. This is different from the traditional way of writing .NET Lambda functions. Previously, a Lambda project is a class library and the Lambda function handler is set to the assembly, type, and method name that the Lambda runtime client invokes.</p> 
       <p>Here is an example of .NET Lambda function handler string:</p> 
       <p><code>LambdaProject::LambdaProject.Function::FunctionHandler</code></p> 
       <p>And here is what the code for this function handler could look like:</p> 
       <pre><code>using System.IO;
using System.Threading.Tasks;

using Amazon.Lambda.Core;
using Amazon.Lambda.S3Events;
using Amazon.S3;

// Assembly attribute to enable the Lambda function’s JSON input to be converted into a .NET class.
[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace LambdaProject
{
    public class Function
    {
        IAmazonS3 _s3Client;

        public Function()
        {
            _s3Client = new AmazonS3Client();
        }

        public async Task FunctionHandler(S3Event evnt, IlambdaContext context)
        {
            foreach (var record in evnt.Records)
            {
                using var response = await _s3Client.GetObjectAsync(record.S3.Bucket.Name, record.S3.Object.Key);
                using var reader = new StreamReader(response.ResponseStream);
                // Run business logic on the text contexts of the S3 object
            }
        }
    }
}
</code></pre> 
       <p>Using reflection, the .NET Lambda runtime client uses the function handler string to identify the method to call in the .NET assembly.</p> 
       <p>When using top-level statements, you instead tell Lambda to run the assembly, which runs the top-level statements. To indicate that you want Lambda to run the assembly, set the Lambda function handler to the assembly name only. Using the previous example, the .NET Lambda function handler string is <code>LambdaProject</code>.</p> 
       <p>With the .NET assembly containing the Lambda function being run at startup, instead of the Lambda runtime client, your function code must start the Lambda runtime client so that Lambda events are sent to your code.</p> 
       <p>To start the Lambda runtime client:</p> 
       <ol> 
        <li>Add the <a href="https://www.nuget.org/packages/Amazon.Lambda.RuntimeSupport/" target="_blank" rel="noopener noreferrer">Amazon.Lambda.RuntimeSupport</a> NuGet package to your project.</li> 
        <li>In the file that defines all of your top-level statements add to the end of the file the code to start the Lambda runtime client. The exact code is shown at the end of the example below.</li> 
       </ol> 
       <p>This is a full example of a C# Lambda function using top-level statements that processes Lambda events:</p> 
       <pre><code>using Amazon.Lambda.Core;
using Amazon.Lambda.RuntimeSupport;
using Amazon.Lambda.Serialization.SystemTextJson;
using Amazon.Lambda.S3Events;
using Amazon.S3;

// Code outside of the handler will be executed during Lambda initialization
var s3Client = new AmazonS3Client();

// The function handler that will be called for each Lambda event
var handler = async (S3Event evnt, ILambdaContext context) =&gt;
{
    foreach(var record in evnt.Records)
    {
        using var response = await s3Client.GetObjectAsync(record.S3.Bucket.Name, record.S3.Object.Key);
        using var reader = new StreamReader(response.ResponseStream);
        // Run business logic on the text contexts of the S3 object
    }
};

// Build the Lambda runtime client passing in the handler to call for each
// event and the JSON serializer to use for translating Lambda JSON documents
// to .NET types.
await LambdaBootstrapBuilder.Create(handler, new DefaultLambdaJsonSerializer())
        .Build()
        .RunAsync();
</code></pre> 
       <h2>ASP.NET Core minimal APIs</h2> 
       <p>Since the first .NET Lambda runtime, you can run ASP.NET Core applications as Lambda functions using the <a href="https://www.nuget.org/packages/Amazon.Lambda.AspNetCoreServer/" target="_blank" rel="noopener noreferrer">Amazon.Lambda.AspNetCoreServer</a> NuGet package.</p> 
       <p>.NET 6 introduces a new style of writing ASP.NET Core applications called <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis?view=aspnetcore-6.0" target="_blank" rel="noopener noreferrer">Minimal APIs</a>. These take advantage of C# 9’s top-level statement support simplifying the initialization of an ASP.NET Core application, allowing you to define an entire ASP.NET Core application in a single file.</p> 
       <p>To deploy an ASP.NET Core application using Minimal APIs to Lambda:</p> 
       <ol> 
        <li>Add the <a href="https://www.nuget.org/packages/Amazon.Lambda.AspNetCoreServer.Hosting/" target="_blank" rel="noopener noreferrer">Amazon.Lambda.AspNetCoreServer.Hosting</a> NuGet package to your project.</li> 
        <li>Add a call to <code>AddAWSLambdaHosting</code> in your application when the services are being defined for the application. The argument for <code>AddAWSLambdaHosting</code> is the event source for the Lambda function. This can be an API Gateway REST or HTTP API, or an <a href="https://aws.amazon.com/elasticloadbalancing/application-load-balancer/" target="_blank" rel="noopener noreferrer">Application Load Balancer</a>.</li> 
       </ol> 
       <p>When the ASP.NET Core project is run locally, <code>AddAWSLambdaHosting</code> does nothing, allowing the normal .NET Kestrel web server to handle the local experience. When running in Lambda, <code>AddAWSLambdaHosting</code> swaps out Kestrel with <strong>Amazon.Lambda.AspNetCoreServer </strong>allowing Lambda and API Gateway to act as the web server instead of Kestrel. Since Minimal APIs take advantage of top-level statements, <code>AddAWSLambdaHosting</code> also starts the Lambda runtime client.</p> 
       <p>This example shows a Minimal API ASP.NET Core application. There is one Lambda-specific line calling <code>AddAWSLambdaHosting</code> that configures the project for Lambda support:</p> 
       <pre><code>using Amazon.S3;

var builder = WebApplication.CreateBuilder(args);

// Add Swagger/OpenAPI support
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Add S3 service client to dependency injection container
builder.Services.AddAWSService&lt;IAmazonS3&gt;();

// Add AWS Lambda support.
builder.Services.AddAWSLambdaHosting(LambdaEventSource.HttpApi);

var app = builder.Build();

app.UseSwagger();
app.UseSwaggerUI();

// Example GET route
app.MapGet(&#34;/document/{name}&#34;, async (IAmazonS3 s3Client, string name) =&gt;
{
    using var response = await s3Client.GetObjectAsync(app.Configuration[&#34;S3Bucket&#34;], name);
    using var reader = new StreamReader(response.ResponseStream);
    var content = await reader.ReadToEndAsync();

    // Run business logic on the text contexts of the S3 object

    return content;
});

app.Run();</code></pre> 
       <p>You must deploy as an executable assembly so the function handler string is set to the assembly name only. For example, this is how the preceding ASP.NET Core application is defined in <a href="https://aws.amazon.com/cloudformation/" target="_blank" rel="noopener noreferrer">AWS CloudFormation</a>:</p> 
       <pre><code>   ...
    
   &#34;AspNetCoreFunction&#34;: {
      &#34;Type&#34;: &#34;AWS::Serverless::Function&#34;,
      &#34;Properties&#34;: {
        &#34;Handler&#34;: &#34;AspNetCoreMinimalApiExample&#34;, // The assembly name only
        &#34;Runtime&#34;: &#34;dotnet6&#34;
        &#34;MemorySize&#34;: 256,
        &#34;Timeout&#34;: 30,
        &#34;Role&#34;: null,
        &#34;Policies&#34;: [
          &#34;AWSLambda_FullAccess&#34;,
          &#34;AmazonS3ReadOnlyAccess&#34;
        ],
        &#34;Events&#34;: {
          &#34;ProxyResource&#34;: {
            &#34;Type&#34;: &#34;HttpApi&#34;,
            &#34;Properties&#34;: {
              &#34;Path&#34;: &#34;/{proxy+}&#34;,
              &#34;Method&#34;: &#34;ANY&#34;
            }
          },
          &#34;RootResource&#34;: {
            &#34;Type&#34;: &#34;HttpApi&#34;,
            &#34;Properties&#34;: {
              &#34;Path&#34;: &#34;/&#34;,
              &#34;Method&#34;: &#34;ANY&#34;
            }
          }
        }
      }
    }
  },
  
  ...
</code></pre> 
       <h2>Open source Lambda runtime client</h2> 
       <p>Over the last few years, AWS has open sourced more components of Lambda to help the community contribute to the Lambda experience. For .NET, you can find all the AWS client libraries in the <a href="https://github.com/aws/aws-lambda-dotnet" target="_blank" rel="noopener noreferrer">aws/aws-lambda-dotnet</a> GitHub repository.</p> 
       <p>For .NET 6, the managed runtime now uses the open source <a href="https://github.com/aws/aws-lambda-dotnet/tree/master/Libraries/src/Amazon.Lambda.RuntimeSupport" target="_blank" rel="noopener noreferrer">Lambda runtime client</a> from the <a href="https://github.com/aws/aws-lambda-dotnet" target="_blank" rel="noopener noreferrer">aws/aws-lambda-dotnet</a> repository. Previously, the open source Lambda runtime client was used for functions that used Lambda’s custom runtime or container-image based support.</p> 
       <p>Now you have a consistent and transparent Lambda runtime client experience in all environments whether that is the managed runtime, container images or using the Lambda runtime client for .NET custom runtimes. The switch from the previous runtime client to the open source runtime client is transparent as Lambda functions are migrated to .NET 6.</p> 
       <p>The open source Lambda runtime client has different performance characteristics than the .NET Core 3.1 Lambda runtime client. This is because the open source client uses all managed code, whereas the .NET Core 3.1 client uses a mix of managed and native code. In our testing, cold starts for basic “Hello, world!” functions may be slightly faster in .NET Core 3.1. However, for Lambda functions that do real world work, the testing shows a significant cold start improvement in .NET 6. For example, a .NET 6 Lambda function that uses the AWS .NET SDK to retrieve an item from DynamoDB showed a 25% performance improvement.</p> 
       <h2>Migrating to .NET 6</h2> 
       <p>To migrate existing .NET Lambda functions to the new .NET 6 runtime:</p> 
       <ol> 
        <li>Open the csproj or fsproj file. Set the TargetFramework element to net6.0.</li> 
        <li>Open the aws-lambda-tools-defaults.json file, if it exists: 
         <ol> 
          <li>Set the function-runtime field to dotnet6</li> 
          <li>Set the framework field to net6.0. If you remove the field, the value is inferred from the project file.</li> 
         </ol> </li> 
        <li>If it exists, open the serverless.template file. For any AWS::Lambda::Function or AWS::Servereless::Function resource, set the Runtime property to dotnet6.</li> 
        <li>Update all Amazon.Lambda.* NuGet package references to the latest versions.</li> 
       </ol> 
       <h2>Conclusion</h2> 
       <p>We are excited to add support for .NET 6 to Lambda. It’s fast to get started or migrate existing functions to .NET 6, with many new features in .NET 6 to take advantage of. Read the Lambda Developer Guide for more <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-csharp.html" target="_blank" rel="noopener noreferrer">getting started</a> information.</p> 
       <p>To provide feedback for .NET on AWS Lambda, contact the AWS .NET team on the <a href="https://github.com/aws/aws-lambda-dotnet" target="_blank" rel="noopener noreferrer">.NET Lambda GitHub</a> repository.</p> 
       <p>For more serverless learning resources, visit <a href="https://serverlessland.com" target="_blank" rel="noopener noreferrer">Serverless Land</a>.</p> 
       <!-- '"` --> 
      </section></div>
  </body>
</html>
