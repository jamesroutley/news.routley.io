<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scarybeastsecurity.blogspot.com/2020/11/reverse-engineering-forgotten-1970s.html">Original</a>
    <h1>Reverse engineering a forgotten 1970s Intel dual core beast: 8271 (2020)</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-8807496949986478566" itemprop="description articleBody">
<p><a href="https://1.bp.blogspot.com/-BAxgZgYqEm0/X6hp_uyJdjI/AAAAAAAAzM8/RdX_oVoeX8cYYuwPCwSyvt9gxGFAsD_7QCLcBGAsYHQ/s2444/intel1978.jpg"><img data-original-height="330" data-original-width="2444" height="86" src="https://1.bp.blogspot.com/-BAxgZgYqEm0/X6hp_uyJdjI/AAAAAAAAzM8/RdX_oVoeX8cYYuwPCwSyvt9gxGFAsD_7QCLcBGAsYHQ/w640-h86/intel1978.jpg" width="640"/></a></p><p>&#34;<b>As I recall, those two chips were fairly large. And fairly late -- to the marketplace. We had lots of issues with them. [...] Sometimes the elegant solution isn&#39;t the best solution.</b>&#34; -- Dave House, digressing to the 8271 during &#34;Oral History Panel on the Development and Promotion of the Intel 8080 Microprocessor&#34; [<a href="http://archive.computerhistory.org/resources/text/Oral_History/Intel_8080/102658123.05.01.pdf" target="_blank">link</a>], April 26th 2007, Computer History Museum, Mountain View, California.</p><h2>Introduction</h2><p>Around 1977, Intel released a floppy disc controller (FDC) chip called the 8271. This controller isn&#39;t particularly well known. It was mainly used in business computers and storage solutions, but its one breakthrough into the consumer space was with the <a href="https://en.wikipedia.org/wiki/BBC_Micro" target="_blank">BBC Micro</a>, a UK-centric computer released in 1981.</p><table><tbody><tr><td><a href="https://1.bp.blogspot.com/-Nc7F7ELiKcg/X6tty3pLYaI/AAAAAAAAzOM/gAxepoBzq3ANNtsZPbgm7mhWZ--cUEA4gCLcBGAsYHQ/s267/i8271.png"><img data-original-height="267" data-original-width="234" src="https://1.bp.blogspot.com/-Nc7F7ELiKcg/X6tty3pLYaI/AAAAAAAAzOM/gAxepoBzq3ANNtsZPbgm7mhWZ--cUEA4gCLcBGAsYHQ/s0/i8271.png"/></a></td></tr><tr><td>Intel 8271 (left) in an issue 3 BBC Micro model B</td></tr></tbody></table><p>There are very few easily discovered details about this chip online, aside from the useful <a href="http://www.nj7p.org/Manuals/PDFs/Intel/AFN-00223B.pdf" target="_blank">datasheet</a>. This, combined with increasing observations of strange behavior, make the chip a bit of an enigma. My interest in the chip was piqued when I accidentally triggered a wild test mode that managed to corrupt one of my floppy discs even though the write protect tab was present! You can read about that here:</p><p><a href="https://scarybeastsecurity.blogspot.com/2020/06/a-wild-bug-1970s-intel-8271-disc-chip.html" target="_blank">A wild bug: 1970s Intel 8271 disc chip ate my data!</a></p><p>Can we reverse engineer a detailed understanding of how it works? What wonders will we find?</p><h2>Credits</h2><p>The work described here represents the efforts of a virtual team that came together in an impromptu way to investigate the chip. There are many critical players, and special thanks go to:</p><ul><li><b>Nigel Barnes</b>. Bridged the MAME community and BBC Micro community, locating someone with chip decapping skills.</li><li><b>BeebMaster</b>. Provided a couple of sacrificial 8271 chips for decapping.</li><li><b>Sean Riddle</b>. Decapped the chips and provided beautiful hi-resolution images.</li><li><b>ZXGuesser</b>, <b>Diminished</b>. Hardware level reverse engineering, including accurate extraction of ROM bits.</li><li><b>Ken Shirriff</b>. Provided notes on silicon macro structures, and located historic documents of great utility.</li><li><b>Rich Talbot-Watkins</b>, <b>Chris Evans</b> (me). Calculating the ISA, disassembling the ROM.</li></ul><h2>The beauty of the beast: recap and decap</h2><p>So to recap: we had a few indicators that this could be a very interesting chip. These range from the crazy test mode we found above, to the fact the data sheet hints at a large number of internal registers, with only a few documented.</p><p>And, to decap:</p><table><tbody><tr><td><a href="https://1.bp.blogspot.com/-zP3yJ1Fyrag/X6iQ3qpDr7I/AAAAAAAAzNI/Gv7Bfc5Y3L8hrUK9S-zJAGM8FZCBsuoQACLcBGAsYHQ/s1024/8271-6metal_1024px.jpg"><img data-original-height="914" data-original-width="1024" height="573" src="https://1.bp.blogspot.com/-zP3yJ1Fyrag/X6iQ3qpDr7I/AAAAAAAAzNI/Gv7Bfc5Y3L8hrUK9S-zJAGM8FZCBsuoQACLcBGAsYHQ/w640-h573/8271-6metal_1024px.jpg" width="640"/></a></td></tr><tr><td>(See references at the end for very high resolution shots)</td></tr></tbody></table><p>This a complicated chip for an FDC! There are a large number of large structures present, densely packed. To illustrate the point, we can compare this chip with the heart of the BBC Micro -- a venerable, legendary 6502, as used in iconic 80s machines and consoles such as the Apple ][, Commodore 64 and NES:</p><table><tbody><tr><td><a href="https://1.bp.blogspot.com/-w4_B4zG9xas/X6svWXOnACI/AAAAAAAAzNo/0hVy9qt_YZ8Uln1GyVbRg8p0Lp_YrWh7ACLcBGAsYHQ/s1024/8271_and_6502.png"><img data-original-height="457" data-original-width="1024" height="286" src="https://1.bp.blogspot.com/-w4_B4zG9xas/X6svWXOnACI/AAAAAAAAzNo/0hVy9qt_YZ8Uln1GyVbRg8p0Lp_YrWh7ACLcBGAsYHQ/w640-h286/8271_and_6502.png" width="640"/></a></td></tr><tr><td>8271 left, 6502 right</td></tr></tbody></table><p>Not only is the 8271 larger than the main CPU by a significant amount, it also cost more by all accounts:</p><blockquote><p><i>&#34;In Acorn&#39;s wisdom, they had chosen the Intel 8271 disk controller for the BBC Micro - this controller was probably obsolete even before the BBC Micro was launched. The Acorn disk upgrade comprised the 8271, a handful of standard TTL ICs, an Acorn DFS ROM, and the disk manual. The ICs plugged into unpopulated sockets on the motherboard.</i></p><p><i>A few hardy folks tried sourcing the parts separately - which was fine, except that an 8271 tended to cost about £109 on its own, </i>if<i> you could find one...&#34;</i> -- [<a href="http://www.adsb.co.uk/bbc/disk_controllers/" target="_blank">source link</a>]</p></blockquote><p>By contrast, the 6502 <a href="https://retrocomputing.stackexchange.com/questions/2760/how-much-did-the-6502-and-z80-cost" target="_blank">allegedly cost around $7.45 in 1981</a>, which is a huge difference factor.</p><h3>Getting the ROM bits</h3><p>From a quick eyeball of the 8271 die, there are plenty of PLA-like structures, but perhaps most promisingly, a large rectangle of ROM in the lower left. Right away, we&#39;re thinking that this <i>could indeed</i> be a general purpose microcontroller CPU if there&#39;s a ROM program. Initial focus fell immediately to extracting the ROM.</p><p>ZXGuesser and Diminished put in a Herculean effort, transcribing the ROM bits first by hand and later with some tooling assist and cross-checking. In case you&#39;re wondering what transcribing ROM bits by hand looks like, it looks a little like this:</p><table><tbody><tr><td><a href="https://1.bp.blogspot.com/-9Ub0YUPQ-Zk/X6s95IqdlOI/AAAAAAAAzN0/lXgPhiDKKpQmTXTwVmSCp4enXfiILQcigCLcBGAsYHQ/s1024/8271_partial_annotated_rom.png"><img data-original-height="768" data-original-width="1024" height="480" src="https://1.bp.blogspot.com/-9Ub0YUPQ-Zk/X6s95IqdlOI/AAAAAAAAzN0/lXgPhiDKKpQmTXTwVmSCp4enXfiILQcigCLcBGAsYHQ/w640-h480/8271_partial_annotated_rom.png" width="640"/></a></td></tr><tr><td>Look closely; those cyan annotations are 0s and 1s!</td></tr></tbody></table><p>The ROM matrix is 64x108 bit cells, for a ROM size of 864 bytes.</p><p>Once you&#39;ve gotten the ROM bits, you still have the challenge of assembling them together into a correctly sequenced byte stream. This isn&#39;t always as easy as you might think, and is particularly rough when you don&#39;t have a reliable way of telling if the extracted bytes are ok, as is the case here. During my research, I found:</p><ul><li><a href="http://adamsblog.rfidiot.org/2013/01/fun-with-masked-roms.html" target="_blank">Two 8-bit bytes interleaved</a>.</li><li><a href="https://seanriddle.com/psu.html" target="_blank">Bits and bytes heavily interleaved in a Channel F game cartridge</a>.</li><li><a href="http://caps0ff.blogspot.com/2020/11/the-elusive-tms32010-mask-rom.html" target="_blank">Byte ordering permuted fairly arbitrarily -- obfuscation?</a></li></ul><p>Fortunately, the ROM reversers also looked at the row and column circuitry connecting the ROM, and gave a fairly robust opinion that the ROM bits / bytes are:</p><ul><li>Left-to-right, top-to-bottom.</li><li>Bits inverted relative to the initial decode in the image above.</li><li>Bits MSB first.</li><li>Bytes build from 1 bit per linear 8 bit group.</li></ul><p>This gives the first bytes of the ROM as the following:</p><p><a href="https://1.bp.blogspot.com/-LOclFa5WPl8/X6tamrsG8dI/AAAAAAAAzOA/Thts9MEvrOkYOrjdJ3JjW8TyarKijpJKgCLcBGAsYHQ/s482/8271_rom_first_bytes.png"><img data-original-height="16" data-original-width="482" height="22" src="https://1.bp.blogspot.com/-LOclFa5WPl8/X6tamrsG8dI/AAAAAAAAzOA/Thts9MEvrOkYOrjdJ3JjW8TyarKijpJKgCLcBGAsYHQ/w640-h22/8271_rom_first_bytes.png" width="640"/></a></p><p>This happens to be a correct decode, although we couldn&#39;t be sure for some time.</p><h3>Architecture hints</h3><p>As Rich and myself engaged in efforts to try and disassemble the ROM, without any prior knowledge of the Instruction Set Architecture (ISA), I was fortunate enough to have a conversation with Ken Shirriff (<a href="http://righto.com">righto.com</a>) about this interesting chip. Against all odds, he found a detailed conference presentation abstract from 1977 [<a href="https://drive.google.com/file/d/1B2gUpavFpVP_s45A4cH6JKaI1A3O3t7T/view" target="_blank">link to copy of full abstract</a>].</p><p>This image from the abstract, will look familiar (imagine +90 degrees rotated).</p><p><a href="https://1.bp.blogspot.com/-ATqW73uACls/X6uJuQXQ63I/AAAAAAAAzOY/OBNhopVpNDgJEn2sgs8qCD-DFqh2AK0wQCLcBGAsYHQ/s642/8271_photomicrograph.png"><img data-original-height="642" data-original-width="576" height="320" src="https://1.bp.blogspot.com/-ATqW73uACls/X6uJuQXQ63I/AAAAAAAAzOY/OBNhopVpNDgJEn2sgs8qCD-DFqh2AK0wQCLcBGAsYHQ/s320/8271_photomicrograph.png"/></a></p><p>The rest of the abstract is a gold mine. The presentation was titled &#34;A Dual Processor Serial Data Controller Chip&#34; and begins:</p><blockquote><p><i>&#34;A DUAL PROCESSOR microprogrammable chip that implements a specialized architecture for high-speed serial data controllers will be described. The chip measures 218 mils by 244 mils and contains 22,000 transistors...&#34;</i></p></blockquote><p><b>22,000 transistors</b>!! We knew this was a bit of a chonker, but for reference, the 6502 has 3,218 transistors; the 8080 6,000 transistors and the 8086 29,000 transistors. Yes, the 8271 is not that far off an 8086 in terms of transistor count.</p><p>This instructive table and diagram are also from the abstract:</p><p><a href="https://1.bp.blogspot.com/-e-V92zQW5w8/X6uOwAizXPI/AAAAAAAAzOk/NgDJ13X_NE0rdlyyZBAhKjeo1bqUtNUxQCLcBGAsYHQ/s728/8271_bit_byte_summary.png"><img data-original-height="244" data-original-width="728" height="214" src="https://1.bp.blogspot.com/-e-V92zQW5w8/X6uOwAizXPI/AAAAAAAAzOk/NgDJ13X_NE0rdlyyZBAhKjeo1bqUtNUxQCLcBGAsYHQ/w640-h214/8271_bit_byte_summary.png" width="640"/></a></p><p>This confirms our suspicions that we <i>are</i> dealing with a general purpose CPU, coupled with some acceleration for I/O. The general purpose CPU has the features you&#39;d expect, including a PC, stack, ALU, accumulator, registers, and access to a bus. Further detail in the abstract includes &#34;32 eight-bit registers&#34; and &#34;four-level stack&#34;.</p><p>The presence of a a bit processor (a co-processor if you like) with 250ns cycle time resolves the elephant in the room with the &#34;general CPU&#34; theory. A general CPU of the era probably wouldn&#39;t be fast enough to calculate CRC16 at the disc data rate. However, a specialized PLA-driven bit engine bolted on to the side will do just fine.</p><div><p>Finally on this abstract, we see that it states &#34;To date, two distinct controllers have been microprogrammed: a floppy disk controller and a synchronous data link controller (SDLC)&#34;. Well, we&#39;ve found the FDC, the 8271. Intel&#39;s SDLC from the era was the 8273. Enter Sean Riddle once more -- what a star -- and another sacrificed chip or two later, we have our result:</p><table><tbody><tr><td><a href="https://1.bp.blogspot.com/-G9mwTNwiKdM/X6uSSexg3eI/AAAAAAAAzOw/wgCiIwdSRp88t36gyBXf8DBtm76id5HiQCLcBGAsYHQ/s1024/8271_and_8273.jpg"><img data-original-height="457" data-original-width="1024" height="286" src="https://1.bp.blogspot.com/-G9mwTNwiKdM/X6uSSexg3eI/AAAAAAAAzOw/wgCiIwdSRp88t36gyBXf8DBtm76id5HiQCLcBGAsYHQ/w640-h286/8271_and_8273.jpg" width="640"/></a></td></tr><tr><td>8271 left, 8273 right</td></tr></tbody></table><p>Ken also found a patent relating to this dual core design! It&#39;s <a href="https://patents.google.com/patent/US4152761A/" target="_blank">US4152761</a>. [<a href="https://drive.google.com/file/d/1bnR9p-fwb82HZeQvJAIr_JM3Oebc8xrs/view" target="_blank">link to a more complete version</a>]. There&#39;s a lot of useful architectural detail in the patent, including this interesting summary of key components.</p><table><tbody><tr><td><a href="https://1.bp.blogspot.com/-DEWAzrvaRDU/X6uUYhi67JI/AAAAAAAAzO8/9AtRcmLVm5QeavKH3MlZd2iyQbN09wzwACLcBGAsYHQ/s728/patent_8271_diag.png"><img data-original-height="506" data-original-width="728" height="444" src="https://1.bp.blogspot.com/-DEWAzrvaRDU/X6uUYhi67JI/AAAAAAAAzO8/9AtRcmLVm5QeavKH3MlZd2iyQbN09wzwACLcBGAsYHQ/w640-h444/patent_8271_diag.png" width="640"/></a></td></tr><tr><td>From US4,152,761</td></tr></tbody></table><p>As can be seen, there&#39;s additional complexity described here that falls outside what we&#39;d expect from a traditional CPU. There&#39;s dispatcher requests, priority resolution, a &#34;case&#34; and an &#34;address&#34; register in addition to the program counter and instruction register. This relates to some form of scheduling, which we&#39;ll encounter later.</p><p>Finally, here&#39;s a diagram (courtesy of Ken). It&#39;s an early estimation of how the architecture we&#39;ve seen in the the documents so far might map to the silicon. As a dual processor behemoth, note how there&#39;s two ALUs, two sets of registers, lots of PLAs (including a couple to the left and right of the &#34;control&#34; label), and plenty of patches of silicon with unknown function.</p><p><a href="https://1.bp.blogspot.com/-S8ZcdDBfcGc/X6uhKQ6CHKI/AAAAAAAAzPI/i5zleRTOnmM5_7lO5uy7WnYaWqlK035hwCLcBGAsYHQ/s924/image%2B%25283%2529.png"><img data-original-height="855" data-original-width="924" height="592" src="https://1.bp.blogspot.com/-S8ZcdDBfcGc/X6uhKQ6CHKI/AAAAAAAAzPI/i5zleRTOnmM5_7lO5uy7WnYaWqlK035hwCLcBGAsYHQ/w640-h592/image%2B%25283%2529.png" width="640"/></a></p><h3>From bits to bytes to an Instruction Set Architecture (ISA)</h3><p>With an overview of the architecture, we have a better idea of what sort of opcodes we might find in the instruction set. The more pieces of the puzzle we have in our heads, the better chance we have of making abstract connections in our attempt to solve a problem with a lot of moving parts.</p><p>Initial attempts to disassemble the ROM centered around the theory that the CPU core might be based on the Intel <a href="https://en.wikipedia.org/wiki/Intel_MCS-48" target="_blank">MCS-48</a> microcontroller series. This series includes the well-known 8048 and has several variants such as the slightly cut-down 8020 (less I/O lines). And why wouldn&#39;t this core be based on a further cut-down 8020? It just fits too well: 1K ROM, 64 registers, 13 I/O lines. The timing works well too: the MCS-48 series first launched in 1976, making the core available before the release of the 8271. So the theory went, you&#39;d be crazy as an 1970s Intel employee to not just walk down the corridor and raid the parts bin of your colleagues in order to get a headstart.</p><p>The MCS-48 theory turned out to fit extremely well.... but be false. No amount of ROM bit / byte wrangling led to sensible MCS-48 disassemblies.</p><p>Back to the drawing board, we looked again at our &#34;probably correct&#34; ROM decode and analyzed it for patterns we&#39;d expect to find in an 8271 ROM, based on our understanding of how the controller works, and how disc recording works in general. Here&#39;s a section we found enlightening:</p><p><a href="https://1.bp.blogspot.com/-9rMUfFP7_QE/X6zWgUz8b5I/AAAAAAAAzPs/ADcU0WUZSHsVHMdPRkODzyhrtj57ulFjQCLcBGAsYHQ/s485/rom_hex_red_boxed.png"><img data-original-height="70" data-original-width="485" height="92" src="https://1.bp.blogspot.com/-9rMUfFP7_QE/X6zWgUz8b5I/AAAAAAAAzPs/ADcU0WUZSHsVHMdPRkODzyhrtj57ulFjQCLcBGAsYHQ/w640-h92/rom_hex_red_boxed.png" width="640"/></a></p><p>Most significant is the appearance of the constants $FE + $C7 (middle box), then $E5 + $FF (lower box) in a the same context. These constants are the data byte + clocks byte we&#39;d expect to see in the format routine for FM (single density) formatted discs. $FE + $C7 is the sector header marker, and $E5 + $FF is the default fill byte for freshly formatted sectors. As a bonus, we speculated that $E9 (appearing four times in a row) could be a shift left or right opcode, with $FD perhaps being RET. All in all, some strong circumstantial evidence for a correct decode.</p><p>After the MCS-48 opcode list failed to match our ROM, we spent a long time trying to derive an alternate instruction set.</p><p><b>But it&#39;s hard; it&#39;s a bit like one of those jigsaw puzzles where every piece is the exact same color. It&#39;s very hard to find a start as there are so many different possibilities to try. Research is too often presented as a neatly packaged result, with no mention of the struggle. I think this contributes to discouraging newcomers. So make no mistake: this was a struggle; it went on for some time; there was swearing; and the characteristics leading to success were perseverance and grit as opposed to any particular technical ability.</b></p><p>The breakthrough was catalyzed when the hardware investigations got a good read on the wiring and content of one of the instruction PLAs associated with the byte processor. The PLA in question is actually the darker rectangular block to the left of the &#34;control&#34; label in the image above. It is populated like this:</p><table><tbody><tr><td><a href="https://1.bp.blogspot.com/-OsJtpbF68Ns/X6zfr6L18EI/AAAAAAAAzP4/SIgoMLXyvwU3C_jqi80L2BA7fwTGMTXpACLcBGAsYHQ/s557/left_instruction_table.jpg"><img data-original-height="202" data-original-width="557" height="145" src="https://1.bp.blogspot.com/-OsJtpbF68Ns/X6zfr6L18EI/AAAAAAAAzP4/SIgoMLXyvwU3C_jqi80L2BA7fwTGMTXpACLcBGAsYHQ/w400-h145/left_instruction_table.jpg" width="400"/></a></td></tr><tr><td>Thanks to Diminished!</td></tr></tbody></table><p>With the instruction PLAs decoded, it would be possible to trace the effects of each 8-bit opcode by following activation lines to the registers, stack, ALU, etc. However, we were able to hit our breakthrough with only opcode ranges, provided by this PLA. Of specific interest is these ranges from Rich:</p></div><blockquote></blockquote><p>The specialized $FC and $FD match our theory of CALL and RET, but more pivotal is the range of $20-$3F, split into 2x 16 wide blocks. Immediately, I speculated this could be &#34;move register to accumulator&#34; and &#34;move accumulator to register&#34;. This would turn out to be correct. Furthermore, I noted that opcode $0? was common before $2? or $3?, e.g.</p><blockquote><p><span>05D:   04 22 03 35</span></p></blockquote><div><p>This led to the theory that these are register bank selection opcodes. Similar to the MCS-48, the theory is that there aren&#39;t enough opcodes for all operations to be able to reference all 32 registers, so there must be a bank select. This also would turn out to be correct. In fact, with these pieces, the jigsaw started to fall in place, and fall into place faster and faster.</p><h3>Some ROM code examples</h3><p>For these code examples, bear in mind that the Instruction Set Architecture (ISA) presented here hasn&#39;t seen public light of day as far as we know. We&#39;ve had to invent our own assembly mnemonics, although they&#39;re designed to be familiar to anyone familiar with assembly languages in general. Some specific notes:</p><ul><li>SEL RB is SELect Register Bank, and provides the base index for register access (multiply by 8 to get actual index).</li><li>Note that all register references are by index, not register number. A register number can be calculated with the index and register bank.</li></ul><p><b>1) READ SPECIAL REGISTER</b></p><p><span>.command_READ_SPECIAL_REGISTER</span></p><p>The READ SPECIAL REGISTER command is one of the simplest. As suspected, &#34;special register&#34; externally is just &#34;index into the 32 registers&#34; internally. We can also note plenty of interesting things:</p><ul><li>The command setup code, which we&#39;ll see in a bit, writes parameters to R7 downwards.</li><li>Indirect reads and writes are done via special opcodes that indirect through I0 (typically but not always R0), as per the MCS-48 architecture.</li><li>Some of the internal registers interact with the external bus registers used to interact with the host CPU. R22 is where you write values for them to appear in &#34;ext RESULT&#34;, which is read with BBC Micro&#39;s 6502 at memory location $FE81.</li><li>The &#34;register bank&#34; concept appears to be re-used to provide a lookup index to the SYS 2, RB opcode. You might consider this a minor kludge.</li><li>In order to jump from page 3 ($3??) to page 2 ($2??) at the end, a special SYS opcode is required. Normal JMP / CALL instructions only have an 8-bit operand and can only jump to the current page. SYS opcodes look up a 10-bit PC from a hard coded table.</li><li>The command exits by jumping to a common exit routine, <span>.post_command_tidy_up</span>. This routine disables most of the chip, including the bit processor, and events. This will be important later.</li></ul><p><b>2) SPECIFY</b></p><p><span>.command_SPECIFY</span></p><p>SPECIFY is also a simple command. It&#39;s not strictly a necessary command because it has the same effect as 3 WRITE SPECIAL REGISTER commands to sequential register numbers. It&#39;s unclear why it exists, given the space crunch in the ROM and on the silicon, but the datasheet does describe initializing the 8271 using a few of calls to this. Other items of note:</p><div><ul><li>SPECIFY accepts and applies the register writes immediately, YIELDing (sleeping / idling) between writes and waiting for the host CPU to supply the next register. This means the SPECIFY command might be partially completed for some time, and never fully completed, depending on how we program the chip. This will be significant later.</li><li>SPECIFY internally uses R0 as a destination index to write register values, and R1 as a count to complete. This makes it an ideal candidate to do some black box testing to confirm the chip behaves the same as our source code disassembly. Specifically, I tried and confirmed:</li><ul><li>Pass the first parameter to SPECIFY as 0, indicating we are writing register values starting at R0. Note that as per the code, R0 is used internally by SPECIFY.</li><li>Pass the second parameter as $22. This will get written to R0 (because R0 currently points to R0) and incremented, leaving $23 in R0. This has &#34;corrupted&#34; R0.</li><li>Pass the third parameter as $48. This will get written to MMIO register R35 ($23), and should turn on the drive motor.</li><li>Do not pass a fourth parameter. Despite not “completing” the full four parameters of the command, we expect the writing of the third parameter to have the effect as just described. <b>It does on real hardware</b>.</li></ul></ul></div><p><b>3) External command register handling</b></p><div><p><span>.wakeup_COMMAND</span></p><p><span>014   02<span>	</span>SEL RB 2</span></p><p><span>015   F6 00<span>	</span>MOV I6, #$00<span>		</span>; R22 ($16) = $00 (ext RESULT)</span></p><p><span>017   CF BF<span>	</span>AND I7, #$BF<span>		</span>; R23 ($17) (ext STATUS) !CMD_FULL</span></p><p><span>019   00<span>	</span>SEL RB 0</span></p><p><span>01A   F5 01<span>	</span>MOV I5, #$01<span>		</span>; R5 ($05) = $01 (param 3 default $01)</span></p><p><span><span>					</span>; That’s 1x 128 byte sector in many cases.</span></p><p><span>01C   F4 01<span>	</span>MOV I4, #$01<span>		</span>; R4 ($04) = $01 (param 4 default $01)</span></p><p><span>01E   03<span>	</span>SEL RB 3</span></p><p><span>01F   98 05<span>	</span>MOV A, #$05<span>		</span>; 5 parameters expected</span></p><p><span>021   6F 18 27<span>	</span>TBZ IF, #$18, $027<span>	</span>; R31 ($1F) (ext CMD), jump if 5 param <span>    </span><span>   <span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span></span><span>; </span>command</span></p><p><span><span>					</span>; matches SCAN, FORMAT</span></p><p><span>024   2F<span>	</span>MOV A, IF<span>		</span>; R31 ($1F) (ext CMD)</span></p><p><span>025   9C 03<span>	</span>AND A, #$03<span>		</span>; (CMD &amp; 3) parameters expected</span></p><p><span>027   00<span>	</span>SEL RB 0</span></p><p><span>028   31<span>	</span>MOV I1, A<span>		</span>; R1 ($01) = A = parameters expected</span></p><p><span>029   8A 3D<span>	</span>BZ $03D<span>    </span><span>		</span>; if no parameters, start command</span></p><p><span>02B   F0 07<span>	</span>MOV I0, #$07<span>		</span>; R0 ($00) = $07 (put parameters at $07 down)</span></p><p><span>02D   BC 01<span>	</span>TASK 4, 1<span>		</span>; select .wakeup_PARAM_1_accept</span></p><p><span><span>					</span>; 3 9 (1, 3, 9, B) = $035</span></p><p><span>02F   FF<span>	</span>YIELD</span></p><p>This is where to start reading if you want to trace the main entry point into the ROM. The 8271 byte processor wakes up here where the external host CPU writes to the external command register ($FE80 on the BBC Micro). And again some interesting things to note:</p><div><ul><li>For commands other than SCAN and FORMAT, the number of parameters expected is actually encoding in to the low order bits of the command byte. Undoubtedly, this saves space in the ROM. This is another case where a simple test can confirm the behavior claimed by the ROM code:</li><ul><li>Take a command that takes 1 parameter, e.g. READ SPECIAL REGISTER.</li><li>Increment the command byte and supply that to the 8271 instead.</li><li>We&#39;d expect the 8271 to require 2 parameters to start the command, but then ignore the second parameter and behave as if the 1 parameter version was used. <b>This is indeed observed on real hardware</b>.</li></ul><li>Some default parameter values are deployed. These are used in the commands the datasheet calls &#34;128 Byte Single Record Format&#34;. Presumably it is again a win for ROM space savings.</li></ul><p><b>4) Full ROM disassembly</b></p><p>The full ROM disassembly, as of time of writing, may be found here: [<a href="https://drive.google.com/file/d/1SyvAfMYjFEZjd0Q-YguTAXRlxoR-tPYI/view" target="_blank">link</a>]. This copy will remain static. It&#39;s mostly complete, and all of the &#34;main&#34; paths are fully traced, including SEEK, READ DATA, WRITE DATA and FORMAT TRACK.</p><p><h3>Javascript on a (1970s!) chip</h3></p><p>It is time to look at some of the unusual sounding instructions in the ISA:</p><div><ul><li><b>YIELD</b>. $FF. This instruction tells the processor to switch to running the highest priority dispatcher request, or (more likely) go idle if there&#39;s no dispatcher request active.</li><li><b>TASK t, r</b>. $B8-$BF, 2 bytes. This instruction changes the callback routine for the specified task. Callback routines are specified as an integer that form part of a lookup key into a table of ROM addresses.</li><li><b>YIELDTO r</b>. $10-$1F. Change the callback routine for the currently executing task and yield.</li><li><b>SYS 0, RB, A</b>. $EC. Jump to the ROM address at key (0, RB, A) in the address PLA. RB is the current register bank from the SEL RB instruction, and A is the accumulator value.</li><li><b>SYS 1, RB, R</b>. $ED. Jump to the ROM address at key (1, RB, R) in the address PLA. RB is the current register bank from the SEL RB instruction, and R is current routine value.</li><li><b>SYS 2, RB</b>. $EE. Jump to the ROM address at key (2, RB, 0) in the address PLA. RB is the current register bank.</li></ul><p>There are quite a few concepts introduced here. If you find them somewhat jumbled, you are not alone. A lot of things about the non-traditional parts of the byte processor CPU appear very ad-hoc to me. Let&#39;s look at a concrete example: the handler for the SPECIFY command. This is the <span>.command_SPECIFY</span> code in example chunk 2) above.</p></div><p>To get <span>.command_SPECIFY</span> to run, the host CPU provides the command $35 to the external command register, then 1 initial expected parameter to the external parameter register. The byte processor CPU wakes up at <span>.wakeup_PARAM_1_accept</span>. The context here is:</p><div><ul><li>PC == $035</li><li>TASK == 4</li><li>SEGMENT == 9, ROUTINE == 1</li></ul></div><p>The fact that writes to the external parameter register wake up task 4 is <b>hardcoded</b>. The PC executed is determined by the routine selected for this task, which was 1 at the time. This is used to create the key (3,9,1), which looks up the address $035 in the address PLA. The address PLA is <b>hardcoded</b>. The fact that task 4 keys lookups as (3,9,x) is <b>hardcoded</b>.</p><p><span>.command_SPECIFY</span> ends with this, because it is the one command that gets executed and then decides it wants to yield to wait for 3 more parameters:</p><div><p><span>06B   14<span>	</span>YIELDTO 4<span>		</span>; seems to set PARAM callback to</span></p><p><span><span>					</span>; .wakeup_PARAM_4_SPECIFY, then YIELD</span></p></div><p>This unusual instruction sets the callback routine for the <i>current</i> task to be 4. This means that the callback code for the next external parameter register write will be keyed (3,9,4) in the address PLA. That&#39;s PC $06C, aka. <span>.wakeup_PARAM_4_SPECIFY</span>.</p><p><b>A good mental model for this is Javascript</b>. All execution is event based; the handler for a given event can be changed (by the handler itself, or an unrelated handler); there is no pre-emption until an explicit yield.</p><p>The known events wired in to the byte processor are:</p><div><ul><li>0: Not reversed at all. Appears to be related to the SCAN command, which isn&#39;t enabled on the BBC Micro due to lack of DMA.</li><li>1: Bit processor event, e.g. found sync, lost sync, CRC error.</li><li>2: Bit processor, read byte ready.</li><li>3: Bit processor, write byte needed.</li><li>4: External parmeter register written.</li><li>5: appears unused. (Could be permanently connected to external command register?)</li><li>6: Disc drive index pulse.</li><li>7: appears unused.</li></ul></div><p>On top of the &#34;normal&#34; Javascript model, there&#39;s also the concept of task priorities. These are not visible in the ISA and are presumably hardcoded. One instance this might come in handy in a floppy disc controller is when a disc drive index pulse (once per disc revolution) fires at the same time the bit processor needs a write byte. (It&#39;s not common to write across the index, but it could happen.) In this instance, providing the bit processor a data byte is a much more real-time task than handling an index pulse, so it should be handled first.</p><p>Yes, this is quite some complexity in addition to the complexity typical in a general purpose CPU. In particular, it provides many additional ways to slice and dice control flow handling beyond the standard JMP / CALL / RET. In fact -- and somewhat painfully -- the different control flow possibilities are mixed together! To briefly get a taste of the horrors, here&#39;s the command handler for many of the sector read operations:</p><div><p><span>.command_READ_DATA</span></p><p><span>.command_READ_DATA_AND_DEL_DATA</span></p><p><span>.command_VERIFY_DATA_AND_DEL_DATA</span></p><p><span>0A7   FC C9<span>	</span>CALL $0C9<span>    </span><span>   </span>; .do_common_path_from_seek</span></p><p><span><span>			<span>    </span><span>    </span></span>; very gnarly because this CALL does a YIELD</span></p><p><span><span>			<span>    <span>    </span></span></span>; context on RET is from</span></p><p><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>; .wakeup_BITPROC_EVENT_1_check_header_crc</span></p><p><span><span>		<span>    </span><span>    </span><span>    </span><span>    </span></span>; if we get a matching sector header,</span></p><p><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>; the RET at $255 fires</span></p><p><span><span>0A9   BA 0B<span>	</span>TASK 2, 11<span>	</span>; select </span><span>.wakeup_BITPROC_READ_10_11_count_GAP2</span></span></p><p><span><span>			<span>    </span><span>    </span></span>; (3,5,(10,11)) = $1B8</span></p><p><span>0AB   12<span>	</span>YIELDTO 2<span>	</span>; select</span></p><p><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>; .wakeup_BITPROC_EVENT_2_check_for_data_marker</span></p><p><span><span>				</span>; (3,4,2) = $2D0</span></p><p><span><span>				</span>; and YIELD</span></p></div><p>As can be seen, a CALL subroutine is doing a YIELD without unwinding the stack. This should probably be considered an anti-pattern? The stack is a shared resource across all tasks, so you&#39;d better hope that two different tasks can&#39;t trip over each by doing this at the same time. There&#39;s also the complexity that when a CALL returns, various aspects of the execution environment (task, routine, RB, etc.) may well have changed.</p><p>All this makes the ROM very hard to follow for the read and write paths, even with a fully disassembled and commented ROM!</p><h3>Unusual features of the ISA</h3></div><p><b>1) Lack of symmetry</b></p><p>These are the opcodes we found relating to incrementing, decrementing, adding and subtracting:</p><div><p><span>$80-$83:<span>	</span>INC Ix</span></p><p><span>$84-$87:<span>	</span>ADC A, Ix</span></p><p><span>[...]</span></p><p><span>$A0-$A7:<span>	</span>DEC Ix</span></p><p><span>[...]</span></p><p><span>$90-$93:<span>	</span>ADC Ix<span>			</span>does INC Ix if carry</span></p><p><span>$94-$97:<span>	</span>SBB A, Ix</span></p></div><p>This is interesting because there is an asymmetry between which registers can be incremented vs. decremented. Some registers cannot be incremented at all, even with register banking, because banking operates in multiples of 8 and there are only 4 increment opcodes.</p><p>One theory is that the chip designers were short on silicon space, and trying to get away without add and subtract support in the ALU. There&#39;s only circumstantial evidence to support this, such as the hacked-out ranges in the opcode space; the code generally being add / subtract free except for the code implementing disc drive seek; no compare instruction found (yet -- there are unknowns); the use of XOR to do equality checks at $240 and $24F; and the presence of only direct equality checking or mask based checking for the most common branch opcodes (see item 2) directly below). But it&#39;s fun to speculate wildly isn&#39;t it?</p><p><b>2) 3-byte opcodes</b></p><p>An entire quarter(!) of the opcode space is devoted to four conditional branch instructions:</p><div><p><span>$40-$4F:<span>    </span><span>    </span>BEQ Ix, #imm, abs<span>	</span>branch if Ix == imm</span></p><p><span>$50-$5F: <span>    </span><span>   </span>BNE Ix, #imm, abs<span>	</span>branch if Ix != imm</span></p><p><span>$60-$6F:<span>    </span><span>    </span>TBZ Ix, #imm, abs<span>	</span>test and branch if zero</span></p><p><span>$70-$7F:<span>    </span><span>    </span>TBNZ Ix, #imm, abs<span>	</span>test and branch if not zero</span></p></div><p>These opcodes are all three bytes, which is a departure from Intel&#39;s other microcontrollers of the era. It&#39;s a lot of opcode space, but they can do a lot with a little, for example this piece of code from <span>.do_seek</span>.</p><div><p><span>13E   62 01 3E<span>	</span>TBZ I2, #$01, $13E<span>   </span>; MMIO R34 ($22) (drive in), wait until CNT/OPI</span></p><p><span>141   72 01 41<span>	</span>TBNZ I2, #$01, $141<span>  </span>; MMIO R34 ($22) (drive in), wait until !CNT/OPI</span></p></div><p>For a certain (less common) seek mode, these 6 bytes are sufficient to busy loop while waiting for the drive to start the seek, then acknowledge finishing it.</p><p>These three byte opcodes were found by the previously mentioned &#34;jigsaw&#34; analogy. Once the command entry function was fully disassembled apart from just three bytes at $021, there was only one clean possibility that fitted the required behavior.</p><p><b>3) No timers, port I/O or IRQs</b></p><p>Presumably to save silicon, the byte processor CPU has done away with timers, dedicated port I/O instructions and IRQs. The MCS-48 has all of those.</p><p>They&#39;re not needed, though. Delays, such as the millisecond range delays for seek steps, are simply timed via busy loops.</p><p><b>4) Decide your own adventure</b></p><p>At time of writing, our opcode list is here: [<a href="https://drive.google.com/file/d/1EIg6utXQKTEYf9x6fcpJ0Sht1Pj_r9WW/view" target="_blank">link</a>]. It is not complete. The one part of the 8271 ROM we have not disassembled, SCAN handling, uses at least opcodes $9A, $9B and $8C. (We&#39;ve ignored SCAN because it needs DMA wired up, which is not the case in the BBC Micro application.) Furthermore, the PLAs suggest that other opcode ranges <i>not</i> seen in the 8271 ROM might do something. This includes $A8-$AF and $B0-$B7. Feel free to go and have a look!</p><h3>Interface to the bit processor</h3><p>Now that we&#39;ve got the byte processor understood and disassembled, it&#39;s time to turn our attention to interface to the bit processor and its behavior. After all, it&#39;s the bit processor that is wired to the disc drive control and data lines!</p><p>Our initial assumption was that the byte processor CPU would, like the MCS-48, have some form of port I/O instructions. This turned out to be false. The reality is simpler: it uses MMIO (Memory Mapped Input/Output). This means that access to certain register indexes change registers in the bit processor instead of the byte processor. It&#39;s quite simple: 0-31 references the byte processor registers. And the range 32-39 references bit processor registers. For simplicity of decoding, the bit processor&#39;s 8 register references are mirrored 4 times across the range 32-63. The entire 0-63 range is then mirrored 4 times in the entire addressable range of 0-255.</p><table><tbody><tr><td><a href="https://1.bp.blogspot.com/-kWVhh-q4_28/X68AB39pVNI/AAAAAAAAzQE/WGoqlH0cQ2Arrw3u0abrTyLAtzacKeIeACLcBGAsYHQ/s547/8271init.jpg"><img data-original-height="410" data-original-width="547" height="300" src="https://1.bp.blogspot.com/-kWVhh-q4_28/X68AB39pVNI/AAAAAAAAzQE/WGoqlH0cQ2Arrw3u0abrTyLAtzacKeIeACLcBGAsYHQ/w400-h300/8271init.jpg" width="400"/></a></td></tr><tr><td>Registers 0-63, read on a real BBC Micro, illustrating mirroring of the bit processor registers</td></tr></tbody></table><p>Furthermore, the context of bit processor references in the byte processor code makes it clear that the bit processor interface is very simple. It is so simple we didn&#39;t feel the need to reverse engineer the bit processor further. The bit processor register assignments are as follows:</p><div><ul><li>0: control register, 4 bits</li><ul><li>Bit 0 (0x01) =&gt; gather CRC (?)</li><li>Bit 1 (0x02) =&gt; finish CRC (?)</li><li>Bit 2 (0x04) =&gt; 1 for read, 0 for write</li><li>Bit 3 (0x08) =&gt; idle state</li></ul><li>1: status register, indicates sync data byte type, CRC error, etc.</li><li>2: drive input, read for drive status</li><li>3: drive output, controls step / write / etc. lines</li><li>4: clocks output byte</li><li>5: data output byte</li><li>6: data input byte</li><li>7: unused? (returns 0xFF, and byte processor ROM relies on this!)</li></ul><p>The astute reader might ask: does this mean the bit processor can be programmed directly with the WRITE SPECIAL REGISTER command, since the bit processor registers are MMIO? And the answer is yes! There are severe caveats however:</p></div><div><ul><li>The generic command entry code corrupts bit processor state on entry.</li><li>The generic command exit code resets the bit processor and associated callbacks on exit (but strangely and usefully not for WRITE SPECIAL REGISTER).</li><li><b>The latency of WRITE SPECIAL REGISTER is terrible</b>.</li></ul></div><p>That last bullet, the poor latency, is unfortunate. It&#39;s about 211us, which means there&#39;s zero chance for tricks like writing data to the disc a clocks + data byte at a time. The latency is large because the byte processor executes a large number of instructions on the command entry path, doing things like checking and caching drive status, as well as reading parameters one at a time, checking if the selected drive changed, etc.</p><p>Writing the drive output register directly is useful, though. I did this for my trick to write &#34;weak bits&#34; directly using the 8271! See my blog post about weak bits for more details. [<a href="https://scarybeastsecurity.blogspot.com/2020/06/weak-bits-floppy-disc-protection.html" target="_blank">link</a>]</p><h3>Writing the unwritable</h3><p>Now that we know how this monster works, it is of course time to turn our attention to mischief. Can we make the chip do things it is &#34;not supposed&#34; to be able to do? Of course we can, and as usual, it involves disobeying the datasheet:</p><p><a href="https://1.bp.blogspot.com/-KMR4QIEpLqU/X68czifdgoI/AAAAAAAAzQQ/ycPvt_HbOy4riVZSjHUSrYF-ppLie7N2gCLcBGAsYHQ/s490/datasheet_illegal.png"><img data-original-height="325" data-original-width="490" height="424" src="https://1.bp.blogspot.com/-KMR4QIEpLqU/X68czifdgoI/AAAAAAAAzQQ/ycPvt_HbOy4riVZSjHUSrYF-ppLie7N2gCLcBGAsYHQ/w640-h424/datasheet_illegal.png" width="640"/></a></p><p>We are specifically going to disobey the sentence that states &#34;Issuing a command while another command is in progress is illegal.&#34; We are now equipped to see exactly what happens if we do this, by reading and reasoning about the code. The callback called when the external command register is written gets on with its job without regard for whether a command is in progress, so side effects will be:</p><div><ul><li>The internal command register itself is corrupted, i.e. mismatched with the currently executing command. It is referenced from time to time so this may be useful to us.</li><li>The illegal command will change internal register values, which may impact the execution of the current command.</li><li>The illegal command may change or disable callbacks, or reset or reconfigure the bit processor.</li></ul></div><p>Taking these things into consideration, we are going to <b>try and write an arbitrary FM bit stream</b>. Achieving this will enable us to recreate copy protected disc surfaces that are not supposed to be writeable with the 8271. Remember, kids:</p><p><a href="https://1.bp.blogspot.com/-3ctTtZams3E/X68nLNJWuNI/AAAAAAAAzQc/8LJkQY2eu64dWHkw8HTxW_wrAQTkPhkvwCLcBGAsYHQ/s364/Dontcopythatfloppy.jpg"><img data-original-height="274" data-original-width="364" height="301" src="https://1.bp.blogspot.com/-3ctTtZams3E/X68nLNJWuNI/AAAAAAAAzQc/8LJkQY2eu64dWHkw8HTxW_wrAQTkPhkvwCLcBGAsYHQ/w400-h301/Dontcopythatfloppy.jpg" width="400"/></a></p><p>We&#39;re going to attempt this by separating out how we write the data bytes and how we write the special sector mark clock bytes. Writing a full track of data bytes is easy, but useless on its own. We can do this by:</p><div><ul><li>Formatting a track with a single sector header.</li><li>Issue a WRITE DATA command for that sector, of size 8192 bytes. A track is only 3125 bytes (with a perfectly calibrated drive), so:</li><ul><li>At the first wrap around, start writing the track of bytes we want.</li><li>3125 or so bytes later, at the second wrap around, abort the command by resetting the controller.</li></ul></ul><p>This track of data bytes alone will be useless. If you try to read a sector from it, you will get error $18, aka. &#34;sector not found&#34;. The special clock byte markers required to identify sector headers and sector data will be missing.</p><p>The way FM encoding works is very simple: it alternates clock bit, data bit, clock bit, data bit, ... every 4us. Normally all the clock bits are 1, to maintain timing and keep the drive electronics happy. But for a sector header or data marker, a few clock bits are left out so that the floppy disc controller can locate things in a bitstream where it is not sure where it is.</p></div><p>So, while the WRITE DATA command is running, we&#39;re going to sneak in some parallel SPECIFY commands to &#34;corrupt&#34; registers for the running WRITE DATA command, without disturbing it. Specifically, we&#39;re only going to corrupt the clocks byte register (MMIO R36) at the precise times necessary to write clocks byte values other than 0xFF. The overall operation looks like this:</p><p><a href="https://1.bp.blogspot.com/-w6c6LiMbVac/X68vo7RomKI/AAAAAAAAzQs/7pfFc4fAWYUEK75UzIOIqU-6hlvGFW-wACLcBGAsYHQ/s960/Reverse%2Bengineering%2Bthe%2BIntel%2B8271%2B%25281%2529.png"><img data-original-height="540" data-original-width="960" height="360" src="https://1.bp.blogspot.com/-w6c6LiMbVac/X68vo7RomKI/AAAAAAAAzQs/7pfFc4fAWYUEK75UzIOIqU-6hlvGFW-wACLcBGAsYHQ/w640-h360/Reverse%2Bengineering%2Bthe%2BIntel%2B8271%2B%25281%2529.png" width="640"/></a></p></div></div><blockquote><div><p>The line in orange is the one in question. I annotated it as iffy with ??? when I first disassembled it as it looked wacky. But, it&#39;s correct and a real machine exhibits the corrupted clocks precisely as described by the code. The corrupt clocks value, $40 if writing to drive 0, is shown in orange in the above diagram. Once you know it&#39;s there, and why, the easiest way to navigate around it is to arrange for the clocks corruption to land where it doesn&#39;t case problems. When paired with a $FF data byte, it doesn&#39;t create weak bits on the disc surface, and the controller actually seems to skip over it on read.</p></div></blockquote><div><div><div><ul><li>The write I/O path, by some stroke of good fortune, resets the clocks byte to $FF on every write I/O callback. This saves us a lot of trouble:</li></ul><div><p><span>.wakeup_BITPROC_WRITE_3_set_clocks_and_count_host_bytes</span></p><p><span>318   F4 FF<span>	</span>MOV I4, #$FF<span>	</span>; MMIO R36 ($24), standard clocks</span></p></div><p><span>[...]</span></p><ul><li>Careful timing is needed. There&#39;s a pipeline of bytes from the external data register to the internal bit processor data byte register to the actual output pulse machinery. This needs to be accounted for.</li></ul><p>Combined, these quirks convince me that I&#39;d have never gotten this going, or gotten close, without a thoroughly reverse engineered and disassembled ROM.</p></div><h3>Other successes and failures</h3><p>Other things enabled or demonstrated based on careful reading of the ROM code:</p><div><ul><li>beebjit now has a much more accurate 8271 driver.</li><li>Unexplained weirdness trying to read a sector with logical track id $FF has been explained as an integer overflow in the bad tracks handling.</li><li>Sectors on a non-zero physical track, but with a zero logical track id, were believed &#34;impossible&#34; to read. I&#39;m able to read them by using the &#34;command within command&#34; trick. Once a READ DATA command is safely underway, including having processed the seek request and gone idle, it&#39;s possible to use WRITE SPECIAL REGISTER to change R7 (command param 1, which is the requested track) to zero, and have the sector read fine. The issue is that references to logical track 0 in the seek code are always treated as a mandate to find physical track 0. You need to bypass that.</li></ul><p>Things not achieved:</p></div><div><ul><li>Reading or writing MFM (double density) -- looks fundamentally impossible. Does not appear to be a capability in the hard-wired bit processor.</li><li>Executing arbitrary code on the chip. This is a shame, as the byte processor is a capable CPU! Who knows what we could use a little co-processor for? Things making this hard include:</li><ul><li>Separation of code and data in separate address spaces.</li><li>No references to the stack possible outside of CALL and RET.</li><li>Indirect jump targets stored in a read-only PLA. (Microsoft CFG? :)</li><li>... and yes, curiously, these accidental defenses all sound similar to defensive technologies investigated or deployed since year 2000. So, the 1970s called and...</li></ul></ul></div><h3>Summary</h3><div><p>The 8271 has exceeded our expectations! Where to start? It&#39;s a massive chip, encompassing dual cores and a Javascript like execution model. Remember, this was the mid-1970s. Its general purpose CPU runs an Intel instruction set architecture that I don&#39;t believe has been publicly documented until now. It&#39;s not every day we get the treat of a new Intel ISA.</p><p>We never got to the bottom of the crazy test mode that started this whole investigation. There&#39;s no trace of it in the byte processor ROM, so it must be handled by some other component on the silicon. Something to investigate for another day perhaps.</p><p>Having seen the complexity of the chip, I must confess to a feeling of surprise every time my BBC Micro successfully loads a disc.</p></div><h3>Epilogue</h3></div><p>Given the 8271 issues with cost, heat, supply chain, complexity, and lack of MFM, it wouldn&#39;t be surprising if Intel had had enough with the architecture behind the 8271 and 8273. Intel staggered bravely forward with the 8272, which introduced MFM support and... hang on, let&#39;s have a look at a decapitated one of those...</p><table><tbody><tr><td><a href="https://1.bp.blogspot.com/-bLL4fL5BMLc/X6-ChZErYDI/AAAAAAAAzRE/StqRSrHBHyUeP4ggl-9EdGZi9cNFKoL8gCLcBGAsYHQ/s1622/8271_nec_8272.jpg"><img data-original-height="537" data-original-width="1622" height="212" src="https://1.bp.blogspot.com/-bLL4fL5BMLc/X6-ChZErYDI/AAAAAAAAzRE/StqRSrHBHyUeP4ggl-9EdGZi9cNFKoL8gCLcBGAsYHQ/w640-h212/8271_nec_8272.jpg" width="640"/></a></td></tr><tr><td>Left to right: Intel 8271, NEC D765, Intel 8272</td></tr></tbody></table><p>This is very cheeky! The 8272 die may say &#34;8272 (c) Intel 1979&#34; but it is the same die as a NEC D765, stamped &#34;NEC D765B&#34;. It looks like Intel may have licensed the NEC design. The NEC doesn&#39;t appear much smaller in terms of die size, but the layout looks much simpler and less busy. Bizarrely, Intel appears to have fabbed the 8272 much larger than the NEC. </p><h3>Extra references</h3><ul><li><a href="http://stardot.org.uk/" target="_blank">StarDot</a> forum thread where the investigation unfolded: [<a href="https://stardot.org.uk/forums/viewtopic.php?f=3&amp;t=19762" target="_blank">link</a>]</li><li>Sean Riddle&#39;s decap page: [<a href="https://seanriddle.com/decap.html" target="_blank">link</a>]</li><li>beebjit&#39;s 8271 driver: [<a href="https://github.com/scarybeasts/beebjit/blob/master/intel_fdc.c" target="_blank">link</a>]</li><li>8271 tests and tools (warning: rough) for the BBC Micro: [<a href="https://github.com/scarybeasts/misc/tree/master/8271" target="_blank">link</a>]</li><li>Live document for 8271 disassembly: [<a href="https://docs.google.com/document/d/1bQTvncIcgRfO0zOvBB16x37WfTh71c4U5WWCyQ4lFVM/edit#" target="_blank">link</a>]</li><li>Very high resolution die shots of the 8271 and 8273 (beware, will hang browsers!): [<a href="http://www.seanriddle.com/8271/" target="_blank">link</a>]</li></ul></div>

</div></div>
  </body>
</html>
