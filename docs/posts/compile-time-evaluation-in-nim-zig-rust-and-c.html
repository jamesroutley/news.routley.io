<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://castillodel.github.io/compile-time-evaluation/">Original</a>
    <h1>Compile time evaluation in Nim, Zig, Rust and C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div>
  <section>
    <div>
      <h2>Compile time evaluation in Nim, Zig, Rust and C++</h2>
      
    </div>
    
    
    
    <article id="main_text">
      <p>Evaluating code at compile time is a capability that most, if not all, compiled programming languages possess, even if it can&#39;t be directly used by the programmer, but rather applied as an optimization. In this post, we&#39;ll explore a bit how to execute code at compile time in Nim, Zig, Rust and C++.</p>
<h2 id="nim">Nim</h2>
<p>In Nim, we can use the word <code>const</code> to declare a variable that needs to be evaluated at compile time. If we didn&#39;t want or can&#39;t evaluate something at compile time we will need to use <code>var</code> or <code>let</code>. The following code will result in a list of string representing the numbers between 1 and 100 to be present in the binary.</p>
<pre data-lang="nim"><code data-lang="nim"><span>const</span><span> numbers = </span><span>toSeq</span><span>(</span><span>1</span><span>..</span><span>100</span><span>).</span><span>map</span><span>(x =&gt; $x) </span><span># $ allows us to transform the numbers to string
</span><span>for</span><span> num </span><span>in</span><span> numbers:
</span><span>    </span><span>echo</span><span> num
</span></code></pre>
<p>It&#39;s easy to check that&#39;s the case. We just need to open the binary with a text editor and check that there is some place where there is a list with all these numbers. Don&#39;t worry if there is a lot of strange symbols there! They just mean the binary code there isn&#39;t meant to represent ASCII or even UTF characters, but our list of numbers will be there. I found the following, all in the same line and with strange symbols between each number:</p>
<pre><code><span>@1@2@3@4@5@6@7@8@9@10@11@12@13@14@15@16@17@18 ... @96@97@98@99@100
</span></code></pre>
<p>Now, that we know the basics we can try to do something funnier. We will try to implement <a href="https://en.wikipedia.org/wiki/Fizz_buzz">Fizzbuzz</a> (a really famous, but rather simple programming challenge), so that the result is always evaluated at compile time.</p>
<pre data-lang="nim"><code data-lang="nim"><span>import</span><span> std/sequtils
</span><span>import</span><span> std/sugar
</span><span>
</span><span>proc </span><span>fizzbuzz</span><span>(number: </span><span>int</span><span>): </span><span>string </span><span>{.</span><span>compileTime</span><span>.} </span><span>=
</span><span>  </span><span>if</span><span> number </span><span>mod </span><span>3</span><span> == </span><span>0</span><span>:
</span><span>    result = </span><span>&#34;Fizz&#34;
</span><span>  </span><span>if</span><span> number </span><span>mod </span><span>5</span><span> == </span><span>0</span><span>:
</span><span>    result &amp;= </span><span>&#34;Buzz&#34;
</span><span>  </span><span>if</span><span> result == </span><span>&#34;&#34;</span><span>:
</span><span>    result = $number
</span><span>
</span><span>const</span><span> numbers = </span><span>toSeq</span><span>(</span><span>1</span><span>..</span><span>100</span><span>).</span><span>map</span><span>(x =&gt; </span><span>fizzbuzz</span><span>(x))
</span><span>for</span><span> num </span><span>in</span><span> numbers:
</span><span>    </span><span>echo</span><span> num
</span></code></pre>
<p>Notice that with this we have introduced some new elements. There is a function call and some mathematic operations. There is also the <code>compileTime</code> pragma, which ensures that this function will only be called during compilation and no code will be generated for it. If we check the resulting binary we will find something like this:</p>
<pre><code><span>@1@2@Fizz@4@Buzz@7@8@11@13@14@FizzBuzz@16@17@19@22@23@26@28@29@31 ...
</span></code></pre>
<p>It works! It almost seems like it was too easy, right? Executing arbritrary code at compile time seems like something really complex. We will continue thinking about that further down the line, but now we feel optimistic and happy because everything has come out nicely.</p>
<p>But wait... Why do &#34;Fizz&#34;, &#34;Buzz&#34; and &#34;FizzBuzz&#34; only appear once? And why are some numbers missing like 6, 9, 20 and 30???</p>
<p>Every number that is missing should be &#34;Fizz&#34;, &#34;Buzz&#34; or &#34;FizzBuzz&#34; and these ones only need to appear once, because the same string can be reused. But now we have a new problem, if these strings we have been seeing don&#39;t contain &#34;Fizz&#34; more than once, then they can&#39;t represent the final array, right?. That&#39;s true. What we have been seeing are only the preprocessed strings, the array will be made of pointers to the directions of this strings, that way it&#39;s possible to reuse the &#34;Fizz&#34; string.</p>
<h2 id="zig">Zig</h2>
<p>In zig we can evaluate code at compile time using the <code>comptime</code> keyword. It should be pretty easy based on our experience with Nim. Something like the following should be enough:</p>
<pre data-lang="zig"><code data-lang="zig"><span>fn </span><span>get_fizzbuzz</span><span>(</span><span>n</span><span>: </span><span>usize</span><span>) []</span><span>const u8 </span><span>{
</span><span>    </span><span>if </span><span>(n </span><span>% </span><span>15 </span><span>== </span><span>0</span><span>) {
</span><span>        </span><span>return </span><span>&#34;FizzBuzz&#34;</span><span>;
</span><span>    } </span><span>else if </span><span>(n </span><span>% </span><span>3 </span><span>== </span><span>0</span><span>) {
</span><span>        </span><span>return </span><span>&#34;Fizz&#34;</span><span>;
</span><span>    } </span><span>else if </span><span>(n </span><span>% </span><span>5 </span><span>== </span><span>0</span><span>) {
</span><span>        </span><span>return </span><span>&#34;Buzz&#34;</span><span>;
</span><span>    }
</span><span>    </span><span>return</span><span> n </span><span>// missing: convert n to string
</span><span>}
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>anyerror</span><span>!</span><span>void </span><span>{
</span><span>    </span><span>const</span><span> fizzbuzz_numbers </span><span>= </span><span>comptime </span><span>init: {
</span><span>        </span><span>var </span><span>numbers</span><span>: [</span><span>100</span><span>][]</span><span>const u8 </span><span>= </span><span>undefined</span><span>;
</span><span>        </span><span>for </span><span>(numbers) </span><span>|*</span><span>val, i</span><span>| </span><span>{
</span><span>            val</span><span>.* = </span><span>get_fizzbuzz</span><span>(i </span><span>+ </span><span>1</span><span>);
</span><span>        }
</span><span>        </span><span>break</span><span> :init numbers;
</span><span>    };
</span><span>    </span><span>for </span><span>(fizzbuzz_numbers) </span><span>|</span><span>n</span><span>| </span><span>{
</span><span>        std.debug.</span><span>print</span><span>(</span><span>&#34;{s}</span><span>\n</span><span>&#34;</span><span>, .{n});
</span><span>    }
</span><span>}
</span></code></pre>
<p>Notice how we wrap the <code>fizzbuzz_numbers</code> initialization in a <code>comptime</code> block. This should mostly work. We only need to to convert <code>n</code> to a string and we&#39;re all set! In Nim it was so easy, surely we can just convert it. Let me search how to do it.</p>
<pre data-lang="zig"><code data-lang="zig"><span>    </span><span>return</span><span> std.fmt.</span><span>allocPrint</span><span>(allocator, </span><span>&#34;{d}&#34;</span><span>, .{n});
</span></code></pre>
<p>We can just do something like this! But wait, we need an allocator for this. Why? Well, if we think it through it&#39;s clear why. Different numbers need different string sizes to be represented. 10 can be represented in two ASCII characters, but 100 needs three. So this is something that tipycally needs heap allocated memory to work. We don&#39;t need to get desperate though! Luckily for us, Zig has our backs!</p>
<pre data-lang="zig"><code data-lang="zig"><span>    </span><span>return</span><span> std.fmt.</span><span>comptimePrint</span><span>(</span><span>&#34;{}&#34;</span><span>, .{n});
</span></code></pre>
<p>The <code>comptimePrint</code> function allows us to do exactly what we need. It performs all the necessary checks at compile time, so the compiled code knows the exact size of the string it needs to handle. This way it can be allocated in the stack. For this to work, we need to mark <code>n</code> as a <code>comptime</code> value, which means it must be known at compile time. The final code would be the following:</p>
<pre data-lang="zig"><code data-lang="zig"><span>const</span><span> std </span><span>= </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);
</span><span>
</span><span>fn </span><span>get_fizzbuzz</span><span>(</span><span>comptime </span><span>n</span><span>: </span><span>usize</span><span>) []</span><span>const u8 </span><span>{
</span><span>    </span><span>if </span><span>(n </span><span>% </span><span>15 </span><span>== </span><span>0</span><span>) {
</span><span>        </span><span>return </span><span>&#34;FizzBuzz&#34;</span><span>;
</span><span>    } </span><span>else if </span><span>(n </span><span>% </span><span>3 </span><span>== </span><span>0</span><span>) {
</span><span>        </span><span>return </span><span>&#34;Fizz&#34;</span><span>;
</span><span>    } </span><span>else if </span><span>(n </span><span>% </span><span>5 </span><span>== </span><span>0</span><span>) {
</span><span>        </span><span>return </span><span>&#34;Buzz&#34;</span><span>;
</span><span>    }
</span><span>    </span><span>return</span><span> std.fmt.</span><span>comptimePrint</span><span>(</span><span>&#34;{}&#34;</span><span>, .{n});
</span><span>}
</span><span>
</span><span>pub fn </span><span>main</span><span>() </span><span>anyerror</span><span>!</span><span>void </span><span>{
</span><span>    </span><span>const</span><span> fizzbuzz_numbers </span><span>= </span><span>comptime </span><span>init: {
</span><span>        </span><span>var </span><span>numbers</span><span>: [</span><span>100</span><span>][]</span><span>const u8 </span><span>= </span><span>undefined</span><span>;
</span><span>        </span><span>for </span><span>(numbers) </span><span>|*</span><span>val, i</span><span>| </span><span>{
</span><span>            val</span><span>.* = </span><span>get_fizzbuzz</span><span>(i </span><span>+ </span><span>1</span><span>);
</span><span>        }
</span><span>        </span><span>break</span><span> :init numbers;
</span><span>    };
</span><span>    </span><span>for </span><span>(fizzbuzz_numbers) </span><span>|</span><span>n</span><span>| </span><span>{
</span><span>        std.debug.</span><span>print</span><span>(</span><span>&#34;{s}</span><span>\n</span><span>&#34;</span><span>, .{n});
</span><span>    }
</span><span>}
</span></code></pre>
<p>If we repeat what we did with the Nim code, we can also see the corresponding strings in the binary. We can also see it clearly using <a href="https://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:&#39;1&#39;,fontScale:14,fontUsePx:&#39;0&#39;,j:1,lang:zig,selection:(endColumn:26,endLineNumber:3,positionColumn:26,positionLineNumber:3,selectionStartColumn:26,selectionStartLineNumber:3,startColumn:26,startLineNumber:3),source:&#39;const+std+%3D+@import(%22std%22)%3B%0A%0Afn+get_fizzbuzz(comptime+n:+usize)+%5B%5Dconst+u8+%7B%0A++++if+(n+%25+15+%3D%3D+0)+%7B%0A++++++++return+%22FizzBuzz%22%3B%0A++++%7D+else+if+(n+%25+3+%3D%3D+0)+%7B%0A++++++++return+%22Fizz%22%3B%0A++++%7D+else+if+(n+%25+5+%3D%3D+0)+%7B%0A++++++++return+%22Buzz%22%3B%0A++++%7D%0A++++return+std.fmt.comptimePrint(%22%7B%7D%22,+.%7Bn%7D)%3B%0A%7D%0A%0Apub+fn+main()+anyerror!!void+%7B%0A++++const+fizzbuzz_numbers+%3D+comptime+init:+%7B%0A++++++++var+numbers:+%5B100%5D%5B%5Dconst+u8+%3D+undefined%3B%0A++++++++for+(numbers)+%7C*val,+i%7C+%7B%0A++++++++++++val.*+%3D+get_fizzbuzz(i+%2B+1)%3B%0A++++++++%7D%0A++++++++break+:init+numbers%3B%0A++++%7D%3B%0A++++for+(fizzbuzz_numbers)+%7Cn%7C+%7B%0A++++++++std.debug.print(%22%7Bs%7D%5Cn%22,+.%7Bn%7D)%3B%0A++++%7D%0A%7D&#39;),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;Zig+source+%231&#39;,t:&#39;0&#39;)),k:55.38833031495245,l:&#39;4&#39;,m:100,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;),(g:!((h:compiler,i:(compiler:z090,filters:(b:&#39;1&#39;,binary:&#39;0&#39;,commentOnly:&#39;1&#39;,demangle:&#39;0&#39;,directives:&#39;1&#39;,execute:&#39;1&#39;,intel:&#39;0&#39;,libraryCode:&#39;0&#39;,trim:&#39;1&#39;),flagsViewOpen:&#39;1&#39;,fontScale:14,fontUsePx:&#39;0&#39;,j:1,lang:zig,libs:!(),options:&#39;&#39;,selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1,tree:&#39;1&#39;),l:&#39;5&#39;,n:&#39;0&#39;,o:&#39;zig+0.9.0+(Zig,+Editor+%231,+Compiler+%231)&#39;,t:&#39;0&#39;)),k:44.61166968504757,l:&#39;4&#39;,n:&#39;0&#39;,o:&#39;&#39;,s:0,t:&#39;0&#39;)),l:&#39;2&#39;,n:&#39;0&#39;,o:&#39;&#39;,t:&#39;0&#39;)),version:4">Compiler Explorer</a>.</p>
<p>I liked Zig approach, it made the different problems be clear, but also gave us the appropiate tools to overcome them. Nim, on the other hand, just handled everything for us which was really nice. It is also really interesting to look at <a href="https://github.com/ziglang/zig/blob/f8d2b87fa122a948e2c8e1056e2ec4cfd4cf01bf/lib/std/fmt.zig#L1935">the source code of the <code>comptimePrint</code> function</a>. It is implemented outside the language, in the standard library, and really takes advantage of Zig&#39;s compile time execution capabilities.</p>
<h2 id="rust">Rust</h2>
<p>We can also try to do the same in Rust! In Rust we use the keyword <code>const</code> to declare a function that can be evaluated at compile time. This restricts the operations we can do. For example, we can&#39;t use the <code>String</code> type, because it uses heap allocations. So our function should return a <code>&amp;&#39;static str</code>, which means a reference to a string that lives throughout the entire program (usually because the data is embedded in the binary).</p>
<pre data-lang="rust"><code data-lang="rust"><span>const fn </span><span>get_fizzbuzz_equivalent</span><span>(</span><span>number</span><span>: </span><span>usize</span><span>) -&gt; </span><span>&amp;</span><span>&#39;static str </span><span>{
</span><span>    </span><span>if</span><span> number </span><span>% </span><span>15 </span><span>== </span><span>0 </span><span>{
</span><span>        </span><span>&#34;FizzBuzz&#34;
</span><span>    } </span><span>else if</span><span> number </span><span>% </span><span>3 </span><span>== </span><span>0 </span><span>{
</span><span>        </span><span>&#34;Fizz&#34;
</span><span>    } </span><span>else if</span><span> number </span><span>% </span><span>5 </span><span>== </span><span>0 </span><span>{
</span><span>        </span><span>&#34;Buzz&#34;
</span><span>    } </span><span>else </span><span>{
</span><span>        </span><span>&amp;</span><span>number.</span><span>to_string</span><span>() </span><span>// Obviously this doesn&#39;t work for the reasons we discussed previously
</span><span>    }
</span><span>}
</span></code></pre>
<p>This is a nice first approach, but we have the same problem we had with Zig. Notice that Rust also makes the problem really clear, we can&#39;t use a String inside a <code>const</code> function. We could use something like <a href="https://docs.rs/crate/const_format/latest">const_format</a> to get what we need. We would have the following code:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>const_format::formatcp;
</span><span>
</span><span>const fn </span><span>get_fizzbuzz_equivalent</span><span>&lt;</span><span>const</span><span> number: </span><span>usize</span><span>&gt;() -&gt; </span><span>&amp;</span><span>&#39;static str </span><span>{
</span><span>    </span><span>if</span><span> number </span><span>% </span><span>15 </span><span>== </span><span>0 </span><span>{
</span><span>        </span><span>&#34;FizzBuzz&#34;
</span><span>    } </span><span>else if</span><span> number </span><span>% </span><span>3 </span><span>== </span><span>0 </span><span>{
</span><span>        </span><span>&#34;Fizz&#34;
</span><span>    } </span><span>else if</span><span> number </span><span>% </span><span>5 </span><span>== </span><span>0 </span><span>{
</span><span>        </span><span>&#34;Buzz&#34;
</span><span>    } </span><span>else </span><span>{
</span><span>        formatcp!(</span><span>&#34;{}&#34;</span><span>, number)
</span><span>    }
</span><span>}
</span></code></pre>
<p>We need to declare number as a const generic, to indicate it must be known at compile time(the arguments of a <code>const fn</code> don&#39;t need to be known at compile time, if they aren&#39;t the function will just run normally at runtime, but we can&#39;t call <code>formatcp!</code> at runtime). But even with that, <code>formatcp!</code> doesn&#39;t work nicely with const generics. I think it should be possible to do it, but I couldn&#39;t find a simple way to do it.</p>
<h2 id="c">C++</h2>
<p>C++&#39;s <code>constexpr</code> is similar to Rust&#39;s <code>const</code>, so we can do something like this:</p>
<pre data-lang="c++"><code data-lang="c++"><span>constexpr char</span><span>* </span><span>get_fizzbuzz</span><span>(</span><span>int </span><span>number</span><span>) {
</span><span>    </span><span>if </span><span>(number </span><span>% </span><span>15 </span><span>== </span><span>0</span><span>) {
</span><span>        </span><span>return </span><span>&#34;FizzBuzz&#34;</span><span>;
</span><span>    } </span><span>else if </span><span>(number </span><span>% </span><span>3 </span><span>== </span><span>0</span><span>) {
</span><span>        </span><span>return </span><span>&#34;Fizz&#34;</span><span>;
</span><span>    } </span><span>else if </span><span>(number </span><span>% </span><span>5 </span><span>== </span><span>0</span><span>) {
</span><span>        </span><span>return </span><span>&#34;Buzz&#34;</span><span>;
</span><span>    }
</span><span>    </span><span>return</span><span> number; </span><span>// convert to string
</span><span>}
</span></code></pre>
<p>Again, we have the same problem as before. In C++, we can solve it with the <a href="https://en.cppreference.com/w/cpp/utility/to_chars"><code>to_chars</code> function</a> from the standard library. The downside is that to use <code>to_chars</code> we need to first declare an array with a fixed length. This is, of course, a valid solution, but we could be using some unnecessary bytes. In the Zig and Nim solution we don&#39;t need to that because the compiler calculated the actual necessary length.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I wanted to bring attention to the fact that a lot of operations that we think are really simple, like converting a number to string, aren&#39;t actually that simple.</p>
<p>Of course, there is a lot more to talk about this topic, but I think this rather short post can be interesting to some people. I did learn a lot writing and experimenting about the topic. If you reached the end, thank you! I hope you have learned something.</p>

    </article>
  </section>

  

</div></div>
  </body>
</html>
