<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/s2022/az292_kw456_lh479/az292_kw456_lh479/index.html">Original</a>
    <h1>Bombe Machine on an FPGA</h1>
    
    <div id="readability-page-1" class="page">
        <!-- Navigation-->
        <nav id="mainNav">
            
        </nav>
        <!-- Masthead-->
        <header>
            <div>
                <div>
                    <div>
                        
                        
                        
                        
                        
                        
                        
                        <h2>Angela Zou, Kathleen Wang, Robby Huang</h2>
                        <p><a href="#Intro">Get Started</a></p></div>
                </div>
            </div>
        </header>
        <!-- About-->
        <section id="Intro">
            
        </section>
        <!-- High Level Design-->
        <section id="HighLevel">
            <div>
                <p>
                    <h2>High Level Design</h2>
                </p>
                <div>
                    <div>
                        <p><img width="750" height="auto" src="https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/s2022/az292_kw456_lh479/az292_kw456_lh479/assets/img/enigma_diagram.png" alt="..."/>Figure 1: Enigma Design</p>
                            <h3>Background</h3>
                            <p>
                                First, we recreated the Enigma machine that is used to encrypt and decrypt messages. The main components of an Enigma are the plugboard, the three rotors, and the reflector.  </p>
                            <p><img width="500" height="auto" src="https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/s2022/az292_kw456_lh479/az292_kw456_lh479/assets/img/example_crib_and_menu.png" alt="..."/>Figure 2: Example Crib and Menu</p>
                            <p>The goal is to have one connected graph with as many loops as possible. If a menu does not contain enough letters/loops, there will be more false stops on the Bombe meaning there will be a lot more work required to determine the correct key. As shown by the chain in green, we then find a connected sequence of at least 13 letters (12 links) that will be an input into the Bombe machine.
                            </p> 
                            
                            <p>  The Bombe machine, which can be thought of as consisting of multiple Enigma machines, is mainly used to figure out plugboard connections and consists of linked drum banks each processing one letter-encryption pair. During the war, a Bombe had 36 drum banks arranged in three rows of 12 drum banks per row. Each drum bank has 3 drums (representing the 3 rotors) and each bank represents just the rotor scrambler and reflector parts of an Enigma machine.
                            </p>  
                            <p><img width="750" height="auto" src="https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/s2022/az292_kw456_lh479/az292_kw456_lh479/assets/img/bombe_diagram.png" alt="..."/>Figure 3: Bombe Machine Drum Arrangement</p>
                             
                            <p>
                                The machine works by making an assumption about the first plugboard mapping, deducing the other plugboard mappings, and checking for conflicts knowing that the same letter can not be mapped to two different letters on the plugboard. For example, if A is mapped to B from one plugboard mapping, we know that it is not possible for A also to be mapped to C. The Bombe stops when a specific plugboard setting that matches the crib is found, and can stop multiple times since there can be multiple possibilities. </p>
                            <h3>Design Overview</h3>
                            <p>
                                To develop a better understanding of how to construct a Bombe machine, we first started off constructing an Enigma machine in C and then an Enigma module in Verilog, consisting of rotor modules, a stepping module, a reflector module, and a plugboard wired together.  </p>
                        
                    </div>
                </div>
            </div>
        </section>
        <!-- Software Design-->
        <section id="Verilog">
            <div>
                <div>
                    <div>
                        <h2>Verilog</h2>
                        <h3>Enigma Machine in Verilog</h3>
                        <p>
                            As mentioned above, the Enigma machine in Verilog consists of rotor, stepping, reflector, and plugboard modules that are used in a main Enigma module that puts them all together. 
                            </p> 
                            <h3>Bombe Machine Overview </h3>
                            <p>
                                For our implementation of the Bombe machine, we define a drum module as consisting of a double-ended scrambler (going through 3 rotors forward, a reflector, and then the 3 rotors backward) and an FSM for reading and writing to M10K memory. We use M10K memory with 26 partitions(corresponding to the 26 letters of the alphabet) of 5 bits each to give us the ability to read if a letter has already been mapped, and therefore if there are any conflicts that indicate an invalid mapping.  </p>
                            <h3>Drum Module </h3>
                            <p>
                                At a high level, our drum module consists of an FSM that writes/reads from M10K memory and a double-ended scrambler. The scrambler combines three rotor modules, a stepping module, and a reflector module, with the input being the plugboard_passin_mapping.  </p><p><img width="900" height="auto" src="https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/s2022/az292_kw456_lh479/az292_kw456_lh479/assets/img/Drum_FSM.png" alt="..."/>Figure 4: Drum Module FSM
                            </p>
                            <h3>Drum Bank Module</h3>
                            <p> In the drumbank module, we have 12 drum modules, each corresponding to a different letter of the 12-letter chain that we are inputting into the Bombe machine, as described in the background section. We create the 12 drums using a generate statement, offsetting the input values/addresses that we instantiate each drum module with according to the instance number. 
                                We also instantiate the M10K memory, which consists of 26 partitions with a data width of 5 bits each. We use the M10K memory to check if a letter has already been mapped, and therefore if there are any conflicts that indicate an invalid mapping.
                                If any of the drums have faults, the drumbank will have a fault signal.</p>
                            <h3>Bombe Module</h3>
                            <p> 
                                The Bombe top-level module uses an FSM to try different input plugboard settings and restart the drumbank if there are any faults. As seen, the FSM starts in the <code>INIT</code> states where we initialize all variables and pass in the first plugboard mapping to test. We then remain in this <code>RUN </code>state until a bank fault is detected or the bank is done. If there is a bank fault, we move into the <code>UPDATE</code> state where we try different plugboard settings (meaning we try a different first mapping, leading to different mappings for the remaining 11 letters). We stop going to the <code>UPDATE</code> once <code>plugboard_passin_mapping</code> &gt; 25, meaning we have tried all plugboard possibilities for the first letter of our 12-link sequence.  </p><p><img width="900" height="auto" src="https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/s2022/az292_kw456_lh479/az292_kw456_lh479/assets/img/Bombe_FSM.png" alt="..."/>Figure 5: Bombe Top-level FSM
                            </p>
                        
                    </div>
                </div>
            </div>
        </section>
        <!-- C-->
        <section id="C">
            <div>
                <p>
                    <h2>C Program</h2>
                </p>
                <div>
                    <div>
                        <h3>HPS Code</h3>
                        <p>
                                We use PIO ports to send data between the FPGA and the HPS. In particular, we send values like the initial rotor positions, rotor turnover positions, the reset signal, and the 13-letter chain found from our graph. While we split this into two 12 letter sequences excluding the last and first letter respectively, we also split those two 64-bit sequences into 2 variables of 32 bits each to pass through our PIO ports. The FPGA passes to the HPS the found plugboard mappings from the Bombe module and also ctrl signals that indicate whether the FPGA has found a valid mapping or is done with computation.  </p>
                            <h3>Bombe Checker in C</h3>
                            <p> 
                                The Bombe machine is an effective tool in eliminating a large number of incorrect plugboard settings, but after such elimination, there is still a large amount of possible but unverified plugboard settings. We know that a letter may or may not be matched in a plugboard and once it is mapped to another letter, those two letters are matched to each other. One needs to take all the unmatched letters in the plugboard and test out all the possible unique and non overlapping pairs. Back in WWII, this process involved an abundance of manpower and effort. We condensed this time intensive process to less than a second by developing a recursive C program that can create unique and non-overlapping pairs of letters from a list of unique letters.  </p><p><img width="200" height="auto" src="https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/s2022/az292_kw456_lh479/az292_kw456_lh479/assets/img/equ_1.png" alt="..."/>Equation 1: Number of Permutations</p><p>
                                where N is the total number of letters to be paired and P is the number of pairs. To select P pairs from N objects, there are  <code>N!/(N-2P)!</code> ways. Since the ordering of those pairs and the order of the two objects in the pair do not matter, <code>P!</code> and <code>(2!)^P</code> are in the denominator. For example, there are <code>4!/((4-22)!2!(2!)^2)=3 </code>unique pairs, as shown in the figure below. In our case, the maximal number of unique and non-overlapping pairs we will need to test is  <code>14!/((14-62)!6!(2!)^6)=945945</code> number of pairs, when we are trying to find 6 unique pairs in 14 letters. While this looks like a huge number, it actually does not take the C program that long to run if we keep optimization in mind while implementing the algorithm. We later use the number of possible permutations to verify the correctness of our algorithm. </p></div>
                </div>
            </div>
        </section>
        <!-- Results-->
        <section id="Results">
            <div>
                <div>
                    <div>
                        <h2>Testing, Analysis &amp; Results</h2>
                        <h3>Demo of Bombe Machine Operation</h3>
                        <p>
                        <iframe src="https://www.youtube.com/embed//V2vZobI_-IM" width="560" height="315" frameborder="0" allowfullscreen=""></iframe></p>
                        <p>
                            As shown in the video at the attached link, we show a screen recording of the example we presented at our final demo. Our crib is <code>THEYSAYECESCANDOEVERYTHING</code> and we encrypt the message using our Enigma machine implemented in C, meaning we know the key used (the plugboard settings, rotor settings, etc.). We also know the initial rotor positions, initial rotor turnover positions, as well as the 13-letter chain (split into two messages) that we found when creating a menu from our crib previously. First, we reset the Bombe and input those 13 letters as well as their corresponding stepping positions according to the menu as an input to the Bombe.</p>
                        <h3>Demo of Bombe Machine Operation</h3>
                        <p>
                            To calculate the exact duration of the bombe computation, we added a cycle count feature. In the demo, we showed that it takes 302 cycles to find one valid solution. Given that the clock speed is 50MHz, the time it takes is 6.04 microseconds. Searching through all possible input takes 1131 clock cycles, which is equivalent to 22.62 microseconds. Considering this process used to take 20 minutes (1200000000 microseconds), we accelerated the process by about one million times.
                        </p>
                        <h3>Bombe Checker Computation Time</h3>
                        <p><img src="https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/s2022/az292_kw456_lh479/az292_kw456_lh479/assets/img/bombet1.png"/></p></div>
                </div>
            </div>
        </section>
        <!-- Conclusion-->
        <section id="Conclusion">
            <div>
                <p>
                    <h2>Conclusion</h2>
                </p>
                <div>
                    <div>
                        <p>
                                Based on the successful results from our test cases and user feedback, we are satisfied with how well our design meets our expectations and replicates the hardware of the actual Bombe machine built during WWII. Eighty-two years after it was invented, we preserved its original algorithm in hardware but shortened its computation time tremendously. Considering how many more resources we have and how we were replicating a pre-existing design, we appreciate this ingenious mechanism even more.</p>
                        
                    </div>
                </div>
            </div>
        </section>
        <!-- Appendix-->
        <section id="Appendix">
            
        </section>

        <!-- Contact-->
        <section id="contact">
            <div>
                <div>
                    
                    <div>
                        <div>
                            <div>
                                <h4>Info</h4>
                                <hr/>
                                <p>ECE5760 Advanced Microcontroller Design</p>
                                <p>Cornell University Class of 2022</p>
                                <p>Electrical and Computer Engineering</p>
                            </div>
                        </div>
                    </div>
                    <div>
                        <div>
                            <div>
                                <h4>More</h4>
                                <hr/>
                                <p>Feel free to reach out if you want to learn more!</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <!-- Footer-->
        
        <!-- Bootstrap core JS-->
        
        <!-- Core theme JS-->
        
        <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *-->
        <!-- * *                               SB Forms JS                               * *-->
        <!-- * * Activate your form at https://startbootstrap.com/solution/contact-forms * *-->
        <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *-->
        





        <!-- Portfolio Modals-->
        <!-- Portfolio item 1 modal popup-->
        <div id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true">
            <div>
                <div>
                    <p><img src="https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/s2022/az292_kw456_lh479/az292_kw456_lh479/assets/img/close-icon.svg" alt="Close modal"/></p>
                    <div>
                        <div>
                            <div>
                                <div>
                                    <!-- Project details-->
                                    <h2>TODO</h2>
                                    <p>
                                        TODO
                                    </p>
                                    <video width="500" height="400" controls="">
                                        <source src="assets/img/portfolio/lab1/mazenav.mp4" type="video/mp4"/>
                                    </video>
                                    <p><img width="600" height="auto" src="https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/s2022/az292_kw456_lh479/az292_kw456_lh479/assets/img/portfolio/lab1/mazenavserial.png" alt="..."/>
                                    
                                </p></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>


    

</div>
  </body>
</html>
