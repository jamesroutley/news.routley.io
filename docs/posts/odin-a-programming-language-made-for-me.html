<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zylinski.se/posts/a-programming-language-for-me/">Original</a>
    <h1>Odin: A programming language made for me</h1>
    
    <div id="readability-page-1" class="page"><div><p>In my book <a href="https://odinbook.com">Understanding the Odin Programming Language</a> I wrote that “Odin incorporates some of my favorite C best practices, straight into the language”. But I didn’t really elaborate on the details. Let’s do that here!</p><p>This brings me to talking a bit about a previous job I had. Back in 2021 I worked at a place called <a href="https://ruby0x1.github.io/machinery_blog_archive/">Our Machinery</a>. We were creating a whole game engine in plain C. We used a very comfortable and powerful way to program C.</p><p>We relied on concepts such as:</p><ul><li>Custom allocators</li><li>Temporary allocators</li><li>Tracking allocators</li><li>Designated initializers</li><li>Zero is initialized</li><li>Cache friendly programming</li></ul><p>While working there, I <a href="https://odin-lang.org">stumbled upon Odin</a>. I read a bit about it. It seemed to incorporate all these things. In many ways it seemed like a language built around the specific way in which we programmed C at my job. Since I liked that way of programming, it almost seemed like a language built for me!</p><h2 id="custom-allocators">Custom allocators</h2><p>At my job we had implemented our own <code>Allocator</code> interface in C. An allocator provides a custom way in which one can do dynamic memory allocations. C programmers are used to <code>malloc</code> and <code>free</code>. But you can make allocators that provide more advanced allocation strategies. Our <code>Allocator</code> interface made it possible to reason about allocators in a uniform way and pass them around to functions.</p><p>If a function accepted a parameter of type <code>Allocator</code>, then it was a hint that its return value was dynamically allocated.</p><p>This is exactly how it works in Odin. But the <code>Allocator</code> interface <a href="https://pkg.odin-lang.org/base/runtime/#Allocator">is built into the language’s <code>base</code> library collection</a>! This meant that Odin’s <code>base</code> and <code>core</code> libraries support these allocators too. At my job, the <code>Allocator</code> interface was only supported in our own code: The C standard library didn’t support any of that. But in Odin, my own code <em>and</em> the <code>core</code> libraries can reason about custom allocators, making the concept even more powerful.</p><blockquote><p>In Odin, <code>core</code> and <code>base</code> are two collections of libraries that come with the compiler. Some refer to them as the “standard library” of Odin. But they are shipped as source with the compiler. You are encouraged to make copies of the packages inside <code>core</code>, making it possible to tailor those packages to your own needs. So it’s more of a “default library” than a “standard library”. There’s a sensible default, but you’re free do things however you want.</p></blockquote><h2 id="temporary-allocators">Temporary allocators</h2><p>Temporary memory allocators provide a way to do dynamic memory allocations that are only needed for a short while. What’s “a short while”? Video games have a very convenient “short while”: A single frame.</p><p>At my C job we had a temporary allocator that I used <em>a lot</em>. Gone was the need to manually <code>malloc</code> and <code>free</code> strings and arrays that were only needed for a short while. Just use the temp allocator. It’ll be gone the next frame! And it’s more efficient: The temp allocator allocates into pre-allocated blocks of memory.</p><p>I was happy to discover that Odin came with exactly this functionality. There’s a built in temp allocator available under the name <code>context.temp_allocator</code>. And again, the <code>core</code> libraries and my code uses the same <code>Allocator</code> interface. So I can just pass <code>context.temp_allocator</code> into any <code>core</code> library procedure that accepts an <code>Allocator</code> parameter. Whatever that procedure allocates will then be temporary. Nice!</p><blockquote><p>Odin lets you choose when to clear the temp allocator. You do that by putting <code>free_all(context.temp_allocator)</code> somewhere in your code. In a video game, I’d put it as the last line of the “main game loop”.</p></blockquote><h2 id="tracking-allocators">Tracking allocators</h2><p>Manual memory management may seem hard. How do you know if you’re leaking memory?</p><p>At my C job we had a special tracking allocator that could wrap any other allocator. It recorded when an allocation happened, and recorded when it was deallocated. That way we could display a warning on shutdown, if anything hadn’t been deallocated.</p><p>This is exactly how the tracking allocator that comes with Odin works. Just plop the code below at the top of your <code>main</code> procedure. It’ll print a list of memory leaks on shutdown.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>track</span><span>:</span> <span>mem</span><span>.</span><span>Tracking_Allocator</span>
</span></span><span><span><span>mem</span><span>.</span><span>tracking_allocator_init</span><span>(</span><span>&amp;</span><span>track</span><span>,</span> <span>context</span><span>.</span><span>allocator</span><span>)</span>
</span></span><span><span><span>context</span><span>.</span><span>allocator</span> <span>=</span> <span>mem</span><span>.</span><span>tracking_allocator</span><span>(</span><span>&amp;</span><span>track</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>defer</span> <span>{</span>
</span></span><span><span>	<span>if</span> <span>len</span><span>(</span><span>track</span><span>.</span><span>allocation_map</span><span>)</span> <span>&gt;</span> <span>0</span> <span>{</span>
</span></span><span><span>		<span>fmt</span><span>.</span><span>eprintf</span><span>(</span><span>&#34;=== %v allocations not freed: ===\n&#34;</span><span>,</span> <span>len</span><span>(</span><span>track</span><span>.</span><span>allocation_map</span><span>))</span>
</span></span><span><span>		<span>for</span> <span>_</span><span>,</span> <span>entry</span> <span>in</span> <span>track</span><span>.</span><span>allocation_map</span> <span>{</span>
</span></span><span><span>			<span>fmt</span><span>.</span><span>eprintf</span><span>(</span><span>&#34;- %v bytes @ %v\n&#34;</span><span>,</span> <span>entry</span><span>.</span><span>size</span><span>,</span> <span>entry</span><span>.</span><span>location</span><span>)</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>mem</span><span>.</span><span>tracking_allocator_destroy</span><span>(</span><span>&amp;</span><span>track</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><blockquote><p>You’ll also need to do <code>import &#34;core:mem&#34;</code> and <code>import &#34;core:fmt&#34;</code> at the top of the file. The code above is from the <a href="https://odin-lang.org/docs/overview/#tracking-allocator">Odin overview</a>.</p></blockquote><h2 id="zero-is-initialized-zii">Zero is initialized (ZII)</h2><p>ZII, short for zero is initialized, means that you try to make the zero-value of memory valid in as many situations as possible.</p><p>In Odin all variables are automatically zero initialized. Not just integers and floats. But all structs as well. Their memory is filled with zeroes when those variables are created. So if <code>Some_Type</code> is a struct, then you can just write the following line to declare and zero-initialize a variable of that type:</p><p>This makes ZII extra powerful! There is little risk of variables accidentally being uninitialized. You can lean on that zero initialization. Also, the whole <code>core</code> library of Odin relies on ZII as well. So it feels very natural throughout the whole language and its ecosystem.</p><blockquote><p>You can skip zero initialization by writing <code>x: Some_Type = ---</code>. You rarely need to do so, but it can be a good idea in some specific, performance sensitive situations. It’s great that zero initialization is opt out, instead of opt in. That way we get way less bugs due to uninitialized memory.</p></blockquote><h2 id="designated-initializers">Designated initializers</h2><p>This is a feature built into both C and Odin. The code below will create a variable <code>x</code> of type <code>My_Type</code>. It’ll initialize the field <code>number</code> to <code>7</code>. Any non-mentioned field will be zero-initialized. This plays very well together with the “zero is initialized” concept.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>My_Type</span> <span>::</span> <span>struct</span> <span>{</span>
</span></span><span><span>	<span>number</span><span>:</span> <span>int</span><span>,</span>
</span></span><span><span>	<span>sub_thing</span><span>:</span> <span>Another_Type</span><span>,</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>Another_Type</span> <span>::</span> <span>struct</span> <span>{</span>
</span></span><span><span>	<span>some</span><span>:</span> <span>int</span><span>,</span>
</span></span><span><span>	<span>more</span><span>:</span> <span>f32</span><span>,</span>
</span></span><span><span>	<span>state</span><span>:</span> <span>bool</span><span>,</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>x</span> <span>:=</span> <span>My_Type</span> <span>{</span>
</span></span><span><span>	<span>number</span> <span>=</span> <span>7</span><span>,</span>	
</span></span><span><span><span>}</span>
</span></span></code></pre></div><h2 id="cache-friendly-programming">Cache friendly programming</h2><p>The CPU has some memory inside it that is very fast. It’s called a cache. If you keep the cache filled with whatever data the CPU might need next, then your program will run very fast.</p><p>At my C job we had an entity-component-system (ECS) that used what is known as “Structure of Arrays” (SoA). That’s a memory layout that can, in certain circumstances, help fill your CPU cache with relevant data. Anyone who has written SoA data types in C knows it’s not very fun.</p><p>However, Odin comes with built in SoA support. Just put <code>#soa</code> in front of an array declaration. It’ll automatically re-arrange the memory layout for you.</p><p>As an example, the following code uses the “default layout”. Also known as “Arrays of Structures” (AoS):</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>Person</span> <span>::</span> <span>struct</span> <span>{</span>
</span></span><span><span>	<span>health</span><span>:</span> <span>int</span><span>,</span>
</span></span><span><span>	<span>age</span><span>:</span> <span>int</span><span>,</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>people</span><span>:</span> <span>[</span><span>128</span><span>]</span><span>Person</span>
</span></span></code></pre></div><p>The memory layout of the <code>people</code> array looks like this:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>people[0].health
</span></span><span><span>people[0].age
</span></span><span><span>people[1].health
</span></span><span><span>people[1].age
</span></span><span><span>people[2].health
</span></span><span><span>people[2].age
</span></span><span><span>people[3].health
</span></span><span><span>people[3].age
</span></span><span><span>people[4].health
</span></span><span><span>people[4].age
</span></span><span><span>... etc
</span></span></code></pre></div><p>If you add <code>#soa</code> in front of <code>[128]Person</code>, like so:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>Person</span> <span>::</span> <span>struct</span> <span>{</span>
</span></span><span><span>	<span>health</span><span>:</span> <span>int</span><span>,</span>
</span></span><span><span>	<span>age</span><span>:</span> <span>int</span><span>,</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>people</span><span>:</span> <span>#</span><span>soa</span><span>[</span><span>128</span><span>]</span><span>Person</span>
</span></span></code></pre></div><p>then the memory layout of <code>people</code> will instead look like this:</p><div><pre tabindex="0"><code data-lang="txt"><span><span>people[0].health
</span></span><span><span>people[1].health
</span></span><span><span>people[2].health
</span></span><span><span>people[3].health
</span></span><span><span>people[4].health
</span></span><span><span>... and 123 more health items
</span></span><span><span>people[0].age
</span></span><span><span>people[1].age
</span></span><span><span>people[2].age
</span></span><span><span>people[3].age
</span></span><span><span>people[4].age
</span></span><span><span>... and 123 more age items
</span></span></code></pre></div><p>Achieving this in C is manual work. But here you just add <code>#soa</code>.</p><p>Now, don’t go putting <code>#soa</code> everywhere, just because you can. It will still make the code a bit trickier to write (you need to use <code>#soa</code> pointers etc instead of normal pointers). The code will also be a bit harder to debug. Put it in if you have proof of a clear performance benefit.</p><blockquote><p>By the way, I discourage anyone who is making their own video game from making an ECS. It’s usually not a good idea. Perhaps it’s a good idea for some massive game engines. But for a small project it might just make your code harder to write and thereby your game worse. I feel like people who write an ECS before starting on their gameplay code are people who actually don’t want to make games: They want to make general purpose game engines. That’s fine, but make sure you’re not lying to yourself about what it is you want to do. If you want to make a game, then just make a game. Write the code that you need for the problem at hand, don’t pretend to be a giant game engine company.</p></blockquote><h2 id="finally-simplicity">Finally: Simplicity</h2><p>Odin is very simple language. The reason my job used C over C++ was partially because of the simplicity of C. But we did sometimes miss some modern ideas of C++. However, C++ is a massive beast. We didn’t want to open that can of worms.</p><p>Odin retains the simplicity of C while bringing along some nice modern things, such as generics and (explicit) overloading. But the language is still kept small and simple. And it is meant to remain so. Very few language features have been added to Odin over the last few years. It’s mostly the <code>core</code> libraries that are getting major changes at this point.</p><h2 id="not-everyone-has-my-programming-background">Not everyone has my programming background</h2><p>Learning Odin came naturally to me, due to it being so similar to the way in which I wrote C code.</p><p>You may come from a different background. If these things are unfamiliar to you, but you still want to learn Odin, then perhaps you’d benefit from reading my book <a href="https://odinbook.com">Understanding the Odin Programming Language</a>. It’s meant to be a reader-friendly intro to the language. The book tries to give you the insights I already had when I discovered Odin.</p><h2 id="thanks-for-reading">Thanks for reading!</h2><p>Why not drop by <a href="https://discord.gg/4FsHgtBmFK">my Discord server</a>? On there you can ask me questions as well as discuss Odin and game development.</p><p>Have a nice day!</p><p>/Karl Zylinski</p></div></div>
  </body>
</html>
