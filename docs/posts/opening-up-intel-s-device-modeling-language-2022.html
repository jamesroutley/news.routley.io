<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://community.intel.com/t5/Blogs/Products-and-Solutions/Software/Opening-up-the-Device-Modeling-Language/post/1417739">Original</a>
    <h1>Opening up Intel&#39;s Device Modeling Language (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>
		<div itemprop="text" id="bodyDisplay">
	
		<div>
			
				
					
					
						<p><span>The Device Modeling Language (DML) is a domain-specific language for creating fast functional transaction-level virtual platform models. The first version of DML was launched in 2005, and it has been the standard way to build device models for the <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/simics-simulator.html" target="_blank" rel="noopener nofollow noreferrer">Simics®</a> simulator ever since. </span></p>
<p><span>The Simics use of DML as the primary modeling tool is an interesting example for the virtual platform community. The most common approach for virtual platform modeling is to use a general-purpose language (like C++ or C#) along with a modeling library and simulator API.  Designing a domain-specific language is philosophically different, and in our experience DML has provided benefits for programmer productivity and model quality that provide a clear return-on-investment. </span></p>
<p><span>Some particular observations about the benefits of DML:</span></p>
<ul>
<li><span>DML code is smaller and clearer than general-purpose languages (which is to be expected from a domain-specific language). </span></li>
<li><span>Maintaining code is easier, thanks to the higher level of abstraction.</span></li>
<li><span>It is easy to follow good transaction-level modeling practice.</span></li>
<li><span>Event-driven execution is built in. </span></li>
<li><span>It encourages the use of metadata at all interface points. </span></li>
<li><span>Virtual-platform-specific actions such as scheduling event callbacks and issuing log message are built-in keywords in the language, not function calls. </span></li>
<li><span>The language definition is not limited to what is provided by the underlying language, making it possible to add useful constructs like multiple return values from methods.</span></li>
<li><span>It automatically generates checkpoint-capable models (unless the programmer explicitly breaks checkpointing). </span></li>
<li><span>Compile-time resolution is used wherever possible, to minimize run-time and storage overhead from generic and common code libraries. </span></li>
<li><span>DML can support new versions of the Simics simulator framework with a simple recompile of the code – since the simulator API is handled by the compiler. </span></li>
<li><span>DML code is portable across host types, as the language and Simics simulator runtime system isolate the model code from the specifics of the host. </span></li>
</ul>
<p><span>Previously, the user base and audience for DML has been fairly limited, as it has only been available as part of the Simics simulator. That has changed. The <a href="https://community.intel.com/t5/Blogs/Products-and-Solutions/Software/The-Public-Release-of-Intel-Simics-and-More/post/1372402" target="_blank">Simics simulator is available as a public release</a>, and the DML language and compiler have been made available as <a href="https://github.com/intel/device-modeling-language" target="_blank" rel="noopener nofollow noreferrer">open-source on github</a>. Taken together, these releases make very easy for anyone interested to try DML and do some device modeling with it, in a virtual platform context. </span></p>
<p><span><span image-alt="dml-random-source-code-in-editor.png"><img src="https://community.intel.com/t5/image/serverpage/image-id/33707i41D0EF66E669F17D/image-size/large?v=v2&amp;px=999" role="button" title="dml-random-source-code-in-editor.png" alt="dml-random-source-code-in-editor.png" li-image-url="https://community.intel.com/t5/image/serverpage/image-id/33707i41D0EF66E669F17D?v=v2" li-image-display-id="&#39;33707i41D0EF66E669F17D&#39;" li-message-uid="&#39;1417739&#39;" li-messages-message-image="true" li-bindable="" tabindex="0" li-bypass-lightbox-when-linked="true" li-use-hover-links="false"/></span></span></p>
<p> Some example DML source code being edited in Emacs*</p>

<h2 id="toc-hId--1329440044"><span>The Background of DML<br/></span></h2>
<p><span>Before DML existed, device modeling for the Simics simulator was done using C or C++ and the Simics API. This resulted in large amounts of boilerplate code for mandatory tasks such as registering classes with the simulator core. Whenever such unnecessary repetition is seen, the <a href="https://jakob.engbloms.se/archives/747" target="_blank" rel="noopener nofollow noreferrer">natural reaction</a> of a programmer is to design a little language to distill the interesting parts of the problem. DML grew from an initial C-code generator into a language. </span></p>
<p><span>This resulted in DML 1.0, which was released in 2005. The second version, DML 1.2, was released in 2007. It worked very well, but over time the need for a major overhaul became clear. The current version, DML 1.4, had its first release in 2019. It marked a distinct change compared for DML 1.2, overhauling much of the syntax and refining and defining the language semantics. Since then, there has been a steady stream of additions to the language, with <a href="https://github.com/intel/device-modeling-language/wiki" target="_blank" rel="noopener nofollow noreferrer">more in the pipe</a>. </span></p>
<p><span>The DML compiler generates C code with simulator API calls. Models written in DML can be mixed in the same Simics simulator session as models written in plain C, C++, Python, and SystemC.</span></p>
<h2 id="toc-hId-1158072789"><span>Device Modeling</span></h2>
<p><span>The Device Modeling Language is a language used to model devices, i.e., individual hardware blocks. For example, a timer, serial port, interrupt controller, accelerator block, or Ethernet interface. DML assumes an event-driven transaction-level simulator where the device model is driven by a series of function calls from the outside, and in turn operate by calling other device models. Device models are typically leaves in the system hierarchy (alongside instruction-set simulators, memory maps, interconnects, and memories), and are created by a separate simulator configuration system.</span></p>
<p><span>The main interfaces of a device model are illustrated below. DML provides dedicated language constructs for each of those interfaces.  </span></p>
<ul>
<li><span><strong>Programming registers</strong> (register banks) are used by software drivers</span></li>
<li><span><strong>Connects</strong> let a device call out to other devices</span></li>
<li><span><strong>Ports</strong> receive calls from other devices</span></li>
<li><span><strong>Events</strong> are used to get callbacks at future points in time</span></li>
<li><span><strong>Attributes</strong> are used to configure the device and provide back-door access to the device state for tools and users </span></li>
</ul>
<p><span><span image-alt="dml-device-model-sketch.png"><img src="https://community.intel.com/t5/image/serverpage/image-id/33708i3DC02ED415EE7F81/image-size/large?v=v2&amp;px=999" role="button" title="dml-device-model-sketch.png" alt="dml-device-model-sketch.png" li-image-url="https://community.intel.com/t5/image/serverpage/image-id/33708i3DC02ED415EE7F81?v=v2" li-image-display-id="&#39;33708i3DC02ED415EE7F81&#39;" li-message-uid="&#39;1417739&#39;" li-messages-message-image="true" li-bindable="" tabindex="0" li-bypass-lightbox-when-linked="true" li-use-hover-links="false"/></span></span></p>

<h2 id="toc-hId--649381674"><span>Example Device Declaration</span></h2>
<p><span>Every DML device starts with a device declaration, followed by parameters (</span><strong>param</strong><span> keywords) that provide model metadata and control aspects of the device setup. The behaviors of device-level templates are also controlled and specialized using </span><span>param</span><span>. Standard libraries, interface declarations, and framework code used in a model are pulled in using </span><strong>import</strong><span> statements. </span></p>

<pre><code>// DML version 
dml 1.4;

// Declaring the name of the device class
device m_control;

// Metadata, as device parameters
param desc = &#34;mandelbrot control unit&#34;;
param documentation = &#34;Control unit for synchronizing compute units.&#34;;

// Importing general library files 
import &#34;utility.dml&#34;;

// Importing particular interfaces used in the device 
import &#34;simics/devs/signal.dml&#34;;
import &#34;simics/devs/memory-space.dml&#34;;
import &#34;simics/simulator-api.dml&#34;;
import &#34;m-compute-control-interface.dml&#34;;

// Settings to use in this device model only 
// Enable PCIe setup
param use_pcie = true;
// Enable use of stall performance optimization 
param stall_on_status_read = false;
// Compute units: created outside this device and connected at runtime
// up to a fixed maximum 
param max_compute_units = 8;
</code></pre>

<p><span>The example code used here can be found in the <strong>m-control</strong> device that is part of workshop-02 in the training package in the <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/simics-simulator.html" target="_blank" rel="noopener nofollow noreferrer">public release of the Intel Simics simulator</a>. </span></p>
<h2 id="toc-hId-1838131159"><span>Example Register Bank</span></h2>
<p><span>Register banks are declared using the </span><span>bank</span><span> keyword. Inside each bank, there are registers and fields. For readability, it is recommended to declare the layout of a register bank separate from the implementation. The DML compiler combines all declarations related to the same register into a single implementation, allowing arbitrary code structuring. </span></p>
<p><span>An example register bank: </span></p>

<pre><code>// Declaring a register bank – typically separate from implementation 
bank ctrl {
    param register_size = 8;
    register compute_units @ 0x00 is (read_only) &#34;Available compute units&#34;;
    register start  @ 0x08 is (write) &#34;Start operation&#34;; 
    register status @ 0x10 &#34;Operation status&#34; {
        field done        @ [63] is (write)      &#34;Operation completed&#34; ;
        field processing  @ [62] is (read_only)  &#34;Operation in progress&#34; ;
        field unused      @ [61:0] is (reserved) &#34;unused&#34; ;
    }
    register _reserved    @ 0x18 is (reserved) &#34;Reserved&#34;;
    // Managing the compute units 
    // as bit masks in registers 
    register present @ 0x20 is (compute_unit_bitmask_register) 
                               &#34;compute units present bitmask&#34;;
    register used    @ 0x28 is (compute_unit_bitmask_register) 
                               &#34;units used in current operation&#34;;
    register done    @ 0x30 is (compute_unit_bitmask_register) 
                                &#34;units used &amp; completed operation&#34;;
}
</code></pre>

<p><span>Register layouts generated from specification files (such as </span><span>IP-XACT*</span><span>) are typically saved to their own source file, which is then imported into the device model. Templates (such as </span><strong>read_only</strong><span> or </span><strong>reserved</strong><span> in the code above) are used to specify common behaviors. When more complex and specific behaviors are needed, they are added in a second bank declaration that provides implementations for methods like </span><span><strong>read</strong>()</span><span> and </span><span><strong>write</strong>()</span><span> on registers and fields. </span></p>
<p><span>For example:</span></p>

<pre><code>// Specifying the behavior in a section of code 
// All partial definitions are “merged” in compilation
bank ctrl {
    ...
    register start is write {
        method write(uint64 value) {
            start_compute(value);     // Call method defined elsewhere
            this.val = value;
        }
    }

    ...

    register status {
        field done is write {
            method write(uint64 v) {
                if (v == 1) {
                    if (this.val == 1) {
                        // Wrote a 1 bit to clear the done flag
                        // - Take all side-effect actions needed. 
                        do_clear_done();
                    } else {
                        log spec_viol, 1, control: 
                            &#34;Attempt to clear already clear done flag&#34;;
                    }
                } else {
                    log spec_viol, 1, control: &#34;Writing zero to done has no effect&#34;;
                }
            }
        }
</code></pre>

<p><span>Note the use of </span><strong>log spec_viol</strong><span> to report bad actions from the software. A virtual platform can check and report on what the software does, and DML makes it very easy to add usage warnings like these.</span></p>
<h2 id="toc-hId-30676696"><span>Example Connect and Port</span></h2>
<p><span>Another core function of a device is to communicate with other devices. In DML, this is accomplished using unidirectional connections from one device to another. A device receives incoming transactions as function calls in named <strong>ports.</strong> </span></p>
<p><span>For example, this port is called </span><strong>control_in</strong><span> and implements the </span><strong>m_compute_control</strong><span> interface:</span></p>

<pre><code>port control_in {
    param desc = &#34;control input from the control unit&#34;;

    implement m_compute_control {

        // Start an operation
        method start_operation() {
            log info, 2, control: &#34;Received request to start compute job&#34;;
            if (ctrl.status.processing.val == 1) {
                // Getting to this error state requires that the
                // external world calls start_operation() twice without
                // completing the operation in the meantime. 
                log spec_viol, 1, control :
                    &#34;Operation start request while operation in progress&#34;;
                return;
            } 

            // Note that it is OK to start a new operation if the device
            // is in state &#34;done&#34;.  
            start_compute_job();
        }

        method clear_done() {
            log info, 2, control: &#34;Received request to clear done flag&#34;;
            // Sanity check 
            if (ctrl.status.done.val == 0) {
                log spec_viol, 1, control :
                &#34;Clear done signal received when done flag is not set.&#34;;
                return;
            }    
            log info, 2, control: &#34;Clearing done flag from signal %s&#34;, this.qname;
            do_clear_done();
        }
    }
}
</code></pre>

<p><span>Interfaces are defined outside of the device model, since they are by nature shared between multiple devices. On the sending side of the interface, there is a </span><strong>connect</strong><span><strong>.</strong> For example, the following declaration creates an array of connections from a device to a set of devices implementing the </span><strong>m_compute_control</strong><span> interface: </span></p>

<pre><code>connect compute_unit_control[i&lt;max_compute_units] {
    param desc = &#34;Connection to the compute unit control ports&#34;;
    param configuration = &#34;optional&#34;; 
    param internal = false;       // = list-attributes shows it by default
    interface m_compute_control;

    // This method handles the &#34;protocol&#34; to a compute unit.
    // Avoids putting that into the starting-operation method. 
    method signal_start_operation() {
        if (!obj) {
            // Print clear error message - even though this should not happen unless
            // the user interactively breaks the simulation setup at runtime. 
            log error: &#34;Model setup is inconsistent! (connect %s has no object)&#34;, 
                       this.qname; 
            return;
        }
        // Signal the object to start computing
        this.m_compute_control.start_operation();
    }

    method signal_clear_done() {
        if (!obj) {
            // Print clear error message (same logic as above)
            log error: &#34;Model setup is inconsistent! (connect %s has no object)&#34;, 
                       this.qname; 
            return;
        }
        // Signal the object to clear the done flag
        this.m_compute_control.clear_done();
    }
}
</code></pre>

<p><span>When used in the Simics simulator, the connect automatically creates a configuration attribute that is used by the simulator setup system to point at the receiving object’s port. </span></p>
<h2 id="toc-hId--1776777767"><span>Try It Out!</span></h2>
<p><span>The above code examples are just a few snippets to demonstrate what DML looks like. To learn more, the best way is to <a href="https://www.intel.com/content/www/us/en/developer/articles/guide/simics-simulator-installation.html" target="_blank" rel="noopener nofollow noreferrer">download and install</a> the <a href="https://developer.intel.com/simics-simulator" target="_blank" rel="noopener nofollow noreferrer">public release of the Intel Simics simulator</a>. As documented in the <a href="https://www.intel.com/content/www/us/en/developer/articles/guide/simics-simulator-get-started.html" target="_blank" rel="noopener nofollow noreferrer">get started guide</a>, there is a workshop called w02 that uses DML to model a PCIe-based accelerator. There are also many device models written in DML in the Simics base package and Simics Quick-Start Platform (QSP).  The DML language is documented in the Simics simulator documentation, as well as on the <a href="https://github.com/intel/device-modeling-language/wiki/DML-1.4-Reference-Manual" target="_self" rel="nofollow noopener noreferrer">github page</a>. </span></p>
<p><span>The Simics simulator installation contains a ready-built DML compiler, but you can also <a href="https://intel.github.io/dml-lang/refman/2.-The-DML-compiler" target="_blank" rel="noopener nofollow noreferrer">build your own DML compiler</a> from the sources and use it to build models in a Simics simulator project. </span></p>



					
				
			
			
			
			
			
			
			
			
		</div>
		
		
	

	
	
</div>
	</div></div>
  </body>
</html>
