<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.micahcantor.com/blog/programming-beyond-paradigms/">Original</a>
    <h1>Programming Beyond Paradigms</h1>
    
    <div id="readability-page-1" class="page"><div>
        <a href="https://www.micahcantor.com/" title="back" aria-label="back">
            <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
            </svg>
        </a>
        
        <p>
            <i>Why the next paradigm in programming is no paradigm at all.</i>
        </p>
        
            <p>Published: <time>March 31, 2024</time></p>
        
        
          
        <hr/> 
        <p>Since the invention of high-level programming languages, programming has been dominated by paradigms. 
From imperative to object-oriented to functional, paradigms shape much of the modern discourse around programming languages.</p>
<p>Paradigms are often used to categorize the many different languages, styles, and eras of programming.
Many universities also structure their curricula around paradigms, offering courses in different styles of progamming.
And of course paradigms are an endless topic of debate among programmers: 
countless blog posts have been written on why functional is superior to object-oriented programming, and vice-versa.</p>
<p>This leads to a natural question: <em>what really is a programming paradigm?</em>
The most common understanding is that a paradigm is a set of features in a progamming language that determine its control flow or type system.
For instance, this definition can be applied to three prototypical languages created in the 20th century:</p>
<ul>
<li>C is an imperative language; its programs are composed of statements and procedures that are executed top-to-bottom.</li>
<li>Java is an object-oriented language; its programs are composed of objects that interact through dynamic dispatch.</li>
<li>Haskell is a functional language; its programs are evaluated by the composition and application of pure functions. </li>
</ul>
<p>Programming languages of the past were limited in the number and breadth of features they could offer. 
For Java and Haskell, the language designers chose a set of features that they felt would produce the best programs.
The creators of C did the same, but were also limited by the feasibility of a feature&#39;s implementation.</p>
<p>But modern programming languages are far less limited in the scope of features they choose to include and their capacity to do so.
This has led many languages to adopt a new and somewhat confounding adjective: <em>multi-paradigm</em>.</p>
<p>Indeed, almost all modern languages are best described as multi-paradigm. 
The latest versions of Python, JavaScript, and even Java all offer the features needed for functional programming alongside imperative and object-oriented progamming. The same could be said for C++, C#, OCaml, and more.</p>
<p>Due to the relative feature-set equality between languages, I believe that programming paradigms are now best understood as a <em>style</em> of programming, rather than as an exclusive set of features. Since almost all languages are multi-paradigm, we can&#39;t categorize an entire language under a single paradigm. But we can still compare how particular programs, or parts of programs, use one paradigm or another across languages.</p>
<p>General purpose languages of the 21st century don&#39;t define themselves by a single paradigm anymore, nor do they use the term multi-paradigm.
The unifying aspect of new languages such as <a href="https://www.rust-lang.org/">Rust</a>, <a href="https://nim-lang.org/">Nim</a>, and <a href="https://gleam.run/">Gleam</a> is that they were designed from the beginning to be <strong>beyond paradigms</strong>.</p>
<p>These post-paradigm languages draw on the best features of past languages and refuse to limit the programmer to a single style. 
This puts more power and creativity in the hands of the programmer rather than the language designer.</p>
<p>Programming languages of the future will continue to prioritize the inclusion of the best individual features in their language or tooling, regardless of paradigm. I think there will continue to be a great diversity between different languages, but the best aspects of each programming paradigm refuse to be siloed.</p>

    </div></div>
  </body>
</html>
