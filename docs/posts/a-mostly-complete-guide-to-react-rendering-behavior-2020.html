<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/">Original</a>
    <h1>A mostly complete guide to React rendering behavior (2020)</h1>
    
    <div id="readability-page-1" class="page"><article>
	
  <header>
    
    
	
        
	    
    	<p><a href="" id="series"></a>This is a post in the <a href="https://blog.isquaredsoftware.com/series/blogged-answers"><b>Blogged Answers</b></a> series.
        </p><hr/>
	 
  </header>
  <section>
    <i> Details on how React rendering behaves, and how use of Context and React-Redux affect rendering </i>

<p>I&#39;ve seen a lot of ongoing confusion over when, why, and how React will re-render components, and how use of Context and React-Redux will affect the timing and scope of those re-renders. After having typed up variations of this explanation dozens of times, it seems it&#39;s worth trying to write up a consolidated explanation that I can refer people to. Note that all this information is available online already, and has been explained in numerous other excellent blog posts and articles, several of which I&#39;m linking at the end in the <a href="#further-information">&#34;Further Information&#34;</a> section for reference. But, people seem to be struggling to put the pieces together for a full understanding, so hopefully this will help clarify things for someone.</p>

<blockquote>
<p><strong>Note</strong>: Updated October 2022 to cover React 18 and future React updates</p>
</blockquote>

<p>I also did a talk based on this post for React Advanced 2022:</p>

<p><a href="https://blog.isquaredsoftware.com/2023/08/presentations-react-rendering-behavior/"><strong>React Advanced 2022 - A (Brief) Guide to React Rendering Behavior</strong></a></p>

<h3 id="table-of-contents">Table of Contents<a href="#table-of-contents" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<ul>
<li><a href="#what-is-rendering">What is &#34;Rendering&#34;?</a>

<ul>
<li><a href="#rendering-process-overview">Rendering Process Overview</a></li>
<li><a href="#render-and-commit-phases">Render and Commit Phases</a></li>
</ul></li>
<li><a href="#how-does-react-handle-renders">How Does React Handle Renders?</a>

<ul>
<li><a href="#queuing-renders">Queuing Renders</a></li>
<li><a href="#standard-render-behavior">Standard Render Behavior</a></li>
<li><a href="#rules-of-react-rendering">Rules of React Rendering</a></li>
<li><a href="#component-metadata-and-fibers">Component Metadata and Fibers</a></li>
<li><a href="#component-types-and-reconciliation">Component Types and Reconciliation</a></li>
<li><a href="#keys-and-reconciliation">Keys and Reconciliation</a></li>
<li><a href="#render-batching-and-timing">Render Batching and Timing</a></li>
<li><a href="#async-rendering-closures-and-state-snapshots">Async Rendering, Closures, and State Snapshots</a></li>
<li><a href="#render-behavior-edge-cases">Render Behavior Edge Cases</a></li>
</ul></li>
<li><a href="#improving-rendering-performance">Improving Rendering Performance</a>

<ul>
<li><a href="#component-render-optimization-techniques">Component Render Optimization Techniques</a></li>
<li><a href="#how-new-props-references-affect-render-optimizations">How New Props References Affect Render Optimizations</a></li>
<li><a href="#optimizing-props-references">Optimizing Props References</a></li>
<li><a href="#memoize-everything">Memoize Everything?</a></li>
<li><a href="#immutability-and-rerendering">Immutability and Rerendering</a></li>
<li><a href="#measuring-react-component-rendering-performance">Measuring React Component Rendering Performance</a></li>
</ul></li>
<li><a href="#context-and-rendering-behavior">Context and Rendering Behavior</a>

<ul>
<li><a href="#context-basics">Context Basics</a></li>
<li><a href="#updating-context-values">Updating Context Values</a></li>
<li><a href="#state-updates-context-and-re-renders">State Updates, Context, and Re-Renders</a></li>
<li><a href="#context-updates-and-render-optimizations">Context Updates and Render Optimizations</a></li>
</ul></li>
<li><a href="#react-redux-and-rendering-behavior">React-Redux and Rendering Behavior</a>

<ul>
<li><a href="#react-redux-subscriptions">React-Redux Subscriptions</a></li>
<li><a href="#differences-between-connect-and-useselector">Differences between <code>connect</code> and <code>useSelector</code></a></li>
</ul></li>
<li><a href="#future-react-improvements">Future React Improvements</a>

<ul>
<li><a href="#react-forget-memoizing-compiler">&#34;React Forget&#34; Memoizing Compiler</a></li>
<li><a href="#context-selectors">Context Selectors</a></li>
</ul></li>
<li><a href="#summary">Summary</a></li>
<li><a href="#final-thoughts">Final Thoughts</a></li>
<li><a href="#further-information">Further Information</a></li>
</ul>

<h2 id="what-is-rendering">What is &#34;Rendering&#34;?<a href="#what-is-rendering" arialabel="Anchor"> üîóÔ∏é</a> </h2>

<p><strong>Rendering</strong> is the process of React asking your components to describe what they want their section of the UI to look like, now, based on the current combination of props and state.</p>

<h3 id="rendering-process-overview">Rendering Process Overview<a href="#rendering-process-overview" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>During the rendering process, React will start at the root of the component tree and loop downwards to find all components that have been flagged as needing updates. For each flagged component, React will call either <code>FunctionComponent(props)</code> (for function components), or <code>classComponentInstance.render()</code> (for class components) , and save the render output for the next steps of the render pass.</p>

<p>A component&#39;s render output is normally written in JSX syntax, which is then converted to <code>React.createElement()</code> calls as the JS is compiled and prepared for deployment. <code>createElement</code> returns React <em>elements</em>, which are plain JS objects that describe the intended structure of the UI. Example:</p>

<pre><code>// This JSX syntax:
return &lt;MyComponent a={42} b=&#34;testing&#34;&gt;Text here&lt;/MyComponent&gt;

// is converted to this call:
return React.createElement(MyComponent, {a: 42, b: &#34;testing&#34;}, &#34;Text Here&#34;)

// and that becomes this element object:
{type: MyComponent, props: {a: 42, b: &#34;testing&#34;}, children: [&#34;Text Here&#34;]}

// And internally, React calls the actual function to render it:
let elements = MyComponent({...props, children})

// For &#34;host components&#34; like HTML:
return &lt;button onClick={() =&gt; {}}&gt;Click Me&lt;/button&gt;
// becomes
React.createElement(&#34;button&#34;, {onClick}, &#34;Click Me&#34;)
// and finally:
{type: &#34;button&#34;, props: {onClick}, children: [&#34;Click me&#34;]}
</code></pre>

<p>After it has collected the render output from the entire component tree, React will diff the new tree of objects (frequently referred to as the &#34;virtual DOM&#34;), and collects a list of all the changes that need to be applied to make the real DOM look like the current desired output. The diffing and calculation process is known as <a href="https://legacy.reactjs.org/docs/reconciliation.html">&#34;reconciliation&#34;</a>.</p>

<p>React then applies all the calculated changes to the DOM in one synchronous sequence.</p>

<blockquote>
<p><strong>Note:</strong> The React team has downplayed the term &#34;virtual DOM&#34; in recent years. <a href="https://twitter.com/dan_abramov/status/1066328666341294080?lang=en">Dan Abramov said</a>:</p>

<p>I wish we could retire the term ‚Äúvirtual DOM‚Äù. It made sense in 2013 because otherwise people assumed React creates DOM nodes on every render. But people rarely assume this today. ‚ÄúVirtual DOM‚Äù sounds like a workaround for some DOM issue. But that‚Äôs not what React is.</p>
</blockquote>

<h3 id="render-and-commit-phases">Render and Commit Phases<a href="#render-and-commit-phases" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>The React team divides this work into two phases, conceptually:</p>

<ul>
<li>The &#34;Render phase&#34; contains all the work of rendering components and calculating changes</li>
<li>The &#34;Commit phase&#34; is the process of applying those changes to the DOM</li>
</ul>

<p>After React has updated the DOM in the commit phase, it updates all refs accordingly to point to the requested DOM nodes and component instances. It then synchronously runs the <code>componentDidMount</code> and <code>componentDidUpdate</code> class lifecycle methods, and the <code>useLayoutEffect</code> hooks.</p>

<p>React then sets a short timeout, and when it expires, runs all the <code>useEffect</code> hooks. This step is also known as the &#34;Passive Effects&#34; phase.</p>

<p>React 18 added &#34;Concurrent Rendering&#34; features like <a href="https://github.com/reactwg/react-18/discussions/64"><code>useTransition</code></a>. This gives React the ability to pause the work in the rendering phase to allow the browser to process events. React will either resume, throw away, or recalculate that work later as appropriate. Once the render pass has been completed, React will still run the commit phase synchronously in one step.</p>

<p>A key part of this to understand is that <strong>&#34;rendering&#34; is not the same thing as &#34;updating the DOM&#34;, and a component may be rendered without any visible changes happening as a result</strong>. When React renders a component:</p>

<ul>
<li>The component might return the same render output as last time, so no changes are needed</li>
<li>In Concurrent Rendering, React might end up rendering a component multiple times, but throw away the render output each time if other updates invalidate the current work being done</li>
</ul>

<p>This <a href="https://julesblom.com/writing/react-hook-component-timeline">excellent interactive React hooks timeline diagram</a> helps illustrate the sequencing of rendering, committing, and executing hooks:</p>

<p><img src="https://blog.isquaredsoftware.com/images/2020-05-react-rendering-behavior/react-hook-timeline-diagram.png" alt="React hooks timeline diagram"/></p>

<p>For additional visualizations, see:</p>

<ul>
<li><a href="https://github.com/donavon/hook-flow">React hooks flow diagram</a></li>
<li><a href="https://wavez.github.io/react-hooks-lifecycle/">React hooks render/commit phase diagram</a></li>
<li><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">React class lifecycle methods diagram</a></li>
</ul>

<h2 id="how-does-react-handle-renders">How Does React Handle Renders?<a href="#how-does-react-handle-renders" arialabel="Anchor"> üîóÔ∏é</a> </h2>

<h3 id="queuing-renders">Queuing Renders<a href="#queuing-renders" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>After the initial render has completed, there are a few different ways to tell React to queue a re-render:</p>

<ul>
<li>Function components:

<ul>
<li><code>useState</code> setters</li>
<li><code>useReducer</code> dispatches</li>
</ul></li>
<li>Class components:

<ul>
<li><code>this.setState()</code></li>
<li><code>this.forceUpdate()</code></li>
</ul></li>
<li>Other:

<ul>
<li>Calling the ReactDOM top-level <code>render(&lt;App&gt;)</code> method again (which is equivalent to calling <code>forceUpdate()</code> on the root component)</li>
<li>Updates triggered from the new <code>useSyncExternalStore</code> hook</li>
</ul></li>
</ul>

<p>Note that function components don&#39;t have a <code>forceUpdate</code> method, but you can get the same behavior by using a <code>useReducer</code> hook that always increments a counter:</p>

<pre><code>const [, forceRender] = useReducer((c) =&gt; c + 1, 0);
</code></pre>

<h3 id="standard-render-behavior">Standard Render Behavior<a href="#standard-render-behavior" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>It&#39;s very important to remember that:</p>

<p><strong>React&#39;s default behavior is that when a parent component renders, React will recursively render <em>all</em> child components inside of it!</strong></p>

<p>As an example, say we have a component tree of <code>A &gt; B &gt; C &gt; D</code>, and we&#39;ve already shown them on the page. The user clicks a button in <code>B</code> that increments a counter:</p>

<ul>
<li>We call <code>setState()</code> in <code>B</code>, which queues a re-render of B.</li>
<li>React starts the render pass from the top of the tree</li>
<li>React sees that <code>A</code> is not marked as needing an update, and moves past it</li>
<li>React sees that <code>B</code> is marked as needing an update, and renders it. <code>B</code> returns <code>&lt;C /&gt;</code> as it did last time.</li>
<li><code>C</code> was <em>not</em> originally marked as needing an update. However, because its parent <code>B</code> rendered, React now moves downwards and renders <code>C</code> as well. C returns <code>&lt;D /&gt;</code> again.</li>
<li><code>D</code> was also not marked for rendering, but since its parent <code>C</code> rendered, React moves downward and renders <code>D</code> too.</li>
</ul>

<p>To repeat this another way:</p>

<p><strong>Rendering a component will, by default, cause <em>all</em> components inside of it to be rendered too!</strong></p>

<p>Also, another key point:</p>

<p><strong>In normal rendering, React does <em>not</em> care whether &#34;props changed&#34; - it will render child components unconditionally just because the parent rendered!</strong></p>

<p>This means that calling <code>setState()</code> in your root <code>&lt;App&gt;</code> component, with no other changes altering the behavior, <em>will</em> cause React to re-render every single component in the component tree. After all, one of the original sales pitches for React was <a href="https://www.slideshare.net/floydophone/react-preso-v2">&#34;act like we&#39;re redrawing the entire app on every update&#34;</a>.</p>

<p>Now, it&#39;s very likely that most of the components in the tree will return the exact same render output as last time, and therefore React won&#39;t need to make any changes to the DOM. <em>But</em>, React will still have to do the work of asking components to render themselves and diffing the render output. Both of those take time and effort.</p>

<p>Remember, <strong>rendering is not a <em>bad</em> thing - it&#39;s how React knows whether it needs to actually make any changes to the DOM!</strong></p>

<h3 id="rules-of-react-rendering">Rules of React Rendering<a href="#rules-of-react-rendering" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>One of the primary rules of React rendering is that <strong>rendering must be &#34;pure&#34; and not have any side effects!</strong></p>

<p>This can be tricky and confusing, because many side effects are not obvious, and don&#39;t result in anything breaking. For example, strictly speaking a <code>console.log()</code> statement is a side effect, but it won&#39;t actually break anything. Mutating a prop is definitely a side effect, and it <em>might</em> not break anything. Making an AJAX call in the middle of rendering is also definitely a side effect, and can definitely cause unexpected app behavior depending on the type of request.</p>

<p>Sebastian Markbage wrote an excellent document entitled <a href="https://gist.github.com/sebmarkbage/75f0838967cd003cd7f9ab938eb1958f"><strong>The Rules of React</strong></a>. In it, he defines the expected behaviors for different React lifecycle methods, including <code>render</code>, and what kinds of operations would be considered safely &#34;pure&#34; and which would be unsafe. It&#39;s worth reading that in its entirety, but I&#39;ll summarize the key points:</p>

<ul>
<li>Render logic <em>must not</em>:

<ul>
<li>Can&#39;t mutate existing variables and objects</li>
<li>Can&#39;t create random values like <code>Math.random()</code> or <code>Date.now()</code></li>
<li>Can&#39;t make network requests</li>
<li>Can&#39;t queue state updates</li>
</ul></li>
<li>Render logic <em>may</em>:

<ul>
<li>Mutate objects that were newly created while rendering</li>
<li>Throw errors</li>
<li>&#34;Lazy initialize&#34; data that hasn&#39;t been created yet, such as a cached value</li>
</ul></li>
</ul>

<h3 id="component-metadata-and-fibers">Component Metadata and Fibers<a href="#component-metadata-and-fibers" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>React stores an internal data structure that tracks all the current component instances that exist in the application. The core piece of this data structure is an object called a &#34;fiber&#34;, which contains metadata fields that describe:</p>

<ul>
<li>What component type is supposed to be rendered at this point in the component tree</li>
<li>The current props and state associated with this component</li>
<li>Pointers to parent, sibling, and child components</li>
<li>Other internal metadata that React uses to track the rendering process</li>
</ul>

<p>If you&#39;ve ever <a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">heard the phrase &#34;React Fiber&#34;</a> used to describe a React version or feature, that&#39;s really referring to the rewrite of React&#39;s internals that switched the rendering logic to rely on these &#34;Fiber&#34; objects as the key data structure. That was released as React 16.0, so every version of React since then has used this approach.</p>

<p>The shortened version of the <code>Fiber</code> type looks like:</p>

<pre><code>export type Fiber = {
  // Tag identifying the type of fiber.
  tag: WorkTag;

  // Unique identifier of this child.
  key: null | string;

  // The resolved function/class/ associated with this fiber.
  type: any;

  // Singly Linked List Tree Structure.
  child: Fiber | null;
  sibling: Fiber | null;
  index: number;

  // Input is the data coming into this fiber (arguments/props)
  pendingProps: any;
  memoizedProps: any; // The props used to create the output.

  // A queue of state updates and callbacks.
  updateQueue: Array&lt;State | StateUpdaters&gt;;

  // The state used to create the output
  memoizedState: any;

  // Dependencies (contexts, events) for this fiber, if any
  dependencies: Dependencies | null;
};
</code></pre>

<p>(You can see <a href="https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactInternalTypes.js#L64-L193">the full definition of the <code>Fiber</code> type as of React 18 here</a>.)</p>

<p>During a rendering pass, React will iterate over this tree of fiber objects, and construct an updated tree as it calculates the new rendering results.</p>

<p>Note that <strong>these &#34;fiber&#34; objects store the <em>real</em> component props and state values</strong>. When you use <code>props</code> and <code>state</code> in your components, React is actually giving you access to the values that were stored on the fiber objects. In fact, for class components specifically, <a href="https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactFiberClassComponent.new.js#L1083-L1087">React explicitly copies <code>componentInstance.props = newProps</code> over to the component right before rendering it</a>. So, <code>this.props</code> does exist, but it only exists because React copied the reference over from its internal data structures. In that sense, components are sort of a facade over React&#39;s fiber objects.</p>

<p>Similarly, React hooks work because <a href="https://www.swyx.io/getting-closure-on-hooks/">React stores all of the hooks for a component as a linked list attached to that component&#39;s fiber object</a>. When React renders a function component, it gets that linked list of hook description entries from the fiber, and every time you call another hook, <a href="https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L908">it returns the appropriate values that were stored in the hook description object (like the <code>state</code> and <code>dispatch</code> values for <code>useReducer</code></a>.</p>

<p>When a parent component renders a given child component for the first time, React creates a fiber object to track that &#34;instance&#34; of a component. For class components, <a href="https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactFiberClassComponent.new.js#L656">it literally calls <code>const instance = new YourComponentType(props)</code></a> and saves the actual component instance onto the fiber object. For function components, <a href="https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L428">React just calls <code>YourComponentType(props)</code> as a function</a>.</p>

<h3 id="component-types-and-reconciliation">Component Types and Reconciliation<a href="#component-types-and-reconciliation" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>As described in the <a href="https://legacy.reactjs.org/docs/reconciliation.html#elements-of-different-types">&#34;Reconciliation&#34; docs page</a>, React tries to be efficient during re-renders, by reusing as much of the existing component tree and DOM structure as possible. If you ask React to render the same type of component or HTML node in the same place in the tree, React will reuse that and just apply updates if appropriate, instead of re-creating it from scratch. That means that React will keep component instances alive as long as you keep asking React to render that component type in the same place. For class components, it actually does use the same actual instance of your component. A function component has no true &#34;instance&#34; the way a class does, but we can think of <code>&lt;MyFunctionComponent /&gt;</code> as representing an &#34;instance&#34; in terms of &#34;a component of this type is being shown here and kept alive&#34;.</p>

<p>So, how does React know when and how the output has actually changed?</p>

<p>React&#39;s rendering logic compares elements based on their <code>type</code> field first, using <code>===</code> reference comparisons. If an element in a given spot has changed to a different type, such as going from <code>&lt;div&gt;</code> to <code>&lt;span&gt;</code> or <code>&lt;ComponentA&gt;</code> to <code>&lt;ComponentB&gt;</code>, React will speed up the comparison process by assuming that entire tree has changed. As a result, <strong>React will destroy that entire existing component tree section, including all DOM nodes</strong>, and recreate it from scratch with new component instances.</p>

<p>This means that <strong>you must never create new component types while rendering!</strong> Whenever you create a new component type, it&#39;s a different reference, and that will cause React to repeatedly destroy and recreate the child component tree.</p>

<p>In other words, <strong><em>don&#39;t</em></strong> do this:</p>

<pre><code>// ‚ùå BAD!
// This creates a new `ChildComponent` reference every time!
function ParentComponent() {
  function ChildComponent() {
    return &lt;div&gt;Hi&lt;/div&gt;;
  }

  return &lt;ChildComponent /&gt;;
}
</code></pre>

<p>Instead, always define components separately:</p>

<pre><code>// ‚úÖ GOOD
// This only creates one component type reference
function ChildComponent() {
  return &lt;div&gt;Hi&lt;/div&gt;;
}

function ParentComponent() {
  return &lt;ChildComponent /&gt;;
}
</code></pre>

<h3 id="keys-and-reconciliation">Keys and Reconciliation<a href="#keys-and-reconciliation" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>The other way that React identifies component &#34;instances&#34; is via the <code>key</code> pseudo-prop. React uses <code>key</code> as a unique identifier that it can use to differentiate specific instances of a component type.</p>

<p>Note that <code>key</code> isn&#39;t actually a <em>real</em> prop - it&#39;s an instruction to React. React will always strip that off, and it will never be passed through to the actual component, so you can never have <code>props.key</code> - it will always be <code>undefined</code>.</p>

<p>The main place we use keys is rendering lists. Keys are especially important here if you are rendering data that may be changed in some way, such as reordering, adding, or deleting list entries. It&#39;s particularly important here that <strong>keys <em>should</em> be some kind of unique IDs from your data if at all possible - only use array indices as keys as a last resort fallback!</strong></p>

<pre><code>// ‚úÖ Use a data object ID as the key for list items
todos.map((todo) =&gt; &lt;TodoListItem key={todo.id} todo={todo} /&gt;);
</code></pre>

<p>Here&#39;s an example of why this matters. Say I render a list of 10 <code>&lt;TodoListItem&gt;</code> components, using array indices as keys. React sees 10 items, with keys of <code>0..9</code>. Now, if we delete items 6 and 7, and add three new entries at the end, we end up rendering items with keys of <code>0..10</code>. So, it looks to React like I really just added one new entry at the end because we went from 10 list items to 11. React will happily reuse the existing DOM nodes and component instances. But, that means that we&#39;re probably now rendering <code>&lt;TodoListItem key={6}&gt;</code> with the todo item that <em>was</em> being passed to list item #8. So, the component instance is still alive, but now it&#39;s getting a different data object as a prop than it was previously. This may work, but it may also produce unexpected behavior. Also, React will now have to go apply updates to several of the list items to change the text and other DOM contents, because the existing list items are now having to show different data than before. Those updates really shouldn&#39;t be necessary here, since none of those list items changed.</p>

<p>If instead we were using <code>key={todo.id}</code> for each list item, React will correctly see that we deleted two items and added three new ones. It will destroy the two deleted component instances and their associated DOM, and create three new component instances and their DOM. This is better than having to unnecessarily update the components that didn&#39;t actually change.</p>

<p>Keys are useful for component instance identity beyond lists as well. <strong>You can add a <code>key</code> to any React component at any time to indicate its identity, and changing that key will cause React to destroy the old component instance and DOM and create new ones</strong>. A common use case for this is a list + details form combination, where the form shows the data for the currently selected list item. Rendering <code>&lt;DetailForm key={selectedItem.id}&gt;</code> will cause React to destroy and re-create the form when the selected item changes, thus avoiding any issues with stale state inside the form.</p>

<h3 id="render-batching-and-timing">Render Batching and Timing<a href="#render-batching-and-timing" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>By default, each call to <code>setState()</code> causes React to start a new render pass, execute it synchronously, and return. However, React also applies a sort of optimization automatically, in the form of <em>render batching</em>. <strong>Render batching is when multiple calls to <code>setState()</code> result in a single render pass being queued and executed, usually on a slight delay</strong>.</p>

<p>The React community often describes this as &#34;state updates may be asynchronous&#34;. The new React docs also describe it as <a href="https://react.dev/learn/adding-interactivity#state-as-a-snapshot">&#34;State is a Snapshot&#34;</a>. That&#39;s a reference to this render batching behavior.</p>

<p>In React 17 and earlier, React only did batching in React event handlers such as <code>onClick</code> callbacks. Updates queued outside of event handlers, such as in a <code>setTimeout</code>, after an <code>await</code>, or in a plain JS event handler, were <em>not</em> queued, and would each result in a separate re-render.</p>

<p>However, <strong><a href="https://github.com/reactwg/react-18/discussions/21">React 18 now does &#34;automatic batching&#34; of <em>all</em> updates queued in any single event loop tick</a></strong>. This helps cut down on the overall number of renders needed.</p>

<p>Let&#39;s look at a specific example.</p>

<pre><code>const [counter, setCounter] = useState(0);

const onClick = async () =&gt; {
  setCounter(0);
  setCounter(1);

  const data = await fetchSomeData();

  setCounter(2);
  setCounter(3);
};
</code></pre>

<p>With React 17, this executed <strong>three</strong> render passes. The first pass will batch together <code>setCounter(0)</code> and <code>setCounter(1)</code>, because both of them are occurring during the original event handler call stack, and so they&#39;re both occurring inside the <code>unstable_batchedUpdates()</code> call.</p>

<p>However, the call to <code>setCounter(2)</code> is happening after an <code>await</code>. This means the original synchronous call stack is done, and the second half of the function is running much later in a totally separate event loop call stack. Because of that, React will execute an entire render pass synchronously as the last step inside the <code>setCounter(2)</code> call, finish the pass, and return from <code>setCounter(2)</code>.</p>

<p>The same thing will then happen for <code>setCounter(3)</code>, because it&#39;s also running outside the original event handler, and thus outside the batching.</p>

<p>However, <strong>with React 18, this executes <em>two</em> render passes</strong>. The first two, <code>setCounter(0)</code> and <code>setCounter(1)</code>, are batched together because they&#39;re in one event loop tick. Later, after the <code>await</code>, both <code>setCounter(2)</code> and <code>setCounter(3)</code> are batched together - even though they&#39;re much later, that&#39;s <em>also</em> two state updates queued in the same event loop, so they get batched into a second render.</p>

<h3 id="async-rendering-closures-and-state-snapshots">Async Rendering, Closures, and State Snapshots<a href="#async-rendering-closures-and-state-snapshots" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>One extremely common mistake we see all the time is when a user sets a new value, then tries to log the existing variable name. However, the original value gets logged, not the updated value.</p>

<pre><code>function MyComponent() {
  const [counter, setCounter] = useState(0);

  const handleClick = () =&gt; {
    setCounter(counter + 1);
    // ‚ùå THIS WON&#39;T WORK!
    console.log(counter);
    // Original value was logged - why is this not updated yet??????
  };
}
</code></pre>

<p>So, why doesn&#39;t this work?</p>

<p>As mentioned above, it&#39;s common for experienced users to say &#34;React state updates are async&#34;. This is <em>sort</em> of true, but there&#39;s a bit more nuance then that, and actually a couple different problems at work here.</p>

<p>Strictly speaking, the React render is literally synchronous - it will be executed in a &#34;microtask&#34; at the very end of this event loop tick. (This is admittedly being pedantic, but the goal of this article is exact details and clarity.) However, yes, from the point of view of that <code>handleClick</code> function, it&#39;s &#34;async&#34; in that you can&#39;t immediately see the results, and the actual update occurs much later than the <code>setCounter()</code> call.</p>

<p>However, there&#39;s a bigger reason why this doesn&#39;t work. <strong>The <code>handleClick</code> function is a <em>&#34;closure&#34;</em> - it can <em>only</em> see the values of variables as they existed <em>when the function was defined</em></strong>. In other words, <strong>these state variables are a snapshot in time</strong>.</p>

<p>Since <code>handleClick</code> was defined during the most recent render of this function component, <strong>it can <em>only</em> see the value of <code>counter</code> as it existed during that render pass.</strong> When we call <code>setCounter()</code>, it queues up a <em>future</em> render pass, and that <em>future</em> render will have a new <code>counter</code> variable with the new value and a new <code>handleClick</code> function... <strong>but <em>this</em> copy of <code>handleClick</code> will never be able to see that new value.</strong></p>

<p>The new React docs cover this in more detail in the section <a href="https://react.dev/learn/adding-interactivity#state-as-a-snapshot"><strong>State as a Snapshot</strong></a>, which is highly recommended reading.</p>

<p>Going back to the original example: trying to use a variable right after you set an updated value is almost always the wrong approach, and suggests you need to rethink how you are trying to use that value.</p>

<h3 id="render-behavior-edge-cases">Render Behavior Edge Cases<a href="#render-behavior-edge-cases" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<h4 id="commit-phase-lifecycles">Commit Phase Lifecycles<a href="#commit-phase-lifecycles" arialabel="Anchor"> üîóÔ∏é</a> </h4>

<p>There&#39;s some additional edge cases inside of the commit-phase lifecycle methods: <code>componentDidMount</code>, <code>componentDidUpdate</code>, and <code>useLayoutEffect</code>. These largely exist to allow you to perform additional logic after a render, but before the browser has had a chance to paint. In particular, a common use case is:</p>

<ul>
<li>Render a component the first time with some partial but incomplete data</li>
<li>In a commit-phase lifecycle, use refs to measure the real size of the actual DOM nodes in the page</li>
<li>Set some state in the component based on those measurements</li>
<li>Immediately re-render with the updated data</li>
</ul>

<p>In this use case, we don&#39;t want the initial &#34;partial&#34; rendered UI to be visible to the user at all - we only want the &#34;final&#34; UI to show up. Browsers will recalculate the DOM structure as it&#39;s being modified, but they won&#39;t actually paint anything to the screen while a JS script is still executing and blocking the event loop. So, you can perform multiple DOM mutations, like <code>div.innerHTML = &#34;a&#34;; div.innerHTML = b&#34;;</code>, and the <code>&#34;a&#34;</code> will never appear.</p>

<p>Because of this, <strong>React will always run renders in commit-phase lifecycles synchronously</strong>. That way, if you do try to perform an update like that &#34;partial-&gt;final&#34; switch, only the &#34;final&#34; content will ever be visible on screen.</p>

<p>As far as I know, state updates in <code>useEffect</code> callbacks are queued up, and flushed at the end of the &#34;Passive Effects&#34; phase once all the <code>useEffect</code> callbacks have completed.</p>

<h4 id="reconciler-batching-methods">Reconciler Batching Methods<a href="#reconciler-batching-methods" arialabel="Anchor"> üîóÔ∏é</a> </h4>

<p>React reconcilers (ReactDOM, React Native) have methods to alter render batching.</p>

<p>For React 17 and earlier, you can wrap multiple updates that are outside of event handlers in <code>unstable_batchedUpdates()</code> to batch them together. (Note that despite the <code>unstable_</code> prefix, it&#39;s heavily used and depended on by code at Facebook and public libraries - <a href="https://blog.isquaredsoftware.com/2018/11/react-redux-history-implementation/#use-of-react-s-batched-updates-api">React-Redux v7 used <code>unstable_batchedUpdates</code> internally</a>)</p>

<p>Since React 18 automatically batches by default, <a href="https://react.dev/reference/react-dom/flushSync">React 18 has a <code>flushSync()</code> API</a> that you can use to force immediate renders and opt out of automatic batching.</p>

<p>Note that since these are reconciler-specific APIs, alternate reconcilers like <code>react-three-fiber</code> and <code>ink</code> may not have them exposed. Check the API declarations or implementation details to see what&#39;s available.</p>

<h4 id="strictmode"><code>&lt;StrictMode&gt;</code><a href="#strictmode" arialabel="Anchor"> üîóÔ∏é</a> </h4>

<p>React will <strong>double-render components inside of a <code>&lt;StrictMode&gt;</code> tag in development</strong>. That means the number of times your rendering logic runs is <em>not</em> the same as the number of committed render passes, and you <em>cannot</em> rely on <code>console.log()</code> statements while rendering to count the number of renders that have occurred. Instead, either use the React DevTools Profiler to capture a trace and count the number of committed renders overall, or add logging inside of a <code>useEffect</code> hook or <code>componentDidMount/Update</code> lifecycle. That way the logs will only get printed when React has actually completed a render pass and committed it.</p>

<h4 id="setting-state-while-rendering">Setting State While Rendering<a href="#setting-state-while-rendering" arialabel="Anchor"> üîóÔ∏é</a> </h4>

<p>In normal situations, you should <em>never</em> queue a state update while in the actual rendering logic. In other words, it&#39;s fine to create a click callback that will call <code>setSomeState()</code> when the click happens, but you should <em>not</em> call <code>setSomeState()</code> as part of the actual rendering behavior.</p>

<p>However, there is one exception to this. <strong>Function components <em>may</em> call <code>setSomeState()</code> directly while rendering, as long as it&#39;s done conditionally</strong> and isn&#39;t going to execute <em>every</em> time this component renders. This acts as <a href="https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops">the function component equivalent of <code>getDerivedStateFromProps</code> in class components</a>. If a function component queues a state update while rendering, <a href="https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L430-L469">React will immediately apply the state update and synchronously re-render that one component</a> before moving onwards. If the component infinitely keeps queueing state updates and forcing React to re-render it, React will break the loop after a set number of retries and throw an error (currently 50 attempts). This technique can be used to immediately force an update to a state value based on a prop change, without requiring a re-render + a call to <code>setSomeState()</code> inside of a <code>useEffect</code>.</p>

<h2 id="improving-rendering-performance">Improving Rendering Performance<a href="#improving-rendering-performance" arialabel="Anchor"> üîóÔ∏é</a> </h2>

<p>Although renders are the normal expected part of how React works, it&#39;s also true that that render work can be &#34;wasted&#34; effort at times. If a component&#39;s render output didn&#39;t change, and that part of the DOM didn&#39;t need to be updated, then the work of rendering that component was really kind of a waste of time.</p>

<p><strong>React component render output <em>should</em> always be entirely based on current props and current component state</strong>. Therefore, if we <em>know</em> ahead of time that a component&#39;s props and state haven&#39;t changed, we <em>should</em> also know that the render output would be the same, that no changes are necessary for this component, and that we can safely skip the work of rendering it.</p>

<p>When trying to improve software performance in general, there are two basic approaches: 1) do the same work faster, and 2) do less work. Optimizing React rendering is primarily about doing less work by skipping rendering components when appropriate.</p>

<h3 id="component-render-optimization-techniques">Component Render Optimization Techniques<a href="#component-render-optimization-techniques" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>React offers three primary APIs that allow us to potentially skip rendering a component:</p>

<p><strong>The primary method is <a href="https://react.dev/reference/react/memo"><code>React.memo()</code></a></strong>, a built-in <a href="https://legacy.reactjs.org/docs/higher-order-components.html">&#34;higher order component&#34;</a> type. It accepts your own component type as an argument, and returns a new wrapper component. The wrapper component&#39;s default behavior is to check to see if any of the props have changed, and if not, prevent a re-render. Both function components and class components can be wrapped using <code>React.memo()</code>. (A custom comparison callback may be passed in, but it really can only compare the old and new props anyway, so the main use case for a custom compare callback would be only comparing specific props fields instead of all of them.)</p>

<p>The other options are:</p>

<ul>
<li><a href="https://react.dev/reference/react/Component#shouldcomponentupdate"><code>React.Component.shouldComponentUpdate</code></a>: an optional class component lifecycle method that will be called early in the render process. If it returns <code>false</code>, React will skip rendering the component. It may contain any logic you want to use to calculate that boolean result, but the most common approach is to check if the component&#39;s props and state have changed since last time, and return <code>false</code> if they&#39;re unchanged.</li>
<li><a href="https://react.dev/reference/react/PureComponent"><code>React.PureComponent</code></a>: since that comparison of props and state is the most common way to implement <code>shouldComponentUpdate</code>, the <code>PureComponent</code> base class implements that behavior by default, and may be used instead of <code>Component</code> + <code>shouldComponentUpdate</code>.</li>
</ul>

<p>All of these approaches use a comparison technique called <strong>&#34;shallow equality&#34;</strong>. This means checking every individual field in two different objects, and seeing if any of the <em>contents</em> of the objects are a different value. In other words, <code>obj1.a === obj2.a &amp;&amp; obj1.b === obj2.b &amp;&amp; ........</code>. This is typically a fast process, because <code>===</code> comparisons are very simple for the JS engine to do. So, these three approaches do the equivalent of <code>const shouldRender = !shallowEqual(newProps, prevProps)</code>.</p>

<p>There&#39;s also a lesser-known technique as well: <strong>if a React component returns the exact same element reference in its render output as it did the last time, React will skip re-rendering that particular child.</strong> There&#39;s at least a couple ways to implement this technique:</p>

<ul>
<li>If you include <code>props.children</code> in your output, that element is the same if this component does a state update</li>
<li>If you wrap some elements with <code>useMemo()</code>, those will stay the same until the dependencies change</li>
</ul>

<p>Examples:</p>

<pre><code>// The `props.children` content won&#39;t re-render if we update state
function SomeProvider({ children }) {
  const [counter, setCounter] = useState(0);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;Count: {counter}&lt;/button&gt;
      &lt;OtherChildComponent /&gt;
      {children}
    &lt;/div&gt;
  );
}

function OptimizedParent() {
  const [counter1, setCounter1] = useState(0);
  const [counter2, setCounter2] = useState(0);

  const memoizedElement = useMemo(() =&gt; {
    // This element stays the same reference if counter 2 is updated,
    // so it won&#39;t re-render unless counter 1 changes
    return &lt;ExpensiveChildComponent /&gt;;
  }, [counter1]);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setCounter1(counter1 + 1)}&gt;
        Counter 1: {counter1}
      &lt;/button&gt;
      &lt;button onClick={() =&gt; setCounter1(counter2 + 1)}&gt;
        Counter 2: {counter2}
      &lt;/button&gt;
      {memoizedElement}
    &lt;/div&gt;
  );
}
</code></pre>

<p>Conceptually, we could say that the difference between these two approaches is:</p>

<ul>
<li><code>React.memo()</code>: controlled by the child component</li>
<li>Same-element references: controlled by the parent component</li>
</ul>

<p>For all of these techniques, <strong>skipping rendering a component means React will also skip rendering that entire subtree</strong>, because it&#39;s effectively putting a stop sign up to halt the default &#34;render children recursively&#34; behavior.</p>

<h3 id="how-new-props-references-affect-render-optimizations">How New Props References Affect Render Optimizations<a href="#how-new-props-references-affect-render-optimizations" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>We&#39;ve already seen that <strong>by default, React re-renders all nested components even if their props haven&#39;t changed</strong>. That also means that passing new references as props to a child component doesn&#39;t matter, because it will render whether or not you pass the same props. So, something like this is totally fine:</p>

<pre><code>function ParentComponent() {
  const onClick = () =&gt; {
    console.log(&#39;Button clicked&#39;);
  };

  const data = { a: 1, b: 2 };

  return &lt;NormalChildComponent onClick={onClick} data={data} /&gt;;
}
</code></pre>

<p>Every time <code>ParentComponent</code> renders, it will create a new <code>onClick</code> function reference and a new <code>data</code> object reference, then pass them as props to <code>NormalChildComponent</code>. (Note that it doesn&#39;t matter whether we&#39;re defining <code>onClick</code> using the <code>function</code> keyword or as an arrow function - it&#39;s a new function reference either way.)</p>

<p>That also means <strong>there&#39;s no point in trying to optimize renders for &#34;host components&#34; like a <code>&lt;div&gt;</code> or a <code>&lt;button&gt;</code> by wrapping them up in a <code>React.memo()</code></strong>. There&#39;s no child component underneath those basic components, so the rendering process would stop there anyway.</p>

<p>However, <strong><em>if</em> the child component is trying to optimize renders by checking to see whether props have changed, <em>then</em> passing new references as props will cause the child to render</strong>. If the new prop references are actually new data, this is good. However, what if the parent component is just passing down a callback function?</p>

<pre><code>const MemoizedChildComponent = React.memo(ChildComponent);

function ParentComponent() {
  const onClick = () =&gt; {
    console.log(&#39;Button clicked&#39;);
  };

  const data = { a: 1, b: 2 };

  return &lt;MemoizedChildComponent onClick={onClick} data={data} /&gt;;
}
</code></pre>

<p>Now, every time <code>ParentComponent</code> renders, these new references are going to cause <code>MemoizedChildComponent</code> to see that its props values have changed to new references, and it will go ahead and re-render... even though the <code>onClick</code> function and the <code>data</code> object <em>should</em> be basically the same thing every time!</p>

<p>This means that:</p>

<ul>
<li><code>MemoizedChildComponent</code> will always re-render even though we wanted to skip rendering most of the time</li>
<li>The work that it&#39;s doing to compare its old and new props is wasted effort</li>
</ul>

<p>Similarly, note that rendering <code>&lt;MemoizedChild&gt;&lt;OtherComponent /&gt;&lt;/MemoizedChild&gt;</code> will <em>also</em> force the child to always render, because <code>props.children</code> is always a new reference.</p>

<h3 id="optimizing-props-references">Optimizing Props References<a href="#optimizing-props-references" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>Class components don&#39;t have to worry about accidentally creating new callback function references as much, because they can have instance methods that are always the same reference. However, they may need to generate unique callbacks for separate child list items, or capture a value in an anonymous function and pass that to a child. Those will result in new references, and so will creating new objects as child props while rendering. React doesn&#39;t have anything built-in to help optimize those cases.</p>

<p>For function components, React does provide two hooks to help you reuse the same references: <code>useMemo</code> for any kind of general data like creating objects or doing complex calculations, and <code>useCallback</code> specifically for creating callback functions.</p>

<h3 id="memoize-everything">Memoize Everything?<a href="#memoize-everything" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>As mentioned above, you don&#39;t have throw <code>useMemo</code> and <code>useCallback</code> at every single function or object you pass down as a prop - only if it&#39;s going to make a difference in behavior for the child. (That said, the dependency array comparisons for <code>useEffect</code> <em>do</em> add another use case where the child might want to receive consistent props references, which does make things more complicated.)</p>

<p>The other question that comes up all the time is &#34;Why doesn&#39;t React wrap <em>everything</em> in <code>React.memo()</code> by default?&#34;.</p>

<p>Dan Abramov has <a href="https://twitter.com/dan_abramov/status/1095661142477811717">repeatedly pointed out that memoization <em>does</em> still incur the cost of comparing props</a>, and that there are many cases where the memoization check can never prevent re-renders because the component always receives new props. As an example, <a href="https://twitter.com/dan_abramov/status/1083897065263034368">see this Twitter thread from Dan</a>:</p>

<blockquote>
<p>Why doesn‚Äôt React put memo() around every component by default? Isn‚Äôt it faster? Should we make a benchmark to check?</p>

<p>Ask yourself:</p>

<p>Why don‚Äôt you put Lodash memoize() around every function? Wouldn‚Äôt that make all functions faster? Do we need a benchmark for this? Why not?</p>
</blockquote>

<p>Also, while I don&#39;t have a specific link on it, it&#39;s possible that trying to apply this to all components by default might result in bugs due to cases where people are mutating data rather than updating it immutably.</p>

<p>I&#39;ve had some public discussion with Dan about this on Twitter. I personally think it&#39;s likely that using <code>React.memo()</code> on a widespread basis would likely be a net gain in overall app rendering perf. As I said in <a href="https://twitter.com/acemarke/status/1141755698948165632">an extended Twitter thread last year</a>:</p>

<blockquote>
<p>The React community as a whole seems to be over obsessed with &#34;perf&#34;, yet much of the discussion revolves around outdated &#34;tribal wisdom&#34; passed down via Medium posts and Twitter comments rather than based on concrete usage.</p>

<p>There&#39;s definitely collective misunderstanding about the idea of a &#34;render&#34; and the perf impact. Yes, React is totally based around rendering - gotta render to do anything at all. No, most renders aren&#39;t overly expensive.</p>

<p>&#34;Wasted&#34; rerenders certainly aren&#39;t the end of the world. Neither is rerendering the whole app from the root.
That said, it&#39;s also true that a &#34;wasted&#34; rerender with no DOM update is CPU cycles that didn&#39;t need to be burned. Is that a problem for most apps? Probably not. Is it something that can be improved? Probably.</p>

<p>Are there apps where default &#34;rerender it all&#34; approaches aren&#39;t sufficient? Of course, that&#39;s why sCU, PureComponent, and memo() exist.</p>

<p>Should users wrap <em>everything</em> in memo() by default? Probably not, if only because you should <em>think</em> about your app&#39;s perf needs. Will it actually hurt if you do? No, and realistically I expect it does have a net benefit (despite Dan&#39;s points about wasted comparisons)</p>

<p>Are benchmarks flawed, and results highly variable based on scenarios and apps? Of course. That said, it would be REALLY REALLY HELPFUL if folks could start pointing at hard numbers for these discussions instead of playing the telephone game of &#34;I saw a comment once...&#34;</p>

<p>I&#39;d love to see a bunch of benchmark suites from the React team and the larger community to measure a bunch of scenarios so we could stop arguing about most of this stuff once and for all. Function creation, render cost, optimization... CONCRETE EVIDENCE, PLEASE!</p>
</blockquote>

<p>But, <a href="https://twitter.com/acemarke/status/1229083161646305280">no one&#39;s put together any good benchmarks that would demonstrate whether or not this is true</a>:</p>

<blockquote>
<p>Dan&#39;s standard answer is that app structure and update patterns vary drastically, so it&#39;s hard to make a representative benchmark.</p>

<p>I still think <em>some</em> actual numbers would be useful to aid the discussion</p>
</blockquote>

<p>There&#39;s also an extended issue discussion on <a href="https://github.com/facebook/react/issues/14463">&#34;When should you NOT use React.memo?</a> in the React issues.</p>

<p>Note that <strong><a href="https://react.dev/reference/react/memo#should-you-add-memo-everywhere">the new React docs specifically address the &#34;memo everything?&#34; question</a></strong>:</p>

<blockquote>
<p>Optimizing with <code>memo</code> is only valuable when your component re-renders often with the same exact props, and its re-rendering logic is expensive. If there is no perceptible lag when your component re-renders, <code>memo</code> is unnecessary. Keep in mind that <code>memo</code> is completely useless if the props passed to your component are always different, such as if you pass an object or a plain function defined during rendering. This is why you will often need <code>useMemo</code> and <code>useCallback</code> together with <code>memo</code>.</p>

<p>There is no benefit to wrapping a component in <code>memo</code> in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that‚Äôs ‚Äúalways new‚Äù is enough to break memoization for an entire component.</p>
</blockquote>

<p>See the details section under that link for further suggestions on avoiding unnecessary memoization and improving performance.</p>

<h3 id="immutability-and-rerendering">Immutability and Rerendering<a href="#immutability-and-rerendering" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p><strong>State updates in React should always be done immutably</strong>. There are two main reasons why:</p>

<ul>
<li>depending on what you mutate and where, it can result in components not rendering when you expected they would render</li>
<li>it causes confusion about when and why data actually got updated</li>
</ul>

<p>Let&#39;s look at a couple specific examples.</p>

<p>As we&#39;ve seen, <code>React.memo / PureComponent / shouldComponentUpdate</code> all rely on shallow equality checks of the current props vs the previous props. So, the expectation is that we can know if a prop is a new value, by doing <code>props.someValue !== prevProps.someValue</code>.</p>

<p>If you mutate, then <code>someValue</code> is the same reference, and those components will assume nothing has changed.</p>

<p>Note that this is <em>specifically</em> when we&#39;re trying to optimize performance by avoiding unnecessary re-renders. A render is &#34;unnecessary&#34; or &#34;wasted&#34; if the props haven&#39;t changed. If you mutate, the component may wrongly think nothing has changed, and then you wonder why the component didn&#39;t re-render.</p>

<p>The other issue is the <code>useState</code> and <code>useReducer</code> hooks. Every time I call <code>setCounter()</code> or <code>dispatch()</code>, React will queue up a re-render. However, React requires that any hook state updates must pass in / return a new reference as the new state value, whether it be a new object/array reference, or a new primitive (string/number/etc).</p>

<p>React applies all state updates during the render phase. When React tries to apply a state update from a hook, it checks to see if the new value is the same reference. React will <em>always</em> finish rendering the component that queued the update. However, <em>if</em> the value is the same reference as before, <em>and</em> there are no other reasons to continue rendering (such as the parent having rendered), React will then throw away the render results for the component and bail out of the render pass completely. So, if I mutate an array like this:</p>

<pre><code>const [todos, setTodos] = useState(someTodosArray);

const onClick = () =&gt; {
  todos[3].completed = true;
  setTodos(todos);
};
</code></pre>

<p>then the component will fail to re-render.</p>

<p>(Note that React <em>does</em> actually have <a href="https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L2234-L2259">a &#34;fast path&#34; bailout mechanism that will attempt to check the new value <em>before</em> queuing the state update in some cases</a>. Since this also relies on a direct reference check, it&#39;s another example of needing to do immutable updates.)</p>

<p>Technically, only the outermost reference has to be immutably updated. If we change that example to:</p>

<pre><code>const onClick = () =&gt; {
  const newTodos = todos.slice();
  newTodos[3].completed = true;
  setTodos(newTodos);
};
</code></pre>

<p>then we have created a new array reference and passed it in, and the component <em>will</em> re-render.</p>

<p>Note that there is a distinct difference in behavior between the class component <code>this.setState()</code> and the function component <code>useState</code> and <code>useReducer</code> hooks with regards to mutations and re-rendering. <code>this.setState()</code> doesn&#39;t care if you mutate at all - it <em>always</em> completes the re-render. So, this will re-render:</p>

<pre><code>const { todos } = this.state;
todos[3].completed = true;
this.setState({ todos });
</code></pre>

<p>And in fact, so will passing in an empty object like <code>this.setState({})</code>.</p>

<p>Beyond all the actual rendering behavior, mutation introduces confusion to the standard React one-way data flow. Mutation can lead other code to see different values when the expectation was they haven&#39;t changed at all. This makes it harder to know when and why a given piece of state was actually supposed to update, or where a change came from.</p>

<p>Bottom line: <strong>React, and the rest of the React ecosystem, assume immutable updates. Any time you mutate, you run the risk of bugs. Don&#39;t do it.</strong></p>

<h3 id="measuring-react-component-rendering-performance">Measuring React Component Rendering Performance<a href="#measuring-react-component-rendering-performance" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>Use the <a href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html">React DevTools Profiler</a> to see what components are rendering in each commit. Find components that are rendering unexpectedly, use the DevTools to figure out <em>why</em> they rendered, and fix things (perhaps by wrapping them in <code>React.memo()</code>, or having the parent component memoize the props it&#39;s passing down.)</p>

<p>Also, remember that React runs way slower in dev builds. You can profile your app in development mode to see <em>which</em> components are rendering and why, and do some comparisons of <em>relative</em> time needed to render components in comparison to each other (&#34;Component B took 3 times as long to render in this commit than component A&#34; did). But, <strong>never measure absolute render times using a React development build - only measure absolute times using production builds!</strong> (or else Dan Abramov will have to come yell at you for using numbers that aren&#39;t accurate). Note that you&#39;ll need to use <a href="https://kentcdodds.com/blog/profile-a-react-app-for-performance">a special &#34;profiling&#34; build of React</a> if you want to actually use the profiler to capture timing data from a prod-like build.</p>

<h2 id="context-and-rendering-behavior">Context and Rendering Behavior<a href="#context-and-rendering-behavior" arialabel="Anchor"> üîóÔ∏é</a> </h2>

<p><strong>React&#39;s Context API is a mechanism for making a single user-provided value available to a subtree of components</strong>, Any component inside of a given <code>&lt;MyContext.Provider&gt;</code> can read the value from that context instance, without having to explicitly pass that value as a prop through every intervening component.</p>

<p><strong>Context is not a &#34;state management&#34; tool</strong>. You have to manage the values that are passed into context yourself. This is typically done by keeping data in React component state, and constructing context values based on that data.</p>

<h3 id="context-basics">Context Basics<a href="#context-basics" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>A context provider receives a single <code>value</code> prop, like <code>&lt;MyContext.Provider value={42}&gt;</code>. Child components may consume the context by rendering the context consumer component and providing a render prop, like:</p>

<p><code>&lt;MyContext.Consumer&gt;{ (value) =&gt; &lt;div&gt;{value}&lt;/div&gt;}&lt;/MyContext.Consumer&gt;</code></p>

<p>or by calling the <code>useContext</code> hook in a function component:</p>

<p><code>const value = useContext(MyContext)</code></p>

<h3 id="updating-context-values">Updating Context Values<a href="#updating-context-values" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>React checks to see if a context provider has been given a new value when the surrounding component renders the provider. If the provider&#39;s value is a new reference, then React knows the value has changed, and that the components consuming that context need to be updated.</p>

<p>Note that <strong>passing a new object to a context provider <em>will</em> cause it to update</strong>:</p>

<pre><code>function GrandchildComponent() {
  const value = useContext(MyContext);
  return &lt;div&gt;{value.a}&lt;/div&gt;;
}

function ChildComponent() {
  return &lt;GrandchildComponent /&gt;;
}

function ParentComponent() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(&#39;text&#39;);

  const contextValue = { a, b };

  return (
    &lt;MyContext.Provider value={contextValue}&gt;
      &lt;ChildComponent /&gt;
    &lt;/MyContext.Provider&gt;
  );
}
</code></pre>

<p>In this example, every time <code>ParentComponent</code> renders, React will take note that <code>MyContext.Provider</code> has been given a new value, and look for components that consume <code>MyContext</code> as it continues looping downwards. <strong>When a context provider has a new value, <em>every</em> nested component that consumes that context will be forced to re-render</strong>.</p>

<p>Note that from React&#39;s perspective, each context provider only has a single value - doesn&#39;t matter whether that&#39;s an object, array, or a primitive, it&#39;s just one context value. Currently, <strong>there is no way for a component that consumes a context to skip updates caused by new context values, even if it only cares about <em>part</em> of a new value.</strong></p>

<p>If a component only needs <code>value.a</code>, and an update is made to cause a new <code>value.b</code> reference... the rules of immutable updates and context rendering require that <code>value</code> be a new reference also, and so the component reading <code>value.a</code> will also render too.</p>

<h3 id="state-updates-context-and-re-renders">State Updates, Context, and Re-Renders<a href="#state-updates-context-and-re-renders" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>It&#39;s time to put some of these pieces together. We know that:</p>

<ul>
<li>Calling <code>setState()</code> queues a render of that component</li>
<li>React recursively renders nested components by default</li>
<li>Context providers are given a value by the component that renders them</li>
<li>That value normally comes from that parent component&#39;s state</li>
</ul>

<p>This means that <strong>by default, any state update to a parent component that renders a context provider will cause all of its descendants to re-render anyway, regardless of whether they read the context value or not!</strong>.</p>

<p>If we look back at the <code>Parent/Child/Grandchild</code> example just above, we can see that <strong>the <code>GrandchildComponent</code> <em>will</em> re-render, but not because of a context update - it will re-render because <code>ChildComponent</code> rendered!</strong>. In this example, there&#39;s nothing trying to optimize away &#34;unnecessary&#34; renders, so React renders <code>ChildComponent</code> and <code>GrandchildComponent</code> by default any time <code>ParentComponent</code> renders. If the parent puts a new context value into <code>MyContext.Provider</code>, the <code>GrandchildComponent</code> will see the new value when it renders and use it, but the context update didn&#39;t <em>cause</em> <code>GrandchildComponent</code> to render - it was going to happen anyway.</p>

<h3 id="context-updates-and-render-optimizations">Context Updates and Render Optimizations<a href="#context-updates-and-render-optimizations" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>Let&#39;s modify that example so that it does actually try to optimize things, but we&#39;ll add one other twist by putting a <code>GreatGrandchildComponent</code> at the bottom:</p>

<pre><code>function GreatGrandchildComponent() {
  return &lt;div&gt;Hi&lt;/div&gt;
}

function GrandchildComponent() {
    const value = useContext(MyContext);
    return (
      &lt;div&gt;
        {value.a}
        &lt;GreatGrandchildComponent /&gt;
      &lt;/div&gt;
}

function ChildComponent() {
    return &lt;GrandchildComponent /&gt;
}

const MemoizedChildComponent = React.memo(ChildComponent);

function ParentComponent() {
    const [a, setA] = useState(0);
    const [b, setB] = useState(&#34;text&#34;);

    const contextValue = {a, b};

    return (
      &lt;MyContext.Provider value={contextValue}&gt;
        &lt;MemoizedChildComponent /&gt;
      &lt;/MyContext.Provider&gt;
    )
}
</code></pre>

<p>Now, if we call <code>setA(42)</code>:</p>

<ul>
<li><code>ParentComponent</code> will render</li>
<li>A new <code>contextValue</code> reference is created</li>
<li>React sees that <code>MyContext.Provider</code> has a new context value, and thus any consumers of <code>MyContext</code> need to be updated</li>
<li>React will try to render <code>MemoizedChildComponent</code>, but see that it&#39;s wrapped in <code>React.memo()</code>. There are no props being passed at all, so the props have not actually changed. React will skip rendering <code>ChildComponent</code> entirely.</li>
<li>However, there was an update to <code>MyContext.Provider</code>, so there <em>may</em> be components further down that need to know about that.</li>
<li>React continues downwards and reaches <code>GrandchildComponent</code>. It sees that <code>MyContext</code> is read by <code>GrandchildComponent</code>, and thus it <em>should</em> re-render because there&#39;s a new context value. React goes ahead and re-renders <code>GrandchildComponent</code>, specifically because of the context change.</li>
<li>Because <code>GrandchildComponent</code> <em>did</em> render, React then keeps on going and also renders whatever&#39;s inside of it. So, React will also re-render <code>GreatGrandchildComponent</code>.</li>
</ul>

<p>In other words, <a href="https://twitter.com/sophiebits/status/1228942768543686656">as Sophie Alpert said</a>:</p>

<blockquote>
<p><strong>That React Component Right Under Your Context Provider Should Probably Use <code>React.memo</code></strong></p>
</blockquote>

<p>That way, state updates in the parent component will <em>not</em> force every component to re-render, just the sections where the context is read. (You could also get basically the same result by having <code>ParentComponent</code> render <code>&lt;MyContext.Provider&gt;{props.children}&lt;/MyContext.Provider&gt;</code>, which leverages the &#34;same element reference&#34; technique to avoid child components re-rendering, and then rendering <code>&lt;ParentComponent&gt;&lt;ChildComponent /&gt;&lt;/ParentComponent&gt;</code> from one level up.)</p>

<p>Note, however, that <strong>once <code>GrandchildComponent</code> rendered based on the next context value, React went right back to its default behavior of recursively re-rendering everything</strong>. So, <code>GreatGrandchildComponent</code> was rendered, and anything else under there would have rendered too.</p>

<h3 id="context-and-renderer-boundaries">Context and Renderer Boundaries<a href="#context-and-renderer-boundaries" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>Normally, a React app is built entirely with a single renderer like ReactDOM or React Native. But, the core rendering and reconciling logic is published as a package called <code>react-reconciler</code>, and you can use that to build your own version of React that targets other environments. Good examples of this are <a href="https://github.com/pmndrs/react-three-fiber"><code>react-three-fiber</code></a>, which uses React to drive Three.js models and WebGL rendering, and <a href="https://github.com/vadimdemedes/ink"><code>ink</code></a>, which draws terminal text UIs using React.</p>

<p>One long-standing limitation is that if you have multiple renderers in an app, such as showing React-Three-Fiber content inside of ReactDOM, context providers won&#39;t pass through the renderer boundary. So, if the component tree looks like this:</p>

<pre><code>function App() {
  return (
    &lt;MyContext.Provider&gt;
      &lt;DomComponent&gt;
        &lt;ReactThreeFiberParent&gt;
          &lt;ReactThreeFiberChild /&gt;
        &lt;/ReactThreeFiberParent&gt;
      &lt;/DomComponent&gt;
    &lt;/MyContext.Provider&gt;
  );
}
</code></pre>

<p>where <code>ReactFiberParent</code> creates and shows content rendered with React-Three-Fiber, then <code>&lt;ReactThreeFiberChild&gt;</code> will not be able to see the value from <code>&lt;MyContext.Provider&gt;</code>.</p>

<p>This is a known limitation of React and there is currently no official way to solve this.</p>

<p>That said, the Poimandres org behind React-Three-Fiber has had some internal hacks that made context bridging feasible, and they recently released a lib called <a href="https://github.com/pmndrs/its-fine">https://github.com/pmndrs/its-fine</a> that includes <a href="https://github.com/pmndrs/its-fine#useContextBridge">a <code>useContextBridge</code> hook</a> that is a valid workaround.</p>

<h2 id="react-redux-and-rendering-behavior">React-Redux and Rendering Behavior<a href="#react-redux-and-rendering-behavior" arialabel="Anchor"> üîóÔ∏é</a> </h2>

<p>The various forms of &#34;CONTEXT VS REDUX?!?!??!&#34; seem to be the single most-asked question I see in the React community right now. (<a href="https://blog.isquaredsoftware.com/2021/01/context-redux-differences/">That question is a false dichotomy to begin with, as <strong>Redux and Context are different tools that do different things</strong></a>.)</p>

<p>That said, one of the recurring things that people point out when this comes up is that &#34;React-Redux only re-renders the components that actually need to render, so that makes it better than context&#34;.</p>

<p>That&#39;s <em>somewhat</em> true, but the answer is a lot more nuanced than that.</p>

<h3 id="react-redux-subscriptions">React-Redux Subscriptions<a href="#react-redux-subscriptions" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>I&#39;ve seen a lot of folks repeat the phrase &#34;React-Redux uses context inside.&#34; Also technically true, but <a href="https://blog.isquaredsoftware.com/2020/01/blogged-answers-react-redux-and-context-behavior/">React-Redux uses context to pass the <em>Redux store instance</em>, not the <em>current state value</em></a>. That means that we always pass the same context value into our <code>&lt;ReactReduxContext.Provider&gt;</code> over time.</p>

<p>Remember that a Redux store runs all its subscriber notification callbacks whenever an action is dispatched. <a href="https://blog.isquaredsoftware.com/2018/11/react-redux-history-implementation/">UI layers that need to use Redux always subscribe to the Redux store, read the latest state in their subscriber callbacks, diff the values, and force a re-render if the relevant data has changed</a>. The subscription callback process happens <em>outside</em> of React entirely, and React only gets involved if React-Redux <em>knows</em> that the data needed by a specific React component has changed (based on the return values of <code>mapState</code> or <code>useSelector</code>).</p>

<p>This results in a very different set of performance characteristics than context. Yes, it&#39;s likely that fewer components will be rendering all the time, <em>but</em> React-Redux will always have to run the <code>mapState/useSelector</code> functions for the entire component tree every time the store state is updated. <strong>Most of the time, the cost of running those selectors is less than the cost of React doing another render pass, so it&#39;s usually a net win</strong>, but it <em>is</em> work that has to be done. <strong>However, if those selectors are doing expensive transformations or accidentally returning new values when they shouldn&#39;t, that can slow things down</strong>.</p>

<h3 id="differences-between-connect-and-useselector">Differences between <code>connect</code> and <code>useSelector</code><a href="#differences-between-connect-and-useselector" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p><code>connect</code> is a higher-order component. You pass in your own component, and <code>connect</code> returns a wrapper component that does all the work of subscribing to the store, running your <code>mapState</code> and <code>mapDispatch</code>, and passing the combined props down to your own component.</p>

<p>The <code>connect</code> wrapper components have always acted equivalent to <code>PureComponent/React.memo()</code>, but with a slightly different emphasis: <code>connect</code> will only make your own component render <em>if</em> the combined props it&#39;s passing down to your component have changed. Typically, the final combined props are a combination of <code>{...ownProps, ...stateProps, ...dispatchProps}</code>, so any new prop references from the parent will indeed cause your component to render, same as <code>PureComponent</code> or <code>React.memo()</code>. Besides parent props, <a href="https://react-redux.js.org/using-react-redux/connect-mapstate#mapstatetoprops-and-performance">any new references returned from <code>mapState</code> will also cause your component to render. </a>. (Since you <em>could</em> customize how <code>ownProps/stateProps/dispatchProps</code> are merged, it&#39;s also possible to alter that behavior.)</p>

<p><code>useSelector</code>, on the other hand, is a hook that is called inside of your own function components. Because of that, <strong><code>useSelector</code> has no way of stopping your component from rendering when the parent component renders!</strong>.</p>

<p>This is <a href="https://react-redux.js.org/api/hooks#performance">a key performance difference between <code>connect</code> and <code>useSelector</code></a>. With <code>connect</code>, every connected component acts like <code>PureComponent</code>, and thus acts as a firewall to prevent React&#39;s default render behavior from cascading down the entire component tree. Since a typical React-Redux app has <em>many</em> connected components, this means that most re-render cascades are limited to a fairly small section of the component tree. React-Redux will force a connected component to render based on data changes, the next 2-3 components below it might render as well, then React runs into another connected component that didn&#39;t need to update and that stops the rendering cascade.</p>

<p>In addition, having more connected components means that each component is probably reading smaller pieces of data from the store, and thus is less likely to have to re-render after any given action.</p>

<p>If you&#39;re exclusively using function components and <code>useSelector</code>, then <strong>it&#39;s likely that larger parts of your component tree will re-render based on Redux store updates than they would with <code>connect</code></strong>, since there aren&#39;t other connected components to stop those render cascades from continuing down the tree.</p>

<p>If that becomes a performance concern, then the answer is to wrap components in <code>React.memo()</code> yourself as needed, to prevent unnecessary re-renders caused by parent components.</p>

<h2 id="future-react-improvements">Future React Improvements<a href="#future-react-improvements" arialabel="Anchor"> üîóÔ∏é</a> </h2>

<h3 id="react-forget-memoizing-compiler">&#34;React Forget&#34; Memoizing Compiler<a href="#react-forget-memoizing-compiler" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>Ever since React hooks first came out and we started dealing with dependency arrays for hooks like <code>useEffect</code> and <code>useMemo</code>, the React team had said they intended the hooks deps arrays to be something that &#34;a sufficiently advanced compiler could generated automatically&#34;. In other words, use a variable named <code>counter</code> inside of a hook, and the compiler would automatically insert the <code>[counter]</code> deps array for you at build time.</p>

<p>Despite popping up in several discussions, the &#34;sufficiently advanced compiler&#34; never materialized. The community tried <a href="https://github.com/facebook/react/issues/14406">creating their own auto-memoization approaches like a Babel macro</a>, but no official compiler appeared...</p>

<p>until ReactConf 2021, when <strong>the React team gave a talk entitled <a href="https://youtu.be/lGEMwh32soc">&#34;React Without Memo&#34;</a></strong>. In that talk they gave a demo of an experimental compiler code-named <strong>&#34;React Forget&#34;</strong>. It&#39;s designed to rewrite the body of function components in order to automatically add memoization capabilities.</p>

<p>What&#39;s really exciting about React Forget is that not only does it try to memoize hook dependency arrays, <strong>it <em>also</em> memoizes JSX element return values</strong>. And since we know from earlier that React has a &#34;same-element reference&#34; optimization that can prevent re-rendering children, this means that <strong>React Forget <em>could</em>, potentially, effectively eliminate unnecessary renders throughout a React component tree!</strong>.</p>

<p>As of October 2022, the React Forget compiler has not yet been released, but the bits of news trickling out of the React team are encouraging. Supposedly 3-4 engineers are working on building it full-time, with a goal of having Facebook.com fully working before it&#39;s released publicly for the community to try out. There&#39;s also been other hints that the work is going well - the <code>useEvent</code> RFC was closed on the grounds that it might not be entirely necessary if React Forget works out, and other discussions have generally suggested &#34;what if the too many renders problem just goes away in the future thanks to auto-memoization?&#34;.</p>

<p>So, no guarantees at this point, but there&#39;s reason to be optimistic about the chances of React Forget panning out.</p>

<h3 id="context-selectors">Context Selectors<a href="#context-selectors" arialabel="Anchor"> üîóÔ∏é</a> </h3>

<p>We said earlier that the biggest weakness of the Context API is that a component cannot selectively subscribe to <em>parts</em> of a context value, so <em>all</em> components reading that context will re-render when the value is updated.</p>

<p>In July 2019, a community member <a href="https://github.com/reactjs/rfcs/pull/119">wrote an RFC proposing a &#34;context selectors&#34; API</a>, which would allow components to selectively subscribe to just part of a context. That RFC sat around for a while, and finally showed signs of life. Andrew Clark then <a href="https://github.com/facebook/react/pull/20646">implemented a proof of concept approach for context selectors in React</a> in January 2021, with the new ability hidden behind an internal feature flag for experimentation.</p>

<p>Sadly, there has been no further movement on the context selectors feature since then. From the discussion and PR, the proof of concept version will almost definitely require changes and iteration to the API design before it could be finalized. It&#39;s also possible that this may be another feature that is semi-obsolete if the React Forget compiler works out.</p>

<p>If this feature actually does ever get released, it will make the Context + <code>useReducer</code> combo a more viable option for larger amounts of React app state.</p>

<p>It&#39;s worth noting that there <em>is</em> <a href="https://github.com/dai-shi/use-context-selector">a <code>useContextSelector</code> library</a> from Daishi Kato (maintainer of Zustand and Jotai) that may be useful as a polyfill in the meantime.</p>

<h2 id="summary">Summary<a href="#summary" arialabel="Anchor"> üîóÔ∏é</a> </h2>

<ul>
<li>React always recursively renders components by default, so when a parent renders, its children will render</li>
<li>Rendering by itself is fine - it&#39;s how React knows what DOM changes are needed</li>
<li>But, rendering takes time, and &#34;wasted renders&#34; where the UI output didn&#39;t change can add up</li>
<li>It&#39;s okay to pass down new references like callback functions and objects most of the time</li>
<li>APIs like <code>React.memo()</code> can skip unnecessary renders if props haven&#39;t changed</li>
<li>But if you always pass new references down as props, <code>React.memo()</code> can never skip a render, so you may need to memoize those values</li>
<li>Context makes values accessible to any deeply nested component that is interested</li>
<li>Context providers compare their value by reference to know if it&#39;s changed</li>
<li>A new context values does force all nested consumers to re-render</li>
<li>But, many times the child would have re-rendered anyway due to the normal parent-&gt;child render cascade process</li>
<li>So you probably want to wrap the child of a context provider in <code>React.memo()</code>, or use <code>{props.children}</code>, so that the whole tree doesn&#39;t render all the time when you update the context value</li>
<li>When a child component is rendered based on a new context value, React keeps cascading renders down from there too</li>
<li>React-Redux uses subscriptions to the Redux store to check for updates, instead of passing store state values by context</li>
<li>Those subscriptions run on every Redux store update, so they need to be as fast as possible</li>
<li>React-Redux does a lot of work to ensure that only components whose data changed are forced to re-render</li>
<li><code>connect</code> acts like <code>React.memo()</code>, so having lots of connected components can minimize the total number of components that render at a time</li>
<li><code>useSelector</code> is a hook, so it can&#39;t stop renders caused by parent components. An app that only has <code>useSelector</code> everywhere should probably add <code>React.memo()</code> to some components to help avoid renders from cascading all the time.</li>
<li>The &#34;React Forget&#34; auto-memoizing compiler may drastically simplify all this if it does get released.</li>
</ul>

<h2 id="final-thoughts">Final Thoughts<a href="#final-thoughts" arialabel="Anchor"> üîóÔ∏é</a> </h2>

<p>Clearly, the whole situation is a lot more complex than just &#34;context makes everything render, Redux doesn&#39;t, use Redux&#34;. Don&#39;t get me wrong, I <em>want</em> people to use Redux, but I also want people to clearly understand the behaviors and tradeoffs involved in different tools so they can make informed decisions about what&#39;s best for their own use cases.</p>

<p>Since everyone always seems to ask <a href="https://blog.isquaredsoftware.com/2021/01/context-redux-differences/">&#34;When should I use Context, and when should I use (React-)Redux?&#34;</a>, let me go ahead and recap some standard rules of thumb:</p>

<ul>
<li>Use context if:

<ul>
<li>You just need to pass some simple values that don&#39;t change often</li>
<li>You have some state or functions that need to be accessed through part of the app, and you don&#39;t want to pass them as props all the way down</li>
<li>You want to stick with what&#39;s built in to React and not add additional libraries</li>
</ul></li>
<li>Use (React-)Redux if:

<ul>
<li>You have large amounts of application state that are needed in many places in the app</li>
<li>The app state is updated frequently over time</li>
<li>The logic to update that state may be complex</li>
<li>The app has a medium or large-sized codebase, and might be worked on by many people</li>
</ul></li>
</ul>

<p>Please note that <strong>these are not hard, exclusive rules - they are just some suggested guidelines for when these tools <em>might</em> make sense!</strong> As always, <em>please</em> take some time to decide for yourself what the best tool is for whatever situation you&#39;re dealing with.</p>

<p>Overall, hopefully this explanation helps folks understand the bigger picture of what&#39;s actually going on with React&#39;s rendering behavior in various situations.</p>

<h2 id="further-information">Further Information<a href="#further-information" arialabel="Anchor"> üîóÔ∏é</a> </h2>

<p>I recorded a conference talk version of this post for React Advanced in October 2022:</p>

<ul>
<li><a href="https://blog.isquaredsoftware.com/2023/08/presentations-react-rendering-behavior/"><strong>React Advanced 2022 - A (Brief) Guide to React Rendering Behavior</strong></a></li>
</ul>

<p>I&#39;ve seen several other good articles specifically covering &#34;how does React rendering work?&#34; recently, and I&#39;ll point to those as recommended:</p>

<ul>
<li><strong>Recommended React Rendering articles</strong>:

<ul>
<li><a href="https://www.joshwcomeau.com/react/why-react-re-renders/">Josh Comeau: Why React Re-Renders</a></li>
<li><a href="https://www.zhenghao.io/posts/react-rerender">Zhenghao He: When does React render your component?</a></li>
<li><a href="https://alexsidorenko.com/blog/react-render-cheat-sheet/">Alex Sidorenko: Visual Guide to React Rendering series</a></li>
<li><a href="https://www.developerway.com/posts/react-re-renders-guide">Nadia Makarevich: React re-renders guide</a></li>
</ul></li>
</ul>

<p>Beyond that, see these additional resources:</p>

<ul>
<li><strong>General</strong>

<ul>
<li><a href="https://daveceddia.com/javascript-references/">Dave Ceddia: A Visual Guide to References in JavaScript</a></li>
</ul></li>
<li><strong>React Render Behavior</strong>

<ul>
<li><a href="https://legacy.reactjs.org/docs/reconciliation.html">React docs: Reconciliation</a></li>
<li><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">React class lifecycle methods diagram</a></li>
<li><a href="https://github.com/donavon/hook-flow">React hooks lifecycle diagram</a></li>
<li><a href="https://github.com/facebook/react/issues/14110">React issues: bailing out of context and hooks</a></li>
<li><a href="https://github.com/facebook/react/issues/11527#issuecomment-360199710">React issues: why <code>setState</code> is async</a></li>
<li><a href="https://github.com/facebook/react/issues/14110#issuecomment-448074060">Seb Markbage: &#34;Context is good for low-frequency updates, not Flux-like state propagation&#34;</a></li>
<li><a href="https://cdb.reacttraining.com/react-inline-functions-and-performance-bdff784f5578">Ryan Florence: React, Inline Functions, and Performance</a></li>
<li><a href="https://frontarm.com/james-k-nelson/react-context-performance/">James K Nelson: React context and performance</a></li>
<li><a href="https://will-it-render.vercel.app/">Will It Render? A visualization for component rendering</a></li>
</ul></li>
<li><strong>Optimizing Render Performance</strong>

<ul>
<li><a href="https://legacy.reactjs.org/docs/optimizing-performance.html">React docs: Optimizing Performance</a></li>
<li><a href="https://kentcdodds.com/blog/fix-the-slow-render-before-you-fix-the-re-render">Kent C Dodds: Fix the slow render before you fix the re-render</a></li>
<li><a href="https://kentcdodds.com/blog/usememo-and-usecallback">Kent C Dodds: When to <code>useMemo</code> and <code>useCallback</code></a></li>
<li><a href="https://kentcdodds.com/blog/optimize-react-re-renders">Kent C Dodds: One simple trick to optimize React re-renders</a></li>
<li><a href="https://github.com/facebook/react/issues/14463">React issues: When should you NOT use React.memo?</a></li>
</ul></li>
<li><strong>Profiling React Components</strong>

<ul>
<li><a href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html">React docs: Introducing the React DevTools Profiler</a></li>
<li><a href="https://react-devtools-tutorial.now.sh/">React DevTools profiler interactive tutorial</a></li>
<li><a href="https://kentcdodds.com/blog/profile-a-react-app-for-performance">Kent C Dodds: Profile a React App for Performance</a></li>
<li><a href="https://www.netlify.com/blog/2018/08/29/using-the-react-devtools-profiler-to-diagnose-react-app-performance-issues/">Shawn Wang: Using the React DevTools Profiler to Diagnose React App Performance Issues</a></li>
<li><a href="https://scotch.io/tutorials/use-the-react-profiler-for-performance">Use the React Profiler for Performance</a></li>
</ul></li>
<li><strong>React-Redux Performance</strong>

<ul>
<li><a href="https://blog.isquaredsoftware.com/2017/01/practical-redux-part-6-connected-lists-forms-and-performance/">Practical Redux, Part 6: Connected Lists and Performance</a></li>
<li><a href="https://blog.isquaredsoftware.com/2018/11/react-redux-history-implementation/">Idiomatic Redux: The History and Implementation of React-Redux</a></li>
<li><a href="https://react-redux.js.org/using-react-redux/connect-mapstate#mapstatetoprops-and-performance">React-Redux docs: <code>mapState</code> Usage Guide - Performance</a></li>
<li><a href="http://somebody32.github.io/high-performance-redux/">High-Performance Redux</a></li>
<li><a href="https://github.com/markerikson/react-redux-links/blob/master/react-performance.md">React-Redux links: React/Redux Performance</a></li>
</ul></li>
</ul></section>

	
	
	<hr/>
	<section>
	<p><a href="" id="series"></a>This is a post in the <a href="https://blog.isquaredsoftware.com/series/blogged-answers"><b>Blogged Answers</b></a> series.
	Other posts in this series:</p>
	
	
	<ul>
	
		<li>Aug 08, 2023 - 
		
			<a href="https://blog.isquaredsoftware.com/2023/08/esm-modernization-lessons/"><b>Blogged Answers: My Experience Modernizing Packages to ESM</b> </a>
		
		</li>
	
		<li>Jul 06, 2022 - 
		
			<a href="https://blog.isquaredsoftware.com/2022/07/npm-package-market-share-estimates/"><b>Blogged Answers: How I Estimate NPM Package Market Share (and how Redux usage compares to other libraries)</b> </a>
		
		</li>
	
		<li>Jun 22, 2021 - 
		
			<a href="https://blog.isquaredsoftware.com/2021/06/the-evolution-of-redux-testing-approaches/"><b>Blogged Answers: The Evolution of Redux Testing Approaches</b> </a>
		
		</li>
	
		<li>Jan 18, 2021 - 
		
			<a href="https://blog.isquaredsoftware.com/2021/01/context-redux-differences/"><b>Blogged Answers: Why React Context is Not a &#34;State Management&#34; Tool (and Why It Doesn&#39;t Replace Redux)</b> </a>
		
		</li>
	
		<li>Jun 21, 2020 - 
		
			<a href="https://blog.isquaredsoftware.com/2020/06/blogged-answers-react-components-reusability-and-abstraction/"><b>Blogged Answers: React Components, Reusability, and Abstraction</b> </a>
		
		</li>
	
		<li>May 17, 2020 - 
		
			<b>Blogged Answers: A (Mostly) Complete Guide to React Rendering Behavior</b>
		
		</li>
	
		<li>May 12, 2020 - 
		
			<a href="https://blog.isquaredsoftware.com/2020/05/blogged-answers-why-i-write/"><b>Blogged Answers: Why I Write</b> </a>
		
		</li>
	
		<li>Feb 22, 2020 - 
		
			<a href="https://blog.isquaredsoftware.com/2020/02/blogged-answers-why-redux-toolkit-uses-thunks-for-async-logic/"><b>Blogged Answers: Why Redux Toolkit Uses Thunks for Async Logic</b> </a>
		
		</li>
	
		<li>Feb 22, 2020 - 
		
			<a href="https://blog.isquaredsoftware.com/2020/02/blogged-answers-coder-vs-tech-lead---balancing-roles/"><b>Blogged Answers: Coder vs Tech Lead - Balancing Roles</b> </a>
		
		</li>
	
		<li>Jan 19, 2020 - 
		
			<a href="https://blog.isquaredsoftware.com/2020/01/blogged-answers-react-redux-and-context-behavior/"><b>Blogged Answers: React, Redux, and Context Behavior</b> </a>
		
		</li>
	
		<li>Jan 01, 2020 - 
		
			<a href="https://blog.isquaredsoftware.com/2020/01/blogged-answers-years-in-review-2018-2019/"><b>Blogged Answers: Years in Review, 2018-2019</b> </a>
		
		</li>
	
		<li>Jan 01, 2020 - 
		
			<a href="https://blog.isquaredsoftware.com/2020/01/blogged-answers-reasons-to-use-thunks/"><b>Blogged Answers: Reasons to Use Thunks</b> </a>
		
		</li>
	
		<li>Jan 01, 2020 - 
		
			<a href="https://blog.isquaredsoftware.com/2020/01/blogged-answers-redux-batching-techniques/"><b>Blogged Answers: A Comparison of Redux Batching Techniques</b> </a>
		
		</li>
	
		<li>Nov 26, 2019 - 
		
			<a href="https://blog.isquaredsoftware.com/2019/11/blogged-answers-learning-and-using-typescript/"><b>Blogged Answers: Learning and Using TypeScript as an App Dev and a Library Maintainer</b> </a>
		
		</li>
	
		<li>Jul 10, 2019 - 
		
			<a href="https://blog.isquaredsoftware.com/2019/07/blogged-answers-thoughts-on-hooks/"><b>Blogged Answers: Thoughts on React Hooks, Redux, and Separation of Concerns</b> </a>
		
		</li>
	
		<li>Jan 19, 2019 - 
		
			<a href="https://blog.isquaredsoftware.com/2019/01/blogged-answers-debugging-tips/"><b>Blogged Answers: Debugging Tips</b> </a>
		
		</li>
	
		<li>Mar 29, 2018 - 
		
			<a href="https://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/"><b>Blogged Answers: Redux - Not Dead Yet!</b> </a>
		
		</li>
	
		<li>Dec 18, 2017 - 
		
			<a href="https://blog.isquaredsoftware.com/2017/12/blogged-answers-learn-redux/"><b>Blogged Answers: Resources for Learning Redux</b> </a>
		
		</li>
	
		<li>Dec 18, 2017 - 
		
			<a href="https://blog.isquaredsoftware.com/2017/12/blogged-answers-learn-react/"><b>Blogged Answers: Resources for Learning React</b> </a>
		
		</li>
	
		<li>Aug 02, 2017 - 
		
			<a href="https://blog.isquaredsoftware.com/2017/08/blogged-answers-webpack-hmr-vs-rhl/"><b>Blogged Answers: Webpack HMR vs React-Hot-Loader</b> </a>
		
		</li>
	
		<li>Sep 14, 2016 - 
		
			<a href="https://blog.isquaredsoftware.com/2016/09/how-i-got-here-my-journey-into-the-world-of-redux-and-open-source/"><b>How I Got Here: My Journey Into the World of Redux and Open Source</b> </a>
		
		</li>
	
	</ul>
	</section>
 

  
</article></div>
  </body>
</html>
