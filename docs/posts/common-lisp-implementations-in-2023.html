<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.n16f.net/blog/common-lisp-implementations-in-2023/">Original</a>
    <h1>Common Lisp Implementations in 2023</h1>
    
    <div id="readability-page-1" class="page"><div>
    <section>
      <p>Much has been written on Common Lisp; there is rarely one year without someone
proclaming the death of the language and how nobody uses it anymore. And yet
it is still here, so something must have been done right.</p>
<p>Common Lisp is not a software, it is a language described by the ANSI INCITS
226-1994 standard; there are multiple implementations available, something
often used as argument for how alive and thriving the language is.</p>
<p>Let us see what the 2023 situation is.</p>
<h2 id="general-information">General information</h2>
<table>
<thead>
<tr>
<th>Implementation</th>
<th>License</th>
<th>Target</th>
<th>Last release</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://sbcl.org/">SBCL</a></td>
<td>Public domain</td>
<td>Native</td>
<td>2023/01 (2.3.1)</td>
</tr>
<tr>
<td><a href="https://ccl.clozure.com/">CCL</a></td>
<td>Apache 2.0</td>
<td>Native</td>
<td>2021/05 (1.12.1)</td>
</tr>
<tr>
<td><a href="https://ecl.common-lisp.dev/">ECL</a></td>
<td>LGPL 2.1</td>
<td>Native (C translation)</td>
<td>2021/02 (21.2.1)</td>
</tr>
<tr>
<td><a href="https://abcl.org/">ABCL</a></td>
<td>GPL2</td>
<td>Java bytecode</td>
<td>2023/02 (1.9.1)</td>
</tr>
<tr>
<td><a href="https://clasp-developers.github.io">CLASP</a></td>
<td>LGPL 2.1</td>
<td>Native (LLVM)</td>
<td>2023/01 (2.1.0)</td>
</tr>
<tr>
<td><a href="https://www.cons.org/cmucl/">CMUCL</a></td>
<td>Public domain</td>
<td>Native</td>
<td>2017/10 (21c)</td>
</tr>
<tr>
<td><a href="https://www.gnu.org/software/gcl/">GCL</a></td>
<td>LGPL2</td>
<td>Native (C translation)</td>
<td>2023/01 (2.6.14)</td>
</tr>
<tr>
<td><a href="https://clisp.sourceforge.io/">CLISP</a></td>
<td>GPL</td>
<td>Bytecode</td>
<td>2010/07 (2.49)</td>
</tr>
<tr>
<td><a href="http://www.lispworks.com/">Lispworks</a></td>
<td>Proprietary</td>
<td>Native</td>
<td>2022/06 (8.0.1)</td>
</tr>
<tr>
<td><a href="https://franz.com/products/allegro-common-lisp/">Allegro</a></td>
<td>Proprietary</td>
<td>Native</td>
<td>2017/04 (10.1)</td>
</tr>
</tbody>
</table>
<p>Note that all projects may have small parts with different licenses. This is
particularily important for CLASP which contains multiple components imported
from other projects.</p>
<p>I was quite surprised to see so many projects with recent releases. Clearly a
good sign. Let us look at each implementation.</p>
<h2 id="implementations">Implementations</h2>
<h3 id="sbcl">SBCL</h3>
<p>Steel Bank Common Lisp was forked from CMUCL in December 1999 and has since
massively grown in popularity; it is currently the most used implementation by
far. Unsurprisingly given its popularity, SBCL is supported by pretty much all
Common Lisp libraries and tools out there. It is well known for generating
fast native code compared to other implementations.</p>
<p>The most important aspect of SBCL is that it is actively maintained: its
developers release new versions on a monthly basis, bringing each time a small
list of improvements and bug fixes. Activity has actually increased these last
years, something uncommon in the Common Lisp world.</p>
<h3 id="ccl">CCL</h3>
<p>Clozure Common Lisp has a long and complex
<a href="https://ccl.clozure.com/history.html">history</a> and has been around for
decades. It is a mature implementation; it has two interesting aspects
compared to SBCL:</p>
<ul>
<li>The compiler is much faster.</li>
<li>Error messages tend to be clearer.</li>
</ul>
<p>This is why I currently use it to test my code along SBCL. And according to
what I have heard, this is a common choice among developers.</p>
<p>The main issue with CCL is that the project is almost completely abandonned.
<a href="https://github.com/Clozure/ccl/graphs/contributors">Git activity</a> has slowed
down to a crawl in the last two years, and none of the original maintainers
from Clozure seem to be actively working on it. It remains nonetheless a major
implementation.</p>
<h3 id="ecl">ECL</h3>
<p>Embeddable Common Lisp is a small implementation which can be used both as a
library or as a standalone program. It contains a bytecode interpreter, but
can also translate Lisp code to C to be compiled to native code.</p>
<p>While development is slow, improvements and bug fixes are still added on a
regular basis. Clearly an interesting project: I could see myself using ECL to
write plugins into an application able to call a C library.</p>
<h3 id="abcl">ABCL</h3>
<p>Armed Bear Common Lisp is quite different from other implementations: it
produces Java bytecode and targets the Java Virtual Machine, making it a
useful tool in Java ecosystems.</p>
<p>While it has not found the same success as <a href="https://clojure.org/">Clojure</a>,
ABCL is still a fully featured Common Lisp implementation which passes almost
the entire ANSI Common Lisp test suite.</p>
<p>Developement is slow nowadays but there are still new releases with lots of
bug fixes. Also note that two of the developers are able to provide paid
support.</p>
<h3 id="clasp">CLASP</h3>
<p>CLASP is a newcomer in the Common Lisp world (new meaning it is less than a
decade old). Developed by Christian Schafmeister for his research work, this
implementation has been used as an exemple of how alive and kicking Common
Lisp, mainly due to two
<a href="https://www.youtube.com/watch?v=8X69_42Mj-g">excellent</a>
<a href="https://www.youtube.com/watch?v=mbdXeRBbgDM">presentations</a>.</p>
<p>While very promising, CLASP suffers from its young age: trying to run the last
release on my code resulted in a brutal error with now details and no
backtrace. However I have no doubt that CLASP will get a lot better: it is
actively maintained and used in production, two of the necessary ingredients
for a software to stay relevant.</p>
<h3 id="gcl">GCL</h3>
<p>GNU Common Lisp is described as the official Common Lisp implementation for
the GNU project. While it clearly does not have the popularity of other
implementations, it is still a maintained project.</p>
<p>Trying to use it, I quickly realized it is not fully compliant with the
standard. For example it will fail when evaluating a call to <code>COMPILE-FILE</code>
with the <code>:VERBOSE</code> key argument.</p>
<p>Hopefully development will continue.</p>
<h3 id="clisp">CLISP</h3>
<p>CLISP is almost as old as I am; it was the first implementation I used a long
time ago, and it still works. While it has all the usual features
(multithreading, FFI, MOP, etc.), there is no real reason to use it compared
to other implementations.</p>
<p>Even if it was to have any specific feature, CLISP is almost completely
abandonned. While there are has been a semblant of activity a few years ago,
active development pretty much stopped around 2012; the last release was more
than 12 years ago.</p>
<h3 id="lispworks">Lispworks</h3>
<p>Moving to proprietary implementations; Lispworks has been around for more than
30 years and the company producing it still release new versions on a regular
basis.</p>
<p>While Lispworks supports most features you would expect from a commercial
product (native compiler, multithreading, FFI, GUI library, various graphical
tools, a Prolog implementation…), it is hampered by its licensing system.</p>
<p>The free “Personal Edition” limits the program size and the amount of time it
can run, making it pretty much useless for anything but evaluation. The
professional and enterprise licenses do not really make sense for anyone: you
will have to buy separate licenses for every single platform at more than a
thousand euros per license (with the enterprise version being 2-3 times more
expensive). Of course you will have to buy a maintenance contract on a yearly
basis… but it does not include technical support. It will have to be bought
with “incident packs” costing thousands of euros; because yes, paying for a
product and a maintenance contract does not mean they will fix bugs, and you
will have to pay for each of them.</p>
<p>I do not have anything personal against commercial software, and I strongly
support developers being paid for their work. But this kind of licensing makes
Lispworks irrelevant to everyone but those already using their proprietary
libraries.</p>
<h3 id="allegro">Allegro</h3>
<p>Allegro Common Lisp is the other well known proprietary implementation.
Developped by Franz Inc., it is apparently used by multiple organizations
including the U.S. Department of Defense.</p>
<p>Releases are uncommon, the last one being almost 6 years ago. But Allegro is a
mature implementation packed with features not easily replicated such as
<a href="https://franz.com/products/allegrocache/index.lhtml">AllegroCache</a>,
<a href="https://franz.com/products/web_tools/">AllegroServe</a>, libraries for multiple
protocols and data formats, analysis tools, a concurrent garbage collector and
even an OpenGL interface.</p>
<p>Allegro suffers the same issue as Lispworks: the enterprise-style pricing
system is incredibly frustrating. The website advertises a hefty $599 starting
price (which at least includes technical support), but there is no mention of
what it contains. Interested developpers will have to contact Franz Inc. to
get other prices. A quick Google search will reveal rumours of enterprise
versions priced above 8000 dollars. No comment.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Researching Common Lisp implementations has been interesting. While it is
clear that the language is far from dead, its situation is very fragile.
Proprietary implementations are completely out of touch with the needs of most
developers, leaving us with a single open source, actively maintained, high
performance implementation: SBCL. Unless of course they are willing to deal
with the JVM to use ABCL.</p>
<p>It might me interesting to investigate a possible solution to keep CCL somehow
alive, with patches being merged and releases being produced. I sent a patch
very recently, let us see what can be done!</p>

    </section>
  </div></div>
  </body>
</html>
