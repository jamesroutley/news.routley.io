<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://samwho.dev/big-o/">Original</a>
    <h1>A visual introduction to big O notation</h1>
    
    <div id="readability-page-1" class="page"><article>
    <main id="content">
        
<p>Big O notation is a way of describing the performance of a function without
using time. Rather than timing a function from start to finish, big O describes
how the time grows as the input size increases. It is used to help understand
how programs will perform across a range of inputs.</p>
<p>In this post I&#39;m going to cover 4 frequently-used categories of big O notation:
<strong>constant</strong>, <strong>logarithmic</strong>, <strong>linear</strong>, and <strong>quadratic</strong>. Don&#39;t worry if
these words mean nothing to you right now. I&#39;m going to talk about them in
detail, as well as visualise them, throughout this post.</p>
<s-dog name="doe">
  Before you scroll! This post has been sponsored by the wonderful folks at <a href="https://ittybit.com/?ref=sam">ittybit</a>, and their API for working
  with videos, images, and audio. If you need to store, encode, or get
  intelligence from the media files in your app, check them out!
</s-dog>
<h2 id="iterating"><a href="#iterating">#</a>
Iterating</h2>
<p>Consider this JavaScript function that calculates the sum of 1 to n.</p>
<pre data-lang="typescript"><code data-lang="typescript"><span><span><span>function</span> <span><span>sum</span></span><span><span>(</span><span>n</span><span>)</span></span> <span><span>{</span>
</span></span></span><span><span><span>  <span><span>let</span> <span><span><span>total</span></span> </span><span>=</span> <span>0</span></span><span>;</span>
</span></span></span><span><span><span>  <span>for</span> <span>(</span><span><span>let</span> <span><span><span>i</span></span> </span><span>=</span> <span>1</span></span><span>;</span> <span>i</span> <span>&lt;=</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    <span>total</span> <span>+=</span> <span>i</span><span>;</span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span>  <span>return</span> <span>total</span><span>;</span>
</span></span></span><span><span><span><span>}</span></span></span>
</span></code></pre>
<p>I&#39;m going to pass in 1 billion, written using the shorthand <code>1e9</code>, so it takes a
noticeable amount of time to run. Press the <h- key="run"></h-> button below to
measure how long it takes to calculate the sum of 1 to 1 billion.</p>
<s-code-timer title="sum(1e9)">
function sum(n) {
  let total = 0;
  for (let i = 1; i &lt;= n; i++) {
    total += i;
  }
  return total;
}
const result = sum(1e9);
</s-code-timer>
<p>On my laptop this takes just under 1 second. The time you get may be different,
and it may vary by a few tens of milliseconds each time you run it. This is
expected.</p>
<p>Timing code this way, by taking the start time and the end time and finding the
difference, is called <b>wall-clock time</b>.</p>
<p>How long do you think 2 billion, <code>2e9</code>, will take?</p>
<s-code-timer title="sum(2e9)">
function sum(n) {
  let total = 0;
  for (let i = 1; i &lt;= n; i++) {
    total += i;
  }
  return total;
}
const result = sum(2e9);
</s-code-timer>
<p>It takes about twice as long. The code loops <code>n</code> times and does a single
addition each time. If we passed in 3 billion, we would expect the execution
time to increase by a factor of three.</p>
<s-dog position="right" name="sage" mode="proud">
  The relationship between a function&#39;s input and how long it takes to execute
  is called its <b>time complexity</b>, and <b>big O notation</b> is how we
  communicate what the time complexity of a function is.
</s-dog>
<p>Play around with the buttons below. Each bar adds an extra 1 billion to the <code>n</code>
that we pass to <code>sum</code>, so the <h- key="run">1e9</h-> button calls <code>sum(1e9)</code>,
the <h- key="run">2e9</h-> button calls <code>sum(2e9)</code>, and so on. You should see
<code>2e9</code> take about twice as long as <code>1e9</code>, and <code>3e9</code> take about three times as
long as <code>1e9</code>.</p>
<s-code-timer-bar-graph>
  <shared>
    function sum(n) {
      let total = 0;
      for (let i = 1; i &lt;= n; i++) {
        total += i;
      }
      return total;
    }
  </shared>
  <bar label="1e9">sum(1e9);</bar>
  <bar label="2e9">sum(2e9);</bar>
  <bar label="3e9">sum(3e9);</bar>
  <bar label="4e9">sum(4e9);</bar>
  <bar label="5e9">sum(5e9);</bar>
</s-code-timer-bar-graph>

<p>Because <code>sum</code>&#39;s wall-clock time grows at the same rate as <code>n</code>, e.g. <code>sum(20)</code>
would take twice as long as <code>sum(10)</code>, we say that <code>sum</code> is a &#34;linear&#34;
function. It has a big O of n, or <strong>O(n)</strong>.</p>
<s-dog position="left" name="haskie" mode="confused">
  Why do we use that syntax: <b>O(n)</b>? What is O? Why those brackets?
</s-dog>
<p>The &#34;O&#34; stands for &#34;order,&#34; short for &#34;order of growth.&#34; Said out loud it would
be: &#34;the order of growth of the <code>sum</code> function is n.&#34; <strong>O(n)</strong> is a compact way
to write that. The notation was created by the German mathematician Paul
Bachmann in 1894.  Also, the &#34;O&#34; (letter) might look like a 0 (number) in some
typefaces.  It is always the letter O.</p>
<p>A different way to sum the numbers from 1 to n is to use the formula
<code>(n*(n+1))/2</code>. Here&#39;s the result of this formula with the numbers from 1 to 5.
In each case the result should be the same as doing, e.g. <code>1+2+3+4+5</code> for <code>n=5</code>.</p>
<ul>
<li><code>(1*2)/2 = 2/2  = 1</code></li>
<li><code>(2*3)/2 = 6/2  = 3</code></li>
<li><code>(3*4)/2 = 12/2 = 6</code></li>
<li><code>(4*5)/2 = 20/2 = 10</code></li>
<li><code>(5*6)/2 = 30/2 = 15</code></li>
</ul>
<p>Here&#39;s how <code>sum</code> would look if it used that formula instead of the loop we had
before:</p>
<pre data-lang="javascript"><code data-lang="javascript"><span><span><span>function</span> <span><span>sum</span></span><span><span>(</span><span>n</span><span>)</span></span> <span><span>{</span>
</span></span></span><span><span><span>  <span>return</span> <span>(</span><span>n</span> <span>*</span> <span>(</span><span>n</span> <span>+</span> <span>1</span><span>)</span><span>)</span> <span>/</span> <span>2</span><span>;</span>
</span></span></span><span><span><span><span>}</span></span></span>
</span></code></pre>
<p>How do you think the wall-clock time of this function changes as <code>n</code> increases?
The next two examples <strong>differ by a factor of 100</strong>.</p>
<s-code-timer title="sum(1e9)">
function sum(n) {
  return (n * (n + 1)) / 2;
}
const result = sum(1e9);
</s-code-timer>
<s-code-timer title="sum(100e9)">
function sum(n) {
  return (n * (n + 1)) / 2;
}
const result = sum(100e9);
</s-code-timer>
<p>This example isn&#39;t broken. Both of these functions take almost no time at
all.  The variance in timing is caused by the browser, and the unpredictability
of computers, not the <code>sum</code> function.  Running each example a few times, you
should see that the wall-clock time hovers around the same value for both.</p>
<p>We call functions like this, whose wall-clock time is about the same no matter
what input you give it, <strong>constant</strong> or <strong>O(1)</strong>.</p>
<s-dog position="left" name="haskie" mode="triumphant">
  Wow, so we improved our sum function from <b>O(n)</b> to <b>O(1)</b>! It
  always runs instantly now!
</s-dog>
<p>We did! Though it is crucial to remember that <strong>O(1)</strong> doesn&#39;t <em>always</em> mean
&#34;instant.&#34; It means that <strong>the time taken doesn&#39;t increase with the size
of the input.</strong> In the case of our new <code>sum</code> function, it&#39;s more or less
instant. But it&#39;s possible for an <strong>O(1)</strong> algorithm to take several minutes or
even hours, depending on what it does.</p>
<p>It&#39;s also possible for an <strong>O(n)</strong> algorithm to be faster than an <strong>O(1)</strong>
algorithm for some of its inputs. Eventually, though, the <strong>O(1)</strong> algorithm
will outpace the <strong>O(n)</strong> algorithm as the input size grows. Play with the
slider below to see an example of that.</p>
<s-graph id="constantlinear" drawupto="0">
  <legend position="top-left">
  <axes>
    <x tics="10" ticformat="tic.toFixed(0)" max="100">
    <y tics="10" ticformat="tic.toFixed(0)" max="110">
  </y></x></axes>
  <lines>
    <line label="O(n)" y="5 + x">
    <line label="O(1)" y="20">
  </line></line></lines>
</legend></s-graph>


<s-dog position="left" name="haskie" mode="confused">
  The <b>O(1)</b> line is always at 20 in that graph, so why don&#39;t we say
  <b>O(20)</b> instead?
</s-dog>
<p>The purpose of big O notation is to describe the relationship between the input
and the wall-clock time of a function. It isn&#39;t concerned with what that
wall-clock time ends up being, only with how it grows.</p>
<p>Big O describes growth in the smallest terms possible.  It would quickly get
messy if the world had to figure out what number to put inside the brackets for
every function, and have those numbers be correct relative to each other.
Likewise, linear functions are always <strong>O(n)</strong> and never <strong>O(2n)</strong> or <strong>O(n +
1)</strong>, because <strong>O(n)</strong> is the smallest linear term.</p>
<h2 id="sorting"><a href="#sorting">#</a>
Sorting</h2>
<p>Let&#39;s move away from <code>sum</code> and talk about a different algorithm: <b>bubble
sort</b>.</p>
<p>The idea behind bubble sort is that you loop over the input array and swap
elements next to each other if they are not in the desired order. You do this
until you&#39;re able to complete a loop through the array without making any swaps.
It&#39;s called bubble sort because of the way numbers &#34;bubble&#34; up to their correct
position.</p>
<p>Below is a JavaScript implementation of this algorithm. We&#39;re going to sort
these numbers in ascending order, so the desired result is 1, 2, 3, 4, 5.</p>
<p>You can step through this code and watch the array get sorted using the
controls. <h- key="step"></h-> steps forwards 1 line at a time, <h- key="stepback"></h-> steps backwards, <h- key="play"></h-> automatically
advances forward 1 line every second, and <h- key="restart"></h-> resets back to
the start.</p>
<s-array ref="a" debugger-id="bubble-sort-debugger">
  <annotation name="i"></annotation>
  <annotation name="i+1">
    <span data-name="i">i</span>
    <span>+</span>
    <span>1</span>
  </annotation>
</s-array>
<div>
  <s-debugger-controls debugger-id="bubble-sort-debugger">
  </s-debugger-controls>
  <s-debugger id="bubble-sort-debugger">
    <pre main="">      function bubbleSort(a) {
        while(true) {
          let swapped = false;
          for (let i = 0; i &lt; a.length - 1; i++) {
            if (a[i] &gt; a[i+1]) {
              [a[i], a[i+1]] = [a[i+1], a[i]];
              swapped = true;
            }
          }
          if (!swapped) break;
        }
        return a;
      }
    </pre>
    <pre>      bubbleSort([3, 2, 5, 4, 1]);
    </pre>
  </s-debugger>
</div>
<p>Now you&#39;ve had a look at the algorithm in action, what do you think its big O
is?</p>
<p>If the array is already sorted, the algorithm loops through once, does no swaps,
and exits. This would be <strong>O(n)</strong>. But if the array is in any other order,
we need to loop through more than once. In the worst case, where the array is
in reverse order, we would have to loop through <code>n</code> times in order to move the
smallest element from the end to the start.</p>
<p>Looping through the <code>n</code> elements of our array <code>n</code> times results in <code>n*n</code>
operations, or <code>n^2</code>. That means <strong>bubble sort is an O(n^2) algorithm</strong>.
Sometimes called <strong>quadratic.</strong></p>
<p>Because it&#39;s common for an algorithm&#39;s performance to depend not just on the
<em>size</em> of the input, but also its arrangement, <strong>big O notation, unless stated
otherwise, describes the worst-case scenario</strong>. The same notation can also be
used for best and average case, but worst case is the default.</p>
<p>Below is another way to visualise bubble sort. It starts off with the array 5,
4, 3, 2, 1 from top to bottom. The end state should be 1, 2, 3, 4, 5 top to
bottom. Each <h- key="step"></h-> step forward represents a full loop through
the array, potentially involving multiple swaps. Use <h->Best</h->,
<h->Worst</h->, and <h->Rand</h-> to see different initial configurations.</p>

<p>If you played around with <h->Rand</h-> a few times you&#39;ll have noticed that you
do sometimes get only a couple of iterations. Despite this, bubble sort is still
<strong>O(n^2)</strong> because in the worst case you&#39;ll have to iterate over the array
<code>n</code> times.</p>
<h2 id="searching"><a href="#searching">#</a>
Searching</h2>
<p>The last algorithm I want to talk about is <strong>binary search</strong>.</p>
<p>Let&#39;s start with a game. <b>Think of a number between 1 and 100.</b> I&#39;m going
to try and guess what it is. Use the buttons below to tell me if your number is
higher or lower than my guess.</p>

<p>What I&#39;m doing is starting in the middle of the range, 50, and eliminating half
of the possibilities with each guess. This is a <b>binary search</b>.</p>
<p>Using this method it will never take more than 7 guesses to find your number.
This is because we start with 100 possibilities and half of the possibilities
are ruled out with each guess.</p>
<p>The table below shows the guessing pattern for all numbers between 1 and 100,
use the slider to choose a number.</p>

<p>When it&#39;s possible to eliminate a fraction of possibilities with every step
of an algorithm, we call it <b>logarithmic</b>. That means that binary search is
an <strong>O(log n)</strong> algorithm.</p>
<p>Below is a graph of the number of guesses I would need in order to figure out
any number between 1 and 1000.</p>
<s-graph id="guesses" drawupto="0">
  <axes>
    <x tics="100" ticformat="tic.toFixed(0)" label="Target number" max="1000">
    <y tics="2" ticformat="tic.toFixed(0)" label="Max guesses needed" max="10">
  </y></x></axes>
  <lines>
    <line label="Guesses" y="Math.ceil(Math.log(x) / Math.log(2))">
  </line></lines>
</s-graph>


<p>Every time the target number doubles, I need 1 extra guess to find it. If you
were to pick a number between 1 and 1 billion, I would need 31 guesses at most
to find it. Logarithmic growth is really slow! Below is a graph comparing it to
<strong>O(n)</strong> and <strong>O(n^2)</strong>, which both grow much faster.</p>
<s-graph id="graph2" drawupto="0">
  <legend position="top-left">
  <axes>
    <x tics="20" ticformat="tic.toFixed(0)" max="100">
    <y tics="20" ticformat="tic.toFixed(0)" max="100">
  </y></x></axes>
  <lines>
    <line label="O(n^2)" y="Math.pow(x, 2)">
    <line label="O(n)" y="x">
    <line label="O(log n)" y="Math.log(x) / Math.log(2)">
  </line></line></line></lines>
</legend></s-graph>


<h2 id="putting-this-knowledge-to-work"><a href="#putting-this-knowledge-to-work">#</a>
Putting this knowledge to work</h2>
<p>In the previous sections of this post I&#39;ve described the difference between
<strong>O(1)</strong>, <strong>O(log n)</strong>, <strong>O(n)</strong>, and <strong>O(n^2)</strong> algorithms. Let&#39;s have a look
at some situations you might encounter while writing code and what you can do to
improve your time complexity.</p>
<h3 id="finding-an-item-in-a-list"><a href="#finding-an-item-in-a-list">#</a>
Finding an item in a list</h3>
<p>Here&#39;s a function that checks if a list contains a specific item.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span><span><span>function</span> <span><span>contains</span></span><span><span>(</span><span>items</span><span>,</span> <span>target</span><span>)</span></span> <span><span>{</span>
</span></span></span><span><span><span>  <span>for</span> <span>(</span><span><span>const</span> <span><span><span>item</span></span> </span></span><span>of</span> <span>items</span><span>)</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    <span>if</span> <span>(</span><span>item</span> <span>===</span> <span>target</span><span>)</span> <span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>      <span>return</span> <span>true</span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>    <span>}</span></span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span>  <span>return</span> <span>false</span><span>;</span>
</span></span></span><span><span><span><span>}</span></span></span>
</span></code></pre>
<p>If you&#39;re looking up items in the same list lots of times, you might want to
consider using a data structure that allows for faster lookups, such as a
<strong>Set</strong>. Modern browsers implement <code>Set</code> in a way that gives <strong>O(1)</strong>
time complexity for lookups.</p>
<p>However, don&#39;t do this:</p>
<pre data-lang="javascript"><code data-lang="javascript"><span><span><span>function</span> <span><span>contains</span></span><span><span>(</span><span>items</span><span>,</span> <span>target</span><span>)</span></span> <span><span>{</span>
</span></span></span><span><span><span>  <span><span>const</span> <span><span><span>itemSet</span></span> </span><span>=</span> <span><span>new</span> <span>Set</span><span>(</span><span>items</span><span>)</span></span></span><span>;</span>
</span></span></span><span><span><span>  <span>return</span> <span><span>itemSet</span><span>.</span><span>has</span></span><span>(</span><span>target</span><span>)</span><span>;</span>
</span></span></span><span><span><span><span>}</span></span></span>
</span></code></pre>
<p><em>Building</em> the <code>new Set(items)</code> is an <strong>O(n)</strong> operation! This is because the
<code>Set</code> constructor loops over all items in the array to add them to the set. You
need to weigh the cost of this upfront work against the potential savings from
faster lookups.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span><span><span>const</span> <span><span><span>items</span></span> </span><span>=</span> <span><span>new</span> <span>Set</span><span>(</span><span><span>[</span><span><span>&#34;</span>apple<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>banana<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>cherry<span>&#34;</span></span><span>]</span></span><span>)</span></span></span><span>;</span>
</span><span><span><span>items</span><span>.</span><span>has</span></span><span>(</span><span><span>&#34;</span>banana<span>&#34;</span></span><span>)</span> 
</span></code></pre>
<h3 id="loop-an-array-with-indexes"><a href="#loop-an-array-with-indexes">#</a>
Loop an array with indexes</h3>
<p>The code below contains a common mistake I&#39;ve seen dozens of times in production
code.  Have a read and see if you can answer:</p>
<ul>
<li>What is the big O of this function?</li>
<li>How could we improve it?</li>
</ul>
<pre data-lang="javascript"><code data-lang="javascript"><span><span><span>function</span> <span><span>buildList</span></span><span><span>(</span><span>items</span><span>)</span></span> <span><span>{</span>
</span></span></span><span><span><span>  <span><span>const</span> <span><span><span>output</span></span> </span><span>=</span><span> <span>[</span><span>]</span></span></span><span>;</span>
</span></span></span><span><span><span>  <span>for</span> <span>(</span><span><span>const</span> <span><span><span>item</span></span> </span></span><span>of</span> <span>items</span><span>)</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    <span><span>const</span> <span><span><span>index</span></span> </span><span>=</span> <span><span>items</span><span>.</span><span>indexOf</span></span><span>(</span><span>item</span><span>)</span></span><span>;</span>
</span></span></span></span><span><span><span><span>    <span><span>output</span><span>.</span><span>push</span></span><span>(</span><span><span>`</span>Item <span><span>${</span></span><span><span><span>index</span> <span>+</span> <span>1</span></span><span>}</span></span>: <span><span>${</span></span><span><span><span>item</span></span><span>}</span></span><span>`</span></span><span>)</span><span>;</span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span>  <span>return</span> <span><span>output</span><span>.</span><span>join</span></span><span>(</span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span><span>)</span><span>;</span>
</span></span></span><span><span><span><span>}</span></span></span>
</span></code></pre>
<p>The problem is calling <code>.indexOf</code> inside the loop. The <code>.indexOf</code> function is an
<strong>O(n)</strong> operation! It works by looping over the array until it finds the target
element, returning <code>-1</code> if it doesn&#39;t. Calling it inside the loop makes the
overall big O of our <code>buildList</code> function <strong>O(n^2)</strong>!</p>
<p>To fix this we can loop using an index. Looking up an element in an array by its
index is <strong>O(1)</strong>, so the overall big O of the function is reduced to <strong>O(n)</strong>.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span><span><span>function</span> <span><span>buildList</span></span><span><span>(</span><span>items</span><span>)</span></span> <span><span>{</span>
</span></span></span><span><span><span>  <span><span>const</span> <span><span><span>output</span></span> </span><span>=</span><span> <span>[</span><span>]</span></span></span><span>;</span>
</span></span></span><span><span><span>  <span>for</span> <span>(</span><span><span>let</span> <span><span><span>i</span></span> </span><span>=</span> <span>0</span></span><span>;</span> <span>i</span> <span>&lt;</span> <span>items</span><span>.</span><span>length</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    <span><span>output</span><span>.</span><span>push</span></span><span>(</span><span><span>`</span>Item <span><span>${</span></span><span><span><span>i</span> <span>+</span> <span>1</span></span><span>}</span></span>: <span><span>${</span></span><span><span><span>items</span><span><span>[</span><span>i</span><span>]</span></span></span><span>}</span></span><span>`</span></span><span>)</span><span>;</span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span>  <span>return</span> <span><span>output</span><span>.</span><span>join</span></span><span>(</span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span><span>)</span><span>;</span>
</span></span></span><span><span><span><span>}</span></span></span>
</span></code></pre>
<p>You can also achieve the same result with JavaScript&#39;s <code>items.forEach((item, index) =&gt; ...)</code> method on arrays, or <code>items.entries()</code>.</p>
<h3 id="caching-intermediate-results"><a href="#caching-intermediate-results">#</a>
Caching intermediate results</h3>
<p>Consider this function to calculate the factorial of a number. A factorial in
mathematics is written as, e.g., <code>5!</code> to represent <code>5*4*3*2*1</code> or <code>3!</code> to
represent <code>3*2*1</code>.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span><span><span>function</span> <span><span>factorial</span></span><span><span>(</span><span>n</span><span>)</span></span> <span><span>{</span>
</span></span></span><span><span><span>  <span>if</span> <span>(</span><span>n</span> <span>===</span> <span>0</span><span>)</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    <span>return</span> <span>1</span><span>;</span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span>  <span>return</span> <span>n</span> <span>*</span> <span><span>factorial</span></span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
</span></span></span><span><span><span><span>}</span></span></span>
</span></code></pre>
<p>This function has a time complexity of <strong>O(n)</strong>, but most calls to this function
are going to redo work we&#39;ve done before. Calling <code>factorial(4)</code> and then
<code>factorial(5)</code> will mean <code>factorial(4)</code> is calculated twice.</p>
<p>We can cache the result of each calculation to avoid this redundant work.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span><span><span>const</span> <span><span><span>cache</span></span> </span><span>=</span> <span><span>new</span> <span>Map</span><span>(</span><span>)</span></span></span><span>;</span>
</span><span><span><span>function</span> <span><span>factorial</span></span><span><span>(</span><span>n</span><span>)</span></span> <span><span>{</span>
</span></span></span><span><span><span>  <span>if</span> <span>(</span><span><span>cache</span><span>.</span><span>has</span></span><span>(</span><span>n</span><span>)</span><span>)</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    <span>return</span> <span><span>cache</span><span>.</span><span>get</span></span><span>(</span><span>n</span><span>)</span><span>;</span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span>  <span>if</span> <span>(</span><span>n</span> <span>===</span> <span>0</span><span>)</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    <span>return</span> <span>1</span><span>;</span>
</span></span></span></span><span><span><span><span>  <span>}</span></span>
</span></span></span><span><span><span>  <span><span>const</span> <span><span><span>result</span></span> </span><span>=</span> <span>n</span> <span>*</span> <span><span>factorial</span></span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>  <span><span>cache</span><span>.</span><span>set</span></span><span>(</span><span>n</span><span>,</span> <span>result</span><span>)</span><span>;</span>
</span></span></span><span><span><span>  <span>return</span> <span>result</span><span>;</span>
</span></span></span><span><span><span><span>}</span></span></span>
</span></code></pre>
<p>This makes use of the <strong>O(1)</strong> time complexity for lookups in a <code>Map</code>.  It
doesn&#39;t change the worst case time complexity of the <code>factorial</code> function, but
it does make the average case faster at the cost of increased memory usage.</p>
<s-dog position="right" name="sage" mode="caution">
  When it comes to performance, remember that you can&#39;t ever take what you read
  online at face value. <b>Always test your code</b> before and after changes
  to make sure you&#39;re actually improving it!
</s-dog>
<h2 id="conclusion"><a href="#conclusion">#</a>
Conclusion</h2>
<p>Let&#39;s recap what we&#39;ve learned:</p>
<ul>
<li>Big O notation describes the <strong>relationship between a function&#39;s input and
its wall-clock time</strong>.</li>
<li>From slowest growth to fastest growth we saw examples of:
<ul>
<li><strong>O(1)</strong>, constant time (best!)</li>
<li><strong>O(log n)</strong>, logarithmic time</li>
<li><strong>O(n)</strong>, linear time</li>
<li><strong>O(n^2)</strong>, quadratic time</li>
</ul>
</li>
<li>We can improve the time complexity of the code we write by making better
algorithmic choices and avoiding common pitfalls.</li>
</ul>
<p>These posts take me a long time to write, and they wouldn&#39;t be possible without
the support of my family, friends, sponsors, and reviewers. I&#39;m so grateful to
all of you—you know who you are—for making it possible for me to make these.</p>
<p>If you enjoyed this post, I&#39;ve written a bunch more similar that you can find <a href="http://tinylogger.com/">on my homepage</a>. I also love hearing from folks that have questions
or feedback, you can reach me via <a href="mailto:big-o@samwho.dev">email</a>,
on <a href="https://bsky.app/profile/samwho.dev">Bluesky</a>, or anonymously via
my <a href="http://tinylogger.com/ping">silly little ping service</a>.</p>
<p>I&#39;ll leave you with one last graph comparing all of the time complexities we
covered in this post.</p>
<s-graph id="final" drawupto="0">
  <legend position="top-left">
  <axes>
    <x tics="10" ticformat="tic.toFixed(0)" max="50">
    <y tics="10" ticformat="tic.toFixed(0)" max="50">
  </y></x></axes>
  <lines>
    <line label="O(1), constant" y="1">
    <line label="O(log n), logarithmic" y="Math.log(x) / Math.log(2)">
    <line label="O(n), linear" y="x">
    <line label="O(n^2), quadratic" y="Math.pow(x, 2)">
  </line></line></line></line></lines>
</legend></s-graph>



    </main>
</article></div>
  </body>
</html>
