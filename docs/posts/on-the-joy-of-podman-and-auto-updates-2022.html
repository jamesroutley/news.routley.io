<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://feldspaten.org/2022/07/09/On-the-joy-of-podman-and-auto-updates/">Original</a>
    <h1>On the joy of podman and auto-updates (2022)</h1>
    
    <div id="readability-page-1" class="page"><section>
    
    
    <p><code>podman</code> provides an integrated <a href="https://docs.podman.io/en/latest/markdown/podman-auto-update.1.html" target="_blank" rel="noopener">auto-update</a> mechanism, which I recently applied to all of my containers running on feldspaten. The mechanism is nice, but at first appears a bit counter-intuitive. In this post ’m trying to explain how you can use the mechanism and what to watch out for. I’ll start with the trap I think most people fall for.</p>

<p>Most people’s path to containers starts with <code>docker</code>, which by itself is an amazing tool. I see <code>podman</code> as an improvement/modernization step of <code>docker</code> because it can run daemonless, rootless and thereby integrates well with systemd. The last part is in my experience a stumbling block, most people fall over at first.</p>
<p>When you deply your applications with <code>docker</code> the typical approach is to use <a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">Docker Compose</a>. This allows for easy deployment of your application, consisting of multiple containers and removes the necessity of writing long uncomprehensible command line arguments with tons of <code>-v</code>, <code>-e</code> parameters. This looks honestly ugly and Docker-Compose does a good job in making this building block more accessible.</p>
<p>The consequence of Docker Compose is that most people use podman containers the same way as they use docker containers. You first create the container, and then you figure a way out, how to restart the container on every reboot. And this approach does not work with podman auto-update, because it requires this process to be upside-down … Wait upside-down? … What do I mean with that?</p>
<p>The canonical way of starting podman containers at boottime is the creation of custom systemd units for them. This is cool and allows to have daemonless, independent containers running. <code>podman</code> itself provides a handy way of creating those system units, e.g. here for a new <code>nginx</code> container:</p>
<pre><code># podman create --name nginx -p 80:80 -v /var/www:/usr/share/nginx/html docker.io/library/nginx:latest
# podman generate systemd nginx
</code></pre>
<p>This generates the following output:</p>
<div><pre tabindex="0"><code data-lang="ini"><span><span><span># container-c69183be0ce6fd025f04f34ab8e7f8c1abadcd3fa901b116489191df022b480c.service</span>
</span></span><span><span><span># autogenerated by Podman 3.4.4</span>
</span></span><span><span><span># Sat Jul  9 10:45:47 CEST 2022</span>
</span></span><span><span>
</span></span><span><span><span>[Unit]</span>
</span></span><span><span><span>Description</span><span>=</span><span>Podman container-c69183be0ce6fd025f04f34ab8e7f8c1abadcd3fa901b116489191df022b480c.service</span>
</span></span><span><span><span>Documentation</span><span>=</span><span>man:podman-generate-systemd(1)</span>
</span></span><span><span><span>Wants</span><span>=</span><span>network-online.target</span>
</span></span><span><span><span>After</span><span>=</span><span>network-online.target</span>
</span></span><span><span><span>RequiresMountsFor</span><span>=</span><span>/var/run/containers/storage</span>
</span></span><span><span>
</span></span><span><span><span>[Service]</span>
</span></span><span><span><span>Environment</span><span>=</span><span>PODMAN_SYSTEMD_UNIT=%n</span>
</span></span><span><span><span>Restart</span><span>=</span><span>on-failure</span>
</span></span><span><span><span>TimeoutStopSec</span><span>=</span><span>70</span>
</span></span><span><span><span>ExecStart</span><span>=</span><span>/usr/bin/podman start c69183be0ce6fd025f04f34ab8e7f8c1abadcd3fa901b116489191df022b480c</span>
</span></span><span><span><span>ExecStop</span><span>=</span><span>/usr/bin/podman stop -t 10 c69183be0ce6fd025f04f34ab8e7f8c1abadcd3fa901b116489191df022b480c</span>
</span></span><span><span><span>ExecStopPost</span><span>=</span><span>/usr/bin/podman stop -t 10 c69183be0ce6fd025f04f34ab8e7f8c1abadcd3fa901b116489191df022b480c</span>
</span></span><span><span><span>PIDFile</span><span>=</span><span>/var/run/containers/storage/btrfs-containers/c69183be0ce6fd025f04f34ab8e7f8c1abadcd3fa901b116489191df022b480c/userdata/conmon.pid</span>
</span></span><span><span><span>Type</span><span>=</span><span>forking</span>
</span></span><span><span>
</span></span><span><span><span>[Install]</span>
</span></span><span><span><span>WantedBy</span><span>=</span><span>default.target</span>
</span></span></code></pre></div><p>Now you can still tune this unit, perhaps call the container by name instead by it’s id (using the <code>-n</code> parameter) but ultimately this ends up in <code>/etc/systemd/system</code> and you can then enable this system unit - voila! - Your container is up and running as a proper systemd unit at startup. Nice.</p>
<p>Now comes the problem: a necessary requirement for podman auto-update is that systemd units CREATE the podman container at startup. From the <a href="https://docs.podman.io/en/latest/markdown/podman-auto-update.1.html" target="_blank" rel="noopener">documentation page</a>:</p>
<blockquote>
<p>[…] The systemd units are expected to be generated with podman-generate-systemd –new, or similar units that create new containers in order to run the updated images. Systemd units that start and stop a container cannot run a new image.</p>
</blockquote>
<p>This means, that the typical process of how people approach containers would not work. Most people first create the containers and then try to make the container restart and then want them to also auto-update. <code>podman auto-update</code> however requires the user to think the other way around - you need to make a systemd unit which creates the container for you at startup. This is the part that I believe is counter-intuitive at first, although if you think from the systems perspective is is the more natural process flow.</p>
<p>Enough talk, let’s do this.</p>

<p>So, in order for podman auto-update to work, you will need two things:</p>
<ul>
<li>a systemd unit that creates the container</li>
<li>label the container with <code>io.containers.autoupdate=image</code></li>
</ul>
<p>A good template for the former can be generated from podman itself:</p>
<pre><code>podman generate systemd --new nginx
</code></pre>
<div><pre tabindex="0"><code data-lang="ini"><span><span><span># container-c69183be0ce6fd025f04f34ab8e7f8c1abadcd3fa901b116489191df022b480c.service</span>
</span></span><span><span><span># autogenerated by Podman 3.4.4</span>
</span></span><span><span><span># Sat Jul  9 10:48:25 CEST 2022</span>
</span></span><span><span>
</span></span><span><span><span>[Unit]</span>
</span></span><span><span><span>Description</span><span>=</span><span>Podman container-c69183be0ce6fd025f04f34ab8e7f8c1abadcd3fa901b116489191df022b480c.service</span>
</span></span><span><span><span>Documentation</span><span>=</span><span>man:podman-generate-systemd(1)</span>
</span></span><span><span><span>Wants</span><span>=</span><span>network-online.target</span>
</span></span><span><span><span>After</span><span>=</span><span>network-online.target</span>
</span></span><span><span><span>RequiresMountsFor</span><span>=</span><span>%t/containers</span>
</span></span><span><span>
</span></span><span><span><span>[Service]</span>
</span></span><span><span><span>Environment</span><span>=</span><span>PODMAN_SYSTEMD_UNIT=%n</span>
</span></span><span><span><span>Restart</span><span>=</span><span>on-failure</span>
</span></span><span><span><span>TimeoutStopSec</span><span>=</span><span>70</span>
</span></span><span><span><span>ExecStartPre</span><span>=</span><span>/bin/rm -f %t/%n.ctr-id</span>
</span></span><span><span><span>ExecStart</span><span>=</span><span>/usr/bin/podman run --cidfile=%t/%n.ctr-id --cgroups=no-conmon --rm --sdnotify=conmon -d --replace --name nginx -p 80:80 -v /var/www:/usr/share/nginx/html docker.io/library/nginx:latest</span>
</span></span><span><span><span>ExecStop</span><span>=</span><span>/usr/bin/podman stop --ignore --cidfile=%t/%n.ctr-id</span>
</span></span><span><span><span>ExecStopPost</span><span>=</span><span>/usr/bin/podman rm -f --ignore --cidfile=%t/%n.ctr-id</span>
</span></span><span><span><span>Type</span><span>=</span><span>notify</span>
</span></span><span><span><span>NotifyAccess</span><span>=</span><span>all</span>
</span></span><span><span>
</span></span><span><span><span>[Install]</span>
</span></span><span><span><span>WantedBy</span><span>=</span><span>default.target</span>
</span></span></code></pre></div><p>CAVE: This does not hold yet the <code>--label io.containers.autoupdate=image</code> argument that you will need to add to ExecStart (remember to add arguments before the image name). For your convenience I provide the modified systemd unit as template here:</p>
<ul>
<li><a href="https://feldspaten.org/2022/07/09/On-the-joy-of-podman-and-auto-updates/podman-nginx.service">podman-nginx.service</a></li>
</ul>
<p>The <code>ExecStart</code> is the magical part. Edit this to your needs, add the necessary environment variables and volumes there and you’re good. The systemd unit will create a new podman container with your configuration at each startup, and the <code>PODMAN_SYSTEMD_UNIT</code> variable allows podman auto-update to figure out, which systemd unit is associated to which container. This is necessary to pull the updated image and then restart the systemd unit.</p>
<p>The neat part is, that once you have created your systemd unit, you can store this elsewhere and use this as your deployment recipe for your podman containers. On a fresh machine, you can just dump them to <code>/etc/systemd/system/</code>, do a <code>systemd daemon-reload</code>, enable/start the service and you’re done. <code>podman</code> will pull the images at startup if they are not present, so the only thing you need to care about is the systemd unit. This is awesome, because you only have to care about one piece for the system configuration of your containers.</p>
<p>After setting up your container, you can simply run <code>podman auto-update</code> to automatically update your containers with new versions of the underlying image.</p>
<pre><code># podman auto-update
UNIT                  CONTAINER             IMAGE                           POLICY      UPDATED
podman-nginx.service  8f7bdccf5576 (nginx)  docker.io/library/nginx:latest  registry    false
</code></pre>
<p>This checks if a new image is available, and if so, pulls the new image and restarts the associated systemd unit.</p>
<p>The cherry on top is to enable the <code>podman-auto-update.timer</code> unit, so this happens automatically once per day.</p>
<pre><code>systemctl enable --now podman-auto-update.timer
</code></pre>
<hr/>
<p>And that’s it! It is a little bit of a configuration effort but once it’s in place, <code>podman auto-update</code> will automagically update all of your containers once new images are available. After you automated this one, there is nothing that holds you back from that 4-week camping trip to Scandinavia, you always dreamed about. At least the excuse that you need to update your containers is not valid anymore ;-)</p>

</section></div>
  </body>
</html>
