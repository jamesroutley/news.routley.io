<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stripe.com/blog/sorbet-stripes-type-checker-for-ruby">Original</a>
    <h1>Sorbet: Stripe&#39;s Type Checker for Ruby</h1>
    
    <div id="readability-page-1" class="page"><section>
    <p>By 2017, Stripe had grown to the point where hundreds of engineers had written millions of lines of code. Most of that code was—and still is—written in Ruby, which is famous for helping engineers iterate quickly (if somewhat notorious for encouraging inscrutable code). Unfortunately we were starting to see Ruby come apart at the seams: new engineers found it hard to learn the codebase, and existing engineers were scared to make sweeping changes. Everyone faced a constant tradeoff: run the fast, local tests which might not catch many breakages, or run all the tests, even the slow ones. Ruby was becoming a source of friction more than a source of productivity.</p><p>We set out to change that, with two goals in mind: make it easier to understand the code, while doubling down on what makes Ruby productive and delightful. This was the backdrop against which we decided to create and open source <a href="https://sorbet.org/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">Sorbet</a>, a fast, powerful type checker designed for Ruby. Sorbet statically analyzes a codebase, builds up an understanding of how each piece of code relates to every other piece, and then exposes that knowledge to the programmer via type errors, autocompletion results, documentation on hover, or jumps between definitions and usages.</p><p>Today Sorbet runs over Stripe’s entire Ruby codebase, <strong>currently amounting to over 15 million lines of code spread across 150,000 files</strong>. We can&#39;t take credit for pioneering the idea of adding static types to a dynamically typed language—Microsoft and Facebook popularized the approach with TypeScript and Hack, respectively. However, we thought it was worth sharing how Sorbet has not just met but exceeded our goals in the almost four years since we first enabled it on our Ruby codebase.</p><p>Sorbet reinforces the delightful bits of Ruby while making engineers more productive. Not only has it made code easier to understand, it’s even helped shape and reinforce Stripe&#39;s engineering culture as we&#39;ve grown. But before we dive into what makes Sorbet… Sorbet, let’s take a short step back in time to its origins at Stripe.</p><h2>A brief history of Sorbet inside Stripe</h2><p>Type annotations arrived in Stripe&#39;s Ruby codebase as early as November 2016, almost a full year before work began on Sorbet. These annotations were born out of a desire to encourage engineers to write modular units with clear public interfaces. Here&#39;s an example test case from the pull request that introduced type annotations:</p><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.ctfassets.net/fzn2n1nzq965/30W43dgvJa6iyZHKPvqsrs/97a4dcc22ba70f3e8348ccd4a41583bc/01-declare-method-syntax.png?w=1082&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="Blog &gt; Sorbet &gt; Declare method syntax image" src="
        
          https://images.ctfassets.net/fzn2n1nzq965/30W43dgvJa6iyZHKPvqsrs/97a4dcc22ba70f3e8348ccd4a41583bc/01-declare-method-syntax.png?w=1082&amp;q=80
        
      " width="904" height="416" loading="lazy"/>
    </picture>
</div>
  
</figure><p>Neither Sorbet nor any other static type checker existed to consume these type annotations yet; they existed only at runtime. The <code>declare_method</code> call above acted like a decorator on the <code>def call</code> method: it would check that the <code>msg</code> argument given to <code>call</code> was a <code>String</code> and that <code>call</code> returned a <code>String</code> on every invocation. Throughout the next year, these runtime-only annotations spread throughout Stripe&#39;s codebase.</p><p>Months prior we had added <a href="https://flow.org/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">Flow</a>, a static type checker for JavaScript, to our frontend codebase. Ruby developers quickly grew envious and kept asking us what it would take to get the same features for Ruby. We staffed an effort to figure out what it would take to either adopt one of the two in-progress Ruby type checkers—RDL and TypedRuby—or to build our own. RDL proved to be powerful, but too slow. TypedRuby was faster, but had bugs that would have required a near-rewrite to solve. So in November 2017, we began writing Sorbet from scratch. Six months later, in May 2018, Sorbet type checking became required in Stripe’s automated test suite. After another year of internal adoption, <a href="https://sorbet.org/blog/2019/06/20/open-sourcing-sorbet" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">we released Sorbet to the world</a> in June 2019.</p><p>In all that time a lot has changed—Sorbet has far more features today than we ever imagined back then. But there&#39;s been one constant driving force behind the project: building tools that make engineers working in Ruby more productive.</p><h2>Supercharged productivity in Ruby</h2><p>When we ask how Sorbet makes people more productive they tell us all sorts of things, but the most common theme is raw speed.</p><p>Sorbet gives near-instantaneous feedback while editing: for 80% of edits, it can finish reporting type errors in milliseconds, even in our multi-million line codebase. The longest error reporting wait times measure in seconds. Types aren&#39;t a replacement for tests, but few test suites are fast enough to run on every edit like Sorbet.</p><p>But there&#39;s more to it than just speed: Sorbet takes the toil out of understanding how code fits together. </p><p>On the day we rolled out the <a href="https://sorbet.org/blog/2022/01/06/open-sourcing-sorbet-vscode" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">Sorbet-powered VS Code extension</a> for Ruby, Justin Duke described the feeling better than anyone:</p><blockquote>
  <svg width="15" height="11" viewBox="0 0 15 11" xmlns="http://www.w3.org/2000/svg"><path d="M15 1.72c-1.96.95-2.94 2.07-2.94 3.36.83.1 1.53.44 2.07 1.02.55.58.82 1.25.82 2.01a2.81 2.81 0 0 1-2.8 2.89c-.9 0-1.68-.36-2.33-1.09a3.78 3.78 0 0 1-1-2.63c0-3.1 1.76-5.53 5.26-7.28L15 1.72zm-8.83 0c-1.97.95-2.96 2.07-2.96 3.36.85.1 1.55.44 2.1 1.02.54.58.82 1.25.82 2.01A2.82 2.82 0 0 1 3.3 11 3 3 0 0 1 .98 9.91 3.8 3.8 0 0 1 0 7.28C0 4.18 1.74 1.75 5.23 0l.94 1.72z" fill="#635BFF" fill-rule="nonzero"></path></svg>Having just spent the past few minutes clicking around VSCode like a kid on Christmas morning, I don&#39;t think it&#39;s an exaggeration to say that this might be the single largest improvement in my pay-server [Stripe&#39;s Ruby codebase] productivity since joining Stripe.
  
</blockquote><p>In a large codebase, Ruby can be uniquely hard to understand, even among other dynamically typed languages. What&#39;s worse is that it&#39;s hard to just, say, lint against the features that make Ruby hard to understand, because many of them are Ruby&#39;s most <em>loved</em> features. Here are some of the features that can make a Ruby codebase hard to unravel:</p><p><strong>Ruby lacks import statements</strong> (like those in Python or JavaScript), which bind global names to file-scoped names. Instead, Ruby provides <code>require</code> statements, which merely run other Ruby code. This mechanism works kind of like <code>#include</code> statements in C and C++: a single <code>require</code> statement might hide implicit calls to hundreds of other <code>require</code> statements.</p><p>But this feature enables Rails’ famous “convention over configuration” approach to project layouts, which many people love about it, you don&#39;t <em>have</em> to import files in Rails, you can just reference the code you want to reference.</p><p><strong>Ruby encourages factoring code into modules</strong>, which can then be mixed into classes or even other modules. When used well, modules can help organize code into composable, testable units. </p><p>But on the other hand, overuse of modules obscures where a method is defined behind a deep ancestor hierarchy. New Stripe engineers working in our codebase frequently struggled to find a method’s definition when it came into scope from behind multiple layers of modules.</p><p><strong>Ruby embraces metaprogramming</strong>, which is when methods and objects are dynamically created by code itself, instead of directly by the programmer. Concretely, this means that while some methods are written literally like <code>def invoices; ...; end</code>, others are defined dynamically by calling a library function like <code>has_many(:invoices)</code>. Metaprogramming as a way to share code is one of the biggest reasons why projects like Rails have been so successful.</p><p>Unfortunately, metaprogramming is very opaque. It prevents simple regular expression searches from surfacing method definitions. Once a definition is found, the programmer still has to trace through code to know things like what arguments the method takes.</p><p>We built Sorbet to make it easy to navigate and understand a codebase without having to give up these features people love about Ruby. The key, more than just reporting type errors quickly, is to offer a powerful editor extension, which provides ever-present answers to common questions. The answer to “where is this class defined?” is a click away, not hidden behind multiple <code>require</code> statements. “How am I supposed to use this method?” fades as a flick of the cursor reveals the method&#39;s types and documentation, replacing a lengthy crawl through a class&#39;s transitive mixins. Instant responses from Sorbet mean less time toiling and more time discovering.</p><p>Building Sorbet in a way where it delivers type errors and IDE responses so fast comes from a set of design choices we made early on in its development. First, Sorbet is written in C++, not Ruby. To quote Nelson Elhage, one of the founding members of the team, &#34;Writing in C++ doesn&#39;t automatically make your program fast, and a program does not need to be written in C++ to be fast. However, using C++ well gives an experienced team a fairly unique set of tools to write high-performance software.&#34; C++ gives us great baseline performance and a lot of headroom for further improvement when we decide that it&#39;s critical to make a given component of Sorbet fast.</p><p>Another key element of why Sorbet is fast is that we deliberately chose a simple type inference algorithm. Specifically, Sorbet only does local type inference, so the result of type checking one method never affects the result of type checking another method. This inference algorithm is a pure function of the code inside a method and Sorbet&#39;s immutable indexes of what&#39;s defined where. Put this all together, and Sorbet&#39;s inference algorithm is embarrassingly parallel, scaling to as many cores as the machine has available while being able to use fast shared memory instead of copying large data structures.</p><h2>A bedrock for engineering values</h2><p>In addition to the productivity boost, an unintentional benefit to come out of adopting Sorbet has been its cultural impact. In a fast-growing company, communicating and codifying cultural norms can be a full time job on its own! Sorbet lends concrete structure to some of Stripe&#39;s engineering norms.</p><p>Consider the cultural norm “Stripe should grow <strong>more</strong> reliable over time.” Despite our best efforts, production incidents happen—our goal when an incident happens is to make sure the same one doesn&#39;t happen again. After years of using Sorbet, Stripe engineers reflexively reach for type annotations as a preventative tool when doing incident remediations. </p><p>As an aside, it&#39;s interesting to reflect on the classes of problems that simply don&#39;t happen at Stripe anymore (or if they do, they happen exceedingly rarely). For example: typos that used to manifest as <code>NameError: uninitialized constant</code> exceptions in production have been entirely replaced by static type errors. But even some more subtle problems are absent, like this one:</p><p>Does this method need to be passed a string invoice ID, or a full invoice object? Scanning the implementation for context clues can sometimes help, but type annotations replace guesswork with machine-checked assurances:</p><p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Aclass%20Invoice%0A%20%20%23%20...%0Aend%0A%0Asig%20%7Bparams%28invoice%3A%20Invoice%2C%20paid%3A%20T%3A%3ABoolean%29.void%7D%0Adef%20update_invoice%28invoice%2C%20paid%29%0A%20%20%23%20...%0Aend%0A%0A%23%20error%3A%20Expected%20%60Invoice%60%20but%20found%20%60String%60%20for%20argument%20%60invoice%60%0Aupdate_invoice%28&#39;in_1KZ7eP2eZvKYlo2C3B98SLc9&#39;%2C%20true%29" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">View in the Sorbet Playground →</a></p><p>This brings up another norm: “public interfaces should have up-to-date documentation.” For this we use a clever trick about how Sorbet&#39;s <a href="https://sorbet.org/docs/type-annotations#type-annotations-and-strictness-levels" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">strictness levels</a> work. Sorbet activates in files with <code># typed: true</code> comments at the top of the file, but only in a “best-effort” mode: type annotations aren&#39;t required and all methods behave as though their arguments were annotated with <code>T.untyped</code>. But by trading up to <code># typed: strict</code>, Sorbet stops assuming <code>T.untyped</code> and instead requires signatures for all methods.</p><p>To encourage this, Stripe’s continuous integration (CI) system looks through all code changes and leaves a “Stripe code quality score” in a comment on the pull request, like this one:</p><figure data-asset-count="1">
  <div>
  <picture>
      
        <source srcset="https://images.ctfassets.net/fzn2n1nzq965/5m2hOHqiIl1pEo2OO4eh6x/36ef24d2ee31911f1c03cc9ae956266a/03-code-quality-comment.png?w=1620&amp;q=80&amp;fm=webp" type="image/webp"/>
      

      

      <img alt="Blog &gt; Sorbet &gt; Code quality image" src="
        
          https://images.ctfassets.net/fzn2n1nzq965/5m2hOHqiIl1pEo2OO4eh6x/36ef24d2ee31911f1c03cc9ae956266a/03-code-quality-comment.png?w=1620&amp;q=80
        
      " width="1600" height="987" loading="lazy"/>
    </picture>
</div>
  
</figure><p>The score is reported as a weighted sum of signals, where a smaller score is better. There are a lot of inputs to the score, and we hide the ones that don’t change in a given pull request, but the one relevant to Sorbet in the picture above reads, “Number of non-test files which are not strictly typed (typed below <code>strict</code>).” This means both the author and reviewer get a heads up when new files aren&#39;t using <code># typed: strict</code>, reminding them that at Stripe we really prefer all Ruby code to be type-annotated. After almost 4 years of Sorbet at Stripe, 85% of all non-test files opt into <code># typed: strict</code> (and for that matter, over 95% of all files are <code># typed: true</code>).</p><p>We often say that most of Stripe&#39;s engineers haven&#39;t been hired yet. Tooling like Sorbet encodes lessons learned over the years and helps teach these lessons to new engineers in a hands-on environment. As we continue to grow, especially distributed around the globe, Sorbet will continue to serve as a concrete reference point for new and old coworkers to align on shared engineering values.</p><p>Ruby fits in alongside a handful of other languages in use at Stripe. Stripe is also deeply investing in building new product backends in Java, building delightful frontend experiences with TypeScript, and various pieces of infrastructure in Go. Stripe commits to staffing high quality development experiences across all of these languages, not just Ruby. Making strategic investments in tooling ensures engineers at Stripe write code that is safe and fast as we scale.</p><p>After all this time, Sorbet is still gaining features, performance improvements, and bug fixes. We love that Sorbet lets us enhance Ruby&#39;s natural productivity while helping shape Stripe&#39;s code to be resilient and understandable as we grow. As we approach 5 years since Sorbet&#39;s conception, we can&#39;t wait to see where the next 5 years will lead!</p><p>Sorbet is written in C++ and compiles to WebAssembly, which means you can <a href="https://sorbet.run/" data-js-controller="AnalyticsButton" data-analytics-category="Links" data-analytics-action="Clicked" data-analytics-label="">try it out in your browser.</a> Below you’ll find a link to the Sorbet Playground.</p><section>
  <section>
  <section>
  
  
    
  

  
    <p>Our docs guide you through the process of adding Sorbet to your codebase.</p>
  

  
    
  

  
</section>
</section>
  
    <section>
  <section>
  
  
    
  

  
    <p>Play around with Sorbet’s type system and editor features, right in your browser.</p>
  

  
    
  

  
</section>
</section>
  
    <section>
  <section>
  
  
    
  

  
    <p>Come chat with other Sorbet users, working on large and small codebases alike.</p>
  

  
    
  

  
</section>
</section>
</section>
        
  </section></div>
  </body>
</html>
