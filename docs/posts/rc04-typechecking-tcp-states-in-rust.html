<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stace.dev/rc-04-typechecking-tcp-states-in-rust/">Original</a>
    <h1>RC04: Typechecking TCP states in Rust</h1>
    
    <div id="readability-page-1" class="page"><div><article itemscope="" itemtype="http://schema.org/Article"><header><p>November 25, 2023</p></header><section><p>
I&#39;m attending the Fall 2 batch at <a href="https://www.recurse.com/scout/click?t=4b09801ab494151291278015fdbdd197">Recurse Center</a>! Posts in this series cover things I&#39;m working on or find interesting during my time here.
</p>
<p>I’ve been working on writing a toy TCP implementation in Rust to learn more about how TCP works (and to become more proficient at Rust). Unlike UDP, TCP is <a href="https://en.wikipedia.org/wiki/Connection-oriented_communication">connection oriented</a>. Before a TCP socket can be used to send and receive data, the socket first needs to establish a connection with the remote host by initiating a three-way handshake. The socket is also expected to close the connection once there’s no more data to send.</p>
<h2>What do TCP states tell us?</h2>
<p>To model these connection establishment, data transfer, and connection termination phases of the socket, TCP has various states, as defined in <a href="https://datatracker.ietf.org/doc/html/rfc793">RFC793</a>, that indicate its position in the lifecycle. These positions indicate the operations that the socket is allowed to do and what specific packets it might need to await from the remote host. For example, the TCP socket cannot send application data to the remote host before it is in the <em>Established</em> state. Additionally, state transitions occur in response to a well-defined set of events, triggered either by application-level or user actions, or an incoming segment from the remote server.</p>
<p><span>
      <span></span>
  <img alt="tcp states" title="tcp states" src="https://stace.dev/static/7b2bbf67a42f8501783efc518fd7b4ed/fcda8/tcp-states.png" srcset="/static/7b2bbf67a42f8501783efc518fd7b4ed/12f09/tcp-states.png 148w,
/static/7b2bbf67a42f8501783efc518fd7b4ed/e4a3f/tcp-states.png 295w,
/static/7b2bbf67a42f8501783efc518fd7b4ed/fcda8/tcp-states.png 590w,
/static/7b2bbf67a42f8501783efc518fd7b4ed/d48f1/tcp-states.png 796w" sizes="(max-width: 590px) 100vw, 590px" loading="lazy" decoding="async"/>
    </span></p>
<p>A simplified TCP state diagram. Source: Wikipedia’s <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Protocol_operation">page on TCP</a>.</p>
<h2>A first approach</h2>
<p>My initial instinct at implementing TCP states was to use a Rust enum. Then, I’d use an if-statement or match-statement to determine the current state before proceeding.</p>
<div data-language="rust"><pre><code><span>enum</span> <span>TcpState</span> <span>{</span>
    <span>Closed</span><span>,</span>
    <span>SynSent</span><span>,</span>
    <span>Established</span><span>,</span>
    
<span>}</span>

<span>struct</span> <span>TcpStream</span> <span>{</span>
    source<span>:</span> <span>u16</span><span>,</span>
    state<span>:</span> <span>TcpState</span><span>,</span>
<span>}</span>

<span>impl</span> <span>TcpStream</span> <span>{</span>
    <span>fn</span> <span>write</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>usize</span><span>,</span> <span>&amp;</span><span>&#39;static</span> <span>str</span><span>&gt;</span> <span>{</span>
        <span>match</span> <span>self</span><span>.</span>state <span>{</span>
            <span>Closed</span> <span>=&gt;</span> <span>Err</span><span>(</span><span>&#34;Invalid state.&#34;</span><span>)</span><span>,</span>
            <span>Established</span> <span>=&gt;</span> <span>todo!</span><span>(</span><span>&#34;Implement writing data here.&#34;</span><span>)</span><span>,</span>
            
        <span>}</span>
    <span>}</span>
<span>}</span></code></pre></div>
<p>This works, but it’ll require the code to check the TCP connection’s state every time before performing an action. This also results in additional nesting and CPU operations performed (at runtime). And if a user attempts to call a method that doesn’t work with the current state, they’ll get a runtime error, which is almost always <em>eventually</em> less fun to deal with than a compile time error.</p>
<h2>Modelling TCP states using type parameters</h2>
<p>While reading <a href="https://rust-for-rustaceans.com/">Rust for Rustaceans</a>, I encountered an intriguing pattern that enabled encoding and enforcing allowed methods using the type checker<sup id="fnref-1"><a href="#fn-1">1</a></sup>. This is done using type parameters.</p>
<div data-language="rust"><pre><code><span>pub</span> <span>struct</span> <span>Closed</span><span>;</span>
<span>pub</span> <span>struct</span> <span>Established</span> <span>{</span>
    source<span>:</span> <span>u16</span><span>,</span>
    
<span>}</span>

<span>pub</span> <span>struct</span> <span>TcpStream</span><span>&lt;</span><span>State</span><span>&gt;</span> <span>{</span>
    socket_addr_v4<span>:</span> <span>SocketAddrV4</span><span>,</span>
    state<span>:</span> <span>State</span><span>,</span>
<span>}</span>

<span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>TcpStream</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>peer_addr</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>io<span>::</span></span><span>Result</span><span>&lt;</span><span>SocketAddrV4</span><span>&gt;</span> <span>{</span>
        <span>Ok</span><span>(</span><span>self</span><span>.</span>socket_addr_v4<span>)</span>
    <span>}</span>
<span>}</span>

<span>impl</span> <span>TcpStream</span><span>&lt;</span><span>Closed</span><span>&gt;</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>connect</span><span>&lt;</span><span>T</span><span>:</span> <span>ToSocketAddrs</span><span>&gt;</span><span>(</span>
        addr<span>:</span> <span>T</span><span>,</span>
    <span>)</span> <span>-&gt;</span> <span>io<span>::</span></span><span>Result</span><span>&lt;</span><span>TcpStream</span><span>&lt;</span><span>Established</span><span>&gt;&gt;</span> <span>{</span>
        
    <span>}</span>
<span>}</span>

<span>impl</span> <span>TcpStream</span><span>&lt;</span><span>Established</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>close</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>&amp;</span><span>&#39;static</span> <span>str</span><span>&gt;</span> <span>{</span>
        
    <span>}</span>
<span>}</span>

<span>impl</span> <span>io<span>::</span></span><span>Write</span> <span>for</span> <span>TcpStream</span><span>&lt;</span><span>Established</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>write</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> buf<span>:</span> <span>&amp;</span><span>[</span><span>u8</span><span>]</span><span>)</span> <span>-&gt;</span> <span>io<span>::</span></span><span>Result</span><span>&lt;</span><span>usize</span><span>&gt;</span> <span>{</span>
        
    <span>}</span>
<span>}</span></code></pre></div>
<p>In the example code above, <code>TcpStream</code> is a struct that expects a type parameter <code>State</code>, which we use to represent the TCP states <em>Closed</em> and <em>Established</em>. The method <code>peer_addr</code> is available to <code>TcpStream</code> in any state, while <code>close</code> can only be called by <code>TcpState</code> when it’s <code>Established</code>. Attempting to call <code>close</code> in other non-<em>Established</em> <code>TcpState</code>s will result in a type error during compilation.</p>
<p>This is rather neat since we’ve eliminated the runtime checking of TCP state altogether and it’s now much clearer which methods are allowed in which <code>TcpStream</code> states. An additional bonus is that the allowed state transitions are now enforced by the typechecker.</p>
<p>Thus far, one issue that I’ve encountered from this approach is that the compiler prohibits a specialized implementation for the <code>Drop</code> trait <sup id="fnref-2"><a href="#fn-2">2</a></sup>. For example, writing</p>
<div data-language="rust"><pre><code><span>impl</span> <span>Drop</span> <span>for</span> <span>TcpStream</span><span>&lt;</span><span>Established</span><span>&gt;</span> <span>{</span>
    <span>fn</span> <span>drop</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span>
        
    <span>}</span>
<span>}</span></code></pre></div>
<p>will result in an error. There seem to be good reasons for this (see <a href="https://github.com/rust-lang/rust/issues/8142">here</a> and <a href="https://rust-lang.github.io/rfcs/0769-sound-generic-drop.html">here</a>), and I haven’t quite figured out a workaround for this yet that I like.</p>
<p>If this sounds interesting, Cliff Biffle gives a more detailed and thorough walkthrough on this pattern in his blog post <a href="http://cliffle.com/blog/rust-typestate/">here</a>.</p>
</section><hr/><div><div data-gatsby-image-wrapper=""><p><img aria-hidden="true" data-placeholder-image="" decoding="async" src="data:image/jpeg;base64,/9j/2wBDAAIBAQEBAQIBAQECAgICAgQDAgICAgUEBAMEBgUGBgYFBgYGBwkIBgcJBwYGCAsICQoKCgoKBggLDAsKDAkKCgr/2wBDAQICAgICAgUDAwUKBwYHCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgr/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAcGCAX/xAAYAQADAQEAAAAAAAAAAAAAAAADBgcEBf/aAAwDAQACEAMQAAAB5+6bhtZ5++dPHDFPtWUJf0gnrB//xAAbEAABBQEBAAAAAAAAAAAAAAAFAgMEBgcBAP/aAAgBAQABBQIG+rssI4ajL2TqX7aEDT6g1W7j22K0xTTdoJWgqS9n8t6Ga0uK0q1//8QAIBEAAgEBCQAAAAAAAAAAAAAAAQIAAwQREhQiMUFisf/aAAgBAwEBPwF8u9Fnxal4iMxQS2Ei49h6INp//8QAHxEAAgICAQUAAAAAAAAAAAAAAQIAAwQRMRITIaGy/9oACAECAQE/AbabAmmr8MNg69xUWtemYCg42jx2z8wcT//EACcQAAIBBAIABAcAAAAAAAAAAAECAwAEBRESIRMxQVEUIzJxgZGh/9oACAEBAAY/ArySKFpG8IhY1PmTIo1/aixWTv8AEzW93CyqthMztbOB0GJ6O9EfcVEIo9CPGwJr20tXefvTEESDWo/mPy5A/SPL3pcbZ5NpZGJk004ZeK+qLoapvhmJQwIQW9equMlJIqPJcueMQ0o711+qxVzERs5JVK66IkADD87qVOwEjRVC9aGq/8QAHBABAAMAAwEBAAAAAAAAAAAAAQARITFBUWGB/9oACAEBAAE/Ic7lFV4vi0v9jZuO8KMBWUdE6wAVtqZ9gVTNi96KgaeM9hgdDfQ1MC223qes+5I9eRrkLaVu6sLwoTjlAxpQVdHNSHdQMlE//9oADAMBAAIAAwAAABDkP8D/xAAbEQEAAgIDAAAAAAAAAAAAAAABACExURFxgf/aAAgBAwEBPxBKjQdtZytJk9jA6IwTwtsEgn//xAAZEQEAAwEBAAAAAAAAAAAAAAABESExAEH/2gAIAQIBAT8Qn1WSE0FHwNHG5mOIDyubkIpc152Xf//EABwQAQEBAQADAQEAAAAAAAAAAAERIQAxQVFhkf/aAAgBAQABPxBdr3WY54olZMMnEmZi3UCBTHr2lkWxbc2Sif37vGgIWgK12KSVzHW7SDu0LINLAeDGwrXS20Nm+vt7TdjtwpQBqrKq71zp0MMqlOt8bhwbxXKwEDD+9//Z" alt=""/></p><picture><source type="image/webp" data-srcset="/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/541c0/profile-pic.webp 64w,/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/57ec1/profile-pic.webp 128w" sizes="64px"/><img data-gatsby-image-ssr="" layout="fixed" data-main-image="" sizes="64px" decoding="async" loading="lazy" data-src="/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/df4a6/profile-pic.jpg" data-srcset="/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/df4a6/profile-pic.jpg 64w,/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/c7570/profile-pic.jpg 128w" alt="Stacey Tay"/></picture></div><p>Hi! I’m Stacey. Welcome to my<!-- --> <a href="https://stace.dev/">blog</a>. I’m a software engineer with an interest in programming languages and web performance. I also like making 🍵, reading fiction, and discovering random<!-- --> <a href="https://www.quora.com/What-should-everybody-know-about-tea-in-terms-of-health-benefits-or-detriments-carbon-footprint-quality-and-how-my-choice-of-tea-reflects-on-me/answer/Stacey-Tay-1">word origins</a>.</p></div></article></div></div>
  </body>
</html>
