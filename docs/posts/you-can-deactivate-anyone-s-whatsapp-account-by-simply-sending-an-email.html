<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://twitter.com/JakeMooreUK/status/1680962682726363136">Original</a>
    <h1>You can deactivate anyone&#39;s WhatsApp account by simply sending an email</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-07-13T00:00:00-07:00">July 13, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          7 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        

<p>A few weeks back I built an assembler in Python as a project for Nand2Tetris. When I was first plotting my approach and feeling ambitious, I thought, hey, maybe I should write this in C. But every time I thought about how to actually do that, it felt, well, impossible, so in the end I just used Python to do my dirty work.</p>

<p>Today, however, was Impossible Stuff Day, which meant it was time for me to dive in and see how far I could get.</p>



<p>The assembler’s job is to take an assembly program like this one from n2t</p>

<div><div><pre><code>@R0
D=M
@R1
D=D-M
@OUTPUT_FIRST
D;JGT
@R1
D=M
@OUTPUT_D
0;JMP
(OUTPUT_FIRST)
@R0
D=M
(OUTPUT_D)
@R2
M=D
(INFINITE_LOOP)
@INFINITE_LOOP
0;JMP
</code></pre></div></div>

<p>and translate it into machine language like this</p>

<div><div><pre><code>0000000000000000
1111110000010000
0000000000000001
1111010011010000
0000000000001010
1110001100000001
0000000000000001
1111110000010000
0000000000001100
1110101010000111
0000000000000000
1111110000010000
0000000000000010
1110001100001000
0000000000001110
1110101010000111
</code></pre></div></div>

<p>In the case of nand2tetris, we’re working with a 16-bit machine, which means each instuction is 16-bits long.</p>

<p>I wrote about assembly basics <a href="https://www.datadoodad.com/recurse%20center/RC26/">a few weeks ago</a> when building the CPU to this computer, which is the thing that actually does stuff with the 16-bit codes above. It’s worth revisiting some of the key ideas here.</p>

<p>In the nand2tetris dialect of assembly, there are two types of commands:</p>
<ul>
  <li>address commands (they start with <code>@</code> and load a value into the CPU’s A Register)</li>
  <li>compute commands (the other stuff, which tells the CPU which registers to read from, what to do with those values, and where to store the result)</li>
</ul>

<p>(There are also labels – the things in parentheses – which aren’t really commands but label line-numbers so that the program can jump around later on.)</p>

<p><strong>Address commands</strong> are the simplest, since converting them to 16-bit strings is a matter of converting the number to a 15-bit integer and sticking a <code>0</code> on the front end, which is what identifies the instruction as an A Instruction.</p>

<table>
  <tbody><tr>
    <td>0</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
    <td>v</td>
  </tr>
  <tr>
    <td>15</td>
    <td>14</td>
    <td>13</td>
    <td>12</td>
    <td>11</td>
    <td>10</td>
    <td>9</td>
    <td>8</td>
    <td>7</td>
    <td>6</td>
    <td>5</td>
    <td>4</td>
    <td>3</td>
    <td>2</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody></table>

<ul>
  <li><span>the most significant bit</span> (set to 0) identifies the instruction as an A instruction</li>
  <li>the least significant 15 bits represent a 15-bit unsigned integer</li>
</ul>

<p><strong>C Instructions</strong> are trickier, since they have three component parts that are encoded into various chunks of the 16-bit instruction string. For sample C-instructions like “AD=M+1” or “D;JEQ” or “D=1” or “D=M-1;JLT”:</p>
<ul>
  <li>everything to the left of the <code>=</code> is the destination part of the command – i.e., where the ALU’s output needs to go. (<strong>D</strong> is the destination in the command <code>D=M+1</code>.) This piece of information gets encoded as a 3-bit sequence and spans bits 3-5 of the resulting instruction string.</li>
  <li>everything to the right of the <code>=</code> and to the left of the <code>;</code> is the computation command – i.e., what computation the ALU performs on its inputs. (<strong>M+1</strong> is the computation in the command <code>D=M+1</code>.) There are a lot of options here, so this piece of information gets encoded as a 7-bit sequence and spans bits 6-12 of the resulting instruction string.</li>
  <li>everything right of the <code>;</code> is the jump command, which, if present, loads the value in the A Register (in this case representing a program line number) into the Program Counter, thus “jumping” to another line in the program. (<strong>JGT</strong> specifies the jump in the command <code>D;JGT</code>.) This piece of information gets encoded as a 3-bit sequence and spans bits 0-2 in the resulting instruction string.</li>
</ul>

<p>That’s complicated, but the whole thing looks like this:</p>

<table>
  <tbody><tr>
    <td>1</td>
    <td>x</td>
    <td>x</td>
    <td>a</td>
    <td>c</td>
    <td>c</td>
    <td>c</td>
    <td>c</td>
    <td>c</td>
    <td>c</td>
    <td>d</td>
    <td>d</td>
    <td>d</td>
    <td>j</td>
    <td>j</td>
    <td>j</td>
  </tr>
  <tr>
    <td>15</td>
    <td>14</td>
    <td>13</td>
    <td>12</td>
    <td>11</td>
    <td>10</td>
    <td>9</td>
    <td>8</td>
    <td>7</td>
    <td>6</td>
    <td>5</td>
    <td>4</td>
    <td>3</td>
    <td>2</td>
    <td>1</td>
    <td>0</td>
  </tr>
</tbody></table>

<ul>
  <li><span>the most significant bit</span> (set to 1) identifies the computation instruction as such</li>
  <li>bits 13 and 14 aren’t used</li>
  <li><span>the <b>a</b> bit</span> (bit 12) dictates whether the ALU should accept its <code>y</code> input from the A Register or from somewhere in Memory. This is effectively part of the computation instruction, which is why I grouped it that way in describing it above.</li>
  <li><span>the 6 <b>c</b> bits</span> (bits 6-11) specify the ALU function and are fed into its 6 function inputs <code>zx</code>, <code>nx</code>, <code>zy</code>, <code>ny</code>, <code>f</code>, and <code>no</code>.</li>
  <li><span>the 3 <b>d</b> bits</span> (bits 3-5) specify the destination for the ALU’s output, either <code>M</code> (memory), <code>A</code> (A register), or <code>D</code> (D register), or some combination of the three.</li>
  <li><span>the 3 <b>j</b> bits</span> (bits 0-2) specify any jump command based on whether the ALU’s output is <code>&lt; 0</code>, <code>&lt;= 0</code>, <code>== 0</code>, <code>&gt;= 0</code>, or <code>&gt; 0</code>.</li>
</ul>



<p>Right. So how far did I get porting my assembler to C today? Well, not really that far, I suppose. Basically, I handled the A-Instructions (and only in the case where A-Instructions consist of Number literals, at that) – i.e., taking a command like <code>@53</code> and emitting <code>0000000000110101</code> or a command like <code>@9</code> and emitting <code>0000000000001001</code>.</p>

<p>Here’s what my code in action looks like at the moment:</p>

<div><div><pre><code> 1:    @2 --&gt; 0000000000000010
 2:   D=A --&gt; C Command
 3:    @3 --&gt; 0000000000000011
 4: D=D+A --&gt; C Command
 5:    @0 --&gt; 0000000000000000
 6:   M=D --&gt; C Command
</code></pre></div></div>

<p>Of course the C Commands aren’t yet implemented, so just placeholders for now. But the A Instructions are doing their thing and doing it right.</p>

<p>It doesn’t seem like much, and I suppose it isn’t really. But getting here meant bumping into many, MANY walls, which meant making HUGE leaps.</p>

<p>Here are some highlights:</p>

<h3 id="reading-in-a-file">Reading in a file</h3>

<p>Here’s how.</p>

<div><div><pre><code><span>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</span>
<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span>
<span>{</span>
    <span>// exit if argc is not as expected</span>
    <span>if</span> <span>(</span><span>argc</span> <span>!=</span> <span>2</span><span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;usage: assembler &lt;path&gt;</span><span>\n</span><span>&#34;</span><span>);</span>
        <span>return</span> <span>EXIT_FAILURE</span><span>;</span> <span>// macro defined in stdlib.h</span>
    <span>}</span>

    <span>FILE</span> <span>*</span><span>f</span><span>;</span>
    <span>char</span> <span>line_in</span><span>[</span><span>256</span><span>];</span>
    <span>int</span> <span>linecount</span> <span>=</span> <span>0</span><span>;</span>

    <span>// open file passed as CL arg</span>
    <span>f</span> <span>=</span> <span>fopen</span><span>(</span><span>argv</span><span>[</span><span>1</span><span>],</span> <span>&#34;r&#34;</span><span>);</span>

    <span>// check for errors opening file</span>
    <span>if</span> <span>(</span><span>f</span> <span>==</span> <span>NULL</span><span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;Error opening file %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>argv</span><span>[</span><span>1</span><span>]);</span>
        <span>return</span> <span>EXIT_FAILURE</span><span>;</span>
    <span>}</span>

    <span>// loop through input file and parse</span>
    <span>while</span> <span>(</span><span>fgets</span><span>(</span><span>line_in</span><span>,</span> <span>sizeof</span> <span>line_in</span><span>,</span> <span>f</span><span>)</span> <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>

        <span>// remove trailing newline or carriage return</span>
        <span>line_in</span><span>[</span><span>strcspn</span><span>(</span><span>line_in</span><span>,</span> <span>&#34;</span><span>\n\r</span><span>&#34;</span><span>)]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>

        <span>// strip comments</span>
        <span>char</span> <span>*</span><span>comment_pos</span> <span>=</span> <span>strstr</span><span>(</span><span>line_in</span><span>,</span> <span>&#34;//&#34;</span><span>);</span>
        <span>if</span> <span>(</span><span>comment_pos</span> <span>!=</span> <span>NULL</span><span>)</span>
            <span>*</span><span>comment_pos</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>

        <span>// do stuff if line not blank</span>
        <span>if</span> <span>(</span><span>line_in</span><span>[</span><span>0</span><span>]</span> <span>!=</span> <span>&#39;\0&#39;</span><span>)</span>
            <span>printf</span><span>(</span><span>&#34;%2d: %5s --&gt; &#34;</span><span>,</span> <span>++</span><span>linecount</span><span>,</span> <span>line_in</span><span>);</span> <span>// print line_in</span>
        <span>}</span>
    <span>}</span>

    <span>// close file</span>
    <span>fclose</span><span>(</span><span>f</span><span>);</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>All this does it read in the file passed along as a command-line argument and print it back out to stdout (along with a line number), stripping comments and removing blank lines as it does so.</p>

<p><code>fgets()</code> is the bread-and-butter of this version of a file reader, although I’ve been advised to consider <code>getline()</code>. To remove trailing newlines and carriage returns, I’m using <code>strcspn()</code> to reset intances of those with a string terminator. To strip comments, I’m using <code>strstr()</code> in a somewhat similar way to return a pointer to the location where a comment is found and reassigning that index a string terminator. As long as there’s something in the resulting line, (i.e., the first character isn’t <code>\0</code>), then I print it!</p>

<h3 id="converting-integers-to-bitstrings">Converting integers to bitstrings</h3>

<p>Then there’s the issue of converting integers to bitstrings. Here’s how.</p>

<div><div><pre><code><span>void</span> <span>itob</span><span>(</span><span>uint16_t</span> <span>num</span><span>,</span> <span>char</span> <span>*</span><span>b</span><span>,</span> <span>int</span> <span>len</span><span>)</span>
<span>{</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span><span>=</span><span>0</span><span>;</span> <span>i</span><span>&lt;</span><span>len</span><span>;</span> <span>++</span><span>i</span><span>)</span>
    <span>{</span>
        <span>b</span><span>[</span><span>len</span><span>-</span><span>i</span><span>-</span><span>1</span><span>]</span> <span>=</span> <span>((</span><span>num</span> <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>1</span><span>)</span> <span>?</span> <span>&#39;1&#39;</span> <span>:</span> <span>&#39;0&#39;</span><span>;</span>
        <span>num</span> <span>&gt;&gt;=</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>void</span> <span>build_A_COMMAND</span><span>(</span><span>char</span> <span>*</span><span>line_in</span><span>,</span> <span>char</span> <span>*</span><span>line_out</span><span>)</span>
<span>{</span>
    <span>uint16_t</span> <span>i</span><span>;</span>

    <span>i</span> <span>=</span> <span>atoi</span><span>(</span><span>line_in</span> <span>+</span> <span>1</span><span>);</span>  <span>// convert line[1:] to int</span>
    <span>i</span> <span>=</span> <span>i</span> <span>&amp;</span> <span>0x7fff</span><span>;</span>         <span>// set MSB to 0 if i&gt;32767</span>
    <span>itob</span><span>(</span><span>i</span><span>,</span> <span>line_out</span><span>,</span> <span>16</span><span>);</span>  <span>// convert i to 15+1-bit string and save to output</span>
<span>}</span>
</code></pre></div></div>

<p>First, the <code>build_A_COMMAND()</code> function, which I call only after determining a line is an A Instruction (i.e., it starts with <code>@</code>). This function takes two strings as arguments – the assembly line it’s parsing and the binary line it’s building. It converts the input line (after the initial <code>@</code> character) to an 16-bit integer, then it resets the most significant bit to 0 (a hack-y way of ensuring that the most significant bit is 0, but some better error-handling is needed here to validate that the input integer is max 15-bits to begin with). Lastly it calls <code>itob()</code>, which is my fun little integer-to-bitstring converter.</p>

<p><code>itob()</code> checks to see if the least significant bit of the 16-bit integer above is 1, and then sets output string <code>b[15]</code> to 1 or 0 accordingly. Then it shifts the 16-bit integer right one bit and continues along for the full 16 bits, writing the bitstring from least [15] to most [0] significant bit as it goes.</p>


<p>I’ve already scaffolded out the various functions for building C Instructions. That means the next big step is sorting out some sort of lookup table to connect a command component (e.g., a jump command like <code>JNE</code>) to its binary equivalen (in this case <code>101</code>). In Python that was a simple matter of dictionaries. Here, I’m considering implementing a simple hash table to do that.</p>

<p>After that, it’s a matter of implementing functionality to handle symbols and labels, which requires another hash table.</p>


          

        

        
      </section>

      

      

      
  <nav>
    
      <a href="https://www.datadoodad.com/recurse%20center/RC41/" title="RC41. Building a DNS Resolver in C, Part 3: Implementing a toy version of inet_pton()
">Previous</a>
    
    
      <a href="https://www.datadoodad.com/recurse%20center/Assembler-Part-2/" title="Porting my assembler to C, Part II
">Next</a>
    
  </nav>

    </div></div>
  </body>
</html>
