<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.philipzucker.com/overload_bool/">Original</a>
    <h1>Symbolic Execution by Overloading __bool__</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>A few months ago I saw a talk on buildit, <a href="https://buildit.so/">https://buildit.so/</a> a really neat project that achieves staged metaprogramming as a C++ library. I love the central tenets of being in a mainstream language and not requiring a modified compiler. Right on, brother. One thing I came away with was a neat trick for getting non-overloadable syntax to be overloadable.</p>

<p>The interesting observation, which seems clear in hindsight (the best observations are), is that bool conversion <em>is</em> overloadable by writing a <code>__bool__</code> function on the Z3 class. With a little hackery, you can record all the paths through a piece of fairly pure python code. In this way you can simply achieve symbolic execution of python code without the usual expected rigamarole, or symbolically reflect python code as pure z3 expressions.</p>



<p>I have noted for a while after tinkering with <a href="https://okmij.org/ftp/ML/MetaOCaml.html">MetaOCaml</a> that metaprogramming z3 in python has a lot of the flavor of staged metaprogramming (big surprise? Maybe there’s not much content to the observation).</p>

<p>Some metaprogramming frameworks or styles look very different from unstaged code. You explicitly call all sorts of weird functions to construct code obects.</p>

<p>A really cool flavor of staged metaprogramming takes the unstaged code and adds some annotations to get staged code. The more similar the staged code looks to the original, the better. It probably takes some kind of language level feature like quotation, overloading, or introspection to achieve this.</p>

<p>A canonical example of staged metaprogramming is unrolling a power function (Ershov). Here is a simple example of an unstaged recursive power function operating on regular python ints.</p>

<div><div><pre><code><span>def</span> <span>mypow</span><span>(</span><span>x</span> <span>:</span> <span>int</span><span>,</span> <span>n</span> <span>:</span> <span>int</span><span>):</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>1</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>x</span> <span>*</span> <span>mypow</span><span>(</span><span>x</span><span>,</span> <span>n</span><span>-</span><span>1</span><span>)</span>
    
<span>assert</span> <span>mypow</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span> <span>==</span> <span>8</span>
<span>mypow</span><span>(</span><span>2</span><span>,</span><span>3</span><span>)</span>
</code></pre></div></div>



<p>You can instead use very similar looking code to codegen code-strings. The python <a href="https://docs.python.org/3/reference/lexical_analysis.html#f-strings">f-strings</a> feature (which are being continually improved. I’m hopeful for <a href="https://peps.python.org/pep-0750/">tagged strings</a>) make for some nice quotation mechanism. What is very cute is that the following looks just like the above. We interpret the parameter <code>n</code> as being known as “compile time”/static and the parameter <code>x</code> as being known as “run time”/dynamic.</p>

<div><div><pre><code><span>def</span> <span>Code</span><span>(</span><span>t</span><span>):</span><span>return</span> <span>str</span>
<span>def</span> <span>mypow</span><span>(</span><span>x</span> <span>:</span> <span>Code</span><span>(</span><span>int</span><span>),</span> <span>n</span> <span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>Code</span><span>(</span><span>int</span><span>):</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>&#34;1&#34;</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>f</span><span>&#34;</span><span>{</span><span>x</span><span>}</span><span> * </span><span>{</span><span>mypow</span><span>(</span><span>x</span><span>,</span> <span>n</span><span>-</span><span>1</span><span>)</span><span>}</span><span>&#34;</span>

<span>assert</span> <span>mypow</span><span>(</span><span>&#34;x&#34;</span><span>,</span><span>3</span><span>)</span>  <span>==</span> <span>&#34;x * x * x * 1&#34;</span>
<span>mypow</span><span>(</span><span>&#34;x&#34;</span><span>,</span><span>3</span><span>)</span>
</code></pre></div></div>



<p>A very similar but more structure thing occurs if we consider z3 expressions to be “code”. This actually gives us a tree thing to work with.</p>

<div><div><pre><code><span>import</span> <span>z3</span>
<span>def</span> <span>code</span><span>(</span><span>typ</span><span>):</span>
    <span>if</span> <span>typ</span> <span>==</span> <span>int</span><span>:</span>
        <span>return</span> <span>z3</span><span>.</span><span>IntSort</span><span>()</span>
<span>def</span> <span>mypow</span><span>(</span><span>x</span> <span>:</span> <span>Code</span><span>(</span><span>int</span><span>),</span> <span>n</span> <span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>Code</span><span>(</span><span>int</span><span>):</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>1</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>x</span> <span>*</span> <span>mypow</span><span>(</span><span>x</span><span>,</span> <span>n</span><span>-</span><span>1</span><span>)</span>

<span>x</span> <span>=</span> <span>z3</span><span>.</span><span>Int</span><span>(</span><span>&#34;x&#34;</span><span>)</span>
<span>assert</span> <span>mypow</span><span>(</span><span>x</span><span>,</span> <span>3</span><span>).</span><span>eq</span><span>(</span><span>x</span><span>*</span><span>(</span><span>x</span><span>*</span><span>(</span><span>x</span><span>*</span><span>1</span><span>)))</span>
<span>mypow</span><span>(</span><span>x</span><span>,</span><span>3</span><span>)</span>
</code></pre></div></div>

<p>x·x·x·1</p>

<p>The role of “static” compile time is played by regular python values abd the role of “dynamic” is played by Z3 expressions. You can mush around things between compile and run time, doing more or less in the solver. Things like unrolling loops have a correspondence in unrolling quantifiers. Because z3 uses python’s overloading, the same code can be used in the different ways with light annotations.</p>

<p>I think of there being 2 notable design points of symbolic execution / . Do you throw all the branches into the solver or do you throw only a single path/trace into the solver over many queries. The difference between these approaches could be seen as stage mushing. Is the return value of the branch condition a static or dynamic bool?</p>

<p>Some things in python really aren’t overloadable though. <code>if-then-else</code> blocks, <code>while</code>, chained comparison, <code>and or not</code> operators are all not overloadable. So you need to change things around to use <code>z3.If</code>. This is kind of a bummer.</p>

<h2 id="overloading-__bool__">Overloading <code>__bool__</code></h2>

<p>But actually, you can overload these features indirectly. When the conditions aren’t bools, the overloadable <code>__bool__</code> function is called on the class. You can monkey patch in one to z3.</p>

<p>This alone doesn’t quite get you there, you need to run the function in question multiple times to explore all the paths. This is a version of symbolic execution, which is of interest on its own.</p>

<p>You could probably do the same thing using the C++ Z3 bindings.</p>

<p>I find this particular interesting as a way of using python code as a DSL. For example, I was trying to use an “applicative” subset of python as a logic akin to how ACL2 uses a subset of common lisp <a href="https://www.philipzucker.com/applicative_python/">https://www.philipzucker.com/applicative_python/</a> but I was doing a traversal over the python AST, an ugly and verbose thing to do.</p>

<p>I’ve seen similar problems in the tensor compiling or MLIR worlds. People kind of want python syntax at least for playing around. It is quite difficult to get a maintainable system though.</p>

<div><div><pre><code><span>import</span> <span>random</span>
<span>from</span> <span>z3</span> <span>import</span> <span>*</span>
<span>def</span> <span>symexec</span><span>(</span><span>*</span><span>vs</span><span>,</span> <span>limit</span><span>=</span><span>100</span><span>):</span>
    <span>def</span> <span>wrapper</span><span>(</span><span>f</span><span>):</span>
        <span>trace</span> <span>=</span> <span>[]</span>
        <span>traces</span> <span>=</span> <span>[]</span>
        <span># a shared solver being pushed and popped is probably more efficient
</span>        <span>s</span> <span>=</span> <span>Solver</span><span>()</span>
        <span>def</span> <span>branch</span><span>(</span><span>self</span><span>):</span>
            <span># branch gets called on every branch (every time a z3 expression is asked to be converted to a concrete bool)
</span>            <span>s</span><span>.</span><span>push</span><span>()</span>
            <span>s</span><span>.</span><span>add</span><span>(</span><span>And</span><span>(</span><span>trace</span><span>))</span> <span># TODO: I could move push pop around to avoid this full push
</span>            <span># flip a coin. Probably that means any individual run will end.
</span>            <span># If there are no loops, being more deterministic is fine.
</span>            <span>if</span> <span>random</span><span>.</span><span>random</span><span>()</span> <span>&lt;</span> <span>0.5</span><span>:</span>
                <span>take</span> <span>=</span> <span>True</span>
            <span>else</span><span>:</span>
                <span>take</span> <span>=</span> <span>False</span>
            <span># Is it possible to take the branch?
</span>            <span>s</span><span>.</span><span>add</span><span>(</span><span>self</span> <span>==</span> <span>take</span><span>)</span>
            <span>res</span> <span>=</span> <span>s</span><span>.</span><span>check</span><span>()</span>
            <span>s</span><span>.</span><span>pop</span><span>()</span>
            <span>if</span> <span>res</span> <span>==</span> <span>sat</span><span>:</span>
                <span># It was possible to take the branch
</span>                <span>trace</span><span>.</span><span>append</span><span>(</span><span>self</span> <span>==</span> <span>take</span><span>)</span>
                <span>return</span> <span>take</span>
            <span>else</span><span>:</span>
                <span># it was not possible to take the branch
</span>                <span>trace</span><span>.</span><span>append</span><span>(</span><span>self</span> <span>==</span> <span>(</span><span>not</span> <span>take</span><span>))</span>
                <span>return</span> <span>not</span> <span>take</span>
        <span>BoolRef</span><span>.</span><span>__bool__</span> <span>=</span> <span>branch</span> <span># monkey patch in the __bool__ overload
</span>        <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>limit</span><span>):</span>
            <span>if</span> <span>s</span><span>.</span><span>check</span><span>()</span> <span>==</span> <span>unsat</span><span>:</span> <span># If no more branches possible, stop
</span>                <span>break</span>
            <span>trace</span> <span>=</span> <span>[]</span> <span># reset the trace
</span>            <span>res</span> <span>=</span> <span>f</span><span>(</span><span>*</span><span>vs</span><span>)</span> <span># run the function
</span>            <span># res = z3.simplify(res) # might be nice.
</span>            <span>traces</span><span>.</span><span>append</span><span>((</span><span>trace</span><span>,</span><span>res</span><span>))</span> <span># record the result of the run
</span>            <span>s</span><span>.</span><span>add</span><span>(</span><span>Not</span><span>(</span><span>And</span><span>(</span><span>trace</span><span>)))</span> <span># disallow exact trace again
</span>        <span>BoolRef</span><span>.</span><span>__bool__</span> <span>=</span> <span>None</span>
        <span>return</span> <span>traces</span>
    <span>return</span> <span>wrapper</span>




<span>@</span><span>symexec</span><span>(</span><span>z3</span><span>.</span><span>Int</span><span>(</span><span>&#34;x&#34;</span><span>))</span>
<span>def</span> <span>foo</span><span>(</span><span>x</span><span>):</span>
    <span>if</span> <span>x</span> <span>&gt;</span> <span>3</span><span>:</span>
        <span>if</span> <span>x</span> <span>==</span> <span>4</span><span>:</span>
            <span>return</span> <span>x</span>
        <span>else</span><span>:</span>
            <span>return</span> <span>x</span> <span>-</span> <span>2</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>x</span><span>*</span><span>3</span>
    
<span>foo</span>
</code></pre></div></div>

<div><div><pre><code>[([(x &gt; 3) == True, (x == 4) == True], x),
 ([(x &gt; 3) == True, (x == 4) == False], x - 2),
 ([(x &gt; 3) == False], x*3)]
</code></pre></div></div>

<p>We can get niceties like comparator chaining</p>

<div><div><pre><code><span>@</span><span>symexec</span><span>(</span><span>Int</span><span>(</span><span>&#34;x&#34;</span><span>),</span> <span>Int</span><span>(</span><span>&#34;y&#34;</span><span>))</span>
<span>def</span> <span>comparison_example</span><span>(</span><span>x</span><span>,</span><span>y</span><span>):</span>
    <span>return</span> <span>y</span> <span>-</span> <span>3</span> <span>&lt;</span> <span>x</span> <span>&lt;</span> <span>y</span> <span>+</span> <span>4</span> <span>or</span> <span>x</span> <span>&gt;</span> <span>3</span>
<span>comparison_example</span>
</code></pre></div></div>

<div><div><pre><code>[([(y - 3 &lt; x) == True, (x &lt; y + 4) == True], x &lt; y + 4),
 ([(y - 3 &lt; x) == False, (y - 3 &lt; x) == False], x &gt; 3),
 ([(y - 3 &lt; x) == True, (x &lt; y + 4) == False], x &gt; 3)]
</code></pre></div></div>

<p>Or match statements</p>

<div><div><pre><code><span>@</span><span>symexec</span><span>(</span><span>Int</span><span>(</span><span>&#34;x&#34;</span><span>))</span>
<span>def</span> <span>matcher</span><span>(</span><span>x</span><span>):</span>
    <span>match</span> <span>x</span><span>:</span>
        <span>case</span> <span>0</span><span>:</span>
            <span>return</span> <span>1</span>
        <span>case</span> <span>2</span><span>:</span>
            <span>return</span> <span>x</span> <span>+</span> <span>14</span>
        <span>case</span> <span>_</span><span>:</span>
            <span>return</span> <span>x</span> <span>*</span> <span>2</span> 
<span>matcher</span>
</code></pre></div></div>

<div><div><pre><code>[([(x == 0) == False, (x == 2) == False], x*2),
 ([(x == 0) == False, (x == 2) == True], x + 14),
 ([(x == 0) == True], 1)]
</code></pre></div></div>

<p>Or bounded whiles</p>

<div><div><pre><code><span>@</span><span>symexec</span><span>(</span><span>Int</span><span>(</span><span>&#34;x&#34;</span><span>))</span>
<span>def</span> <span>bwhile</span><span>(</span><span>x</span><span>):</span>
    <span>if</span> <span>x</span> <span>&gt;</span> <span>0</span> <span>and</span> <span>x</span> <span>&lt;</span> <span>10</span><span>:</span>
        <span>acc</span> <span>=</span> <span>0</span>
        <span>while</span> <span>x</span> <span>&gt;</span> <span>0</span><span>:</span>
            <span>x</span> <span>-=</span> <span>2</span>
            <span>acc</span> <span>+=</span> <span>x</span>
        <span>return</span> <span>acc</span>
<span>bwhile</span>
</code></pre></div></div>

<div><div><pre><code>[([(x &gt; 0) == False], None),
 ([(x &gt; 0) == True, (x &lt; 10) == True, (x &gt; 0) == True, (x - 2 &gt; 0) == False],
  0 + x - 2),
 ([(x &gt; 0) == True,
   (x &lt; 10) == True,
   (x &gt; 0) == True,
   (x - 2 &gt; 0) == True,
   (x - 2 - 2 &gt; 0) == False],
  0 + x - 2 + x - 2 - 2),
 ([(x &gt; 0) == True,
   (x &lt; 10) == True,
   (x &gt; 0) == True,
   (x - 2 &gt; 0) == True,
   (x - 2 - 2 &gt; 0) == True,
   (x - 2 - 2 - 2 &gt; 0) == True,
   (x - 2 - 2 - 2 - 2 &gt; 0) == False],
  0 + x - 2 + x - 2 - 2 + x - 2 - 2 - 2 + x - 2 - 2 - 2 - 2),
 ([(x &gt; 0) == True, (x &lt; 10) == False], None),
 ([(x &gt; 0) == True,
   (x &lt; 10) == True,
   (x &gt; 0) == True,
   (x - 2 &gt; 0) == True,
   (x - 2 - 2 &gt; 0) == True,
   (x - 2 - 2 - 2 &gt; 0) == True,
   (x - 2 - 2 - 2 - 2 &gt; 0) == True,
   (x - 2 - 2 - 2 - 2 - 2 &gt; 0) == False],
  0 +
  x - 2 +
  x - 2 - 2 +
  x - 2 - 2 - 2 +
  x - 2 - 2 - 2 - 2 +
  x - 2 - 2 - 2 - 2 - 2),
 ([(x &gt; 0) == True,
   (x &lt; 10) == True,
   (x &gt; 0) == True,
   (x - 2 &gt; 0) == True,
   (x - 2 - 2 &gt; 0) == True,
   (x - 2 - 2 - 2 &gt; 0) == False],
  0 + x - 2 + x - 2 - 2 + x - 2 - 2 - 2)]
</code></pre></div></div>

<p>We can also seek unbounded whiles, but then the output will be incomplete.</p>

<div><div><pre><code><span>@</span><span>symexec</span><span>(</span><span>Int</span><span>(</span><span>&#34;x&#34;</span><span>),</span> <span>limit</span><span>=</span><span>5</span><span>)</span>
<span>def</span> <span>bfor</span><span>(</span><span>x</span><span>):</span>
    <span>acc</span> <span>=</span> <span>0</span>
    <span>while</span> <span>x</span> <span>&gt;</span> <span>0</span><span>:</span>
        <span>x</span> <span>-=</span> <span>1</span>
        <span>acc</span> <span>+=</span> <span>x</span>
    <span>return</span> <span>acc</span>
<span>bfor</span>
</code></pre></div></div>

<div><div><pre><code>[([(x &gt; 0) == False], 0),
 ([(x &gt; 0) == True, (x - 1 &gt; 0) == False], 0 + x - 1),
 ([(x &gt; 0) == True,
   (x - 1 &gt; 0) == True,
   (x - 1 - 1 &gt; 0) == True,
   (x - 1 - 1 - 1 &gt; 0) == False],
  0 + x - 1 + x - 1 - 1 + x - 1 - 1 - 1),
 ([(x &gt; 0) == True,
   (x - 1 &gt; 0) == True,
   (x - 1 - 1 &gt; 0) == True,
   (x - 1 - 1 - 1 &gt; 0) == True,
   (x - 1 - 1 - 1 - 1 &gt; 0) == False],
  0 + x - 1 + x - 1 - 1 + x - 1 - 1 - 1 + x - 1 - 1 - 1 - 1),
 ([(x &gt; 0) == True,
   (x - 1 &gt; 0) == True,
   (x - 1 - 1 &gt; 0) == True,
   (x - 1 - 1 - 1 &gt; 0) == True,
   (x - 1 - 1 - 1 - 1 &gt; 0) == True,
   (x - 1 - 1 - 1 - 1 - 1 &gt; 0) == False],
  0 +
  x - 1 +
  x - 1 - 1 +
  x - 1 - 1 - 1 +
  x - 1 - 1 - 1 - 1 +
  x - 1 - 1 - 1 - 1 - 1)]
</code></pre></div></div>



<p>If I want to be careful, I should make sure limit is not reached and also if the result is ever None, a return was being forgotten.</p>

<p>Could combine the technique with hypothesis to get concolic testing.</p>

<p>I could probably recapture loops by noticing we have returned to a previously seen position by inspecting the stack that called <code>__bool__</code>. It would be awkeard though. Maybe one could also do it by recording way more info in the overloads, but this is a lot more work.</p>

<p><a href="https://docs.python.org/3/library/codecs.html#codecs.register">https://docs.python.org/3/library/codecs.html#codecs.register</a>
<a href="https://docs.python.org/3/reference/import.html">https://docs.python.org/3/reference/import.html</a>
<a href="https://news.ycombinator.com/item?id=41322758">https://news.ycombinator.com/item?id=41322758</a> python’s preprocessor. Fiendish macros.</p>

<p>I have seen people do special stuff in jupyter. I don’t rerally liek any of that</p>

<p>Nelli
Ast. Rewrite if elif else -&gt; If
rewrite return to null?
Overloading kind of works, except
and or not to And Or Not
If
rewrite x &lt;= y &lt;= z</p>

<p>Some MLIR and other pytonh syntax using DSLs</p>

<ul>
  <li><a href="https://github.com/makslevental/mlir-python-extras">https://github.com/makslevental/mlir-python-extras</a></li>
  <li><a href="https://github.com/spcl/pymlir">https://github.com/spcl/pymlir</a> - lark parse into mirrored thing</li>
  <li><a href="https://mlir.llvm.org/OpenMeetings/2023-12-21-PyDSL.pdf">https://mlir.llvm.org/OpenMeetings/2023-12-21-PyDSL.pdf</a> pydsl</li>
  <li><a href="https://github.com/SRI-CSL/filia">https://github.com/SRI-CSL/filia</a></li>
  <li><a href="https://arxiv.org/pdf/2307.16080">https://arxiv.org/pdf/2307.16080</a> nelli <a href="https://github.com/makslevental/nelli">https://github.com/makslevental/nelli</a> hmm. archived.
Maybe these techniques could be useful for z3 reification.
Rewrite AST + rewrite bytecode + overloading</li>
</ul>

<p>exocompiler and others.
<a href="https://cap.csail.mit.edu/sites/default/files/research-pdfs/Codon-%20A%20Compiler%20for%20High-Performance%20Pythonic%20Applications%20and%20DSLs.pdf">https://cap.csail.mit.edu/sites/default/files/research-pdfs/Codon-%20A%20Compiler%20for%20High-Performance%20Pythonic%20Applications%20and%20DSLs.pdf</a> codon converts to llvm
<a href="https://github.com/exaloop/codon">https://github.com/exaloop/codon</a></p>

<p>could convert ifthenelse to <code>x if c else</code>.
Nah.</p>

<p>chococpy
codon
mypyc</p>

<p>buildit style</p>

<ul>
  <li><a href="https://buildit.so/">https://buildit.so/</a></li>
  <li><a href="https://intimeand.space/docs/buildit.pdf">https://intimeand.space/docs/buildit.pdf</a></li>
</ul>

<p>Thermometer continuations</p>

<ul>
  <li><a href="https://calwoo.github.io/posts/2020-02-12-thermometer_p1.html">https://calwoo.github.io/posts/2020-02-12-thermometer_p1.html</a></li>
  <li><a href="https://github.com/jkoppel/thermometer-continuations">https://github.com/jkoppel/thermometer-continuations</a></li>
  <li><a href="https://arxiv.org/abs/1710.10385">https://arxiv.org/abs/1710.10385</a> Capturing the Future by Replaying the Past</li>
</ul>

<p>dialectica and probing. Pierre Marie-Pedrot</p>

<p>Symbolic execution by overloading <strong>bool</strong></p>

<p>Honestly using C++ in this way might be on the table. It is not easy to symbolically execute C++. Klee of course. But klee is quite an effort.</p>

<p>Symcc has a partial evaluation vibe</p>

<p>Using the same idea for partial eval? The trace starts by setting some variables.
Concolic</p>

<p>Actually detecting the loops seems hard since it isn’t that we reach the loop again with the same expression.</p>

<p>Concolic by using hypothesis.
Decorator “partial evals”</p>

<p>What does Rosette really offer over python + z3? I’ve never been clear on that <a href="https://docs.racket-lang.org/rosette-guide/index.html">https://docs.racket-lang.org/rosette-guide/index.html</a>
It does over the racket make a dsl thing if you’re into that.</p>

<p>Could switch out for Not based form.</p>

<p>Tagging the code string with other metadata is probable quite useful.
You want it to fail early if the types make no sense.
But then you can’t use fstrings. :(</p>

<div><div><pre><code><span>from</span> <span>dataclasses</span> <span>import</span> <span>dataclass</span>
<span>from</span> <span>typing</span> <span>import</span> <span>TypeVar</span>
<span>T</span> <span>=</span> <span>TypeVar</span><span>(</span><span>&#39;T&#39;</span><span>)</span>
<span>@</span><span>dataclass</span>
<span>class</span> <span>Code</span><span>[</span><span>T</span><span>]:</span>
    <span>typ</span> <span>:</span> <span>T</span>
    <span>code</span> <span>:</span> <span>str</span>

    <span>def</span> <span>__add__</span><span>(</span><span>self</span><span>):</span>

</code></pre></div></div>

<div><div><pre><code><span>def</span> <span>mypow</span><span>(</span><span>x</span><span>:</span><span>int</span><span>,</span><span>n</span><span>:</span><span>int</span><span>)</span> <span>-&gt;</span> <span>int</span><span>:</span>
    <span>assert</span> <span>n</span> <span>&gt;=</span> <span>0</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>1</span>
    <span>else</span><span>:</span>
        <span>x</span> <span>*</span> <span>mypow</span><span>(</span><span>x</span><span>,</span><span>n</span><span>-</span><span>1</span><span>)</span>

<span># accumulator version?
</span>
<span># string version
# strings are a universal but somewhat structure free rep of code.
</span><span>Code</span> <span>=</span> <span>str</span>
<span>def</span> <span>mypow2</span><span>(</span><span>n</span><span>:</span><span>int</span><span>,</span> <span>x</span><span>:</span><span>Code</span><span>)</span> <span>-&gt;</span> <span>Code</span><span>:</span>
    <span>if</span> <span>x</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>&#34;1&#34;</span>
    <span>else</span><span>:</span>
        <span>f</span><span>&#34;</span><span>{</span><span>x</span><span>}</span><span> * </span><span>{</span><span>mypow2</span><span>(</span><span>x</span><span>,</span><span>n</span><span>-</span><span>1</span><span>)</span><span>}</span><span>&#34;</span>

<span>mypow</span> <span>=</span> <span>lambda</span> <span>x</span><span>,</span><span>n</span><span>:</span> <span>1</span> <span>if</span> <span>n</span> <span>&lt;=</span> <span>0</span> <span>else</span> <span>x</span> <span>*</span> <span>mypow</span><span>(</span><span>x</span><span>,</span><span>n</span><span>-</span><span>1</span><span>)</span>

<span>mypow</span> <span>=</span> <span>Function</span><span>(</span><span>&#34;mypow&#34;</span><span>,</span> <span>IntSort</span><span>(),</span> <span>IntSort</span><span>(),</span> <span>IntSort</span><span>())</span>
<span>mypow_def</span> <span>=</span> <span>ForAll</span><span>([</span><span>x</span><span>,</span><span>n</span><span>],</span> <span>mypow</span><span>(</span><span>n</span><span>,</span> <span>x</span><span>)</span> <span>==</span> <span>If</span><span>(</span><span>n</span> <span>&lt;=</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>x</span> <span>*</span> <span>mypow</span><span>(</span><span>n</span><span>-</span><span>1</span><span>,</span> <span>x</span><span>)))</span>

<span># Partially evaled
</span><span>def</span> <span>mypow</span><span>(</span><span>x</span><span>:</span><span>ExprRef</span><span>,</span> <span>n</span><span>:</span><span>int</span><span>)</span> <span>-&gt;</span> <span>ExprRef</span><span>:</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>IntVal</span><span>(</span><span>1</span><span>)</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>x</span> <span>*</span> <span>mypow</span><span>(</span><span>x</span><span>,</span><span>n</span><span>-</span><span>1</span><span>)</span>


</code></pre></div></div>

<div><div><pre><code><span>class</span> <span>Bool</span><span>():</span>
    <span>def</span> <span>__bool__</span><span>(</span><span>self</span><span>):</span>
        <span>print</span><span>(</span><span>&#34;asked&#34;</span><span>)</span>
        <span>return</span> <span>True</span>
    

<span>b</span> <span>=</span> <span>Bool</span><span>()</span>
<span>if</span> <span>b</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;yes&#34;</span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span>&#34;no&#34;</span><span>)</span>

<span>import</span> <span>z3</span>

<span>ctx</span> <span>=</span> <span>None</span>
<span>path</span> <span>=</span> <span>[]</span>
<span>s</span> <span>=</span> <span>Solver</span><span>()</span>
<span>def</span> <span>record_bool</span><span>():</span>
    <span>s</span><span>.</span><span>check</span><span>()</span>
    <span>path</span><span>.</span><span>append</span><span>()</span>

<span>z3</span><span>.</span><span>BoolRef</span><span>.</span><span>__bool__</span> <span>=</span> <span>lambda</span> <span>self</span><span>,</span> 
<span>def</span> <span>reify</span><span>(</span><span>f</span><span>,</span> <span>vs</span><span>):</span>
    <span>global</span> <span>ctx</span>
    <span>ctx</span> <span>=</span> <span>[</span><span>m</span><span>]</span>
    <span>while</span> <span>True</span><span>:</span>
        <span>retval</span> <span>=</span> <span>f</span><span>(</span><span>vs</span><span>)</span>
        
    <span>ctx</span> <span>=</span> <span>None</span>

<span>@</span><span>reify</span>
<span>def</span> <span>example</span><span>(</span><span>x</span><span>):</span>
    <span>if</span> <span>x</span> <span>==</span> <span>7</span><span>:</span>
        <span>return</span> <span>3</span>
    <span>else</span><span>:</span>
        <span>if</span> <span>x</span> <span>&gt;</span> <span>14</span><span>:</span>
            <span>return</span> <span>4</span>
        <span>else</span><span>:</span>
            <span>return</span> <span>5</span>
</code></pre></div></div>

<div><div><pre><code><span>from</span> <span>z3</span> <span>import</span> <span>*</span>
<span>import</span> <span>kdrag.smt</span> <span>as</span> <span>smt</span>
<span>traces</span> <span>=</span> <span>[]</span>
<span>trace</span>  <span>=</span> <span>[]</span>
<span>def</span> <span>reset</span><span>():</span>
    <span>global</span> <span>trace</span>

    <span>trace</span> <span>=</span> <span>[]</span>
<span>def</span> <span>record</span><span>(</span><span>self</span><span>):</span>
    <span>s</span> <span>=</span> <span>Solver</span><span>()</span>
    <span>for</span> <span>tr</span><span>,</span><span>res</span> <span>in</span> <span>traces</span><span>:</span>
        <span>s</span><span>.</span><span>add</span><span>(</span><span>smt</span><span>.</span><span>Not</span><span>(</span><span>smt</span><span>.</span><span>And</span><span>(</span><span>tr</span><span>)))</span> <span># we can&#39;t repeat the same trace.
</span>    <span>s</span><span>.</span><span>add</span><span>(</span><span>smt</span><span>.</span><span>And</span><span>(</span><span>trace</span><span>))</span> <span># currently this is true
</span>    <span>s</span><span>.</span><span>add</span><span>(</span><span>self</span><span>)</span> <span># bias towards taking the branch
</span>    <span>res</span> <span>=</span> <span>s</span><span>.</span><span>check</span><span>()</span>
    <span>if</span> <span>res</span> <span>==</span> <span>sat</span><span>:</span>
        <span>trace</span><span>.</span><span>append</span><span>(</span><span>self</span> <span>==</span> <span>True</span><span>)</span>
        <span>return</span> <span>True</span>
    <span>else</span><span>:</span>
        <span>trace</span><span>.</span><span>append</span><span>(</span><span>self</span> <span>==</span> <span>False</span><span>)</span>
        <span>return</span> <span>False</span>
<span>BoolRef</span><span>.</span><span>__bool__</span> <span>=</span> <span>record</span>
<span>x</span> <span>=</span> <span>Int</span><span>(</span><span>&#34;x&#34;</span><span>)</span>

<span>def</span> <span>foo</span><span>(</span><span>x</span><span>):</span>
    <span>if</span> <span>x</span> <span>&gt;</span> <span>3</span><span>:</span>
        <span>if</span> <span>x</span> <span>==</span> <span>4</span><span>:</span>
            <span>return</span> <span>x</span>
        <span>else</span><span>:</span>
            <span>return</span> <span>x</span><span>-</span><span>1</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>x</span><span>*</span><span>3</span>

<span>while</span> <span>True</span><span>:</span>
    <span>trace</span> <span>=</span> <span>[]</span>
    <span>res</span> <span>=</span> <span>foo</span><span>(</span><span>x</span><span>)</span>
    <span>if</span> <span>len</span><span>(</span><span>traces</span><span>)</span> <span>&gt;</span> <span>0</span> <span>and</span> <span>all</span><span>(</span> <span>c1</span><span>.</span><span>eq</span><span>(</span><span>c2</span><span>)</span> <span>for</span> <span>c1</span><span>,</span><span>c2</span> <span>in</span> <span>zip</span><span>(</span><span>traces</span><span>[</span><span>-</span><span>1</span><span>][</span><span>0</span><span>],</span><span>trace</span><span>)):</span>
        <span>break</span> 
    <span>traces</span><span>.</span><span>append</span><span>((</span><span>trace</span><span>,</span><span>res</span><span>))</span>
<span>traces</span>

<span># maybe a brute force is better?
# could rejoin cases
# could be way more efficient with sat solver queries.
# loop detection?
</span></code></pre></div></div>

<p>Hmm. Actually, doing it in order might be important for proper if then else resolution? No. I don’t think so.</p>



<div><div><pre><code>[v0] []
[v0] [([(v0 &gt; 3) == True, (v0 == 4) == True], v0)]
[v0] [([(v0 &gt; 3) == True, (v0 == 4) == True], v0), ([(v0 &gt; 3) == False], v0*3)]





[([(v0 &gt; 3) == True, (v0 == 4) == True], v0),
 ([(v0 &gt; 3) == False], v0*3),
 ([(v0 &gt; 3) == True, (v0 == 4) == False], v0 - 2)]
</code></pre></div></div>

<div><div><pre><code><span>@</span><span>symexec</span><span>(</span><span>IntSort</span><span>())</span>
<span>def</span> <span>comp</span><span>(</span><span>x</span><span>):</span>
    <span>return</span> <span>x</span> <span>+</span> <span>3</span> <span>&lt;</span> <span>x</span> <span>&lt;</span> <span>x</span> <span>-</span> <span>4</span> <span>or</span> <span>x</span> <span>&gt;</span> <span>3</span>
<span>comp</span>
</code></pre></div></div>

<div><div><pre><code>[v0] []





[([(v0 + 3 &lt; v0) == False, (v0 + 3 &lt; v0) == False], v0 &gt; 3)]
</code></pre></div></div>

<p>Some ideas about compressing making prettier the output.</p>

<p>We may wnat ot compile into if then else trees, then maybe how we’d arrange things is a big different.</p>

<div><div><pre><code><span>def</span> <span>lookup_trie</span><span>(</span><span>trie</span><span>,</span> <span>key</span><span>):</span>
    <span>node</span> <span>=</span> <span>trie</span>
    <span>for</span> <span>k</span> <span>in</span> <span>key</span><span>:</span>
        <span>node</span> <span>=</span> <span>node</span><span>.</span><span>get</span><span>(</span><span>k</span><span>)</span>
        <span>if</span> <span>node</span> <span>is</span> <span>None</span><span>:</span>
            <span>return</span> <span>None</span>
    <span>return</span> <span>node</span>

<span>def</span> <span>store_trie</span><span>(</span><span>trie</span><span>,</span> <span>key</span><span>,</span> <span>value</span><span>):</span>
    <span>node</span> <span>=</span> <span>trie</span>
    <span>for</span> <span>k</span> <span>in</span> <span>key</span><span>:</span>

        <span>if</span> <span>k</span> <span>not</span> <span>in</span> <span>node</span><span>:</span>
            <span>node</span><span>[</span><span>k</span><span>]</span> <span>=</span> <span>{}</span>
        <span>node</span> <span>=</span> <span>node</span><span>[</span><span>k</span><span>]</span>
    <span>node</span><span>[</span><span>&#34;result&#34;</span><span>]</span> <span>=</span> <span>value</span>

<span>def</span> <span>trace_trie</span><span>(</span><span>traces</span><span>):</span>
    <span>trie</span> <span>=</span> <span>{}</span>
    <span>for</span> <span>trace</span><span>,</span><span>res</span> <span>in</span> <span>traces</span><span>:</span>
        <span>print</span><span>(</span><span>trie</span><span>)</span>
        <span>store_trie</span><span>(</span><span>trie</span><span>,</span> <span>trace</span><span>,</span> <span>res</span><span>)</span>
    <span>return</span> <span>trie</span>

<span>def</span> <span>compress_trie</span><span>(</span><span>traces</span><span>):</span>
    <span># If only one path, compress away that node
</span>    <span># If all paths have same result, compress away.
</span>    <span># probably best to do bottom up
</span>    <span>pass</span>

<span>t</span> <span>=</span> <span>{}</span>
<span>store_trie</span><span>(</span><span>t</span><span>,</span> <span>&#34;abc&#34;</span> <span>,</span><span>3</span> <span>)</span>

<span>trace_trie</span><span>(</span><span>foo</span><span>)</span>
<span>t</span>
</code></pre></div></div>

<div><div><pre><code>{}
{(v0 &gt; 3) == True: {(v0 == 4) == True: {&#39;result&#39;: v0}}}
{(v0 &gt; 3) == True: {(v0 == 4) == True: {&#39;result&#39;: v0}}, (v0 &gt; 3) == False: {&#39;result&#39;: v0*3}}



---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

Cell In[29], line 34
     31 t = {}
     32 store_trie(t, &#34;abc&#34; ,3 )
---&gt; 34 trace_trie(foo)
     35 t


Cell In[29], line 22, in trace_trie(traces)
     20 for trace,res in traces:
     21     print(trie)
---&gt; 22     store_trie(trie, trace, res)
     23 return trie


Cell In[29], line 13, in store_trie(trie, key, value)
     10 node = trie
     11 for k in key:
---&gt; 13     if k not in node:
     14         node[k] = {}
     15     node = node[k]


TypeError: &#39;NoneType&#39; object is not callable
</code></pre></div></div>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
