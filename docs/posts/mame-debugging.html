<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mattgreer.dev/blog/mame-debugging/">Original</a>
    <h1>MAME Debugging</h1>
    
    <div id="readability-page-1" class="page"><p>Here are some tips and a small guide on how to use MAME for debugging more effectively</p><div><p>I&#39;ve been working on a ROM hack for the Neo Geo game Puzzle Bobble (video on it <a tabindex="0" href="https://www.youtube.com/watch?v=buq1Kh65goU">here</a>, github repo <a tabindex="0" href="https://github.com/city41/rotary-bobble">here</a>). The purpose of the hack is to replace the joystick controls with a rotary dial. The MAME debugger and its Lua scripting have been absolutely indispensable. Using these tools at first was overwhelming and kind of frustrating. But after I got the feel for them they made figuring out how the game works surprisingly easy. Here are some tips to help if you are overwhelmed too.</p><p><b>Hey!</b> I&#39;m not a MAME expert, and I&#39;ve only been using it on Neo Geo games. MAME is a massive program and supports thousands of games. So your experience may vary.</p> <p>Games usually run at 60 frames per second and do a <em>massive</em> amount of stuff very rapidly.
At first they&#39;re pretty much a complete brickwall; so much is going on, so many things
are changing, and either waaaaaay too fast if you let the game run on its own, or
waaaaaaay too slowly if you step through it line by line. Trying to learn anything
at all about them is <em>very</em> hard. This is where MAME comes in. The debugger and its
Lua scripting offer tactics you can use to spot patterns, find interesting and relevant
changes, and test theories. Frankly before tools like this existed I have no idea
how people made ROM hacks. Those people were superstars. Anyway, let&#39;s start with
the debugger.</p><h2 id="the-debugger">The Debugger<a aria-hidden="true" href="#the-debugger"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>The debugger is the real star of the show. To get access to it, add <code>-debug</code> to your MAME command line invocation. I don&#39;t believe the debugger can be accessed from the UI. <code>mame samsho1 -debug</code> for example.</p><p>When it first opens, you will see something like this</p><figure><img src="https://mattgreer.dev/_next/static/media/debuggerAtFirstOpen.9131e57a.png" alt="The MAME debugger as it appears when first launched"/><figcaption>The debugger as it appears when you first launch it</figcaption></figure><p>It starts with the game paused. To start the game type in <code>go</code> or press F5. To make the game pause again, type in <code>step</code> or press F11. Once paused, you can step through the code with...</p><ul><li>F11 - <strong>step into:</strong> mostly just moves to the next line of execution</li><li>F10 - <strong>step over:</strong> if the next line to execute is going to jump to subroutine, this lets you skip past it</li><li>shift+F11 - <strong>step out:</strong> if you are inside a subroutine, this lets you get back out to wherever it was called</li></ul><p>The left panel is the registers in the processor. The Neo Geo uses a Motorola 68k, and its registers like D0 through D7 (general purpose registers) and A0 through A7 (address registers) are shown. <code>PC</code> is the program counter, this is an address into the game&#39;s ROM that the processor is currently focused on. I don&#39;t use any of the other stuff in this pane.</p><p>The <code>dasm</code> window to the right shows where the program counter is currently at (in other words, what the game is currently executing). In the case of the Neo Geo, the BIOS is first to do anything, so here MAME is paused at <code>C11002</code>, the first instruction the BIOS will execute. This is because I just launched the game and have not given it a chance to run yet.</p><p>Down below is the general output window. This is where logging and results from computations show up.</p><h3 id="the-dasm-window">The DASM Window<a aria-hidden="true" href="#the-dasm-window"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>Invoking <code>Debug &gt; New DASM Window</code> or pressing <code>CTRL-D</code> will open the disassembly window. MAME can fully disassemble the machine code back to assembly. At least it can for the Motorola 68k and the Zilog Z80 (the two processors in the Neo Geo).</p><figure><img src="https://mattgreer.dev/_next/static/media/dasmWindow.30849226.png" alt="The disassembly window"/><figcaption>The disassembly window</figcaption></figure><p>The yellow highlighted line is currently where the program counter is and matches the DASM pane in the main debugger window. The real benefit to this window is being able to jump anywhere you want by entering an address.</p><figure><img src="https://mattgreer.dev/_next/static/media/dasmAtSpecificAddress.6d051f85.png" alt="The disassembly window at a chosen address"/><figcaption>The disassembly window at a chosen address</figcaption></figure><p>Here I haved entered <code>2f602</code> as the address. This routine is one of Puzzle Bobble&#39;s main routines it runs during gameplay. I look at the disassembly in this window often. After I have applied one of my hack patches, I often come into here and confirm it got applied as I expected.</p><h3 id="the-memory-window">The Memory Window<a aria-hidden="true" href="#the-memory-window"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p><code>Debug &gt; New Memory Window</code> or <code>CTRL-M</code> will open the memory window. This is the current RAM contents of the game. Things in here will change often as the game is running. You can start the game and just watch the changes as they happen. Sometimes just finding an active region of RAM is a first clue into something you want to dig into more.</p><figure><img src="https://mattgreer.dev/_next/static/media/memoryWindow.ecf08b2f.png" alt="The memory window"/><figcaption>The memory window</figcaption></figure><p>For example here I am looking at memory around <code>108212</code> while Puzzle Bobble&#39;s main gameplay is happening. These chunks of memory are what the main gameplay routines use. For example, <code>108262</code> is currently <code>22</code> (in hex, 34 in decimal). That is the shooter&#39;s current angle in the game</p><figure><img src="https://mattgreer.dev/_next/static/media/shooterAt22.ab306942.png" alt="Puzzle Bobble with the shooter at 34 degrees"/><figcaption>The shooter at 34 degrees. They aren&#39;t really &#34;degrees&#34;, but that&#39;s what I call them :)</figcaption></figure><h2 id="the-cheat-debugger">The Cheat debugger<a aria-hidden="true" href="#the-cheat-debugger"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>The cheat debugger is very useful, and often your first stop to understand something about a game. It was made to allow the creation of cheats like &#34;infinite lives&#34; or &#34;invincibility&#34;, and cheats are almost always just manipulating the game&#39;s running memory to pull off the effect.</p><p>My ROM hack changes the controls from using the joystick to using a rotary dial. So to get started, I wanted to know where the game stores the shooter&#39;s angle.</p><figure><img src="https://mattgreer.dev/_next/static/media/shooterChangesAngle.8a6bdb29.png" alt="Puzzle Bobble changing the angle of the shooter from 0 to 25"/><figcaption>Puzzle Bobble changing the angle of the shooter from 0 to 25</figcaption></figure><p>I used the cheat debugger to figure this out. First, initialize it. With the game at the main game play mode and paused in the debugger</p><p><code><p><span>cheatinit <wbr/>ub</span></p></code></p><p>This tells the cheat system to keep track of unsigned bytes in memory. Then I enter <code>go</code>, and press on the joystick once to move the shooter as little as possible.</p><p><code><p><span>step</span></p><p><span>cheatnext <wbr/></span><span>+</span><span></span></p></code></p><p>Since I pressed right, the shooter&#39;s angle probably increased by 1 or maybe 2 in memory. This command has the cheat system look at memory and find any bytes that increased. First run <code>step</code> to pause the game. Then <code>cheatnext +</code> to have MAME find the memory changes, and then <code>cheatlist</code> to show all the changes it found</p><p><code><p><span>114</span><span> <wbr/>cheats <wbr/>found</span></p><p><span></span><span>Address</span><span>=</span><span>100C9D <wbr/></span><span>Start</span><span>=</span><span>97</span><span> <wbr/></span><span>Current</span><span>=</span><span>B1</span><span></span></p><p><span></span><span>Address</span><span>=</span><span>101077</span><span> <wbr/></span><span>Start</span><span>=</span><span>00</span><span> <wbr/></span><span>Current</span><span>=</span><span>04</span><span></span></p><p><span></span><span>Address</span><span>=</span><span>101087</span><span> <wbr/></span><span>Start</span><span>=</span><span>00</span><span> <wbr/></span><span>Current</span><span>=</span><span>01</span><span></span></p><p><span></span><span>...</span><span></span></p></code></p><p>OK, 114 changes is a lot. From here I unpause the game, press right as lightly as possible, <code>step</code> to pause it, then <code>cheatnext +</code>. I do this a few times, and each time it finds fewer and fewer memory changes. That is good. The last time I got this</p><p><code><p><span>9</span><span> <wbr/>cheats <wbr/>found</span></p><p><span></span><span>&gt;</span><span>cheatlist</span></p><p><span></span><span>Address</span><span>=</span><span>101087</span><span> <wbr/></span><span>Start</span><span>=</span><span>00</span><span> <wbr/></span><span>Current</span><span>=</span><span>05</span><span></span></p><p><span></span><span>Address</span><span>=</span><span>105572</span><span> <wbr/></span><span>Start</span><span>=</span><span>50</span><span> <wbr/></span><span>Current</span><span>=</span><span>5C</span></p><p><span></span><span>Address</span><span>=</span><span>105578</span><span> <wbr/></span><span>Start</span><span>=</span><span>4C <wbr/></span><span>Current</span><span>=</span><span>54</span><span></span></p><p><span></span><span>Address</span><span>=</span><span>10568E <wbr/></span><span>Start</span><span>=</span><span>50</span><span> <wbr/></span><span>Current</span><span>=</span><span>5D</span></p><p><span></span><span>Address</span><span>=</span><span>105694</span><span> <wbr/></span><span>Start</span><span>=</span><span>4C <wbr/></span><span>Current</span><span>=</span><span>55</span><span></span></p><p><span></span><span>Address</span><span>=</span><span>108173</span><span> <wbr/></span><span>Start</span><span>=</span><span>7A <wbr/></span><span>Current</span><span>=</span><span>FC</span><span></span></p><p><span></span><span>Address</span><span>=</span><span>10825F <wbr/></span><span>Start</span><span>=</span><span>00</span><span> <wbr/></span><span>Current</span><span>=</span><span>07</span><span></span></p><p><span></span><span>Address</span><span>=</span><span>108263</span><span> <wbr/></span><span>Start</span><span>=</span><span>00</span><span> <wbr/></span><span>Current</span><span>=</span><span>0E</span></p><p><span></span><span>Address</span><span>=</span><span>10826D <wbr/></span><span>Start</span><span>=</span><span>00</span><span> <wbr/></span><span>Current</span><span>=</span><span>07</span><span></span></p></code></p><p><code>Start</code> is what the value at that address was when you first started the cheat system, way back with <code>cheatinit ub</code>. When I look through the changes, one in particular seems suspicious, <code>108263</code> because</p><ul><li>It has a small value, which I would expect as the angle of the shooter is small</li><li>It only increased each time, and only by a little bit, which matches with how I pressed right on the joystick</li><li>It is present in all <code>cheatlist</code>s. I would expect this, because I pressed right every time</li></ul><p>So I set the memory window to <code>108263</code> and then play the game and make the shooter go left and right, and sure enough, it goes up and down in exact step with my inputs. We have found the right memory location!</p><p>Actually the correct memory location is <code>108262</code>, because Puzzle Bobble stores the shooter angle as a word, not a byte. Not sure why, but it does.</p><p>All breakthroughs I have made in understanding the game first started with the cheat debugger.</p><h3 id="watchpoints">Watchpoints<a aria-hidden="true" href="#watchpoints"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>Watchpoints let you break into the debugger whenever memory is written to or read from. By itself this is rarely useful, because games interact with RAM <em>very</em> quickly.</p><p>A simple watchpoint would be <code>wpset 108262,1,w</code>. This will break into the debugger whenever Puzzle Bobble updates the shooter&#39;s angle. This is a great next step, because I want to start zeroing on the part of the code that is making shooter angle changes.</p><p>Watchpoints are more powerful and interesting when you add in conditions and actions. For example, <code>wpset 108262,1,w,b@10fd96 != 0</code> This says &#34;break into the debugger whenever 108262 is written to, and the byte at 10fd96 is not zero&#34;. <code>10fd96</code> on the Neo Geo is <code>BIOS_P1CURRENT</code>, a byte storing the current state of the joystick. If it&#39;s not zero, that means some kind of input has been received. Now when you run the game, it will only break back into the debugger when you first press right on the joystick.</p><p>Watchpoints can have conditionals as their 4th argument, like <code>b@10fd96 != 0</code> above. They can also have actions as their 5th argument, such as <code>{ printf &#34;value written: %x&#34;,wpdata }</code>, which will print the written value to the output window.</p><h4 id="some-useful-watchpoints">Some useful watchpoints<a aria-hidden="true" href="#some-useful-watchpoints"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4><p><code><p><span>wpset <wbr/></span><span>108262</span><span>,</span><span>1</span><span>,</span><span>w</span><span>,</span><span>,</span><span>{</span><span> <wbr/>printf <wbr/></span><span>&#34;108262 <wbr/>set <wbr/>with: <wbr/>%x&#34;</span><span>,</span><span>wpdata</span><span>;</span><span> <wbr/>g <wbr/></span><span>}</span><span></span></p></code></p><p>That double comma is not a typo, this watchpoint has no condition, so it is left blank.</p><p>whenever the shooter angle changes, write the value to the console and don&#39;t stop the debugger. You can separate actions with <code>;</code>, much like writing a program. <code>g</code> means &#34;go&#34;, ie don&#39;t break just let the game keep playing. <code>printf</code> works very similar to C&#39;s printf.</p><p><code><p><span>wpset <wbr/>3c000c</span><span>,</span><span>1</span><span>,</span><span>w</span><span>,</span><span>wpdata <wbr/></span><span>==</span><span> <wbr/></span><span>4</span><span>,</span><span>{</span><span> <wbr/>printf <wbr/></span><span>&#34;vblank <wbr/>ack&#34;</span><span>;</span><span> <wbr/>g <wbr/></span><span>}</span><span></span></p><p><span>wpset <wbr/></span><span>108212</span><span>,</span><span>1</span><span>,</span><span>w</span><span>,</span><span>,</span><span>{</span><span> <wbr/>printf <wbr/></span><span>&#34;108212 <wbr/>set <wbr/>with: <wbr/>%x <wbr/>at <wbr/>%x&#34;</span><span>,</span><span>wpdata</span><span>,</span><span>PC</span><span>;</span><span> <wbr/>g <wbr/></span><span>}</span><span></span></p><p><span>wpset <wbr/></span><span>108212</span><span>,</span><span>1</span><span>,</span><span>r</span><span>,</span><span>,</span><span>{</span><span> <wbr/>printf <wbr/></span><span>&#34;108212 <wbr/>read <wbr/>at: <wbr/>%x&#34;</span><span>,</span><span>PC</span><span>;</span><span> <wbr/>g <wbr/></span><span>}</span><span></span></p></code></p><p>Here I am setting up three watchpoints. All three print to the screen and let the game keep going. <code>3c000c</code> is the register the game writes to when acknowledging the vblank interrupt (ie, the system is now starting to draw the next frame). The other two are listening to reads and writes at <code>108212</code> and outputting where the writes came from (<code>PC</code> being the program counter).</p><p>This produces output like this</p><p><code><p><span>vblank <wbr/>ack</span></p><p><span></span><span>108212</span><span> <wbr/>read <wbr/>at</span><span>:</span><span> <wbr/>2E9BA</span></p><p><span></span><span>108212</span><span> <wbr/></span><span>set</span><span> <wbr/></span><span>with</span><span>:</span><span> <wbr/></span><span>0</span><span> <wbr/>at <wbr/>2E9BA</span></p><p><span></span><span>108212</span><span> <wbr/>read <wbr/>at</span><span>:</span><span> <wbr/>2F5C4</span></p><p><span></span><span>108212</span><span> <wbr/>read <wbr/>at</span><span>:</span><span> <wbr/>2F606</span></p><p><span></span><span>108212</span><span> <wbr/>read <wbr/>at</span><span>:</span><span> <wbr/>2F746</span></p><p><span>vblank <wbr/>ack</span></p><p><span></span><span>108212</span><span> <wbr/>read <wbr/>at</span><span>:</span><span> <wbr/>2E9BA</span></p><p><span></span><span>108212</span><span> <wbr/></span><span>set</span><span> <wbr/></span><span>with</span><span>:</span><span> <wbr/></span><span>0</span><span> <wbr/>at <wbr/>2E9BA</span></p><p><span></span><span>108212</span><span> <wbr/>read <wbr/>at</span><span>:</span><span> <wbr/>2F5C4</span></p><p><span></span><span>108212</span><span> <wbr/>read <wbr/>at</span><span>:</span><span> <wbr/>2F606</span></p><p><span></span><span>108212</span><span> <wbr/>read <wbr/>at</span><span>:</span><span> <wbr/>2F746</span></p><p><span>vblank <wbr/>ack</span></p><p><span></span><span>108212</span><span> <wbr/>read <wbr/>at</span><span>:</span><span> <wbr/>2E9BA</span></p><p><span></span><span>108212</span><span> <wbr/></span><span>set</span><span> <wbr/></span><span>with</span><span>:</span><span> <wbr/></span><span>0</span><span> <wbr/>at <wbr/>2E9BA</span></p><p><span></span><span>108212</span><span> <wbr/>read <wbr/>at</span><span>:</span><span> <wbr/>2F5C4</span></p><p><span></span><span>108212</span><span> <wbr/>read <wbr/>at</span><span>:</span><span> <wbr/>2F606</span></p><p><span></span><span>108212</span><span> <wbr/>read <wbr/>at</span><span>:</span><span> <wbr/>2F746</span></p><p><span></span><span>...</span><span></span></p></code></p><p>This is very useful information! &#34;vblank ack&#34; is just telling me a frame just started, so I know the next lines that follow are happening sequentially. Without the &#34;vblank ack&#34;, the other 5 lines would just be repeated over and over and I wouldn&#39;t really be able to tell which happened first within a frame.</p><p>This tells me that <code>2E9BA</code> is updating <code>108212</code> (this value is how far the shooter should move based on input. So if the player pressed right, this will be <code>1</code> to indicate the shooter should move one degree to the right). And then the other locations are reading in that value and doing things accordingly (like actually moving the shooter, changing animations, etc).</p><p>My ROM hack is about changing the input from using a joystick to a rotary dial. So I knew once <code>2E9BA</code> sets the shooter delta, I could safely inject my own code that would re-set the shooter delta based on what the rotary dial is doing, as long as I injected it before <code>2F5C4</code> and the rest read the value. I successfuly did that, and now my ROM hack allows the shooter to change using rotary controls, and the game really has no idea, everything else &#34;just works&#34; because this output told me no one else anywhere is changing this value. Having your hack &#34;play along&#34; with the rest of the game as much as possible is good, as you will get less bugs that way.</p><h3 id="breakpoints">Breakpoints<a aria-hidden="true" href="#breakpoints"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>Breakpoints are similar to watchpoints except they just stop whenever the program counter hits them. <code>bpset 2f602</code> will cause the game to break into the debugger whenever the game&#39;s CPU executes the instruction at <code>2f602</code> in the ROM.</p><p>Like watchpoints, they can have conditions and actions.</p><p><code><p><span>bpset <wbr/>2f602</span><span>,</span><span> <wbr/>b@10fd06 <wbr/></span><span>!=</span><span> <wbr/></span><span>0</span><span></span></p></code></p><p>Like above, this will only break when <code>BIOS_P1CURRENT</code> (which is <code>10fd06</code>) is not zero. So only breaks when some input has happened like pressing on the joystick (this trick is Neo Geo specific btw).</p><p><code><p><span>bpset <wbr/>2f602</span><span>,</span><span>,</span><span>{</span><span> <wbr/>printf <wbr/></span><span>&#34;shooter <wbr/>delta <wbr/>is: <wbr/>%d&#34;</span><span>,</span><span>b@</span><span>108212</span><span>;</span><span> <wbr/>g <wbr/></span><span>}</span><span></span></p></code></p><p>Whenever the game hits <code>2f602</code>, print out the current value of <code>108212</code> to the screen and let the game keep going.</p><h3 id="history">History<a aria-hidden="true" href="#history"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p><code>history</code> outputs the path the CPU took to get to where it&#39;s currently at. This is extremely useful. I mostly use it to find subroutines. For example here is a typical <code>history</code> listing</p><p><code><p><span>(</span><span>many <wbr/>many <wbr/>lines <wbr/>left <wbr/>out</span><span>)</span><span></span></p><p><span></span><span>...</span><span></span></p><p><span>02F5EA</span><span>:</span><span> <wbr/>move</span><span>.</span><span>w</span><span> <wbr/></span><span>(</span><span>$6</span><span>,</span><span>PC</span><span>,</span><span>D0</span><span>.</span><span>w</span><span>)</span><span>,</span><span> <wbr/></span><span>(</span><span>$5e</span><span>,</span><span>A4</span><span>)</span><span></span></p><p><span>02F5F0</span><span>:</span><span> <wbr/>rts</span></p><p><span>02F5BA</span><span>:</span><span> <wbr/>rts</span></p><p><span>02EA4A</span><span>:</span><span> <wbr/>bsr <wbr/>$2f602</span></p><p><span>02F602</span><span>:</span><span> <wbr/>move</span><span>.</span><span>w</span><span> <wbr/></span><span>(</span><span>$10</span><span>,</span><span>A4</span><span>)</span><span>,</span><span> <wbr/></span><span>D0</span><span></span></p><p><span>02f606</span><span>:</span><span> <wbr/>beq <wbr/>$2f63e</span></p><p><span>0f2608</span><span>:</span><span> <wbr/>subq</span><span>.</span><span>w</span><span> <wbr/>#</span><span>1</span><span>,</span><span> <wbr/></span><span>(</span><span>$64</span><span>,</span><span>A4</span><span>)</span><span></span></p><p><span>02F60C</span><span>:</span><span> <wbr/>bgt <wbr/>$2f63e</span></p></code></p><p>Here I am currently paused at <code>2F60C</code>, but what is going on? Where am I? The history helps. We can follow it back and find that at <code>2EA4A</code> it did <code>bsr $2f602</code>. <code>bsr</code> is &#34;branch to subroutine&#34;, and one way a subroutine can get called. And if you look in the history the PC went from <code>2EA4A</code> to <code>2F602</code>, showing the jump into the subroutine. This is very useful because it is showing where a subroutine starts. Usually subroutines do one thing, or if they do more than one thing, they are usually related to each other (usually...) So finding the start of a subroutine and just focusing on that one routine and figuring out what it does is a big step foward in understanding the game. One subroutine at a time...</p><p>Now that I know the subroutine starts at <code>2f602</code>, I can set a breakpoint there, and then step through the entire routine and begin to pick apart what it is doing. Or I can do <code>dasm subroutine.txt,2f602,&lt;length&gt;</code> and save the subroutine into a file, then pick apart what it is doing offline. <a tabindex="0" href="https://github.com/city41/rotary-bobble/blob/main/decompiles/setAngle.asm">Here</a> is my picking apart of the subroutine at <code>2f602</code>. Spoiler alert, its job is to take the delta value stored at <code>108212</code>, usually -1, 0, or 1, and add that to the shooter angle (ie, go from say 24 to 25, <code>shooterAngle = shooterAngle + delta</code>) to cause the shooter to move in response to input.</p><h3 id="other-stuff">Other stuff<a aria-hidden="true" href="#other-stuff"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>The MAME debugger has a lot of features. I use the above four the most. Here are some other things it can do</p><ul><li><code>trackmem</code>: kind of like a global watchpoint. It keeps track of all memory writes throughout the whole game, but it holds onto the most recent one, so I have found its usefulness not as good as watchpoints.</li><li><code>find</code>: Searches memory for values</li><li><code>wpenable</code>/<code>wpdisable</code>/<code>bpenable</code>/<code>bpdisable</code>: Turns on/off all watchpoints/breakpoints</li></ul><p>There are many more. I recommend reading the <a tabindex="0" href="https://docs.mamedev.org/debugger/">docs</a>.</p><h2 id="lua-scripts">Lua Scripts<a aria-hidden="true" href="#lua-scripts"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>MAME fairly recently added Lua scripting. This is an awesome and very powerful feature.</p><p>MAME devs have stated that the Lua scripting engine is a bit experimental and early. The API and how to use it might have changed since I wrote this.</p><p>To use a Lua script, write it, then launch MAME with <code>mame &lt;game&gt; -autoboot_script &lt;path to your script&gt;</code></p><p>Lua scripts can also be used to create <a tabindex="0" href="https://docs.mamedev.org/plugins/index.html">plugins</a>, but we won&#39;t get into those here.</p><p>Here is a very simple Lua script for Puzzle Bobble that will cause the shooter to move 4 times faster than normal</p><p><code><p><span>cpu <wbr/>= <wbr/>manager.machine.devices[&#34;:maincpu&#34;]</span></p><p><span>mem <wbr/>= <wbr/>cpu.spaces[&#34;program&#34;]</span></p><p><span>-- <wbr/>this <wbr/>address <wbr/>is <wbr/>the <wbr/>&#34;shooter <wbr/>delta&#34;, <wbr/>whatever <wbr/>gets</span></p><p><span>-- <wbr/>set <wbr/>here <wbr/>will <wbr/>get <wbr/>added <wbr/>to <wbr/>the <wbr/>shooter&#39;s <wbr/>current <wbr/>angle</span></p><p><span>address <wbr/>= <wbr/>0x108212</span></p><p><span>function <wbr/>on_memory_write(offset, <wbr/>data)</span></p><p><span> <wbr/> <wbr/> <wbr/> <wbr/>if <wbr/>offset <wbr/>== <wbr/>address <wbr/>then</span></p><p><span> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/>-- <wbr/>by <wbr/>multiplying <wbr/>the <wbr/>value, <wbr/>the <wbr/>end <wbr/>result <wbr/>is <wbr/>the <wbr/>shooter <wbr/>travels</span></p><p><span> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/>-- <wbr/>much <wbr/>faster</span></p><p><span> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/>return <wbr/>data <wbr/>* <wbr/>4</span></p><p><span> <wbr/> <wbr/> <wbr/> <wbr/>end</span></p><p><span>end</span></p><p><span>mem_handler <wbr/>= <wbr/>mem:install_write_tap(address, <wbr/>address <wbr/>+ <wbr/>1, <wbr/>&#34;writes&#34;, <wbr/>on_memory_write)</span></p></code></p><p>Then run it with <code>mame pbobblen -autoboot_script fasterShooter.lua</code></p><p>Now when pressing left or right, the shooter moves at 4 times its normal speed. Too fast to be useful of course, but this is just a simple demo.</p><p>I use Lua scripts to help test theories I have devised. For example, once I figured out the shooter angle is at memory address <code>108262</code>, I made this tiny script to help confirm that</p><p><code><p><span>cpu <wbr/>= <wbr/>manager.machine.devices[&#34;:maincpu&#34;]</span></p><p><span>mem <wbr/>= <wbr/>cpu.spaces[&#34;program&#34;]</span></p><p><span>-- <wbr/>the <wbr/>shooter <wbr/>angle <wbr/>address</span></p><p><span>address <wbr/>= <wbr/>0x108262</span></p><p><span>function <wbr/>on_memory_write(offset, <wbr/>data)</span></p><p><span> <wbr/> <wbr/> <wbr/> <wbr/>if <wbr/>offset <wbr/>== <wbr/>address <wbr/>then</span></p><p><span> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/>-- <wbr/>force <wbr/>the <wbr/>shooter <wbr/>to <wbr/>always <wbr/>be <wbr/>at <wbr/>10 <wbr/>degrees</span></p><p><span> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/> <wbr/>return <wbr/>10</span></p><p><span> <wbr/> <wbr/> <wbr/> <wbr/>end</span></p><p><span>end</span></p><p><span>mem_handler <wbr/>= <wbr/>mem:install_write_tap(address, <wbr/>address <wbr/>+ <wbr/>1, <wbr/>&#34;writes&#34;, <wbr/>on_memory_write)</span></p></code></p><p>Now running Puzzle Bobble with this script, the shooter is locked at 10 degrees and won&#39;t budge. The write tap is intercepting the memory write and forcing the write to have a different value. So despite the game&#39;s efforts, the shooter angle will always be 10 when this script is active. So without a doubt, <code>108262</code> is where the shooter angle is stored.</p><p>Again a simple example, but I have written complex Lua scripts that have really helped me figure out something about the game, reproduce a bug, or just explore the game. Early on in my exploration I noticed the game uses about 100 bytes or so, and a lot of those bytes I had no idea what they did. So I wrote a script that would one at a time, prevent writes to each byte. Then when I ran the game, sometimes it was obvious what the byte was for. I also wrote scripts to help confirm my ROM hack is working as I expected.</p><p>There is <code>install_write_tap</code> to get involved whenever the game writes to memory, and <code>install_read_tap</code> to get involved whenever it reads from memory. There is also much, much more. The <a tabindex="0" href="https://docs.mamedev.org/luascript/index.html">Lua docs</a> cover it all.</p><p>I have started a repo collecting Neo Geo Lua scripts <a tabindex="0" href="https://github.com/city41/ngDebugScripts">here</a>. For example here is one that shows what sprites are currently being used and where they are on the screen</p><figure><img src="https://mattgreer.dev/_next/static/media/kof94sprites.b4b39159.png" alt="Showing a game&#39;s sprites with a Lua script"/><figcaption>Showing a game&#39;s sprites with a Lua script</figcaption></figure><h2 id="conclusion">Conclusion<a aria-hidden="true" href="#conclusion"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>With the debugger and Lua in hand, I am shocked how easy it is to figure a Neo Geo game out. There aren&#39;t many Neo Geo ROM hacks, so hopefully these tools will mean more in the future. Thanks to the MAME team for such useful tools.</p><h2 id="cheat-sheet">Cheat Sheet<a aria-hidden="true" href="#cheat-sheet"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>These are just the commands I use most often. The debugger can do <a tabindex="0" href="https://docs.mamedev.org/debugger/index.html">much more</a></p><table><tbody><tr><td colspan="2">Debugger - basic commands</td></tr><tr><td>go (F5)</td><td>Runs/unpauses the game</td></tr><tr><td>(s)tep (F11)</td><td>Pauses the game, breaks into the debugger, executes a single instruction</td></tr><tr><td>(o)ver (F10)</td><td>Steps over a subroutine and keeps debugging from where it returns to</td></tr><tr><td>out (shift+F11)</td><td>Leaves the current subroutine and breaks at its exit point</td></tr><tr><td>history</td><td>Prins out the path the CPU took to get to the current stopped point</td></tr><tr><td>dasm file.txt,12345,120</td><td>Takes the program rom, starting at address 12345, and disassembles the instructions ending 120 bytes away. Writes the disassembly into file.txt</td></tr><tr><td colspan="2">Cheat Debugger - find memory changes</td></tr><tr><td>cheatinit &lt;data type&gt;</td><td>The cheat system starts tracking memory. Data type can be &#34;ub&#34;, unsigned byte, &#34;sb&#34;, signed byte, &#34;uw&#34;, unsigned word, &#34;ud&#34;, unsigned double word, etc</td></tr><tr><td>cheatnext +</td><td>Causes the cheat system to look for increment (+) or decrement (-) memory changes since <!-- -->cheatinit<!-- -->. Can also add on a value to choose what the increment value is, like <!-- -->cheatnext +,1</td></tr><tr><td>cheatlist</td><td>Lists out the current memory address that are a match</td></tr><tr><td colspan="2">Watch points - get notified on memory reads and writes</td></tr><tr><td>(wp)set 123456,1,w</td><td>Breaks when the game writes a byte to address 123456, the &#34;1&#34; is the data size, 1 for byte, 2 for word, etc</td></tr><tr><td>(wp)set 123456,1,r</td><td>Breaks when the game reads a byte from address 123456</td></tr><tr><td>wpset 123456,1,w,wpdata == 3F</td><td>Breaks when the game writes a byte to address 123456 but only if the value being written is 3F</td></tr><tr><td>wpset 123456,1,r,b@456789 == 3F</td><td>Breaks when the game reads from address 123456 but only if the byte at 456789 is 3F</td></tr><tr><td>wpset 123456,1,w,,{ printf &#34;wrote :%x&#34;,wpdata; g }</td><td>Whenever the game writes to 123456, prints out what the data was, but doesn&#39;t stop the game</td></tr><tr><td colspan="2">Break points - break into the debugger and pause the game</td></tr><tr><td>(bp)set 1234</td><td>Breaks whenever the CPU executes address 1234</td></tr><tr><td>bpset 1234,D1 == 5</td><td>Breaks at 1234 if the D1 register&#39;s value is 5</td></tr><tr><td>bpset 1234,,{ printf &#34;123456 is %x&#34;,b@123456; g }</td><td>Whenever the CPU hits 1234, prints out what the value of 123456 is in memory, and keeps the game running</td></tr><tr><td>bpset 1234,D1 == 5B80 &amp;&amp; w@A0 == 8A50</td><td>Breaks at 1234 whenever the D1 register is 4B80 and the word that the address register, A0, is pointing to out in memory is 8A50</td></tr></tbody></table></div></div>
  </body>
</html>
