<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.downtowndougbrown.com/2023/03/upgrading-my-chumby-8-kernel-part-4-reboot-poweroff/">Original</a>
    <h1>Upgrading my Chumby 8 kernel part 4: reboot/poweroff</h1>
    
    <div id="readability-page-1" class="page"><div>
				
<p>For the next post in my series about upgrading my Chumby 8’s Linux kernel (here are links to parts <a rel="noreferrer noopener" href="https://www.downtowndougbrown.com/2022/12/upgrading-my-old-chumby-8-linux-kernel-part-1-u-boot/" data-type="post" data-id="2063" target="_blank">1</a>, <a rel="noreferrer noopener" href="https://www.downtowndougbrown.com/2022/12/upgrading-my-chumby-8-kernel-part-2-initial-linux-boot/" data-type="post" data-id="2200" target="_blank">2</a>, and <a rel="noreferrer noopener" href="https://www.downtowndougbrown.com/2023/01/upgrading-my-chumby-8-kernel-part-3-wi-fi/" data-type="post" data-id="2265" target="_blank">3</a>), I thought I’d look at what was involved in getting the reboot and poweroff commands working properly. I noticed pretty early during the development process that they didn’t work, which was pretty annoying.</p>



<pre>The system is going down NOW!
Sent SIGTERM to all processes
Sent SIGKILL to all processes
Requesting system reboot
[   46.457580] reboot: Restarting system
[   47.458947] Reboot failed -- System halted</pre>



<p>This meant that in order to restart the Chumby, I had to physically press a button to power it off and again to power it back on. As you can imagine, this got old really fast during development. For that reason it was one of the earliest things that I got working.</p>



<p>I actually implemented it in U-Boot first, but I thought the Linux side of it would be more fun to share. If you want to see what was involved on the U-Boot side, see <a rel="noreferrer noopener" href="https://github.com/dougg3/u-boot/commit/5118bbab4f51616d5471031388f1ed9d0755dc3d" data-type="URL" data-id="https://github.com/dougg3/u-boot/commit/5118bbab4f51616d5471031388f1ed9d0755dc3d" target="_blank">this commit from my fork of U-Boot</a>.</p>



<p>Before I got it working in both U-Boot and Linux, I had to do some research to figure out how the reboot and poweroff commands worked in the stock Chumby 2.6.28 kernel, as well as how they are expected to work in modern kernels. On a lot of ARM variants, the existing code in the kernel handles it all for you and you don’t have to do anything special. Unfortunately, the PXA168 is not one of these architectures. It’s not a problem unique to the PXA168 though. On some boards you might need to toggle a GPIO pin, set a bit in a register, enable the watchdog timer and let it expire, or send a command to an external microcontroller. There are a bunch of reset drivers in modern mainline kernels. See the <a rel="noreferrer noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/power/reset?h=v6.2" data-type="URL" data-id="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/power/reset?h=v6.2" target="_blank">drivers/power/reset</a> directory in the kernel source. This directory didn’t exist in the 2.6.28 kernel though, so it’s a mechanism that has undergone some changes throughout the years.</p>



<p>The Chumby 8/Insignia Infocast 8 was known internally by Chumby as “silvermoon”. Thus, one way to find a bunch of the Chumby-specific kernel customizations is simply to search the <a rel="noreferrer noopener" href="http://files.chumby.com/source/" data-type="URL" data-id="http://files.chumby.com/source/" target="_blank">Chumby 2.6.28 kernel source</a> for the string silvermoon:</p>



<pre>cd linux-2.6.28</pre>



<p>This revealed all sorts of custom drivers and patches to the kernel, including: touchscreen support, PWM backlight control, a custom boot logo, several sound-related tweaks and drivers, and tweaks to the PXA168 framebuffer, USB, and UART drivers. If you’re curious about which topics are remaining to be covered in this series, that’s a pretty accurate list!</p>



<p>Several lines it found in the UART driver looked interesting:</p>



<pre>drivers/serial/pxa.c:static void silvermoon_pm_power_off(void)
drivers/serial/pxa.c:static void silvermoon_pm_restart(char ignored)
drivers/serial/pxa.c:		arm_pm_restart = silvermoon_pm_restart;
drivers/serial/pxa.c:		pm_power_off   = silvermoon_pm_power_off;</pre>



<p>At first glance, it seemed kind of…odd…that the serial driver would have functions related to poweroff and reboot. As I investigated more deeply, it started to make sense. The Chumby 8’s power control is actually handled by the STM32F101 “cryptoprocessor” on the same board. The PXA168 communicates with the STM32 through a UART, and then the STM32 twiddles GPIO pins in response to enable/disable power rails and/or reset the PXA168. It seems that it was easiest for the original developers to insert the reset code into the UART driver since it was all set up for sending and receiving data.</p>



<p>I investigated the silvermoon_pm_restart() and silvermoon_pm_power_off() functions in more depth. They are both pretty simple. They send a command 8 times over the UART: “RSET” for reset or “DOWN” for power down. The repetition is to be safe, because the UART communication could potentially fail.</p>


<div><pre title="">static void silvermoon_pm_power_off(void)
{
	struct uart_pxa_port *up = serial_pxa_ports[2];

    CHLOG(&#34;Powering off...\n&#34;);
    // Have the CP power us down.
    if(!up) {
        CHLOG(&#34;serial_pxa_ports is NULL.  Try to power off too soon?\n&#34;);
        return;
    }

	/*
	 * Due to timing reasons and lack of flow-control, the first try might
	 * not bring the system down.  Try multiple times.
	 */
	send_cp_command(up, &#34;DOWN&#34;, NULL, NULL);
	send_cp_command(up, &#34;DOWN&#34;, NULL, NULL);
	send_cp_command(up, &#34;DOWN&#34;, NULL, NULL);
	send_cp_command(up, &#34;DOWN&#34;, NULL, NULL);
	send_cp_command(up, &#34;DOWN&#34;, NULL, NULL);
	send_cp_command(up, &#34;DOWN&#34;, NULL, NULL);
	send_cp_command(up, &#34;DOWN&#34;, NULL, NULL);
	send_cp_command(up, &#34;DOWN&#34;, NULL, NULL);

	CHLOG(&#34;We should be powered down now.\n&#34;);
}
</pre></div>


<p>These functions both call a common send_cp_command() function that sets up the UART for simple polling, tries to get the cryptoprocessor’s attention by sending “!!!!”, waits for a confirmation response of ‘?’, repeats if there is no response, and finally sends the command followed by a linefeed and carriage return.</p>



<p>With that knowledge in hand, I decided to figure out a clean approach for adding this functionality to newer kernels. I wanted it do it the “correct” way now that there is a dedicated subsystem for reset drivers, rather than patching it directly into the PXA serial driver. Let’s walk backwards from the “Reboot failed” error message and trace out how rebooting works in modern kernels:</p>



<pre>$ grep -R &#39;Reboot failed&#39;
arch/mips/kernel/reset.c:	pr_emerg(&#34;Reboot failed -- System halted\n&#34;);
arch/sparc/kernel/process_32.c:	panic(&#34;Reboot failed!&#34;);
arch/sparc/kernel/reboot.c:	panic(&#34;Reboot failed!&#34;);
arch/openrisc/kernel/process.c:	pr_emerg(&#34;Reboot failed -- System halted\n&#34;);
arch/arm64/kernel/process.c:	printk(&#34;Reboot failed -- System halted\n&#34;);
arch/arm/kernel/reboot.c:	printk(&#34;Reboot failed -- System halted\n&#34;);
arch/microblaze/kernel/reset.c:	pr_emerg(&#34;Reboot failed -- System halted\n&#34;);</pre>



<p>Clearly, the error message is coming from architecture-specific code. In particular, we are interested in <a rel="noreferrer noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm/kernel/reboot.c?h=v6.2#n134" data-type="URL" data-id="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm/kernel/reboot.c?h=v6.2#n134" target="_blank">the ARM version</a>:</p>


<div><pre title="">void machine_restart(char *cmd)
{
	local_irq_disable();
	smp_send_stop();

	do_kernel_restart(cmd);

	/* Give a grace period for failure to restart of 1s */
	mdelay(1000);

	/* Whoops - the platform was unable to reboot. Tell the user! */
	printk(&#34;Reboot failed -- System halted\n&#34;);
	while (1);
}
</pre></div>


<p>This seems pretty straightforward, and explains why the failure message appears almost exactly one second after the “Restarting system” message. The relevant function is do_kernel_restart(), <a rel="noreferrer noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/reboot.c?h=v6.2#n223" data-type="URL" data-id="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/reboot.c?h=v6.2#n223" target="_blank">which is actually a platform-independent function in kernel/reboot.c</a>:</p>


<div><pre title="">void do_kernel_restart(char *cmd)
{
	atomic_notifier_call_chain(&amp;restart_handler_list, reboot_mode, cmd);
}
</pre></div>


<p>Aha, so it’s just executing a list of registered restart handlers. Right above do_kernel_restart(), there’s a function called register_restart_handler() that adds a handler to the list. That function is called extensively in lots of drivers, especially the power/reset directory I mentioned earlier. <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm/kernel/setup.c?h=v6.2#n1176" data-type="URL" data-id="https://elixir.bootlin.com/linux/v6.2.5/source/arch/arm/kernel/setup.c#L1176" target="_blank" rel="noreferrer noopener">It’s also called by the common ARM setup_arch function</a>, which is how it’s hooked up on a lot of the ARM platforms.</p>



<p>I inspected some of the other reset drivers to see how they worked. It’s all pretty simple. In the probe function, you set up any necessary resources (e.g. I/O addresses) and register the reset handler. Some of them also deal with poweroff. Those drivers modify the pm_power_off global variable which is a function pointer to the function that should be called when the system needs to be powered off. I knew I would need to implement that functionality too. By the way, it looks like there is a new register_sys_off_handler() function that is similar to register_restart_handler(). Most drivers aren’t using it yet though. pm_power_off <a rel="noreferrer noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/reboot.c?h=v6.2#n639" target="_blank">eventually ends up being hooked up to it under the hood</a>. If I submit it upstream, I should probably use the new mechanism instead.</p>



<p>Anyway, the Chumby’s requirements are a little unique compared to the other drivers I inspected. It’s not just a simple GPIO pin toggle or a register write. It’s an algorithm that requires two-way communication with the STM32. I have to send the “!!!!”, wait for the ‘?’, retry a few times if I don’t get a response, and then send the command. Then, that whole process has to be retried several times in case it fails due to serial communication problems. The closest driver I found was <a rel="noreferrer noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/power/reset/qnap-poweroff.c?h=v6.2" data-type="URL" data-id="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/power/reset/qnap-poweroff.c?h=v6.2" target="_blank">qnap-poweroff</a>, which is designed for some QNAP and Synology NAS devices. It sends a single character through a UART to tell the system to shut down.</p>



<p>My driver needed to do a bit more work, but I liked the way the qnap-poweroff driver handled it. Rather than trying to figure out how to interact with any serial drivers, it takes over complete control of the UART. It seems to be a 16550A-compatible UART just like the PXA168. It sets it up with the correct baud rate and framing, disables the FIFOs and interrupts, and manually sends the command by directly writing to the UART’s TX register.</p>



<p>I figured I could do pretty much the same thing, just with some added two-way communication. After all, we’re trying to shut down or reboot, so it’s not really a big deal if I take over the entire CPU busy-waiting for a response from the STM32. In some ways it’s even preferable. It doesn’t depend on any other drivers or subsystems that could introduce other failures. It just does a sequence of register reads and writes that should be pretty safe as long as the hardware is still working. With that in mind, I coded up a reset/poweroff driver.</p>



<p>One thing that required a bit of thinking was how I would handle it from a device tree standpoint. The thing is, the cryptoprocessor also has to be functional inside of Linux because you can run the <a rel="noreferrer noopener" href="https://github.com/sutajiokousagi/cpi" data-type="URL" data-id="https://github.com/sutajiokousagi/cpi" target="_blank">cpi</a> utility to communicate with it. I wanted to retain compatibility with cpi, because I could use it for purposes such as determining how many seconds have elapsed since the cryptoprocessor restarted. This would allow me to emulate an RTC, for example. So I needed both the normal serial driver and this new reset driver to work. They both needed to be mapped to the same address. This turned out to not be a problem at all. The reset driver doesn’t interfere with the UART driver during normal operation and they seem to coexist peacefully:</p>



<pre>uart3: serial@d4026000 {
	compatible = &#34;mrvl,mmp-uart&#34;, &#34;intel,xscale-uart&#34;;
	reg = &lt;0xd4026000 0x1000&gt;;
	reg-shift = &lt;2&gt;;
	interrupts = &lt;29&gt;;
	clocks = &lt;&amp;soc_clocks PXA168_CLK_UART2&gt;;
	resets = &lt;&amp;soc_clocks PXA168_CLK_UART2&gt;;
	status = &#34;okay&#34;;
};</pre>



<pre>/* Note: Mapped to same address as UART3 */
reset: reset@d4026000 {
	compatible = &#34;chumby,chumby8-reboot-controller&#34;;
	reg = &lt;0xd4026000 0x1000&gt;;
	clocks = &lt;&amp;soc_clocks PXA168_CLK_UART2&gt;;
	resets = &lt;&amp;soc_clocks PXA168_CLK_UART2&gt;;
	status = &#34;okay&#34;;
};</pre>



<p>I don’t think it would be much fun to go line-by-line through the <a rel="noreferrer noopener" href="https://github.com/dougg3/silvermoon-linux/blob/v6.2-chumby8/drivers/power/reset/chumby8-reboot.c" data-type="URL" data-id="https://github.com/dougg3/silvermoon-linux/blob/v6.2-chumby8/drivers/power/reset/chumby8-reboot.c" target="_blank">entire driver</a>, but here are a few highlights of how it’s set up:</p>


<div><pre title="">static struct chumby8_rebootcon {
	struct clk *clk;
	void __iomem *base;
	struct notifier_block nb;
} c8_poweroff;
</pre></div>


<p>I keep track of the UART’s peripheral clock. This is needed so that I can calculate the correct divisor to use in order to set up the UART for 115,200 baud before sending a command. The stock Chumby 2.6.28 reset code didn’t do this, so if something in userspace didn’t set up the baud rate correctly, the reboot/poweroff commands wouldn’t work. This was a nonissue with the stock Chumby firmware because it always set it up properly somewhere in userspace. I wanted to make sure it would always work in my updated kernel, regardless of what userspace had or hadn’t done. The base address is also saved so that I know where the UART registers are. Finally, “nb” is the notifier block which contains a function pointer to my restart callback.</p>



<p>When a command is ready to be sent to the UART, I manually set up various UART registers. I turn off the FIFOs, turn off interrupts, and set it up for 115,200 8N1.</p>


<div><pre title="">#include &lt;uapi/linux/serial_reg.h&gt;

/* Disable UART interrupts and FIFOs */
chumby8_coproc_serial_out(UART_IER, UART_IER_UUE);
chumby8_coproc_serial_out(UART_FCR, 0);

/* Ensure UART is set for 115200, 8N1 */
clk_rate = clk_get_rate(c8_poweroff.clk);
divisor = clk_rate / 16 / 115200;
chumby8_coproc_serial_out(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN8);
chumby8_coproc_serial_out(UART_DLL, divisor &amp; 0xFF);
chumby8_coproc_serial_out(UART_DLM, divisor &gt;&gt; 8);
chumby8_coproc_serial_out(UART_LCR, UART_LCR_WLEN8);
</pre></div>


<p>Luckily, the 16550A UART is so common that Linux has a header that includes defines for the register offsets and bits. Note that the PXA168 UART has a special non-standard UUE (UART unit enable) bit in the interrupt enable register that has to be set to a 1 in order to be used.</p>



<p>Reading data involves checking to make sure that data is actually available to read, and then grabbing it from the register if so:</p>


<div><pre title="">int c = -1;

if (chumby8_coproc_serial_in(UART_LSR) &amp; UART_LSR_DR) {
	c = chumby8_coproc_serial_in(UART_RX);
}
</pre></div>


<p>Writing data works similarly. I wait until the UART is ready to send another byte, and then write it out:</p>


<div><pre title="">/* wait for transmit available */
while (!(chumby8_coproc_serial_in(UART_LSR) &amp; UART_LSR_THRE));

/* send the char */
chumby8_coproc_serial_out(UART_TX, c);
</pre></div>


<p>Other than my manual register accesses described above, it’s all just the same basic solution that the original Chumby code used. The original code had a few delays, and we know it works okay, so I replicated the delays exactly as they were: 300 microseconds between checks for ‘?’ after “!!!!”, and 1 millisecond between each character when writing out the final command.</p>



<p>After enabling this driver, adding it to my device tree as shown above, and rebooting, I tried it out. It succeeded! Now, when I reboot, I get the following output:</p>



<pre>The system is going down NOW!
Sent SIGTERM to all processes
Sent SIGKILL to all processes
Requesting system reboot
[   17.097732] reboot: Restarting system</pre>



<p>At that point, the system reboots instead of complaining a second later. The poweroff command is also slightly different from its previous output. It now prints this:</p>



<pre>The system is going down NOW!
Sent SIGTERM to all processes
Sent SIGKILL to all processes
Requesting system poweroff
[   28.257771] reboot: Power down</pre>



<p>Previously the last line said “reboot: System halted” instead, and it wasn’t actually turning off. I had to press the power button once to turn it off, and then again to turn it back on. Now it definitely turns off. Pressing the power button once turns it back on.</p>



<p>While developing in the kernel, I have occasionally run into situations where I make a mistake and the kernel gets hung up or crashes. Luckily, reset drivers play nicely with the <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Magic_SysRq_key" data-type="URL" data-id="https://en.wikipedia.org/wiki/Magic_SysRq_key" target="_blank">magic SysRq</a> functionality to reboot the system. This is enabled with CONFIG_MAGIC_SYSRQ_SERIAL=y and CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1. In minicom, I activate the magic SysRq by typing Ctrl-A, then F. This sends a break, and then I can type the letter b to reboot. Even with the system in bad shape, my reset driver still works properly and reboots it. It’s much more convenient than fiddling with the power button.</p>



<p>This ended up being fairly simple to implement. It has been really nice to have the reset/poweroff driver working. I’m undecided on whether I want to attempt upstreaming this driver to the mainline kernel or not. I suspect that I will always be maintaining a fork of the kernel with a few custom tweaks, especially related to the display driver. The reset driver is so simple that I’m not super concerned about the difficulty of keeping it updated as the kernel evolves. We’ll see how it goes though.</p>



<p>Speaking of the display driver, my next post in the series is going to talk about what was involved in getting the LCD up and running. There was a lot of work required. I’m not sure if I can even fit it into a single post! Stay tuned and you’ll find out.</p>
			  
			</div></div>
  </body>
</html>
