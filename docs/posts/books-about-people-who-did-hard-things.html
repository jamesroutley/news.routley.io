<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://news.ycombinator.com/item?id=42614722">Original</a>
    <h1>Ask HN: Books about people who did hard things</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>From 2018 to 2021, I worked on a greenfield Python runtime called
<a href="https://github.com/tekknolagi/skybison">Skybison</a>.
One of its major differences from CPython was that it used a moving garbage
collector (GC). This I understood in theory—I knew that it ran when the heap
filled up, knew we needed handles to update pointers in the runtime’s code, had
read the <a href="https://bernsteinbear.com/assets/img/moon-gc.pdf">Moon paper</a> (PDF)—but the other day, I
wanted to implement weak references and couldn’t immediately figure it out.
Skybison thankfully has a reasonably clear implementation. So now I’m writing
this post, mostly for myself, but maybe it will be useful to you as well.</p>

<p>In this post I’ll give a brief overview of a garbage collector, a sample
“normal” object, and then show the special handling for weak references. I’ve
taken inspiration from the Skybison code, but it’s possible other projects have
different approaches.</p>

<h2 id="garbage-collectors">Garbage collectors</h2>

<p>While this post talks mostly about moving garbage collectors, I think the
weakref handling applies pretty cleanly to mark-sweep and other types of
stop-the-world GC as well. I don’t know about reference counting or concurrent
GC, though.</p>

<blockquote>
  <p>As an aside, if you have not been in the internals of a moving garbage
collector before, I wholeheartedly recommend <a href="https://wingolog.org/archives/2022/12/10/a-simple-semi-space-collector">Andy Wingo’s post</a>.
He’s distilled the core ideas so well. Ever read a post that’s so well
written and concise that it takes your breath away? It’s what brought the
Moon paper from dream land into the real world for me.</p>
</blockquote>

<p>The important things to know about a garbage collector for this post are:</p>

<ul>
  <li>It collects objects when they are dead</li>
  <li>Dead means that they have no pointers pointing to them</li>
  <li>“No pointers” means no non-weakref pointers</li>
  <li>A weakref is itself a type of object</li>
  <li>The weakref object might still be alive</li>
  <li>When a weakref’s referent (thing it points to) dies, the <code>ref.referent</code> field
should be cleared</li>
</ul>

<p>Here is the core of Scrapscript’s garbage collector. It’s a very slightly
modified version of Andy’s semispace GC. There are two phases, marked by
comments in the code: 1) scan the roots 2) incrementally copy over the object
graph (indirectly) pointed to by the roots. Everything not indirectly pointed
to is dead.</p>

<div><div><pre><code><span>void</span> <span>collect</span><span>(</span><span>struct</span> <span>gc_heap</span><span>*</span> <span>heap</span><span>)</span> <span>{</span>
  <span>flip</span><span>(</span><span>heap</span><span>);</span>
  <span>// Scan the roots and copy them into newspace</span>
  <span>uintptr_t</span> <span>scan</span> <span>=</span> <span>heap</span><span>-&gt;</span><span>hp</span><span>;</span>
  <span>for_each_root</span><span>(</span><span>heap</span><span>,</span> <span>copy_to_newspace</span><span>);</span>
  <span>// Now go copy the rest of the graph</span>
  <span>while</span> <span>(</span><span>scan</span> <span>&lt;</span> <span>heap</span><span>-&gt;</span><span>hp</span><span>)</span> <span>{</span>
    <span>struct</span> <span>gc_obj</span><span>*</span> <span>obj</span> <span>=</span> <span>(</span><span>struct</span> <span>gc_obj</span><span>*</span><span>)</span><span>scan</span><span>;</span>
    <span>for_each_field</span><span>(</span><span>obj</span><span>,</span> <span>heap</span><span>,</span> <span>copy_to_newspace</span><span>);</span>
    <span>scan</span> <span>+=</span> <span>heap_object_size</span><span>(</span><span>obj</span><span>);</span>
  <span>}</span>
<span>}</span>

<span>void</span> <span>for_each_field</span><span>(</span><span>struct</span> <span>gc_obj</span><span>*</span> <span>obj</span><span>,</span> <span>struct</span> <span>gc_heap</span><span>*</span> <span>heap</span><span>,</span> <span>VisitFn</span> <span>visit</span><span>)</span> <span>{</span>
  <span>switch</span> <span>(</span><span>obj_tag</span><span>(</span><span>obj</span><span>))</span> <span>{</span>
    <span>case</span> <span>TAG_LIST</span><span>:</span>
      <span>visit</span><span>(</span><span>&amp;</span><span>((</span><span>struct</span> <span>list</span><span>*</span><span>)</span><span>obj</span><span>)</span><span>-&gt;</span><span>first</span><span>,</span> <span>heap</span><span>);</span>
      <span>visit</span><span>(</span><span>&amp;</span><span>((</span><span>struct</span> <span>list</span><span>*</span><span>)</span><span>obj</span><span>)</span><span>-&gt;</span><span>rest</span><span>,</span> <span>heap</span><span>);</span>
      <span>break</span><span>;</span>
    <span>// ...</span>
    <span>default:</span>
      <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;unknown tag: %u</span><span>\n</span><span>&#34;</span><span>,</span> <span>obj_tag</span><span>(</span><span>obj</span><span>));</span>
      <span>abort</span><span>();</span>
  <span>}</span>
<span>}</span>

<span>void</span> <span>copy_to_newspace</span><span>(</span><span>struct</span> <span>gc_obj</span><span>**</span> <span>pointer</span><span>,</span> <span>struct</span> <span>gc_heap</span><span>*</span> <span>heap</span><span>)</span> <span>{</span>
  <span>struct</span> <span>gc_obj</span><span>*</span> <span>from</span> <span>=</span> <span>*</span><span>pointer</span><span>;</span>
  <span>*</span><span>pointer</span> <span>=</span> <span>is_forwarded</span><span>(</span><span>from</span><span>)</span> <span>?</span> <span>forwarded</span><span>(</span><span>from</span><span>)</span> <span>:</span> <span>copy</span><span>(</span><span>heap</span><span>,</span> <span>from</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<blockquote>
  <p>As an aside, using newspace as a queue like this (and, implict here, using
forwarding pointers) is called Cheney copying after a technique described by
CJ Cheney in his <a href="https://bernsteinbear.com/assets/img/cheney.pdf">1970 paper</a> (PDF). It’s not
important for this blog post, but it’s worth knowing about.</p>
</blockquote>

<p>Now, here’s the problem. Say we were to add an empty case for weakrefs in
<code>for_each_field</code>.</p>

<div><div><pre><code><span>// ...</span>
    <span>case</span> <span>TAG_WEAKREF</span><span>:</span>
      <span>// Don&#39;t visit the referent.</span>
      <span>break</span><span>;</span>
<span>// ...</span>
</code></pre></div></div>

<p>That’s great and all—the weakref won’t keep its referent alive—but there
are two problems:</p>

<ol>
  <li>If the referent dies, we have a dangling pointer into oldspace. We should
instead clear the referent and have it point to some NULL-like sentinel
object.</li>
  <li>If the referent ends up staying alive, we have a dangling pointer to a
forwarded object and need to fix it up.</li>
</ol>

<p>Let’s add one more step to fix both problems.</p>

<h2 id="weak-references">Weak references</h2>

<p>At a high level, we want to find all the still-alive weakref objects and fix up
their referent pointers. If the referent is still alive, we want to update it
to the updated (forwarded) pointer in newspace. If the referent is dead, we
want to set the referent field to <code>NULL</code> or something. This has to happen after
the main collection, since that heap root and heap traversal determines what is
still alive and what is dead.</p>

<p>We could do another full heap traversal to find all the weakrefs, but that
might be slow: the heap could be arbitrarily large. In that case, one weakref
at the end might incur a second full heap scan. Not great. Instead, we make
weakrefs pay-as-you-go: each weakref contains a <code>link</code> field so that we can put
it in a linked list in the first heap scan. Then, we’ll traverse only the
linked list of weakrefs to update their referents.</p>

<div><div><pre><code><span>struct</span> <span>weakref</span> <span>{</span>
  <span>struct</span> <span>gc_obj</span> <span>HEAD</span><span>;</span>
  <span>struct</span> <span>gc_obj</span><span>*</span> <span>referent</span><span>;</span>
  <span>struct</span> <span>weakref</span><span>*</span> <span>link</span><span>;</span>
<span>};</span>

<span>struct</span> <span>weakref</span><span>*</span> <span>delayed_references</span> <span>=</span> <span>NULL</span><span>;</span>

<span>void</span> <span>enqueue_weakref</span><span>(</span><span>struct</span> <span>weakref</span><span>*</span> <span>ref</span><span>)</span> <span>{</span>
  <span>ref</span><span>-&gt;</span><span>link</span> <span>=</span> <span>delayed_references</span><span>;</span>
  <span>delayed_references</span> <span>=</span> <span>ref</span><span>;</span>
<span>}</span>

<span>struct</span> <span>weakref</span><span>*</span> <span>dequeue_weakref</span><span>()</span> <span>{</span>
  <span>struct</span> <span>weakref</span><span>*</span> <span>result</span> <span>=</span> <span>delayed_references</span><span>;</span>
  <span>delayed_references</span> <span>=</span> <span>result</span><span>-&gt;</span><span>link</span><span>;</span>
  <span>result</span><span>-&gt;</span><span>link</span> <span>=</span> <span>NULL</span><span>;</span>
  <span>return</span> <span>result</span><span>;</span>
<span>}</span>

<span>bool</span> <span>is_weakref</span><span>(</span><span>struct</span> <span>gc_obj</span><span>*</span><span>);</span>

<span>void</span> <span>collect</span><span>(</span><span>struct</span> <span>gc_heap</span><span>*</span> <span>heap</span><span>)</span> <span>{</span>
  <span>flip</span><span>(</span><span>heap</span><span>);</span>
  <span>// Scan the roots and copy them into newspace</span>
  <span>uintptr_t</span> <span>scan</span> <span>=</span> <span>heap</span><span>-&gt;</span><span>hp</span><span>;</span>
  <span>for_each_root</span><span>(</span><span>heap</span><span>,</span> <span>copy_to_newspace</span><span>);</span>
  <span>// Now go copy the rest of the graph</span>
  <span>while</span> <span>(</span><span>scan</span> <span>&lt;</span> <span>heap</span><span>-&gt;</span><span>hp</span><span>)</span> <span>{</span>
    <span>struct</span> <span>gc_obj</span><span>*</span> <span>obj</span> <span>=</span> <span>(</span><span>struct</span> <span>gc_obj</span><span>*</span><span>)</span><span>scan</span><span>;</span>
    <span>if</span> <span>(</span><span>is_weakref</span><span>(</span><span>obj</span><span>))</span> <span>{</span>
      <span>// Enqueue to linked list (new!)</span>
      <span>enqueue_weakref</span><span>((</span><span>struct</span> <span>weakref</span><span>*</span><span>)</span><span>obj</span><span>);</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>for_each_field</span><span>(</span><span>obj</span><span>,</span> <span>heap</span><span>,</span> <span>copy_to_newspace</span><span>);</span>
    <span>}</span>
    <span>scan</span> <span>+=</span> <span>heap_object_size</span><span>(</span><span>obj</span><span>);</span>
  <span>}</span>
  <span>// Update or clear all referents (new!)</span>
  <span>while</span> <span>(</span><span>delayed_references</span> <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
    <span>struct</span> <span>weakref</span><span>*</span> <span>ref</span> <span>=</span> <span>dequeue_weakref</span><span>();</span>
    <span>struct</span> <span>gc_obj</span><span>*</span> <span>referent</span> <span>=</span> <span>ref</span><span>-&gt;</span><span>referent</span><span>;</span>
    <span>ref</span><span>-&gt;</span><span>referent</span> <span>=</span> <span>is_forwarded</span><span>(</span><span>referent</span><span>)</span> <span>?</span> <span>forwarded</span><span>(</span><span>referent</span><span>)</span> <span>:</span> <span>NULL</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>link</code> field is otherwise completely unused during normal program
operations. Its sole purpose is to be GC metadata.</p>

<p>Let’s see what this looks like with two examples: 1) a weakref whose referent
dies 2) a weakref whose referent lives across a collection.</p>

<p>We use this thing called “handles” (or shadow stack, or …) to mark pointers
as needed by C code that the garbage collector does not know about. To learn
more about that, check out <a href="https://bernsteinbear.com/blog/scrapscript-baseline/">my post on the Scrapscript baseline
compiler</a>. Search for “handles”.</p>

<div><div><pre><code><span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>HANDLES</span><span>();</span>
  <span>struct</span> <span>gc_heap</span><span>*</span> <span>heap</span> <span>=</span> <span>make_heap</span><span>(</span><span>1024</span><span>);</span>
  <span>// left4dead_num has no handle; it will die at the call to collect().</span>
  <span>struct</span> <span>gc_obj</span><span>*</span> <span>left4dead_num</span> <span>=</span> <span>mknum</span><span>(</span><span>heap</span><span>,</span> <span>3</span><span>);</span>
  <span>// keptalive_num is kept alive and the pointer is updated because we have</span>
  <span>// used a handle.</span>
  <span>GC_HANDLE</span><span>(</span><span>struct</span> <span>gc_obj</span><span>*</span><span>,</span> <span>keptalive_num</span><span>,</span> <span>mknum</span><span>(</span><span>heap</span><span>,</span> <span>4</span><span>));</span>
  <span>// Both weakref *objects* will be kept alive beacuse of the handles.</span>
  <span>GC_HANDLE</span><span>(</span><span>struct</span> <span>gc_obj</span><span>*</span><span>,</span> <span>ref0</span><span>,</span> <span>mkweakref</span><span>(</span><span>heap</span><span>,</span> <span>left4dead_num</span><span>));</span>
  <span>GC_HANDLE</span><span>(</span><span>struct</span> <span>gc_obj</span><span>*</span><span>,</span> <span>ref1</span><span>,</span> <span>mkweakref</span><span>(</span><span>heap</span><span>,</span> <span>keptalive_num</span><span>));</span>
  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;ref0 %p with referent %p</span><span>\n</span><span>&#34;</span><span>,</span>
                  <span>ref0</span><span>,</span> <span>((</span><span>struct</span> <span>weakref</span><span>*</span><span>)</span><span>ref0</span><span>)</span><span>-&gt;</span><span>referent</span><span>);</span>
  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;ref1 %p with referent %p</span><span>\n</span><span>&#34;</span><span>,</span>
                  <span>ref1</span><span>,</span> <span>((</span><span>struct</span> <span>weakref</span><span>*</span><span>)</span><span>ref1</span><span>)</span><span>-&gt;</span><span>referent</span><span>);</span>
  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;COLLECTING</span><span>\n</span><span>&#34;</span><span>);</span>
  <span>collect</span><span>(</span><span>heap</span><span>);</span>
  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;ref0 %p with referent %p</span><span>\n</span><span>&#34;</span><span>,</span>
                  <span>ref0</span><span>,</span> <span>((</span><span>struct</span> <span>weakref</span><span>*</span><span>)</span><span>ref0</span><span>)</span><span>-&gt;</span><span>referent</span><span>);</span>
  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;ref1 %p with referent %p (keptalive is %p)</span><span>\n</span><span>&#34;</span><span>,</span>
                  <span>ref1</span><span>,</span> <span>((</span><span>struct</span> <span>weakref</span><span>*</span><span>)</span><span>ref1</span><span>)</span><span>-&gt;</span><span>referent</span><span>,</span> <span>keptalive_num</span><span>);</span>
  <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Lo, ref0’s referent is cleared while ref1’s referent gets updated to the new
pointer:</p>

<div><div><pre><code><span>$</span><span> </span>./main
<span>ref0 0x771baf155020 with referent 0x771baf155000
ref1 0x771baf155038 with referent 0x771baf155010
COLLECTING
ref0 0x771baf155810 with referent (nil)
ref1 0x771baf155828 with referent 0x771baf155800 (keptalive is 0x771baf155800)
</span><span>$</span><span>
</span></code></pre></div></div>

<p>Nice.</p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>Thank you to <a href="https://cfallin.org/">Chris Fallin</a> for reviewing this post.</p>

<p>See the <a href="https://github.com/tekknolagi/wingogc">full code snippet</a> (including
the entire GC).</p>

<h2 id="other-approaches">Other approaches</h2>

<p>The T3 compiler used oldspace for data structures. See <a href="https://bernsteinbear.com/assets/img/clark.pdf">Clark’s 1976
paper</a> (PDF). Thanks, Taylor, for linking to this in a
comment on <a href="https://wingolog.org/archives/2022/12/11/we-iterate-so-that-you-can-recurse">Andy Wingo’s post</a>.</p>


        </div></div>
  </body>
</html>
