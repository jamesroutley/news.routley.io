<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/hylang/hy/discussions/2608">Original</a>
    <h1>Hy 1.0 – Lisp dialect for Python</h1>
    
    <div id="readability-page-1" class="page"><div role="presentation" data-paste-markdown-skip="">
    <tbody data-target-translation-id="10722112" data-target-translation-type="comment">
        <tr>
    <td>
        <p dir="auto">Congrats. This is the moment I&#39;ve been waiting for over a decade, literally.</p>
<p dir="auto">It gives me peace of mind because I am working on an ORM and an async web framework, both in Hy, they are not the typical &#34;yet another ...&#34; ones, I am not reinventing the wheel, both libraries are leveraging existing awesome libraries, containing mostly macros, focusing on cleaner interface and less boilerplate code.</p>
<p dir="auto">For example, instead of these models in <a href="https://docs.sqlalchemy.org/en/20/orm/quickstart.html#declare-models" rel="nofollow">SQLAlchemy&#39;s ORM Quick Start Guide</a></p>
<div dir="auto" data-snippet-clipboard-copy-content="class Base(DeclarativeBase):
    pass

class User(Base):
    __tablename__ = &#34;user_account&#34;

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(30))
    fullname: Mapped[Optional[str]]

    addresses: Mapped[List[&#34;Address&#34;]] = relationship(
        back_populates=&#34;user&#34;, cascade=&#34;all, delete-orphan&#34;
    )

class Address(Base):
    __tablename__ = &#34;address&#34;

    id: Mapped[int] = mapped_column(primary_key=True)
    email_address: Mapped[str]
    user_id: Mapped[int] = mapped_column(ForeignKey(&#34;user_account.id&#34;))

    user: Mapped[&#34;User&#34;] = relationship(back_populates=&#34;addresses&#34;)"><pre><span>class</span> <span>Base</span>(<span>DeclarativeBase</span>):
    <span>pass</span>

<span>class</span> <span>User</span>(<span>Base</span>):
    <span>__tablename__</span> <span>=</span> <span>&#34;user_account&#34;</span>

    <span>id</span>: <span>Mapped</span>[<span>int</span>] <span>=</span> <span>mapped_column</span>(<span>primary_key</span><span>=</span><span>True</span>)
    <span>name</span>: <span>Mapped</span>[<span>str</span>] <span>=</span> <span>mapped_column</span>(<span>String</span>(<span>30</span>))
    <span>fullname</span>: <span>Mapped</span>[<span>Optional</span>[<span>str</span>]]

    <span>addresses</span>: <span>Mapped</span>[<span>List</span>[<span>&#34;Address&#34;</span>]] <span>=</span> <span>relationship</span>(
        <span>back_populates</span><span>=</span><span>&#34;user&#34;</span>, <span>cascade</span><span>=</span><span>&#34;all, delete-orphan&#34;</span>
    )

<span>class</span> <span>Address</span>(<span>Base</span>):
    <span>__tablename__</span> <span>=</span> <span>&#34;address&#34;</span>

    <span>id</span>: <span>Mapped</span>[<span>int</span>] <span>=</span> <span>mapped_column</span>(<span>primary_key</span><span>=</span><span>True</span>)
    <span>email_address</span>: <span>Mapped</span>[<span>str</span>]
    <span>user_id</span>: <span>Mapped</span>[<span>int</span>] <span>=</span> <span>mapped_column</span>(<span>ForeignKey</span>(<span>&#34;user_account.id&#34;</span>))

    <span>user</span>: <span>Mapped</span>[<span>&#34;User&#34;</span>] <span>=</span> <span>relationship</span>(<span>back_populates</span><span>=</span><span>&#34;addresses&#34;</span>)</pre></div>
<p dir="auto">One can use the <code>defmodel</code> macro:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(defmodel User
  (id int :primary-key)
  (name str :max-length 30)
  (fullname str :nullable)
  (1-&gt;* Address :as &#34;addresses&#34;))

(defmodel Address
  (id int :primary-key)
  (email str)
  (*-&gt;1 User :reference &#34;addresses&#34;))"><pre>(<span>defmodel</span> <span>User</span>
  (<span>id</span> int <span>:primary-key</span>)
  (<span>name</span> str <span>:max-length</span> <span>30</span>)
  (<span>fullname</span> str <span>:nullable</span>)
  (<span>1</span>-&gt;* Address <span>:as</span> <span><span>&#34;</span>addresses<span>&#34;</span></span>))

(<span>defmodel</span> <span>Address</span>
  (<span>id</span> int <span>:primary-key</span>)
  (<span>email</span> str)
  (<span>*-&gt;1</span> User <span>:reference</span> <span><span>&#34;</span>addresses<span>&#34;</span></span>))</pre></div>
<p dir="auto">There will be <strong>no extra cost in runtime</strong> as <code>defmodel</code> is merely a macro that expand the code into the SQLAlchemy one above. To me, this is the true power of lisp, and a stabilized set of internals and APIs of Hy is a must for this kind of thing, so thank you all for the release of 1.0.</p>
    </td>
  </tr>

    </tbody>
  </div></div>
  </body>
</html>
