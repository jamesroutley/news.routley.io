<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sam.elborai.me/articles/tabular-programming/">Original</a>
    <h1>Tabular Programming: A New Paradigm for Expressive Computing</h1>
    
    <div id="readability-page-1" class="page"><div>
			<p>I&#39;ve been exploring the m8 Dirtywave tracker for a few months now, and it&#39;s been a fascinating experience. If you&#39;re not familiar with it, the m8 is a portable music sequencer built on the Teensy platform that combines a minimal 8-button interface with a powerful tabular workflow. What makes it special isn&#39;t just its portability or its sound capabilities, but how the hardware and interface work together to create an experience that&#39;s simultaneously constrained and liberating.</p>

<p>When I&#39;m making music on the m8, I don&#39;t feel like I&#39;m fighting with the UI or solving puzzles. It&#39;s more like intuitive cooking - mixing ingredients, tasting, adapting, and discovering new flavors along the way. I can lay on my couch, pick it up, and within minutes be immersed in the creative process. No re-learning complicated interfaces, no decision paralysis from too many options - just pure creative flow.</p>
<p>This experience got me thinking about programming environments. Most of our programming tools are designed for desktop workstations with keyboards, mice, and large displays. But what about a programming environment designed specifically for a minimal, portable hardware interface? What would programming look like if it was built around a tabular interface navigated with just a handful of buttons?</p>
<h2>The Core Idea</h2>
<p>I&#39;ve been conceptualizing a programming environment built around a tabular interface inspired by the m8. The key insight is that while traditional programming involves typing long streams of text, we could instead organize code into a structured table with each function defined as rows with fixed columns:</p>
<p><img src="https://sam.elborai.me/assets/4a7324c6d924c575_module-view.svg" title=""/></p>
<ol>
<li>NAME: The function identifier</li>
<li>IN: Input parameter specification</li>
<li>EXP1-EXP5: Five expression cells (the core of execution)</li>
<li>OUT: Output specification</li>
</ol>
<p>At first glance, limiting each function to just five expressions seems incredibly restrictive. But this constraint actually encourages breaking down complex operations into atomic, composable functions - which tends to produce more maintainable code.</p>
<ol>
<li>NAME: The function identifier</li>
<li>IN: Input parameter specification</li>
<li>EXP1-EXP5: Five expression cells (the core of execution)</li>
<li>OUT: Output specification</li>
</ol>
<p>At first glance, limiting each function to just five expressions seems incredibly restrictive. But this constraint actually encourages breaking down complex operations into atomic, composable functions - which tends to produce more maintainable code.</p>
<p>The hardware component is just as important as the software model. The target hardware would be deliberately minimal:</p>
<ul>
<li>Teensy 4.1 microcontroller (same as the m8)</li>
<li>320x240 display</li>
<li>D-pad, A/B, START/SELECT buttons (8 buttons total)</li>
<li>microSD slot and headphone jack</li>
</ul>
<p>You would navigate the table with the D-pad, edit cells with the A button (which brings up a contextual menu), and run your program with START. No keyboard needed - all programming happens on the device itself through selection rather than typing.</p>
<p>This isn&#39;t just about building yet another programming tool - it&#39;s about exploring how hardware constraints can lead to new programming paradigms. When you start from the assumption that your interface has just 8 buttons and a small screen, you&#39;re forced to rethink fundamental aspects of how programming works.</p>
<p>The current concept is built on a stack-based model similar to Forth, but that&#39;s just an implementation detail. The core innovation is the tabular programming model and how it maps to minimal hardware controls.</p>
<p>Some interesting properties emerge from this design:</p>
<ol>
<li><strong>Error Reduction</strong>: By selecting from valid options, many classes of syntax errors simply cannot happen</li>
<li><strong>Focused Decomposition</strong>: The five-expression limit forces thoughtful function decomposition</li>
<li><strong>Explicit Data Flow</strong>: Data flow between expressions is visually explicit in the table</li>
<li><strong>Portability</strong>: The entire environment is designed for programming on the go, in casual positions</li>
</ol>
<h2>Real-World Examples: Demoscene Effects</h2>
<p>To demonstrate that this concept isn&#39;t just theoretical, let&#39;s explore how a classic demoscene effect - a plasma - would be implemented using this tabular programming model:</p>
<pre><code>┌─────────┬─────┬───────┬───────┬───────┬───────┬───────┬─────┐
│ NAME    │ IN  │ EXP1  │ EXP2  │ EXP3  │ EXP4  │ EXP5  │ OUT │
├─────────┼─────┼───────┼───────┼───────┼───────┼───────┼─────┤
│ PLASMA  │ void│ INIT  │ LOOP  │       │       │       │ void│
│ INIT    │ void│ 0     │ →TIME │ 0     │ →BEAT │       │ void│
│ LOOP    │ void│ TIME+ │ CLR   │ CALC  │ DISP  │ LOOP  │ void│
│ CLR     │ void│ 0     │ VRAM! │       │       │       │ void│
│ CALC    │ void│ 0     │ 0     │ Y-LOOP│       │       │ void│
│ Y-LOOP  │ Y   │ 0     │ X-LOOP│ Y 1+  │ Y&lt;H?  │ Y-LOOP│ void│
│ X-LOOP  │ X Y │ PXCALC│ PLOT  │ X 1+  │ X&lt;W?  │ X-LOOP│ void│
│ PXCALC  │ X Y │ X 16/ │ SIN   │ Y 16/ │ COS   │ +     │ VAL │
│ PLOT    │ X Y V│ TIME  │ V +   │ BEAT  │ *     │ !PIXEL│ void│
│ TIME+   │ void│ TIME  │ 1 +   │ →TIME │ BEAT+ │       │ void│
│ BEAT+   │ void│ AUDIO │ THRSH&gt;?│ BEAT1+│       │       │ void│
│ BEAT1+  │ void│ BEAT  │ 16 +   │ 127 MIN│ →BEAT│       │ void│
└─────────┴─────┴───────┴───────┴───────┴───────┴───────┴─────┘
</code></pre>
<p>Let&#39;s break down how this plasma effect works in detail:</p>
<p>The entry point <code>PLASMA</code> first calls <code>INIT</code> to set up initial state variables, then calls <code>LOOP</code> to start the main execution loop. The <code>INIT</code> function initializes two global variables: <code>TIME</code> set to 0 to track animation time, and <code>BEAT</code> set to 0 to respond to audio input. The arrow symbol (<code>→</code>) represents assignment to a variable, making the data flow explicit.</p>
<p>The main <code>LOOP</code> function orchestrates the entire effect by:</p>
<ol>
<li>Calling <code>TIME+</code> to increment the time counter</li>
<li>Calling <code>CLR</code> to clear the screen by writing 0 to video memory</li>
<li>Calling <code>CALC</code> to calculate the plasma values</li>
<li>Calling <code>DISP</code> (implied but not shown) to display the frame</li>
<li>Recursively calling itself to continue the animation loop</li>
</ol>
<p>The actual plasma calculation happens through a nested loop structure. <code>CALC</code> sets up the initial Y coordinate (0) and calls <code>Y-LOOP</code>. The <code>Y-LOOP</code> function then processes each row of pixels by:</p>
<ol>
<li>Setting the initial X coordinate to 0</li>
<li>Calling <code>X-LOOP</code> to process that row</li>
<li>Incrementing Y by 1</li>
<li>Checking if Y is less than the screen height (<code>Y&lt;H?</code>)</li>
<li>If so, recursively calling itself to process the next row</li>
</ol>
<p>Similarly, <code>X-LOOP</code> processes each pixel in a row by:</p>
<ol>
<li>Calling <code>PXCALC</code> to calculate the plasma value for that pixel</li>
<li>Calling <code>PLOT</code> to set the pixel</li>
<li>Incrementing X by 1</li>
<li>Checking if X is less than the screen width (<code>X&lt;W?</code>)</li>
<li>If so, recursively calling itself to process the next pixel</li>
</ol>
<p>The core math of the plasma effect happens in <code>PXCALC</code>. It:</p>
<ol>
<li>Takes X and Y coordinates as input</li>
<li>Divides X by 16 to scale it down</li>
<li>Calculates the sine of that scaled X value</li>
<li>Divides Y by 16 to scale it down</li>
<li>Calculates the cosine of that scaled Y value</li>
<li>Adds the sine and cosine values together</li>
<li>Returns this sum as the plasma value (<code>VAL</code>)</li>
</ol>
<p>This creates a simple plasma pattern based on the interference of sine and cosine waves. The division by 16 controls the frequency of the waves.</p>
<p><code>PLOT</code> takes X, Y coordinates and a value V as input, then:</p>
<ol>
<li>Adds the current <code>TIME</code> to the value to animate the plasma</li>
<li>Multiplies by the current <code>BEAT</code> value to make it respond to audio</li>
<li>Calls <code>!PIXEL</code> to set the pixel at (X,Y) with the resulting color value</li>
</ol>
<p>The <code>TIME+</code> function increments the <code>TIME</code> variable by 1 and then calls <code>BEAT+</code> to update the beat value. The audio responsiveness is implemented by <code>BEAT+</code> and <code>BEAT1+</code>:</p>
<ol>
<li><code>BEAT+</code> reads the audio input level (<code>AUDIO</code>) and checks if it&#39;s above a threshold (<code>THRSH&gt;?</code>)</li>
<li>If it is, it calls <code>BEAT1+</code> to increase the beat value</li>
<li><code>BEAT1+</code> adds 16 to the current beat value, limits it to a maximum of 127, and stores it back in the <code>BEAT</code> variable</li>
</ol>
<p>This creates a visual &#34;pulse&#34; effect when audio input is detected, as the plasma pattern will get brighter or more saturated.</p>
<p>What&#39;s particularly fascinating about this implementation is how it manages data flow using the stack. Between each expression cell, data implicitly moves via the stack. For example, in the <code>PXCALC</code> function:</p>
<pre><code>│ PXCALC  │ X Y │ X 16/ │ SIN   │ Y 16/ │ COS   │ +     │ VAL │
</code></pre>
<p>The stack operations would be:</p>
<ol>
<li>Start with X and Y on the stack</li>
<li><code>X 16/</code>: Pop X, divide by 16, push result (let&#39;s call it X&#39;)</li>
<li><code>SIN</code>: Pop X&#39;, calculate sine, push result (sin(X&#39;))</li>
<li><code>Y 16/</code>: Pop Y, divide by 16, push result (Y&#39;)</li>
<li><code>COS</code>: Pop Y&#39;, calculate cosine, push result (cos(Y&#39;))</li>
<li><code>+</code>: Pop cos(Y&#39;), pop sin(X&#39;), add them, push result (sin(X&#39;) + cos(Y&#39;))</li>
</ol>
<p>The final value on the stack is the plasma value that gets returned as <code>VAL</code>.</p>
<p>This illustrates how the stack implicitly connects operations within a row, while the explicit function calls (like <code>X-LOOP</code> calling <code>PXCALC</code> and then <code>PLOT</code>) handle data flow between rows.</p>
<p>To execute this tabular code, a virtual machine would need to:</p>
<ol>
<li>Maintain a data stack and a return stack</li>
<li>Process each expression cell from left to right within a row</li>
<li>Handle function calls by pushing the current position to the return stack and jumping to the new function</li>
<li>Support basic stack operations, arithmetic, conditionals, and variable storage</li>
<li>Provide hardware abstraction for screen access, audio input, etc.</li>
</ol>
<p>The beauty of this approach is that the VM can be quite simple while still supporting powerful programs. The tabular structure adds a layer of organization that makes the code more readable and navigable than traditional Forth, while still leveraging the power of stack-based programming.</p>
<p>Here&#39;s another example of a classic demoscene effect - a tunnel:</p>
<pre><code>┌─────────┬─────┬───────┬───────┬───────┬───────┬───────┬─────┐
│ NAME    │ IN  │ EXP1  │ EXP2  │ EXP3  │ EXP4  │ EXP5  │ OUT │
├─────────┼─────┼───────┼───────┼───────┼───────┼───────┼─────┤
│ MAIN    │ void│ INIT  │ LOOP  │       │       │       │ void│
│ INIT    │ void│ 0     │ →TIME │ GEN-LUT│      │       │ void│
│ LOOP    │ void│ TIME+ │ CLR   │ CALC  │ DISP  │ LOOP  │ void│
│ CLR     │ void│ 0     │ VRAM! │       │       │       │ void│
│ GEN-LUT │ void│ 0     │ ANGLE │ 0     │ DIST  │       │ void│
│ ANGLE   │ Y   │ 0     │ ANG-X │ Y 1+  │ Y&lt;H?  │ ANGLE │ void│
│ ANG-X   │ X Y │ X CX -│ Y CY -│ ATAN2 │ →ANG  │ X+    │ void│
│ DIST    │ Y   │ 0     │ DST-X │ Y 1+  │ Y&lt;H?  │ DIST  │ void│
│ DST-X   │ X Y │ X CX -│ Y CY -│ HYPOT │ →DST  │ X+    │ void│
│ CALC    │ void│ 0     │ 0     │ Y-LOOP│       │       │ void│
│ Y-LOOP  │ Y   │ 0     │ X-LOOP│ Y 1+  │ Y&lt;H?  │ Y-LOOP│ void│
│ X-LOOP  │ X Y │ X Y   │ TEX   │ PLOT  │ X 1+  │ X&lt;W?  │ void│
│ TEX     │ X Y │ ANG@  │ DST@  │ TIME +│ PTRN  │       │ C   │
│ PLOT    │ X Y C│ X    │ Y     │ C     │ !PIXEL│       │ void│
│ TIME+   │ void│ TIME  │ 1 +   │ →TIME │       │       │ void│
└─────────┴─────┴───────┴───────┴───────┴───────┴───────┴─────┘
</code></pre>
<p>The tunnel effect works by precalculating angle and distance lookup tables (<code>GEN-LUT</code>, <code>ANGLE</code>, <code>ANG-X</code>, <code>DIST</code>, <code>DST-X</code>) and then using those tables to map each screen pixel to a position in a texture pattern. The angle (<code>ATAN2</code>) and distance (<code>HYPOT</code>) calculations would normally be expensive operations, but by precalculating them into lookup tables, the effect can run at full speed even on limited hardware.</p>
<p>What&#39;s impressive about these examples is how they demonstrate complex mathematics and visualization techniques in a highly constrained programming model. Despite the five-expression limit per function, these programs can create sophisticated visual effects with smooth animation and even audio responsiveness.</p>
<p>While demoscene effects are a great way to demonstrate the capabilities of this system, I&#39;m more excited about its potential for creative applications like pixel art editors, music tools, or interactive storytelling environments.</p>
<p>Imagine a pixel art painting program implemented in this tabular format. The main structure might look something like this:</p>
<pre><code>┌─────────┬─────┬───────┬───────┬───────┬───────┬───────┬─────┐
│ NAME    │ IN  │ EXP1  │ EXP2  │ EXP3  │ EXP4  │ EXP5  │ OUT │
├─────────┼─────┼───────┼───────┼───────┼───────┼───────┼─────┤
│ MAIN    │ void│ INIT  │ LOOP  │       │       │       │ void│
│ INIT    │ void│ LOAD-│ CANVAS│ UI-INIT│       │       │ void│
│ LOOP    │ void│ INPUT │ PROCESS│ RENDER│ SAVE? │ LOOP  │ void│
│ INPUT   │ void│ JOY   │ BUTTONS│ →STATE│       │       │ void│
│ PROCESS │ void│ MODE? │ DRAW  │ FILL  │ SELECT│ MENU  │ void│
│ RENDER  │ void│ CANVAS│ CURSOR│ UI    │ FLIP  │       │ void│
└─────────┴─────┴───────┴───────┴───────┴───────┴───────┴─────┘
</code></pre>
<p>The real power would come from how naturally the hardware maps to the application. The D-pad could move your cursor or navigate UI elements, the A button would draw or select, and B would undo or cancel. The entire interface would be designed around the constraints of the hardware, making it feel natural and intuitive rather than limited.</p>
<p>One of the challenges with this approach is scaling beyond simple demos. To address this, I&#39;ve been thinking about a hierarchical organization model inspired by the m8&#39;s structure. The m8&#39;s navigation system is quite elegant - it divides the interface into &#34;Views&#34; that can be navigated by holding SHIFT and using the direction keys, with a helpful mini-map in the corner showing your location.</p>
<p><img src="https://sam.elborai.me/assets/b1e89057bd529a81_functions-view.svg" title=""/></p>
<p>The context-sensitive menu system would be a crucial part of making this environment work with so few controls. When you press the A button to edit a cell, you would see a menu of valid options for that context. This eliminates syntax errors and makes discovery of available functions organic.</p>
<p><img src="https://sam.elborai.me/assets/c9fbf7397ac07303_function-edit.svg" title=""/></p>
<p>For example, when editing an expression cell, the menu might show available functions, variables, constants, and operators. The options would be filtered based on the current context, so you only see what&#39;s relevant. This approach makes programming feel more like navigation than typing.</p>
<p>What excites me most about this concept isn&#39;t just the software model, but how the hardware and software could work together when designed as an integrated system. The m8 succeeds because it isn&#39;t just tracker software running on portable hardware - it&#39;s a complete experience where every aspect of the hardware and software are designed to work together.</p>
<p>Similarly, this tabular programming environment isn&#39;t just about cramming programming capabilities into a Game Boy-like
device. It&#39;s about rethinking programming from the ground up for a specific hardware context. The result would be
something that doesn&#39;t feel constrained when you&#39;re using it - it feels natural and intuitive for its purpose, even if
it looks strange and completely foreign at first.</p>
<p>This tabular programming concept opens up many possibilities for exploration. By rethinking how programming can work within tight hardware constraints, we might discover new approaches that actually enhance rather than limit creative expression. I&#39;m sharing this idea because I believe there&#39;s something genuinely interesting in the intersection of minimal hardware interfaces and structured programming models.</p>

		</div></div>
  </body>
</html>
