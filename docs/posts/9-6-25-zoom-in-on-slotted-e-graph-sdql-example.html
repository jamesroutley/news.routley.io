<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/saulshanabrook/saulshanabrook/discussions/44">Original</a>
    <h1>9/6/25 Zoom in on slotted e-graph sdql example</h1>
    
    <div id="readability-page-1" class="page"><div role="presentation" data-paste-markdown-skip="">
    <tbody data-target-translation-id="8850593" data-target-translation-type="discussion">
        <tr>
    <td>
        <p dir="auto">Follow up from <a data-error-text="Failed to load title" data-id="8843034" data-permission-text="Title is private" data-url="https://github.com/saulshanabrook/saulshanabrook/discussions/42" data-hovercard-type="discussion" data-hovercard-url="/saulshanabrook/saulshanabrook/discussions/42/hovercard" href="https://github.com/saulshanabrook/saulshanabrook/discussions/42">#42</a></p>
<p dir="auto">High level thoughts are:</p>
<ol dir="auto">
<li>Understand particular semantics of SDQL encoding to see how rewrites work</li>
<li>ERe-implement SQDL egg encoding in egglog Python for easier use</li>
<li>(optional) see how if slotted e-graph version can be embedded in egglog as well, or if not, then at least try to understand it</li>
<li>Map this to functional synatx in egglog, to see what starting ruleset would be and ending ruleset, for functions as rules</li>
<li>Start to actually do research of how we could partially evaluate rulesets to do higher order functions</li>
<li>Once finished (lol) compare against other embedding in egglog, as well as egg and slotted e-graph</li>
</ol>
<p dir="auto">First step is to understand SDQL semanatics!</p>
<p dir="auto"><a href="https://github.com/memoryleak47/slotted-egraphs-artifact/blob/main/sdql/slotted/progs/mmm_sum_1st.sexp">https://github.com/memoryleak47/slotted-egraphs-artifact/blob/main/sdql/slotted/progs/mmm_sum_1st.sexp</a></p>
<p dir="auto">Trying to see what eqsat does:</p>
<p dir="auto">Original: <a href="https://github.com/memoryleak47/slotted-egraphs-artifact/blob/main/sdql/baseline/progs/mmm_sum_1st.sexp">https://github.com/memoryleak47/slotted-egraphs-artifact/blob/main/sdql/baseline/progs/mmm_sum_1st.sexp</a></p>
<p dir="auto">Cleaned <a href="https://chatgpt.com/share/68bc6f5f-e7b4-8011-849b-6dbc913e03d6" rel="nofollow">up by chatgpt</a>:</p>
<blockquote>

<p dir="auto">Goal (scalar):</p>
<p dir="auto"><math-renderer data-run-id="270235d572fcbbfefc0f249098c9552f">$$
Q ;=; \sum_{i,j,k} A(i,k),B(k,j)
$$</math-renderer></p>
<p dir="auto">Below are two equivalent encodings in the paper’s <strong>relational functional IR</strong>:</p>
<ol dir="auto">
<li>a direct triple-sum, and</li>
<li>an equality-saturated / factored form.</li>
</ol>
<blockquote>
<p dir="auto">Note: There is <strong>no <code>sing</code></strong> in ΣMMM; every <code>sum</code> produces a scalar, so the whole program returns a scalar.</p>
</blockquote>
<hr/>
<h2 dir="auto">1) ΣMMM — Original triple-sum form</h2>
<div dir="auto" data-snippet-clipboard-copy-content="(lambda A                                    // A : k ↦ (i ↦ A(i,k))   (column view)
  (lambda B                                  // B : k ↦ (j ↦ B(k,j))   (row view by k)
    (sum k Ak (var A)                        // for each k, Ak = A(:,k)
      (sum i Aik (var Ak)                    //   for each i with A(i,k) ≠ 0
        (sum j Bkj (get (var B) (var k))     //     for each j with B(k,j) ≠ 0
          (* (var Aik) (var Bkj))            //       contribute A(i,k) * B(k,j)
))))))"><pre><span>(</span><span>lambda</span> A                                    // A : k ↦ (i ↦ A(i,k))   (column view)
  <span>(</span><span>lambda</span> B                                  // B : k ↦ (j ↦ B(k,j))   (row view by k)
    <span>(</span><span>sum</span> k Ak <span>(</span>var A<span>)</span>                        // for each k, Ak = A(:,k)
      <span>(</span><span>sum</span> i Aik <span>(</span>var Ak<span>)</span>                    //   for each i with A(i,k) ≠ 0
        <span>(</span><span>sum</span> j Bkj <span>(</span><span>get</span> <span>(</span>var B<span>)</span> <span>(</span>var k<span>)</span><span>)</span>     //     for each j with B(k,j) ≠ 0
          <span>(</span><span>*</span> <span>(</span>var Aik<span>)</span> <span>(</span>var Bkj<span>)</span><span>)</span>            //       contribute A(i,k) * B(k,j)
<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span></pre></div>
<h3 dir="auto">Semantics</h3>
<ul dir="auto">
<li><code>A</code> is accessed <strong>by column</strong>: for each <code>k</code>, iterate the sparse map <code>Ak = A(:,k)</code>.</li>
<li>For each <code>(i, A(i,k))</code> in <code>Ak</code>, iterate the sparse row <code>B(k,:)</code> to get <code>(j, B(k,j))</code>.</li>
<li>Multiply <code>A(i,k) * B(k,j)</code> and <strong>sum</strong> over <code>j</code>, then <code>i</code>, then <code>k</code>.</li>
<li>Returns a <strong>scalar</strong> <code>Q</code> (no <code>sing</code> used anywhere).</li>
</ul>
<hr/>
<h2 dir="auto">2) ΣMMM — Equality-saturated / factored form</h2>
<p dir="auto">Mathematically:</p>
<p dir="auto"><math-renderer data-run-id="270235d572fcbbfefc0f249098c9552f">$$
Q ;=; \sum_k \Big(\sum_i A(i,k)\Big);\Big(\sum_j B(k,j)\Big)
$$</math-renderer></p>
<div dir="auto" data-snippet-clipboard-copy-content="(lambda A                                    // A : k ↦ (i ↦ A(i,k))
  (lambda B                                  // B : k ↦ (j ↦ B(k,j))
    (sum k Ak (var A)                        // for each k
      (* (sum i Aik (var Ak) (var Aik))      //   S_A(k) = ∑_i A(i,k)
         (sum j Bkj (get (var B) (var k))    //   S_B(k) = ∑_j B(k,j)
              (var Bkj)
))))))"><pre><span>(</span><span>lambda</span> A                                    // A : k ↦ (i ↦ A(i,k))
  <span>(</span><span>lambda</span> B                                  // B : k ↦ (j ↦ B(k,j))
    <span>(</span><span>sum</span> k Ak <span>(</span>var A<span>)</span>                        // for each k
      <span>(</span><span>*</span> <span>(</span><span>sum</span> i Aik <span>(</span>var Ak<span>)</span> <span>(</span>var Aik<span>)</span><span>)</span>      //   S_A(k) = ∑_i A(i,k)
         <span>(</span><span>sum</span> j Bkj <span>(</span><span>get</span> <span>(</span>var B<span>)</span> <span>(</span>var k<span>)</span><span>)</span>    //   S_B(k) = ∑_j B(k,j)
              <span>(</span>var Bkj<span>)</span>
<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span></pre></div>
<h3 dir="auto">Semantics</h3>
<ul dir="auto">
<li>For each <code>k</code>, compute the <strong>column-sum</strong> <code>S_A(k) = Σ_i A(i,k)</code> and the <strong>row-sum</strong> <code>S_B(k) = Σ_j B(k,j)</code>.</li>
<li>Multiply <code>S_A(k) * S_B(k)</code> and sum over <code>k</code>.</li>
<li>Returns the same <strong>scalar</strong> <code>Q</code>.</li>
</ul>
<hr/>
<h2 dir="auto">Equivalence &amp; optimization</h2>
<ul dir="auto">
<li>Both encodings are equivalent by associativity/commutativity of addition and distributivity over multiplication.</li>
<li>The <strong>factored form</strong> can be advantageous when computing <code>Σ_i A(i,k)</code> and <code>Σ_j B(k,j)</code> is cheaper than enumerating all <code>(i,j)</code> pairs reachable from each <code>k</code> (e.g., when columns of <code>A</code> and rows of <code>B</code> are long but summing them is efficient).</li>
</ul>
</blockquote>
    </td>
  </tr>

    </tbody>
  </div></div>
  </body>
</html>
