<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dxuuu.xyz/casts.html">Original</a>
    <h1>Truthiness in C</h1>
    
    <div id="readability-page-1" class="page"><a href="https://dxuuu.xyz">Home</a>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->



<p>This week someone mentioned that C supports casting from
<code>int</code> to <code>bool</code>. That naturally triggered my
curiosity – what does the generated code look like?</p>
<p>First I think it’s important to point out most casts in C are “free”.
“Free” in the sense that the compiler changes its internal understanding
of an expression. But in actual assembly nothing really changes –
registers don’t have types. (NB: architecture dependent)</p>
<p>For example, consider:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>char</span> a<span>(</span><span>int</span> x<span>)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>(</span><span>char</span><span>)</span>x<span>;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span>int</span> b<span>(</span><span>char</span> x<span>)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>(</span><span>int</span><span>)</span>x<span>;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span>char</span> <span>*</span>c<span>(</span><span>int</span> <span>*</span>x<span>)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>(</span><span>char</span> <span>*)</span>x<span>;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>The generated code looks like:</p>
<pre><code>a(int):
        mov     eax, edi
        ret
b(char):
        movsx   eax, dil
        ret
c(int*):
        mov     rax, rdi
        ret</code></pre>
<p>Clearly we are just moving values between the argument register and
the return register. So the cast is “free”.</p>
<p>But what about casting from <code>int</code> to
<code>bool</code>?</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>bool</span> d<span>(</span><span>int</span> x<span>)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>(</span><span>bool</span><span>)</span>x<span>;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Well, the compiler gives us:</p>
<pre><code>d(int):
        test    edi, edi
        setne   al
        ret</code></pre>
<p>We see that it generates code to first <code>test eax</code> and then
to <code>setne al</code>. <a href="https://web.itu.edu.tr/kesgin/mul06/intel/instr/test.html"><code>test</code></a>
is used to set the status flags. <a href="https://web.itu.edu.tr/kesgin/mul06/intel/instr/setne_setnz.html"><code>setne</code></a>
is used to set the lowest 8 bit subregister in <code>rax</code>.
<code>rax</code> is used to <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">return
integer values</a> from a function in the System V ABI.</p>
<p>Note that the top 56 bits in <code>rax</code> are not zeroed – they
contain junk. This is fine b/c the compiler will only make callers check
the lowest bit of a register for boolean operations. This is why
changing the compiler’s “understanding” (ie the cast) is necessary.</p>
<p>So, two otherwise extra instructions. Not too bad for how useful it
is.</p>
<p>See the full code <a href="https://godbolt.org/z/osTjnqnn9">here</a>.</p>
<h3 id="errata">Errata</h3>
<p>Thanks thxg on HN for pointing out that I was incorrectly compiling
with <code>-m32</code> but talking about x86-64.</p>
<p>And also to AshamedCaptain for pointing out the x86 centered
assumptions.</p>


</div>
  </body>
</html>
