<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ezzeriesa.com/index/Writing%20efa7772a3ae64a8193c7ef981ac619fc/How%20to%20level%20up%20beyond%20ETLs%200987988358654751a8538a05bde18f96.html">Original</a>
    <h1>How to level up beyond ETLs</h1>
    
    <div id="readability-page-1" class="page"><div><p id="3152a8d8-a41c-4776-8331-ded056947300">The Slack messages are coming in hard and fast. Why is the cluster slow? How is gross revenue smaller vs net revenue? When will the marketing columns get added? Why does the dashboard not match the enterprise accounts table? How long will the backfill take? You feel like quitting.</p><p id="009e34f9-a30f-4dc9-bd26-17032b067b48">Getting technical people to solve problems faced by business people is not new. What’s new is how every part of the business now runs on data, and thus the growing need for data experts to keep things moving. The tricky part is when context goes ‘over the wall’ - the consumer finds an issue with the data but the producer is not familiar with the domain to see it’s a problem. Over time, information transfer between the two sides becomes the bottleneck and issues pile up.</p><p id="b02e5b10-b397-4e69-bbef-d9385c819ae6">In proposing a solution, Stitch Fix has the boldly-titled blog post <a href="https://multithreaded.stitchfix.com/blog/2016/03/16/engineers-shouldnt-write-etl">Engineers Shouldn’t Write ETL</a>. The idea here is the engineering team creates ‘Lego blocks’ that consumers then assemble into end-to-end data pipelines. This tends to work better when consumers are themselves technical; in any case a lot of upfront investment is needed. More and more startups get created every day with the promise to make this process effortless, but for now you’re the data engineer and you need to figure it out.</p><p id="bd407c69-910c-442f-bb7a-13f9e4c1fb9a">Maybe this isn’t what you signed up for. Maybe there was some bait-and-switch; you were hired to write Python but due to ‘critical initiatives’ you end up writing SQL (side note: SQL is Turing complete). Maybe the manager who hired you left and the new one feels the team should have a wider scope. Maybe the CTO left and sales/marketing/finance/ops now has the CEO’s ear.</p><p id="41768adf-4d16-4847-93bf-37fda07a1f7d">My friends, I feel your pain. We can’t turn back time, but perhaps we can reflect on the more interesting things to work on moving forwards.</p><p id="9fbe47c1-b761-4906-ae12-8524b4110964">Tell your customers you’ll speed up their queries and they’ll love you for it. I’ve worked with the following relational databases (or if you’re pedantic, RDBMS) in production: MySQL, Hive, Vertica, Snowflake, Redshift, Postgres. The common thread? Complaints about slow queries.</p><p id="40b5e4e4-2b62-4d2b-8d7a-c13da8640f90">Relational databases have been around for a while, and are among the most ‘battle-tested’ software around. If your query is slow, odds are it’s your query and not the database.</p><figure id="7297134e-7146-4e36-ab5a-62454002f86c"><p><span>⚡</span></p><p>How do we speed up our queries?</p></figure><p id="391fe352-a810-4bfd-bf20-77e51baa86e1">Databases used in data warehouses tend to be columnar-store; in this section we’ll focus on Redshift. The simplest way to make your queries run faster is to select only the columns you need. Let’s say you have a table where each row represents an event.</p><pre id="67bd6298-17aa-40cc-8824-ee13663d12df"><code>CREATE TABLE events (
    event_id      VARCHAR
    event_ts      TIMESTAMP
    user_id       VARCHAR
    browser_id    VARCHAR
);</code></pre><p id="a45a71c9-0602-45dd-bc58-204d22c9ab06">Suppose you only need the first two columns. Instead of using selecting all the columns, you get a speed up for free by specifying only the columns you need.</p><pre id="519f7793-ac1c-4a71-8232-951951c75fa3"><code>SELECT
    *

FROM
    events</code></pre><pre id="a55f12d2-7c48-4e90-8fbf-f5caf0f6dcbc"><code>SELECT
    event_id
  , event_ts

FROM
    events</code></pre><p id="db54c0d4-0467-4eb5-a25e-4296a3e74f63">Note this doesn’t apply to Postgres or MySQL or SQLite, since these databases are row-oriented.</p><p id="c38087b8-dd4d-4aa3-8876-ecba32985106">In diagnosing slow queries, the main culprit tends to be joins. What I wished someone told me about Redshift is to set the most common join column as the distribution key and the most common range filter column as the sort key. This is the 80/20.</p><p id="d203c850-7cfe-43ba-9d10-8e98c50a4211">Re: distribution keys, the motivating idea is fast query execution across multiple machines. The fancy term for this is massively-parallel processing (MPP). Since the data won’t fit in a single machine, the rows could either be spread out randomly, copied across all machines, or distributed using a bucketing mechanism like the hash of a specific column. The distribution key can be thought of as this hash.</p><p id="2a0dc2fb-3707-4d05-8be3-bedb24b9d96a">Let’s look back at our table. Suppose <code>event_id</code> is the unique identifier for each event, but consumers mainly use the table to investigate user behavior. This means that most joins to other tables will be on <code>user_id</code>. Setting <code>user_id</code> as the distribution key means the rows will be distributed in the cluster based on the hash of <code>user_id</code>. If you’re joining to another table which also has a <code>user_id</code> distribution key, then the data is co-located. Less I/O means faster queries. </p><p id="0d849c50-bae7-45df-99b5-376c239d7b1b">Even if only one table has <code>user_id</code> as the distribution key, then only the rows from one table need to be ‘fanned out’ across the cluster (instead of both). Like most operations that involve hashing, you also want to ensure that <code>user_id</code> has low percentage of nulls and high cardinality to ensure an even distribution.</p><p id="5bb961cc-67ae-4e20-a430-bc37f80dad61">Re: sort keys, the motivating idea is fast loading from storage across multiple machines. The sort key determines how rows are sorted in each machine. Running a query with a filter on the sort key speeds things up because loads take place across a smaller range. In our example, we may be interested only in events in a specific date range; <code>event_ts</code> would thus make a good candidate for the sort key. Less sorting means faster queries.</p><p id="5c46b544-13e2-4f9c-a5ab-d0d356ef9a3a">To create the table with <code>user_id</code> as the distribution key and <code>event_ts</code> as the sort key, specify the distribution and sort key details at the end.</p><pre id="0fa8a3c1-96f8-4cd9-a85c-201869f08f07"><code>CREATE TABLE events (
    event_id      VARCHAR
    event_ts      TIMESTAMP
    user_id       VARCHAR
    browser_id    VARCHAR
)
DISTSTYLE KEY
DISTKEY (user_id)
SORTKEY (event_ts);
;</code></pre><p id="bfb53198-3d49-4770-a14a-9492cfe18b2a">There’s definitely more to be said on Redshift (AWS post <a href="https://aws.amazon.com/blogs/big-data/amazon-redshift-engineerings-advanced-table-design-playbook-distribution-styles-and-distribution-keys">here</a>) or how things work ‘under the hood’ more generally: Redshift vs Postgres (fast aggregates vs fast single row access), key-value stores, compact formats for data-at-rest like Parquet or data-over-the-wire like Protocol Buffers - more suggestions in the <a href="https://www.ezzeriesa.com/index/Writing%20efa7772a3ae64a8193c7ef981ac619fc/How%20to%20level%20up%20beyond%20ETLs%200987988358654751a8538a05bde18f96.html">section below</a>. It’s my vote of confidence for <a href="https://www.benkuhn.net/blub">blub studies</a>.</p><p id="c0a73b10-035a-4174-aba9-4f4d7503d4f8">OK queries are now faster, you’ve bought yourself some time to write code. While offering to rewrite the stack in Rust might be hard sell, setting up a framework to improve data quality is something everyone can get on board with.</p><figure id="10b74a1c-c78d-4f8c-8a12-81e8adebff7f"><p><span>📈</span></p><p>How do we improve data quality?</p></figure><p id="48e3757b-a46f-4732-a136-f4fdbab8665a">The first is by preventing bad data. Suppose <code>event_id</code> should never be null. To prevent this, we can introduce data quality checks to raise a runtime error if there are null values in the column. This way the rows in question are not inserted into the final table, but remain in a staging table for closer review. We’ll refer back to data quality checks at the end of this section.</p><p id="70e563e1-9979-4b59-8d79-2aeb9827d614">The second is by preventing bad queries. Suppose we have the following rows in the events table (remaining columns omitted for clarity).</p><pre id="8e1b0d80-1baa-49f4-b192-bbee44abe5a1"><code> user_id  | browser_id
----------+------------
          | brws0001
 user0001 | brws0002</code></pre><p id="0cda77a7-7d3e-4611-b108-3a666afc76cc">Now let’s say our query looks for <code>browser_id</code> seen with a non-null <code>user_id</code>. If our query returns the pair <code>brws0001 - user0001</code>, then we know something is wrong. To protect ourselves against this, we can borrow a pattern we see all the time in software: unit testing.</p><p id="ffa7a101-d505-4d10-abae-dee9a0d2a54f">Here’s how it works.</p><ol type="1" id="70d85dba-bf62-4d5c-bb6c-24ce84c71315" start="1"><li>Set up mock input table</li></ol><ol type="1" id="29b62d45-4a44-43e7-91d4-506224a2e568" start="2"><li>Insert rows above</li></ol><ol type="1" id="32fc7d4b-00e4-4d8f-92d9-05545e8d8e17" start="3"><li>Run query</li></ol><ol type="1" id="c9a88b85-b6aa-41a4-a748-833efe2d01fc" start="4"><li>Read from output table</li></ol><ol type="1" id="1128033d-2f7b-4590-9d68-32a4da614cb2" start="5"><li>Assert output row has desired value</li></ol><p id="1e9e1a20-1892-476b-8df3-01ebadc16f8d">To do this you might want to set up a local Postgres instance to avoid calling Redshift; this way all tests can be run locally. Sounds like a lot of work? Good, you’ll get to write lots of code. In fact, a SQL unit testing framework is a great opportunity to try out a few novel programming ideas.</p><h3 id="a9e6b9e6-f92e-4f32-a844-ed84a969fcd7">ORMs</h3><p id="95d9be47-8ff0-468b-b807-0db7cb95278c">I first came across ORMs (Object Relational Mapping) when building web apps. ORMs like SQLAlchemy let you manipulate the data model as Python classes, as opposed to having to write SQL (or rather, custom string formatting functions that output SQL strings).</p><p id="093de486-eed2-4a7d-b720-8ca1e6765aab">In setting up Postgres for testing, we can leverage the SQLAlchemy engine and connection objects to abstract away database interactions. In other words, we can write the same code whether we’re interacting with Redshift (in production) or Postgres (in tests).</p><p id="cb5b1510-4db1-4a2a-b359-00e182db8d4c">We can also leverage SQLAlchemy table and column objects. For example, we can define our events table above as follows.</p><pre id="b6a3451b-9bd8-4f9e-8585-deb2879b4bd7"><code>class Table:
    __table__: sqlalchemy.Table


Base = declarative_base(Table)


class Events(Base):
    __tablename__ = &#34;events&#34;

    event_id = sqlalchemy.Column(sqlalchemy.String, primary_key=True)
    event_ts = sqlalchemy.Column(sqlalchemy.DateTime)
    user_id = sqlalchemy.Column(sqlalchemy.String)
    browser_id = sqlalchemy.Column(sqlalchemy.String)</code></pre><h3 id="07e0af69-1875-41d7-a67c-b22a4a76d810">Code generation</h3><p id="cd99fb52-8c49-4666-bb79-e735d1c68546">We can access Redshift to see what the column name and types are, and manually type them into the table schema file. That’s no fun.</p><p id="426250e4-a4a3-448b-b071-4f74f8926595">We could instead run code to create more code. The <a href="https://pypi.org/project/sqlacodegen">sqlacodegen</a> library lets you generate SQLAlchemy table schemas from the table in the database. This works well as a script. The table name of interest is specified as input. Running the script will load the schema from Redshift, convert it to a SQLAlchemy table and write it to a Python file. </p><h3 id="4fb9fa07-0193-4a71-8cc9-151ef418bfc9">Fixtures</h3><p id="114f096e-8685-4ef6-8400-c6aeba5d6bf5">We now have our mock tables, let’s take a closer look at inserting rows. Rows can be represented as a dictionary, where the keys are column names and values are the column values.</p><pre id="11a79d32-9dbf-4b48-a3ae-b537543f26e0"><code>row = dict(
		event_id = &#34;evnt0001&#34;,
		event_ts = datetime.datetime(2021, 1, 1, 0, 0, 0)
		user_id = &#34;user0001&#34;,
		browser_id = &#34;brws0001&#34;,   
)</code></pre><p id="9e020387-416a-4d39-b2d8-a402ee7c700e">When we need two rows, we can copy-and-paste boilerplate code. The problem here is we have to specify every key-value pair, which doesn’t help highlight <code>user_id</code> and <code>browser_id</code> as the columns we care about.</p><pre id="e72137e5-6b19-48d1-b3ba-c4e983fe3ac8"><code>rows = [
    dict(
        event_id =&#34;evnt0001&#34;,
        event_ts = datetime.datetime(2021, 1, 1, 0, 0, 0),
        user_id = &#34;user0001&#34;,
        browser_id = &#34;brws0001&#34;,
    ),
    dict(
        event_id = &#34;evnt0002&#34;,
        event_ts = datetime.datetime(2021, 1, 1, 0, 0, 0),
        user_id = None,
        browser_id = &#34;brws0002&#34;,
    ),
]</code></pre><p id="d177340a-6f2d-4560-8b86-c711831e1a0b">Since we have our events table above, why not use it? We can create a function that takes in a generic table schema and returns a row from the table. The <code>init_column</code> function here can either generate a random identifier (with a common prefix based on the column name) or a default value based on the type.</p><pre id="32b1376c-2f56-40fc-94ce-654f073d1cf0"><code>ColumnType = typing.Union[
    None, str, bool, int, float, datetime.date, datetime.datetime
]


def init_row(table_schema: typing.Type[Base]) -&gt; typing.Dict[str, ColumnType]:
    &#34;&#34;&#34; &#34;&#34;&#34;
    row: typing.Dict[str, ColumnType] = {}

    for column in table_schema.__table__.columns:
        row[column.name] = init_column(column.name)

    return row</code></pre><p id="ab84ba0b-e575-4ad3-82a9-c04d4abd8451">For our desired row, we can simply override the column values.</p><pre id="cb450b8a-a23a-416a-9467-261d0a7789b6"><code>row = init_row(Events)
row[&#34;user_id&#34;] = &#34;user0001&#34;
row[&#34;browser_id&#34;] = &#34;brws0002&#34;
print(row)</code></pre><pre id="06c685f0-ccfa-4036-a6ce-03836a96812c"><code>{
    &#39;event_id&#39;: &#39;evntxF7z&#39;,
    &#39;event_ts&#39;: datetime.datetime(2021, 1, 1, 0, 0),
    &#39;user_id&#39;: &#39;user0001&#39;,
    &#39;browser_id&#39;: &#39;brws0002&#39;
}</code></pre><h3 id="898e39b4-242d-44e7-8d95-addfb05a7654">Functional programming</h3><p id="206a2851-90a1-4420-8e63-13af78d1a631">It a little repetitive calling <code>init_row</code> multiple times when we need multiple rows. To generate multiple rows from a single function call, we can set up a row factory.</p><p id="471e0600-f15f-48b9-bac3-d8fc24055190">The <code>init_row</code> function takes in a table schema as input and outputs a row. Let’s kick this up a notch. We can define a function that takes in a table schema and outputs a custom function. The custom function takes in a dictionary with the override column values, and returns the row with the given override column values where specified and pre-set values elsewhere.</p><p id="f66fe9fb-1079-4070-a001-1ed18749f394">This might be easier to explain in code.</p><pre id="2e9f16b1-d848-4d39-ac0b-dcc8d8a1f5ae"><code>ColumnTypeDict = typing.Dict[str, ColumnType]


def init_row_factory(
    table_schema: typing.Type[Base],
) -&gt; typing.Callable[[ColumnTypeDict], ColumnTypeDict]:
    &#34;&#34;&#34; &#34;&#34;&#34;
    row_initial = init_row(table_schema)

    def closure(column_values: ColumnTypeDict) -&gt; ColumnTypeDict:
				&#34;&#34;&#34; &#34;&#34;&#34;
        row_final = row_initial.copy()
        row_final.update(column_values)

        return row_final

    return closure</code></pre><p id="fc651b8d-6d57-41a4-b6b6-6987d589d9f8">Let’s try it out.</p><pre id="81debc9d-14c2-45db-a298-1d15be204b98"><code>row_factory = init_row_factory(Events)
row = row_factory(dict(user_id=&#34;user0001&#34;, browser_id=&#34;brws0002&#34;))
print(row)</code></pre><pre id="e5199f5d-dc3a-49ea-8b37-59882ccf0922"><code>{
    &#39;event_id&#39;: &#39;evntCX51&#39;,
    &#39;event_ts&#39;: datetime.datetime(2021, 1, 1, 0, 0),
    &#39;user_id&#39;: &#39;user0001&#39;,
    &#39;browser_id&#39;: &#39;brws0002&#39;
}</code></pre><h3 id="6ddc98b5-8c43-4c7a-8070-57524471fa59">Meta-programming</h3><p id="cc9d83c2-4b67-455f-94be-e0e7d403ac32">Let’s recap. We now have a SQL unit testing framework set up to ensure queries are correctly written, and data quality checks to provide confidence that data in production tables has the desired properties. </p><figure id="c60f4315-43c3-4b00-b4d8-7826f66f9469"><p><span>🏆</span></p><p>How do we involve consumers in data quality checks?</p></figure><p id="cde6d389-a255-4594-b8ef-198c633c7373">The purpose here is two-fold. First, consumers have the best context to know when data looks ‘off’, and thus what checks to put in place. Second, making check creation self-serve helps everyone feel invested in the data quality. </p><p id="34b9d4b6-9463-470e-82b7-d8133058b97c">Suppose we have the following check.</p><pre id="31957c0b-4de6-4904-ac06-2bf5bb6266be"><code>def expect_non_null_column(rows: List[ColumnTypeDict], column_name: str):
    &#34;&#34;&#34; &#34;&#34;&#34;
    assert not None in [row[column_name] for row in rows]</code></pre><p id="2d0e97c9-b588-42dd-af95-b4f79b74197d">We set this up for our events table to make sure <code>event_id</code> is not null.</p><pre id="4d7f3284-cf00-49db-8297-4aaa1f2c5637"><code>expect_non_null_column(rows, &#34;event_id&#34;)</code></pre><p id="ef61a60d-006c-488d-8656-130321e2a9c2">It might not be too difficult for consumers to set this up, but let’s make this even more intuitive. We can set up a ‘parallel’ process so that checks can be defined in a config file like yaml.</p><pre id="57439a12-069a-4e81-af14-236f2dfa0d4d"><code>expect_non_null_column:
    column_name: event_id</code></pre><p id="a9ed8426-2951-4faa-8087-6cd119dad86f">To prevent configs from being incorrectly set up, we can create a Python test to load the config and compare it against the Python definition. In particular, we can use the function signature (via <code>__annotations__</code>) to ensure that the config values have the same types as our function.</p><p id="e815422d-12d8-4597-9f64-1d6036b79cd4">Donald Knuth says it best.</p><blockquote id="d2f7b25f-ad1d-4afd-9dd0-623d30e47c3d">If you find that you’re spending almost all your time on theory, start turning some attention to practical things; it will improve your theories. If you find that you’re spending almost all your time on practice, start turning some attention to theoretical things; it will improve your practice.</blockquote><p id="f69fdcc2-eb54-458d-b0d2-23c857cad4ae">If you have the budget and can fit in a part-time course, I would recommend <a href="https://bradfieldcs.com">Bradfield</a>. If you don’t have the budget but can take time off, I would recommend <a href="https://www.recurse.com">Recurse Center</a>. If it’s one book I’d recommend (for RC or otherwise), it’s <a href="https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321">Designing Data-Intensive Applications</a> by <a href="https://twitter.com/martinkl">Martin Kleppmann</a>. <a href="https://twitter.com/chipro">Chip Huyen</a> has also made available her Data Engineering 101 <a href="https://twitter.com/chipro/status/1357329955131191298">notes</a> for free.</p><p id="a75fd267-f440-4c42-9659-1408b01d09fa">Think of your job as a relationship. When things get bumpy, is breaking up the first thing that comes to mind? There’s nothing stopping you, but maybe you want to try to see if you can make it work. At the very least, think about the delayed opportunity to implement all the cool things we just talked about because you have to re-learn the stack at the new job.</p><p id="18d46c22-a5f7-40ce-945c-b54af52131f2">The data producer vs consumer divide has its share of drama and politics (the other divide is moving from writing SQL to training machine learning models, perhaps for another post). Everyone is trying to <a href="https://erikbern.com/2021/07/07/the-data-team-a-short-story.html">figure it out</a>. Give your manager the benefit of doubt. Trust your colleagues have the best intentions. Keep your head up, keep shipping. Things will get better.</p><p id="93329d21-87ee-4cf3-a24f-fac1c5e82761">Imagine this scenario a year from now. Queries are fast. Data is trustworthy. Everyone gets to chip in. That’s looks like a promotion packet.</p></div></div>
  </body>
</html>
