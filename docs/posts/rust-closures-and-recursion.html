<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mckzm.github.io/rust/2024/10/13/rust_closures.html">Original</a>
    <h1>Rust Closures and Recursion</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>I keep forgetting that Rust closures do not (straightforwardly<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>) support recursion. Sometimes I
remember in the midst of writing code, in other instances rust-analyzer or
Clippy duly serve me a reminder to that effect - with a side-order of déjà vu.
Maybe posting about this will help it (finally) sink in.</p>

<p>As an example, the code below (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=9ec9bbb60b88669d64af29682d4724c8">playground
link</a>),
which aims to have an implementation of <a href="https://en.wikipedia.org/wiki/Ackermann_function#Definition:_as_m-ary_function">the Ackermann function, in its
Péter/Robinson
incarnation</a>,
tally the number of its invocations by using a closure, does not compile:</p>

<pre><code>fn main() {
    let mut invocations = 0;
    let ackermann = |m, n| {
        invocations += 1;
        match (m, n) {
            (0, _) =&gt; n + 1,
            (_, 0) =&gt; ackermann(m - 1, 1),
            _ =&gt; ackermann(m - 1, ackermann(m, n - 1)),
        }
    };
}
</code></pre>

<p>Specifically, rustc tells us we used <a href="https://doc.rust-lang.org/stable/error_codes/E0425.html">an unresolved name, resulting in
E0425</a>:</p>
<div><div><pre><code>Checking playground v0.0.1 (/playground)
error[E0425]: cannot find function `ackermann` in this scope
 --&gt; src/main.rs:7:23
  |
7 |             (_, 0) =&gt; ackermann(m - 1, 1),
  |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `ackermann` in this scope
 --&gt; src/main.rs:8:35
  |
8 |             _ =&gt; ackermann(m - 1, ackermann(m, n - 1)),
  |                                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `ackermann` in this scope
 --&gt; src/main.rs:8:18
  |
8 |             _ =&gt; ackermann(m - 1, ackermann(m, n - 1)),
  |                  ^^^^^^^^^ not found in this scope

For more information about this error, try `rustc --explain E0425`.
error: could not compile `playground` (bin &#34;playground&#34;) due to 3 previous errors
</code></pre></div></div>

<p>This contretemps is never a showstopper in my experience<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>. In this specific
instance, there are a few ways to achieve our goal using a function item
instead of a closure - for example by pairing <code>n</code> with an extra parameter meant
to record invocations, and returning that same pair:</p>

<pre><code>fn ackermann(m: u32, (n, invocations): (u32, u32)) -&gt; (u32, u32) {
    match (m, n) {
        (0, _) =&gt; (n + 1, invocations + 1),
        (_, 0) =&gt; ackermann(m - 1, (1, invocations + 1)),
        _ =&gt; ackermann(m - 1, ackermann(m, (n - 1, invocations + 1))),
    }
}

fn main() {
    println!(&#34;{:?}&#34;, ackermann(3, (4, 0)));
}
</code></pre>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=38a8048a70de3c398cb3e3aa00398ca5">playground
link</a>)</p>

<p>We could wrap calls to the function above within another that exposes the usual
Ackermann interface, too. And arguably not fiddling with enclosing scopes is A
Good Thing. Still, I find Rust’s closure syntax, being much lighter than its
counterpart for function items, a pleasure to use, in particular for scratch
code. A construct similar to <code>let rec</code> or <code>let/where</code> in OCaml/Haskell (resp.)
would be lovely.</p>


<p><a href="https://doc.rust-lang.org/book/ch13-01-closures.html#:~:text=Fn%20applies%20to"><code>Fn</code> closures don’t mutate their environment when they are
called</a>;
indeed some may not capture anything from their enclosing scope. They can be
recursively called if wrapped within a struct, which I learned <a href="https://users.rust-lang.org/t/how-to-do-recursive-closure-and-mutate-the-captured-env/114975">thanks to
asherlau and
steffhan in an URLO
thread</a>.
Reprising the Ackermann/Péter/Robinson example (without the invocation counter,
since we’re using a <code>Fn</code>), this gives something like:</p>
<pre><code>struct FnWrapper&lt;&#39;a&gt; {
    f: &amp;&#39;a dyn Fn(u32, u32, &amp;FnWrapper) -&gt; u32,
}

fn main() {
    let ackermann = FnWrapper {
        f: &amp;|m: u32, n: u32, wrap: &amp;FnWrapper| match (m, n) {
            (0, _) =&gt; n + 1,
            (_, 0) =&gt; (wrap.f)(m - 1, 1, wrap),
            _ =&gt; (wrap.f)(m - 1, (wrap.f)(m, n - 1, wrap), wrap),
        },
    };
    println!(&#34;{}&#34;, (ackermann.f)(3, 4, &amp;ackermann));
}
</code></pre>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=86d4a1bd3ecb2a8b458f1aebd9e4579e">playground code</a>)</p>

<p>Unfortunately such code is neither very straightforward to write nor to read:
the comparative advantage of the more lightweight closure syntax has well and
truly disappeared. Still, I’d be lying if I didn’t admit I find it a little
fun!</p>



  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
