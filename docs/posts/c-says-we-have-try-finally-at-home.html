<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20251222-00/?p=111890">Original</a>
    <h1>C&#43;&#43; says “We have try. . . finally at home”</h1>
    
    <div id="readability-page-1" class="page"><div id="single-wrapper">
    
    <article data-clarity-region="article" id="post-111890">
        <div data-bi-area="body_article" data-bi-id="post_page_body_article">
            <p>Many languages¹ that have exceptions also have a <code>finally</code> clause, so you can write</p>
<pre>try {
    ⟦ stuff ⟧
} finally {
    always();
}
</pre>
<p>A quick checks shows that this control structure exists in Java, C#, Python, JavaScript, but not C++.</p>
<p>C++ says, “We have <code>try</code>…finally at home.”</p>
<p>In C++, the way to get a block of code to execute when control leaves a block is to put it in a destructor, because destructors run when control leaves a block. This is the trick used by the Windows Implementation Library’s <a href="https://github.com/microsoft/wil/wiki/RAII-resource-wrappers#wilscope_exit"> wil::<wbr/>scope_exit</a> function: The lambda you provide is placed inside a custom object whose destructor runs the lambda.</p>
<pre>auto ensure_cleanup = wil::scope_exit([&amp;] { always(); });

⟦ stuff ⟧
</pre>
<p>Although the principle is the same, there are some quirks in how each language treats the case where the <code>finally</code> or destructor itself throws an exception.</p>
<p>If control leaves the guarded block without an exception, then any uncaught exception that occurs in the <code>finally</code> block or the destructor is thrown from the <code>try</code> block. All the languages seem to agree on this.</p>
<p>If control leaves the guarded block with an exception, and the <code>finally</code> block or destructor <i>also</i> throws an exception, then the behavior varies by language.</p>
<ul>
<li>In Java, Python, JavaScript, and C# an exception thrown from a <code>finally</code> block overwrites the original exception, and the original exception is lost. <b>Update</b>: Adam Rosenfield points out that Python 3.2 now saves the original exception as the context of the new exception, but it is still the new exception that is thrown.</li>
<li>In C++, an exception thrown from a destructor triggers automatic program termination if the destructor is running due to an exception.²</li>
</ul>
<p>So C++ gives you the ability to run code when control leaves a scope, but your code had better not allow an exception to escape if you know what’s good for you.</p>
<p>¹ The Microsoft compiler also supports the <code>__try</code> and <code>__finally</code> keywords for structured exception handling. These are, however, intended for C code. Don’t use them in C++ code because <a title="Can I throw a C++ exception from a structured exception?" href="https://devblogs.microsoft.com/oldnewthing/20170728-00/?p=96706"> they interact with C++ exceptions in sometimes-confusing ways</a>.</p>
<p>² This is why <code>wil::<wbr/>scope_exit</code> documents that it will terminate the process if the lambda throws an exception. There is an alternate function <code>wil::<wbr/>scope_<wbr/>exit_<wbr/>log</code> that logs and then ignores exceptions that are thrown from the lambda. There is no variation that gives you Java-like behavior.</p>
        </div><!-- .entry-content -->

        <!-- AI Disclaimer -->
            </article>
    
</div></div>
  </body>
</html>
