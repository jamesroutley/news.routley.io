<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xata.io/blog/introducing-pgzx">Original</a>
    <h1>Introducing pgzx: create PostgreSQL extensions using Zig</h1>
    
    <div id="readability-page-1" class="page"><div><p>As part of the <a href="https://xata.io/launch-week-unleash-the-elephant">Xata launch week</a>, we are introducing <a href="https://github.com/xataio/pgzx">pgzx</a>, an open-source framework for developing PostgreSQL extensions written in Zig. It provides a set of utilities (e.g. error handling, memory allocators, wrappers) as well as a build and development environment to simplify integrating with the Postgres codebase.</p>

<p><a href="https://ziglang.org/">Zig</a> is described on its website as a general-purpose programming language and toolchain for maintaining <strong>robust</strong>, <strong>optimal</strong> and <strong>reusable</strong> software. Zig is a new language (pre 1.0), but it has been gaining popularity in the systems programming community. It is fair to think of it as a &#34;modern C&#34;, providing safer memory management, compilation time code execution (comptime), and a rich standard library. We&#39;ll show some of these features in the context of Postgres extensions below.</p>
<p>A major reason to use Zig for Postgres development is its ability to interoperate with C code. Zig supports the C ABI, works with C pointers and data types, including NULL terminated strings, and can even translate C header files into Zig code. Zig&#39;s automatic translation of C macros to Zig code is not yet perfect, but it&#39;s still helpful. This makes Zig a great choice for working with very large C codebases, like Postgres happens to be.</p>

<p>Because Zig can call any C function and translate C macros to inline Zig functions, you can write Postgres extensions in Zig without any additional tooling by following the same steps you would for a C extension. However, a framework like pgzx simplifies the process significantly by providing a development environment, a set of utilities and wrappers for Postgres APIs, common error handling, and more.</p>

<p>pgzx has at the moment 2 sample extensions that you can take inspiration from. <a href="https://github.com/xataio/pgzx/tree/main/examples/char_count_zig">char_count_zig</a> is a minimal extension, while <a href="https://github.com/xataio/pgzx/tree/main/examples/pgaudit_zig">pg_audit_zig</a> is more complex and shows more of the features of pgzx.</p>
<p>Let&#39;s look at the <code>char_count_zig</code>, which is only slightly more than a &#34;Hello, World!&#34; of Postgres extensions. It adds a function that counts how many times a character appears in a string. This was inspired by <a href="https://www.highgo.ca/2019/10/01/a-guide-to-create-user-defined-extension-modules-to-postgres/">this tutorial</a>, which shows how to do this in plpqsql and C.</p>
<div><div role="group"><pre tabindex="0"><code><span><span>select</span><span> char_count_zig(</span><span>&#39;hi hii&#39;</span><span>, </span><span>&#39;i&#39;</span><span>);</span></span>
<span></span>
<span><span> char_count_zig</span></span>
<span><span>----------------</span></span>
<span><span>              3</span></span>
<span><span>(</span><span>1</span><span> row</span><span>)</span></span>
<span></span></code></pre></div></div>
<p>Here is the <code>char_count</code> extension written in Zig and in C.</p>
<div><div><div><p>char_count written in Zig</p><div role="group"><pre tabindex="0"><code><span><span>const</span><span> std = </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);</span></span>
<span><span>const</span><span> pgzx = </span><span>@import</span><span>(</span><span>&#34;pgzx&#34;</span><span>);</span></span>
<span></span>
<span><span>comptime</span><span> {</span></span>
<span><span>    pgzx.</span><span>PG_MODULE_MAGIC</span><span>();</span></span>
<span></span>
<span><span>    pgzx.</span><span>PG_FUNCTION_V1</span><span>(</span><span>&#34;char_count_zig&#34;</span><span>, char_count_zig);</span></span>
<span><span>}</span></span>
<span></span>
<span><span>fn</span><span> char_count_zig</span><span>(input_text: []</span><span>const</span><span> u8</span><span>, target_char: []</span><span>const</span><span> u8</span><span>) </span><span>!u32</span><span> {</span></span>
<span><span>    if</span><span> (target_char.len &gt; </span><span>1</span><span>) {</span></span>
<span><span>        return</span><span> pgzx.elog.</span><span>Error</span><span>(</span><span>@src</span><span>(), </span><span>&#34;Target char is more than one byte&#34;</span><span>, .{});</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    pgzx.elog.</span><span>Info</span><span>(</span><span>@src</span><span>(), </span><span>&#34;input_text: {s}\n&#34;</span><span>, .{input_text});</span></span>
<span><span>    pgzx.elog.</span><span>Info</span><span>(</span><span>@src</span><span>(), </span><span>&#34;target_char: {s}\n&#34;</span><span>, .{target_char});</span></span>
<span><span>    pgzx.elog.</span><span>Info</span><span>(</span><span>@src</span><span>(), </span><span>&#34;Target char len: {}\n&#34;</span><span>, .{target_char.len});</span></span>
<span></span>
<span><span>    var</span><span> count: </span><span>u32</span><span> = </span><span>0</span><span>;</span></span>
<span><span>    for</span><span> (input_text) </span><span>|</span><span>char</span><span>|</span><span> {</span></span>
<span><span>        if</span><span> (char </span><span>==</span><span> target_char[</span><span>0</span><span>]) {</span></span>
<span><span>            count </span><span>+=</span><span> 1</span><span>;</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>    return</span><span> count;</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><div><div><p>char_count written in C</p><div role="group"><pre tabindex="0"><code><span><span>#include</span><span> &#34;postgres.h&#34;</span></span>
<span><span>#include</span><span> &#34;fmgr.h&#34;</span></span>
<span><span>#include</span><span> &#34;utils/builtins.h&#34;</span></span>
<span></span>
<span><span>PG_MODULE_MAGIC;</span></span>
<span></span>
<span><span>PG_FUNCTION_INFO_V1</span><span>(char_count_c);</span></span>
<span></span>
<span><span>Datum</span></span>
<span><span>char_count_c</span><span>(PG_FUNCTION_ARGS)</span></span>
<span><span>{</span></span>
<span><span>    int</span><span> charCount </span><span>=</span><span> 0</span><span>;</span></span>
<span><span>    int</span><span> i </span><span>=</span><span> 0</span><span>;</span></span>
<span><span>    text </span><span>*</span><span> inputText </span><span>=</span><span> PG_GETARG_TEXT_PP(</span><span>0</span><span>)</span><span>;</span></span>
<span><span>    text </span><span>*</span><span> targetChar </span><span>=</span><span> PG_GETARG_TEXT_PP(</span><span>1</span><span>)</span><span>;</span></span>
<span></span>
<span><span>    int</span><span> inputText_sz </span><span>=</span><span> VARSIZE(inputText)</span><span>-</span><span>VARHDRSZ;</span></span>
<span><span>    int</span><span> targetChar_sz </span><span>=</span><span> VARSIZE(targetChar)</span><span>-</span><span>VARHDRSZ;</span></span>
<span><span>    char</span><span> *</span><span> cp_inputText </span><span>=</span><span> NULL</span><span>;</span></span>
<span><span>    char</span><span> *</span><span> cp_targetChar </span><span>=</span><span> NULL</span><span>;</span></span>
<span></span>
<span><span>    if</span><span> (targetChar_sz </span><span>&gt;</span><span> 1</span><span> )</span></span>
<span><span>    {</span></span>
<span><span>        elog(ERROR</span><span>,</span><span> &#34;arg1 must be 1 char long&#34;</span><span>)</span><span>;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    cp_inputText </span><span>=</span><span> (</span><span>char</span><span> *</span><span>) </span><span>palloc(inputText_sz </span><span>+</span><span> 1</span><span>)</span><span>;</span></span>
<span><span>    cp_targetChar </span><span>=</span><span> (</span><span>char</span><span> *</span><span>) </span><span>palloc(targetChar_sz </span><span>+</span><span> 1</span><span>)</span><span>;</span></span>
<span><span>    memcpy(cp_inputText</span><span>,</span><span> VARDATA(inputText)</span><span>,</span><span> inputText_sz)</span><span>;</span></span>
<span><span>    memcpy(cp_targetChar</span><span>,</span><span> VARDATA(targetChar)</span><span>,</span><span> targetChar_sz)</span><span>;</span></span>
<span></span>
<span><span>    elog(INFO</span><span>,</span><span> &#34;arg0 length is </span><span>%d</span><span>, value </span><span>%s</span><span>&#34;</span><span>,</span><span> (</span><span>int</span><span>)strlen(cp_inputText)</span><span>,</span><span> cp_inputText)</span><span>;</span></span>
<span><span>    elog(INFO</span><span>,</span><span> &#34;arg1 length is </span><span>%d</span><span>, value </span><span>%s</span><span>&#34;</span><span>,</span><span> (</span><span>int</span><span>)strlen(cp_targetChar)</span><span>,</span><span> cp_targetChar)</span><span>;</span></span>
<span></span>
<span><span>    while</span><span> ( i </span><span>&lt;</span><span> strlen(cp_inputText)</span><span> )</span></span>
<span><span>    {</span></span>
<span><span>        if</span><span>( cp_inputText[i] </span><span>==</span><span> cp_targetChar[</span><span>0</span><span>] )</span></span>
<span><span>            charCount</span><span>++</span><span>;</span></span>
<span><span>        i</span><span>++</span><span>;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    pfree(cp_inputText)</span><span>;</span></span>
<span><span>    pfree(cp_targetChar)</span><span>;</span></span>
<span><span>    PG_RETURN_INT32(charCount)</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div></div>
<p>Whilst they&#39;re similar, the Zig version is actually a bit more concise. This is partially because Zig is more expressive, but also because pgzx does a bit more of the work.</p>
<p>Registered SQL functions receive their arguments serialized and some code is needed to deserialize them. In C you do that with the help of the <code>G_GETARG_*</code> macros, however with pgzx you simply receive them as normal parameters already deserialized. How? By having a <code>comptime</code> function that generates the necessary boilerplate code at compile time. If you are curious, check out the <a href="https://github.com/xataio/pgzx/blob/9825dde752ee4ace2cbc594332eba100292aafd5/src/pgzx/fmgr.zig#L77-L102">pgCall</a> function, it&#39;s a nice example for the power of Zig&#39;s <code>comptime</code> execution.</p>
<p>The <code>PG_MODULE_MAGIC</code> and <code>PG_FUNCTION_INFO_V1</code> functions are a second example of <code>comptime</code> usage. They export the required symbols needed for Postgres to recognize this as an extension and to register the function as a SQL function. In this case, <code>comptime</code> acts pretty much like the corresponding C macros.</p>

<p>If you looked carefully at the code above, you might have noticed that it contains a bug. It checks for the <code>target_char</code> to not have more than 1 character, but it doesn&#39;t check if it has 0 characters. Later, the code accesses <code>target_char[0]</code>, so if the string is the empty string, there will be a out of bounds access error. We left that bug intentionally in so you can see what happens when bugs like that happen in the extension.</p>
<p>You can trigger the bug with this SQL:</p>
<div><div role="group"><pre tabindex="0"><code><span><span>select</span><span> char_count_zig(</span><span>&#39;hi hii&#39;</span><span>, </span><span>&#39;&#39;</span><span>);</span></span>
<span></span></code></pre></div></div>
<p>Which responds:</p>
<div><div role="group"><pre tabindex="0"><code><span><span>server closed the connection unexpectedly</span></span>
<span><span>        This probably means the server terminated abnormally</span></span>
<span><span>        before or while processing the request.</span></span>
<span><span>The connection to the server was lost. Attempting reset: Failed.</span></span>
<span><span></span></span></code></pre></div></div>
<p>In C code, this type of bug could trigger a segmentation fault or even a security vulnerability. If you try this with the <code>char_count_zig</code> extension, the Postgres process still crashes (not the full server, just the process serving the connection), but if you check the logs you&#39;ll see an error message like this:</p>
<div><div role="group"><pre tabindex="0"><code><span><span>thread 70501513 panic: index out of bounds: index 0, len 0</span></span>
<span><span>/Users/tsg/src/xataio/pgzx/examples/char_count_zig/src/main.zig:21:32: 0x103aaedff in char_count_zig (char_count_zig)</span></span>
<span><span>        if (char == target_char[0]) {</span></span>
<span><span>                               ^</span></span>
<span><span>/Users/tsg/src/xataio/pgzx/src/pgzx/fmgr.zig:95:5: 0x103aaf20f in call (char_count_zig)</span></span>
<span><span>    const value = @call(.no_async, impl, callArgs) catch |e| elog.throwAsPostgresError(src, e);</span></span>
<span><span>    ^</span></span>
<span><span>???:?:?: 0x10316045b in _ExecInterpExpr (???)</span></span>
<span><span>???:?:?: 0x10315fbef in _ExecInterpExprStillValid (???)</span></span>
<span><span>???:?:?: 0x10326ceef in _evaluate_expr (???)</span></span>
<span><span>???:?:?: 0x10326da67 in _simplify_function (???)</span></span>
<span><span>???:?:?: 0x10326bacf in _eval_const_expressions_mutator (???)</span></span>
<span><span></span></span></code></pre></div></div>
<p>It points exactly where the error happened! This happens because Zig has runtime checks depending on the <a href="https://ziglang.org/documentation/master/#Build-Mode">build mode</a>. The <code>ReleaseSafe</code> mode, for example, trades a bit of performance for more safety checks.</p>
<p>Note that this stacktrace worked so well because the error was in Zig code. When building Postgres extensions, you often have to call Postgres APIs which will still segmentation fault if you use them incorrectly.</p>

<p>Postgres uses <a href="https://en.wikipedia.org/wiki/Region-based_memory_management">allocator arenas</a> to manage memory. In the Postgres source code, the arenas are called <a href="https://github.com/postgres/postgres/blob/master/src/backend/utils/mmgr/README">memory contexts</a>. Memory allocated in a &#34;context&#34; can be freed all at once (for example, when a query execution is finished), which simplifies memory management significantly, because you only need to track contexts, not individual allocations. Contexts are also hierarchical, so you can create a context that is a child of another context, and when the parent context is freed, all children are freed as well. This makes memory leaks rather unlikely.</p>
<p>Another advantage of memory contexts is that they improve <a href="https://www.postgresql.org/docs/current/view-pg-backend-memory-contexts.html">memory monitoring</a>, because context have names and you can see how much memory is used by each context. This is useful for debugging large memory usage.</p>
<p>This model of using an arena/context allocator happens to match really good with Zig. One reason is Zig&#39;s convention to have all functions/objects that allocate memory receive an allocator as a parameter. This makes allocations <a href="https://notes.eatonphil.com/2024-03-15-zig-rust-and-other-languages.html">more explicit</a> but also makes it easy to use a custom allocator. pgzx defines custom allocators that wrap the Postgres memory contexts and make them available to Zig code.</p>
<p>Here is an example that creates a new context as a child of the current context and gets the allocator for it:</p>
<div><div role="group"><pre tabindex="0"><code><span><span>var</span><span> memctx = </span><span>try</span><span> pgzx.mem.</span><span>createAllocSetContext</span><span>(</span><span>&#34;zig_context&#34;</span><span>, .{ .parent = pg.CurrentMemoryContext });</span></span>
<span><span>const</span><span> allocator = memctx.</span><span>allocator</span><span>();</span></span>
<span></span></code></pre></div></div>

<p>Another Postgres API that you will very likely need to know about in a more complex extension is the error handling. Postgres implements &#34;exceptions&#34; in C via <code>setjmp/longjmp</code> and provides a set of macros to throw and catch them (<a href="https://github.com/postgres/postgres/blob/master/src/include/utils/elog.h#L318">PG_TRY/PG_CATCH</a>).</p>
<p>The issue is that long jumps could bypass the Zig control flow, for example <code>errdefer</code> blocks might not be executed. This means that if your extension calls into Postgres APIs, and those APIs can throw errors, long jumps might skip your <code>defer</code> and <code>errdefer</code> blocks!</p>
<p>Luckily, pgzx is here to help. It provides a set of functions that allow you to catch the Postgres exceptions and convert them into Zig errors. For example:</p>
<div><div role="group"><pre tabindex="0"><code><span><span>var</span><span> errctx = pgzx.err.Context.</span><span>init</span><span>();</span></span>
<span><span>defer</span><span> errctx.</span><span>deinit</span><span>();</span></span>
<span><span>if</span><span> (errctx.</span><span>pg_try</span><span>()) {</span></span>
<span><span>    // Call Postgres C functions.</span></span>
<span><span>} </span><span>else</span><span> {</span></span>
<span><span>    return</span><span> errctx.</span><span>errorValue</span><span>();</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div>

<p>pgzx comes with a <a href="https://nixos.wiki/wiki/Flakes">Nix flakes</a> based development environment for developing extensions as well as pgzx itself. It also comes with a project template which you can use to set up this environment in a new repository. To use it, <a href="https://github.com/DeterminateSystems/nix-installer">install Nix</a> and then run:</p>
<div><div role="group"><pre tabindex="0"><code><span><span>mkdir</span><span> my_extension</span></span>
<span><span>cd</span><span> my_extension</span></span>
<span><span>nix</span><span> flake</span><span> init</span><span> -t</span><span> github:xataio/pgzx</span></span>
<span></span></code></pre></div></div>
<p>Then load the nix shell with:</p>

<p>The dev environment includes commands to relocate the Postgres binaries in your development environment, to start the server, and so on. The template also comes with a minimal extension and a <code>build.zig</code> file with a few common tasks. See the template <a href="https://github.com/xataio/pgzx/tree/main/nix/templates/init">README</a> for how to build the extension from this point.</p>

<p>Postgres extensions are typically tested via a tool called <code>pg_regress</code>. This is supported by pgzx as well, simply call <code>zig build pg_regress</code>.</p>
<p>But we also wanted to have unit tests. This is a bit tricky because the tests need to be compiled and run in the <strong>context of a Postgres instance</strong>. Otherwise, they won&#39;t be able to interact with Postgres&#39; APIs.</p>
<p>In order to solve this, pgzx registers a custom <code>run_tests</code> function. This function can be called from SQL (<code>SELECT run_tests();</code>) and it will run the unit tests. A test suite is a Zig struct with functions starting with <code>test</code>. To register a test suite, you would typically do something like this:</p>
<div><div role="group"><pre tabindex="0"><code><span><span>comptime</span><span> {</span></span>
<span><span>    pgzx.testing.</span><span>registerTests</span><span>(</span><span>@import</span><span>(</span><span>&#34;build_options&#34;</span><span>).testfn, .{Tests});</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div>
<p>The <a href="https://github.com/xataio/pgzx/blob/9825dde752ee4ace2cbc594332eba100292aafd5/src/pgzx/testing.zig#L39">registerTests</a> function is another example of <code>comptime</code> usage. It iterates over all the fields of a struct and generates the call to run the tests when the <code>run_tests()</code> function is called in SQL.</p>

<p>This walkthrough covered some of the more interesting functionality exposed by pgzx, but there&#39;s more on offer: wrappers for the Postgres data structures (<a href="https://xataio.github.io/pgzx/#A;pgzx:list">lists</a>, hashtables), <a href="https://xataio.github.io/pgzx/#A;pgzx:spi">SPI</a>, <a href="https://xataio.github.io/pgzx/#A;pgzx:shmem">shared memory access</a>, <a href="https://xataio.github.io/pgzx/#A;pgzx:pq">connection management</a>, and more...</p>

<p>At Xata, we have been working on a new Postgres project, which doesn&#39;t really have a name yet, so let&#39;s call it <em>&#34;Xata&#39;s take on distributed Postgres&#34;</em>. It&#39;s in its very early stages, however we&#39;ll be open sourcing it soon and we&#39;re planning to <a href="https://mailchi.mp/xata/2zoy27tx2e">build it in public</a>. It will be somewhat similar to Citus, but some different choices, especially around usage and DX, based on what we learned running Xata for the past couple of years.</p>
<p>For this project, we considered three potential implementation directions:</p>
<ol role="list"><li>As an external proxy, like Vitess does for MySQL.</li><li>As a Postgres extension, like Citus.</li><li>As a fork of Postgres, like Greenplum.</li></ol>
<p>We have some experience with the first option because that&#39;s how our current Xata Proxy works, see more details in this <a href="https://xata.io/blog/serverless-postgres-platform">blog post</a>, so we were almost biased towards it. We know we can speak the Postgres wire protocol, parse the incoming queries and understand them at a deep level, as well as create distributed transactions via 2PC. However, we also know that leveraging existing Postgres code it will open up more options and avoid us having to reimplement some very difficult parts. Given the long term vision of the project, and that we didn&#39;t want to maintain a fork, we decided to go with the second option.</p>
<p>The next node in our decision tree was the <strong>programming language</strong>. The main options we considered were C, Rust, and Zig. While there are pros and cons to each of these options, which we might cover in detail a future blog post, we decided to go with Zig. The main &#34;pros&#34; for Zig were:</p>
<ul role="list"><li>It allows us to call into the Postgres APIs almost directly, so we have the same power as using C.</li><li>It offers more memory safety than C, it&#39;s a bit more expressive, and a bit more fun (we think).</li><li>It fits well with the Postgres codebase, for example when it comes to memory management and string handling.</li></ul>
<p>As we started working, we realized that an equivalent for Rust&#39;s <a href="https://github.com/pgcentralfoundation/pgrx">pgrx</a> would be needed for Zig as well, so we started pgzx.</p>
<p>While Zig and pgzx might not be the best choice for every Postgres extension, we think it&#39;s a reasonable choice for our project and perhaps for some others as well.</p>

<p>pgzx is new and should be considered &#34;alpha&#34; as of now. However, if you want to build a Postgres extension and you want to use Zig, it&#39;s going to be a lot easier with pgzx than without it. A status of the covered functionality is in the <a href="https://github.com/xataio/pgzx">README</a>. If you need help or you&#39;d like to contribute, please join us on the <a href="https://xata.io/discord">Xata Discord</a>.</p>
<p>Also, if this blog post has sparked your interest in Zig and you want to give it a try, why not develop a Postgres extension? Let us know about it and we&#39;ll include it in the list of examples!</p>

<p>Learn more about the development of this project from the folks that built it, and watch a quick demo to see it in action. Check out our latest meet the makers session here:</p>
<div><p><iframe src="https://www.youtube.com/embed/oUvAfia7gjE?si=P5ApXa2moZR3NfL8" title="YouTube video player" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></p></div>
<p>Want to keep up with pgzx, the distributed Postgres project, or other open-source projects from Xata? We have set up an email newsletter just for that. You can subscribe <a href="https://mailchi.mp/xata/2zoy27tx2e">here</a>.</p></div></div>
  </body>
</html>
