<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Goldziher/kreuzberg">Original</a>
    <h1>Show HN: Kreuzberg – Modern async Python library for document text extraction</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Kreuzberg is a Python library for text extraction from documents. It provides a unified async interface for extracting text from PDFs, images, office documents, and more.</p>

<ul dir="auto">
<li><strong>Simple and Hassle-Free</strong>: Clean API that just works, without complex configuration</li>
<li><strong>Local Processing</strong>: No external API calls or cloud dependencies required</li>
<li><strong>Resource Efficient</strong>: Lightweight processing without GPU requirements</li>
<li><strong>Lightweight</strong>: Has few curated dependencies and a minimal footprint</li>
<li><strong>Format Support</strong>: Comprehensive support for documents, images, and text formats</li>
<li><strong>Modern Python</strong>: Built with async/await, type hints, and functional first approach</li>
<li><strong>Permissive OSS</strong>: Kreuzberg and its dependencies have a permissive OSS license</li>
</ul>
<p dir="auto">Kreuzberg was built for RAG (Retrieval Augmented Generation) applications, focusing on local processing with minimal dependencies. Its designed for modern async applications, serverless functions, and dockerized applications.</p>

<div dir="auto"><h3 tabindex="-1" dir="auto">1. Install the Python Package</h3><a id="user-content-1-install-the-python-package" aria-label="Permalink: 1. Install the Python Package" href="#1-install-the-python-package"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>

<div dir="auto"><h3 tabindex="-1" dir="auto">2. Install System Dependencies</h3><a id="user-content-2-install-system-dependencies" aria-label="Permalink: 2. Install System Dependencies" href="#2-install-system-dependencies"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Kreuzberg requires two system level dependencies:</p>
<ul dir="auto">
<li><a href="https://pandoc.org/installing.html" rel="nofollow">Pandoc</a> - For document format conversion</li>
<li><a href="https://tesseract-ocr.github.io/" rel="nofollow">Tesseract OCR</a> - For image and PDF OCR</li>
</ul>
<p dir="auto">You can install these with:</p>

<div dir="auto" data-snippet-clipboard-copy-content="sudo apt-get install pandoc tesseract-ocr"><pre>sudo apt-get install pandoc tesseract-ocr</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# MacOS
brew install tesseract pandoc"><pre><span><span>#</span> MacOS</span>
brew install tesseract pandoc</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="choco install -y tesseract pandoc"><pre>choco install -y tesseract pandoc</pre></div>
<p dir="auto">Notes:</p>
<ul dir="auto">
<li>in most distributions the tesseract-ocr package is split into multiple packages, you may need to install any language models you need aside from English separately.</li>
<li>please consult the official documentation for these libraries for the most up-to-date installation instructions for your platform.</li>
</ul>

<p dir="auto">Kreuzberg integrates:</p>
<ul dir="auto">
<li><strong>PDF Processing</strong>:
<ul dir="auto">
<li><code>pdfium2</code> for searchable PDFs</li>
<li>Tesseract OCR for scanned content</li>
</ul>
</li>
<li><strong>Document Conversion</strong>:
<ul dir="auto">
<li>Pandoc for many document and markup formats</li>
<li><code>python-pptx</code> for PowerPoint files</li>
<li><code>html-to-markdown</code> for HTML content</li>
<li><code>calamine</code> for Excel spreadsheets (with multi-sheet support)</li>
</ul>
</li>
<li><strong>Text Processing</strong>:
<ul dir="auto">
<li>Smart encoding detection</li>
<li>Markdown and plain text handling</li>
</ul>
</li>
</ul>


<ul dir="auto">
<li>PDF (<code>.pdf</code>, both searchable and scanned)</li>
<li>Microsoft Word (<code>.docx</code>)</li>
<li>PowerPoint presentations (<code>.pptx</code>)</li>
<li>OpenDocument Text (<code>.odt</code>)</li>
<li>Rich Text Format (<code>.rtf</code>)</li>
<li>EPUB (<code>.epub</code>)</li>
<li>DocBook XML (<code>.dbk</code>, <code>.xml</code>)</li>
<li>FictionBook (<code>.fb2</code>)</li>
<li>LaTeX (<code>.tex</code>, <code>.latex</code>)</li>
<li>Typst (<code>.typ</code>)</li>
</ul>

<ul dir="auto">
<li>HTML (<code>.html</code>, <code>.htm</code>)</li>
<li>Plain text (<code>.txt</code>) and Markdown (<code>.md</code>, <code>.markdown</code>)</li>
<li>reStructuredText (<code>.rst</code>)</li>
<li>Org-mode (<code>.org</code>)</li>
<li>DokuWiki (<code>.txt</code>)</li>
<li>Pod (<code>.pod</code>)</li>
<li>Troff/Man (<code>.1</code>, <code>.2</code>, etc.)</li>
</ul>
<div dir="auto"><h4 tabindex="-1" dir="auto">Data and Research Formats</h4><a id="user-content-data-and-research-formats" aria-label="Permalink: Data and Research Formats" href="#data-and-research-formats"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>Spreadsheets (<code>.xlsx</code>, <code>.xls</code>, <code>.xlsm</code>, <code>.xlsb</code>, <code>.xlam</code>, <code>.xla</code>, <code>.ods</code>)</li>
<li>CSV (<code>.csv</code>) and TSV (<code>.tsv</code>) files</li>
<li>OPML files (<code>.opml</code>)</li>
<li>Jupyter Notebooks (<code>.ipynb</code>)</li>
<li>BibTeX (<code>.bib</code>) and BibLaTeX (<code>.bib</code>)</li>
<li>CSL-JSON (<code>.json</code>)</li>
<li>EndNote and JATS XML (<code>.xml</code>)</li>
<li>RIS (<code>.ris</code>)</li>
</ul>

<ul dir="auto">
<li>JPEG (<code>.jpg</code>, <code>.jpeg</code>, <code>.pjpeg</code>)</li>
<li>PNG (<code>.png</code>)</li>
<li>TIFF (<code>.tiff</code>, <code>.tif</code>)</li>
<li>BMP (<code>.bmp</code>)</li>
<li>GIF (<code>.gif</code>)</li>
<li>JPEG 2000 family (<code>.jp2</code>, <code>.jpm</code>, <code>.jpx</code>, <code>.mj2</code>)</li>
<li>WebP (<code>.webp</code>)</li>
<li>Portable anymap formats (<code>.pbm</code>, <code>.pgm</code>, <code>.ppm</code>, <code>.pnm</code>)</li>
</ul>

<p dir="auto">Kreuzberg provides both async and sync APIs for text extraction, including batch processing. The library exports the following main functions:</p>
<ul dir="auto">
<li>
<p dir="auto">Single Item Processing:</p>
<ul dir="auto">
<li><code>extract_file()</code>: Async function to extract text from a file (accepts string path or <code>pathlib.Path</code>)</li>
<li><code>extract_bytes()</code>: Async function to extract text from bytes (accepts a byte string)</li>
<li><code>extract_file_sync()</code>: Synchronous version of <code>extract_file()</code></li>
<li><code>extract_bytes_sync()</code>: Synchronous version of <code>extract_bytes()</code></li>
</ul>
</li>
<li>
<p dir="auto">Batch Processing:</p>
<ul dir="auto">
<li><code>batch_extract_file()</code>: Async function to extract text from multiple files concurrently</li>
<li><code>batch_extract_bytes()</code>: Async function to extract text from multiple byte contents concurrently</li>
<li><code>batch_extract_file_sync()</code>: Synchronous version of <code>batch_extract_file()</code></li>
<li><code>batch_extract_bytes_sync()</code>: Synchronous version of <code>batch_extract_bytes()</code></li>
</ul>
</li>
</ul>

<p dir="auto">All extraction functions accept the following optional parameters for configuring OCR and performance:</p>

<ul dir="auto">
<li>
<p dir="auto"><code>force_ocr</code>(default: <code>False</code>): Forces OCR processing even for searchable PDFs.</p>
</li>
<li>
<p dir="auto"><code>language</code> (default: <code>eng</code>): Specifies the language model for Tesseract OCR. This affects text recognition accuracy for documents in different languages. Examples:</p>
<ul dir="auto">
<li><code>eng</code> for English</li>
<li><code>deu</code> for German</li>
<li><code>eng+deu</code> for English and German</li>
</ul>
<p dir="auto">Notes: - the order of languages effect processing time, the first language is the primary language and the second language is the secondary language etc.</p>
</li>
<li>
<p dir="auto"><code>psm</code> (Page Segmentation Mode, default: <code>PSM.AUTO</code>): Controls how Tesseract analyzes page layout. In most cases you do not need to change this to a different value.</p>
</li>
</ul>
<p dir="auto">Consult the <a href="https://tesseract-ocr.github.io/tessdoc/" rel="nofollow">Tesseract documentation</a> for more information on both options.</p>

<ul dir="auto">
<li>
<p dir="auto"><code>max_processes</code> (default: CPU count / 2): Maximum number of concurrent processes for Tesseract and Pandoc.</p>
<p dir="auto">Notes:</p>
<ul dir="auto">
<li>Higher values can lead to performance improvements when batch processing especially with OCR, but may cause resource exhaustion and deadlocks (especially for tesseract).</li>
</ul>
</li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="from pathlib import Path
from kreuzberg import extract_file
from kreuzberg.extraction import ExtractionResult
from kreuzberg._tesseract import PSMMode


# Basic file extraction
async def extract_document():
    # Extract from a PDF file with default settings
    pdf_result: ExtractionResult = await extract_file(&#34;document.pdf&#34;)
    print(f&#34;Content: {pdf_result.content}&#34;)

    # Extract from an image with German language model
    img_result = await extract_file(
        &#34;scan.png&#34;,
        language=&#34;deu&#34;,  # German language model
        psm=PSMMode.SINGLE_BLOCK,  # Treat as single block of text
        max_processes=4  # Limit concurrent processes
    )
    print(f&#34;Image text: {img_result.content}&#34;)

    # Extract from Word document with metadata
    docx_result = await extract_file(Path(&#34;document.docx&#34;))
    if docx_result.metadata:
        print(f&#34;Title: {docx_result.metadata.get(&#39;title&#39;)}&#34;)
        print(f&#34;Author: {docx_result.metadata.get(&#39;creator&#39;)}&#34;)"><pre><span>from</span> <span>pathlib</span> <span>import</span> <span>Path</span>
<span>from</span> <span>kreuzberg</span> <span>import</span> <span>extract_file</span>
<span>from</span> <span>kreuzberg</span>.<span>extraction</span> <span>import</span> <span>ExtractionResult</span>
<span>from</span> <span>kreuzberg</span>.<span>_tesseract</span> <span>import</span> <span>PSMMode</span>


<span># Basic file extraction</span>
<span>async</span> <span>def</span> <span>extract_document</span>():
    <span># Extract from a PDF file with default settings</span>
    <span>pdf_result</span>: <span>ExtractionResult</span> <span>=</span> <span>await</span> <span>extract_file</span>(<span>&#34;document.pdf&#34;</span>)
    <span>print</span>(<span>f&#34;Content: <span><span>{</span><span>pdf_result</span>.<span>content</span><span>}</span></span>&#34;</span>)

    <span># Extract from an image with German language model</span>
    <span>img_result</span> <span>=</span> <span>await</span> <span>extract_file</span>(
        <span>&#34;scan.png&#34;</span>,
        <span>language</span><span>=</span><span>&#34;deu&#34;</span>,  <span># German language model</span>
        <span>psm</span><span>=</span><span>PSMMode</span>.<span>SINGLE_BLOCK</span>,  <span># Treat as single block of text</span>
        <span>max_processes</span><span>=</span><span>4</span>  <span># Limit concurrent processes</span>
    )
    <span>print</span>(<span>f&#34;Image text: <span><span>{</span><span>img_result</span>.<span>content</span><span>}</span></span>&#34;</span>)

    <span># Extract from Word document with metadata</span>
    <span>docx_result</span> <span>=</span> <span>await</span> <span>extract_file</span>(<span>Path</span>(<span>&#34;document.docx&#34;</span>))
    <span>if</span> <span>docx_result</span>.<span>metadata</span>:
        <span>print</span>(<span>f&#34;Title: <span><span>{</span><span>docx_result</span>.<span>metadata</span>.<span>get</span>(<span>&#39;title&#39;</span>)<span>}</span></span>&#34;</span>)
        <span>print</span>(<span>f&#34;Author: <span><span>{</span><span>docx_result</span>.<span>metadata</span>.<span>get</span>(<span>&#39;creator&#39;</span>)<span>}</span></span>&#34;</span>)</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="from kreuzberg import extract_bytes
from kreuzberg.extraction import ExtractionResult


async def process_upload(file_content: bytes, mime_type: str) -&gt; ExtractionResult:
    &#34;&#34;&#34;Process uploaded file content with known MIME type.&#34;&#34;&#34;
    return await extract_bytes(
        file_content,
        mime_type=mime_type,
    )


# Example usage with different file types
async def handle_uploads(docx_bytes: bytes, pdf_bytes: bytes, image_bytes: bytes):
    # Process PDF upload
    pdf_result = await process_upload(pdf_bytes, mime_type=&#34;application/pdf&#34;)
    print(f&#34;PDF content: {pdf_result.content}&#34;)
    print(f&#34;PDF metadata: {pdf_result.metadata}&#34;)

    # Process image upload (will use OCR)
    img_result = await process_upload(image_bytes, mime_type=&#34;image/jpeg&#34;)
    print(f&#34;Image text: {img_result.content}&#34;)

    # Process Word document upload
    docx_result = await process_upload(
        docx_bytes,
        mime_type=&#34;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#34;
    )
    print(f&#34;Word content: {docx_result.content}&#34;)"><pre><span>from</span> <span>kreuzberg</span> <span>import</span> <span>extract_bytes</span>
<span>from</span> <span>kreuzberg</span>.<span>extraction</span> <span>import</span> <span>ExtractionResult</span>


<span>async</span> <span>def</span> <span>process_upload</span>(<span>file_content</span>: <span>bytes</span>, <span>mime_type</span>: <span>str</span>) <span>-&gt;</span> <span>ExtractionResult</span>:
    <span>&#34;&#34;&#34;Process uploaded file content with known MIME type.&#34;&#34;&#34;</span>
    <span>return</span> <span>await</span> <span>extract_bytes</span>(
        <span>file_content</span>,
        <span>mime_type</span><span>=</span><span>mime_type</span>,
    )


<span># Example usage with different file types</span>
<span>async</span> <span>def</span> <span>handle_uploads</span>(<span>docx_bytes</span>: <span>bytes</span>, <span>pdf_bytes</span>: <span>bytes</span>, <span>image_bytes</span>: <span>bytes</span>):
    <span># Process PDF upload</span>
    <span>pdf_result</span> <span>=</span> <span>await</span> <span>process_upload</span>(<span>pdf_bytes</span>, <span>mime_type</span><span>=</span><span>&#34;application/pdf&#34;</span>)
    <span>print</span>(<span>f&#34;PDF content: <span><span>{</span><span>pdf_result</span>.<span>content</span><span>}</span></span>&#34;</span>)
    <span>print</span>(<span>f&#34;PDF metadata: <span><span>{</span><span>pdf_result</span>.<span>metadata</span><span>}</span></span>&#34;</span>)

    <span># Process image upload (will use OCR)</span>
    <span>img_result</span> <span>=</span> <span>await</span> <span>process_upload</span>(<span>image_bytes</span>, <span>mime_type</span><span>=</span><span>&#34;image/jpeg&#34;</span>)
    <span>print</span>(<span>f&#34;Image text: <span><span>{</span><span>img_result</span>.<span>content</span><span>}</span></span>&#34;</span>)

    <span># Process Word document upload</span>
    <span>docx_result</span> <span>=</span> <span>await</span> <span>process_upload</span>(
        <span>docx_bytes</span>,
        <span>mime_type</span><span>=</span><span>&#34;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#34;</span>
    )
    <span>print</span>(<span>f&#34;Word content: <span><span>{</span><span>docx_result</span>.<span>content</span><span>}</span></span>&#34;</span>)</pre></div>

<p dir="auto">Kreuzberg supports efficient batch processing of multiple files or byte contents:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from pathlib import Path
from kreuzberg import batch_extract_file, batch_extract_bytes, batch_extract_file_sync


# Process multiple files concurrently
async def process_documents(file_paths: list[Path]) -&gt; None:
    # Extract from multiple files
    results = await batch_extract_file(file_paths)
    for path, result in zip(file_paths, results):
        print(f&#34;File {path}: {result.content[:100]}...&#34;)


# Process multiple uploaded files concurrently
async def process_uploads(contents: list[tuple[bytes, str]]) -&gt; None:
    # Each item is a tuple of (content, mime_type)
    results = await batch_extract_bytes(contents)
    for (_, mime_type), result in zip(contents, results):
        print(f&#34;Upload {mime_type}: {result.content[:100]}...&#34;)


# Synchronous batch processing is also available
def process_documents_sync(file_paths: list[Path]) -&gt; None:
    results = batch_extract_file_sync(file_paths)
    for path, result in zip(file_paths, results):
        print(f&#34;File {path}: {result.content[:100]}...&#34;)"><pre><span>from</span> <span>pathlib</span> <span>import</span> <span>Path</span>
<span>from</span> <span>kreuzberg</span> <span>import</span> <span>batch_extract_file</span>, <span>batch_extract_bytes</span>, <span>batch_extract_file_sync</span>


<span># Process multiple files concurrently</span>
<span>async</span> <span>def</span> <span>process_documents</span>(<span>file_paths</span>: <span>list</span>[<span>Path</span>]) <span>-&gt;</span> <span>None</span>:
    <span># Extract from multiple files</span>
    <span>results</span> <span>=</span> <span>await</span> <span>batch_extract_file</span>(<span>file_paths</span>)
    <span>for</span> <span>path</span>, <span>result</span> <span>in</span> <span>zip</span>(<span>file_paths</span>, <span>results</span>):
        <span>print</span>(<span>f&#34;File <span><span>{</span><span>path</span><span>}</span></span>: <span><span>{</span><span>result</span>.<span>content</span>[:<span>100</span>]<span>}</span></span>...&#34;</span>)


<span># Process multiple uploaded files concurrently</span>
<span>async</span> <span>def</span> <span>process_uploads</span>(<span>contents</span>: <span>list</span>[<span>tuple</span>[<span>bytes</span>, <span>str</span>]]) <span>-&gt;</span> <span>None</span>:
    <span># Each item is a tuple of (content, mime_type)</span>
    <span>results</span> <span>=</span> <span>await</span> <span>batch_extract_bytes</span>(<span>contents</span>)
    <span>for</span> (<span>_</span>, <span>mime_type</span>), <span>result</span> <span>in</span> <span>zip</span>(<span>contents</span>, <span>results</span>):
        <span>print</span>(<span>f&#34;Upload <span><span>{</span><span>mime_type</span><span>}</span></span>: <span><span>{</span><span>result</span>.<span>content</span>[:<span>100</span>]<span>}</span></span>...&#34;</span>)


<span># Synchronous batch processing is also available</span>
<span>def</span> <span>process_documents_sync</span>(<span>file_paths</span>: <span>list</span>[<span>Path</span>]) <span>-&gt;</span> <span>None</span>:
    <span>results</span> <span>=</span> <span>batch_extract_file_sync</span>(<span>file_paths</span>)
    <span>for</span> <span>path</span>, <span>result</span> <span>in</span> <span>zip</span>(<span>file_paths</span>, <span>results</span>):
        <span>print</span>(<span>f&#34;File <span><span>{</span><span>path</span><span>}</span></span>: <span><span>{</span><span>result</span>.<span>content</span>[:<span>100</span>]<span>}</span></span>...&#34;</span>)</pre></div>
<p dir="auto">Features:</p>
<ul dir="auto">
<li>Ordered results</li>
<li>Concurrent processing</li>
<li>Error handling per item</li>
<li>Async and sync interfaces</li>
<li>Same options as single extraction</li>
</ul>

<p dir="auto">Kreuzberg employs a smart approach to PDF text extraction:</p>
<ol dir="auto">
<li>
<p dir="auto"><strong>Searchable Text Detection</strong>: First attempts to extract text directly from searchable PDFs using <code>pdfium2</code>.</p>
</li>
<li>
<p dir="auto"><strong>Text Validation</strong>: Extracted text is validated for corruption by checking for:</p>
<ul dir="auto">
<li>Control and non-printable characters</li>
<li>Unicode replacement characters (�)</li>
<li>Zero-width spaces and other invisible characters</li>
<li>Empty or whitespace-only content</li>
</ul>
</li>
<li>
<p dir="auto"><strong>Automatic OCR Fallback</strong>: If the extracted text appears corrupted or if the PDF is image-based, automatically falls back to OCR using Tesseract.</p>
</li>
</ol>
<p dir="auto">This approach works well for searchable PDFs and standard text documents. For complex OCR (e.g., handwriting, photographs), use a specialized tool.</p>

<p dir="auto">You can control PDF processing behavior using optional parameters:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from kreuzberg import extract_file


async def process_pdf():
  # Default behavior: auto-detect and use OCR if needed
  # By default, max_processes=1 for safe operation
  result = await extract_file(&#34;document.pdf&#34;)
  print(result.content)

  # Force OCR even for searchable PDFs
  result = await extract_file(&#34;document.pdf&#34;, force_ocr=True)
  print(result.content)

  # Control OCR concurrency for large documents
  # Warning: High concurrency values can cause system resource exhaustion
  # Start with a low value and increase based on your system&#39;s capabilities
  result = await extract_file(
    &#34;large_document.pdf&#34;,
    max_processes=4  # Process up to 4 pages concurrently
  )
  print(result.content)

  # Process a scanned PDF (automatically uses OCR)
  result = await extract_file(&#34;scanned.pdf&#34;)
  print(result.content)"><pre><span>from</span> <span>kreuzberg</span> <span>import</span> <span>extract_file</span>


<span>async</span> <span>def</span> <span>process_pdf</span>():
  <span># Default behavior: auto-detect and use OCR if needed</span>
  <span># By default, max_processes=1 for safe operation</span>
  <span>result</span> <span>=</span> <span>await</span> <span>extract_file</span>(<span>&#34;document.pdf&#34;</span>)
  <span>print</span>(<span>result</span>.<span>content</span>)

  <span># Force OCR even for searchable PDFs</span>
  <span>result</span> <span>=</span> <span>await</span> <span>extract_file</span>(<span>&#34;document.pdf&#34;</span>, <span>force_ocr</span><span>=</span><span>True</span>)
  <span>print</span>(<span>result</span>.<span>content</span>)

  <span># Control OCR concurrency for large documents</span>
  <span># Warning: High concurrency values can cause system resource exhaustion</span>
  <span># Start with a low value and increase based on your system&#39;s capabilities</span>
  <span>result</span> <span>=</span> <span>await</span> <span>extract_file</span>(
    <span>&#34;large_document.pdf&#34;</span>,
    <span>max_processes</span><span>=</span><span>4</span>  <span># Process up to 4 pages concurrently</span>
  )
  <span>print</span>(<span>result</span>.<span>content</span>)

  <span># Process a scanned PDF (automatically uses OCR)</span>
  <span>result</span> <span>=</span> <span>await</span> <span>extract_file</span>(<span>&#34;scanned.pdf&#34;</span>)
  <span>print</span>(<span>result</span>.<span>content</span>)</pre></div>

<p dir="auto">All extraction functions return an <code>ExtractionResult</code> or a list thereof (for batch functions). The <code>ExtractionResult</code> object is a <code>NamedTuple</code>:</p>
<ul dir="auto">
<li><code>content</code>: The extracted text (str)</li>
<li><code>mime_type</code>: Output format (&#34;text/plain&#34; or &#34;text/markdown&#34; for Pandoc conversions)</li>
<li><code>metadata</code>: A metadata dictionary. Currently this dictionary is only populated when extracting documents using pandoc.</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="from kreuzberg import extract_file, ExtractionResult, Metadata

async def process_document(path: str) -&gt; tuple[str, str, Metadata]:
    # Access as a named tuple
    result: ExtractionResult = await extract_file(path)
    print(f&#34;Content: {result.content}&#34;)
    print(f&#34;Format: {result.mime_type}&#34;)

    # Or unpack as a tuple
    content, mime_type, metadata = await extract_file(path)
    return content, mime_type, metadata"><pre><span>from</span> <span>kreuzberg</span> <span>import</span> <span>extract_file</span>, <span>ExtractionResult</span>, <span>Metadata</span>

<span>async</span> <span>def</span> <span>process_document</span>(<span>path</span>: <span>str</span>) <span>-&gt;</span> <span>tuple</span>[<span>str</span>, <span>str</span>, <span>Metadata</span>]:
    <span># Access as a named tuple</span>
    <span>result</span>: <span>ExtractionResult</span> <span>=</span> <span>await</span> <span>extract_file</span>(<span>path</span>)
    <span>print</span>(<span>f&#34;Content: <span><span>{</span><span>result</span>.<span>content</span><span>}</span></span>&#34;</span>)
    <span>print</span>(<span>f&#34;Format: <span><span>{</span><span>result</span>.<span>mime_type</span><span>}</span></span>&#34;</span>)

    <span># Or unpack as a tuple</span>
    <span>content</span>, <span>mime_type</span>, <span>metadata</span> <span>=</span> <span>await</span> <span>extract_file</span>(<span>path</span>)
    <span>return</span> <span>content</span>, <span>mime_type</span>, <span>metadata</span></pre></div>

<p dir="auto">Kreuzberg provides comprehensive error handling through several exception types, all inheriting from <code>KreuzbergError</code>. Each exception includes helpful context information for debugging.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from kreuzberg import extract_file
from kreuzberg.exceptions import (
    ValidationError,
    ParsingError,
    OCRError,
    MissingDependencyError
)

async def safe_extract(path: str) -&gt; str:
    try:
        result = await extract_file(path)
        return result.content

    except ValidationError as e:
        # Input validation issues
        # - Unsupported or undetectable MIME types
        # - Missing files
        # - Invalid input parameters
        print(f&#34;Validation failed: {e}&#34;)

    except OCRError as e:
        # OCR-specific issues
        # - Tesseract processing failures
        # - Image conversion problems
        print(f&#34;OCR failed: {e}&#34;)

    except MissingDependencyError as e:
        # System dependency issues
        # - Missing Tesseract OCR
        # - Missing Pandoc
        # - Incompatible versions
        print(f&#34;Dependency missing: {e}&#34;)

    except ParsingError as e:
        # General processing errors
        # - PDF parsing failures
        # - Format conversion issues
        # - Encoding problems
        print(f&#34;Processing failed: {e}&#34;)

    return &#34;&#34;"><pre><span>from</span> <span>kreuzberg</span> <span>import</span> <span>extract_file</span>
<span>from</span> <span>kreuzberg</span>.<span>exceptions</span> <span>import</span> (
    <span>ValidationError</span>,
    <span>ParsingError</span>,
    <span>OCRError</span>,
    <span>MissingDependencyError</span>
)

<span>async</span> <span>def</span> <span>safe_extract</span>(<span>path</span>: <span>str</span>) <span>-&gt;</span> <span>str</span>:
    <span>try</span>:
        <span>result</span> <span>=</span> <span>await</span> <span>extract_file</span>(<span>path</span>)
        <span>return</span> <span>result</span>.<span>content</span>

    <span>except</span> <span>ValidationError</span> <span>as</span> <span>e</span>:
        <span># Input validation issues</span>
        <span># - Unsupported or undetectable MIME types</span>
        <span># - Missing files</span>
        <span># - Invalid input parameters</span>
        <span>print</span>(<span>f&#34;Validation failed: <span><span>{</span><span>e</span><span>}</span></span>&#34;</span>)

    <span>except</span> <span>OCRError</span> <span>as</span> <span>e</span>:
        <span># OCR-specific issues</span>
        <span># - Tesseract processing failures</span>
        <span># - Image conversion problems</span>
        <span>print</span>(<span>f&#34;OCR failed: <span><span>{</span><span>e</span><span>}</span></span>&#34;</span>)

    <span>except</span> <span>MissingDependencyError</span> <span>as</span> <span>e</span>:
        <span># System dependency issues</span>
        <span># - Missing Tesseract OCR</span>
        <span># - Missing Pandoc</span>
        <span># - Incompatible versions</span>
        <span>print</span>(<span>f&#34;Dependency missing: <span><span>{</span><span>e</span><span>}</span></span>&#34;</span>)

    <span>except</span> <span>ParsingError</span> <span>as</span> <span>e</span>:
        <span># General processing errors</span>
        <span># - PDF parsing failures</span>
        <span># - Format conversion issues</span>
        <span># - Encoding problems</span>
        <span>print</span>(<span>f&#34;Processing failed: <span><span>{</span><span>e</span><span>}</span></span>&#34;</span>)

    <span>return</span> <span>&#34;&#34;</span></pre></div>
<p dir="auto">All exceptions include:</p>
<ul dir="auto">
<li>Error message</li>
<li>Context in the <code>context</code> attribute</li>
<li>String representation</li>
<li>Exception chaining</li>
</ul>

<p dir="auto">This library is open to contribution. Feel free to open issues or submit PRs. Its better to discuss issues before
submitting PRs to avoid disappointment.</p>

<ol dir="auto">
<li>
<p dir="auto">Clone the repo</p>
</li>
<li>
<p dir="auto">Install the system dependencies</p>
</li>
<li>
<p dir="auto">Install the full dependencies with <code>uv sync</code></p>
</li>
<li>
<p dir="auto">Install the pre-commit hooks with:</p>
<div dir="auto" data-snippet-clipboard-copy-content="pre-commit install &amp;&amp; pre-commit install --hook-type commit-msg"><pre>pre-commit install <span>&amp;&amp;</span> pre-commit install --hook-type commit-msg</pre></div>
</li>
<li>
<p dir="auto">Make your changes and submit a PR</p>
</li>
</ol>

<p dir="auto">This library uses the MIT license.</p>
</article></div></div>
  </body>
</html>
