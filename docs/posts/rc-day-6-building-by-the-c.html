<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mikeenglish.net/blog/2023/07/03/rc-day-6/">Original</a>
    <h1>RC Day 6 - Building by the C</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Today was my sixth day and the start of my second week at the <a href="https://www.recurse.com/scout/click?t=24c53dc56ddd7af575ff67d7fa1194c4">Recurse Center</a> as a participant in this year’s Summer 2 batch!</p>

<h3 id="writing">Writing</h3>

<p>I had some really good discussions this morning about how to make the most of our time in-batch.
A few of us<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> also discussed how to capture a large volume of ideas and new discoveries so we don’t forget them.
A common thread seems to be that writing first for oneself and then for an audience is a good way to first get ideas onto the page and then structure thoughts and solidify one’s understanding of a topic.</p>

<p>Lately, I’ve been using <a href="https://logseq.com/">Logseq</a> as a tool to capture thoughts and ideas throughout the day. 
I don’t worry too much about structuring them as I capture things - I just create a new bullet point whenever I want to add something.
If I’m taking notes on a meeting or specific topic I’ll nest bullet points under that topic, but otherwise I don’t worry too much about where things go.
This lack of pressure to provide any polish or structure up front has greatly increased the volume of ideas I write down, which has in turn made it easier to keep writing and share ideas on Zulip and on this blog.
I’ve also given myself permission to make these daily blog posts as short or as long as they need to be. If at some point I only have one sentence to write about a given day, that would be OK.</p>

<h3 id="linking-to-a-rust-library-from-c">Linking to a Rust library from C</h3>

<p>Later in the day I spent some time pairing with Rhea on my project to link to a Rust library from <a href="https://ffmpeg.org/">ffmpeg</a>.</p>

<p>With a few hacks, we were able to get ffmpeg to build and link against our toy Rust library today!
<del>At some point I plan to write up what was needed to make that work.</del></p>

<p>On <em>second thought</em>, in the spirit of <strong>capturing discoveries before they’re forgotten</strong>, here’s the gist of what we’ve done so far:</p>
<ul>
  <li>Created a new library crate (<code>cargo new --lib ffout</code>)</li>
  <li>Added no-op stubs for some functions in <code>src/lib.rs</code> that I think we’ll need:
    <ul>
      <li><code>write_header</code></li>
      <li><code>write_packet</code></li>
      <li><code>write_trailer</code></li>
    </ul>
  </li>
  <li>Added the <a href="https://crates.io/crates/ffmpeg-sys-next"><code>ffmpeg-sys-next</code></a> crate to our dependencies in <code>Cargo.toml</code></li>
  <li><code>use</code>‘d the necessary types in <code>src/lib.rs</code> to provide appropriate function signatures — namely:
    <ul>
      <li><code>use ffmpeg_sys_next::{AVFormatContext, AVPacket}</code></li>
      <li><code>use std::os::raw::c_int;</code></li>
    </ul>
  </li>
  <li>Made the functions all <code>pub extern &#34;C&#34;</code> and marked them <code>#[no_mangle]</code> so the correct symbols get exported</li>
  <li>Set <code>crate-type</code> in <code>Cargo.toml</code> to <code>[&#34;cdylib&#34;, &#34;staticlib&#34;]</code> to build C-compatible dynamic and static libraries</li>
  <li>Figured out that this only seems to work when building <code>--release</code> targets for some reason</li>
  <li>Realized we needed to produce a header file for these libraries</li>
  <li>Found <a href="https://github.com/mozilla/cbindgen"><code>cbindgen</code></a> and added it to our <code>build.rs</code> to create a header file at <code>target/release/ffout.h</code></li>
  <li>Figured out how to configure <code>cbindgen</code> to produce C header files instead of C++ header files (<code>cbindgen.toml</code>)</li>
  <li>Determined we’ll also want to produce a <code>pkg-config</code> file (<code>libffout.pc</code>)</li>
  <li>Borrowed heavily from other patches to produce a changeset for <code>ffmpeg</code> itself to optionally build with support for our library
    <ul>
      <li>(Note: this part is almost certainly not correct yet, but it’s close enough to test basic linking at least)</li>
    </ul>
  </li>
  <li>Learned about <a href="https://github.com/lu-zero/cargo-c"><code>cargo-c</code></a> and its slightly more opinionated approach to building C ABI libraries like this</li>
  <li>Decided to keep doing things by hand a bit more before adopting <code>cargo-c</code></li>
  <li>Added some code to <code>build.rs</code> to write a statically defined <code>target/release/libffout.pc</code></li>
  <li>Added a Makefile to “install” and “uninstall” our library from <code>/usr/local</code> for testing</li>
  <li>Spent a good portion of the afternoon just making names and paths match up correctly
    <ul>
      <li>Fun fact I knew: linking C libaries by convention drops any leading <code>lib</code> prefix from the library name in the linker flags (e.g. <code>-lffout</code> to link against <code>libffout.a</code>)</li>
      <li>Fact I had forgotten: by convention, header files also drop the <code>lib</code> portion of the library’s full name (e.g. <code>libffout/ffout.h</code>)</li>
    </ul>
  </li>
  <li>One last hack: since Homebrew doesn’t seem to link <code>ffmpeg</code>’s libraries or headers into <code>/usr/local</code>, we put the path of my local ffmpeg git checkout direclty into our <code>libffout.pc</code> configuration’s include flags so that ffmpeg could find its own headers which define the <code>AVFormatContext</code> and <code>AVPacket</code> structs our functions accept</li>
</ul>

<p>In the end we were able to get our patched <code>ffmpeg</code>’s <code>./configure</code> script to run without error, and <code>make</code> even worked!</p>

<p>My repos for work this are public on GitHub, but they’re not really in a tutorial or walkthrough state of cleanliness so I’m not linking directly to them here for now.
If you’re curious about any of this though, feel free to poke around my <a href="https://github.com/englishm">GitHub profile</a> and/or ping me on <a href="https://hachyderm.io/@englishm">Hachyderm</a>, <a href="https://bsky.app/profile/englishm.bsky.social">Bluesky</a>, <a href="https://discordapp.com/users/123510893194510337">Discord</a>, or even <a href="https://twitter.com/englishm_">Twitter</a> or wherever else you can find me.</p>

<h3 id="media-over-quic-moq-and-cdns">Media over QUIC (MoQ) and CDNs</h3>

<p>After that I spent some time catching up with non-RC collaborators and other folks interested in <a href="https://datatracker.ietf.org/wg/moq/about/">MoQ</a> and talked about things like what “CDN support” means for a protocol like this as compared to something like WebRTC.</p>

<p>Tomorrow, I’ll take the day off of RC to spend with family.</p>

<hr/>





  </div>

</article>

      </div>
    </div></div>
  </body>
</html>
