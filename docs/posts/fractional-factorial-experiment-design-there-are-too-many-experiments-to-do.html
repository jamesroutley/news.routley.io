<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.demofox.org/2023/10/17/fractional-factorial-experiment-design-when-there-are-too-many-experiments-to-do/">Original</a>
    <h1>Fractional Factorial Experiment Design: There Are Too Many Experiments to Do</h1>
    
    <div id="readability-page-1" class="page"><div>
				
<p>Have you ever found yourself in a situation where you had a bunch of parameters to tune for a better result, but there were just too many to exhaustively search all possibilities?</p>



<p>I recently saw a video that talked about how to reduce the number of experiments in these situations, such that it formalizes what conclusions you can and cannot make from those experiments. Even better, the number of experiments can be a sliding scale to either be fewer experiments (faster), or more information from the results (higher quality).</p>



<p>We are going to explore a method for doing that in this post, but you should also give the video a watch before or after reading, as it talks about a different method than we will! <a href="https://www.youtube.com/watch?v=5oULEuOoRd0" rel="nofollow">https://www.youtube.com/watch?v=5oULEuOoRd0</a></p>



<h2>Fractional Factorial Design Terminology</h2>



<p>The term “fractional factorial” is in contrast to the term “full factorial”.</p>



<p>To have some solid context, let’s pretend that we want to figure out how to make the best brownies, and we have 3 options A, B, C. Option “A” may be “add an extra egg”, “B” may be “double the butter” and “C” may be “put nuts on top”, where 1 means do it, and -1 means don’t do it. </p>



<p>Three parameters with two choices each means we have 8 possibilities total:</p>



<figure><table><tbody><tr><td></td><td>A</td><td>B</td><td>C</td></tr><tr><td>Test 0</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>Test 1</td><td>-1</td><td>-1</td><td>1</td></tr><tr><td>Test 2</td><td>-1</td><td>1</td><td>-1</td></tr><tr><td>Test 3</td><td>-1</td><td>1</td><td>1</td></tr><tr><td>Test 4</td><td>1</td><td>-1</td><td>-1</td></tr><tr><td>Test 5</td><td>1</td><td>-1</td><td>1</td></tr><tr><td>Test 6</td><td>1</td><td>1</td><td>-1</td></tr><tr><td>Test 7</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></figure>



<p>We’ve essentially counted in binary, doing all 8 tests for all 8 possibilities of the three binary parameters.</p>



<p>If you’ve noticed that the number of tests are 2^3, and not a factorial, you are correct. The term “factorial” refers to “factors” which is another name for a parameter.  We have 3 factors in our experiment to make the best brownies.</p>



<p>Each factor has two possible values. In the literature, the number of values a parameter can take is called a level.  So, our brownie experiment has 3 two level factors.</p>



<p>If we didn’t have enough pans to bake all 8 types of brownies, we may instead opt to do a smaller amount.  We may only do 1/2 of the tests for instance, which means that we would be doing a fractional amount of the full factorial experiment.  We’d be doing a fractional factorial experiment.  We could even do 1/4 of the experiments.  The fewer experiments we do, the less information we get.</p>



<p>Choosing which four experiments to do, and knowing what conclusions we can draw form the results is where the magic happens.</p>



<h2>Fractional Factorial Design</h2>



<p>Going back to our brownie recipe, let’s say that we want to do 4 bakes, instead of 8.</p>



<p>We start by making a full experiment table for A and B, but leave C blank</p>



<figure><table><tbody><tr><td></td><td>A</td><td>B</td><td>C</td></tr><tr><td>Test 0</td><td>-1</td><td>-1</td><td></td></tr><tr><td>Test 1</td><td>-1</td><td>1</td><td></td></tr><tr><td>Test 2</td><td>1</td><td>-1</td><td></td></tr><tr><td>Test 3</td><td>1</td><td>1</td><td></td></tr></tbody></table></figure>



<p>We now have to decide on a formula for how to set C’s value, based on the value of A and B. This is called a generator and to test things out, lets set C to the same value as A, so our generator for C is “C = A”</p>



<figure><table><tbody><tr><td></td><td>A</td><td>B</td><td>C=A</td></tr><tr><td>Test 0</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>Test 1</td><td>-1</td><td>1</td><td>-1</td></tr><tr><td>Test 2</td><td>1</td><td>-1</td><td>1</td></tr><tr><td>Test 3</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></figure>



<p>We have 4 experiments to do now, instead of 8, but it isn’t obvious what information we can get from the results.  Luckily some algebra can help us sort that out.  This algebra is a bit weird in that any letter squared becomes “I”, or identity.  Our ultimate goal is to find the “Aliasing Structure” of our experiments, which is made up of “words”. Words are combinations of the parameter letters, as well as identity “I”.  The aliasing structure lets you use algebra to find what testing parameters alias with other testing parameters. An alias means you can’t tell one from the other, with the limited number of tests you’ve done.</p>



<p>That is quite a lot of explaining, so lets actually do these things.</p>



<p>First up we have <strong><em>C = A</em></strong>.  If we multiply both sides by <strong><em>C</em></strong> we get <strong><em>CC = AC</em></strong>.  Any value multiplied by itself is identity, so we get <strong><em>I = AC</em></strong> as a result.  Believe it or not, that is our full aliasing structure and we are done! We’ll have more complex aliasing structures later but we can keep it simple for now.</p>



<p>Now that we have our aliasing structure, if we want to know what something is aliased by, we just multiply both sides by our query to get the result.  Here’s a table to show what I mean.</p>



<figure><table><tbody><tr><td>Alias Query</td><td>Result</td></tr><tr><td>I</td><td>I = AC</td></tr><tr><td>A</td><td>A = AAC = C</td></tr><tr><td>B</td><td>B = ABC</td></tr><tr><td>C</td><td>C = ACC = A</td></tr><tr><td>AB</td><td>AB = AABC = BC</td></tr><tr><td>AC</td><td>AC = AACC = I</td></tr><tr><td>BC</td><td>BC = ABCC = AB</td></tr><tr><td>ABC</td><td>ABC = AABCC = B</td></tr></tbody></table></figure>



<p>Looking at the table above, we see that <strong><em>B = ABC</em></strong>. This means that B aliases ABC. More plainly, this means that from our experiments, if the brownies were rated from 1 to 10 for tastyness, we wouldn’t be able to tell the difference in results between only doing option B (doubling the butter) and doing all three options: adding an egg, doubling the butter, and adding nuts on top.</p>



<p>Another thing we can see in the table is that <strong><em>A = C</em></strong>.  That means that we cannot tell the difference between adding an egg, or adding nuts on top.</p>



<p>Lastly, <strong><em>I = AC</em></strong> means that we can’t tell the difference between doing nothing at all, compared to adding an egg and adding nuts on top.</p>



<p>If we care to be able to distinguish any of these things, we’d have to change our experiment design. Specifically, we would need to change the generator for C.</p>



<p>We can do that, and in fact there is a better choice for a generator for C.  Let’s make it so that value of C is the value of A and B multiplied together. <strong><em>C = AB</em></strong>.</p>



<figure><table><tbody><tr><td></td><td>A</td><td>B</td><td>C=AB</td></tr><tr><td>Test 0</td><td>-1</td><td>-1</td><td>1</td></tr><tr><td>Test 1</td><td>-1</td><td>1</td><td>-1</td></tr><tr><td>Test 2</td><td>1</td><td>-1</td><td>-1</td></tr><tr><td>Test 3</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></figure>



<p>It doesn’t look like much has changed, but lets do the same analysis as before.</p>



<p>We can get our aliasing structure by starting with <strong><em>C=AB</em></strong> and multiplying both sides by C to get <strong><em>CC=ABC</em></strong>, which simplifies to <strong><em>I = ABC</em></strong>.  Let’s find all of our aliases again.</p>



<figure><table><tbody><tr><td>Alias Query</td><td>Result</td></tr><tr><td>I</td><td>I = ABC</td></tr><tr><td>A</td><td>A = BC</td></tr><tr><td>B</td><td>B = AC</td></tr><tr><td>C</td><td>C = AB</td></tr><tr><td>AB</td><td>AB = C</td></tr><tr><td>AC</td><td>AC = B</td></tr><tr><td>BC</td><td>BC = A</td></tr><tr><td>ABC</td><td>ABC = I</td></tr></tbody></table></figure>



<p>Something interesting has happened with this design of experiments (D.O.E.).  All of the single letters alias with double letters.  This means that we can distinguish all primary effects from each other, but that primary effects are aliased (or get “confounded”) with secondary effects.  In many situations, the primary effects are more prominent than secondary effects (adding butter or adding nuts is more impactful individually, than when combined). In these situations, you can assume that if there’s a big difference noticed, that it is the primary effect causing it.  If there’s any doubt, you can also do more focused experiment(s) to make sure your assumptions are correct.</p>



<h2>Resolution</h2>



<p>So why is it that our first generator C=A wasn’t able to differentiate primary effects, while our second generator C=AB could?  For such a simple example, it might be obvious when looking at C=A, but this has to do with something called “Resolution”, which is equal to the length of shortest word in the aliasing structure (not counting I).</p>



<p>With I=CA, that is two letters, so it is a resolution II D.O.E.  Resolution II D.O.E.s have at least some primary effects aliased (or confounded) with other primary effects.  Resolution II D.O.E.s are usually not very useful.</p>



<p>With I=ABC, that is three letters, so is a resolution III D.O.E. Resolution III D.O.E.s have primary effects aliased with secondary effects. These are more useful, as we explained above.</p>



<p>As you add more factors, you can get even higher resolution D.O.E.s.  A resolution IV has primary effects aliased with tertiary effects, and secondary effects are aliased with each other.  A resolution V has primary effects aliased with quaternary effects, and secondary effects are aliased with tertiary effects. If you are noticing the pattern that the aliasing effect classes add up to the resolution, you are correct, and that pattern holds for all resolutions.</p>



<p>Getting a higher resolution D.O.E. is usually better, so you want your generators to contain more letters.  You have to be careful to make them unique enough though.  If you had four factors A,B,C,D and generators C=AB, D=AB, you can see that you’ve introduced an alias C=D.</p>



<p>If you work out the aliasing structure, this problem becomes apparent that you’ve made a resolution II D.O.E.  Aliasing structures always need 2^p words, where p is the number of parameters that have generators.  In this case, p is 2, so you need 2^2 or 4 words in the aliasing structure.</p>



<p>The first word comes from C=AB, which can be rewritten as I=ABC. Actually that’s the first two words.</p>



<p>The second word comes from D=AB, which can be rewritten as I=ABD. That gives us three words:</p>



<p>I = ABC = ABD</p>



<p>To get the fourth word, we can see that both ABC and ABD are equal to each other. Remembering that when we multiply the same thing against itself we get identity, we can make our fourth word by multiplying them together to get something equal to identity for our aliasing structure.</p>



<p>ABC*ABD = AABBCD = CD.</p>



<p>So, our four words all together are:</p>



<p>I = ABC = ABD = CD</p>



<p>Since “CD” is the shortest word that is not identity, and is 2 letters, we can conclude that we have a resolution II D.O.E. </p>



<p>We can multiply the aliasing structure by C to get all the things that C is aliased with.</p>



<p>C = AB = ABCD = D</p>



<p>This shows we cannot tell the difference between C and D, because they are aliased, or confounded, and confirms that we have a resolution II D.O.E.</p>



<h2>What’s With The Weird Algebra?</h2>



<p>When we said C=AB, where A and B were either -1 or +1 in each column, it was pretty easy to just multiply the values together to get the result.</p>



<p>What probably made less sense is when working with the generators and aliasing structures, why a letter times itself would become identity.  The reason for this is that the multiplication is a component wise vector product.  If the original value was -1, then we get -1*-1 or +1.  If the original value was +1, then we get 1*1 or +1.  The result of a component wise vector product between a vector and itself will have a 1 in every component, which is identity.</p>



<p>Nothing too mysterious going on.</p>



<h2>Larger Example: 8 Experiments, 5 Factors, 2 Levels</h2>



<p>To help cement these ideas, we’ll do one more example with 8 experiment and 5 factors.  That means we’ll only do 1/4 of the experiments we would if doing the full factorial, doing 8 experiments instead of 32.</p>



<p>8 experiments mean that the first three factors will be full factorial, and the last two parameters will need generators. We’ll use D = AB and E=BC as our generators.</p>



<p>We can make our experiment table to start.</p>



<figure><table><tbody><tr><td></td><td>A</td><td>B</td><td>C</td><td>D=AB</td><td>E=BC</td></tr><tr><td>Test 0</td><td>-1</td><td>-1</td><td>-1</td><td>1</td><td>1</td></tr><tr><td>Test 1</td><td>-1</td><td>-1</td><td>1</td><td>1</td><td>-1</td></tr><tr><td>Test 2</td><td>-1</td><td>1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>Test 3</td><td>-1</td><td>1</td><td>1</td><td>-1</td><td>1</td></tr><tr><td>Test 4</td><td>1</td><td>-1</td><td>-1</td><td>-1</td><td>1</td></tr><tr><td>Test 5</td><td>1</td><td>-1</td><td>1</td><td>-1</td><td>-1</td></tr><tr><td>Test 6</td><td>1</td><td>1</td><td>-1</td><td>1</td><td>-1</td></tr><tr><td>Test 7</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></figure>



<p>Let’s also make our aliasing structure. Since we are using generators on 2 parameters, that means p=2, and so we have 2^p = 2^2 = 4 words in our aliasing structure. The first 3 are easy, since they come from our generators directly.</p>



<p>D = AB : I = ABD</p>



<p>For the fourth word, we again know that ABD and BCE are equal since they are both equal to identity. We also know that multiplying anything by itself is identity, so we can multiply them together to get the fourth word:</p>



<p>ABD*BCE = ABBCDE = ACDE</p>



<p>Our full aliasing structure is then the below, which shows that we have a resolution III D.O.E, meaning primary effects are only aliased with secondary effects.</p>



<p>I = ABD = BCE = ACDE</p>



<p>Lastly, let’s make the full 32 entry table showing all aliases to understand the things we can, and cannot differentiate from our experiment results.</p>



<figure><table><tbody><tr><td>Alias Query</td><td>Result</td></tr><tr><td>I</td><td>I = ABD = BCE = ACDE</td></tr><tr><td>A</td><td>A = BD = ABCE = CDE</td></tr><tr><td>B</td><td>B = AD = CE = ABCDE</td></tr><tr><td>C</td><td>C = ABCD = BE = ADE</td></tr><tr><td>D</td><td>D = AB = BCDE = ACE</td></tr><tr><td>E</td><td>E = ABDE = BC = ACD</td></tr><tr><td>AB</td><td>AB = D = ACE = BCDE</td></tr><tr><td>AC</td><td>AC = BCD = ABE = DE</td></tr><tr><td>AD</td><td>AD = B = ABCDE = CE</td></tr><tr><td>AE</td><td>AE = BDE = ABC = CD</td></tr><tr><td>BC</td><td>BC = ACD = E = ABDE</td></tr><tr><td>BD</td><td>BD = A = CDE = ABCE</td></tr><tr><td>BE</td><td>BE = ADE = C = ABCD</td></tr><tr><td>CD</td><td>CD = ABC = BDE = AE</td></tr><tr><td>CE</td><td>CE = ABCDE = B = AD</td></tr><tr><td>DE</td><td>DE = ABE = BCD = AC</td></tr><tr><td>ABC</td><td>ABC = CD = AE = BDE</td></tr><tr><td>ABD</td><td>ABD = I = ACDE = BCE</td></tr><tr><td>ABE</td><td>ABE = DE = AC = BCD</td></tr><tr><td>ACD</td><td>ACD = BC = ABDE = E</td></tr><tr><td>ACE</td><td>ACE = BCDE = AB = D</td></tr><tr><td>ADE</td><td>ADE = BE = ABCD = C</td></tr><tr><td>BCD</td><td>BCD = AC = DE = ABE</td></tr><tr><td>BCE</td><td>BCE = ACDE = I = ABD</td></tr><tr><td>BDE</td><td>BDE = AE = CD = ABC</td></tr><tr><td>CDE</td><td>CDE = ABCE = BD = A</td></tr><tr><td>ABCD</td><td>ABCD = C = ADE = BE</td></tr><tr><td>ABCE</td><td>ABCE = CDE = A = BDE</td></tr><tr><td>ABDE</td><td>ABDE = E = ACD = BC</td></tr><tr><td>ACDE</td><td>ACDE = BCE = ABD = I</td></tr><tr><td>BCDE</td><td>BCDE = ACE = D = AB</td></tr><tr><td>ABCDE</td><td>ABCDE = CE = AD = B</td></tr></tbody></table></figure>



<h2>Closing</h2>



<p>A limitation you may have noticed in this article is that it only works with binary parameters (2 level factors).  Part 2 of this blog post will show how to overcome that limitation using a different technique for fractional factorial experimental design.</p>



<p>Until then, there is a way to extend this method to factors which have a multiple of 4 levels.  If you are interested in that, google Plackett-Burman.</p>
			</div></div>
  </body>
</html>
