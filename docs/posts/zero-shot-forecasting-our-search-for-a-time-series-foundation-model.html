<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.parseable.com/blog/zero-shot-forecasting">Original</a>
    <h1>Zero-Shot Forecasting: Our Search for a Time-Series Foundation Model</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-parent"><div id="post-content-wrapper"><blockquote>
<p>Parseable is a new and rapidly growing project focused on delivering fast and seamless observability on S3. If you love what we&#39;re building, show us some ❤️ by <a target="_blank" href="https://github.com/parseablehq/parseable">starring our repository</a>. Your support keeps our team motivated!</p>
</blockquote>
<p>Now, let&#39;s dive into the blog!</p>
<h2 id="heading-introduction">Introduction</h2>
<p>In the last few years, the field of time-series forecasting has seen a fundamental shift. Where we once depended solely on classic statistical methods, think <a target="_blank" href="https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average">ARIMA</a>, <a target="_blank" href="https://machinelearningmastery.com/sarima-for-time-series-forecasting-in-python/">SARIMA</a>, and <a target="_blank" href="https://facebook.github.io/prophet/">Prophet</a>, new “foundation” models have emerged, promising to bring the power and flexibility of large language models (LLMs) into the world of time-series data. The allure is obvious: can we build a single, reusable forecasting model that works across a variety of datasets and domains, instead of painstakingly training a new model for every scenario?</p>
<p><a target="_blank" href="https://www.parseable.com/">Parseable</a> is built to handle our users’ observability data at any scale, a nonstop stream of raw ingest counts, infrastructure vitals, and fine-grained application signals. Running a separate, hand-tuned forecasting model for every slice quickly turns into a treadmill: each new stream or workload tweak demands fresh hyper-params, retrains, and ever-growing config sprawl. All that manual churn slows forecasts and breeds drift, so the results never feel fully trustworthy.</p>
<p>Then came the rise of foundation models, which revolutionised natural language processing by offering strong zero-shot and transfer learning capabilities. Researchers began asking a natural question: if LLMs can generalise to new tasks with minimal retraining, could similar techniques be applied to time-series data? What if you could just hand any telemetry stream to a pre-trained foundation model and immediately get a high-quality forecast, regardless of whether the model had seen data from that source before?</p>
<p>Motivated by this possibility, we set out to benchmark a new generation of time-series foundation models, <a target="_blank" href="https://github.com/amazon-science/chronos-forecasting">Amazon Chronos</a>, <a target="_blank" href="https://github.com/google-research/timesfm">Google TimesFM</a>, <a target="_blank" href="https://research.ibm.com/publications/tiny-time-mixers-ttms-fast-pre-trained-models-for-enhanced-zerofew-shot-forecasting-of-multivariate-time-series--1">IBM Tiny Time-Mixers</a>, and <a target="_blank" href="https://github.com/DataDog/toto">Datadog Toto</a><a target="_blank" href="https://github.com/Time-MoE/Time-MoE">.</a> Our goal was to assess how well these models perform on two representative tasks: a relatively straightforward forecasting problem (predicting ingestion volumes) and a more complex multivariate problem (forecasting multiple pod-level metrics). Along the way, we compared them to classical baselines and took note of both practical and technical trade-offs.</p>
<p>This post details our methodology, the challenges we encountered, how we evaluated the models, and what we learned from putting foundation models to the test on real-world observability data.</p>
<h2 id="heading-why-foundation-models">Why Foundation Models?</h2>
<p>The idea of “foundation models” has fundamentally changed how we approach complex machine learning problems. In natural language processing, models like GPT have shown that a single, large model trained on vast and diverse datasets can generalize well to entirely new tasks sometimes even without fine-tuning. This zero-shot capability means a single model can perform sentiment analysis, summarization, translation, or question-answering, just by changing the prompt.</p>
<p>In the world of time-series forecasting, the appeal of such flexibility is obvious, especially for modern data engineering and observability platforms. Traditionally, every new data stream whether it’s CPU utilization, request rates, or disk I/O required its own model, hyperparameter tuning, and regular retraining. For an SRE or platform engineer, this quickly becomes unmanageable as the number of streams explodes. If a pipeline ingests data from a hundred microservices, does every service metric really need its own hand-tuned ARIMA or Prophet model? The answer, up until recently, was “yes.”</p>
<p>Foundation models for time series are built to change that. The core motivation is scalability and adaptability: train a single, large model (often with billions of parameters) on a wide range of time-series datasets and let it learn the underlying “language” of temporal data. Once trained, this model should ideally handle a completely new telemetry stream, even if it has never seen data of that exact shape or domain before. In theory, you could input any new time series, whether it’s network packet counts, database query durations, or energy consumption readings and get a high-quality forecast without retraining.</p>
<p>This is a huge leap from traditional approaches. Classic statistical models like ARIMA or seasonal decomposition excel when you have clean, stationary data and a well-understood seasonal pattern, but fall short when faced with missing values, sudden regime changes, or non-standard periodicity. More importantly, these models can’t transfer knowledge from one dataset to another; every dataset is a blank slate.</p>
<p>On the other hand, foundation models bring the promise of:</p>
<ul>
<li><p><strong>Zero-shot forecasting:</strong> Run predictions on new datasets without needing to retrain the model.</p>
</li>
<li><p><strong>Robustness to data variety:</strong> Adapt to changing data distributions, missing values, and previously unseen behaviors.</p>
</li>
<li><p><strong>Simplified operations:</strong> Lower the engineering overhead of managing hundreds of individual models.</p>
</li>
<li><p><strong>Transfer learning:</strong> Leverage patterns learned from one domain (e.g., retail traffic) to help forecast another (e.g., system metrics).</p>
</li>
</ul>
<p>In practical terms, this means you can dramatically speed up time to value for forecasting tasks, especially in fast-moving environments like cloud infrastructure and observability, where new streams appear all the time and data is messy by default. Instead of spending weeks building and maintaining forecasting pipelines for each stream, you could plug in a foundation model and start generating insights almost immediately.</p>
<p>Of course, there are open questions: Do these models really perform well on operational data? Can they match (or beat) hand-tuned classic models? And what are the compute and operational trade-offs involved? Our benchmarking journey set out to answer exactly those questions, by seeing how today’s top time-series foundation models actually perform on real, production-scale telemetry.</p>
<h2 id="heading-models-explored"><strong>Models Explored</strong></h2>
<p>To understand what “zero-shot” time-series forecasting looks like in practice, we selected a range of recently released foundation models. Each of these models represents a different philosophy and technical approach to the problem, some focus on universality, others on resource efficiency, and a few on tackling multivariate streams directly. Here’s a brief tour of the models we benchmarked:</p>
<h3 id="heading-amazon-chronos">Amazon Chronos</h3>
<p>Chronos is designed to be a universal forecaster for time-series data, capable of handling both univariate and multivariate streams. Built with transformer-based architecture and trained on a massive collection of open time-series datasets, Chronos aims to generalize well across domains, from finance and retail to infrastructure telemetry. With support for both batch and streaming predictions, Chronos is particularly attractive for use cases where the underlying data distributions can shift rapidly.</p>
<p><strong>Technical highlights</strong></p>
<ul>
<li><p>Architecture: Transformer-based (details in the official paper)</p>
</li>
<li><p>Supports: Univariate &amp; Multivariate forecasting</p>
</li>
<li><p>Typical parameter count: Tens of millions (specific version-dependent)</p>
</li>
<li><p>License: Apache 2.0</p>
</li>
</ul>
<h3 id="heading-google-timesfm">Google TimesFM</h3>
<p>Google’s TimesFM (Time Series Foundation Model) is positioned as the GPT-style model for time-series analysis. Trained on billions of data points, TimesFM leverages a large, attention-based architecture to capture temporal dependencies and seasonalities. It is primarily geared towards univariate forecasting tasks, such as predicting sales, energy usage, or metrics like CPU utilization, and is often used in research for benchmarking “zero-shot” and “few-shot” performance.</p>
<p><strong>Technical highlights</strong></p>
<ul>
<li><p>Architecture: Large language model adaptation for time-series</p>
</li>
<li><p>Supports: Univariate forecasting</p>
</li>
<li><p>Parameter count: Billions</p>
</li>
<li><p>License: Apache 2.0</p>
</li>
</ul>
<h3 id="heading-ibm-tiny-time-mixers">IBM Tiny Time-Mixers</h3>
<p>IBM’s Tiny Time-Mixers take the opposite approach: Instead of scaling up, they focus on making time-series foundation models small and efficient enough to run on the edge or in resource-constrained environments. Despite their compact size, these models are trained on diverse datasets and often deliver surprising accuracy, making them a good fit for IoT, embedded devices, or any observability scenario where every CPU cycle counts.</p>
<p><strong>Technical highlights</strong></p>
<ul>
<li><p>Architecture: Lightweight mixer-based neural network</p>
</li>
<li><p>Supports: Univariate forecasting</p>
</li>
<li><p>Parameter count: Hundreds of thousands to a few million</p>
</li>
<li><p>License: Apache 2.0</p>
</li>
</ul>
<h3 id="heading-datadog-toto">Datadog Toto</h3>
<p>Datadog’s Toto is a production-grade, multivariate time-series foundation model. It’s tailored for real-world infrastructure monitoring, where multiple correlated metrics need to be forecasted together, think CPU, memory, and network traffic. Toto is also designed for scalability and reliability, with emphasis on fast warm-up times and high throughput.</p>
<p><strong>Technical highlights</strong></p>
<ul>
<li><p>Architecture: Multivariate deep learning model (architecture details partially proprietary)</p>
</li>
<li><p>Supports: Multivariate forecasting</p>
</li>
<li><p>Parameter count: Several million (exact details not fully disclosed)</p>
</li>
<li><p>License: Apache 2.0</p>
</li>
</ul>
<div>
<table>
<thead>
<tr>
<td><strong>Model</strong></td><td><strong>Publisher</strong></td><td><strong>Params</strong></td><td><strong>Uni/Multi</strong></td><td><strong>License</strong></td><td><strong>Notable Feature</strong></td></tr>
</thead>
<tbody>
<tr>
<td>Amazon Chronos</td><td>AWS</td><td>~10M–100M+</td><td>Both</td><td>Apache 2.0</td><td>General-purpose, scalable</td></tr>
<tr>
<td>Google TimesFM</td><td>Google</td><td>~1B+</td><td>Uni</td><td>Apache 2.0</td><td>Large, transformer-based</td></tr>
<tr>
<td>IBM Tiny Time-Mixers</td><td>IBM</td><td>&lt;5M</td><td>Uni</td><td>Apache 2.0</td><td>Ultra-lightweight, edge-ready</td></tr>
<tr>
<td>Datadog Toto</td><td>Datadog</td><td>~10M+ (est.)</td><td>Multi</td><td>Apache 2.0</td><td>Production multivariate</td></tr>
</tbody>
</table>
</div><p>These models collectively showcase the diversity in approaches, trade-offs, and intended deployment environments in the modern time-series forecasting landscape. In the following sections, we’ll dive into how we evaluated them and what we learned.</p>
<h2 id="heading-evaluation-metric">Evaluation Metric</h2>
<p>When benchmarking forecasting models, especially across a wide variety of time-series tasks, choosing the right evaluation metric is critical. It needs to be robust, interpretable, and fair across datasets that may vary widely in scale, seasonality, and behavior. For our study, we selected <strong>Mean Absolute Percentage Error (MAPE)</strong> as the primary metric.</p>
<h3 id="heading-why-mape">Why MAPE?</h3>
<p>MAPE stands out for a few practical reasons. First, it’s easy to interpret: the result is simply the average absolute error, expressed as a percentage of the true values. A MAPE of 5% means, on average, your forecasts are within 5% of the real-world values, intuitive enough for both data scientists and engineers managing the infrastructure. This makes it a great fit when you need to quickly assess whether a model’s performance is “good enough” to trust in production.</p>
<p>Second, MAPE is <strong>scale-invariant</strong>. That means we can compare errors from streams measured in bytes per second with those measured in milliseconds or CPU units, without worrying that one type of metric will dominate the results simply because of its numeric range. This is especially important in observability, where you might be forecasting everything from request rates (hundreds per second) to memory utilization (gigabytes).</p>
<p><strong>How does MAPE work?</strong></p>
<p><code>MAPE = (1/n) × Σ |(actual - forecast) / actual| × 100</code></p>
<p>Where:</p>
<ul>
<li><p>actual is the real observed value,</p>
</li>
<li><p>forecast is the predicted value,</p>
</li>
<li><p>and n is the total number of observations in the test set.</p>
</li>
</ul>
<p><strong>When is MAPE well-suited?</strong></p>
<p>We also considered other metrics like RMSE (Root Mean Squared Error) and sMAPE (Symmetric MAPE) for completeness, but kept the primary focus on MAPE for its clarity and direct relevance to production observability pipelines. When the goal is to provide easy-to-grok, actionable metrics for engineers and SREs, who might need to explain model accuracy to their teams, MAPE simply makes sense.</p>
<h2 id="heading-dataset-used"><strong>Dataset Used</strong></h2>
<p>The reliability of any benchmarking effort depends heavily on the diversity and realism of the underlying datasets. For this study, we set out to mimic the kind of time-series data that an observability or infrastructure engineering team actually deals with, no sanitized academic benchmarks, just real production telemetry.</p>
<h3 id="heading-data-sources">Data Sources</h3>
<p>For this benchmark, we focused exclusively on a complex, multivariate forecasting task designed to reflect real-world challenges in modern observability. Our dataset consisted of Kubernetes pod metrics collected from a production retail checkout application. These streams included CPU usage, memory consumption, and request latency, all sampled at one-second intervals. This setup provided a “ground truth” that included steady workloads, sudden spikes, and all the operational quirks you see in live systems, perfect for stress-testing both classic and foundation forecasting models.</p>
<h4 id="heading-pre-processing-steps">Pre-Processing Steps</h4>
<p>Time-series forecasting models (especially deep learning ones) are highly sensitive to noise, missing values, and sampling inconsistencies. To level the playing field, we applied the following pre-processing pipeline:</p>
<ul>
<li><p><strong>Resampling:</strong></p>
</li>
<li><p><strong>Missing Value Handling:</strong></p>
</li>
<li><p><strong>Normalization:</strong></p>
</li>
<li><p><strong>Sliding Window Split:</strong></p>
</li>
<li><p><strong>Multivariate Structuring:</strong></p>
</li>
</ul>
<h4 id="heading-ensuring-fair-evaluation">Ensuring Fair Evaluation</h4>
<p>All pre-processing, normalization, and data splits were defined in config files and applied identically across every model. This strict protocol ensured fairness and reproducibility—no hand-tuning for individual models, no hidden data leaks. Our goal was to see how these models really perform on real production telemetry, not just sanitized academic datasets.</p>
<h2 id="heading-results-and-observations"><strong>Results and Observations</strong></h2>
<div>
<table>
<thead>
<tr>
<td>Model</td><td>License</td><td>Uni/Multi-variate</td><td>Size</td><td>Granularity</td><td>Input Length</td><td>Output Length</td><td>MAPE</td><td>MAE</td><td>HuggingFace Link</td></tr>
</thead>
<tbody>
<tr>
<td>amazon chronos bolt</td><td>Apache 2.0</td><td>Multivariate</td><td>205M</td><td>1m</td><td>512</td><td>64</td><td>0.046</td><td>0.04395</td><td><a target="_blank" href="https://huggingface.co/amazon/chronos-bolt-base">chronos-bolt-base</a></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td>1h</td><td>220</td><td>64</td><td>1.79</td><td>1.72385</td><td></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td>1d</td><td>10</td><td>3</td><td>2.697</td><td>2.6576</td><td></td></tr>
<tr>
<td>google timesfm</td><td>Apache 2.0</td><td>Univariate</td><td>500M</td><td>1m</td><td>512</td><td>64</td><td>0.108</td><td>0.09553</td><td><a target="_blank" href="https://huggingface.co/google/timesfm-2.0-500m-pytorch">timesfm-2.0-500m</a></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td>1h</td><td>128</td><td>24</td><td>0.534</td><td>0.51253</td><td></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td>1d</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr>
<tr>
<td>lag-llama</td><td>Apache 2.0</td><td>Univariate</td><td>2.45M</td><td>1m</td><td>512</td><td>64</td><td>0.537</td><td>0.47321</td><td><a target="_blank" href="https://huggingface.co/time-series-foundation-models/Lag-Llama">Lag-Llama</a></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td>1h</td><td>220</td><td>24</td><td>9.983</td><td>9.5478</td><td></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td>1d</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>ibm-ttm</td><td>Apache 2.0</td><td>Multivariate</td><td>805K</td><td>1m</td><td>512</td><td>96</td><td>1.121</td><td>1.00742</td><td><a target="_blank" href="https://huggingface.co/ibm-granite/granite-timeseries-ttm-r2">granite-timeseries-ttm-r2</a></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td>1h</td><td>180</td><td>60</td><td>2.592</td><td>2.54402</td><td></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td>1d</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>datadog toto</td><td>Apache 2.0</td><td>Multivariate</td><td>151M</td><td>1m</td><td>512</td><td>64</td><td>0.006</td><td>0.00646</td><td><a target="_blank" href="https://huggingface.co/Datadog/Toto-Open-Base-1.0">Toto-Open-Base-1.0</a></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td>1h</td><td>220</td><td>24</td><td>3.866</td><td>3.69394</td><td></td></tr>
<tr>
<td></td><td></td><td></td><td></td><td>1d</td><td>10</td><td>3</td><td>0.541</td><td>0.52186</td></tr>
</tbody>
</table>
</div><p>After running our battery of models across the complex multivariate pod-metrics scenario, a few patterns, and some honest surprises, emerged. Our analysis zoomed in not just on headline accuracy, but on where each model type shines, where it falls flat, and what it all means for anyone looking to do this in production.</p>
<h3 id="heading-results-and-observations-1">Results and Observations</h3>
<h4 id="heading-1-multivariate-pod-metrics-foundation-models-in-the-trenches">1. Multivariate Pod-Metrics: Foundation Models in the Trenches</h4>
<p>For the hard stuff, jointly forecasting CPU, memory, and latency from real production Kubernetes workloads, foundation models proved to be better.</p>
<ul>
<li><p><strong>Datadog Toto</strong> emerged as the top performer among foundation models. It often matched or outperformed classic baselines like Vector-ARIMA, especially on datasets where metric relationships were stable over time. Toto’s ability to handle multiple, correlated inputs with minimal tuning was a real advantage in high-variety, high-noise environments.</p>
</li>
<li><p><strong>Amazon Chronos</strong> and <strong>IBM TTM</strong> posted solid results as well. Chronos worked well across diverse pods, while IBM’s “Tiny Time-Mixer” was especially notable for its efficiency, delivering decent accuracy with minimal compute, making it a great fit for edge or cost-sensitive scenarios.</p>
</li>
<li><p><strong>Classic Vector-ARIMA</strong> stayed surprisingly competitive, especially for “steady-state” workloads where metric relationships didn’t shift much. In these situations, its simplicity, speed, and predictable performance kept it firmly in the running.</p>
</li>
</ul>
<h4 id="heading-2-robustness-and-real-world-behavior">2. Robustness and Real-World Behavior</h4>
<ul>
<li><p><strong>Zero-shot generalization:</strong> Even the best foundation models sometimes stumbled on data patterns far outside their training (think: sudden config changes, outages, or highly non-stationary behavior). When that happened, a freshly retrained ARIMA still sometimes pulled ahead, though at the expense of more manual work.</p>
</li>
<li><p><strong>Inference latency:</strong> Toto and Chronos required a brief “warm-up” before settling into fast predictions. By contrast, classical approaches like Vector-ARIMA and Prophet offered sub-second responses from the jump, useful for latency-critical monitoring loops.</p>
</li>
<li><p><strong>Licensing:</strong> Open-licensed models (Apache 2.0, MIT) were a no-brainer for production. Anything with a research-only or restrictive license (Moirai, etc.) was dropped from consideration.</p>
</li>
</ul>
<h4 id="heading-3-qualitative-patterns">3. Qualitative Patterns</h4>
<ul>
<li><p><strong>Handling outliers:</strong> Foundation models generally absorbed short-lived outliers better, producing less erratic forecasts when recent history got spiky. In contrast, classical models sometimes “overreacted” to recent volatility.</p>
</li>
<li><p><strong>Learning new regimes:</strong> No model, foundation or classical, nailed true first-of-its-kind events. But with a bit of fine-tuning, foundation models did recover more gracefully as new patterns emerged.</p>
</li>
<li><p><strong>Resource efficiency:</strong> IBM’s TTM (“Tiny Time-Mixer”) especially stood out for its low hardware requirements, offering a pragmatic trade-off between accuracy and footprint.</p>
</li>
</ul>
<h4 id="heading-4-when-do-foundation-models-win">4. When Do Foundation Models Win?</h4>
<ul>
<li><p>If you have a fleet of fast-changing, multivariate streams, and want to avoid constantly retraining classical models, foundation models like Toto or Chronos offer serious operational wins.</p>
</li>
<li><p>For predictable, steady-state workloads, classical models still shine for simplicity, speed, and cost.</p>
</li>
<li><p>For high-noise, high-variance environments (think retail, real-world infrastructure), foundation models generalize better, but need careful monitoring as workloads evolve.</p>
</li>
</ul>
<h2 id="heading-conclusion">Conclusion</h2>
<p>Foundation models have earned their place in the time-series forecasting toolbox. While they’re not a universal fix, their ability to deliver strong out-of-the-box performance, handle data variety, and reduce operational overhead is a genuine step forward especially for modern observability and platform engineering teams juggling countless data streams. Classical models still matter, especially for narrow, stable use cases or when resources are tight. But for teams who need flexibility, scale, and less manual tuning, foundation models are rapidly becoming the new default.</p>
<p>We’re excited to see how the landscape evolves, and even more excited to keep building alongside the community. Whether you’re a foundation model skeptic or an enthusiast, now’s the time to experiment, benchmark, and share what works and what doesn’t.</p>
<h3 id="heading-whats-next">What&#39;s Next?</h3>
<p>We&#39;re actively working on exciting roadmap features, including correlation and dynamic dashboards! 🚀</p>
<p>If you love what we&#39;re building, show us some ❤️ by <a target="_blank" href="https://github.com/parseablehq/parseable">starring our repository</a>, it keeps our team motivated to keep pushing for fast and seamless observability on S3!</p>
</div></div></div>
  </body>
</html>
