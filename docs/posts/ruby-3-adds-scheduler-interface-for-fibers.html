<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.kiprosh.com/ruby-fiber-schedular/">Original</a>
    <h1>Ruby 3 adds Scheduler Interface for Fibers</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
  <div>

    <article>

      


      <section>
        <section>
            <p>Concurrency is essential for every application to achieve higher performance within the limited set of CPU cores. In Ruby, Concurrency can be implemented in a variety of ways, including using Threads or Fibers. Ruby Fibers allow the programmer to control when to start and stop the process, providing greater flexibility and performance. To know more about Ruby Fibers, check out our previous blog <strong><a href="https://blog.kiprosh.com/ruby-fibers/">An Introduction to Ruby&#39;s &#39;Fibers&#39;</a></strong>.</p><figure><a href="https://blog.kiprosh.com/ruby-fibers/"><div><p>An Introduction to Ruby’s ‘Fibers’</p><p>What are fibers ? How can we use them for increasing the app performance in Ruby.</p><p><img src="https://blog.kiprosh.com/favicon.png" alt=""/><span>Abhinav Garg</span></p></div><p><img src="https://blog.kiprosh.com/content/images/2019/12/fibers-of-addiction-1.jpg" alt=""/></p></a></figure><p>Ruby 3 was released with the primary goal of improving performance. <a href="https://rubyapi.org/3.0/o/fiber/schedulerinterface">Fiber::SchedulerInterface</a> was added in Ruby 3 to support the concept of <em>non-blocking fiber</em>.</p><blockquote>Fiber Scheduler interface is a set of hooks for blocking operations and allows inserting a asynchronous behavior when a blocking operation occurs. </blockquote><p>With this new interface, we can split the long I/O operations into separate fiber hooks, and instead of us controlling the fiber execution, the <code>Scheduler</code> will manage the waiting and resuming of the fiber when it is ready.</p><p>To enable async behaviour in our application, we need to set the Fiber scheduler object using <code>Fiber.set_scheduler(scheduler)</code> method. Ruby does not include a default scheduler, so we can create our own or use one from the list of available schedulers <a href="https://github.com/bruno-/fiber_scheduler_list">here</a>.</p><p>In this article, we will see how using the Fiber Scheduler interface we can perform asynchronous programming in our application. In the below example I will be using Ruby 3.1 with <code>fiber_scheduler</code> gem as the scheduler.</p><p>Assume that for an action, we need to retrieve data from multiple APIs or run time-consuming DB queries. When multiple long I/O operations must be performed, they can be placed in separate non-blocking Fibers rather than blocking each other while waiting.</p><pre><code>require &#39;net/http&#39;
require &#39;fiber_scheduler&#39;

Benchmark.realtime do
  Thread.new do # in this thread, we&#39;ll have non-blocking fibers
    Fiber.set_scheduler(FiberScheduler.new)

    %w[India Germany Canada].each do |country|
      Fiber.schedule do # Runs block of code in a separate Fiber
        t = Time.now
        # Instead of blocking until the response is ready, the Fiber will invoke scheduler
        # to add itself to the list of waiting fibers and transfer control to other fibers
        Net::HTTP.get(&#39;universities.hipolabs.com&#39;, &#34;/search?country=#{country}&#34;)
        puts &#39;%s: finished in %.3f&#39; % [country, Time.now - t]
      end
    end
  end.join # At the END of the thread code, Scheduler will be called to dispatch all waiting fibers 
           # in a non-blocking manner
end

Canada: finished in 0.631
Germany: finished in 0.801
India: finished in 0.863
=&gt; 0.8634749999982887 # total time taken</code></pre><p>The code above generates three fibers, each of which makes an HTTP request. Rather than waiting for the request to be completed, the fibers transfer the control to the next fiber. As a result, the total execution time is less than the sum of the execution times of the individual fibers.</p><p>We can also use <code>FiberScheduler</code> to add nested fiber blocks and specify whether the parent should <code>wait</code>/<code>block</code> until the execution of the child is complete.</p><!--kg-card-begin: markdown--><ol>
<li><code>Waiting</code>: Sometimes we may need parent fiber to wait for the child fiber to complete.<pre><code>FiberScheduler do
  Fiber.schedule do # parent
    Fiber.schedule(:waiting) do # child
      # Our code goes here
      # for simplicity I have used sleep
      sleep 2
    end
    # The fiber stops here until the waiting child fiber completes.

    sleep 2
  end

  Fiber.schedule do
    sleep 2
  end
end

# The above example will take 4 seconds to finish.
</code></pre>
</li>
<li><code>Blocking</code>: This will prevent all other fibers from running until the current one is finished.<pre><code>FiberScheduler do
  Fiber.schedule do
    # the fiber will block all the execution until the below fiber completes.
    Fiber.schedule(:blocking) do
      sleep 2
    end
  end

  Fiber.schedule do
    sleep 2
  end
end

# The above example will take 4 seconds to finish.
</code></pre>
</li>
</ol>
<!--kg-card-end: markdown--><h2 id="final-thoughts"><strong>Final Thoughts</strong></h2><p>Adding the interface for <code>Fiber Scheduler</code>, is one of Ruby 3&#39;s most significant additions. By leveraging Ruby&#39;s built-in methods <code>set_scheduler</code> and <code>schedule {...}</code>, one may easily get the benefits of concurrency by parallelizing long-blocking operations without any overhead of managing the fibers.</p><p>Happy coding with Fiber Scheduler! ❤️</p><h2 id="references"><strong>References</strong></h2><ul><li><a href="https://rubyapi.org/3.0/o/fiber/schedulerinterface">Fiber::SchedulerInterface</a></li><li><a href="https://github.com/bruno-/fiber_scheduler">fiber_scheduler gem</a></li><li><a href="https://rubyreferences.github.io/rubychanges/3.0.html#non-blocking-fiber-and-scheduler">Non-blocking Fiber and scheduler</a></li><li><a href="https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/">Ruby 3 release notes</a></li></ul>
        </section>
        <section>
            
        </section>
      </section>

      

    </article>

  </div>
</div></div>
  </body>
</html>
