<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bun.sh/blog/compile-and-run-c-in-js">Original</a>
    <h1>Compile and Run C in JavaScript</h1>
    
    <div id="readability-page-1" class="page"><section><div><hr/><article><p>From compression to cryptography to networking to the web browser you&#39;re reading this on, the world runs on C. If it&#39;s not written in C, it speaks the C ABI (C++, Rust, Zig, etc) and is available as a C library. C and the C ABI are the past, present, and future of systems programming.</p><p><strong>That&#39;s why in Bun v1.1.28, we introduced experimental support for compiling and running native C from JavaScript</strong></p><div id="ohFyVuVNVC"><div><div><p>hello.c</p><div><div><pre><code><span><span>#include</span><span> </span><span>&lt;</span><span>stdio.h</span><span>&gt;</span></span>
<span></span>
<span><span>void</span><span> </span><span>hello</span><span>() {</span></span>
<span><span>  </span><span>printf</span><span>(</span><span>&#34;</span><span>You can now compile &amp; run C in Bun!</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div></div><div><div><p>hello.ts</p><div><div><pre><code><span><span>import</span><span> { cc } </span><span>from</span><span> </span><span>&#34;</span><span>bun:ffi</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>export</span><span> </span><span>const</span><span> {</span></span>
<span><span>  </span><span>symbols</span><span>:</span><span> { hello },</span></span>
<span><span>} </span><span>=</span><span> </span><span>cc</span><span>({</span></span>
<span><span>  source</span><span>:</span><span> </span><span>&#34;</span><span>./hello.c</span><span>&#34;</span><span>,</span></span>
<span><span>  symbols</span><span>:</span><span> {</span></span>
<span><span>    hello</span><span>:</span><span> {</span></span>
<span><span>      returns</span><span>:</span><span> </span><span>&#34;</span><span>void</span><span>&#34;</span><span>,</span></span>
<span><span>      args</span><span>:</span><span> [],</span></span>
<span><span>    },</span></span>
<span><span>  },</span></span>
<span><span>});</span></span>
<span></span>
<span><span>hello</span><span>();</span></span>
<span></span></code></pre></div></div></div></div></div><p>On Twitter, many people asked the same question:</p><p>&#34;Why would I want to compile and run C programs from JavaScript?&#34;</p><p>Previously, you had two options for using systems libraries from JavaScript:</p><ol><li>Writing a N-API (napi) addon or V8 C++ API library addon</li><li>Compiling to WASM/WASI via emscripten or wasm-pack</li></ol><h2 level="2" anchor-id="what-s-wrong-with-n-api-napi" id="what-s-wrong-with-n-api-napi"><a name="what-s-wrong-with-n-api-napi"></a><a href="#what-s-wrong-with-n-api-napi">What&#39;s wrong with N-API (napi)?</a></h2><p>N-API (napi) is a runtime agnostic C API for exposing native libraries to JavaScript. Bun and Node.js implement it. Before napi, native addons mostly used the V8 C++ API which meant potentially breaking changes each time Node.js updated V8.</p><h3 level="3" anchor-id="compiling-native-addons-breaks-ci" id="compiling-native-addons-breaks-ci"><a name="compiling-native-addons-breaks-ci"></a><a href="#compiling-native-addons-breaks-ci">Compiling native addons breaks CI</a></h3><p>Native addons usually rely on a <code>&#34;postinstall&#34;</code> script to compile N-API addons with <code>node-gyp</code>. <code>node-gyp</code> depends on Python 3 and a recent C++ compiler.</p><p>For many, needing to install Python 3 and a C++ compiler in CI to build a frontend JavaScript app is an unwelcome surprise.</p><figure><a target="_blank" href="https://github.com/oven-sh/bun/issues/9807"><img src="https://github.com/user-attachments/assets/5af47e38-aa0f-4e43-8447-34e4497ea020" href="https://github.com/oven-sh/bun/issues/9807"/></a></figure><h3 level="3" anchor-id="compiling-native-addons-is-complicated-for-maintainers" id="compiling-native-addons-is-complicated-for-maintainers"><a name="compiling-native-addons-is-complicated-for-maintainers"></a><a href="#compiling-native-addons-is-complicated-for-maintainers">Compiling native addons is complicated for maintainers</a></h3><p>To address this, some libraries prebuild their packages leveraging the <a href="https://docs.npmjs.com/cli/v10/configuring-npm/package-json/#os"><code>&#34;os&#34;</code></a> and <a href="https://docs.npmjs.com/cli/v10/configuring-npm/package-json/#cpu"><code>&#34;cpu&#34;</code></a> fields in package.json. Moving that complexity from users to maintainers is good for the ecosystem, but maintaining a build matrix of 10 different build targets is not simple.</p><div><p>@napi-rs/canvas/package.json</p><div><div><pre><code><span><span>&#34;</span><span>optionalDependencies</span><span>&#34;</span><span>: {</span></span>
<span><span>  </span><span>&#34;</span><span>@napi-rs/canvas-win32-x64-msvc</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>0.1.55</span><span>&#34;</span><span>,</span></span>
<span><span>  </span><span>&#34;</span><span>@napi-rs/canvas-darwin-x64</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>0.1.55</span><span>&#34;</span><span>,</span></span>
<span><span>  </span><span>&#34;</span><span>@napi-rs/canvas-linux-x64-gnu</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>0.1.55</span><span>&#34;</span><span>,</span></span>
<span><span>  </span><span>&#34;</span><span>@napi-rs/canvas-linux-arm-gnueabihf</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>0.1.55</span><span>&#34;</span><span>,</span></span>
<span><span>  </span><span>&#34;</span><span>@napi-rs/canvas-linux-x64-musl</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>0.1.55</span><span>&#34;</span><span>,</span></span>
<span><span>  </span><span>&#34;</span><span>@napi-rs/canvas-linux-arm64-gnu</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>0.1.55</span><span>&#34;</span><span>,</span></span>
<span><span>  </span><span>&#34;</span><span>@napi-rs/canvas-linux-arm64-musl</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>0.1.55</span><span>&#34;</span><span>,</span></span>
<span><span>  </span><span>&#34;</span><span>@napi-rs/canvas-darwin-arm64</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>0.1.55</span><span>&#34;</span><span>,</span></span>
<span><span>  </span><span>&#34;</span><span>@napi-rs/canvas-android-arm64</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>0.1.55</span><span>&#34;</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><h3 level="3" anchor-id="javascript-n-api-function-calls-3x-overhead" id="javascript-n-api-function-calls-3x-overhead"><a name="javascript-n-api-function-calls-3x-overhead"></a><a href="#javascript-n-api-function-calls-3x-overhead">JavaScript → N-API function calls: 3x overhead</a></h3><p>In exchange for more complicated builds, what do we get?</p><div><table><thead><tr><th>JavaScript → Native call overhead</th><th>Mechanism</th></tr></thead><tbody><tr><td>7ns - 15ns</td><td>N-API</td></tr><tr><td>2ns</td><td>JavaScriptCore C++ API (lower bound)</td></tr></tbody></table></div><p>Using the JavaScriptCore C++ API, a simple noop function costs 2ns per call. Using N-API, a noop function costs 7ns per call.</p><p><strong>Why are we paying a 3x performance hit for this?</strong></p><p>Unfortunately, this is an API design issue in napi. To make napi runtime-agnostic, simple operations like reading an integer from a JavaScript value involve a dynamic library function call. To make napi language-agnostic, runtime type-checking for arguments happens in every dynamic library function call. More complicated operations involve many memory allocations (or GC&#39;d object allocations) and multiple layers of pointer indirection. N-API was never designed to be fast.</p><p>JavaScript is the world&#39;s most popular programming language. Can we do better?</p><h2 level="2" anchor-id="what-about-webassembly" id="what-about-webassembly"><a name="what-about-webassembly"></a><a href="#what-about-webassembly">What about WebAssembly?</a></h2><p>To workaround the N-API build complexity and performance issues, some projects choose to compile their native addon to WebAssembly and import it in JavaScript.</p><p>Since JavaScript engines can inline function calls crossing the WebAssembly &lt;&gt; JavaScript boundary, this can work.</p><p>However, for system libraries, <strong>WebAssembly&#39;s isolated memory model comes with serious tradeoffs</strong>.</p><h4 level="4" id="isolation-means-no-system-calls">Isolation means no system calls</h4><p>WebAssembly can only access functions the runtime exposes to it. Usually, that&#39;s JavaScript.</p><p>What about libraries that depend on system APIs like the <a href="https://developer.apple.com/documentation/security/keychain-services">macOS Keychain API</a> (for securely storing/retrieving passwords) or <a href="https://learn.microsoft.com/en-us/windows/win32/directshow/audio-capture">audio recording</a>? What if your CLI wants to use the Windows Registry?</p><h4 level="4" id="isolation-means-clone-everything">Isolation means clone everything</h4><p>Modern processors support about 280 TB of addressible memory (48 bits). WebAssembly is 32-bit and can only access its own memory.</p><p>That means by default, passing strings and binary data JavaScript &lt;=&gt; WebAssembly must clone every time. For many projects, this negates any performance gain from leveraging WebAssembly.</p><hr/><p>What if N-API and WebAssembly weren&#39;t the only options for server-side JavaScript? What if we could compile and run native C from JavaScript with shared memory, and near-zero call overhead?</p><h2 level="2" anchor-id="compile-and-run-native-c-from-javascript" id="compile-and-run-native-c-from-javascript"><a name="compile-and-run-native-c-from-javascript"></a><a href="#compile-and-run-native-c-from-javascript">Compile and run native C from JavaScript</a></h2><p>Here&#39;s a quick example that compiles a random number generator in C and runs it in JavaScript.</p><div><p>myRandom.c</p><div><div><pre><code><span><span>#include</span><span> </span><span>&lt;</span><span>stdio.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>stdlib.h</span><span>&gt;</span></span>
<span></span>
<span><span>int</span><span> </span><span>myRandom</span><span>() {</span></span>
<span><span>    </span><span>return</span><span> </span><span>rand</span><span>() </span><span>+</span><span> </span><span>42</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><p>The JavaScript code that compiles and runs C:</p><div><p>main.js</p><div><div><pre><code><span><span>import</span><span> { cc } </span><span>from</span><span> </span><span>&#34;</span><span>bun:ffi</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>export</span><span> </span><span>const</span><span> {</span></span>
<span><span>  </span><span>symbols</span><span>:</span><span> { myRandom },</span></span>
<span><span>} </span><span>=</span><span> </span><span>cc</span><span>({</span></span>
<span><span>  source</span><span>:</span><span> </span><span>&#34;</span><span>./myRandom.c</span><span>&#34;</span><span>,</span></span>
<span><span>  symbols</span><span>:</span><span> {</span></span>
<span><span>    myRandom</span><span>:</span><span> {</span></span>
<span><span>      returns</span><span>:</span><span> </span><span>&#34;</span><span>int</span><span>&#34;</span><span>,</span></span>
<span><span>      args</span><span>:</span><span> [],</span></span>
<span><span>    },</span></span>
<span><span>  },</span></span>
<span><span>});</span></span>
<span></span>
<span><span>console.</span><span>log</span><span>(</span><span>&#34;</span><span>myRandom() =</span><span>&#34;</span><span>, </span><span>myRandom</span><span>());</span></span>
<span></span></code></pre></div></div></div><p>And finally, the output:</p><h3 level="3" anchor-id="how-does-this-work" id="how-does-this-work"><a name="how-does-this-work"></a><a href="#how-does-this-work">How does this work?</a></h3><p><code>bun:ffi</code> uses TinyCC to compile, link, and relocate C programs in-memory. From there, it generates inline function wrappers that convert JavaScript primitive types &lt;=&gt; C primitive types.</p><p>For example, to convert an <code>int</code> in C to JavaScriptCore&#39;s EncodedJSValue representation, the code essentially does this:</p><div><div><div><pre><code><span><span>static</span><span> </span><span>int64_t</span><span> </span><span>int32_to_js</span><span>(</span><span>int32_t</span><span> </span><span>input</span><span>) {</span></span>
<span><span>  </span><span>return</span><span> </span><span>0x</span><span>fffe000000000000</span><span>ll</span><span> </span><span>|</span><span> (</span><span>uint32_t</span><span>)input;</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div><p>Unlike N-API, these type conversions happen automatically and with zero dynamic dispatch overhead. Since these wrappers are generated at C compile time, we can safely inline type conversions without worrying about compatibility issues and without sacrificing performance.</p><h3 level="3" anchor-id="bun-ffi-compiles-quickly" id="bun-ffi-compiles-quickly"><a name="bun-ffi-compiles-quickly"></a><a href="#bun-ffi-compiles-quickly"><code>bun:ffi</code> compiles quickly</a></h3><p>If you&#39;ve used <code>clang</code> or <code>gcc</code> before, you might be thinking:</p><p><strong>clang/gcc user</strong>: &#34;great 🙄 now I have to wait 10 seconds to compile C every time I run this JS.&#34;</p><p>Let&#39;s measure how long this takes to compile with <code>bun:ffi</code>:</p><div><p>main.js</p><div><div><pre><code><span><span>import</span><span> { cc } </span><span>from</span><span> </span><span>&#34;</span><span>bun:ffi</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span> console.</span><span>time</span><span>(</span><span>&#34;</span><span>Compile ./myRandom.c</span><span>&#34;</span><span>);</span></span>
<span><span>export</span><span> </span><span>const</span><span> {</span></span>
<span><span>  </span><span>symbols</span><span>:</span><span> { myRandom },</span></span>
<span><span>} </span><span>=</span><span> </span><span>cc</span><span>({</span></span>
<span><span>  source</span><span>:</span><span> </span><span>&#34;</span><span>./myRandom.c</span><span>&#34;</span><span>,</span></span>
<span><span>  symbols</span><span>:</span><span> {</span></span>
<span><span>    myRandom</span><span>:</span><span> {</span></span>
<span><span>      returns</span><span>:</span><span> </span><span>&#34;</span><span>int</span><span>&#34;</span><span>,</span></span>
<span><span>      args</span><span>:</span><span> [],</span></span>
<span><span>    },</span></span>
<span><span>  },</span></span>
<span><span>});</span></span>
<span><span> console.</span><span>timeEnd</span><span>(</span><span>&#34;</span><span>Compile ./myRandom.c</span><span>&#34;</span><span>);</span></span></code></pre></div></div></div><p>And the output:</p><div><div><div><pre><code><span><span>[5.16ms] Compile ./myRandom.c</span></span>
<span><span>myRandom() = 43</span></span></code></pre></div></div></div><p>That&#39;s 5.16ms. Thanks to <a href="https://bellard.org/tcc/">TinyCC</a>, compiling C in Bun is fast. We wouldn&#39;t be comfortable shipping this if it took 10 seconds to compile.</p><h3 level="3" anchor-id="bun-ffi-is-low-overhead" id="bun-ffi-is-low-overhead"><a name="bun-ffi-is-low-overhead"></a><a href="#bun-ffi-is-low-overhead"><code>bun:ffi</code> is low-overhead</a></h3><p>Foreign Function Interface (FFI) has a reputation for being slow. In Bun, things are different.</p><p>Before we measure it in Bun, let&#39;s understand an upper-bound of how fast it could get. For simplicity, let&#39;s use Google&#39;s benchmark library (which requires a .cpp file):</p><div><p>bench.cpp</p><div><div><pre><code><span><span>#include</span><span> </span><span>&lt;</span><span>stdio.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>stdlib.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>benchmark/benchmark.h</span><span>&gt;</span></span>
<span></span>
<span><span>int</span><span> </span><span>myRandom</span><span>() {</span></span>
<span><span>    </span><span>return</span><span> </span><span>rand</span><span>() </span><span>+</span><span> </span><span>42</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>static</span><span> </span><span>void</span><span> </span><span>BM_MyRandom</span><span>(benchmark::State</span><span>&amp;</span><span> </span><span>state</span><span>) {</span></span>
<span><span>  </span><span>for</span><span> (auto _ : state) {</span></span>
<span><span>    </span><span>benchmark::DoNotOptimize</span><span>(</span><span>myRandom</span><span>());</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span><span>BENCHMARK</span><span>(BM_MyRandom);</span></span>
<span></span>
<span><span>BENCHMARK_MAIN</span><span>();</span></span>
<span></span></code></pre></div></div></div><p>And the output:</p><div><div><div><pre><code><span><span>clang++ ./bench.cpp -L/opt/homebrew/lib -l benchmark -O3 -I/opt/homebrew/include -o bench</span></span></code></pre></div></div><div><div><pre><code><span><span>------------------------------------------------------</span></span>
<span><span>Benchmark            Time             CPU   Iterations</span></span>
<span><span>------------------------------------------------------</span></span>
<span><span>BM_MyRandom       4.67 ns         4.66 ns    150144353</span></span></code></pre></div></div></div><p>So that&#39;s 4 nanoseconds per call in C/C++. This represents the ceiling of how fast it could possibly get.</p><p>How long does it take with <code>bun:ffi</code>?</p><div><p>bench.js</p><div><div><pre><code><span><span>import</span><span> { bench, run } </span><span>from</span><span> </span><span>&#39;</span><span>mitata</span><span>&#39;</span><span>;</span></span>
<span><span>import</span><span> { myRandom } </span><span>from</span><span> </span><span>&#39;</span><span>./main</span><span>&#39;</span><span>;</span></span>
<span></span>
<span><span>bench</span><span>(</span><span>&#39;</span><span>myRandom</span><span>&#39;</span><span>, () </span><span>=&gt;</span><span> {</span></span>
<span><span>  </span><span>myRandom</span><span>();</span></span>
<span><span>});</span></span>
<span></span>
<span><span>run</span><span>();</span></span>
<span></span></code></pre></div></div></div><p>On my machine, the result is:</p><div><div><div><pre><code><span><span>cpu: Apple M3 Max</span></span>
<span><span>runtime: bun 1.1.28 (arm64-darwin)</span></span>
<span><span></span></span>
<span><span>benchmark      time (avg)             (min … max)       p75       p99      p999</span></span>
<span><span>------------------------------------------------- -----------------------------</span></span>
<span><span>myRandom     6.26 ns/iter    (6.16 ns … 17.68 ns)   6.23 ns   7.67 ns  10.17 ns</span></span></code></pre></div></div></div><p>6 nanoseconds. So, <code>bun:ffi</code> has a per-call overhead of only 6ns - 4ns = 2ns.</p><h2 level="2" anchor-id="what-can-you-build-with-this" id="what-can-you-build-with-this"><a name="what-can-you-build-with-this"></a><a href="#what-can-you-build-with-this">What can you build with this?</a></h2><p>bun:ffi can use dynamically-linked shared libraries.</p><h4 level="4" id="convert-short-videos-with-ffmpeg-3x-faster">Convert short videos with ffmpeg 3x faster</h4><p>By avoiding the overhead of spawning a new process and allocating a lot of memory for each video, you can convert short videos 3x faster.</p><div id="gnYzKphfND"><div><div><p>ffmpeg.js</p><div><div><pre><code><span><span>import</span><span> { cc, ptr } </span><span>from</span><span> </span><span>&#34;</span><span>bun:ffi</span><span>&#34;</span><span>;</span></span>
<span><span>import</span><span> source </span><span>from</span><span> </span><span>&#34;</span><span>./mp4.c</span><span>&#34;</span><span> with {type: &#39;file&#39;};</span></span>
<span><span>import</span><span> { basename, extname, join } </span><span>from</span><span> </span><span>&#34;</span><span>path</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>console.</span><span>time</span><span>(</span><span>`Compile ./mp4.c`</span><span>);</span></span>
<span><span>const</span><span> {</span></span>
<span><span>  </span><span>symbols</span><span>:</span><span> { convert_file_to_mp4 },</span></span>
<span><span>} </span><span>=</span><span> </span><span>cc</span><span>({</span></span>
<span><span>  source,</span></span>
<span><span>  library</span><span>:</span><span> [</span><span>&#34;</span><span>c</span><span>&#34;</span><span>, </span><span>&#34;</span><span>avcodec</span><span>&#34;</span><span>, </span><span>&#34;</span><span>swscale</span><span>&#34;</span><span>, </span><span>&#34;</span><span>avformat</span><span>&#34;</span><span>],</span></span>
<span><span>  symbols</span><span>:</span><span> {</span></span>
<span><span>    convert_file_to_mp4</span><span>:</span><span> {</span></span>
<span><span>      returns</span><span>:</span><span> </span><span>&#34;</span><span>int</span><span>&#34;</span><span>,</span></span>
<span><span>      args</span><span>:</span><span> [</span><span>&#34;</span><span>cstring</span><span>&#34;</span><span>, </span><span>&#34;</span><span>cstring</span><span>&#34;</span><span>],</span></span>
<span><span>    },</span></span>
<span><span>  },</span></span>
<span><span>});</span></span>
<span><span>console.</span><span>timeEnd</span><span>(</span><span>`Compile ./mp4.c`</span><span>);</span></span>
<span><span>const</span><span> outname </span><span>=</span><span> </span><span>join</span><span>(</span></span>
<span><span>  process.</span><span>cwd</span><span>(),</span></span>
<span><span>  </span><span>basename</span><span>(process.argv.</span><span>at</span><span>(</span><span>2</span><span>), </span><span>extname</span><span>(process.argv.</span><span>at</span><span>(</span><span>2</span><span>))) </span><span>+</span><span> </span><span>&#34;</span><span>.mp4</span><span>&#34;</span></span>
<span><span>);</span></span>
<span><span>const</span><span> input </span><span>=</span><span> Buffer.</span><span>from</span><span>(process.argv.</span><span>at</span><span>(</span><span>2</span><span>) </span><span>+</span><span> </span><span>&#34;</span><span>\0</span><span>&#34;</span><span>);</span></span>
<span><span>const</span><span> output </span><span>=</span><span> Buffer.</span><span>from</span><span>(outname </span><span>+</span><span> </span><span>&#34;</span><span>\0</span><span>&#34;</span><span>);</span></span>
<span><span>for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&lt;</span><span> </span><span>10</span><span>; i</span><span>++</span><span>) {</span></span>
<span><span>  console.</span><span>time</span><span>(</span><span>`Convert </span><span>${</span><span>process.argv.</span><span>at</span><span>(</span><span>2</span><span>)</span><span>}</span><span> to </span><span>${</span><span>outname</span><span>}</span><span>`</span><span>);</span></span>
<span><span>  </span><span>const</span><span> result </span><span>=</span><span> </span><span>convert_file_to_mp4</span><span>(</span><span>ptr</span><span>(input), </span><span>ptr</span><span>(output));</span></span>
<span><span>  </span><span>if</span><span> (result </span><span>==</span><span> </span><span>0</span><span>) {</span></span>
<span><span>    console.</span><span>timeEnd</span><span>(</span><span>`Convert </span><span>${</span><span>process.argv.</span><span>at</span><span>(</span><span>2</span><span>)</span><span>}</span><span> to </span><span>${</span><span>outname</span><span>}</span><span>`</span><span>);</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span></span></code></pre></div></div></div></div><div><div><p>mp4.c</p><div><div><pre><code><span><span>#include</span><span> </span><span>&lt;</span><span>dlfcn.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>libavcodec/avcodec.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>libavformat/avformat.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>libavutil/avutil.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>libavutil/imgutils.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>libavutil/opt.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>libswscale/swscale.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>stdio.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>stdlib.h</span><span>&gt;</span></span>
<span></span>
<span><span>int</span><span> </span><span>to_mp4</span><span>(</span><span>void</span><span> </span><span>*</span><span>buf</span><span>, </span><span>size_t</span><span> </span><span>buflen</span><span>, </span><span>void</span><span> </span><span>**</span><span>out</span><span>, </span><span>size_t</span><span> </span><span>*</span><span>outlen</span><span>) {</span></span>
<span><span>  AVFormatContext </span><span>*</span><span>input_ctx </span><span>=</span><span> </span><span>NULL</span><span>, </span><span>*</span><span>output_ctx </span><span>=</span><span> </span><span>NULL</span><span>;</span></span>
<span><span>  AVIOContext </span><span>*</span><span>input_io_ctx </span><span>=</span><span> </span><span>NULL</span><span>, </span><span>*</span><span>output_io_ctx </span><span>=</span><span> </span><span>NULL</span><span>;</span></span>
<span><span>  </span><span>uint8_t</span><span> </span><span>*</span><span>output_buffer </span><span>=</span><span> </span><span>NULL</span><span>;</span></span>
<span><span>  </span><span>int</span><span> ret </span><span>=</span><span> </span><span>0</span><span>;</span></span>
<span><span>  </span><span>int64_t</span><span> </span><span>*</span><span>last_dts </span><span>=</span><span> </span><span>NULL</span><span>;</span></span>
<span></span>
<span><span>  </span><span>// Register all codecs and formats</span></span>
<span></span>
<span><span>  </span><span>// Create input IO context</span></span>
<span><span>  input_io_ctx </span><span>=</span><span> </span><span>avio_alloc_context</span><span>(buf, buflen, </span><span>0</span><span>, </span><span>NULL</span><span>, </span><span>NULL</span><span>, </span><span>NULL</span><span>, </span><span>NULL</span><span>);</span></span>
<span><span>  </span><span>if</span><span> (</span><span>!</span><span>input_io_ctx) {</span></span>
<span><span>    ret </span><span>=</span><span> </span><span>AVERROR</span><span>(ENOMEM);</span></span>
<span><span>    </span><span>goto</span><span> end;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Allocate input format context</span></span>
<span><span>  input_ctx </span><span>=</span><span> </span><span>avformat_alloc_context</span><span>();</span></span>
<span><span>  </span><span>if</span><span> (</span><span>!</span><span>input_ctx) {</span></span>
<span><span>    ret </span><span>=</span><span> </span><span>AVERROR</span><span>(ENOMEM);</span></span>
<span><span>    </span><span>goto</span><span> end;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  input_ctx</span><span>-&gt;</span><span>pb </span><span>=</span><span> input_io_ctx;</span></span>
<span></span>
<span><span>  </span><span>// Open input</span></span>
<span><span>  </span><span>if</span><span> ((ret </span><span>=</span><span> </span><span>avformat_open_input</span><span>(</span><span>&amp;</span><span>input_ctx, </span><span>NULL</span><span>, </span><span>NULL</span><span>, </span><span>NULL</span><span>)) </span><span>&lt;</span><span> </span><span>0</span><span>) {</span></span>
<span><span>    </span><span>goto</span><span> end;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Retrieve stream information</span></span>
<span><span>  </span><span>if</span><span> ((ret </span><span>=</span><span> </span><span>avformat_find_stream_info</span><span>(input_ctx, </span><span>NULL</span><span>)) </span><span>&lt;</span><span> </span><span>0</span><span>) {</span></span>
<span><span>    </span><span>goto</span><span> end;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Allocate output format context</span></span>
<span><span>  </span><span>avformat_alloc_output_context2</span><span>(</span><span>&amp;</span><span>output_ctx, </span><span>NULL</span><span>, </span><span>&#34;</span><span>mp4</span><span>&#34;</span><span>, </span><span>NULL</span><span>);</span></span>
<span><span>  </span><span>if</span><span> (</span><span>!</span><span>output_ctx) {</span></span>
<span><span>    ret </span><span>=</span><span> </span><span>AVERROR</span><span>(ENOMEM);</span></span>
<span><span>    </span><span>goto</span><span> end;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Create output IO context</span></span>
<span><span>  ret </span><span>=</span><span> </span><span>avio_open_dyn_buf</span><span>(</span><span>&amp;</span><span>output_ctx</span><span>-&gt;</span><span>pb);</span></span>
<span><span>  </span><span>if</span><span> (ret </span><span>&lt;</span><span> </span><span>0</span><span>) {</span></span>
<span><span>    </span><span>goto</span><span> end;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Copy streams</span></span>
<span><span>  </span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&lt;</span><span> input_ctx</span><span>-&gt;</span><span>nb_streams; i</span><span>++</span><span>) {</span></span>
<span><span>    AVStream </span><span>*</span><span>in_stream </span><span>=</span><span> input_ctx</span><span>-&gt;</span><span>streams[i];</span></span>
<span><span>    AVStream </span><span>*</span><span>out_stream </span><span>=</span><span> </span><span>avformat_new_stream</span><span>(output_ctx, </span><span>NULL</span><span>);</span></span>
<span><span>    </span><span>if</span><span> (</span><span>!</span><span>out_stream) {</span></span>
<span><span>      ret </span><span>=</span><span> </span><span>AVERROR</span><span>(ENOMEM);</span></span>
<span><span>      </span><span>goto</span><span> end;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    ret </span><span>=</span><span> </span><span>avcodec_parameters_copy</span><span>(out_stream</span><span>-&gt;</span><span>codecpar, in_stream</span><span>-&gt;</span><span>codecpar);</span></span>
<span><span>    </span><span>if</span><span> (ret </span><span>&lt;</span><span> </span><span>0</span><span>) {</span></span>
<span><span>      </span><span>goto</span><span> end;</span></span>
<span><span>    }</span></span>
<span><span>    out_stream</span><span>-&gt;</span><span>codecpar</span><span>-&gt;</span><span>codec_tag </span><span>=</span><span> </span><span>0</span><span>;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Write header</span></span>
<span><span>  ret </span><span>=</span><span> </span><span>avformat_write_header</span><span>(output_ctx, </span><span>NULL</span><span>);</span></span>
<span><span>  </span><span>if</span><span> (ret </span><span>&lt;</span><span> </span><span>0</span><span>) {</span></span>
<span><span>    </span><span>goto</span><span> end;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Allocate last_dts array</span></span>
<span><span>  last_dts </span><span>=</span><span> </span><span>calloc</span><span>(input_ctx</span><span>-&gt;</span><span>nb_streams, </span><span>sizeof</span><span>(</span><span>int64_t</span><span>));</span></span>
<span><span>  </span><span>if</span><span> (</span><span>!</span><span>last_dts) {</span></span>
<span><span>    ret </span><span>=</span><span> </span><span>AVERROR</span><span>(ENOMEM);</span></span>
<span><span>    </span><span>goto</span><span> end;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Copy packets</span></span>
<span><span>  AVPacket pkt;</span></span>
<span><span>  </span><span>while</span><span> (</span><span>1</span><span>) {</span></span>
<span><span>    ret </span><span>=</span><span> </span><span>av_read_frame</span><span>(input_ctx, </span><span>&amp;</span><span>pkt);</span></span>
<span><span>    </span><span>if</span><span> (ret </span><span>&lt;</span><span> </span><span>0</span><span>) {</span></span>
<span><span>      </span><span>break</span><span>;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    AVStream </span><span>*</span><span>in_stream </span><span>=</span><span> input_ctx</span><span>-&gt;</span><span>streams[pkt.stream_index];</span></span>
<span><span>    AVStream </span><span>*</span><span>out_stream </span><span>=</span><span> output_ctx</span><span>-&gt;</span><span>streams[pkt.stream_index];</span></span>
<span></span>
<span><span>    </span><span>// Convert timestamps</span></span>
<span><span>    pkt.pts </span><span>=</span></span>
<span><span>        </span><span>av_rescale_q_rnd</span><span>(pkt.pts, in_stream</span><span>-&gt;</span><span>time_base, out_stream</span><span>-&gt;</span><span>time_base,</span></span>
<span><span>                         AV_ROUND_NEAR_INF </span><span>|</span><span> AV_ROUND_PASS_MINMAX);</span></span>
<span><span>    pkt.dts </span><span>=</span></span>
<span><span>        </span><span>av_rescale_q_rnd</span><span>(pkt.dts, in_stream</span><span>-&gt;</span><span>time_base, out_stream</span><span>-&gt;</span><span>time_base,</span></span>
<span><span>                         AV_ROUND_NEAR_INF </span><span>|</span><span> AV_ROUND_PASS_MINMAX);</span></span>
<span><span>    pkt.duration </span><span>=</span></span>
<span><span>        </span><span>av_rescale_q</span><span>(pkt.duration, in_stream</span><span>-&gt;</span><span>time_base, out_stream</span><span>-&gt;</span><span>time_base);</span></span>
<span></span>
<span><span>    </span><span>// Ensure monotonically increasing DTS</span></span>
<span><span>    </span><span>if</span><span> (pkt.dts </span><span>&lt;=</span><span> last_dts[pkt.stream_index]) {</span></span>
<span><span>      pkt.dts </span><span>=</span><span> last_dts[pkt.stream_index] </span><span>+</span><span> </span><span>1</span><span>;</span></span>
<span><span>      pkt.pts </span><span>=</span><span> </span><span>FFMAX</span><span>(pkt.pts, pkt.dts);</span></span>
<span><span>    }</span></span>
<span><span>    last_dts[pkt.stream_index] </span><span>=</span><span> pkt.dts;</span></span>
<span></span>
<span><span>    pkt.pos </span><span>=</span><span> </span><span>-</span><span>1</span><span>;</span></span>
<span></span>
<span><span>    ret </span><span>=</span><span> </span><span>av_interleaved_write_frame</span><span>(output_ctx, </span><span>&amp;</span><span>pkt);</span></span>
<span><span>    </span><span>if</span><span> (ret </span><span>&lt;</span><span> </span><span>0</span><span>) {</span></span>
<span><span>      </span><span>char</span><span> errbuf[AV_ERROR_MAX_STRING_SIZE];</span></span>
<span><span>      </span><span>av_strerror</span><span>(ret, errbuf, AV_ERROR_MAX_STRING_SIZE);</span></span>
<span><span>      </span><span>fprintf</span><span>(stderr, </span><span>&#34;</span><span>Error writing frame: </span><span>%s</span><span>\n</span><span>&#34;</span><span>, errbuf);</span></span>
<span><span>      </span><span>break</span><span>;</span></span>
<span><span>    }</span></span>
<span><span>    </span><span>av_packet_unref</span><span>(</span><span>&amp;</span><span>pkt);</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Write trailer</span></span>
<span><span>  ret </span><span>=</span><span> </span><span>av_write_trailer</span><span>(output_ctx);</span></span>
<span><span>  </span><span>if</span><span> (ret </span><span>&lt;</span><span> </span><span>0</span><span>) {</span></span>
<span><span>    </span><span>goto</span><span> end;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Get the output buffer</span></span>
<span><span>  </span><span>*</span><span>outlen </span><span>=</span><span> </span><span>avio_close_dyn_buf</span><span>(output_ctx</span><span>-&gt;</span><span>pb, </span><span>&amp;</span><span>output_buffer);</span></span>
<span><span>  </span><span>*</span><span>out </span><span>=</span><span> output_buffer;</span></span>
<span><span>  output_ctx</span><span>-&gt;</span><span>pb </span><span>=</span><span> </span><span>NULL</span><span>; </span><span>// Set to NULL to prevent double free</span></span>
<span></span>
<span><span>  ret </span><span>=</span><span> </span><span>0</span><span>; </span><span>// Success</span></span>
<span></span>
<span><span>end:</span></span>
<span><span>  </span><span>if</span><span> (input_ctx) {</span></span>
<span><span>    </span><span>avformat_close_input</span><span>(</span><span>&amp;</span><span>input_ctx);</span></span>
<span><span>  }</span></span>
<span><span>  </span><span>if</span><span> (output_ctx) {</span></span>
<span><span>    </span><span>avformat_free_context</span><span>(output_ctx);</span></span>
<span><span>  }</span></span>
<span><span>  </span><span>if</span><span> (input_io_ctx) {</span></span>
<span><span>    </span><span>av_freep</span><span>(</span><span>&amp;</span><span>input_io_ctx</span><span>-&gt;</span><span>buffer);</span></span>
<span><span>    </span><span>av_freep</span><span>(</span><span>&amp;</span><span>input_io_ctx);</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>return</span><span> ret;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>int</span><span> </span><span>convert_file_to_mp4</span><span>(</span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>input_filename</span><span>,</span></span>
<span><span>                        </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>output_filename</span><span>) {</span></span>
<span><span>  FILE </span><span>*</span><span>input_file </span><span>=</span><span> </span><span>NULL</span><span>;</span></span>
<span><span>  FILE </span><span>*</span><span>output_file </span><span>=</span><span> </span><span>NULL</span><span>;</span></span>
<span><span>  </span><span>uint8_t</span><span> </span><span>*</span><span>input_buffer </span><span>=</span><span> </span><span>NULL</span><span>;</span></span>
<span><span>  </span><span>uint8_t</span><span> </span><span>*</span><span>output_buffer </span><span>=</span><span> </span><span>NULL</span><span>;</span></span>
<span><span>  </span><span>size_t</span><span> input_size </span><span>=</span><span> </span><span>0</span><span>;</span></span>
<span><span>  </span><span>size_t</span><span> output_size </span><span>=</span><span> </span><span>0</span><span>;</span></span>
<span><span>  </span><span>int</span><span> ret </span><span>=</span><span> </span><span>0</span><span>;</span></span>
<span></span>
<span><span>  </span><span>// Open the input file</span></span>
<span><span>  input_file </span><span>=</span><span> </span><span>fopen</span><span>(input_filename, </span><span>&#34;</span><span>rb</span><span>&#34;</span><span>);</span></span>
<span><span>  </span><span>if</span><span> (</span><span>!</span><span>input_file) {</span></span>
<span><span>    </span><span>perror</span><span>(</span><span>&#34;</span><span>Could not open input file</span><span>&#34;</span><span>);</span></span>
<span><span>    </span><span>return</span><span> </span><span>-</span><span>1</span><span>;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Get the size of the input file</span></span>
<span><span>  </span><span>fseek</span><span>(input_file, </span><span>0</span><span>, SEEK_END);</span></span>
<span><span>  input_size </span><span>=</span><span> </span><span>ftell</span><span>(input_file);</span></span>
<span><span>  </span><span>fseek</span><span>(input_file, </span><span>0</span><span>, SEEK_SET);</span></span>
<span></span>
<span><span>  </span><span>// Allocate memory for the input buffer</span></span>
<span><span>  input_buffer </span><span>=</span><span> (</span><span>uint8_t</span><span> </span><span>*</span><span>)</span><span>malloc</span><span>(input_size);</span></span>
<span><span>  </span><span>if</span><span> (</span><span>!</span><span>input_buffer) {</span></span>
<span><span>    </span><span>perror</span><span>(</span><span>&#34;</span><span>Could not allocate input buffer</span><span>&#34;</span><span>);</span></span>
<span><span>    ret </span><span>=</span><span> </span><span>-</span><span>1</span><span>;</span></span>
<span><span>    </span><span>goto</span><span> cleanup;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Read the input file into the buffer</span></span>
<span><span>  </span><span>if</span><span> (</span><span>fread</span><span>(input_buffer, </span><span>1</span><span>, input_size, input_file) </span><span>!=</span><span> input_size) {</span></span>
<span><span>    </span><span>perror</span><span>(</span><span>&#34;</span><span>Could not read input file</span><span>&#34;</span><span>);</span></span>
<span><span>    ret </span><span>=</span><span> </span><span>-</span><span>1</span><span>;</span></span>
<span><span>    </span><span>goto</span><span> cleanup;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Call the to_mp4 function to convert the buffer</span></span>
<span><span>  ret </span><span>=</span><span> </span><span>to_mp4</span><span>(input_buffer, input_size, (</span><span>void</span><span> </span><span>**</span><span>)</span><span>&amp;</span><span>output_buffer, </span><span>&amp;</span><span>output_size);</span></span>
<span><span>  </span><span>if</span><span> (ret </span><span>&lt;</span><span> </span><span>0</span><span>) {</span></span>
<span><span>    </span><span>fprintf</span><span>(stderr, </span><span>&#34;</span><span>Error converting to MP4</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span><span>    </span><span>goto</span><span> cleanup;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Open the output file</span></span>
<span><span>  output_file </span><span>=</span><span> </span><span>fopen</span><span>(output_filename, </span><span>&#34;</span><span>wb</span><span>&#34;</span><span>);</span></span>
<span><span>  </span><span>if</span><span> (</span><span>!</span><span>output_file) {</span></span>
<span><span>    </span><span>perror</span><span>(</span><span>&#34;</span><span>Could not open output file</span><span>&#34;</span><span>);</span></span>
<span><span>    ret </span><span>=</span><span> </span><span>-</span><span>1</span><span>;</span></span>
<span><span>    </span><span>goto</span><span> cleanup;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>// Write the output buffer to the file</span></span>
<span><span>  </span><span>if</span><span> (</span><span>fwrite</span><span>(output_buffer, </span><span>1</span><span>, output_size, output_file) </span><span>!=</span><span> output_size) {</span></span>
<span><span>    </span><span>perror</span><span>(</span><span>&#34;</span><span>Could not write output file</span><span>&#34;</span><span>);</span></span>
<span><span>    ret </span><span>=</span><span> </span><span>-</span><span>1</span><span>;</span></span>
<span><span>    </span><span>goto</span><span> cleanup;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>cleanup:</span></span>
<span></span>
<span><span>  </span><span>if</span><span> (output_buffer) {</span></span>
<span><span>    </span><span>av_free</span><span>(output_buffer);</span></span>
<span><span>  }</span></span>
<span><span>  </span><span>if</span><span> (input_file) {</span></span>
<span><span>    </span><span>fclose</span><span>(input_file);</span></span>
<span><span>  }</span></span>
<span><span>  </span><span>if</span><span> (output_file) {</span></span>
<span><span>    </span><span>fclose</span><span>(output_file);</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>return</span><span> ret;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// for running it standalone</span></span>
<span><span>int</span><span> </span><span>main</span><span>(</span><span>const</span><span> </span><span>int</span><span> </span><span>argc</span><span>, </span><span>const</span><span> </span><span>char</span><span> </span><span>**</span><span>argv</span><span>) {</span></span>
<span></span>
<span><span>  </span><span>if</span><span> (argc </span><span>!=</span><span> </span><span>3</span><span>) {</span></span>
<span><span>    </span><span>printf</span><span>(</span><span>&#34;</span><span>Usage: </span><span>%s</span><span> &lt;input_file&gt; &lt;output_file&gt;</span><span>\n</span><span>&#34;</span><span>, argv[</span><span>0</span><span>]);</span></span>
<span><span>    </span><span>return</span><span> </span><span>-</span><span>1</span><span>;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>input_filename </span><span>=</span><span> argv[</span><span>1</span><span>];</span></span>
<span><span>  </span><span>const</span><span> </span><span>char</span><span> </span><span>*</span><span>output_filename </span><span>=</span><span> argv[</span><span>2</span><span>];</span></span>
<span></span>
<span><span>  </span><span>int</span><span> result </span><span>=</span><span> </span><span>convert_file_to_mp4</span><span>(input_filename, output_filename);</span></span>
<span><span>  </span><span>if</span><span> (result </span><span>==</span><span> </span><span>0</span><span>) {</span></span>
<span><span>    </span><span>printf</span><span>(</span><span>&#34;</span><span>Conversion successful!</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span><span>  } </span><span>else</span><span> {</span></span>
<span><span>    </span><span>printf</span><span>(</span><span>&#34;</span><span>Conversion failed!</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span><span>  }</span></span>
<span><span>  </span><span>return</span><span> result;</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div></div></div><h4 level="4" id="securely-save-load-passwords-with-the-macos-keychain-api">Securely save &amp; load passwords with the macOS Keychain API</h4><p>macOS has a builtin Keychain API for securely storing &amp; retrieving passwords, but this isn&#39;t exposed to JavaScript. Instead of figuring out how to wrap this with N-API, getting CMake configured with node-gyp, what if you could just write a few lines of C in your JS project and be done with it?</p><div id="aALpVSBTjA"><div><div><p>keychain.js</p><div><div><pre><code><span><span>import</span><span> { cc, ptr, CString } </span><span>from</span><span> </span><span>&#34;</span><span>bun:ffi</span><span>&#34;</span><span>;</span></span>
<span><span>const</span><span> {</span></span>
<span><span>  </span><span>symbols</span><span>:</span><span> { setPassword, getPassword, deletePassword },</span></span>
<span><span>} </span><span>=</span><span> </span><span>cc</span><span>({</span></span>
<span><span>  source</span><span>:</span><span> </span><span>&#34;</span><span>./keychain.c</span><span>&#34;</span><span>,</span></span>
<span><span>  flags</span><span>:</span><span> [</span></span>
<span><span>    </span><span>&#34;</span><span>-framework</span><span>&#34;</span><span>,</span></span>
<span><span>    </span><span>&#34;</span><span>Security</span><span>&#34;</span><span>,</span></span>
<span><span>    </span><span>&#34;</span><span>-framework</span><span>&#34;</span><span>,</span></span>
<span><span>    </span><span>&#34;</span><span>CoreFoundation</span><span>&#34;</span><span>,</span></span>
<span><span>    </span><span>&#34;</span><span>-framework</span><span>&#34;</span><span>,</span></span>
<span><span>    </span><span>&#34;</span><span>Foundation</span><span>&#34;</span><span>,</span></span>
<span><span>  ],</span></span>
<span><span>  symbols</span><span>:</span><span> {</span></span>
<span><span>    setPassword</span><span>:</span><span> {</span></span>
<span><span>      args</span><span>:</span><span> [</span><span>&#34;</span><span>cstring</span><span>&#34;</span><span>, </span><span>&#34;</span><span>cstring</span><span>&#34;</span><span>, </span><span>&#34;</span><span>cstring</span><span>&#34;</span><span>],</span></span>
<span><span>      returns</span><span>:</span><span> </span><span>&#34;</span><span>i32</span><span>&#34;</span><span>,</span></span>
<span><span>    },</span></span>
<span><span>    getPassword</span><span>:</span><span> {</span></span>
<span><span>      args</span><span>:</span><span> [</span><span>&#34;</span><span>cstring</span><span>&#34;</span><span>, </span><span>&#34;</span><span>cstring</span><span>&#34;</span><span>, </span><span>&#34;</span><span>ptr</span><span>&#34;</span><span>, </span><span>&#34;</span><span>ptr</span><span>&#34;</span><span>],</span></span>
<span><span>      returns</span><span>:</span><span> </span><span>&#34;</span><span>i32</span><span>&#34;</span><span>,</span></span>
<span><span>    },</span></span>
<span><span>    deletePassword</span><span>:</span><span> {</span></span>
<span><span>      args</span><span>:</span><span> [</span><span>&#34;</span><span>cstring</span><span>&#34;</span><span>, </span><span>&#34;</span><span>cstring</span><span>&#34;</span><span>],</span></span>
<span><span>      returns</span><span>:</span><span> </span><span>&#34;</span><span>i32</span><span>&#34;</span><span>,</span></span>
<span><span>    },</span></span>
<span><span>  },</span></span>
<span><span>});</span></span>
<span></span>
<span><span>var</span><span> service </span><span>=</span><span> Buffer.</span><span>from</span><span>(</span><span>&#34;</span><span>com.bun.test.keychain</span><span>\0</span><span>&#34;</span><span>);</span></span>
<span></span>
<span><span>var</span><span> account </span><span>=</span><span> Buffer.</span><span>from</span><span>(</span><span>&#34;</span><span>bun</span><span>\0</span><span>&#34;</span><span>);</span></span>
<span><span>var</span><span> password </span><span>=</span><span> Buffer.</span><span>alloc</span><span>(</span><span>1024</span><span>);</span></span>
<span><span>password.</span><span>write</span><span>(</span><span>&#34;</span><span>password</span><span>\0</span><span>&#34;</span><span>);</span></span>
<span><span>var</span><span> passwordPtr </span><span>=</span><span> </span><span>new</span><span> </span><span>BigUint64Array</span><span>(</span><span>1</span><span>);</span></span>
<span><span>passwordPtr[</span><span>0</span><span>] </span><span>=</span><span> </span><span>BigInt</span><span>(</span><span>ptr</span><span>(password));</span></span>
<span><span>var</span><span> passwordLength </span><span>=</span><span> </span><span>new</span><span> </span><span>Uint32Array</span><span>(</span><span>1</span><span>);</span></span>
<span></span>
<span><span>setPassword</span><span>(</span><span>ptr</span><span>(service), </span><span>ptr</span><span>(account), </span><span>ptr</span><span>(password));</span></span>
<span></span>
<span><span>passwordLength[</span><span>0</span><span>] </span><span>=</span><span> </span><span>1024</span><span>;</span></span>
<span><span>password.</span><span>fill</span><span>(</span><span>0</span><span>);</span></span>
<span><span>getPassword</span><span>(</span><span>ptr</span><span>(service), </span><span>ptr</span><span>(account), </span><span>ptr</span><span>(passwordPtr), </span><span>ptr</span><span>(passwordLength));</span></span>
<span><span>const</span><span> result </span><span>=</span><span> </span><span>new</span><span> </span><span>CString</span><span>(</span></span>
<span><span>  </span><span>Number</span><span>(passwordPtr[</span><span>0</span><span>]),</span></span>
<span><span>  </span><span>0</span><span>,</span></span>
<span><span>  passwordLength[</span><span>0</span><span>]</span></span>
<span><span>);</span></span>
<span><span>console.</span><span>log</span><span>(result);</span></span>
<span></span></code></pre></div></div></div></div><div><div><p>keychain.c</p><div><div><pre><code><span><span>#include</span><span> </span><span>&lt;</span><span>Security/Security.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>stdio.h</span><span>&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;</span><span>string.h</span><span>&gt;</span></span>
<span></span>
<span><span>// Function to set a password in the keychain</span></span>
<span><span>OSStatus</span><span> </span><span>setPassword</span><span>(</span><span>const</span><span> </span><span>char*</span><span> </span><span>service</span><span>, </span><span>const</span><span> </span><span>char*</span><span> </span><span>account</span><span>, </span><span>const</span><span> </span><span>char*</span><span> </span><span>password</span><span>) {</span></span>
<span><span>    SecKeychainItemRef item </span><span>=</span><span> </span><span>NULL</span><span>;</span></span>
<span><span>    </span><span>OSStatus</span><span> status </span><span>=</span><span> </span><span>SecKeychainFindGenericPassword</span><span>(</span></span>
<span><span>        </span><span>NULL</span><span>,</span></span>
<span><span>        </span><span>strlen</span><span>(service), service,</span></span>
<span><span>        </span><span>strlen</span><span>(account), account,</span></span>
<span><span>        </span><span>NULL</span><span>, </span><span>NULL</span><span>,</span></span>
<span><span>        </span><span>&amp;</span><span>item</span></span>
<span><span>    );</span></span>
<span></span>
<span><span>    </span><span>if</span><span> (status </span><span>==</span><span> errSecSuccess) {</span></span>
<span><span>        </span><span>// Update existing item</span></span>
<span><span>        status </span><span>=</span><span> </span><span>SecKeychainItemModifyAttributesAndData</span><span>(</span></span>
<span><span>            item,</span></span>
<span><span>            </span><span>NULL</span><span>,</span></span>
<span><span>            </span><span>strlen</span><span>(password),</span></span>
<span><span>            password</span></span>
<span><span>        );</span></span>
<span><span>        </span><span>CFRelease</span><span>(item);</span></span>
<span><span>    } </span><span>else</span><span> </span><span>if</span><span> (status </span><span>==</span><span> errSecItemNotFound) {</span></span>
<span><span>        </span><span>// Add new item</span></span>
<span><span>        status </span><span>=</span><span> </span><span>SecKeychainAddGenericPassword</span><span>(</span></span>
<span><span>            </span><span>NULL</span><span>,</span></span>
<span><span>            </span><span>strlen</span><span>(service), service,</span></span>
<span><span>            </span><span>strlen</span><span>(account), account,</span></span>
<span><span>            </span><span>strlen</span><span>(password), password,</span></span>
<span><span>            </span><span>NULL</span></span>
<span><span>        );</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>return</span><span> status;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// Function to get a password from the keychain</span></span>
<span><span>OSStatus</span><span> </span><span>getPassword</span><span>(</span><span>const</span><span> </span><span>char*</span><span> </span><span>service</span><span>, </span><span>const</span><span> </span><span>char*</span><span> </span><span>account</span><span>, </span><span>char**</span><span> </span><span>password</span><span>, </span><span>UInt32</span><span>*</span><span> </span><span>passwordLength</span><span>) {</span></span>
<span><span>    </span><span>return</span><span> </span><span>SecKeychainFindGenericPassword</span><span>(</span></span>
<span><span>        </span><span>NULL</span><span>,</span></span>
<span><span>        </span><span>strlen</span><span>(service), service,</span></span>
<span><span>        </span><span>strlen</span><span>(account), account,</span></span>
<span><span>        passwordLength, (</span><span>void**</span><span>)password,</span></span>
<span><span>        </span><span>NULL</span></span>
<span><span>    );</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// Function to delete a password from the keychain</span></span>
<span><span>OSStatus</span><span> </span><span>deletePassword</span><span>(</span><span>const</span><span> </span><span>char*</span><span> </span><span>service</span><span>, </span><span>const</span><span> </span><span>char*</span><span> </span><span>account</span><span>) {</span></span>
<span><span>    SecKeychainItemRef item </span><span>=</span><span> </span><span>NULL</span><span>;</span></span>
<span><span>    </span><span>OSStatus</span><span> status </span><span>=</span><span> </span><span>SecKeychainFindGenericPassword</span><span>(</span></span>
<span><span>        </span><span>NULL</span><span>,</span></span>
<span><span>        </span><span>strlen</span><span>(service), service,</span></span>
<span><span>        </span><span>strlen</span><span>(account), account,</span></span>
<span><span>        </span><span>NULL</span><span>, </span><span>NULL</span><span>,</span></span>
<span><span>        </span><span>&amp;</span><span>item</span></span>
<span><span>    );</span></span>
<span></span>
<span><span>    </span><span>if</span><span> (status </span><span>==</span><span> errSecSuccess) {</span></span>
<span><span>        status </span><span>=</span><span> </span><span>SecKeychainItemDelete</span><span>(item);</span></span>
<span><span>        </span><span>CFRelease</span><span>(item);</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>return</span><span> status;</span></span>
<span><span>}</span></span>
<span></span></code></pre></div></div></div></div></div><h2 level="2" anchor-id="what-is-this-good-for" id="what-is-this-good-for"><a name="what-is-this-good-for"></a><a href="#what-is-this-good-for">What is this good for?</a></h2><p>This is a low-boilerplate way to use C libraries and system libraries from JavaScript. The same project that runs the JavaScript can also run the C without a separate build step.</p><p>It&#39;s good for glue code that binds C or C-like libraries to JavaScript. Sometimes, you want to use a C library or system API from JavaScript, and that library was never meant to be used from JavaScript.</p><p>Writing some C to wrap that sort of code into a JavaScript-friendly API is usually the easiest way to go because:</p><ul><li>The examples are in C, not in JavaScript through FFI.</li><li>Using FFI means you have to mentally translate between JavaScript and C. It&#39;s easier to use pointers in C than to use pointers in FFI through typed arrays in JavaScript. So, why not make it easier on yourself?</li></ul><h4 level="4" id="what-is-this-not-for">What is this not for?</h4><p>Every tool has tradeoffs.</p><ul><li>You probably don&#39;t want to use this to compile large C projects like PostgresSQL or SQLite. TinyCC compiles to decently performant C, but it won&#39;t do advanced optimizations that Clang or GCC does like autovectorization or very specialized CPU instructions.</li><li>You probably won&#39;t get much of a performance gain from micro-optimizing small parts of your codebase through C, but happy to be proven wrong!</li></ul></article></div></section>
</div>
  </body>
</html>
