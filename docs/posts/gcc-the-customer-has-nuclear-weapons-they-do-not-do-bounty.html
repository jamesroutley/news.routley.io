<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c4">Original</a>
    <h1>GCC: The customer has nuclear weapons. They do not do “bounty”</h1>
    
    <div id="readability-page-1" class="page"><div id="comments">




<!-- This auto-sizes the comments and positions the collapse/expand links 
     to the right. -->
<table>
<tbody><tr>
<td>
<div id="c0">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c0">Description</a>
        </span>

        <span>
          <span><span>Bill Long</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-06-11 16:55:45 UTC
        </span>

      </p>




<pre><span>&gt; cat test2.f90</span>

program test

  use, intrinsic :: ieee_arithmetic, only : ieee_fma

  implicit none

end program test


Intel:

<span>&gt; ifort test2.f90</span>

Cray:

<span>&gt; module swap PrgEnv-intel PrgEnv-cray
&gt; ftn test2.f90
&gt; ./a.out</span>

gfortran:

<span>&gt; module swap PrgEnv-cray PrgEnv-gnu
&gt; gfortran test2.f90</span>
test2.f90:2:43:

2 | use, intrinsic :: ieee_arithmetic, only : ieee_fma
1
Error: Symbol &#39;ieee_fma&#39; referenced at (1) not found in module &#39;ieee_arithmetic&#39;
&gt;</pre>
    </div>

    <div id="c1">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c1">Comment 1</a>
        </span>

        <span>
          <span><span>Dominique d&#39;Humieres</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-06-11 17:50:38 UTC
        </span>

      </p>




<pre>Confirmed.</pre>
    </div>

    <div id="c2">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c2">Comment 2</a>
        </span>

        <span>
          <span><span>Bill Long</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-10-02 21:46:09 UTC
        </span>

      </p>




<pre>Any update on a fix for this?  (The original customer is asking.)</pre>
    </div>

    <div id="c3">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c3">Comment 3</a>
        </span>

        <span>
          <span>anlauf
</span>
        </span>

        <span>
        </span>

        <span>
          2020-10-05 19:45:27 UTC
        </span>

      </p>




<pre><span>&gt; Any update on a fix for this?  (The original customer is asking.)</span>

I assume the customer or Cray didn&#39;t set a bounty on this?

Adding F2018 to summary.</pre>
    </div>

    <div id="c4">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c4">Comment 4</a>
        </span>

        <span>
          <span><span>Bill Long</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2020-10-05 19:50:27 UTC
        </span>

      </p>




<pre>The customer has nuclear weapons.  They do not do &#34;bounty&#34;. :)  Cray/HPE is just the messenger. I think they would be happy with a plan for including the routine.</pre>
    </div>

    <div id="c5">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c5">Comment 5</a>
        </span>

        <span>
          <span><span>Bill Long</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2021-01-22 18:00:50 UTC
        </span>

      </p>




<pre>Original customer is asking again...</pre>
    </div>

    <div id="c6">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c6">Comment 6</a>
        </span>

        <span>
          <span><span>Jerry DeLisle</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2021-01-23 03:07:19 UTC
        </span>

      </p>




<pre>Hi Bill, per our operational security procedure we can&#39;t talk about ieee_arithmetic, especially when we dont get paid.  However, I can go look at the code and see if Steve&#39;s patch got in or not.</pre>
    </div>

    <div id="c7">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c7">Comment 7</a>
        </span>

        <span>
          <span><span>Bill Long</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2021-03-03 21:59:06 UTC
        </span>

      </p>




<pre>Inquiry from the original site:

&#34;Does GCC provide a timeline for when they will conform to F2018?&#34;</pre>
    </div>

    <div id="c8">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c8">Comment 8</a>
        </span>

        <span>
          <span>kargl
</span>
        </span>

        <span>
        </span>

        <span>
          2021-03-04 00:51:21 UTC
        </span>

      </p>




<pre>(In reply to Bill Long from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c7">comment #7</a>)
<span>&gt; Inquiry from the original site:
&gt; 
&gt; &#34;Does GCC provide a timeline for when they will conform to F2018?&#34;</span>

gfortran is maintained mostly by a very, very, very, small group
of individuals who have very, very, very, limited free time.  Things
get fixed and implemented as time and whim permits.

The quickest way to ensure something is implemented/fixed is to
download the source code and dive in.

Short of someone diving in, there is always the kludge of

module kludge

   use iso_c_binding, only : fp =&gt; c_float
   use iso_c_binding, only : dp =&gt; c_double
   use iso_c_binding, only : lp =&gt; c_long_double

   implicit none

   private

   public ieee_fma

   interface ieee_fma

      function fmaf(x, y, z) bind(c, name=&#39;fmaf&#39;)
         import fp
         real(fp) fmaf
         real(fp), intent(in), value :: x, y, z
      end function fmaf
 
      function fma(x, y, z) bind(c, name=&#39;fma&#39;)
         import dp
         real(dp) fma
         real(dp), intent(in), value :: x, y, z
      end function fma

      function fmal(x, y, z) bind(c, name=&#39;fmal&#39;)
         import lp
         real(lp) fmal
         real(lp), intent(in), value :: x, y, z
      end function fmal
   end interface ieee_fma

end module

program foo
   use kludge, only : ieee_fma
   real x, y, z    ! Yeah, I should use fp from kludge.
   x = 1.
   y = 2. / 3.
   z = y
   print *, ieee_fma(x, y, z)
end program foo

Or, if the availability of IEEE_FMA is must have feature and someone
is incapability of implemented, someone could approach on of those
very, very, very, few individuals and pay for the work to be done.</pre>
    </div>

    <div id="c9">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c9">Comment 9</a>
        </span>

        <span>
          <span>kargl
</span>
        </span>

        <span>
        </span>

        <span>
          2021-03-04 02:04:00 UTC
        </span>

      </p>




<pre>(In reply to kargl from <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c8">comment #8</a>)
<span>&gt; 
&gt; Short of someone diving in, there is always the kludge of ...
&gt; </span>

This is a better kludge, but is far from the correct approach
as gfortran should use the __builtin_fma() family of functions.
But, this works for at least static linking.  I did not update
the symbol map for dynamic linking.  I also did not test the
libquadmath portion.  ENOTIME.

diff --git a/libgfortran/ieee/ieee_arithmetic.F90 b/libgfortran/ieee/ieee_arithmetic.F90
index 35a16938f8e..3d686863e90 100644
--- a/libgfortran/ieee/ieee_arithmetic.F90
+++ b/libgfortran/ieee/ieee_arithmetic.F90
@@ -39,7 +39,7 @@ module IEEE_ARITHMETIC
     IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, IEEE_INEXACT, IEEE_USUAL, &amp;
     IEEE_ALL, IEEE_STATUS_TYPE, IEEE_GET_FLAG, IEEE_GET_HALTING_MODE, &amp;
     IEEE_GET_STATUS, IEEE_SET_FLAG, IEEE_SET_HALTING_MODE, &amp;
-    IEEE_SET_STATUS, IEEE_SUPPORT_FLAG, IEEE_SUPPORT_HALTING
+    IEEE_SET_STATUS, IEEE_SUPPORT_FLAG, IEEE_SUPPORT_HALTING, IEEE_FMA
 
   ! Derived types and named constants
 
@@ -88,6 +88,17 @@ module IEEE_ARITHMETIC
   end interface
   public :: operator (.ne.)
 
+  ! IEEE_FMA
+  interface ieee_fma
+      module procedure fma04
+      module procedure fma08
+#ifdef HAVE_GFC_REAL_10
+      module procedure fma10
+#endif
+#ifdef HAVE_GFC_REAL_16
+      module procedure fma16
+#endif
+  end interface ieee_fma
 
   ! IEEE_IS_FINITE
 
@@ -808,6 +819,65 @@ SUPPORTGENERIC(IEEE_SUPPORT_STANDARD)
 
 contains
 
+      impure elemental function fma04(x, y, z)
+         use iso_c_binding, only : knd =&gt; c_float
+         real(4) fma04
+         real(4), intent(in) :: x, y, z
+         interface
+            function fmaf(x, y, z) bind(c, name=&#39;fmaf&#39;)
+               import knd
+               real(knd) fmaf
+               real(knd), intent(in), value :: x, y, z
+            end function fmaf
+         end interface
+         fma04 = fmaf(real(x, knd), real(y, knd), real(z, knd))
+      end function fma04
+
+      impure elemental function fma08(x, y, z)
+         use iso_c_binding, only : knd =&gt; c_double
+         real(8) fma08
+         real(8), intent(in) :: x, y, z
+         interface
+            function fma(x, y, z) bind(c, name=&#39;fma&#39;)
+               import knd
+               real(knd) fma
+               real(knd), intent(in), value :: x, y, z
+            end function fma
+         end interface
+         fma08 = fma(real(x, knd), real(y, knd), real(z, knd))
+      end function fma08
+#ifdef HAVE_GFC_REAL_10
+      impure elemental function fma10(x, y, z)
+         use iso_c_binding, only : knd =&gt; c_long_double
+         real(10) fma10
+         real(10), intent(in) :: x, y, z
+         interface
+            function fmal(x, y, z) bind(c, name=&#39;fmal&#39;)
+               import knd
+               real(knd) fmal
+               real(knd), intent(in), value :: x, y, z
+            end function fmal
+         end interface
+         fma10 = fmal(real(x, knd), real(y, knd), real(z, knd))
+      end function fma10
+#endif
+#ifdef HAVE_GFC_REAL_16
+      impure elemental function fma16(x, y, z)
+         integer, parameter :: knd = 16
+         real(16) fma16
+         real(16), intent(in) :: x, y, z
+         interface
+            function fmaq(x, y, z) bind(c, name=&#39;fmaq&#39;)
+               import knd
+               real(knd) fmaq
+               real(knd), intent(in) :: x, y, z
+            end function fmaq
+         end interface
+         fma16 = fmaq(real(x, knd), real(y, knd), real(z, knd))
+      end function fma16
+#endif
+
+
   ! Equality operators for IEEE_CLASS_TYPE and IEEE_ROUNDING_MODE
   elemental logical function IEEE_CLASS_TYPE_EQ (X, Y) result(res)
     implicit none</pre>
    </div>

    <div id="c10">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c10">Comment 10</a>
        </span>

        <span>
          <span><span>Jerry DeLisle</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2021-03-04 02:22:46 UTC
        </span>

      </p>




<pre>It is very likely that the gcc optimizers will actually convert the to fma machine instructions, but no guarantee.

I don&#39;t have much time, but it is likely some of the tricks we used in matmul can be used to get this to be &#34;register&#34; implemented .</pre>
    </div>

    <div id="c11">

      <p><span>
          <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c11">Comment 11</a>
        </span>

        <span>
          <span><span>Steve Kargl</span>
</span>
        </span>

        <span>
        </span>

        <span>
          2021-03-04 04:02:24 UTC
        </span>

      </p>




<pre>On Thu, Mar 04, 2021 at 02:22:46AM +0000, jvdelisle at gcc dot gnu.org wrote:
<span>&gt; <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644</a>
&gt; 
&gt; --- <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95644#c10">Comment #10</a> from Jerry DeLisle &lt;jvdelisle at gcc dot gnu.org&gt; ---
&gt; It is very likely that the gcc optimizers will actually convert the to fma
&gt; machine instructions, but no guarantee.</span>

That&#39;s what __builtin_fma() will do.  The second kludge I
posted would still have the layer of indirection of calling
on of fma04, fma08, fma10, or fma16.  Also, note that the
kludge declares these as IMPURE ELEMENTAL because of the
BIND(C) stuff.  This is technically incorrect.

<span>&gt; I don&#39;t have much time, but it is likely some of the tricks we used in matmul
&gt; can be used to get this to be &#34;register&#34; implemented .</span>

The correct approach would give interfaces in the
ieee_arithmetic so that argument checking can be
done.  The implementation details would be contained
in trans-intrinsic.c where conv_intrinsic_fma() is
called and __builtin_fma is directly emitted.  Another
approach, where conv_intrinsic_fma() is unneeded,
would be to register __builtin_fma() as builtin function
with gfortran.  This, however, requires more work because
gfortran currently does not have a mechanism for registering
a 3 argument builtin function.</pre>
    </div>


  

</td>
<td>
</td>
</tr></tbody></table>
  </div></div>
  </body>
</html>
