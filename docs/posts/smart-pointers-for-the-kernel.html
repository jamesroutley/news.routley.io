<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/992055/">Original</a>
    <h1>Smart pointers for the kernel</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>

<div>

<p>
Rust has a plethora of smart-pointer types, including reference-counted
pointers, which have special support in the compiler to make them
easier to use. The Rust-for-Linux project would like to reap those same benefits
for its smart pointers, which need to be written by hand to conform to
the
<a href="https://mckzm.github.io/Articles/718628/">
Linux kernel
memory model</a>. Xiangfei Ding
presented at Kangrejos about the work to enable custom
smart pointers to function the same as built-in smart pointers.
</p>

<p>
Ding showed the specific &#34;superpowers&#34; that built-in smart pointers have in his
<a href="https://kangrejos.com/2024/SmartPointer%20and%20PinCoerceUnsized.pdf">
slides</a>:
unsizing and dynamic dispatch. Unsizing allows the programmer
to remove the length of an array behind a pointer from its type,
turning
a <tt>Ptr&lt;[T; N]&gt;</tt> (bounds-checked at compile time) into a
<tt>Ptr&lt;[T]&gt;</tt> (bounds-checked at run time). This needs special support because slices
(values of type <tt>[T]</tt>) do not have a known size at compile time; therefore the compiler
needs to store the size somewhere at run time. The compiler could store the size
in the pointed-to allocation, but that would require reallocating the array&#39;s
memory, which would be expensive. Instead, the compiler stores the size
alongside the pointer itself, as a fat pointer. On nightly Rust compilers, users
can enable an experimental feature and then have their
pointer type implement
<a href="https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html"><tt>CoerceUnsized</tt></a>
to indicate that it supports that.
</p>

<p><a href="https://mckzm.github.io/Articles/992336">
<img src="https://static.lwn.net/images/2024/xiangfei-ding-small.png" alt="[Xiangfei Ding]" title="Xiangfei Ding"/>
</a></p><p>
The second superpower is called
<a href="https://doc.rust-lang.org/std/ops/trait.DispatchFromDyn.html"><tt>DispatchFromDyn</tt></a>
and allows converting a <tt>Ptr&lt;T&gt;</tt> into a <tt>Ptr&lt;dyn
Trait&gt;</tt> when <tt>T</tt> implements <tt>Trait</tt>. This has to do with
the way that Rust implements dynamic dispatch — a value of type <tt>Ptr&lt;dyn
Trait&gt;</tt> uses a dispatch table to find the implementation of the method
being invoked at run time.
That method expects to receive a <tt>self</tt> pointer. So converting a smart
pointer to use dynamic dispatch only works when the smart pointer can be used as
a <tt>self</tt> pointer.
</p>

<p>
These features are both experimental, because the Rust project is still working
on their design. Ding explained that there is an
<a href="https://rust-lang.github.io/rfcs/3621-derive-smart-pointer.html">
RFC</a> aimed at stabilizing just enough for the Linux kernel to use, without
impeding the development of the features. The RFC would add a new macro
that makes it trivial for
a smart pointer satisfying certain requirements to implement the
necessary traits, no matter what the final forms of the traits end up looking
like. That would let the kernel start using its custom smart pointers on stable
Rust sooner rather than later.
</p>

<p>
There is one catch — implementing these features for a smart-pointer type with a
malicious or broken
<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">
<tt>Deref</tt></a> (the trait that lets a programmer dereference a value)
implementation could break the guarantees
Rust relies on to determine when objects can be moved in memory.
This is of particular importance to
<a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><tt>Pin</tt></a>,
which is a wrapper type used to mark an allocation that cannot be moved.
It&#39;s not hard to write smart-pointer types that don&#39;t cause problems,
but in keeping with Rust&#39;s
commitment to ensuring safe code cannot cause memory-safety problems, the RFC
also requires programmers to use unsafe (specifically, implementing an
<tt>unsafe</tt>
<a href="https://users.rust-lang.org/t/understanding-the-marker-traits/75625/3">
marker trait</a>) as a promise that
they&#39;ve read the relevant documentation and are not going to break <tt>Pin</tt>.
With that addition, the code for a smart-pointer type would look like this:
</p>

<pre>    // Use Ding&#39;s macro ...
    #[derive(SmartPointer)]
    // On a struct that is just a wrapper around a pointer
    #[repr(transparent)]
    struct MySmartPointer&lt;T: ?Sized&gt;(Box&lt;T&gt;);

    // Implement Deref, with whatever custom logic is needed
    impl&lt;T: ?Sized&gt; Deref for MySmartPointer&lt;T&gt; {
        type Target = T;
        fn deref(&amp;self) -&gt; &amp;T {
            ...
        }
    }

    // And then promise the compiler that the Deref implementation is okay to
    // use in conjunction with Pin:
    unsafe impl&lt;T: ?Sized&gt; PinCoerceUnsized for MySmartPointer&lt;T&gt; {}
</pre>

<p>
Andreas Hindborg asked for some clarification about why the marker trait is
needed. <tt>Deref</tt>
is supposed to be simple, Ding explained. Usually, someone writing a
smart-pointer type would have a normal pointer stored in their type; when implementing
<tt>Deref</tt>, they can just use the normal pointer. But it&#39;s technically
possible to implement something more complicated than that. In this case, you
could have a <tt>Deref</tt> implementation that actually moves data out of the
object pointed to and stores something else there. This would not normally be a problem,
except when the smart pointer is contained in a <tt>Pin</tt>, which is supposed
to prevent the value from being moved. If the <tt>Deref</tt> implementation
moves the value anyway, then that would be undefined behavior. The unsafe marker
trait is a promise to the compiler that the programmer has not done that.
</p>

<!-- middle-ad -->

<p>
The new macro is available on nightly Rust, although Ding says that it needs a
bit more testing in order to stabilize, as well as some additional documentation
which he is working on. Miguel Ojeda asked how soon the macro might be
stabilized; Ding answered that it should be quite soon. He will make a
stabilization report shortly, and then it is just a matter of checking off the
requirements.
</p></div> <!-- ArticleText -->



</div> <!-- middlecolumn -->

</div></div>
  </body>
</html>
