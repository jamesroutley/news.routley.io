<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.eriksen.com.br/en/introducing-kotlin-money">Original</a>
    <h1>Show HN: Kotlin Money</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>Manipulating monetary amounts is a common computing chore. However, no mainstream language has a first-class data type for representing money, it’s up to programmers to code abstractions for it. This isn’t an issue per se until dealing with rounding issues from operations like installment payments (e.g., buy now, pay later), foreign exchange, or even simple things like fee processing and tax collection.</p>

<p>Inspired by my days at <a href="https://blog.eriksen.com.br/en/platform-engineering-n26">N26</a> dealing with these challenges, I introduce <a href="https://github.com/eriksencosta/money/">Money</a>: a Kotlin library that makes monetary calculations and allocations easy:</p>

<pre><code>val price = 100 money &#34;USD&#34;                     // USD 100.00
val shipping = 5 money &#34;USD&#34;                    // USD 5.00
val subtotal = price + shipping                 // USD 105.00
val discount = 10.percent()                     // 10%
val total = subtotal decreaseBy discount        // USD 94.50

val ratios = listOf(60.percent(), 40.percent()) // [60%, 40%]

total allocate 2                                // [USD 47.25, USD 47.25]
total allocate ratios                           // [USD 56.70, USD 37.80]
</code></pre>

<p>The library supports mathematical operations with monetary amounts, calculations with percentages, and allocation, making it simple to model use cases like those mentioned. Cryptocurrencies are also fully supported out of the box:</p>

<pre><code>val price = 0.01607580 money &#34;BTC&#34;           // BTC 0.01607580
val transactionFee = 1.25.percent()          // 1.25%
val total = price increaseBy transactionFee  // BTC 0.01627675
val installments = total allocate 3          // [BTC 0.00542559, BTC 0.00542558, BTC 0.00542558]

val rate = 62_555.60 money &#34;USD&#34;             // USD 62555.60
val totalInUsd = total exchange rate         // USD 1005.63
</code></pre>

<h2 id="allocation">Allocation</h2>

<p>One of the nicest features of the library is its allocation capability. Allocation allows the distribution of a monetary amount into parts while guaranteeing that the sum of the parts equals the original value. For example, a retailer may accept purchases by credit card installments or by buy now, pay later (BNPL). What happens when a customer makes a purchase totaling USD 100.00 to be paid in three installments?</p>

<pre><code>val price = 100 money &#34;USD&#34;
val number = 3
val installment = price / number
val installments = List(number) { installment } // [USD 33.33, USD 33.33, USD 33.33]
val total = installments.sum()                  // USD 99.99
</code></pre>

<p>As you noticed, there is a loss of USD 0.01. A penny here and there may seem a slight loss, but it may be <a href="https://slate.com/technology/2019/10/round-floor-software-errors-stock-market-battlefield.html">costly over time</a>. But there are other complications as well, such as overcharging a customer (which can be an infringement of consumer rights in several countries) due to rounding issues. The library provides a handy <code>allocate()</code> method that guarantees the result won’t differ from the original amount:</p>

<pre><code>val price = 100 money &#34;USD&#34;
val installments = price allocate 3          // [USD 33.34, USD 33.33, USD 33.33]
val total = installments.allocations().sum() // USD 100.00
</code></pre>

<p>To allocate in proportional parts, pass a list of <code>Percentage</code> values to the method:</p>

<pre><code>val amount = 2345.89 money &#34;USD&#34;
val result = dueAmount allocate listOf(50.percent(), 30.percent(), 20.percent())
val allocations = result.allocations() // [USD 1172.94, USD 703.77, USD 469.18]
val total = allocations.sum()          // USD 2345.89
</code></pre>

<p>As you can see in the previous examples, both results totaled up to the original monetary amount. No cent was lost or gained. By default, the library automatically allocates the difference. But you can tweak how the difference is allocated in the allocations list. For example, suppose your company requires the difference to be always allocated to the last item. You can do it by creating the allocator object directly with the desired allocation strategy:</p>

<pre><code>val price = 100 money &#34;USD&#34;
val allocator = EvenAllocator(OnLast)
val installments = allocator.allocate(price, 3) // [USD 33.33, USD 33.33, USD 33.34]
val total = installments.allocations().sum()    // USD 100.00
</code></pre>

<h2 id="wrapping-up">Wrapping up</h2>

<p>This post is just a glimpse of the library’s capabilities. I intend to keep the library’s API concise and to expand its capabilities gradually, including supporting Android development and out of the box persistence and serialization. Nevertheless, I hope it’s useful in its current version for people manipulating monetary amounts in Kotlin projects.</p>

<p>Refer to the <a href="https://github.com/eriksencosta/money/tree/trunk/docs/usage">usage guide</a> on how to work with Money. The library has built-in support for <a href="https://github.com/eriksencosta/money/blob/trunk/docs/appendixes/circulating-currencies.md">306 circulating currencies</a> and <a href="https://github.com/eriksencosta/money/blob/trunk/docs/appendixes/cryptocurrencies.md">2283 cryptocurrencies</a>. The <a href="https://github.com/eriksencosta/money/#installation">installation procedures</a> are explained in the project’s README. Give it a shot!</p>

<!-- Links. -->



    
      <h2>References</h2>
      
<ul>

  <li>
    <a id=""></a>
    

    <a href="https://blog.eriksen.com.br/en/platform-engineering-n26">Platform engineering at N26: how we planned and launched it</a>

    
  </li>

  <li>
    <a id=""></a>
    

    <a href="https://github.com/eriksencosta/money">Money: Project repository</a>

    
  </li>

  <li>
    <a id=""></a>
    Slate. Lav Varshney, 2019.

    <a href="https://slate.com/technology/2019/10/round-floor-software-errors-stock-market-battlefield.html">The Deadly Consequences of Rounding Errors</a>

    
  </li>

  <li>
    <a id=""></a>
    

    <a href="https://github.com/eriksencosta/money/tree/trunk/docs/usage">Money: Usage guide</a>

    
  </li>

  <li>
    <a id=""></a>
    

    <a href="https://github.com/eriksencosta/money/blob/trunk/docs/appendixes/circulating-currencies.md">Money: Circulating currencies</a>

    
  </li>

  <li>
    <a id=""></a>
    

    <a href="https://github.com/eriksencosta/money/blob/trunk/docs/appendixes/cryptocurrencies.md">Money: Cryptocurrencies</a>

    
  </li>

  <li>
    <a id=""></a>
    

    <a href="https://github.com/eriksencosta/money/#installation">Money: Installation procedures</a>

    
  </li>

</ul>


    
  </article></div>
  </body>
</html>
