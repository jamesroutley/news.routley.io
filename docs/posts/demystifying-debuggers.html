<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.rfleury.com/p/demystifying-debuggers-part-1-a-busy">Original</a>
    <h1>Demystifying Debuggers</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><article><div><div><div dir="auto"><p><em><a href="https://www.rfleury.com/i/146446067/demystifying-debuggers-series" rel="">Part 1 in a series.</a></em></p><p>Debuggers exist at the intersection of many parts of the computing ecosystem—they must contend with intricate details of kernels, compilers, linkers, programming languages, and instruction set architectures.</p><p><span>My familiarity with debuggers has improved my programming abilities, the utility of debuggers in my day-to-day programming, and my general knowledge of computing. Back in January, </span><a href="https://github.com/EpicGamesExt/raddebugger" rel="">the RAD Debugger</a><span>—the project I work on full-time—was open sourced to the public, to mark the start of its open alpha phase. I’ve been working on the debugger, or the technology on which it depends, for almost four years full-time now. The project has taught me an enormous number of lessons, through exposure to an enormous number of problems. There is still a lot of work to do, and so I expect it will continue to do so, for many years to come.</span></p><p>But perhaps most importantly, debuggers are an intricate piece of the puzzle of the design of a development platform—a future I become more interested in every day, given the undeniable decay infecting modern computing devices and their software ecosystems.</p><p><span>To emphasize their importance, I’d like to reflect on the name “debugger”. It is not a name I would’ve chosen, because it can give the impression that a debugger is an auxiliary, only-relevant-when-things-break tool. Of course, a debugger is </span><em>used to debug</em><span>—which is why it was named as such—but it is also enormously useful to analyze </span><em>working</em><span> code’s behavior, and to verify code’s correctness, with respect to the expectations of the code.</span></p><p>A good debugger provides clear and insightful visualizations into what code is doing. As such, they are also enormously useful educational tools—for beginners and experts alike—because they make what is normally opaque, visible. They provide these features by dynamically interacting with running programs—as such, they can also dynamically modify code. At the limit, this approximates (or employs) JIT-compilation and hot-reloading, making traditional compiled toolchains have much more runtime flexibility for developers.</p><p>For these reasons, “debugger” is much too special-purpose of a name for the full set of capabilities that debuggers actually provide—they offer glimpses into the lower level inner-workings of a computer. If one designed a computing system from scratch, they might not ideally be independent from the operating system itself. Instead, perhaps the same capabilities could simply be provided through first-class visualization and dynamic execution adjustment features that the operating system naturally exposes. But that is a topic for another day.</p><p><span>I hope this sheds light on the imbecility of Internet debates about the utility of debuggers—for example, where one might find comments like, “I don’t need debuggers, because I can just use </span><code>printf</code><span>”, or “I don’t need debuggers if I can statically guarantee correctness”. It’s akin to suggesting that someone does not benefit from vision, because they can feel their way around with a mobility cane, or read text through Braille. Even though mobility canes and Braille are obviously good inventions for people who can’t have vision, that doesn’t somehow imply that vision isn’t an obvious benefit, or that it isn’t obviously preferable. Similarly, even though logging and static verification are obviously good inventions for programs or circumstances which cannot be easily debugged at runtime, or when those things are simply preferable in context, that doesn’t somehow imply that actively visualizing the runtime execution of programs through a debugger isn’t an obvious net benefit, or that it isn’t obviously preferable in many cases. To suggest otherwise in either case is absurd. The more useful debuggers become, the shorter the iteration loop of the programmer, the more efficient software production becomes, and the more trivially that programmers can obtain true from-first-principles reasoning about their code.</span></p><p>Given their importance for both the present and future, and their utility to myself (and thus perhaps readers), I’m writing a series explaining and documenting debugger architecture.</p><p>In this series of posts, I’ll cover the following topics:</p><ul><li><p><em><strong><a href="https://www.rfleury.com/p/demystifying-debuggers-part-2-the" rel="">The Anatomy Of A Running Program</a><span> </span></strong></em><span>— On the concepts involved in a running program. What happens, exactly, when you double click an executable file, or launch it from the command line, and it begins to execute?</span></p></li><li><p><em><strong><a href="https://www.rfleury.com/p/demystifying-debuggers-part-3-kernel" rel="">Debugger-Kernel Interaction</a><span> </span></strong></em><span>— On how kernels collect and expose information about program execution to debuggers, like “debug events”, encoding changes like thread creation &amp; destruction, dynamic module loading &amp; unloading, low level exceptions being hit by threads, and more; or like the reading &amp; writing of memory &amp; thread registers, or like the suspension and resumption of threads.</span></p></li><li><p><em><strong>CPU Debug Features </strong></em><span>— On the features that CPUs commonly expose for debuggers, like interruption instructions, debug registers, single-stepping mode, and more.</span></p></li><li><p><em><strong>Debugger-Inserted Traps</strong></em><span> — On how debuggers set “traps”—a trivial but widely-used form of runtime code modification that allows the debugger to intercept and control code execution (like to implement the higher level “breakpoints” feature).</span></p></li><li><p><em><strong>Debug Info &amp; Toolchains</strong></em><span> — On the traditional compilation and linking pipeline, how “debug info” is produced, what it contains, and how it helps debuggers implement higher level features, which can correlate a program’s state with source code or language constructs.</span></p></li><li><p><em><strong>Evaluation </strong></em><span>— On evaluating expressions using an expression language and “location info” and “type info”—two parts of “debug info”.</span></p></li><li><p><em><strong>Breakpoints</strong></em><span> — On how “breakpoints” are implemented, from address breakpoints, symbol breakpoints, source code location breakpoints, to conditional breakpoints and processor (or data) breakpoints.</span></p></li><li><p><em><strong>Stepping</strong></em><span> — On the various “stepping” features in debuggers, from the barebones single-instruction stepping, to disassembly stepping, to source line stepping, all with variants like “step into”, “step over”, and “step out”, all while correctly handling multithreaded programs.</span></p></li><li><p><em><strong>Unwinding</strong></em><span> — On “unwinding”, which is how a debugger determines a thread’s current “call stack”, and is able to correctly evaluate values from all scopes in a call stack.</span></p></li><li><p><em><strong>Graphical Debugger Multithreaded Architecture</strong></em><span> — On the structure of a graphical debugger, which employs the aforementioned features and concepts, and exposes them through a real-time interactive interface.</span></p></li><li><p><em><strong>The Watch Window, &amp; General-Purpose Data Visualization</strong></em><span> — On the traditional “watch window” graphical debugger interface, and how it may be extended to support general-purpose data visualization.</span></p></li><li><p>…and anything else I stumble across while writing that I think would be appropriate to cover!</p></li></ul><p><span>In discussing these topics, I’ll try to abstract over platform and architectural details when possible, but I’ll base my writing on my experience from working on </span><a href="https://github.com/EpicGamesExt/raddebugger" rel="">the RAD Debugger</a><span>, which has begun its journey as a Windows, user-mode, x64 debugger (although it’s not </span><em>finishing</em><span> its journey as merely that). I’ll also use the RAD Debugger to demonstrate certain concepts and features concretely.</span></p><p>When I am explicitly relying on that context, I’ll do my best to state so, but I’ll also do my best to extrapolate to more generalized information when appropriate, as many of the concepts have similar if not identical analogs on other platforms, and so I feel the knowledge is quite generalizable.</p><p>I hope you’re excited to come along for the ride, and demystify debuggers for yourself!</p><p>If you enjoyed this post, please consider subscribing. Thanks for reading.</p><p>-Ryan</p></div></div></div></article></div></div></div><div><div id="discussion"><div><h4>Discussion about this post</h4></div></div></div></div>
  </body>
</html>
