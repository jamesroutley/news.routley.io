<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ahgamut.github.io/2023/07/13/patching-gcc-cosmo/">Original</a>
    <h1>Patching GCC to build Actually Portable Executables</h1>
    
    <div id="readability-page-1" class="page"><div id="main"><div><header><p><a href="https://joseph.yiasemides.com/"><b>Blog Needs a Name</b></a></p><ul><li><a href="https://joseph.yiasemides.com/">Home</a></li><li><a href="https://joseph.yiasemides.com/about">About</a></li></ul></header><hr/><h2>Patching GCC to build Actually Portable Executables</h2><p><strong>2023-07-13:</strong> I wrote a <a href="https://github.com/ahgamut/gcc/tree/portcosmo-11.2">~2000-line <code>gcc</code> patch</a> to simplify building
Actually Portable Executables with <a href="https://github.com/jart/cosmopolitan">Cosmopolitan Libc</a>. Now you can build
popular software such as <code>bash</code>, <code>curl</code>, <code>git</code>, <code>ninja</code>, and even <code>gcc</code> itself,
with Cosmopolitan Libc via the <code>./configure</code> or <code>cmake</code> build system, without
having to change source code, and the built executables should run on Linux,
FreeBSD, MacOS, OpenBSD, NetBSD, and in some cases even Windows too<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.
Here’s how you can port your own software to Cosmopolitan Libc now:</p><ol><li>Clone the <a href="https://github.com/jart/cosmopolitan">Cosmopolitan Libc repo</a>, and set up the <code>/opt/cosmo</code> and
<code>/opt/cosmos</code> directories as per the README.</li><li>Set the necessary environment variables:</li></ol><div><pre tabindex="0"><code data-lang="sh"><span><span><span>export</span> <span>COSMO</span><span>=</span>/opt/cosmo
</span></span><span><span><span>export</span> <span>COSMOS</span><span>=</span>/opt/cosmos
</span></span><span><span><span>export</span> <span>CC</span><span>=</span><span>$COSMO</span>/tool/scripts/cosmocc 
</span></span><span><span><span>export</span> <span>CXX</span><span>=</span><span>$COSMO</span>/tool/scripts/cosmoc++
</span></span><span><span><span>export</span> <span>LD</span><span>=</span><span>$COSMO</span>/tool/scripts/cosmoc++
</span></span></code></pre></div><ol start="3"><li><em>(Optional)</em>: here are my forks of <a href="https://github.com/ahgamut/gcc/tree/portcosmo-11.2"><code>gcc</code></a> and
<a href="https://github.com/ahgamut/musl-cross-make"><code>musl-cross-make</code></a>, which you can use to build <code>gcc</code> with the
latest version of my patch. If you do this, remember to edit <code>cosmocc</code> and
<code>cosmoc++</code> accordingly.</li><li>Let’s try a simple <code>hello world</code> example first:</li></ol><div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>printf</span><span>(</span><span>&#34;Actually Portable Executable built via cosmocc</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>    <span>return</span> <span>0</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>To build the APE for a single file, you can just</p><div><pre tabindex="0"><code data-lang="sh"><span><span>cosmocc -o hello.com hello.c
</span></span></code></pre></div><ol start="5"><li><p>to build software that <a href="https://github.com/ahgamut/superconfigure">uses <code>./configure</code></a> or <code>cmake</code>, export the
above environment variables, and then run the necessary build steps to get a
static debug executable that runs on Linux</p></li><li><p>to get an Actually Portable Executable, run</p></li></ol><div><pre tabindex="0"><code data-lang="sh"><span><span>objcopy -SO binary your-software your-software.com
</span></span><span><span><span>$COSMO</span>/o/tool/scripts/zipcopy.com your-software your-software.com
</span></span></code></pre></div><p>When Cosmopolitan Libc burst onto the scene with the <a href="https://news.ycombinator.com/item?id=26271117">Hacker News post about the
<code>redbean</code> webserver</a> in 2021, an immediate question was how existing
C software would run on it. The best way to test a new libc is to build more
code on top, and <a href="https://github.com/jart/cosmopolitan/tree/master/third_party">many codebases have been ported</a> to use cosmo. The
porting efforts have also helped fill out the libc API. However, a new libc must
also fit in with how C software is conventionally built – things like
<code>./configure</code> and <code>cmake</code> – so that porting more software is easy. When
<a href="https://github.com/jart/cosmopolitan/releases/tag/2.1"><code>pthreads</code> became available last year</a>, I said: <a href="https://joseph.yiasemides.com/2022/07/27/ape-rust-example/">porting is just a
matter of convincing the build system</a>. I believe my <code>gcc</code> patch is a
big step towards seamlessly building a lot of software with Cosmopolitan Libc.
This blog post will cover how the patch came to be.</p><h2 id="introduction">Introduction</h2><p><a href="https://github.com/jart/cosmopolitan/issues/61">Lua</a> was the first programming language to be ported to Cosmopolitan Libc,
followed by <a href="https://github.com/jart/cosmopolitan/issues/104">Wren</a>, <a href="https://github.com/jart/cosmopolitan/issues/114">Janet</a>, and Fabrice Bellard’s
<a href="https://github.com/jart/cosmopolitan/issues/97#issuecomment-816831508"><code>quickjs</code></a>. There appeared to be a common change across the ports:
<code>switch</code> statements with system values like <code>SIGTERM</code> or <code>EINVAL</code> had to be
rewritten as <code>if</code> statements. <strong>2021-03-24:</strong> I raised issue #134 on Github
about this, and got the below answer from <a href="https://github.com/jart">Justine Tunney</a>:</p><blockquote><p>Code that uses <code>switch</code> on system constants needs to be updated to use <code>if</code>
statements. That’s unavoidable unfortunately. It’s the one major breakage we
needed to make in terms of compatibility. The tradeoff is explained in the APE
blog post […] C preprocessor macros relating to system interfaces need to be
symbolic. This is barely an issue, except in cases like <code>switch(errno){case EINVAL:}</code> If we feel comfortable bending the rules […]</p></blockquote><p><strong>2022-09-05:</strong> After writing a bunch of ports, it was clear that the
<code>switch(errno)</code> pattern is quite common, and porting software would be much
faster if the rules could be bent automatically. I decided to try solving
<code>this</code>, but let’s define what <code>this</code> is.</p><h2 id="switch-to-if"><code>switch</code> to <code>if</code></h2><p>Consider the below code snippet:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// somewhere within your code
</span></span></span><span><span><span></span><span>switch</span> <span>(</span><span>errno</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>case</span> <span>EINVAL</span><span>:</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;you got EINVAL</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>        <span>break</span><span>;</span>
</span></span><span><span><span>#ifdef EAFNOSUPPORT
</span></span></span><span><span><span></span>    <span>case</span> <span>EAFNOSUPPORT</span><span>:</span>
</span></span><span><span>        <span>// fallthrough
</span></span></span><span><span><span></span><span>#endif
</span></span></span><span><span><span></span>    <span>case</span> <span>ENOSYS</span><span>:</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;you got ENOSYS</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>        <span>break</span><span>;</span>
</span></span><span><span>    <span>default</span><span>:</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;unknown error</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>        <span>break</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The C standard<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> says that <code>case</code> labels need to be compile-time
constants. If <code>EINVAL</code> is not a compile-time constant, you would get an error
like <code>case label does not reduce to an integer constant</code> when compiling this
snippet with <code>gcc</code>. So you’d need to rewrite the <code>switch</code> statement into an <code>if</code>
statement. My code rewrites <code>switch</code> statements like this:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// rewriting the switch to an if
</span></span></span><span><span><span></span><span>{</span> <span>// maintain scoping
</span></span></span><span><span><span></span>    <span>if</span><span>(</span><span>errno</span> <span>==</span> <span>EINVAL</span><span>)</span> <span>goto</span> <span>caselabel_EINVAL</span><span>;</span>
</span></span><span><span><span>#ifdef EAFNOSUPPORT
</span></span></span><span><span><span></span>    <span>if</span><span>(</span><span>errno</span> <span>==</span> <span>EAFNOSUPPORT</span><span>)</span> <span>goto</span> <span>caselabel_EAFNOSUPPORT</span><span>;</span>
</span></span><span><span><span>#endif
</span></span></span><span><span><span></span>    <span>if</span><span>(</span><span>errno</span> <span>==</span> <span>ENOSYS</span><span>)</span> <span>goto</span> <span>caselabel_ENOSYS</span><span>;</span>
</span></span><span><span>    <span>goto</span> <span>caselabel_default</span><span>;</span>
</span></span><span><span>    <span>caselabel_EINVAL</span><span>:</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;you got EINVAL</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>        <span>goto</span> <span>endofthis_switch</span><span>;</span> <span>//  break
</span></span></span><span><span><span></span><span>#ifdef EAFNOSUPPORT
</span></span></span><span><span><span></span>    <span>caselabel_EAFNOSUPPORT</span><span>:</span>
</span></span><span><span>        <span>// fallthrough
</span></span></span><span><span><span></span><span>#endif
</span></span></span><span><span><span></span>    <span>caselabel_ENOSYS</span><span>:</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;you got ENOSYS</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>        <span>goto</span> <span>endofthis_switch</span><span>;</span>
</span></span><span><span>    <span>caselabel_default</span><span>:</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;unknown error</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>        <span>goto</span> <span>endofthis_switch</span><span>;</span>
</span></span><span><span>    <span>endofthis_switch</span><span>:</span>
</span></span><span><span>        <span>((</span><span>void</span><span>)</span><span>0</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The above pattern might not be the most elegant<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> but it handles all
the examples I have seen across codebases.</p><h2 id="struct-initializations"><code>struct</code> initializations</h2><p>While constructing test cases for <code>switch</code> statements that would have to be
rewritten, I came across a related problem that also assumed compile-time
constants – <code>static</code> or <code>const</code> <code>struct</code> initializations. The <a href="https://github.com/ahgamut/cpython/blob/master/Modules/faulthandler.c#L66"><code>faulthandler</code>
module in CPython</a> is a real-life example of this, but let’s look
at the below snippet:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> <span>toy</span> <span>{</span>
</span></span><span><span>    <span>int</span> <span>status</span><span>;</span>
</span></span><span><span>    <span>int</span> <span>value</span><span>;</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>func</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>struct</span> <span>toy</span> <span>t1</span> <span>=</span> 
</span></span><span><span>        <span>{.</span><span>status</span> <span>=</span> <span>EINVAL</span><span>,</span> <span>.</span><span>value</span> <span>=</span> <span>25</span><span>};</span> <span>// ok
</span></span></span><span><span><span></span>    <span>const</span> <span>struct</span> <span>toy</span> <span>t2</span> <span>=</span> 
</span></span><span><span>        <span>{.</span><span>status</span> <span>=</span> <span>EINVAL</span><span>,</span> <span>.</span><span>value</span> <span>=</span> <span>25</span><span>};</span> <span>// error
</span></span></span><span><span><span></span>    <span>static</span> <span>struct</span> <span>toy</span> <span>t3</span> <span>=</span>
</span></span><span><span>        <span>{.</span><span>status</span> <span>=</span> <span>EINVAL</span><span>,</span> <span>.</span><span>value</span> <span>=</span> <span>25</span><span>};</span> <span>// error
</span></span></span><span><span><span></span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>const</span> <span>struct</span> <span>toy</span> <span>gt2</span> <span>=</span> 
</span></span><span><span>    <span>{.</span><span>status</span> <span>=</span> <span>EINVAL</span><span>,</span> <span>.</span><span>value</span> <span>=</span> <span>25</span><span>};</span> <span>// error
</span></span></span><span><span><span></span><span>static</span> <span>struct</span> <span>toy</span> <span>gt3</span> <span>=</span>
</span></span><span><span>    <span>{.</span><span>status</span> <span>=</span> <span>EINVAL</span><span>,</span> <span>.</span><span>value</span> <span>=</span> <span>25</span><span>};</span> <span>// error
</span></span></span></code></pre></div><p>If <code>EINVAL</code> is not a compile-time constant, four of the initializations above
are not valid<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> in C. My fix was to dummy-initialize the <code>struct</code>s and
then add an <code>if</code> statement or an <a href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gcc/Common-Function-Attributes.html#Common-Function-Attributes"><code>__attribute__((constructor))</code></a> to fill
in the correct value(s) before they are used at runtime.</p><h2 id="outline-of-the-problem">Outline of the problem</h2><p>From the above two sections we have defined the problem space: certain <code>switch</code>
statements and <code>struct</code> initializations may not compile, because they rely on
system values being compile-time constants. Now:</p><ul><li>Can we (automatically) find these <code>switch</code> statements and convert them into
<code>if</code>s and <code>goto</code>s?</li><li>Can we (automatically) find these <code>struct</code> initializations and insert the
necessary code that fills in the correct runtime values?</li></ul><p>I started off trying to automate these conversions using <code>sed</code> in a shell
script. After a while, it was a python script with some extra regex work to
handle <code>switch</code> fallthroughs. But neither of these worked completely because of
the C preprocessor and <code>ifdef</code>s. It is difficult to perform the rewrite as a
<em>text substitution</em> when you do not know which <code>ifdef</code>s would activate during
compilation. Then, maybe I could perform the rewrite as an <em>AST substitution</em> –
if the code was available as an AST (abstract syntax tree), performing a rewrite
would be replacing one subtree with another. I could also avoid dealing with
the C preprocessor…</p><h2 id="curiously-exploring-gcc-plugins">Curiously exploring <code>gcc</code> plugins</h2><p><code>gcc</code> provides a plugin architecture via which you can access the AST of the
code being compiled. You compile your code as a shared object, load it alongside
<code>gcc</code> with the flag <code>-fplugin=your-plugin.so</code>. The <a href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gccint/"><code>gcc</code> internals
documentation</a> provides detailed explanations as to when and how the
plugin writers can interact with the compilation process, and there are some
<a href="https://jongy.github.io/2020/04/25/gcc-assert-introspect.html">wonderful</a> <a href="https://gabrieleserra.ml/blog/2020-08-27-an-introduction-to-gcc-and-gccs-plugins.html">articles</a> with examples of how you can write your own
<code>gcc</code> plugins (perhaps I should write my own article with examples). For now,
let’s just remember the following:</p><ol><li><code>gcc</code> allows plugins to activate callbacks during <a href="https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gccint/Plugin-API.html#Plugin-API">plugin events</a>:</li></ol><div><pre tabindex="0"><code data-lang="c"><span><span><span>enum</span> <span>plugin_event</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>PLUGIN_START_PARSE_FUNCTION</span><span>,</span>  <span>/* Called before parsing the body of a function. */</span>
</span></span><span><span>  <span>PLUGIN_FINISH_PARSE_FUNCTION</span><span>,</span> <span>/* After finishing parsing a function. */</span>
</span></span><span><span>  <span>PLUGIN_FINISH_DECL</span><span>,</span>           <span>/* After finishing parsing a declaration. */</span>
</span></span><span><span>  <span>PLUGIN_PRE_GENERICIZE</span><span>,</span>        <span>/* Allows to see low level AST in C and C++ frontends.  */</span>
</span></span><span><span>  <span>PLUGIN_INFO</span><span>,</span>                  <span>/* Information about the plugin. */</span>
</span></span><span><span>  <span>PLUGIN_INCLUDE_FILE</span><span>,</span>          <span>/* Called when a file is #include-d */</span>
</span></span><span><span>  <span>/* [removed some of the events] */</span>
</span></span><span><span>  <span>PLUGIN_START_UNIT</span><span>,</span>            <span>/* Called before processing a translation unit.  */</span>
</span></span><span><span>  <span>PLUGIN_FINISH_UNIT</span><span>,</span>           <span>/* Useful for summary processing.  */</span>
</span></span><span><span>  <span>PLUGIN_FINISH</span>                 <span>/* Called before GCC exits.  */</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div><p>The callback is provided some data from <code>gcc</code> (which may be a pointer to an AST,
a string, or something else depending on the event), and a pointer to data that
you might have initialized at startup. Since we need to manipulate the AST, the
<code>PLUGIN_PRE_GENERICIZE</code>, <code>PLUGIN_FINISH_PARSE_FUNCTION</code>, or <code>PLUGIN_FINISH_DECL</code>
events seem viable.</p><ol start="2"><li><p>The AST provided by <code>gcc</code> is a tree structure, which takes a while to connect
to the original C code, but is easy to read and manipulate afterwards. <code>gcc</code>
provides a function called <code>debug_tree</code> that prints the AST. It’s probably
the function you will use the most when developing a plugin. There are also
convenient macros to access, say, the second arg of the <code>ADD_EXPR</code> or the
name of the <code>VAR_DECL</code>.</p></li><li><p><code>gcc</code> provides a function <code>walk_tree_without_duplicates(ast, your_callback, your_data)</code> which walks through the entire AST in pre-order traversal and
presents each node to <code>your_callback</code> to read, process, and modify.</p></li></ol><p><strong>2022-12-27:</strong> I set up a <a href="https://github.com/ahgamut/cosmo-gcc-plugin/tree/3389ca1afd736af9ba187086d0896e0680312923"><code>gcc</code> plugin</a> that would activate on
<code>PLUGIN_PRE_GENERICIZE</code> and walk through the AST looking for <code>switch</code> statements
to rewrite. Simple enough, seemed like it would work, so I tried the below
example:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>switch</span><span>(</span><span>errval</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>case</span> <span>0</span><span>:</span>
</span></span><span><span>        <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>SIGILL</span><span>:</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;you got a SIGILL</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>        <span>break</span><span>;</span>
</span></span><span><span>    <span>default</span><span>:</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;unknown error</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>But:</p><pre tabindex="0"><code data-lang="gcc">examples/ex1_modded.c: In function ‘exam_func’:
examples/ex1_modded.c:25:5: 
   error: case label does not reduce to an integer constant
   25 |     case SIGILL:
      |     ^~~~
</code></pre><p><code>gcc</code> is still raising an error due to the <code>case</code> label? Why does the plugin not
activate? I check the AST with <code>debug_tree</code>, and <code>case 0:</code> was there:</p><pre tabindex="0"><code>&lt;switch_stmt
   arg:0 &lt;parm_decl errval&gt;
   arg:1 &lt;statement_list type &lt;void_type void&gt;
     stmt &lt;case_label_expr type &lt;void_type void&gt;
         arg:0 &lt;integer_cst constant 0&gt; arg:2 &lt;label_decl D.2390&gt;&gt;
     stmt &lt;break_stmt type &lt;void_type void&gt;&gt;
</code></pre><p>But <code>case SIGILL:</code>?</p><div><pre tabindex="0"><code data-lang="html"><span><span>     stmt <span>&lt;</span><span>call_expr</span> <span>type</span> <span>&lt;</span><span>integer_type</span> <span>int</span><span>&gt;</span>
</span></span><span><span>         side-effects
</span></span><span><span>         fn <span>&lt;</span><span>addr_expr</span> <span>type</span> <span>&lt;</span><span>pointer_type</span><span>&gt;</span>
</span></span><span><span>             constant arg:0 <span>&lt;</span><span>function_decl</span> <span>printf</span><span>&gt;</span>&gt;
</span></span><span><span>         arg:0 <span>&lt;</span><span>nop_expr</span> <span>type</span> <span>&lt;</span><span>pointer_type</span><span>&gt;</span>
</span></span><span><span>           arg:0 <span>&lt;</span><span>addr_expr</span> <span>type</span> <span>&lt;</span><span>pointer_type</span><span>&gt;</span>
</span></span><span><span>             arg:0 <span>&lt;</span><span>string_cst</span> <span>type</span> <span>&lt;</span><span>array_type</span><span>&gt;</span>
</span></span><span><span>                readonly constant static &#34;you got a SIGILL\012\000&#34;&gt;&gt;&gt;
</span></span><span><span>     stmt <span>&lt;</span><span>break_stmt</span> <span>type</span> <span>&lt;</span><span>void_type</span> <span>void</span><span>&gt;</span>&gt;
</span></span></code></pre></div><p>There was no <code>case</code> label to rewrite! I checked my code and all of the build
config for building the plugin, but I always got an invalid AST, and a <code>switch</code>
statement without the (incorrect) <code>case</code> label that I wanted to rewrite.</p><p>After a while watching the errors repeat, I found out that the plugin can access
the AST only <em>after</em> <code>gcc</code> had finished parsing the source file, and the <code>case</code>
label validation happens <em>during</em> the parsing process. I can’t fix the <code>switch</code>
case without knowing the value of the <code>case</code> label, and even then, the error
raised by <code>gcc</code> earlier would still mean the compilation fails.</p><p>Was this the end?</p><h2 id="return-of-the-c-preprocessor">Return of the C preprocessor</h2><p><strong>2023-03-14:</strong> <code>PLUGIN_PRE_GENERICIZE</code> only received an AST after parsing, and
but <code>gcc</code> gave me an invalid AST due to the <code>switch</code> statement. I needed to
ensure a valid AST before I could rewrite it, and one way to interact with the
code before parsing is … with the C preprocessor! Could I interact with the C
preprocessor from within the plugin? Yes! The <code>gcc</code> plugin headers provide a
structure called <code>cpp_reader</code>, within which you can define custom callbacks that
activate when a macro is <code>#define</code>’d, <code>#undef</code>’d, and used! I still don’t
understand exactly how <code>cpp_reader</code> works, but now there was another line of
attack:</p><ul><li>Cosmopolitan Libc (used to) provide macros for system values like below, so
that the <code>#ifdef</code> checks would not complain:</li></ul><div><pre tabindex="0"><code data-lang="c"><span><span><span>extern</span> <span>const</span> <span>int</span> <span>SIGTERM</span><span>;</span>
</span></span><span><span><span>#define SYMBOLIC(X) X
</span></span></span><span><span><span>#define SIGTERM SYMBOLIC(SIGTERM)
</span></span></span></code></pre></div><ul><li>With a custom header file, I could create a temporary value like:</li></ul><div><pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>const</span> <span>int</span> <span>__tmpcosmo_SIGTERM</span> <span>=</span> <span>3141592</span><span>;</span>
</span></span></code></pre></div><ul><li><p>and then within my plugin code, I could <em>intercept the usage of the macro
<code>SYMBOLIC(SIGTERM)</code> and substitute my temporary value instead</em>, so that the
parsing would not error out.</p></li><li><p>Finally, with a valid AST in <code>PLUGIN_PRE_GENERICIZE</code>, I could <em>look up the
specific line of code where I did the interception</em> and rewrite the AST with
the correct <code>VAR_DECL</code> of <code>SIGTERM</code> instead of the temporary value.</p></li></ul><p>Let me repeat: a <code>#define</code> in Cosmopolitan Libc headers, a temporary <code>static const</code> in my custom header, a macro interception in the plugin, followed by an
AST rewrite in the plugin. In terms of code outside the compiler:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// Cosmopolitan Libc provided
</span></span></span><span><span><span></span><span>extern</span> <span>const</span> <span>int</span> <span>ENOSYS</span><span>;</span>
</span></span><span><span><span>#define ENOSYS SYMBOLIC(ENOSYS)
</span></span></span><span><span><span></span><span>// for the plugin-macro-hack
</span></span></span><span><span><span></span><span>static</span> <span>const</span> <span>int</span> <span>__tmpcosmo_ENOSYS</span> <span>=</span> <span>1209372</span><span>;</span>
</span></span><span><span><span>#define SYMBOLIC(ENOSYS) __tmpcosmo_ENOSYS
</span></span></span></code></pre></div><p>Then the plugin would latch on to the temporary constants, and perform the AST
rewrites. It sounds ridiculous, <a href="https://github.com/ahgamut/cosmo-gcc-plugin/commit/8ddce89551eadb6ea19ab843a71876cd75340edc">but it <em>worked</em></a>. Within that
week, I had a plugin that successfully worked around both the <code>switch</code>-<code>case</code>
and the <code>struct</code> initialization errors, which I could verify with a bunch of
simple examples. <strong>2023-03-26:</strong> I got a minimal <a href="https://github.com/ahgamut/cpython/tree/py311-custom">CPython 3.11</a>
building with this macro hack. There were a few issues, but at this point the
experiment had a decent chance of success, so I asked Justine if we could use
this plugin when building software with Cosmopolitan Libc.</p><h2 id="why-not-just-patch-gcc">Why not just patch <code>gcc</code>?</h2><p>The common theme in my discussion with Justine was: now that we know the problem
can be solved, is there a simpler way to solve the problem? She suggested I not
bother using plugin APIs, work on the GCC codebase itself, and simply change
whatever I needed. I was initially hesitant<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>, but the edge cases and
crashes with the macro-hack arrangement got wackier<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup> , due to lots of
extra unnecessary work. Here’s an example:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>extern</span> <span>const</span> <span>int</span> <span>ENOSYS</span><span>;</span>
</span></span><span><span><span>/* for the plugin */</span>
</span></span><span><span><span>static</span> <span>const</span> <span>int</span> <span>__tmpcosmo_ENOSYS</span> <span>=</span> <span>172389</span><span>;</span>
</span></span><span><span><span>#define SYMBOLIC(ENOSYS) __tmpcosmo_ENOSYS
</span></span></span><span><span><span>#define ENOSYS SYMBOLIC(ENOSYS)
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>foo</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>switch</span><span>(</span><span>errno</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>case</span> <span>ENOSYS</span><span>:</span>                        <span>// necessary to rewrite
</span></span></span><span><span><span></span>            <span>int</span> <span>x</span> <span>=</span> <span>ENOSYS</span> <span>+</span> <span>1</span><span>;</span>             <span>// EXTRA WORK
</span></span></span><span><span><span></span>            <span>printf</span><span>(</span><span>&#34;ENOSYS = %d&#34;</span><span>,</span> <span>ENOSYS</span><span>);</span>  <span>// EXTRA WORK
</span></span></span><span><span><span></span>            <span>return</span> <span>x</span><span>;</span>                       <span>// EXTRA WORK
</span></span></span><span><span><span></span>        <span>default</span><span>:</span>
</span></span><span><span>            <span>return</span> <span>0</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The only error that <code>gcc</code> would raise without the plugin is the <code>case ENOSYS</code>,
and the plugin can handle that. However, the macro substitution due to
<code>ACTUALLY(ENOSYS)</code> meant that the plugin also had to handle every other (valid)
use of <code>ENOSYS</code>, which could (hopefully) be avoided by patching <code>gcc</code> instead.</p><p>It took a while to figure out where to add my code into the <code>gcc</code> source tree,
but the overall design of the plugin became simpler. Instead of <code>-fplugin</code>, the
code was now activated with a compiler flag <code>-fportcosmo</code>. To my great relief,
I could delete all my macro-related hacks. Now I could just intercept the parser
error instead: right before <code>gcc</code> raised a <code>case is not constant</code> error, check
if <code>flag_portcosmo</code> is active, and if yes, perform the necessary substitution.
The AST rewriting code was a copy-paste from the plugin, and it was executed
by <code>gcc</code> right before invoking other plugin callbacks.</p><h2 id="porting-software-with-the-patched-gcc">Porting software with the patched <code>gcc</code></h2><p><strong>2023-06-05:</strong> At this stage, the patched <code>gcc</code> was passing all the test cases
I had written for the plugin earlier, and new binaries were added into the
Cosmopolitan Libc monorepo. This allowed for compiling a lot more code, leading
to fixes and improvements. Building <code>lua</code> was now straightforward, and for
<code>python3.11</code> I added some changes to access the ZIP store within the executable.
I found out where <code>g++</code> raised the <code>case constant</code> error so <code>ninja</code> could build.
Then I tried building <code>busybox</code>, but my brain had a segfault with the <a href="https://github.com/mirror/busybox/blob/2d4a3d9e6c1493a9520b907e07a41aca90cdfd94/libbb/u_signal_names.c#L88">below
code</a>:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>const</span> <span>char</span> <span>signals</span><span>[][</span><span>7</span><span>]</span> <span>ALIGN1</span> <span>=</span> <span>{</span>
</span></span><span><span>	<span>[</span><span>0</span><span>]</span> <span>=</span> <span>&#34;EXIT&#34;</span><span>,</span>
</span></span><span><span><span>#ifdef SIGHUP
</span></span></span><span><span><span></span>	<span>[</span><span>SIGHUP</span>   <span>]</span> <span>=</span> <span>&#34;HUP&#34;</span><span>,</span>
</span></span><span><span><span>#endif
</span></span></span><span><span><span>#ifdef SIGINT
</span></span></span><span><span><span></span>	<span>[</span><span>SIGINT</span>   <span>]</span> <span>=</span> <span>&#34;INT&#34;</span><span>,</span>
</span></span><span><span><span>#endif
</span></span></span><span><span><span>#ifdef SIGQUIT
</span></span></span><span><span><span></span>	<span>[</span><span>SIGQUIT</span>  <span>]</span> <span>=</span> <span>&#34;QUIT&#34;</span><span>,</span>
</span></span><span><span><span>#endif
</span></span></span><span><span><span>#ifdef SIGILL
</span></span></span><span><span><span></span>	<span>[</span><span>SIGILL</span>   <span>]</span> <span>=</span> <span>&#34;ILL&#34;</span><span>,</span>
</span></span><span><span><span>#endif
</span></span></span><span><span><span>#ifdef SIGTRAP
</span></span></span><span><span><span></span>	<span>[</span><span>SIGTRAP</span>  <span>]</span> <span>=</span> <span>&#34;TRAP&#34;</span><span>,</span>
</span></span><span><span><span>#endif
</span></span></span></code></pre></div><p>That’s an array of strings, <em>index-initialized by the signal constants</em>, used as
a lookup table, just to convert signal values to strings and back. <strike>Why?
Why not just use a switch statement? What if one of the constants turns out to
be 400000, does <code>gcc</code> allocate a large array with empty
space?</strike> Yeah… my patch can’t handle that, and I don’t want it to.
Anyway, I wanted <a href="https://github.com/ahgamut/cpython/tree/portcosmo">Python3.11</a> to have <code>ncurses</code>, so I tried building
that next. <code>ncurses</code> had <a href="https://github.com/mirror/ncurses/blob/master/ncurses/trace/lib_tracebits.c#L151">something interesting</a>:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>unsigned</span> <span>int</span> <span>val</span><span>;</span>
</span></span><span><span>    <span>const</span> <span>char</span> <span>name</span><span>[</span><span>BITNAMELEN</span><span>];</span>
</span></span><span><span><span>}</span> <span>BITNAMES</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>#define DATA(name)        { name, { #name } }
</span></span></span><span><span><span>#define DATA2(name,name2) { name, { #name2 } }
</span></span></span><span><span><span></span>
</span></span><span><span><span>static</span> <span>const</span> <span>BITNAMES</span> <span>cflags</span><span>[]</span> <span>=</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>	<span>DATA</span><span>(</span><span>CLOCAL</span><span>),</span>
</span></span><span><span>	<span>DATA</span><span>(</span><span>CREAD</span><span>),</span>
</span></span><span><span>	<span>DATA</span><span>(</span><span>CSTOPB</span><span>),</span>
</span></span><span><span><span>#if !defined(CS5) || !defined(CS8)
</span></span></span><span><span><span></span>	<span>DATA</span><span>(</span><span>CSIZE</span><span>),</span>
</span></span><span><span><span>#endif
</span></span></span><span><span><span></span>	<span>DATA</span><span>(</span><span>HUPCL</span><span>),</span>
</span></span><span><span>	<span>DATA</span><span>(</span><span>PARENB</span><span>),</span>
</span></span><span><span>	<span>DATA2</span><span>(</span><span>PARODD</span> <span>|</span> <span>PARENB</span><span>,</span> <span>PARODD</span><span>),</span>
</span></span><span><span>	<span>DATAX</span><span>()</span>
</span></span><span><span><span>#define ALLCTRL	(CLOCAL|CREAD|CSIZE|CSTOPB|HUPCL|PARENB|PARODD)
</span></span></span><span><span><span></span>    <span>};</span>
</span></span></code></pre></div><p>Now <code>PARENB</code> and <code>PARODD</code> were <code>extern const</code> values in
Cosmopolitan Libc, and my patch was fixing the <code>struct</code> initialization for
<code>DATA(PARENB)</code> as expected, but it was getting stuck with:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>// DATA2(PARODD | PARENB, PARODD) evaluates to
</span></span></span><span><span><span></span> <span>{.</span><span>val</span> <span>=</span> <span>PARODD</span> <span>|</span> <span>PARENB</span><span>,</span> <span>.</span><span>name</span> <span>=</span> <span>&#34;PARODD&#34;</span><span>},</span> <span>// unable to rewrite
</span></span></span></code></pre></div><p>The <code>struct</code> initialization for <code>PARODD</code> had a <em>binary expression</em>, instead of
the usual constants, and my patch had no code to handle that. I thought about it
for a while, and decided situations like this would occur frequently enough
where it would be convenient to handle them automatically. I added a change
allowing <code>case</code> labels and <code>struct</code> initializer elements in C<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup> to be
<em>arbitrary expressions</em>, which means you can compile things like:</p><div><pre tabindex="0"><code data-lang="c"><span><span> <span>// C does NOT allow this, but with -fportcosmo...
</span></span></span><span><span><span></span><span>case</span> <span>(</span><span>foo</span><span>(</span><span>SIGTERM</span><span>)</span> <span>+</span> <span>bar</span><span>(</span><span>SIGILL</span><span>))</span><span>:</span>
</span></span><span><span>    <span>break</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>struct</span> <span>toy</span> <span>t</span> <span>=</span> 
</span></span><span><span>    <span>{.</span><span>status</span> <span>=</span> <span>(</span><span>foo</span><span>(</span><span>SIGILL</span><span>)</span> <span>+</span> <span>bar</span><span>(</span><span>ENOSYS</span><span>)),</span> <span>value</span> <span>=</span> <span>22</span><span>};</span>
</span></span></code></pre></div><p>With that, <code>ncurses</code> built without a complaint. Note that the C standard allows
<code>case</code> labels to only be compile-time constants, and my patched compiler will
still raise a warning when you do something like this, but otherwise…</p><p><img src="https://joseph.yiasemides.com/images/patch-gcc/portal_gun.webp" alt="" loading="lazy" decoding="async" width="" height=""/></p><p><code>./configure</code> flags, run <code>make</code> and ... you got it! you f****** got it!</p><h2 id="closing-notes">Closing Notes</h2><p><strong>2023-07-13:</strong> To port software to Cosmopolitan Libc, you just need to convince
the build system. I mentioned this last year, and this <code>gcc</code> patch experiment
was to reduce the amount of convincing you would need to do. One of the
motivations for this experiment was to find an answer to the question “what is
the minimum amount of source code that would need to change in order to port
something to Cosmopolitan Libc?” I am glad to find out that the answer is less
than ten lines in most cases, and could even be zero.</p><p>Of course, my patch isn’t perfect. It can’t handle some anonymous structs,
<code>enum</code>s, <code>const int</code>s, or amazing things like using <code>SIGILL</code> as an array index
within an initializer. Rare compiler crashes may still occur in some weird
<code>static</code> initializations, or if you try stuffing <code>SIGTERM</code> into a <code>static const int8_t</code>. But I’ve spent a good chunk of time removing obvious counterexamples,
and a lot of popular software builds seamlessly. A stringent testing setup will
reveal more things to improve.</p><p>If you prefer, you can still rewrite the <code>switch</code> statements and <code>struct</code>
initializers by hand, but for many cases the compiler can do it for you, and all
that is necessary for a port is to specify the right flags to <code>./configure</code> or
<code>cmake</code>. If you can build your C software statically (bonus points if it builds
with <code>musl</code>), there’s a decent chance it builds with Cosmopolitan Libc right
now. Just try to build it! There are lots of possibilities.</p><hr/></div></div></div>
  </body>
</html>
