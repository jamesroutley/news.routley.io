<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/neelsomani/cuq">Original</a>
    <h1>Show HN: Cuq – Formal Verification of Rust GPU Kernels</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">

<p dir="auto">Rust&#39;s rise as a systems language has extended into GPU programming through projects like Rust-CUDA and rust-gpu, which compile Rust kernels to NVIDIA&#39;s PTX or SPIR-V backends. Yet despite Rust&#39;s strong safety guarantees, there is currently no formal semantics for Rust&#39;s GPU subset, nor any verified mapping from Rust&#39;s compiler IR to PTX&#39;s formally defined execution model.</p>
<p dir="auto">This project introduces the first framework for <strong>formally verifying the semantics of Rust GPU kernels</strong> by translating Rust&#39;s Mid-level Intermediate Representation (MIR) into Coq and connecting it to the existing Coq formalization of the PTX memory model (Lustig et al., ASPLOS 2019).
Rather than modeling Rust&#39;s ownership and borrowing rules directly, this work focuses on defining a mechanized operational semantics for a realistic subset of MIR and establishing memory-model soundness: proving that MIR atomic and synchronization operations compile soundly to PTX instructions under the PTX memory model.</p>
<p dir="auto"><strong>Cuq = CUDA + Coq</strong>.</p>

<ol dir="auto">
<li>
<p dir="auto"><strong>No formal semantics for Rust GPU code:</strong>
Although Rust compilers can emit GPU code via NVVM or SPIR-V, the semantics of such kernels are defined only informally through the compiler&#39;s behavior. There is no mechanized model of MIR execution for GPU targets.</p>
</li>
<li>
<p dir="auto"><strong>Disconnect between high-level Rust and verified GPU models:</strong>
NVIDIA&#39;s PTX memory model has a complete Coq specification, but that model has never been linked to a high-level language. Existing proofs connect only C++ atomics to PTX atomics.</p>
</li>
<li>
<p dir="auto"><strong>MIR as a verification sweet spot:</strong>
MIR is a well-typed SSA IR that preserves Rust&#39;s structured control flow and side-effect information while stripping away syntax. It provides a precise, implementation-independent level at which to define semantics and translate to Coq.</p>
</li>
</ol>

<ol dir="auto">
<li>
<p dir="auto"><strong>Define a mechanized semantics for MIR:</strong>
Implement a Coq formalization of a simplified MIR subset sufficient to express GPU kernels: variable assignment, arithmetic, control flow, memory loads/stores, and synchronization intrinsics.</p>
</li>
<li>
<p dir="auto"><strong>Translate MIR to Coq:</strong>
Develop a translation tool that consumes <code>rustc</code>&#39;s <code>-Z dump-mir</code> output and produces corresponding Gallina definitions. The translation captures MIR basic blocks, terminators, and memory actions as Coq terms.</p>
</li>
<li>
<p dir="auto"><strong>Connect to PTX semantics:</strong>
Use the existing Coq formalization of PTX to define a <em>memory-model correspondence</em> between MIR and PTX traces. The initial goal is to prove <em>soundness</em> in the same sense as Lustig et al. (ASPLOS 2019):</p>
<blockquote>
<p dir="auto">If a MIR kernel is data-race-free under the MIR memory model, its compiled PTX program admits only executions consistent with the PTX memory model.</p>
</blockquote>
</li>
<li>
<p dir="auto"><strong>Property verification:</strong>
Leverage this semantics to verify kernel-level properties such as:</p>
<ul dir="auto">
<li>Absence of divergent barrier synchronization;</li>
<li>Preservation of sequential equivalence (e.g., for reductions or scans);</li>
<li>Conformance to the PTX consistency model under shared-memory interactions.</li>
</ul>
</li>
<li>
<p dir="auto"><strong>Prototype toolchain:</strong>
Deliver a prototype that automatically translates Rust-CUDA kernels into Coq terms, evaluates their semantics within Coq, and interfaces with PTX proofs.</p>
</li>
</ol>

<ul dir="auto">
<li>A <strong>Coq formalization of Rust MIR semantics</strong> for GPU kernels using Rust nightly-2025-03-02.</li>
<li>A <strong>MIR→PTX memory-model correspondence theorem</strong>, establishing soundness of atomic and synchronization operations for a well-defined kernel subset.</li>
<li>A <strong>prototype translator</strong> generating Coq verification artifacts from Rust code.</li>
<li><strong>Case studies</strong> on standard CUDA benchmarks (e.g., SAXPY, reductions) verifying barrier correctness and dataflow soundness.</li>
</ul>

<p dir="auto">While this first phase omits Rust&#39;s ownership and lifetime reasoning, the framework is designed to incorporate it later. Future extensions can integrate ownership types or affine resource logics into the MIR semantics, enabling end-to-end proofs of data-race freedom and alias safety.</p>

<p dir="auto">This project establishes the missing formal bridge between Rust&#39;s compiler infrastructure and the only existing mechanized model of GPU execution.
By defining verified semantics for MIR and connecting it to PTX, it provides the foundation for future CompCert-style verified compilation of GPU code and opens the door to ownership-aware proofs of safety and correctness for massively parallel Rust programs.</p>

<p dir="auto">Rebuild the MIR dumps, translate them into Coq, and check the traces/bridges with:</p>

<p dir="auto">The target performs three steps:</p>
<ol dir="auto">
<li><code>rustc -Z dump-mir=all</code> for <code>examples/saxpy.rs</code> and <code>examples/atomic_flag.rs</code> (writes into <code>mir_dump/</code>).</li>
<li><code>tools/mir2coq.py</code> parses the <code>PreCodegen.after</code> dumps and regenerates <code>coq/examples/{saxpy,atomic_flag}_gen.v</code>.</li>
<li><code>make -C coq all</code> type-checks the MIR semantics, the generated programs, and the MIR→PTX translation lemmas.</li>
</ol>
<p dir="auto">Afterwards you can inspect <code>coq/examples/*_gen.v</code> and re-run <code>Eval compute</code> queries found in <code>coq/MIRTests.v</code> to see the MIR event traces and their PTX images.</p>

<div data-snippet-clipboard-copy-content="examples/*.rs --rustc -Z dump-mir--&gt; mir_dump/*.mir --tools/mir2coq.py--&gt; coq/examples/*_gen.v
        \                                                                 |
         \--&gt; target/*.ptx (optional)                                     v
           Coq build (MIRSyntax + MIRSemantics + Translate + Soundness) -&gt; PTX event traces"><pre><code>examples/*.rs --rustc -Z dump-mir--&gt; mir_dump/*.mir --tools/mir2coq.py--&gt; coq/examples/*_gen.v
        \                                                                 |
         \--&gt; target/*.ptx (optional)                                     v
           Coq build (MIRSyntax + MIRSemantics + Translate + Soundness) -&gt; PTX event traces
</code></pre></div>

<ol dir="auto">
<li>
<p dir="auto">Ensure the Rust nightly and Coq toolchain are available:</p>
<ul dir="auto">
<li><code>rustup toolchain install nightly-2025-03-02</code></li>
<li><code>rustup override set nightly-2025-03-02</code></li>
<li><code>opam install coq</code> (Coq ≥ 8.18)</li>
</ul>
</li>
<li>
<p dir="auto">In every new shell, activate the Coq switch so <code>coq_makefile</code> is on your <code>PATH</code>:</p>

</li>
<li>
<p dir="auto">Run the end-to-end build:</p>

</li>
</ol>

<p dir="auto">Refer to <code>docs/mapping-table.md</code> for the full table. In short:</p>
<ul dir="auto">
<li><code>TyI32</code>/<code>TyU32</code>/<code>TyF32</code> loads and stores become <code>EvLoad</code>/<code>EvStore</code> in PTX with
<code>space_global</code>, relaxed semantics, and the matching <code>mem_ty</code> (<code>MemS32</code>,
<code>MemU32</code>, <code>MemF32</code>).</li>
<li>Acquire loads and release stores attach <code>sem_acquire</code>/<code>sem_release</code> and CTA
scope, mirroring the observed <code>ld.acquire.sys.&lt;ty&gt;</code> and <code>st.release.sys.&lt;ty&gt;</code>.</li>
<li>Barriers translate to <code>EvBarrier scope_cta</code>.</li>
</ul>
<p dir="auto">The translator (<code>coq/Translate.v</code>) and the docs stay in sync via helper
functions <code>mem_ty_of_mir</code> and <code>z_of_val</code>.</p>

<ul dir="auto">
<li>Global memory only; shared-memory scopes and bank conflicts are out of scope.</li>
<li>Non-atomic accesses are relaxed and scope-less; only one acquire/release pair
with SYS scope is modelled.</li>
<li>Floating-point values are treated as raw IEEE-754 bit patterns (<code>Z</code> payloads);
no reasoning about NaNs or rounding edge cases yet.</li>
<li>Translator handles a curated subset of MIR (no arbitrary control flow, panic
paths, or complex intrinsics).</li>
</ul>

<ol dir="auto">
<li>Extend the translator grammar to cover additional MIR statements
(comparisons, guards, simple loops/barriers) while preserving determinism.</li>
<li>Enrich the PTX shim with reads-from / coherence relations from the PTX Coq
model.</li>
<li>Prove the remaining per-event lemmas (<code>Load_ok</code>, <code>Store_ok</code>) and lift the
<code>translate_trace_shape</code> property toward an end-to-end soundness theorem.</li>
<li>Integrate shared-memory scope tags and CTA-wide fences, then revisit
atomics/fences beyond acquire-release.</li>
</ol>
</article></div></div>
  </body>
</html>
