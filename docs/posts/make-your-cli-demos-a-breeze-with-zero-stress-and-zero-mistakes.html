<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://martinheinz.dev/blog/94">Original</a>
    <h1>Make your CLI demos a breeze with zero stress and zero mistakes</h1>
    
    <div id="readability-page-1" class="page"><article><div><div><!--[--><p> Running live demos can be stressful. You know what you want to say and show. You prepare the CLI commands you want to run to best showcase what you&#39;ve built, but then you waste time typing long commands; you make typos; the commands fail or take way too long to complete. Maybe they depend on external system (network, APIs, cloud, ...) and <i>of course</i> it&#39;s not cooperating while you&#39;re running your live demo. </p><p> Here&#39;s how you can avoid all of the above by scripting, automating and recording your demos, so that you never have to stress about showcasing ever again... </p><p><i>Note: All the scripts and code are made available in <a href="https://github.com/MartinHeinz/cli-showcase-setup">this repository</a>.</i></p><h2>The Script</h2><p> It&#39;s easy to forget some of the things that you want to show or say during showcase, so you might want to write a script - both in the &#34;theatre&#34; and &#34;programming&#34; sense of the word. </p><p> Just writing things down and following this <i>script</i> can make a showcase much smoother, but why not go a step further and make it an actual runnable script? </p><p> There are a couple tools you could use for this. We will talk about two - <a href="https://github.com/paxtonhare/demo-magic"><code>demo-magic</code></a> and <a href="https://github.com/saschagrunert/demo">https://github.com/saschagrunert/demo</a>. </p><p> The former is a simple, yet powerful set of <code>bash</code> functions and helpers which you can use to automate your demos/showcases as a shell script. To install it, run the following: </p><pre><code>
git clone https://github.com/paxtonhare/demo-magic.git
mkdir demo  # Create a working dir for showcase
cp demo-magic/demo-magic.sh demo/demo-magic.sh  # Copy the helpers

# Install &#34;Pipe Viewer&#34; for simulated typing
# MacOS:
brew install pv

# Ubuntu:
apt-get install pv

# Move to showcase directory and create your &#34;script&#34;
cd demo
touch sample.sh
chmod +x sample.sh
</code></pre><p> Now we just need to write our <i>script</i>, which will live in the <code>demo/sample.sh</code> file: </p><pre><code>
#!/bin/bash

# Include the &#34;demo-magic&#34; helpers
source demo-magic.sh

DEMO_PROMPT=&#34;${GREEN}âžœ ${CYAN}\W ${COLOR_RESET}&#34;
TYPE_SPEED=30

function comment() {
  cmd=$DEMO_COMMENT_COLOR$1$COLOR_RESET
  echo -en &#34;$cmd&#34;; echo &#34;&#34;
}

clear

comment &#34;# Simple commands:&#34;
pe &#39;ps aux | head&#39;
pe &#39;ls -l&#39;

comment &#34;# Print and execute immediately&#34;
pei &#39;cat some-file&#39;
echo

comment &#34;# Long running:&#34;
pe &#39;docker build -t some-app .&#39;

comment &#34;# Error prone (dependant on external factors like network):&#34;

pe &#39;curl --silent -X GET https://httpstat.us/418 -H &#34;Accept: application/json&#34; | jq .&#39;

pe &#39;curl -i -X POST &#34;https://httpbin.org/status/204&#34; --data &#34;{&#39;some&#39;:&#39;data&#39;}&#34;&#39;

pe &#39;wget -q --show-progress -O some-file.txt https://raw.githubusercontent.com/octocat/Hello-World/master/README&#39;

comment &#34;# Hard to type:&#34;

pe &#39;openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 -nodes -keyout example.key -out example.crt -subj &#34;/CN=example.com&#34; -addext &#34;subjectAltName=DNS:example.com,DNS:www.example.net,IP:10.0.0.1&#34; 2&gt;/dev/null&#39;

comment &#34;#  Enter interactive mode...&#34;
cmd  # Run &#39;ls -l | grep example&#39; to show result of &#39;openssl ...&#39;
</code></pre><p> Let&#39;s go over what&#39;s going on here - we start by including the <code>demo-magic.sh</code> so that we can use its helper functions (<code>pe</code>, <code>pei</code> and <code>cmd</code>). Next we configure the prompt and simulated typing speed, and we also add a helper function of our own - <code>comment</code> - which simply prints text without executing it, so that we can describe the commands we&#39;re showing. </p><p> Then comes the actual script - after clearing the terminal we run series of commands using <code>pe</code> and <code>pei</code>. Both of these print and execute the specified command, but the former waits for <i>enter</i> and latter executes immediately. If you want to include an interactive section in your demo, then you can also use <code>cmd</code> command, which lets you type out and run single command before proceeding with rest of the script. </p><p> And running the above example would result in something like this: </p><p><img src="https://raw.githubusercontent.com/MartinHeinz/cli-showcase-setup/master/samples/sample-demo-magic-small-compressed.gif" alt="demo-magic"/></p><p> The other tool I mentioned is <a href="https://github.com/saschagrunert/demo">https://github.com/saschagrunert/demo</a>, which uses Golang to build the script instead of shell (you decide whether that belongs into pros or cons column). Therefore, to use it we need to create a Golang project. First create a <code>go.mod</code> file: </p><pre><code>
# go.mod
module cli-demo

go 1.20
</code></pre><p> And install the tool from GitHub: </p><pre><code>
go get github.com/saschagrunert/demo@latest
</code></pre><p> Then create a <code>main.go</code> file which will become your demo script: </p><pre><code>
package main

import (
 demo &#34;github.com/saschagrunert/demo&#34;
 &#34;github.com/urfave/cli/v2&#34;
)

func main() {
 d := demo.New()
 d.Add(simple(), &#34;simple&#34;, &#34;Simple commands demo&#34;)
 d.Run()
}

func simple() *demo.Run {
 r := demo.NewRun(
  &#34;Simple commands demo&#34;,
 )
 r.Step(demo.S(
  &#34;Simple commands:&#34;,
 ), nil)
 r.Step(nil, demo.S(
  &#34;ls -l&#34;,
 ))
 r.Step(nil, demo.S(
  &#34;cat some-file&#34;,
 ))

 return r
}
</code></pre><p> In <code>main</code> function we instantiate the demo and add (<code>Add(...)</code>) demo runs to it. In this case we only add single run named <code>simple</code>, but you can use the <code>Add</code> function multiple times. In the demo run function we create individual steps using <code>r.Step(demo.S(...))</code>, where first and second parameter represent comment and CLI command respectively. Either of these can be omitted if you only want to print comment/command. </p><p> Now you can build it and run it: </p><pre><code>
go build
./cli-demo --all
</code></pre><p> And again, a complete example would look like so: </p><p><img src="https://raw.githubusercontent.com/MartinHeinz/cli-showcase-setup/master/samples/sample-golang-demo-small-compressed.gif" alt="CLI Showcase"/></p><p> To keep things concise and readable, I didn&#39;t include the full code used to create the above GIF, but you can find it <a href="https://github.com/MartinHeinz/cli-showcase-setup/blob/master/main.go">here</a>. </p><p> One advantage of this tool over <code>demo-magic</code> are that it includes <i>setup</i> and <i>teardown</i> functions, so you can easily prepare and destroy the environment of your demo. It also produces a executable which can be useful for distributing the demo. On the other hand though, this tool doesn&#39;t have an option for customizing prompt or changing speed of simulated typing, with that said the whole code is less than 300 lines, so you could add these features quite easily. </p><h2>Recording</h2><p> Most of the time you might be satisfied with a runnable script. You will use it once during a live demo/showcase and never touch it again. However, in some cases, you might want to (pre)record the demo and share it. For example, so you can add an example GIF to a GitHub repository. For that you can use tool called <a href="https://github.com/faressoft/terminalizer"><code>terminalizer</code></a>. </p><p> Nice thing about this tool is that it doesn&#39;t record an actual video of your screen/window, rather it generates a YAML file based on what you type in terminal. This file can be then adjusted/fixed, so can do some &#34;post-processing&#34; - such as removing frames - just by changing the generated YAML before rendering GIF from it. </p><p> To install it, run: </p><pre><code>
# You might need &#39;sudo&#39;
npm install -g terminalizer

terminalizer init
# The global config directory is created at
# /home/martin/.terminalizer
</code></pre><p> After installing with <code>npm</code>, we initialize <code>terminalizer</code> which creates a global configuration file at <code>/home/user/.terminalizer/config.yaml</code>. You can leave the config as is, but I recommend adjusting some options: </p><pre><code>
frameDelay: 150
# If you want to force size of window
cols: 140
rows: 75

frameBox:
  type: floating
  title: &lt;Demo Specific&gt;  # or null
  style:
    backgroundColor: &#34;#263238&#34;
    border: 0px black solid

theme:
  background: &#34;transparent&#34;
  foreground: &#34;#afafaf&#34;
  cursor: &#34;#c7c7c7&#34;
  black: &#34;#2E3436&#34;
  red: &#34;#CC0000&#34;
  # ...
</code></pre><p> As I mentioned, <code>terminalizer</code> only records strokes, not the actual screen, so this config allows us to change styling of the final render, including color scheme, window size, etc. </p><p> By default, <code>terminalizer</code> will use same pauses between strokes/typing as was during recording, which might mean that there will be unnecessarily long or short pauses. To fix that we can change <code>frameDelay</code> value to specific number of milliseconds between each frame. </p><p> Another configuration you might want to change is <code>framebox</code>, which sets terminal window title, size and style. Finally, I also like to set <code>theme</code> to the same color palette, which I use in the actual terminal. </p><p> If you want some inspiration, then my configuration can be found <a href="https://github.com/MartinHeinz/cli-showcase-setup/blob/master/config.yaml">here</a>. </p><p> With global config ready, we can run <code>terminalizer config</code> which will copy the default config into current directory. We can then record our demo in this directory without making changes to the default config: </p><pre><code>
terminalizer record demo --config config.yaml

# ... perform the demo commands

# CTRL+D to stop recording...

# Successfully Recorded
# The recording data is saved into the file:
# /home/.../demo.yml

# ---------

terminalizer play demo

# https://github.com/faressoft/terminalizer/issues/29
# sudo chown -R &lt;YOUR_USERNAME&gt; /usr/lib/node_modules/terminalizer/render/
terminalizer render demo
# ...
# Successfully Rendered
# The animated GIF image is saved into the file:
# /.../render1677937002675.gif
</code></pre><p> Running <code>terminalizer record demo</code> will start screen (keystroke) recording and hitting <code>CTRL+D</code> will stop and save the results into <code>./demo.yaml</code>. You can then use <code>terminalizer play demo</code> to replay the demo right in the terminal as if you were typing it. Afterwards, when you&#39;re satisfied with the recording, you can run <code>terminalizer render demo</code> which will render a GIF using the style configuration in <code>config.yaml</code>. </p><p> To then combine the scripting and recording into one piece you can do something like this (that is - my preferred workflow): </p><pre><code>
# ... Edit &#39;main.go&#39;
go build
# OR
cp template.sh my-cool-demo.sh
# Edit &#39;my-cool-demo.sh&#39;

# -----

# Start recording:
terminalizer record demo
# Start scripted demo:
./cli-demo --all -i
# OR
./my-cool-demo.sh
# ... Go through the demo
# CTRL+D
terminalizer play demo  # To check
# ... Adjust demo.yml
terminalizer render demo  # To render
</code></pre><p> The GIFs that this will produce can be pretty big - in my case upwards of 40MBs - so you might want to use <code>--step N</code> argument with the <code>render</code> command to skip some frames. Alternatively, you can also run it through <a href="https://gifcompressor.com/">https://gifcompressor.com/</a>. </p><p> Finally, while rendering GIFs has been so far sufficient for me, you might also want render videos, which <code>terminalizer</code> can&#39;t do - for that I recommend checking out <a href="https://asciinema.org/">asciinema</a> which renders output that is closer to a proper video format. </p><h2>Conclusion</h2><p> While point of this article was to provide a way to make your showcases and demos a little less stressful and smoother, another big benefit of using these tools is better quality - running a cool, impressive, fancy demo can make a big difference. Having a fancy showcase can keep audience engaged and can help you leave a good impression even if you&#39;re showcasing something boring. </p><!--]--></div></div></article></div>
  </body>
</html>
