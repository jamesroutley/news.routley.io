<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nickdrozd.github.io/2026/01/16/ai-lin-busy-beaver.html">Original</a>
    <h1>AI Reproduction of Lin’s Busy Beaver Proof</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Does anybody care about “look what AI can do” posts anymore? <strong>We’re <a href="https://nickdrozd.github.io/2025/12/31/goalposts.html">running out of places to move the goalposts to</a>, but expectations are adjusting quickly.</strong> What would have been a huge breakthrough a year ago is a yawn today. Given that <a href="https://github.com/teorth/erdosproblems/wiki/AI-contributions-to-Erd%C5%91s-problems">AI is solving open math problems</a>, this little piece of news might not seem very exciting, but I figured I would share it anyway. Namely: <strong>ChatGPT is able to reproduce <a href="https://nickdrozd.github.io/2020/12/15/lin-rado-proof.html">Shen Lin’s 1963 Busy Beaver proof</a></strong>.</p>

<p>The Busy Beaver problem asks: what is the longest that a <strong>Turing machine program</strong> of <em>N</em> states can run before halting when started on the blank tape? This problem is <strong>uncomputable</strong>, which is to say that there is no general method for determining <em>BB(N)</em> for all values of <em>N</em>. Even proving Busy Beaver for small values of <em>N</em> is difficult. The problem was first posed in 1962, but <strong><a href="https://arxiv.org/abs/2509.12337v1">the value of <em>BB(5)</em> was not proved until 2024</a></strong>.</p>

<p>Proving that <em>BB(N) = K</em> requires enumerating all <em>N</em>-state Turing machine programs and proving of each one that it either halts with <em>K</em> steps or does not halt at all. This is <strong>difficult</strong> because 1) the number of programs to check increases <strong>exponentially</strong> with <em>N</em> and 2) individual program complexity increases in some unspecified-but-substantial quantity with <em>N</em>. In other words, the basic structure of a Busy Beaver proof is a <strong>conjunction of individual program proofs</strong>, and as <em>N</em> grows the length of the conjunction explodes and the proofs get all harder.</p>

<p>Lin’s proof that <em>BB(3) = 21</em> works as follows. First, observe that we can <strong>prune the search space</strong> substantially by normalizing the first program instruction to <code>A0:1RB</code> (a limited form of <strong><a href="https://nickdrozd.github.io/2022/01/14/bradys-algorithm.html">Brady’s algorithm</a></strong>), leaving 80,000 or so programs to check. Next, run all of these for 21 steps, since it is known by explicit witness that <em>BB(3) ≥ 21</em>. Then run all remaining programs for 50 steps and check for rudimentary <strong>looping behavior</strong>: either getting stuck in place going back and forth or getting stuck doing the same thing moving off to the left or right. As it happens almost all 3-state non-halting programs end up in this condition, now known as <strong><a href="https://nickdrozd.github.io/2021/02/24/lin-recurrence-and-lins-algorithm.html">Lin recurrence</a></strong>. This leaves exactly <strong>40 holdouts</strong> that Lin claimed to have analyzed by hand and verified not to halt.</p>

<p>This is all laid out in <strong><a href="https://etd.ohiolink.edu/acprod/odb_etd/ws/send_file/send?accession=osu1486554418657614&amp;disposition=inline">Lin’s dissertation</a></strong>. No code is provided; all methods and algorithms are described in English. It has been argued in the past that is not a very precise way of doing things, since it makes the result difficult to reproduce. On the other hand, I doubt including a bunch of <strong><a href="https://nickdrozd.github.io/2021/12/08/busy-beaver-hardware.html">IBM 7090 machine code</a></strong> would have helped to elucidate anything. Besides, English is a good-enough method of describing algorithms, and I can attest that I was personally able to reproduce the results myself. Which is to say, I wrote some code (in Python) according to Lin’s descriptions and that code was able to reproduce the exact same 40 holdouts listed.</p>

<p>Reproduction of results in this case was possible, but not so easy. For one thing, the recurrence algorithm is just a <strong>minefield of off-by-one errors</strong>, and it is tricky to get it right. For another thing, it requires reading through the whole text and figuring out the author’s <strong>ad-hoc conventions for Turing machine program notation</strong>, which are different from what is used today. Lin identifies programs using 8-digit octal “serial numbers” (I guess so it could fit within a “machine word”), so even reading this holdout list requires a decoding procedure. Overall, the whole thing took some doing. Wouldn’t it be nice if the drudgery could be automated?</p>

<p>Yes, well, <strong>ChatGPT can do it now</strong>. Just give it the PDF along with some prompts: “discuss problem, methods, and results” and “want to reproduce result. produce single c file containing whole pipeline. program enumeration, pruning, etc according to lin’s methods”. It didn’t get it right on the first try or the second, but by the third try it did indeed produce a single C file that runs enumeration and filtering, ending up with the correct 40 holdouts. It even got the serial number scheme right (although initially it got the nybbles backwards). The whole thing took about a half hour.</p>

<p>I’ll include the code in full below, if anyone wants to verify it. But first, a <strong>challenge / prediction</strong>. Lin’s proof of <em>BB(3)</em> is ultimately pretty straightforward. <strong><a href="https://arxiv.org/pdf/2509.12337">The recent proof of <em>BB(5)</em></a></strong> is quite a bit more involved, with a variety of separate decider components. <strong><em>I believe it is now or will soon be possible to implement the whole thing from start to finish in a single C file just from the PDF.</em></strong> Other languages could be used. <strong>Lean</strong> would be an especially good choice. This might be a <strong>fun challenge</strong> for anyone looking to work on an AI project.</p>

<p>Anyway, here is the C code that implements Lin’s proof. I didn’t write any of it. <strong>Take a look with fair-minded skepticism.</strong></p>

<figure><pre><code data-lang="c"><span>// lin_bb3.c</span>
<span>// Reproduce Shen Lin (1963) BB-3 (3-card binary) normalized search pipeline.</span>
<span>//</span>
<span>// This single-file program implements:</span>
<span>//   1) Lin&#39;s normalized enumeration: 4 lots x 12^4 = 82,944 machines.</span>
<span>//      Fixed lines: Card1-0 = 112, and the unique stop-line = 110.</span>
<span>//   2) Discard machines that stop in &lt;= 21 shifts (recording scores).</span>
<span>//   3) Lin&#39;s &#34;obvious&#34; pruning rules for some lots.</span>
<span>//   4) Lin&#39;s PARTIAL RECURRENCE routine (36-bit tape word, start square at bit 18)</span>
<span>//      exactly as described in Chapter III.</span>
<span>//   5) Print remaining &#34;holdouts&#34; in standard TM program notation:</span>
<span>//         A0 A1  B0 B1  C0 C1</span>
<span>//      e.g. 1RB 1RH  0LC 0RA  1LA 1LB</span>
<span>//</span>
<span>// Build:</span>
<span>//   gcc -O3 -std=c11 -Wall -Wextra lin_bb3.c -o lin_bb3</span>
<span>// Run:</span>
<span>//   ./lin_bb3</span>
<span>//</span>
<span>// References (from Lin dissertation PDF):</span>
<span>// - Normalization to 82,944 and lots, stop&lt;=21 phase: see Chapter III. fileciteturn16file2L13-L22</span>
<span>// - Partial recurrence routine formulas and 50-shift bound, spill check: fileciteturn16file3L1-L20</span>
<span>// - Barrier intuition: compare tape between barriers / drifting recurrence: fileciteturn16file0L11-L15</span>

<span>#include</span> <span>&lt;stdio.h&gt;</span><span>
#include</span> <span>&lt;stdint.h&gt;</span><span>
#include</span> <span>&lt;stdlib.h&gt;</span><span>
#include</span> <span>&lt;string.h&gt;</span><span>
</span>
<span>#define NUM_LINES 6
#define NUM_LOTS 4
#define MAX_STOP_SCAN 21
#define MAX_REC_SHIFTS 50
</span>
<span>// Full tape for accurate scoring in the &lt;=21 shift scan</span>
<span>#define TAPE_SIZE 4096
#define TAPE_MID  (TAPE_SIZE/2)
</span>
<span>// 36-bit tape word used by Lin&#39;s recurrence routine</span>
<span>#define WORD_BITS 36
#define START_BIT 18          // starting square at bit 18 fileciteturn16file0L18-L19
#define DEV_LIMIT 17          // spill when |deviation| &gt; 17 fileciteturn16file3L11-L14
#define WORD_MASK ((uint64_t)((1ULL&lt;&lt;WORD_BITS)-1ULL))
</span>
<span>// --- Bit-numbering conventions (compile-time tunable) ---</span>
<span>// Lin&#39;s text uses expressions like &#34;T shifted left 18 + D bits&#34; fileciteturn16file3L1-L3.</span>
<span>// Different machines/notations may number bits MSB-&gt;LSB or LSB-&gt;MSB.</span>
<span>// To reproduce Lin&#39;s counts, we keep the mapping explicit:</span>
<span>//   - deviation d corresponds to bit position BITPOS(d) within the 36-bit word.</span>
<span>//   - the &#34;shift left&#34; operation used in comparisons is SHIFT36(word, k).</span>

<span>#ifndef BITPOS
</span><span>// Default: bit index = START_BIT + deviation (so D=0 is bit 18)</span>
<span>#define BITPOS(d) (START_BIT + (d))
#endif
</span>
<span>#ifndef SHIFT36
</span><span>// Default: C-style logical left shift within 36-bit width</span>
<span>#define SHIFT36(word, k) (shl36((word), (k)))
#endif
</span>
<span>#ifndef PRINT_HOLDOUTS
#define PRINT_HOLDOUTS 1
#endif
</span>
<span>#ifndef SHIFT36
#define SHIFT36(w, k) shift_left36((w), (k))
#endif
</span>
<span>static</span> <span>inline</span> <span>int</span> <span>line_index</span><span>(</span><span>int</span> <span>card</span> <span>/*1..3*/</span><span>,</span> <span>int</span> <span>sym</span> <span>/*0/1*/</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>card</span><span>-</span><span>1</span><span>)</span><span>*</span><span>2</span> <span>+</span> <span>sym</span><span>;</span>
<span>}</span>

<span>// Lin&#39;s 4-bit line encoding: [p][s][c1][c0]</span>
<span>static</span> <span>inline</span> <span>uint8_t</span> <span>enc_line</span><span>(</span><span>uint8_t</span> <span>p</span><span>,</span> <span>uint8_t</span> <span>s</span><span>,</span> <span>uint8_t</span> <span>c</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>uint8_t</span><span>)((</span><span>p</span><span>&lt;&lt;</span><span>3</span><span>)</span> <span>|</span> <span>(</span><span>s</span><span>&lt;&lt;</span><span>2</span><span>)</span> <span>|</span> <span>(</span><span>c</span> <span>&amp;</span> <span>3</span><span>));</span>
<span>}</span>
<span>static</span> <span>inline</span> <span>uint8_t</span> <span>get_p</span><span>(</span><span>uint8_t</span> <span>w</span><span>)</span> <span>{</span> <span>return</span> <span>(</span><span>w</span><span>&gt;&gt;</span><span>3</span><span>)</span><span>&amp;</span><span>1</span><span>;</span> <span>}</span>
<span>static</span> <span>inline</span> <span>uint8_t</span> <span>get_s</span><span>(</span><span>uint8_t</span> <span>w</span><span>)</span> <span>{</span> <span>return</span> <span>(</span><span>w</span><span>&gt;&gt;</span><span>2</span><span>)</span><span>&amp;</span><span>1</span><span>;</span> <span>}</span>
<span>static</span> <span>inline</span> <span>uint8_t</span> <span>get_c</span><span>(</span><span>uint8_t</span> <span>w</span><span>)</span> <span>{</span> <span>return</span> <span>w</span> <span>&amp;</span> <span>3</span><span>;</span> <span>}</span>

<span>// 12 possible non-stop cases for a free line: p∈{0,1}, s∈{0,1}, c∈{1,2,3}</span>
<span>static</span> <span>void</span> <span>gen_12_cases</span><span>(</span><span>uint8_t</span> <span>cases12</span><span>[</span><span>12</span><span>])</span> <span>{</span>
    <span>int</span> <span>t</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>uint8_t</span> <span>p</span><span>=</span><span>0</span><span>;</span><span>p</span><span>&lt;=</span><span>1</span><span>;</span><span>p</span><span>++</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>uint8_t</span> <span>s</span><span>=</span><span>0</span><span>;</span><span>s</span><span>&lt;=</span><span>1</span><span>;</span><span>s</span><span>++</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>uint8_t</span> <span>c</span><span>=</span><span>1</span><span>;</span><span>c</span><span>&lt;=</span><span>3</span><span>;</span><span>c</span><span>++</span><span>)</span> <span>{</span>
                <span>cases12</span><span>[</span><span>t</span><span>++</span><span>]</span> <span>=</span> <span>enc_line</span><span>(</span><span>p</span><span>,</span><span>s</span><span>,</span><span>c</span><span>);</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>// Build normalized machine for a given lot, with 4 free lines</span>
<span>static</span> <span>void</span> <span>build_machine_for_lot</span><span>(</span><span>int</span> <span>lot</span><span>,</span> <span>const</span> <span>uint8_t</span> <span>free4</span><span>[</span><span>4</span><span>],</span> <span>uint8_t</span> <span>out</span><span>[</span><span>NUM_LINES</span><span>])</span> <span>{</span>
    <span>// initialize with a placeholder non-stop line</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span><span>=</span><span>0</span><span>;</span><span>i</span><span>&lt;</span><span>NUM_LINES</span><span>;</span><span>i</span><span>++</span><span>)</span> <span>out</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>enc_line</span><span>(</span><span>0</span><span>,</span><span>0</span><span>,</span><span>1</span><span>);</span>

    <span>// fixed Card1-0 line = 112</span>
    <span>out</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>enc_line</span><span>(</span><span>1</span><span>,</span><span>1</span><span>,</span><span>2</span><span>);</span>

    <span>// determine stop-line index per lot</span>
    <span>// Lot1: Card1-1</span>
    <span>// Lot2: Card2-1</span>
    <span>// Lot3: Card3-0</span>
    <span>// Lot4: Card3-1</span>
    <span>int</span> <span>stop_idx</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
    <span>if</span> <span>(</span><span>lot</span> <span>==</span> <span>1</span><span>)</span> <span>stop_idx</span> <span>=</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span><span>lot</span> <span>==</span> <span>2</span><span>)</span> <span>stop_idx</span> <span>=</span> <span>3</span><span>;</span>
    <span>if</span> <span>(</span><span>lot</span> <span>==</span> <span>3</span><span>)</span> <span>stop_idx</span> <span>=</span> <span>4</span><span>;</span>
    <span>if</span> <span>(</span><span>lot</span> <span>==</span> <span>4</span><span>)</span> <span>stop_idx</span> <span>=</span> <span>5</span><span>;</span>

    <span>// stop-line fixed to 110</span>
    <span>out</span><span>[</span><span>stop_idx</span><span>]</span> <span>=</span> <span>enc_line</span><span>(</span><span>1</span><span>,</span><span>1</span><span>,</span><span>0</span><span>);</span>

    <span>// assign remaining 4 lines in deterministic order:</span>
    <span>// all indices except 0 and stop_idx</span>
    <span>int</span> <span>k</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span><span>=</span><span>0</span><span>;</span><span>i</span><span>&lt;</span><span>NUM_LINES</span><span>;</span><span>i</span><span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>i</span><span>==</span><span>0</span> <span>||</span> <span>i</span><span>==</span><span>stop_idx</span><span>)</span> <span>continue</span><span>;</span>
        <span>out</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>free4</span><span>[</span><span>k</span><span>++</span><span>];</span>
    <span>}</span>
<span>}</span>

<span>// Lin&#39;s &#34;obvious&#34; pruning rules</span>
<span>// Lot1: discard if no call to Card1 appears in Cards 2 and 3</span>
<span>// Lots3&amp;4: discard if no call to Card3 appears in Cards 1 and 2</span>
<span>// (as stated in Chapter III results discussion) fileciteturn10file0L365-L366</span>
<span>static</span> <span>int</span> <span>prune_obvious</span><span>(</span><span>int</span> <span>lot</span><span>,</span> <span>const</span> <span>uint8_t</span> <span>lines</span><span>[</span><span>NUM_LINES</span><span>])</span> <span>{</span>
    <span>if</span> <span>(</span><span>lot</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
        <span>// among Card2/3 lines (idx2..5), check any c==1</span>
        <span>for</span> <span>(</span><span>int</span> <span>i</span><span>=</span><span>2</span><span>;</span><span>i</span><span>&lt;=</span><span>5</span><span>;</span><span>i</span><span>++</span><span>)</span> <span>if</span> <span>(</span><span>get_c</span><span>(</span><span>lines</span><span>[</span><span>i</span><span>])</span> <span>==</span> <span>1</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>lot</span> <span>==</span> <span>3</span> <span>||</span> <span>lot</span> <span>==</span> <span>4</span><span>)</span> <span>{</span>
        <span>// among Card1-1 (idx1) and Card2 lines (idx2,idx3), check any c==3</span>
        <span>if</span> <span>(</span><span>get_c</span><span>(</span><span>lines</span><span>[</span><span>1</span><span>])</span> <span>==</span> <span>3</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
        <span>if</span> <span>(</span><span>get_c</span><span>(</span><span>lines</span><span>[</span><span>2</span><span>])</span> <span>==</span> <span>3</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
        <span>if</span> <span>(</span><span>get_c</span><span>(</span><span>lines</span><span>[</span><span>3</span><span>])</span> <span>==</span> <span>3</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>// --- TM program notation printer ---</span>
<span>// Card1=A, Card2=B, Card3=C, stop=H</span>
<span>static</span> <span>char</span> <span>state_letter</span><span>(</span><span>uint8_t</span> <span>c</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>c</span><span>==</span><span>0</span><span>)</span> <span>return</span> <span>&#39;H&#39;</span><span>;</span>
    <span>if</span> <span>(</span><span>c</span><span>==</span><span>1</span><span>)</span> <span>return</span> <span>&#39;A&#39;</span><span>;</span>
    <span>if</span> <span>(</span><span>c</span><span>==</span><span>2</span><span>)</span> <span>return</span> <span>&#39;B&#39;</span><span>;</span>
    <span>return</span> <span>&#39;C&#39;</span><span>;</span>
<span>}</span>

<span>static</span> <span>void</span> <span>line_to_tm</span><span>(</span><span>uint8_t</span> <span>w</span><span>,</span> <span>char</span> <span>out</span><span>[</span><span>4</span><span>])</span> <span>{</span>
    <span>// out: e.g. &#34;1RB&#34;</span>
    <span>out</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>(</span><span>char</span><span>)(</span><span>&#39;0&#39;</span> <span>+</span> <span>get_p</span><span>(</span><span>w</span><span>));</span>
    <span>out</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>get_s</span><span>(</span><span>w</span><span>)</span> <span>?</span> <span>&#39;R&#39;</span> <span>:</span> <span>&#39;L&#39;</span><span>;</span>
    <span>out</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>state_letter</span><span>(</span><span>get_c</span><span>(</span><span>w</span><span>));</span>
    <span>out</span><span>[</span><span>3</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
<span>}</span>

<span>static</span> <span>inline</span> <span>uint32_t</span> <span>lin_serial24_from_lines</span><span>(</span><span>const</span> <span>uint8_t</span> <span>L</span><span>[</span><span>6</span><span>])</span> <span>{</span>
    <span>// L order must be: A0 A1 B0 B1 C0 C1</span>
    <span>return</span> <span>((</span><span>uint32_t</span><span>)(</span><span>L</span><span>[</span><span>0</span><span>]</span> <span>&amp;</span> <span>0xF</span><span>)</span> <span>&lt;&lt;</span> <span>20</span><span>)</span> <span>|</span>
           <span>((</span><span>uint32_t</span><span>)(</span><span>L</span><span>[</span><span>1</span><span>]</span> <span>&amp;</span> <span>0xF</span><span>)</span> <span>&lt;&lt;</span> <span>16</span><span>)</span> <span>|</span>
           <span>((</span><span>uint32_t</span><span>)(</span><span>L</span><span>[</span><span>2</span><span>]</span> <span>&amp;</span> <span>0xF</span><span>)</span> <span>&lt;&lt;</span> <span>12</span><span>)</span> <span>|</span>
           <span>((</span><span>uint32_t</span><span>)(</span><span>L</span><span>[</span><span>3</span><span>]</span> <span>&amp;</span> <span>0xF</span><span>)</span> <span>&lt;&lt;</span>  <span>8</span><span>)</span> <span>|</span>
           <span>((</span><span>uint32_t</span><span>)(</span><span>L</span><span>[</span><span>4</span><span>]</span> <span>&amp;</span> <span>0xF</span><span>)</span> <span>&lt;&lt;</span>  <span>4</span><span>)</span> <span>|</span>
           <span>((</span><span>uint32_t</span><span>)(</span><span>L</span><span>[</span><span>5</span><span>]</span> <span>&amp;</span> <span>0xF</span><span>)</span> <span>&lt;&lt;</span>  <span>0</span><span>);</span>
<span>}</span>

<span>static</span> <span>inline</span> <span>void</span> <span>print_lin_serial_octal_from_lines</span><span>(</span><span>const</span> <span>uint8_t</span> <span>L</span><span>[</span><span>6</span><span>])</span> <span>{</span>
    <span>printf</span><span>(</span><span>&#34;%08o&#34;</span><span>,</span> <span>lin_serial24_from_lines</span><span>(</span><span>L</span><span>));</span>
<span>}</span>

<span>static</span> <span>void</span> <span>print_machine_tm</span><span>(</span><span>const</span> <span>uint8_t</span> <span>lines</span><span>[</span><span>NUM_LINES</span><span>])</span> <span>{</span>
    <span>printf</span><span>(</span><span>&#34;Serial=&#34;</span><span>);</span>
    <span>print_lin_serial_octal_from_lines</span><span>(</span><span>lines</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;  &#34;</span><span>);</span>
    <span>char</span> <span>a0</span><span>[</span><span>4</span><span>],</span> <span>a1</span><span>[</span><span>4</span><span>],</span> <span>b0</span><span>[</span><span>4</span><span>],</span> <span>b1</span><span>[</span><span>4</span><span>],</span> <span>c0</span><span>[</span><span>4</span><span>],</span> <span>c1</span><span>[</span><span>4</span><span>];</span>
    <span>line_to_tm</span><span>(</span><span>lines</span><span>[</span><span>0</span><span>],</span> <span>a0</span><span>);</span>
    <span>line_to_tm</span><span>(</span><span>lines</span><span>[</span><span>1</span><span>],</span> <span>a1</span><span>);</span>
    <span>line_to_tm</span><span>(</span><span>lines</span><span>[</span><span>2</span><span>],</span> <span>b0</span><span>);</span>
    <span>line_to_tm</span><span>(</span><span>lines</span><span>[</span><span>3</span><span>],</span> <span>b1</span><span>);</span>
    <span>line_to_tm</span><span>(</span><span>lines</span><span>[</span><span>4</span><span>],</span> <span>c0</span><span>);</span>
    <span>line_to_tm</span><span>(</span><span>lines</span><span>[</span><span>5</span><span>],</span> <span>c1</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;%s %s  %s %s  %s %s&#34;</span><span>,</span> <span>a0</span><span>,</span><span>a1</span><span>,</span><span>b0</span><span>,</span><span>b1</span><span>,</span><span>c0</span><span>,</span><span>c1</span><span>);</span>
<span>}</span>

<span>// --- Phase 1: run machine up to 21 shifts, accurate score on full tape ---</span>
<span>// STOP line halts after executing its print+shift (Lin fixes stop-line to 110).</span>
<span>// Score = number of 1s on tape at stop.</span>
<span>static</span> <span>int</span> <span>tape_score</span><span>(</span><span>const</span> <span>uint8_t</span> <span>*</span><span>tape</span><span>,</span> <span>int</span> <span>min_i</span><span>,</span> <span>int</span> <span>max_i</span><span>)</span> <span>{</span>
    <span>int</span> <span>s</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span><span>=</span><span>min_i</span><span>;</span><span>i</span><span>&lt;=</span><span>max_i</span><span>;</span><span>i</span><span>++</span><span>)</span> <span>s</span> <span>+=</span> <span>(</span><span>tape</span><span>[</span><span>i</span><span>]</span> <span>!=</span> <span>0</span><span>);</span>
    <span>return</span> <span>s</span><span>;</span>
<span>}</span>

<span>typedef</span> <span>struct</span> <span>{</span>
    <span>int</span> <span>stopped</span><span>;</span> <span>// 1 if stopped within bound</span>
    <span>int</span> <span>shifts</span><span>;</span>
    <span>int</span> <span>score</span><span>;</span>
<span>}</span> <span>StopScanResult</span><span>;</span>

<span>static</span> <span>StopScanResult</span> <span>run_stop_scan_21</span><span>(</span><span>const</span> <span>uint8_t</span> <span>lines</span><span>[</span><span>NUM_LINES</span><span>])</span> <span>{</span>
    <span>uint8_t</span> <span>tape</span><span>[</span><span>TAPE_SIZE</span><span>];</span>
    <span>memset</span><span>(</span><span>tape</span><span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span><span>tape</span><span>));</span>
    <span>int</span> <span>head</span> <span>=</span> <span>TAPE_MID</span><span>;</span>
    <span>int</span> <span>card</span> <span>=</span> <span>1</span><span>;</span>
    <span>int</span> <span>minTape</span> <span>=</span> <span>head</span><span>,</span> <span>maxTape</span> <span>=</span> <span>head</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> <span>s</span><span>=</span><span>1</span><span>;</span> <span>s</span><span>&lt;=</span><span>MAX_STOP_SCAN</span><span>;</span> <span>s</span><span>++</span><span>)</span> <span>{</span>
        <span>int</span> <span>scanned</span> <span>=</span> <span>tape</span><span>[</span><span>head</span><span>]</span> <span>&amp;</span> <span>1</span><span>;</span>
        <span>uint8_t</span> <span>w</span> <span>=</span> <span>lines</span><span>[</span><span>line_index</span><span>(</span><span>card</span><span>,</span> <span>scanned</span><span>)];</span>

        <span>// execute print</span>
        <span>tape</span><span>[</span><span>head</span><span>]</span> <span>=</span> <span>get_p</span><span>(</span><span>w</span><span>);</span>
        <span>if</span> <span>(</span><span>head</span> <span>&lt;</span> <span>minTape</span><span>)</span> <span>minTape</span> <span>=</span> <span>head</span><span>;</span>
        <span>if</span> <span>(</span><span>head</span> <span>&gt;</span> <span>maxTape</span><span>)</span> <span>maxTape</span> <span>=</span> <span>head</span><span>;</span>

        <span>// execute shift</span>
        <span>if</span> <span>(</span><span>get_s</span><span>(</span><span>w</span><span>))</span> <span>head</span><span>++</span><span>;</span> <span>else</span> <span>head</span><span>--</span><span>;</span>
        <span>if</span> <span>(</span><span>head</span> <span>&lt;</span> <span>0</span> <span>||</span> <span>head</span> <span>&gt;=</span> <span>TAPE_SIZE</span><span>)</span> <span>{</span>
            <span>StopScanResult</span> <span>r</span> <span>=</span> <span>{</span><span>0</span><span>,</span> <span>s</span><span>,</span> <span>0</span><span>};</span>
            <span>return</span> <span>r</span><span>;</span>
        <span>}</span>

        <span>// stop?</span>
        <span>if</span> <span>(</span><span>get_c</span><span>(</span><span>w</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>StopScanResult</span> <span>r</span><span>;</span>
            <span>r</span><span>.</span><span>stopped</span> <span>=</span> <span>1</span><span>;</span>
            <span>r</span><span>.</span><span>shifts</span> <span>=</span> <span>s</span><span>;</span>
            <span>r</span><span>.</span><span>score</span> <span>=</span> <span>tape_score</span><span>(</span><span>tape</span><span>,</span> <span>minTape</span><span>,</span> <span>maxTape</span><span>);</span>
            <span>return</span> <span>r</span><span>;</span>
        <span>}</span>

        <span>card</span> <span>=</span> <span>get_c</span><span>(</span><span>w</span><span>);</span>
    <span>}</span>

    <span>StopScanResult</span> <span>r</span> <span>=</span> <span>{</span><span>0</span><span>,</span> <span>MAX_STOP_SCAN</span><span>,</span> <span>0</span><span>};</span>
    <span>return</span> <span>r</span><span>;</span>
<span>}</span>

<span>// --- Lin&#39;s 36-bit recurrence routine implementation ---</span>

<span>// 36-bit shift-left with zero fill, keeping 36-bit width</span>
<span>static</span> <span>inline</span> <span>uint64_t</span> <span>shl36</span><span>(</span><span>uint64_t</span> <span>x</span><span>,</span> <span>int</span> <span>k</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>k</span> <span>&lt;=</span> <span>0</span><span>)</span> <span>return</span> <span>x</span> <span>&amp;</span> <span>WORD_MASK</span><span>;</span>
    <span>if</span> <span>(</span><span>k</span> <span>&gt;=</span> <span>WORD_BITS</span><span>)</span> <span>return</span> <span>0ULL</span><span>;</span>
    <span>return</span> <span>(</span><span>x</span> <span>&lt;&lt;</span> <span>k</span><span>)</span> <span>&amp;</span> <span>WORD_MASK</span><span>;</span>
<span>}</span>

<span>// 36-bit shift-right with zero fill (for alternative bit-numbering conventions)</span>
<span>static</span> <span>inline</span> <span>uint64_t</span> <span>shr36</span><span>(</span><span>uint64_t</span> <span>x</span><span>,</span> <span>int</span> <span>k</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>k</span> <span>&lt;=</span> <span>0</span><span>)</span> <span>return</span> <span>x</span> <span>&amp;</span> <span>WORD_MASK</span><span>;</span>
    <span>if</span> <span>(</span><span>k</span> <span>&gt;=</span> <span>WORD_BITS</span><span>)</span> <span>return</span> <span>0ULL</span><span>;</span>
    <span>return</span> <span>(</span><span>x</span> <span>&gt;&gt;</span> <span>k</span><span>)</span> <span>&amp;</span> <span>WORD_MASK</span><span>;</span>
<span>}</span>

<span>static</span> <span>inline</span> <span>int</span> <span>bit_at</span><span>(</span><span>uint64_t</span> <span>T</span><span>,</span> <span>int</span> <span>dev</span><span>)</span> <span>{</span>
    <span>// return tape bit at square with deviation dev (within [-DEV_LIMIT..DEV_LIMIT])</span>
    <span>int</span> <span>bp</span> <span>=</span> <span>BITPOS</span><span>(</span><span>dev</span><span>);</span>
    <span>if</span> <span>(</span><span>bp</span> <span>&lt;</span> <span>0</span> <span>||</span> <span>bp</span> <span>&gt;=</span> <span>WORD_BITS</span><span>)</span> <span>return</span> <span>0</span><span>;</span> <span>// outside tracked word treated as 0</span>
    <span>return</span> <span>(</span><span>int</span><span>)((</span><span>T</span> <span>&gt;&gt;</span> <span>bp</span><span>)</span> <span>&amp;</span> <span>1ULL</span><span>);</span>
<span>}</span>

<span>// Compare tape segments for Lin&#39;s barrier recurrence logic (see discussion preceding routine)</span>
<span>// For Dq &lt; D (current head is to the right): compare the portion of tape to the right of the</span>
<span>// left barrier (minimum deviation Dmin) with the earlier pattern shifted by delta = D - Dq.</span>
<span>static</span> <span>int</span> <span>compare_right_of_left_barrier</span><span>(</span><span>uint64_t</span> <span>Tq</span><span>,</span> <span>uint64_t</span> <span>T</span><span>,</span> <span>int</span> <span>Dmin</span><span>,</span> <span>int</span> <span>delta</span><span>)</span> <span>{</span>
    <span>// Compare dev in [Dmin .. DEV_LIMIT - delta] : Tq[dev] == T[dev + delta]</span>
    <span>int</span> <span>start</span> <span>=</span> <span>Dmin</span><span>;</span>
    <span>int</span> <span>end</span> <span>=</span> <span>DEV_LIMIT</span> <span>-</span> <span>delta</span><span>;</span>
    <span>if</span> <span>(</span><span>end</span> <span>&lt;</span> <span>start</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> <span>dev</span> <span>=</span> <span>start</span><span>;</span> <span>dev</span> <span>&lt;=</span> <span>end</span><span>;</span> <span>dev</span><span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>bit_at</span><span>(</span><span>Tq</span><span>,</span> <span>dev</span><span>)</span> <span>!=</span> <span>bit_at</span><span>(</span><span>T</span><span>,</span> <span>dev</span> <span>+</span> <span>delta</span><span>))</span> <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>1</span><span>;</span>
<span>}</span>

<span>// For Dq &gt; D (current head is to the left): compare the portion of tape to the left of the</span>
<span>// right barrier (maximum deviation Dmax) with the earlier pattern shifted by delta = D - Dq (negative).</span>
<span>static</span> <span>int</span> <span>compare_left_of_right_barrier</span><span>(</span><span>uint64_t</span> <span>Tq</span><span>,</span> <span>uint64_t</span> <span>T</span><span>,</span> <span>int</span> <span>Dmax</span><span>,</span> <span>int</span> <span>delta</span><span>)</span> <span>{</span>
    <span>// delta &lt; 0. Compare dev in [(-DEV_LIMIT - delta) .. Dmax] : Tq[dev] == T[dev + delta]</span>
    <span>int</span> <span>start</span> <span>=</span> <span>-</span><span>DEV_LIMIT</span> <span>-</span> <span>delta</span><span>;</span>
    <span>if</span> <span>(</span><span>start</span> <span>&lt;</span> <span>-</span><span>DEV_LIMIT</span><span>)</span> <span>start</span> <span>=</span> <span>-</span><span>DEV_LIMIT</span><span>;</span>
    <span>int</span> <span>end</span> <span>=</span> <span>Dmax</span><span>;</span>
    <span>if</span> <span>(</span><span>end</span> <span>&lt;</span> <span>start</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> <span>dev</span> <span>=</span> <span>start</span><span>;</span> <span>dev</span> <span>&lt;=</span> <span>end</span><span>;</span> <span>dev</span><span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>bit_at</span><span>(</span><span>Tq</span><span>,</span> <span>dev</span><span>)</span> <span>!=</span> <span>bit_at</span><span>(</span><span>T</span><span>,</span> <span>dev</span> <span>+</span> <span>delta</span><span>))</span> <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>1</span><span>;</span>
<span>}</span>

<span>static</span> <span>inline</span> <span>uint64_t</span> <span>mask_range_bits</span><span>(</span><span>int</span> <span>lo</span><span>,</span> <span>int</span> <span>hi</span><span>)</span> <span>{</span>
    <span>// inclusive, within [0..35]</span>
    <span>if</span> <span>(</span><span>lo</span> <span>&lt;</span> <span>0</span><span>)</span> <span>lo</span> <span>=</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span><span>hi</span> <span>&gt;</span> <span>WORD_BITS</span><span>-</span><span>1</span><span>)</span> <span>hi</span> <span>=</span> <span>WORD_BITS</span><span>-</span><span>1</span><span>;</span>
    <span>if</span> <span>(</span><span>hi</span> <span>&lt;</span> <span>lo</span><span>)</span> <span>return</span> <span>0ULL</span><span>;</span>
    <span>int</span> <span>len</span> <span>=</span> <span>hi</span> <span>-</span> <span>lo</span> <span>+</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span><span>len</span> <span>&gt;=</span> <span>WORD_BITS</span><span>)</span> <span>return</span> <span>WORD_MASK</span><span>;</span>
    <span>uint64_t</span> <span>m</span> <span>=</span> <span>(</span><span>len</span> <span>==</span> <span>64</span><span>)</span> <span>?</span> <span>~</span><span>0ULL</span> <span>:</span> <span>((</span><span>1ULL</span> <span>&lt;&lt;</span> <span>len</span><span>)</span> <span>-</span> <span>1ULL</span><span>);</span>
    <span>return</span> <span>(</span><span>m</span> <span>&lt;&lt;</span> <span>lo</span><span>)</span> <span>&amp;</span> <span>WORD_MASK</span><span>;</span>
<span>}</span>

<span>typedef</span> <span>struct</span> <span>{</span>
    <span>uint64_t</span> <span>T</span><span>;</span>
    <span>int</span> <span>S</span><span>;</span>
    <span>int</span> <span>D</span><span>;</span>
<span>}</span> <span>TBEntry</span><span>;</span>

<span>typedef</span> <span>enum</span> <span>{</span>
    <span>REC_LOOPED</span> <span>=</span> <span>1</span><span>,</span>
    <span>REC_NO_RECURRENCE</span> <span>=</span> <span>0</span><span>,</span>
    <span>REC_SPILL</span> <span>=</span> <span>-</span><span>1</span><span>,</span>
    <span>REC_STOPPED</span> <span>=</span> <span>2</span>
<span>}</span> <span>RecResult</span><span>;</span>

<span>// Compute min/max deviation between shifts Sq and s inclusive</span>
<span>static</span> <span>inline</span> <span>void</span> <span>dev_minmax</span><span>(</span><span>const</span> <span>int</span> <span>dev</span><span>[],</span> <span>int</span> <span>Sq</span><span>,</span> <span>int</span> <span>s</span><span>,</span> <span>int</span> <span>*</span><span>outMin</span><span>,</span> <span>int</span> <span>*</span><span>outMax</span><span>)</span> <span>{</span>
    <span>int</span> <span>mn</span> <span>=</span> <span>dev</span><span>[</span><span>Sq</span><span>];</span>
    <span>int</span> <span>mx</span> <span>=</span> <span>dev</span><span>[</span><span>Sq</span><span>];</span>
    <span>for</span> <span>(</span><span>int</span> <span>k</span><span>=</span><span>Sq</span><span>;</span> <span>k</span><span>&lt;=</span><span>s</span><span>;</span> <span>k</span><span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>dev</span><span>[</span><span>k</span><span>]</span> <span>&lt;</span> <span>mn</span><span>)</span> <span>mn</span> <span>=</span> <span>dev</span><span>[</span><span>k</span><span>];</span>
        <span>if</span> <span>(</span><span>dev</span><span>[</span><span>k</span><span>]</span> <span>&gt;</span> <span>mx</span><span>)</span> <span>mx</span> <span>=</span> <span>dev</span><span>[</span><span>k</span><span>];</span>
    <span>}</span>
    <span>*</span><span>outMin</span> <span>=</span> <span>mn</span><span>;</span>
    <span>*</span><span>outMax</span> <span>=</span> <span>mx</span><span>;</span>
<span>}</span>

<span>// Lin recurrence routine: run up to 50 shifts looking for partial recurrence.</span>
<span>// Returns:</span>
<span>//  - REC_LOOPED if recurrence detected =&gt; discard never-stopper</span>
<span>//  - REC_NO_RECURRENCE if none within 50 =&gt; holdout</span>
<span>//  - REC_SPILL if |deviation|&gt;17 =&gt; holdout (spilled beyond 36-bit word)</span>
<span>//  - REC_STOPPED if it stops (should not happen if SH(3)=21)</span>
<span>static</span> <span>RecResult</span> <span>run_lin_recurrence_50</span><span>(</span><span>const</span> <span>uint8_t</span> <span>lines</span><span>[</span><span>NUM_LINES</span><span>])</span> <span>{</span>
    <span>// tape word bits: bit(BITPOS(D)) corresponds to square at deviation D</span>
    <span>uint64_t</span> <span>T</span> <span>=</span> <span>0ULL</span><span>;</span>
    <span>int</span> <span>D</span> <span>=</span> <span>0</span><span>;</span>      <span>// deviation of head relative to starting square</span>
    <span>int</span> <span>card</span> <span>=</span> <span>1</span><span>;</span>

    <span>// deviation history (after each shift) dev[s] = D</span>
    <span>int</span> <span>dev</span><span>[</span><span>MAX_REC_SHIFTS</span><span>+</span><span>1</span><span>];</span>
    <span>dev</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>

    <span>// Tape tables TB[i][j], i=1..3, j=0..1</span>
    <span>TBEntry</span> <span>tb</span><span>[</span><span>4</span><span>][</span><span>2</span><span>][</span><span>MAX_REC_SHIFTS</span><span>+</span><span>1</span><span>];</span>
    <span>int</span> <span>tbCount</span><span>[</span><span>4</span><span>][</span><span>2</span><span>];</span>
    <span>memset</span><span>(</span><span>tbCount</span><span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span><span>tbCount</span><span>));</span>

    <span>// We begin before shift 1 with all-0 tape; scanned digit at start is 0.</span>

    <span>for</span> <span>(</span><span>int</span> <span>s</span><span>=</span><span>1</span><span>;</span> <span>s</span><span>&lt;=</span><span>MAX_REC_SHIFTS</span><span>;</span> <span>s</span><span>++</span><span>)</span> <span>{</span>
        <span>// scanned symbol at current head (deviation D)</span>
        <span>if</span> <span>(</span><span>D</span> <span>&lt;</span> <span>-</span><span>DEV_LIMIT</span> <span>||</span> <span>D</span> <span>&gt;</span> <span>DEV_LIMIT</span><span>)</span> <span>{</span>
            <span>return</span> <span>REC_SPILL</span><span>;</span>
        <span>}</span>
        <span>int</span> <span>bitpos</span> <span>=</span> <span>BITPOS</span><span>(</span><span>D</span><span>);</span>
        <span>int</span> <span>scanned</span> <span>=</span> <span>(</span><span>int</span><span>)((</span><span>T</span> <span>&gt;&gt;</span> <span>bitpos</span><span>)</span> <span>&amp;</span> <span>1ULL</span><span>);</span>

        <span>// execute current instruction</span>
        <span>uint8_t</span> <span>w</span> <span>=</span> <span>lines</span><span>[</span><span>line_index</span><span>(</span><span>card</span><span>,</span> <span>scanned</span><span>)];</span>
        <span>uint8_t</span> <span>p</span> <span>=</span> <span>get_p</span><span>(</span><span>w</span><span>);</span>
        <span>uint8_t</span> <span>sh</span> <span>=</span> <span>get_s</span><span>(</span><span>w</span><span>);</span>
        <span>uint8_t</span> <span>c</span> <span>=</span> <span>get_c</span><span>(</span><span>w</span><span>);</span>

        <span>// print: set bit at current deviation</span>
        <span>if</span> <span>(</span><span>p</span><span>)</span> <span>T</span> <span>|=</span> <span>(</span><span>1ULL</span> <span>&lt;&lt;</span> <span>bitpos</span><span>);</span>
        <span>else</span>   <span>T</span> <span>&amp;=</span> <span>~</span><span>(</span><span>1ULL</span> <span>&lt;&lt;</span> <span>bitpos</span><span>);</span>

        <span>// shift head</span>
        <span>if</span> <span>(</span><span>sh</span><span>)</span> <span>D</span><span>++</span><span>;</span> <span>else</span> <span>D</span><span>--</span><span>;</span>

        <span>// stop?</span>
        <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>dev</span><span>[</span><span>s</span><span>]</span> <span>=</span> <span>D</span><span>;</span>
            <span>return</span> <span>REC_STOPPED</span><span>;</span>
        <span>}</span>

        <span>// call next card</span>
        <span>card</span> <span>=</span> <span>(</span><span>int</span><span>)</span><span>c</span><span>;</span>

        <span>// spill check (after shift)</span>
        <span>dev</span><span>[</span><span>s</span><span>]</span> <span>=</span> <span>D</span><span>;</span>
        <span>if</span> <span>(</span><span>D</span> <span>&lt;</span> <span>-</span><span>DEV_LIMIT</span> <span>||</span> <span>D</span> <span>&gt;</span> <span>DEV_LIMIT</span><span>)</span> <span>{</span>
            <span>return</span> <span>REC_SPILL</span><span>;</span>
        <span>}</span>

        <span>// scanned digit after shift, used to index TB[card][j]</span>
        <span>int</span> <span>bitpos2</span> <span>=</span> <span>BITPOS</span><span>(</span><span>D</span><span>);</span>
        <span>int</span> <span>j</span> <span>=</span> <span>(</span><span>int</span><span>)((</span><span>T</span> <span>&gt;&gt;</span> <span>bitpos2</span><span>)</span> <span>&amp;</span> <span>1ULL</span><span>);</span>

        <span>// insert into tape table TB[card][j]</span>
        <span>int</span> <span>cnt</span> <span>=</span> <span>tbCount</span><span>[</span><span>card</span><span>][</span><span>j</span><span>];</span>

        <span>// if table nonempty, test against previous entries</span>
        <span>for</span> <span>(</span><span>int</span> <span>q</span><span>=</span><span>0</span><span>;</span> <span>q</span><span>&lt;</span><span>cnt</span><span>;</span> <span>q</span><span>++</span><span>)</span> <span>{</span>
            <span>TBEntry</span> <span>*</span><span>e</span> <span>=</span> <span>&amp;</span><span>tb</span><span>[</span><span>card</span><span>][</span><span>j</span><span>][</span><span>q</span><span>];</span>
            <span>uint64_t</span> <span>Tq</span> <span>=</span> <span>e</span><span>-&gt;</span><span>T</span><span>;</span>
            <span>int</span> <span>Sq</span> <span>=</span> <span>e</span><span>-&gt;</span><span>S</span><span>;</span>
            <span>int</span> <span>Dq</span> <span>=</span> <span>e</span><span>-&gt;</span><span>D</span><span>;</span>

            <span>if</span> <span>(</span><span>Dq</span> <span>&lt;</span> <span>D</span><span>)</span> <span>{</span>
                <span>// Dq &lt; D: find Dmin between Sq and s, then compare shifted words</span>
                <span>int</span> <span>Dmin</span><span>,</span> <span>Dmax</span><span>;</span>
                <span>dev_minmax</span><span>(</span><span>dev</span><span>,</span> <span>Sq</span><span>,</span> <span>s</span><span>,</span> <span>&amp;</span><span>Dmin</span><span>,</span> <span>&amp;</span><span>Dmax</span><span>);</span>

                <span>// Tq shifted left 18 + Dq bits</span>
                <span>// T  shifted left 18 + Dmin + D - Dq bits</span>
                <span>// (Lin: &#34;Tq is shifted left 18 + Dq bits and T shifted left 18 + Dmin + D - Dq bits&#34;)</span>
                <span>// fileciteturn16file3L1-L3</span>
                <span>// Lin&#39;s OCR scan truncates the symbol after &#34;18 +&#34; in some copies.</span>
                <span>// The barrier-based derivation implies shifting relative to the barrier</span>
                <span>// (minimum deviation) rather than the earlier endpoint deviation.</span>
                <span>int</span> <span>delta</span> <span>=</span> <span>D</span> <span>-</span> <span>Dq</span><span>;</span>
                <span>if</span> <span>(</span><span>compare_right_of_left_barrier</span><span>(</span><span>Tq</span><span>,</span> <span>T</span><span>,</span> <span>Dmin</span><span>,</span> <span>delta</span><span>))</span> <span>{</span>
                    <span>return</span> <span>REC_LOOPED</span><span>;</span>
                <span>}</span>

            <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>Dq</span> <span>&gt;</span> <span>D</span><span>)</span> <span>{</span>
                <span>// symmetric when Dq &gt; D</span>
                <span>int</span> <span>Dmin</span><span>,</span> <span>Dmax</span><span>;</span>
                <span>dev_minmax</span><span>(</span><span>dev</span><span>,</span> <span>Sq</span><span>,</span> <span>s</span><span>,</span> <span>&amp;</span><span>Dmin</span><span>,</span> <span>&amp;</span><span>Dmax</span><span>);</span>

                <span>// symmetric right-barrier analogue: use Dmax instead of Dmin</span>
                <span>// (Lin: &#34;Symmetrical procedure hold when Dq &gt; D&#34;) fileciteturn16file3L8</span>
                <span>int</span> <span>delta</span> <span>=</span> <span>D</span> <span>-</span> <span>Dq</span><span>;</span> <span>// negative</span>
                <span>if</span> <span>(</span><span>compare_left_of_right_barrier</span><span>(</span><span>Tq</span><span>,</span> <span>T</span><span>,</span> <span>Dmax</span><span>,</span> <span>delta</span><span>))</span> <span>{</span>
                    <span>return</span> <span>REC_LOOPED</span><span>;</span>
                <span>}</span>

            <span>}</span> <span>else</span> <span>{</span>
                <span>// Dq == D: use both barriers (mask compare between barriers)</span>
                <span>// Lin: &#34;If Dq = D, both Dmax and Dmin are determined and Tq and T</span>
                <span>// are compared from bits ... to ... by the use of a mask.&#34; fileciteturn16file3L9-L10</span>
                <span>int</span> <span>Dmin</span><span>,</span> <span>Dmax</span><span>;</span>
                <span>dev_minmax</span><span>(</span><span>dev</span><span>,</span> <span>Sq</span><span>,</span> <span>s</span><span>,</span> <span>&amp;</span><span>Dmin</span><span>,</span> <span>&amp;</span><span>Dmax</span><span>);</span>

                <span>int</span> <span>lo</span> <span>=</span> <span>BITPOS</span><span>(</span><span>Dmin</span><span>);</span>
                <span>int</span> <span>hi</span> <span>=</span> <span>BITPOS</span><span>(</span><span>Dmax</span><span>);</span>
                <span>uint64_t</span> <span>m</span> <span>=</span> <span>mask_range_bits</span><span>(</span><span>lo</span><span>,</span> <span>hi</span><span>);</span>
                <span>if</span> <span>(</span> <span>(</span><span>Tq</span> <span>&amp;</span> <span>m</span><span>)</span> <span>==</span> <span>(</span><span>T</span> <span>&amp;</span> <span>m</span><span>)</span> <span>)</span> <span>{</span>
                    <span>return</span> <span>REC_LOOPED</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>

        <span>// no recurrence found; append entry</span>
        <span>tb</span><span>[</span><span>card</span><span>][</span><span>j</span><span>][</span><span>cnt</span><span>].</span><span>T</span> <span>=</span> <span>T</span><span>;</span>
        <span>tb</span><span>[</span><span>card</span><span>][</span><span>j</span><span>][</span><span>cnt</span><span>].</span><span>S</span> <span>=</span> <span>s</span><span>;</span>
        <span>tb</span><span>[</span><span>card</span><span>][</span><span>j</span><span>][</span><span>cnt</span><span>].</span><span>D</span> <span>=</span> <span>D</span><span>;</span>
        <span>tbCount</span><span>[</span><span>card</span><span>][</span><span>j</span><span>]</span> <span>=</span> <span>cnt</span> <span>+</span> <span>1</span><span>;</span>

        <span>// continue to next shift</span>
    <span>}</span>

    <span>// no recurrence after 50 shifts =&gt; holdout fileciteturn16file3L18-L20</span>
    <span>return</span> <span>REC_NO_RECURRENCE</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>uint8_t</span> <span>cases12</span><span>[</span><span>12</span><span>];</span>
    <span>gen_12_cases</span><span>(</span><span>cases12</span><span>);</span>

    <span>int</span> <span>total</span> <span>=</span> <span>0</span><span>;</span>
    <span>int</span> <span>stoppers</span> <span>=</span> <span>0</span><span>;</span>
    <span>int</span> <span>bestScore</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
    <span>int</span> <span>bestScoreShifts</span> <span>=</span> <span>0</span><span>;</span>
    <span>uint8_t</span> <span>bestScoreMachine</span><span>[</span><span>NUM_LINES</span><span>];</span>
    <span>int</span> <span>bestShifts</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
    <span>int</span> <span>bestShiftsScore</span> <span>=</span> <span>0</span><span>;</span>
    <span>uint8_t</span> <span>bestShiftMachine</span><span>[</span><span>NUM_LINES</span><span>];</span>

    <span>int</span> <span>candidates</span> <span>=</span> <span>0</span><span>;</span>
    <span>int</span> <span>obviousPruned</span> <span>=</span> <span>0</span><span>;</span>
    <span>int</span> <span>recLooped</span> <span>=</span> <span>0</span><span>;</span>
    <span>int</span> <span>holdouts</span> <span>=</span> <span>0</span><span>;</span>
    <span>int</span> <span>spilled</span> <span>=</span> <span>0</span><span>;</span>
    <span>int</span> <span>stoppedBeyond21</span> <span>=</span> <span>0</span><span>;</span>

    <span>printf</span><span>(</span><span>&#34;Lin BB-3 normalized enumeration: 4 lots x 12^4 = 82,944 machines</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;Phase 1: discard machines that stop in &lt;= %d shifts</span><span>\n</span><span>&#34;</span><span>,</span> <span>MAX_STOP_SCAN</span><span>);</span>

    <span>for</span> <span>(</span><span>int</span> <span>lot</span><span>=</span><span>1</span><span>;</span> <span>lot</span><span>&lt;=</span><span>NUM_LOTS</span><span>;</span> <span>lot</span><span>++</span><span>)</span> <span>{</span>
        <span>int</span> <span>lotTotal</span><span>=</span><span>0</span><span>,</span> <span>lotStop</span><span>=</span><span>0</span><span>,</span> <span>lotCand</span><span>=</span><span>0</span><span>,</span> <span>lotPrune</span><span>=</span><span>0</span><span>,</span> <span>lotHold</span><span>=</span><span>0</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> <span>a</span><span>=</span><span>0</span><span>;</span><span>a</span><span>&lt;</span><span>12</span><span>;</span><span>a</span><span>++</span><span>)</span>
        <span>for</span> <span>(</span><span>int</span> <span>b</span><span>=</span><span>0</span><span>;</span><span>b</span><span>&lt;</span><span>12</span><span>;</span><span>b</span><span>++</span><span>)</span>
        <span>for</span> <span>(</span><span>int</span> <span>c</span><span>=</span><span>0</span><span>;</span><span>c</span><span>&lt;</span><span>12</span><span>;</span><span>c</span><span>++</span><span>)</span>
        <span>for</span> <span>(</span><span>int</span> <span>d</span><span>=</span><span>0</span><span>;</span><span>d</span><span>&lt;</span><span>12</span><span>;</span><span>d</span><span>++</span><span>)</span> <span>{</span>
            <span>uint8_t</span> <span>free4</span><span>[</span><span>4</span><span>]</span> <span>=</span> <span>{</span><span>cases12</span><span>[</span><span>a</span><span>],</span> <span>cases12</span><span>[</span><span>b</span><span>],</span> <span>cases12</span><span>[</span><span>c</span><span>],</span> <span>cases12</span><span>[</span><span>d</span><span>]};</span>
            <span>uint8_t</span> <span>m</span><span>[</span><span>NUM_LINES</span><span>];</span>
            <span>build_machine_for_lot</span><span>(</span><span>lot</span><span>,</span> <span>free4</span><span>,</span> <span>m</span><span>);</span>

            <span>total</span><span>++</span><span>;</span> <span>lotTotal</span><span>++</span><span>;</span>

            <span>StopScanResult</span> <span>r</span> <span>=</span> <span>run_stop_scan_21</span><span>(</span><span>m</span><span>);</span>
            <span>if</span> <span>(</span><span>r</span><span>.</span><span>stopped</span><span>)</span> <span>{</span>
                <span>stoppers</span><span>++</span><span>;</span> <span>lotStop</span><span>++</span><span>;</span>

                <span>if</span> <span>(</span><span>r</span><span>.</span><span>score</span> <span>&gt;</span> <span>bestScore</span><span>)</span> <span>{</span>
                    <span>bestScore</span> <span>=</span> <span>r</span><span>.</span><span>score</span><span>;</span>
                    <span>bestScoreShifts</span> <span>=</span> <span>r</span><span>.</span><span>shifts</span><span>;</span>
                    <span>memcpy</span><span>(</span><span>bestScoreMachine</span><span>,</span> <span>m</span><span>,</span> <span>NUM_LINES</span><span>);</span>
                <span>}</span>
                <span>if</span> <span>(</span><span>r</span><span>.</span><span>shifts</span> <span>&gt;</span> <span>bestShifts</span><span>)</span> <span>{</span>
                    <span>bestShifts</span> <span>=</span> <span>r</span><span>.</span><span>shifts</span><span>;</span>
                    <span>bestShiftsScore</span> <span>=</span> <span>r</span><span>.</span><span>score</span><span>;</span>
                    <span>memcpy</span><span>(</span><span>bestShiftMachine</span><span>,</span> <span>m</span><span>,</span> <span>NUM_LINES</span><span>);</span>
                <span>}</span>

                <span>// Lin printed champions score&gt;=6 or shifts&gt;=20</span>
                <span>if</span> <span>(</span><span>r</span><span>.</span><span>score</span> <span>&gt;=</span> <span>6</span> <span>||</span> <span>r</span><span>.</span><span>shifts</span> <span>&gt;=</span> <span>20</span><span>)</span> <span>{</span>
                    <span>printf</span><span>(</span><span>&#34;HALTED  stop@%2d score=%d lot=%d :: &#34;</span><span>,</span> <span>r</span><span>.</span><span>shifts</span><span>,</span> <span>r</span><span>.</span><span>score</span><span>,</span> <span>lot</span><span>);</span>
                    <span>print_machine_tm</span><span>(</span><span>m</span><span>);</span>
                    <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>&#34;</span><span>);</span>
                <span>}</span>
                <span>continue</span><span>;</span>
            <span>}</span>

            <span>// Not stopped within 21 shifts</span>
            <span>candidates</span><span>++</span><span>;</span> <span>lotCand</span><span>++</span><span>;</span>

            <span>if</span> <span>(</span><span>prune_obvious</span><span>(</span><span>lot</span><span>,</span> <span>m</span><span>))</span> <span>{</span>
                <span>obviousPruned</span><span>++</span><span>;</span> <span>lotPrune</span><span>++</span><span>;</span>
                <span>continue</span><span>;</span>
            <span>}</span>

            <span>// Lin recurrence routine</span>
            <span>RecResult</span> <span>rr</span> <span>=</span> <span>run_lin_recurrence_50</span><span>(</span><span>m</span><span>);</span>
            <span>if</span> <span>(</span><span>rr</span> <span>==</span> <span>REC_LOOPED</span><span>)</span> <span>{</span>
                <span>recLooped</span><span>++</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>rr</span> <span>==</span> <span>REC_STOPPED</span><span>)</span> <span>{</span>
                <span>stoppedBeyond21</span><span>++</span><span>;</span>
                <span>// if this ever triggers, SH(3) &gt; 21 (contradicts Lin)</span>
                <span>printf</span><span>(</span><span>&#34;WARNING: stopper beyond 21 shifts lot=%d :: &#34;</span><span>,</span> <span>lot</span><span>);</span>
                <span>print_machine_tm</span><span>(</span><span>m</span><span>);</span>
                <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>&#34;</span><span>);</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>// holdout or spill</span>
                <span>holdouts</span><span>++</span><span>;</span> <span>lotHold</span><span>++</span><span>;</span>
                <span>if</span> <span>(</span><span>rr</span> <span>==</span> <span>REC_SPILL</span><span>)</span> <span>spilled</span><span>++</span><span>;</span>

                <span>if</span> <span>(</span><span>PRINT_HOLDOUTS</span><span>)</span> <span>{</span>
                    <span>printf</span><span>(</span><span>&#34;HOLDOUT lot=%d (%s) :: &#34;</span><span>,</span> <span>lot</span><span>,</span> <span>(</span><span>rr</span><span>==</span><span>REC_SPILL</span><span>)</span><span>?</span><span>&#34;spill&#34;</span><span>:</span><span>&#34;no-recurrence&#34;</span><span>);</span>
                    <span>print_machine_tm</span><span>(</span><span>m</span><span>);</span>
                    <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>&#34;</span><span>);</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>

        <span>printf</span><span>(</span><span>&#34;Lot %d: total=%d stoppers&lt;=21=%d candidates=%d pruned=%d holdouts=%d</span><span>\n</span><span>&#34;</span><span>,</span>
               <span>lot</span><span>,</span> <span>lotTotal</span><span>,</span> <span>lotStop</span><span>,</span> <span>lotCand</span><span>,</span> <span>lotPrune</span><span>,</span> <span>lotHold</span><span>);</span>
    <span>}</span>

    <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>=== SUMMARY ===</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;Machines enumerated: %d (expected 82944)</span><span>\n</span><span>&#34;</span><span>,</span> <span>total</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;Stoppers (&lt;=21 shifts): %d (Lin reports 26073)</span><span>\n</span><span>&#34;</span><span>,</span> <span>stoppers</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;Candidates after 21 shifts: %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>candidates</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;Obvious pruned: %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>obviousPruned</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;Recurrence-discarded (looped): %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>recLooped</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;Holdouts remaining: %d (Lin reports 40)</span><span>\n</span><span>&#34;</span><span>,</span> <span>holdouts</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;  of which spills: %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>spilled</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;Stopped beyond 21 (should be 0): %d</span><span>\n</span><span>&#34;</span><span>,</span> <span>stoppedBeyond21</span><span>);</span>

    <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>Best score observed: %d (expected Sigma(3)=6)</span><span>\n</span><span>&#34;</span><span>,</span> <span>bestScore</span><span>);</span>
    <span>if</span> <span>(</span><span>bestScore</span> <span>&gt;=</span> <span>0</span><span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;  achieved at %d shifts by: &#34;</span><span>,</span> <span>bestScoreShifts</span><span>);</span>
        <span>print_machine_tm</span><span>(</span><span>bestScoreMachine</span><span>);</span>
        <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>}</span>

    <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>Max shifts among stoppers observed: %d (expected SH(3)=21)</span><span>\n</span><span>&#34;</span><span>,</span> <span>bestShifts</span><span>);</span>
    <span>if</span> <span>(</span><span>bestShifts</span> <span>&gt;=</span> <span>0</span><span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;  score at max shifts: %d, machine: &#34;</span><span>,</span> <span>bestShiftsScore</span><span>);</span>
        <span>print_machine_tm</span><span>(</span><span>bestShiftMachine</span><span>);</span>
        <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>}</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></pre></figure>


  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
