<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-7/">Original</a>
    <h1>Building view-trees: What&#39;s up with Renderables [Part-7]</h1>
    
    <div id="readability-page-1" class="page"><section>
            <p>Previously: <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-1">intro</a>, <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-2">the basics</a>, <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-3">error handling</a>,
<a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-4">async data fetching</a>, <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5">http.Handler</a>, and <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-6">more</a>.</p>
<hr/>
<h2 id="hmmm"><em>hmmm</em></h2>
<p>Ok, so I&#39;m starting here not knowing exactly where I want to go,
and then using this to move forward. Going forward can mean staying
where we are with our design.</p>
<p>Following up on the <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-6">last post</a>, there still is something that
doesn&#39;t feel right with the design of the library.</p>
<p>Mainly, the difference between the following interface functions:</p>
<ul>
<li><code>Renderable(context.Context) (Renderable, error)</code></li>
<li><code>RequestRenderable(*http.Request) (AsRenderable, error)</code></li>
<li><code>ErrorRenderable(context.Context, error) (AsRenderable, error)</code></li>
</ul>
<p>For the first one, we covered that it&#39;s useful for us to have something
that is representalbe this wayâ€“ <em>fine</em>. For the second and third however,
we have two things that seem different but are closely related.</p>
<ol>
<li>We don&#39;t need to pass a context for <code>RequestRenderable</code> becuase a <code>Request</code>
has a context, otherwise I&#39;d be passing <code>func(ctx, r)</code>.</li>
<li>We <em>might</em> not need to pass an <code>err</code> to <code>ErrorRenderable</code> since
a context can have a <a rel="nofollow noreferrer" href="https://pkg.go.dev/context#CancelCauseFunc"><code>CancelCause</code></a>, but either way
we come from a place of <code>context</code> and <code>value</code>.</li>
</ol>
<p>It brings up the question, and one of the reasons I punted on errors
after solving errors: Should they be unified?</p>
<ul>
<li>
<p>Should the library follow the principle: everything only gets a
<code>context.Context</code>, implying the existence of a <code>*veun.Error</code> which
has a <code>Context</code> interface similar to that of <code>*http.Request</code>?</p>
</li>
<li>
<p>Should the library follow the principle: only pass a context and
you use that to determine your current state to know what kind of
renderable you are producing ala <code>ctx.Err()</code> and <code>ctx.Cause()</code>? One
can attach arbitrary values to <code>Context</code> and/or create different
ones for different use cases.</p>
</li>
</ul>
<h2 id="exploration">Exploration</h2>
<p>Writing our own <code>context.Context</code> wrapper would mean that the interface
implementor would have to dispatch on some kind of switch statement...</p>
<pre data-lang="go"><code data-lang="go"><span>func</span><span>(ctx veun.</span><span>Context</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>switch </span><span>ctx.Type() {
</span><span>    </span><span>case </span><span>veun.Request:
</span><span>        </span><span>// ... extract the request
</span><span>    }
</span><span>}
</span></code></pre>
<p>The above feels like code that would be fairly error prone. There&#39;s
another way to represent a similar thing, and it&#39;s really not bad
at all.</p>
<pre data-lang="go"><code data-lang="go"><span>func</span><span>(ctx veun.</span><span>Context</span><span>) (veun.</span><span>AsRenderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>ctx.Renderable(veun.R{
</span><span>        Request: </span><span>func</span><span>(r </span><span>*</span><span>http.</span><span>Request</span><span>) (veun.</span><span>AsRenderable</span><span>, http.</span><span>Handler</span><span>, </span><span>error</span><span>) {
</span><span>            </span><span>// ctx, and r are available here
</span><span>        },
</span><span>        Error: </span><span>func</span><span>(err </span><span>error</span><span>) (veun.</span><span>AsRenderable</span><span>, </span><span>error</span><span>) {
</span><span>            </span><span>// ctx and err are available here
</span><span>        },
</span><span>    })
</span><span>}
</span></code></pre>
<p>I&#39;d need to explore the <em>calling</em> code and how rendering and composition
would work in practice actually. Another thing to keep in mind is is if
<code>veun.R</code> (for renderable) is also an <code>AsRenderable</code>?</p>
<p>A thing that&#39;s nice is if we add <em>more</em> factory types then it&#39;s easy to
extend the struct. A thing that isn&#39;t so nice is that it encodes the kinds
of things you need to do in the library and doesn&#39;t give more flexibility
to try other ways of executing it.</p>
<h3 id="veun-error-tho"><code>veun.Error</code> tho</h3>
<p>Let&#39;s try out a hypothetical <code>*veun.Error</code> that&#39;s similar in structure
and interface to <code>*http.Request</code>.</p>
<pre data-lang="go"><code data-lang="go"><span>struct </span><span>Error { Err error </span><span>/* ... */ </span><span>}
</span><span>
</span><span>func </span><span>(e </span><span>*Error</span><span>) </span><span>Context</span><span>() context.</span><span>Context </span><span>{ </span><span>/* ... */ </span><span>}
</span><span>
</span><span>func </span><span>(e </span><span>*Error</span><span>) </span><span>WithContext</span><span>(ctx context.</span><span>Context</span><span>) </span><span>*Error </span><span>{ </span><span>/* ... */ </span><span>}
</span><span>
</span><span>func </span><span>(e </span><span>*Error</span><span>) </span><span>Error</span><span>() </span><span>string </span><span>{ </span><span>return </span><span>e.Err.Error() }
</span><span>
</span><span>func </span><span>(e </span><span>*Error</span><span>) </span><span>Unwrap</span><span>() </span><span>error </span><span>{ </span><span>return </span><span>errors.Unwrap(e.Err) }
</span></code></pre>
<p>I&#39;m not really sure we&#39;d need the <code>WithContext</code> here, but why not, let&#39;s
keep it consistent.</p>
<p>Also we are fulfilling the <code>Error</code> and <code>Unwrap</code> interfaces for errors.</p>
<h2 id="thinking-does-any-of-this-actually-help">ðŸ¤” Does any of this actually help?</h2>
<p>While looking at errors, in my implmentations and tests, I kept coming back
to a couple of things. Renaming <code>RequestRenderable</code>, <code>ErrorRenderable</code>, <code>Renderable</code>,
<code>View</code>, etc.</p>

<p>At first when starting to write this post, I wanted to explore errors and contexts.
A couple of different things I tried were interesting but <em>not good enough</em> or not
useful enough, or not intuitive enough. And just repeating <code>Renderable</code> really was the
thing to <em>fix</em>.</p>
<p>There&#39;s an adage in go that is something like: return structs and accept
interfaces, and in our prior situation we were just throwing around interfaces,
this meant for concrete implementations, there was always wrapping and unwrapping.</p>
<p>In the search for the <em>right</em> ergnomic and naming I&#39;ve moved around
the and renamed the library code <em>a whole bunch</em>.</p>
<h3 id="template">Template</h3>
<p>In our original implementation, we were returning a <code>View</code> struct which was
<code>Renderable</code>. And in a lot of the writing, I was referring to <code>View</code> and <code>Renderable</code>
as interchangeable concepts.</p>
<p>I&#39;ve since separated that out for things to be renderable to HTML <a rel="nofollow noreferrer" href="https://github.com/stanistan/veun/blob/64f2cc1aee66ff6d0317c751db1abd683ca3b37e/veun.go#L12-L15">here</a>,
and there&#39;s also the <code>Div</code> functions we can construct using <code>veun.Raw</code>.</p>
<p><strong>Concepts:</strong></p>
<ul>
<li><code>View</code></li>
<li><code>ViewForError</code></li>
<li><code>ViewForRequest</code></li>
</ul>
<p>These are the interface functions we&#39;re building, <code>Template</code> is an implmentation detail
of directly using a <code>html/template</code>.</p>
<h2 id="views">Views</h2>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>MyView </span><span>struct </span><span>{ </span><span>/* fields elided */ </span><span>}
</span><span>
</span><span>func </span><span>(v </span><span>MyView</span><span>) </span><span>View</span><span>(ctx context.</span><span>Context</span><span>) (</span><span>*</span><span>veun.</span><span>View</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>veun.V(veun.Template{
</span><span>        Tpl:   someTpl,
</span><span>        Data:  </span><span>nil</span><span>,
</span><span>        Slots: veun.Slots{ </span><span>/* ... */ </span><span>},
</span><span>    }).WithErrorHandler(someErrorHandler), </span><span>nil
</span><span>}
</span></code></pre>
<p>A few things jump out from the new implementation of the (now called)
<code>AsView</code> interface: <code>veun.V</code>, <code>veun.Template</code>, and <code>*veun.View</code>.</p>
<p><code>*veun.View</code> is an opaque type, and can only be constructed (in a useful way),
by <code>veun.V</code>. This <em>constructor</em> combines <code>HTMLRenderable</code> and <code>ErrorHandler</code>.</p>
<p>We&#39;re not doing duck-typing by whether or not the error handler interface
is attached to <code>MyView</code>, we&#39;re doing it based on wether or not an error
handler was explicitly attached to the <code>*View</code> constructed.</p>
<p>This allows us to conitnue to return <code>nil</code> (also ergonomic for construction).</p>
<p><em>Aside:</em> We <em>are</em> doing duck-typing inside of <code>V</code> but afterwards we get a
concrete implementation.</p>
<h3 id="view-constructors">View constructors</h3>
<p>Other types, like <code>ViewForRequest</code>, and <code>ViewForError</code> return an <code>AsView</code>.</p>
<h3 id="rendering">Rendering</h3>
<p>I made an explicit decition to change <code>Render</code> to a function that accepts an <code>AsView</code>,
and the rendering to be opaque behind and <code>HTMLRenderable</code> encapsulated by
a <code>View</code>.</p>
<p>In the prior version it was actually a bit confusing on what you can call render
on and what you can&#39;t, where you&#39;d get error handling and where you wouldn&#39;t. I
wanted to remove that kind of ambiguity and make it simpler to do more.</p>

<p>I moved all of the http related types and functions to the <code>vhttp</code> package. It&#39;s
called <code>vhttp</code> since you&#39;re using it in conjunction with the <code>net/http</code> standard
library and otherwise you&#39;d be import/aliasing it.</p>
<p>We&#39;ve got <code>vhttp.Handler</code>, <code>request.Handler</code>, and a package of middleware that
can be useful for use with standard <code>mux</code>.</p>
<h2 id="what-it-looks-like">What it looks like</h2>
<p>Given a <code>MyView</code> like we wrote above that renders something, we can have it be
created by an HTTP request.</p>
<pre data-lang="go"><code data-lang="go"><span>import </span><span>(
</span><span>    </span><span>&#34;context&#34;
</span><span>    </span><span>&#34;net/http&#34;
</span><span>
</span><span>    </span><span>&#34;github.com/stanistan/veun&#34;
</span><span>    </span><span>&#34;github.com/stanistan/veun/vhttp&#34;
</span><span>    </span><span>&#34;github.com/stanistan/veun/vhttp/request&#34;
</span><span>)
</span><span>
</span><span>func </span><span>(v </span><span>MyView</span><span>) </span><span>View</span><span>(_ context.</span><span>Context</span><span>) (</span><span>*</span><span>veun.</span><span>View</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>veun.View(</span><span>/*...*/</span><span>), </span><span>nil
</span><span>}
</span><span>
</span><span>func </span><span>MyViewRequestHandler</span><span>() request.</span><span>Handler </span><span>{
</span><span>    </span><span>return </span><span>request.HandlerFunc(</span><span>func</span><span>(r </span><span>*</span><span>http.</span><span>Request</span><span>) (veun.</span><span>AsView</span><span>, http.</span><span>Handler</span><span>, </span><span>error</span><span>) {
</span><span>        </span><span>// - We can extract data from the request.
</span><span>        </span><span>// - We can push up an error
</span><span>        </span><span>// - or we can do something with the response, like a 404, or anything.
</span><span>        </span><span>return </span><span>MyView{}, </span><span>nil</span><span>, </span><span>nil
</span><span>    })
</span><span>}
</span><span>
</span><span>func </span><span>main</span><span>() {
</span><span>    </span><span>// ...
</span><span>    mux.Handle(</span><span>&#34;/some/path&#34;</span><span>, vhttp.Handler(MyViewRequestHandler()))
</span><span>    </span><span>// ...
</span><span>}
</span></code></pre>
<h2 id="demo">Demo</h2>
<p>I&#39;m working on a demo webserver where there are examples of different ways
of doing composition, routing, redirects, errors, etc, and the kinds
of patterns that become possible and useful when you have all of this
in one place.</p>
<ul>
<li>website: <a rel="nofollow noreferrer" href="https://veun-http-demo.stanistan.com">veun-http-demo.stanistan.com</a></li>
<li>source: <a rel="nofollow noreferrer" href="https://github.com/stanistan/veun-http-demo">github/veun-http-demo</a></li>
</ul>
<p>In the future, I&#39;d like to actually build (or rebuild) something using the
library as well as better document the different components that are part
of the demo server.</p>

        </section></div>
  </body>
</html>
