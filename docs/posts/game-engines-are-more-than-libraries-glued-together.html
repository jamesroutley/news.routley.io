<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.leafwing-studios.com/blog/game-engine-glue/">Original</a>
    <h1>Game engines are more than libraries glued together</h1>
    
    <div id="readability-page-1" class="page"><div>
<figure>
	<img src="https://leafwing-studios.com/processed_images/d62ae7bf668eecf800.jpg" alt="SpongeBob, happy: I&#39;m going to put all these libraries together and make a game engine! SpongeBob, skeletalized: 10 years later..."/>
</figure>
<p><em>Meme from the <a href="https://twitter.com/reduzio/status/1550462229484560385">Twitter post</a> by Juan Linietsky, creator of <a href="https://godotengine.org/">Godot</a>, that inspired this blog post.</em></p>
<p>When starting a massive technical project (such as, in our case, a <a href="https://bevyengine.org/">game engine</a>),
the path of least resistance is to take a bunch of working components, glue them all together and then ship it!
What could be easier?</p>
<p>Unfortunately, it seems that empirically this simply doesn&#39;t work.
It&#39;s not a path to success:
GitHub is littered with failed projects taking this approach
while the most promising up-and-coming game engines (<a href="https://godotengine.org/">Godot</a>, <a href="https://bevyengine.org/">Bevy</a>, <a href="https://ourmachinery.com/">Our Machinery</a>)
eschew this in favor of a much more integrated design.</p>
<p>Why?
The underlying libraries (like <a href="https://www.libsdl.org/">SDL2</a> or <a href="https://www.opengl.org/">OpenGL</a>) may all be great, high quality pieces of software.
In fact, the engines that develop momentum often rely on these same foundational libraries,
and individual game projects (like <a href="https://www.paradoxinteractive.com/games/stellaris/about">Stellaris</a>) can succeed
by doing precisely the thing I&#39;m arguing you shouldn&#39;t do!</p>
<p>So what&#39;s the difference?
What <em>is</em> a game engine,
and why can&#39;t we make one by slapping high-quality libraries together in a sticky, gluey blob?</p>
<h2 id="game-engines-are-defined-by-their-communities"><a href="#game-engines-are-defined-by-their-communities" aria-label="Anchor link for: game-engines-are-defined-by-their-communities">Game engines are defined by their communities</a></h2>
<p>Let&#39;s begin with something controversial:
<em>a stack made for a single game is not a game engine</em>.</p>
<p>What <a href="https://www.factorio.com/">Factorio</a> did, what <a href="https://www.minecraft.net/en-us">Minecraft</a> did, what <a href="https://www.gamedeveloper.com/design/classic-tools-retrospective-tim-sweeney-on-the-first-version-of-the-unreal-editor">Quake</a> did?
Effective, but <strong>not an engine!</strong></p>
<p>Instead, they made something that could be replaced by a game engine,
but is a qualitatively different product.
As a <strong>single-game-stack</strong>, they have one goal:
make the game they were designed for as effectively as possible.</p>
<p>They don&#39;t need to care about:</p>
<ul>
<li><strong>attracting users</strong></li>
<li>efficiently teaching those new users</li>
<li>working on diverse developer hardware</li>
<li>managing backwards compatibility</li>
<li><strong>supporting diverse use cases</strong></li>
</ul>
<p>In exchange, they don&#39;t benefit from:</p>
<ul>
<li><strong>pooling development resources</strong>, either via licensing revenue or open source contributions</li>
<li>the architectural battle-hardening won by having to meet those <strong>harsher requirements</strong></li>
<li>a <strong>thriving ecosystem</strong> of learning materials, compatible assets and extensions</li>
</ul>
<p>Engines live and die on the strength of their <a href="https://discord.com/invite/bevy">communities</a>.
Single-game stacks are judged by how quickly, cheaply and effectively they can make the single game they were made for.</p>
<p>Single-game-stacks and game engines are two distinct things, each with their own strengths and challenges.
If you take a technique that works well for single-game-stacks (like gluing together libraries)
and apply it to making game engines,
past performance, as they say, is not a guarantee of future results.</p>
<h2 id="dependencies-are-great-but-glue-code-sucks"><a href="#dependencies-are-great-but-glue-code-sucks" aria-label="Anchor link for: dependencies-are-great-but-glue-code-sucks">Dependencies are great, but glue code sucks</a></h2>
<p>Don&#39;t get me wrong: libaries rock, and dependencies are Good, Actually.
Bevy has <a href="https://crates.io/crates/bevy/0.7.0/dependencies">dozens of them</a>, both direct and transitive!</p>
<p>Without libraries, your velocity will crawl to a halt,
and just as importantly, you won&#39;t be giving back to <a href="https://arewegameyet.rs/">the ecosystem</a>.</p>
<p>The problem here is the dreaded <strong>glue code</strong>:
code that exists solely to get everything to play nice together and talk to each other.
Glue code is brutal to maintain because:</p>
<ol>
<li>It breaks with alarming regularity whenever your dependencies change their major version.
<ol>
<li>No, don&#39;t just never update your dependencies. Bad!</li>
</ol>
</li>
<li>It is soul-sucking to write and update.
<ol>
<li>What, you thought game engine coding was all HDR rainbows and skeletally-animated unicorns?</li>
</ol>
</li>
<li>It&#39;s painful to test.
<ol>
<li>I hope you like writing mocks!</li>
</ol>
</li>
<li>It makes the cost of switching dependencies incredibly high.
<ol>
<li>Swapping an integration layer for a complex library is often nearly as much work as writing the code yourself.</li>
<li>Abstractions are lossy, and nothing will make you realize it faster than trying to swap a &#34;quick and easy&#34; integration.</li>
</ol>
</li>
<li>Maintaining glue code won&#39;t get you promoted, so it&#39;ll be <a href="https://rmurphey.com/posts/eng-ladder-glue-work/">neglected and left to rot</a>.
<ol>
<li>Open source may not care about promotions, but boy do contributors <em>hate</em> volunteering for tedious tasks.</li>
</ol>
</li>
</ol>
<p>If your entire engine is glue code: guess what the vast majority of your work will be.</p>
<h2 id="tight-cross-org-coordination-sucks-more"><a href="#tight-cross-org-coordination-sucks-more" aria-label="Anchor link for: tight-cross-org-coordination-sucks-more">Tight cross-org coordination sucks more</a></h2>
<p>It gets so much worse though.
Suppose you <em>need</em> that bug fix from your dependency,
or worse, want a shiny new feature to unblock your work?</p>
<p><strong>Roll a d12</strong> to determine what happens:</p>
<ol>
<li>You open an issue. It&#39;s ignored, then closed by <a href="https://drewdevault.com/2021/10/26/stalebot.html">stalebot</a> after two years.</li>
<li>You open an issue, but find that the work is blocked on a rewrite that&#39;s been ongoing for the past 18 months.</li>
<li>You open an issue, and find that the bug is &#34;working as intended&#34;.</li>
<li>Your dependency has been abandoned because the solo maintainer burned out.</li>
<li>Your dependency has been abandoned because the VC-backed company behind it was accquired.</li>
<li>You open a PR, which is promptly closed for failing to follow the coding style guide for the project.</li>
<li>You open a PR, and it sits unreviewed.</li>
<li>You open a PR, but the maintainer disagrees with your architectural choice. Spend 3 months in review discussions.</li>
<li>You open a PR, but another major user says it will break their workflow. Your PR is closed.</li>
<li>You try to open a PR, but find that the maintainer only accepts PGP-signed patches via plain text email. You waste two days setting this up.</li>
<li>You learn a new language, carefully read the style guide and <code>CONTRIBUTING.md</code>, submit a PR, wait 2 months and get the PR merged! You must wait 3 months for the next release.</li>
<li>A maintainer takes pity on you and actually just fixes your issue.</li>
</ol>
<p>Truly, can&#39;t you see all the time you&#39;re saving?
It&#39;s so Agileâ„¢!</p>
<p>So <strong>what makes a dependency Good?</strong></p>
<ul>
<li>permissive (or at least compatible) licensing</li>
<li>contributor-friendly culture</li>
<li>fast reviews, merges and releases</li>
<li>high bus factor</li>
<li>small or unopinionated scope</li>
<li>far from your core domain-specific logic</li>
<li>handles a lot of annoying edge cases for you (thanks <a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> and <a href="https://github.com/rust-windowing/winit"><code>winit</code></a>...)</li>
<li>aligned with your vision of what the library should be</li>
</ul>
<p>Unfortunately, if you&#39;re just gluing together libraries, you don&#39;t get to make that choice.
You can&#39;t pick good dependencies or bad ones (except between competitors):
you&#39;re stuck with what they give you.</p>
<h2 id="game-engines-need-a-competitive-edge"><a href="#game-engines-need-a-competitive-edge" aria-label="Anchor link for: game-engines-need-a-competitive-edge">Game engines need a competitive edge</a></h2>
<p>If you want to make a better game engine than <a href="https://unity.com/">Unity</a>,
or beat <a href="https://www.unrealengine.com/en-US">Unreal</a> at their own game,
you need a plan.</p>
<p>A real, honest-to-god plan:
none of this &#34;we&#39;ll hire the best and work really hard!&#34; pablum.
Trying hard is not a solution,
and it certainly is not a competitive edge.</p>
<p>Similarly, getting off the ground faster is not a competitive edge:
it simply closes the gap between you and the decade of work ahead of you to catch up
with the entrenched, multi-million dollar companies that you&#39;re hoping to compete with.</p>
<p>You cannot beat an entrenched competitor by playing their own game,
but catching up faster.
So what makes your engine different?
Who would use it, and why?</p>
<p>Gluing libraries together doesn&#39;t help here:
instead, it makes the problem worse.
Every library is opinonated:
you must either write your own, or smooth over the differences.</p>
<p>API design, <a href="https://github.com/bevyengine/bevy/tree/main/crates/bevy_ecs">data flow</a>, <a href="https://ourmachinery.com/post/the-anti-feature-dream/">core philosophy</a>, <a href="https://www.rust-lang.org/">programming language</a>:
you <em>must</em> coordinate here, or your engine will be:</p>
<ul>
<li>harder to <strong>learn</strong></li>
<li>harder to <strong>use</strong></li>
<li>harder to <strong>maintain</strong></li>
<li>harder to <strong>optimize</strong></li>
</ul>
<p>And once you&#39;ve glued libraries together,
and you&#39;ve rendered your test scene with blazing fast hyperrealistic shadows and a billion particles,
doing the <a href="https://en.wikipedia.org/wiki/Ninety%E2%80%93ninety_rule">second 90%</a> of the work feels brutal.
You&#39;re taking working code,
performing an unending series of cosmetic tweaks to it,
and throwing away all of the advantages you&#39;ve gained by reusing already working tools.</p>
<p>You&#39;re left with two options:</p>
<ol>
<li><strong>Don&#39;t refactor for a unified UX:</strong> Fail to accquire users, struggle to execute any grand vision, watch the tech debt pile higher.</li>
<li><strong>Refactor for a unified UX:</strong> Burn out your team, constantly break your users, frustrate investors with the lack of progress.</li>
</ol>
<p>Pick your poison.</p>
<h2 id="game-engines-need-vision"><a href="#game-engines-need-vision" aria-label="Anchor link for: game-engines-need-vision">Game engines need vision</a></h2>
<p>Ultimately, if you want to make the Next Great Game Engine (I do!),
your project needs a vision that will attract users, investors, toolmakers and contributors.</p>
<p>It needs <strong>features that set it apart</strong>,
<strong>problems it can solve better</strong> than any of the titans,
and a <strong>clear, unified model</strong> that it can teach to users and point at to keep tech debt at bay.</p>
<p>For <a href="https://godotengine.org/">Godot</a>, that&#39;s a pervasive focus on user-friendliness, the enduring value of open source and the value of a great editor-first workflow.</p>
<p>For <a href="https://ourmachinery.com/">Our Machinery</a>, that&#39;s an emphasis on hackability, the importance of performance, and the benefits of being able to build your own tools.</p>
<p>And for <a href="https://bevyengine.org/">Bevy</a>, that&#39;s a belief in <a href="https://ajmmertens.medium.com/ecs-from-tool-to-paradigm-350587cdf216">ECS as a general-purpose paradigm</a>, the ease of writing correct code in Rust, and the benefits of a thriving intercompatible ecosystem.</p>
<p>If you want to join us in shaping the future of game development,
you better be able to tell me: <strong>what does that shiny future look like?</strong></p>
</div><p>
	Thanks for reading: hopefully it was educational, thought-provoking, and/or fun.
	If you&#39;d like to read more like this in the future, consider signing up for our <a href="https://www.leafwing-studios.com/mailing-list">email list</a>
	or subscribing to our <a href="https://www.leafwing-studios.com/rss.xml">RSS feed</a>.
</p></div>
  </body>
</html>
