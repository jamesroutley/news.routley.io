<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developer.chrome.com/blog/wasmgc/">Original</a>
    <h1>WasmGC â€“ Run GC languages such as Kotlin, Java in Chrome browser</h1>
    
    <div id="readability-page-1" class="page"><div><p>There are two types of programming languages: garbage-collected programming languages and programming languages that require manual memory management. Examples of the former, among many more, are Kotlin, PHP, or Java. Examples of the latter are C, C++, or Rust. As a general rule, higher-level programming languages are more likely to have garbage collection as a standard feature. In this blog post, the focus is on such garbage-collected programming languages and how they can be compiled to WebAssembly (Wasm). But what is garbage collection (often referred to as GC) to begin with?</p><div><p><span>Browser support</span></p><ul><li><span data-browser="chrome"> <span>Chrome 119, Supported</span> </span><span aria-label="Supported" title="Supported" data-compat="yes"> 119 </span></li><li><span data-browser="firefox"> <span>Firefox, Not supported</span> </span><span aria-label="Not supported" title="Not supported" data-compat="no"></span></li><li><span data-browser="edge"> <span>Edge 119, Supported</span> </span><span aria-label="Supported" title="Supported" data-compat="yes"> 119 </span></li><li><span data-browser="safari"> <span>Safari, Not supported</span> </span><span aria-label="Not supported" title="Not supported" data-compat="no"></span></li></ul></div><h2 id="garbage-collection" tabindex="-1"><a href="#garbage-collection" aria-hidden="true">#</a> Garbage collection</h2><p>In simplified terms, the idea of garbage collection is the attempt to reclaim memory which was allocated by the program, but that is no longer referenced. Such memory is called garbage. There are many strategies for implementing garbage collection. One of them is <a href="https://en.wikipedia.org/wiki/Reference_counting">reference counting</a> where the objective is to count the number of references to objects in memory. When there are no more references to an object, it can be marked as no longer used and thus ready for garbage collection. <a href="https://www.php.net/">PHP</a>&#39;s garbage collector <a href="https://www.php.net/manual/en/features.gc.refcounting-basics.php">uses reference counting</a>, and using the <a href="https://xdebug.org/">Xdebug</a> extension&#39;s <a href="https://xdebug.org/docs/all_functions#xdebug_debug_zval"><code>xdebug_debug_zval()</code></a> function allows you to peek under its hood. Consider the following PHP program.</p><pre><code><span><span>&lt;?php</span></span></code></pre><p>The program assigns a random number casted to a string to a new variable called <code>a</code>. It then creates two new variables, <code>b</code> and <code>c</code>, and assigns them the value of <code>a</code>. After that, it reassigns <code>b</code> to the number <code>42</code>, and then unsets <code>c</code>. Finally, it sets the value of <code>a</code> to <code>null</code>. Annotating each step of the program with <code>xdebug_debug_zval()</code>, you can see the garbage collector&#39;s reference counter at work.</p><pre><code><span><span>&lt;?php</span></span></code></pre><p>The above example will output the following logs, where you see how the number of references to the value of the variable <code>a</code> decreases after each step, which makes sense given the code sequence. (Your random number will be different of course.)</p><pre><code>a:</code></pre><p>Reference counting is used in PHP, but most modern browsers now don&#39;t use reference-counting for garbage collection.</p><p>There are other challenges with garbage collection, like <a href="https://www.php.net/manual/en/features.gc.collecting-cycles.php">detecting cycles</a>, but for this article, having a basic level of understanding of reference counting is enough.</p><h2 id="programming-languages-are-implemented-in-other-programming-languages" tabindex="-1"><a href="#programming-languages-are-implemented-in-other-programming-languages" aria-hidden="true">#</a> Programming languages are implemented in other programming languages</h2><p>It may feel like inception, but programming languages are implemented in other programming languages. For example, the PHP runtime is primarily implemented in C. You can check out the <a href="https://github.com/php/php-src/">PHP source code on GitHub</a>. PHP&#39;s garbage collection code is mainly located in the file <a href="https://github.com/php/php-src/blob/master/Zend/zend_gc.c"><code>zend_gc.c</code></a>. Most developers will install PHP via the package manager of their operating system. But developers can also <a href="https://github.com/php/php-src/tree/master#building-php-source-code">build PHP from the source code</a>. For example, in a Linux environment, the steps <code>./buildconf &amp;&amp; ./configure &amp;&amp; make</code> would build PHP for the Linux runtime. But this also means that the PHP runtime can be compiled for other runtimes, like, you guessed it, Wasm.</p><h2 id="traditional-methods-of-porting-languages-to-the-wasm-runtime" tabindex="-1"><a href="#traditional-methods-of-porting-languages-to-the-wasm-runtime" aria-hidden="true">#</a> Traditional methods of porting languages to the Wasm runtime</h2><p>Independently from the platform PHP is running on, PHP scripts are compiled into the same bytecode and run by the <a href="https://en.wikipedia.org/wiki/Zend_Engine">Zend Engine</a>. The Zend Engine is a compiler and runtime environment for the PHP scripting language. It consists of the Zend Virtual Machine (VM), which is composed of the Zend Compiler and the Zend Executor. Languages like PHP that are implemented in other high-level languages like C commonly have optimizations that target specific architectures, such as Intel or ARM, and require a different backend for each architecture. In this context, Wasm represents a new architecture. If the VM has architecture-specific code, like just-in-time (JIT) or ahead-of-time (AOT) compilation, then the developer also implements a backend for JIT/AOT for the new architecture. This approach makes a lot of sense because often the main part of the codebase can just be recompiled for each new architecture.</p><p>Given how low-level Wasm is, it is natural to try the same approach there: Recompile the main VM code with its parser, library support, garbage collection, and optimizer to Wasm, and implement a JIT or AOT backend for Wasm if needed. This has been possible since the Wasm MVP, and it works well in practice in many cases. In fact, <a href="https://github.com/WordPress/wordpress-playground/blob/trunk/packages/php-wasm/compile/build.js">PHP compiled to Wasm</a> is what powers the <a href="https://playground.wordpress.net/">WordPress Playground</a>. Learn more about the project in the article <a href="https://web.dev/wordpress-playground/">Build in-browser WordPress experiences with WordPress Playground and WebAssembly</a>.</p><p>However, PHP Wasm runs in the browser in the context of the host language JavaScript. In Chrome, <a href="https://v8.dev/docs/wasm-compilation-pipeline">JavaScript and Wasm are run in V8</a>, Google&#39;s open source JavaScript engine that implements ECMAScript as specified in <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">ECMA-262</a>. And, <a href="https://chromium.googlesource.com/v8/v8.git/+/refs/heads/main/src/heap/cppgc/">V8 already has a garbage collector</a>. This means developers making use of, for example, PHP compiled to Wasm, end up shipping a garbage collector implementation of the ported language (PHP) to the browser that already has a garbage collector, which is as wasteful as it sounds. This is where WasmGC comes in.</p><p>The other problem of the old approach of letting Wasm modules build their own GC on top of Wasm&#39;s linear memory is that there&#39;s then no interaction between Wasm&#39;s own garbage collector and the built-on-top garbage collector of the compiled-to-Wasm language, which tends to cause problems like memory leaks and inefficient collection attempts. Letting Wasm modules reuse the existing built-in GC avoids these issues.</p><h2 id="porting-programming-languages-to-new-runtimes-with-wasmgc" tabindex="-1"><a href="#porting-programming-languages-to-new-runtimes-with-wasmgc" aria-hidden="true">#</a> Porting programming languages to new runtimes with WasmGC</h2><p>WasmGC is a <a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md">proposal</a> of the <a href="https://www.w3.org/community/webassembly/">WebAssembly Community Group</a>. The current Wasm MVP implementation is only capable of dealing with numbers, that is, integers and floats, in linear memory, and with the <a href="https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md">reference types</a> proposal being shipped, Wasm can additionally hold on to external references. WasmGC now adds struct and array heap types, which means support for non-linear memory allocation. Each WasmGC object has a fixed type and structure, which makes it easy for VMs to generate efficient code to access their fields without the risk of <a href="https://web.dev/speed-v8/#de-optimization">deoptimizations</a> that dynamic languages like JavaScript have. This proposal thereby adds efficient support for high-level managed languages to WebAssembly, via struct and array heap types that enable language compilers targeting Wasm to integrate with a garbage collector in the host VM. In simplified terms, this means that with WasmGC, porting a programming language to Wasm means the programming language&#39;s garbage collector no longer needs to be part of the port, but instead the existing garbage collector can be used.</p><p>To verify the real-world impact of this improvement, Chrome&#39;s Wasm team has compiled versions of the <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/fannkuchredux.html">Fannkuch benchmark</a> (which allocates data structures as it works) from <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-gcc-5.html">C</a>, <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-rust-2.html">Rust</a>, and <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-java-2.html">Java</a>. The C and Rust binaries could be anywhere from <em>6.1 K</em> to <em>9.6 K</em> depending on the various compiler flags, while the Java version is much smaller at only <em>2.3 K</em>! C and Rust do not include a garbage collector, but they do still bundle <code>malloc/free</code> to manage memory, and the reason Java is smaller here is because it doesn&#39;t need to bundle any memory management code at all. This is just one specific example, but it shows that WasmGC binaries have the potential of being very small, and this is even before any significant work on optimizing for size.</p><h2 id="seeing-a-wasmgc-ported-programming-language-in-action" tabindex="-1"><a href="#seeing-a-wasmgc-ported-programming-language-in-action" aria-hidden="true">#</a> Seeing a WasmGC-ported programming language in action</h2><h3 id="kotlin-wasm" tabindex="-1"><a href="#kotlin-wasm" aria-hidden="true">#</a> Kotlin Wasm</h3><p>One of the first programming languages that has been ported to Wasm thanks to WasmGC is <a href="https://kotlinlang.org/">Kotlin</a> in the form of <a href="https://kotl.in/wasmgc">Kotlin/Wasm</a>. The <a href="https://kotlin-wasm-hello-world.glitch.me/">demo</a>, with <a href="https://github.com/Kotlin/kotlin-wasm-examples/tree/main/browser-example">source code</a> courtesy of the Kotlin team, is shown in the following listing.</p><pre><code><span>import</span> kotlinx<span>.</span>browser<span>.</span>document</code></pre><p>To see the demo, you need to set the browser flags as per the instructions on the screen.</p><p>Now you may be wondering what the point is, since the Kotlin code above basically consists of the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/org.w3c.dom/">JavaScript OM APIs converted to Kotlin</a>. It starts to make more sense in combination with <a href="https://www.jetbrains.com/lp/compose-multiplatform/">Compose Multiplatform</a>, which allows developers to build upon the UI they may already have created for their Android Kotlin apps. Check out an early exploration of this with the <a href="https://kotlin-wasm-image-viewer.glitch.me/">Kotlin/Wasm image viewer</a> demo and explore its <a href="https://github.com/Kotlin/kotlin-wasm-examples/tree/main/compose-imageviewer">source code</a>, likewise courtesy of the Kotlin team.</p><div><div><svg fill="none" width="24" height="24" viewBox="0 0 24 24"><path d="M23 21L12 2 1 21h22zm-12-3v-2h2v2h-2zm0-4h2v-4h-2v4z" fill-rule="evenodd" clip-rule="evenodd"></path></svg><p><span>Warning</span></p></div><p>In this early experimental stage, the <a href="https://kotlin-wasm-image-viewer.glitch.me/">Kotlin/Wasm image viewer</a> demo is fully rendered onto a <code>canvas</code> with no meaningful DOM tree that could be used to create an <a href="https://developer.mozilla.org/docs/Glossary/Accessibility_tree">accessibility tree</a>. This means it&#39;s completely inaccessible to non-sighted users and breaks important browser features like find on page, translation, text selection, extensions, zooming, and link to text fragment.</p></div><h3 id="dart-and-flutter" tabindex="-1"><a href="#dart-and-flutter" aria-hidden="true">#</a> Dart and Flutter</h3><p>The Dart and Flutter teams at Google are also preparing support for WasmGC. The Dart-to-Wasm compilation work is almost complete, and the team is working on tooling support for delivering Flutter web applications compiled to WebAssembly. You can read about the current state of the work in the <a href="https://flutter.dev/wasm">Flutter documentation</a>. The following demo is the <a href="https://flutterweb-wasm.web.app/">Flutter WasmGC Preview</a>.</p><h2 id="learn-more-about-wasmgc" tabindex="-1"><a href="#learn-more-about-wasmgc" aria-hidden="true">#</a> Learn more about WasmGC</h2><p>This blog post has barely scratched the surface and mostly provided a high-level overview of WasmGC. To learn more about the feature, check out these links:</p><ul><li><a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md">WasmGC Overview</a></li><li><a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/MVP.md">WasmGC MVP</a></li><li><a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/Post-MVP.md">WasmGC post-MVP</a></li></ul><h2 id="acknowledgements" tabindex="-1"><a href="#acknowledgements" aria-hidden="true">#</a> Acknowledgements</h2><p>Hero image by <a href="https://unsplash.com/@gary_at_unsplash">Gary Chan</a> on <a href="https://unsplash.com/photos/YzSZN3qvHeo">Unsplash</a>. This article was reviewed by <a href="https://github.com/Liedtke">Matthias Liedtke</a>, <a href="https://github.com/ajklein">Adam Klein</a>, <a href="https://github.com/inexorabletash">Joshua Bell</a>, <a href="https://github.com/kripken">Alon Zakai</a>, <a href="https://github.com/jakobkummerow">Jakob Kummerow</a>, <a href="https://github.com/backes">Clemens Backes</a>, <a href="https://github.com/ecmziegler">Emanuel Ziegler</a>, and <a href="https://rachelandrew.co.uk/">Rachel Andrew</a>.</p></div></div>
  </body>
</html>
