<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.harudagondi.space/blog/rust-documentation-ecosystem-review/">Original</a>
    <h1>A Rust Documentation Ecosystem Review</h1>
    
    <div id="readability-page-1" class="page"><div>  <article id="main-content">  <p><strong>Reading time:</strong> 100 min read</p> <span> <hr/> <h2>
Table of Contents
</h2> <p><a href="#what-are-the-four-quadrants">1.1</a> What are the four quadrants?</p><p><a href="#why-are-they-important-and-is-it-worth-it">1.2</a> Why are they important? And is it worth it?</p><p><a href="#the-rust-ecosystem-review">1.3</a> The Rust Ecosystem Review</p><p><a href="#the-rust-official-documentation">1.3.24</a> The Rust Official Documentation</p><p><a href="#analysis-of-crates">1.4</a> Analysis of Crates</p><p><a href="#conclusion">1.5</a> Conclusion</p> <hr/> </span> <figure id="image-post">  <label for="mathematics-formulas-temporal-logic-in-a-phd-thesis" data-astro-cid-ascxwteo=""> <img src="https://www.harudagondi.space/uploads/doc-quad/2048px-Formules.jpg" alt="Mathematics formulas (temporal logic) in a PhD thesis." data-astro-cid-ascxwteo=""/> </label> <figcaption> <p>Photo by <a href="https://unsplash.com/@rocinante_11">Guillaume Piolle</a>.</p> </figcaption> </figure>
<p>I’ve been thinking about documentation lately.</p>
<p>Anecdotally, documenting code is somehow one of the least favorite things programmers do. when developing. However, it is undeniable that documentation is essential when it comes to teaching beginners. In fact, one of the most typical ways people can begin their journey in programming is by following a YouTube video tutorial, or reading a book, or tinkering with examples in the “recipe” of your choice. Without such resources (or access to such), less people will be introduced to the field of programming and software development.</p>
<p>Clearly, documentation is important. We read manuals. We read books. We watch video tutorials. And yet, it is an afterthought of a lot of developers, especially those who publish libraries for people to use. <em>Especially</em> for people who want such libraries to be popular. Reading documentation is the way for beginners to learn, and the way for experts to remember.</p>
<p>But what constitutes good documentation?</p>
<p>Documentation quality is something that’s not very easy to measure. There are no guidelines to determine whether or not documentation qualifies as satisfactory to the intended audience. However, there are some signs that can tell whether the documentation is <em>bad</em>. An obvious example is the <em>lack</em> of documentation. How would people understand your library if you don’t have the means to teach it?</p>
<p>There are also other, more <em>subtle</em> ways why someone could say the documentation is bad. In newer libraries, the documentation they have is just the API reference. You could glean the meaning of each function and each class and each struct and each record, but the way it can be put together is non-obvious. How do you use so-and-so function? What’s the entry point of this library? Why was this framework architectured this way?</p>
<p>Sometimes, when I don’t see the answer in the documentation. I’ll have to resort to asking people on Discord. I’ll get an answer, I’ll say thank you, and then I don’t think about the Discord server for at least three years. But then, I would think about the next person who would ask the same question, and if they would think twice about using Discord. We have to admit that Discord isn’t an accessible place. It’s a walled garden, and the search functionality is dead. Forums are a much better solution to this, as it has better search indexing and more prominent, but it’s rare to see it in some places.</p>
<p>Ah, discoverability. It’s hard to discover new things without either reading the whole API reference or consume several hundred hours worth of tutorials. Do I need to read the newsletter for each new added feature? Do I need to see some obscure esoteric code in some random Discord channel? There were a lot of cases where people discover and rediscover the <a href="https://doc.rust-lang.org/reference/patterns.html#r-patterns.ident.scrutinized"><code>@</code> syntax</a> after months of dabbling in Rust and I was kinda surprised, since it was actually discussed in the <a href="https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html#-bindings">Rust Book on the chapter of patterns</a>. Is the Rust Book not approachable enough?</p>
<p>I’m sure there are many other criteria that determine the quality of documentation, but I want to focus on these three, based on the previous anecdotes I’ve stated:</p>
<ol>
<li>Comprehensiveness — the amount of substance on the topic</li>
<li>Discoverability — how easily can you explore new topics</li>
<li>Philosophy — knowing the reasoning of the choices made in the library</li>
<li>Approachability — is the documentation intimidating or not</li>
</ol>
<p>As I’ve been thinking of such topics, I came across this image somewhere:</p>
 <label for="the-ditaxis-system-or-the-documentation-quadrants" data-astro-cid-ascxwteo=""> <img src="https://www.harudagondi.space/uploads/doc-quad/diataxis.png" alt="The Diátaxis system, or the documentation quadrants" data-astro-cid-ascxwteo=""/> </label>
<p>It seems interesting, as it neatly categorized documentation to four topics. Let’s investigate what is the meaning of this image, shall we?</p>
<section><h2 id="what-are-the-four-quadrants">What are the four quadrants?<a aria-hidden="true" tabindex="-1" href="#what-are-the-four-quadrants"> #</a></h2><p>I’ve tracked this image down. It’s from the site called <a href="https://diataxis.fr">diataxis.fr</a>. According to the website, the term <em>Diátaxis</em> refers to the “systematic approach to technical documentation authoring”. It’s derived from the Ancient Greek <em>δῐᾰ́τᾰξῐς</em>, “dia” meaning across and “taxis” meaning arrangement.</p><p>It mentions that it solves the knowledge management problem by prescribing a system of four quadrants: <em>tutorials</em>, <em>how-to guides</em>, <em>technical reference</em>, and <em>explanations</em>. I recommend reading the whole website to fully understand what each quadrant entails, but to summarize:</p><ol>
<li>A <a href="https://diataxis.fr/start-here/#tutorials">tutorial</a> is a <em>practical learning experience, where the user learns by doing</em>.</li>
<li>A <a href="https://diataxis.fr/start-here/#how-to-guides">how-to guide</a> is a <em>manual that addresses a real-world goal or problem</em>.</li>
<li>A <a href="https://diataxis.fr/start-here/#reference">reference</a> is a <em>factual collection of documentation that contains the technical description</em>.</li>
<li>An <a href="https://diataxis.fr/start-here/#reference">explanation</a> <em>describes the philosophy and provides context on why something is so-and-so</em>.</li>
</ol><p>Additional, the <em>Diátaxis</em> compass (referring to the image above) shows the relationship between each system. Tutorials and how-to guides are driven by <em>action</em>; what the user <em>does</em> takes the driver’s seat in this scenario. On the other hand, references and explanations are driven by <em>cognition</em>; what the user <em>knows</em> is the main character of this story.</p><p>Action vs. cognition is not the only axis we can extract from this graph. Tutorials and explanations are useful when a user wants to <em>acquire</em> the knowledge and skill required for the usage of a library, while how-to guides and references are for when a user wants to <em>apply</em> said knowledge and skill to the task at hand.</p><p>The website has a more comprehensive overview of what constitutes good documentation for each variant, but for now I’m not going to delve into that. Instead, I’ll discuss it later as needed when we survey the Rust ecosystem’s approach to documentation.</p></section>
<section><h2 id="why-are-they-important-and-is-it-worth-it">Why are they important? And is it worth it?<a aria-hidden="true" tabindex="-1" href="#why-are-they-important-and-is-it-worth-it"> #</a></h2><p>I want to return to the criteria of what I believe is important in documentation: comprehensiveness, discoverability, and philosophy. How do the four quadrants measure up to these criteria (that I just made up lol)?</p><section><h3 id="tutorials">Tutorials<a aria-hidden="true" tabindex="-1" href="#tutorials"> #</a></h3><p>In the context of the <em>Diátaxis</em> system, tutorials are not comprehensive at all. It operates on a “learn what you only need” basis, and thus it does not aim to discuss the entirety of what can be discussed about a library. As such, its main purpose is to impart only the necessary knowledge without getting into the weeds of things. This is not to say that tutorials are useless; it’s just that it never aims to be comprehensive in the first place.</p><p>What it makes up for it is the discoverability. Tutorials are typically for complete beginners. It introduces the main API needed to get started and get going with the library. It allows the user to know what and where to look for. And of course, it solves the problem of “you don’t know what you don’t know”. By knowing the main and important interfaces needed to interact with the library, it jumpstarts your journey and allows the opportunity to go deeper.</p><p>However, tutorials are not good for explaining the philosophy of the library. A tutorial serves as a learning experience, and I would say <em>learning</em> is not the same as <em>understanding</em>. You don’t need to understand why a function looks a certain way, or why a codebase is architected like that. A user may just simply want to <em>do</em> something, and the method to learn how to do it is simply a linear no-frills guide that takes you from point A to point B. It is not a realistic depiction of what to do when there are unexpected outcomes. It does not diagnose. It is contrived. It doesn’t give choices. It is easy to do, and therefore useful for learning the methods but not understanding the philosophy.</p><p>Lastly, by its nature, tutorials are very approachable. It assumes you know nothing. It guides your hand. It handles all possible situations for you. You just have to follow the steps and get a product. Simple, easy, fast.</p></section><section><h3 id="how-to-guides">How-to guides<a aria-hidden="true" tabindex="-1" href="#how-to-guides"> #</a></h3><p>Unlike tutorials, which is aimed at people who doesn’t have knowledge to start using the library, how-to guides is typically targeted to people with at least basic competence on the topic at hand.  They are not for learning the tools, but for achieving goals with those tools. It’s not for studying, it’s for application in real-world scenarios. As such, how-to guides are typically more comprehensive since it discusses beyond what a tutorial would discuss. As the Diátaxis website discusses, it serves your <em>work</em>, not your <em>study</em><sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> A good guide to distinguish between the two is that tutorials discuss <em>the basics</em> and how-to guides discuss <em>the advanced</em>  </span> . A real-world situation is more complex than idealized scenarios. As such, the documentation shall be appropriate for that situation, and discusses the possible mishaps and unexpected events that may happen, plus the appropriate tools for those.</p><p>As a natural extension, how-to guides has more discoverability when compared to tutorials, given the nature of anticipating the user and unexpected outcomes. It has to give more information depending on the scenario. This necessitates introducing new API that may not be introduced in a tutorial, for fear of overwhelming the user with complexity.</p><p>Due to the goal oriented format of how-to guides, the explanation of why an interface is the way it is is not at the forefront. As such, like tutorials, it omits details for understanding and just gets straight to giving you the answers.</p><p>Unlike tutorials however, how-to guides expect basic competence. It does not hold your hand. It doesn’t idealize scenarios. It assumes familiarity with the subject. It gives you choices that you have to make. Therefore, for a beginner, it is less approachable compared to a tutorial, but for someone who knows their stuff, how-to guides may be more up their speed.</p></section><section><h3 id="references">References<a aria-hidden="true" tabindex="-1" href="#references"> #</a></h3><p>Ah. the most common documentation format and the least approachable. It is good for learning a library in terms of its parts, but it is not a good format for learning a library in whole. You don’t really know how to start, nor how to solve problems because a reference does not typically give you the whole picture. It is useful for examining its items, less useful in extracting the relationships between items, and least useful when developing a program out of its entirety.</p><p>It is, for what its worth, maximally comprehensive by design. It describes each item in detail (hopefully), and answers any and all potential questions by the user. Does it throw an error? If so, in which scenarios and what corresponding errors does it return? Is there any special behavior I have to take note?</p><p>However, it does not explain its philosophy very well. References are, by design, cold, and exacting. No ambiguities, totally authoritative. As the Diátaxis website states: “One hardly <em>reads</em> reference material; one <em>consults</em> it.” It is not the <em>why</em>. It is the <em>what</em> of the library.</p><p>I guess its discoverability is both at its maximum and minimum. Maximum, because you can discover absolutely everything here. Minimally, because it is not a good way to naturally discover anything. There’s no motivation that is presented here, and so there’s no reason to discover anything yet.</p></section><section><h3 id="explanation">Explanation<a aria-hidden="true" tabindex="-1" href="#explanation"> #</a></h3><p>Based on my experience, the explanation is probably one of the rarest format of documentation there ever is. It’s rare that someone would write about the reasoning why they coded it a certain way. You’ll just see the changelog be like <a href="https://github.com/rust-random/rand/releases/tag/0.9.0">“Renamed <code>DistString</code> to <code>SampleString</code>”</a> whose motivation is stated in the PR. Rare will you see an official writeup why the maintainer decided to architected it in some way, and why it was necessary to do so.</p><p>Continuing with analyzing each documentation format by my own criteria, explanations are approachable for people with basic competency and teaches its philosophy very well. Teaching the reasoning is what makes explanations so useful. It gives the user a concrete way to grok things instead acting like the library is a black box. It lessens the frustrations of beginners, as it goes beyond the common response of “it is what it is.” It gives the motivation of the library, why it exist, why it works like that, and why not like this other way. It is the greatest tool for understanding things.</p><p>It can be a tool for discoverability and comprehensiveness. The author/maintainer of the library has the opportunity to showcase what the ideal program you could make with their library, and what functions and types they showcase may not be familiar to you. The maintainer can unfold the secret of the machinery and possibly introduce you to some topics that is not normally talked about in everyday usage.</p></section><section><h3 id="to-recap">To recap…<a aria-hidden="true" tabindex="-1" href="#to-recap"> #</a></h3><p>Here’s a simple table on what I think each documentation quadrant can provide, based on the criteria I devised:</p>







































<table><thead><tr><th></th><th>Tutorial</th><th>How-to Guide</th><th>Reference</th><th>Explanation</th></tr></thead><tbody><tr><td>Comprehensiveness</td><td>⚠</td><td>⚠</td><td>✅</td><td>⚠</td></tr><tr><td>Discoverability</td><td>✅</td><td>✅</td><td>⚠</td><td>⚠</td></tr><tr><td>Philosophy</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>Approachability</td><td>✅</td><td>⚠</td><td>❌</td><td>⚠</td></tr></tbody></table><p>Legend:</p><ul>
<li>✅: Achieves the criteria</li>
<li>⚠: Has some lapses</li>
<li>❌: Does not achieve in any good way.</li>
</ul><p>At a glance, tutorials and how-to guides are very similar, differing from their approachability. However, the issues I have with in terms of comprehensiveness are different. Tutorials are not comprehensive in the sense that it does not introduce you to every idea ever, but it is comprehensive in that it has anticipated every problem the beginner might face because that would be the author’s responsibility to help you. On the other hand, how-to guides are more comprehensive than tutorials because of its increased complexity, but it falls under the same situation where it doesn’t necessarily introduce you to the entire library.</p><p>References are maximally comprehensive, as by design, but it is the only quadrant that is not approachable by any means. Accordingly, It is very useful for consultation of topics but not learning of said topics.</p></section></section>
<section><h2 id="the-rust-ecosystem-review">The Rust Ecosystem Review<a aria-hidden="true" tabindex="-1" href="#the-rust-ecosystem-review"> #</a></h2><p>Now, with what we’ve learned about the four quadrants and criteria I have on hand, we can survey the Rust ecosystem and see if they hold up to our standards. I will pick a selection of crates from the <a href="https://blessed.rs/crates">blessed.rs</a> website, with some additional crates not mentioned that I think could be useful for comparison. To start, here are the crates I’ve picked:</p><ol>
<li><code>rand</code></li>
<li><code>fastrand</code></li>
<li><code>chrono</code></li>
<li><code>time</code></li>
<li><code>jiff</code></li>
<li><code>axum</code></li>
<li><code>actix-web</code></li>
<li><code>rocket</code></li>
<li><code>bevy</code></li>
<li><code>macroquad</code></li>
<li><code>fyrox</code></li>
<li><code>thiserror</code></li>
<li><code>anyhow</code></li>
<li><code>snafu</code></li>
<li><code>clap</code></li>
<li><code>pico-args</code></li>
<li><code>ratatui</code></li>
<li><code>egui</code></li>
<li><code>iced</code></li>
<li><code>wgpu</code></li>
<li><code>tokio</code></li>
<li><code>smol</code></li>
<li><code>embassy</code></li>
<li>Rust’s official documentation</li>
</ol><p>I’ll be measuring the quality of their documentation by the criteria I’ve set and checking the existence of the documentation quadrants I’ve discussed beforehand. I will not, however, be measuring the quality of the code or the API of the library. The goal here is to check if the ecosystem matches my expectations of what good documentation should be.</p><section><h3 id="rand"><code>rand</code><a aria-hidden="true" tabindex="-1" href="#rand"> #</a></h3><p><code>rand</code><sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> As of writing, the version is 0.9.1  </span>  was the first on the list of the blessed.rs website. So naturally let’s look at it first.</p><p>The <a href="https://crates.io/crates/rand">crates.io</a> page has a general overview written, linking the different random number generators (RNGs), its features, anti-features, and platform support. Seems reasonable for an overview. Plus, it has a lot of links to third party crates, to its book (that we will discuss later), and some open source specific stuff.</p><p>The <a href="https://docs.rs/rand/latest/rand/">docs.rs</a> page of rand is simple. A quick start and then a link of <a href="https://rust-random.github.io/book/">The Rust Rand Book</a>. Before we check out the book, let’s first look at the API reference.</p> <label for="docs-in-the-rand-crate" data-astro-cid-ascxwteo=""> <img src="https://www.harudagondi.space/uploads/doc-quad/rand-docs.png" alt="Docs in the `rand` crate" data-astro-cid-ascxwteo=""/> </label><p>The short descriptions is informative that you can differentiate between each type. The difference between<code>Rng</code>/<code>RngCore</code> seem non-obvious from its name, so the docs spelled it out by indicating that <code>Rng</code> is the user-level interface while <code>RngCore</code> is the implementation-level interface. Also, the functions’ docs do go beyond its name. <code>random</code> mentions the thread-local random number generator. <code>random_ratio</code><sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> Note that I consider the names as part of the docs.  </span>  is surprising; the name implies returning a rational number (?), but actually it returns a boolean with a customizable weight for <code>true</code>. I would’ve named it <code>weighted_random_bool</code>, but that seems too clunky. Ugh, naming is hard.</p><p>The traits and modules do have more substance. <a href="https://docs.rs/rand/latest/rand/trait.Rng.html"><code>Rng</code></a> has docs for its usage as a trait bound of generics, while <a href="https://docs.rs/rand/latest/rand/distr/index.html"><code>rand::distr</code></a> has a high level view on probability distributions, default distribution used by the crate, and the other distributions that are available.</p><p>What I’ve noticed is that there’s not much tutorials and how-to guides on the <code>docs.rs</code> page, other than the quickstart example on the main page. Speaking of the main page, let’s look at the book linked in it.</p><p>The introduction of the book contains a simple table of contents, and external links that concerns this project. Skimming through the book, it shows:</p><ol>
<li>A more fleshed out quickstart example</li>
<li>The project architecture, its features, platform support, and reproducibility guarantees</li>
<li>A comprehensive guide to using random number generators using <code>rand</code> (yes, simulating randomness is a deep topic)</li>
<li>Migration guides</li>
<li>Contributing guidelines</li>
</ol><p>I applaud the main guide and migration guide; These are indepth, well written documentation that gives us the explanation needed for these topics. I like that I can discover the different types of RNGs in the ecosystem, the different distributions available, a topic I didn’t know (stochastic processes), fallibility of RNGs, and testing randomness. It discusses the terminologies to beginners, gives a comparison between different generators, and gives notes on its performance and quality. Thus, it feels approachable for someone who has basic competence on what random generators, but has not delved into it deeper. For absolute beginners, I think that the quickstart examples from both <code>docs.rs</code> and the rand book is sufficient enough to get started.</p><p>Lastly. <code>rand</code> is 100% documented according to <code>docs.rs</code>. Nice.</p></section><section><h3 id="fastrand"><code>fastrand</code><a aria-hidden="true" tabindex="-1" href="#fastrand"> #</a></h3><p>According to the <a href="https://docs.rs/fastrand/latest/fastrand/">documentation</a>, <code>fastrand</code> is a “simple and fast random number generator.” It uses Wyrand as its generator.</p><p>At first glance, it shows multiple simple examples, its cargo features, and notes on WebAssembly usage.</p><p>I don’t expect much from <code>fastrand</code>. It aims to be simple and easy. I wish it mentions what distribution it uses. It is 100% documented, but the documentation is repetitive. But what can you say? Not much.</p></section><section><h3 id="chrono"><code>chrono</code><a aria-hidden="true" tabindex="-1" href="#chrono"> #</a></h3><p>The <a href="https://crates.io/crates/chrono">crates.io</a> page discusses the high level overview of its features, including a Wikipedia link to the <a href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">proleptic Gregorian calendar</a>. Which is nice.</p><p>The main page on <a href="https://docs.rs/chrono/0.4.40/chrono/">docs.rs</a> is <em>meaty</em>.</p><p>Of course.</p><p>Time is… erm, <a href="https://youtu.be/-5wpm-gesOY?si=Wx5qXO1gqWyKmRZY"><em>complicated</em></a>.</p><p>The high level overview from the crates.io page was repeated here. It also adds all the <a href="https://docs.rs/chrono/0.4.40/chrono/#features">cargo features and their uses</a>. It has an in-depth explanations and examples, grouped in different sections, filled with hyperlinks to the corresponding functions used.</p><p>Even they discuss the relation between <a href="https://docs.rs/chrono/0.4.40/chrono/#features"><code>chrono</code> and <code>time</code> 0.1</a>!</p><p>So in terms of the four quadrants, explanations and how-to guides (via the recipe examples they gave) hold up. Does it have tutorials? Gleaning from the page, I don’t think so. Does it <em>need</em> a tutorial? It’s a library. I don’t think there’s an idealized end product to made, complete with idealized scenarios. Time is a finicky thing; a library needs to handle any and all potential mishaps and problems that may occur. Thus, the main page consists of multiple how-to guides, detailing the different ways a user  can handle certain situations. How do I format my <code>DateTime</code>s? The <a href="https://docs.rs/chrono/0.4.40/chrono/#formatting-and-parsing">example</a> provides nine ways to do it, each differing in the output.</p><p>On the basis of quadrants, we can see that there’s a lot of how-to guides and explanations, and we judged that tutorials aren’t that necessary. What about the reference?</p><p>For starters, we can see that the library is 100% documented. Nice.</p><p>The short descriptions are clear enough. <code>NaiveDate</code> has the description “ISO 8601 calendar date without timezone. Allows for every <a href="https://docs.rs/chrono/0.4.40/chrono/struct.NaiveDate.html#calendar-date" title="struct chrono::NaiveDate">proleptic Gregorian date</a> from Jan 1, 262145 BCE to Dec 31, 262143 CE. Also supports the conversion from ISO 8601 ordinal and week date.”, which is better than just saying “Timezone-less date”, for example. It’s complete. It’s informative. It even has a link to itself, which is kinda funny.</p><p>Clicking on the <code>NaiveDate</code> type leads me its docs, which is also extensive. It explains the caveats of the proleptic Gregorian calendar. Then, it explains what a week date is, and how the year number of a week date may not correspond to the actual Gregorian year. Lastly, it discusses the ordinal date as the internal format of <code>chrono</code>’s date types.</p><p>The subitems of <code>NaiveDate</code> are also interesting. <code>NaiveDate::MIN</code> and <code>NaiveDate::MAX</code> not only state the obvious (that it is the minimum/maximum possible <code>NaiveDate</code>), but also the actual constant<sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> If you’re curious, the minimum possible <code>NaiveDate</code> is January 1, 262144 BCE while the maximum possible <code>NaiveDate</code> is December 31, 262142 CE.  </span> . Some of the associated functions also include the “Errors” and “Panics” sections, which indicates that this project may be using <a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_errors_doc">pedantic lints</a>! That’s a plus in my book, I just hope they pick and choose instead of blindly doing <code>#![warn(clippy::pedantic)]</code>.</p><p>From this skim, I’d say it has an okay amount of how-to guides to help the people with basic competencies and some discussions that dig into the history of things. However, word of warning, I’m not particularly well versed in time-related crates and do not know the deficiencies doc-wise without reading the issues on the repo and hearing about testimonials. Nevertheless, at a glance, this seems like a good look. If you, the reader, have found some lapses in the docs, or any docs for the matter, I would love to learn more to improve my heuristics of what makes a certain documentation good or bad.</p><p>The docs are somewhat comprehensive in terms of the main section. The discoverability is nice since there’s a lot of starting points to go to when needed. It is approachable with lots of how-to-guides and some of its design was moderately explained at the end.</p></section><section><h3 id="time"><code>time</code><a aria-hidden="true" tabindex="-1" href="#time"> #</a></h3><p>The <a href="https://crates.io/crates/time">crates.io</a> README only has links the docs.rs page, the <a href="https://time-rs.github.io/book/">Time Book</a>, the MSRVP, the contributing guidelines, and the license. Compared to <code>chrono</code>, my impressions are that it is a bit sparser as it does not include an explanation to what kind of calendar it uses. Nevertheless, it links to an <code>mdbook</code> page, which is a lot more interesting than just putting the explanations and guides in the top-level document.</p><p>Before we move on to the book, let’s first check out what’s going on with the <a href="https://docs.rs/time/0.3.41/time/">docs.rs</a> page. The page contains a section on its feature flags.. and that’s it. I’ll comment on the reference later. Let’s look at the Time Book instead.</p><p>The introduction sells the <code>time</code> crate with its features, including being an “easy and safe” crate that is “space optimal and efficient.” I’m not going to test these claims, as the goal of this blog post is to have a shallow analysis on the documentation of selected crates. Instead, let’s continue on skimming through the book.</p><p>My thoughts:</p><ol>
<li>For starters, there are some chapters that don’t have any content on it. <code>mdbook</code> does have support for <a href="https://rust-lang.github.io/mdBook/format/summary.html">draft chapters</a>, so I’m curious why <code>time</code> didn’t opt into it.</li>
<li>There is a section called “How-to guides” and a section called “Technical reference”. I wonder if the <code>time</code> authors knew about the Diátaxis method.</li>
<li>The how-to guides seems not very comprehensive. It only discusses creation and parsing of <code>Date</code>/<code>Time</code> types. It doesn’t seem to discuss about possible unexpected scenarios like non-existent dates or leap seconds or whatever and how to handle them.</li>
<li>The technical reference has some explanations, which is what I kinda expected when someone makes a book that contains a “reference” section. It discusses some decisions on API design and why they were made, or just lists out grammar diagrams (which I appreciate at lot).</li>
<li>The rest of the book do not have any content in it, so the table of contents kinda misled me into thinking this book was gonna be substantial.</li>
</ol><p>Now we got the Time Book out of the way, let’s move on the <code>docs.rs</code> page proper. Clicking on the <code>Date</code> struct, we see a sparser discussion on what a Date is, and seems like the majority of the method docs only consist of one-to-two sentences description and code snippets full of asserts. I am guessing that they are using the documentation mainly for tests. I’d appreciate enabling the pedantic lints mentioned earlier.</p><p>Clicking on the modules honestly makes me disappointed. The module docs consists of a single sentence, and rarely you see a paragraph. The <code>serde</code> module has the docs “Differential formats for serde” which is vague, and its submodules only links to the corresponding RFC/ISO formats. I’d appreciate some examples at least of how to use these modules with serde. For what it’s worth, <a href="https://docs.rs/time/0.3.41/time/serde/macro.format_description.html"><code>time::serde::format_description!</code></a> does have significant docs. My gripe is that it isn’t that discoverable, since the time book doesn’t have any content on the <a href="https://time-rs.github.io/book/api/formatting.html">formatting chapter</a> and the <a href="https://time-rs.github.io/book/third-party/serde.html"><code>serde</code></a> chapter.</p><p>Comparing this to <code>chrono</code>, I’m gonna say that <code>time</code> has… documentation of lesser quality. The discoverability is not that great, and the reference is lacking. Since there’s less content, it is not that approachable. One thing about the Time Book however is that for the pages that are written, at least there were explanation for some design choices of the library.</p></section><section><h3 id="jiff"><code>jiff</code><a aria-hidden="true" tabindex="-1" href="#jiff"> #</a></h3><p><code>jiff</code> wasn’t in the blessed.rs site, but I added it because I remembered that (1) it’s a new library by <a href="https://github.com/BurntSushi">burntsushi</a><sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> Known for <code>regex</code>, <code>ripgrep</code>,<code>bstr</code>, and many, many more.  </span> , and (2) I was very impressed by its documentation. So I want to revisit that. Now, let’s look at its <a href="https://crates.io/crates/jiff">crates.io</a> page.</p><p>The README gives an overview, list of hyperlinks for its documentation, an example, a usage tutorial for absolute beginners to Rust, a short fragment on crate features, future plans, performance characteristics, platform support, dependency policy, and its MSRV. That’s a lot. I’d say it’s <em>comprehensive</em>, even just for a README. This gives me hope that the main documentation is as substantial as this.</p><p>What’s interesting is that in the list of documentation links, there is a bullet point listed as “<a href="https://github.com/BurntSushi/jiff/blob/HEAD/COMPARE.md">Comparison with <code>chrono</code>, <code>time</code>, <code>hifitime</code> and <code>icu</code></a>” and “- <a href="https://github.com/BurntSushi/jiff/blob/HEAD/DESIGN.md">The API design rationale for Jiff</a>”. It’s an explicit decision to highlight the <em>explanation</em> or discussion of the design choices of <code>jiff</code>. Based on earlier crates we have surveyed, this is the first time where you can clearly see and discover that one of the most neglected documentation quadrant is emphasized here. I’ll check these links later; first, I want to check the API reference first.</p><p>The <a href="https://docs.rs/jiff/latest/jiff/">main page</a> on docs.rs is very, very impressive. I would say at least 90% of it is pure documentation, and I’m not exaggerating. I’m honestly amazed by the amount of effort put in authoring this library’s docs. It includes a more comprehensive overview of the library, its features (not the crate features mind you!), the usage taken from the README, hefty amount of short how-to guides with a dedicated paragraph or two (other libraries only have the code snippets and a sentence or two!), and docs on its crate features.</p><p>Interestingly, what catches my eye the most is the <a href="https://docs.rs/jiff/latest/jiff/_documentation/index.html"><code>_documentation</code></a> module, which contains the comparison and design page mentioned before, plus platform support and changelog. Personally I wouldn’t have put them in docs.rs, but I imagine that making an <code>mdbook</code> project is not worth the effort if you are just looking to dump in your rationalizations somewhere. To be fair, I don’t think there would be an “official” way to put in your design decisions anywhere. <code>mdbook</code> is typically used for recipes and how-to guides, and tutorials are typically authored by third-party bloggers. The nearest example I could think of are <code>ARCHITECTURE.md</code> files, found in some repos, but that’s aimed for contributors.</p><p>Going back, I want to point the library features here. In <code>chrono</code> and <code>time</code>, the only thing mentioned that stood out to me was that it was using the proleptic Gregorian calendar. <code>jiff</code> does mention using the Gregorian calendar in the not-yet-features section where calendars other than Gregorian is not yet supported. What is amazing though is that <code>jiff</code> goes beyond that. It talks about integrating with the IANA Time Zone databases, separation of datetime types, daylight savings, a specific format for formatting and parsing beyond the RFCs/ISOs, etc. It also lists the not-yet-features such as leap seconds, localization, datetime representation, and many more. It’s impressive for a library to recognize its flaws and unsupported features then communicate that to the user. Discussions like these implies that there is room for growth.</p><p>Going <em>way</em> back, I want to take a look at the comparison. Surprisingly, this links me to a <a href="https://github.com/BurntSushi/jiff/blob/HEAD/COMPARE.md">markdown file on the Github repo</a>. I noticed that this has the exact same contents as the one in docs.rs, so I checked the source code:</p><div><figure><pre data-language="rust"><code><div><p><span>///</span><span> Longer form documentation for Jiff.</span></p></div><div><p><span>pub</span><span> </span><span>mod</span><span> </span><span>_documentation</span><span> </span><span>{</span></p></div><div><p><span>    </span><span>#[</span><span>doc </span><span>=</span><span> include_str</span><span>!</span><span>(</span><span>&#34;../COMPARE.md&#34;</span><span>)]</span></p></div><div><p><span>    </span><span>pub</span><span> </span><span>mod</span><span> </span><span>comparison</span><span> </span><span>{}</span></p></div><div><p><span>    </span><span>#[</span><span>doc </span><span>=</span><span> include_str</span><span>!</span><span>(</span><span>&#34;../DESIGN.md&#34;</span><span>)]</span></p></div><div><p><span>    </span><span>pub</span><span> </span><span>mod</span><span> </span><span>design</span><span> </span><span>{}</span></p></div><div><p><span>    </span><span>#[</span><span>doc </span><span>=</span><span> include_str</span><span>!</span><span>(</span><span>&#34;../PLATFORM.md&#34;</span><span>)]</span></p></div><div><p><span>    </span><span>pub</span><span> </span><span>mod</span><span> </span><span>platform</span><span> </span><span>{}</span></p></div><div><p><span>    </span><span>#[</span><span>doc </span><span>=</span><span> include_str</span><span>!</span><span>(</span><span>&#34;../CHANGELOG.md&#34;</span><span>)]</span></p></div><div><p><span>    </span><span>pub</span><span> </span><span>mod</span><span> </span><span>changelog</span><span> </span><span>{}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>Yup. The modules just <code>include_str!</code> the markdown files for its docs. I personally like it, as (1) it maintains a single source of truth, and (2) it makes the document discoverable to people who only use <code>docs.rs</code> for browsing the documentation and not necessarily using <code>crates.io</code> as the starting point. That’s an additional point for discoverability.</p><p>Moving along, the second paragraph of COMPARISON.md has the statement “The goal of this document is to be as <em>descriptive</em> and <em>substantively complete</em> as possible,” which is a nice way of setting up expectations for your readers.  It discusses the differences between <code>jiff</code>, <code>chrono</code>, <code>time</code>, <code>hifitime</code>, and <code>icu</code>. The author provides certain scenarios where <code>jiff</code> performs better (not the speed kind) than other libraries, but there are some scenarios where it falls behind. There is a genuine attempt by the author to be as unbiased as possible. My concern is that while there is justification for the author to create their own library and have a writeup about it, bias may still color the comparisons. Nevertheless, this is a treasure of discussions and gives the user ample understanding of the library and its decisions.</p><p>Speaking of, another document that discusses the design decisions is <a href="https://github.com/BurntSushi/jiff/blob/HEAD/DESIGN.md">DESIGN.md</a>. This is less about comparisons via code examples or performance characteristics, but rather the philosophy differences between libraries and the rationalization of its API design. The first part are opinionated pieces (remember, from the perspective of the author :p) of comparisons and his experiences with the respective library. I like that he links in <a href="https://github.com/BurntSushi/jiff/issues/63">a commentary from the original author of the <code>chrono</code> crate</a>.</p><p>The second part of this file discusses the API decisions of <code>jiff</code>. <a href="https://github.com/BurntSushi/jiff/blob/HEAD/DESIGN.md#why-are-there-two-duration-types">Why are there two duration types?</a> <a href="https://github.com/BurntSushi/jiff/blob/HEAD/DESIGN.md#why-isnt-there-a-timezone-trait">Why isn’t there a <code>TimeZone</code> trait?</a> <a href="https://github.com/BurntSushi/jiff/blob/HEAD/DESIGN.md#why-doesnt-timezone-implement-copy">Why doesn’t <code>TimeZone</code> implement <code>Copy</code>?</a> And there’s more. This is exactly what I look for when I want the <em>explanations</em> in the sense of the Diátaxis approach: a document that does not just give me <em>knowledge</em>, but also <em>understanding</em> of the library. It provides the high-level discussions. It gives context. It is <em>opinionated</em>. There is no objective way to write a library. API decisions are colored by the author’s decisions, and I <em>personally</em> want to know that. I love asking why. Without these explanations, a library’s API seem arbitrary and sometimes nonsensical.</p><p>After all of that, now let’s look at the actual API reference on docs.rs.</p><p>I would imagine a beginner user would like to get a <code>DateTime</code> or equivalent, but there’s no such thing in the top-level module. But by the magic of <code>Ctrl + F</code>, we can find that we can use <code>Zoned</code> for a <code>DateTime</code> with time zones, or <code>civil::DateTime</code> for a naïve, imprecise version of this.</p><p>Let’s check <a href="https://docs.rs/jiff/latest/jiff/struct.Zoned.html"><code>Zoned</code></a> first.</p><p>The struct docs has <em>five</em> headings.</p><p>For comparison, <a href="https://docs.rs/chrono/latest/chrono/struct.DateTime.html"><code>chrono::DateTime</code></a> has two sentences and 31 words, while <a href="https://docs.rs/time/latest/time/struct.OffsetDateTime.html"><code>time::OffsetDateTime</code></a> has two sentences and 13 words. The <code>jiff</code> docs confers a degree of complexity for handing time, and rightfully so. It discusses the prominent features of <code>Zoned</code>, its caveats, and ways to handle exceptional situations.</p><p>Common methods also include substantive amount of docs.<a href="https://docs.rs/jiff/latest/jiff/struct.Zoned.html"><code>Zoned::new</code></a> not only discusses how to construct a <code>Zoned</code> struct with <code>new</code>, but also with other methods such as <code>DateTime::in_tz</code>, <code>DateTime::to_zoned</code>, <code>Date::in_tz</code>, and <code>Date::to_zoned</code>. It also details the problem when converting an ambiguous civil time to zoned datetimes, and solving this via <code>TimeZone::to_ambiguous_zoned</code>. It has two “real-world” (well, presented as such) problems like answering the question “What was the civil time in Tasmania at the Unix epoch?” and “What was the civil time in New York when World War 1 ended?”</p><p>Impressively, all inherent methods each have at least one paragraph and one example. Skimming this, it has the appropriate “Errors” sections when necessary, and does not repeat itself when needed; opting to linking to related methods whenever necessary. Helpful for discoverability and maintaining a single source of truth!</p><p>I want to go on and on with the documentation in other parts of the API reference, but that would be me repeating myself. Instead, I would like to go to the <a href="https://github.com/BurntSushi/jiff/blob/HEAD/PLATFORM.md">PLATFORM.md</a> and <a href="https://github.com/BurntSushi/jiff/blob/HEAD/CHANGELOG.md">CHANGELOG.md</a> documents to see what’s going on. The changelog seems typical; it does not necessarily follow <a href="https://keepachangelog.com/en/1.0.0/">Keep A Changelog</a>’s guidelines, but it doesn’t deviate very much from a normal changelog.</p><p>Documentation on platform support is more substantive than I thought. It has a section on vocabulary<sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> I think this should’ve been given more emphasis in the main docs.  </span> , environmental variables, list of platform support and some caveats. I can see this being useful for esoteric targets like Android and Wasm, which were discussed here.</p><p>All in all, I think the documentation is very comprehensive, pretty discoverable, super approachable, and explains its philosophy pretty well. It has lots of explanations and simple how-to guides, and a comprehensive reference. Just like the previous libraries, I don’t think this one would benefit from a hand-holdy tutorial.</p></section><section><h3 id="axum"><code>axum</code><a aria-hidden="true" tabindex="-1" href="#axum"> #</a></h3><p>Moving on from time-related crates, let’s look at the web server frameworks. Now, instead of dealing with libraries that allows you to pick and choose your functions and types and use it as you will, frameworks will force you to use it in a certain way just to start working with. I expect that there will be either an entry-point function or type that you must call or construct to start, and your custom functions or types must follow an interface.</p><p>With that assumption, let’s look at the <a href="https://crates.io/crates/axum">crates.io</a> page of <code>axum</code>. The README discusses its high level features, an example tutorial, performance, and characteristics, MSRV, where to get more examples, help, projects, how to contribute to the framework, and licensing. Pretty typical.</p><p>Moving to the <a href="https://docs.rs/axum/latest/axum/"><code>docs.rs</code></a> page: it’s awesome that it has so many sections in the top-level document. Reminiscent of <code>jiff</code>’s docs. Each part of the framework has a minimal discussion on what they are, and it links to its corresponding module for further discussion. Good for discoverability! Examples are sprinkled around the docs too, giving good enough how-to guides for using certain items. There’s also docs on the feature flags, which we can appreciate.</p><p>Before we dive into the reference, I’d like to look at the examples, showcases, and tutorials linked in the crates.io page. The <a href="https://github.com/tokio-rs/axum/tree/main/examples">examples link</a> brings me to its repository in the examples folder. Which is kinda what I expected. The README doesn’t provide much info. It doesn’t even say what each folder mean. Clicking on the folders does not give much info, so this tells me that <code>axum</code> will just throw me to the deep end and say “You’re on your own, kiddo!” Uh oh. At least there are examples here.</p><p>Clicking on the <a href="https://github.com/tokio-rs/axum/blob/main/ECOSYSTEM.md#project-showcase">showcases hyperlink</a> leads me to a markdown file named ECOSYSTEM.md, specifically on the “Project showcase” heading. It’s a bullet list; each point contains a link to the project and a short 1-2 sentence description. Clicking on the <a href="https://github.com/tokio-rs/axum/blob/main/ECOSYSTEM.md#tutorials">tutorials hyperlink</a> leads me to the same file, but on the “Tutorials” heading. Same spiel, but with posts/series from people outside of the tokio group.</p><p>Now I’m thinking whether or not should a tutorial be made by the maintainers of the crate, or be delegated to users who wants to teach to other users. But that’s probably a topic for another time.</p><p>Anyways, I don’t really have anything to say for the two hyperlinks here.</p><p>Moving on!</p><p>Skimming the docs, it seems that the entry point here is <a href="https://docs.rs/axum/latest/axum/fn.serve.html"><code>axum::serve</code></a>, which uses <a href="https://docs.rs/axum/latest/axum/struct.Router.html"><code>Router</code></a> and <code>tokio::new::TcpListener</code>. I will not discuss the latter type right now, but after looking at <code>axum::serve</code>, we should look at <code>Router</code> next. The <code>serve</code> function has an incredible function signature:</p><div><figure><pre data-language="rust"><code><div><p><span>pub</span><span> </span><span>fn</span><span> </span><span>serve</span><span>&lt;</span><span>L</span><span>,</span><span> </span><span>M</span><span>,</span><span> </span><span>S</span><span>&gt;(</span><span>listener</span><span>:</span><span> </span><span>L</span><span>,</span><span> </span><span>make_service</span><span>:</span><span> </span><span>M</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Serve</span><span>&lt;</span><span>L</span><span>,</span><span> </span><span>M</span><span>,</span><span> </span><span>S</span><span>&gt;</span><span>where</span></p></div><div><p><span>    </span><span>L</span><span>:</span><span> </span><span>Listener</span><span>,</span></p></div><div><p><span>    </span><span>M</span><span>:</span><span> </span><span>for</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>Service</span><span>&lt;</span><span>IncomingStream</span><span>&lt;&#39;</span><span>a</span><span>,</span><span> </span><span>L</span><span>&gt;,</span><span> </span><span>Error</span><span> </span><span>=</span><span> </span><span>Infallible</span><span>,</span><span> </span><span>Response</span><span> </span><span>=</span><span> </span><span>S</span><span>&gt;,</span></p></div><div><p><span>    </span><span>S</span><span>:</span><span> </span><span>Service</span><span>&lt;</span><span>Request</span><span>,</span><span> </span><span>Response</span><span> </span><span>=</span><span> </span><span>Response</span><span>,</span><span> </span><span>Error</span><span> </span><span>=</span><span> </span><span>Infallible</span><span>&gt;</span><span> </span><span>+</span><span> </span><span>Clone</span><span> </span><span>+</span><span> </span><span>Send</span><span> </span><span>+</span><span> </span><span>&#39;</span><span>static</span><span>,</span></p></div><div><p><span>    </span><span>S</span><span>::</span><span>Future</span><span>:</span><span> </span><span>Send</span><span>,</span></p></div></code></pre></figure></div><p>Trait soup my beloved.<sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> If you want to learn how to grok these runes and incantations, I recommend watching this video: <a href="https://www.youtube.com/watch?v=uh9i3be2wIE">https://www.youtube.com/watch?v=uh9i3be2wIE</a>  </span> </p><p>The docs of this function does have a less meaty overview of what it is, and a more meaty section on examples of usage, plus additional links to relevant functions and methods. Interestingly, it has a dedicated section on its return value. I think it’s nonstandard though; I probably would’ve named this section “Errors” instead.</p><p>Next, let’s look at <code>Router</code>.</p><p>Oh.</p><p>Just a single short description and a caveat to what the generic means. It links to <a href="https://docs.rs/axum/latest/axum/struct.Router.html#method.with_state"><code>Router::with_state</code></a>, which has a more substantial documentation. It does have lots of examples for handling each caveat, and some explanation on the generic <code>S</code>. Honestly, this is one of the best examples (so far) on what a how-to guide should be: discusses how to handle some common scenarios and assumes basic competence on the user.</p><p>I guess the documentation is comprehensive, but not to the level of <code>jiff</code>. I like the discoverability on the API reference with the amount of linking done, but the examples just makes me feel lost. Approachability, I’d say is fine. The philosophy wasn’t discussed that much.</p><p>It does have a lot of examples, linked tutorials, good how-to guides in the reference, and of course, 100% documented in docs.rs. That’s an “Okay!” in my book.</p></section><section><h3 id="actix-web"><code>actix-web</code><a aria-hidden="true" tabindex="-1" href="#actix-web"> #</a></h3><p><code>actix-web</code> is another web server framework (not to be confused with <code>actix</code>. That’s an actor framework). The <a href="https://crates.io/crates/actix-web">crates.io page</a> show the framework features, links to documentations, benchmarks, license, and code of conduct. Not much to say about it, but listing out a partial list of the examples in the “More Examples” section is interesting.</p><p>There’s objectively less content on the <a href="https://docs.rs/actix-web/latest/actix_web/">docs.rs</a> page compared to <code>axum</code>, but it does link to its website, example repository, and Discord server. It also links relevant types and modules for you to research on, which is a plus point for discoverability.</p><p>I’m curious on what the <a href="https://actix.rs/">website</a> and its user guide look like, so get on with it. The main page looks sleek; it reminds me of websites I’ve seen for documentation in other programming languages. It has some snippets for giving the user a taste, which I like.</p><p>The book-like docs on their official website delves into the discussion of <code>actix-web</code> as former part of the <code>actix</code> ecosystem, and how <code>actix-web</code> works. Additional, it has a mini-tutorial and multiple how-to guides. The text looks good, as it discusses how to handle certain scenarios typical for backend server development. It even discusses one pattern not commonly found in other frameworks, which is dependency injection via functions called <a href="https://actix.rs/docs/handlers">handlers</a> with magical argument types called <a href="https://actix.rs/docs/extractors">extractors</a>.</p><p>This site is very comprehensive. It also details advanced topics, protocols, recipes, and patterns using third-party services, and some insights on the framework’s <a href="https://actix.rs/docs/http_server_init">HTTP server initialization</a> and <a href="https://actix.rs/docs/conn_lifecycle">connection lifecycle</a>. Surprisingly, it also discusses the <code>actix</code> actor framework.</p><p>Clearly, the majority of the docs is consolidated in their website. Is it a good idea? Maybe. I would’ve done a standalone website if:</p><ol>
<li>The documentation you want to write does not lend well to the format that crates.io, docs.rs, or mdbook could not.</li>
<li>The website includes not just documentation, but also other stuff, like a blog/newsletter, interactive examples, external resources, and others.<sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> Subtle foreshadowing <code>:ferrisClueless:</code>  </span> </li>
<li>Aesthetic reasons ¯\_(ツ)_/¯</li>
</ol><p>The website contents seems mdbook-shaped. It’s not really a problem, though; mdbook has a certain aesthetic that the maintainers may not want here. But, it doesn’t really have any non-documentation stuff here, so I wonder if they’re looking to expanding upon this website more.</p><p>Anyways, I digress. Enough pondering. Let’s move on to the API reference.</p><p>For frameworks, I would like to look into the entry-point item’s documentation. In this case, I assume that it will be the <a href="https://docs.rs/actix-web/latest/actix_web/struct.App.html"><code>App</code></a> struct.</p><p>Ah. The doc on the struct is only one sentence. Wait, let’s check the percentage of crate documented. Uh oh. 92.09%. I think that’s the first time where the library wasn’t completely documented. That’s sad.</p><p>Looking at the methods, I can see that it actually has more substance here. It at least has multiple sentences and some even has examples! Nice.</p><p>The modules continue to be minimal in its documentation. <a href="https://docs.rs/actix-web/latest/actix_web/web/index.html"><code>actix::web</code></a> only has bulleted lists with phrases describing the item. Okay. I don’t really have much to say here. There <em>is</em> documentation. I check the types here and there is more text inside. I just wish I am given the reason why I would use this type over that. At first glance, I can’t tell the real differences of <code>Data</code>, <code>ThinData</code>, and <code>ReqData</code> without reading their docs one by one.</p><p>Going beyond that, is there a reason for me to check the other modules or is it a matter of “I have a problem and I need to know how to solve it?” If so, is the documentation primed for discoverability? Can I arrive to the answer just from the docs? If I am not familiar with web development, how do I know what search terms should I use here? Hmm, there’s a lot of questions to ponder here.</p><p>Lastly, I want to check out the <a href="https://github.com/actix/examples">examples repository</a>.  It’s a link to an actual separate repo, woah. The short description states “ Curated examples using the Actix ecosystem.” Interesting! However, the rest of the document do not discuss what the examples in the repo <em>do</em>. You have to guess from the name, which is sad. A minus point for discoverability. There is a lot of examples, though, if you explore the folders.</p><p>The remaining part of the document contains a section of a community showcase in the real world, like <a href="https://github.com/dessalines/lemmy">lemmy</a>, <a href="https://github.com/meilisearch/MeiliSearch">MeiliSearch</a>, and <a href="https://github.com/LukeMathWalker/zero-to-production/">Zero2Prod</a>. Impressive. The next section is titled “Community Articles, Example Apps, Starters &amp; Boilerplate Projects”, which is full of tutorials from the community. That’s what I’ve been looking for when it comes to tutorials! For completeness sake, there’s also the paid resources section which contains only one bullet point which is the book version of <a href="https://algoluca.gumroad.com/l/zero2prod">Zero2Prod</a>. Love that for the author of the book, get that bag!</p><p>All in all, the amount of tutorials and how-to guides are impressive, but the explanations and references are lacking. It is not that comprehensive, discoverable, and does not explain its philosophy, but it is approachable with the amount of tutorials and examples it has.</p></section><section><h3 id="rocket"><code>rocket</code><a aria-hidden="true" tabindex="-1" href="#rocket"> #</a></h3><p>Rocket is the third and last backend server framework we will be discussing today. The <a href="https://crates.io/crates/rocket">crates.io</a> page discusses a simple example, links to different parts of its documentation, how to build and test the crate, contribution guidelines, and license. The documentation links are very interesting, as it links to their <a href="https://rocket.rs/">website</a> instead of an mdbook.</p><p>The front page of the website is typical marketing stuff with some snippets showcasing what you can do with <code>rocket</code>. I like how the docs in the website is structured. It gives an introduction to the philosophy of <code>rocket</code>, a quickstart, some fairly detailed reference pages, a nontrivial tutorial, a conclusion, and a FAQ section. Some differences I’ve noticed:</p><ol>
<li>Rocket <em>does</em> discuss on its design philosophy, which I don’t remember reading in the docs of both <code>axum</code> and <code>actix-web</code>.</li>
<li>I like the use of book elements such as admonitions here. It emphasizes certain information that may be useful for the user, but does not flow well in the main content.</li>
<li>The content is more substantial in the Rocket docs compared to <code>actix-web</code>.</li>
<li>It actually has a nontrivial tutorial, specifically creating a pastebin. It runs through creating one with Rocket, discusses certain consideration regarding security, and gives a complete program you can run for yourself.</li>
</ol><p>Every essential part of the framework was discussed thoroughly in each section, like <a href="https://rocket.rs/guide/v0.5/requests/">requests</a>, <a href="https://rocket.rs/guide/v0.5/responses/">responses</a>, <a href="https://rocket.rs/guide/v0.5/state/">state</a>, middleware via <a href="https://rocket.rs/guide/v0.5/fairings/">fairings</a>, <a href="https://rocket.rs/guide/v0.5/testing/">testing</a>, <a href="https://rocket.rs/guide/v0.5/configuration/">configuration</a>, and <a href="https://rocket.rs/guide/v0.5/deploying/">deployment</a>. I’ll have to say, Rocket’s documentation seems more comprehensive compared to <code>actix-web</code>, with better ways of handling exceptional situations and showcasing tips by presenting it as admonitions, with its warning, note, and tip callout boxes.</p><p>One curious thing about this is that I don’t think there’s any links to its examples, nor does it have any showcases and third-party tutorials, unlike <code>actix-web</code>. It says that the examples are provided in the <code>examples/</code> directory, but there’s no link to it in the crates.io page. They probably just forgot.</p><p>The <a href="https://github.com/rwf2/Rocket/tree/master/examples">examples folder</a> does have some good description for each example. A breath of fresh air, finally. I like that there are three complete application examples like <a href="https://github.com/rwf2/Rocket/blob/master/examples/pastebin"><code>pastebin</code></a>, <a href="https://github.com/rwf2/Rocket/blob/master/examples/todo"><code>todo</code></a>, and <a href="https://github.com/rwf2/Rocket/blob/master/examples/chat"><code>chat</code></a>, and some examples on Rocket’s features not discussed much in the main website.</p><p>The API reference is interesting, as it is hosted on <a href="https://api.rocket.rs/v0.5/rocket/">api.rocket.rs</a> and not docs.rs. Why? I don’t know. I just want to point it out. Anyways, the main page shows a usage section, configuration, and testing. There’s not much to go around here, but then most of the documentation is in the website, which is fine.</p><p>Let’s look at the entry level items first, which is the <a href="https://api.rocket.rs/v0.5/rocket/fn.build"><code>build</code></a> function. Oh no, a single sentence description. Apparently it’s just an alias for an associated of the <code>Rocket</code> type, so let’s look into that instead. Well, there’s only two sentences worth of docs <a href="https://api.rocket.rs/v0.5/rocket/struct.Rocket#method.build">here</a>, but it does have a very basic example. The other methods in this page does have more fleshed out examples here, and the main struct have multiple sections on configuration and launching of the application server.</p><p>Clicking on the <a href="https://api.rocket.rs/v0.5/rocket/config/struct.Config#method.figment"><code>Config::figment</code></a> link has two paragraphs and an example, but just like <code>Rocket</code>, the doc on the type itself is where the meat is. It’s nice that the fields docs tells you the default values here, which is not very common to see to be quite honest.</p><p>My verdict on this crate: very comprehensive and discoverable, with its overall philosophy properly explained in a section. The website is very approachable; the API reference kinda less so. It has a single complete tutorial, many how-to guides, okayish API reference, and a small section for its philosophy and that’s about it.</p></section><section><h3 id="bevy"><code>bevy</code><a aria-hidden="true" tabindex="-1" href="#bevy"> #</a></h3><p>Now, we shall move on to game engines.</p><p>Bevy’s <a href="https://crates.io/crates/bevy">crates.io</a> page is kinda different from other crates. There’s some classics like a list of links to docs, a simple example, licenses, and contributions. However, there’s some new stuff, like an explicit <strong>WARNING</strong> section, design goals, an about section, and a community section. That tells me a lot about the values of this crate’s maintainers and in extension, its community. The license is also not like the others, as it lists the caveats of some of its code, not just its general license.</p><p>Since I can see a <a href="https://bevyengine.org/learn/quick-start/introduction">Quick Start Guide</a> link, let’s go that first. Ooh, it leads to its own website, just like <code>actix-web</code> and <code>rocket</code>. The introduction of this guide restates the crate’s design goals and its stability warning. The next few pages is a very simple tutorial to create a minimal Bevy app.</p><p>I like how some sections are expandable; it’s a good way to make the document readable and makes relevant information more accessible. Like, why do I have to scroll around to see where the “Windows” section is when I could just click on it and ignore the rest? It also hides some alternative steps so that the beginner don’t get overwhelmed with info. It also explains what certain types do and how it functions in the context of the whole machinery. Terminologies also get explained, albeit only for a brief moment. I appreciate the “Next Steps” section; giving me a list of links directed at beginners so that they can explore more about this framework</p><p>I’m still curious about the website, so let’s check the front page here. Ah, a classic list of its features. Ooooh, a list of Bevy’s financial supporters. Nice.</p><p>The “Learn” tab is a list of different documentation links, which is a prime example of discoverability. All guides, tutorials, and references are listed here. Migration guides, contributing guide, bevy assets, and FAQs, oh my!</p><p>The examples page is particularly impressive. Numerous pages containing a <code>&lt;canvas&gt;</code> you can actually see on your browser and the actual code under it! This is so lovely, I haven’t seen anything like it. However, I don’t think this method of displaying examples is very much applicable to other crates. But I want to say: if you think you can do it and it makes to do it. please do it and copy Bevy here. Thank you very much.</p><p>The contributing guidelines is not just a paragraph here, but a full blown guide just like the quick start guide. It’s awesome. Bevy maintainers really values open source principles and fostering a good and helpful community.</p><p>They even have rustc like bevy errors! woag</p><p>The frequently asked questions section links me to the<a href="https://github.com/bevyengine/bevy/discussions?discussions_q=label%3AFAQ+sort%3Atop"> GitHub Discussion page</a> on the Bevy repository. I haven’t really seen anyone used this feature, so it’s interesting that they decide to use this feature.</p><p>Bevy Assets shows first-party and third-party tutorials, how-to guides, and external games and tools written with Bevy. It’s a step above what <code>actix-web</code> do by integrating community posts into its website, and organizing it by topics. I wonder if <code>actix-web</code> would be open to adding this kind of thing in their website.</p><p>Before we look into the API reference, let’s look at the news tab. It’s a list of posts, sort of like a newsletter. There’s blog posts on new version releases, and some news that is not necessarily code-related, like Bevy being at <a href="https://bevyengine.org/news/bevy-at-rust-week/">RustWeek 2025</a>, <a href="https://bevyengine.org/news/bevy-foundation-501c3/">Bevy Foundation being a public charity</a>, and of course, the most important one: <a href="https://bevyengine.org/news/bevys-fourth-birthday/">celebrating birthdays</a>. I like it. It kinda humanizes the project; making it seems alive as an open source crate and welcoming for users and contributors.</p><p>The community tab is a collection of links for social media accounts, GitHub organization, Q&amp;A, Bevy Assets, and the <a href="https://bevyengine.org/community/people/">Bevy People</a>. Clicking on that leads me to a list of people who are part of the bevy organization and look! That’s me!</p> <label for="a-section-of-my-card-in-the-bevy-organization" data-astro-cid-ascxwteo=""> <img src="https://www.harudagondi.space/uploads/doc-quad/bevy_organization_harudagondi.png" alt="A section of my card in the Bevy organization." data-astro-cid-ascxwteo=""/> </label><p>My bad guys. I am actually familiar with Bevy and some previous crates here. To clarify, I am approaching this blog from the perspective who may be new to these crates, so I just pretend that I don’t know any of these. Moving on!<sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> (Anyways, I should really update my Bevy libraries. The past few years have been <em>pretty</em> hectic. My bad again guys lol.)  </span> </p><p>The foundation tab is an overview of the crate’s foundation and its model for sustainability of maintaining it. It discusses what exactly is the Bevy Foundation, its leadership, and its transparency processes.</p><p>Now the part we are all waiting for: the API reference!</p><p>The main page of the <a href="https://docs.rs/bevy/latest/bevy/">docs.rs</a> site contains some links to the website, a “Hello World” example, what this crate is exactly, and the description for each cargo feature. Damn, there is a lot of features. Wow. You have to see <a href="https://docs.rs/bevy/latest/bevy/#cargo-features">it</a> for yourself.</p><p>The API reference is okay. I checked the <a href="https://docs.rs/bevy/latest/bevy/app/struct.App.html"><code>App</code></a> struct and it has two paragraphs of information and an example, and the method docs are as meaty, if not a little bit more meatier. What’s interesting is that the docs uses automatically scraped examples from the repository, which is nice.</p> <label for="scraped-examples-done-via-rustdocs" data-astro-cid-ascxwteo=""> <img src="https://www.harudagondi.space/uploads/doc-quad/scraped_examples.png" alt="Scraped examples done via rustdocs." data-astro-cid-ascxwteo=""/> </label><p>The other types, however, is much, much more substantial than <code>App</code>. <a href="https://docs.rs/bevy/latest/bevy/ecs/component/trait.Component.html"><code>Component</code></a> has a <em>lot</em>. The type docs consumes like 30% of the page. The method docs? Eh. Only one to two sentences, except for <a href="https://docs.rs/bevy/latest/bevy/ecs/component/trait.Component.html#method.map_entities"><code>Component::map_entities</code></a>. To be fair, 60% of the page is just the trait’s <a href="https://docs.rs/bevy/latest/bevy/ecs/component/trait.Component.html#implementors">implementors</a>.</p><p><a href="https://docs.rs/bevy/latest/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> amusingly has a lot of warnings, notes, and caveats. For such an ubiquitous part of a Bevy program, it’s funny that there is a lot of things you have to consider when using this in a low level way. The trait implementation docs is cute as both <a href="https://docs.rs/bevy/latest/bevy/ecs/entity/struct.Entity.html#impl-Debug-for-Entity"><code>Debug</code></a> and <a href="https://docs.rs/bevy/latest/bevy/ecs/entity/struct.Entity.html#impl-Display-for-Entity"><code>Display</code></a> has docs noting the actual format the entity takes form of.</p><p>All in all, the documentation is rich in examples, tutorials, and how-to guides, both from the repo itself and from third party posts. It has elaborated docs for community-based stuff such as contribution guidelines, newsletters, and social media/forums/chat , which is nice to see as a way to be approachable to users, especially beginners. The design goals is briefly explained, and the website provides a great way to discover the framework and its examples.</p></section><section><h3 id="macroquad"><code>macroquad</code><a aria-hidden="true" tabindex="-1" href="#macroquad"> #</a></h3><p>Unlike Bevy, <code>macroquad</code> is a “graphics library”, which implies (1) not a framework, (2) not necessarily for games, despite the fact that <a href="https://blessed.rs/crates">blessed.rs</a>’s description is “a simple and easy to use 2d game library, great for beginners.” Anyways, the <a href="https://crates.io/crates/macroquad">crates.io page</a> shows us its features, supported platforms, build instructions (which is surprisingly has a lot of docs), community links, and… “async/await”. Uh oh. They have continuations at home. It looks kinda janky but the design decision makes (some) sense.</p><p>Not much to say here that’s different to what I say in previous crates, so let’s move on to the API reference—wait is that a link to the website?</p> <label for="a-sneaky-little-link-to-macroquads-website" data-astro-cid-ascxwteo=""> <img src="https://www.harudagondi.space/uploads/doc-quad/macroquad-website-link.png" alt="A sneaky little link to macroquad&#39;s website" data-astro-cid-ascxwteo=""/> </label><p>Why was it not emphasized??? Can’t believe that it they did that. Anyways, let’s check that site out.</p><p>The <a href="https://macroquad.rs/">website</a> does have a simple list of features, and a minimal “Get Started with Macroquad” section, which is nice. Just like Bevy, Macroquad has an example page with playable examples when you click on one. Sadly, unlike Bevy, it doesn’t show its source code, and only links the specific example file to GitHub.</p><p>It also has an <a href="https://macroquad.rs/articles/">article tab</a>, which has a list of project updates and guides for the crate. Just like Bevy, I appreciate how the maintainers have a write up on some guides for specific scenarios and some changelog stuff.</p><p>What’s interesting is that Macroquad has a <a href="https://macroquad.rs/twiq/">“This Week in Quads” page</a> which I don’t think Bevy has, or I have seen yet. Each article details the thoughts of the contributors and what new features are being worked on. Basing on the criteria I’ve set way earlier<sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> <em>checks notes</em> uh oh I wrote like 10k words by this point :ferrisClueless:  </span> , it’s one of the best sources for discussing the crate’s philosophy.</p><p>The docs tab is an <code>iframe</code> to the docs.rs page. What. Let’s just skip that and go to the real <a href="https://docs.rs/macroquad/latest/macroquad/">docs.rs</a> website.</p><p>This page states its supported platforms and its features, plus some minimal example. Thankfully, the <a href="https://docs.rs/macroquad/latest/macroquad/attr.main.html"><code>main</code></a> macro has some considerable amount of docs, as it includes an error handling part and how to configure it (albeit only shown via code).</p><p>The other functions just have a single sentence for docs, like <a href="https://docs.rs/macroquad/latest/macroquad/shapes/fn.draw_circle.html"><code>draw_circle</code></a> and <a href="https://docs.rs/macroquad/latest/macroquad/shapes/fn.draw_line.html"><code>draw_line</code></a>. 😕. At least it has scraped examples from the repository.</p><p>Going back, I want to click on the <a href="https://github.com/ozkriff/awesome-quads">Awesome Quads</a> link. That page is a list of game engines built with the <code>*quad</code> related libraries, games and apps written with macroquad, posts and publications, example usages, tools, and library integrations. There’s surprisingly a lot, which is nice.</p><p>To summarize, the tutorials and how-to guides are provided in the aforementioned “Awesome Quads” link. The website does not detail on creating a Macroquad game, but it does have runnable examples and numerous articles. It gives insight on design decisions via This Week in Quads and the Articles tabs. Comparing to Bevy, I don’t think <code>macroquad</code> is more approachable to a beginner in terms of docs, but the code itself seems simple enough.</p></section><section><h3 id="fyrox"><code>fyrox</code><a aria-hidden="true" tabindex="-1" href="#fyrox"> #</a></h3><p>Fyrox is an interesting one. Its <a href="https://crates.io/crates/fyrox">crates.io</a> page has less content, but has ample links available. Since it’s a game engine with an actual scene editor, I’d imagine raw code examples would not be helpful here. Let’s check out the <a href="https://fyrox-book.github.io/">Fyrox Book</a> next to see what’s going on.</p><p>This book is clearly made with mdbook, and looking at the section, it is looking to be very comprehensive. I would like to point this <a href="https://fyrox-book.github.io/introduction/philosophy_and_goals.html">page</a> on design philosophy and goals; it’s what I’m really looking for in a crate and it’s nice that there’s a dedicated page for it. Also, this <a href="https://fyrox-book.github.io/beginning/data_management.html">page on data management</a> has a motivation and technical details section which is useful for people who (1) wants to understand the performance characteristics and (2) the reasoning for Fyrox choosing whatever solution it has right now.</p><p>The book is full of screenshots, some even have videos! Skimming through, there’s lots of diagrams, explanations, code snippets, a lot of links to the reference, and many more. I don’t really want to discuss the details of this book, but I want to say the effort here is commendable. I don’t think Bevy really has something comparable to this, but that’s probably because of the API instability and constant breaking changes every three months.</p><p>Sadly, there’s some chapters which are labelled WIP, but then I can’t really complain too much given the wealth of information written here. It is reminiscent of the read-the-docs site from Godot, and other game engines with a scene editor such as Unity and Unreal engine.</p><p>Wait, there’s an official website too that isn’t written in the README??  😞</p><p>Okay let’s check it out. The website has:</p><ol>
<li>A front page with a download link and a play demo projects button.</li>
<li>A download page</li>
<li>A link to the book (that I don’t think link back to the website)</li>
<li>Examples that run on the browser</li>
<li>A dedicated page for games done in Fyrox</li>
<li>A blog that contains update posts, explanations on certain parts of the engine, and some feature articles.</li>
<li>A complete list of the game engine’s features</li>
<li>A list of links to different external crates</li>
</ol><p>Just like the previous gamedev crates, I like the inclusion of examples and having a blog here. The blog posts may not be as flashy and boisterous as Bevy’s update posts, but I appreciate it nonetheless. I kinda wish there were more people looking into Fyrox, as Bevy really got the spotlight right now.</p><p>Unlike libraries and frameworks such as <code>actix-web</code> and Bevy, there’s not much information on third party tutorials and how-to guides in this website, nor in the crates.io page, There’s some tutorials in the Fyrox book and a single series on game development in Fyrox, but not much else. Considering that this game engine actually has an editor, I would imagine that this type of crate would need the most amount of tutorials, especially blogs with images or video tutorials. However, this is reliant on the Fyrox’s community and whether it is “alive” or “energetic” enough. Sad to say, but I honestly think Fyrox could use some marketing like what Bevy does.</p><p>Now, I wanna see the API reference next. Uh oh. The docs looks very <em>minimal</em>, but it has links to tutorials in the Fyrox book. The docs on the items like <a href="https://docs.rs/fyrox/0.36.2/fyrox/plugin/trait.Plugin.html"><code>Plugin</code></a> are pretty substantial when it has some caveats involved, but other’s are kinda missing docs despite the fact that <code>docs.rs</code> will tell you that the crate is 100% documented; an example is the methods on this <code>impl</code> block on <a href="https://docs.rs/fyrox/0.36.2/fyrox/renderer/framework/core/pool/struct.Handle.html#impl-Handle%3CT%3E-1"><code>Handle</code></a>. Some items like <a href="https://docs.rs/fyrox/0.36.2/fyrox/scene/struct.Scene.html"><code>Scene</code></a> tells me to see the module docs, but then the docs contain only <a href="https://docs.rs/fyrox/0.36.2/fyrox/scene/index.html">two sentences</a>, which is funny.</p><p>To summarize this section, the Fyrox Book contains the majority of documentation of this crate. It is very comprehensive and approachable for competent Rust programmers, but I don’t think there’s anything aimed to absolute beginners. The Book is also full of how-to guides and high-level reference for the parts of the game engine, with a few tutorials at the end. Consequently, the API reference is incomplete and not that comprehensive, since I’m assuming that the effort went to the book. The design philosophy is adequately explained in the book and the blog, and the book is primed for allowing the users to discover the extent of this engine, plus linking to the reference for details.</p></section><section><h3 id="thiserror"><code>thiserror</code><a aria-hidden="true" tabindex="-1" href="#thiserror"> #</a></h3><p>We shall be moving on to a completely different category of crates: error libraries!</p><p>The <a href="https://crates.io/crates/thiserror">crates.io</a> of <code>thiserror</code> gives an example usage, and… details ooooooh. I’d imagine that this would be located in the docs.rs main page but yeah I’m not opposed to this. There’s a comparison to anyhow, and that’s mostly it. The <a href="https://docs.rs/thiserror/2.0.12/thiserror/">docs.rs</a> page is exactly the same as the README, so I’m guessing this is just a <code>include_str!</code> situation (which is surprisingly… not).</p><p>There is exactly one item called <code>Error</code>, and that isn’t even documented. Honestly, fair. Majority of the docs are in the top level document, anyway.</p><p>The details section is comprehensive for what it is, and tutorials/how-to guides aren’t really that necessary. There’s not really much to say here.</p></section><section><h3 id="anyhow"><code>anyhow</code><a aria-hidden="true" tabindex="-1" href="#anyhow"> #</a></h3><p>Because the person who made <code>thiserror</code> also made <code>anyhow</code>, the documentation looks very, <em>very</em> similar. It has a details section just like <code>thiserror</code>, and a comparison to the <code>failure</code> and <code>thiserror</code> crates.</p><p>The API reference considerably has more items in it, and the they are well documented. <a href="https://docs.rs/anyhow/1.0.98/anyhow/struct.Error.html"><code>Error</code></a> has a section on display representations. Methods also have some good docs, like it also discusses the caveats of using this struct and some considerations for its API usage.</p><p>I see both <code>thiserror</code> and <code>anyhow</code> as crates simple enough to not need any documentation beyond an API reference. Does it need tutorials and how-to guides? Probably not. Does it need explanations? I would’ve appreciated it. Is it necessary? I guess not.</p></section><section><h3 id="snafu"><code>snafu</code><a aria-hidden="true" tabindex="-1" href="#snafu"> #</a></h3><p>The last of the error libraries we will look at is <code>snafu</code>. I chose this crate because I’ve been seeing some increasing popularity in the <a href="https://discord.com/invite/rust-lang-community">Rust Programming Language Community Server</a><sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> nawt the official rust lang server on the official website btw  </span> .</p><p>The README on the <a href="https://crates.io/crates/snafu">crates.io</a> page is very minimal. It shows a medium-sized example, and links to the documentation and the user’s guide. No sections. Hmm, interesting.</p><p>I want to check out the <a href="https://docs.rs/snafu/latest/snafu/guide/index.html">user’s guide</a> first, so let’s click on that. It leads me to docs.rs, but in a module. Kinda like <code>jiff</code>! It has links to troubleshooting, examples, design philosophy, showcase of advanced usage via explanations and how-to guides, feature flags docs, compatibility section, upgrading guide, and comparison list. Damn! This is more than what <code>jiff</code> has.</p><p>I’m gonna try to go through the majority of these to see what’s it is all about.</p><p>The <a href="https://docs.rs/snafu/latest/snafu/guide/troubleshooting/index.html"><code>troubleshooting</code></a> module is apparently a FAQ for the most common issues. Although, there’s only one module here for a single error. I guess if people encounter the same problems more frequently (and report them of course), the maintainer may decide to add more modules to this. However, the module docs says:</p><blockquote>
<p>If you experience a problem and spend a significant amount of time answering it, please consider <a href="https://github.com/shepmaster/snafu/blob/master/CONTRIBUTING.md">submitting a pull request</a> to add it here. If you cannot solve your issue after reading this, please <a href="https://github.com/shepmaster/snafu/issues">open an issue</a> to ask your question.</p>
</blockquote><p>This is interesting, I would’ve imagine that the maintainer would collate all problems and write a module doc for the most common ones. But I guess that this is not the case here. The only submodule here, called <a href="https://docs.rs/snafu/latest/snafu/guide/troubleshooting/missing_field_source/index.html"><code>missing_field_source</code></a> has a minimal reproducible example, a solution, and most importantly, the <em>explanation</em>. I love how it doesn’t just end at the solution; it allows the user to understand the <em>why</em> of the problem and the solution.</p><p>The quick example just links to the main docs.rs page. Uh. Let’s skip that.</p><p>The “more examples” link goes to the <a href="https://docs.rs/snafu/latest/snafu/guide/examples/index.html">examples module</a>. The docs tells me that looking at the source code for each error type is recommended, and there’s a suggested order to browse the examples. There’s also a note telling me to browse the acceptance and compatibility tests, which “cover a broad range of functionality but with minimal descriptive prose.” Okay, nice. I love the author setting up expectations for me before I click these links.</p><p>I will not be checking the backtrace example, only the basic example.</p><p>I like the docs here. It explains each context selector, and how to use them via snafu. The source code also shows me a cute little comment telling me that a line isn’t required for most use cases.</p><div><figure><pre data-language="rust"><code><div><p><span>#[</span><span>derive</span><span>(</span><span>Debug</span><span>,</span><span> </span><span>Snafu</span><span>)]</span></p></div><div><p><span>//</span><span> This line is only needed to generate documentation; it is not</span></p></div><div><p><span>//</span><span> needed in most cases:</span></p></div><div><p><span>#[</span><span>snafu</span><span>(</span><span>crate_root</span><span>(</span><span>crate</span><span>),</span><span> visibility</span><span>(</span><span>pub</span><span>))]</span></p></div><div><p><span>pub</span><span> </span><span>enum</span><span> </span><span>Error</span><span> </span><span>{</span></p></div><div><p><span>    </span><span>Leaf</span><span> </span><span>{</span></p></div><div><p><span>        </span><span>user_id</span><span>:</span><span> </span><span>i32</span><span>,</span></p></div><div><p><span>    </span><span>},</span></p></div><div></div><div><p><span>    </span><span>Intermediate</span><span> </span><span>{</span></p></div><div><p><span>        </span><span>source</span><span>:</span><span> </span><span>std</span><span>::</span><span>io</span><span>::</span><span>Error</span><span>,</span></p></div><div><p><span>    </span><span>},</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div><p>Going back a step, the <a href="https://github.com/shepmaster/snafu/tree/main/tests">acceptance tests</a> link leads me to a folder in the repository, which uh, doesn’t tell me anything about the files here. But hey! I recognize <a href="https://github.com/shepmaster/snafu/blob/main/tests/basic.rs"><code>basic.rs</code></a> here. Let’s click on i—uh, this is not what I saw in the previous example. Uh. Let’s move on to the <a href="https://github.com/shepmaster/snafu/tree/main/compatibility-tests">compatibility tests</a>. Uh oh, it’s like the previous link, but it’s folders now instead of files! And still no README. Sad. Let’s just move on.</p><p>Looking at the <a href="https://docs.rs/snafu/latest/snafu/guide/philosophy/index.html">design philosophy</a>, it gives me a very brief document: with four sections each having 1–2 sentences, this just gives me a feature, use case, and error design recommendation. I was a little bit disappointed. I was kinda expecting something of the caliber of <code>jiff</code>’s <a href="https://docs.rs/jiff/latest/jiff/_documentation/design/index.html">design rationale</a>.</p><p>The <a href="https://docs.rs/snafu/latest/snafu/guide/what_code_is_generated/index.html"><code>what_code_is_generated</code></a> provides an explanation on the expanded derive macro and its design decisions. I like the list of notes on the expanded macro. For the untrained eye, it helps spotting the crucial differences between the original and expanded code. Also some additional code examples I can’t grok yet. (My bad, I don’t really use this crate)</p><p><a href="https://docs.rs/snafu/latest/snafu/guide/opaque/index.html"><code>opaque</code></a> is just a simple how-to guide how to make opaque errors in snafu. <a href="https://docs.rs/snafu/latest/snafu/guide/structs/index.html"><code>structs</code></a> is another how-to guide for using snafu with struct errors. <a href="https://docs.rs/snafu/latest/snafu/guide/generics/index.html"><code>generics</code></a> describes how to use snafu for things with generics, both types and lifetimes. The unique thing about the last one is the “Caveats” section here. Love that.</p><p>Ooh, the <a href="https://docs.rs/snafu/latest/snafu/guide/feature_flags/index.html">feature flags</a> module have descriptions that are longer than one sentence. It also states whether or not the feature flag is a default or not. I don’t think I’ve seen people specify that before.</p><p>The <a href="https://docs.rs/snafu/latest/snafu/guide/compatibility/index.html"><code>compatibility</code></a> module, like the feature flags, is a collection of feature flags and their description. The difference is that the feature flags are all about compatibility with older rust versions. I like the “Implies” part, and the description also indicate what specific features this crate uses.</p><p>The <a href="https://docs.rs/snafu/latest/snafu/guide/upgrading/index.html"><code>upgrading</code></a> module is like the migration guides in the previous crates we discussed, specifically the one in Bevy. It has code examples for converting the code from the previous version to the newer version. I really like this kind of stuff, especially if the crate updates relatively frequently.</p><p>Lastly, the <a href="https://docs.rs/snafu/latest/snafu/guide/comparison/index.html"><code>comparison</code></a> module aims to be an unopinionated document of comparisons of snafu with other libraries. But erm. There’s only one submodule here, which is the difference between snafu and <code>failure</code>. This page seems like a less elaborated form of <code>jiff</code>’s comparison page, which makes it less… comprehensive.</p><p>I honestly wish that the author elaborated on their philosophy on error handling more. I wanna know why they created this crate, and what makes their crate special. I would’ve appreciate both opinion pieces and unbiased comparisons not just with <code>failure</code>, but with other modern error handling solutions like <code>thiserror</code>, <code>anyhow</code>, <code>error-stack</code>, <code>eyre</code>, <code>color-eyre</code>, <code>miette</code>, etc. Despite that, I still love the effort of expanding beyond the reference here.</p><p>After all of that, now let’s move on to the API reference. The <a href="https://docs.rs/snafu/latest/snafu/index.html">docs.rs</a> front page have a list of features with corresponding links, a quick start example, custom error guide, and a small “Next steps” section. I wanna read the entry-point of the library first, so let’s check out <a href="https://docs.rs/snafu/latest/snafu/derive.Snafu.html"><code>Snafu</code></a> next.</p><p>Wow, compared to <code>thiserror</code>, this document has a very significant amount of text in it. Counting the sections, it has… eleven main sections, and 24 sections overall when including subsections. This is incredible.</p><p>It even has an <a href="https://docs.rs/snafu/latest/snafu/derive.Snafu.html">attribute cheat sheet</a> formatted as a table!</p><p>There’s also multiple sections about controlling different things, like <a href="https://docs.rs/snafu/latest/snafu/derive.Snafu.html#controlling-display"><code>Display</code></a>, <a href="https://docs.rs/snafu/latest/snafu/derive.Snafu.html#controlling-context">context</a>, <a href="https://docs.rs/snafu/latest/snafu/derive.Snafu.html#controlling-visibility">visibility</a>, <a href="https://docs.rs/snafu/latest/snafu/derive.Snafu.html#controlling-error-sources">error sources</a>, <a href="https://docs.rs/snafu/latest/snafu/derive.Snafu.html#controlling-backtraces">backtraces</a>, <a href="https://docs.rs/snafu/latest/snafu/derive.Snafu.html#controlling-implicitly-generated-data">generated data</a>, <a href="https://docs.rs/snafu/latest/snafu/derive.Snafu.html#controlling-stringly-typed-errors">stringly-typed errors</a>, and <a href="https://docs.rs/snafu/latest/snafu/derive.Snafu.html#controlling-how-the-snafu-crate-is-resolved">resolution of the snafu crate</a>. The content is extensive and ripe with information, I think you could rely on this for the majority of snafu usage. Each section has at least one paragraph and one example, which is lovely compared to other crates.</p><p>Now I’m rethinking about my verdict on <code>thiserror</code> and <code>anyhow</code>. Can they do more in terms of documentation?</p><p>The other items have shorter docs compared to the <code>Snafu</code> macro, but still substantial.  The <a href="https://docs.rs/snafu/latest/snafu/struct.Whatever.html"><code>Whatever</code></a> struct has a description, an example with a link to the <a href="https://docs.rs/snafu/latest/snafu/macro.whatever.html"><code>whatever!</code></a> macro, and its limitations. The docs on the macro does elaborate more, with some examples based on the existence of an underlying error.</p><p>Overall, the documentation is very comprehensive and approachable, with good discoverability via the amount of hyperlinking in the docs plus the user guide. Numerous how-to guides are available, and the reference is thorough enough. The explanations? Not so much. I want to see the opinions of the author and sell their library to me. What’s wrong with other libraries? Why did you make this one?</p></section><section><h3 id="clap"><code>clap</code><a aria-hidden="true" tabindex="-1" href="#clap"> #</a></h3><p>After reviewing the error libraries, let’s now review CLI parsers next.</p><p>One of the most popular CLI parsers in Rust right now is called <a href="https://crates.io/crates/clap"><code>clap</code></a>. The crates.io page. is incredibly minimal. No examples in the README, only a link to docs.rs and examples, plus some sponsors.</p><p>The <a href="https://docs.rs/clap/latest/clap/"><code>docs.rs</code></a> is where all the meat is. There’s a tutorial and reference for both derive macros and the builder pattern, plus a cookbook, FAQ, discussions page, and a changelog that includes migration guides.</p><p>It also has a section on its aspirations, which explains the philosophy and goals of this crate. However, there’s not really any links on it beyond <a href="https://github.com/clap-rs/clap/tree/master/clap_complete">shell completions</a> and <a href="https://github.com/rust-cli/team/">WG-CLI</a>. I was hoping that there’s some more proof here like linking “help generation” to an attribute macro or whatever, or migration guides to port code using other CLI parser libraries to <code>clap</code>, and others.</p><p>There’s a quick example, and a section to its related projects, such as libraries that augment the crate, testing crates, and a CLI app book.</p><p>There are modules that contains documentation, just like <code>jiff</code> and <code>snafu</code>. Let’s check each one out first.</p><p>The <a href="https://docs.rs/clap/latest/clap/_derive/index.html">derive reference</a> acts like a mini book, full of sections such as the overview, attributes with its six subsections, argument types, doc comments, mixing the two APIs, and some tips. It has a terminology section, which is nice, and woah:</p> <label for="an-admonition-in-the-reference" data-astro-cid-ascxwteo=""> <img src="https://www.harudagondi.space/uploads/doc-quad/clap-admonition.png" alt="An admonition in the reference." data-astro-cid-ascxwteo=""/> </label><p>An <a href="https://scp-wiki.wikidot.com/admonition">admonition</a>? woag</p><p>I feel like that when compared to snafu’s <code>Snafu</code> derive macro, clap’s derive tutorial is more organized and concise, due to its bulleted list and tabulated format.</p><p>The <a href="https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html">derive tutorial</a> is very simplistic: it has code examples and then CLI output for each section, with minimal description. Code speaks louder than words, I guess. At least it doesn’t explain too much, or meander to subtopics which detracts the flow of the tutorial. Hmm, is this enough for users?</p><p>The builder reference is a dead link 😕</p><p>The <a href="https://docs.rs/clap/latest/clap/_tutorial/index.html">builder tutorial</a>, just like the derive tutorial, has the same code examples and CLI output. So, my comments on the derive tutorial will also apply here.</p><p>The <a href="https://docs.rs/clap/latest/clap/_cookbook/index.html">cookbook</a> is a module containing submodules of examples that is either labeled as using the builder API or the derive API. Let’s check the <code>repl_derive</code> example for fun. Ah. It’s just a long code snippet. Mhm. I kinda wanted something like an interactive command line in a website, where you can have a command line on the web, and the example code below just like Bevy.</p><p>Wait, let’s check if clap has a website that wasn’t linked anywhere.</p><p>…</p><p>Okay there isn’t one. Moving on!</p><p><a href="https://docs.rs/clap/latest/clap/_cookbook/escaped_positional_derive/index.html"><code>escaped_positional_derive</code></a> does at least have outputs here for some sample usage.</p><p>The <a href="https://docs.rs/clap/latest/clap/_faq/index.html">FAQ</a> is one of the most substantial document I’ve seen so far. It reminds of <code>jiff</code>’s <a href="https://docs.rs/jiff/latest/jiff/_documentation/comparison/index.html">comparison</a> and <a href="https://docs.rs/jiff/latest/jiff/_documentation/design/index.html">design</a> modules. It has a comparison section and a pitch/anti-pitch, and the rest is what the typical topics seen for a FAQs document. The comparison is eh, as it just compares <code>clap</code> to <code>structopt</code> and not any other existing CLI parser. 😕</p><p>The pitch and anti-pitch is also kinda eh. It has a lot of claims, but not any examples and links to prove the claim. How is it lightweight? How is it “a walk in the park?” In what way is it verbose? What certain features were implemented in a way that is contrary to some use cases?</p><p>The <a href="https://github.com/clap-rs/clap/discussions">discussions</a> link goes to the GitHub’s Discussions feature, which is a nice way to provide a forum. Thank god they aren’t relying on Discord for forums.</p><p><a href="https://github.com/clap-rs/clap/blob/v4.5.37/CHANGELOG.md"><code>CHANGELOG.md</code></a> is a changelog based on <a href="https://keepachangelog.com/en/1.1.0/">Keep a Changelog</a>. The major versions does have a <a href="https://github.com/clap-rs/clap/blob/v4.5.37/CHANGELOG.md#migrating">migration guide</a>, albeit somewhat more minimal than I expected. Maybe I was just spoiled by Bevy’s migration guides.</p><p>Now let’s check the API reference. Searching for <code>Parser</code>, we got the trait and… where’s the derive macro? It’s not showing up. Now I’ll have to check the documentation for <a href="https://docs.rs/clap_derive/4.5.32/clap_derive/"><code>clap_derive</code></a>. Oh, the docs for the <a href="https://docs.rs/clap_derive/4.5.32/clap_derive/derive.Parser.html"><code>Parser</code></a> macro is just two sentences. I guess you are really meant to only rely on the derive tutorial as your reference. Kinda weird. It doesn’t even describe all the possible usages of each attribute that is available.</p><p>The <a href="https://docs.rs/clap/latest/clap/trait.Parser.html"><code>Parser</code></a> trait has some docs, but it seems to be written in a low-level way; not meant to be read by an ordinary user.</p><p>Let’s check the entry-point item for the builder API, which is the <a href="https://docs.rs/clap/latest/clap/macro.command.html"><code>command!</code></a> macro. Erm. A single sentence description and an admonition box. Why does it use <code>Cargo.toml</code> and what keys does it read? I don’t know, and the builder tutorial doesn’t elaborate on it beyond the code snippet.</p><p>Is the reference just full of descriptions of limited detail? This is just sad. I was hoping the reference would at least explain every nook and cranny of each part of each item.</p><p>To conclude this section, the reference seems not very comprehensive. The discoverability is fine, but I wish they expounded on the examples a bit more so they have an opportunity to add links to the relevant methods. The examples/tutorials/how-to guides are fine, I like them. The philosophy is not very elaborated, but at least it exists.</p></section><section><h3 id="pico-args"><code>pico-args</code><a aria-hidden="true" tabindex="-1" href="#pico-args"> #</a></h3><p>Unlike <code>clap</code>, <code>pico-args</code> does have a longer README, containing a bulleted list of supported and unsupported features, crate feature flags, limitations, and alternatives. There’s no code example, however.</p><p>True to its name, the crate has only two items. The <a href="https://docs.rs/pico-args/0.5.0/pico_args/">docs.rs</a> page just repeats a part of the text in the previous page, giving the same bulleted list and the flags.</p><p><a href="https://docs.rs/pico-args/0.5.0/pico_args/struct.Arguments.html"><code>Arguments</code></a> just has a three word description, but the methods does have better docs here, albeit continuing with the minimal trend. Not only it describes what it does, but also its warnings and notes. It also includes the recognizable “Errors” heading from the clippy lint, and some scraped examples.</p><p><a href="https://docs.rs/pico-args/0.5.0/pico_args/enum.Error.html"><code>Error</code></a> is… eh.  The dataless variants are fine, but the variants with fields are what I have a problem with. At least document what the fields mean.</p><p>With the small crate comes with a small summary: fine, but could do better in some areas.</p></section><section><h3 id="ratatui"><code>ratatui</code><a aria-hidden="true" tabindex="-1" href="#ratatui"> #</a></h3><p><code>ratatui</code> is not exactly a CLI parser, but rather a TUI. I’m just inserting this crate in this part because the next two crates are all about GUIs.</p><p>The README on the <a href="https://crates.io/crates/ratatui">crates.io</a> page does have a quick start tutorial, list of links to documentation, an introduction section, layout section, and text plus styling section, contributing guidelines, community projects, and alternative crates.</p><p>I also notice that there’s a link to its website at the <em>top</em>. That’s awesome. Let’s click on that first.</p><p>Wow, the <a href="https://ratatui.rs/">website</a> is a bit… distracting. There’s a sticky header with a lot of buttons, and a navigation sidebar. Like look:</p> <label for="ratatuis-homepage-website" data-astro-cid-ascxwteo=""> <img src="https://www.harudagondi.space/uploads/doc-quad/ratatui-homepage.png" alt="Ratatui&#39;s homepage website" data-astro-cid-ascxwteo=""/> </label><p>A caveat: I am currently writing this blog post on <a href="https://obsidian.md/">Obsidian</a> first, with a web viewer on the other side. Also, I have a 14” laptop. So, my view would be quite small.</p><p>The front page is a typical marketing page with some selling points why you should use <code>ratatui</code>, and some direction to start learning.</p><p>Oh my god. There’s gifs in this. And admonitions. And screenshots. And code snippets with file names. And diffs. And expandable code snippets. And adequately detailed paragraphs. And copious amount of pictures. And infographics. And a nontrivial, long tutorial. And external videos on <code>ratatui</code>. And an example directory with gifs. And each example has instructions to run the example, a gif, and the code snippet in the page. And there’s actually four different sections on examples. And conceptual explanations. And related literature on concepts. And a peek behind the under-the-hood machineries. And different patterns for the TUI architecture you want. And an overview of terminal backends. And a comparison of backends with a Mermaid diagram. And code recipes. And a substantial FAQs page complete with infographics. And a highlights page akin to Bevy’s update posts. And a showcase of apps and widgets written with <code>ratatui</code>. And a page for cargo templates. And the references page is just like an <code>awesome</code> repo included in the site. And contributor guidelines for the crate and the website.</p><p>Holy shit.</p><p>…</p><p>The only complaint I have is that they did not link the functions and types used to the API reference. 😔</p><p>Other than that, this website is incredible. It’s amazingly comprehensive and approachable.</p><p>The <a href="https://ratatui.rs/tutorials/">tutorials</a> section shows three tutorials called <a href="https://ratatui.rs/tutorials/hello-ratatui/">“Hello Ratatui”</a>, <a href="https://ratatui.rs/tutorials/counter-app/">“Counter App”</a>, and <a href="https://ratatui.rs/tutorials/json-editor/">“JSON Editor”</a>. Most tutorials in other crates end at the “Hello Ratatui” equivalent, while some end at the counter app. It’s nice that <code>ratatui</code> is one of those crates that has a nontrivial tutorial with complex moving parts such as the JSON Editor tutorial.</p><p>The JSON Editor tutorial details each function needed with a motivational paragraph and the entire snippet; just like a tutorial should. It also guides the user through the process of writing a typical app like what people do when starting a project: making a minimal viable product, and expanding on that piece by piece. I like that when doing the UI part, the tutorial has associated graphics.</p><p>The tutorials section even has a list of videos, which is nice.</p><p>Just like Bevy, the <a href="https://ratatui.rs/examples/">examples</a> include a link to the example and the example file. The difference is that the example is not interactable, but rather just a gif. I wonder if there’s a way to have a terminal backend as a wasm applet.</p><p>The concepts section is unique. It discusses the fundamental concepts of this crate, with multiple links of the types to its corresponding docs.rs page. Some types also has some explanations why they exist, such as <a href="https://ratatui.rs/concepts/widgets/#widgetref-and-statefulwidgetref"><code>WidgetRef</code> and <code>StatefulWidgetRef</code></a>:</p><blockquote>
<p>These two traits were introduced in Ratatui 0.26.0 to help avoid a shortcoming that meant that widgets were always consumed on rendering while not breaking all code that has previously been built with that assumption. These two widgets are currently marked as unstable and gated behind the <code>unstable-widget-ref</code> feature flag.</p>
</blockquote><p>There’s also a section on how to use widgets, and how to implement them. I like that this actually explains the code in words. Also, unlike the tutorials, this section exposes the internal machinery of <code>ratatui</code> like the <a href="https://ratatui.rs/concepts/rendering/under-the-hood/">“Under the Hood”</a> subsection in Rendering.</p><p><a href="https://ratatui.rs/concepts/application-patterns/">Application Patterns</a> is an interesting section. It implies that they’re not endorsing a single architecture for the user to use. Rather, they present these architectures as supplemental reading; quoting:</p><blockquote>
<p>The documentation on this page is for theoretical understanding and pedagogical purposes only.</p>
</blockquote><p>It’s not exactly about <code>ratatui</code> (as these architectures are crate agnostic), so I appreciate the effort of writing these pages. Also love the diagram (is that UML) here.</p><p>Also, the documentation discusses terminal backends here, with a comparison page teaching you how to choose what backend to use.</p><p>The <a href="https://ratatui.rs/recipes/">recipes</a> act like simple how-to guides, as recipe shows a real-world problem and a solution, plus some different scenarios that could happen/different goals that is needed to be achieved. <a href="https://ratatui.rs/recipes/layout/collapse-borders/">Collapsing borders</a>? You got it. <a href="https://ratatui.rs/recipes/widgets/custom/">Creating custom widgets</a>? They have it.</p><p>Compared to other FAQs, <a href="https://ratatui.rs/faq/"><code>ratatui</code>’s</a> is really nice. It’s substantial; it’s full of diagrams, images, and gifs, and questions that dip into complex topics have an appropriate external reference for further. Love that they wanna satiate the curiosity of users.</p><p><a href="https://ratatui.rs/highlights/">Highlights</a> is less like a changelog and more like a newsletter of updates. Each update is a full blog post that showcases the new features added in each version.</p><p><a href="https://ratatui.rs/showcase/">Showcase</a> exhibits the different projects from the users of this crate, with gifs attached. Curiously, there’s a showcase of built-in widgets, which in my opinion should probably be a section in the concepts section instead. It’s fine. What’s more interesting here is the third party widgets, which is nice for discovering new libraries, especially since it includes pics.</p><p><a href="https://ratatui.rs/templates/">Templates</a> is also a unique section that I didn’t find in previous crates. Does one need templates for making a <code>ratatui</code> app? Well, I’m not gonna question that right now. I’m gonna appreciate the effort instead.</p><p>The <a href="https://ratatui.rs/templates/">references</a> page is actually an awesome-like bulleted list of links to projects and third party crates. Not what I expected for a page named “References” to be honest.</p><p>And of course, last but not the least, there’s the <a href="https://ratatui.rs/developer-guide/">contributing guidelines</a> part of the documentation, which in this case is actually not a single paragraph! It’s super detailed. Makes it super approachable for those who wants to contribute to the project.</p><p>Now. After all of that, we shall check out the <a href="https://docs.rs/ratatui/latest/ratatui/">API reference</a>. The overview is the same as the one in crates.io. I think the entry-point struct here would be the <a href="https://docs.rs/ratatui/latest/ratatui/struct.Terminal.html"><code>Terminal</code></a>. The documentation is decent with an explanation of how the Terminal works internally. Most methods though are just single sentences description. The most important method though, which is <a href="https://docs.rs/ratatui/latest/ratatui/struct.Terminal.html#method.draw"><code>Terminal::draw</code></a> has a considerable amount of docs, even including a list of actions this method will do, and some notes.</p><p>The <a href="https://docs.rs/ratatui/latest/ratatui/widgets/index.html"><code>widgets</code></a> module is okay. There’s a bulleted list pf built-in widgets with a concise and informative description (at least there’s some detail specified that isn’t really gleanable from its name). The <a href="https://docs.rs/ratatui/latest/ratatui/widgets/trait.Widget.html"><code>Widget</code></a> trait docs is neat; there’s some historical recounting of how widgets internally worked back then, and some recommendations if you have a niche (?) goal like “widgets immutably work on its data.”</p><p>From what I can infer, I see the API reference usually includes some explanations, caveats, and some non-obvious behavior of the crate. In the meanwhile, the website clearly aims to be approachable and comprehensive for a beginner to read. There’s also some locations where you can discover libraries and examples outside the website.</p><p>If I was making a ranking, I would place this at the top to be quite honest. But I’m not 😝 so. Stay tuned for the conclusion! You’re almost there!</p></section><section><h3 id="egui"><code>egui</code><a aria-hidden="true" tabindex="-1" href="#egui"> #</a></h3><p>Now, we are starting to discuss about actual GUI libraries, starting with <code>egui</code>.</p><p>Wow the <a href="https://crates.io/crates/egui">crates.io</a> page is <em>long</em>. It also has a pronounciation guide!</p><p>Just like standard crates that has long READMEs, there’s an example, quickstart, features, and FAQs. There’s also a section for its design goals and its current development states. Additionally, there’s a section describing its dependencies, its purpose and reasoning, and integration possibilities. The README is chockful of explanations and discussions on its design decision, which I didn’t expect for this page at all.</p><p>I think the “Dependencies” and “Who is equi for?” sections are interesting. There’s an emphasis on being a low-dep crate. Also, there’s an emphasis on being a niche crate with its own use case. The “Why immediate mode” is unexpectedly long, even providing an advantage/disadvantage subsection. The “Other” section has a subsection on conventions and design choice, which does explain some patterns used here.<sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> Sidenote: I <em>disagree</em> that rust should have named and default arguments, but that’s an opinion I would love to discuss in another day.  </span> </p><p>Looking at the <a href="https://docs.rs/egui/latest/egui/">docs.rs</a>, there’s a small overview, docs of feature flags, a link to the… website. I don’t think it was mentioned in the crates.io page, and if it was, it’s not emphasized. Before we check out the website, let’s continue looking at the main section of docs.rs first. There’s multiple examples, a section about viewports and coordinate system, how to integrate egui, how to debug egui, an explanation of immediate mode (which is different from the crates.io page of  the advantage/disadvantage), and a miscellaneous section containing some guides.</p><p>I like the in-depth discussions on immediate mode and widgets, but I wonder if the main page of  docs.rs is the right place for it. Isn’t it better if the current miscellaneous page is split into multiple parts like the widgets discussion would be in the <code>Widget</code> trait, and the “Auto-sizing panels and windows” part is in the <code>Layout</code> struct? I don’t know.</p><p>My impressions of this page is that it seems disorganized, like why is half of the content in here? Should a beginner of egui “fully grok what immediate mode implies?” Maybe, maybe not. Does it need expand on multi-pass immediate mode in the crate root docs? Probably not. Seems like something that should be in a troubleshooting page or module. It’s like a collection of knick-knacks in a document form; yes, they’re useful to know, but does a beginner need to know that right now? Should they only discover a section of this when they are debugging, or should they know this upfront?</p><p>Now, let’s check out the crate’s <a href="https://www.egui.rs/">website</a>.</p><p>Ah.</p> <label for="eguis-website" data-astro-cid-ascxwteo=""> <img src="https://www.harudagondi.space/uploads/doc-quad/egui-website.png" alt="Egui&#39;s website." data-astro-cid-ascxwteo=""/> </label><p>It’s a demo.</p><p>It’s a nice demo, to be fair. Each example can be brought up via clicking on the thing at the right side of the page. The examples also have a corresponding link to its source code, which leads me to the specific file in the GitHub repo.</p><p>Aside from demos, you can switch to different tabs at the upper portion of the site. The <a href="https://www.egui.rs/#easymarkeditor">EasyMark editor</a> is a demo of egui’s custom markup language. It contains a brief description,  design philosophy, details, and feature roadmap. It also have a rendered view of the source code at the right side, which is nice.</p><p>The <a href="https://www.egui.rs/#http">HTTP</a> tab is not clear to me. Is it a demo? Why is it in a tab instead of being part of the demos?</p><p>The <a href="https://www.egui.rs/#clock">Fractal Clock</a>, <a href="https://www.egui.rs/#custom3d">3D Painting</a>, and <a href="https://www.egui.rs/#rendering">Rendering Test</a> tabs seems like demos for rendering in general. The clock is very mesmerizing, I’d have to say. Very effective tool to showcase rendering capabilities.</p><p>Unlike other crates that has a website, egui’s does not seem to be aimed for people who want to learn via tutorials or how-to guides; rather, it’s aimed to those who just wanna see the stuff themselves, and only needs examples. Not much handholding is happening here. I may dock some (nonexistent) points for approachability. (Well I’m not tallying the score anyway, so)</p><p>Now for our favorite part of reviewing a crate: the API reference! First, we shall look at the entry-point type of the library, which I think is <a href="https://docs.rs/egui/latest/egui/struct.Ui.html"><code>Ui</code></a>.</p><p>The docs contains two “paragraphs” each with one sentence, plus an example code snippet.  Okay. I’m assuming the meat of this is in the methods. Well, they aren’t exactly faring better, given that they are all mostly just two sentence description, but I’ll have to say that I like the links to relevant items in the second sentences.</p><p>Most examples I’ve seen in their repo’s <a href="https://github.com/emilk/egui/tree/master/examples">examples folder</a> (I don’t think this was linked anywhere in the crates.io or docs.rs, but I may have missed it) require <a href="https://crates.io/crates/eframe"><code>eframe</code></a>, which is apparently the official library that allows making apps using <code>egui</code> where it actually renders windows to the screen. Which makes me wonder: is there a tutorial or manual on how to do this? I can’t tell from the docs I’ve read.</p><p>I don’t really know what item to check out next, so uhhhh *throws dart* let’s check out the <a href="https://docs.rs/egui/latest/egui/viewport/index.html"><code>viewport</code></a> module.</p><p>Okay! The docs here are measurably better; they’re much, much longer. It tells you how to spawn a new viewport and it discusses the different viewport classes it has. It also has a section on viewport usage and integration stuff. It’s interesting that there’s a short section on future viewport work, linking to a GitHub <a href="https://github.com/emilk/egui/issues/3556">tracking issue</a>.</p><p>Well, to conclude this crate, I guess my general feeling is that despite the crates.io page/main docs.rs page being comprehensive, it feels a bit… disorganized? I don’t know if that judgement is fair. I think some parts of the docs could have been relegated to either the relevant modules/types or the website instead. Speaking of, I wish the site was kinda expanded upon to have a tutorial and some explanations on its design philosophy, like the immediate mode stuff. The crate docs is somewhat less approachable due to the disorganization, but I do like the discoverability in the item docs.</p></section><section><h3 id="iced"><code>iced</code><a aria-hidden="true" tabindex="-1" href="#iced"> #</a></h3><p>The next and last GUI library we will be discussing is iced.</p><p>The README on <a href="https://crates.io/crates/iced">crates.io</a> looks nice; like a typical README of the JavaScript frameworks I’ve seen, there’s centered text and some gifs (yes, the pinnacle of READMEs). The features section is a bulleted list of what <code>iced</code> is. There’s also an overview section of how its architecture works, accompanied by some mini-tutorial with code snippets. Moreover, there’s an intriguing section on its implementation details, which explains some of its design decisions and history.</p><p>To be safe, let’s check if there’s a link explicitly stating that they have a website. They do not. But, the metadata does have the homepage link, leading to <a href="https://iced.rs/">iced.rs</a>.</p><p>The website is clean, with the front page displaying a typical hero section and showcases of real-world applications using <code>iced</code>. The navigation bar is just a drop down menu called “Documentation”, with items linking to the iced book, docs.rs page, and a subdomain containing a rustdoc generated reference built from the development branch.</p><p>Looking at the <a href="https://book.iced.rs/index.html">iced book</a>, it seems unfinished, with 3 main sections and two sections in the appendix. The written sections however are very approachable, using the 2nd person point of view, simple graphics and diagrams, with a storyteller-like cadence. I like the approach of guiding the reader to build an app from the ground up, and refactoring as we see fit.</p><p>I really like the note at the end of the main section. The author tells us that the current form is intended to serve as a quick intro, but admits that the book is not done yet. I’d say its a nice gesture, and illustrates the hard work that comes with documentation. I hope they get the resource and help needed to finish it, because I really like it.</p><p>Moving to the <a href="https://docs.rs/iced/latest/iced/">docs.rs</a> page, I’m greeted with a disclaimer. I want to highlight the last two paragraphs here:</p><blockquote>
<p>Therefore, iced is easy to learn for <strong>advanced</strong> Rust programmers; but plenty of patient beginners have learned it and had a good time with it. Since it leverages a lot of what Rust has to offer in a type-safe way, it can be a great way to discover Rust itself.</p>
<p>If you don’t like the sound of that, you expect to be spoonfed, or you feel frustrated and struggle to use the library; then I recommend you to wait patiently until <a href="https://book.iced.rs/">the book</a> is finished.</p>
</blockquote><p>Harsh, but I get it. Open source is <em>hard</em>, and dedicating the time to documentation is harder when you could be resolving issues or adding new features. However, given that this library is becoming more widely use, where even <a href="https://github.com/pop-os/libcosmic">Pop_OS! is now using iced</a> for their apps, I wonder if there’s any interested contributors that would like to improve the iced book. On the other hand, maybe iced breaks too fast with its updates, and you can’t really discuss anything beyond the fundamentals without it being out of date very  quickly.</p><p>The rest of the crate root’s docs consists of snippets for each concept of the crate and how to start using them. They aren’t an exhaustive explanation of these concepts, but they’re a great venue for discovering what iced has to offer here in terms of API. And wow there’s a lot of concepts here.</p><p>Now let’s check the entry point item here, which I’m inferring to be the <a href="https://docs.rs/iced/latest/iced/fn.application.html"><code>application</code></a> function. Okay. A single sentence description and a usage example with no explanation. Am I surprised? No. The docs just told me that I’m not gonna be spoonfed. I’m guessing that I’ll have to rely on the function signature<sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> I should write a blog post on this  </span>  for documentation. But then look at the signature:</p><div><figure><pre data-language="rust"><code><div><p><span>pub</span><span> </span><span>fn</span><span> </span><span>application</span><span>&lt;</span><span>State</span><span>,</span><span> </span><span>Message</span><span>,</span><span> </span><span>Theme</span><span>,</span><span> </span><span>Renderer</span><span>&gt;(</span></p></div><div><p><span>    </span><span>title</span><span>:</span><span> </span><span>impl</span><span> </span><span>Title</span><span>&lt;</span><span>State</span><span>&gt;,</span></p></div><div><p><span>    </span><span>update</span><span>:</span><span> </span><span>impl</span><span> </span><span>Update</span><span>&lt;</span><span>State</span><span>,</span><span> </span><span>Message</span><span>&gt;,</span></p></div><div><p><span>    </span><span>view</span><span>:</span><span> </span><span>impl</span><span> </span><span>for</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>View</span><span>&lt;&#39;</span><span>a</span><span>,</span><span> </span><span>State</span><span>,</span><span> </span><span>Message</span><span>,</span><span> </span><span>Theme</span><span>,</span><span> </span><span>Renderer</span><span>&gt;,</span></p></div><div><p><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Application</span><span>&lt;</span><span>impl</span><span> </span><span>Program</span><span>&lt;</span><span>State</span><span> </span><span>=</span><span> </span><span>State</span><span>,</span><span> </span><span>Message</span><span> </span><span>=</span><span> </span><span>Message</span><span>,</span><span> </span><span>Theme</span><span> </span><span>=</span><span> </span><span>Theme</span><span>&gt;&gt;</span></p></div><div><p><span>where</span></p></div><div><p><span>    </span><span>State</span><span>:</span><span> </span><span>&#39;</span><span>static</span><span>,</span></p></div><div><p><span>    </span><span>Message</span><span>:</span><span> </span><span>Send</span><span> </span><span>+</span><span> </span><span>Debug</span><span> </span><span>+</span><span> </span><span>&#39;</span><span>static</span><span>,</span></p></div><div><p><span>    </span><span>Theme</span><span>:</span><span> </span><span>Default</span><span> </span><span>+</span><span> </span><span>DefaultStyle</span><span>,</span></p></div><div><p><span>    </span><span>Renderer</span><span>:</span><span> </span><span>Renderer</span><span>,</span></p></div></code></pre></figure></div><p>Well. I personally can understand this. But can a beginner? No, probably not. Can an intermediate to advanced user understand this? Probably yes. Like look: the generics aren’t single letter names; they’re full words. It’s readable if you have the appropriate experience.</p><p>I want to check out <a href="https://docs.rs/iced/latest/iced/type.Element.html"><code>Element</code></a>, which… okay. It’s a type alias where the code block has a horizontal scroll bar. And the docs is just two sentences totalling to fifteen words.</p><p>🤷‍♀️</p><p>Yeah, this is gonna be a frustrating experience for a beginner.</p><p>At least there’s some docs with extensive content, like <a href="https://docs.rs/iced_core/0.13.2/iced_core/struct.Element.html"><code>iced_core::Element::map</code></a> for example.</p><p>To sum it all up. I think the iced book is very promising, with its accessible language for beginners, contrasted with its API reference’s barebones docs. Is it comprehensive? Eh. The iced book needs not to be, and the reference needs some more examples and explanatory text. The crates.io README does have some of its philosophies written down, and the root docs on docs.rs gives a good overview for the user to discover some of its basic features. Beyond that? Good luck!</p></section><section><h3 id="wgpu"><code>wgpu</code><a aria-hidden="true" tabindex="-1" href="#wgpu"> #</a></h3><p>This crate is semi-related to the previous two crates. It’s a graphics library! Yay.</p><p>The <a href="https://crates.io/crates/wgpu">crates.io</a> page is somewhat long. There’s a tabulated links of docs, examples and changelog; and there’s a bulleted list of links to all the libraries in the monorepo. The getting started section is intriguing, as it not only have a subsection on Rust, but also on C/C++ and other languages. The community section are links to a Matrix space, which is interesting since most of the crates I’ve seen before uses Discord for real-time communication. There’s also extension specifications. I don’t know what that means. There’s a table of support platforms, with helpful emojis telling you what kind of support it has, with an accompanying subsection on shader support and whatever “Angle” is. There’s even a dedicated section on environment variables and testing.</p><p>Checking on the metadata, it does have a <a href="https://wgpu.rs/">homepage</a>, so let’s check that out.</p><p>Just like <code>iced</code>, <a href="https://wgpu.rs/"><code>wgpu.rs</code></a> contains a hero section and a grid of third-party libraries and binaries that uses <code>wgpu</code> under the hood. The navigation has links to docs.rs, “download” links (they’re just links to crates.io + GitHub repo), and  a live demo page that looks kinda scuffed. There’s no link to the source code for each example, and the navigation bar seems unCSS’d. Well, at least there’s examples, but I don’t know how to find the source easily.</p><p>Looking at the <a href="https://docs.rs/wgpu/latest/wgpu/">docs.rs</a>, it just features a small description and feature flags. No simple examples. Probably not possible for a graphics library I guess. The docs does tell me that to start using the API, I should create an <a href="https://docs.rs/wgpu/latest/wgpu/struct.Instance.html"><code>Instance</code></a>. So let’s check that out first.</p><p>At least this has more than two sentences. Kinda eh that the items with minimal docs are very terse. The methods are faring better, like <a href="https://docs.rs/wgpu/latest/wgpu/struct.Instance.html#method.new"><code>Instance::new</code></a> having a dedicated “Arguments” section for explaining what the argument entails. Too bad some of them are disappoint, like <a href="https://docs.rs/wgpu/latest/wgpu/struct.Instance.html#method.from_hal"><code>Instance::from_hal</code></a> having the docs “<code>hal_instance</code> - wgpu-hal instance.”</p><p><code>wgpu</code> kinda falls short for me. I appreciate the examples, demos, and the length of the README, but I feel like they could do more here. I guess I was kinda wrong for expecting the docs to be targeted to beginners to <code>wgpu</code>.</p></section><section><h3 id="tokio"><code>tokio</code><a aria-hidden="true" tabindex="-1" href="#tokio"> #</a></h3><p>Now let’s move on to async executors, starting with arguably the most popular one: <code>tokio</code>!</p><p>The <a href="https://crates.io/crates/tokio">crates.io</a> page seems organized and typical of most other crates, like having an overview, examples and link to other guides, contributing section, list of related projects, and other stuff about the crate maintenance itself. Thank god that they have a link to the website that is explicitly labelled as “Website”.</p><p>Browsing their <a href="https://tokio.rs/">website</a>, I’m greeted with a typical hero section and a list of sponsors (I’m assuming), some of its high level features, and the <code>tokio</code> stack. Remarkably, there’s a guide book when clicking on the <a href="https://tokio.rs/tokio/tutorial">Learn</a> tab in the navigation bar.</p><p>This page contains a tutorial on making a mini-<code>redis</code>, applying all the features <code>tokio</code> has to offer while guiding you all the way through. Damn, this tutorial is substantive and filled with information about the behavior and some of the idiosyncrasies of its functions and types. After the tutorial proper, there’s explanations on how async exactly works under the hood, and discusses some features not yet discussed in the tutorial. Love that for discoverability.</p><p>There’s also a section called <a href="https://tokio.rs/tokio/topics">“Topics”</a>, which has “self-contained articles related to various topics that come up when writing asynchronous applications.” Yep, these are how-to guides. It’s interesting that these guides backreference the tutorial on making a “mini-<code>redis</code>” which makes me question the “self-contained” aspect of this. There’s also two articles named <a href="https://tokio.rs/tokio/topics/tracing">“Getting started with Tracing”</a> and <a href="https://tokio.rs/tokio/topics/tracing-next-steps">“Next steps with Tracing”</a>. I’m getting mixed signals here.</p><p>In addition, there’s also the glossary. I have not seen that before. It looks good; there’s definitely a lot of terminologies with its own connotation in the context of asynchronous programming, so this is useful.</p><p>The API documentation tab just links me to the <a href="https://docs.rs/tokio/latest/tokio/">docs.rs page</a>. Let’s put a pin on that for later.</p><p>Last thing I want to look at in the website is the <a href="https://tokio.rs/blog/2025-01-01-announcing-axum-0-8-0">blog</a>. It basically consists of announcement posts, including both new released versions of the tokio stack crates and new crates. The latest non-announcement post was back in 2021, which is the first and only <a href="https://tokio.rs/blog/2021-09-console-dev-diary-1">dev diary about tokio-console</a>. Sad, I would’ve like reading more about the thoughts of the developers. Other non-announcement blog posts include an <a href="https://tokio.rs/blog/2021-05-14-inventing-the-service-trait">insight on <code>tower</code>’s <code>Service</code> trait</a>, <a href="https://tokio.rs/blog/2021-04-welcome-alice">welcoming someone as the first paid contributor</a>, and <a href="https://tokio.rs/blog/2020-04-preemption">how the maintainers reduced latencies with a specific strategy</a>. I would love to read more about the developer’s thoughts and tokio’s internals. Maybe a “this week/month in tokio” style devlog would be nice?</p><p>Unpining the page we pinned earlier, next let’s look at the API documentation.</p><p>Okay, the crate root docs is at least substantial. Like, it occupies like 90% of the whole page. There’s a simple overview, and a tour of tokio which gives a survey of the landscape like its common functions, and modules one should know when working with specific things like async IO and scheduling. The example section is just a code snippet of a simple TCP echo server, with not much explanation. Okay. There’s also the standard feature flags docs, which is mostly just “enables X traits/types”, and there’s unstable feature flags which are API that may break in 1.x.y releases. Lastly, there’s a section on support platforms, including <code>wasm</code> support, some of its caveats.</p><p>Let’s check on the entry-point item, which is the <a href="https://docs.rs/tokio/latest/tokio/attr.main.html"><code>main</code></a> attribute macro. The docs are substantial, containing a lot of notes and example usage, not only just the default but also how to use the single threaded runtime, setting the number of worker threads, starting with time paused, handling renamed use imports, and how to handle panics. Nice.</p><p>Next, let’s check out the <a href="https://docs.rs/tokio/latest/tokio/task/fn.spawn.html"><code>spawn</code></a> function, which seems like the bread-and-butter action people would do in an async context. Just like <code>tokio::main</code>, the documentation here is long, with a informative description, two examples, when it panics, and how to use <code>!Send</code> values from a task. I like that it gives you its guarantees and caveats; not something I see often in these docs.</p><p>I’ll have to say the docs here is clean, informative, organized, and accessible to beginners and intermediates. The tutorial is comprehensive, the how-to guides are, eh. It’s okay. I was hoping for more explanations like the blog posts I pointed out earlier, and the reference isn’t an afterthought here.</p></section><section><h3 id="smol"><code>smol</code><a aria-hidden="true" tabindex="-1" href="#smol"> #</a></h3><p><code>smol</code> is another async executor, albeit not as popular as <code>tokio</code>.</p><p>The README on the <a href="https://crates.io/crates/smol">crates.io</a> page is considerably shorter than <code>tokio</code>’s, but it isn’t <em>nothing</em>. It has an overview, an example, a list of its subcrates, um, a section about TLS certificates (?), its MSRV policy and license. The crate doesn’t have a website, so my only source docs here would be the API reference.</p><p>The docs in <a href="https://docs.rs/smol/2.0.2/smol/">docs.rs</a> is the same as the first two sections in the README we read earlier, with a link to the examples. Sadly, the example folder doesn’t have a README, so it doesn’t really makes it clear what the files here mean. What’s an <code>async-h1-client.rs</code> and <code>async-h1.server.rs</code>? I don’t know. What’s the difference with <code>simple-client.rs</code>, <code>tcp-client.rs</code>, and <code>tls-client.rs</code>? I’d have to click on them.</p><p>Let’s look at the entry-point item of this crate, which I’m assuming is <a href="https://docs.rs/smol/2.0.2/smol/fn.block_on.html"><code>block_on</code></a>. Ah. A single sentence description and an example. Okay.</p><p><a href="https://docs.rs/smol/2.0.2/smol/struct.Executor.html"><code>Executor</code></a> isn’t faring better, with the type docs and most of its methods consists of obvious one liner descriptions and an example. At least <code>smol</code> has examples for every part of this. Love the doctests aspect of this. <a href="https://docs.rs/smol/2.0.2/smol/struct.Executor.html#method.spawn_many"><code>Executor::spawn_many</code></a> is somewhat curious, as it has additional two paragraphs that contrasts this method with the <a href="https://docs.rs/smol/2.0.2/smol/struct.Executor.html#method.spawn"><code>spawn</code></a>, and a note of its behavior when a large number of tasks is spawned.</p><p>I don’t really have much to say here. I guess I like the amount of examples here.</p></section><section><h3 id="embassy"><code>embassy</code><a aria-hidden="true" tabindex="-1" href="#embassy"> #</a></h3><p>The third and last async crate we will be looking at is <code>embassy</code>.</p><p>The <a href="https://crates.io/crates/embassy">crates.io</a> page… is literally just this:</p><blockquote>
<p>Crate name reserved for the Embassy project: <a href="https://github.com/akiles/embassy">https://github.com/akiles/embassy</a></p>
</blockquote><p>OK.</p><p>The GitHub repo is clearly better, with links to the Embassy Book, the API reference, the website, and the Matrix server. There’s also a section on its motivation, its features whose description are actually a paragraph long, and a “sneak peek” which actually is just a quick start example. There’s an examples section which explains how the folder is organized, and how to run them (it’s not just <code>cargo run --example foo</code> apparently).</p><p>I wanna check out the website first. Ah, just typical hero sections and grid of features. Something new here that I haven’t seen yet is the blog, which contains only three posts. The <a href="https://embassy.dev/blog/hello-world/">oldest post</a> is literally just titled “Hello World!” and the content is “Hello World!”. The other two are announcement posts. Okay. Let’s move on.</p><p>The <a href="https://embassy.dev/book/index.html">Embassy Book</a> is just an incredibly long single page. I like that the tutorial anticipates for possible problems like <code>cargo run --release</code> not working. The book also contains a high-level reference and architecture of the crate. There’s also a lot of questions in the FAQs section, which is good.</p><p>What I appreciate the most here is the <a href="https://embassy.dev/book/index.html#_system_description">“System description”</a> section, which even has diagrams on the executor’s behavior and bootloader partitions. It’s surprisingly detailed. Also, love the best practices section, haven’t seen that before.</p><p>Lastly, let’s look at the API reference. It links me to the <a href="https://docs.embassy.dev/embassy-executor/git/cortex-m/index.html"><code>docs.embassy.dev</code></a> site, which contains its unique behavior and features, and the description of its features flags. Reading the docs of the <a href="https://docs.embassy.dev/embassy-executor/git/cortex-m/attr.main.html"><code>main</code></a> macro, it’s not as illustrative as tokio’s <code>main</code> macro but it does describes its restrictions succinctly. Same could be said for <a href="https://docs.embassy.dev/embassy-executor/git/cortex-m/attr.task.html"><code>task</code></a>.</p><p>An interesting thing I would like to point out is that unlike docs.rs where the second button in the navbar gives you its links, owners, deps, and versions, embassy’s rustdoc generated page has a list of related crates here.</p> <label for="smols-navigation-bar" data-astro-cid-ascxwteo=""> <img src="https://www.harudagondi.space/uploads/doc-quad/embassy-smol-navbar.png" alt="Smol&#39;s navigation bar" data-astro-cid-ascxwteo=""/> </label> <label for="embassys-navigation-bar" data-astro-cid-ascxwteo=""> <img src="https://www.harudagondi.space/uploads/doc-quad/embassy-doc-navbar.png" alt="Embassy&#39;s navigation bar" data-astro-cid-ascxwteo=""/> </label><p>Seeing the docs on <a href="https://docs.embassy.dev/embassy-time/git/default/index.html"><code>embassy-time</code></a>, I like that there’s an extensive overview of how time works especially in the context of embedded device. Sadly, most of the items like <a href="https://docs.embassy.dev/embassy-time/git/default/struct.Duration.html"><code>Duration</code></a>, <a href="https://docs.embassy.dev/embassy-time/git/default/struct.Instant.html"><code>Instant</code></a>, and <a href="https://docs.embassy.dev/embassy-time/git/default/fn.block_for.html"><code>block_for</code></a> have single sentence descriptions.</p><p>So, I really like the embassy book, as it is a good starting point, a good source of its design and architecture, and common troubleshooting questions, but the API reference leaves a desire that could have been fleshed out more.</p></section><section><h3 id="the-rust-official-documentation">The Rust Official Documentation<a aria-hidden="true" tabindex="-1" href="#the-rust-official-documentation"> #</a></h3><p>Last but not least, let’s look at the official docs, including all official books and the standard library.</p><p>Of course, we have to start with the main site of the programming language which is <a href="https://www.rust-lang.org/">https://www.rust-lang.org/</a>. Just like the websites we have seen before, there’s a hero section containing a <strong>GET STARTED</strong> button, and a list of its main features. There’s also a list of fields and domains Rust excels at, a single paragraph (no links?) about how Rust is used in production, how to get into Rust, and a section dedicated to contributors and foundation members.</p><p>Clicking on the “getting started” button leads me to detailed guide on how to install Rust and code in the aforementioned programming language. I like that each part of the guide is divided by the background color, and how there’s links to how to setup Rust in some editors. Curiously also includes <a href="https://helix-editor.com/">Helix</a> (where it links me to the <a href="https://rust-analyzer.github.io/book/index.html">rust-analyzer</a> <code>mdbook</code> page?) and <a href="https://projects.eclipse.org/projects/tools.corrosion">Eclipse</a>.<sup data-astro-cid-w6f27h4z="">†</sup><span>  <sup data-astro-cid-w6f27h4z="">†</sup> I love the section describing the (unofficial) mascot of Rust, Ferris!  </span> </p><p>The <a href="https://www.rust-lang.org/learn">Learn</a> tab contains links to many of its documentation and tutorials, like the <a href="https://doc.rust-lang.org/book/">Rust Book</a>, <a href="https://github.com/rust-lang/rustlings/">Rustlings</a>, and <a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a> (RBE). There’s also a section on Rust’s core documentation, which contains the standard library and five <code>mdbook</code>s about its tooling, editions, and compiler errors. Continuing on that, they also link to <code>mdbook</code>s on specific application domains such as the command line, WebAssembly, and embedded devices. Lastly, there’s also links to more advanced documentation such as the <a href="https://doc.rust-lang.org/reference/index.html">Reference/Informal Specification</a>, the <a href="https://doc.rust-lang.org/nomicon/index.html">Rustonomicon</a>, and the <a href="https://doc.rust-lang.org/nightly/unstable-book/index.html">Unstable Book</a>.</p><p>Yup. There’s a lot of books.</p><p>I would love to discuss every book ever, but that would make this blog post 50,000+ words long, so let’s not, probably. 😛</p><p>Moving on to other tabs, the <a href="https://play.rust-lang.org/">Playground</a> link leads me to an interactive code editor where you can run simple Rust programs. Annoying that you can’t go back though, even when clicking the previous page button on the browser.</p><p>The <a href="https://www.rust-lang.org/tools">Tools</a> tab includes links on how to add support for Rust in various editors, just like what we saw in the Getting Start page. There’s also some instructions how to use <code>cargo</code>, Rust’s build tool, and there’s a dedicated section to Rust’s official tooling for formatting, linting, and documenting.</p><p>Next, the <a href="https://www.rust-lang.org/governance">Governance</a> page previews how the process of working and improving on the language works. Including the RFC process and all the teams and link to the members and contact details demonstrates the transparency of the Rust team as a whole. (Let’s not delve into the details :ferrisClueless:)</p><p>Furthermore, the <a href="https://www.rust-lang.org/community">Community</a> tab gives some links to its forums and chat platforms. It’s interesting that there’s separate forums for users and internals, and they use two different platforms for real time communication. I like that they also include the “<a href="https://this-week-in-rust.org/">This Week in Rust</a>” website, a community-ran newsletter reporting on the new features, crates, and updates that happened in the past week.</p><p>Do the governance and community pages count as documentation? I’d argue so. They don’t refer to the direct usage of the language, but they do relate to Rust, specifically the social aspects of it. I realized before then that documentation is made by people and meant to be read by people. I know that’s obvious, but without recognizing the human and understanding the perspective of others, how can we write documentation that is catered to our users?</p><p>My opinion is that the community page is useful because when documentation fails us, we can turn to other people for help. Then, we can diagnose the missing or substandard piece of docs and rewrite it to be better. The governance page is interesting because not only the leadership and its teams decide what features to add, modify, or delete, but also how would they communicate to the multitude of users. With varying degrees of experience and competence in both coding and general communication, the docs must be accessible to all of them, or at least the majority. That’s why I like the inclusion of the RFC process here, which gives the power of an ordinary user to suggest changes in an organized way, and some of the aspects the teams consider is teachability to the user, which is critical.</p><p>Last in the website that we will discuss is the <a href="https://blog.rust-lang.org/">blog</a>. Okay, we see the classic announcement pages here. But not as much as other crates. There’s a lot of other stuff, like <a href="https://blog.rust-lang.org/2025/04/11/crates-io-security-session-cookies/">reporting security incidents</a>, <a href="https://blog.rust-lang.org/2025/04/08/Project-Goals-2025-March-Update/">project goals update</a>, <a href="https://blog.rust-lang.org/2025/04/04/vision-doc-survey/">call to actions</a> (maybe a survey?), and a <a href="https://blog.rust-lang.org/2025/04/04/c-abi-changes-for-wasm32-unknown-unknown/">lot</a> <a href="https://blog.rust-lang.org/2025/03/26/adopting-the-fls/">of</a> <a href="https://blog.rust-lang.org/2025/03/03/Rust-participates-in-GSoC-2025/">other</a> <a href="https://blog.rust-lang.org/2025/02/13/2024-State-Of-Rust-Survey-results/">stuff</a>. I like the monthly project goals update the most, as it gives the reasoning for why they’re working for a feature, what happened to that progress, and some help wanted posts and other goal updates not brought to the spotlight.</p><p>Before we look at the API reference, I wanna check out a book that is commonly recommended to beginners, nicknamed <a href="https://doc.rust-lang.org/book/">The Book</a>. This resource is popular as a source recommended to beginners for them to start working with Rust. I’m not going to dive into each chapter here, but I’ll give some of my opinions here.</p><p>First, this book is not really aimed for absolute beginners to programming in general. It’s obvious from the third chapter titled “Common Programming Concepts”. This chapter is typically taught in universities for a semester or two. For example, my high school taught programming in Visual Basic for a year, and we never reached functions. I’ve also heard of people in IT and engineering courses learning about the basics in a semester. So the fact that these concepts are compressed to a single chapter probably makes it hard for absolute beginners to get over that hump. On the other hand, learning Rust as a first programming language could be very easy as you aren’t coming from the mainstream OOP languages and rewiring your brain to work with Rust’s paradigm.</p><p>My second opinion is that the “Advanced Features” chapter shouldn’t be called “advanced.” These topics aren’t advanced. These are intermediate at best, but I’d consider them part of the fundamentals. You want advanced topics? Read the <a href="https://doc.rust-lang.org/nomicon/">nomicon</a>. Or the <a href="https://rust-unofficial.github.io/too-many-lists/">Too Many Lists Book</a>. Or the many blog posts about <a href="https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html">pointers</a>, <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">provenance</a>, and <a href="https://www.ralfj.de/blog/2022/04/11/provenance-exposed.html">exposed semantics</a>. I’ve seen a lot of people skipping this part because they “don’t need it,” or “they could read it later,” which ugh. You are going to encounter that in your second or third mini-project. Let’s not waste time not knowing what you don’t know.</p><p>My third and last opinion is that I wish the Rust Book has a chapter titled “Next Steps”. In RPLCS (the community Discord server), I’ve seen a lot of people asking “what should I do after reading the book?” which is a valid question. Sure, you could make projects, but what if you can’t think of one right now. That’s why I have made a Carl-bot tag titled <code>roadmap</code> which contains several links to resources I have found valuable when learning Rust, and recently refactored it into its own <a href="https://github.com/harudagondi/rust-roadmap">GitHub repository</a>.</p><p>Whew. Anyways. Let’s move on to what we are we are waiting for: the <a href="https://doc.rust-lang.org/std/index.html">API reference</a>!</p><p>The main page familiarizes you with the landscape and how to navigae them. The section on the tour of the rust standard library lists out containers and collections, and platform abstractions and I/O, which is nice. Let’s look at what I think is a representative set of items, which are:</p><ol>
<li><code>Option</code></li>
<li><code>Vec</code></li>
<li><code>Iterator</code></li>
<li><code>File</code></li>
<li><code>thread::spawn</code></li>
<li><code>std::pin</code></li>
</ol><p>The <code>Option</code> docs is just “The Option type” and then refers to the module level docs for more information. Okay, let’s look at the <a href="https://doc.rust-lang.org/std/option/index.html">module</a>. Now this is more promising. It explains the uses of <code>Option</code>, interactions with pointers, the try operator, its byte representation, and an overview of its methods. I really love this overview. Just reading the actual type docs seems noiser with the formatting on its functions, but here? It’s formatted as bulleted lists with appropriate descriptions that compare and contrasts with othe related methods. I also like the table in the boolean operators section. Very reminiscent of truth tables.</p><p>Next, let’s check out the <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> docs. Unlike the docs on <code>Option</code>, the main docs is located on the type proper. There’s examples, and sections on indexing and slicing. There’s also some explanations on its capacity and reallocation behavior, plus some its guarantees. The guarantees section is very informative. It extensively discusses its memory representation, its behavior in regards to allocation and reallocation via its methods, and drop order.</p><p>Some of the methods have very simplistic description, with <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.new"><code>Vec::new</code></a> having only two sentences and a single line example. I probably would’ve added using it in <code>const</code> and <code>static</code>, and maybe mention about the Vec using a dangling pointer. Some methods are actually very educational, especially unsafe functions such as <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.from_raw_parts"><code>Vec::from_raw_parts</code></a>, with an incredibly long list of invariants that must be followed, and two long examples showcasing this.</p><p>The third item we will be looking at is the <code>Iterator</code> trait. Just like <code>Option</code>, it gives me a very obvious description and a link to the <a href="https://doc.rust-lang.org/std/iter/index.html">module-level documentation</a>. It has a section on how the module was organized, how Iterator mainly works, how to iterate on stuff, and how to implement it. The documentation also discusses some part on iterator adapters, <code>Iterator</code>’s lazy behavior, and the possibility of infinite elements. I like that they pointed out the last three things, but I wish they expounded on the adapter aspect, and how <code>next</code> works with nested <code>Iterator</code> types. Spoiler alert: unlike JavaScript, <code>my_iter.map(...).filter(...)</code> does not mean it maps all elements first, then filters all resulting elements next.</p><p>Fourth, let’s look at <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a>. It explains what an instance of the struct can do, drop behavior, and caveats on reads and writes. Honestly, the docs here is similar to other crates that has long docs: with several examples, and methods having a medium length of description accompanied by examples. The <a href="https://doc.rust-lang.org/std/fs/index.html">module docs</a> doesn’t really have much to add here.</p><p>Fifth, let’s check the <a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn</code></a> function. Okay, long docs. I like the explanation on its trait bounds. Ooooh, there’s more than one code snippet in the examples section, and there’s a notes section about unwinding behavior. The <a href="https://doc.rust-lang.org/std/thread/index.html">module</a> docs explains the threading model of Rust, and an overview of how to spawn threads via the function mentioned earlier. There’s also something about thread-local storage, naming threads, and stack sizes, which I am surprised that it wasn’t emphasized that much in the <code>spawn</code> function.</p><p>Last but not least, we should look at the <a href="https://doc.rust-lang.org/std/pin/index.html"><code>pin</code></a> module, which contains one of the most detailed docs I’ve ever seen. It explains what “moving” is, what “pinning” is, examples where moving is detrimental, details on pinning, and implement address sensitive types. I think I’ve only seen the concept of pinning really sublimated in Rust, so it makes sense that the language takes extra effort into explaining this idea.</p><p>To conclude this part, the Rust official documentation is the most comprehensive among all crates we’ve seen before, maximizing approachability and discoverability with the amount of books it has. The blog is not just a glorified announcement page, it includes some explanatory details on current and future features, and some things about the community at whole. However, the majority of the docs is just a big ol’ reference, with some guides/tutorials here or there. I guess you can’t really have tutorials without getting into very specific domains. And by that point, might as well just browse your favorite crate’s docs for that.</p></section></section>
<section><h2 id="analysis-of-crates">Analysis of Crates<a aria-hidden="true" tabindex="-1" href="#analysis-of-crates"> #</a></h2><p>Well. I don’t expect this section to be very rigorous. More just vibes I guess.</p><p>What I noticed in the crates I have reviewed is that there is a wide variety of text content in these documentations, but the mode of delivering these docs are somewhat consistent. There’s crates.io, docs.rs, sometimes an mdbook generated document for more complex crates, and a website.</p><p>My common criticisms is that API references are typically too short to not explain anything beyond its name. Surely people can say something more than “The Frobnicator struct.” What are its exact behavior? Do I have to look at the source code and its unit tests to determine what it does and does not? I think if someone needs to do this, then the documentation failed.</p><p>There’s some arguments that you could infer the meaning of the function via its signature. <em>Damn Haskellers</em>. This is true for some cases, but you generally can’t glean the nuance of its behavior just from the signature and their names. This is especially true for unsafe functions, since you can’t rely on reading a raw pointer in the signature and make deductions out of that. Unless the crate is sufficient type-safe, relying on signatures 100% isn’t feasible.</p><p>I’ve noticed that there’s only a few crates that really elaborated on its design philosophy very well. Sure, there are some that lists out its features, but they don’t explain why its good and decided to focus on that. Bevy’s reasoning on focusing on being data-driven using the ECS paradigm is not really mentioned anyway from what I can tell. There’s posts on discussing what makes <a href="https://bevyengine.org/news/introducing-bevy/#bevy-ecs">Bevy’s ECS</a> implementation special, but nothing about why ECS over OOP. What motivates the original maintainer to use ECS in the first place? There are pages that discusses the benefits of ECS, but is that what the author was thinking of?</p><p>Moving on the topic of websites, some of them kinda fall flat and some are incredibly good. I don’t want to name names, because that would be sad and accusatory. But I like it when websites bring something to the table that both the crates.io and docs.rs sites could not. At the very least, I would like to see a main tutorial and multiple how-to guides in these sites, since docs.rs can’t do custom sorting of modules without any jank. Does <code>mdbook</code> count as a custom website? In this context, I’d say so. However, I am not that familiar with the possible limitations of <code>mdbook</code> to say much.</p><p>Speaking of tutorials, does dumping a big code snippet to the user counts as a tutorial? I pointed out these “quick start tutorials” some of these crates have where they only have a single code block that contains a minimal runnable example. Okay great. Now what? I was hoping that we get a step by step process on making a minimal program, narrated by the developer’s thoughts. Maybe even modifying that same program by adding more features! Programming isn’t really a once-and-done deal like what these examples imply. It is an <em>iterative process</em>, and I want the tutorials to reflect that.</p><p>The benefit of this iterative style, like what Bevy and Ratatui has, is that it lends to more avenues of more organized discoverability and better approachability. Like, if I read a long code snippet, how do I derive its salient functions easily? Compared to a narrative type of tutorials, the author has the choice to emphasize and highlight what functions and types the reader should focus on. This is an important aspect of tutorials in serving the purpose of discoverability. Why waste time reading function docs mentioned in the tutorial when in the real world, it is only really used in tutorials or unit tests? We should consider the reader, not just in the moment where they’re reading the tutorial, but also what happens after that.</p><p>When it comes to how-to guides, I think there’s not even much emphasis on this in all the crates I’ve seen here. I guess FAQs act as how-to guides here. Among all the reviewed crates, I like <code>embassy</code> the best, as it actually addresses the problem in the perspective of the <em>user</em>, and it’s short and sweet. Second would be probably Bevy’s usage of GitHub discussions, since it involves real users, but I don’t know if it is good since the answers are in the perspective of the library author. Same for <code>clap</code>’s FAQ page with the perspective stuff, but without the involvement of the user and their problems. Clap’s is mostly about theoretical questions, not practical problems.</p><p>My criteria on philosophy seems the most neglected by the majority of the crates. Is it fair to say neglected? I don’t know. Anyways, since the standard library is basically bare bones, and everyone is making their 51st game engine, I think crates would benefit from explaining what sets them from the rest. With that, I really liked <code>jiff</code>’s the most. It has the greatest amount of detail written about the rationale of the library, and <em>why it exists</em>, as opposed to just contributing to another. Library authors should ask themselves: what makes my library unique? And how do I communicate that to my potential users? It may help people decide what’s best for them, help users understand why the library is the way it is, and help contributors tread through the machinery.</p><p>I guess all in all, the popular crates are promising. They <em>could</em> do better, and I hope they will. Personally, I believe that documentation is the second most important thing an open source project should be focused on, first being the code of course. Code executes your vision, while documentation makes it accessible. That’s why I think internalizing the mantra of “bad docs are bugs” is very essential; programming is not just a mental problem, but also a social one. You can’t just publish a docless crate and expect people to use it. Even if your code is a miraculous act of god, if you can’t communicate to someone how to use it, then they don’t understand it, and they won’t use it.</p><p>…</p><p>Uhhh, I guess I don’t really have anything more to say, so to end this section: I want you to repeat “Bad docs are bugs!” three times in front of a mirror to see Ferris give you a high five. Congratulations!</p></section>
<section><h2 id="conclusion">Conclusion<a aria-hidden="true" tabindex="-1" href="#conclusion"> #</a></h2><p>To conclude this 23,000+ words worth a blog post, I wanna start with awarding crates with superlatives I just made up:</p><ol>
<li><strong>Best Design Rationale</strong>: <code>jiff</code></li>
<li><strong>Best Website</strong>: Bevy and Ratatui</li>
<li><strong>Best mdbook</strong>: Fyrox</li>
<li><strong>Best Tutorials</strong>: Rocket</li>
<li><strong>Best How-to Guides</strong>: <code>embassy</code></li>
<li><strong>Best Explanations</strong>: <code>jiff</code></li>
<li><strong>Best API References</strong>: The Rust standard library</li>
<li><strong>Most Comprehensive</strong>: Fyrox or <code>jiff</code>, I can’t decide.</li>
<li><strong>Most Discoverable</strong>: Bevy</li>
<li><strong>Most Approachable</strong>: Bevy or Rocket, I also can’t decide.</li>
</ol><p>I just decided these on the spot, so probably don’t think about it too hard.</p><p>Anyways, there’s a lot of shortcomings with this blog post, so I want to give out recommendations (just like in research papers) for other people to write about this:</p><ol>
<li>Approach this review in a quantitative way, somehow.</li>
<li>Review non-popular crates.</li>
<li>Survey the Rust community on their thoughts on documentation.</li>
<li>Actually approach this in rigorous qualitative way. Maybe peruse the <a href="https://uk.sagepub.com/en-gb/eur/qualitative-inquiry-and-research-design/book266033">Creswell book</a>, I don’t know.</li>
<li>Write this blog post but better lol</li>
</ol><p>I hope you enjoyed this post and goodbye!</p></section> <hr/>  <hr/>  </article>  </div></div>
  </body>
</html>
