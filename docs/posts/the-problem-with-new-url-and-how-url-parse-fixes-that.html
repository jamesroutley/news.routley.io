<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kilianvalkhof.com/2024/javascript/the-problem-with-new-url-and-how-url-parse-fixes-that/">Original</a>
    <h1>The problem with new URL(), and how URL.parse() fixes that</h1>
    
    <div id="readability-page-1" class="page"><div><p>As someone building <a href="https://polypane.app">a browser</a> I need to parse a lot of URLs. Partially to validate them, but also to normalize them or get specific parts out of the URL. The URL API in browsers lets you do that, but it’s ergonomics aren’t ideal.<span id="more-3281"></span></p><h3>The problem with <code>new URL()</code></h3><p>The “new” in front of new URL() indicates that it’s used as a constructor: calling it creates a new URL instance for you. When you give it a malformed URL however, one that it can’t parse, it throws an error. Because it throws an error, you need to write code to handle that error.</p><p>If you don’t do that, The thrown error won’t get handled and your JS stops being executed. The following code looks great but if <code>urlstring</code> is malformed, it will stop execution:</p><pre><code>const urlstring = &#34;this is not a URL&#34;;
const not_a_url = new URL(urlstring);
// Uncaught TypeError: URL constructor: &#34;this is not a URL&#34; is not a valid URL.</code></pre><p>So you&#39;ll want to wrap it in a try...catch so that the error is caught.</p><pre><code>const urlstring = &#34;this is not a URL&#34;;
let not_a_url;

try {
   not_a_url = new URL(urlstring);
} catch {
  // we catch and ignore the error
  // not_a_url is already undefined so no need to actually do anything.
}</code></pre><p>That&#39;s a lot more lines of code, has more visual noise and it means you have to change <code>not_a_url</code> from a <code>const</code> to a <code>let</code> to be able to overwrite it. The control flow of the application ends up being more complex.</p><h3>Making it slightly better</h3><p>A recent addition to the URL api is <code>URL.canParse()</code>, a function that returns true if the URL is a parseable URL.</p><p>It&#39;s only been available cross-browser <a href="https://caniuse.com/mdn-api_url_canparse_static">since December 2023</a> so it might be a little too early for general use, but it does make the code more readable.</p><p>Instead of trying and catching the error, we can first check if the URL is parseable before parsing it, and we can do that inline:</p><pre><code>const urlstring = &#34;this is not a URL&#34;;

const not_a_url = URL.canParse(urlstring) &amp;&amp; new URL(urlstring);
// not_a_url = false</code></pre><p>This makes <code>not_a_url</code> a const again, and is definitely easier to understand.</p><h3>Complaining</h3><p>Rather than being constructive and writing my own little function to abstract that try...catch or canParse away from my regular code base, I decided to do the right thing and <a href="https://twitter.com/kilianvalkhof/status/1765312128188088454">complain on Twitter</a>:</p><blockquote><p> Making new URL() throw when you give it an invalid URL was a terrible API choice.</p></blockquote><p>Not much later Anne van Kesteren <a href="https://twitter.com/annevk/status/1767939562368569807">replied</a> with a link to a <a href="https://github.com/whatwg/url/issues/372">GitHub issue</a> discussing the addition of a &#34;parse&#34; function to URL that would not throw.</p><p>Anne added that issue in 2018 but my tweet <a href="https://github.com/whatwg/url/issues/372#issuecomment-1994704897">renewed interest</a>. Not much later, Anne added <code>URL.parse()</code> to <a href="https://github.com/whatwg/url/issues/372">the spec</a> and implementation bugs were filed for all browser engines.</p><p>Anne himself implemented it <a href="https://bugs.webkit.org/show_bug.cgi?id=271636">in WebKit</a> and it&#39;s also going to <a href="https://chromestatus.com/feature/6301071388704768">ship in Chromium 126</a> and <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1887611">Firefox 126</a>.</p><h3>Using URL.parse</h3><p>With URL.parse we can go back to that original example all the way up top, and keep our control flow as simple as possible:</p><pre><code>const urlstring = &#34;this is not a URL&#34;;

const not_a_url = URL.parse(urlstring);
// not_a_url = null</code></pre><p>The browsers with this feature will ship in the next few months (Firefox in May, Chrome in June, I&#39;ve not been able to figure out when Safari will) so you&#39;ll have to wait a little before using it but I can&#39;t wait to get rid of all my try..catch calls!</p></div></div>
  </body>
</html>
