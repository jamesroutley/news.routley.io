<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/litestream-v050-is-here/">Original</a>
    <h1>Litestream v0.5.0</h1>
    
    <div id="readability-page-1" class="page"><article>
         <dl>
             <dt>Author</dt>
             <dd>
                 <img alt="Ben Johnson" src="https://fly.io/static/images/ben.webp"/>
               <dl>
                 <dt>Name</dt>
                 <dd>
                   Ben Johnson
                 </dd>
                  <dt>@benbjohnson</dt>
                  <dd>
                    <a href="https://twitter.com/benbjohnson" target="_blank">
                      @benbjohnson
                    </a>
                  </dd>
               </dl>
             </dd>
         </dl>

        <section>
            <figure>
                <img src="https://fly.io/blog/litestream-v050-is-here/assets/litestream-v050-is-here.jpg" alt=""/>
                <figcaption>
                  <span>Image by</span>
                  
<svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd">
  <g buffered-rendering="static">
    <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path>
  </g>
</svg>

                    <a href="https://annieruygtillustration.com/" target="_blank">
                      Annie Ruygt
                    </a>
                </figcaption>
            </figure>
          <p><strong>I’m Ben Johnson, and I work on Litestream at Fly.io. Litestream makes it easy to build SQLite-backed full-stack applications  with resilience to server failure. It’s open source, runs anywhere, and</strong> <a href="https://litestream.io/" title=""><strong>it’s easy to get started</strong></a><strong>.</strong></p>
<p>Litestream is the missing backup/restore system for SQLite. It runs as a sidecar process in the background, alongside unmodified SQLite applications, intercepting WAL checkpoints and streaming them to object storage in real time. Your application doesn’t even know it’s there. But if your server crashes, Litestream lets you quickly restore the database to your new hardware.</p>

<p>The result: you can safely build whole full-stack applications on top of SQLite.</p>

<p>A few months back, we announced <a href="https://fly.io/blog/litestream-revamped/" title="">plans for a major update to Litestream</a>. I’m psyched to announce that the first batch of those changes are now “shipping”. Litestream is  faster and now supports efficient point-in-time recovery (PITR).</p>

<p>I’m going to take a beat to recap Litestream and how we got here, then talk about how these changes work and what you can expect to see with them.</p>
<h2 id="litestream-to-litefs-to-litestream"><a href="#litestream-to-litefs-to-litestream" aria-label="Anchor"></a><span>Litestream to LiteFS to Litestream</span></h2>
<p>Litestream is one of two big SQLite things I’ve built. The other one, originally intended as a sort of sequel to Litestream, is LiteFS.</p>

<p>Boiled down to a sentence: LiteFS uses a FUSE filesystem to crawl further up into SQLite’s innards, using that access to perform live replication, for unmodified SQLite-backed apps.</p>

<p>The big deal about LiteFS for us is that it lets you do the multiregion primary/read-replica deployment people love Postgres for: reads are fast everywhere, and writes are sane and predictable. We were excited to make this possible for SQLite, too.</p>

<p>But the market has spoken! Users prefer Litestream. And honestly, we get it: Litestream is easier to run and to reason about. So we’ve shifted our focus back to it. First order of business: <a href="https://fly.io/blog/litestream-revamped/" title="">take what we learned building LiteFS and stick as much of it as we can back into Litestream</a>.</p>
<h2 id="the-ltx-file-format"><a href="#the-ltx-file-format" aria-label="Anchor"></a><span>The LTX File Format</span></h2>
<p>Consider this basic SQL table:</p>
<div>
  <div>
    <pre><code id="code-n62ywsla"><span>CREATE</span> <span>TABLE</span> <span>sandwiches</span> <span>(</span>
    <span>id</span> <span>INTEGER</span> <span>PRIMARY</span> <span>KEY</span> <span>AUTOINCREMENT</span><span>,</span>
    <span>description</span> <span>TEXT</span> <span>NOT</span> <span>NULL</span><span>,</span>
    <span>star_rating</span> <span>INTEGER</span><span>,</span> 
    <span>reviewer_id</span> <span>INTEGER</span> <span>NOT</span> <span>NULL</span>
<span>);</span>
</code></pre>
  </div>
</div>
<p>In our hypothetical, this table backs a wildly popular sandwich-reviewing app that we keep trying to get someone to write. People eat a lot of sandwiches and this table gets a lot of writes. Because it makes my point even better and it’s funny, assume people dither a lot about their sandwich review for the first couple minutes after they leave it. This Quiznos sub… is it ⭐ or ⭐⭐?</p>

<p>Underneath SQLite is a B-tree. Like databases everywhere, SQLite divides storage up into disk-aligned pages, working hard to read as few pages as possible for any task while treating work done within a page as more or less free. SQLite always reads and writes in page-sized chunks.</p>

<p>Our <code>sandwiches</code> table includes a feature that’s really painful for a tool like Litestream that thinks in pages: an automatically updating primary key. That key dictates that every insert into the table hits the rightmost leaf page in the underlying table B-tree. For SQLite itself, that’s no problem. But Litestream has less information to go on: it sees only a feed of whole pages it needs to archive.</p>

<p>Worse still, when it comes time to restore the database – something you tend to want to happen quickly – you have to individually apply those small changes, as whole pages. Your app is down, PagerDuty is freaking out, and you’re sitting there watching Litestream reconstruct your Quiznos uncertainty a page (and an S3 fetch) at a time.</p>

<p>So, LTX. Let me explain. We needed LiteFS to be transaction-aware. It relies on finer-grained information than just raw dirty pages (that’s why it needs the FUSE filesystem). To ship transactions, rather than pages, we invented a <a href="https://github.com/superfly/ltx" title="">file format we call LTX</a>.</p>

<p>LTX was designed as an interchange format for transactions, but for our purposes in Litestream, all we care about is that LTX files represent ordered ranges of pages, and that it supports compaction.</p>

<p>Compaction is straightforward. You’ve stored a bunch of LTX files that collect numbered pages. Now you want to to restore a coherent picture of the database. Just replay them newest to oldest, skipping duplicate pages (newer wins), until all changed pages are accounted for.</p>

<p>Importantly, LTX isn’t limited to whole database backups. We can use LTX compaction to compress a bunch of LTX files into a single file with no duplicated pages. And Litestream now uses this capability to create a hierarchy of compactions:</p>

<ul>
<li>at Level 1, we compact all the changes in a 30-second time window
</li><li>at Level 2, all the Level 1 files in a 5-minute window
</li><li>at Level 3, all the Level 2’s over an hour.
</li></ul>

<p>Net result: we can restore a SQLite database to any point in time, <em>using only a dozen or so files on average</em>.</p>

<p>Litestream performs this compaction itself. It doesn’t rely on SQLite to process the WAL file. Performance is limited only by I/O throughput.</p>
<h2 id="no-more-generations"><a href="#no-more-generations" aria-label="Anchor"></a><span>No More Generations</span></h2>
<p>What people like about Litestream is that it’s just an ordinary Unix program. But like any Unix program, Litestream can crash. It’s not supernatural, so when it’s not running, it’s not seeing database pages change. When it misses changes, it falls out of sync with the database.</p>

<p>Lucky for us, that’s easy to detect. When it notices a gap between the database and our running “shadow-WAL” backup, Litestream resynchronizes from scratch.</p>

<p>The only time this gets complicated is if you have multiple Litestreams backing up to the same destination. To keep multiple Litestreams from stepping on each other, Litestream divides backups into “generations”, creating a new one any time it resyncs. You can think of generations as Marvel Cinematic Universe parallel dimensions in which your database might be simultaneously living in.</p>

<p>Yeah, we didn’t like those movies much either.</p>

<p>LTX-backed Litestream does away with the concept entirely. Instead, when we detect a break in WAL file continuity, we re-snapshot with the next LTX file. Now we have a monotonically incrementing transaction ID. We can use it look up database state at any point in time, without searching across generations.</p>
<h2 id="upgrading-to-litestream-v0-5-0"><a href="#upgrading-to-litestream-v0-5-0" aria-label="Anchor"></a><span>Upgrading to Litestream v0.5.0</span></h2>
<p>Due to the file format changes, the new version of Litestream can’t restore from old v0.3.x WAL segment files.</p>

<p>That’s OK though! The upgrade process is simple: just start using the new version. It’ll leave your old WAL files intact, in case you ever need to revert to the older version.The new LTX files are stored cleanly in an <code>ltx</code> directory on your replica.</p>

<p>The configuration file is fully backwards compatible.</p>

<p>There’s one small catch. We added a new constraint. You only get a single replica destination per database. This probably won’t affect you, since it’s how most people use Litestream already. We’ve made it official.</p>

<p>The rationale: having a single source of truth simplifies development for us, and makes the tool easier to reason about. Multiple replicas can diverge and are sensitive to network availability. Conflict resolution is brain surgery.</p>

<p>Litestream commands still work the same. But you’ll see references to “transaction IDs” (TXID) for LTX files, rather than the <code>generation/index/offset</code> we used previously with WAL segments.</p>

<p>We’ve also changed <code>litestream wal</code> to <code>litestream ltx</code>.</p>
<h2 id="other-stuff-v0-5-0-does-better"><a href="#other-stuff-v0-5-0-does-better" aria-label="Anchor"></a><span>Other Stuff v0.5.0 Does Better</span></h2>
<p>We’ve beefed up the <a href="https://github.com/superfly/ltx" title="">underlying LTX file format library</a>. It used to be an LTX file was just a sorted list of pages, all compressed together. Now we compress per-page, and keep an index at the end of the LTX file to pluck individual pages out.</p>

<p>You’re not seeing it yet, but we’re excited about this change: we can operate page-granularly even dealing with large LTX files. This allows for more features. A good example: we can build features that query from any point in time, without downloading the whole database.</p>

<p>We’ve also gone back through old issues &amp; PRs to improve quality-of-life. CGO is now gone. We’ve settled the age-old contest between <code>mattn/go-sqlite3</code> and <code>modernc.org/sqlite</code> in favor of <code>modernc.org</code>. This is super handy for people with automated build systems that want to run from a MacBook but deploy on an x64 server, since it lets the cross-compiler work.</p>

<p>We’ve also added a replica type for NATS JetStream. Users that already have JetStream running can get Litestream going without adding an object storage dependency.</p>

<p>And finally, we’ve upgraded all our clients (S3, Google Storage, &amp; Azure Blob Storage) to their latest versions. We’ve also moved our code to support newer S3 APIs.</p>
<h2 id="whats-next"><a href="#whats-next" aria-label="Anchor"></a><span>What’s next?</span></h2>
<p>The next major feature we’re building out is a Litestream VFS for read replicas. This will let you instantly spin up a copy of the database and immediately read pages from S3 while the rest of the database is hydrating in the background.</p>

<p>We already have a proof of concept working and we’re excited to show it off when it’s ready!</p>

          
        </section>
        <dl>
            <dt>
              Previous post  ↓
            </dt>
            <dd>
              <a href="https://fly.io/blog/build-better-agents-with-morphllm/">
                Build Better Agents With MorphLLM
              </a>
            </dd>
        </dl>
      </article></div>
  </body>
</html>
