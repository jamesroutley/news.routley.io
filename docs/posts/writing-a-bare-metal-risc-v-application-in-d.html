<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zyedidia.github.io/blog/posts/1-d-baremetal/">Original</a>
    <h1>Writing a bare-metal RISC-V application in D</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>This post will show you how to use D to write a bare-metal “Hello world”
program that targets the RISC-V QEMU simulator.  In a future blog post (<a href="https://zyedidia.github.io/blog/posts/2-baremetal-visionfive">now
available</a>) we’ll build on this to target actual
hardware: the <a href="https://www.kickstarter.com/projects/starfive/visionfive-2">VisionFive
2</a> SBC. See
<a href="https://github.com/zyedidia/blog-code">blog-code</a> for the final code from
this post. For a more complex example, see
<a href="https://github.com/zyedidia/multiplix">Multiplix</a>, an operating system I am
developing that runs on the VisionFive 2 (and Raspberry Pis).</p>

<p>Recently I’ve been writing bare-metal code in C, and I’ve become a bit
frustrated with the lack of features that C provides. I started searching for a
good replacement, and revisited <a href="https://dlang.org">D</a> (a language I used for a
project a few years ago).  It turns out D has introduced a mode called
<a href="https://dlang.org/spec/betterc.html">betterC</a><sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> (sounds exactly like what I
want), which essentially disables all language features that require the D
runtime. This makes it roughly as easy to use D for bare-metal programming as
C. You don’t get all the features of D, but you get enough that it covers all
the things I want (in fact, for systems programming I prefer the betterC subset
of D over full D). D in betterC mode is exactly what it sounds like, and
retains the feel of C – going forward I think I will be using it instead of C
in all situations where I would have otherwise used C (even in non-bare-metal
situations).</p>
<p>Here are the positives about D I value most:</p>
<ul>
<li>A decent import system (no more header files and <code>#include</code>).</li>
<li>Automatic bounds checking, and bounded strings and arrays.</li>
<li>Methods in structs.</li>
<li>Compile-time code evaluation (run D code at compile-time!).</li>
<li>Powerful templating and generics.</li>
<li>Iterators.</li>
<li>Default support for thread-local storage.</li>
<li>Scope guards and RAII.</li>
<li>Some memory safety protections with <code>@safe</code>.</li>
<li>A fairly comprehensive and readable <a href="https://dlang.org/spec/spec.html">online specification</a>.</li>
<li>An active discord channel with people that answer my questions in minutes.</li>
<li>Both an LLVM-based compiler (LDC) and a GNU compiler (GDC), which is officially
part of the GCC project.
<ul>
<li>And these compilers both export roughly the same flags and intrinsics as
Clang and GCC respectively.</li>
</ul>
</li>
</ul>
<p>These features, combined with the lack of a runtime and the C-like feel of the
language (making it easy to port previous code), make it a no-brainer for me to
have D as the base choice for any project where I would otherwise use C.</p>

<p>Now that I’ve told you about my reasons for choosing D, let’s try using it to
write a bare-metal application that targets RISC-V. If you want to follow
along, the first step is to download the toolchain (the following tools should
work on Linux or MacOS). You’ll need three different components:</p>
<ol>
<li>LDC 1.30 (the LLVM-based D compiler). Can be downloaded from
<a href="https://github.com/ldc-developers/ldc/releases/tag/v1.30.0">GitHub</a>. Make sure to
use version 1.30<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</li>
<li>A <code>riscv64-unknown-elf</code> GNU toolchain. Can be downloaded from
SiFive’s <a href="https://github.com/sifive/freedom-tools/releases">Freedom Tools
repository</a>.</li>
<li>The QEMU RISC-V simulator: <code>qemu-system-riscv64</code>. Can be downloaded from
SiFive’s <a href="https://github.com/sifive/freedom-tools/releases">Freedom Tools
repository</a>, or also
usually available as part of your system’s QEMU package.</li>
</ol>
<p>We’ll be using LDC since it ships with the ability to target <code>riscv64</code>.  I have
used GDC for bare-metal development as well, but it requires building a
toolchain from source since nobody ships pre-built <code>riscv64-unknown-elf-gdc</code>
binaries<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>. We’ll use the GNU toolchain for assembling, linking, and for other
tools like <code>objcopy</code> and <code>objdump</code>, and QEMU for simulating the hardware.</p>
<p>With these installed you should be able to run:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ ldc2 --version
</span></span><span><span>LDC - the LLVM D compiler (1.30.0):
</span></span><span><span>...
</span></span><span><span>
</span></span><span><span>$ riscv64-unknown-elf-ld
</span></span><span><span>riscv64-unknown-elf-ld: no input files
</span></span><span><span>
</span></span><span><span>$ qemu-system-riscv64 -h
</span></span><span><span>...
</span></span></code></pre></div>
<p>We’re writing bare-metal code, so there’s no operating system, no console, no
files – nothing. The CPU just starts executing instructions at a pre-specified
address<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> after performing some initial setup. We’ll figure out what that
address is later when we set up the linkerscript. For now we can just define
the <code>_start</code> symbol as our entrypoint, and assume the linker will place the
code at this label at the CPU entrypoint.</p>
<p>A D function requires a valid stack pointer, so before we can execute any D code
we need to load the stack pointer register <code>sp</code> with a valid address.</p>
<p>Let’s make a file called <code>start.s</code> and put the following in it:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>.section</span> <span>&#34;.text.boot&#34;</span>
</span></span><span><span>
</span></span><span><span><span>.globl</span> <span>_start</span>
</span></span><span><span><span>_start:</span>
</span></span><span><span>    <span>la</span> <span>sp</span>, <span>_stack_start</span>
</span></span><span><span>    <span>call</span> <span>dstart</span>
</span></span><span><span><span>_hlt:</span>
</span></span><span><span>    <span>j</span> <span>_hlt</span>
</span></span></code></pre></div><p>For now let’s assume <code>_stack_start</code> is a symbol with the address of a valid
stack, and in the linkerscript we’ll set this up properly. After loading <code>sp</code>,
we call a D function called <code>dstart</code>, defined in the next part.</p>

<p>Now we can define our <code>dstart</code> function in <code>dstart.d</code>. For now we’ll just cause
an infinite loop.</p>
<div><pre tabindex="0"><code data-lang="d"><span><span><span>module</span> <span>dstart</span><span>;</span>
</span></span><span><span>
</span></span><span><span>extern <span>(</span>C<span>)</span> <span>void</span> <span>dstart</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>while</span> <span>(</span><span>1</span><span>)</span> <span>{}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div>
<p>Before we can compile this program we need a bit of linkerscript to tell the
linker how our code should be laid out. We’ll need to specify the address where
the text section should start (the entry address), and reserve space for all
the data sections (<code>.rodata</code>, <code>.data</code>, <code>.bss</code>), and the stack.</p>
<h2 id="entry-address">Entry address</h2>
<p>Today we’ll be targeting the QEMU <code>virt</code> RISC-V machine, so we have
to figure out what its entrypoint is.</p>
<p>We can ask QEMU for a list of all devices in the <code>virt</code> machine by telling it
to dump the its device tree:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ qemu-system-riscv64 -machine virt,dumpdtb=virt.dtb
</span></span><span><span>$ dtc virt.dtb &gt; virt.dts
</span></span></code></pre></div><p>In <code>virt.dts</code> you’ll find the following entry:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>memory@80000000 {
</span></span><span><span>    device_type = &#34;memory&#34;;
</span></span><span><span>    reg = &lt;0x00 0x80000000 0x00 0x8000000&gt;;
</span></span><span><span>};
</span></span></code></pre></div><p>This means that RAM starts at address <code>0x80000000</code> (everything below is special
memory or inaccessible). The CPU entrypoint for the <code>virt</code> machine is the first
instruction in RAM, stored at <code>0x80000000</code>.</p>
<p>In the linkerscript, we need to tell the linker that it should place the
<code>_start</code> function at <code>0x80000000</code>. We do this by telling it to put the
<code>.text.boot</code> section first in the <code>.text</code> section, located at <code>0x80000000</code>.
Then we include the rest of the <code>.text</code> sections, followed by read-only data,
writable data, and the BSS.</p>
<p>In <code>link.ld</code>:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>ENTRY(_start)
</span></span><span><span>
</span></span><span><span>SECTIONS
</span></span><span><span>{
</span></span><span><span>    .text 0x80000000 : {
</span></span><span><span>        KEEP(*(.text.boot))  
</span></span><span><span>        *(.text*) 
</span></span><span><span>    }
</span></span><span><span>    .rodata : {
</span></span><span><span>        . = ALIGN(8);
</span></span><span><span>        *(.rodata*)
</span></span><span><span>        *(.srodata*)
</span></span><span><span>        . = ALIGN(8);
</span></span><span><span>    }
</span></span><span><span>    .data : { 
</span></span><span><span>        . = ALIGN(8);
</span></span><span><span>        *(.sdata*)
</span></span><span><span>        *(.data*)
</span></span><span><span>        . = ALIGN(8);
</span></span><span><span>    } 
</span></span><span><span>    .bss : {
</span></span><span><span>        . = ALIGN(8);
</span></span><span><span>        _bss_start = .;
</span></span><span><span>        *(.sbss*)
</span></span><span><span>        *(.bss*)
</span></span><span><span>        *(COMMON)
</span></span><span><span>        . = ALIGN(8);
</span></span><span><span>        _bss_end = .;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    .kstack : {
</span></span><span><span>        . = ALIGN(16);
</span></span><span><span>        . += 4K;
</span></span><span><span>        _stack_start = .;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    /DISCARD/ : { *(.comment .note .eh_frame) }
</span></span><span><span>}
</span></span></code></pre></div><h2 id="what-is-the-bss">What is the BSS?</h2>
<p>The BSS is a region of memory that the compiler assumes is initialized to all
zeroes. Usually the static data for a program is directly copied into the ELF
executable – if you have a string <code>&#34;hello world&#34;</code> in your program, those exact
bytes will live somewhere in the binary (in the read-only data section).
However, a lot of static data is initialized to zero, so instead of putting
those zero bytes directly into the ELF file, the linker lets us save space by
making a special section (the BSS) that must be initialized to all zeroes at
runtime, but won’t actually contain that data in the ELF file itself.  So even
if you have a giant 1MB array of zeroes, your ELF binary will be small because
that section will be expanded into RAM only when the application starts.
Usually the OS sets up the BSS before it launches a program, but we’re running
bare-metal, so we have to do that manually in the <code>dstart</code> function (in the
next section).  To make this initialization possible, we define the
<code>_bss_start</code> and <code>_bss_end</code> symbols in the linkerscript. These are symbols
whose <em>addresses</em> will be the start and end of the BSS section respectively.</p>
<h2 id="reserving-space-for-the-stack">Reserving space for the stack</h2>
<p>We also reserve one page for the <code>.kstack</code> section and mark the <code>_stack_start</code>
symbol to be located to the end of it (remember the stack grows down). The
stack must be 16-byte aligned.</p>

<p>Now we have everything we need to compile a basic bare-metal program.</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ ldc2 -Oz -betterC -mtriple=riscv64-unknown-elf -mattr=+m,+a,+c --code-model=medium -c dstart.d
</span></span><span><span>$ riscv64-unknown-elf-as -mno-relax -march=rv64imac start.S -c -o start.o
</span></span><span><span>$ riscv64-unknown-elf-ld -Tlink.ld start.o dstart.o -o prog.elf
</span></span></code></pre></div><p>Let’s look at some of these flags:</p>
<ul>
<li><code>Oz</code>: optimize aggressively for size.</li>
<li><code>betterC</code>: enable betterC mode (disable the built-in D runtime).</li>
<li><code>mtriple=riscv64-unknown-elf</code>: build for the riscv64 bare-metal ELF target.</li>
<li><code>mattr=+m,+a,+c</code>: enable the following RISC-V extensions: <code>m</code>
(multiply/divide), <code>a</code> (atomics), and <code>c</code> (compressed instructions).</li>
<li><code>code-model=medium</code>: <a href="https://www.sifive.com/blog/all-aboard-part-4-risc-v-code-models">code
models</a> in
RISC-V control how pointers to far away locations are constructed. The
<code>medium</code> code model (also called <code>medany</code>) allows us to address any symbol
located within 2 GiB of the current address, and is recommended for 64-bit
programs. See the SiFive post for more information.</li>
<li><code>mno-relax</code>: disables linker relaxation in the assembler (it is already
disabled by default in LDC). Linker relaxation is a RISC-V-specific
optimization that allows the linker to make use of the <code>gp</code> (global pointer)
register.  I explain it in more detail in the <a href="#enabling-linker-relaxation">linker relaxation
section</a>.</li>
</ul>
<p>It’s going to get tedious to type out these commands repeatedly, so let’s
create a Makefile<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> (or a <a href="https://github.com/zyedidia/knit">Knitfile</a> if you’re
cool):</p>
<div><pre tabindex="0"><code data-lang="make"><span><span><span>SRC</span><span>=</span><span>$(</span>wildcard *.d<span>)</span>
</span></span><span><span><span>OBJ</span><span>=</span><span>$(</span>SRC:.d<span>=</span>.o<span>)</span>
</span></span><span><span>
</span></span><span><span><span>all</span><span>:</span> prog.bin
</span></span><span><span>
</span></span><span><span><span>%.o</span><span>:</span> %.d
</span></span><span><span>	ldc2 -Oz -betterC -mtriple<span>=</span>riscv64-unknown-elf -mattr<span>=</span>+m,+a,+c,+relax --code-model<span>=</span>medium --makedeps<span>=</span><span>$*</span>.dep $&lt; -c -of <span>$@</span>
</span></span><span><span><span>%.o</span><span>:</span> %.s
</span></span><span><span>	riscv64-unknown-elf-as -march<span>=</span>rv64imac $&lt; -c -o <span>$@</span>
</span></span><span><span><span>prog.elf</span><span>:</span> start.o <span>$(</span><span>OBJ</span><span>)</span>
</span></span><span><span>	riscv64-unknown-elf-ld -Tlink.ld $^ -o <span>$@</span>
</span></span><span><span><span>%.bin</span><span>:</span> %.elf
</span></span><span><span>	riscv64-unknown-elf-objcopy $&lt; -O binary <span>$@</span>
</span></span><span><span><span>%.list</span><span>:</span> %.elf
</span></span><span><span>	riscv64-unknown-elf-objdump -D $&lt; &gt; <span>$@</span>
</span></span><span><span><span>run</span><span>:</span> prog.bin
</span></span><span><span>	qemu-system-riscv64 -nographic -bios none -machine virt -kernel prog.bin
</span></span><span><span><span>clean</span><span>:</span>
</span></span><span><span>	rm -f *.bin *.list *.o *.elf *.dep
</span></span><span><span>
</span></span><span><span><span>-include</span> <span>*.dep</span>
</span></span></code></pre></div><p>and compile with</p>
<p>This file is a raw dump of our program. At this point it clocks in at a
whopping 22 bytes.</p>
<p>To see the disassembled program, run</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ make prog.list
</span></span><span><span>...
</span></span><span><span>$ cat prog.list
</span></span><span><span>prog.elf:     file format elf64-littleriscv
</span></span><span><span>
</span></span><span><span>Disassembly of section .text:
</span></span><span><span>
</span></span><span><span>0000000080000000 &lt;_start&gt;:
</span></span><span><span>    80000000:	00001117          	auipc	sp,0x1
</span></span><span><span>    80000004:	02010113          	addi	sp,sp,32 # 80001020 &lt;_stack_start&gt;
</span></span><span><span>    80000008:	00000097          	auipc	ra,0x0
</span></span><span><span>    8000000c:	00c080e7          	jalr	12(ra) # 80000014 &lt;dstart&gt;
</span></span><span><span>
</span></span><span><span>0000000080000010 &lt;_hlt&gt;:
</span></span><span><span>    80000010:	a001                	j	80000010 &lt;_hlt&gt;
</span></span><span><span>    ...
</span></span><span><span>
</span></span><span><span>0000000080000014 &lt;dstart&gt;:
</span></span><span><span>    80000014:	a001                	j	80000014 &lt;dstart&gt;
</span></span></code></pre></div><p>Looks like our <code>_start</code> function is being linked properly at <code>0x80000000</code> and
has the expected assembly!</p>
<p>If you try to run with</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>$ make run
</span></span><span><span>qemu-system-riscv64 -nographic -bios none -machine virt -kernel prog.bin
</span></span></code></pre></div><p>it will just enter an infinite loop (press <code>Ctrl-A</code> <code>Ctrl-X</code> to quit QEMU). We
still have a bit more work to do before we get output.</p>

<p>Now let’s modify <code>dstart</code> to initialize the BSS. We need to declare some
<code>extern</code> variables so that the linker symbols <code>_bss_start</code> and <code>_bss_end</code> are
available to our D code. Then we can just loop from <code>_bss_start</code> to <code>_bss_end</code>
and assign all the bytes in that range to zero. Once complete, our BSS is
initialized and we can run arbitrary<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup> D code (using globals that may be
initialized to zero).</p>
<div><pre tabindex="0"><code data-lang="d"><span><span>extern <span>(</span>C<span>)</span> <span>{</span>
</span></span><span><span>    extern <span>__gshared</span> <span>uint</span> _bss_start<span>,</span> _bss_end<span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>void</span> <span>dstart</span><span>()</span> <span>{</span>
</span></span><span><span>        <span>uint</span><span>*</span> bss <span>=</span> <span>&amp;</span>_bss_start<span>;</span>
</span></span><span><span>        <span>uint</span><span>*</span> bss_end <span>=</span> <span>&amp;</span>_bss_end<span>;</span>
</span></span><span><span>        <span>while</span> <span>(</span>bss <span>&lt;</span> bss_end<span>)</span> <span>{</span>
</span></span><span><span>            <span>*</span>bss<span>++</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>import</span> <span>main</span><span>;</span>
</span></span><span><span>        kmain<span>();</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>And in <code>main.d</code> we have our bare-metal main entrypoint:</p>
<div><pre tabindex="0"><code data-lang="d"><span><span><span>module</span> <span>main</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>kmain</span><span>()</span> <span>{}</span>
</span></span></code></pre></div>
<p>Several D language features are unavailable because of our lack of runtime. For
example, types such as <code>string</code> and <code>size_t</code> are undefined, and we can’t use
assertions (we’ll get to those later). The first step to creating a minimal
runtime is to create an <code>object.d</code> file. The D compiler will search for this
special file and import it automatically everywhere. So we can create
definitions for types like <code>string</code> and <code>size_t</code> here. Here is the minimal
definition I like to use, which also defines <code>ptrdiff_t</code>, <code>noreturn</code>, and
<code>uintptr</code>.</p>
<div><pre tabindex="0"><code data-lang="d"><span><span><span>module</span> <span>object</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>alias</span> <span>string</span> <span>=</span> immutable<span>(</span><span>char</span><span>)[];</span>
</span></span><span><span><span>alias</span> size_t <span>=</span> typeof<span>(</span><span>int</span><span>.</span><span>sizeof</span><span>);</span>
</span></span><span><span><span>alias</span> ptrdiff_t <span>=</span> typeof<span>(</span><span>cast</span><span>(</span><span>void</span><span>*)</span> <span>0</span> <span>-</span> <span>cast</span><span>(</span><span>void</span><span>*)</span> <span>0</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>alias</span> noreturn <span>=</span> typeof<span>(*</span><span>null</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>static</span> <span>if</span> <span>((</span><span>void</span><span>*).</span><span>sizeof</span> <span>==</span> <span>8</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>alias</span> uintptr <span>=</span> <span>ulong</span><span>;</span>
</span></span><span><span><span>}</span> <span>else</span> <span>static</span> <span>if</span> <span>((</span><span>void</span><span>*).</span><span>sizeof</span> <span>==</span> <span>4</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>alias</span> uintptr <span>=</span> <span>uint</span><span>;</span>
</span></span><span><span><span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>    <span>static</span> <span>assert</span><span>(</span><span>0</span><span>,</span> <span>&#34;pointer size must be 4 or 8 bytes&#34;</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div>
<p>Most systems have a UART device. Generally how this works is that you write a
byte to a special place in memory<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>, and that byte will be transmitted using the
UART protocol over some pins on the board. In order to read the bytes with your
host computer you need a UART to USB adapter plugged into your host, and then
you can read from the corresponding device file (usually <code>/dev/ttyUSB0</code>) on the
host computer. Today we’ll just be simulating our bare-metal code in QEMU, so
you don’t need to have a special adapter. QEMU will emulate a UART device and
print out the bytes written to its transmit register.</p>
<h2 id="enabling-volatile-loadsstores">Enabling volatile loads/stores</h2>
<p>When writing to device memory it is important to ensure that the compiler does
not remove our loads/stores. For example, if a device is located at
<code>0x10000000</code>, we might write directly to that address by casting the integer to
a pointer. To the compiler, it just looks like we are writing to random
addresses, which might be undefined behavior or result in dead code (e.g., if
we never read the value back, the compiler may determine that it can eliminate
the write). We need to inform the compiler that these reads/writes of device
memory must be preserved and cannot be optimized out. D uses the
<code>volatileStore</code> and <code>volatileLoad</code> intrinsics for this.</p>
<p>We can define these in our <code>object.d</code>:</p>
<div><pre tabindex="0"><code data-lang="d"><span><span><span>pragma</span><span>(</span>LDC_intrinsic<span>,</span> <span>&#34;ldc.bitop.vld&#34;</span><span>)</span> <span>ubyte</span> <span>volatileLoad</span><span>(</span><span>ubyte</span><span>*</span> ptr<span>);</span>
</span></span><span><span><span>pragma</span><span>(</span>LDC_intrinsic<span>,</span> <span>&#34;ldc.bitop.vld&#34;</span><span>)</span> <span>ushort</span> <span>volatileLoad</span><span>(</span><span>ushort</span><span>*</span> ptr<span>);</span>
</span></span><span><span><span>pragma</span><span>(</span>LDC_intrinsic<span>,</span> <span>&#34;ldc.bitop.vld&#34;</span><span>)</span> <span>uint</span> <span>volatileLoad</span><span>(</span><span>uint</span><span>*</span> ptr<span>);</span>
</span></span><span><span><span>pragma</span><span>(</span>LDC_intrinsic<span>,</span> <span>&#34;ldc.bitop.vld&#34;</span><span>)</span> <span>ulong</span> <span>volatileLoad</span><span>(</span><span>ulong</span><span>*</span> ptr<span>);</span>
</span></span><span><span><span>pragma</span><span>(</span>LDC_intrinsic<span>,</span> <span>&#34;ldc.bitop.vst&#34;</span><span>)</span> <span>void</span> <span>volatileStore</span><span>(</span><span>ubyte</span><span>*</span> ptr<span>,</span> <span>ubyte</span> value<span>);</span>
</span></span><span><span><span>pragma</span><span>(</span>LDC_intrinsic<span>,</span> <span>&#34;ldc.bitop.vst&#34;</span><span>)</span> <span>void</span> <span>volatileStore</span><span>(</span><span>ushort</span><span>*</span> ptr<span>,</span> <span>ushort</span> value<span>);</span>
</span></span><span><span><span>pragma</span><span>(</span>LDC_intrinsic<span>,</span> <span>&#34;ldc.bitop.vst&#34;</span><span>)</span> <span>void</span> <span>volatileStore</span><span>(</span><span>uint</span><span>*</span> ptr<span>,</span> <span>uint</span> value<span>);</span>
</span></span><span><span><span>pragma</span><span>(</span>LDC_intrinsic<span>,</span> <span>&#34;ldc.bitop.vst&#34;</span><span>)</span> <span>void</span> <span>volatileStore</span><span>(</span><span>ulong</span><span>*</span> ptr<span>,</span> <span>ulong</span> value<span>);</span>
</span></span></code></pre></div><h2 id="controlling-the-uart">Controlling the UART</h2>
<p>With that set up, let’s figure out where QEMU’s UART device is located in
memory so we can write to it.</p>
<p>The QEMU <code>virt</code> machine defines a number of virtual devices, one of which is a
UART device. Looking through the QEMU device tree again in <code>virt.dts</code>, you’ll
see the following:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>uart@10000000 {
</span></span><span><span>    interrupts = &lt;0x0a&gt;;
</span></span><span><span>    interrupt-parent = &lt;0x03&gt;;
</span></span><span><span>    clock-frequency = &lt;0x384000&gt;;
</span></span><span><span>    reg = &lt;0x00 0x10000000 0x00 0x100&gt;;
</span></span><span><span>    compatible = &#34;ns16550a&#34;;
</span></span><span><span>};
</span></span></code></pre></div><p>This says that a ns16550a UART device exists at address <code>0x10000000</code>.</p>
<p>On real hardware the UART would need to be properly initialized by writing some
memory-mapped configuration registers (for setting up the baud rate and other
options). However the QEMU device does not require initialization. It emulates
an ns16550a device, and writing to its transmit register is enough to cause a
byte to be written over the UART (which appears on the console when simulating
with QEMU). The transmit register for the ns16550a is the first mapped register,
so it is located at <code>0x10000000</code>.</p>
<p>In <code>uart.d</code>:</p>
<div><pre tabindex="0"><code data-lang="d"><span><span><span>module</span> <span>uart</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>struct</span> <span>Ns16650a</span><span>(</span><span>ubyte</span><span>*</span> base<span>)</span> <span>{</span>
</span></span><span><span>    <span>static</span> <span>void</span> <span>tx</span><span>(</span><span>ubyte</span> b<span>)</span> <span>{</span>
</span></span><span><span>        volatileStore<span>(</span>base<span>,</span> b<span>);</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>alias</span> Uart <span>=</span> Ns16650a<span>!(</span><span>cast</span><span>(</span><span>ubyte</span><span>*)</span> <span>0x10000000</span><span>);</span>
</span></span></code></pre></div><p>Now in <code>kmain</code>, we can test the UART.</p>
<div><pre tabindex="0"><code data-lang="d"><span><span><span>module</span> <span>main</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>uart</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>kmain</span><span>()</span> <span>{</span>
</span></span><span><span>    Uart<span>.</span><span>tx</span><span>(</span><span>&#39;h&#39;</span><span>);</span>
</span></span><span><span>    Uart<span>.</span><span>tx</span><span>(</span><span>&#39;i&#39;</span><span>);</span>
</span></span><span><span>    Uart<span>.</span><span>tx</span><span>(</span><span>&#39;\n&#39;</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="txt"><span><span>$ make prog.bin
</span></span><span><span>$ qemu-system-riscv64 -nographic -bios none -machine virt -kernel prog.bin
</span></span><span><span>hi
</span></span></code></pre></div><p>Press <code>Ctrl-A</code> <code>Ctrl-x</code> to quit QEMU (the program will enter an infinite loop
after returning from <code>kmain</code>).</p>

<p>Now we can just wrap the <code>Uart.tx</code> function up with a <code>println</code> function and
we’ll have a bare-metal <code>Hello world!</code> in no time.</p>
<p>In <code>object.d</code>:</p>
<div><pre tabindex="0"><code data-lang="d"><span><span><span>import</span> <span>uart</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>printElem</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>
</span></span><span><span>    Uart<span>.</span><span>tx</span><span>(</span>c<span>);</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>printElem</span><span>(</span><span>string</span> s<span>)</span> <span>{</span>
</span></span><span><span>    <span>foreach</span> <span>(</span>c<span>;</span> s<span>)</span> <span>{</span>
</span></span><span><span>        printElem<span>(</span>c<span>);</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>print</span><span>(</span>Args<span>...)(</span>Args args<span>)</span> <span>{</span>
</span></span><span><span>    <span>foreach</span> <span>(</span>arg<span>;</span> args<span>)</span> <span>{</span>
</span></span><span><span>        printElem<span>(</span>arg<span>);</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>println</span><span>(</span>Args<span>...)(</span>Args args<span>)</span> <span>{</span>
</span></span><span><span>    print<span>(</span>args<span>,</span> <span>&#39;\n&#39;</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>And in <code>main.d</code>:</p>
<div><pre tabindex="0"><code data-lang="d"><span><span><span>void</span> <span>kmain</span><span>()</span> <span>{</span>
</span></span><span><span>    println<span>(</span><span>&#34;Hello world!&#34;</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="txt"><span><span>$ make prog.bin
</span></span><span><span>$ qemu-system-riscv64 -nographic -bios none -machine virt -kernel prog.bin
</span></span><span><span>Hello world!
</span></span></code></pre></div><p>There you have it, (simulated) bare-metal hello world!</p>
<p>Some of the initialization we’ve done hasn’t been strictly necessary (we didn’t
end up using any variables in the BSS), but it should set you up properly for
writing more complex bare-metal programs. The next sections discuss some
further steps.</p>

<h2 id="adding-support-for-assertions-and-bounds-checking">Adding support for assertions and bounds-checking</h2>
<p>If you try to use a D assert expression, you might notice that the linking step fails:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>riscv64-unknown-elf-ld: dstart.o: in function `_D6dstart5kmainFZv&#39;:
</span></span><span><span>dstart.d:(.text+0x3c): undefined reference to `__assert&#39;
</span></span></code></pre></div><p>It is looking for an <code>__assert</code><sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup> function, so let’s create one in the <code>object.d</code> file:</p>
<div><pre tabindex="0"><code data-lang="d"><span><span>size_t <span>strlen</span><span>(</span><span>const</span><span>(</span><span>char</span><span>)*</span> s<span>)</span> <span>{</span>
</span></span><span><span>    size_t n<span>;</span>
</span></span><span><span>    <span>for</span> <span>(</span>n <span>=</span> <span>0</span><span>;</span> <span>*</span>s <span>!=</span> <span>&#39;\0&#39;</span><span>;</span> <span>++</span>s<span>)</span> <span>{</span>
</span></span><span><span>        <span>++</span>n<span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>return</span> n<span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>extern <span>(</span>C<span>)</span> noreturn <span>__assert</span><span>(</span><span>const</span><span>(</span><span>char</span><span>)*</span> msg<span>,</span> <span>const</span><span>(</span><span>char</span><span>)*</span> file<span>,</span> <span>int</span> line<span>)</span> <span>{</span>
</span></span><span><span>    <span>// convert a char pointer into a bounded string with the [0 .. length] syntax
</span></span></span><span><span><span></span>    <span>string</span> smsg <span>=</span> <span>cast</span><span>(</span><span>string</span><span>)</span> msg<span>[</span><span>0</span> <span>..</span> strlen<span>(</span>msg<span>)];</span>
</span></span><span><span>    <span>string</span> sfile <span>=</span> <span>cast</span><span>(</span><span>string</span><span>)</span> file<span>[</span><span>0</span> <span>..</span> strlen<span>(</span>file<span>)];</span>
</span></span><span><span>    println<span>(</span><span>&#34;fatal error: &#34;</span><span>,</span> sfile<span>,</span> <span>&#34;: &#34;</span><span>,</span> smsg<span>);</span>
</span></span><span><span>    <span>while</span> <span>(</span><span>1</span><span>)</span> <span>{}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Now you can use <code>assert</code> statements!</p>
<p>D also supports bounds-checking, and internally the compiler will also call
<code>__assert</code> when a bounds check fails. This means we also have working bounds
checks now.</p>
<p>Try this in <code>main.d</code>:</p>
<div><pre tabindex="0"><code data-lang="d"><span><span><span>void</span> <span>kmain</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>char</span><span>[</span><span>10</span><span>]</span> array<span>;</span>
</span></span><span><span>    <span>int</span> x <span>=</span> <span>12</span><span>;</span>
</span></span><span><span>    println<span>(</span>array<span>[</span>x<span>]);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Running it gives</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>fatal error: main.d: array index out of bounds
</span></span></code></pre></div><p>Bounds-checked arrays!</p>
<p>This code doesn’t print the line number because that requires converting an
<code>int</code> to a <code>string</code> – something left as an exercise to the reader.</p>
<h2 id="enabling-linker-relaxation">Enabling linker relaxation</h2>
<p><a href="https://www.sifive.com/blog/all-aboard-part-3-linker-relaxation-in-riscv-toolchain">Linker
relaxation</a>
is an optimization in the RISC-V toolchain that allows globals to be accessed
through the global pointer (stored in the <code>gp</code> register). This value is a
pointer to somewhere in the data section, which allows instructions to load
globals by directly offsetting from <code>gp</code>, instead of constructing the
address of the global from scratch (which may require multiple instructions on
RISC-V).</p>
<p>To enable linker relaxation we have to do three things:</p>
<ol>
<li>Modify the linkerscript so that it defines a symbol for the global pointer.</li>
<li>Load the <code>gp</code> register with this value in the <code>_start</code> function.</li>
<li>Enable linker relaxation in our compiler.</li>
</ol>
<p>To modify the linkerscript we just add the following at the beginning of the
<code>.rodata</code> section definition:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>__global_pointer$ = . + 0x800;
</span></span></code></pre></div><p>This sets up the <code>__global_pointer$</code> symbol (a special symbol that the
linker assumes is stored in <code>gp</code>) to point <code>0x800</code> bytes into the data
segment (RISC-V instructions can load/store values offset up to <code>0x800</code> bytes
from the <code>gp</code> register in either direction in one instruction). This allows
offsets from <code>gp</code> to cover most/all of static data.</p>
<p>Next we add to <code>_start</code>:</p>
<div><pre tabindex="0"><code data-lang="txt"><span><span>.option push
</span></span><span><span>.option norelax
</span></span><span><span>la gp, __global_pointer$
</span></span><span><span>.option pop
</span></span></code></pre></div><p>We need to temporarily enable the <code>norelax</code> option, otherwise the assembler
will optimize this to <code>mv gp, gp</code>.</p>
<p>Finally, we can remove the <code>-mno-relax</code> flag from the <code>riscv64-unknown-elf-as</code>
invocation, and add <code>-mattr=+m,+a,+c,+relax</code> to the <code>ldc2</code> invocation to enable
linker relaxation in the compiler.</p>
<h2 id="removing-unused-functions">Removing unused functions</h2>
<p>If you take a look at the disassembly of the program (<code>make prog.list</code>), you
might notice there are definitions for functions that are never called. This is
because those functions have been inlined, but the definitions were not
removed. Functions/globals in D are always exported in the object file, even if
they are marked <code>private</code> (I’m not really sure why). Luckily modern linkers can
be pretty smart and it’s easy to have the linker remove these unused functions.
Pass <code>--function-sections</code> and <code>--data-sections</code> to LDC to have it put each
function/global in its own section (still within <code>.text</code>, <code>.data</code> etc.). Now if
you pass the <code>--gc-sections</code> flag to the linker, it will remove any
unreferenced sections (hence removing any unused functions/globals). With these
flags I got the final “hello world” binary down to 160 bytes.</p>
<p>This is a basic form of optimization performed by the linker. There are more
advanced forms of link-time optimization (LTO), which I won’t discuss in much
detail. If you pass <code>-flto=thin</code> or <code>-flto=full</code> to LDC, the object files that
it generates will be LLVM bitcode. Then you will need to invoke the linker with
the LLVMgold linker plugin (or use LLD) so that it can read these files. With
this method, the linker will apply full compiler optimizations across object
files.</p>
<!-- ## Why does the Makefile build one object file per source file? -->
<!--  -->
<!-- The Makefile for the project builds one object file per D source file. We could -->
<!-- also pass all the D files to the compiler at once, and generate one object file -->
<!-- from the result. That would probably produce a better-optimized binary (since -->
<!-- we aren't using LTO). However it is not as good for incremental rebuilds, since -->
<!-- we end up recompiling everything from scratch every time. -->
<h2 id="thread-local-storage-and-globals">Thread-local storage and globals</h2>
<p>Globals are thread-local by default in D. That means if you declare a global as
<code>int x;</code> then whenever you access <code>x</code>, the compiler will do so through the
system’s thread pointer (on RISC-V this is stored in the <code>tp</code> register). That
means if you use a thread-local variable, you had better make sure <code>tp</code>
points to a block of memory where <code>x</code> is located, and if you have multiple
threads each thread’s <code>tp</code> should point to a distinct thread-local block (each thread
will have its own private copy of <code>x</code>). I won’t explain in detail how to set that up here,
but briefly, you’ll need to initialize the <code>.tdata</code> and <code>.tbss</code> sections for each thread
in <code>dstart</code>, and load <code>tp</code> with a pointer to the current thread’s local <code>.tdata</code>.</p>
<p>To make a global shared across all threads, you need to mark it as <code>immutable</code>
or <code>shared</code>. A variable marked as <code>shared</code> imposes some limits, and basically
forces you to mark everything it touches as <code>shared</code>. You can still read/write
it without checks, but at least you should be able to easily know if you are
accessing a shared variable (and manually verify you have the appropriate
synchronization). In a future version of D it is likely that directly accessing
a shared variable will be disallowed, except through atomic intrinsics. If you
have a lock to protect the variable, then you will need to cast away the
<code>shared</code> qualifier manually, which isn’t perfect but forces the programmer to
acknowledge the possible unsafety of accessing the shared global. You can
always use the <code>__gshared</code> attribute as an escape hatch, which makes the global
shared but does not make any changes to the type (no limitations). A global
marked as <code>__gshared</code> is equivalent to a C global.</p>

<p>I hope this provided a simple introduction to D for bare-metal programming, and
that you might consider using D instead of C in some future project as a
result.  This post has only covered running in a simulated environment. In a
future post I’ll show how to write bare-metal code for the <a href="https://www.kickstarter.com/projects/starfive/visionfive-2">VisionFive
2</a><sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup>, a recently
released RISC-V SBC produced by StarFive. Stay tuned! (<a href="https://zyedidia.github.io/blog/posts/2-baremetal-visionfive">now
available</a>)</p>
<p>If you want to see a larger example, I am developing an operating system called
<a href="https://github.com/zyedidia/multiplix">Multiplix</a> in D. It has support for
RISC-V and AArch64, and targets the VisionFive, VisionFive 2, Raspberry Pi 3,
and Raspberry Pi 4 (and likely more boards in the future).
Check it out! It is currently heavily in-progress, but I plan to make a post
about it when it is further along.</p>
<p>The code from this post is available in my
<a href="https://github.com/zyedidia/blog-code">blog-code</a> repository.</p>


</div></div>
  </body>
</html>
