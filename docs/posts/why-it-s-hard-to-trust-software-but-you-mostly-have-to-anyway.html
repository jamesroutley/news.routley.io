<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://educatedguesswork.org/posts/ensuring-software-provenance/">Original</a>
    <h1>Why it&#39;s hard to trust software, but you mostly have to anyway</h1>
    
    <div id="readability-page-1" class="page"><div>
          <main>
            
<div>
  <div>
    <article>
        
        

        <p><em>[Edited to change the title and subtitle -- 2024-12-28]</em>.</p>
<figure>
<img src="https://educatedguesswork.org/img/two-kids-under-a-trench-coat.jpeg" width="400"/>
<figcaption>
Two children under a trenchcoat. Image from ChatGPT.
</figcaption>
</figure>
<p>My long-time collaborator <a href="https://datatracker.ietf.org/person/rlb@ipv.sx">Richard
Barnes</a>
used to say
that <em>&#34;in security, trust is a four letter word&#34;</em>, and yet the
dominant experience of using any software-based system—which is,
you know, pretty much anything electronic—is trusting the
manufacturer. Not only is there no meaningful way to <a href="https://educatedguesswork.org/posts/verifying-software">determine what
software</a> is running on a given device
without trusting the device, even when you download the software
yourself, verifying that it&#39;s not malicious is extraordinarily
difficult in practice and mostly you just end up trusting the vendor
anyway.
Obviously, most vendors are honest, but what if they&#39;re not?</p>
<p>A good motivating case here is secure messaging apps like iMessage,
WhatsApp, or Signal. People use these apps because they want to be
able to communicate securely and they are willing to trust them
with really sensitive information. In fact, a large
part of the value proposition of a secure messenger is that not
even the vendor can see your communications. For instance, here&#39;s
what Apple <a href="https://www.apple.com/privacy/features/">has to say about iMessage and FaceTime</a>.</p>
<blockquote>
<p>End-to-end encryption protects your iMessage and FaceTime
conversations across all your devices. With watchOS, iOS, and
iPadOS, your messages are encrypted on your device so they can’t be
accessed without your passcode. iMessage and FaceTime are designed
so that there’s no way for Apple to read your messages when they’re
in transit between devices. You can choose to automatically delete
your messages from your device after 30 days or a year or keep them
on your device indefinitely. Messages sent via satellite also use
end-to-end encryption to protect your privacy.</p>
</blockquote>
<p>This security guarantee critically depends on the app behaving
as advertised, which brings us right back to trusting the vendor.</p>
<p>&#34;But what about open source software?&#34; I hear you say. &#34;I&#39;ll just
review the source code and determine whether it&#39;s malicious&#34;.</p>
<figure>
<p><img src="https://educatedguesswork.org/img/one-does-not-simply-review.jpg" alt="One does not simply review..."/></p>
</figure>
<p>I would make several points in response to this. The first is: &#34;LOL&#34;.
Any nontrivial program consists of hundreds of thousands to millions of
<em>[2024-12-28 -- fixed typo]</em>
lines of code, and reviewing any fraction of that in a reasonable period
of time is simply impractical. The way you can tell this is that people
are constantly finding vulnerabilities in programs, and if it were
straightforward to find those vulnerabilities, then we would have
found them all. You&#39;re certainly not going to review every program
you run yourself, at least not in any way that&#39;s effective.
And that&#39;s just the first step: the supply chain from &#34;source code available&#34; to &#34;I actually trust
this code&#34; is very long and leaky. Even if you did review the source, most software—even open source software—is
actually delivered in binary form (when was the last time you compiled
Firefox for yourself?) so what makes you think the binary you&#39;re getting
was compiled from the source code you reviewed?</p>
<p>Obviously, this is a bad situation if what you&#39;re using software
to do sensitive stuff—which, again, pretty much everyone is—and
there&#39;s been quite a bit of work on the general problem of being able
to give people more confidence in the software they&#39;re running.
It&#39;s far from a solved problem, so what I&#39;d like to do here is give you
a sense of the problem, hard it is, the solution space that&#39;s been explored,
and how far we are from a real solution.</p>
<h2 id="checking-software-provenance">Checking Software Provenance <a href="#checking-software-provenance">#</a></h2>
<p>As a warm-up, let&#39;s look at the problem of verifying downloaded
software (e.g., via your Web browser). This
is a much easier problem because we&#39;re trusting the publisher
not to provide malicious software; we&#39;re just trying to ensure
that the software we got is what the publisher intended.</p>
<h3 id="the-basic-supply-chain">The Basic Supply Chain <a href="#the-basic-supply-chain">#</a></h3>
<p>For reference, here&#39;s an example of a relatively simple software
supply chain with just a single code author.</p>
<figure>
<p><img src="https://educatedguesswork.org/img/SoftwareSupplyChain.png" alt="Example software supply chain"/></p>
<figcaption>
A simple software supply chain
</figcaption>
</figure>
<p>The process starts with the vendors engineers developing the
code. Typically this is done on their desktop (or laptop) machines,
with the engineers collaborating via some code repository site
(usually <a href="https://github.com">GitHub</a>. When engineer A makes
a change to the code, they publish it on GitHub and then engineers
B, C, etc. update their local copy.</p>
<p>When it&#39;s time to build a release, a number of things can happen,
including:</p>
<ol>
<li>Some engineer builds it on their local machine (step 2(a) above)</li>
<li>The engineers tag the release on GitHub, prompting it to build
a release (step 2(b) above).</li>
</ol>
<p>The release then gets uploaded to the vendor&#39;s website, which is
probably hosted on some cloud service like Amazon or Netlify.
You can also host the binaries on GitHub. In principle, users
could just download the binaries directly from your site (or GitHub) but it&#39;s
common to instead use a content distribution network (CDN) like Cloudflare
or Fastly which retrieves a copy of the binary once, caches it, and
then gives out copies to each user. CDNs are designed for massive
scaling, thus saving both load on your servers and cost.</p>
<p>One thing you should notice right away is how many third parties are
involved in this process. Each of these is an opportunity for
corruption of the code on its way from the developers to the
user.</p>
<h3 id="code-signing">Code Signing <a href="#code-signing">#</a></h3>
<p>The obvious &#34;right thing&#34; approach to software authentication
that everyone comes up with is to just digitally sign the package. This provides both
integrity (ensuring things weren&#39;t changed) and data origin
authentication (telling you who the package is from). Moreover,
signed objects are self-contained, so, for instance, you
can sign your package and then put it up for download on
someone else&#39;s site (or, in the diagram above, a CDN) and users will still be able to verify
it&#39;s from you.
These is a pretty good sounding set of properties
and unsurprisingly, both <a href="https://developer.apple.com/developer-id/">MacOS</a>
and <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/install/authenticode">Windows</a>
support signed applications.</p>
<p>The basic idea here is that when you install a piece of software
you get a dialog like this (on Windows):</p>
<figure>
<p><img src="https://educatedguesswork.org/img/code-signing-sectigo.png" alt="With and without code signing"/></p>
<figcaption>
<p>Windows code signing dialog. Image from <a href="https://sectigostore.com/page/microsoft-authenticode-code-signing-certificates/">Sectigo</a>.</p>
</figcaption>
</figure>
<p>Or alternately, maybe you just get warning:</p>
<figure>
<p><img src="https://educatedguesswork.org/img/mac-unsigned-babkin.png" alt="MacOS without code signing"/></p>
<figcaption>
<p>Mac unsigned binary dialog. Image from <a href="https://dennisbabkin.com/blog/?t=how-to-get-certificate-code-sign-notarize-macos-binaries-outside-apple-app-store">Dennis Babkin</a>.</p>
</figcaption>
</figure>
<p>Here&#39;s what Apple&#39;s dialog looks like for a signed binary.</p>
<figure>
<p><img src="https://educatedguesswork.org/img/macos-valid-software.png" alt="MacOS with code signing"/></p>
<figcaption>
<p>Mac signed binary dialog.</p>
</figcaption>
</figure>
<p>The way that Microsoft&#39;s version of code signing (Authenticode) works is
the software author gets a code signing certificate issued by a public
certificate authority. They then use their private key to sign the
binary. Apple&#39;s system is similar, except that instead of using a
public CA you need to be an Apple registered developer (surprise!).
When you download a binary and try to run it the first time, the
operating system checks the signature and then pops up the appropriate
dialog box, telling you who signed the code, or warning you that it&#39;s
unsigned, with the exact details
depending on the operating system version.
Modern versions of MacOS have become increasingly aggressive about
not letting you run unsigned code, but as of this writing, it&#39;s
<a href="https://dennisbabkin.com/blog/?t=how-to-get-certificate-code-sign-notarize-macos-binaries-outside-apple-app-store#run_unsigned">still possible</a>.</p>
<p>Mobile operating systems are even more locked down, where almost
all software is installed from some app store (typically operated
by the vendor).
Historically, Apple has <strong>only</strong> let you install
apps from the iOS app store, whereas on Android you could install
third party apps if you were willing to work a bit. In response to
the EU Digital Markets Act, Apple is allowing <a href="https://developer.apple.com/support/dma-and-apps-in-the-eu/">alternative app
installation inside Europe</a>,
but even then it&#39;s much less convenient, and not available in the
US at all.
Apps installed through the app store are also signed and the
mobile OS automatically verifies the provenance of the app.</p>
<p>The basic problem with code signing systems is that they rely heavily
on user diligence, because the OS only verifies that the code <em>was
signed</em> but doesn&#39;t know who was supposed to sign it. In the simplest
case, consider what happens if you are lured to the attacker&#39;s web
site and persuaded to download an app. As long as the attacker has a
code signing certificate—or is an approved Apple
developer—then they can send you a malicious binary, which will
run fine. In principle users are supposed to check the publisher
name—assuming, that is, that the OS even shows a dialog
box—but we know from long experience that users don&#39;t check this
kind of thing. If it becomes well-known that a given publisher is signing
malicious binaries, the OS vendor might blocklist the publisher, but this
takes time and leaves the vendor constantly chasing bad behavior.
Moreover, &#34;well-known&#34; is doing a lot of work here, as it&#39;s not exactly
unheard of for malicious apps to <a href="https://www.darkreading.com/cyberattacks-data-breaches/malicious-apps-millions-downloads-apple-google-app-stores">make it into various app stores</a>.</p>
<p>If you&#39;re on a mobile operating system, you&#39;ll of course be downloading
programs via the app store. The situation is a little better here
because the app store operates the directory, and so offers
(sort of) unambiguous naming and at least in principle the
app store operator can do something about <a href="https://support.apple.com/guide/adguide/unacceptable-or-prohibited-content-guidelines-apd527d891a8/icloud">copycat software with
confusing
names</a>,
so it&#39;s harder to trick you into installing the wrong package,
though of course you&#39;re trusting the app store vendor to provide
the right package. It&#39;s still signed but the device vendor
controls the signing key authentication system, so they can can impersonate anyone they want.</p>
<p>Whether you are downloading software directly or via an app
store, it&#39;s usually
necessary to download software over a secure transport <em>even if
there is code signing</em>. If you don&#39;t download software using
secure transport then a network attacker can substitute their own
code—signed with their own valid certificate—during the
download process; unless you check the publisher&#39;s identity,
you&#39;ll end up running the attacker&#39;s code.</p>
<p>Of course, if you have to download software over secure transport anyway,
this raises the natural question of why bother to sign the code
at all? Why not <em>just</em> have all downloads happen over secure
transport? One reason is that is that signing allows for third
party hosting. The big technical difference between code signing and transport security
is that the signed object is a self-contained package that can be
distributed by anyone. This is a big asset in any scenario
where the publisher doesn&#39;t want to—or isn&#39;t allowed to—distribute
the software directly.</p>
<h4 id="blocklisting">Blocklisting <a href="#blocklisting">#</a></h4>
<p>Another reason for signing is to make blocklisting easier.
As I mentioned above, if the OS vendor determines that a publisher
is misbehaving, they can revoke permissions for that publisher,
thus preventing software signed with their certificate from being
installed. This is a highly imperfect mechanism for two obvious
reasons:</p>
<ol>
<li>
<p>An attacker can register as a different publisher and continue
to sign as that publisher until they get caught.</p>
</li>
<li>
<p>An attacker can just distribute unsigned software.</p>
</li>
</ol>
<p>Note that you could operate a blocklist where you just listed
malicious software—for instance by publishing a hash—but
that would be much easier to evade, as the attacker could just
change their software until it evaded detection; this is a common
problem with antivirus software. If you require software to be signed
by some key that chains back to some non-free credential, then this
allows you to increase the level of friction to distribute all
software, but especially malicious software.  If you want to register as a different publisher,
you have to establish that identity and then get a certificate, join
the developer program, etc. None of this is free, though we&#39;re probably
talking hundreds of dollars, not thousands,
so it makes it somewhat more expensive to distribute malware.</p>
<p>Of course, the attacker could just distribute unsigned software, but then there&#39;s
some additional friction in the install experience, so you might
not manage to infect quite as many victims.</p>
<h4 id="automatic-updates">Automatic Updates <a href="#automatic-updates">#</a></h4>
<p>A lot of modern software has some sort of self-updating feature.
Unlike the initial install, however, the software updater is
written—or at least distributed—by the publisher, who
knows precisely who should be signing the update, and so signatures
work just fine as a security measure.  Conceptually, this is a similar
to the <a href="https://en.wikipedia.org/w/index.php?title=Trust_on_first_use&amp;oldid=1264102677">trust on first use
(TOFU)</a>
mechanisms used by SSH: as long as you get the right
packager the first time, you&#39;re safe in the future because
the publisher can directly authenticate the code.</p>
<h4 id="package-managers">Package managers <a href="#package-managers">#</a></h4>
<p>In the open source world, it&#39;s common to have a package manager which
lets you install software from the command line. For instance:</p>
<ul>
<li>
<p>Linux and FreeBSD come with a variety of package managers
(<a href="https://ubuntu.com/server/docs/package-management">apt</a>,
<a href="https://www.debian.org/doc/manuals/debian-faq/pkgtools.en.html">dpkg</a>,
etc.). On MacOS it&#39;s possible to install third party software via
<a href="https://brew.sh/">Homebrew</a></p>
</li>
<li>
<p>Many modern  programming languages have some kind of
package manager, such as <a href="https://www.npmjs.com/">npm (JavaScript)</a>,
<a href="https://crates.io/">Cargo/Crates (Rust)</a>, <a href="https://pypi.org/">PyPi
(Python)</a>, etc.</p>
</li>
</ul>
<p>The way these systems typically work is
that people publish their packages onto the package manager site and
people download the packages from there using some local program provided with
the language or the operating system. This obviously makes the
distribution site a <a href="https://www.computerweekly.com/news/366609663/PyPI-loophole-puts-thousands-of-packages-at-risk-of-compromise">single point of
vulnerability</a>,
in at least two ways:</p>
<ul>
<li>
<p>The package author&#39;s account on the package repository might
be compromised (e.g., if they don&#39;t use <a href="https://en.wikipedia.org/w/index.php?title=Multi-factor_authentication&amp;oldid=1249536145">MFA</a>),
and the attacker uploads a malicious version. A huge amount
of the energy in securing open source supply chains has
gone into preventing this kind of attack.</p>
</li>
<li>
<p>The package repository itself is compromised, and the attacker
uses their access to upload a malicious package.</p>
</li>
</ul>
<p>Using secure transport to the package repository is standard
practice, but it doesn&#39;t help against either of these threats
because the problem is the data on the package manager itself
is compromised. In theory it seems like signatures offer a way
out of this: if packages are signed then even if the attacker
compromises the repository they won&#39;t be able to replace the
package with their own.</p>
<p>Unfortunately package signing isn&#39;t a complete solution for the same
kind of identity reasons as before.</p>
<ul>
<li>
<p>Attackers can submit malicious <a href="https://www.sonatype.com/blog/open-source-attacks-on-the-rise-top-8-malicious-packages-found-in-npm">copycat packages</a>
to the package repository with similar names to legitimate
packages. It&#39;s easy to be fooled by this.</p>
</li>
<li>
<p>If the package repository is malicious, then it can point you
to the wrong package. When you first decide to use a package, you probably go to
the package manager site and do some kind of search (e.g.,
&#34;give me a package for task <code>example</code>). If the package manager
site is under the control of the attacker, then they can just tell you to
install package <code>example-attacker</code> (hopefully with a less
obvious name) instead of package <code>example</code>. The package
will be signed, just by the attacker.</p>
</li>
<li>
<p>Even if you know the right package name, a malicious package repository
can still attack you because you don&#39;t know what key should be
signing the packages, so once again you have to worry about identity
substitution. What&#39;s needed here is some way to issue credentials
that are tied unambiguously to the package name. One could imagine
a number of ways to do this, including (1) having the package
manager repo run its own CA or (2) tying package names to domain
names the way Java does (e.g., <code>com.example.package-name</code>
and using the WebPKI, which already attests to domain names.</p>
</li>
</ul>
<p>As with the case of software updating, however, the problem is easier
once a package has been downloaded, because you could store the
package signing key along with the package (e.g., in the
<code>package.json</code>) file, and then generate an alert if packages
aren&#39;t signed with that key (TOFU again).
Better yet, this would also work when <em>other people</em> go to use
your package: if they get your list of keys then all the dependencies
would be protected.</p>
<p>There&#39;s been talk for a long time about signing packages, but
it doesn&#39;t seem to have really gotten off the ground for any
of the major package managers. For example, PyPi used to have
GPG signatures, but it looks like they didn&#39;t work that well
for a variety of <a href="https://blog.pypi.org/posts/2023-05-23-removing-pgp/">operational reasons</a>
and they were recently removed and <a href="https://blog.pypi.org/posts/2024-11-14-pypi-now-supports-digital-attestations/">replaced with &#34;digital attestations&#34;</a> based
on <a href="https://www.sigstore.dev">sigstore</a>, but many popular packages are not signed,
and as far as I can tell there is as yet no <a href="https://blog.trailofbits.com/2024/11/14/attestations-a-new-generation-of-signatures-on-pypi/">automatic verification</a>.
Note that
<a href="https://docs.npmjs.com/about-registry-signatures">npm</a> supports what&#39;s called &#34;registry signatures&#34;
using ECDSA, but the signatures are made by the npm registry
(package manager) using <a href="https://registry.npmjs.org/-/npm/v1/keys">its keys</a>,
so this doesn&#39;t protect you against compromise of the package management system.
The bottom line is that you mostly need to trust the server that
is publishing the packages not to send you malicious packages.</p>
<h2 id="how-not-to-trust-the-publisher-(or-at-least-trust-them-less)">How not to trust the publisher (or at least trust them less) <a href="#how-not-to-trust-the-publisher-(or-at-least-trust-them-less)">#</a></h2>
<p>Of course, this was all warmup for the real problem we want to
solve. Everything up to now was about ensuring that you get the binary
that the publisher wanted to send you. This still leaves you
trusting the publisher, which you shouldn&#39;t, both because it&#39;s
bad security practice to have to trust people and because
there is plenty of evidence of software <a href="https://www.bitdefender.com/en-us/blog/hotforsecurity/facebook-app-for-ios-caught-accessing-camera-in-background">publisher</a>
<a href="https://www.theverge.com/23935029/microsoft-edge-forced-windows-10-google-chrome-fight">misbehavior</a>.</p>
<p>There are two main threats to consider from a malicious vendor:</p>
<ul>
<li>A broad attack where a malicious binary is distributed to everyone.</li>
<li>A targeted attack where a malicious binary is only distributed
to specific people.</li>
</ul>
<p>Over the past 10 years or so, the industry hive mind
has developed a sort of
aspirational three part roadmap for what it would take to actually
provide confidence in binaries without trusting the vendor.</p>
<ol>
<li>Reviewable source code to allow people to verify program
functionality.</li>
<li>Reproducible builds to verify the compilation process.</li>
<li>Binary transparency to ensure that people are getting the
right binary and that everyone is getting the same binary
(thus preventing targeted attack).</li>
</ol>
<p>The relationship between these is shown in the diagram below.</p>
<figure>
<p><img src="https://educatedguesswork.org/img/software-validity.png" alt="Software provenance workflow"/></p>
<figcaption>
Ensuring software provenance
</figcaption>
</figure>
<p>The process starts with the publisher releasing the source code.  As a
practical matter, some kind of review of the source code is a
necessary but not sufficient precondition to being able to have
confidence in a piece of software. Reviewing the
binary is not really practical on any kind of scalable level; it is of
course possible to reverse engineer binaries, but it&#39;s incredibly time
consuming even for experts. The expectation is that if the software
is important enough, then some set of people will scrutinize it,
looking for defects. If this process is working correctly, then it
should be safe for people to download the (reviewed) source code
and compile it themselves.</p>
<p>That&#39;s enough in some cases (e.g., if you&#39;re building a Web app
and you didn&#39;t minify or obfuscate the code), but in most cases, people want to download compiled versions
even when the software itself is open source. But how do you know
that the binary that the vendor is distributing to the user
corresponds to the (presumably) safe source code. The general
idea is that some set of people (the reviewers again?) build
the binary themselves and compare it to the binary that the
vendor is distributing. This is actually harder than it sounds
for two reasons:</p>
<ol>
<li>It&#39;s often not the case that you can compile the same
source code and get the same binary.</li>
<li>Even if the reviewers get the same binary as the vendor,
how do you know that you got the same binary as both of them?</li>
</ol>
<p>The first problem is addressed by having what&#39;s called &#34;reproducible
builds&#34;, which is what it sounds like: making it possible for
two people to get the same binary from the same source. Once
you have reproducible builds, then it should be possible for
third parties to check the compilation process.</p>
<p>The second problem is addressed by a technique called
<a href="https://binary.transparency.dev/">binary transparency</a> (BT).
BT is like <a href="https://educatedguesswork.org/posts/transparency-part-2/">Certificate Transparency (CT)</a>
and involves publishing hashes of each binary generated by the
vendor. For instance, when Mozilla releases Firefox 140, they would
publish hashes for the Mac, Windows, and Linux builds into the
BT log. Users and reviewers could then independently verify that
their copy of the binary (downloaded in the case of the user, built in
the case of the reviewer) were what was in the log, providing assurance
that everyone got the same binary.</p>
<p>When you put all of this together, you get what should be end-to-end
verifiability for the program&#39;s behavior:</p>
<ol>
<li>Independent source code review verifies that the source code is non-malicious.</li>
<li>Reproducible builds allow for comparison between the vendor
compiled binary and independently produced binaries from
the reviewed source code.</li>
<li>Binary transparency allows users to verify that they got
the same binaries that were compiled from the reviewed
source code, and that they are the same as everyone else
got.</li>
</ol>
<p>Let&#39;s look at each of these in more detail.</p>
<h3 id="first%2C-we-publish-the-source">First, we publish the source <a href="#first%2C-we-publish-the-source">#</a></h3>
<p>Even with access to the source code, it&#39;s very difficult to really be
sure what a program does and even hard to exclude the possibility
that it does something malicious.
The basic problem is that software is incredibly complicated
and so just getting to the point where you understand <em>approximately</em>
what it does is very time consuming.</p>
<p>Moreover, the easiest way to read code—at least for me—is
to try to figure out what it&#39;s trying to do, which means just
reading it. Like reading text, this means that you skip over
little details and errors because they interfere with overall
comprehension. It&#39;s much harder to put yourself in the mode
of really studying each piece of the code and making sure you
know exactly what it is <em>actually</em> doing rather than what
you think it should be trying to do and assuming it does that.
However, that&#39;s exactly what you need to do when you review
a piece of code, because defects so often arise when the
programmer wrote something that is superficially sensible
but is actually broken on closer inspection. It&#39;s a similar
task to copy editing, where you have to focus on the details
and deliberately suppress your mind&#39;s natural tendency to
correct any errors and process the big picture. And of course
the more code you have to read the harder the job is.</p>
<blockquote><p lang="en" dir="ltr">10 lines of code = 10 issues.</p>— I Am Devloper (@iamdevloper) <a href="https://twitter.com/iamdevloper/status/397664295875805184?ref_src=twsrc%5Etfw">November 5, 2013</a></blockquote>  
<p>I&#39;m certainly not telling you not to review code, but it&#39;s
important to recognize its limits. To a first order, every line
of code that goes into Chrome and Firefox is reviewed and
the reviewers take their jobs seriously, and yet both browsers
still ship with plenty of undetected vulnerabilities and even
more undetected defects. Humans simply aren&#39;t up to being able
to the task of finding every defect in a piece of software,
especially when it requires reasoning about hundreds of thousands
of lines of code all at once; it&#39;s not even easy to find defects
when you know they&#39;re there and and approximately what the misbehavior
is, as anyone has had to debug a complicated issue can tell you.</p>
<p>Moreover, everything I&#39;ve just said is about the setting
where the original author and the reviewer are on the same
side, with the author trying to write clear, correct code
and the reviewer trying to genuinely understand it. The
problem is of course much harder if the author is trying
to actively deceive the reviewer, which is what we are worried
about here. There used to be something called the
<a href="https://underhanded-c.org/">underhanded C contest</a> where
the idea was to write a program which looked normal and behaved
normally under most conditions but had a defect that could
be triggered with the right input. Some of the programs are
quite clever and it&#39;s easy to believe you would miss errors
during the review phase.</p>
<h4 id="vulnerabilities-vs.-malicious-code">Vulnerabilities vs. Malicious Code <a href="#vulnerabilities-vs.-malicious-code">#</a></h4>
<p>It&#39;s important to recognize that a malicious vendor doesn&#39;t
need to embed all the functionality that they want into the
source code; they just need to introduce a vulnerability that allows
them to exploit the software once it&#39;s compiled, just as attackers
regularly do with unintentional vulnerabilities.  This makes
it much harder to detect malicious code because you can&#39;t
just study the functionality to see if there is something
fishy, you need to find all the defects.</p>
<p>The problem is especially acute in <a href="https://educatedguesswork.org/posts/memory-safety">non-memory safe languages</a>
like C and C++ because (1) it is easy to create defects that
cause memory vulnerabilities and hard to detect them
(2) exploiting those vulnerabilities is
a very well understood problem and (3) memory vulnerabilities
are generally lead to powerful exploits, up to and including
remote code execution, which would allow an attacker to
do anything they wanted on your machine. By contrast, in a language
like Rust or Python, many defects just cause program failure and
you have to work a lot harder to get to remote code execution.</p>
<p>Actually, a malicious vendor doesn&#39;t really have to do anything to
deliberately introduce defects because, as I keep saying,
real software is full of vulnerabilities, which in almost all
cases were introduced by accident. All the vendor has to do is
not fix some of those defects (assuming they discovered
them themselves). Presto, instant malicious software, plus
plausible deniability.</p>
<h4 id="you&#39;re-not-really-going-to-do-this-yourself-are-you%3F">You&#39;re not really going to do this yourself are you? <a href="#you&#39;re-not-really-going-to-do-this-yourself-are-you%3F">#</a></h4>
<p>Even if it were in principle possible to verify that a piece of
software was free of malicious code and vulnerabilities, it would be
at best an incredibly time consuming process. For example, Firefox
consists of tens of millions of lines of code. If you were to review one
line  of code a second, you&#39;d still be looking at something like a
year wall clock time just to review that one program. And this assumes
that you&#39;re expert enough to do that, which almost nobody is. Clearly,
this isn&#39;t something people are going to do for themselves.</p>
<p>This is a piece of the puzzle that doesn&#39;t get talked about that much,
but I think that people have some vague that somehow the open source community
will self-organize to review the entirety of all open source software
in the <a href="https://en.wikipedia.org/w/index.php?title=Linus%27s_law&amp;oldid=1237652268">given enough eyeballs, all bugs are shallow</a>
sense, and if something bad was found, it would be reported and
fixed, and if really obviously bad, there would be some consequences
for the vendor, if only in the form of negative press and people
complaining on Hacker News.</p>
<p>I think you should be suspicious of this in at least two ways.
First, open source software routinely has <a href="https://www.usenix.org/system/files/sec22-alexopoulos.pdf">quite old vulnerabilities</a>,
so clearly whatever we have now is not effectively fulfilling this function.
Second, it&#39;s not clear to me what such a structure would look like:
would someone parcel out the pieces of code for others to look at?
Would we have a registry of what had been reviewed? How would you know that
reviewers weren&#39;t malicious? Who would pay for all this reviewer time?
I suppose it&#39;s possible we could build some mechanism for the highest
profile software, though in practice my experience is that that&#39;s precisely the
code that everyone just assumes is nonmalicious.
In a number of cases vendors have contracted
for some published third party audit (e.g., <a href="https://blog.trailofbits.com/2022/12/22/curl-security-audit-threat-model/">cURL</a>,
<a href="https://blog.trailofbits.com/2024/07/30/our-audit-of-homebrew/">Homebrew</a>,
<a href="https://blog.mozilla.org/security/2023/12/06/mozilla-vpn-security-audit-2023/">Mozilla VPN</a>,
etc.), and there has been some progress on
<a href="https://mozilla.github.io/cargo-vet/">crowdsourcing review of Rust crates</a>,
but I don&#39;t think anyone really thinks audits capture every
vulnerability so much as providing an overall assessment of code
quality, and in my experience auditors don&#39;t usually go into the
engagement assuming that the vendor is malicious.</p>
<h3 id="verifying-the-build">Verifying the Build <a href="#verifying-the-build">#</a></h3>
<p>OK, so you&#39;ve convinced yourself that the source code is non-malicious,
but in most cases you don&#39;t run the source code but rather the compiled
binary, and you usually don&#39;t compile it yourself but rather download it from
the vendor, even for open source software. There are a number of reasons
for this, but for starters, compiling even a modestly large package
can take a long time, and that&#39;s not even to mention installing all
the prerequisites (do you even have a compiler installed?).
There certainly are systems where people have to install everything
from source (<a href="https://www.gentoo.org/">Gentoo Linux</a>, I&#39;m looking at you),
but it&#39;s not exactly the most convenient thing; there&#39;s a reason why
even systems like <a href="https://brew.sh/">Homebrew</a> which start with
other people&#39;s source code provide binaries.</p>
<p>However, if you&#39;re installing the binary, how do you know that the vendor
has actually compiled it from the source code you looked at rather
than from some other malicious source? The obvious thing to do is to
just download the source code and compile it yourself. This is actually a lot harder than it
looks because two independent compilations of the same source code
often do not produce the same binary. This may be somewhat surprising,
as compilation feels like a mechanical process, but there are actually
a number of important sources of variation, including:</p>
<ul>
<li>You may not have exactly the same toolchain (libraries, compiler,
etc.) as the publisher used.
<ul>
<li>If you have two different versions of
some dependency and that is included in the final binary, the
result will obviously be different.</li>
<li>The compiler has a lot of discretion in how to compile a given piece
of source code, and even different versions of the same compiler
might behave differently (e.g., using different optimizations).</li>
</ul>
</li>
<li>Binaries often include timestamps, which will obviously be different
each time you compile.</li>
<li>Some build chains are inherently non-deterministic. For instance,
Firefox builds uses a technique called <a href="https://en.wikipedia.org/w/index.php?title=Profile-guided_optimization&amp;oldid=1250741304">profile-guided
optimization</a> in which you run the program under instrumentation and
use the results to inform the optimization process. Because
profiling is sensitive to the underlying state of the computer,
you can have small instabilities in the results which produce
different outcomes.</li>
</ul>
<p>This isn&#39;t to say that it&#39;s impossible to have builds be exactly the
same each time (this is called <a href="https://en.wikipedia.org/w/index.php?title=Reproducible_builds&amp;oldid=1254961378">reproducible builds</a>, and there is a known set
of <a href="https://reproducible-builds.org/docs/">techniques</a> for making them
work) but it&#39;s a nontrivial task to make a given build reproducible,
and if the publisher hasn&#39;t done it for their system—including
providing reproduction information—then you&#39;re pretty much out
of luck. However, if the publisher <em>has</em> enabled reproducible builds,
then it should be reasonably practical to independently verify a
given binary.</p>
<div>
<h4 id="a-non-reproducible-build">A non-reproducible build <a href="#a-non-reproducible-build">#</a></h4>
<p>Back when I was at Mozilla, one thing I worked on was the
the <a href="https://wiki.mozilla.org/NSS">NSS security library</a> in Firefox. NSS
dated back to the original origins of Firefox back at <a href="https://en.wikipedia.org/w/index.php?title=Netscape&amp;oldid=1261674314">Netscape</a> and had some unusual
and very old feeling formatting choices. The team decided to adopt
the Google C style guide, in part because you could use an automated
formatter to mass reformat all the code. Naturally we were a little
worried about introducing defects, so we decided to compare the output
binaries pre- and post-format. NSS compilation was pretty simple
and so we expected this to just work, but surprisingly the results
didn&#39;t match.</p>
<p>After a fair bit of head scratching, one of the engineers discovered
the issue: we had a few locations in the code that used the C <code>__LINE__</code>
preprocessor macro, which is translated to the current line of source code,
and embedded the result in a a string. When we had reformatted the
code, it had changed what line this use of the macro appeared,
leading to a difference.</p>
</div>
<h3 id="binary-transparency">Binary Transparency <a href="#binary-transparency">#</a></h3>
<p>If the publisher has made builds reproducible, then, then in principle
you should be able to compile the code yourself and compare the binary
you get to the one on the publisher&#39;s Web site, but then why did you
bother to download the binary at all? Just as with
reviewing the source code, maybe somebody <em>else</em> that you trust could
do this and report back if there was a mismatch. This is where
binary transparency (BT) comes in.</p>
<p>BT is like <a href="https://educatedguesswork.org/posts/transparency-part-2/">Certificate Transparency
(CT)</a> but instead of publishing every
certificate, the publisher instead publishes a hash of every binary
they release. The idea here is that there should be only a small
number of canonical binaries for every version (say one for each
platform/language combination). When you went to install a piece of
software you would verify that it appeared in the BT log and that
there weren&#39;t an unreasonable number of entries in the log (ideally
there would be exactly one for every configuration). This doesn&#39;t
verify that the binary is non-malicious but just that you&#39;re getting
the same binary as everyone else.</p>
<p>Our hypothetical auditors would independently build
copies of the binary and verify that they matches whatever was
in the log. If there was a mismatch, they would (somehow) report
the issue and hopefully it would get enough PR that the publisher
would be required to explain the issue; if they didn&#39;t have an
innocuous explanation (e.g., an alternate way of compiling to
that binary) then this is evidence that something is wrong.
Note that this system relies crucially on some assumptions about
the behavior of third parties, namely that:</p>
<ol>
<li>Someone is actually doing their own builds and checking the
logs.</li>
<li>Reporting of log mismatches gets enough attention that there
will be consequences for the publisher.</li>
</ol>
<p>This seems like something that will work a lot better for big
vendors; if Chrome
builds can&#39;t be matched to something in the
BT log, this is a much bigger issue than some package with 20
users.</p>
<p>Even without open source and reproducible builds, BT still provides
<em>some</em> value in that it makes it harder for the vendor to supply
individualized malicious builds to a small number of people; if you
get a unique build you should perhaps worry that you have been targeted.
Of course in this case we&#39;re depending even more heavily on the
BT logs being audited because the signature of this attack
is just an unusual number of versions in the log, and it&#39;s not
at all uncommon to have a lot of software versions floating
around for various reasons (alpha/beta releases, A/B testing,
development builds, localization, etc.)</p>
<div>
<h4 id="smuggling-binary-transparency-into-certificate-transparency">Smuggling Binary Transparency into Certificate Transparency <a href="#smuggling-binary-transparency-into-certificate-transparency">#</a></h4>
<p>When I was at Mozilla, we spent some time trying to
<a href="https://wiki.mozilla.org/Security/Binary_Transparency">figure out how to deploy Binary Transparency</a>. At the time there weren&#39;t any BT
logs at all, so one of us (I think it was either Richard Barnes or I)
came up with the idea of publishing the binary hashes in
the CT log by minting new domain names of the form
<code>&lt;hash&gt;.&lt;firefox-version&gt;.fx-trans.net</code>, getting certificates for that
name, and then using the CT log to provide transparency.</p>
</div>
<p>At present we&#39;re seeing modest levels of binary transparency. In
particular, Google has deployed it for Android <a href="https://developers.google.com/android/binary_transparency/overview">firmware and
APKs</a>,
using Google-provided logs.  The <a href="https://www.sigstore.dev/">sigstore</a>
project provides generic tooling for binary signing, reproducible
builds, and binary transparency and seems to be getting some
uptake. However, we&#39;re not seeing the kind of large-scale deployment
that we have for certificate transparency, and there don&#39;t seem to be
any generic logs in wide use like there are with CT.
Facebook has also deployed a system called <a href="https://www.facebook.com/help/messenger-app/799550494558955">Code Verify</a>
to provide a form of binary transparency for Facebook Messenger.
See <a href="#the-web">below</a> for more on this.</p>
<h3 id="what&#39;s-your-trusted-computing-base%3F">What&#39;s your Trusted Computing Base? <a href="#what&#39;s-your-trusted-computing-base%3F">#</a></h3>
<p>If you&#39;ve been paying attention you may have noticed that this
all requires a fair amount of computation on the user&#39;s computer.
After they&#39;ve downloaded the binary, they need to compute
its hash and verify that it&#39;s been published in the BT log;
obviously you&#39;re not going to do this by hand unless you have
a lot of time.
All of this requires some kind of software on the user&#39;s computer,
and it needs to be software you trust.</p>
<p>Ideally, of course, we&#39;d have some sort of generic system that
handled all of this, but that&#39;s not generically the case on a desktop operating
system, so we&#39;re mostly back to the problem at the very
beginning of identifying which software package the user is trying
to download; it&#39;s not
just that the binary is <em>somewhere</em> on the BT log; it needs to be
associated with the right name, which is to say <code>firefox</code> and not
<code>firef0x</code>, but the vendor knows</p>
<h4 id="updaters">Updaters <a href="#updaters">#</a></h4>
<p>Once you <em>have</em> downloaded the right software,
then the publisher can incorporate BT checking into the
software updater as it&#39;s already
custom software so you don&#39;t need to worry about having a generic BT
log (because there really isn&#39;t one).  Moreover, this solves the
problem of knowing what binary to look for in the BT log, because
the vendor knows the name of their own software.</p>
<p>Of course, now we&#39;ve just shifted the problem from having to trust
the software provider to provide you a nonmalicious binary to having
to trust the software provider to send you a nonmalicious updater,
so things haven&#39;t necessarily improved that much. However, it is
better in one specific way: it protects you from the publisher
starting out nonmalicious and then becoming malicious. That&#39;s a real
problem, for instance if the attacker <a href="https://www.helpnetsecurity.com/2024/04/16/open-source-project-takeover/">takes over a legitimate package</a> or if they decide to attack
you personally for some reason.</p>
<h4 id="app-stores">App Stores <a href="#app-stores">#</a></h4>
<p>By contrast, mobile operating systems <em>do</em> have a generic initial software
installation mechanism, which is to say the app store.
App stores also come with automatic updating, and because the app
store operator rather than the publisher is responsible for the
update, it&#39;s much harder for the publisher to provide target-specific
malicious code, though of course they can provide a malicious build to
everyone. This provides some guarantee that everyone is getting the
same binary even without binary transparency, because the publisher
can&#39;t supply multiple binaries.</p>
<p>Of course, as noted above, you have to trust the platform vendor
who operates the app store not to themselves send you a malicious
binary, but in most cases you&#39;re trusting them anyway because they
provided the operating system, the installer, and any mechanism you
have to view the binary. This is obvious on iOS, which is a completely
closed system, but even on Android, <a href="https://educatedguesswork.org/posts/verifying-software">all of your interactions with the
system are intermediated by hardware and firmware provided by the
device vendor</a>, so you&#39;re reduced to trusting Google and the phone
manufacturer anyway.  I&#39;m not
saying this is good, just that it&#39;s the way it is.</p>
<p>Note that it doesn&#39;t really help that much if the platform vendor
actually did binary transparency, because it&#39;s their software that
does the checking and you don&#39;t have a good way of checking that
software. So while I think it&#39;s good that Google is trying to
prime the pump some with Android binary transparency, I&#39;m skeptical
that it provides significant benefit to the user.</p>
<p>On the other hand, if you <em>do</em> trust the platform vendor, then
the app store model can provide a significant amount of additional
security even in the absence of the app store enforcing strict
policies on the binaries, just because the app store insulates
you from the publisher. Moreover, if the vendor requires reproducible
builds, then any source code review that they do—or if
the program is open source, that others do—can be connected
to the resulting binary. For example, <a href="https://extensionworkshop.com/documentation/publish/source-code-submission/">Firefox add-ons can be
submitted in two ways</a>:</p>
<ul>
<li>In source code form directly (add-ons are written in JavaScript,
so you don&#39;t need to compile prior delivery).</li>
<li>In a pre-packaged form, but with a complete copy of the source
code sufficient to build the packaged version (and even then,
<a href="https://extensionworkshop.com/documentation/publish/source-code-submission/#use-of-obfuscated-code">obfuscation is forbidden</a>).</li>
</ul>
<p>Mozilla does some source code review, and this system ensures that
whatever ships is what was reviewed, though of course you&#39;re
reliant on the quality of Mozilla&#39;s review, which is somewhat
variable. If the add-on isn&#39;t open source
(which isn&#39;t required by Mozilla&#39;s policies) this is all you get, but
if it is open source (or just delivered as source), then anyone can in
principle do this kind of review for themselves.</p>
<h4 id="the-web">The Web <a href="#the-web">#</a></h4>
<p>We&#39;re well over 7000 words already, but I do just want to briefly touch
on the topic of the Web. The Web has a number of properties that
do make the problem somewhat easier:</p>
<ul>
<li>Web programs execute in the browser, which serves as the trusted
computing base.</li>
<li>There&#39;s a clear way to identify the &#34;program&#34; the user is trying
to run, which is to say the <a href="https://educatedguesswork.org/posts/web-security-model-origin">origin</a>.</li>
<li>Web applications are (mostly) not compiled but rather HTML and
JavaScript, which are (again mostly) readable, which might
make the problem of reproducibility easier.</li>
</ul>
<p>However, it also has several important properties that make the problem
much harder:</p>
<ul>
<li>The Web application is individually downloaded directly from the
publisher by each user, often after they have been authenticated,
making it very easy to mount a targeted attack.</li>
<li>It&#39;s very common to send each user a slightly different Web page,
for instance if there is personalized content, which makes the
question of whether it&#39;s the same program very difficult.</li>
<li>Authors of Web applications often change the application very
frequently, either deploying as soon as changes are made
(&#34;continuous deployment&#34;) or for experimentation purposes
(A/B testing), which means there are a lot of different
versions floating around even without personalization.</li>
<li>Web pages often consist of a lot of pieces of JavaScript from
various servers (e.g., all the ads that are displayed on the
page). This JavaScript is part of the application and so has
to be validated somehow, but in many cases it&#39;s not even
meaningfully under the control of the Web site.</li>
</ul>
<p>Probably the most serious attempt to provide binary transparency for
Web applications, is Facebook&#39;s <a href="https://www.facebook.com/help/messenger-app/799550494558955">Code
Verify</a>)
system, provided in <a href="https://blog.cloudflare.com/cloudflare-verifies-code-whatsapp-web-serves-users/">collaboration with
Cloudflare</a>.
Code Verify works by the user installing a <a href="https://chromewebstore.google.com/detail/code-verify/llohflklppcaghdpehpbklhlfebooeog?hl=en">browser
extension</a>
which checks that code running on WhatsApp, Facebook, Instagram, and Messenger
matches the source of truth known to Cloudflare. This is a good start
but it&#39;s also fairly far away from being globally usable.</p>
<h2 id="the-bigger-picture">The Bigger Picture <a href="#the-bigger-picture">#</a></h2>
<p>As should be clear at this point, the situation is fairly dire:
if you&#39;re running software written by someone else—which
basically everyone is—you have to trust a number of different
actors. We do have some technologies which have the potential to
reduce the amount you have to trust them, but we don&#39;t really
have any plausible venue to reduce things down to the level where
there aren&#39;t a number of single points of trust.
This doesn&#39;t mean we should succumb to security nihilism: there&#39;s
still plenty of room for improvement and we know how to make
some of those improvements. However, this isn&#39;t a problem that&#39;s
going to get solved any time soon. Open source, audits, reproducible builds, and
binary transparency are all good, but they don&#39;t eliminate the
need to trust whoever is providing your software and you
should be suspicious of anyone telling you otherwise.</p>



    </article>

    
      
  </div>
  
</div>

<!-- Cloudflare Web Analytics --><!-- End Cloudflare Web Analytics -->


          </main>
        </div></div>
  </body>
</html>
