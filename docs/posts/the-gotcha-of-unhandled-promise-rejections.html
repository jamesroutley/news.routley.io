<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakearchibald.com/2023/unhandled-rejections/">Original</a>
    <h1>The gotcha of unhandled promise rejections</h1>
    
    <div id="readability-page-1" class="page"><div><p>Let&#39;s say you wanted to display a bunch of chapters on the page, and for whatever reason, the API only gives you a chapter at a time. You could do this:</p>
<div><pre><code><span>async</span> <span>function</span> <span>showChapters</span><span>(</span><span>chapterURLs</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>const</span> url <span>of</span> chapterURLs<span>)</span> <span>{</span>
    <span>const</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span>url<span>)</span><span>;</span>
    <span>const</span> chapterData <span>=</span> <span>await</span> response<span>.</span><span>json</span><span>(</span><span>)</span><span>;</span>
    <span>appendChapter</span><span>(</span>chapterData<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre></div><p>This gives the correct result – all the chapters appear in the right order. But, it&#39;s kinda slow, because it waits for each chapter to finish fetching before it tries to fetch the next one.</p>
<p>Alternatively, you could do the fetches in parallel:</p>
<div><pre><code><span>async</span> <span>function</span> <span>showChapters</span><span>(</span><span>chapterURLs</span><span>)</span> <span>{</span>
  <span>const</span> chapterPromises <span>=</span> chapterURLs<span>.</span><span>map</span><span>(</span><span>async</span> <span>(</span><span>url</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span>url<span>)</span><span>;</span>
    <span>return</span> response<span>.</span><span>json</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>const</span> chapters <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span>chapterPromises<span>)</span><span>;</span>

  <span>for</span> <span>(</span><span>const</span> chapterData <span>of</span> chapters<span>)</span> <span>appendChapter</span><span>(</span>chapterData<span>)</span><span>;</span>
<span>}</span></code></pre></div><p>Great! Except, you&#39;re now waiting on the last chapter before showing the first.</p>
<p>For the best performance, do the fetches in parallel, but handle them in sequence:</p>
<div><pre><code><span>async</span> <span>function</span> <span>showChapters</span><span>(</span><span>chapterURLs</span><span>)</span> <span>{</span>
  <span>const</span> chapterPromises <span>=</span> chapterURLs<span>.</span><span>map</span><span>(</span><span>async</span> <span>(</span><span>url</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span>url<span>)</span><span>;</span>
    <span>return</span> response<span>.</span><span>json</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>for</span> <span>await</span> <span>(</span><span>const</span> chapterData <span>of</span> chapterPromises<span>)</span> <span>{</span>
    <span>appendChapter</span><span>(</span>chapterData<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre></div><p>However, this has introduced a tricky bug involving unhandled promise rejections.</p>
<h2 id="unhandled-promise-rejections"><a href="#unhandled-promise-rejections">Unhandled promise rejections</a></h2>
<p>Unhandled promise rejections happen when a promise… is rejected… but isn&#39;t handled.</p>
<p>Ok ok, they&#39;re like the promise equivalent of an uncaught error. Like this:</p>
<div><pre><code><span>const</span> promise <span>=</span> Promise<span>.</span><span>reject</span><span>(</span><span>Error</span><span>(</span><span>&#39;BAD&#39;</span><span>)</span><span>)</span><span>;</span></code></pre></div><p>The rejected state of this promise is &#39;unhandled&#39; because nothing is dealing with the rejection.</p>
<p>Here are a few ways it could be handled:</p>
<div><pre><code>
<span>try</span> <span>{</span>
  <span>await</span> promise<span>;</span>
<span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
  
<span>}</span>


promise<span>.</span><span>catch</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
<span>}</span><span>)</span><span>;</span>


<span>await</span> promise<span>;</span>




promise<span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
<span>}</span><span>)</span><span>;</span>


</code></pre></div><p>A promise is handled when something is done in reaction to that promise, even if it&#39;s creating another rejected promise, or turning a rejected promise into a throw.</p>
<p>Once a promise is rejected, you have until just-after the next processing of microtasks to handle that rejection, else it may count as an unhandled rejection (&#39;may&#39;, because there&#39;s a little bit of wiggle room with task queuing).</p>
<div><pre><code><span>const</span> promise <span>=</span> Promise<span>.</span><span>reject</span><span>(</span><span>Error</span><span>(</span><span>&#39;BAD&#39;</span><span>)</span><span>)</span><span>;</span>




<span>queueMicrotask</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
<span>}</span><span>)</span><span>;</span>

<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
<span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span></code></pre></div><h3 id="unhandled-rejections-are-problematic"><a href="#unhandled-rejections-are-problematic">Unhandled rejections are problematic</a></h3>
<p>Unhandled rejections are a bit like uncaught errors, in that they cause the entire program to exit with an error code in Node and Deno.</p>
<p>In browsers, you get errors appearing in the console, again similar to uncaught errors:</p>
<figure>
<picture>
  <source type="image/avif" srcset="/c/console-72b15aa1.avif"/>
  <img src="https://jakearchibald.com/c/console-88bec2e0.png" width="1598" height="288" alt="In the console: Uncaught (in promise) TypeError: Failed to fetch"/>
</picture>
</figure>

<p>They might also appear in error logging systems, if the system listens for unhandled rejections:</p>
<div><pre><code><span>addEventListener</span><span>(</span><span>&#39;unhandledrejection&#39;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
<span>}</span><span>)</span><span>;</span></code></pre></div><p>The point is, you want to avoid unhandled rejections.</p>
<h2 id="but-where-are-the-unhandled-rejections-in-the-example"><a href="#but-where-are-the-unhandled-rejections-in-the-example">But where are the unhandled rejections in the example?</a></h2>
<p>It&#39;s not immediately obvious:</p>
<div><pre><code><span>async</span> <span>function</span> <span>showChapters</span><span>(</span><span>chapterURLs</span><span>)</span> <span>{</span>
  <span>const</span> chapterPromises <span>=</span> chapterURLs<span>.</span><span>map</span><span>(</span><span>async</span> <span>(</span><span>url</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span>url<span>)</span><span>;</span>
    <span>return</span> response<span>.</span><span>json</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>for</span> <span>await</span> <span>(</span><span>const</span> chapterData <span>of</span> chapterPromises<span>)</span> <span>{</span>
    <span>appendChapter</span><span>(</span>chapterData<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre></div><p>The promises in <code>chapterPromises</code> are handled by the <code>for await</code> in each iteration of the loop. When the loop encounters a rejected promise, it becomes a throw, which abandons the function and rejects the promise <code>showChapters</code> returned.</p>
<p>The bug happens if a promise rejects before the <code>for await</code> handles that promise, or if that promise is never reached.</p>
<p>For example: If <code>chapterPromises[0]</code> takes a long time to resolve, and meanwhile <code>chapterPromises[1]</code> rejects, then <code>chapterPromises[1]</code> is an unhandled rejection, because the loop hasn&#39;t reached it yet.</p>
<p>Or: If <code>chapterPromises[0]</code> <em>and</em> <code>chapterPromises[1]</code> reject, then <code>chapterPromises[1]</code> is an unhandled rejection, because the loop is abandoned before it gets to <code>chapterPromises[1]</code>.</p>
<p>Ugh. The &#34;unhandled promise rejection&#34; feature is there so you don&#39;t &#39;miss&#39; rejected promises, but in this case it&#39;s a false positive, because the promise returned by <code>showChapters</code> already sufficiently captures the success/failure of the operation.</p>
<p>This issue doesn&#39;t always involve fetches, it could be any bit of work you start early, then pick up the result later. Like a worker task.</p>
<p>This doesn&#39;t always involve <code>for await</code> either. It impacts any situation where you start the work early, then handle the result later, asynchronously.</p>
<p>It <em>wasn&#39;t</em> an issue for the <code>Promise.all</code> example:</p>
<div><pre><code><span>async</span> <span>function</span> <span>showChapters</span><span>(</span><span>chapterURLs</span><span>)</span> <span>{</span>
  <span>const</span> chapterPromises <span>=</span> chapterURLs<span>.</span><span>map</span><span>(</span><span>async</span> <span>(</span><span>url</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span>url<span>)</span><span>;</span>
    <span>return</span> response<span>.</span><span>json</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>const</span> chapters <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span>chapterPromises<span>)</span><span>;</span>

  <span>for</span> <span>(</span><span>const</span> chapterData <span>of</span> chapters<span>)</span> <span>appendChapter</span><span>(</span>chapterData<span>)</span><span>;</span>
<span>}</span></code></pre></div><p>In this case all the promises in <code>chapterPromises</code> are handled immediately, by <code>Promise.all</code>, which returns a single promise that&#39;s immediately handled by the <code>await</code>. But this solution has worse performance than our sequential solution.</p>
<h2 id="whats-the-real-solution"><a href="#whats-the-real-solution">What&#39;s the real solution?</a></h2>
<p>Unfortunately it&#39;s a bit of a hack. The solution is to immediately mark the promises as handled, before they have a chance to become unhandled rejections.</p>
<div><pre><code><span>async</span> <span>function</span> <span>showChapters</span><span>(</span><span>chapterURLs</span><span>)</span> <span>{</span>
  <span>const</span> chapterPromises <span>=</span> chapterURLs<span>.</span><span>map</span><span>(</span><span>async</span> <span>(</span><span>url</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span>url<span>)</span><span>;</span>
    <span>return</span> response<span>.</span><span>json</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  

  <span>for</span> <span>await</span> <span>(</span><span>const</span> chapterData <span>of</span> chapterPromises<span>)</span> <span>{</span>
    <span>appendChapter</span><span>(</span>chapterData<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre></div><p>One way to do this is to add a dummy <code>catch</code> handler to each promise:</p>
<div><pre><code><span>for</span> <span>(</span><span>const</span> promise <span>of</span> chapterPromises<span>)</span> promise<span>.</span><span>catch</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><span>}</span><span>)</span><span>;</span></code></pre></div><p>This doesn&#39;t change the promises other than marking them as &#39;handled&#39;. They&#39;re still rejected promises. It doesn&#39;t cause errors to be missed/swallowed elsewhere.</p>
<p>A shorter way to achieve the same thing is <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"><code>Promise.allSettled</code></a>:</p>
<div><pre><code>Promise<span>.</span><span>allSettled</span><span>(</span>chapterPromises<span>)</span><span>;</span></code></pre></div><p>This works because <code>allSettled</code> handles all the promises you give it, similar to <code>Promise.all</code>, but unlike <code>Promise.all</code> it never returns a rejected promise itself (unless something is fundamentally wrong with the input iterator).</p>
<p>Both of these look pretty hacky, and likely to confuse others that read the code later. Because of this, I&#39;d probably create a helper function like <code>preventUnhandledRejections</code>:</p>
<div><pre><code>
<span>export</span> <span>function</span> <span>preventUnhandledRejections</span><span>(</span><span><span>...</span>promises</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>const</span> promise <span>of</span> promises<span>)</span> promise<span>.</span><span>catch</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><span>}</span><span>)</span><span>;</span>
<span>}</span></code></pre></div><p>And comment its usage:</p>
<div><pre><code><span>import</span> <span>{</span> preventUnhandledRejections <span>}</span> <span>from</span> <span>&#39;./promise-utils.js&#39;</span><span>;</span>

<span>async</span> <span>function</span> <span>showChapters</span><span>(</span><span>chapterURLs</span><span>)</span> <span>{</span>
  <span>const</span> chapterPromises <span>=</span> chapterURLs<span>.</span><span>map</span><span>(</span><span>async</span> <span>(</span><span>url</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span>url<span>)</span><span>;</span>
    <span>return</span> response<span>.</span><span>json</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  
  
  <span>preventUnhandledRejections</span><span>(</span><span>...</span>chapterPromises<span>)</span><span>;</span>

  <span>for</span> <span>await</span> <span>(</span><span>const</span> chapterData <span>of</span> chapterPromises<span>)</span> <span>{</span>
    <span>appendChapter</span><span>(</span>chapterData<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre></div><p>I wish there was a less &#39;blunt&#39; way of handling this in JavaScript, but I&#39;m not sure what that would look like. The design of the &#34;unhandled rejections&#34; feature directly clashes with starting work early and handling the result later, or not handling the result if a prerequisite fails.</p>
<p>In the meantime, <code>preventUnhandledRejections</code> does the trick!</p>
<p><small>For completeness, here&#39;s an <a href="https://gist.github.com/jakearchibald/8bc2360a6d3f6240d1bad2de375fa92a">abortable implementation of <code>showChapters</code></a>, that also handles bad responses.</small></p>
<p><small>Thanks to <a href="https://twitter.com/DasSurma">Surma</a> and <a href="https://twitter.com/tomayac">Thomas Steiner</a> for proof-reading.</small></p>
</div></div>
  </body>
</html>
