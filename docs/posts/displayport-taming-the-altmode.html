<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hackaday.com/2023/08/03/displayport-taming-the-altmode/">Original</a>
    <h1>DisplayPort: Taming the Altmode</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
        <p>The DisplayPort altmode is semi-proprietary, but it can absolutely be picked apart if we try. Last time, <a href="https://hackaday.com/2023/07/24/displayport-tapping-the-altmode/">we found a cool appnote describing the DisplayPort altmode in detail, switched the FUSB302 into packet sniffing mode and got packet captures, learned about PD VDMs (vendor-defined messages), and successfully replayed the captured messages to switch a USB-C port into the DisplayPort altmode</a>. Today, we will go through the seven messages that summon the DisplayPort altmode, implement them, and tie them all into a library – then, figure out the hardware we need to have DisplayPort work in the wild.</p>
<p><a href="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_8.png" target="_blank"><img data-attachment-id="602592" data-permalink="https://hackaday.com/2023/08/03/displayport-taming-the-altmode/hadimg_re_dp_altmode_8/" data-orig-file="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_8.png" data-orig-size="987,911" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="hadimg_re_dp_altmode_8" data-image-description="" data-image-caption="" data-medium-file="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_8.png?w=400" data-large-file="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_8.png?w=677" decoding="async" loading="lazy" src="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_8.png?w=250" alt="" width="250" height="231" srcset="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_8.png 987w, https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_8.png?resize=250,231 250w, https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_8.png?resize=400,369 400w, https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_8.png?resize=677,625 677w" sizes="(max-width: 250px) 100vw, 250px"/></a>For a start, as you might have seen from the diagram, a single command can be either a request or a response. For instance, if you get a <code>Discover Identity</code> <code>REQ</code> (request), you reply to it with a <code>Discover Identity</code> <code>ACK</code> (response), adding your identity data to your response along the way. With some commands, the DP source will add some data for you to use; for most commands, your DP sink will have to provide information instead – and we’ll do just that, armed with the PDF provided and the packet captures.</p>
<p>We have seven commands we need to handle in order to get DisplayPort out of a compatible USB-C port – if you need a refresher on these commands, page 13 of the ST’s PDF on the DP altmode will show you the message sequence. These commands are: <code>Discover Identity</code>, <code>Discover SVIDs</code>, <code>Discover Modes</code>, <code>Enter Mode</code>, <code>DP Status Update</code>, <code>DP Configure</code>, and <code>Attention</code>. Out of these, the first four are already partially described in the base USB PD standard, the two DP commands afterwards are DisplayPort-altmode-specific but sufficiently described in the PDF we have, and the <code>Attention</code> command is from the base standard as well, mostly helpful for reporting state of the HPD pin. Let’s start with the first two!<span id="more-602486"></span></p>
<h2>The Discovery Process</h2>
<p>The first two commands are not DisplayPort-specific at all. In particular, the <code>Discover Identity</code> message is omnipresent. Just like with the <code>Source_Capabilities</code> message that we didn’t even have to request from the PSU, if you plug into a USB-C port of a laptop capable of DP or even Thunderbolt, you will receive a <code>Discover Identity</code> command message. If your device is capable of handling any altmode, replying to this message is how you announce this capability.</p>
<p>Your <code>Discover Identity</code> response will have to contain a bunch of data about your device – most of this data, you can outright fake. This data says that you’re an alternate mode adapter, there’s two bits denoting whether you’re capable of USB host or USB device operation, a “certification” field that can be left completely empty, as well as USB VID and PID. To my knowledge, the VID and PID aren’t used for anything feature-wise, unlike regular USB connection PID and VID, which we know to be used for driver selection in operating systems. The adapter that I have has vendor ID <code>0xBDA</code>, product ID <code>0x2172</code> and bcdDevice number <code>0x201.</code> These values are sent once, and don’t show up in any further USB-C communications whatsoever.</p>
<p>The second command is <code>Discover SVIDs</code> – SVIDs are, essentially, two-byte codes for the the altmodes that your device supports. If your answer is <code>0xFF01</code> (so, reply with <code>0xFF010000</code> as extra data), you get a cookie, in the form of being recognized as a DisplayPort altmode-capable device. One of the devices I own, answers with <code>0xFF01</code>, but also adds <code>0x25A4</code> to it – my suspicion is that this is a firmware update interface, so if you ever wanted to probe USB-C devices for pentesting purposes, this would absolutely be a vector to look into.</p>
<h2>DisplayPort Found – What’s Next?</h2>
<p>By giving the <code>0xFF01</code> answer to the <code>Discover SVIDs</code> request, we claim that our device supports DisplayPort altmode – even if, truth be told, we’re halfway through properly implementing it, faking it until we make it. No worry, though, as we’re on the right track – now we’re talking DisplayPort specifics. Our third command is <code>Discover Modes</code>, where we let the DP source know how exactly our DisplayPort needs map onto the USB-C connector.</p>
<p><img data-attachment-id="602593" data-permalink="https://hackaday.com/2023/08/03/displayport-taming-the-altmode/hadimg_re_dp_altmode_7/" data-orig-file="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_7.png" data-orig-size="1012,456" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="hadimg_re_dp_altmode_7" data-image-description="" data-image-caption="" data-medium-file="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_7.png?w=400" data-large-file="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_7.png?w=800" decoding="async" loading="lazy" src="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_7.png?w=800" alt="" width="800" height="360" srcset="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_7.png 1012w, https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_7.png?resize=250,113 250w, https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_7.png?resize=400,180 400w, https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_7.png?resize=800,360 800w" sizes="(max-width: 800px) 100vw, 800px"/></p>
<p>Remember how you can get full 4 lanes of DP from a USB-C connector, or do a 2-lane compromise but get USB3? Well, our <code>Discover Modes</code> response determines exactly that. First, our response defines whether we are a DP source or DP sink – apparently, the protocol allows for building bidirectional DP devices, which is certainly idea-provoking! It also explicitly defines USB 2.0 signaling use, whether the USB3 port we might request would support USB3 Gen 2, and whether our device uses a USB-C plug or a USB-C socket. Most importantly, though, it talks about the pin mapping.</p>
<p>The DisplayPort altmode can have six pin mappings, five in case of a USB-C socket. Two of them are dual-lane DP with USB3 and three of them are four-lane DP. All of them have different lane arrangements, apparently, but at least one of those should work for us as long as we wire up our mux chip according to the datasheet. It’s not clear to me what the noteworthy differences are or why the assignments are done the way they’re done – perhaps, the unavailable full spec would have some insights. For now, this PDF gives us the mappings we can use, and the bits we should set according to the mapping we have chosen.</p>
<p>After answering the <code>Discover Modes</code> message with info about our preferred pinout, we will shortly get an <code>Enter Mode</code> message – which we simply acknowledge with an <code>Enter Mode</code> response, no extra data required. Now, in hacker voice, <em>we’re in.</em></p>
<h2>The Last Trio</h2>
<p><a href="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_9.png" target="_blank"><img data-attachment-id="602591" data-permalink="https://hackaday.com/2023/08/03/displayport-taming-the-altmode/hadimg_re_dp_altmode_9/" data-orig-file="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_9.png" data-orig-size="987,757" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="hadimg_re_dp_altmode_9" data-image-description="" data-image-caption="" data-medium-file="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_9.png?w=400" data-large-file="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_9.png?w=800" decoding="async" loading="lazy" src="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_9.png?w=250" alt="" width="250" height="192" srcset="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_9.png 987w, https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_9.png?resize=250,192 250w, https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_9.png?resize=400,307 400w, https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_9.png?resize=800,614 800w" sizes="(max-width: 250px) 100vw, 250px"/></a>The three last commands are even closer to the actual DisplayPort nitty-gritty. The first one is <code>DP Status Update</code>, following right after the <code>Enter Mode</code> command. We can get this command whenever the DP sink wants to get an update, and we’ll have to answer it with our current link state. The bits in this command, as described on page 11 of our by-now-favourite PDF, communicate the current state of the DP altmode link. <code>DP Status Update</code> contents is a report on the overall connection status, both from the downstream point of view (DP source) and from the upstream point of view (DP sink, aka our device). Here we can exit the altmode if desired, switch to USB mode, or perhaps, to low-power mode, and we must also report the HPD pin state here. All of that fits within nine bits of data – not much to write home about, but write home, you must.</p>
<p>The very first occurrence of <code>DP Status Update</code> is uneventful, we just wing it, telling that HPD is low and all that. It will be followed by the <code>DP Configure</code> message – now, this point is where we get access to the raw DisplayPort signal on the SBU and high-speed pins of the USB-C port. The <code>DP Configure</code> message tells us which DP altmode pin mapping we should switch our hardware to, which is useful in case we claimed to support multiple mappings in our <code>Discover Modes</code> response – if we only claim to support one, there will be no surprises, unless the DP source doesn’t support the mapping we wanted.</p>
<p>Last but not least, there’s the <code>Attention</code> message – literally, bringing attention to some event on our side. The data for it is the same as the <code>DP Status Update</code> message – think of <code>Attention</code> as a <code>DP Status Update</code> message that we can send voluntarily whenever something changes on our side. So, if you have a USB-C to DisplayPort socket adapter, the <code>Attention</code> message will be the very last message of the DP altmode summoning process, letting the DP source know that the source has been connected. This, in particular is determined by the HPD pin, something that’s used as a hotplug detection pin in DisplayPort, but is also used for interrupts as a sideband to the AUX communication channel – as a pseudodifferential diffpair not unlike USB 1.1 and 2.0, the device on the other end expects to be polled, and our <code>Attention</code> messages will transfer the HPD cries of the device that has something to say and but hasn’t yet been asked to speak.</p>
<p>Now, we’re done – that’s all seven messages described, and implemented in code as we did so. The whole altmode negotiation flow has to be complete within a second’s time, or else the process will halt at some step. Which is to say, if you’d like to perform some calculations or print data out, you better be quick! Here’s example MicroPython code for you – somehow, I managed to have the parsing and command building be quick enough.</p>
<p>Mind you, this is the software side. Apart from what we just did, let’s go through a typical homegrown DP altmode design and what it needs.</p>
<h2>Hardware Basics</h2>
<p>First off, you’ll want to put the FUSB302 down on your schematic, and add a MCU to work with that. I usually pick a RP2040, but even an ESP12 module should do – you need I2C, a few GPIOs for mux control, and a bit of RAM for PD packet manipulation stuff. Then, of course, use a USB-C socket with high-speed lanes available – regular USB 2.0-only ports with 16 pins don’t expose the TX/RX pins we need. When it comes to DisplayPort diffpairs, pick a six-layer board – you’ll want two outer layers for DisplayPort diffpairs, two layers under each for reference ground planes, and two innermost layers for routing out the VBUS, USB2, CC and SBU pins – thankfully, both Aisler and JLCPCB have decent and cheap six-layer offerings now!</p>
<p>We can’t quite buy USB-C captive cables cheaply, sadly – however, putting a USB-C socket on our board is the next best thing! You do need a bit of extra hardware though. Again, the benefit of a captive cable is not needing a mux – which means that we will need a mux for handling our socket. When I was looking for USB-C muxes, I stumbled upon the VL170 chip, and <a href="https://crimier.github.io/posts/VL170/" target="_blank">pieced together its specifications</a> from screenshots online. Later, I found out that the VL170 is a clone of TI’s <a href="https://www.ti.com/product/HD3SS460" target="_blank">HD3SS460</a> (<a href="https://www.ti.com/lit/gpn/hd3ss460" target="_blank">datasheet</a>), and that’s what I recommend you use – whether you want to do 4-lane DisplayPort, or a USB3 and DisplayPort combination, just USB3, or even combine DisplayPort from two sources, the HD3SS460 mux will work for you, and it has a proper datasheet with example circuits.</p>
<p><img data-attachment-id="602595" data-permalink="https://hackaday.com/2023/08/03/displayport-taming-the-altmode/hadimg_re_dp_altmode_6/" data-orig-file="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_6.png" data-orig-size="1484,1258" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="hadimg_re_dp_altmode_6" data-image-description="" data-image-caption="" data-medium-file="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_6.png?w=400" data-large-file="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_6.png?w=737" decoding="async" loading="lazy" src="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_6.png?w=250" alt="" width="250" height="212" srcset="https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_6.png 1484w, https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_6.png?resize=250,212 250w, https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_6.png?resize=400,339 400w, https://hackaday.com/wp-content/uploads/2023/06/hadimg_re_dp_altmode_6.png?resize=737,625 737w" sizes="(max-width: 250px) 100vw, 250px"/>Don’t ground the shield – it’s grounded at host end as a rule, so it’s going to become counterproductive given high speeds of DisplayPort. Instead, add a 0805 footprint or two going from the shield to ground; later on, you can put a ferrite there, or a resistor and capacitor combination. When it comes to high-speed signals, the shield will be performing the function of shielding your signals from external interference; however, if you ground it on both ends, it will also end up carrying some of the VBUS current, which will reduce its shielding properties significantly. Oh, and about VBUS – it’s up to you on what you will be doing with that, after all, the “PD controller” part will be fully in your reach to begin with; whether you summon 5 V, provide 5 V, perhaps request 20 V if you’ve found a high-power and DP-capable port somehow, all of that is completely up to you.</p>
<h2>Route Your Tracks And You’re Done</h2>
<p>Remember the DisplayPort trace routing rules? Well, the VL170 doesn’t quite make it easy on you. Due to the the USB-C connector-side pair polarity on its pinout, only two of its diffpairs connect in a straightforward fashion – other two pairs need to be flipped before they connect. Remember, you still need to match lengths between the tracks, so you will need to adjust the part between the mux and the USB-C connector, and also the part between your your device and your mux. That said, in a reference-ish design of mine, I’ve managed to keep the connector-mux section to about one centimeter of length, so it shouldn’t be too much of a space hog for you. As for the after-mux side, you would route the DisplayPort link the same way you would normally, not much of a difference here.</p>
<p>Are there further bringup aspects you might need? Absolutely! For instance, you might need to tune the common-mode voltages before and after the mux using a few carefully matched resistors. Still, if you ever wanted to give your device a DisplayPort link out of a USB-C connector, now you’re well-equipped to do so, no NDAs or proprietary document acquisition needed.</p>
	            </div></div>
  </body>
</html>
