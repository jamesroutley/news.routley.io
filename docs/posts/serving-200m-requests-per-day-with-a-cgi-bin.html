<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simonwillison.net/2025/Jul/5/cgi-bin-performance/">Original</a>
    <h1>Serving 200M requests per day with a CGI-bin</h1>
    
    <div id="readability-page-1" class="page"><div>



<p><strong><a href="https://jacob.gold/posts/serving-200-million-requests-with-cgi-bin/">Serving 200 million requests per day with a cgi-bin</a></strong> (<a href="https://news.ycombinator.com/item?id=44464272" title="Hacker News">via</a>) Jake Gold tests how well 90s-era CGI works today, using a Go + SQLite CGI program running on a 16-thread AMD 3700X.</p>
<blockquote>
<p>Using CGI on modest hardware, itâ€™s possible to serve 2400+ requests per second or 200M+ requests per day.</p>
</blockquote>
<p>I got my start in web development with CGI back in the late 1990s - I was a huge fan of <a href="https://web.archive.org/web/20010509081826/http://www.amphibianweb.com/newspro/">NewsPro</a>, which was effectively a weblog system before anyone knew what a weblog was.</p>
<p>CGI works by starting, executing and terminating a process for every incoming request. The nascent web community quickly learned that this was a bad idea, and invented technologies like PHP and <a href="https://en.wikipedia.org/wiki/FastCGI">FastCGI</a> to help avoid that extra overhead and keep code resident in-memory instead.</p>
<p>This lesson ended up baked into my brain, and I spent the next twenty years convinced that you should <em>never</em> execute a full process as part of serving a web page.</p>
<p>Of course, computers in those two decades got a <em>lot</em> faster. I finally overcame that twenty-year core belief in 2020, when <a href="https://simonwillison.net/2020/Nov/28/datasette-ripgrep/">I built datasette-ripgrep</a>, a Datasette plugin that shells out to the lightning fast <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> CLI tool (written in Rust) to execute searches. It worked great!</p>
<p>As was <a href="https://news.ycombinator.com/item?id=44464272#44465143">pointed out on Hacker News</a>, part of CGI&#39;s problem back then was that we were writing web scripts in languages like Perl, Python and Java which had not been designed for lightning fast startup speeds. Using Go and Rust today helps make CGI-style requests a whole lot more effective.</p>
<p>Jake notes that CGI-style request handling is actually a great way to take advantage of multiple CPU cores:</p>
<blockquote>
<p>These days, we have servers with 384 CPU threads. Even a small VM can have 16 CPUs. The CPUs and memory are much faster as well.</p>
<p>Most importantly, CGI programs, because they run as separate processes, are excellent at taking advantage of many CPUs!</p>
</blockquote>
<p>Maybe we should start coding web applications like it&#39;s 1998, albeit with Go and Rust!</p>



</div></div>
  </body>
</html>
