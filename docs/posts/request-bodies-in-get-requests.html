<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://evertpot.com/get-request-bodies/">Original</a>
    <h1>Request bodies in GET requests</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>12 years ago I asked on Stack Overflow: <a href="https://stackoverflow.com/questions/978061/http-get-with-request-body">Are HTTP GET requests allowed to
have request bodies?</a>. This got a 2626 upvotes and a whopping 1.6 million
views, so clearly it’s something lots of people are still curious about, and
in some cases disagree with the accepted answer.</p>

<p><a href="https://stackoverflow.com/questions/978061/http-get-with-request-body"><img src="https://evertpot.com/assets/posts/get-body/so-screenshot.png" alt="Stack overflow screenshot"/></a></p>

<p>Because it keeps popping up in my Stack Overflow notifications (and
I compulsively visit the site), the question has lived in my head
rent-free. I keep adding context in my head, and I’ve been meaning to write
some of this down for a few years now and hopefully evict it.</p>

<p>Anyway, if you’re just looking for a quick answer, it’s ‘No, you shouldn’t do
this.’, you should probably use <a href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-safe-method-w-body-02"><code>QUERY</code></a>.</p>

<h2 id="undefined-behavior">Undefined behavior</h2>

<p>A number of people (most famously <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html#search-search-api-desc">ElasticSearch</a>) have gotten this wrong,
but why? I think it’s because of this sentence in the <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1">HTTP Spec</a>:</p>

<blockquote>
  <p>A payload within a GET request message has no defined semantics</p>
</blockquote>

<p>That sentence could easily suggest that there’s no specific behavior associated
to request bodies with <code>GET</code> requests, and that the behavior is left up to the
implementor.</p>

<p>The reality is that this is more like <a href="https://en.wikipedia.org/wiki/Undefined_behavior">Undefined behavior</a> from languages
like C/C++. My understanding is that leaving certain aspects of the C language
undefined (instead of for example requiring an error to be thrown) leaves room for
compiler implementations to make certain optimizations. Some compilers also
have fun with this; GCC hilariously <a href="https://feross.org/gcc-ownage/">starts a video game</a> in a specific case
of undefined behavior which really brings home this point.</p>

<p>If you were to write a C program that relies on how a compiler dealt with
specific undefined behavior, it means your program is no longer a portable
C program, but it’s written in variant of C that only works on some compilers.</p>

<p>The same applies for HTTP as well. It’s true that undefined behavior means
that <em>you</em> as a server developer can define it, but you are not an island!</p>

<p>When working with HTTP, there’s servers but also load balancers, proxies,
browsers and other clients that all need to work together. The behavior isn’t
just undefined server-side, a load balancer might choose to silently drop
bodies or throw errors. There’s many real-world examples of this. <code>fetch()</code>
for example will throw an error.</p>

<p>This hasn’t stopped people from doing this anyway. OpenAPI <a href="https://swagger.io/docs/specification/describing-request-body/">removed</a>
support for describing <code>GET</code> request bodies in version 3.0 (and <code>DELETE</code>,
which has the same issue!), but was quitely <a href="https://github.com/OAI/OpenAPI-Specification/pull/2117">added back in 3.1</a> to not
prevent people from documenting their arguably broken APIs.</p>

<h2 id="why-its-not-defined">Why it’s not defined</h2>

<p>The best source I have is this quote from Roy Fielding in 2007. Roy Fielding
coined REST is and is one of the main authors of the HTTP/1.1 RFCs.</p>

<blockquote>
  <p>Yes. In other words, any HTTP request message is allowed to contain a message body, and thus must parse messages with that in mind. Server semantics for GET, however, are restricted such that a body, if any, has no semantic meaning to the request. The requirements on parsing are separate from the requirements on method semantics.
 So, yes, you can send a body with GET, and no, it is never useful to do so.
This is part of the layered design of HTTP/1.1 that will become clear again once the spec is partitioned (work in progress).</p>

  <p>….Roy</p>
</blockquote>

<p>(<small>His message was originally sent to the now-dead rest-discuss
group on Yahoo Groups, but I found an <a href="https://github.com/jam01/rest-discuss-archive/blob/262d6768f83cdf811c2a997564105fc74bad8987/rest-discuss/9962.json">archive in JSON format</a></small>)</p>

<p>However, I always found this answer unsatisfying. I understand that you might
want a low-level protocol design that just passes messages containing headers,
bodies, urls, methods and statuses and not concern itself with method-specific
behavior.</p>

<p>That design goal doesn’t preclude <code>GET</code> from specifically rejecting request
bodies though, and it also doesn’t preclude the spec from mentioning that
request bodies should not be emitted.</p>

<p>So, unless there’s a different reason for this I’m going to have to assume
that this was well-intentioned but just not written clearly enough.</p>

<p>Despite this explanation from one of the authors of the HTTP spec itself,
I noticed some people will still claim a different interpretation, making
a sort of a <a href="https://en.wikipedia.org/wiki/The_Death_of_the_Author">‘death of the author’</a> argument. It’s a bit funny to think
about ‘death of the author’ in technical specs, but I think they have a
point. I believe that the definition of a standard such as HTTP is not
the written RFC, it’s how everyone actually implements it.</p>

<p>The goal of the spec is to accurately describe the standard, not to define
it. If what everyone is doing is different from the author’s intention,
the spec has failed to accurately describe the standard, not vice versa.</p>

<p>The team behind the HTTP specs believes this too, which is why we’ve
seen new releases of <code>HTTP/1.1</code> without increasing the version.
In each iteration major steps are taken to capture real-world usage,
sometimes even in conflict with the original RFC2616.</p>

<p>However, in this case it’s irrelevant. Many popular HTTP implementations
will throw errors when seeing <code>GET</code> bodies, such as <code>fetch()</code>. Using <code>GET</code>
bodies will give you such poor interopability that it’s worth continuing to
not do this.</p>

<p>In 2019 I’ve <a href="https://github.com/httpwg/http-core/issues/202">opened a ticket</a> to request to fix this, and they
listened. The upcoming HTTP/1.1 is going to include the following text:</p>

<blockquote>
  <p>Although request message framing is independent of the method used,
content received in a GET request has no generally defined semantics,
cannot alter the meaning or target of the request, and might lead
some implementations to reject the request and close the connection
because of its potential as a request smuggling attack (Section 11.2
of HTTP/1.1).</p>

  <p>A client SHOULD NOT generate content in a GET
request unless it is made directly to an origin server that has
previously indicated, in or out of band, that such a request has a
purpose and will be adequately supported.&gt;An origin server SHOULD
NOT rely on private agreements to receive content, since participants
in HTTP communication are often unaware of intermediaries along the
request chain.</p>
</blockquote>

<p><a href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-semantics#section-9.3.1">Source</a>.</p>

<h2 id="why-should-get-have-a-body">Why should <code>GET</code> have a body?</h2>

<p>I think we feel this way, because we’ve been told over and over again that
it’s a good idea to use protocols in a ‘semantically correct’ way.</p>

<p>But why should be care about semantics? 2 reasons:</p>

<ol>
  <li>If you do things in a semantically correct way, other systems can make
assumptions about how it should behave. For example: A <code>PUT</code> request
may be automatically repeated if it failed the first time due to a network
failure or 5xx error. A <code>GET</code> request may be cached if it contained a
<code>Cache-Control</code> header.</li>
  <li>It’s self-documenting behavior. If you see a <code>GET</code> request it tells a
developer something is being retrieved.</li>
</ol>

<p>So while #1 doesn’t really apply here (there’s no technical advantages,
because it’s undefined behavior), but #2 makes sense.</p>

<p>So if we decided to use <code>GET</code> for our complex search, what can we do?
Body is obviously not allowed; our only options are headers and the URL.
There’s a number of issues with this: Encoding UTF-8 is unclear, no real
support for documents/mine-types, length limitations.  It’s a bit of a mess!</p>

<h2 id="why-was-it-designed-not-to-support-bodies">Why was it designed not to support bodies?</h2>

<p>Most developers working with HTTP and learning about it is in the context
of APIs, but this is not the original use-case.</p>

<p>It all starts with HTML and browsers and URLS. The world wide web was
<a href="http://info.cern.ch/hypertext/WWW/Summary.html">designed</a> as a distributed hypertext document system, where every
document has a global unique identifier called a URL.</p>

<p>To retrieve a hypertext document, you would do a <code>GET</code> on this url, to
replace or create the document a <code>PUT</code> and to remove the document <code>DELETE</code>.
(<small>Note that it took longer to get a writable web, but I wanted to
illustrate what I think the intended design is without being encumbered
by facts</small>).</p>

<p>Taken from this perspective, the idea of ‘parameters’ makes less sense.
<code>GET</code> doesn’t just mean “Do a <a href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-semantics#section-9.3.1">safe</a> request and read something from the
server”, it means: ‘Give me the document with this name’.</p>

<p>This specific feature is in part why the web was so successful. Given that
the URL comprehensively describes to a client exactly how to connect to
a server and retrieve a document, it made the <code>&lt;a&gt;</code> HTML work. It also let
people make bookmarks, share links via email/chat and paint it on
store-fronts.</p>

<p>The URL is the web’s superstar and killer feature. HTTP just let you find
documents associated with the URL. <a href="https://www.w3.org/Protocols/HTTP/AsImplemented.html">HTTP/0.9 didn’t even have headers and
can be read during a bathroom break</a>.</p>

<h2 id="our-needs-have-evolved-has-http">Our needs have evolved, has HTTP?</h2>

<p>I still maintain that even if you’re building a REST api, it’s good to think
of your endpoints as documents, and the <code>GET</code>, <code>PUT</code> and <code>DELETE</code> as the most
important HTTP methods to manipulate these, using the URL as the primary key.</p>

<p>But, sometimes we need to do something more complicated and it would be nice
if HTTP had a prescribed way to handle cases where we want to describe a
search query as a document.</p>

<p>The answer traditionally was to just use <code>POST</code>. <code>POST</code> is kind of your
no-guarantees catch all method. Often also used to tunnel other protocols
that don’t really speak HTTP well, such as SOAP, XMLRPC and more recently
GraphQL.</p>

<p>But there’s a new contender. Now I think your best option is <a href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-safe-method-w-body-02"><code>QUERY</code></a>.
This is a new method, that’s not quite standard yet but any compliant HTTP
client and server should already support it. The goal of <code>QUERY</code> is
specifically to solve this use-case.</p>

<p><code>QUERY</code> solves the following problems:</p>

<ol>
  <li>It’s basically a ‘safe’ <code>POST</code>. This means the implication is that it’s
for reading and safe to repeat.</li>
  <li>It also is self-descriptive. It tells a developer that this is a API
that’s focused on reading.</li>
  <li>The spec also makes it cachable.</li>
</ol>

<p>I think you should still continue the use <code>GET</code> for the majority of cases,
but there’s a clear answer now for what to do when that doesn’t fit.</p>

<h2 id="anyway">Anyway…</h2>

<p>That’s a lot of writing for what seemingly is a simple question. It’s just
one of those things that’s been bouncing around my head for a bit too long.</p>

<p>I hope it’s out of my system!</p>

<p>Big thank you to everyone who originally answered my SO question.</p>

<h2 id="wanna-discuss">Wanna discuss?</h2>

<p>Hit me up on <a href="https://twitter.com/evertp/status/1487511342374219780">Twitter</a>,
<a href="https://github.com/evert/evert.github.com/discussions/42">Github Discussions</a>, or read the <a href="https://news.ycombinator.com/item?id=30129631">Hacker News Thread</a></p>


</div></div>
  </body>
</html>
