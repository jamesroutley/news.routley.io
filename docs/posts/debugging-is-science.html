<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://amedee.me/2022/11/09/debugging/">Original</a>
    <h1>Debugging Is Science</h1>
    
    <div id="readability-page-1" class="page"><section>
			<p>Debugging is one of the most difficult parts of working with computers.
Worse, you have to do more and more of it over time as you become responsible for mountains of code you didn’t write.</p>
<figure><img src="https://www.bloomberg.com/img/debugging/Screen%20Shot%202022-11-09%20at%203.45.09%20PM.png" alt="A graph of the amount of code you have to debug, increasing with expertise."/><figcaption>
            <p>(At least we don’t have to deal with God-tier bugs like <a href="https://www.snopes.com/fact-check/cone-of-silence/">my car doesn’t start after buying vanilla ice cream</a>)</p>
        </figcaption>
</figure>

<p>At work my last promotion was due in part to my problem solving abilities—my boss called me “a world-class debugger”. Here I will try to lay out the process I use and my best tricks.</p>
<p><img src="https://www.bloomberg.com/img/debugging/Screen%20Shot%202022-11-09%20at%206.29.00%20PM.png" alt="A map of debugging, with &amp;ldquo;Better Hypotheses&amp;rdquo; in a causal loop with &amp;ldquo;Better Experiments&amp;rdquo;."/></p>
<p>If it looks a bit science-ey, it’s because I cribbed it from a model of how scientists work<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.
When I’m debugging I like to think of myself as a scientist in a lab coat indifferently observing a phenomenon.</p>
<h2 id="think-of-yourself-as-a-scientist">Think of Yourself as a Scientist</h2>
<p>On top of feeling fancy with our imaginary lab coats and safety goggles, this has the huge emotional benefit of reducing our frustration with whatever we’re debugging. It gives us distance from the bug instead of feeling like an idiot for not understanding our own code, or not getting something we think should be simple.
And it provides us with important metaphors: we can talk about navigating a hypothesis space by doing experiments. The hypothesis space is the haystack of possible causes for the bug:</p>
<figure><img src="https://www.bloomberg.com/img/debugging/Screen%20Shot%202022-11-09%20at%203.53.41%20PM.png" alt="A cirlce with many reasons your bug might be happening, like AWS being down or your app being broken."/>
</figure>

<p>Finding the needle that’s causing our bug is difficult, so we’ll iteratively run “experiments” to narrow down the possibilities. For example we could check that AWS works well internally, and then rule out that set of causes:</p>
<figure><img src="https://www.bloomberg.com/img/debugging/Screen%20Shot%202022-11-09%20at%203.59.13%20PM.png" alt="Some of the reasons in the cirlce are now crossed out because we tested and AWS is up."/>
</figure>

<p>To decide which parts of the space to go after (do we check AWS or the frontend server?), you have to build up a spidey sense of what’s more likely in this picture, and you go after those parts first.</p>
<h2 id="train-your-internal-bug-barometer">Train Your Internal Bug Barometer</h2>
<p>Julia Evans has a <a href="https://jvns.ca/blog/2022/08/30/a-way-to-categorize-debugging-skills/">post</a> on debugging skills, which I recommend if you are trying to level up your debugging. It ends by quoting a research paper on expert vs novice debuggers:</p>
<blockquote>
<p>Their findings did not show a significant difference in the strategies employed by the novices and experts. <em>Experts simply formed more correct hypotheses</em> and were more efficient at finding the fault. The authors suspect that this result is due to the difference in the programming experience between novices and experts.</p>
</blockquote>
<p>Experts just picked the likeliest causes more often, and had more experience at debugging tools. This tracks with my experience, where I often “one-shot” bugs at work: the first place I look at is where the bug is, because my hunches are well calibrated.</p>
<p>You can build out this “Bug Barometer” over time by remembering how bugs manifest as you encounter them, and seeking out listings of bugs being solved in the wild and what they looked like. Good places at work are incident reports and on-call logs.</p>
<h2 id="tighten-a-window-around-the-bug">Tighten a Window Around the Bug</h2>
<p>Another thing that helps is ruling out entire subsystems at once. If you could rule out the backend or the frontend entirely at the begining of your debugging session, you’d save a lot of time. In an ideal world you’d have a binary elimination process where you eliminate the most likely subtree at each step you take:</p>
<figure><img src="https://www.bloomberg.com/img/debugging/Screen%20Shot%202022-11-09%20at%204.33.21%20PM.png" alt="A binary tree of reasons your app might be broken"/>
</figure>

<p>The bad news is there’s no universal decision tree for debugging and there will never be one. The systems are too complicated and change too often. What I do instead is, in my mind’s eye I lay out the golden path of what should be happening in broad strokes:</p>
<figure><img src="https://www.bloomberg.com/img/debugging/Screen%20Shot%202022-11-08%20at%202.46.30%20PM.png" alt="A causal"/>
</figure>

<p>And then I overlay probabilities of being broken onto each system:
</p><figure><img src="https://www.bloomberg.com/img/debugging/Screen%20Shot%202022-11-08%20at%203.28.53%20PM.png" alt="A causal"/>
</figure>

<p>And successively eliminate the likeliest areas, tightening a window around the bug like I’m guessing a number between 1 and 100 with binary search. I zoom in as I rule out more pieces, or if I run out of possibilities.</p>
<h2 id="isolating--reproducing-more-than-half-the-battle">Isolating + Reproducing: More Than Half the Battle</h2>
<p>You don’t have to understand a bug to reproduce it (<a href="https://web.mit.edu/jemorris/humor/500-miles">Emails don’t travel more than 500 miles</a> is a good enough starting point), but you have to be able to reproduce it <sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p>
<p>The worst types of bugs are on machines you don’t control, and which happen intermittently.
Some of these are Heisenbugs, which disappear when you are trying to observe them. (eg hooking up the debugger makes the problem go away!).
The only good method I have for dealing with these are trace recording tools, which require the entire execution of the application and let you play it back.</p>
<ul>
<li><a href="https://rr-project.org/">rr</a> records and plays back entire linux processes. <a href="https://www.postgresql.org/message-id/CAH2-WznTb6-0fjW4WPzNQh4mFvBH86J7bqZpNqteVUzo8p%3D6Hg%40mail.gmail.com">Here</a> is an amazing Postgres developers’ email thread finding a gnarly multi-threaded consistency bug with it.</li>
<li><a href="https://replay.io">Replay.io</a> records the browser and can replay traces with the dev tools and inspect state over the entire lifecycle of the bug, injecting console.logs anywhere in the code.</li>
<li>Look for similar tools in your domain(maybe distributed tracing tools for microservices, or qemu for embedded), possibly by googling “rr for $DOMAIN”.</li>
</ul>
<p>If you don’t have these tools available, you’ll have to gather more information from logs and look at multiple instantiations of the bug to find patterns, which will be much slower.</p>
<p>Trace recording tools are still extremely valuable even when you already know how to reproduce a bug, because they free you from having to re-trigger it over and over to intestigate it.
<strong>As much as possible, use trace recording tools to isolate bugs and experiment on them faster.</strong></p>
<h2 id="use-what-youre-familiar-with-but-dont-get-stuck">Use What You’re Familiar With, but Don’t Get Stuck</h2>
<p>Some parts of the system are harder to introspect than others, and we all have varying skill at each of them. For example, I might be really good with <code>lsof</code> but not with <code>dtrace</code>, or <code>printfs</code> instead of GDB. That’s ok, if you only need to know if a particular codepath is being reached <code>printf(&#34;here&#34;)</code> will do fine.</p>
<p>But don’t get me wrong: <strong>it’s very important to learn the debugging tools</strong>, and unless your bug is causing downtime/mission critical it’s definitely better in the long-run to go learn the new tool<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>. That investment will pay off ridiculously fast. I don’t use debuggers that often, but I’m ready to bust them out when I need them. Many people people get stuck because they don’t have the knowledge to open up the right devtool/tracing tool to look at what is going on. I’d go ahead and say if you are stuck on a bug, the first thing to think about should be if there is a better tool, or if you could be looking at a different level of detail.</p>
<h2 id="what-if-you-run-out-of-hypotheses">What if You Run Out of Hypotheses?</h2>
<p>This is the toughest part of debugging: when you feel like you’re banging your head against the wall because you’ve run out of ideas.
I don’t have any tools here outside of the usual “take a step back and take a break” wisdom.</p>
<p>I will say this happens more often when you are not familiar with the underlying system (the protocols your app uses), or if you’ve taken a wrong turn in your analysis earlier. To try to fix this, revisit your previous experiments and “zoom in” on your causal map of the system.</p>
<p>For a networking example, say your computer can reach <a href="https://en.wikipedia.org">en.wikipedia.org</a> but not <a href="https://google.com">google.com</a>. Since it can reach Wikipedia, you had had assumed your computer was working fine, so you don’t know what else to do. Zoom in on how your computer makes network connections: it looks up IP addresses in a <code>hosts</code> file, has a cache of DNS answers, sends the router a DNS query, etc. Now you have a list of new places to look.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In the short term:</p>
<ul>
<li>Think of yourself as a scientist and to feel better about the bug.</li>
<li>Use trace recording tools and time travel debuggers to isolate bugs and experiment on them faster.</li>
<li>Tighten a window around the bug to rule out possible causes faster.</li>
</ul>
<p>In the medium term, learn introspection tools like dtrace or your browser’s DevTools, and learn the systems your code depends on.</p>
<p>Over time, tune your bug barometer by mentally noting how bugs manifest themselves, and seeking out written reports.</p>
<p>These should accumulate and save you a mountain of time and pain. After implementing these practices, computer programming now feels to me much more like manifesting my creative intent, and less like arguing with a robot.</p>
<div role="doc-endnotes">
<hr/>
<ol>
<li id="fn:1">
<p>It’s a theory that scientists work by simultaneously navigating a Hypothesis space and an Experiment Space called <a href="https://www.sciencedirect.com/science/article/abs/pii/0364021388900079">Dual Space Search</a>. <a href="#fnref:1" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:2">
<p>You can debug things that already happened, like “the customer shouldn’t have been able to buy anything until their email was confirmed”, but you’re not guaranteed to have sucess there. <a href="#fnref:2" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn:3">
<p>Odds are you will encounter a similar bug in the same subsystem next week, and you will be happy to have learned the proper tool to investigate. <a href="#fnref:3" role="doc-backlink">↩︎</a></p>
</li>
</ol>
</div>


			
				<hr/>
				


<a href="https://disqus.com">comments powered by <span>Disqus</span></a>
			

			<hr/>
			


<ul>
	
	<li><a href="https://www.bloomberg.com/2022/11/08/dont-call-yourself-a-programmer/">Patio11&#39;s Don&#39;t Call Yourself a Programmer, and Other Career Advice</a></li>
	
	<li><a href="https://www.bloomberg.com/2022/11/06/zoxy/">Forget about localhost:3000 with zoxy</a></li>
	
	<li><a href="https://www.bloomberg.com/2022/08/22/7-powers-programming-languages/">The 7 Powers in Programming Language Adoption</a></li>
	
	<li><a href="https://www.bloomberg.com/2021/02/13/pdq-emscripten-4/">Compiling LibPDQ to JS with Emscripten Part 4: Writing Docs &amp; Emitting Typescript</a></li>
	
	<li><a href="https://www.bloomberg.com/2021/01/28/emscripten-libpdq-3/">Compiling LibPDQ to JS with Emscripten Part 3: All in JS → Pushing to NPM</a></li>
	
</ul>

		</section></div>
  </body>
</html>
