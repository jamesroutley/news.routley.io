<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dataswamp.org/~solene/2023-12-31-hardened-openbsd-workstation.html">Original</a>
    <h1>OpenBSD Workstation Hardening</h1>
    
    <div id="readability-page-1" class="page"><div>
<article id="20231231">
  <header>
  
    
    <p>Written by <em>Solène</em>, on 31 December 2023.</p>
    
    
  </header>
  
<p>I wanted to share a list of hardening you can do on your OpenBSD workstation, and explaining the threat model of each change.
</p>
<p><a href="https://www.openbsd.org">OpenBSD official project website</a></p>
<p>Feel free to pick any tweak you find useful for your use-case, many are certainly overkill for most people, but depending on the context, these changes could make sense for others.
</p>

<p>There are some tweaks that could be done in the configuration of a user to improve the security.
</p>
<h2 id="_The_Least_privileges">2.1. The Least privileges <a href="#_The_Least_privileges">§</a></h2>
<p>In order to prevent a program to escalate privileges, remove yourself from the wheel group, and don&#39;t set any doas or sudo permission.
</p>
<p>If you need root privileges, switch to a TTY using the root user.
</p>
<h2 id="_Multiple-factor_authentication">2.2. Multiple-factor authentication <a href="#_Multiple-factor_authentication">§</a></h2>
<p>In some cases, it may be desirable to have a multiple factor authentication, this mean that in order to log in your system, you would need a TOTP generator (phone app typically, or a password manager such as KeePassXC) in addition to your regular password.
</p>
<p>This would protect against people nearby who may be able to guess your system password.
</p>
<p>I already wrote a guide explaining how to add TOTP to an OpenBSD login.
</p>
<p><a href="https://dataswamp.org/~solene/2021-02-06-openbsd-2fa.html">Blog post: Multi-factor authentication on OpenBSD</a></p>
<h2 id="_Home_directory_permission">2.3. Home directory permission <a href="#_Home_directory_permission">§</a></h2>
<p>The permissions of the user directory should be 700, so only the owner and root could browse it.
</p>
<p>Ideally, you should add <code>umask 077</code> to your user environment, so every new directory or file permissions will be restricted to your user only.
</p>

<p>There are some interesting policies to configure with the help of OpenBSD firewall Packet Filter.
</p>
<h2 id="_Block_inbound">3.1. Block inbound <a href="#_Block_inbound">§</a></h2>
<p>By default, it&#39;s good practice to disable all incoming traffic except the responses to established sessions (so servers can reply to your requests).  This protects against someone on your local network / VPN to access network services that would be listening on the network interfaces.
</p>
<p>In <code>/etc/pf.conf</code> you would have to replace the default:
</p>
<pre><code>block return
pass
</code></pre>
<p>By the following:
</p>
<pre><code>block all
pass out inet
# allow ICMP because it&#39;s useful
pass in proto icmp
</code></pre>
<p>Then, reload with <code>pfctl -f /etc/pf.conf</code>, if you ever need to allow a port on the network, add the according rule in the file.
</p>
<h2 id="_Filter_outbound">3.2. Filter outbound <a href="#_Filter_outbound">§</a></h2>
<p>It may be useful and effective to block outbound traffic, but this only work effectively if you know exactly what you need because you will have to allow hosts and remote ports manually.
</p>
<p>It would protect against a program trying to exfiltrate data using a non-allowed port/host.
</p>

<p>Disabling network by default is an important mitigation in my opinion.  This will protect against any program your run and try to act rogue, if they can&#39;t figure there is a proxy, they won&#39;t be able to connect to the Internet.
</p>
<p>This could also save you from mistaken commands that would pull stuff from the network like pip, npm and co.  I think it&#39;s always great to have a tight control on which program should do networking and which shouldn&#39;t.  On Linux this is actually easy to do, but on OpenBSD we can&#39;t restrict a single program so a proxy is the only solution.
</p>
<p>This can be done by creating a new user named <code>_proxy</code> (or whatever the name you prefer) using <code>useradd -s /sbin/nologin -m _proxy</code> and adding your SSH key to its authorized_keys file.
</p>
<p>Add this rule at the end of your file <code>/etc/pf.conf</code> and then reload with <code>pfctl -f /etc/pf.conf</code>:
</p>
<pre><code>block return out proto {tcp udp} user solene
</code></pre>
<p>Now, if you want to allow a program to use the network, you need to:
</p>
<ul>

  <li>toggle the proxy ON with the command: <code>ssh -N -D 10000 _proxy@localhost</code> which is only possible if your SSH private key is unlocked</li>
  <li>configure a SOCKS5 proxy in the program</li>
</ul>

<h3 id="_Some_network_fixes">4.0.1. Some network fixes <a href="#_Some_network_fixes">§</a></h3>
<p>Most programs will react to a proxy configured in a variable named <code>http_proxy</code> or <code>https_proxy</code> or <code>all_proxy</code>, however it&#39;s not a good idea to globally define these variables for your user as it would be a lot easier to a program to use the proxy automatically, which is against the essence of this proxy.
</p>
<h4 id="_SSH">4.0.1.1. SSH <a href="#_SSH">§</a></h4>
<p>By default, you won&#39;t be able to ssh to anything except on a local user, we need to proxy every remote ssh connection through the local _proxy user.
</p>
<p>In <code>~/.ssh/config</code>:
</p>
<pre><code>Host localhost
User _proxy
ControlMaster auto
ControlPath ~/.ssh/%h%p%r.sock
ControlPersist 60

Host *.*
ProxyJump localhost
</code></pre>
<h4 id="_Chromium">4.0.1.2. Chromium <a href="#_Chromium">§</a></h4>
<p>If you didn&#39;t configure GNOME proxy settings, Chromium / Ungoogled Chromium won&#39;t use a proxy, except if you add a command line parameter <code>--proxy-server=socks5://localhost:10000</code>.
</p>
<p>I tried to manually modified the dconf database where the &#34;GNOME&#34; settings are to configure the proxy, but I didn&#39;t get it to work (it used to work for me, but I can&#39;t succeed anymore).
</p>
<h4 id="_Syncthing">4.0.1.3. Syncthing <a href="#_Syncthing">§</a></h4>
<p>If you use syncthing, you need to proxy all its traffic through the SSH tunnel. This is done by setting the environment variable <code>all_proxy=socks5://localhost:10000</code> in the program environment.
</p>

<p>It&#39;s possible to have most of your home directory be a temporary file system living in memory, with a few directories with persistency.
</p>
<p>This change would prevent anyone from using temporary files or cache left-over from previous session.
</p>
<p>The most efficient method to achieve this is to use the program home-impermanence that I wrote for this use case, it handles a list of files/directories that should be persistent.
</p>
<p><a href="https://dataswamp.org/~solene/2022-03-15-openbsd-impermanence.html">Blog post: Reproducible clean $HOME on OpenBSD using impermanence</a></p>
<p>If you only want to start fresh using a template (that doesn&#39;t evolve on use), you can check the flag <code>-P</code> of <code>mount_mfs</code> which allows populating the fresh memory based file system using an existing directory.
</p>
<p><a href="https://man.openbsd.org/mount_mfs">OpenBSD man page: mount_mfs(8)</a></p>

<p>Good news!  I take the opportunity here to remember OpenBSD disables by default the video and audio recording of the various capable devices, instead, they will appear to work but record empty stream of data.
</p>
<p>They can be manually enabled by changing the sysctls <code>kern.audio.record</code> or <code>kern.video.record</code> to 1 when you need to use them.
</p>

<p>If you need to protect your system from malicious USB devices (usually in an office environment), you should disable them in the BIOS/Firmware if possible.
</p>
<p>If it&#39;s not possible, then you could still disable the kernel drivers at boot time using this method.
</p>
<p>Create the file <code>/etc/bsd.re-config</code> and add the content to it:
</p>
<pre><code>disable usb
disable xhci
</code></pre>
<p>This will disable the support for USB 3 and 2 controllers.  On a desktop computer, you may want to use PS/2 peripherals in these conditions.
</p>

<h2 id="_Clamav_antivirus">8.1. Clamav antivirus <a href="#_Clamav_antivirus">§</a></h2>
<p>While this one may make you smile, if there is a chance it saves you once, I think it&#39;s still a valuable addition to any kind of hardening.  A downloaded attachment from an email, or rogue JPG file could still harm your system.
</p>
<p>OpenBSD ships a fully working clamav service, don&#39;t forget to enable freshclam, the viral database updater.
</p>
<h2 id="_Auto-update">8.2. Auto-update <a href="#_Auto-update">§</a></h2>
<p>I already covered it in a previous article about anacron, but in my opinion, auto-updating the packages and base system daily on a computer is the minimum that should be done everywhere.
</p>
<p><a href="https://dataswamp.org/~solene/2023-06-28-anacron.html#_Useful_examples">Anacron: useful OpenBSD examples</a></p>

<h2 id="_Memory_allocation_hardening">9.1. Memory allocation hardening <a href="#_Memory_allocation_hardening">§</a></h2>
<p>The OpenBSD malloc system allows you to enable some extra checks, like use after free, heap overflow or guard pages, they can be all enabled at once.  This is really efficient for security as most security exploits relies on memory management issues, BUT it may break software that have memory management issues (there are many of them).  Using this mode will also impact the performance negatively, as the system needs to do more checks for each piece of allocated memory.
</p>
<p>In order to enable it, add this to <code>/etc/sysctl.conf</code>:
</p>
<pre><code>vm.malloc_conf=S
</code></pre>
<p>It can be immediately enabled with <code>sysctl vm.malloc_conf=S</code>, and disabled by setting no value <code>sysctl vm.malloc_conf=&#34;&#34;</code>.
</p>
<p>The program <code>ssh</code> and <code>sshd</code> always run with this flag enabled, even if it&#39;s disabled system-wide.
</p>

<h2 id="_Specialized_proxies">10.1. Specialized proxies <a href="#_Specialized_proxies">§</a></h2>
<p>It could be possible to have different proxy users, with each restriction to the remote ports allowed, we could imagine proxies like:
</p>
<ul>

  <li>http / https / ftp</li>
  <li>ssh only</li>
  <li>imap / smtp</li>
  <li>etc....</li>
</ul>

<p>Of course, this is even more tedious than the multipurpose proxy, but at least, it&#39;s harder for a program to guess what proxy to use, especially if you don&#39;t connect them all at once.
</p>
<h2 id="_Run_process_using_dedicated_users">10.2. Run process using dedicated users <a href="#_Run_process_using_dedicated_users">§</a></h2>
<p>I wrote a bit about this in the past, for command line programs, running them in dedicated local users over SSH make sense, as long as it&#39;s still practical.
</p>
<p><a href="https://dataswamp.org/~solene/2019-11-12-dedicated-users-processes.html">Dedicated users to run processes</a></p>
<p>But if you need to run graphical programs, this becomes tricky. Using <code>ssh -Y</code> gives the remote program a full access to your display server, which has access to everything else running, not great...  You could still rely on <code>ssh -X</code> which enables X11 Security extensions, but you have to trust the implementation, and it comes with issues like no shared clipboard, poor performance and programs crashing when attempting to access a legit resource that is blocked by the security protocol...
</p>
<p>In my opinion, the best way to achieve isolation for graphical programs would be to run a dedicated VNC server in the local user, and connect from your own user.  This should be better than running on your own X locally.
</p>
<h2 id="_Encrypted_home_with_USB_unlocking">10.3. Encrypted home with USB unlocking <a href="#_Encrypted_home_with_USB_unlocking">§</a></h2>
<p>In a setup where the computer is used by multiple person, the system encryption may be tedious because everyone have to remember the main passphrase, you have no guarantee one won&#39;t write it down on a post-it... In that case, it may be better to have a personal volume, encrypted, for each user.
</p>
<p>I don&#39;t have an implementation yet, but I got a nice idea.  Adding a volume for a user would look like the following:
</p>
<ul>

  <li>take a dedicated USB memory stick for this user, this will be used as a &#34;key&#34; to unlock their data directory</li>
  <li>overwrite the memory stick with random data</li>
  <li>create an empty disk file on the system, it will contain the encrypted virtual disk, use a random part of the USB disk for the passphrase (you will have to write down the length + offset)</li>
  <li>write a rc file that looks for the USB disk volume if present, if so, tries to unlock and mount the partition upon boot</li>
</ul>

<p>This way, you only need to have your USB memory stick plugged in when the system is booting, and it should automatically unlock and mount your personal encrypted volume.  Note that if you want to switch user, you would have to reboot to unlock their drive if  you don&#39;t want to mess with the command line.
</p>

<p>It&#39;s always possible to harden a system more and more, but the balance between real world security and actual usability should always be studied.
</p>
<p>No one will use a too-much hardened system if they can&#39;t work on it efficiently, on the other handle, users expect their system to protect them against most common threats.
</p>
<p>Depending on one&#39;s environment and threat model, it&#39;s important to configure their system accordingly.
</p>

</article>
</div></div>
  </body>
</html>
