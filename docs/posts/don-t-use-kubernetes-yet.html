<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matt-rickard.com/dont-use-kubernetes-yet/">Original</a>
    <h1>Don&#39;t use Kubernetes yet</h1>
    
    <div id="readability-page-1" class="page"><div><p>Early-stage startups shouldn&#39;t run on Kubernetes yet. </p><p>But eventually, growth-stage and large companies <em>should </em>be running on Kubernetes in some form. <a href="https://matt-rickard.com/kubernetes-maximalism/">Kubernetes Maximalism</a> doesn&#39;t mean one-size-fits-all.</p><p>Infrastructure should progressively grow with your workloads and team. How can you choose the right technology <em>now </em>so that you can maximize growth and minimize pain <em>later </em>when you inevitably outgrow it?</p><p>This is a deeper dive into one area of the infrastructure stack: container abstractions. There are tons of ways to run containers on cloud, so it&#39;s especially tough to pick the right abstraction at the right time. I&#39;d roughly classify them into four categories:</p><ul><li>Code-to-Container-to-Deploy (AWS App Runner, Google App Engine)</li><li>Serverless Container Runtime (Fargate on ECS, Google Cloud Run)</li><li>Managed Kubernetes ({A,E,G}-KS)</li><li>Self-Hosted Kubernetes</li></ul><p>A guide to choosing the right container abstractions broken down by engineering teams that are 1e0, 1e1, 1e2, and 1e3+ engineers.</p><pre><code>1e0 ≤ team_size ≤ 1e1</code></pre><p>Let&#39;s take the example of a <em>small team</em>. The developers might have some DevOps experience, but everyone&#39;s essentially an SRE. There might be a simple CI/CD pipeline but a limited focus on reproducibility or air-gapped environments. You can get far with serverless functions and event-driven architectures, but you&#39;ll probably need a long-running daemon at some point.</p><p>I&#39;d be careful with the all-in-one options like AWS App Runner or any service that promises code-to-container-to-deployment. For any team building anything other than a simple web service, you&#39;ll run into a wall quickly with those services.</p><p>Be wary of simplicity that is hyper-opinionated optimization in disguise – <a href="https://matt-rickard.com/optimization-is-fragile/">Optimization is Fragile</a>.</p><p>My advice for this team: <strong><em>start with serverless container runtimes</em>.</strong> On AWS, that would be Fargate on ECS, or on Google Cloud, Google Cloud Run.</p><ul><li>Deployments look like a simplified version of what you&#39;d deploy on Kubernetes. </li><li>Turning on basic autoscaling is easy enough when you reach a little more scale. </li><li>You won&#39;t have to manage servers, network overlays, logging, or other necessary middleware. </li></ul><p>The downsides are that you&#39;ll have to build and upload container images. While many higher-level services will pack up your code and turn it into a container, I don&#39;t suggest using them. Once you hit the configurability cliff (e.g., needing to change something that the builder abstracts), you take on all of the complexity that you thought you avoided, all at once.</p><p>In my experience, these services can be difficult to work with if you use the UI. I&#39;d suggest provisioning them in code with something like Pulumi or AWS CDK.</p><p>You don&#39;t need a fully baked CI/CD pipeline. It&#39;s OK to build and deploy containers locally or with a simple script on GitHub actions. In the <a href="https://matt-rickard.com/spectrum-of-reproducibility/">Spectrum of Reproducibility</a>, you only need weak guarantees. While not reproducible and many foot guns, Docker images are good enough for small teams. </p><pre><code>1e1 ≤ team_size ≤ 1e2</code></pre><p>I&#39;d suggest that teams adopting Kubernetes (even the managed versions) have an SRE team, or at minimum, a dedicated SRE engineer.</p><p>Reasons you might outgrow a serverless container runtime</p><ul><li>Have non-standard resource requirements. Storage, networking, and machine configuration are limited on serverless runtimes. If you have particularly lopsided requirements (high RAM, low CPU) or high IOP storage, you might consider using a managed Kubernetes offering.</li><li>Stateful workloads that need operators. Stateful workloads are difficult to build on serverless runtimes, as the storage options are limited. You might need additional abstractions over the network (like service discovery or peering) that are tougher with serverless runtimes.</li><li>Managing an order of magnitude of services. Running a few services on Fargate on ECS or Cloud Run means that you can easily take care of automatable-but-infrequent events with a script or manual intervention. Having hundreds of ephemeral services that require TLS certificates and external DNS means that maybe GKE or EKS is a better option as a basis for automation.</li></ul><p>The thing about Kubernetes tooling is that: (1) there are a lot of APIs to build upon, (2) that results in a Cambrian explosion of tools for which (3) not all of them will be useful.</p><pre><code>1e2 ≤ team_size ≤ ??</code></pre><p>Large engineering teams may want to run Kubernetes on bare metal or cloud.</p><p>You&#39;ll probably need a dedicated <code>1e2</code> DevOps team if you&#39;re going down this route. Or, you might be a company exposing Kubernetes in some way to your customers (e.g., a platform service or IaaS-like provider).</p><p>Some reasons why you might want to run Kubernetes yourself.</p><ul><li>Cost: utilizing existing on-prem or legacy hardware, specialized hardware for specific applications (e.g., GPU-intensive)</li><li>Performance: applications where bare-metal performance is critical (e.g., FPGA, GPU, etc.)</li><li>Non-cloud environment: running Kubernetes at the edge, like in retail stores (e.g., <a href="https://medium.com/@cfatechblog/bare-metal-k8s-clustering-at-chick-fil-a-scale-7b0607bd3541">Chick-fil-A</a>)</li></ul><p>My advice: be careful with the internal platforms and abstractions you build on Kubernetes. Even the best snowflake infrastructure eventually suffers from diseconomies of scale (see <a href="https://matt-rickard.com/diseconomies-of-scale-at-google/">Diseconomies of Scale at Google</a>). You shouldn&#39;t be wasting engineering cycles competing with or recreating products already offered by cloud hyperscalers.</p></div></div>
  </body>
</html>
