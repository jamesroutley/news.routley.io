<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/bottlesdevs/Bottles">Original</a>
    <h1>Bottles – Run Windows software and games on Linux</h1>
    
    <div id="readability-page-1" class="page"><div><p><span></span><a href="https://jaked.org/index"><span>Jake Donham</span></a><span> &gt; </span><a href="https://jaked.org/blog/index"><span>Technical Difficulties</span></a><span> &gt; Read the Code: GitHub Flat Viewer</span></p><h3 id="2022-01-26"><span><em>2022-01-26</em></span></h3><p><span>One way I like to learn new a computer thing—a new library, language, tool, or technique—is to read the code of projects that use it. I don&#39;t do this enough! I usually start by following a &#34;getting started&#34; tutorial, skimming the documentation, and looking at example code. But often the distance between getting started with a computer thing and using it effectively is very large. So reading the code of a substantial project can be really helpful: it&#39;s working code with a purpose; you can see how the new thing works and how it fits together with other things. I also like reading project code because I usually learn a lot of things beyond what I set out to learn, like tools and libraries I hadn&#39;t heard of, or programming styles and idioms.</span></p><p><span>I&#39;m starting a new job soon at </span><a href="https://next.github.com/"><span>GitHub Next</span></a><span>, so I thought I would read the code of some existing GitHub Next projects to get a sense of how the team works. I started with </span><a href="https://github.com/githubocto/flat-viewer"><span>Flat Viewer</span></a><span>, a browser app that reads flat data files from GitHub via the </span><a href="https://docs.github.com/en/rest"><span>REST API</span></a><span> and displays them in a table interface with sorting and filtering. I think it&#39;s a pretty straightforward browser app, but I am not a very experienced browser app programmer, so I learned a lot. In what follows I&#39;m going to focus on the parts that are new to me, so this will be a bit of a hodgepodge, but I hope there&#39;s something in it that&#39;s new and/or useful for you.</span></p><p><span>The world of libraries, frameworks, and tools for building browser apps is immense and ever-changing—&#34;best practice&#34; is a destination forever receding into the distance as you approach—so please read this as a description of one way of doing things, that seems to work for a particular purpose, as one person understands it, rather than anything like an authoritative explanation.</span></p><p><span>Flat Viewer is a </span><a href="https://reactjs.org/"><span>React</span></a><span> app written in </span><a href="https://www.typescriptlang.org/"><span>TypeScript</span></a><span>. Good, I feel pretty comfortable with this! Let&#39;s walk through the components:</span></p><h2 id="app"><span>App</span></h2><p><span>The main component is </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/App.tsx#L13"><span><code>App</code></span></a><span>, and the main thing it does is route to different views within the app based on the URL path, using </span><a href="https://v5.reactrouter.com/"><span>React Router</span></a><span>. In a single-page React app, navigating to a view doesn&#39;t interact with the browser&#39;s URL bar: history is not recorded, and you can&#39;t get back to a view by copying and pasting its URL. React Router parses the URL and routes to a matching view; navigating to a view updates the URL (and records it in history). This works using a pattern-matching syntax inside of React JSX tags, like so:</span></p><pre><code><span>&lt;</span>Router<span>&gt;</span>
  <span>&lt;</span>Switch<span>&gt;</span>
    <span>&lt;</span>Route exact path<span>=</span><span>&#34;/&#34;</span> component<span>=</span><span>{</span>Home<span>}</span> <span>/</span><span>&gt;</span>
    <span>&lt;</span>Route exact path<span>=</span><span>&#34;/:org/&#34;</span> component<span>=</span><span>{</span>OrgListing<span>}</span> <span>/</span><span>&gt;</span>
    <span>&lt;</span>Route path<span>=</span><span>&#34;/:owner/:name&#34;</span> component<span>=</span><span>{</span>RepoDetail<span>}</span> <span>/</span><span>&gt;</span>
  <span>&lt;</span><span>/</span>Switch<span>&gt;</span>
<span>&lt;</span><span>/</span>Router<span>&gt;</span></code></pre><p><span>An empty path </span><a href="https://flatgithub.com/"><span>/</span></a><span> routes to the </span><span><code>Home</code></span><span> component; a one-segment path like </span><a href="https://flatgithub.com/githubocto/"><span><code>/githubocto/</code></span></a><span> routes to the </span><span><code>OrgListing</code></span><span> component; a two-segment path like </span><a href="https://flatgithub.com/githubocto/flat-demo-bitcoin-price"><span><code>/githubocto/flat-demo-bitcoin-price</code></span></a><span> routes to the </span><span><code>RepoDetail</code></span><span> component.</span></p><p><span>There are a few other things going on in </span><span><code>App</code></span><span>:</span></p><ul><li><p><span>show a progress bar while data is being fetched using </span><a href="https://ricostacruz.com/nprogress/"><span>NProgress</span></a><span></span></p></li><li><p><span>set up a React context for </span><a href="https://react-query.tanstack.com/"><span><code>react-query</code></span></a><span> for reading data from the GitHub API (this is actually one level outside </span><span><code>App</code></span><span> in </span><span><code>main.tsx</code></span><span>, so the progress bar in </span><span><code>App</code></span><span> can use it)</span></p></li><li><p><span>set up a context for </span><a href="https://github.com/tizmagik/react-head"><span><code>react-head</code></span></a><span>, so view components can set the page title with a local </span><span><code>&lt;Title&gt;</code></span><span> tag (instead of twiddling </span><span><code>document.title</code></span><span>)</span></p></li><li><p><span>set up a context for </span><a href="https://github.com/pbeshai/use-query-params"><span><code>use-query-params</code></span></a><span>, which is used to store component state in query params (so browser history and copying/pasting the URL works for that state as well as view navigation; more on this below)</span></p></li></ul><h2 id="home-and-repoform"><span>Home and RepoForm</span></h2><p><span>The </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/components/home.tsx#L5"><span><code>Home</code></span></a><span> component just adds some styling around </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/components/repo-form.tsx#L102"><span><code>RepoForm</code></span></a><span>, which shows a form for filling in a GitHub account and repo. There are several interesting things going on in </span><span><code>RepoForm</code></span><span>:</span></p><ul><li><p><span>the form is rendered using </span><a href="https://formik.org/"><span>Formik</span></a><span>, which keeps track of the state of field values, validates the values, and prevents submitting the form if any values are invalid.</span></p></li><li><p><span>field values are validated using </span><a href="https://github.com/jquense/yup"><span><code>yup</code></span></a><span>, which takes a schema describing expected values, like</span></p><pre><code><span>const</span> validationSchema <span>=</span> <span>object</span><span>(</span><span>)</span><span>.</span><span>shape</span><span>(</span><span>{</span>
  owner<span>:</span> <span>string</span><span>(</span><span>)</span><span>.</span><span>required</span><span>(</span><span>&#34;Please enter a repository owner&#34;</span><span>)</span><span>,</span>
  name<span>:</span> <span>string</span><span>(</span><span>)</span><span>.</span><span>optional</span><span>(</span><span>)</span><span>,</span>
<span>}</span><span>)</span><span>;</span></code></pre><p><span>It&#39;s integrated with Formik so you can pass the schema directly into the </span><a href="https://formik.org/docs/api/formik"><span><code>&lt;Formik&gt;</code></span></a><span> tag.</span></p></li><li><p><span>submitting the form adds a new path to the browser history using React Router&#39;s </span><a href="https://v5.reactrouter.com/web/api/Hooks/usehistory"><span><code>useHistory</code></span></a><span> API; this causes the &lt;</span><span><code>Router&gt;</code></span><span> component in </span><span><code>Home</code></span><span> to re-render, changing the view. (</span><span><code>RepoForm</code></span><span> also uses </span><a href="https://v5.reactrouter.com/web/api/Link"><span><code>Link</code></span></a><span> to link to an example repo, which does the same thing.)</span></p></li><li><p><span>fields are styled differently when they are invalid; this is handled using </span><a href="https://github.com/jorgebucaran/classcat"><span><code>classcat</code></span></a><span>, which builds a string of CSS class names from an object mapping names to flags. (More below on styling components.)</span></p></li></ul><p><span>There&#39;s always a tradeoff between calling out to a dependency and writing the code by hand—I would probably write something simple like this by hand (keep track of field values with </span><a href="https://reactjs.org/docs/hooks-reference.html#usestate"><span><code>React.useState</code></span></a><span> and validate them inline). But I can see that for a big form with intricate validation, using Formik and </span><span><code>yup</code></span><span> would be much easier; and if they are in your toolbox already it&#39;s easier to use them even for simple things.</span></p><h2 id="orglisting"><span>OrgListing</span></h2><p><span>The </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/components/org-listing.tsx#L58"><span><code>OrgListing</code></span></a><span> component displays a list of repos from a GitHub account. The list of repos is queried from the GitHub REST API using </span><a href="https://elbywan.github.io/wretch/"><span><code>wretch</code></span></a><span> and </span><a href="https://react-query.tanstack.com/"><span>React Query</span></a><span>.</span></p><p><span><code>Wretch</code></span><span> is a wrapper around the browser built-in </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch"><span><code>fetch</code></span></a><span> function (which makes an HTTP request and returns a </span><span><code>Promise</code></span><span> of the result). It replaces </span><span><code>fetch</code></span><span>&#39;s &#34;big bag of options&#34;-style interface with a &#34;builder&#34;-style interface, and provides some prebuilt handlers for HTTP-level error responses and for decoding response bodies. Here&#39;s the </span><span><code>wretch</code></span><span> call to get a list of repos (see </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/api/index.ts#L286"><span><code>fetchOrgRepos</code></span></a><span>):</span></p><pre><code>githubWretch
  <span>.</span><span>url</span><span>(</span><span>`</span><span>/search/repositories</span><span>`</span><span>)</span>
  <span>.</span><span>query</span><span>(</span><span>{</span> q<span>:</span> <span>`</span><span>topic:flat-data org:</span><span>${</span><span>orgName</span><span>}</span><span>`</span><span>,</span> per_page<span>:</span> <span>100</span> <span>}</span><span>)</span>
  <span>.</span><span>get</span><span>(</span><span>)</span>
  <span>.</span><span>json</span><span>(</span><span>)</span><span>;</span></code></pre><p><span>It calls the API (at </span><span><code>https://api.github.com</code></span><span>; this is pre-configured in </span><span><code>githubWretch</code></span><span>) with the given path and query params (see the </span><a href="https://docs.github.com/en/rest/reference/search#search-repositories"><span>API docs</span></a><span>), then decodes a successful response as JSON. (Note that the search matches only repos tagged </span><span><code>flat-data</code></span><span>.)</span></p><p><span>React rendering is basically synchronous, but </span><span><code>wretch</code></span><span> returns an asynchronous </span><span><code>Promise</code></span><span>. This is where React Query comes in: it keeps track of the state of a query—succeeded (with some value), failed (with some error), or waiting—and rerenders components that depend on the query when the state changes (e.g. the </span><span><code>Promise</code></span><span> resolves). To query the list of repos, the </span><span><code>wretch</code></span><span> query above is wrapped in a </span><a href="https://react-query.tanstack.com/reference/useQuery"><span><code>useQuery</code></span></a><span> hook (in </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/hooks/index.ts#L75"><span><code>useOrgFlatRepos</code></span></a><span>):</span></p><pre><code><span>useQuery</span><span>(</span>
  <span>[</span><span>&#34;org&#34;</span><span>,</span> orgName<span>]</span><span>,</span>
  <span>(</span><span>)</span> <span>=&gt;</span> <span>fetchOrgRepos</span><span>(</span>orgName<span>)</span><span>,</span>
  <span>{</span> retry<span>:</span> <span>false</span><span>,</span> refetchOnWindowFocus<span>:</span> <span>false</span> <span>}</span>
<span>)</span></code></pre><p><span>The return value of </span><span><code>useQuery</code></span><span> includes a </span><span><code>status</code></span><span> field of type </span><span><code>&#34;success&#34; | &#34;error&#34; | &#34;loading&#34;</code></span><span>; depending on </span><span><code>status</code></span><span> it has additional fields describing the returned value or error. </span><span><code>OrgListing</code></span><span> renders an appropriate component (</span><span><code>RepoListing</code></span><span>, </span><span><code>ErrorState</code></span><span>, or </span><span><code>Spinner</code></span><span>) depending on </span><span><code>status</code></span><span>. </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/components/org-listing.tsx#L20"><span><code>RepoListing</code></span></a><span> renders a list of repos, each with a React Router </span><span><code>Link</code></span><span> to navigate to the </span><span><code>RepoDetail</code></span><span> view.</span></p><p><span>The arguments to </span><span><code>useQuery</code></span><span> are a label (used for caching and deduplicating queries), a </span><span><code>Promise</code></span><span>-returning function that makes the underlying query (you can use any library you like), and some options controlling when the query should be retried or refetched (by default, focusing away then returning to the browser refetches the query).</span></p><h2 id="repodetail"><span>RepoDetail</span></h2><p><span>The </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/components/repo-detail.tsx#L36"><span><code>RepoDetail</code></span></a><span> component displays controls to select a data file and version from a repo, and a table view of the selected data. By default the first file (having an appropriate format) in the repo and latest version are shown.</span></p><p><span>The state representing the selected data file and version is tracked with </span><a href="https://github.com/pbeshai/use-query-params"><span><code>use-query-params</code></span></a><span>. This provides a </span><a href="https://github.com/pbeshai/use-query-params/tree/master/packages/use-query-params#usequeryparam"><span><code>useQueryParam</code></span></a><span> hook that works like </span><span><code>React.useState</code></span><span>:</span></p><pre><code><span>const</span> <span>[</span>filename<span>,</span> setFilename<span>]</span> <span>=</span> <span>useQueryParam</span><span>(</span><span>&#34;filename&#34;</span><span>,</span> StringParam<span>)</span><span>;</span>
<span>const</span> <span>[</span>selectedSha<span>,</span> setSelectedSha<span>]</span> <span>=</span> <span>useQueryParam</span><span>(</span><span>&#34;sha&#34;</span><span>,</span> StringParam<span>)</span><span>;</span></code></pre><p><span>but serializes the state value (</span><span><code>StringParam</code></span><span> specifies how to serialize it) and stores it in URL query params. It integrates with React Router; updating a state variable (e.g. calling </span><span><code>setFilename</code></span><span>) causes a navigation, so the state is restored if you copy/paste the URL or press the back button. Nice! There is a lot I don&#39;t understand about how React Router and </span><span><code>use-query-params</code></span><span> work under the hood—it would be worth reading this code, but not today.</span></p><p><span>When </span><span><code>RepoDetail</code></span><span> renders, it first queries a list of files in the repo (with </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/hooks/index.ts#L60"><span><code>useGetFiles</code></span></a><span> and </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/api/index.ts#L97"><span><code>fetchFilesFromRepo</code></span></a><span>; see the </span><a href="https://docs.github.com/en/rest/reference/git#get-a-tree"><span>API docs</span></a><span>) and sets </span><span><code>filename</code></span><span> to the first valid filename. Next it queries the list of commits for the file (with </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/api/index.ts#L97"><span><code>useCommits</code></span></a><span> and </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/api/index.ts#L97"><span><code>fetchCommits</code></span></a><span>; see the </span><a href="https://docs.github.com/en/rest/reference/git#get-a-commit"><span>API docs</span></a><span>) and sets </span><span><code>selectedSha</code></span><span> to the hash of the latest commit. React Query has a nice way to chain asynchronous queries: </span><span><code>useQuery</code></span><span> supports an </span><span><code>enabled</code></span><span> flag, which the </span><span><code>useCommits</code></span><span> query sets only when the </span><span><code>useGetFiles</code></span><span> query has completed successfully.</span></p><p><span><code>UseCommits</code></span><span> / </span><span><code>fetchCommits</code></span><span> refer to the type of the API response using </span><span><code>Endpoints</code></span><span> from </span><a href="https://github.com/octokit/types.ts#readme"><span><code>@octokit/types</code></span></a><span>:</span></p><pre><code><span>type</span> <span>listCommitsResponse</span> <span>=</span>
  Endpoints<span>[</span><span>&#34;GET /repos/{owner}/{repo}/commits&#34;</span><span>]</span><span>[</span><span>&#34;response&#34;</span><span>]</span><span>;</span></code></pre><p><span>This is very cool! Apparently the types are </span><a href="https://github.blog/2020-04-09-from-48k-lines-of-code-to-10-the-story-of-githubs-javascript-sdk/"><span>scraped from the API docs</span></a><span>. It looks like Octokit doesn&#39;t have full types for the search API (used in </span><span><code>OrgListing</code></span><span>), so those types are written out explicitly. (I wonder why Flat Viewer doesn&#39;t use the </span><a href="https://github.com/octokit/rest.js"><span>Octokit client</span></a><span>.)</span></p><p><span>Commits of data files created by </span><a href="https://github.com/marketplace/actions/flat-data"><span>Flat Action</span></a><span> contain the URL of the data source (see </span><a href="https://github.com/githubocto/flat-demo-bitcoin-price/commit/884305594b4416a66fef3404f9bb95c668f194d0"><span>example</span></a><span>); </span><span><code>RepoDetail</code></span><span> parses it out (with </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/lib/index.ts#L15"><span><code>parseFlatCommitMessage</code></span></a><span>) in order to display a link.</span></p><p><span>Finally, </span><span><code>RepoDetail</code></span><span> renders its controls (with components to show file and version pickers) and the data file itself (using </span><span><code>JSONDetail</code></span><span>). There&#39;s also a &#34;toast&#34; component for displaying error messages, and a &#34;disclosure&#34; component that makes the controls hideable on smaller displays; I didn&#39;t dig into the details.</span></p><h2 id="jsondetail"><span>JSONDetail</span></h2><p><span>The </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/components/json-detail-container.tsx#L23"><span><code>JSONDetail</code></span></a><span> component queries the contents of a data file (with </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/hooks/index.ts#L37"><span><code>useDataFile</code></span></a><span> and </span><a href="https://github.com/githubocto/flat-viewer/blob/ea66076452c8f6b62fac5785e55b6137657a5e11/src/api/index.ts#L142"><span><code>fetchDataFile</code></span></a><span>) and displays the contents using </span><a href="https://github.com/githubocto/flat-ui"><span><code>flat-ui</code></span></a><span>. It also displays a picker for keys within the file—I guess it handles JSON files with a top-level object containing multiple arrays? </span><span><code>FetchDataFile</code></span><span> parses the file as CSV, TSV, YAML, or JSON based on the file extension (using </span><a href="https://github.com/d3/d3-dsv"><span><code>d3-dsv</code></span></a><span> and </span><a href="https://eemeli.org/yaml/v1/#yaml"><span><code>yaml</code></span></a><span>), and has some special handling for </span><a href="https://geojson.org/"><span>GeoJSON</span></a><span> / </span><a href="https://github.com/topojson/topojson"><span>TopoJSON</span></a><span> files.</span></p><p><span><code>Flat-ui</code></span><span> has controls for filtering and sorting data, but it doesn&#39;t maintain its own control state; </span><span><code>JSONDetail</code></span><span> passes props for the control state and an </span><span><code>onChange</code></span><span> callback, and uses </span><span><code>use-query-params</code></span><span> to track the state in the URL:</span></p><pre><code><span>const</span> <span>[</span>query<span>,</span> setQuery<span>]</span> <span>=</span> <span>useQueryParams</span><span>(</span><span>{</span>
  tab<span>:</span> StringParam<span>,</span>
  stickyColumnName<span>:</span> StringParam<span>,</span>
  sort<span>:</span> StringParam<span>,</span>
  filters<span>:</span> StringParam<span>,</span>
<span>}</span><span>)</span><span>;</span></code></pre><p><span>You pass </span><a href="https://github.com/pbeshai/use-query-params/tree/master/packages/use-query-params#usequeryparams-1"><span><code>useQueryParams</code></span></a><span> an object of serializers (the keys are used as param names), and you can pass a partial object to the setter if you want to set only some fields. (There&#39;s a </span><a href="https://github.com/pbeshai/use-query-params/blob/master/packages/serialize-query-params/src/types.ts#L37"><span>nice use of type-level programming</span></a><span> to give </span><span><code>query</code></span><span> / </span><span><code>setQuery</code></span><span> the appropriate types based on the serializers.)</span></p><p><span>There is a lot of cool stuff going on in </span><span><code>flat-ui</code></span><span> and I would like to read that code some time.</span></p><h2 id="styling-with-tailwind"><span>Styling with Tailwind</span></h2><p><span>All these components are styled with </span><a href="https://tailwindcss.com/"><span>Tailwind CSS</span></a><span>, so there are lots of class names sprinkled all over the place. I found this very mysterious! Here&#39;s what the Tailwind </span><a href="https://tailwindcss.com/docs/utility-first"><span>docs</span></a><span> have to say about it:</span></p><blockquote><p><span>Now I know what you’re thinking, “this is an atrocity, what a horrible mess!” and you’re right, it’s kind of ugly. In fact it’s just about impossible to think this is a good idea the first time you see it [...]</span></p></blockquote><p><span>I really appreciate honest documentation!</span></p><p><span>As far as I understand the pitch: the traditional way to do CSS is to write &#34;semantic&#34; classes that describe the style for a particular component in the app, then use the class name whenever that component appears. The Tailwind way is to use &#34;utility&#34; classes that describe particular CSS attributes, and string together the ones you need when you need them. This might cost some duplication (similar components might use a similar set of utility classes), but saves the pain of writing and maintaining a hairy CSS file.</span></p><p><span>I&#39;ve used </span><a href="https://styled-components.com/"><span><code>styled-components</code></span></a><span>, which is a different way to avoid writing and maintaining a hairy CSS file, so this makes sense to me; but it&#39;s a whole other language to learn. It would be cool if you could hover a Tailwind class in VS Code and see what it actually means... </span><a href="https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss"><span>oh look</span></a><span>.</span></p><h2 id="thats-it"><span>That&#39;s it!</span></h2><p><span>Please </span><a href="https://jaked.org/blog/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p></div></div>
  </body>
</html>
