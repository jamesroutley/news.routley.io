<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ochagavia.nl/blog/the-birth-of-a-package-manager/">Original</a>
    <h1>The birth of a package manager</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>Since my time at the university, pursuing a Computer Science degree, I have always been fascinated
by programming languages and the tooling around them: compilers, IDEs, package managers, etc.
Eventually, that <a href="https://ochagavia.nl/blog/how-i-got-involved-in-the-rust-community/">got me involved</a> as a
hobbyist in the development of the Rust compiler and rust-analyzer, but I never got the chance to
work professionally on programming language tooling… until two months ago! In January, the nice
folks at <a href="https://prefix.dev">prefix.dev</a> asked me to help them develop the <a href="https://github.com/mamba-org/rattler">rattler package
manager</a>, and there is lots to tell about what we have
achieved since then, so buckle up!</p>
<h2 id="ehm-what-is-rattler">Ehm… what is rattler?</h2>
<p>Good question! Here is what the <a href="https://prefix.dev/blog/introducing_rattler_conda_from_rust">official
announcement</a> has to say:</p>
<blockquote>
<p>[Rattler is] an open-source Rust library for working with the conda ecosystem.</p>
</blockquote>
<p>If you are like me and have never heard of “the conda ecosystem” before, this description might
leave you with more questions than you already had. The conda rabbit hole is <em>deep</em>, but we can get
quite far with an oversimplification: the conda community maintains a repository of software
packages<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. Rattler is able to, given a set of dependencies, determine which exact versions need
to be installed, and then proceed to install them in a virtual environment. You can also use it as a
CLI, as shown below<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>, where we see rattler installing the <code>cowpy</code> package to a virtual
environment, including a suitable version of python that is actually able to run <code>cowpy</code> (note:
<code>cargo run --release</code> is running the rattler CLI):</p>

<h2 id="technical-challenges">Technical challenges</h2>
<p>Working on rattler, and probably on any package manager, brings quite a few interesting challenges
on one’s path. Let’s have a look at the most relevant two!</p>
<h4 id="dependency-resolution">Dependency resolution</h4>
<p>As a user of a package manager, you want to specify the names of the packages you are interested in,
and maybe some additional constraints, like which versions are allowed. For instance, if you want to
install <code>numpy</code> but are required to use Python 3.7, your package manager should take that into
account and tell you to use <code>numpy</code> version <code>1.21.5</code> (instead of version <code>1.24.2</code>, which is the
newest one at the time of this writing, but no longer supports Python 3.7).</p>
<p>In the conda ecosystem, every package (e.g. <code>numpy</code>) has multiple versions (e.g. <code>1.21.5</code>, <code>1.24.2</code>,
etc). But it doesn’t end there! Even for a particular version, there might be more than one build.
Python libraries such as PyTorch, for instance, provide different builds depending on which GPU you
have (e.g. does it support CUDA?). This and other factors make it complex to resolve dependencies.</p>
<p>Fortunately, the problem of dependency resolution has been studied for a while, and there are
production-grade open source solvers suited for the task. We are currently using <a href="https://github.com/baszalmstra/libsolv">a fork of
libsolv</a>, which relies on the technique of <a href="https://en.wikipedia.org/wiki/SAT_solver">SAT
solving</a>. It is not perfect (software never is), but gets
the job done.</p>
<p>One interesting avenue of future work is to try to replace libsolv by a solver written in Rust, such
as <a href="https://github.com/pubgrub-rs/pubgrub">PubGrub</a>. That way we could get rid of a bunch of unsafe
code we are using to interface with libsolv through Rust’s FFI.</p>
<h4 id="performance-tuning">Performance tuning</h4>
<p>Resolving and installing dependencies is a complex process that can take <em>minutes</em>, especially when
done for the first time. This is annoying, particularly in the context of CI pipelines, where fast
feedback is invaluable. Performance is one of the reasons why rattler is written in Rust. It should
be able to set up a working Python environment in a much shorter timeframe than traditional
Python-based tools such as <code>miniconda</code>!</p>
<p>Rust gives you pretty decent performance for free, but there is always room for more if you are
willing to put the effort! For instance, I built a prototype to <a href="https://ochagavia.nl/blog/crafting-container-images-without-dockerfiles/">generate docker images from conda
environments</a>, which is very convenient for some
scenarios<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>. Another example is <a href="https://github.com/mamba-org/rattler/pull/89">@baszalmstra’s
PR</a> to sparsely load the package index, inspired by
Cargo’s new <a href="https://blog.rust-lang.org/inside-rust/2023/01/30/cargo-sparse-protocol.html">sparse
protocol</a>, shaving off
<em>seconds</em> in the dependency resolution stage. And there are more performance improvements underway!</p>
<p>Speaking about performance improvements, I also got to build rattler-server, which resolves
dependencies upon request, taking around 300 <em>milliseconds</em> instead of the 10 to 20 <em>seconds</em> it
usually takes (even when the package index is cached locally). The performance boost is achieved
with a clever trick, suggested by <a href="https://github.com/wolfv">@wolfv</a>, which consists of preloading
the available dependencies in libsolv and caching the state of the solver in-memory<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>.</p>
<h2 id="more-on-rattler-server">More on rattler-server</h2>
<p>If you feel like playing with rattler-server yourself, go ahead and clone the
<a href="https://github.com/mamba-org/rattler-server">repo</a>! All it takes is to run <code>cargo run --release</code>.
If you are a Windows user, though, you will need to do this inside WSL, because we are using some
libc functions that are otherwise unavailable (just for clarity: rattler is fully cross-platform,
but rattler-server is not).</p>
<p>Once the server is running, you can try POSTing the following body to <code>localhost:3000</code>:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>    <span>&#34;platform&#34;</span>: <span>&#34;linux-64&#34;</span>,
</span></span><span><span>    <span>&#34;specs&#34;</span>: [<span>&#34;numpy&#34;</span>],
</span></span><span><span>    <span>&#34;virtual_packages&#34;</span>: [<span>&#34;__unix&#34;</span>],
</span></span><span><span>    <span>&#34;channels&#34;</span>: [<span>&#34;conda-forge&#34;</span>]
</span></span><span><span>}
</span></span></code></pre></div><p>Since this is the first request to the server, it will take between 10 and 15 seconds to download
and cache the package index from <code>conda-forge</code>. Future requests should complete within 300
<em>milliseconds</em>. You can see for yourself by POSTing a new request for a different set of
dependencies (e.g. installing the famous <code>ncurses</code> C library):</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>    <span>&#34;platform&#34;</span>: <span>&#34;linux-64&#34;</span>,
</span></span><span><span>    <span>&#34;specs&#34;</span>: [<span>&#34;ncurses&#34;</span>],
</span></span><span><span>    <span>&#34;virtual_packages&#34;</span>: [<span>&#34;__unix&#34;</span>],
</span></span><span><span>    <span>&#34;channels&#34;</span>: [<span>&#34;conda-forge&#34;</span>]
</span></span><span><span>}
</span></span></code></pre></div><p>The response is too long to include here in its entirety, so below you can see a summarized version of
it:</p>
<div><pre tabindex="0"><code data-lang="js"><span><span>{
</span></span><span><span>  <span>&#34;packages&#34;</span><span>:</span> [
</span></span><span><span>    <span>// Leading packages omitted for brevity...
</span></span></span><span><span><span></span>    {
</span></span><span><span>      <span>&#34;name&#34;</span><span>:</span> <span>&#34;ncurses&#34;</span>,
</span></span><span><span>      <span>&#34;version&#34;</span><span>:</span> <span>&#34;6.3&#34;</span>,
</span></span><span><span>      <span>&#34;build&#34;</span><span>:</span> <span>&#34;h27087fc_1&#34;</span>,
</span></span><span><span>      <span>&#34;build_number&#34;</span><span>:</span> <span>1</span>,
</span></span><span><span>      <span>&#34;subdir&#34;</span><span>:</span> <span>&#34;linux-64&#34;</span>,
</span></span><span><span>      <span>&#34;md5&#34;</span><span>:</span> <span>&#34;4acfc691e64342b9dae57cf2adc63238&#34;</span>,
</span></span><span><span>      <span>&#34;sha256&#34;</span><span>:</span> <span>&#34;b801e8cf4b2c9a30bce5616746c6c2a4e36427f045b46d9fc08a4ed40a9f7065&#34;</span>,
</span></span><span><span>      <span>&#34;size&#34;</span><span>:</span> <span>1025992</span>,
</span></span><span><span>      <span>&#34;depends&#34;</span><span>:</span> [
</span></span><span><span>        <span>&#34;libgcc-ng &gt;=10.3.0&#34;</span>
</span></span><span><span>      ],
</span></span><span><span>      <span>&#34;constrains&#34;</span><span>:</span> [],
</span></span><span><span>      <span>&#34;license&#34;</span><span>:</span> <span>&#34;X11 AND BSD-3-Clause&#34;</span>,
</span></span><span><span>      <span>&#34;timestamp&#34;</span><span>:</span> <span>1649338526116</span>,
</span></span><span><span>      <span>&#34;fn&#34;</span><span>:</span> <span>&#34;ncurses-6.3-h27087fc_1.tar.bz2&#34;</span>,
</span></span><span><span>      <span>&#34;url&#34;</span><span>:</span> <span>&#34;https://conda.anaconda.org/conda-forge/linux-64/ncurses-6.3-h27087fc_1.tar.bz2&#34;</span>,
</span></span><span><span>      <span>&#34;channel&#34;</span><span>:</span> <span>&#34;https://conda.anaconda.org/conda-forge/&#34;</span>
</span></span><span><span>    }
</span></span><span><span>  ]
</span></span><span><span>}
</span></span></code></pre></div><p>The response comprises a list of packages that satisfy the dependencies you specified in the
request. While not visible in the example above, because it is summarized, it is interesting to note
that the packages are sorted topologically. With this information, you can write custom tooling to
initialize a virtual environment by downloading and installing the packages in order. This is what
<a href="https://outerbounds.com/">Outerbounds</a> is doing, for instance, to setup their machine learning
infrastructure (props to them, who generously sponsored the development of rattler-server!)</p>
<h2 id="closing-thoughts">Closing thoughts</h2>
<p>Participating in the birth of rattler was an exciting experience! There is obviously still a lot to
do, so if you are looking for an open source project to contribute to, this might be your chance.
You might, for instance, want to fuzz the <code>rattler_libsolv</code> crate, which uses plenty of unsafe code
for FFI (will you earn a place in the <a href="https://github.com/rust-fuzz/trophy-case">trophy case</a>?).
There is also a <a href="https://github.com/mamba-org/rattler/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">list of
issues</a>
marked as “good first issue”, if you’d rather contribute with code. Or you could build your own
tooling on top of rattler and tell the guys at prefix about it (they have a
<a href="https://discord.gg/kKV8ZxyzY4">Discord</a> server).</p>
<p>As to myself, this week I started working on my next engagement, sponsored by
<a href="https://www.stormshield.com/">Stormshield</a> to enhance <a href="https://github.com/quinn-rs/quinn/">Quinn</a>
(the community-driven QUIC implementation in Rust). I’ll be <a href="https://github.com/quinn-rs/quinn/pull/804">resurrecting this
PR</a> as a first step, and if everything goes well will
stay around for a few months to improve the library some more. I’ll make sure to write about it when
there is more to tell!</p>
<p>In the meantime, if you have any comments, suggestions, ideas, etc. you want to share, feel free to
contact me (details are in the <a href="https://ochagavia.nl/hire_me/">Hire me</a> page). You can also
<a href="https://news.ycombinator.com/item?id=35182791">discuss</a> on HN.</p>

<p>Less sexy than the above, but not less important, was figuring out how to properly test everything.
Since my first approach to Rust, back in 2014, the Rust ecosystem has come a long way, and we
currently have a bunch of very useful crates to aid with testing. Here are a few that proved
especially usfeul:</p>
<ul>
<li><a href="https://insta.rs/">insta</a>: makes it a breeze to add snapshot tests (e.g. tests that assert values
against a reference value).</li>
<li><a href="https://crates.io/crates/rstest">rstest</a>: provides handy macros to write tests more easily. I
found the combination of <code>#[rstest]</code> and <code>#[case]</code> especially useful to create parameterized
tests.</li>
<li><a href="https://docs.rs/testcontainers/latest/testcontainers/">testcontainers</a>: facilitates integration
testing by spinning up Docker containers and removing them afterwards.</li>
<li><a href="https://crates.io/crates/mockito">mockito</a>: generates HTTP mocks, which you can use to test code
that makes requests to HTTP endpoints.</li>
<li><a href="https://crates.io/crates/mock_instant">mock_instant</a>: allows you to test code that uses
<code>Instant</code>, without having to resort to sleeping or other dirty tricks.</li>
</ul>


</div></div>
  </body>
</html>
