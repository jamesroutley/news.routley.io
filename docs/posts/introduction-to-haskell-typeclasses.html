<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://serokell.io/blog/haskell-typeclasses">Original</a>
    <h1>Introduction to Haskell Typeclasses</h1>
    
    <div id="readability-page-1" class="page"><div><p>Imagine you‚Äôve been tasked to write a function for increasing a value by one in Haskell.</p>
<p>What‚Äôs easier? Finally, a place where one can use previous JavaScript experience. üòÖ</p>
<p>You find the type of bounded integers ‚Äì <code>Int</code> ‚Äì and get to work.</p>
<pre><code><span>plusOne</span> :: <span>Int</span> -&gt;  <span>Int</span>
<span>plusOne</span> a = a + <span>1</span>
</code></pre>
<p>But it turns out that the team lead also wants a plus function that works with floating-point numbers.</p>
<pre><code><span>plusOneFloat</span> :: <span>Float</span> -&gt; <span>Float</span>
<span>plusOneFloat</span> a = a + <span>1</span>
</code></pre>
<p>Both of these requests could definitely be covered by a more generic function.</p>
<pre><code><span>plusOnePoly</span> :: a -&gt; a
<span>plusOnePoly</span> a = a + <span>1</span>
</code></pre>
<p>Unfortunately, the code above doesn‚Äôt compile.</p>
<pre><code>No instance for (Num a) arising from a use of &#39;+&#39;
</code></pre>
<p>To sum two members of the same type in Haskell via <code>+</code>, their type needs to have an instance of the <code>Num</code> typeclass.</p>
<p>But what‚Äôs a typeclass, and what‚Äôs an instance of a typeclass? Read further to find the answers.</p>
<p>I‚Äôll cover:</p>
<ul>
<li>what typeclasses are;</li>
<li>how to use them;</li>
<li>how to create instances of typeclasses;</li>
<li>basic typeclasses like <code>Eq</code>, <code>Ord</code>, <code>Num</code>, <code>Show</code>, and <code>Read</code>.</li>
</ul>
<p>Recommended previous knowledge: <a href="https://serokell.io/blog/algebraic-data-types-in-haskell">algebraic data types</a>.</p>
<h2 id="what%E2%80%99s-a-typeclass-in-haskell%3F"><p>What‚Äôs a typeclass in Haskell?</p></h2>
<p>A typeclass defines a set of methods that is shared across multiple types.</p>
<p>For a type to belong to a typeclass, it needs to implement the methods of that typeclass. These implementations are ad-hoc: methods can have different implementations for different types.</p>
<p>As an example, let‚Äôs look at the <code>Num</code> typeclass in Haskell.</p>
<pre><code><span><span>class</span> <span>Num</span> a <span>where</span></span>
  (+) :: a -&gt; a -&gt; a
  (-) :: a -&gt; a -&gt; a
  (*) :: a -&gt; a -&gt; a
  negate :: a -&gt; a
  abs :: a -&gt; a
  signum :: a -&gt; a
  fromInteger :: <span>Integer</span> -&gt; a
</code></pre>
<p>For a type to belong to the <code>Num</code> typeclass, it needs to implement its methods: <code>+</code>, <code>-</code>, <code>*</code>, and so forth.</p>
<p>If you want to use one of its methods, such as  <code>+</code>, you can only use it on types that have an instance of <code>Num</code>.</p>
<p>And a function that uses <code>+</code> needs to limit itself by only taking members of the <code>Num</code> typeclass. Otherwise, it won‚Äôt compile.</p>
<p>This is done by putting a type constraint (<code>Num a =&gt;</code>) in the type signature.</p>
<pre><code><span>plusOnePoly</span> :: <span>Num</span> a =&gt; a -&gt; a
<span>plusOnePoly</span> a = a + <span>1</span>
</code></pre>
<p>This stands in contrast to polymorphism across all types. For example, <code>++</code> will work with two lists of elements of the same type, no matter what that type is.</p>
<pre><code>Prelude&gt; :t (++)
(++) :: [a] -&gt; [a] -&gt; [a]
</code></pre>
<p>Typeclasses are similar to Java interfaces, Rust traits, and Elixir protocols, but there are also <a href="https://diogocastro.com/blog/2018/06/17/typeclasses-in-perspective/">noticeable differences</a>.</p>
<h2 id="what%E2%80%99s-an-instance-of-a-typeclass%3F"><p>What‚Äôs an instance of a typeclass?</p></h2>
<p>A type has an instance of a typeclass if it implements the methods of that typeclass.</p>
<p>We can define these instances by hand, but Haskell can also do a lot of work for us by deriving implementations on its own.</p>
<p>I‚Äôll cover both of these options in the section below.</p>
<h2 id="how-to-define-typeclass-instances"><p>How to define typeclass instances</p></h2>
<p>Let‚Äôs imagine we have a data type for Pokemon that includes their name, Pokedex number, type, and abilities.</p>
<pre><code><span><span>data</span> <span>Pokemon</span> = <span>Pokemon</span></span>
  { pokedexId   :: <span>Int</span>
  , name        :: <span>String</span>
  , pokemonType :: [<span>String</span>]
  , abilities   :: [<span>String</span>]
  }
</code></pre>
<p>We have two Pokemon ‚Äì Slowking and Jigglypuff ‚Äì which are arguably the best offerings of the Pokemon universe.</p>
<pre><code>*Main&gt; slowking = Pokemon 199 &#34;Slowking&#34; [&#34;Water&#34;, &#34;Psychic&#34;] [&#34;Oblivious&#34;, &#34;Own Tempo&#34;]
*Main&gt; jigglypuff = Pokemon 39 &#34;Jigglypuff&#34; [&#34;Normal&#34;, &#34;Fairy&#34;] [&#34;Cute Charm&#34;, &#34;Competitive&#34;]
</code></pre>
<p>For some reason, we would like to know whether their values are equal.</p>
<p>Right now, GHCi cannot answer this.</p>
<pre><code>*Main&gt; slowking == jigglypuff

&lt;interactive&gt;:19:1: error:
    ‚Ä¢ No instance for (Eq Pokemon) arising from a use of &#39;==&#39;
    ‚Ä¢ In the expression: slowking == jigglypuff
      In an equation for &#39;it&#39;: it = slowking == jigglypuff
</code></pre>
<p>That‚Äôs because <code>Pokemon</code> doesn‚Äôt have an instance of the <code>Eq</code> typeclass.</p>
<p>There are two ways of making <code>Pokemon</code> a member of the <code>Eq</code> typeclass: deriving an instance or manually creating it. I‚Äôll cover them both.</p>
<h3 id="deriving-eq"><p>Deriving <code>Eq</code></p></h3>
<p>When creating a type, you can add the <code>deriving</code> keyword and a tuple of typeclasses you want the instance of, such as <code>(Show, Eq)</code>. The compiler will then try to figure out the instances for you.</p>
<p>This can save a lot of time that would be spent in typing out obvious instances.</p>
<p>In the case of <code>Eq</code>, we can usually derive the instance.</p>
<pre><code><span><span>data</span> <span>Pokemon</span> = <span>Pokemon</span></span>
  { pokedexId   :: <span>Int</span>
  , name        :: <span>String</span>
  , pokemonType :: [<span>String</span>]
  , abilities   :: [<span>String</span>]
  } <span>deriving</span> (<span>Eq</span>)
</code></pre>
<p>The derived instance will compare two Pokemon for equality by comparing each individual field. If all the fields are equal, the records should be equal as well.</p>
<p>Now we can answer our question.</p>
<pre><code>*Main&gt; slowking == jigglypuff
False
</code></pre>
<h3 id="defining-eq"><p>Defining <code>Eq</code></p></h3>
<p>The Pokedex number should uniquely identify a Pokemon (if we use the National Pokedex). So, technically, we don‚Äôt need to compare all the fields of two Pokemons to know that they are the same Pokemon. Comparing just the index will be enough.</p>
<p>To do that, we can create a custom instance of <code>Eq</code>.</p>
<p>First, we need to remove the <code>deriving (Eq)</code> clause.</p>
<pre><code><span><span>data</span> <span>Pokemon</span> = <span>Pokemon</span></span>
  { pokedexId   :: <span>Int</span>
  , name        :: <span>String</span>
  , pokemonType :: [<span>String</span>]
  , abilities   :: [<span>String</span>]
  }
</code></pre>
<p>Then we can define an <code>Eq</code> instance for the <code>Pokemon</code> typeclass.</p>
<pre><code>
<span><span>instance</span> <span>Eq</span> <span>Pokemon</span> <span>where</span></span>
  
  pokemon1 == pokemon2 = pokedexId pokemon1 == pokedexId pokemon2




</code></pre>
<p>Even though <code>Eq</code> has two methods: <code>==</code> and <code>/=</code>, we only need to define one of them to satisfy the minimal requirements of the instance.</p>
<h4 id="minimal-requirements-to-define-an-instance"><p>Minimal requirements to define an instance</p></h4>
<p>It usually isn‚Äôt necessary to define all the methods of the typeclass.</p>
<p>For example, <code>Eq</code> has two methods: <code>==</code> and <code>/=</code>. If you define <code>==</code>, it‚Äôs reasonable to assume that <code>/=</code> will be <code>not ==</code>.</p>
<p>In fact, that‚Äôs in the definition of the typeclass.</p>
<pre><code>class Eq a <span>where</span>
    (==) :: <span><span>a</span> -&gt;</span> <span><span>a</span> -&gt;</span> Bool
    (/=) :: <span><span>a</span> -&gt;</span> <span><span>a</span> -&gt;</span> Bool
    x == y = <span>not</span> (x /= y)
    x /= y = <span>not</span> (x == y)
</code></pre>
<p>For this reason, the minimal definition for <code>Eq</code> is to define one of these methods.</p>
<p>To see the minimal definition of a typeclass, you can use <code>:info</code>.</p>
<pre><code>*Main&gt; :info Eq
...
  {-# MINIMAL (==) | (/=) #-}
...
</code></pre>
<p>If you provide the minimal implementation of a typeclass, the compiler can figure out the other methods.</p>
<p>This is because they can be:</p>
<ul>
<li>defined in terms of methods you‚Äôve already provided;</li>
<li>defined in terms of methods that a superclass of the typeclass has (I‚Äôll cover superclasses later);</li>
<li>provided by default.</li>
</ul>
<p>You might want to provide your own implementations for performance reasons, though.</p>
<h3 id="ordering-pokemon"><p>Ordering Pokemon</p></h3>
<p>Let‚Äôs imagine that we want to order and sort our Pokemon.</p>
<p>To compare two values of a type, the type needs to have an instance of the <code>Ord</code> typeclass.</p>
<pre><code><span><span>class</span> <span>Eq</span> a =&gt; <span>Ord</span> a <span>where</span></span>
  compare :: a -&gt; a -&gt; <span>Ordering</span>
  (&lt;) :: a -&gt; a -&gt; <span>Bool</span>
  (&lt;=) :: a -&gt; a -&gt; <span>Bool</span>
  (&gt;) :: a -&gt; a -&gt; <span>Bool</span>
  (&gt;=) :: a -&gt; a -&gt; <span>Bool</span>
  max :: a -&gt; a -&gt; a
  min :: a -&gt; a -&gt; a
</code></pre>
<p><code>Ord</code> and <code>Eq</code> go hand in hand in Haskell since <code>Eq</code> is a superclass of <code>Ord</code>.</p>
<pre><code>class Eq a =&gt; Ord a where           
</code></pre>
<p>Let‚Äôs quickly go over superclasses so that we understand what that means.</p>
<h4 id="superclasses"><p>Superclasses</p></h4>
<p>In Haskell, typeclasses have a hierarchy similar to that of classes in OOP.</p>
<p>If a typeclass <code>x</code> is a superclass of another class <code>y</code>, you need to implement  <code>x</code> before you implement <code>y</code>.</p>
<p>In our case, we needed to implement <code>Eq</code> (which we did) before we implement <code>Ord.</code></p>
<p>Furthermore, typeclasses often depend on their superclasses for method definitions. So you need to be careful that you ‚Äúmean the same thing‚Äù when you define both the typeclass and its superclass.</p>
<p>For example, the <code>Ord</code> typeclass depends on the <code>Eq</code> typeclass for defaults, so it is a rule of thumb to have them be compliant with each other.</p>
<p>This means that our <code>Ord</code> instance should order things in a way that <code>a &lt;= b</code> and <code>a &gt;= b</code> implies <code>a == b</code>. Yeah, Haskell can be like that sometimes. üòÇ</p>
<hr/>
<p>Since we used the Pokedex number to define equality, we also will use it to define order.</p>
<p>In the case of <code>Ord</code>, the minimal definition is <code>&lt;=</code> or <code>compare</code>. We‚Äôll define the first of these.</p>
<p>Here‚Äôs how the instance definition looks:</p>
<pre><code><span><span>instance</span> <span>Ord</span> <span>Pokemon</span> <span>where</span></span>
  pokemon1 &lt;= pokemon2 = pokedexId pokemon1 &lt;= pokedexId pokemon2
</code></pre>
<p>At this point, it‚Äôs easy to see why our <code>Ord</code> instance needs to be compliant with our <code>Eq</code> instance. Since we provided only the minimal implementation, Haskell will use the method of <code>Eq</code> ‚Äì <code>==</code> ‚Äì and our definition of <code>&lt;=</code> to create implementations for <code>&lt;</code> and <code>&gt;</code>.</p>
<p>Now we can compare Pokemon.</p>
<pre><code>*Main&gt; jigglypuff &lt; slowking
True
*Main&gt; jigglypuff &gt; slowking
False
</code></pre>
<p>We can also create a third Pokemon and sort a list of Pokemon using the <code>sort</code> function.</p>
<p>To see the sorted list in GHCi, we need to derive the <code>Show</code> typeclass for our data type.</p>
<pre><code><span><span>data</span> <span>Pokemon</span> = <span>Pokemon</span></span>
  { pokedexId   :: <span>Int</span>
  , name        :: <span>String</span>
  , pokemonType :: [<span>String</span>]
  , abilities   :: [<span>String</span>]
  } <span>deriving</span> (<span>Show</span>)
</code></pre>
<p>And now we can see the results:</p>
<pre><code>*Main&gt; chansey = Pokemon 113 &#34;Chansey&#34; [&#34;Normal&#34;] [&#34;Natural Cure&#34;, &#34;Serene Grace&#34;]
*Main&gt; import Data.List

*Main Data.List&gt; sort([chansey, jigglypuff, slowking])
[Pokemon {name = pokedexId = 39, &#34;Jigglypuff&#34;, pokemonType = [&#34;Normal&#34;,&#34;Fairy&#34;], abilities = [&#34;Cute Charm&#34;,&#34;Competitive&#34;]},Pokemon {pokedexId = 113, name = &#34;Chansey&#34;, pokemonType = [&#34;Normal&#34;], abilities = [&#34;Natural Cure&#34;,&#34;Serene Grace&#34;]},Pokemon {pokedexId = 199, name = &#34;Slowking&#34;, pokemonType = [&#34;Water&#34;,&#34;Psychic&#34;], abilities = [&#34;Oblivious&#34;,&#34;Own Tempo&#34;]}]
</code></pre>
<h2 id="basic-haskell-typeclasses"><p>Basic Haskell typeclasses</p></h2>
<p>Let‚Äôs look at the basic Haskell typeclasses that you have encountered while reading this article.</p>
<h3 id="eq"><p><code>Eq</code></p></h3>
<p><code>Eq</code> provides an interface for testing for equality. It has two methods: <code>==</code> and <code>/=</code> for equality and inequality, respectively.</p>
<pre><code><span><span>class</span> <span>Eq</span> a <span>where</span></span>
  (==) :: a -&gt; a -&gt; <span>Bool</span>
  (/=) :: a -&gt; a -&gt; <span>Bool</span>
</code></pre>
<p>The minimal definition for <code>Eq</code> is to either provide <code>==</code> or <code>/=</code>.</p>
<p>You can generally derive this typeclass while defining your data types.</p>
<h3 id="ord"><p><code>Ord</code></p></h3>
<p><code>Ord</code> is a subclass of <code>Eq</code> that is used for data types that have a total ordering (every value can be compared with another).</p>
<pre><code><span><span>class</span> <span>Eq</span> a =&gt; <span>Ord</span> a <span>where</span></span>
  compare :: a -&gt; a -&gt; <span>Ordering</span>
  (&lt;) :: a -&gt; a -&gt; <span>Bool</span>
  (&lt;=) :: a -&gt; a -&gt; <span>Bool</span>
  (&gt;) :: a -&gt; a -&gt; <span>Bool</span>
  (&gt;=) :: a -&gt; a -&gt; <span>Bool</span>
  max :: a -&gt; a -&gt; a
  min :: a -&gt; a -&gt; a
</code></pre>
<p>It offers the following functions:</p>
<ul>
<li><code>compare</code>, which compares two values and gives an <code>Ordering</code>, which is one of three values: <code>LT</code>, <code>EQ</code>, or <code>GT</code>.</li>
<li>Operators for comparison: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> that take two values and return a <code>Bool</code>.</li>
<li><code>max</code> and <code>min</code>, which return the largest and smallest of two values, respectively.</li>
</ul>
<p>The minimal definition for the <code>Ord</code> typeclass is either <code>compare</code> or <code>&lt;=</code>.</p>
<h3 id="show-and-read"><p><code>Show</code> and <code>Read</code></p></h3>
<p><code>Show</code> is a typeclass for conversion to strings. <code>Read</code> is its opposite: it‚Äôs the typeclass for conversion from strings to values. The implementations are supposed to follow the law of <code>read . show = id</code>.</p>
<p>For beginners, the <code>show</code> method will be important for debugging purposes. If you are working with GHCi and need to print out your custom types in the terminal, you need to derive <code>Show</code>. Otherwise, you won‚Äôt be able to print them.</p>
<p>One important thing that some beginners get confused about: these typeclasses are not supposed to be used for pretty-printing and parsing complex values. There are better tools for that.</p>
<h3 id="num"><p><code>Num</code></p></h3>
<p><code>Num</code> is the typeclass for numbers.</p>
<pre><code><span><span>class</span> <span>Num</span> a <span>where</span></span>
  (+) :: a -&gt; a -&gt; a
  (-) :: a -&gt; a -&gt; a
  (*) :: a -&gt; a -&gt; a
  negate :: a -&gt; a
  abs :: a -&gt; a
  signum :: a -&gt; a
  fromInteger :: <span>Integer</span> -&gt; a
</code></pre>
<p>The minimal definition for <code>Num</code> includes: <code>(+)</code>, <code>(*)</code>, <code>abs</code>, <code>signum</code>, <code>fromInteger</code>, and <code>negate</code> or <code>(-)</code>.</p>
<p>It offers all the arithmetic operations that you would expect to need when working with integers.</p>
<h2 id="conclusion"><p>Conclusion</p></h2>
<p>This introduction to typeclasses in Haskell covered what typeclasses are and how to create your own instances by deriving or defining them.</p>
<p>For further reading, we have a series called <a href="https://serokell.io/blog/what&#39;s-that-typeclass">What‚Äôs That Typeclass</a> that covers more advanced typeclasses. So far, we have posts about  <code>Monoid</code> and <code>Foldable</code>, but more are to come.</p>
<p>If you want to get informed about new beginner-friendly Haskell articles, follow us on <a href="https://twitter.com/serokell">Twitter</a> or subscribe to our mailing list via the form below.</p></div></div>
  </body>
</html>
